{"sha": "3024c1434a667425d30e4b0785857381323712aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwMjRjMTQzNGE2Njc0MjVkMzBlNGIwNzg1ODU3MzgxMzIzNzEyYWE=", "commit": {"author": {"name": "Matt Brubeck", "email": "mbrubeck@limpet.net", "date": "2017-12-09T01:32:04Z"}, "committer": {"name": "Matt Brubeck", "email": "mbrubeck@limpet.net", "date": "2017-12-09T22:18:33Z"}, "message": "Use Try syntax for Option in place of macros or match", "tree": {"sha": "97e25cbc974f2a552c2314a2da2e216c358fb141", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97e25cbc974f2a552c2314a2da2e216c358fb141"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3024c1434a667425d30e4b0785857381323712aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3024c1434a667425d30e4b0785857381323712aa", "html_url": "https://github.com/rust-lang/rust/commit/3024c1434a667425d30e4b0785857381323712aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3024c1434a667425d30e4b0785857381323712aa/comments", "author": {"login": "mbrubeck", "id": 5920, "node_id": "MDQ6VXNlcjU5MjA=", "avatar_url": "https://avatars.githubusercontent.com/u/5920?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbrubeck", "html_url": "https://github.com/mbrubeck", "followers_url": "https://api.github.com/users/mbrubeck/followers", "following_url": "https://api.github.com/users/mbrubeck/following{/other_user}", "gists_url": "https://api.github.com/users/mbrubeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbrubeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbrubeck/subscriptions", "organizations_url": "https://api.github.com/users/mbrubeck/orgs", "repos_url": "https://api.github.com/users/mbrubeck/repos", "events_url": "https://api.github.com/users/mbrubeck/events{/privacy}", "received_events_url": "https://api.github.com/users/mbrubeck/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mbrubeck", "id": 5920, "node_id": "MDQ6VXNlcjU5MjA=", "avatar_url": "https://avatars.githubusercontent.com/u/5920?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbrubeck", "html_url": "https://github.com/mbrubeck", "followers_url": "https://api.github.com/users/mbrubeck/followers", "following_url": "https://api.github.com/users/mbrubeck/following{/other_user}", "gists_url": "https://api.github.com/users/mbrubeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbrubeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbrubeck/subscriptions", "organizations_url": "https://api.github.com/users/mbrubeck/orgs", "repos_url": "https://api.github.com/users/mbrubeck/repos", "events_url": "https://api.github.com/users/mbrubeck/events{/privacy}", "received_events_url": "https://api.github.com/users/mbrubeck/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7b6d8263b0c106503d102ab8148769ac9f7d086", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7b6d8263b0c106503d102ab8148769ac9f7d086", "html_url": "https://github.com/rust-lang/rust/commit/c7b6d8263b0c106503d102ab8148769ac9f7d086"}], "stats": {"total": 322, "additions": 92, "deletions": 230}, "files": [{"sha": "c2a8f5f8ff957e5004b9b2cf95ea0cb4d6dfe448", "filename": "src/liballoc/allocator.rs", "status": "modified", "additions": 9, "deletions": 37, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Fliballoc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Fliballoc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fallocator.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -217,14 +217,8 @@ impl Layout {\n     /// On arithmetic overflow, returns `None`.\n     #[inline]\n     pub fn repeat(&self, n: usize) -> Option<(Self, usize)> {\n-        let padded_size = match self.size.checked_add(self.padding_needed_for(self.align)) {\n-            None => return None,\n-            Some(padded_size) => padded_size,\n-        };\n-        let alloc_size = match padded_size.checked_mul(n) {\n-            None => return None,\n-            Some(alloc_size) => alloc_size,\n-        };\n+        let padded_size = self.size.checked_add(self.padding_needed_for(self.align))?;\n+        let alloc_size = padded_size.checked_mul(n)?;\n \n         // We can assume that `self.align` is a power-of-two that does\n         // not exceed 2<sup>31</sup>. Furthermore, `alloc_size` has already been\n@@ -246,26 +240,14 @@ impl Layout {\n     /// On arithmetic overflow, returns `None`.\n     pub fn extend(&self, next: Self) -> Option<(Self, usize)> {\n         let new_align = cmp::max(self.align, next.align);\n-        let realigned = match Layout::from_size_align(self.size, new_align) {\n-            None => return None,\n-            Some(l) => l,\n-        };\n+        let realigned = Layout::from_size_align(self.size, new_align)?;\n \n         let pad = realigned.padding_needed_for(next.align);\n \n-        let offset = match self.size.checked_add(pad) {\n-            None => return None,\n-            Some(offset) => offset,\n-        };\n-        let new_size = match offset.checked_add(next.size) {\n-            None => return None,\n-            Some(new_size) => new_size,\n-        };\n+        let offset = self.size.checked_add(pad)?;\n+        let new_size = offset.checked_add(next.size)?;\n \n-        let layout = match Layout::from_size_align(new_size, new_align) {\n-            None => return None,\n-            Some(l) => l,\n-        };\n+        let layout = Layout::from_size_align(new_size, new_align)?;\n         Some((layout, offset))\n     }\n \n@@ -282,11 +264,7 @@ impl Layout {\n     ///\n     /// On arithmetic overflow, returns `None`.\n     pub fn repeat_packed(&self, n: usize) -> Option<Self> {\n-        let size = match self.size().checked_mul(n) {\n-            None => return None,\n-            Some(scaled) => scaled,\n-        };\n-\n+        let size = self.size().checked_mul(n)?;\n         Layout::from_size_align(size, self.align)\n     }\n \n@@ -306,14 +284,8 @@ impl Layout {\n     ///\n     /// On arithmetic overflow, returns `None`.\n     pub fn extend_packed(&self, next: Self) -> Option<(Self, usize)> {\n-        let new_size = match self.size().checked_add(next.size()) {\n-            None => return None,\n-            Some(new_size) => new_size,\n-        };\n-        let layout = match Layout::from_size_align(new_size, self.align) {\n-            None => return None,\n-            Some(l) => l,\n-        };\n+        let new_size = self.size().checked_add(next.size())?;\n+        let layout = Layout::from_size_align(new_size, self.align)?;\n         Some((layout, self.size()))\n     }\n "}, {"sha": "580d2dbb623e6f64e581c3d08305f013c08e5321", "filename": "src/liballoc/btree/set.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Fliballoc%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Fliballoc%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fset.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -1067,21 +1067,15 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n \n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n-            let o_cmp = match (self.a.peek(), self.b.peek()) {\n-                (None, _) => None,\n-                (_, None) => None,\n-                (Some(a1), Some(b1)) => Some(a1.cmp(b1)),\n-            };\n-            match o_cmp {\n-                None => return None,\n-                Some(Less) => {\n+            match Ord::cmp(self.a.peek()?, self.b.peek()?) {\n+                Less => {\n                     self.a.next();\n                 }\n-                Some(Equal) => {\n+                Equal => {\n                     self.b.next();\n                     return self.a.next();\n                 }\n-                Some(Greater) => {\n+                Greater => {\n                     self.b.next();\n                 }\n             }"}, {"sha": "ca493ab27e3ad67003d5655416eee41da0711aa6", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -1044,10 +1044,7 @@ impl String {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<char> {\n-        let ch = match self.chars().rev().next() {\n-            Some(ch) => ch,\n-            None => return None,\n-        };\n+        let ch = self.chars().rev().next()?;\n         let newlen = self.len() - ch.len_utf8();\n         unsafe {\n             self.vec.set_len(newlen);"}, {"sha": "9c7c865771606607d03a2ecc5f6bb5d6e1b17c65", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -1423,10 +1423,7 @@ impl<T: PartialEq> Vec<T> {\n     /// ```\n     #[unstable(feature = \"vec_remove_item\", reason = \"recently added\", issue = \"40062\")]\n     pub fn remove_item(&mut self, item: &T) -> Option<T> {\n-        let pos = match self.iter().position(|x| *x == *item) {\n-            Some(x) => x,\n-            None => return None,\n-        };\n+        let pos = self.iter().position(|x| *x == *item)?;\n         Some(self.remove(pos))\n     }\n }"}, {"sha": "1ca995cae6d971675494ff005e1040df7ed24588", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -494,11 +494,10 @@ fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n #[inline]\n pub fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32> {\n     // Decode UTF-8\n-    let x = match bytes.next() {\n-        None => return None,\n-        Some(&next_byte) if next_byte < 128 => return Some(next_byte as u32),\n-        Some(&next_byte) => next_byte,\n-    };\n+    let x = *bytes.next()?;\n+    if x < 128 {\n+        return Some(x as u32)\n+    }\n \n     // Multibyte case follows\n     // Decode from a byte combination out of: [[[x y] z] w]"}, {"sha": "8969528dd1949d4e903f5ad7a656e9e305b0cfb3", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -978,9 +978,8 @@ impl<'a, 'hir> NodesMatchingSuffix<'a, 'hir> {\n         // chain, then returns `None`.\n         fn find_first_mod_parent<'a>(map: &'a Map, mut id: NodeId) -> Option<(NodeId, Name)> {\n             loop {\n-                match map.find(id) {\n-                    None => return None,\n-                    Some(NodeItem(item)) if item_is_mod(&item) =>\n+                match map.find(id)? {\n+                    NodeItem(item) if item_is_mod(&item) =>\n                         return Some((id, item.name)),\n                     _ => {}\n                 }"}, {"sha": "6d198601447b089ca342e79cdaee250caa7af886", "filename": "src/librustc/infer/error_reporting/util.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -91,10 +91,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         .iter()\n                         .enumerate()\n                         .filter_map(|(index, arg)| {\n-                            let ty = match tables.borrow().node_id_to_type_opt(arg.hir_id) {\n-                                Some(v) => v,\n-                                None => return None, // sometimes the tables are not yet populated\n-                            };\n+                            // May return None; sometimes the tables are not yet populated.\n+                            let ty = tables.borrow().node_id_to_type_opt(arg.hir_id)?;\n                             let mut found_anon_region = false;\n                             let new_arg_ty = self.tcx\n                                 .fold_regions(&ty, &mut false, |r, _| if *r == *anon_region {"}, {"sha": "2e9e45c9ffe16b9b436be9210dcb25f2f7ff5656", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -439,12 +439,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n         });\n \n-        let dtor_did = match dtor_did {\n-            Some(dtor) => dtor,\n-            None => return None,\n-        };\n-\n-        Some(ty::Destructor { did: dtor_did })\n+        Some(ty::Destructor { did: dtor_did? })\n     }\n \n     /// Return the set of types that are required to be alive in"}, {"sha": "76d3494dbf08209c87726743bdd6cb2207eae3e3", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -215,24 +215,18 @@ pub fn record_time<T, F>(accu: &Cell<Duration>, f: F) -> T where\n     rv\n }\n \n-// Like std::macros::try!, but for Option<>.\n-#[cfg(unix)]\n-macro_rules! option_try(\n-    ($e:expr) => (match $e { Some(e) => e, None => return None })\n-);\n-\n // Memory reporting\n #[cfg(unix)]\n fn get_resident() -> Option<usize> {\n     use std::fs::File;\n     use std::io::Read;\n \n     let field = 1;\n-    let mut f = option_try!(File::open(\"/proc/self/statm\").ok());\n+    let mut f = File::open(\"/proc/self/statm\").ok()?;\n     let mut contents = String::new();\n-    option_try!(f.read_to_string(&mut contents).ok());\n-    let s = option_try!(contents.split_whitespace().nth(field));\n-    let npages = option_try!(s.parse::<usize>().ok());\n+    f.read_to_string(&mut contents).ok()?;\n+    let s = contents.split_whitespace().nth(field)?;\n+    let npages = s.parse::<usize>().ok()?;\n     Some(npages * 4096)\n }\n "}, {"sha": "5d7139507b33f9427e0eb4048893596e0f98818a", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -291,10 +291,8 @@ impl<'a, T: Idx> Iterator for Iter<'a, T> {\n                 }\n             }\n \n-            match self.iter.next() {\n-                Some((i, word)) => self.cur = Some((*word, word_bits * i)),\n-                None => return None,\n-            }\n+            let (i, word) = self.iter.next()?;\n+            self.cur = Some((*word, word_bits * i));\n         }\n     }\n }"}, {"sha": "264c15bcd0b76ee8f93431665a09be3f89db86c5", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -385,10 +385,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn load(&mut self, locate_ctxt: &mut locator::Context) -> Option<LoadResult> {\n-        let library = match locate_ctxt.maybe_load_library_crate() {\n-            Some(lib) => lib,\n-            None => return None,\n-        };\n+        let library = locate_ctxt.maybe_load_library_crate()?;\n \n         // In the case that we're loading a crate, but not matching\n         // against a hash, we could load a crate which has the same hash"}, {"sha": "a76e7e6cda1b2359c0fcf3e9038eee066059c35b", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -1982,10 +1982,7 @@ mod prefixes {\n     impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n         type Item = &'cx Place<'tcx>;\n         fn next(&mut self) -> Option<Self::Item> {\n-            let mut cursor = match self.next {\n-                None => return None,\n-                Some(place) => place,\n-            };\n+            let mut cursor = self.next?;\n \n             // Post-processing `place`: Enqueue any remaining\n             // work. Also, `place` may not be a prefix itself, but"}, {"sha": "609629bffb9dad4f48318015f89bcfdeea605850", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -120,10 +120,7 @@ impl<'a> ArchiveBuilder<'a> {\n         if let Some(ref a) = self.src_archive {\n             return a.as_ref()\n         }\n-        let src = match self.config.src {\n-            Some(ref src) => src,\n-            None => return None,\n-        };\n+        let src = self.config.src.as_ref()?;\n         self.src_archive = Some(ArchiveRO::open(src).ok());\n         self.src_archive.as_ref().unwrap().as_ref()\n     }"}, {"sha": "d075bf436792050c7322e748c05d3c26c2a38e2f", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -79,10 +79,8 @@ impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n         let (kind, new_ty) = if let Some(mt) = self.cur_ty.builtin_deref(false, NoPreference) {\n             (AutoderefKind::Builtin, mt.ty)\n         } else {\n-            match self.overloaded_deref_ty(self.cur_ty) {\n-                Some(ty) => (AutoderefKind::Overloaded, ty),\n-                _ => return None,\n-            }\n+            let ty = self.overloaded_deref_ty(self.cur_ty)?;\n+            (AutoderefKind::Overloaded, ty)\n         };\n \n         if new_ty.references_error() {\n@@ -108,10 +106,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n \n         // <cur_ty as Deref>\n         let trait_ref = TraitRef {\n-            def_id: match tcx.lang_items().deref_trait() {\n-                Some(f) => f,\n-                None => return None,\n-            },\n+            def_id: tcx.lang_items().deref_trait()?,\n             substs: tcx.mk_substs_trait(self.cur_ty, &[]),\n         };\n "}, {"sha": "feb4eb603f5132ac380352746222d0d465af329c", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -425,15 +425,13 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n         Some(&(ref fqp, shortty)) => {\n             (fqp, shortty, repeat(\"../\").take(loc.len()).collect())\n         }\n-        None => match cache.external_paths.get(&did) {\n-            Some(&(ref fqp, shortty)) => {\n-                (fqp, shortty, match cache.extern_locations[&did.krate] {\n-                    (.., render::Remote(ref s)) => s.to_string(),\n-                    (.., render::Local) => repeat(\"../\").take(loc.len()).collect(),\n-                    (.., render::Unknown) => return None,\n-                })\n-            }\n-            None => return None,\n+        None => {\n+            let &(ref fqp, shortty) = cache.external_paths.get(&did)?;\n+            (fqp, shortty, match cache.extern_locations[&did.krate] {\n+                (.., render::Remote(ref s)) => s.to_string(),\n+                (.., render::Local) => repeat(\"../\").take(loc.len()).collect(),\n+                (.., render::Unknown) => return None,\n+            })\n         }\n     };\n     for component in &fqp[..fqp.len() - 1] {"}, {"sha": "7e5f9b4e31115ae9faec82b8bcf959cb8f80a14a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -1672,11 +1672,8 @@ impl<'a> Item<'a> {\n         let mut path = String::new();\n         let (krate, path) = if self.item.def_id.is_local() {\n             let path = PathBuf::from(&self.item.source.filename);\n-            if let Some(path) = self.cx.shared.local_sources.get(&path) {\n-                (&self.cx.shared.layout.krate, path)\n-            } else {\n-                return None;\n-            }\n+            let path = self.cx.shared.local_sources.get(&path)?;\n+            (&self.cx.shared.layout.krate, path)\n         } else {\n             // Macros from other libraries get special filenames which we can\n             // safely ignore."}, {"sha": "efdad7d801ab5ac83d074bf569ce572642647094", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -1052,10 +1052,7 @@ impl Json {\n     pub fn find_path<'a>(&'a self, keys: &[&str]) -> Option<&'a Json>{\n         let mut target = self;\n         for key in keys {\n-            match target.find(*key) {\n-                Some(t) => { target = t; },\n-                None => return None\n-            }\n+            target = target.find(*key)?;\n         }\n         Some(target)\n     }"}, {"sha": "7f0e5a8d2aa22552810848e20befbd71de809a28", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -1152,13 +1152,9 @@ impl<'a, T, S> Iterator for Intersection<'a, T, S>\n \n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n-            match self.iter.next() {\n-                None => return None,\n-                Some(elt) => {\n-                    if self.other.contains(elt) {\n-                        return Some(elt);\n-                    }\n-                }\n+            let elt = self.iter.next()?;\n+            if self.other.contains(elt) {\n+                return Some(elt);\n             }\n         }\n     }\n@@ -1202,13 +1198,9 @@ impl<'a, T, S> Iterator for Difference<'a, T, S>\n \n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n-            match self.iter.next() {\n-                None => return None,\n-                Some(elt) => {\n-                    if !self.other.contains(elt) {\n-                        return Some(elt);\n-                    }\n-                }\n+            let elt = self.iter.next()?;\n+            if !self.other.contains(elt) {\n+                return Some(elt);\n             }\n         }\n     }"}, {"sha": "9c401d7663fd62d3d7528ec1ccb7461f73fd75f0", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -2019,10 +2019,9 @@ impl<R: Read> Iterator for Chars<R> {\n     type Item = result::Result<char, CharsError>;\n \n     fn next(&mut self) -> Option<result::Result<char, CharsError>> {\n-        let first_byte = match read_one_byte(&mut self.inner) {\n-            None => return None,\n-            Some(Ok(b)) => b,\n-            Some(Err(e)) => return Some(Err(CharsError::Other(e))),\n+        let first_byte = match read_one_byte(&mut self.inner)? {\n+            Ok(b) => b,\n+            Err(e) => return Some(Err(CharsError::Other(e))),\n         };\n         let width = core_str::utf8_char_width(first_byte);\n         if width == 1 { return Some(Ok(first_byte as char)) }"}, {"sha": "9f7125fb935f713b64b0d9b0febf5959e0efbe40", "filename": "src/libstd/net/parser.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibstd%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibstd%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fparser.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -170,11 +170,7 @@ impl<'a> Parser<'a> {\n                 return None;\n             }\n \n-            let octet = self.read_number(10, 3, 0x100).map(|n| n as u8);\n-            match octet {\n-                Some(d) => bs[i] = d,\n-                None => return None,\n-            };\n+            bs[i] = self.read_number(10, 3, 0x100).map(|n| n as u8)?;\n             i += 1;\n         }\n         Some(Ipv4Addr::new(bs[0], bs[1], bs[2], bs[3]))"}, {"sha": "cb249af4254083f57363afdc7f860cca846f6e49", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -255,10 +255,7 @@ pub mod guard {\n \n     pub unsafe fn init() -> Option<usize> {\n         let psize = os::page_size();\n-        let mut stackaddr = match get_stack_start() {\n-            Some(addr) => addr,\n-            None => return None,\n-        };\n+        let mut stackaddr = get_stack_start()?;\n \n         // Ensure stackaddr is page aligned! A parent process might\n         // have reset RLIMIT_STACK to be non-page aligned. The"}, {"sha": "c70b39995ebb0c45d3ae91a0c2959518baa79054", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -136,10 +136,7 @@ impl Iterator for LookupHost {\n     fn next(&mut self) -> Option<SocketAddr> {\n         loop {\n             unsafe {\n-                let cur = match self.cur.as_ref() {\n-                    None => return None,\n-                    Some(c) => c,\n-                };\n+                let cur = self.cur.as_ref()?;\n                 self.cur = cur.ai_next;\n                 match sockaddr_to_addr(mem::transmute(cur.ai_addr),\n                                        cur.ai_addrlen as usize)"}, {"sha": "b2fc559bb37f2954630fb19adbf6cffd956adfd8", "filename": "src/libstd/sys_common/wtf8.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fwtf8.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -578,10 +578,7 @@ impl Wtf8 {\n     fn next_surrogate(&self, mut pos: usize) -> Option<(usize, u16)> {\n         let mut iter = self.bytes[pos..].iter();\n         loop {\n-            let b = match iter.next() {\n-                None => return None,\n-                Some(&b) => b,\n-            };\n+            let b = *iter.next()?;\n             if b < 0x80 {\n                 pos += 1;\n             } else if b < 0xE0 {"}, {"sha": "293c66148ab1ca786b26def94fe026f47d5d575b", "filename": "src/libstd_unicode/char.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibstd_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibstd_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fchar.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -1528,12 +1528,7 @@ impl<I: Iterator<Item = u16>> Iterator for DecodeUtf16<I> {\n     fn next(&mut self) -> Option<Result<char, DecodeUtf16Error>> {\n         let u = match self.buf.take() {\n             Some(buf) => buf,\n-            None => {\n-                match self.iter.next() {\n-                    Some(u) => u,\n-                    None => return None,\n-                }\n-            }\n+            None => self.iter.next()?\n         };\n \n         if u < 0xD800 || 0xDFFF < u {"}, {"sha": "e5e95002e107933e12be56e58fbf4d833cb17e14", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -1123,10 +1123,7 @@ impl MetaItem {\n             _ => return None,\n         };\n         let list_closing_paren_pos = tokens.peek().map(|tt| tt.span().hi());\n-        let node = match MetaItemKind::from_tokens(tokens) {\n-            Some(node) => node,\n-            _ => return None,\n-        };\n+        let node = MetaItemKind::from_tokens(tokens)?;\n         let hi = match node {\n             MetaItemKind::NameValue(ref lit) => lit.span.hi(),\n             MetaItemKind::List(..) => list_closing_paren_pos.unwrap_or(span.hi()),\n@@ -1182,10 +1179,8 @@ impl MetaItemKind {\n         let mut tokens = delimited.into_trees().peekable();\n         let mut result = Vec::new();\n         while let Some(..) = tokens.peek() {\n-            match NestedMetaItemKind::from_tokens(&mut tokens) {\n-                Some(item) => result.push(respan(item.span(), item)),\n-                None => return None,\n-            }\n+            let item = NestedMetaItemKind::from_tokens(&mut tokens)?;\n+            result.push(respan(item.span(), item));\n             match tokens.next() {\n                 None | Some(TokenTree::Token(_, Token::Comma)) => {}\n                 _ => return None,"}, {"sha": "26f39f608807d9afc9786bcd302cf73b27e3f727", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -620,10 +620,7 @@ fn prepend_attrs(sess: &ParseSess,\n                  span: syntax_pos::Span)\n     -> Option<tokenstream::TokenStream>\n {\n-    let tokens = match tokens {\n-        Some(tokens) => tokens,\n-        None => return None,\n-    };\n+    let tokens = tokens?;\n     if attrs.len() == 0 {\n         return Some(tokens.clone())\n     }"}, {"sha": "0476d7d4fcc1c53b45d14f0e6f1e94187efafbd1", "filename": "src/libsyntax_ext/format_foreign.rs", "status": "modified", "additions": 27, "deletions": 48, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibsyntax_ext%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibsyntax_ext%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat_foreign.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -8,15 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-macro_rules! try_opt {\n-    ($e:expr) => {\n-        match $e {\n-            Some(v) => v,\n-            None => return None,\n-        }\n-    };\n-}\n-\n pub mod printf {\n     use super::strcursor::StrCursor as Cur;\n \n@@ -173,7 +164,7 @@ pub mod printf {\n             s.push_str(\"{\");\n \n             if let Some(arg) = self.parameter {\n-                try_opt!(write!(s, \"{}\", try_opt!(arg.checked_sub(1))).ok());\n+                write!(s, \"{}\", arg.checked_sub(1)?).ok()?;\n             }\n \n             if has_options {\n@@ -203,12 +194,12 @@ pub mod printf {\n                 }\n \n                 if let Some(width) = width {\n-                    try_opt!(width.translate(&mut s).ok());\n+                    width.translate(&mut s).ok()?;\n                 }\n \n                 if let Some(precision) = precision {\n                     s.push_str(\".\");\n-                    try_opt!(precision.translate(&mut s).ok());\n+                    precision.translate(&mut s).ok()?;\n                 }\n \n                 if let Some(type_) = type_ {\n@@ -277,13 +268,9 @@ pub mod printf {\n     impl<'a> Iterator for Substitutions<'a> {\n         type Item = Substitution<'a>;\n         fn next(&mut self) -> Option<Self::Item> {\n-            match parse_next_substitution(self.s) {\n-                Some((sub, tail)) => {\n-                    self.s = tail;\n-                    Some(sub)\n-                },\n-                None => None,\n-            }\n+            let (sub, tail) = parse_next_substitution(self.s)?;\n+            self.s = tail;\n+            Some(sub)\n         }\n     }\n \n@@ -303,11 +290,10 @@ pub mod printf {\n         use self::State::*;\n \n         let at = {\n-            let start = try_opt!(s.find('%'));\n-            match s[start+1..].chars().next() {\n-                Some('%') => return Some((Substitution::Escape, &s[start+2..])),\n-                Some(_) => {/* fall-through */},\n-                None => return None,\n+            let start = s.find('%')?;\n+            match s[start+1..].chars().next()? {\n+                '%' => return Some((Substitution::Escape, &s[start+2..])),\n+                _ => {/* fall-through */},\n             }\n \n             Cur::new_at_start(&s[start..])\n@@ -335,16 +321,16 @@ pub mod printf {\n         // Used to establish the full span at the end.\n         let start = at;\n         // The current position within the string.\n-        let mut at = try_opt!(at.at_next_cp());\n+        let mut at = at.at_next_cp()?;\n         // `c` is the next codepoint, `next` is a cursor after it.\n-        let (mut c, mut next) = try_opt!(at.next_cp());\n+        let (mut c, mut next) = at.next_cp()?;\n \n         // Update `at`, `c`, and `next`, exiting if we're out of input.\n         macro_rules! move_to {\n             ($cur:expr) => {\n                 {\n                     at = $cur;\n-                    let (c_, next_) = try_opt!(at.next_cp());\n+                    let (c_, next_) = at.next_cp()?;\n                     c = c_;\n                     next = next_;\n                 }\n@@ -801,31 +787,27 @@ pub mod shell {\n     /// Parse the next substitution from the input string.\n     pub fn parse_next_substitution(s: &str) -> Option<(Substitution, &str)> {\n         let at = {\n-            let start = try_opt!(s.find('$'));\n-            match s[start+1..].chars().next() {\n-                Some('$') => return Some((Substitution::Escape, &s[start+2..])),\n-                Some(c @ '0' ... '9') => {\n+            let start = s.find('$')?;\n+            match s[start+1..].chars().next()? {\n+                '$' => return Some((Substitution::Escape, &s[start+2..])),\n+                c @ '0' ... '9' => {\n                     let n = (c as u8) - b'0';\n                     return Some((Substitution::Ordinal(n), &s[start+2..]));\n                 },\n-                Some(_) => {/* fall-through */},\n-                None => return None,\n+                _ => {/* fall-through */},\n             }\n \n             Cur::new_at_start(&s[start..])\n         };\n \n-        let at = try_opt!(at.at_next_cp());\n-        match at.next_cp() {\n-            Some((c, inner)) => {\n-                if !is_ident_head(c) {\n-                    None\n-                } else {\n-                    let end = at_next_cp_while(inner, is_ident_tail);\n-                    Some((Substitution::Name(at.slice_between(end).unwrap()), end.slice_after()))\n-                }\n-            },\n-            _ => None\n+        let at = at.at_next_cp()?;\n+        let (c, inner) = at.next_cp()?;\n+\n+        if !is_ident_head(c) {\n+            None\n+        } else {\n+            let end = at_next_cp_while(inner, is_ident_tail);\n+            Some((Substitution::Name(at.slice_between(end).unwrap()), end.slice_after()))\n         }\n     }\n \n@@ -946,10 +928,7 @@ mod strcursor {\n         }\n \n         pub fn next_cp(mut self) -> Option<(char, StrCursor<'a>)> {\n-            let cp = match self.cp_after() {\n-                Some(cp) => cp,\n-                None => return None,\n-            };\n+            let cp = self.cp_after()?;\n             self.seek_right(cp.len_utf8());\n             Some((cp, self))\n         }"}, {"sha": "492d26e625cbed84dfbbf5dea8316966b8fd6ddf", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3024c1434a667425d30e4b0785857381323712aa/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3024c1434a667425d30e4b0785857381323712aa/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=3024c1434a667425d30e4b0785857381323712aa", "patch": "@@ -20,10 +20,7 @@ use std::path::PathBuf;\n #[allow(deprecated)]\n pub fn get_dbpath_for_term(term: &str) -> Option<PathBuf> {\n     let mut dirs_to_search = Vec::new();\n-    let first_char = match term.chars().next() {\n-        Some(c) => c,\n-        None => return None,\n-    };\n+    let first_char = term.chars().next()?;\n \n     // Find search directory\n     if let Some(dir) = env::var_os(\"TERMINFO\") {"}]}