{"sha": "7dfa486d4a18b7a6e514e589771f52c43eff4f3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkZmE0ODZkNGExOGI3YTZlNTE0ZTU4OTc3MWY1MmM0M2VmZjRmM2I=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-04-28T23:45:58Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-05-18T13:41:32Z"}, "message": "Add support for high byte registers on x86", "tree": {"sha": "6e9ac7f1c742cc946353074a940341798f47e681", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e9ac7f1c742cc946353074a940341798f47e681"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7dfa486d4a18b7a6e514e589771f52c43eff4f3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7dfa486d4a18b7a6e514e589771f52c43eff4f3b", "html_url": "https://github.com/rust-lang/rust/commit/7dfa486d4a18b7a6e514e589771f52c43eff4f3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93e2946d0c0cccd69ee03390adca7ec4f71a2113", "url": "https://api.github.com/repos/rust-lang/rust/commits/93e2946d0c0cccd69ee03390adca7ec4f71a2113", "html_url": "https://github.com/rust-lang/rust/commit/93e2946d0c0cccd69ee03390adca7ec4f71a2113"}], "stats": {"total": 321, "additions": 198, "deletions": 123}, "files": [{"sha": "20abfbcf4055848e5f905a22d03901d259df9a0e", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=7dfa486d4a18b7a6e514e589771f52c43eff4f3b", "patch": "@@ -409,6 +409,7 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass) -> String {\n             InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => \"Q\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => \"r\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg)\n             | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg) => \"x\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => \"v\",\n@@ -459,6 +460,7 @@ fn modifier_to_llvm(\n             Some('r') => Some('q'),\n             _ => unreachable!(),\n         },\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => None,\n         InlineAsmRegClass::X86(reg @ X86InlineAsmRegClass::xmm_reg)\n         | InlineAsmRegClass::X86(reg @ X86InlineAsmRegClass::ymm_reg)\n         | InlineAsmRegClass::X86(reg @ X86InlineAsmRegClass::zmm_reg) => match (reg, modifier) {\n@@ -499,6 +501,7 @@ fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => cx.type_f32(),\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)\n         | InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => cx.type_i32(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => cx.type_i8(),\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg)\n         | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg)\n         | InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => cx.type_f32(),"}, {"sha": "9e144f86cd89774afb08940b2fcdb59d5aa35e3a", "filename": "src/librustc_passes/intrinsicck.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Flibrustc_passes%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Flibrustc_passes%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fintrinsicck.rs?ref=7dfa486d4a18b7a6e514e589771f52c43eff4f3b", "patch": "@@ -268,6 +268,12 @@ impl ExprVisitor<'tcx> {\n                     reg_class.name(),\n                     supported_tys.join(\", \"),\n                 ));\n+                if let Some(suggest) = reg_class.suggest_class(asm_arch, asm_ty) {\n+                    err.help(&format!(\n+                        \"consider using the `{}` register class instead\",\n+                        suggest.name()\n+                    ));\n+                }\n                 err.emit();\n                 return Some(asm_ty);\n             }\n@@ -298,7 +304,7 @@ impl ExprVisitor<'tcx> {\n         }\n \n         // Check whether a modifier is suggested for using this type.\n-        if let Some((suggested_modifier, suggested_result, switch_reg_class)) =\n+        if let Some((suggested_modifier, suggested_result)) =\n             reg_class.suggest_modifier(asm_arch, asm_ty)\n         {\n             // Search for any use of this operand without a modifier and emit\n@@ -323,18 +329,10 @@ impl ExprVisitor<'tcx> {\n                         let msg = \"formatting may not be suitable for sub-register argument\";\n                         let mut err = lint.build(msg);\n                         err.span_label(expr.span, \"for this argument\");\n-                        if let Some(switch_reg_class) = switch_reg_class {\n-                            err.help(&format!(\n-                                \"use the `{}` modifier with the `{}` register class \\\n-                                 to have the register formatted as `{}`\",\n-                                suggested_modifier, switch_reg_class, suggested_result,\n-                            ));\n-                        } else {\n-                            err.help(&format!(\n-                                \"use the `{}` modifier to have the register formatted as `{}`\",\n-                                suggested_modifier, suggested_result,\n-                            ));\n-                        }\n+                        err.help(&format!(\n+                            \"use the `{}` modifier to have the register formatted as `{}`\",\n+                            suggested_modifier, suggested_result,\n+                        ));\n                         err.help(&format!(\n                             \"or use the `{}` modifier to keep the default formatting of `{}`\",\n                             default_modifier, default_result,"}, {"sha": "e7c9edea7653aec7f996724f806e69c602459ddb", "filename": "src/librustc_target/asm/aarch64.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Flibrustc_target%2Fasm%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Flibrustc_target%2Fasm%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Faarch64.rs?ref=7dfa486d4a18b7a6e514e589771f52c43eff4f3b", "patch": "@@ -18,22 +18,26 @@ impl AArch64InlineAsmRegClass {\n         }\n     }\n \n+    pub fn suggest_class(self, _arch: InlineAsmArch, _ty: InlineAsmType) -> Option<Self> {\n+        None\n+    }\n+\n     pub fn suggest_modifier(\n         self,\n         _arch: InlineAsmArch,\n         ty: InlineAsmType,\n-    ) -> Option<(char, &'static str, Option<&'static str>)> {\n+    ) -> Option<(char, &'static str)> {\n         match self {\n             Self::reg => match ty.size().bits() {\n                 64 => None,\n-                _ => Some(('w', \"w0\", None)),\n+                _ => Some(('w', \"w0\")),\n             },\n             Self::vreg | Self::vreg_low16 => match ty.size().bits() {\n-                8 => Some(('b', \"b0\", None)),\n-                16 => Some(('h', \"h0\", None)),\n-                32 => Some(('s', \"s0\", None)),\n-                64 => Some(('d', \"d0\", None)),\n-                128 => Some(('q', \"q0\", None)),\n+                8 => Some(('b', \"b0\")),\n+                16 => Some(('h', \"h0\")),\n+                32 => Some(('s', \"s0\")),\n+                64 => Some(('d', \"d0\")),\n+                128 => Some(('q', \"q0\")),\n                 _ => None,\n             },\n         }"}, {"sha": "1798b2a0949754125a40e92b2a43afc3c3780aba", "filename": "src/librustc_target/asm/arm.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Flibrustc_target%2Fasm%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Flibrustc_target%2Fasm%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Farm.rs?ref=7dfa486d4a18b7a6e514e589771f52c43eff4f3b", "patch": "@@ -25,11 +25,15 @@ impl ArmInlineAsmRegClass {\n         }\n     }\n \n+    pub fn suggest_class(self, _arch: InlineAsmArch, _ty: InlineAsmType) -> Option<Self> {\n+        None\n+    }\n+\n     pub fn suggest_modifier(\n         self,\n         _arch: InlineAsmArch,\n         _ty: InlineAsmType,\n-    ) -> Option<(char, &'static str, Option<&'static str>)> {\n+    ) -> Option<(char, &'static str)> {\n         None\n     }\n "}, {"sha": "f1e8457cacca595dca22e0101f0147927a082bcd", "filename": "src/librustc_target/asm/mod.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Flibrustc_target%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Flibrustc_target%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Fmod.rs?ref=7dfa486d4a18b7a6e514e589771f52c43eff4f3b", "patch": "@@ -291,9 +291,20 @@ impl InlineAsmRegClass {\n         }\n     }\n \n+    /// Returns a suggested register class to use for this type. This is called\n+    /// after type checking via `supported_types` fails to give a better error\n+    /// message to the user.\n+    pub fn suggest_class(self, arch: InlineAsmArch, ty: InlineAsmType) -> Option<Self> {\n+        match self {\n+            Self::X86(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::X86),\n+            Self::Arm(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Arm),\n+            Self::AArch64(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::AArch64),\n+            Self::RiscV(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::RiscV),\n+        }\n+    }\n+\n     /// Returns a suggested template modifier to use for this type and an\n-    /// example of a  register named formatted with it. Optionally also returns\n-    /// the name of a different register class to use instead.\n+    /// example of a  register named formatted with it.\n     ///\n     /// Such suggestions are useful if a type smaller than the full register\n     /// size is used and a modifier can be used to point to the subregister of\n@@ -302,7 +313,7 @@ impl InlineAsmRegClass {\n         self,\n         arch: InlineAsmArch,\n         ty: InlineAsmType,\n-    ) -> Option<(char, &'static str, Option<&'static str>)> {\n+    ) -> Option<(char, &'static str)> {\n         match self {\n             Self::X86(r) => r.suggest_modifier(arch, ty),\n             Self::Arm(r) => r.suggest_modifier(arch, ty),"}, {"sha": "7da30cc887565cca885ad9e148b4697a77cb40ab", "filename": "src/librustc_target/asm/riscv.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Flibrustc_target%2Fasm%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Flibrustc_target%2Fasm%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Friscv.rs?ref=7dfa486d4a18b7a6e514e589771f52c43eff4f3b", "patch": "@@ -14,11 +14,15 @@ impl RiscVInlineAsmRegClass {\n         &[]\n     }\n \n+    pub fn suggest_class(self, _arch: InlineAsmArch, _ty: InlineAsmType) -> Option<Self> {\n+        None\n+    }\n+\n     pub fn suggest_modifier(\n         self,\n         _arch: InlineAsmArch,\n         _ty: InlineAsmType,\n-    ) -> Option<(char, &'static str, Option<&'static str>)> {\n+    ) -> Option<(char, &'static str)> {\n         None\n     }\n "}, {"sha": "6eb99b0180ff89776acf0997712432a5ed0c8a30", "filename": "src/librustc_target/asm/x86.rs", "status": "modified", "additions": 103, "deletions": 38, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Flibrustc_target%2Fasm%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Flibrustc_target%2Fasm%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Fx86.rs?ref=7dfa486d4a18b7a6e514e589771f52c43eff4f3b", "patch": "@@ -6,6 +6,7 @@ def_reg_class! {\n     X86 X86InlineAsmRegClass {\n         reg,\n         reg_abcd,\n+        reg_byte,\n         xmm_reg,\n         ymm_reg,\n         zmm_reg,\n@@ -30,46 +31,45 @@ impl X86InlineAsmRegClass {\n                     &['l', 'h', 'x', 'e']\n                 }\n             }\n+            Self::reg_byte => &[],\n             Self::xmm_reg | Self::ymm_reg | Self::zmm_reg => &['x', 'y', 'z'],\n             Self::kreg => &[],\n         }\n     }\n \n+    pub fn suggest_class(self, _arch: InlineAsmArch, ty: InlineAsmType) -> Option<Self> {\n+        match self {\n+            Self::reg | Self::reg_abcd if ty.size().bits() == 8 => Some(Self::reg_byte),\n+            _ => None,\n+        }\n+    }\n+\n     pub fn suggest_modifier(\n         self,\n         arch: InlineAsmArch,\n         ty: InlineAsmType,\n-    ) -> Option<(char, &'static str, Option<&'static str>)> {\n+    ) -> Option<(char, &'static str)> {\n         match self {\n             Self::reg => match ty.size().bits() {\n-                8 => {\n-                    if arch == InlineAsmArch::X86_64 {\n-                        Some(('l', \"al\", None))\n-                    } else {\n-                        // Low byte registers require reg_abcd on x86 so we emit\n-                        // a suggestion to use that register class instead.\n-                        Some(('l', \"al\", Some(\"reg_abcd\")))\n-                    }\n-                }\n-                16 => Some(('x', \"ax\", None)),\n-                32 if arch == InlineAsmArch::X86_64 => Some(('e', \"eax\", None)),\n+                16 => Some(('x', \"ax\")),\n+                32 if arch == InlineAsmArch::X86_64 => Some(('e', \"eax\")),\n                 _ => None,\n             },\n             Self::reg_abcd => match ty.size().bits() {\n-                8 => Some(('l', \"al\", None)),\n-                16 => Some(('x', \"ax\", None)),\n-                32 if arch == InlineAsmArch::X86_64 => Some(('e', \"eax\", None)),\n+                16 => Some(('x', \"ax\")),\n+                32 if arch == InlineAsmArch::X86_64 => Some(('e', \"eax\")),\n                 _ => None,\n             },\n+            Self::reg_byte => None,\n             Self::xmm_reg => None,\n             Self::ymm_reg => match ty.size().bits() {\n                 256 => None,\n-                _ => Some(('x', \"xmm0\", None)),\n+                _ => Some(('x', \"xmm0\")),\n             },\n             Self::zmm_reg => match ty.size().bits() {\n                 512 => None,\n-                256 => Some(('y', \"ymm0\", None)),\n-                _ => Some(('x', \"xmm0\", None)),\n+                256 => Some(('y', \"ymm0\")),\n+                _ => Some(('x', \"xmm0\")),\n             },\n             Self::kreg => None,\n         }\n@@ -84,6 +84,7 @@ impl X86InlineAsmRegClass {\n                     Some(('e', \"eax\"))\n                 }\n             }\n+            Self::reg_byte => None,\n             Self::xmm_reg => Some(('x', \"xmm0\")),\n             Self::ymm_reg => Some(('y', \"ymm0\")),\n             Self::zmm_reg => Some(('z', \"zmm0\")),\n@@ -98,11 +99,12 @@ impl X86InlineAsmRegClass {\n         match self {\n             Self::reg | Self::reg_abcd => {\n                 if arch == InlineAsmArch::X86_64 {\n-                    types! { _: I8, I16, I32, I64, F32, F64; }\n+                    types! { _: I16, I32, I64, F32, F64; }\n                 } else {\n-                    types! { _: I8, I16, I32, F32; }\n+                    types! { _: I16, I32, F32; }\n                 }\n             }\n+            Self::reg_byte => types! { _: I8; },\n             Self::xmm_reg => types! {\n                 \"sse\": I32, I64, F32, F64,\n                   VecI8(16), VecI16(8), VecI32(4), VecI64(2), VecF32(4), VecF64(2);\n@@ -139,20 +141,38 @@ fn x86_64_only(\n \n def_regs! {\n     X86 X86InlineAsmReg X86InlineAsmRegClass {\n-        ax: reg, reg_abcd = [\"ax\", \"al\", \"eax\", \"rax\"],\n-        bx: reg, reg_abcd = [\"bx\", \"bl\", \"ebx\", \"rbx\"],\n-        cx: reg, reg_abcd = [\"cx\", \"cl\", \"ecx\", \"rcx\"],\n-        dx: reg, reg_abcd = [\"dx\", \"dl\", \"edx\", \"rdx\"],\n-        si: reg = [\"si\", \"sil\", \"esi\", \"rsi\"],\n-        di: reg = [\"di\", \"dil\", \"edi\", \"rdi\"],\n-        r8: reg = [\"r8\", \"r8b\", \"r8w\", \"r8d\"] % x86_64_only,\n-        r9: reg = [\"r9\", \"r9b\", \"r9w\", \"r9d\"] % x86_64_only,\n-        r10: reg = [\"r10\", \"r10b\", \"r10w\", \"r10d\"] % x86_64_only,\n-        r11: reg = [\"r11\", \"r11b\", \"r11w\", \"r11d\"] % x86_64_only,\n-        r12: reg = [\"r12\", \"r12b\", \"r12w\", \"r12d\"] % x86_64_only,\n-        r13: reg = [\"r13\", \"r13b\", \"r13w\", \"r13d\"] % x86_64_only,\n-        r14: reg = [\"r14\", \"r14b\", \"r14w\", \"r14d\"] % x86_64_only,\n-        r15: reg = [\"r15\", \"r15b\", \"r15w\", \"r15d\"] % x86_64_only,\n+        ax: reg, reg_abcd = [\"ax\", \"eax\", \"rax\"],\n+        bx: reg, reg_abcd = [\"bx\", \"ebx\", \"rbx\"],\n+        cx: reg, reg_abcd = [\"cx\", \"ecx\", \"rcx\"],\n+        dx: reg, reg_abcd = [\"dx\", \"edx\", \"rdx\"],\n+        si: reg = [\"si\", \"esi\", \"rsi\"],\n+        di: reg = [\"di\", \"edi\", \"rdi\"],\n+        r8: reg = [\"r8\", \"r8w\", \"r8d\"] % x86_64_only,\n+        r9: reg = [\"r9\", \"r9w\", \"r9d\"] % x86_64_only,\n+        r10: reg = [\"r10\", \"r10w\", \"r10d\"] % x86_64_only,\n+        r11: reg = [\"r11\", \"r11w\", \"r11d\"] % x86_64_only,\n+        r12: reg = [\"r12\", \"r12w\", \"r12d\"] % x86_64_only,\n+        r13: reg = [\"r13\", \"r13w\", \"r13d\"] % x86_64_only,\n+        r14: reg = [\"r14\", \"r14w\", \"r14d\"] % x86_64_only,\n+        r15: reg = [\"r15\", \"r15w\", \"r15d\"] % x86_64_only,\n+        al: reg_byte = [\"al\"],\n+        ah: reg_byte = [\"ah\"],\n+        bl: reg_byte = [\"bl\"],\n+        bh: reg_byte = [\"bh\"],\n+        cl: reg_byte = [\"cl\"],\n+        ch: reg_byte = [\"ch\"],\n+        dl: reg_byte = [\"dl\"],\n+        dh: reg_byte = [\"dh\"],\n+        sil: reg_byte = [\"sil\"] % x86_64_only,\n+        dil: reg_byte = [\"dil\"] % x86_64_only,\n+        r8b: reg_byte = [\"r8b\"] % x86_64_only,\n+        r9b: reg_byte = [\"r9b\"] % x86_64_only,\n+        r10b: reg_byte = [\"r10b\"] % x86_64_only,\n+        r11b: reg_byte = [\"r11b\"] % x86_64_only,\n+        r12b: reg_byte = [\"r12b\"] % x86_64_only,\n+        r13b: reg_byte = [\"r13b\"] % x86_64_only,\n+        r14b: reg_byte = [\"r14b\"] % x86_64_only,\n+        r15b: reg_byte = [\"r15b\"] % x86_64_only,\n         xmm0: xmm_reg = [\"xmm0\"],\n         xmm1: xmm_reg = [\"xmm1\"],\n         xmm2: xmm_reg = [\"xmm2\"],\n@@ -224,8 +244,6 @@ def_regs! {\n         k5: kreg = [\"k5\"],\n         k6: kreg = [\"k6\"],\n         k7: kreg = [\"k7\"],\n-        #error = [\"ah\", \"bh\", \"ch\", \"dh\"] =>\n-            \"high byte registers are not currently supported as operands for inline asm\",\n         #error = [\"bp\", \"bpl\", \"ebp\", \"rbp\"] =>\n             \"the frame pointer cannot be used as an operand for inline asm\",\n         #error = [\"sp\", \"spl\", \"esp\", \"rsp\"] =>\n@@ -281,6 +299,8 @@ impl X86InlineAsmReg {\n                 'r' => write!(out, \"r{}\", index),\n                 _ => unreachable!(),\n             }\n+        } else if self as u32 <= Self::r15b as u32 {\n+            out.write_str(self.name())\n         } else if self as u32 <= Self::xmm15 as u32 {\n             let prefix = modifier.unwrap_or('x');\n             let index = self as u32 - Self::xmm0 as u32;\n@@ -301,8 +321,39 @@ impl X86InlineAsmReg {\n \n     pub fn overlapping_regs(self, mut cb: impl FnMut(X86InlineAsmReg)) {\n         macro_rules! reg_conflicts {\n-            ($($x:ident : $y:ident : $z:ident,)*) => {\n+            (\n+                $(\n+                    $w:ident : $l:ident $h:ident\n+                ),*;\n+                $(\n+                    $w2:ident : $l2:ident\n+                ),*;\n+                $(\n+                    $x:ident : $y:ident : $z:ident\n+                ),*;\n+            ) => {\n                 match self {\n+                    $(\n+                        Self::$w => {\n+                            cb(Self::$w);\n+                            cb(Self::$l);\n+                            cb(Self::$h);\n+                        }\n+                        Self::$l => {\n+                            cb(Self::$w);\n+                            cb(Self::$l);\n+                        }\n+                        Self::$h => {\n+                            cb(Self::$w);\n+                            cb(Self::$h);\n+                        }\n+                    )*\n+                    $(\n+                        Self::$w2 | Self::$l2 => {\n+                            cb(Self::$w2);\n+                            cb(Self::$l2);\n+                        }\n+                    )*\n                     $(\n                         Self::$x | Self::$y | Self::$z => {\n                             cb(Self::$x);\n@@ -324,6 +375,20 @@ impl X86InlineAsmReg {\n         // registers are only available with AVX-512, so we just specify them\n         // as aliases directly.\n         reg_conflicts! {\n+            ax : al ah,\n+            bx : bl bh,\n+            cx : cl ch,\n+            dx : dl dh;\n+            si : sil,\n+            di : dil,\n+            r8 : r8b,\n+            r9 : r9b,\n+            r10 : r10b,\n+            r11 : r11b,\n+            r12 : r12b,\n+            r13 : r13b,\n+            r14 : r14b,\n+            r15 : r15b;\n             xmm0 : ymm0 : zmm0,\n             xmm1 : ymm1 : zmm1,\n             xmm2 : ymm2 : zmm2,\n@@ -339,7 +404,7 @@ impl X86InlineAsmReg {\n             xmm12 : ymm12 : zmm12,\n             xmm13 : ymm13 : zmm13,\n             xmm14 : ymm14 : zmm14,\n-            xmm15 : ymm15 : zmm15,\n+            xmm15 : ymm15 : zmm15;\n         }\n     }\n }"}, {"sha": "508d6801580d2228fb65914ffd7c77f0cb387ff4", "filename": "src/test/assembly/asm/x86-types.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Ftest%2Fassembly%2Fasm%2Fx86-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Ftest%2Fassembly%2Fasm%2Fx86-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Fx86-types.rs?ref=7dfa486d4a18b7a6e514e589771f52c43eff4f3b", "patch": "@@ -266,13 +266,6 @@ macro_rules! check {\n     };\n }\n \n-// CHECK-LABEL: reg_i8:\n-// CHECK: #APP\n-// x86_64: mov r{{[a-z0-9]+}}, r{{[a-z0-9]+}}\n-// i686: mov e{{[a-z0-9]+}}, e{{[a-z0-9]+}}\n-// CHECK: #NO_APP\n-check!(reg_i8 i8 reg \"mov\");\n-\n // CHECK-LABEL: reg_i16:\n // CHECK: #APP\n // x86_64: mov r{{[a-z0-9]+}}, r{{[a-z0-9]+}}\n@@ -315,13 +308,6 @@ check!(reg_f64 f64 reg \"mov\");\n // CHECK: #NO_APP\n check!(reg_ptr ptr reg \"mov\");\n \n-// CHECK-LABEL: reg_abcd_i8:\n-// CHECK: #APP\n-// x86_64: mov r{{[a-z0-9]+}}, r{{[a-z0-9]+}}\n-// i686: mov e{{[a-z0-9]+}}, e{{[a-z0-9]+}}\n-// CHECK: #NO_APP\n-check!(reg_abcd_i8 i8 reg_abcd \"mov\");\n-\n // CHECK-LABEL: reg_abcd_i16:\n // CHECK: #APP\n // x86_64: mov r{{[a-z0-9]+}}, r{{[a-z0-9]+}}\n@@ -364,6 +350,12 @@ check!(reg_abcd_f64 f64 reg_abcd \"mov\");\n // CHECK: #NO_APP\n check!(reg_abcd_ptr ptr reg_abcd \"mov\");\n \n+// CHECK-LABEL: reg_byte:\n+// CHECK: #APP\n+// CHECK: mov {{[a-z0-9]+}}, {{[a-z0-9]+}}\n+// CHECK: #NO_APP\n+check!(reg_byte i8 reg_byte \"mov\");\n+\n // CHECK-LABEL: xmm_reg_i32:\n // CHECK: #APP\n // CHECK: movaps xmm{{[0-9]+}}, xmm{{[0-9]+}}"}, {"sha": "016ea9329c4d0988407a47a7b85cad9de9fe05b5", "filename": "src/test/ui/asm/bad-reg.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Ftest%2Fui%2Fasm%2Fbad-reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Ftest%2Fui%2Fasm%2Fbad-reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fbad-reg.rs?ref=7dfa486d4a18b7a6e514e589771f52c43eff4f3b", "patch": "@@ -25,8 +25,6 @@ fn main() {\n         //~^ ERROR register class `zmm_reg` requires the `avx512f` target feature\n         asm!(\"\", in(\"zmm0\") foo);\n         //~^ ERROR register class `zmm_reg` requires the `avx512f` target feature\n-        asm!(\"\", in(\"ah\") foo);\n-        //~^ ERROR invalid register `ah`: high byte registers are not currently supported\n         asm!(\"\", in(\"ebp\") foo);\n         //~^ ERROR invalid register `ebp`: the frame pointer cannot be used as an operand\n         asm!(\"\", in(\"rsp\") foo);\n@@ -44,7 +42,7 @@ fn main() {\n         // (except in/lateout which don't conflict)\n \n         asm!(\"\", in(\"eax\") foo, in(\"al\") bar);\n-        //~^ ERROR register `ax` conflicts with register `ax`\n+        //~^ ERROR register `al` conflicts with register `ax`\n         asm!(\"\", in(\"rax\") foo, out(\"rax\") bar);\n         //~^ ERROR register `ax` conflicts with register `ax`\n         asm!(\"\", in(\"al\") foo, lateout(\"al\") bar);"}, {"sha": "a1423f0e9c1b11ce14031cde92030c2db01f74c8", "filename": "src/test/ui/asm/bad-reg.stderr", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Ftest%2Fui%2Fasm%2Fbad-reg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Ftest%2Fui%2Fasm%2Fbad-reg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fbad-reg.stderr?ref=7dfa486d4a18b7a6e514e589771f52c43eff4f3b", "patch": "@@ -58,91 +58,85 @@ error: register class `zmm_reg` requires the `avx512f` target feature\n LL |         asm!(\"\", in(\"zmm0\") foo);\n    |                  ^^^^^^^^^^^^^^\n \n-error: invalid register `ah`: high byte registers are not currently supported as operands for inline asm\n-  --> $DIR/bad-reg.rs:28:18\n-   |\n-LL |         asm!(\"\", in(\"ah\") foo);\n-   |                  ^^^^^^^^^^^^\n-\n error: invalid register `ebp`: the frame pointer cannot be used as an operand for inline asm\n-  --> $DIR/bad-reg.rs:30:18\n+  --> $DIR/bad-reg.rs:28:18\n    |\n LL |         asm!(\"\", in(\"ebp\") foo);\n    |                  ^^^^^^^^^^^^^\n \n error: invalid register `rsp`: the stack pointer cannot be used as an operand for inline asm\n-  --> $DIR/bad-reg.rs:32:18\n+  --> $DIR/bad-reg.rs:30:18\n    |\n LL |         asm!(\"\", in(\"rsp\") foo);\n    |                  ^^^^^^^^^^^^^\n \n error: invalid register `ip`: the instruction pointer cannot be used as an operand for inline asm\n-  --> $DIR/bad-reg.rs:34:18\n+  --> $DIR/bad-reg.rs:32:18\n    |\n LL |         asm!(\"\", in(\"ip\") foo);\n    |                  ^^^^^^^^^^^^\n \n error: invalid register `st(2)`: x87 registers are not currently supported as operands for inline asm\n-  --> $DIR/bad-reg.rs:36:18\n+  --> $DIR/bad-reg.rs:34:18\n    |\n LL |         asm!(\"\", in(\"st(2)\") foo);\n    |                  ^^^^^^^^^^^^^^^\n \n error: invalid register `mm0`: MMX registers are not currently supported as operands for inline asm\n-  --> $DIR/bad-reg.rs:38:18\n+  --> $DIR/bad-reg.rs:36:18\n    |\n LL |         asm!(\"\", in(\"mm0\") foo);\n    |                  ^^^^^^^^^^^^^\n \n error: invalid register `k0`: the k0 AVX mask register cannot be used as an operand for inline asm\n-  --> $DIR/bad-reg.rs:40:18\n+  --> $DIR/bad-reg.rs:38:18\n    |\n LL |         asm!(\"\", in(\"k0\") foo);\n    |                  ^^^^^^^^^^^^\n \n-error: register `ax` conflicts with register `ax`\n-  --> $DIR/bad-reg.rs:46:33\n+error: register `al` conflicts with register `ax`\n+  --> $DIR/bad-reg.rs:44:33\n    |\n LL |         asm!(\"\", in(\"eax\") foo, in(\"al\") bar);\n-   |                  -------------  ^^^^^^^^^^^^ register `ax`\n+   |                  -------------  ^^^^^^^^^^^^ register `al`\n    |                  |\n    |                  register `ax`\n \n error: register `ax` conflicts with register `ax`\n-  --> $DIR/bad-reg.rs:48:33\n+  --> $DIR/bad-reg.rs:46:33\n    |\n LL |         asm!(\"\", in(\"rax\") foo, out(\"rax\") bar);\n    |                  -------------  ^^^^^^^^^^^^^^ register `ax`\n    |                  |\n    |                  register `ax`\n    |\n help: use `lateout` instead of `out` to avoid conflict\n-  --> $DIR/bad-reg.rs:48:18\n+  --> $DIR/bad-reg.rs:46:18\n    |\n LL |         asm!(\"\", in(\"rax\") foo, out(\"rax\") bar);\n    |                  ^^^^^^^^^^^^^\n \n error: register `ymm0` conflicts with register `xmm0`\n-  --> $DIR/bad-reg.rs:51:34\n+  --> $DIR/bad-reg.rs:49:34\n    |\n LL |         asm!(\"\", in(\"xmm0\") foo, in(\"ymm0\") bar);\n    |                  --------------  ^^^^^^^^^^^^^^ register `ymm0`\n    |                  |\n    |                  register `xmm0`\n \n error: register `ymm0` conflicts with register `xmm0`\n-  --> $DIR/bad-reg.rs:53:34\n+  --> $DIR/bad-reg.rs:51:34\n    |\n LL |         asm!(\"\", in(\"xmm0\") foo, out(\"ymm0\") bar);\n    |                  --------------  ^^^^^^^^^^^^^^^ register `ymm0`\n    |                  |\n    |                  register `xmm0`\n    |\n help: use `lateout` instead of `out` to avoid conflict\n-  --> $DIR/bad-reg.rs:53:18\n+  --> $DIR/bad-reg.rs:51:18\n    |\n LL |         asm!(\"\", in(\"xmm0\") foo, out(\"ymm0\") bar);\n    |                  ^^^^^^^^^^^^^^\n \n-error: aborting due to 19 previous errors\n+error: aborting due to 18 previous errors\n "}, {"sha": "5de15fe49067ae85416a011c1b899f4800165b74", "filename": "src/test/ui/asm/type-check-3.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Ftest%2Fui%2Fasm%2Ftype-check-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Ftest%2Fui%2Fasm%2Ftype-check-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Ftype-check-3.rs?ref=7dfa486d4a18b7a6e514e589771f52c43eff4f3b", "patch": "@@ -29,7 +29,7 @@ fn main() {\n \n         // Template modifier suggestions for sub-registers\n \n-        asm!(\"{0} {0}\", in(reg) 0i8);\n+        asm!(\"{0} {0}\", in(reg) 0i16);\n         //~^ WARN formatting may not be suitable for sub-register argument\n         asm!(\"{0} {0:x}\", in(reg) 0i16);\n         //~^ WARN formatting may not be suitable for sub-register argument\n@@ -39,23 +39,26 @@ fn main() {\n         asm!(\"{}\", in(ymm_reg) 0i64);\n         //~^ WARN formatting may not be suitable for sub-register argument\n         asm!(\"{}\", in(ymm_reg) _mm256_setzero_ps());\n-        asm!(\"{:l}\", in(reg) 0i8);\n         asm!(\"{:l}\", in(reg) 0i16);\n         asm!(\"{:l}\", in(reg) 0i32);\n         asm!(\"{:l}\", in(reg) 0i64);\n         asm!(\"{:x}\", in(ymm_reg) 0i64);\n         asm!(\"{:x}\", in(ymm_reg) _mm256_setzero_ps());\n \n+        // Suggest different register class for type\n+\n+        asm!(\"{}\", in(reg) 0i8);\n+        //~^ ERROR type `i8` cannot be used with this register class\n+        asm!(\"{}\", in(reg_byte) 0i8);\n+\n         // Split inout operands must have compatible types\n \n-        let mut val_i8: i8;\n+        let mut val_i16: i16;\n         let mut val_f32: f32;\n         let mut val_u32: u32;\n         let mut val_u64: u64;\n         let mut val_ptr: *mut u8;\n-        asm!(\"{:r}\", inout(reg) 0u8 => val_i8);\n-        asm!(\"{:r}\", inout(reg) 0u16 => val_i8);\n-        //~^ ERROR incompatible types for asm inout argument\n+        asm!(\"{:r}\", inout(reg) 0u16 => val_i16);\n         asm!(\"{:r}\", inout(reg) 0u32 => val_f32);\n         //~^ ERROR incompatible types for asm inout argument\n         asm!(\"{:r}\", inout(reg) 0u32 => val_ptr);"}, {"sha": "01dbe78db887a70fc3c033c7fda455b51dbd45af", "filename": "src/test/ui/asm/type-check-3.stderr", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Ftest%2Fui%2Fasm%2Ftype-check-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7dfa486d4a18b7a6e514e589771f52c43eff4f3b/src%2Ftest%2Fui%2Fasm%2Ftype-check-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Ftype-check-3.stderr?ref=7dfa486d4a18b7a6e514e589771f52c43eff4f3b", "patch": "@@ -4,23 +4,23 @@ error: type `i128` cannot be used with this register class\n LL |         asm!(\"{}\", in(reg) 0i128);\n    |                            ^^^^^\n    |\n-   = note: register class `reg` supports these types: i8, i16, i32, i64, f32, f64\n+   = note: register class `reg` supports these types: i16, i32, i64, f32, f64\n \n error: type `std::arch::x86_64::__m128` cannot be used with this register class\n   --> $DIR/type-check-3.rs:14:28\n    |\n LL |         asm!(\"{}\", in(reg) _mm_setzero_ps());\n    |                            ^^^^^^^^^^^^^^^^\n    |\n-   = note: register class `reg` supports these types: i8, i16, i32, i64, f32, f64\n+   = note: register class `reg` supports these types: i16, i32, i64, f32, f64\n \n error: type `std::arch::x86_64::__m256` cannot be used with this register class\n   --> $DIR/type-check-3.rs:16:28\n    |\n LL |         asm!(\"{}\", in(reg) _mm256_setzero_ps());\n    |                            ^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: register class `reg` supports these types: i8, i16, i32, i64, f32, f64\n+   = note: register class `reg` supports these types: i16, i32, i64, f32, f64\n \n error: type `u8` cannot be used with this register class\n   --> $DIR/type-check-3.rs:18:32\n@@ -41,11 +41,11 @@ LL |         asm!(\"{}\", in(kreg) 0u64);\n warning: formatting may not be suitable for sub-register argument\n   --> $DIR/type-check-3.rs:32:15\n    |\n-LL |         asm!(\"{0} {0}\", in(reg) 0i8);\n-   |               ^^^ ^^^           --- for this argument\n+LL |         asm!(\"{0} {0}\", in(reg) 0i16);\n+   |               ^^^ ^^^           ---- for this argument\n    |\n    = note: `#[warn(asm_sub_register)]` on by default\n-   = help: use the `l` modifier to have the register formatted as `al`\n+   = help: use the `x` modifier to have the register formatted as `ax`\n    = help: or use the `r` modifier to keep the default formatting of `rax`\n \n warning: formatting may not be suitable for sub-register argument\n@@ -75,18 +75,17 @@ LL |         asm!(\"{}\", in(ymm_reg) 0i64);\n    = help: use the `x` modifier to have the register formatted as `xmm0`\n    = help: or use the `y` modifier to keep the default formatting of `ymm0`\n \n-error: incompatible types for asm inout argument\n-  --> $DIR/type-check-3.rs:57:33\n+error: type `i8` cannot be used with this register class\n+  --> $DIR/type-check-3.rs:50:28\n    |\n-LL |         asm!(\"{:r}\", inout(reg) 0u16 => val_i8);\n-   |                                 ^^^^    ^^^^^^ type `i8`\n-   |                                 |\n-   |                                 type `u16`\n+LL |         asm!(\"{}\", in(reg) 0i8);\n+   |                            ^^^\n    |\n-   = note: asm inout arguments must have the same type, unless they are both pointers or integers of the same size\n+   = note: register class `reg` supports these types: i16, i32, i64, f32, f64\n+   = help: consider using the `reg_byte` register class instead\n \n error: incompatible types for asm inout argument\n-  --> $DIR/type-check-3.rs:59:33\n+  --> $DIR/type-check-3.rs:62:33\n    |\n LL |         asm!(\"{:r}\", inout(reg) 0u32 => val_f32);\n    |                                 ^^^^    ^^^^^^^ type `f32`\n@@ -96,7 +95,7 @@ LL |         asm!(\"{:r}\", inout(reg) 0u32 => val_f32);\n    = note: asm inout arguments must have the same type, unless they are both pointers or integers of the same size\n \n error: incompatible types for asm inout argument\n-  --> $DIR/type-check-3.rs:61:33\n+  --> $DIR/type-check-3.rs:64:33\n    |\n LL |         asm!(\"{:r}\", inout(reg) 0u32 => val_ptr);\n    |                                 ^^^^    ^^^^^^^ type `*mut u8`\n@@ -106,7 +105,7 @@ LL |         asm!(\"{:r}\", inout(reg) 0u32 => val_ptr);\n    = note: asm inout arguments must have the same type, unless they are both pointers or integers of the same size\n \n error: incompatible types for asm inout argument\n-  --> $DIR/type-check-3.rs:63:33\n+  --> $DIR/type-check-3.rs:66:33\n    |\n LL |         asm!(\"{:r}\", inout(reg) main => val_u32);\n    |                                 ^^^^    ^^^^^^^ type `u32`"}]}