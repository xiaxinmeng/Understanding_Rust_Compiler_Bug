{"sha": "d1ea9d12fa95d8f8915b44b7a993591fd528d2ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxZWE5ZDEyZmE5NWQ4Zjg5MTViNDRiN2E5OTM1OTFmZDUyOGQyYmE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-11-13T16:54:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-13T16:54:31Z"}, "message": "Merge #6545\n\n6545: Simplify project model r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "fbfd11e4dbe85cc58c7c195b41a0cb82df43383f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbfd11e4dbe85cc58c7c195b41a0cb82df43383f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1ea9d12fa95d8f8915b44b7a993591fd528d2ba", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfrrpHCRBK7hj4Ov3rIwAAdHIIADVaF2TTir//DhQva3d7t/+9\ntsakYEg92lNmIsXlB+xBI78Mm0E/r+PcW+c55+oES/aXBSpinrehdmlEhndyFZdV\nK4tivNH7f3iF+JNc+gN3yfaEIK/+MN95n9F46JqfZBM6ATD6q8afcUKo0POC9nKl\nN6A9U2E92eIcygAhQBI0cTr75gukpuAL9F0kPYgLhKPJ+2zc1j/Nur/U5dApPt+W\n8gIGx269rWtecDjP8DLwhNLQn+33af2WOj/VFCZm4Tzi+g3cbZ58hfJqdI8aZjSL\nXFp1gBq+VZuFvdezGwfSjTWg3t2Ti6GprfYxMgGRTdzwWy9jl+95NMIl7pY09us=\n=hpT2\n-----END PGP SIGNATURE-----\n", "payload": "tree fbfd11e4dbe85cc58c7c195b41a0cb82df43383f\nparent 700e5e58b6ae51e7a1fd88b9f8da1bcef5d9ac49\nparent b1377363dffa042de5d0b3bd753753a97e488c70\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1605286471 +0000\ncommitter GitHub <noreply@github.com> 1605286471 +0000\n\nMerge #6545\n\n6545: Simplify project model r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1ea9d12fa95d8f8915b44b7a993591fd528d2ba", "html_url": "https://github.com/rust-lang/rust/commit/d1ea9d12fa95d8f8915b44b7a993591fd528d2ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1ea9d12fa95d8f8915b44b7a993591fd528d2ba/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "700e5e58b6ae51e7a1fd88b9f8da1bcef5d9ac49", "url": "https://api.github.com/repos/rust-lang/rust/commits/700e5e58b6ae51e7a1fd88b9f8da1bcef5d9ac49", "html_url": "https://github.com/rust-lang/rust/commit/700e5e58b6ae51e7a1fd88b9f8da1bcef5d9ac49"}, {"sha": "b1377363dffa042de5d0b3bd753753a97e488c70", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1377363dffa042de5d0b3bd753753a97e488c70", "html_url": "https://github.com/rust-lang/rust/commit/b1377363dffa042de5d0b3bd753753a97e488c70"}], "stats": {"total": 1248, "additions": 618, "deletions": 630}, "files": [{"sha": "540b57ae4c8b45e393562a21754648b9530e99f2", "filename": "crates/project_model/src/cargo_workspace.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d1ea9d12fa95d8f8915b44b7a993591fd528d2ba/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1ea9d12fa95d8f8915b44b7a993591fd528d2ba/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs?ref=d1ea9d12fa95d8f8915b44b7a993591fd528d2ba", "patch": "@@ -65,6 +65,10 @@ pub struct CargoConfig {\n     /// rustc target\n     pub target: Option<String>,\n \n+    /// Don't load sysroot crates (`std`, `core` & friends). Might be useful\n+    /// when debugging isolated issues.\n+    pub no_sysroot: bool,\n+\n     /// rustc private crate source\n     pub rustc_source: Option<AbsPathBuf>,\n }\n@@ -140,27 +144,27 @@ impl PackageData {\n impl CargoWorkspace {\n     pub fn from_cargo_metadata(\n         cargo_toml: &AbsPath,\n-        cargo_features: &CargoConfig,\n+        config: &CargoConfig,\n     ) -> Result<CargoWorkspace> {\n         let mut meta = MetadataCommand::new();\n         meta.cargo_path(toolchain::cargo());\n         meta.manifest_path(cargo_toml.to_path_buf());\n-        if cargo_features.all_features {\n+        if config.all_features {\n             meta.features(CargoOpt::AllFeatures);\n         } else {\n-            if cargo_features.no_default_features {\n+            if config.no_default_features {\n                 // FIXME: `NoDefaultFeatures` is mutual exclusive with `SomeFeatures`\n                 // https://github.com/oli-obk/cargo_metadata/issues/79\n                 meta.features(CargoOpt::NoDefaultFeatures);\n             }\n-            if !cargo_features.features.is_empty() {\n-                meta.features(CargoOpt::SomeFeatures(cargo_features.features.clone()));\n+            if !config.features.is_empty() {\n+                meta.features(CargoOpt::SomeFeatures(config.features.clone()));\n             }\n         }\n         if let Some(parent) = cargo_toml.parent() {\n             meta.current_dir(parent.to_path_buf());\n         }\n-        if let Some(target) = cargo_features.target.as_ref() {\n+        if let Some(target) = config.target.as_ref() {\n             meta.other_options(vec![String::from(\"--filter-platform\"), target.clone()]);\n         }\n         let mut meta = meta.exec().with_context(|| {\n@@ -170,8 +174,8 @@ impl CargoWorkspace {\n         let mut out_dir_by_id = FxHashMap::default();\n         let mut cfgs = FxHashMap::default();\n         let mut proc_macro_dylib_paths = FxHashMap::default();\n-        if cargo_features.load_out_dirs_from_check {\n-            let resources = load_extern_resources(cargo_toml, cargo_features)?;\n+        if config.load_out_dirs_from_check {\n+            let resources = load_extern_resources(cargo_toml, config)?;\n             out_dir_by_id = resources.out_dirs;\n             cfgs = resources.cfgs;\n             proc_macro_dylib_paths = resources.proc_dylib_paths;"}, {"sha": "24aa9b8fababab1a45f16d26d1be752cd1c5fca1", "filename": "crates/project_model/src/lib.rs", "status": "modified", "additions": 4, "deletions": 602, "changes": 606, "blob_url": "https://github.com/rust-lang/rust/blob/d1ea9d12fa95d8f8915b44b7a993591fd528d2ba/crates%2Fproject_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1ea9d12fa95d8f8915b44b7a993591fd528d2ba/crates%2Fproject_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Flib.rs?ref=d1ea9d12fa95d8f8915b44b7a993591fd528d2ba", "patch": "@@ -4,74 +4,27 @@ mod cargo_workspace;\n mod project_json;\n mod sysroot;\n mod cfg_flag;\n+mod workspace;\n \n use std::{\n-    fmt,\n-    fs::{self, read_dir, ReadDir},\n+    fs::{read_dir, ReadDir},\n     io,\n-    path::Component,\n     process::Command,\n };\n \n use anyhow::{bail, Context, Result};\n-use base_db::{CrateDisplayName, CrateGraph, CrateId, CrateName, Edition, Env, FileId};\n-use cfg::CfgOptions;\n use paths::{AbsPath, AbsPathBuf};\n-use rustc_hash::{FxHashMap, FxHashSet};\n-\n-use crate::cfg_flag::CfgFlag;\n+use rustc_hash::FxHashSet;\n \n pub use crate::{\n     cargo_workspace::{CargoConfig, CargoWorkspace, Package, Target, TargetKind},\n     project_json::{ProjectJson, ProjectJsonData},\n     sysroot::Sysroot,\n+    workspace::{PackageRoot, ProjectWorkspace},\n };\n \n pub use proc_macro_api::ProcMacroClient;\n \n-#[derive(Clone, Eq, PartialEq)]\n-pub enum ProjectWorkspace {\n-    /// Project workspace was discovered by running `cargo metadata` and `rustc --print sysroot`.\n-    Cargo { cargo: CargoWorkspace, sysroot: Sysroot, rustc: Option<CargoWorkspace> },\n-    /// Project workspace was manually specified using a `rust-project.json` file.\n-    Json { project: ProjectJson, sysroot: Option<Sysroot> },\n-}\n-\n-impl fmt::Debug for ProjectWorkspace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => f\n-                .debug_struct(\"Cargo\")\n-                .field(\"n_packages\", &cargo.packages().len())\n-                .field(\"n_sysroot_crates\", &sysroot.crates().len())\n-                .field(\n-                    \"n_rustc_compiler_crates\",\n-                    &rustc.as_ref().map_or(0, |rc| rc.packages().len()),\n-                )\n-                .finish(),\n-            ProjectWorkspace::Json { project, sysroot } => {\n-                let mut debug_struct = f.debug_struct(\"Json\");\n-                debug_struct.field(\"n_crates\", &project.n_crates());\n-                if let Some(sysroot) = sysroot {\n-                    debug_struct.field(\"n_sysroot_crates\", &sysroot.crates().len());\n-                }\n-                debug_struct.finish()\n-            }\n-        }\n-    }\n-}\n-\n-/// `PackageRoot` describes a package root folder.\n-/// Which may be an external dependency, or a member of\n-/// the current workspace.\n-#[derive(Debug, Clone, Eq, PartialEq, Hash)]\n-pub struct PackageRoot {\n-    /// Is a member of the current workspace\n-    pub is_member: bool,\n-    pub include: Vec<AbsPathBuf>,\n-    pub exclude: Vec<AbsPathBuf>,\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]\n pub enum ProjectManifest {\n     ProjectJson(AbsPathBuf),\n@@ -158,462 +111,6 @@ impl ProjectManifest {\n     }\n }\n \n-impl ProjectWorkspace {\n-    pub fn load(\n-        manifest: ProjectManifest,\n-        cargo_config: &CargoConfig,\n-        with_sysroot: bool,\n-    ) -> Result<ProjectWorkspace> {\n-        let res = match manifest {\n-            ProjectManifest::ProjectJson(project_json) => {\n-                let file = fs::read_to_string(&project_json).with_context(|| {\n-                    format!(\"Failed to read json file {}\", project_json.display())\n-                })?;\n-                let data = serde_json::from_str(&file).with_context(|| {\n-                    format!(\"Failed to deserialize json file {}\", project_json.display())\n-                })?;\n-                let project_location = project_json.parent().unwrap().to_path_buf();\n-                let project = ProjectJson::new(&project_location, data);\n-                let sysroot = match &project.sysroot_src {\n-                    Some(path) => Some(Sysroot::load(path)?),\n-                    None => None,\n-                };\n-                ProjectWorkspace::Json { project, sysroot }\n-            }\n-            ProjectManifest::CargoToml(cargo_toml) => {\n-                let cargo_version = utf8_stdout({\n-                    let mut cmd = Command::new(toolchain::cargo());\n-                    cmd.arg(\"--version\");\n-                    cmd\n-                })?;\n-\n-                let cargo = CargoWorkspace::from_cargo_metadata(&cargo_toml, cargo_config)\n-                    .with_context(|| {\n-                        format!(\n-                            \"Failed to read Cargo metadata from Cargo.toml file {}, {}\",\n-                            cargo_toml.display(),\n-                            cargo_version\n-                        )\n-                    })?;\n-                let sysroot = if with_sysroot {\n-                    Sysroot::discover(&cargo_toml).with_context(|| {\n-                        format!(\n-                            \"Failed to find sysroot for Cargo.toml file {}. Is rust-src installed?\",\n-                            cargo_toml.display()\n-                        )\n-                    })?\n-                } else {\n-                    Sysroot::default()\n-                };\n-\n-                let rustc = if let Some(rustc_dir) = &cargo_config.rustc_source {\n-                    Some(\n-                        CargoWorkspace::from_cargo_metadata(&rustc_dir, cargo_config)\n-                            .with_context(|| {\n-                                format!(\"Failed to read Cargo metadata for Rust sources\")\n-                            })?,\n-                    )\n-                } else {\n-                    None\n-                };\n-\n-                ProjectWorkspace::Cargo { cargo, sysroot, rustc }\n-            }\n-        };\n-\n-        Ok(res)\n-    }\n-\n-    pub fn load_inline(project_json: ProjectJson) -> Result<ProjectWorkspace> {\n-        let sysroot = match &project_json.sysroot_src {\n-            Some(path) => Some(Sysroot::load(path)?),\n-            None => None,\n-        };\n-\n-        Ok(ProjectWorkspace::Json { project: project_json, sysroot })\n-    }\n-\n-    /// Returns the roots for the current `ProjectWorkspace`\n-    /// The return type contains the path and whether or not\n-    /// the root is a member of the current workspace\n-    pub fn to_roots(&self) -> Vec<PackageRoot> {\n-        match self {\n-            ProjectWorkspace::Json { project, sysroot } => project\n-                .crates()\n-                .map(|(_, krate)| PackageRoot {\n-                    is_member: krate.is_workspace_member,\n-                    include: krate.include.clone(),\n-                    exclude: krate.exclude.clone(),\n-                })\n-                .collect::<FxHashSet<_>>()\n-                .into_iter()\n-                .chain(sysroot.as_ref().into_iter().flat_map(|sysroot| {\n-                    sysroot.crates().map(move |krate| PackageRoot {\n-                        is_member: false,\n-                        include: vec![sysroot[krate].root_dir().to_path_buf()],\n-                        exclude: Vec::new(),\n-                    })\n-                }))\n-                .collect::<Vec<_>>(),\n-            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n-                let roots = cargo\n-                    .packages()\n-                    .map(|pkg| {\n-                        let is_member = cargo[pkg].is_member;\n-                        let pkg_root = cargo[pkg].root().to_path_buf();\n-\n-                        let mut include = vec![pkg_root.clone()];\n-                        include.extend(cargo[pkg].out_dir.clone());\n-\n-                        let mut exclude = vec![pkg_root.join(\".git\")];\n-                        if is_member {\n-                            exclude.push(pkg_root.join(\"target\"));\n-                        } else {\n-                            exclude.push(pkg_root.join(\"tests\"));\n-                            exclude.push(pkg_root.join(\"examples\"));\n-                            exclude.push(pkg_root.join(\"benches\"));\n-                        }\n-                        PackageRoot { is_member, include, exclude }\n-                    })\n-                    .chain(sysroot.crates().map(|krate| PackageRoot {\n-                        is_member: false,\n-                        include: vec![sysroot[krate].root_dir().to_path_buf()],\n-                        exclude: Vec::new(),\n-                    }));\n-                if let Some(rustc_packages) = rustc {\n-                    roots\n-                        .chain(rustc_packages.packages().map(|krate| PackageRoot {\n-                            is_member: false,\n-                            include: vec![rustc_packages[krate].root().to_path_buf()],\n-                            exclude: Vec::new(),\n-                        }))\n-                        .collect()\n-                } else {\n-                    roots.collect()\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn proc_macro_dylib_paths(&self) -> Vec<AbsPathBuf> {\n-        match self {\n-            ProjectWorkspace::Json { project, sysroot: _ } => project\n-                .crates()\n-                .filter_map(|(_, krate)| krate.proc_macro_dylib_path.as_ref())\n-                .cloned()\n-                .collect(),\n-            ProjectWorkspace::Cargo { cargo, sysroot: _sysroot, rustc: _rustc_crates } => cargo\n-                .packages()\n-                .filter_map(|pkg| cargo[pkg].proc_macro_dylib_path.as_ref())\n-                .cloned()\n-                .collect(),\n-        }\n-    }\n-\n-    pub fn n_packages(&self) -> usize {\n-        match self {\n-            ProjectWorkspace::Json { project, .. } => project.n_crates(),\n-            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n-                let rustc_package_len = rustc.as_ref().map_or(0, |rc| rc.packages().len());\n-                cargo.packages().len() + sysroot.crates().len() + rustc_package_len\n-            }\n-        }\n-    }\n-\n-    pub fn to_crate_graph(\n-        &self,\n-        target: Option<&str>,\n-        proc_macro_client: &ProcMacroClient,\n-        load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n-    ) -> CrateGraph {\n-        let mut crate_graph = CrateGraph::default();\n-        match self {\n-            ProjectWorkspace::Json { project, sysroot } => {\n-                let sysroot_dps = sysroot\n-                    .as_ref()\n-                    .map(|sysroot| sysroot_to_crate_graph(&mut crate_graph, sysroot, target, load));\n-\n-                let mut cfg_cache: FxHashMap<Option<&str>, Vec<CfgFlag>> = FxHashMap::default();\n-                let crates: FxHashMap<_, _> = project\n-                    .crates()\n-                    .filter_map(|(crate_id, krate)| {\n-                        let file_path = &krate.root_module;\n-                        let file_id = match load(&file_path) {\n-                            Some(id) => id,\n-                            None => {\n-                                log::error!(\"failed to load crate root {}\", file_path.display());\n-                                return None;\n-                            }\n-                        };\n-\n-                        let env = krate.env.clone().into_iter().collect();\n-                        let proc_macro = krate\n-                            .proc_macro_dylib_path\n-                            .clone()\n-                            .map(|it| proc_macro_client.by_dylib_path(&it));\n-\n-                        let target = krate.target.as_deref().or(target);\n-                        let target_cfgs = cfg_cache\n-                            .entry(target)\n-                            .or_insert_with(|| get_rustc_cfg_options(target));\n-\n-                        let mut cfg_options = CfgOptions::default();\n-                        cfg_options.extend(target_cfgs.iter().chain(krate.cfg.iter()).cloned());\n-\n-                        Some((\n-                            crate_id,\n-                            crate_graph.add_crate_root(\n-                                file_id,\n-                                krate.edition,\n-                                krate.display_name.clone(),\n-                                cfg_options,\n-                                env,\n-                                proc_macro.unwrap_or_default(),\n-                            ),\n-                        ))\n-                    })\n-                    .collect();\n-\n-                for (from, krate) in project.crates() {\n-                    if let Some(&from) = crates.get(&from) {\n-                        if let Some((public_deps, _proc_macro)) = &sysroot_dps {\n-                            for (name, to) in public_deps.iter() {\n-                                if let Err(_) = crate_graph.add_dep(from, name.clone(), *to) {\n-                                    log::error!(\"cyclic dependency on {} for {:?}\", name, from)\n-                                }\n-                            }\n-                        }\n-\n-                        for dep in &krate.deps {\n-                            let to_crate_id = dep.crate_id;\n-                            if let Some(&to) = crates.get(&to_crate_id) {\n-                                if let Err(_) = crate_graph.add_dep(from, dep.name.clone(), to) {\n-                                    log::error!(\"cyclic dependency {:?} -> {:?}\", from, to);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n-                let (public_deps, libproc_macro) =\n-                    sysroot_to_crate_graph(&mut crate_graph, sysroot, target, load);\n-\n-                let mut cfg_options = CfgOptions::default();\n-                cfg_options.extend(get_rustc_cfg_options(target));\n-\n-                let mut pkg_to_lib_crate = FxHashMap::default();\n-\n-                // Add test cfg for non-sysroot crates\n-                cfg_options.insert_atom(\"test\".into());\n-                cfg_options.insert_atom(\"debug_assertions\".into());\n-\n-                let mut pkg_crates = FxHashMap::default();\n-\n-                // Next, create crates for each package, target pair\n-                for pkg in cargo.packages() {\n-                    let mut lib_tgt = None;\n-                    for &tgt in cargo[pkg].targets.iter() {\n-                        if let Some(crate_id) = add_target_crate_root(\n-                            &mut crate_graph,\n-                            &cargo[pkg],\n-                            &cargo[tgt],\n-                            &cfg_options,\n-                            proc_macro_client,\n-                            load,\n-                        ) {\n-                            if cargo[tgt].kind == TargetKind::Lib {\n-                                lib_tgt = Some((crate_id, cargo[tgt].name.clone()));\n-                                pkg_to_lib_crate.insert(pkg, crate_id);\n-                            }\n-                            if cargo[tgt].is_proc_macro {\n-                                if let Some(proc_macro) = libproc_macro {\n-                                    if let Err(_) = crate_graph.add_dep(\n-                                        crate_id,\n-                                        CrateName::new(\"proc_macro\").unwrap(),\n-                                        proc_macro,\n-                                    ) {\n-                                        log::error!(\n-                                            \"cyclic dependency on proc_macro for {}\",\n-                                            &cargo[pkg].name\n-                                        )\n-                                    }\n-                                }\n-                            }\n-\n-                            pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n-                        }\n-                    }\n-\n-                    // Set deps to the core, std and to the lib target of the current package\n-                    for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n-                        if let Some((to, name)) = lib_tgt.clone() {\n-                            // For root projects with dashes in their name,\n-                            // cargo metadata does not do any normalization,\n-                            // so we do it ourselves currently\n-                            let name = CrateName::normalize_dashes(&name);\n-                            if to != from && crate_graph.add_dep(from, name, to).is_err() {\n-                                log::error!(\n-                                    \"cyclic dependency between targets of {}\",\n-                                    &cargo[pkg].name\n-                                )\n-                            }\n-                        }\n-                        for (name, krate) in public_deps.iter() {\n-                            if let Err(_) = crate_graph.add_dep(from, name.clone(), *krate) {\n-                                log::error!(\n-                                    \"cyclic dependency on {} for {}\",\n-                                    name,\n-                                    &cargo[pkg].name\n-                                )\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                // Now add a dep edge from all targets of upstream to the lib\n-                // target of downstream.\n-                for pkg in cargo.packages() {\n-                    for dep in cargo[pkg].dependencies.iter() {\n-                        let name = CrateName::new(&dep.name).unwrap();\n-                        if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n-                            for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n-                                if let Err(_) = crate_graph.add_dep(from, name.clone(), to) {\n-                                    log::error!(\n-                                        \"cyclic dependency {} -> {}\",\n-                                        &cargo[pkg].name,\n-                                        &cargo[dep.pkg].name\n-                                    )\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                let mut rustc_pkg_crates = FxHashMap::default();\n-\n-                // If the user provided a path to rustc sources, we add all the rustc_private crates\n-                // and create dependencies on them for the crates in the current workspace\n-                if let Some(rustc_workspace) = rustc {\n-                    for pkg in rustc_workspace.packages() {\n-                        for &tgt in rustc_workspace[pkg].targets.iter() {\n-                            if rustc_workspace[tgt].kind != TargetKind::Lib {\n-                                continue;\n-                            }\n-                            // Exclude alloc / core / std\n-                            if rustc_workspace[tgt]\n-                                .root\n-                                .components()\n-                                .any(|c| c == Component::Normal(\"library\".as_ref()))\n-                            {\n-                                continue;\n-                            }\n-\n-                            if let Some(crate_id) = add_target_crate_root(\n-                                &mut crate_graph,\n-                                &rustc_workspace[pkg],\n-                                &rustc_workspace[tgt],\n-                                &cfg_options,\n-                                proc_macro_client,\n-                                load,\n-                            ) {\n-                                pkg_to_lib_crate.insert(pkg, crate_id);\n-                                // Add dependencies on the core / std / alloc for rustc\n-                                for (name, krate) in public_deps.iter() {\n-                                    if let Err(_) =\n-                                        crate_graph.add_dep(crate_id, name.clone(), *krate)\n-                                    {\n-                                        log::error!(\n-                                            \"cyclic dependency on {} for {}\",\n-                                            name,\n-                                            &cargo[pkg].name\n-                                        )\n-                                    }\n-                                }\n-                                rustc_pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n-                            }\n-                        }\n-                    }\n-                    // Now add a dep edge from all targets of upstream to the lib\n-                    // target of downstream.\n-                    for pkg in rustc_workspace.packages() {\n-                        for dep in rustc_workspace[pkg].dependencies.iter() {\n-                            let name = CrateName::new(&dep.name).unwrap();\n-                            if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n-                                for &from in rustc_pkg_crates.get(&pkg).into_iter().flatten() {\n-                                    if let Err(_) = crate_graph.add_dep(from, name.clone(), to) {\n-                                        log::error!(\n-                                            \"cyclic dependency {} -> {}\",\n-                                            &rustc_workspace[pkg].name,\n-                                            &rustc_workspace[dep.pkg].name\n-                                        )\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-\n-                    // Add dependencies for all the crates of the current workspace to rustc_private libraries\n-                    for dep in rustc_workspace.packages() {\n-                        let name = CrateName::normalize_dashes(&rustc_workspace[dep].name);\n-\n-                        if let Some(&to) = pkg_to_lib_crate.get(&dep) {\n-                            for pkg in cargo.packages() {\n-                                if !cargo[pkg].is_member {\n-                                    continue;\n-                                }\n-                                for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n-                                    if let Err(_) = crate_graph.add_dep(from, name.clone(), to) {\n-                                        log::error!(\n-                                            \"cyclic dependency {} -> {}\",\n-                                            &cargo[pkg].name,\n-                                            &rustc_workspace[dep].name\n-                                        )\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        if crate_graph.patch_cfg_if() {\n-            log::debug!(\"Patched std to depend on cfg-if\")\n-        } else {\n-            log::debug!(\"Did not patch std to depend on cfg-if\")\n-        }\n-        crate_graph\n-    }\n-}\n-\n-fn get_rustc_cfg_options(target: Option<&str>) -> Vec<CfgFlag> {\n-    let mut res = Vec::new();\n-\n-    // Some nightly-only cfgs, which are required for stdlib\n-    res.push(CfgFlag::Atom(\"target_thread_local\".into()));\n-    for &ty in [\"8\", \"16\", \"32\", \"64\", \"cas\", \"ptr\"].iter() {\n-        for &key in [\"target_has_atomic\", \"target_has_atomic_load_store\"].iter() {\n-            res.push(CfgFlag::KeyValue { key: key.to_string(), value: ty.into() });\n-        }\n-    }\n-\n-    let rustc_cfgs = {\n-        let mut cmd = Command::new(toolchain::rustc());\n-        cmd.args(&[\"--print\", \"cfg\", \"-O\"]);\n-        if let Some(target) = target {\n-            cmd.args(&[\"--target\", target]);\n-        }\n-        utf8_stdout(cmd)\n-    };\n-\n-    match rustc_cfgs {\n-        Ok(rustc_cfgs) => res.extend(rustc_cfgs.lines().map(|it| it.parse().unwrap())),\n-        Err(e) => log::error!(\"failed to get rustc cfgs: {:#}\", e),\n-    }\n-\n-    res\n-}\n-\n fn utf8_stdout(mut cmd: Command) -> Result<String> {\n     let output = cmd.output().with_context(|| format!(\"{:?} failed\", cmd))?;\n     if !output.status.success() {\n@@ -627,98 +124,3 @@ fn utf8_stdout(mut cmd: Command) -> Result<String> {\n     let stdout = String::from_utf8(output.stdout)?;\n     Ok(stdout.trim().to_string())\n }\n-\n-fn add_target_crate_root(\n-    crate_graph: &mut CrateGraph,\n-    pkg: &cargo_workspace::PackageData,\n-    tgt: &cargo_workspace::TargetData,\n-    cfg_options: &CfgOptions,\n-    proc_macro_client: &ProcMacroClient,\n-    load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n-) -> Option<CrateId> {\n-    let root = tgt.root.as_path();\n-    if let Some(file_id) = load(root) {\n-        let edition = pkg.edition;\n-        let cfg_options = {\n-            let mut opts = cfg_options.clone();\n-            for feature in pkg.features.iter() {\n-                opts.insert_key_value(\"feature\".into(), feature.into());\n-            }\n-            opts.extend(pkg.cfgs.iter().cloned());\n-            opts\n-        };\n-        let mut env = Env::default();\n-        if let Some(out_dir) = &pkg.out_dir {\n-            // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n-            if let Some(out_dir) = out_dir.to_str().map(|s| s.to_owned()) {\n-                env.set(\"OUT_DIR\", out_dir);\n-            }\n-        }\n-        let proc_macro = pkg\n-            .proc_macro_dylib_path\n-            .as_ref()\n-            .map(|it| proc_macro_client.by_dylib_path(&it))\n-            .unwrap_or_default();\n-\n-        let display_name = CrateDisplayName::from_canonical_name(pkg.name.clone());\n-        let crate_id = crate_graph.add_crate_root(\n-            file_id,\n-            edition,\n-            Some(display_name),\n-            cfg_options,\n-            env,\n-            proc_macro.clone(),\n-        );\n-\n-        return Some(crate_id);\n-    }\n-    None\n-}\n-fn sysroot_to_crate_graph(\n-    crate_graph: &mut CrateGraph,\n-    sysroot: &Sysroot,\n-    target: Option<&str>,\n-    load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n-) -> (Vec<(CrateName, CrateId)>, Option<CrateId>) {\n-    let mut cfg_options = CfgOptions::default();\n-    cfg_options.extend(get_rustc_cfg_options(target));\n-    let sysroot_crates: FxHashMap<_, _> = sysroot\n-        .crates()\n-        .filter_map(|krate| {\n-            let file_id = load(&sysroot[krate].root)?;\n-\n-            let env = Env::default();\n-            let proc_macro = vec![];\n-            let name = CrateName::new(&sysroot[krate].name)\n-                .expect(\"Sysroot crates' names do not contain dashes\");\n-            let crate_id = crate_graph.add_crate_root(\n-                file_id,\n-                Edition::Edition2018,\n-                Some(name.into()),\n-                cfg_options.clone(),\n-                env,\n-                proc_macro,\n-            );\n-            Some((krate, crate_id))\n-        })\n-        .collect();\n-\n-    for from in sysroot.crates() {\n-        for &to in sysroot[from].deps.iter() {\n-            let name = CrateName::new(&sysroot[to].name).unwrap();\n-            if let (Some(&from), Some(&to)) = (sysroot_crates.get(&from), sysroot_crates.get(&to)) {\n-                if let Err(_) = crate_graph.add_dep(from, name, to) {\n-                    log::error!(\"cyclic dependency between sysroot crates\")\n-                }\n-            }\n-        }\n-    }\n-\n-    let public_deps = sysroot\n-        .public_deps()\n-        .map(|(name, idx)| (CrateName::new(name).unwrap(), sysroot_crates[&idx]))\n-        .collect::<Vec<_>>();\n-\n-    let libproc_macro = sysroot.proc_macro().and_then(|it| sysroot_crates.get(&it).copied());\n-    (public_deps, libproc_macro)\n-}"}, {"sha": "9ebb0a811b207b8b714dacd1b7b2a3115cb45176", "filename": "crates/project_model/src/workspace.rs", "status": "added", "additions": 590, "deletions": 0, "changes": 590, "blob_url": "https://github.com/rust-lang/rust/blob/d1ea9d12fa95d8f8915b44b7a993591fd528d2ba/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1ea9d12fa95d8f8915b44b7a993591fd528d2ba/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fworkspace.rs?ref=d1ea9d12fa95d8f8915b44b7a993591fd528d2ba", "patch": "@@ -0,0 +1,590 @@\n+//! Handles lowering of build-system specific workspace information (`cargo\n+//! metadata` or `rust-project.json`) into representation stored in the salsa\n+//! database -- `CrateGraph`.\n+\n+use std::{fmt, fs, path::Component, process::Command};\n+\n+use anyhow::{Context, Result};\n+use base_db::{CrateDisplayName, CrateGraph, CrateId, CrateName, Edition, Env, FileId};\n+use cfg::CfgOptions;\n+use paths::{AbsPath, AbsPathBuf};\n+use proc_macro_api::ProcMacroClient;\n+use rustc_hash::{FxHashMap, FxHashSet};\n+\n+use crate::{\n+    cargo_workspace, cfg_flag::CfgFlag, utf8_stdout, CargoConfig, CargoWorkspace, ProjectJson,\n+    ProjectManifest, Sysroot, TargetKind,\n+};\n+\n+/// `PackageRoot` describes a package root folder.\n+/// Which may be an external dependency, or a member of\n+/// the current workspace.\n+#[derive(Debug, Clone, Eq, PartialEq, Hash)]\n+pub struct PackageRoot {\n+    /// Is a member of the current workspace\n+    pub is_member: bool,\n+    pub include: Vec<AbsPathBuf>,\n+    pub exclude: Vec<AbsPathBuf>,\n+}\n+\n+#[derive(Clone, Eq, PartialEq)]\n+pub enum ProjectWorkspace {\n+    /// Project workspace was discovered by running `cargo metadata` and `rustc --print sysroot`.\n+    Cargo { cargo: CargoWorkspace, sysroot: Sysroot, rustc: Option<CargoWorkspace> },\n+    /// Project workspace was manually specified using a `rust-project.json` file.\n+    Json { project: ProjectJson, sysroot: Option<Sysroot> },\n+}\n+\n+impl fmt::Debug for ProjectWorkspace {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => f\n+                .debug_struct(\"Cargo\")\n+                .field(\"n_packages\", &cargo.packages().len())\n+                .field(\"n_sysroot_crates\", &sysroot.crates().len())\n+                .field(\n+                    \"n_rustc_compiler_crates\",\n+                    &rustc.as_ref().map_or(0, |rc| rc.packages().len()),\n+                )\n+                .finish(),\n+            ProjectWorkspace::Json { project, sysroot } => {\n+                let mut debug_struct = f.debug_struct(\"Json\");\n+                debug_struct.field(\"n_crates\", &project.n_crates());\n+                if let Some(sysroot) = sysroot {\n+                    debug_struct.field(\"n_sysroot_crates\", &sysroot.crates().len());\n+                }\n+                debug_struct.finish()\n+            }\n+        }\n+    }\n+}\n+\n+impl ProjectWorkspace {\n+    pub fn load(manifest: ProjectManifest, config: &CargoConfig) -> Result<ProjectWorkspace> {\n+        let res = match manifest {\n+            ProjectManifest::ProjectJson(project_json) => {\n+                let file = fs::read_to_string(&project_json).with_context(|| {\n+                    format!(\"Failed to read json file {}\", project_json.display())\n+                })?;\n+                let data = serde_json::from_str(&file).with_context(|| {\n+                    format!(\"Failed to deserialize json file {}\", project_json.display())\n+                })?;\n+                let project_location = project_json.parent().unwrap().to_path_buf();\n+                let project = ProjectJson::new(&project_location, data);\n+                let sysroot = match &project.sysroot_src {\n+                    Some(path) => Some(Sysroot::load(path)?),\n+                    None => None,\n+                };\n+                ProjectWorkspace::Json { project, sysroot }\n+            }\n+            ProjectManifest::CargoToml(cargo_toml) => {\n+                let cargo_version = utf8_stdout({\n+                    let mut cmd = Command::new(toolchain::cargo());\n+                    cmd.arg(\"--version\");\n+                    cmd\n+                })?;\n+\n+                let cargo = CargoWorkspace::from_cargo_metadata(&cargo_toml, config).with_context(\n+                    || {\n+                        format!(\n+                            \"Failed to read Cargo metadata from Cargo.toml file {}, {}\",\n+                            cargo_toml.display(),\n+                            cargo_version\n+                        )\n+                    },\n+                )?;\n+                let sysroot = if config.no_sysroot {\n+                    Sysroot::default()\n+                } else {\n+                    Sysroot::discover(&cargo_toml).with_context(|| {\n+                        format!(\n+                            \"Failed to find sysroot for Cargo.toml file {}. Is rust-src installed?\",\n+                            cargo_toml.display()\n+                        )\n+                    })?\n+                };\n+\n+                let rustc = if let Some(rustc_dir) = &config.rustc_source {\n+                    Some(CargoWorkspace::from_cargo_metadata(&rustc_dir, config).with_context(\n+                        || format!(\"Failed to read Cargo metadata for Rust sources\"),\n+                    )?)\n+                } else {\n+                    None\n+                };\n+\n+                ProjectWorkspace::Cargo { cargo, sysroot, rustc }\n+            }\n+        };\n+\n+        Ok(res)\n+    }\n+\n+    pub fn load_inline(project_json: ProjectJson) -> Result<ProjectWorkspace> {\n+        let sysroot = match &project_json.sysroot_src {\n+            Some(path) => Some(Sysroot::load(path)?),\n+            None => None,\n+        };\n+\n+        Ok(ProjectWorkspace::Json { project: project_json, sysroot })\n+    }\n+\n+    /// Returns the roots for the current `ProjectWorkspace`\n+    /// The return type contains the path and whether or not\n+    /// the root is a member of the current workspace\n+    pub fn to_roots(&self) -> Vec<PackageRoot> {\n+        match self {\n+            ProjectWorkspace::Json { project, sysroot } => project\n+                .crates()\n+                .map(|(_, krate)| PackageRoot {\n+                    is_member: krate.is_workspace_member,\n+                    include: krate.include.clone(),\n+                    exclude: krate.exclude.clone(),\n+                })\n+                .collect::<FxHashSet<_>>()\n+                .into_iter()\n+                .chain(sysroot.as_ref().into_iter().flat_map(|sysroot| {\n+                    sysroot.crates().map(move |krate| PackageRoot {\n+                        is_member: false,\n+                        include: vec![sysroot[krate].root_dir().to_path_buf()],\n+                        exclude: Vec::new(),\n+                    })\n+                }))\n+                .collect::<Vec<_>>(),\n+            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n+                let roots = cargo\n+                    .packages()\n+                    .map(|pkg| {\n+                        let is_member = cargo[pkg].is_member;\n+                        let pkg_root = cargo[pkg].root().to_path_buf();\n+\n+                        let mut include = vec![pkg_root.clone()];\n+                        include.extend(cargo[pkg].out_dir.clone());\n+\n+                        let mut exclude = vec![pkg_root.join(\".git\")];\n+                        if is_member {\n+                            exclude.push(pkg_root.join(\"target\"));\n+                        } else {\n+                            exclude.push(pkg_root.join(\"tests\"));\n+                            exclude.push(pkg_root.join(\"examples\"));\n+                            exclude.push(pkg_root.join(\"benches\"));\n+                        }\n+                        PackageRoot { is_member, include, exclude }\n+                    })\n+                    .chain(sysroot.crates().map(|krate| PackageRoot {\n+                        is_member: false,\n+                        include: vec![sysroot[krate].root_dir().to_path_buf()],\n+                        exclude: Vec::new(),\n+                    }));\n+                if let Some(rustc_packages) = rustc {\n+                    roots\n+                        .chain(rustc_packages.packages().map(|krate| PackageRoot {\n+                            is_member: false,\n+                            include: vec![rustc_packages[krate].root().to_path_buf()],\n+                            exclude: Vec::new(),\n+                        }))\n+                        .collect()\n+                } else {\n+                    roots.collect()\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn n_packages(&self) -> usize {\n+        match self {\n+            ProjectWorkspace::Json { project, .. } => project.n_crates(),\n+            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n+                let rustc_package_len = rustc.as_ref().map_or(0, |rc| rc.packages().len());\n+                cargo.packages().len() + sysroot.crates().len() + rustc_package_len\n+            }\n+        }\n+    }\n+\n+    pub fn to_crate_graph(\n+        &self,\n+        target: Option<&str>,\n+        proc_macro_client: &ProcMacroClient,\n+        load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n+    ) -> CrateGraph {\n+        let mut crate_graph = CrateGraph::default();\n+        match self {\n+            ProjectWorkspace::Json { project, sysroot } => {\n+                let sysroot_dps = sysroot\n+                    .as_ref()\n+                    .map(|sysroot| sysroot_to_crate_graph(&mut crate_graph, sysroot, target, load));\n+\n+                let mut cfg_cache: FxHashMap<Option<&str>, Vec<CfgFlag>> = FxHashMap::default();\n+                let crates: FxHashMap<_, _> = project\n+                    .crates()\n+                    .filter_map(|(crate_id, krate)| {\n+                        let file_path = &krate.root_module;\n+                        let file_id = match load(&file_path) {\n+                            Some(id) => id,\n+                            None => {\n+                                log::error!(\"failed to load crate root {}\", file_path.display());\n+                                return None;\n+                            }\n+                        };\n+\n+                        let env = krate.env.clone().into_iter().collect();\n+                        let proc_macro = krate\n+                            .proc_macro_dylib_path\n+                            .clone()\n+                            .map(|it| proc_macro_client.by_dylib_path(&it));\n+\n+                        let target = krate.target.as_deref().or(target);\n+                        let target_cfgs = cfg_cache\n+                            .entry(target)\n+                            .or_insert_with(|| get_rustc_cfg_options(target));\n+\n+                        let mut cfg_options = CfgOptions::default();\n+                        cfg_options.extend(target_cfgs.iter().chain(krate.cfg.iter()).cloned());\n+\n+                        Some((\n+                            crate_id,\n+                            crate_graph.add_crate_root(\n+                                file_id,\n+                                krate.edition,\n+                                krate.display_name.clone(),\n+                                cfg_options,\n+                                env,\n+                                proc_macro.unwrap_or_default(),\n+                            ),\n+                        ))\n+                    })\n+                    .collect();\n+\n+                for (from, krate) in project.crates() {\n+                    if let Some(&from) = crates.get(&from) {\n+                        if let Some((public_deps, _proc_macro)) = &sysroot_dps {\n+                            for (name, to) in public_deps.iter() {\n+                                if let Err(_) = crate_graph.add_dep(from, name.clone(), *to) {\n+                                    log::error!(\"cyclic dependency on {} for {:?}\", name, from)\n+                                }\n+                            }\n+                        }\n+\n+                        for dep in &krate.deps {\n+                            let to_crate_id = dep.crate_id;\n+                            if let Some(&to) = crates.get(&to_crate_id) {\n+                                if let Err(_) = crate_graph.add_dep(from, dep.name.clone(), to) {\n+                                    log::error!(\"cyclic dependency {:?} -> {:?}\", from, to);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            ProjectWorkspace::Cargo { cargo, sysroot, rustc } => {\n+                let (public_deps, libproc_macro) =\n+                    sysroot_to_crate_graph(&mut crate_graph, sysroot, target, load);\n+\n+                let mut cfg_options = CfgOptions::default();\n+                cfg_options.extend(get_rustc_cfg_options(target));\n+\n+                let mut pkg_to_lib_crate = FxHashMap::default();\n+\n+                // Add test cfg for non-sysroot crates\n+                cfg_options.insert_atom(\"test\".into());\n+                cfg_options.insert_atom(\"debug_assertions\".into());\n+\n+                let mut pkg_crates = FxHashMap::default();\n+\n+                // Next, create crates for each package, target pair\n+                for pkg in cargo.packages() {\n+                    let mut lib_tgt = None;\n+                    for &tgt in cargo[pkg].targets.iter() {\n+                        if let Some(crate_id) = add_target_crate_root(\n+                            &mut crate_graph,\n+                            &cargo[pkg],\n+                            &cargo[tgt],\n+                            &cfg_options,\n+                            proc_macro_client,\n+                            load,\n+                        ) {\n+                            if cargo[tgt].kind == TargetKind::Lib {\n+                                lib_tgt = Some((crate_id, cargo[tgt].name.clone()));\n+                                pkg_to_lib_crate.insert(pkg, crate_id);\n+                            }\n+                            if cargo[tgt].is_proc_macro {\n+                                if let Some(proc_macro) = libproc_macro {\n+                                    if let Err(_) = crate_graph.add_dep(\n+                                        crate_id,\n+                                        CrateName::new(\"proc_macro\").unwrap(),\n+                                        proc_macro,\n+                                    ) {\n+                                        log::error!(\n+                                            \"cyclic dependency on proc_macro for {}\",\n+                                            &cargo[pkg].name\n+                                        )\n+                                    }\n+                                }\n+                            }\n+\n+                            pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n+                        }\n+                    }\n+\n+                    // Set deps to the core, std and to the lib target of the current package\n+                    for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+                        if let Some((to, name)) = lib_tgt.clone() {\n+                            // For root projects with dashes in their name,\n+                            // cargo metadata does not do any normalization,\n+                            // so we do it ourselves currently\n+                            let name = CrateName::normalize_dashes(&name);\n+                            if to != from && crate_graph.add_dep(from, name, to).is_err() {\n+                                log::error!(\n+                                    \"cyclic dependency between targets of {}\",\n+                                    &cargo[pkg].name\n+                                )\n+                            }\n+                        }\n+                        for (name, krate) in public_deps.iter() {\n+                            if let Err(_) = crate_graph.add_dep(from, name.clone(), *krate) {\n+                                log::error!(\n+                                    \"cyclic dependency on {} for {}\",\n+                                    name,\n+                                    &cargo[pkg].name\n+                                )\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // Now add a dep edge from all targets of upstream to the lib\n+                // target of downstream.\n+                for pkg in cargo.packages() {\n+                    for dep in cargo[pkg].dependencies.iter() {\n+                        let name = CrateName::new(&dep.name).unwrap();\n+                        if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n+                            for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+                                if let Err(_) = crate_graph.add_dep(from, name.clone(), to) {\n+                                    log::error!(\n+                                        \"cyclic dependency {} -> {}\",\n+                                        &cargo[pkg].name,\n+                                        &cargo[dep.pkg].name\n+                                    )\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                let mut rustc_pkg_crates = FxHashMap::default();\n+\n+                // If the user provided a path to rustc sources, we add all the rustc_private crates\n+                // and create dependencies on them for the crates in the current workspace\n+                if let Some(rustc_workspace) = rustc {\n+                    for pkg in rustc_workspace.packages() {\n+                        for &tgt in rustc_workspace[pkg].targets.iter() {\n+                            if rustc_workspace[tgt].kind != TargetKind::Lib {\n+                                continue;\n+                            }\n+                            // Exclude alloc / core / std\n+                            if rustc_workspace[tgt]\n+                                .root\n+                                .components()\n+                                .any(|c| c == Component::Normal(\"library\".as_ref()))\n+                            {\n+                                continue;\n+                            }\n+\n+                            if let Some(crate_id) = add_target_crate_root(\n+                                &mut crate_graph,\n+                                &rustc_workspace[pkg],\n+                                &rustc_workspace[tgt],\n+                                &cfg_options,\n+                                proc_macro_client,\n+                                load,\n+                            ) {\n+                                pkg_to_lib_crate.insert(pkg, crate_id);\n+                                // Add dependencies on the core / std / alloc for rustc\n+                                for (name, krate) in public_deps.iter() {\n+                                    if let Err(_) =\n+                                        crate_graph.add_dep(crate_id, name.clone(), *krate)\n+                                    {\n+                                        log::error!(\n+                                            \"cyclic dependency on {} for {}\",\n+                                            name,\n+                                            &cargo[pkg].name\n+                                        )\n+                                    }\n+                                }\n+                                rustc_pkg_crates.entry(pkg).or_insert_with(Vec::new).push(crate_id);\n+                            }\n+                        }\n+                    }\n+                    // Now add a dep edge from all targets of upstream to the lib\n+                    // target of downstream.\n+                    for pkg in rustc_workspace.packages() {\n+                        for dep in rustc_workspace[pkg].dependencies.iter() {\n+                            let name = CrateName::new(&dep.name).unwrap();\n+                            if let Some(&to) = pkg_to_lib_crate.get(&dep.pkg) {\n+                                for &from in rustc_pkg_crates.get(&pkg).into_iter().flatten() {\n+                                    if let Err(_) = crate_graph.add_dep(from, name.clone(), to) {\n+                                        log::error!(\n+                                            \"cyclic dependency {} -> {}\",\n+                                            &rustc_workspace[pkg].name,\n+                                            &rustc_workspace[dep.pkg].name\n+                                        )\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    // Add dependencies for all the crates of the current workspace to rustc_private libraries\n+                    for dep in rustc_workspace.packages() {\n+                        let name = CrateName::normalize_dashes(&rustc_workspace[dep].name);\n+\n+                        if let Some(&to) = pkg_to_lib_crate.get(&dep) {\n+                            for pkg in cargo.packages() {\n+                                if !cargo[pkg].is_member {\n+                                    continue;\n+                                }\n+                                for &from in pkg_crates.get(&pkg).into_iter().flatten() {\n+                                    if let Err(_) = crate_graph.add_dep(from, name.clone(), to) {\n+                                        log::error!(\n+                                            \"cyclic dependency {} -> {}\",\n+                                            &cargo[pkg].name,\n+                                            &rustc_workspace[dep].name\n+                                        )\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if crate_graph.patch_cfg_if() {\n+            log::debug!(\"Patched std to depend on cfg-if\")\n+        } else {\n+            log::debug!(\"Did not patch std to depend on cfg-if\")\n+        }\n+        crate_graph\n+    }\n+}\n+\n+fn add_target_crate_root(\n+    crate_graph: &mut CrateGraph,\n+    pkg: &cargo_workspace::PackageData,\n+    tgt: &cargo_workspace::TargetData,\n+    cfg_options: &CfgOptions,\n+    proc_macro_client: &ProcMacroClient,\n+    load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n+) -> Option<CrateId> {\n+    let root = tgt.root.as_path();\n+    if let Some(file_id) = load(root) {\n+        let edition = pkg.edition;\n+        let cfg_options = {\n+            let mut opts = cfg_options.clone();\n+            for feature in pkg.features.iter() {\n+                opts.insert_key_value(\"feature\".into(), feature.into());\n+            }\n+            opts.extend(pkg.cfgs.iter().cloned());\n+            opts\n+        };\n+        let mut env = Env::default();\n+        if let Some(out_dir) = &pkg.out_dir {\n+            // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n+            if let Some(out_dir) = out_dir.to_str().map(|s| s.to_owned()) {\n+                env.set(\"OUT_DIR\", out_dir);\n+            }\n+        }\n+        let proc_macro = pkg\n+            .proc_macro_dylib_path\n+            .as_ref()\n+            .map(|it| proc_macro_client.by_dylib_path(&it))\n+            .unwrap_or_default();\n+\n+        let display_name = CrateDisplayName::from_canonical_name(pkg.name.clone());\n+        let crate_id = crate_graph.add_crate_root(\n+            file_id,\n+            edition,\n+            Some(display_name),\n+            cfg_options,\n+            env,\n+            proc_macro.clone(),\n+        );\n+\n+        return Some(crate_id);\n+    }\n+    None\n+}\n+fn sysroot_to_crate_graph(\n+    crate_graph: &mut CrateGraph,\n+    sysroot: &Sysroot,\n+    target: Option<&str>,\n+    load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n+) -> (Vec<(CrateName, CrateId)>, Option<CrateId>) {\n+    let mut cfg_options = CfgOptions::default();\n+    cfg_options.extend(get_rustc_cfg_options(target));\n+    let sysroot_crates: FxHashMap<_, _> = sysroot\n+        .crates()\n+        .filter_map(|krate| {\n+            let file_id = load(&sysroot[krate].root)?;\n+\n+            let env = Env::default();\n+            let proc_macro = vec![];\n+            let name = CrateName::new(&sysroot[krate].name)\n+                .expect(\"Sysroot crates' names do not contain dashes\");\n+            let crate_id = crate_graph.add_crate_root(\n+                file_id,\n+                Edition::Edition2018,\n+                Some(name.into()),\n+                cfg_options.clone(),\n+                env,\n+                proc_macro,\n+            );\n+            Some((krate, crate_id))\n+        })\n+        .collect();\n+\n+    for from in sysroot.crates() {\n+        for &to in sysroot[from].deps.iter() {\n+            let name = CrateName::new(&sysroot[to].name).unwrap();\n+            if let (Some(&from), Some(&to)) = (sysroot_crates.get(&from), sysroot_crates.get(&to)) {\n+                if let Err(_) = crate_graph.add_dep(from, name, to) {\n+                    log::error!(\"cyclic dependency between sysroot crates\")\n+                }\n+            }\n+        }\n+    }\n+\n+    let public_deps = sysroot\n+        .public_deps()\n+        .map(|(name, idx)| (CrateName::new(name).unwrap(), sysroot_crates[&idx]))\n+        .collect::<Vec<_>>();\n+\n+    let libproc_macro = sysroot.proc_macro().and_then(|it| sysroot_crates.get(&it).copied());\n+    (public_deps, libproc_macro)\n+}\n+\n+fn get_rustc_cfg_options(target: Option<&str>) -> Vec<CfgFlag> {\n+    let mut res = Vec::new();\n+\n+    // Some nightly-only cfgs, which are required for stdlib\n+    res.push(CfgFlag::Atom(\"target_thread_local\".into()));\n+    for &ty in [\"8\", \"16\", \"32\", \"64\", \"cas\", \"ptr\"].iter() {\n+        for &key in [\"target_has_atomic\", \"target_has_atomic_load_store\"].iter() {\n+            res.push(CfgFlag::KeyValue { key: key.to_string(), value: ty.into() });\n+        }\n+    }\n+\n+    let rustc_cfgs = {\n+        let mut cmd = Command::new(toolchain::rustc());\n+        cmd.args(&[\"--print\", \"cfg\", \"-O\"]);\n+        if let Some(target) = target {\n+            cmd.args(&[\"--target\", target]);\n+        }\n+        utf8_stdout(cmd)\n+    };\n+\n+    match rustc_cfgs {\n+        Ok(rustc_cfgs) => res.extend(rustc_cfgs.lines().map(|it| it.parse().unwrap())),\n+        Err(e) => log::error!(\"failed to get rustc cfgs: {:#}\", e),\n+    }\n+\n+    res\n+}"}, {"sha": "76526c66c038a4eb224327e063e198b65b8948d1", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d1ea9d12fa95d8f8915b44b7a993591fd528d2ba/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1ea9d12fa95d8f8915b44b7a993591fd528d2ba/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=d1ea9d12fa95d8f8915b44b7a993591fd528d2ba", "patch": "@@ -21,7 +21,6 @@ pub fn load_cargo(\n     let ws = ProjectWorkspace::load(\n         root,\n         &CargoConfig { load_out_dirs_from_check, ..Default::default() },\n-        true,\n     )?;\n \n     let (sender, receiver) = unbounded();"}, {"sha": "d16796590087947737db0eb0e231d1b4dba43d07", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d1ea9d12fa95d8f8915b44b7a993591fd528d2ba/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1ea9d12fa95d8f8915b44b7a993591fd528d2ba/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=d1ea9d12fa95d8f8915b44b7a993591fd528d2ba", "patch": "@@ -49,7 +49,6 @@ pub struct Config {\n     pub hover: HoverConfig,\n     pub semantic_tokens_refresh: bool,\n \n-    pub with_sysroot: bool,\n     pub linked_projects: Vec<LinkedProject>,\n     pub root_path: AbsPathBuf,\n }\n@@ -155,7 +154,6 @@ impl Config {\n         Config {\n             client_caps: ClientCapsConfig::default(),\n \n-            with_sysroot: true,\n             publish_diagnostics: true,\n             diagnostics: DiagnosticsConfig::default(),\n             diagnostics_map: DiagnosticsMapConfig::default(),\n@@ -209,7 +207,6 @@ impl Config {\n \n         let data = ConfigData::from_json(json);\n \n-        self.with_sysroot = data.withSysroot;\n         self.publish_diagnostics = data.diagnostics_enable;\n         self.diagnostics = DiagnosticsConfig {\n             disable_experimental: !data.diagnostics_enableExperimental,\n@@ -246,6 +243,7 @@ impl Config {\n             load_out_dirs_from_check: data.cargo_loadOutDirsFromCheck,\n             target: data.cargo_target.clone(),\n             rustc_source: rustc_source,\n+            no_sysroot: data.cargo_noSysroot,\n         };\n         self.runnables = RunnablesConfig {\n             override_cargo: data.runnables_overrideCargo,\n@@ -492,6 +490,7 @@ config_data! {\n         cargo_loadOutDirsFromCheck: bool = false,\n         cargo_noDefaultFeatures: bool    = false,\n         cargo_target: Option<String>     = None,\n+        cargo_noSysroot: bool            = false,\n \n         checkOnSave_enable: bool                         = true,\n         checkOnSave_allFeatures: Option<bool>            = None,\n@@ -544,7 +543,6 @@ config_data! {\n         rustfmt_extraArgs: Vec<String>               = Vec::new(),\n         rustfmt_overrideCommand: Option<Vec<String>> = None,\n \n-        withSysroot: bool = true,\n         rustcSource : Option<String> = None,\n     }\n }"}, {"sha": "fa6e09f42bda25b4d89999dae8888b004e225fc1", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d1ea9d12fa95d8f8915b44b7a993591fd528d2ba/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1ea9d12fa95d8f8915b44b7a993591fd528d2ba/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=d1ea9d12fa95d8f8915b44b7a993591fd528d2ba", "patch": "@@ -96,17 +96,12 @@ impl GlobalState {\n         self.task_pool.handle.spawn({\n             let linked_projects = self.config.linked_projects.clone();\n             let cargo_config = self.config.cargo.clone();\n-            let with_sysroot = self.config.with_sysroot.clone();\n             move || {\n                 let workspaces = linked_projects\n                     .iter()\n                     .map(|project| match project {\n                         LinkedProject::ProjectManifest(manifest) => {\n-                            project_model::ProjectWorkspace::load(\n-                                manifest.clone(),\n-                                &cargo_config,\n-                                with_sysroot,\n-                            )\n+                            project_model::ProjectWorkspace::load(manifest.clone(), &cargo_config)\n                         }\n                         LinkedProject::InlineJsonProject(it) => {\n                             project_model::ProjectWorkspace::load_inline(it.clone())"}, {"sha": "b210b98f0d5cf598f77733f3068f66d27fee3518", "filename": "crates/rust-analyzer/tests/rust-analyzer/support.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1ea9d12fa95d8f8915b44b7a993591fd528d2ba/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1ea9d12fa95d8f8915b44b7a993591fd528d2ba/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fsupport.rs?ref=d1ea9d12fa95d8f8915b44b7a993591fd528d2ba", "patch": "@@ -12,7 +12,7 @@ use lsp_types::{\n     notification::Exit, request::Shutdown, TextDocumentIdentifier, Url, WorkDoneProgress,\n };\n use lsp_types::{ProgressParams, ProgressParamsValue};\n-use project_model::ProjectManifest;\n+use project_model::{CargoConfig, ProjectManifest};\n use rust_analyzer::{\n     config::{ClientCapsConfig, Config, FilesConfig, FilesWatcher, LinkedProject},\n     main_loop,\n@@ -47,8 +47,8 @@ impl<'a> Project<'a> {\n         self\n     }\n \n-    pub(crate) fn with_sysroot(mut self, sysroot: bool) -> Project<'a> {\n-        self.with_sysroot = sysroot;\n+    pub(crate) fn with_sysroot(mut self, yes: bool) -> Project<'a> {\n+        self.with_sysroot = yes;\n         self\n     }\n \n@@ -90,7 +90,7 @@ impl<'a> Project<'a> {\n                 work_done_progress: true,\n                 ..Default::default()\n             },\n-            with_sysroot: self.with_sysroot,\n+            cargo: CargoConfig { no_sysroot: !self.with_sysroot, ..Default::default() },\n             linked_projects,\n             files: FilesConfig { watcher: FilesWatcher::Client, exclude: Vec::new() },\n             ..Config::new(tmp_dir_path)"}, {"sha": "220d44abc8f6e77d386d0da71b8420b71a9ef347", "filename": "editors/code/package.json", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1ea9d12fa95d8f8915b44b7a993591fd528d2ba/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/d1ea9d12fa95d8f8915b44b7a993591fd528d2ba/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=d1ea9d12fa95d8f8915b44b7a993591fd528d2ba", "patch": "@@ -283,6 +283,11 @@\n                     \"default\": null,\n                     \"description\": \"Specify the compilation target\"\n                 },\n+                \"rust-analyzer.noSysroot\": {\n+                    \"markdownDescription\": \"Internal config for debugging, disables loading of sysroot crates\",\n+                    \"type\": \"boolean\",\n+                    \"default\": false\n+                },\n                 \"rust-analyzer.rustfmt.extraArgs\": {\n                     \"type\": \"array\",\n                     \"items\": {\n@@ -605,11 +610,6 @@\n                     },\n                     \"default\": null\n                 },\n-                \"rust-analyzer.withSysroot\": {\n-                    \"markdownDescription\": \"Internal config for debugging, disables loading of sysroot crates\",\n-                    \"type\": \"boolean\",\n-                    \"default\": true\n-                },\n                 \"rust-analyzer.diagnostics.enable\": {\n                     \"type\": \"boolean\",\n                     \"default\": true,"}]}