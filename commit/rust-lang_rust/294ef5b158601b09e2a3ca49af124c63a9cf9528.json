{"sha": "294ef5b158601b09e2a3ca49af124c63a9cf9528", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5NGVmNWIxNTg2MDFiMDllMmEzY2E0OWFmMTI0YzYzYTljZjk1Mjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-14T07:24:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-14T07:24:36Z"}, "message": "Auto merge of #29039 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #28991, #29004, #29006, #29013, #29016, #29024, #29027, #29028, #29029, #29032, #29035\n- Failed merges:", "tree": {"sha": "953903e5f926818305cbd3558f119e9baee5d1db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/953903e5f926818305cbd3558f119e9baee5d1db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/294ef5b158601b09e2a3ca49af124c63a9cf9528", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/294ef5b158601b09e2a3ca49af124c63a9cf9528", "html_url": "https://github.com/rust-lang/rust/commit/294ef5b158601b09e2a3ca49af124c63a9cf9528", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/294ef5b158601b09e2a3ca49af124c63a9cf9528/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "293966694c3c8e0c7028e8f54340fbc328d85bff", "url": "https://api.github.com/repos/rust-lang/rust/commits/293966694c3c8e0c7028e8f54340fbc328d85bff", "html_url": "https://github.com/rust-lang/rust/commit/293966694c3c8e0c7028e8f54340fbc328d85bff"}, {"sha": "66b58d19bdeceba7aa3f4043fefd796f8c8b426c", "url": "https://api.github.com/repos/rust-lang/rust/commits/66b58d19bdeceba7aa3f4043fefd796f8c8b426c", "html_url": "https://github.com/rust-lang/rust/commit/66b58d19bdeceba7aa3f4043fefd796f8c8b426c"}], "stats": {"total": 787, "additions": 515, "deletions": 272}, "files": [{"sha": "2486679baaf0a50c16a6a3fd325b20824878940e", "filename": "src/doc/reference.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=294ef5b158601b09e2a3ca49af124c63a9cf9528", "patch": "@@ -1435,11 +1435,11 @@ struct Foo;\n \n trait Shape { fn area(&self) -> f64; }\n trait Circle : Shape { fn radius(&self) -> f64; }\n-# impl Shape for Foo {\n-#     fn area(&self) -> f64 {\n-#         0.0\n-#     }\n-# }\n+impl Shape for Foo {\n+    fn area(&self) -> f64 {\n+        0.0\n+    }\n+}\n impl Circle for Foo {\n     fn radius(&self) -> f64 {\n         println!(\"calling area: {}\", self.area());"}, {"sha": "13265ab1eba12f1444e7382865021ddf027d9fdf", "filename": "src/doc/trpl/lifetimes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Fdoc%2Ftrpl%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Fdoc%2Ftrpl%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flifetimes.md?ref=294ef5b158601b09e2a3ca49af124c63a9cf9528", "patch": "@@ -74,7 +74,7 @@ associated with it, but the compiler lets you elide (i.e. omit, see\n [\"Lifetime Elision\"][lifetime-elision] below) them in common cases.\n Before we get to that, though, let\u2019s break the explicit example down:\n \n-[lifetime-elision]: #user-content-lifetime-elision\n+[lifetime-elision]: #lifetime-elision\n \n ```rust,ignore\n fn bar<'a>(...)"}, {"sha": "834ba91a828d5b2d6be5f5c2126b48f45380a0cb", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 109, "deletions": 1, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=294ef5b158601b09e2a3ca49af124c63a9cf9528", "patch": "@@ -3032,7 +3032,52 @@ impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     fn next_back(&mut self) -> Option<A> { Some(self.element.clone()) }\n }\n \n-/// Creates a new iterator that endlessly repeats the element `elt`.\n+/// Creates a new iterator that endlessly repeats a single element.\n+///\n+/// The `repeat()` function repeats a single value over and over and over and\n+/// over and over and \ud83d\udd01.\n+///\n+/// Infinite iterators like `repeat()` are often used with adapters like\n+/// [`take()`], in order to make them finite.\n+///\n+/// [`take()`]: trait.Iterator.html#method.take\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // the number four 4ever:\n+/// let mut fours = iter::repeat(4);\n+///\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+///\n+/// // yup, still four\n+/// assert_eq!(Some(4), fours.next());\n+/// ```\n+///\n+/// Going finite with [`take()`]:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // that last example was too many fours. Let's only have four fours.\n+/// let mut four_fours = iter::repeat(4).take(4);\n+///\n+/// assert_eq!(Some(4), four_fours.next());\n+/// assert_eq!(Some(4), four_fours.next());\n+/// assert_eq!(Some(4), four_fours.next());\n+/// assert_eq!(Some(4), four_fours.next());\n+///\n+/// // ... and now we're done\n+/// assert_eq!(None, four_fours.next());\n+/// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n@@ -3089,6 +3134,19 @@ impl<T> Default for Empty<T> {\n }\n \n /// Creates an iterator that yields nothing.\n+///\n+/// # Exampes\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // this could have been an iterator over i32, but alas, it's just not.\n+/// let mut nope = iter::empty::<i32>();\n+///\n+/// assert_eq!(None, nope.next());\n+/// ```\n #[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n pub fn empty<T>() -> Empty<T> {\n     Empty(marker::PhantomData)\n@@ -3129,6 +3187,56 @@ impl<T> ExactSizeIterator for Once<T> {\n }\n \n /// Creates an iterator that yields an element exactly once.\n+///\n+/// This is commonly used to adapt a single value into a [`chain()`] of other\n+/// kinds of iteration. Maybe you have an iterator that covers almost\n+/// everything, but you need an extra special case. Maybe you have a function\n+/// which works on iterators, but you only need to process one value.\n+///\n+/// [`chain()`]: trait.Iterator.html#method.chain\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // one is the loneliest number\n+/// let mut one = iter::once(1);\n+///\n+/// assert_eq!(Some(1), one.next());\n+///\n+/// // just one, that's all we get\n+/// assert_eq!(None, one.next());\n+/// ```\n+///\n+/// Chaining together with another iterator. Let's say that we want to iterate\n+/// over each file of the `.foo` directory, but also a configuration file,\n+/// `.foorc`:\n+///\n+/// ```no_run\n+/// use std::iter;\n+/// use std::fs;\n+/// use std::path::PathBuf;\n+///\n+/// let dirs = fs::read_dir(\".foo\").unwrap();\n+///\n+/// // we need to convert from an iterator of DirEntry-s to an iterator of\n+/// // PathBufs, so we use map\n+/// let dirs = dirs.map(|file| file.unwrap().path());\n+///\n+/// // now, our iterator just for our config file\n+/// let config = iter::once(PathBuf::from(\".foorc\"));\n+///\n+/// // chain the two iterators together into one big iterator\n+/// let files = dirs.chain(config);\n+///\n+/// // this will give us all of the files in .foo as well as .foorc\n+/// for f in files {\n+///     println!(\"{:?}\", f);\n+/// }\n+/// ```\n #[stable(feature = \"iter_once\", since = \"1.2.0\")]\n pub fn once<T>(value: T) -> Once<T> {\n     Once { inner: Some(value).into_iter() }"}, {"sha": "41571366af5d41cf82985e20c10034c58cf6d2c8", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 220, "deletions": 160, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=294ef5b158601b09e2a3ca49af124c63a9cf9528", "patch": "@@ -75,7 +75,7 @@ pub struct FormatSpec<'a> {\n     /// The descriptor string representing the name of the format desired for\n     /// this argument, this can be empty or any number of characters, although\n     /// it is required to be one word.\n-    pub ty: &'a str\n+    pub ty: &'a str,\n }\n \n /// Enum describing where an argument for a format can be located.\n@@ -202,7 +202,12 @@ impl<'a> Parser<'a> {\n     /// returned, otherwise the character is consumed and true is returned.\n     fn consume(&mut self, c: char) -> bool {\n         if let Some(&(_, maybe)) = self.cur.peek() {\n-            if c == maybe { self.cur.next(); true } else { false }\n+            if c == maybe {\n+                self.cur.next();\n+                true\n+            } else {\n+                false\n+            }\n         } else {\n             false\n         }\n@@ -227,7 +232,11 @@ impl<'a> Parser<'a> {\n     /// character\n     fn ws(&mut self) {\n         while let Some(&(_, c)) = self.cur.peek() {\n-            if c.is_whitespace() { self.cur.next(); } else { break }\n+            if c.is_whitespace() {\n+                self.cur.next();\n+            } else {\n+                break\n+            }\n         }\n     }\n \n@@ -237,8 +246,12 @@ impl<'a> Parser<'a> {\n         // we may not consume the character, peek the iterator\n         while let Some(&(pos, c)) = self.cur.peek() {\n             match c {\n-                '{' | '}' => { return &self.input[start..pos]; }\n-                _ => { self.cur.next(); }\n+                '{' | '}' => {\n+                    return &self.input[start..pos];\n+                }\n+                _ => {\n+                    self.cur.next();\n+                }\n             }\n         }\n         &self.input[start..self.input.len()]\n@@ -263,7 +276,7 @@ impl<'a> Parser<'a> {\n                 Some(&(_, c)) if c.is_alphabetic() => {\n                     ArgumentNamed(self.word())\n                 }\n-                _ => ArgumentNext\n+                _ => ArgumentNext,\n             }\n         }\n     }\n@@ -279,7 +292,9 @@ impl<'a> Parser<'a> {\n             width: CountImplied,\n             ty: &self.input[..0],\n         };\n-        if !self.consume(':') { return spec }\n+        if !self.consume(':') {\n+            return spec\n+        }\n \n         // fill character\n         if let Some(&(_, c)) = self.cur.peek() {\n@@ -347,7 +362,11 @@ impl<'a> Parser<'a> {\n     /// width.\n     fn count(&mut self) -> Count<'a> {\n         if let Some(i) = self.integer() {\n-            if self.consume('$') { CountIsParam(i) } else { CountIs(i) }\n+            if self.consume('$') {\n+                CountIsParam(i)\n+            } else {\n+                CountIs(i)\n+            }\n         } else {\n             let tmp = self.cur.clone();\n             let word = self.word();\n@@ -370,8 +389,13 @@ impl<'a> Parser<'a> {\n     /// characters.\n     fn word(&mut self) -> &'a str {\n         let start = match self.cur.peek() {\n-            Some(&(pos, c)) if c.is_xid_start() => { self.cur.next(); pos }\n-            _ => { return &self.input[..0]; }\n+            Some(&(pos, c)) if c.is_xid_start() => {\n+                self.cur.next();\n+                pos\n+            }\n+            _ => {\n+                return &self.input[..0];\n+            }\n         };\n         while let Some(&(pos, c)) = self.cur.peek() {\n             if c.is_xid_continue() {\n@@ -397,7 +421,11 @@ impl<'a> Parser<'a> {\n                 break\n             }\n         }\n-        if found { Some(cur) } else { None }\n+        if found {\n+            Some(cur)\n+        } else {\n+            None\n+        }\n     }\n }\n \n@@ -437,178 +465,210 @@ mod tests {\n         same(\"\\\\}}\", &[String(\"\\\\\"), String(\"}\")]);\n     }\n \n-    #[test] fn invalid01() { musterr(\"{\") }\n-    #[test] fn invalid02() { musterr(\"}\") }\n-    #[test] fn invalid04() { musterr(\"{3a}\") }\n-    #[test] fn invalid05() { musterr(\"{:|}\") }\n-    #[test] fn invalid06() { musterr(\"{:>>>}\") }\n+    #[test]\n+    fn invalid01() {\n+        musterr(\"{\")\n+    }\n+    #[test]\n+    fn invalid02() {\n+        musterr(\"}\")\n+    }\n+    #[test]\n+    fn invalid04() {\n+        musterr(\"{3a}\")\n+    }\n+    #[test]\n+    fn invalid05() {\n+        musterr(\"{:|}\")\n+    }\n+    #[test]\n+    fn invalid06() {\n+        musterr(\"{:>>>}\")\n+    }\n \n     #[test]\n     fn format_nothing() {\n-        same(\"{}\", &[NextArgument(Argument {\n-            position: ArgumentNext,\n-            format: fmtdflt(),\n-        })]);\n+        same(\"{}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentNext,\n+                   format: fmtdflt(),\n+               })]);\n     }\n     #[test]\n     fn format_position() {\n-        same(\"{3}\", &[NextArgument(Argument {\n-            position: ArgumentIs(3),\n-            format: fmtdflt(),\n-        })]);\n+        same(\"{3}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentIs(3),\n+                   format: fmtdflt(),\n+               })]);\n     }\n     #[test]\n     fn format_position_nothing_else() {\n-        same(\"{3:}\", &[NextArgument(Argument {\n-            position: ArgumentIs(3),\n-            format: fmtdflt(),\n-        })]);\n+        same(\"{3:}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentIs(3),\n+                   format: fmtdflt(),\n+               })]);\n     }\n     #[test]\n     fn format_type() {\n-        same(\"{3:a}\", &[NextArgument(Argument {\n-            position: ArgumentIs(3),\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountImplied,\n-                width: CountImplied,\n-                ty: \"a\",\n-            },\n-        })]);\n+        same(\"{3:a}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentIs(3),\n+                   format: FormatSpec {\n+                       fill: None,\n+                       align: AlignUnknown,\n+                       flags: 0,\n+                       precision: CountImplied,\n+                       width: CountImplied,\n+                       ty: \"a\",\n+                   },\n+               })]);\n     }\n     #[test]\n     fn format_align_fill() {\n-        same(\"{3:>}\", &[NextArgument(Argument {\n-            position: ArgumentIs(3),\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignRight,\n-                flags: 0,\n-                precision: CountImplied,\n-                width: CountImplied,\n-                ty: \"\",\n-            },\n-        })]);\n-        same(\"{3:0<}\", &[NextArgument(Argument {\n-            position: ArgumentIs(3),\n-            format: FormatSpec {\n-                fill: Some('0'),\n-                align: AlignLeft,\n-                flags: 0,\n-                precision: CountImplied,\n-                width: CountImplied,\n-                ty: \"\",\n-            },\n-        })]);\n-        same(\"{3:*<abcd}\", &[NextArgument(Argument {\n-            position: ArgumentIs(3),\n-            format: FormatSpec {\n-                fill: Some('*'),\n-                align: AlignLeft,\n-                flags: 0,\n-                precision: CountImplied,\n-                width: CountImplied,\n-                ty: \"abcd\",\n-            },\n-        })]);\n+        same(\"{3:>}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentIs(3),\n+                   format: FormatSpec {\n+                       fill: None,\n+                       align: AlignRight,\n+                       flags: 0,\n+                       precision: CountImplied,\n+                       width: CountImplied,\n+                       ty: \"\",\n+                   },\n+               })]);\n+        same(\"{3:0<}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentIs(3),\n+                   format: FormatSpec {\n+                       fill: Some('0'),\n+                       align: AlignLeft,\n+                       flags: 0,\n+                       precision: CountImplied,\n+                       width: CountImplied,\n+                       ty: \"\",\n+                   },\n+               })]);\n+        same(\"{3:*<abcd}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentIs(3),\n+                   format: FormatSpec {\n+                       fill: Some('*'),\n+                       align: AlignLeft,\n+                       flags: 0,\n+                       precision: CountImplied,\n+                       width: CountImplied,\n+                       ty: \"abcd\",\n+                   },\n+               })]);\n     }\n     #[test]\n     fn format_counts() {\n-        same(\"{:10s}\", &[NextArgument(Argument {\n-            position: ArgumentNext,\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountImplied,\n-                width: CountIs(10),\n-                ty: \"s\",\n-            },\n-        })]);\n-        same(\"{:10$.10s}\", &[NextArgument(Argument {\n-            position: ArgumentNext,\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountIs(10),\n-                width: CountIsParam(10),\n-                ty: \"s\",\n-            },\n-        })]);\n-        same(\"{:.*s}\", &[NextArgument(Argument {\n-            position: ArgumentNext,\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountIsNextParam,\n-                width: CountImplied,\n-                ty: \"s\",\n-            },\n-        })]);\n-        same(\"{:.10$s}\", &[NextArgument(Argument {\n-            position: ArgumentNext,\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountIsParam(10),\n-                width: CountImplied,\n-                ty: \"s\",\n-            },\n-        })]);\n-        same(\"{:a$.b$s}\", &[NextArgument(Argument {\n-            position: ArgumentNext,\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountIsName(\"b\"),\n-                width: CountIsName(\"a\"),\n-                ty: \"s\",\n-            },\n-        })]);\n+        same(\"{:10s}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentNext,\n+                   format: FormatSpec {\n+                       fill: None,\n+                       align: AlignUnknown,\n+                       flags: 0,\n+                       precision: CountImplied,\n+                       width: CountIs(10),\n+                       ty: \"s\",\n+                   },\n+               })]);\n+        same(\"{:10$.10s}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentNext,\n+                   format: FormatSpec {\n+                       fill: None,\n+                       align: AlignUnknown,\n+                       flags: 0,\n+                       precision: CountIs(10),\n+                       width: CountIsParam(10),\n+                       ty: \"s\",\n+                   },\n+               })]);\n+        same(\"{:.*s}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentNext,\n+                   format: FormatSpec {\n+                       fill: None,\n+                       align: AlignUnknown,\n+                       flags: 0,\n+                       precision: CountIsNextParam,\n+                       width: CountImplied,\n+                       ty: \"s\",\n+                   },\n+               })]);\n+        same(\"{:.10$s}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentNext,\n+                   format: FormatSpec {\n+                       fill: None,\n+                       align: AlignUnknown,\n+                       flags: 0,\n+                       precision: CountIsParam(10),\n+                       width: CountImplied,\n+                       ty: \"s\",\n+                   },\n+               })]);\n+        same(\"{:a$.b$s}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentNext,\n+                   format: FormatSpec {\n+                       fill: None,\n+                       align: AlignUnknown,\n+                       flags: 0,\n+                       precision: CountIsName(\"b\"),\n+                       width: CountIsName(\"a\"),\n+                       ty: \"s\",\n+                   },\n+               })]);\n     }\n     #[test]\n     fn format_flags() {\n-        same(\"{:-}\", &[NextArgument(Argument {\n-            position: ArgumentNext,\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: (1 << FlagSignMinus as u32),\n-                precision: CountImplied,\n-                width: CountImplied,\n-                ty: \"\",\n-            },\n-        })]);\n-        same(\"{:+#}\", &[NextArgument(Argument {\n-            position: ArgumentNext,\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: (1 << FlagSignPlus as u32) | (1 << FlagAlternate as u32),\n-                precision: CountImplied,\n-                width: CountImplied,\n-                ty: \"\",\n-            },\n-        })]);\n+        same(\"{:-}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentNext,\n+                   format: FormatSpec {\n+                       fill: None,\n+                       align: AlignUnknown,\n+                       flags: (1 << FlagSignMinus as u32),\n+                       precision: CountImplied,\n+                       width: CountImplied,\n+                       ty: \"\",\n+                   },\n+               })]);\n+        same(\"{:+#}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentNext,\n+                   format: FormatSpec {\n+                       fill: None,\n+                       align: AlignUnknown,\n+                       flags: (1 << FlagSignPlus as u32) | (1 << FlagAlternate as u32),\n+                       precision: CountImplied,\n+                       width: CountImplied,\n+                       ty: \"\",\n+                   },\n+               })]);\n     }\n     #[test]\n     fn format_mixture() {\n-        same(\"abcd {3:a} efg\", &[String(\"abcd \"), NextArgument(Argument {\n-            position: ArgumentIs(3),\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountImplied,\n-                width: CountImplied,\n-                ty: \"a\",\n-            },\n-        }), String(\" efg\")]);\n+        same(\"abcd {3:a} efg\",\n+             &[String(\"abcd \"),\n+               NextArgument(Argument {\n+                   position: ArgumentIs(3),\n+                   format: FormatSpec {\n+                       fill: None,\n+                       align: AlignUnknown,\n+                       flags: 0,\n+                       precision: CountImplied,\n+                       width: CountImplied,\n+                       ty: \"a\",\n+                   },\n+               }),\n+               String(\" efg\")]);\n     }\n }"}, {"sha": "12a5c1311705d34c9835ccba0dec2e0f2ba4ca97", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 45, "deletions": 39, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=294ef5b158601b09e2a3ca49af124c63a9cf9528", "patch": "@@ -17,15 +17,17 @@ pub struct LogDirective {\n     pub level: u32,\n }\n \n-pub const LOG_LEVEL_NAMES: [&'static str; 4] = [\"ERROR\", \"WARN\", \"INFO\",\n-                                               \"DEBUG\"];\n+pub const LOG_LEVEL_NAMES: [&'static str; 4] = [\"ERROR\", \"WARN\", \"INFO\", \"DEBUG\"];\n \n /// Parse an individual log level that is either a number or a symbolic log level\n fn parse_log_level(level: &str) -> Option<u32> {\n-    level.parse::<u32>().ok().or_else(|| {\n-        let pos = LOG_LEVEL_NAMES.iter().position(|&name| name.eq_ignore_ascii_case(level));\n-        pos.map(|p| p as u32 + 1)\n-    }).map(|p| cmp::min(p, ::MAX_LOG_LEVEL))\n+    level.parse::<u32>()\n+         .ok()\n+         .or_else(|| {\n+             let pos = LOG_LEVEL_NAMES.iter().position(|&name| name.eq_ignore_ascii_case(level));\n+             pos.map(|p| p as u32 + 1)\n+         })\n+         .map(|p| cmp::min(p, ::MAX_LOG_LEVEL))\n }\n \n /// Parse a logging specification string (e.g: \"crate1,crate2::mod3,crate3::x=1/foo\")\n@@ -40,44 +42,48 @@ pub fn parse_logging_spec(spec: &str) -> (Vec<LogDirective>, Option<String>) {\n     let mods = parts.next();\n     let filter = parts.next();\n     if parts.next().is_some() {\n-        println!(\"warning: invalid logging spec '{}', \\\n-                 ignoring it (too many '/'s)\", spec);\n+        println!(\"warning: invalid logging spec '{}', ignoring it (too many '/'s)\",\n+                 spec);\n         return (dirs, None);\n     }\n-    mods.map(|m| { for s in m.split(',') {\n-        if s.is_empty() { continue }\n-        let mut parts = s.split('=');\n-        let (log_level, name) = match (parts.next(), parts.next().map(|s| s.trim()), parts.next()) {\n-            (Some(part0), None, None) => {\n-                // if the single argument is a log-level string or number,\n-                // treat that as a global fallback\n-                match parse_log_level(part0) {\n-                    Some(num) => (num, None),\n-                    None => (::MAX_LOG_LEVEL, Some(part0)),\n-                }\n+    mods.map(|m| {\n+        for s in m.split(',') {\n+            if s.is_empty() {\n+                continue\n             }\n-            (Some(part0), Some(\"\"), None) => (::MAX_LOG_LEVEL, Some(part0)),\n-            (Some(part0), Some(part1), None) => {\n-                match parse_log_level(part1) {\n-                    Some(num) => (num, Some(part0)),\n-                    _ => {\n-                        println!(\"warning: invalid logging spec '{}', \\\n-                                 ignoring it\", part1);\n-                        continue\n+            let mut parts = s.split('=');\n+            let (log_level, name) = match (parts.next(),\n+                                           parts.next().map(|s| s.trim()),\n+                                           parts.next()) {\n+                (Some(part0), None, None) => {\n+                    // if the single argument is a log-level string or number,\n+                    // treat that as a global fallback\n+                    match parse_log_level(part0) {\n+                        Some(num) => (num, None),\n+                        None => (::MAX_LOG_LEVEL, Some(part0)),\n                     }\n                 }\n-            },\n-            _ => {\n-                println!(\"warning: invalid logging spec '{}', \\\n-                         ignoring it\", s);\n-                continue\n-            }\n-        };\n-        dirs.push(LogDirective {\n-            name: name.map(str::to_owned),\n-            level: log_level,\n-        });\n-    }});\n+                (Some(part0), Some(\"\"), None) => (::MAX_LOG_LEVEL, Some(part0)),\n+                (Some(part0), Some(part1), None) => {\n+                    match parse_log_level(part1) {\n+                        Some(num) => (num, Some(part0)),\n+                        _ => {\n+                            println!(\"warning: invalid logging spec '{}', ignoring it\", part1);\n+                            continue\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    println!(\"warning: invalid logging spec '{}', ignoring it\", s);\n+                    continue\n+                }\n+            };\n+            dirs.push(LogDirective {\n+                name: name.map(str::to_owned),\n+                level: log_level,\n+            });\n+        }\n+    });\n \n     (dirs, filter.map(str::to_owned))\n }"}, {"sha": "b3268c32f18f7392e7aa3b5efc88eb8f99073d47", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 69, "deletions": 49, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=294ef5b158601b09e2a3ca49af124c63a9cf9528", "patch": "@@ -235,7 +235,9 @@ pub trait Logger {\n     fn log(&mut self, record: &LogRecord);\n }\n \n-struct DefaultLogger { handle: Stderr }\n+struct DefaultLogger {\n+    handle: Stderr,\n+}\n \n /// Wraps the log level with fmt implementations.\n #[derive(Copy, Clone, PartialEq, PartialOrd, Debug)]\n@@ -246,7 +248,7 @@ impl fmt::Display for LogLevel {\n         let LogLevel(level) = *self;\n         match LOG_LEVEL_NAMES.get(level as usize - 1) {\n             Some(ref name) => fmt::Display::fmt(name, fmt),\n-            None => fmt::Display::fmt(&level, fmt)\n+            None => fmt::Display::fmt(&level, fmt),\n         }\n     }\n }\n@@ -301,11 +303,10 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     // Completely remove the local logger from TLS in case anyone attempts to\n     // frob the slot while we're doing the logging. This will destroy any logger\n     // set during logging.\n-    let mut logger: Box<Logger + Send> = LOCAL_LOGGER.with(|s| {\n-        s.borrow_mut().take()\n-    }).unwrap_or_else(|| {\n-        box DefaultLogger { handle: io::stderr() }\n-    });\n+    let mut logger: Box<Logger + Send> = LOCAL_LOGGER.with(|s| s.borrow_mut().take())\n+                                                     .unwrap_or_else(|| {\n+                                                         box DefaultLogger { handle: io::stderr() }\n+                                                     });\n     logger.log(&LogRecord {\n         level: LogLevel(level),\n         args: args,\n@@ -320,22 +321,21 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n /// safely\n #[doc(hidden)]\n #[inline(always)]\n-pub fn log_level() -> u32 { unsafe { LOG_LEVEL } }\n+pub fn log_level() -> u32 {\n+    unsafe { LOG_LEVEL }\n+}\n \n /// Replaces the thread-local logger with the specified logger, returning the old\n /// logger.\n pub fn set_logger(logger: Box<Logger + Send>) -> Option<Box<Logger + Send>> {\n     let mut l = Some(logger);\n-    LOCAL_LOGGER.with(|slot| {\n-        mem::replace(&mut *slot.borrow_mut(), l.take())\n-    })\n+    LOCAL_LOGGER.with(|slot| mem::replace(&mut *slot.borrow_mut(), l.take()))\n }\n \n /// A LogRecord is created by the logging macros, and passed as the only\n /// argument to Loggers.\n #[derive(Debug)]\n pub struct LogRecord<'a> {\n-\n     /// The module path of where the LogRecord originated.\n     pub module_path: &'a str,\n \n@@ -373,7 +373,9 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n     // again to whether they should really be here or not. Hence, despite this\n     // check being expanded manually in the logging macro, this function checks\n     // the log level again.\n-    if level > unsafe { LOG_LEVEL } { return false }\n+    if level > unsafe { LOG_LEVEL } {\n+        return false\n+    }\n \n     // This assertion should never get tripped unless we're in an at_exit\n     // handler after logging has been torn down and a logging attempt was made.\n@@ -385,14 +387,11 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n     }\n }\n \n-fn enabled(level: u32,\n-           module: &str,\n-           iter: slice::Iter<directive::LogDirective>)\n-           -> bool {\n+fn enabled(level: u32, module: &str, iter: slice::Iter<directive::LogDirective>) -> bool {\n     // Search for the longest match, the vector is assumed to be pre-sorted.\n     for directive in iter.rev() {\n         match directive.name {\n-            Some(ref name) if !module.starts_with(&name[..]) => {},\n+            Some(ref name) if !module.starts_with(&name[..]) => {}\n             Some(..) | None => {\n                 return level <= directive.level\n             }\n@@ -445,16 +444,14 @@ mod tests {\n \n     #[test]\n     fn match_full_path() {\n-        let dirs = [\n-            LogDirective {\n-                name: Some(\"crate2\".to_string()),\n-                level: 3\n-            },\n-            LogDirective {\n-                name: Some(\"crate1::mod1\".to_string()),\n-                level: 2\n-            }\n-        ];\n+        let dirs = [LogDirective {\n+                        name: Some(\"crate2\".to_string()),\n+                        level: 3,\n+                    },\n+                    LogDirective {\n+                        name: Some(\"crate1::mod1\".to_string()),\n+                        level: 2,\n+                    }];\n         assert!(enabled(2, \"crate1::mod1\", dirs.iter()));\n         assert!(!enabled(3, \"crate1::mod1\", dirs.iter()));\n         assert!(enabled(3, \"crate2\", dirs.iter()));\n@@ -463,49 +460,72 @@ mod tests {\n \n     #[test]\n     fn no_match() {\n-        let dirs = [\n-            LogDirective { name: Some(\"crate2\".to_string()), level: 3 },\n-            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: 2 }\n-        ];\n+        let dirs = [LogDirective {\n+                        name: Some(\"crate2\".to_string()),\n+                        level: 3,\n+                    },\n+                    LogDirective {\n+                        name: Some(\"crate1::mod1\".to_string()),\n+                        level: 2,\n+                    }];\n         assert!(!enabled(2, \"crate3\", dirs.iter()));\n     }\n \n     #[test]\n     fn match_beginning() {\n-        let dirs = [\n-            LogDirective { name: Some(\"crate2\".to_string()), level: 3 },\n-            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: 2 }\n-        ];\n+        let dirs = [LogDirective {\n+                        name: Some(\"crate2\".to_string()),\n+                        level: 3,\n+                    },\n+                    LogDirective {\n+                        name: Some(\"crate1::mod1\".to_string()),\n+                        level: 2,\n+                    }];\n         assert!(enabled(3, \"crate2::mod1\", dirs.iter()));\n     }\n \n     #[test]\n     fn match_beginning_longest_match() {\n-        let dirs = [\n-            LogDirective { name: Some(\"crate2\".to_string()), level: 3 },\n-            LogDirective { name: Some(\"crate2::mod\".to_string()), level: 4 },\n-            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: 2 }\n-        ];\n+        let dirs = [LogDirective {\n+                        name: Some(\"crate2\".to_string()),\n+                        level: 3,\n+                    },\n+                    LogDirective {\n+                        name: Some(\"crate2::mod\".to_string()),\n+                        level: 4,\n+                    },\n+                    LogDirective {\n+                        name: Some(\"crate1::mod1\".to_string()),\n+                        level: 2,\n+                    }];\n         assert!(enabled(4, \"crate2::mod1\", dirs.iter()));\n         assert!(!enabled(4, \"crate2\", dirs.iter()));\n     }\n \n     #[test]\n     fn match_default() {\n-        let dirs = [\n-            LogDirective { name: None, level: 3 },\n-            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: 2 }\n-        ];\n+        let dirs = [LogDirective {\n+                        name: None,\n+                        level: 3,\n+                    },\n+                    LogDirective {\n+                        name: Some(\"crate1::mod1\".to_string()),\n+                        level: 2,\n+                    }];\n         assert!(enabled(2, \"crate1::mod1\", dirs.iter()));\n         assert!(enabled(3, \"crate2::mod2\", dirs.iter()));\n     }\n \n     #[test]\n     fn zero_level() {\n-        let dirs = [\n-            LogDirective { name: None, level: 3 },\n-            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: 0 }\n-        ];\n+        let dirs = [LogDirective {\n+                        name: None,\n+                        level: 3,\n+                    },\n+                    LogDirective {\n+                        name: Some(\"crate1::mod1\".to_string()),\n+                        level: 0,\n+                    }];\n         assert!(!enabled(1, \"crate1::mod1\", dirs.iter()));\n         assert!(enabled(3, \"crate2::mod2\", dirs.iter()));\n     }"}, {"sha": "2d84f6fc2bea8329ab0e24aa25877810924cdb0e", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=294ef5b158601b09e2a3ca49af124c63a9cf9528", "patch": "@@ -528,6 +528,10 @@ impl<'ast> Map<'ast> {\n             NodeTraitItem(ti) => PathName(ti.name),\n             NodeVariant(v) => PathName(v.node.name),\n             NodeLifetime(lt) => PathName(lt.name),\n+            NodeTyParam(tp) => PathName(tp.name),\n+            NodeLocal(&Pat { node: PatIdent(_,l,_), .. }) => {\n+                PathName(l.node.name)\n+            },\n             _ => panic!(\"no path elem for {:?}\", node)\n         }\n     }\n@@ -988,4 +992,3 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         }\n     }\n }\n-"}, {"sha": "16f586cf5e0627487883b2f37b90496635b1520f", "filename": "src/librustc_bitflags/lib.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Flibrustc_bitflags%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Flibrustc_bitflags%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2Flib.rs?ref=294ef5b158601b09e2a3ca49af124c63a9cf9528", "patch": "@@ -22,7 +22,9 @@\n \n //! A typesafe bitmask flag generator.\n \n-#[cfg(test)] #[macro_use] extern crate std;\n+#[cfg(test)]\n+#[macro_use]\n+extern crate std;\n \n /// The `bitflags!` macro generates a `struct` that holds a set of C-style\n /// bitmask flags. It is useful for creating typesafe wrappers for C APIs.\n@@ -321,7 +323,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_bits(){\n+    fn test_bits() {\n         assert_eq!(Flags::empty().bits(), 0b00000000);\n         assert_eq!(Flags::FlagA.bits(), 0b00000001);\n         assert_eq!(Flags::FlagABC.bits(), 0b00000111);\n@@ -354,7 +356,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_is_empty(){\n+    fn test_is_empty() {\n         assert!(Flags::empty().is_empty());\n         assert!(!Flags::FlagA.is_empty());\n         assert!(!Flags::FlagABC.is_empty());\n@@ -413,7 +415,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_insert(){\n+    fn test_insert() {\n         let mut e1 = Flags::FlagA;\n         let e2 = Flags::FlagA | Flags::FlagB;\n         e1.insert(e2);\n@@ -425,7 +427,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_remove(){\n+    fn test_remove() {\n         let mut e1 = Flags::FlagA | Flags::FlagB;\n         let e2 = Flags::FlagA | Flags::FlagC;\n         e1.remove(e2);\n@@ -484,12 +486,12 @@ mod tests {\n \n     #[test]\n     fn test_hash() {\n-      let mut x = Flags::empty();\n-      let mut y = Flags::empty();\n-      assert!(hash(&x) == hash(&y));\n-      x = Flags::all();\n-      y = Flags::FlagABC;\n-      assert!(hash(&x) == hash(&y));\n+        let mut x = Flags::empty();\n+        let mut y = Flags::empty();\n+        assert!(hash(&x) == hash(&y));\n+        x = Flags::all();\n+        y = Flags::FlagABC;\n+        assert!(hash(&x) == hash(&y));\n     }\n \n     fn hash<T: Hash>(t: &T) -> u64 {"}, {"sha": "31e6c942dc697f75e5716f138d23f914cc8ef965", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=294ef5b158601b09e2a3ca49af124c63a9cf9528", "patch": "@@ -592,6 +592,8 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n         };\n \n         substs_wf_in_scope(rcx, origin, &callee.substs, expr.span, expr_region);\n+        type_must_outlive(rcx, infer::ExprTypeIsNotInScope(callee.ty, expr.span),\n+                          callee.ty, expr_region);\n     }\n \n     // Check any autoderefs or autorefs that appear.\n@@ -664,6 +666,8 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n         }\n     }\n \n+    debug!(\"regionck::visit_expr(e={:?}, repeating_scope={}) - visiting subexprs\",\n+           expr, rcx.repeating_scope);\n     match expr.node {\n         hir::ExprPath(..) => {\n             rcx.fcx.opt_node_ty_substs(expr.id, |item_substs| {"}, {"sha": "6f18aad623574d5db6a7c0caae262a86ed2ce69b", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=294ef5b158601b09e2a3ca49af124c63a9cf9528", "patch": "@@ -17,9 +17,8 @@ use option::Option::{self, Some, None};\n use result;\n use sys;\n \n-/// A specialized [`Result`][result] type for I/O operations.\n-///\n-/// [result]: ../result/enum.Result.html\n+/// A specialized [`Result`](../result/enum.Result.html) type for I/O\n+/// operations.\n ///\n /// This type is broadly used across `std::io` for any operation which may\n /// produce an error."}, {"sha": "16c35970bfe77724bc744222ae84d910d33df228", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=294ef5b158601b09e2a3ca49af124c63a9cf9528", "patch": "@@ -335,8 +335,7 @@ LLVMRustSetDataLayoutFromTargetMachine(LLVMModuleRef Module,\n                                        LLVMTargetMachineRef TMR) {\n     TargetMachine *Target = unwrap(TMR);\n #if LLVM_VERSION_MINOR >= 7\n-    if (const DataLayout *DL = Target->getDataLayout())\n-        unwrap(Module)->setDataLayout(*DL);\n+    unwrap(Module)->setDataLayout(Target->createDataLayout());\n #elif LLVM_VERSION_MINOR >= 6\n     if (const DataLayout *DL = Target->getSubtargetImpl()->getDataLayout())\n         unwrap(Module)->setDataLayout(DL);"}, {"sha": "6afcd770746446ce315bc41121c6a26f3b1e69c7", "filename": "src/test/run-pass/issue-22814.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Ftest%2Frun-pass%2Fissue-22814.rs", "raw_url": "https://github.com/rust-lang/rust/raw/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Ftest%2Frun-pass%2Fissue-22814.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-22814.rs?ref=294ef5b158601b09e2a3ca49af124c63a9cf9528", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Test {}\n+\n+macro_rules! test {\n+( $($name:ident)+) => (\n+    impl<$($name: Test),*> Test for ($($name,)*) {\n+    }\n+)\n+}\n+\n+test!(A B C);\n+\n+fn main() {}"}, {"sha": "87112ef171981df96d12cfe9f7e6aab9684a6189", "filename": "src/test/run-pass/issue-28999.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Ftest%2Frun-pass%2Fissue-28999.rs", "raw_url": "https://github.com/rust-lang/rust/raw/294ef5b158601b09e2a3ca49af124c63a9cf9528/src%2Ftest%2Frun-pass%2Fissue-28999.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-28999.rs?ref=294ef5b158601b09e2a3ca49af124c63a9cf9528", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Xyz<'a, V> {\n+    pub v: (V, &'a u32),\n+}\n+\n+pub fn eq<'a, 's, 't, V>(this: &'s Xyz<'a, V>, other: &'t Xyz<'a, V>) -> bool\n+        where V: PartialEq {\n+    this.v == other.v\n+}\n+\n+fn main() {}"}]}