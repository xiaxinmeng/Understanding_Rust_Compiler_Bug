{"sha": "5b118f5ecde796ad62fa349a045d7ad8129b711c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViMTE4ZjVlY2RlNzk2YWQ2MmZhMzQ5YTA0NWQ3YWQ4MTI5YjcxMWM=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-03-11T04:13:24Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-03-17T02:56:31Z"}, "message": "impl str", "tree": {"sha": "9789557ab2407b1ae3cf6d4ef6390f78bc28f08f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9789557ab2407b1ae3cf6d4ef6390f78bc28f08f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b118f5ecde796ad62fa349a045d7ad8129b711c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b118f5ecde796ad62fa349a045d7ad8129b711c", "html_url": "https://github.com/rust-lang/rust/commit/5b118f5ecde796ad62fa349a045d7ad8129b711c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b118f5ecde796ad62fa349a045d7ad8129b711c/comments", "author": null, "committer": null, "parents": [{"sha": "b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e", "html_url": "https://github.com/rust-lang/rust/commit/b2f37554bf9f2b55fa6ba6ba8e8eaf1826301b4e"}], "stats": {"total": 1172, "additions": 1168, "deletions": 4}, "files": [{"sha": "3a2fc17e1e985e4e86a79de92d95d1e096998013", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=5b118f5ecde796ad62fa349a045d7ad8129b711c", "patch": "@@ -27,6 +27,7 @@\n #![feature(box_syntax)]\n #![feature(box_patterns)]\n #![feature(core)]\n+#![feature(lang_items)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n@@ -162,7 +163,10 @@ mod prelude {\n \n     // in core and collections (may differ).\n     pub use slice::{AsSlice, SliceExt};\n+    #[cfg(stage0)]\n     pub use str::{Str, StrExt};\n+    #[cfg(not(stage0))]\n+    pub use str::Str;\n \n     // from other crates.\n     pub use alloc::boxed::Box;"}, {"sha": "b4e548e137e94293c1dcb5e6a1b4577a34da8ab2", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1136, "deletions": 0, "changes": 1136, "blob_url": "https://github.com/rust-lang/rust/blob/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=5b118f5ecde796ad62fa349a045d7ad8129b711c", "patch": "@@ -59,7 +59,9 @@ use self::DecompositionType::*;\n use core::clone::Clone;\n use core::iter::AdditiveIterator;\n use core::iter::{Iterator, IteratorExt, Extend};\n+#[cfg(stage0)]\n use core::ops::Index;\n+#[cfg(stage0)]\n use core::ops::RangeFull;\n use core::option::Option::{self, Some, None};\n use core::result::Result;\n@@ -415,6 +417,7 @@ Section: CowString\n Section: Trait implementations\n */\n \n+#[cfg(stage0)]\n /// Any string that can be represented as a slice.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait StrExt: Index<RangeFull, Output = str> {\n@@ -1539,6 +1542,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     }\n }\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl StrExt for str {\n     fn slice(&self, begin: usize, end: usize) -> &str {\n@@ -1554,6 +1558,1138 @@ impl StrExt for str {\n     }\n }\n \n+#[cfg(not(stage0))]\n+/// Any string that can be represented as a slice.\n+#[lang = \"str\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl str {\n+    /// Escapes each char in `s` with `char::escape_default`.\n+    #[unstable(feature = \"collections\",\n+               reason = \"return type may change to be an iterator\")]\n+    pub fn escape_default(&self) -> String {\n+        self.chars().flat_map(|c| c.escape_default()).collect()\n+    }\n+\n+    /// Escapes each char in `s` with `char::escape_unicode`.\n+    #[unstable(feature = \"collections\",\n+               reason = \"return type may change to be an iterator\")]\n+    pub fn escape_unicode(&self) -> String {\n+        self.chars().flat_map(|c| c.escape_unicode()).collect()\n+    }\n+\n+    /// Replaces all occurrences of one string with another.\n+    ///\n+    /// `replace` takes two arguments, a sub-`&str` to find in `self`, and a second `&str` to\n+    /// replace it with. If the original `&str` isn't found, no change occurs.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"this is old\";\n+    ///\n+    /// assert_eq!(s.replace(\"old\", \"new\"), \"this is new\");\n+    /// ```\n+    ///\n+    /// When a `&str` isn't found:\n+    ///\n+    /// ```\n+    /// let s = \"this is old\";\n+    /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn replace(&self, from: &str, to: &str) -> String {\n+        let mut result = String::new();\n+        let mut last_end = 0;\n+        for (start, end) in self.match_indices(from) {\n+            result.push_str(unsafe { self.slice_unchecked(last_end, start) });\n+            result.push_str(to);\n+            last_end = end;\n+        }\n+        result.push_str(unsafe { self.slice_unchecked(last_end, self.len()) });\n+        result\n+    }\n+\n+    /// Returns an iterator over the string in Unicode Normalization Form D\n+    /// (canonical decomposition).\n+    #[inline]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may be moved to libunicode\")]\n+    pub fn nfd_chars(&self) -> Decompositions {\n+        Decompositions {\n+            iter: self[..].chars(),\n+            buffer: Vec::new(),\n+            sorted: false,\n+            kind: Canonical\n+        }\n+    }\n+\n+    /// Returns an iterator over the string in Unicode Normalization Form KD\n+    /// (compatibility decomposition).\n+    #[inline]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may be moved to libunicode\")]\n+    pub fn nfkd_chars(&self) -> Decompositions {\n+        Decompositions {\n+            iter: self[..].chars(),\n+            buffer: Vec::new(),\n+            sorted: false,\n+            kind: Compatible\n+        }\n+    }\n+\n+    /// An Iterator over the string in Unicode Normalization Form C\n+    /// (canonical decomposition followed by canonical composition).\n+    #[inline]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may be moved to libunicode\")]\n+    pub fn nfc_chars(&self) -> Recompositions {\n+        Recompositions {\n+            iter: self.nfd_chars(),\n+            state: Composing,\n+            buffer: VecDeque::new(),\n+            composee: None,\n+            last_ccc: None\n+        }\n+    }\n+\n+    /// An Iterator over the string in Unicode Normalization Form KC\n+    /// (compatibility decomposition followed by canonical composition).\n+    #[inline]\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may be moved to libunicode\")]\n+    pub fn nfkc_chars(&self) -> Recompositions {\n+        Recompositions {\n+            iter: self.nfkd_chars(),\n+            state: Composing,\n+            buffer: VecDeque::new(),\n+            composee: None,\n+            last_ccc: None\n+        }\n+    }\n+\n+    /// Returns `true` if `self` contains another `&str`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert!(\"bananas\".contains(\"nana\"));\n+    ///\n+    /// assert!(!\"bananas\".contains(\"foobar\"));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n+        core_str::StrExt::contains(&self[..], pat)\n+    }\n+\n+    /// Returns `true` if `self` contains a `char`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert!(\"hello\".contains_char('e'));\n+    ///\n+    /// assert!(!\"hello\".contains_char('z'));\n+    /// ```\n+    #[unstable(feature = \"collections\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use `contains()` with a char\")]\n+    pub fn contains_char<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n+        core_str::StrExt::contains_char(&self[..], pat)\n+    }\n+\n+    /// An iterator over the codepoints of `self`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v: Vec<char> = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n+    ///\n+    /// assert_eq!(v, ['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn chars(&self) -> Chars {\n+        core_str::StrExt::chars(&self[..])\n+    }\n+\n+    /// An iterator over the bytes of `self`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v: Vec<u8> = \"bors\".bytes().collect();\n+    ///\n+    /// assert_eq!(v, b\"bors\".to_vec());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn bytes(&self) -> Bytes {\n+        core_str::StrExt::bytes(&self[..])\n+    }\n+\n+    /// An iterator over the characters of `self` and their byte offsets.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v: Vec<(usize, char)> = \"abc\".char_indices().collect();\n+    /// let b = vec![(0, 'a'), (1, 'b'), (2, 'c')];\n+    ///\n+    /// assert_eq!(v, b);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn char_indices(&self) -> CharIndices {\n+        core_str::StrExt::char_indices(&self[..])\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by a pattern.\n+    ///\n+    /// The pattern can be a simple `&str`, or a closure that determines\n+    /// the split.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple `&str` patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".split('X').collect();\n+    /// assert_eq!(v, [\"\"]);\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n+    /// assert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n+        core_str::StrExt::split(&self[..], pat)\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by characters matched by a pattern,\n+    /// restricted to splitting at most `count` times.\n+    ///\n+    /// The pattern can be a simple `&str`, or a closure that determines\n+    /// the split.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple `&str` patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(2, ' ').collect();\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(2, 'X').collect();\n+    /// assert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n+    ///\n+    /// let v: Vec<&str> = \"abcXdef\".splitn(0, 'X').collect();\n+    /// assert_eq!(v, [\"abcXdef\"]);\n+    ///\n+    /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n+    /// assert_eq!(v, [\"\"]);\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, [\"abc\", \"def2ghi\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> {\n+        core_str::StrExt::splitn(&self[..], count, pat)\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by characters\n+    /// matched by a pattern.\n+    ///\n+    /// Equivalent to `split`, except that the trailing substring is skipped if empty.\n+    ///\n+    /// The pattern can be a simple `&str`, or a closure that determines\n+    /// the split.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple `&str` patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n+    /// assert_eq!(v, [\"A\", \"B\"]);\n+    ///\n+    /// let v: Vec<&str> = \"A..B..\".split_terminator('.').collect();\n+    /// assert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1def2ghi3\".split_terminator(|c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n+        core_str::StrExt::split_terminator(&self[..], pat)\n+    }\n+\n+    /// An iterator over substrings of `self`, separated by characters matched by a pattern,\n+    /// starting from the end of the string.\n+    ///\n+    /// Restricted to splitting at most `count` times.\n+    ///\n+    /// The pattern can be a simple `&str`, or a closure that determines the split.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple `&str` patterns:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(2, ' ').collect();\n+    /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n+    ///\n+    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P> {\n+        core_str::StrExt::rsplitn(&self[..], count, pat)\n+    }\n+\n+    /// An iterator over the start and end indices of the disjoint matches of a `&str` within\n+    /// `self`.\n+    ///\n+    /// That is, each returned value `(start, end)` satisfies `self.slice(start, end) == sep`. For\n+    /// matches of `sep` within `self` that overlap, only the indices corresponding to the first\n+    /// match are returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v: Vec<(usize, usize)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(0,3), (6,9), (12,15)]);\n+    ///\n+    /// let v: Vec<(usize, usize)> = \"1abcabc2\".match_indices(\"abc\").collect();\n+    /// assert_eq!(v, [(1,4), (4,7)]);\n+    ///\n+    /// let v: Vec<(usize, usize)> = \"ababa\".match_indices(\"aba\").collect();\n+    /// assert_eq!(v, [(0, 3)]); // only the first `aba`\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"might have its iterator type changed\")]\n+    // NB: Right now MatchIndices yields `(usize, usize)`,\n+    // but it would be more consistent and useful to return `(usize, &str)`\n+    pub fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n+        core_str::StrExt::match_indices(&self[..], pat)\n+    }\n+\n+    /// An iterator over the substrings of `self` separated by a `&str`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n+    /// assert_eq!(v, [\"\", \"XXX\", \"YYY\", \"\"]);\n+    ///\n+    /// let v: Vec<&str> = \"1abcabc2\".split_str(\"abc\").collect();\n+    /// assert_eq!(v, [\"1\", \"\", \"2\"]);\n+    /// ```\n+    #[unstable(feature = \"collections\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use `split()` with a `&str`\")]\n+    #[allow(deprecated) /* for SplitStr */]\n+    pub fn split_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitStr<'a, P> {\n+        core_str::StrExt::split_str(&self[..], pat)\n+    }\n+\n+    /// An iterator over the lines of a string, separated by `\\n`.\n+    ///\n+    /// This does not include the empty string after a trailing `\\n`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let four_lines = \"foo\\nbar\\n\\nbaz\";\n+    /// let v: Vec<&str> = four_lines.lines().collect();\n+    ///\n+    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// ```\n+    ///\n+    /// Leaving off the trailing character:\n+    ///\n+    /// ```\n+    /// let four_lines = \"foo\\nbar\\n\\nbaz\\n\";\n+    /// let v: Vec<&str> = four_lines.lines().collect();\n+    ///\n+    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn lines(&self) -> Lines {\n+        core_str::StrExt::lines(&self[..])\n+    }\n+\n+    /// An iterator over the lines of a string, separated by either `\\n` or `\\r\\n`.\n+    ///\n+    /// As with `.lines()`, this does not include an empty trailing line.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\";\n+    /// let v: Vec<&str> = four_lines.lines_any().collect();\n+    ///\n+    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// ```\n+    ///\n+    /// Leaving off the trailing character:\n+    ///\n+    /// ```\n+    /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\\n\";\n+    /// let v: Vec<&str> = four_lines.lines_any().collect();\n+    ///\n+    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn lines_any(&self) -> LinesAny {\n+        core_str::StrExt::lines_any(&self[..])\n+    }\n+\n+    /// Deprecated: use `s[a .. b]` instead.\n+    #[unstable(feature = \"collections\",\n+               reason = \"use slice notation [a..b] instead\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use slice notation [a..b] instead\")]\n+    pub fn slice(&self, begin: usize, end: usize) -> &str {\n+        &self[begin..end]\n+    }\n+\n+    /// Deprecated: use `s[a..]` instead.\n+    #[unstable(feature = \"collections\",\n+               reason = \"use slice notation [a..b] instead\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use slice notation [a..] instead\")]\n+    pub fn slice_from(&self, begin: usize) -> &str {\n+        &self[begin..]\n+    }\n+\n+    /// Deprecated: use `s[..a]` instead.\n+    #[unstable(feature = \"collections\",\n+               reason = \"use slice notation [a..b] instead\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use slice notation [..a] instead\")]\n+    pub fn slice_to(&self, end: usize) -> &str {\n+        &self[..end]\n+    }\n+\n+    /// Returns a slice of the string from the character range [`begin`..`end`).\n+    ///\n+    /// That is, start at the `begin`-th code point of the string and continue\n+    /// to the `end`-th code point. This does not detect or handle edge cases\n+    /// such as leaving a combining character as the first code point of the\n+    /// string.\n+    ///\n+    /// Due to the design of UTF-8, this operation is `O(end)`. See `slice`,\n+    /// `slice_to` and `slice_from` for `O(1)` variants that use byte indices\n+    /// rather than code point indices.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `begin` > `end` or the either `begin` or `end` are beyond the\n+    /// last character of the string.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n+    /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"may have yet to prove its worth\")]\n+    pub fn slice_chars(&self, begin: usize, end: usize) -> &str {\n+        core_str::StrExt::slice_chars(&self[..], begin, end)\n+    }\n+\n+    /// Takes a bytewise slice from a string.\n+    ///\n+    /// Returns the substring from [`begin`..`end`).\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// Caller must check both UTF-8 character boundaries and the boundaries of the entire slice as\n+    /// well.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(s.slice_unchecked(0, 21), \"L\u00f6we \u8001\u864e L\u00e9opard\");\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n+        core_str::StrExt::slice_unchecked(&self[..], begin, end)\n+    }\n+\n+    /// Returns `true` if the given `&str` is a prefix of the string.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert!(\"banana\".starts_with(\"ba\"));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n+        core_str::StrExt::starts_with(&self[..], pat)\n+    }\n+\n+    /// Returns true if the given `&str` is a suffix of the string.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// assert!(\"banana\".ends_with(\"nana\"));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::ends_with(&self[..], pat)\n+    }\n+\n+    /// Returns a string with all pre- and suffixes that match a pattern repeatedly removed.\n+    ///\n+    /// The pattern can be a simple `&str`, or a closure that determines the split.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple `&str` patterns:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n+    ///\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"123foo1bar123\".trim_matches(|c: char| c.is_numeric()), \"foo1bar\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+        where P::Searcher: DoubleEndedSearcher<'a>\n+    {\n+        core_str::StrExt::trim_matches(&self[..], pat)\n+    }\n+\n+    /// Returns a string with all prefixes that match a pattern repeatedly removed.\n+    ///\n+    /// The pattern can be a simple `&str`, or a closure that determines the split.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple `&str` patterns:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n+    ///\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"123foo1bar123\".trim_left_matches(|c: char| c.is_numeric()), \"foo1bar123\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n+        core_str::StrExt::trim_left_matches(&self[..], pat)\n+    }\n+\n+    /// Returns a string with all suffixes that match a pattern repeatedly removed.\n+    ///\n+    /// The pattern can be a simple `&str`, or a closure that determines the split.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple `&str` patterns:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"123foo1bar123\".trim_right_matches(|c: char| c.is_numeric()), \"123foo1bar\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::trim_right_matches(&self[..], pat)\n+    }\n+\n+    /// Check that `index`-th byte lies at the start and/or end of a UTF-8 code point sequence.\n+    ///\n+    /// The start and end of the string (when `index == self.len()`) are considered to be\n+    /// boundaries.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `index` is greater than `self.len()`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert!(s.is_char_boundary(0));\n+    /// // start of `\u8001`\n+    /// assert!(s.is_char_boundary(6));\n+    /// assert!(s.is_char_boundary(s.len()));\n+    ///\n+    /// // second byte of `\u00f6`\n+    /// assert!(!s.is_char_boundary(2));\n+    ///\n+    /// // third byte of `\u8001`\n+    /// assert!(!s.is_char_boundary(8));\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"naming is uncertain with container conventions\")]\n+    pub fn is_char_boundary(&self, index: usize) -> bool {\n+        core_str::StrExt::is_char_boundary(&self[..], index)\n+    }\n+\n+    /// Given a byte position, return the next char and its index.\n+    ///\n+    /// This can be used to iterate over the Unicode characters of a string.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `i` is greater than or equal to the length of the string.\n+    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This example manually iterates through the characters of a string; this should normally be\n+    /// done by `.chars()` or `.char_indices()`.\n+    ///\n+    /// ```\n+    /// use std::str::CharRange;\n+    ///\n+    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+    /// let mut i = 0;\n+    /// while i < s.len() {\n+    ///     let CharRange {ch, next} = s.char_range_at(i);\n+    ///     println!(\"{}: {}\", i, ch);\n+    ///     i = next;\n+    /// }\n+    /// ```\n+    ///\n+    /// This outputs:\n+    ///\n+    /// ```text\n+    /// 0: \u4e2d\n+    /// 3: \u534e\n+    /// 6: V\n+    /// 7: i\n+    /// 8: \u1ec7\n+    /// 11: t\n+    /// 12:\n+    /// 13: N\n+    /// 14: a\n+    /// 15: m\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"naming is uncertain with container conventions\")]\n+    pub fn char_range_at(&self, start: usize) -> CharRange {\n+        core_str::StrExt::char_range_at(&self[..], start)\n+    }\n+\n+    /// Given a byte position, return the previous `char` and its position.\n+    ///\n+    /// This function can be used to iterate over a Unicode string in reverse.\n+    ///\n+    /// Returns 0 for next index if called on start index 0.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `i` is greater than the length of the string.\n+    /// If `i` is not an index following a valid UTF-8 character.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This example manually iterates through the characters of a string; this should normally be\n+    /// done by `.chars().rev()` or `.char_indices()`.\n+    ///\n+    /// ```\n+    /// use std::str::CharRange;\n+    ///\n+    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+    /// let mut i = s.len();\n+    /// while i > 0 {\n+    ///     let CharRange {ch, next} = s.char_range_at_reverse(i);\n+    ///     println!(\"{}: {}\", i, ch);\n+    ///     i = next;\n+    /// }\n+    /// ```\n+    ///\n+    /// This outputs:\n+    ///\n+    /// ```text\n+    /// 16: m\n+    /// 15: a\n+    /// 14: N\n+    /// 13:\n+    /// 12: t\n+    /// 11: \u1ec7\n+    /// 8: i\n+    /// 7: V\n+    /// 6: \u534e\n+    /// 3: \u4e2d\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"naming is uncertain with container conventions\")]\n+    pub fn char_range_at_reverse(&self, start: usize) -> CharRange {\n+        core_str::StrExt::char_range_at_reverse(&self[..], start)\n+    }\n+\n+    /// Given a byte position, return the `char` at that position.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `i` is greater than or equal to the length of the string.\n+    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"ab\u03c0c\";\n+    /// assert_eq!(s.char_at(1), 'b');\n+    /// assert_eq!(s.char_at(2), '\u03c0');\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"naming is uncertain with container conventions\")]\n+    pub fn char_at(&self, i: usize) -> char {\n+        core_str::StrExt::char_at(&self[..], i)\n+    }\n+\n+    /// Given a byte position, return the `char` at that position, counting from the end.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `i` is greater than the length of the string.\n+    /// If `i` is not an index following a valid UTF-8 character.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"ab\u03c0c\";\n+    /// assert_eq!(s.char_at_reverse(1), 'a');\n+    /// assert_eq!(s.char_at_reverse(2), 'b');\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"naming is uncertain with container conventions\")]\n+    pub fn char_at_reverse(&self, i: usize) -> char {\n+        core_str::StrExt::char_at_reverse(&self[..], i)\n+    }\n+\n+    /// Convert `self` to a byte slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!(\"bors\".as_bytes(), b\"bors\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn as_bytes(&self) -> &[u8] {\n+        core_str::StrExt::as_bytes(&self[..])\n+    }\n+\n+    /// Returns the byte index of the first character of `self` that matches the pattern, if it\n+    /// exists.\n+    ///\n+    /// Returns `None` if it doesn't exist.\n+    ///\n+    /// The pattern can be a simple `&str`, or a closure that determines the split.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple `&str` patterns:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find('L'), Some(0));\n+    /// assert_eq!(s.find('\u00e9'), Some(14));\n+    ///\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find(|c: char| c.is_whitespace()), Some(5));\n+    /// ```\n+    ///\n+    /// Not finding the pattern:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let x: &[_] = &['1', '2'];\n+    ///\n+    /// assert_eq!(s.find(x), None);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n+        core_str::StrExt::find(&self[..], pat)\n+    }\n+\n+    /// Returns the byte index of the last character of `self` that matches the pattern, if it\n+    /// exists.\n+    ///\n+    /// Returns `None` if it doesn't exist.\n+    ///\n+    /// The pattern can be a simple `&str`, or a closure that determines the split.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple `&str` patterns:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.rfind('L'), Some(13));\n+    /// assert_eq!(s.rfind('\u00e9'), Some(14));\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.rfind(|c: char| c.is_whitespace()), Some(12));\n+    /// ```\n+    ///\n+    /// Not finding the pattern:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let x: &[_] = &['1', '2'];\n+    ///\n+    /// assert_eq!(s.rfind(x), None);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        core_str::StrExt::rfind(&self[..], pat)\n+    }\n+\n+    /// Returns the byte index of the first matching substring if it exists.\n+    ///\n+    /// Returns `None` if it doesn't exist.\n+    ///\n+    /// The pattern can be a simple `&str`, or a closure that determines the split.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n+    /// assert_eq!(s.find_str(\"muffin man\"), None);\n+    /// ```\n+    #[unstable(feature = \"collections\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use `find()` with a `&str`\")]\n+    pub fn find_str<'a, P: Pattern<'a>>(&'a self, needle: P) -> Option<usize> {\n+        core_str::StrExt::find_str(&self[..], needle)\n+    }\n+\n+    /// Retrieves the first character from a `&str` and returns it.\n+    ///\n+    /// This does not allocate a new string; instead, it returns a slice that points one character\n+    /// beyond the character that was shifted.\n+    ///\n+    /// If the slice does not contain any characters, None is returned instead.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let (c, s1) = s.slice_shift_char().unwrap();\n+    ///\n+    /// assert_eq!(c, 'L');\n+    /// assert_eq!(s1, \"\u00f6we \u8001\u864e L\u00e9opard\");\n+    ///\n+    /// let (c, s2) = s1.slice_shift_char().unwrap();\n+    ///\n+    /// assert_eq!(c, '\u00f6');\n+    /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"awaiting conventions about shifting and slices\")]\n+    pub fn slice_shift_char(&self) -> Option<(char, &str)> {\n+        core_str::StrExt::slice_shift_char(&self[..])\n+    }\n+\n+    /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `inner` is not a direct slice contained within self.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let string = \"a\\nb\\nc\";\n+    /// let lines: Vec<&str> = string.lines().collect();\n+    ///\n+    /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n+    /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n+    /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"awaiting convention about comparability of arbitrary slices\")]\n+    pub fn subslice_offset(&self, inner: &str) -> usize {\n+        core_str::StrExt::subslice_offset(&self[..], inner)\n+    }\n+\n+    /// Return an unsafe pointer to the `&str`'s buffer.\n+    ///\n+    /// The caller must ensure that the string outlives this pointer, and that it is not\n+    /// reallocated (e.g. by pushing to the string).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"Hello\";\n+    /// let p = s.as_ptr();\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn as_ptr(&self) -> *const u8 {\n+        core_str::StrExt::as_ptr(&self[..])\n+    }\n+\n+    /// Return an iterator of `u16` over the string encoded as UTF-16.\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may only be provided by libunicode\")]\n+    pub fn utf16_units(&self) -> Utf16Units {\n+        Utf16Units { encoder: Utf16Encoder::new(self[..].chars()) }\n+    }\n+\n+    /// Returns the length of `self` in bytes.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!(\"foo\".len(), 3);\n+    /// assert_eq!(\"\u0192oo\".len(), 4); // fancy f!\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        core_str::StrExt::len(&self[..])\n+    }\n+\n+    /// Returns true if this slice has a length of zero bytes.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert!(\"\".is_empty());\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_empty(&self) -> bool {\n+        core_str::StrExt::is_empty(&self[..])\n+    }\n+\n+    /// Parses `self` into the specified type.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Will return `Err` if it's not possible to parse `self` into the type.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// assert_eq!(\"4\".parse::<u32>(), Ok(4));\n+    /// ```\n+    ///\n+    /// Failing:\n+    ///\n+    /// ```\n+    /// assert!(\"j\".parse::<u32>().is_err());\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn parse<F: FromStr>(&self) -> Result<F, F::Err> {\n+        core_str::StrExt::parse(&self[..])\n+    }\n+\n+    /// Returns an iterator over the [grapheme clusters][graphemes] of `self`.\n+    ///\n+    /// [graphemes]: http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries\n+    ///\n+    /// If `is_extended` is true, the iterator is over the *extended grapheme clusters*;\n+    /// otherwise, the iterator is over the *legacy grapheme clusters*.\n+    /// [UAX#29](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\n+    /// recommends extended grapheme cluster boundaries for general processing.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let gr1 = \"a\\u{310}e\\u{301}o\\u{308}\\u{332}\".graphemes(true).collect::<Vec<&str>>();\n+    /// let b: &[_] = &[\"a\\u{310}\", \"e\\u{301}\", \"o\\u{308}\\u{332}\"];\n+    ///\n+    /// assert_eq!(gr1.as_slice(), b);\n+    ///\n+    /// let gr2 = \"a\\r\\nb\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\".graphemes(true).collect::<Vec<&str>>();\n+    /// let b: &[_] = &[\"a\", \"\\r\\n\", \"b\", \"\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\"];\n+    ///\n+    /// assert_eq!(gr2.as_slice(), b);\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may only be provided by libunicode\")]\n+    pub fn graphemes(&self, is_extended: bool) -> Graphemes {\n+        UnicodeStr::graphemes(&self[..], is_extended)\n+    }\n+\n+    /// Returns an iterator over the grapheme clusters of `self` and their byte offsets. See\n+    /// `graphemes()` for more information.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let gr_inds = \"a\u0310e\u0301o\u0308\u0332\\r\\n\".grapheme_indices(true).collect::<Vec<(usize, &str)>>();\n+    /// let b: &[_] = &[(0, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n+    ///\n+    /// assert_eq!(gr_inds.as_slice(), b);\n+    /// ```\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may only be provided by libunicode\")]\n+    pub fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n+        UnicodeStr::grapheme_indices(&self[..], is_extended)\n+    }\n+\n+    /// An iterator over the non-empty words of `self`.\n+    ///\n+    /// A 'word' is a subsequence separated by any sequence of whitespace. Sequences of whitespace\n+    /// are collapsed, so empty \"words\" are not included.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n+    /// let v: Vec<&str> = some_words.words().collect();\n+    ///\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    /// ```\n+    #[unstable(feature = \"str_words\",\n+               reason = \"the precise algorithm to use is unclear\")]\n+    pub fn words(&self) -> Words {\n+        UnicodeStr::words(&self[..])\n+    }\n+\n+    /// Returns a string's displayed width in columns.\n+    ///\n+    /// Control characters have zero width.\n+    ///\n+    /// `is_cjk` determines behavior for characters in the Ambiguous category: if `is_cjk` is\n+    /// `true`, these are 2 columns wide; otherwise, they are 1. In CJK locales, `is_cjk` should be\n+    /// `true`, else it should be `false`.\n+    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/) recommends that these\n+    /// characters be treated as 1 column (i.e., `is_cjk = false`) if the locale is unknown.\n+    #[unstable(feature = \"collections\",\n+               reason = \"this functionality may only be provided by libunicode\")]\n+    pub fn width(&self, is_cjk: bool) -> usize {\n+        UnicodeStr::width(&self[..], is_cjk)\n+    }\n+\n+    /// Returns a `&str` with leading and trailing whitespace removed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    /// assert_eq!(s.trim(), \"Hello\\tworld\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim(&self) -> &str {\n+        UnicodeStr::trim(&self[..])\n+    }\n+\n+    /// Returns a `&str` with leading whitespace removed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    /// assert_eq!(s.trim_left(), \"Hello\\tworld\\t\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_left(&self) -> &str {\n+        UnicodeStr::trim_left(&self[..])\n+    }\n+\n+    /// Returns a `&str` with trailing whitespace removed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    /// assert_eq!(s.trim_right(), \" Hello\\tworld\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn trim_right(&self) -> &str {\n+        UnicodeStr::trim_right(&self[..])\n+    }\n+\n+    /// Returns the lowercase equivalent of this string.\n+    ///\n+    /// # Examples\n+    ///\n+    /// let s = \"HELLO\";\n+    /// assert_eq!(s.to_lowercase(), \"hello\");\n+    #[unstable(feature = \"collections\")]\n+    pub fn to_lowercase(&self) -> String {\n+        let mut s = String::with_capacity(self.len());\n+        s.extend(self[..].chars().flat_map(|c| c.to_lowercase()));\n+        return s;\n+    }\n+\n+    /// Returns the uppercase equivalent of this string.\n+    ///\n+    /// # Examples\n+    ///\n+    /// let s = \"hello\";\n+    /// assert_eq!(s.to_uppercase(), \"HELLO\");\n+    #[unstable(feature = \"collections\")]\n+    pub fn to_uppercase(&self) -> String {\n+        let mut s = String::with_capacity(self.len());\n+        s.extend(self[..].chars().flat_map(|c| c.to_uppercase()));\n+        return s;\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use prelude::*;"}, {"sha": "47069a81d85852df093472e9e23c3b5144d0a0ca", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=5b118f5ecde796ad62fa349a045d7ad8129b711c", "patch": "@@ -23,6 +23,7 @@ use ops::Deref;\n use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n use slice::{self, SliceExt};\n+#[cfg(stage0)]\n use str::StrExt;\n use string::String;\n use vec::Vec;"}, {"sha": "ce3b690098fc68a78c503927de4730fb624ba4e7", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=5b118f5ecde796ad62fa349a045d7ad8129b711c", "patch": "@@ -25,7 +25,10 @@ use result::Result::{Ok, Err};\n use result;\n use slice::{self, SliceExt};\n use string::String;\n+#[cfg(stage0)]\n use str::{self, StrExt};\n+#[cfg(not(stage0))]\n+use str;\n use vec::Vec;\n \n pub use self::buffered::{BufReader, BufWriter, BufStream, LineWriter};"}, {"sha": "968ffcf62257c6732e78a789960f3f19b1b5ccb8", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=5b118f5ecde796ad62fa349a045d7ad8129b711c", "patch": "@@ -24,6 +24,7 @@ use num::{self, Int, Float, ToPrimitive};\n use num::FpCategory as Fp;\n use ops::FnMut;\n use slice::SliceExt;\n+#[cfg(stage0)]\n use str::StrExt;\n use string::String;\n use vec::Vec;"}, {"sha": "23a7c3d1114ac3812926757463a5ef34a911d66a", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=5b118f5ecde796ad62fa349a045d7ad8129b711c", "patch": "@@ -269,6 +269,7 @@ use result::Result;\n use result::Result::{Ok, Err};\n use sys;\n use slice::SliceExt;\n+#[cfg(stage0)]\n use str::StrExt;\n use str;\n use string::String;"}, {"sha": "f71fa9f92baf7d9d263aa66d4d26ee15567bf39b", "filename": "src/libstd/old_io/net/ip.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs?ref=5b118f5ecde796ad62fa349a045d7ad8129b711c", "patch": "@@ -27,7 +27,10 @@ use option::Option;\n use option::Option::{None, Some};\n use result::Result::{self, Ok, Err};\n use slice::SliceExt;\n+#[cfg(stage0)]\n use str::{FromStr, StrExt};\n+#[cfg(not(stage0))]\n+use str::FromStr;\n use vec::Vec;\n \n pub type Port = u16;"}, {"sha": "647ef7306178a40dd793adcbe028d313b2be692a", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=5b118f5ecde796ad62fa349a045d7ad8129b711c", "patch": "@@ -761,7 +761,7 @@ mod tests {\n     use old_io::{Truncate, Write, TimedOut, timer, process, FileNotFound};\n     use prelude::v1::{Ok, Err, range, drop, Some, None, Vec};\n     use prelude::v1::{Path, String, Reader, Writer, Clone};\n-    use prelude::v1::{SliceExt, Str, StrExt, AsSlice, ToString, GenericPath};\n+    use prelude::v1::{SliceExt, Str, AsSlice, ToString, GenericPath};\n     use old_io::fs::PathExtensions;\n     use old_io::timer::*;\n     use rt::running_on_valgrind;"}, {"sha": "0e6a4b60e773b5e1c88966dcbcf61c6b170267f7", "filename": "src/libstd/old_io/stdio.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=5b118f5ecde796ad62fa349a045d7ad8129b711c", "patch": "@@ -44,6 +44,7 @@ use ptr;\n use result::Result::{Ok, Err};\n use rt;\n use slice::SliceExt;\n+#[cfg(stage0)]\n use str::StrExt;\n use string::String;\n use sys::{fs, tty};"}, {"sha": "b34804fce61c0e4cb71e34c3e26e6b3c17652984", "filename": "src/libstd/old_io/tempfile.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fold_io%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fold_io%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftempfile.rs?ref=5b118f5ecde796ad62fa349a045d7ad8129b711c", "patch": "@@ -21,6 +21,7 @@ use option::Option;\n use old_path::{Path, GenericPath};\n use rand::{Rng, thread_rng};\n use result::Result::{Ok, Err};\n+#[cfg(stage0)]\n use str::StrExt;\n use string::String;\n "}, {"sha": "3f9cfbd2a07af03944cbccd36f1e64606d83390e", "filename": "src/libstd/old_path/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fold_path%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fold_path%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fmod.rs?ref=5b118f5ecde796ad62fa349a045d7ad8129b711c", "patch": "@@ -72,6 +72,7 @@ use iter::IteratorExt;\n use option::Option;\n use option::Option::{None, Some};\n use str;\n+#[cfg(stage0)]\n use str::StrExt;\n use string::{String, CowString};\n use slice::SliceExt;"}, {"sha": "790dd87ae91f8da5d6e752f943d66d70da7974bb", "filename": "src/libstd/old_path/posix.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fold_path%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fold_path%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fposix.rs?ref=5b118f5ecde796ad62fa349a045d7ad8129b711c", "patch": "@@ -21,7 +21,10 @@ use marker::Sized;\n use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n use slice::{AsSlice, Split, SliceExt, SliceConcatExt};\n+#[cfg(stage0)]\n use str::{self, FromStr, StrExt};\n+#[cfg(not(stage0))]\n+use str::{self, FromStr};\n use vec::Vec;\n \n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n@@ -448,7 +451,7 @@ mod tests {\n     use option::Option::{self, Some, None};\n     use old_path::GenericPath;\n     use slice::{AsSlice, SliceExt};\n-    use str::{self, Str, StrExt};\n+    use str::{self, Str};\n     use string::ToString;\n     use vec::Vec;\n "}, {"sha": "4e36befefe8096975133bbedcc156816c92e13e3", "filename": "src/libstd/old_path/windows.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=5b118f5ecde796ad62fa349a045d7ad8129b711c", "patch": "@@ -28,7 +28,10 @@ use mem;\n use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n use slice::{SliceExt, SliceConcatExt};\n+#[cfg(stage0)]\n use str::{SplitTerminator, FromStr, StrExt};\n+#[cfg(not(stage0))]\n+use str::{SplitTerminator, FromStr};\n use string::{String, ToString};\n use vec::Vec;\n "}, {"sha": "2e869312946154ec325538511e491f70eef08ecf", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=5b118f5ecde796ad62fa349a045d7ad8129b711c", "patch": "@@ -57,7 +57,10 @@ use ptr;\n use result::Result::{Err, Ok};\n use result::Result;\n use slice::{AsSlice, SliceExt};\n+#[cfg(stage0)]\n use str::{Str, StrExt};\n+#[cfg(not(stage0))]\n+use str::Str;\n use str;\n use string::{String, ToString};\n use sync::atomic::{AtomicIsize, ATOMIC_ISIZE_INIT, Ordering};"}, {"sha": "81cdced58bd8008680070f85b95b18141d37df14", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=5b118f5ecde796ad62fa349a045d7ad8129b711c", "patch": "@@ -46,8 +46,12 @@\n #[doc(no_inline)] pub use result::Result::{self, Ok, Err};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use slice::{SliceExt, SliceConcatExt, AsSlice};\n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use str::{Str, StrExt};\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)] pub use str::Str;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use string::{String, ToString};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "db613db74cf4a470000f078348c4fb3bba334c83", "filename": "src/libstd/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=5b118f5ecde796ad62fa349a045d7ad8129b711c", "patch": "@@ -533,7 +533,7 @@ mod tests {\n     use io::prelude::*;\n     use prelude::v1::{Ok, Err, drop, Some, Vec};\n     use prelude::v1::{String, Clone};\n-    use prelude::v1::{SliceExt, Str, StrExt, AsSlice, ToString, GenericPath};\n+    use prelude::v1::{SliceExt, Str, AsSlice, ToString, GenericPath};\n     use old_path;\n     use old_io::fs::PathExtensions;\n     use rt::running_on_valgrind;"}, {"sha": "d05e2ba0e19494d4f8ab9360858381cf0004728d", "filename": "src/test/compile-fail/method-suggestion-no-duplication.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Ftest%2Fcompile-fail%2Fmethod-suggestion-no-duplication.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b118f5ecde796ad62fa349a045d7ad8129b711c/src%2Ftest%2Fcompile-fail%2Fmethod-suggestion-no-duplication.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-suggestion-no-duplication.rs?ref=5b118f5ecde796ad62fa349a045d7ad8129b711c", "patch": "@@ -20,5 +20,4 @@ fn main() {\n     //~^^ HELP #1: `core::slice::SliceExt`\n     //~^^^ HELP #2: `core::str::StrExt`\n     //~^^^^ HELP #3: `collections::slice::SliceExt`\n-    //~^^^^^ HELP #4: `collections::str::StrExt`\n }"}]}