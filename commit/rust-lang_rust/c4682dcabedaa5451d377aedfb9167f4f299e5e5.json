{"sha": "c4682dcabedaa5451d377aedfb9167f4f299e5e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0NjgyZGNhYmVkYWE1NDUxZDM3N2FlZGZiOTE2N2Y0ZjI5OWU1ZTU=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-02-28T19:30:27Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-03-07T04:37:28Z"}, "message": "Convert match on enums to use trans::adt.", "tree": {"sha": "4430629dec2ee2db255015de8d95ffc3749ee07f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4430629dec2ee2db255015de8d95ffc3749ee07f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4682dcabedaa5451d377aedfb9167f4f299e5e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4682dcabedaa5451d377aedfb9167f4f299e5e5", "html_url": "https://github.com/rust-lang/rust/commit/c4682dcabedaa5451d377aedfb9167f4f299e5e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4682dcabedaa5451d377aedfb9167f4f299e5e5/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "626ad484fecc5703f46812c7916fce6fec03ace9", "url": "https://api.github.com/repos/rust-lang/rust/commits/626ad484fecc5703f46812c7916fce6fec03ace9", "html_url": "https://github.com/rust-lang/rust/commit/626ad484fecc5703f46812c7916fce6fec03ace9"}], "stats": {"total": 134, "additions": 51, "deletions": 83}, "files": [{"sha": "e3f719229aff2ac87b82fdb12228b221c85975fc", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 51, "deletions": 83, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/c4682dcabedaa5451d377aedfb9167f4f299e5e5/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4682dcabedaa5451d377aedfb9167f4f299e5e5/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=c4682dcabedaa5451d377aedfb9167f4f299e5e5", "patch": "@@ -151,6 +151,7 @@ use middle::const_eval;\n use middle::borrowck::root_map_key;\n use middle::pat_util::*;\n use middle::resolve::DefMap;\n+use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::callee;\n@@ -191,15 +192,15 @@ pub enum Lit {\n // range)\n pub enum Opt {\n     lit(Lit),\n-    var(/* disr val */int, /* variant dids (enm, var) */(def_id, def_id)),\n+    var(/* disr val */int, adt::Repr),\n     range(@ast::expr, @ast::expr),\n     vec_len_eq(uint),\n     vec_len_ge(uint)\n }\n \n pub fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n-    match (*a, *b) {\n-      (lit(a), lit(b)) => {\n+    match (a, b) {\n+      (&lit(a), &lit(b)) => {\n         match (a, b) {\n             (UnitLikeStructLit(a), UnitLikeStructLit(b)) => a == b,\n             _ => {\n@@ -233,13 +234,13 @@ pub fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n             }\n         }\n       }\n-      (range(a1, a2), range(b1, b2)) => {\n+      (&range(a1, a2), &range(b1, b2)) => {\n         const_eval::compare_lit_exprs(tcx, a1, b1) == 0 &&\n         const_eval::compare_lit_exprs(tcx, a2, b2) == 0\n       }\n-      (var(a, _), var(b, _)) => a == b,\n-      (vec_len_eq(a), vec_len_eq(b)) => a == b,\n-      (vec_len_ge(a), vec_len_ge(b)) => a == b,\n+      (&var(a, _), &var(b, _)) => a == b,\n+      (&vec_len_eq(a), &vec_len_eq(b)) => a == b,\n+      (&vec_len_ge(a), &vec_len_ge(b)) => a == b,\n       _ => false\n     }\n }\n@@ -267,8 +268,8 @@ pub fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n             let llval = consts::get_const_val(bcx.ccx(), lit_id);\n             return single_result(rslt(bcx, llval));\n         }\n-        var(disr_val, _) => {\n-            return single_result(rslt(bcx, C_int(ccx, disr_val)));\n+        var(disr_val, ref repr) => {\n+            return adt::trans_case(bcx, repr, disr_val);\n         }\n         range(l1, l2) => {\n             return range_result(rslt(bcx, consts::const_expr(ccx, l1)),\n@@ -283,13 +284,16 @@ pub fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n     }\n }\n \n-pub fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> Opt {\n-    match tcx.def_map.get(&pat_id) {\n+pub fn variant_opt(bcx: block, pat_id: ast::node_id)\n+    -> Opt {\n+    let ccx = bcx.ccx();\n+    match ccx.tcx.def_map.get(&pat_id) {\n         ast::def_variant(enum_id, var_id) => {\n-            let variants = ty::enum_variants(tcx, enum_id);\n+            let variants = ty::enum_variants(ccx.tcx, enum_id);\n             for vec::each(*variants) |v| {\n                 if var_id == v.id {\n-                    return var(v.disr_val, (enum_id, var_id));\n+                    return var(v.disr_val,\n+                               adt::represent_node(bcx, pat_id))\n                 }\n             }\n             ::core::util::unreachable();\n@@ -298,7 +302,7 @@ pub fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> Opt {\n             return lit(UnitLikeStructLit(pat_id));\n         }\n         _ => {\n-            tcx.sess.bug(~\"non-variant or struct in variant_opt()\");\n+            ccx.sess.bug(~\"non-variant or struct in variant_opt()\");\n         }\n     }\n }\n@@ -505,7 +509,7 @@ pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n     do enter_match(bcx, tcx.def_map, m, col, val) |p| {\n         match /*bad*/copy p.node {\n             ast::pat_enum(_, subpats) => {\n-                if opt_eq(tcx, &variant_opt(tcx, p.id), opt) {\n+                if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n                     Some(option::get_or_default(subpats,\n                                              vec::from_elem(variant_size,\n                                                             dummy)))\n@@ -515,7 +519,7 @@ pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n             }\n             ast::pat_ident(_, _, None)\n                     if pat_is_variant_or_struct(tcx.def_map, p) => {\n-                if opt_eq(tcx, &variant_opt(tcx, p.id), opt) {\n+                if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n                     Some(~[])\n                 } else {\n                     None\n@@ -537,7 +541,7 @@ pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n                 if opt_eq(tcx, &range(l1, l2), opt) {Some(~[])} else {None}\n             }\n             ast::pat_struct(_, field_pats, _) => {\n-                if opt_eq(tcx, &variant_opt(tcx, p.id), opt) {\n+                if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n                     // Look up the struct variant ID.\n                     let struct_id;\n                     match tcx.def_map.get(&p.id) {\n@@ -762,8 +766,9 @@ pub fn enter_region(bcx: block,\n // Returns the options in one column of matches. An option is something that\n // needs to be conditionally matched at runtime; for example, the discriminant\n // on a set of enum variants or a literal.\n-pub fn get_options(ccx: @CrateContext, m: &[@Match], col: uint) -> ~[Opt] {\n-    fn add_to_set(tcx: ty::ctxt, set: &DVec<Opt>, val: Opt) {\n+pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n+    let ccx = bcx.ccx();\n+    fn add_to_set(tcx: ty::ctxt, set: &DVec<Opt>, +val: Opt) {\n         if set.any(|l| opt_eq(tcx, l, &val)) {return;}\n         set.push(val);\n     }\n@@ -781,7 +786,7 @@ pub fn get_options(ccx: @CrateContext, m: &[@Match], col: uint) -> ~[Opt] {\n                 match ccx.tcx.def_map.find(&cur.id) {\n                     Some(ast::def_variant(*)) => {\n                         add_to_set(ccx.tcx, &found,\n-                                   variant_opt(ccx.tcx, cur.id));\n+                                   variant_opt(bcx, cur.id));\n                     }\n                     Some(ast::def_struct(*)) => {\n                         add_to_set(ccx.tcx, &found,\n@@ -800,7 +805,7 @@ pub fn get_options(ccx: @CrateContext, m: &[@Match], col: uint) -> ~[Opt] {\n                 match ccx.tcx.def_map.find(&cur.id) {\n                     Some(ast::def_variant(*)) => {\n                         add_to_set(ccx.tcx, &found,\n-                                   variant_opt(ccx.tcx, cur.id));\n+                                   variant_opt(bcx, cur.id));\n                     }\n                     _ => {}\n                 }\n@@ -827,34 +832,13 @@ pub struct ExtractedBlock {\n }\n \n pub fn extract_variant_args(bcx: block,\n-                            pat_id: ast::node_id,\n-                            vdefs: (def_id, def_id),\n+                            repr: &adt::Repr,\n+                            disr_val: int,\n                             val: ValueRef)\n-                         -> ExtractedBlock {\n-    let (enm, evar) = vdefs;\n+    -> ExtractedBlock {\n     let _icx = bcx.insn_ctxt(\"match::extract_variant_args\");\n-    let ccx = *bcx.fcx.ccx;\n-    let enum_ty_substs = match ty::get(node_id_type(bcx, pat_id)).sty {\n-      ty::ty_enum(id, ref substs) => {\n-        assert id == enm;\n-        /*bad*/copy (*substs).tps\n-      }\n-      _ => bcx.sess().bug(~\"extract_variant_args: pattern has non-enum type\")\n-    };\n-    let mut blobptr = val;\n-    let variants = ty::enum_variants(ccx.tcx, enm);\n-    let size = ty::enum_variant_with_id(ccx.tcx, enm,\n-                                        evar).args.len();\n-    if size > 0u && (*variants).len() != 1u {\n-        let enumptr =\n-            PointerCast(bcx, val, T_opaque_enum_ptr(ccx));\n-        blobptr = GEPi(bcx, enumptr, [0u, 1u]);\n-    }\n-    let vdefs_tg = enm;\n-    let vdefs_var = evar;\n-    let args = do vec::from_fn(size) |i| {\n-        GEP_enum(bcx, blobptr, vdefs_tg, vdefs_var,\n-                 /*bad*/copy enum_ty_substs, i)\n+    let args = do vec::from_fn(adt::num_args(repr, disr_val)) |i| {\n+        adt::trans_GEP(bcx, repr, val, disr_val, i)\n     };\n \n     ExtractedBlock { vals: args, bcx: bcx }\n@@ -1365,37 +1349,15 @@ pub fn compile_submatch(bcx: block,\n     }\n \n     // Decide what kind of branch we need\n-    let opts = get_options(ccx, m, col);\n+    let opts = get_options(bcx, m, col);\n     let mut kind = no_branch;\n     let mut test_val = val;\n     if opts.len() > 0u {\n         match opts[0] {\n-            var(_, (enm, _)) => {\n-                let variants = ty::enum_variants(tcx, enm);\n-                if variants.len() == 1 {\n-                    kind = single;\n-                } else {\n-                    let enumptr =\n-                        PointerCast(bcx, val, T_opaque_enum_ptr(ccx));\n-                    let discrimptr = GEPi(bcx, enumptr, [0u, 0u]);\n-\n-\n-                    assert variants.len() > 1;\n-                    let min_discrim = do variants.foldr(0) |&x, y| {\n-                        int::min(x.disr_val, y)\n-                    };\n-                    let max_discrim = do variants.foldr(0) |&x, y| {\n-                        int::max(x.disr_val, y)\n-                    };\n-\n-                    test_val = LoadRangeAssert(bcx, discrimptr,\n-                                               min_discrim as c_ulonglong,\n-                                               (max_discrim + 1)\n-                                               as c_ulonglong,\n-                                               lib::llvm::True);\n-\n-                    kind = switch;\n-                }\n+            var(_, ref repr) => {\n+                let (the_kind, val_opt) = adt::trans_switch(bcx, repr, val);\n+                kind = the_kind;\n+                for val_opt.each |&tval| { test_val = tval; }\n             }\n             lit(_) => {\n                 let pty = node_id_type(bcx, pat_id);\n@@ -1544,11 +1506,12 @@ pub fn compile_submatch(bcx: block,\n         let mut size = 0u;\n         let mut unpacked = ~[];\n         match *opt {\n-            var(_, vdef) => {\n-                let args = extract_variant_args(opt_cx, pat_id, vdef, val);\n-                size = args.vals.len();\n-                unpacked = /*bad*/copy args.vals;\n-                opt_cx = args.bcx;\n+            var(disr_val, ref repr) => {\n+                let ExtractedBlock {vals: argvals, bcx: new_bcx} =\n+                    extract_variant_args(opt_cx, repr, disr_val, val);\n+                size = argvals.len();\n+                unpacked = argvals;\n+                opt_cx = new_bcx;\n             }\n             vec_len_eq(n) | vec_len_ge(n) => {\n                 let tail = match *opt {\n@@ -1757,10 +1720,15 @@ pub fn bind_irrefutable_pat(bcx: block,\n         }\n         ast::pat_enum(_, sub_pats) => {\n             match bcx.tcx().def_map.find(&pat.id) {\n-                Some(ast::def_variant(*)) => {\n-                    let pat_def = ccx.tcx.def_map.get(&pat.id);\n-                    let vdefs = ast_util::variant_def_ids(pat_def);\n-                    let args = extract_variant_args(bcx, pat.id, vdefs, val);\n+                Some(ast::def_variant(enum_id, var_id)) => {\n+                    let repr = adt::represent_node(bcx, pat.id);\n+                    let vinfo = ty::enum_variant_with_id(ccx.tcx,\n+                                                         enum_id,\n+                                                         var_id);\n+                    let args = extract_variant_args(bcx,\n+                                                    &repr,\n+                                                    vinfo.disr_val,\n+                                                    val);\n                     for sub_pats.each |sub_pat| {\n                         for vec::eachi(args.vals) |i, argval| {\n                             bcx = bind_irrefutable_pat(bcx,"}]}