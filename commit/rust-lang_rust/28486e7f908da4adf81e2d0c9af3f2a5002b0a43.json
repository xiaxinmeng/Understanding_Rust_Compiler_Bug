{"sha": "28486e7f908da4adf81e2d0c9af3f2a5002b0a43", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4NDg2ZTdmOTA4ZGE0YWRmODFlMmQwYzlhZjNmMmE1MDAyYjBhNDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-20T00:11:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-20T00:11:40Z"}, "message": "Auto merge of #43247 - est31:master, r=alexcrichton\n\nTidy: allow common lang+lib features\n\nThis allows changes to the Rust language that have both library\nand language components share one feature gate.\n\nThe feature gates need to be \"about the same change\", so that both\nlibrary and language components must either be both unstable, or\nboth stable, and share the tracking issue.\n\nRemoves the ugly \"proc_macro\" exception added by #40939.\n\nCloses #43089", "tree": {"sha": "741a3c98b878d8b8c150b7015b81167457ad44be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/741a3c98b878d8b8c150b7015b81167457ad44be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28486e7f908da4adf81e2d0c9af3f2a5002b0a43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28486e7f908da4adf81e2d0c9af3f2a5002b0a43", "html_url": "https://github.com/rust-lang/rust/commit/28486e7f908da4adf81e2d0c9af3f2a5002b0a43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28486e7f908da4adf81e2d0c9af3f2a5002b0a43/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "582af6e1ad75c12320e7237ff4361a1ed3514124", "url": "https://api.github.com/repos/rust-lang/rust/commits/582af6e1ad75c12320e7237ff4361a1ed3514124", "html_url": "https://github.com/rust-lang/rust/commit/582af6e1ad75c12320e7237ff4361a1ed3514124"}, {"sha": "94fc09c68f36da4b35f870c9399743102bea393f", "url": "https://api.github.com/repos/rust-lang/rust/commits/94fc09c68f36da4b35f870c9399743102bea393f", "html_url": "https://github.com/rust-lang/rust/commit/94fc09c68f36da4b35f870c9399743102bea393f"}], "stats": {"total": 57, "additions": 41, "deletions": 16}, "files": [{"sha": "e72f249896913a6023e6cd199525fee9fc6379ed", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/28486e7f908da4adf81e2d0c9af3f2a5002b0a43/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28486e7f908da4adf81e2d0c9af3f2a5002b0a43/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=28486e7f908da4adf81e2d0c9af3f2a5002b0a43", "patch": "@@ -50,6 +50,34 @@ pub struct Feature {\n     pub tracking_issue: Option<u32>,\n }\n \n+impl Feature {\n+    fn check_match(&self, other: &Feature)-> Result<(), Vec<&'static str>> {\n+        let mut mismatches = Vec::new();\n+        if self.level != other.level {\n+            mismatches.push(\"stability level\");\n+        }\n+        if self.level == Status::Stable || other.level == Status::Stable {\n+            // As long as a feature is unstable, the since field tracks\n+            // when the given part of the feature has been implemented.\n+            // Mismatches are tolerable as features evolve and functionality\n+            // gets added.\n+            // Once a feature is stable, the since field tracks the first version\n+            // it was part of the stable distribution, and mismatches are disallowed.\n+            if self.since != other.since {\n+                mismatches.push(\"since\");\n+            }\n+        }\n+        if self.tracking_issue != other.tracking_issue {\n+            mismatches.push(\"tracking issue\");\n+        }\n+        if mismatches.is_empty() {\n+            Ok(())\n+        } else {\n+            Err(mismatches)\n+        }\n+    }\n+}\n+\n pub type Features = HashMap<String, Feature>;\n \n pub fn check(path: &Path, bad: &mut bool, quiet: bool) {\n@@ -242,23 +270,20 @@ fn get_and_check_lib_features(base_src_path: &Path,\n                      &mut |res, file, line| {\n             match res {\n                 Ok((name, f)) => {\n-                    let mut err = |msg: &str| {\n-                        tidy_error!(bad, \"{}:{}: {}\", file.display(), line, msg);\n-                    };\n-                    if lang_features.contains_key(name) && name != \"proc_macro\" {\n-                        err(\"duplicating a lang feature\");\n-                    }\n-                    if let Some(ref s) = lib_features.get(name) {\n-                        if s.level != f.level {\n-                            err(\"different stability level than before\");\n-                        }\n-                        if s.since != f.since {\n-                            err(\"different `since` than before\");\n+                    let mut check_features = |f: &Feature, list: &Features, display: &str| {\n+                        if let Some(ref s) = list.get(name) {\n+                            if let Err(m) = (&f).check_match(s) {\n+                                tidy_error!(bad,\n+                                            \"{}:{}: mismatches to {} in: {:?}\",\n+                                            file.display(),\n+                                            line,\n+                                            display,\n+                                            &m);\n+                            }\n                         }\n-                        if s.tracking_issue != f.tracking_issue {\n-                            err(\"different `tracking_issue` than before\");\n-                        }\n-                    }\n+                    };\n+                    check_features(&f, &lang_features, \"corresponding lang feature\");\n+                    check_features(&f, &lib_features, \"previous\");\n                     lib_features.insert(name.to_owned(), f);\n                 },\n                 Err(msg) => {"}]}