{"sha": "1202cb0e2b168b0a913b33e3cb3c1d9339683e28", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyMDJjYjBlMmIxNjhiMGE5MTNiMzNlM2NiM2MxZDkzMzk2ODNlMjg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-24T23:00:19Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-24T23:00:19Z"}, "message": "parser: simplify parse_pat_with_or_{inner}", "tree": {"sha": "474ae56640079e2e2908ee2491b1ec2833006c25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/474ae56640079e2e2908ee2491b1ec2833006c25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1202cb0e2b168b0a913b33e3cb3c1d9339683e28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1202cb0e2b168b0a913b33e3cb3c1d9339683e28", "html_url": "https://github.com/rust-lang/rust/commit/1202cb0e2b168b0a913b33e3cb3c1d9339683e28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1202cb0e2b168b0a913b33e3cb3c1d9339683e28/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ab84303326fff65d5d0a168fd47448e05135c9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ab84303326fff65d5d0a168fd47448e05135c9f", "html_url": "https://github.com/rust-lang/rust/commit/0ab84303326fff65d5d0a168fd47448e05135c9f"}], "stats": {"total": 27, "additions": 10, "deletions": 17}, "files": [{"sha": "7c09dc4e566341efc3b087318d6f666d65ac64a5", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1202cb0e2b168b0a913b33e3cb3c1d9339683e28/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1202cb0e2b168b0a913b33e3cb3c1d9339683e28/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=1202cb0e2b168b0a913b33e3cb3c1d9339683e28", "patch": "@@ -49,7 +49,7 @@ impl<'a> Parser<'a> {\n         let gated_leading_vert = self.eat_or_separator() && gate_or == GateOr::Yes;\n \n         // Parse the possibly-or-pattern.\n-        let pat = self.parse_pat_with_or(None, gate_or, TopLevel::Yes)?;\n+        let pat = self.parse_pat_with_or(gate_or, TopLevel::Yes)?;\n \n         // If we parsed a leading `|` which should be gated,\n         // and no other gated or-pattern has been parsed thus far,\n@@ -67,14 +67,9 @@ impl<'a> Parser<'a> {\n \n     /// Parses a pattern, that may be a or-pattern (e.g. `Foo | Bar` in `Some(Foo | Bar)`).\n     /// Corresponds to `pat<allow_top_alt>` in RFC 2535.\n-    fn parse_pat_with_or(\n-        &mut self,\n-        expected: Expected,\n-        gate_or: GateOr,\n-        top_level: TopLevel,\n-    ) -> PResult<'a, P<Pat>> {\n+    fn parse_pat_with_or(&mut self, gate_or: GateOr, top_level: TopLevel) -> PResult<'a, P<Pat>> {\n         // Parse the first pattern.\n-        let first_pat = self.parse_pat(expected)?;\n+        let first_pat = self.parse_pat(None)?;\n         self.maybe_recover_unexpected_comma(first_pat.span, top_level)?;\n \n         // If the next token is not a `|`,\n@@ -86,7 +81,7 @@ impl<'a> Parser<'a> {\n         let lo = first_pat.span;\n         let mut pats = vec![first_pat];\n         while self.eat_or_separator() {\n-            let pat = self.parse_pat(expected)?;\n+            let pat = self.parse_pat(None)?;\n             self.maybe_recover_unexpected_comma(pat.span, top_level)?;\n             pats.push(pat);\n         }\n@@ -177,9 +172,9 @@ impl<'a> Parser<'a> {\n \n     /// Recursive possibly-or-pattern parser with recovery for an erroneous leading `|`.\n     /// See `parse_pat_with_or` for details on parsing or-patterns.\n-    fn parse_pat_with_or_inner(&mut self, expected: Expected) -> PResult<'a, P<Pat>> {\n+    fn parse_pat_with_or_inner(&mut self) -> PResult<'a, P<Pat>> {\n         self.recover_inner_leading_vert();\n-        self.parse_pat_with_or(expected, GateOr::Yes, TopLevel::No)\n+        self.parse_pat_with_or(GateOr::Yes, TopLevel::No)\n     }\n \n     /// Recover if `|` or `||` is here.\n@@ -215,7 +210,7 @@ impl<'a> Parser<'a> {\n                 // Parse `[pat, pat,...]` as a slice pattern.\n                 let (pats, _) = self.parse_delim_comma_seq(\n                     token::Bracket,\n-                    |p| p.parse_pat_with_or_inner(None),\n+                    |p| p.parse_pat_with_or_inner(),\n                 )?;\n                 PatKind::Slice(pats)\n             }\n@@ -344,9 +339,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a tuple or parenthesis pattern.\n     fn parse_pat_tuple_or_parens(&mut self) -> PResult<'a, PatKind> {\n-        let (fields, trailing_comma) = self.parse_paren_comma_seq(|p| {\n-            p.parse_pat_with_or_inner(None)\n-        })?;\n+        let (fields, trailing_comma) = self.parse_paren_comma_seq(|p| p.parse_pat_with_or_inner())?;\n \n         // Here, `(pat,)` is a tuple pattern.\n         // For backward compatibility, `(..)` is a tuple pattern as well.\n@@ -589,7 +582,7 @@ impl<'a> Parser<'a> {\n             err.span_label(self.token.span, msg);\n             return Err(err);\n         }\n-        let (fields, _) = self.parse_paren_comma_seq(|p| p.parse_pat_with_or_inner(None))?;\n+        let (fields, _) = self.parse_paren_comma_seq(|p| p.parse_pat_with_or_inner())?;\n         Ok(PatKind::TupleStruct(path, fields))\n     }\n \n@@ -733,7 +726,7 @@ impl<'a> Parser<'a> {\n             // Parsing a pattern of the form \"fieldname: pat\"\n             let fieldname = self.parse_field_name()?;\n             self.bump();\n-            let pat = self.parse_pat_with_or_inner(None)?;\n+            let pat = self.parse_pat_with_or_inner()?;\n             hi = pat.span;\n             (pat, fieldname, false)\n         } else {"}]}