{"sha": "c86212f9bccb4d5ec625b0607053b067732724ab", "node_id": "C_kwDOAAsO6NoAKGM4NjIxMmY5YmNjYjRkNWVjNjI1YjA2MDcwNTNiMDY3NzMyNzI0YWI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-26T03:31:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-26T03:31:04Z"}, "message": "Auto merge of #111858 - clubby789:fluent-alphabetical, r=jyn514,compiler-errors\n\nEnsure Fluent messages are in alphabetical order\n\nFixes #111847\n\nThis adds a tidy check to ensure Fluent messages are in alphabetical order, as well as sorting all existing messages. I think the error could be worded better, would appreciate suggestions.\n\n<details>\n<summary>Script used to sort files</summary>\n\n```py\nimport sys\nimport re\n\nfn = sys.argv[1]\nwith open(fn, 'r') as f:\n    data = f.read().split(\"\\n\")\n\nchunks = []\ncur = \"\"\nfor line in data:\n    if re.match(r\"^([a-zA-Z0-9_]+)\\s*=\\s*\", line):\n        chunks.append(cur)\n        cur = \"\"\n    cur += line + \"\\n\"\nchunks.append(cur)\nchunks.sort()\n\nwith open(fn, 'w') as f:\n    f.write(''.join(chunks).strip(\"\\n\\n\") + \"\\n\")\n```\n</details>", "tree": {"sha": "a3e3bdc7cf3c53714f90ce3f4299a3536325c83c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3e3bdc7cf3c53714f90ce3f4299a3536325c83c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c86212f9bccb4d5ec625b0607053b067732724ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c86212f9bccb4d5ec625b0607053b067732724ab", "html_url": "https://github.com/rust-lang/rust/commit/c86212f9bccb4d5ec625b0607053b067732724ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c86212f9bccb4d5ec625b0607053b067732724ab/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0004b3b984b19646c1f78b09ba497b7bd6e882c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0004b3b984b19646c1f78b09ba497b7bd6e882c1", "html_url": "https://github.com/rust-lang/rust/commit/0004b3b984b19646c1f78b09ba497b7bd6e882c1"}, {"sha": "f97fddab91fbf290ea5b691fe355d6f915220b6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f97fddab91fbf290ea5b691fe355d6f915220b6e", "html_url": "https://github.com/rust-lang/rust/commit/f97fddab91fbf290ea5b691fe355d6f915220b6e"}], "stats": {"total": 8009, "additions": 4042, "deletions": 3967}, "files": [{"sha": "f63a9bfcd705585809bda87e3c2207fcb6ca7ff1", "filename": "compiler/rustc_ast_lowering/messages.ftl", "status": "modified", "additions": 84, "deletions": 84, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_ast_lowering%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_ast_lowering%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,99 +1,121 @@\n-ast_lowering_generic_type_with_parentheses =\n-    parenthesized type parameters may only be used with a `Fn` trait\n-    .label = only `Fn` traits may use parentheses\n-\n-ast_lowering_use_angle_brackets = use angle brackets instead\n+ast_lowering_abi_specified_multiple_times =\n+    `{$prev_name}` ABI specified multiple times\n+    .label = previously specified here\n+    .note = these ABIs are equivalent on the current target\n \n-ast_lowering_invalid_abi =\n-    invalid ABI: found `{$abi}`\n-    .label = invalid ABI\n-    .note = invoke `{$command}` for a full list of supported calling conventions.\n+ast_lowering_arbitrary_expression_in_pattern =\n+    arbitrary expressions aren't allowed in patterns\n \n-ast_lowering_invalid_abi_suggestion = did you mean\n+ast_lowering_argument = argument\n \n ast_lowering_assoc_ty_parentheses =\n     parenthesized generic arguments cannot be used in associated type constraints\n \n-ast_lowering_remove_parentheses = remove these parentheses\n-\n-ast_lowering_misplaced_impl_trait =\n-    `impl Trait` only allowed in function and inherent method return types, not in {$position}\n-\n-ast_lowering_misplaced_assoc_ty_binding =\n-    associated type bounds are only allowed in where clauses and function signatures, not in {$position}\n+ast_lowering_async_generators_not_supported =\n+    `async` generators are not yet supported\n \n-ast_lowering_underscore_expr_lhs_assign =\n-    in expressions, `_` can only be used on the left-hand side of an assignment\n-    .label = `_` not allowed here\n+ast_lowering_async_non_move_closure_not_supported =\n+    `async` non-`move` closures with parameters are not currently supported\n+    .help = consider using `let` statements to manually capture variables by reference before entering an `async move` closure\n \n-ast_lowering_base_expression_double_dot =\n-    base expression required after `..`\n-    .label = add a base expression here\n+ast_lowering_att_syntax_only_x86 =\n+    the `att_syntax` option is only supported on x86\n \n ast_lowering_await_only_in_async_fn_and_blocks =\n     `await` is only allowed inside `async` functions and blocks\n     .label = only allowed inside `async` functions and blocks\n \n-ast_lowering_this_not_async = this is not `async`\n+ast_lowering_bad_return_type_notation_inputs =\n+    argument types not allowed with return type notation\n+    .suggestion = remove the input types\n \n-ast_lowering_generator_too_many_parameters =\n-    too many parameters for a generator (expected 0 or 1 parameters)\n+ast_lowering_bad_return_type_notation_needs_dots =\n+    return type notation arguments must be elided with `..`\n+    .suggestion = add `..`\n+\n+ast_lowering_bad_return_type_notation_output =\n+    return type not allowed with return type notation\n+    .suggestion = remove the return type\n+\n+ast_lowering_base_expression_double_dot =\n+    base expression required after `..`\n+    .label = add a base expression here\n+\n+ast_lowering_clobber_abi_not_supported =\n+    `clobber_abi` is not supported on this target\n \n ast_lowering_closure_cannot_be_static = closures cannot be static\n \n-ast_lowering_async_non_move_closure_not_supported =\n-    `async` non-`move` closures with parameters are not currently supported\n-    .help = consider using `let` statements to manually capture variables by reference before entering an `async move` closure\n+ast_lowering_does_not_support_modifiers =\n+    the `{$class_name}` register class does not support template modifiers\n+\n+ast_lowering_extra_double_dot =\n+    `..` can only be used once per {$ctx} pattern\n+    .label = can only be used once per {$ctx} pattern\n \n ast_lowering_functional_record_update_destructuring_assignment =\n     functional record updates are not allowed in destructuring assignments\n     .suggestion = consider removing the trailing pattern\n \n-ast_lowering_async_generators_not_supported =\n-    `async` generators are not yet supported\n+ast_lowering_generator_too_many_parameters =\n+    too many parameters for a generator (expected 0 or 1 parameters)\n \n-ast_lowering_inline_asm_unsupported_target =\n-    inline assembly is unsupported on this target\n+ast_lowering_generic_type_with_parentheses =\n+    parenthesized type parameters may only be used with a `Fn` trait\n+    .label = only `Fn` traits may use parentheses\n \n-ast_lowering_att_syntax_only_x86 =\n-    the `att_syntax` option is only supported on x86\n+ast_lowering_inclusive_range_with_no_end = inclusive range with no end\n \n-ast_lowering_abi_specified_multiple_times =\n-    `{$prev_name}` ABI specified multiple times\n-    .label = previously specified here\n-    .note = these ABIs are equivalent on the current target\n+ast_lowering_inline_asm_unsupported_target =\n+    inline assembly is unsupported on this target\n \n-ast_lowering_clobber_abi_not_supported =\n-    `clobber_abi` is not supported on this target\n+ast_lowering_invalid_abi =\n+    invalid ABI: found `{$abi}`\n+    .label = invalid ABI\n+    .note = invoke `{$command}` for a full list of supported calling conventions.\n \n ast_lowering_invalid_abi_clobber_abi =\n     invalid ABI for `clobber_abi`\n     .note = the following ABIs are supported on this target: {$supported_abis}\n \n+ast_lowering_invalid_abi_suggestion = did you mean\n+\n+ast_lowering_invalid_asm_template_modifier_const =\n+    asm template modifiers are not allowed for `const` arguments\n+\n+ast_lowering_invalid_asm_template_modifier_reg_class =\n+    invalid asm template modifier for this register class\n+\n+ast_lowering_invalid_asm_template_modifier_sym =\n+    asm template modifiers are not allowed for `sym` arguments\n+\n ast_lowering_invalid_register =\n     invalid register `{$reg}`: {$error}\n \n ast_lowering_invalid_register_class =\n     invalid register class `{$reg_class}`: {$error}\n \n-ast_lowering_invalid_asm_template_modifier_reg_class =\n-    invalid asm template modifier for this register class\n+ast_lowering_misplaced_assoc_ty_binding =\n+    associated type bounds are only allowed in where clauses and function signatures, not in {$position}\n \n-ast_lowering_argument = argument\n+ast_lowering_misplaced_double_dot =\n+    `..` patterns are not allowed here\n+    .note = only allowed in tuple, tuple struct, and slice patterns\n \n-ast_lowering_template_modifier = template modifier\n+ast_lowering_misplaced_impl_trait =\n+    `impl Trait` only allowed in function and inherent method return types, not in {$position}\n \n-ast_lowering_support_modifiers =\n-    the `{$class_name}` register class supports the following template modifiers: {$modifiers}\n+ast_lowering_misplaced_relax_trait_bound =\n+    `?Trait` bounds are only permitted at the point where a type parameter is declared\n \n-ast_lowering_does_not_support_modifiers =\n-    the `{$class_name}` register class does not support template modifiers\n+ast_lowering_not_supported_for_lifetime_binder_async_closure =\n+    `for<...>` binders on `async` closures are not currently supported\n \n-ast_lowering_invalid_asm_template_modifier_const =\n-    asm template modifiers are not allowed for `const` arguments\n+ast_lowering_previously_used_here = previously used here\n \n-ast_lowering_invalid_asm_template_modifier_sym =\n-    asm template modifiers are not allowed for `sym` arguments\n+ast_lowering_register1 = register `{$reg1_name}`\n+\n+ast_lowering_register2 = register `{$reg2_name}`\n \n ast_lowering_register_class_only_clobber =\n     register class `{$reg_class_name}` can only be used as a clobber, not as an input or output\n@@ -102,9 +124,7 @@ ast_lowering_register_conflict =\n     register `{$reg1_name}` conflicts with register `{$reg2_name}`\n     .help = use `lateout` instead of `out` to avoid conflict\n \n-ast_lowering_register1 = register `{$reg1_name}`\n-\n-ast_lowering_register2 = register `{$reg2_name}`\n+ast_lowering_remove_parentheses = remove these parentheses\n \n ast_lowering_sub_tuple_binding =\n     `{$ident_name} @` is not allowed in a {$ctx}\n@@ -113,41 +133,21 @@ ast_lowering_sub_tuple_binding =\n \n ast_lowering_sub_tuple_binding_suggestion = if you don't need to use the contents of {$ident}, discard the tuple's remaining fields\n \n-ast_lowering_extra_double_dot =\n-    `..` can only be used once per {$ctx} pattern\n-    .label = can only be used once per {$ctx} pattern\n-\n-ast_lowering_previously_used_here = previously used here\n-\n-ast_lowering_misplaced_double_dot =\n-    `..` patterns are not allowed here\n-    .note = only allowed in tuple, tuple struct, and slice patterns\n-\n-ast_lowering_misplaced_relax_trait_bound =\n-    `?Trait` bounds are only permitted at the point where a type parameter is declared\n-\n-ast_lowering_not_supported_for_lifetime_binder_async_closure =\n-    `for<...>` binders on `async` closures are not currently supported\n+ast_lowering_support_modifiers =\n+    the `{$class_name}` register class supports the following template modifiers: {$modifiers}\n \n-ast_lowering_arbitrary_expression_in_pattern =\n-    arbitrary expressions aren't allowed in patterns\n+ast_lowering_template_modifier = template modifier\n \n-ast_lowering_inclusive_range_with_no_end = inclusive range with no end\n+ast_lowering_this_not_async = this is not `async`\n \n ast_lowering_trait_fn_async =\n     functions in traits cannot be declared `async`\n     .label = `async` because of this\n     .note = `async` trait functions are not currently supported\n     .note2 = consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n-ast_lowering_bad_return_type_notation_inputs =\n-    argument types not allowed with return type notation\n-    .suggestion = remove the input types\n-\n-ast_lowering_bad_return_type_notation_needs_dots =\n-    return type notation arguments must be elided with `..`\n-    .suggestion = add `..`\n+ast_lowering_underscore_expr_lhs_assign =\n+    in expressions, `_` can only be used on the left-hand side of an assignment\n+    .label = `_` not allowed here\n \n-ast_lowering_bad_return_type_notation_output =\n-    return type not allowed with return type notation\n-    .suggestion = remove the return type\n+ast_lowering_use_angle_brackets = use angle brackets instead"}, {"sha": "2f0ac0c2b1987e3c78b0421c8070cc80fb43a9ac", "filename": "compiler/rustc_ast_passes/messages.ftl", "status": "modified", "additions": 150, "deletions": 150, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_ast_passes%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_ast_passes%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,64 +1,3 @@\n-ast_passes_forbidden_let =\n-    `let` expressions are not supported here\n-    .note = only supported directly in conditions of `if` and `while` expressions\n-    .not_supported_or = `||` operators are not supported in let chain expressions\n-    .not_supported_parentheses = `let`s wrapped in parentheses are not supported in a context with let chains\n-\n-ast_passes_forbidden_let_stable =\n-    expected expression, found statement (`let`)\n-    .note = variable declaration using `let` is a statement\n-\n-ast_passes_deprecated_where_clause_location =\n-    where clause not allowed here\n-\n-ast_passes_keyword_lifetime =\n-    lifetimes cannot use keyword names\n-\n-ast_passes_invalid_label =\n-    invalid label name `{$name}`\n-\n-ast_passes_visibility_not_permitted =\n-    visibility qualifiers are not permitted here\n-    .enum_variant = enum variants and their fields always share the visibility of the enum they are in\n-    .trait_impl = trait items always share the visibility of their trait\n-    .individual_impl_items = place qualifiers on individual impl items instead\n-    .individual_foreign_items = place qualifiers on individual foreign items instead\n-\n-ast_passes_trait_fn_const =\n-    functions in traits cannot be declared const\n-    .label = functions in traits cannot be const\n-\n-ast_passes_forbidden_lifetime_bound =\n-    lifetime bounds cannot be used in this context\n-\n-ast_passes_forbidden_non_lifetime_param =\n-    only lifetime parameters can be used in this context\n-\n-ast_passes_fn_param_too_many =\n-    function can not have more than {$max_num_args} arguments\n-\n-ast_passes_fn_param_c_var_args_only =\n-    C-variadic function must be declared with at least one named argument\n-\n-ast_passes_fn_param_c_var_args_not_last =\n-    `...` must be the last argument of a C-variadic function\n-\n-ast_passes_fn_param_doc_comment =\n-    documentation comments cannot be applied to function parameters\n-    .label = doc comments are not allowed here\n-\n-ast_passes_fn_param_forbidden_attr =\n-    allow, cfg, cfg_attr, deny, expect, forbid, and warn are the only allowed built-in attributes in function parameters\n-\n-ast_passes_fn_param_forbidden_self =\n-    `self` parameter is only allowed in associated functions\n-    .label = not semantically valid as function parameter\n-    .note = associated functions are those in `impl` or `trait` definitions\n-\n-ast_passes_forbidden_default =\n-    `default` is only allowed on items in trait impls\n-    .label = `default` because of this\n-\n ast_passes_assoc_const_without_body =\n     associated constant in `impl` without body\n     .suggestion = provide a definition for the constant\n@@ -71,72 +10,124 @@ ast_passes_assoc_type_without_body =\n     associated type in `impl` without body\n     .suggestion = provide a definition for the type\n \n+ast_passes_at_least_one_trait = at least one trait must be specified\n+\n+ast_passes_auto_generic = auto traits cannot have generic parameters\n+    .label = auto trait cannot have generic parameters\n+    .suggestion = remove the parameters\n+\n+ast_passes_auto_items = auto traits cannot have associated items\n+    .label = {ast_passes_auto_items}\n+    .suggestion = remove these associated items\n+\n+ast_passes_auto_super_lifetime = auto traits cannot have super traits or lifetime bounds\n+    .label = {ast_passes_auto_super_lifetime}\n+    .suggestion = remove the super traits or lifetime bounds\n+\n+ast_passes_bad_c_variadic = only foreign or `unsafe extern \"C\"` functions may be C-variadic\n+\n+ast_passes_body_in_extern = incorrect `{$kind}` inside `extern` block\n+    .cannot_have = cannot have a body\n+    .invalid = the invalid body\n+    .existing = `extern` blocks define existing foreign {$kind}s and {$kind}s inside of them cannot have a body\n+\n+ast_passes_bound_in_context = bounds on `type`s in {$ctx} have no effect\n+\n+ast_passes_const_and_async = functions cannot be both `const` and `async`\n+    .const = `const` because of this\n+    .async = `async` because of this\n+    .label = {\"\"}\n+\n ast_passes_const_without_body =\n     free constant item without body\n     .suggestion = provide a definition for the constant\n \n-ast_passes_static_without_body =\n-    free static item without body\n-    .suggestion = provide a definition for the static\n+ast_passes_constraint_on_negative_bound =\n+    associated type constraints not allowed on negative bounds\n \n-ast_passes_ty_alias_without_body =\n-    free type alias without body\n-    .suggestion = provide a definition for the type\n+ast_passes_deprecated_where_clause_location =\n+    where clause not allowed here\n \n-ast_passes_fn_without_body =\n-    free function without a body\n-    .suggestion = provide a definition for the function\n+ast_passes_equality_in_where = equality constraints are not yet supported in `where` clauses\n+    .label = not supported\n+    .suggestion = if `{$ident}` is an associated type you're trying to set, use the associated type binding syntax\n+    .suggestion_path = if `{$trait_segment}::{$potential_assoc}` is an associated type you're trying to set, use the associated type binding syntax\n+    .note = see issue #20041 <https://github.com/rust-lang/rust/issues/20041> for more information\n \n ast_passes_extern_block_suggestion = if you meant to declare an externally defined function, use an `extern` block\n \n-ast_passes_bound_in_context = bounds on `type`s in {$ctx} have no effect\n+ast_passes_extern_fn_qualifiers = functions in `extern` blocks cannot have qualifiers\n+    .label = in this `extern` block\n+    .suggestion = remove the qualifiers\n+\n+ast_passes_extern_item_ascii = items in `extern` blocks cannot use non-ascii identifiers\n+    .label = in this `extern` block\n+    .note = this limitation may be lifted in the future; see issue #83942 <https://github.com/rust-lang/rust/issues/83942> for more information\n+\n+ast_passes_extern_keyword_link = for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n \n ast_passes_extern_types_cannot = `type`s inside `extern` blocks cannot have {$descr}\n     .suggestion = remove the {$remove_descr}\n     .label = `extern` block begins here\n \n-ast_passes_extern_keyword_link = for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+ast_passes_extern_without_abi = extern declarations without an explicit ABI are deprecated\n \n-ast_passes_body_in_extern = incorrect `{$kind}` inside `extern` block\n-    .cannot_have = cannot have a body\n-    .invalid = the invalid body\n-    .existing = `extern` blocks define existing foreign {$kind}s and {$kind}s inside of them cannot have a body\n+ast_passes_feature_on_non_nightly = `#![feature]` may not be used on the {$channel} release channel\n+    .suggestion = remove the attribute\n+    .stable_since = the feature `{$name}` has been stable since `{$since}` and no longer requires an attribute to enable\n+\n+ast_passes_fieldless_union = unions cannot have zero fields\n \n ast_passes_fn_body_extern = incorrect function inside `extern` block\n     .cannot_have = cannot have a body\n     .suggestion = remove the invalid body\n     .help = you might have meant to write a function accessible through FFI, which can be done by writing `extern fn` outside of the `extern` block\n     .label = `extern` blocks define existing foreign functions and functions inside of them cannot have a body\n \n-ast_passes_extern_fn_qualifiers = functions in `extern` blocks cannot have qualifiers\n-    .label = in this `extern` block\n-    .suggestion = remove the qualifiers\n+ast_passes_fn_param_c_var_args_not_last =\n+    `...` must be the last argument of a C-variadic function\n \n-ast_passes_extern_item_ascii = items in `extern` blocks cannot use non-ascii identifiers\n-    .label = in this `extern` block\n-    .note = this limitation may be lifted in the future; see issue #83942 <https://github.com/rust-lang/rust/issues/83942> for more information\n+ast_passes_fn_param_c_var_args_only =\n+    C-variadic function must be declared with at least one named argument\n \n-ast_passes_bad_c_variadic = only foreign or `unsafe extern \"C\"` functions may be C-variadic\n+ast_passes_fn_param_doc_comment =\n+    documentation comments cannot be applied to function parameters\n+    .label = doc comments are not allowed here\n \n-ast_passes_item_underscore = `{$kind}` items in this context need a name\n-    .label = `_` is not a valid name for this `{$kind}` item\n+ast_passes_fn_param_forbidden_attr =\n+    allow, cfg, cfg_attr, deny, expect, forbid, and warn are the only allowed built-in attributes in function parameters\n \n-ast_passes_nomangle_ascii = `#[no_mangle]` requires ASCII identifier\n+ast_passes_fn_param_forbidden_self =\n+    `self` parameter is only allowed in associated functions\n+    .label = not semantically valid as function parameter\n+    .note = associated functions are those in `impl` or `trait` definitions\n \n-ast_passes_module_nonascii = trying to load file for module `{$name}` with non-ascii identifier name\n-    .help = consider using the `#[path]` attribute to specify filesystem path\n+ast_passes_fn_param_too_many =\n+    function can not have more than {$max_num_args} arguments\n \n-ast_passes_auto_generic = auto traits cannot have generic parameters\n-    .label = auto trait cannot have generic parameters\n-    .suggestion = remove the parameters\n+ast_passes_fn_without_body =\n+    free function without a body\n+    .suggestion = provide a definition for the function\n \n-ast_passes_auto_super_lifetime = auto traits cannot have super traits or lifetime bounds\n-    .label = {ast_passes_auto_super_lifetime}\n-    .suggestion = remove the super traits or lifetime bounds\n+ast_passes_forbidden_default =\n+    `default` is only allowed on items in trait impls\n+    .label = `default` because of this\n \n-ast_passes_auto_items = auto traits cannot have associated items\n-    .label = {ast_passes_auto_items}\n-    .suggestion = remove these associated items\n+ast_passes_forbidden_let =\n+    `let` expressions are not supported here\n+    .note = only supported directly in conditions of `if` and `while` expressions\n+    .not_supported_or = `||` operators are not supported in let chain expressions\n+    .not_supported_parentheses = `let`s wrapped in parentheses are not supported in a context with let chains\n+\n+ast_passes_forbidden_let_stable =\n+    expected expression, found statement (`let`)\n+    .note = variable declaration using `let` is a statement\n+\n+ast_passes_forbidden_lifetime_bound =\n+    lifetime bounds cannot be used in this context\n+\n+ast_passes_forbidden_non_lifetime_param =\n+    only lifetime parameters can be used in this context\n \n ast_passes_generic_before_constraints = generic arguments must come before the first constraint\n     .constraints = {$constraint_len ->\n@@ -156,88 +147,97 @@ ast_passes_generic_before_constraints = generic arguments must come before the f\n     *[other] arguments\n     }\n \n-ast_passes_pattern_in_fn_pointer = patterns aren't allowed in function pointer types\n-\n-ast_passes_trait_object_single_bound = only a single explicit lifetime bound is permitted\n+ast_passes_generic_default_trailing = generic parameters with a default must be trailing\n \n ast_passes_impl_trait_path = `impl Trait` is not allowed in path parameters\n \n+ast_passes_incompatible_features = `{$f1}` and `{$f2}` are incompatible, using them at the same time is not allowed\n+    .help = remove one of these features\n+\n+ast_passes_inherent_cannot_be = inherent impls cannot be {$annotation}\n+    .because = {$annotation} because of this\n+    .type = inherent impl for this type\n+    .only_trait = only trait implementations may be annotated with {$annotation}\n+\n+ast_passes_invalid_label =\n+    invalid label name `{$name}`\n+\n+ast_passes_item_underscore = `{$kind}` items in this context need a name\n+    .label = `_` is not a valid name for this `{$kind}` item\n+\n+ast_passes_keyword_lifetime =\n+    lifetimes cannot use keyword names\n+\n+ast_passes_module_nonascii = trying to load file for module `{$name}` with non-ascii identifier name\n+    .help = consider using the `#[path]` attribute to specify filesystem path\n+\n+ast_passes_negative_bound_not_supported =\n+    negative bounds are not supported\n+\n ast_passes_nested_impl_trait = nested `impl Trait` is not allowed\n     .outer = outer `impl Trait`\n     .inner = nested `impl Trait` here\n \n-ast_passes_at_least_one_trait = at least one trait must be specified\n-\n-ast_passes_extern_without_abi = extern declarations without an explicit ABI are deprecated\n+ast_passes_nested_lifetimes = nested quantification of lifetimes\n \n-ast_passes_out_of_order_params = {$param_ord} parameters must be declared prior to {$max_param} parameters\n-    .suggestion = reorder the parameters: lifetimes, then consts and types\n+ast_passes_nomangle_ascii = `#[no_mangle]` requires ASCII identifier\n \n ast_passes_obsolete_auto = `impl Trait for .. {\"{}\"}` is an obsolete syntax\n     .help = use `auto trait Trait {\"{}\"}` instead\n \n-ast_passes_unsafe_negative_impl = negative impls cannot be unsafe\n-    .negative = negative because of this\n-    .unsafe = unsafe because of this\n+ast_passes_optional_const_exclusive = `~const` and `{$modifier}` are mutually exclusive\n \n-ast_passes_inherent_cannot_be = inherent impls cannot be {$annotation}\n-    .because = {$annotation} because of this\n-    .type = inherent impl for this type\n-    .only_trait = only trait implementations may be annotated with {$annotation}\n+ast_passes_optional_trait_object = `?Trait` is not permitted in trait object types\n \n-ast_passes_unsafe_item = {$kind} cannot be declared unsafe\n+ast_passes_optional_trait_supertrait = `?Trait` is not permitted in supertraits\n+    .note = traits are `?{$path_str}` by default\n \n-ast_passes_fieldless_union = unions cannot have zero fields\n+ast_passes_out_of_order_params = {$param_ord} parameters must be declared prior to {$max_param} parameters\n+    .suggestion = reorder the parameters: lifetimes, then consts and types\n \n-ast_passes_where_after_type_alias = where clauses are not allowed after the type for type aliases\n-    .note = see issue #89122 <https://github.com/rust-lang/rust/issues/89122> for more information\n+ast_passes_pattern_in_bodiless = patterns aren't allowed in functions without bodies\n+    .label = pattern not allowed in function without body\n \n-ast_passes_generic_default_trailing = generic parameters with a default must be trailing\n+ast_passes_pattern_in_fn_pointer = patterns aren't allowed in function pointer types\n \n-ast_passes_nested_lifetimes = nested quantification of lifetimes\n+ast_passes_pattern_in_foreign = patterns aren't allowed in foreign function declarations\n+    .label = pattern not allowed in foreign function\n \n-ast_passes_optional_trait_supertrait = `?Trait` is not permitted in supertraits\n-    .note = traits are `?{$path_str}` by default\n+ast_passes_show_span = {$msg}\n \n-ast_passes_optional_trait_object = `?Trait` is not permitted in trait object types\n+ast_passes_stability_outside_std = stability attributes may not be used outside of the standard library\n+\n+ast_passes_static_without_body =\n+    free static item without body\n+    .suggestion = provide a definition for the static\n \n ast_passes_tilde_const_disallowed = `~const` is not allowed here\n     .trait = trait objects cannot have `~const` trait bounds\n     .closure = closures cannot have `~const` trait bounds\n     .function = this function is not `const`, so it cannot have `~const` trait bounds\n \n-ast_passes_optional_const_exclusive = `~const` and `{$modifier}` are mutually exclusive\n-\n-ast_passes_const_and_async = functions cannot be both `const` and `async`\n-    .const = `const` because of this\n-    .async = `async` because of this\n-    .label = {\"\"}\n-\n-ast_passes_pattern_in_foreign = patterns aren't allowed in foreign function declarations\n-    .label = pattern not allowed in foreign function\n-\n-ast_passes_pattern_in_bodiless = patterns aren't allowed in functions without bodies\n-    .label = pattern not allowed in function without body\n-\n-ast_passes_equality_in_where = equality constraints are not yet supported in `where` clauses\n-    .label = not supported\n-    .suggestion = if `{$ident}` is an associated type you're trying to set, use the associated type binding syntax\n-    .suggestion_path = if `{$trait_segment}::{$potential_assoc}` is an associated type you're trying to set, use the associated type binding syntax\n-    .note = see issue #20041 <https://github.com/rust-lang/rust/issues/20041> for more information\n+ast_passes_trait_fn_const =\n+    functions in traits cannot be declared const\n+    .label = functions in traits cannot be const\n \n-ast_passes_stability_outside_std = stability attributes may not be used outside of the standard library\n+ast_passes_trait_object_single_bound = only a single explicit lifetime bound is permitted\n \n-ast_passes_feature_on_non_nightly = `#![feature]` may not be used on the {$channel} release channel\n-    .suggestion = remove the attribute\n-    .stable_since = the feature `{$name}` has been stable since `{$since}` and no longer requires an attribute to enable\n+ast_passes_ty_alias_without_body =\n+    free type alias without body\n+    .suggestion = provide a definition for the type\n \n-ast_passes_incompatible_features = `{$f1}` and `{$f2}` are incompatible, using them at the same time is not allowed\n-    .help = remove one of these features\n+ast_passes_unsafe_item = {$kind} cannot be declared unsafe\n \n-ast_passes_show_span = {$msg}\n+ast_passes_unsafe_negative_impl = negative impls cannot be unsafe\n+    .negative = negative because of this\n+    .unsafe = unsafe because of this\n \n-ast_passes_negative_bound_not_supported =\n-    negative bounds are not supported\n+ast_passes_visibility_not_permitted =\n+    visibility qualifiers are not permitted here\n+    .enum_variant = enum variants and their fields always share the visibility of the enum they are in\n+    .trait_impl = trait items always share the visibility of their trait\n+    .individual_impl_items = place qualifiers on individual impl items instead\n+    .individual_foreign_items = place qualifiers on individual foreign items instead\n \n-ast_passes_constraint_on_negative_bound =\n-    associated type constraints not allowed on negative bounds\n+ast_passes_where_after_type_alias = where clauses are not allowed after the type for type aliases\n+    .note = see issue #89122 <https://github.com/rust-lang/rust/issues/89122> for more information"}, {"sha": "e6cbbaf3704bc3e63e75458a67b76fe3e52475b2", "filename": "compiler/rustc_attr/messages.ftl", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_attr%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_attr%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,27 +1,38 @@\n+attr_cfg_predicate_identifier =\n+    `cfg` predicate key must be an identifier\n+\n+attr_deprecated_item_suggestion =\n+    suggestions on deprecated items are unstable\n+    .help = add `#![feature(deprecated_suggestion)]` to the crate root\n+    .note = see #94785 for more details\n+\n attr_expected_one_cfg_pattern =\n     expected 1 cfg-pattern\n \n-attr_invalid_predicate =\n-    invalid predicate `{$predicate}`\n+attr_expected_single_version_literal =\n+    expected single version literal\n \n-attr_multiple_item =\n-    multiple '{$item}' items\n+attr_expected_version_literal =\n+    expected a version literal\n+\n+attr_expects_feature_list =\n+    `{$name}` expects a list of feature names\n+\n+attr_expects_features =\n+    `{$name}` expects feature names\n \n attr_incorrect_meta_item =\n     incorrect meta item\n \n-attr_unknown_meta_item =\n-    unknown meta item '{$item}'\n-    .label = expected one of {$expected}\n-\n-attr_missing_since =\n-    missing 'since'\n+attr_incorrect_repr_format_align_one_arg =\n+    incorrect `repr(align)` attribute format: `align` takes exactly one argument in parentheses\n \n-attr_missing_note =\n-    missing 'note'\n+attr_incorrect_repr_format_generic =\n+    incorrect `repr({$repr_arg})` attribute format\n+    .suggestion = use parentheses instead\n \n-attr_multiple_stability_levels =\n-    multiple stability levels\n+attr_incorrect_repr_format_packed_one_or_zero_arg =\n+    incorrect `repr(packed)` attribute format: `packed` takes exactly one parenthesized argument, or no parentheses at all\n \n attr_invalid_issue_string =\n     `issue` must be a non-zero numeric string or \"none\"\n@@ -31,77 +42,66 @@ attr_invalid_issue_string =\n     .pos_overflow = number too large to fit in target type\n     .neg_overflow = number too small to fit in target type\n \n-attr_missing_feature =\n-    missing 'feature'\n-\n-attr_non_ident_feature =\n-    'feature' is not an identifier\n+attr_invalid_predicate =\n+    invalid predicate `{$predicate}`\n \n-attr_missing_issue =\n-    missing 'issue'\n+attr_invalid_repr_align_need_arg =\n+    invalid `repr(align)` attribute: `align` needs an argument\n+    .suggestion = supply an argument here\n \n-attr_incorrect_repr_format_packed_one_or_zero_arg =\n-    incorrect `repr(packed)` attribute format: `packed` takes exactly one parenthesized argument, or no parentheses at all\n+attr_invalid_repr_generic =\n+    invalid `repr({$repr_arg})` attribute: {$error_part}\n \n attr_invalid_repr_hint_no_paren =\n     invalid representation hint: `{$name}` does not take a parenthesized argument list\n \n attr_invalid_repr_hint_no_value =\n     invalid representation hint: `{$name}` does not take a value\n \n-attr_unsupported_literal_generic =\n-    unsupported literal\n-attr_unsupported_literal_cfg_string =\n-    literal in `cfg` predicate value must be a string\n-attr_unsupported_literal_deprecated_string =\n-    literal in `deprecated` value must be a string\n-attr_unsupported_literal_deprecated_kv_pair =\n-    item in `deprecated` must be a key/value pair\n-attr_unsupported_literal_suggestion =\n-    consider removing the prefix\n+attr_missing_feature =\n+    missing 'feature'\n \n-attr_invalid_repr_align_need_arg =\n-    invalid `repr(align)` attribute: `align` needs an argument\n-    .suggestion = supply an argument here\n+attr_missing_issue =\n+    missing 'issue'\n \n-attr_invalid_repr_generic =\n-    invalid `repr({$repr_arg})` attribute: {$error_part}\n+attr_missing_note =\n+    missing 'note'\n \n-attr_incorrect_repr_format_align_one_arg =\n-    incorrect `repr(align)` attribute format: `align` takes exactly one argument in parentheses\n+attr_missing_since =\n+    missing 'since'\n \n-attr_incorrect_repr_format_generic =\n-    incorrect `repr({$repr_arg})` attribute format\n-    .suggestion = use parentheses instead\n+attr_multiple_item =\n+    multiple '{$item}' items\n \n-attr_rustc_promotable_pairing =\n-    `rustc_promotable` attribute must be paired with either a `rustc_const_unstable` or a `rustc_const_stable` attribute\n+attr_multiple_stability_levels =\n+    multiple stability levels\n+\n+attr_non_ident_feature =\n+    'feature' is not an identifier\n \n attr_rustc_allowed_unstable_pairing =\n     `rustc_allowed_through_unstable_modules` attribute must be paired with a `stable` attribute\n \n-attr_cfg_predicate_identifier =\n-    `cfg` predicate key must be an identifier\n-\n-attr_deprecated_item_suggestion =\n-    suggestions on deprecated items are unstable\n-    .help = add `#![feature(deprecated_suggestion)]` to the crate root\n-    .note = see #94785 for more details\n-\n-attr_expected_single_version_literal =\n-    expected single version literal\n-\n-attr_expected_version_literal =\n-    expected a version literal\n-\n-attr_expects_feature_list =\n-    `{$name}` expects a list of feature names\n-\n-attr_expects_features =\n-    `{$name}` expects feature names\n+attr_rustc_promotable_pairing =\n+    `rustc_promotable` attribute must be paired with either a `rustc_const_unstable` or a `rustc_const_stable` attribute\n \n attr_soft_no_args =\n     `soft` should not have any arguments\n \n+attr_unknown_meta_item =\n+    unknown meta item '{$item}'\n+    .label = expected one of {$expected}\n+\n attr_unknown_version_literal =\n     unknown version literal format, assuming it refers to a future version\n+\n+attr_unsupported_literal_cfg_string =\n+    literal in `cfg` predicate value must be a string\n+attr_unsupported_literal_deprecated_kv_pair =\n+    item in `deprecated` must be a key/value pair\n+attr_unsupported_literal_deprecated_string =\n+    literal in `deprecated` value must be a string\n+attr_unsupported_literal_generic =\n+    unsupported literal\n+attr_unsupported_literal_suggestion =\n+    consider removing the prefix"}, {"sha": "67fdb671742da838921bd3d5daf9df1c3d6fc1b6", "filename": "compiler/rustc_borrowck/messages.ftl", "status": "modified", "additions": 173, "deletions": 173, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_borrowck%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_borrowck%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,188 +1,108 @@\n-borrowck_move_unsized =\n-    cannot move a value of type `{$ty}`\n-    .label = the size of `{$ty}` cannot be statically determined\n-\n-borrowck_higher_ranked_lifetime_error =\n-    higher-ranked lifetime error\n-\n-borrowck_could_not_prove =\n-    could not prove `{$predicate}`\n-\n-borrowck_could_not_normalize =\n-    could not normalize `{$value}`\n-\n-borrowck_higher_ranked_subtype_error =\n-    higher-ranked subtype error\n-\n-borrowck_generic_does_not_live_long_enough =\n-    `{$kind}` does not live long enough\n-\n-borrowck_move_borrowed =\n-    cannot move out of `{$desc}` because it is borrowed\n-\n-borrowck_var_does_not_need_mut =\n-    variable does not need to be mutable\n-    .suggestion = remove this `mut`\n-\n-borrowck_var_cannot_escape_closure =\n-    captured variable cannot escape `FnMut` closure body\n-    .note = `FnMut` closures only have access to their captured variables while they are executing...\n-    .cannot_escape = ...therefore, they cannot allow references to captured variables to escape\n-\n-borrowck_var_here_defined = variable defined here\n-\n-borrowck_var_here_captured = variable captured here\n-\n-borrowck_closure_inferred_mut = inferred to be a `FnMut` closure\n-\n-borrowck_returned_closure_escaped =\n-    returns a closure that contains a reference to a captured variable, which then escapes the closure body\n-\n-borrowck_returned_async_block_escaped =\n-    returns an `async` block that contains a reference to a captured variable, which then escapes the closure body\n-\n-borrowck_returned_ref_escaped =\n-    returns a reference to a captured variable which escapes the closure body\n-\n-borrowck_lifetime_constraints_error =\n-    lifetime may not live long enough\n-\n-borrowck_returned_lifetime_wrong =\n-    {$mir_def_name} was supposed to return data with lifetime `{$outlived_fr_name}` but it is returning data with lifetime `{$fr_name}`\n-\n-borrowck_returned_lifetime_short =\n-    {$category_desc}requires that `{$free_region_name}` must outlive `{$outlived_fr_name}`\n-\n-borrowck_used_impl_require_static =\n-    the used `impl` has a `'static` requirement\n-\n-borrowck_borrow_due_to_use_generator =\n-    borrow occurs due to use in generator\n-\n-borrowck_use_due_to_use_generator =\n-    use occurs due to use in generator\n+borrowck_assign_due_to_use_closure =\n+    assignment occurs due to use in closure\n \n borrowck_assign_due_to_use_generator =\n     assign occurs due to use in generator\n \n+borrowck_assign_part_due_to_use_closure =\n+    assignment to part occurs due to use in closure\n+\n borrowck_assign_part_due_to_use_generator =\n     assign to part occurs due to use in generator\n \n borrowck_borrow_due_to_use_closure =\n     borrow occurs due to use in closure\n \n-borrowck_use_due_to_use_closure =\n-    use occurs due to use in closure\n+borrowck_borrow_due_to_use_generator =\n+    borrow occurs due to use in generator\n \n-borrowck_assign_due_to_use_closure =\n-    assignment occurs due to use in closure\n+borrowck_calling_operator_moves_lhs =\n+    calling this operator moves the left-hand side\n \n-borrowck_assign_part_due_to_use_closure =\n-    assignment to part occurs due to use in closure\n+borrowck_cannot_move_when_borrowed =\n+    cannot move out of {$place ->\n+        [value] value\n+        *[other] {$place}\n+    } because it is borrowed\n+    .label = borrow of {$borrow_place ->\n+        [value] value\n+        *[other] {$borrow_place}\n+    } occurs here\n+    .move_label = move out of {$value_place ->\n+        [value] value\n+        *[other] {$value_place}\n+    } occurs here\n \n borrowck_capture_immute =\n     capture is immutable because of use here\n \n-borrowck_capture_mut =\n-    capture is mutable because of use here\n-\n borrowck_capture_move =\n     capture is moved because of use here\n \n-borrowck_var_borrow_by_use_place_in_generator =\n-    {$is_single_var ->\n-        *[true] borrow occurs\n-        [false] borrows occur\n-    } due to use of {$place} in generator\n-\n-borrowck_var_borrow_by_use_place_in_closure =\n-    {$is_single_var ->\n-        *[true] borrow occurs\n-        [false] borrows occur\n-    } due to use of {$place} in closure\n+borrowck_capture_mut =\n+    capture is mutable because of use here\n \n-borrowck_var_borrow_by_use_in_generator =\n-    borrow occurs due to use in generator\n+borrowck_closure_inferred_mut = inferred to be a `FnMut` closure\n \n-borrowck_var_borrow_by_use_in_closure =\n-    borrow occurs due to use in closure\n+borrowck_closure_invoked_twice =\n+    closure cannot be invoked more than once because it moves the variable `{$place_name}` out of its environment\n \n-borrowck_var_move_by_use_place_in_generator =\n-    move occurs due to use of {$place} in generator\n+borrowck_closure_moved_twice =\n+    closure cannot be moved more than once as it is not `Copy` due to moving the variable `{$place_name}` out of its environment\n \n-borrowck_var_move_by_use_place_in_closure =\n-    move occurs due to use of {$place} in closure\n+borrowck_consider_borrow_type_contents =\n+    help: consider calling `.as_ref()` or `.as_mut()` to borrow the type's contents\n \n-borrowck_var_move_by_use_in_generator =\n-    move occurs due to use in generator\n+borrowck_could_not_normalize =\n+    could not normalize `{$value}`\n \n-borrowck_var_move_by_use_in_closure =\n-    move occurs due to use in closure\n+borrowck_could_not_prove =\n+    could not prove `{$predicate}`\n \n-borrowck_partial_var_move_by_use_in_generator =\n-    variable {$is_partial ->\n-        [true] partially moved\n-        *[false] moved\n-    } due to use in generator\n+borrowck_func_take_self_moved_place =\n+    `{$func}` takes ownership of the receiver `self`, which moves {$place_name}\n \n-borrowck_partial_var_move_by_use_in_closure =\n-    variable {$is_partial ->\n-        [true] partially moved\n-        *[false] moved\n-    } due to use in closure\n+borrowck_generic_does_not_live_long_enough =\n+    `{$kind}` does not live long enough\n \n-borrowck_var_first_borrow_by_use_place_in_generator =\n-    first borrow occurs due to use of {$place} in generator\n+borrowck_higher_ranked_lifetime_error =\n+    higher-ranked lifetime error\n \n-borrowck_var_first_borrow_by_use_place_in_closure =\n-    first borrow occurs due to use of {$place} in closure\n+borrowck_higher_ranked_subtype_error =\n+    higher-ranked subtype error\n \n-borrowck_var_second_borrow_by_use_place_in_generator =\n-    second borrow occurs due to use of {$place} in generator\n+borrowck_lifetime_constraints_error =\n+    lifetime may not live long enough\n \n-borrowck_var_second_borrow_by_use_place_in_closure =\n-    second borrow occurs due to use of {$place} in closure\n+borrowck_move_borrowed =\n+    cannot move out of `{$desc}` because it is borrowed\n \n-borrowck_var_mutable_borrow_by_use_place_in_closure =\n-    mutable borrow occurs due to use of {$place} in closure\n+borrowck_move_out_place_here =\n+    {$place} is moved here\n \n-borrowck_cannot_move_when_borrowed =\n-    cannot move out of {$place ->\n-        [value] value\n-        *[other] {$place}\n-    } because it is borrowed\n-    .label = borrow of {$borrow_place ->\n-        [value] value\n-        *[other] {$borrow_place}\n-    } occurs here\n-    .move_label = move out of {$value_place ->\n-        [value] value\n-        *[other] {$value_place}\n-    } occurs here\n+borrowck_move_unsized =\n+    cannot move a value of type `{$ty}`\n+    .label = the size of `{$ty}` cannot be statically determined\n \n-borrowck_opaque_type_non_generic_param =\n-    expected generic {$kind} parameter, found `{$ty}`\n-    .label = {STREQ($ty, \"'static\") ->\n-        [true] cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n-        *[other] this generic parameter must be used with a generic {$kind} parameter\n-    }\n+borrowck_moved_a_fn_once_in_call =\n+    this value implements `FnOnce`, which causes it to be moved when called\n \n-borrowck_moved_due_to_call =\n+borrowck_moved_due_to_await =\n     {$place_name} {$is_partial ->\n         [true] partially moved\n         *[false] moved\n     } due to this {$is_loop_message ->\n-        [true] call, in previous iteration of loop\n-        *[false] call\n+        [true] await, in previous iteration of loop\n+        *[false] await\n     }\n \n-borrowck_moved_due_to_usage_in_operator =\n+borrowck_moved_due_to_call =\n     {$place_name} {$is_partial ->\n         [true] partially moved\n         *[false] moved\n-    } due to usage in {$is_loop_message ->\n-        [true] operator, in previous iteration of loop\n-        *[false] operator\n+    } due to this {$is_loop_message ->\n+        [true] call, in previous iteration of loop\n+        *[false] call\n     }\n \n borrowck_moved_due_to_implicit_into_iter_call =\n@@ -203,13 +123,74 @@ borrowck_moved_due_to_method_call =\n         *[false] call\n     }\n \n-borrowck_moved_due_to_await =\n+borrowck_moved_due_to_usage_in_operator =\n     {$place_name} {$is_partial ->\n         [true] partially moved\n         *[false] moved\n-    } due to this {$is_loop_message ->\n-        [true] await, in previous iteration of loop\n-        *[false] await\n+    } due to usage in {$is_loop_message ->\n+        [true] operator, in previous iteration of loop\n+        *[false] operator\n+    }\n+\n+borrowck_opaque_type_non_generic_param =\n+    expected generic {$kind} parameter, found `{$ty}`\n+    .label = {STREQ($ty, \"'static\") ->\n+        [true] cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n+        *[other] this generic parameter must be used with a generic {$kind} parameter\n+    }\n+\n+borrowck_partial_var_move_by_use_in_closure =\n+    variable {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to use in closure\n+\n+borrowck_partial_var_move_by_use_in_generator =\n+    variable {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to use in generator\n+\n+borrowck_returned_async_block_escaped =\n+    returns an `async` block that contains a reference to a captured variable, which then escapes the closure body\n+\n+borrowck_returned_closure_escaped =\n+    returns a closure that contains a reference to a captured variable, which then escapes the closure body\n+\n+borrowck_returned_lifetime_short =\n+    {$category_desc}requires that `{$free_region_name}` must outlive `{$outlived_fr_name}`\n+\n+borrowck_returned_lifetime_wrong =\n+    {$mir_def_name} was supposed to return data with lifetime `{$outlived_fr_name}` but it is returning data with lifetime `{$fr_name}`\n+\n+borrowck_returned_ref_escaped =\n+    returns a reference to a captured variable which escapes the closure body\n+\n+borrowck_suggest_create_freash_reborrow =\n+    consider reborrowing the `Pin` instead of moving it\n+\n+borrowck_suggest_iterate_over_slice =\n+    consider iterating over a slice of the `{$ty}`'s content to avoid moving into the `for` loop\n+\n+borrowck_ty_no_impl_copy =\n+    {$is_partial_move ->\n+        [true] partial move\n+        *[false] move\n+    } occurs because {$place} has type `{$ty}`, which does not implement the `Copy` trait\n+\n+borrowck_use_due_to_use_closure =\n+    use occurs due to use in closure\n+\n+borrowck_use_due_to_use_generator =\n+    use occurs due to use in generator\n+\n+borrowck_used_impl_require_static =\n+    the used `impl` has a `'static` requirement\n+\n+borrowck_value_capture_here =\n+    value captured {$is_within ->\n+        [true] here by generator\n+        *[false] here\n     }\n \n borrowck_value_moved_here =\n@@ -224,41 +205,60 @@ borrowck_value_moved_here =\n         *[false] {\"\"}\n     }\n \n-borrowck_consider_borrow_type_contents =\n-    help: consider calling `.as_ref()` or `.as_mut()` to borrow the type's contents\n+borrowck_var_borrow_by_use_in_closure =\n+    borrow occurs due to use in closure\n \n-borrowck_moved_a_fn_once_in_call =\n-    this value implements `FnOnce`, which causes it to be moved when called\n+borrowck_var_borrow_by_use_in_generator =\n+    borrow occurs due to use in generator\n \n-borrowck_calling_operator_moves_lhs =\n-    calling this operator moves the left-hand side\n+borrowck_var_borrow_by_use_place_in_closure =\n+    {$is_single_var ->\n+        *[true] borrow occurs\n+        [false] borrows occur\n+    } due to use of {$place} in closure\n \n-borrowck_func_take_self_moved_place =\n-    `{$func}` takes ownership of the receiver `self`, which moves {$place_name}\n+borrowck_var_borrow_by_use_place_in_generator =\n+    {$is_single_var ->\n+        *[true] borrow occurs\n+        [false] borrows occur\n+    } due to use of {$place} in generator\n \n-borrowck_suggest_iterate_over_slice =\n-    consider iterating over a slice of the `{$ty}`'s content to avoid moving into the `for` loop\n+borrowck_var_cannot_escape_closure =\n+    captured variable cannot escape `FnMut` closure body\n+    .note = `FnMut` closures only have access to their captured variables while they are executing...\n+    .cannot_escape = ...therefore, they cannot allow references to captured variables to escape\n \n-borrowck_suggest_create_freash_reborrow =\n-    consider reborrowing the `Pin` instead of moving it\n+borrowck_var_does_not_need_mut =\n+    variable does not need to be mutable\n+    .suggestion = remove this `mut`\n \n-borrowck_value_capture_here =\n-    value captured {$is_within ->\n-        [true] here by generator\n-        *[false] here\n-    }\n+borrowck_var_first_borrow_by_use_place_in_closure =\n+    first borrow occurs due to use of {$place} in closure\n \n-borrowck_move_out_place_here =\n-    {$place} is moved here\n+borrowck_var_first_borrow_by_use_place_in_generator =\n+    first borrow occurs due to use of {$place} in generator\n \n-borrowck_closure_invoked_twice =\n-    closure cannot be invoked more than once because it moves the variable `{$place_name}` out of its environment\n+borrowck_var_here_captured = variable captured here\n \n-borrowck_closure_moved_twice =\n-    closure cannot be moved more than once as it is not `Copy` due to moving the variable `{$place_name}` out of its environment\n+borrowck_var_here_defined = variable defined here\n \n-borrowck_ty_no_impl_copy =\n-    {$is_partial_move ->\n-        [true] partial move\n-        *[false] move\n-    } occurs because {$place} has type `{$ty}`, which does not implement the `Copy` trait\n+borrowck_var_move_by_use_in_closure =\n+    move occurs due to use in closure\n+\n+borrowck_var_move_by_use_in_generator =\n+    move occurs due to use in generator\n+\n+borrowck_var_move_by_use_place_in_closure =\n+    move occurs due to use of {$place} in closure\n+\n+borrowck_var_move_by_use_place_in_generator =\n+    move occurs due to use of {$place} in generator\n+\n+borrowck_var_mutable_borrow_by_use_place_in_closure =\n+    mutable borrow occurs due to use of {$place} in closure\n+\n+borrowck_var_second_borrow_by_use_place_in_closure =\n+    second borrow occurs due to use of {$place} in closure\n+\n+borrowck_var_second_borrow_by_use_place_in_generator =\n+    second borrow occurs due to use of {$place} in generator"}, {"sha": "f00cd39cbc82a3613b42078e8a4b9fd1ce02cc98", "filename": "compiler/rustc_builtin_macros/messages.ftl", "status": "modified", "additions": 116, "deletions": 116, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,129 +1,140 @@\n-builtin_macros_requires_cfg_pattern =\n-    macro requires a cfg-pattern as an argument\n-    .label = cfg-pattern required\n+builtin_macros_alloc_error_must_be_fn = alloc_error_handler must be a function\n \n-builtin_macros_expected_one_cfg_pattern = expected 1 cfg-pattern\n+builtin_macros_asm_clobber_abi = clobber_abi\n+builtin_macros_asm_clobber_no_reg = asm with `clobber_abi` must specify explicit registers for outputs\n+builtin_macros_asm_clobber_outputs = generic outputs\n \n-builtin_macros_alloc_error_must_be_fn = alloc_error_handler must be a function\n+builtin_macros_asm_duplicate_arg = duplicate argument named `{$name}`\n+    .label = previously here\n+    .arg = duplicate argument\n+\n+builtin_macros_asm_expected_comma = expected token: `,`\n+    .label = expected `,`\n+\n+builtin_macros_asm_expected_other = expected operand, {$is_global_asm ->\n+    [true] options\n+    *[false] clobber_abi, options\n+    }, or additional template string\n+\n+builtin_macros_asm_explicit_register_name = explicit register arguments cannot have names\n+\n+builtin_macros_asm_modifier_invalid = asm template modifier must be a single character\n+\n+builtin_macros_asm_mutually_exclusive = the `{$opt1}` and `{$opt2}` options are mutually exclusive\n+\n+builtin_macros_asm_noreturn = asm outputs are not allowed with the `noreturn` option\n+\n+builtin_macros_asm_opt_already_provided = the `{$symbol}` option was already provided\n+    .label = this option was already provided\n+    .suggestion = remove this option\n+\n+builtin_macros_asm_pos_after = positional arguments cannot follow named arguments or explicit register arguments\n+    .pos = positional argument\n+    .named = named argument\n+    .explicit = explicit register argument\n+\n+builtin_macros_asm_pure_combine = the `pure` option must be combined with either `nomem` or `readonly`\n+\n+builtin_macros_asm_pure_no_output = asm with the `pure` option must have at least one output\n+\n+builtin_macros_asm_requires_template = requires at least a template string argument\n+\n+builtin_macros_asm_sym_no_path = expected a path for argument to `sym`\n+\n+builtin_macros_asm_underscore_input = _ cannot be used for input operands\n+\n+builtin_macros_assert_missing_comma = unexpected string literal\n+    .suggestion = try adding a comma\n \n builtin_macros_assert_requires_boolean = macro requires a boolean expression as an argument\n     .label = boolean expression required\n \n builtin_macros_assert_requires_expression = macro requires an expression as an argument\n     .suggestion = try removing semicolon\n \n-builtin_macros_assert_missing_comma = unexpected string literal\n-    .suggestion = try adding a comma\n+builtin_macros_bad_derive_target = `derive` may only be applied to `struct`s, `enum`s and `union`s\n+    .label = not applicable here\n+    .label2 = not a `struct`, `enum` or `union`\n+\n+builtin_macros_cannot_derive_union = this trait cannot be derived for unions\n \n-builtin_macros_cfg_accessible_unspecified_path = `cfg_accessible` path is not specified\n-builtin_macros_cfg_accessible_multiple_paths = multiple `cfg_accessible` paths are specified\n-builtin_macros_cfg_accessible_literal_path = `cfg_accessible` path cannot be a literal\n builtin_macros_cfg_accessible_has_args = `cfg_accessible` path cannot accept arguments\n \n builtin_macros_cfg_accessible_indeterminate = cannot determine whether the path is accessible or not\n \n-builtin_macros_concat_bytestr = cannot concatenate a byte string literal\n-\n-builtin_macros_concat_missing_literal = expected a literal\n-    .note = only literals (like `\"foo\"`, `-42` and `3.14`) can be passed to `concat!()`\n+builtin_macros_cfg_accessible_literal_path = `cfg_accessible` path cannot be a literal\n+builtin_macros_cfg_accessible_multiple_paths = multiple `cfg_accessible` paths are specified\n+builtin_macros_cfg_accessible_unspecified_path = `cfg_accessible` path is not specified\n+builtin_macros_concat_bytes_array = cannot concatenate doubly nested array\n+    .note = byte strings are treated as arrays of bytes\n+    .help = try flattening the array\n \n-builtin_macros_concat_bytes_missing_literal = expected a byte literal\n-    .note = only byte literals (like `b\"foo\"`, `b's'` and `[3, 4, 5]`) can be passed to `concat_bytes!()`\n+builtin_macros_concat_bytes_bad_repeat = repeat count is not a positive number\n \n builtin_macros_concat_bytes_invalid = cannot concatenate {$lit_kind} literals\n     .byte_char = try using a byte character\n     .byte_str = try using a byte string\n     .number_array = try wrapping the number in an array\n \n-builtin_macros_concat_bytes_oob = numeric literal is out of bounds\n+builtin_macros_concat_bytes_missing_literal = expected a byte literal\n+    .note = only byte literals (like `b\"foo\"`, `b's'` and `[3, 4, 5]`) can be passed to `concat_bytes!()`\n \n builtin_macros_concat_bytes_non_u8 = numeric literal is not a `u8`\n \n-builtin_macros_concat_bytes_array = cannot concatenate doubly nested array\n-    .note = byte strings are treated as arrays of bytes\n-    .help = try flattening the array\n+builtin_macros_concat_bytes_oob = numeric literal is out of bounds\n \n-builtin_macros_concat_bytes_bad_repeat = repeat count is not a positive number\n+builtin_macros_concat_bytestr = cannot concatenate a byte string literal\n+\n+builtin_macros_concat_idents_ident_args = `concat_idents!()` requires ident args\n \n builtin_macros_concat_idents_missing_args = `concat_idents!()` takes 1 or more arguments\n builtin_macros_concat_idents_missing_comma = `concat_idents!()` expecting comma\n-builtin_macros_concat_idents_ident_args = `concat_idents!()` requires ident args\n+builtin_macros_concat_missing_literal = expected a literal\n+    .note = only literals (like `\"foo\"`, `-42` and `3.14`) can be passed to `concat!()`\n \n-builtin_macros_bad_derive_target = `derive` may only be applied to `struct`s, `enum`s and `union`s\n-    .label = not applicable here\n-    .label2 = not a `struct`, `enum` or `union`\n+builtin_macros_default_arg = `#[default]` attribute does not accept a value\n+    .suggestion = try using `#[default]`\n \n-builtin_macros_unexpected_lit = expected path to a trait, found literal\n-    .label = not a trait\n-    .str_lit = try using `#[derive({$sym})]`\n-    .other = for example, write `#[derive(Debug)]` for `Debug`\n+builtin_macros_derive_macro_call = `derive` cannot be used on items with type macros\n \n builtin_macros_derive_path_args_list = traits in `#[derive(...)]` don't accept arguments\n     .suggestion = remove the arguments\n \n builtin_macros_derive_path_args_value = traits in `#[derive(...)]` don't accept values\n     .suggestion = remove the value\n \n-builtin_macros_derive_macro_call = `derive` cannot be used on items with type macros\n-\n-builtin_macros_cannot_derive_union = this trait cannot be derived for unions\n-\n-builtin_macros_no_default_variant = no default declared\n-    .help = make a unit variant default by placing `#[default]` above it\n-    .suggestion = make `{$ident}` default\n-\n-builtin_macros_multiple_defaults = multiple declared defaults\n-    .label = first default\n-    .additional = additional default\n-    .note = only one variant can be default\n-    .suggestion = make `{$ident}` default\n-\n-builtin_macros_non_unit_default = the `#[default]` attribute may only be used on unit enum variants\n-    .help = consider a manual implementation of `Default`\n-\n-builtin_macros_non_exhaustive_default = default variant must be exhaustive\n-    .label = declared `#[non_exhaustive]` here\n-    .help = consider a manual implementation of `Default`\n-\n-builtin_macros_multiple_default_attrs = multiple `#[default]` attributes\n-    .note = only one `#[default]` attribute is needed\n-    .label = `#[default]` used here\n-    .label_again = `#[default]` used again here\n-    .help = try removing {$only_one ->\n-    [true] this\n-    *[false] these\n-    }\n-\n-builtin_macros_default_arg = `#[default]` attribute does not accept a value\n-    .suggestion = try using `#[default]`\n-\n-builtin_macros_env_takes_args = `env!()` takes 1 or 2 arguments\n-\n builtin_macros_env_not_defined = environment variable `{$var}` not defined at compile time\n     .cargo = Cargo sets build script variables at run time. Use `std::env::var(\"{$var}\")` instead\n     .other = use `std::env::var(\"{$var}\")` to read the variable at run time\n \n-builtin_macros_format_requires_string = requires at least a format string argument\n+builtin_macros_env_takes_args = `env!()` takes 1 or 2 arguments\n+\n+builtin_macros_expected_one_cfg_pattern = expected 1 cfg-pattern\n \n builtin_macros_format_duplicate_arg = duplicate argument named `{$ident}`\n     .label1 = previously here\n     .label2 = duplicate argument\n \n+builtin_macros_format_no_arg_named = there is no argument named `{$name}`\n+    .note = did you intend to capture a variable `{$name}` from the surrounding scope?\n+    .note2 = to avoid ambiguity, `format_args!` cannot capture variables when the format string is expanded from a macro\n+\n+builtin_macros_format_pos_mismatch = {$n} positional {$n ->\n+    [one] argument\n+    *[more] arguments\n+    } in format string, but {$desc}\n+\n builtin_macros_format_positional_after_named = positional arguments cannot follow named arguments\n     .label = positional arguments must be before named arguments\n     .named_args = named argument\n \n+builtin_macros_format_requires_string = requires at least a format string argument\n+\n builtin_macros_format_string_invalid = invalid format string: {$desc}\n     .label = {$label1} in format string\n     .note = {$note}\n     .second_label = {$label}\n \n-builtin_macros_sugg = consider using a positional formatting argument instead\n-\n-builtin_macros_format_no_arg_named = there is no argument named `{$name}`\n-    .note = did you intend to capture a variable `{$name}` from the surrounding scope?\n-    .note2 = to avoid ambiguity, `format_args!` cannot capture variables when the format string is expanded from a macro\n-\n builtin_macros_format_unknown_trait = unknown format trait `{$ty}`\n     .note = the only appropriate formatting traits are:\n                                             - ``, which uses the `Display` trait\n@@ -145,60 +156,49 @@ builtin_macros_format_unused_arg = {$named ->\n builtin_macros_format_unused_args = multiple unused formatting arguments\n     .label = multiple missing formatting specifiers\n \n-builtin_macros_format_pos_mismatch = {$n} positional {$n ->\n-    [one] argument\n-    *[more] arguments\n-    } in format string, but {$desc}\n-\n-builtin_macros_test_case_non_item = `#[test_case]` attribute is only allowed on items\n-\n-builtin_macros_test_bad_fn = {$kind} functions cannot be used for tests\n-    .label = `{$kind}` because of this\n-\n-builtin_macros_asm_explicit_register_name = explicit register arguments cannot have names\n-\n-builtin_macros_asm_mutually_exclusive = the `{$opt1}` and `{$opt2}` options are mutually exclusive\n-\n-builtin_macros_asm_pure_combine = the `pure` option must be combined with either `nomem` or `readonly`\n-\n-builtin_macros_asm_pure_no_output = asm with the `pure` option must have at least one output\n-\n-builtin_macros_asm_modifier_invalid = asm template modifier must be a single character\n-\n-builtin_macros_asm_requires_template = requires at least a template string argument\n-\n-builtin_macros_asm_expected_comma = expected token: `,`\n-    .label = expected `,`\n+builtin_macros_global_asm_clobber_abi = `clobber_abi` cannot be used with `global_asm!`\n \n-builtin_macros_asm_underscore_input = _ cannot be used for input operands\n+builtin_macros_multiple_default_attrs = multiple `#[default]` attributes\n+    .note = only one `#[default]` attribute is needed\n+    .label = `#[default]` used here\n+    .label_again = `#[default]` used again here\n+    .help = try removing {$only_one ->\n+    [true] this\n+    *[false] these\n+    }\n \n-builtin_macros_asm_sym_no_path = expected a path for argument to `sym`\n+builtin_macros_multiple_defaults = multiple declared defaults\n+    .label = first default\n+    .additional = additional default\n+    .note = only one variant can be default\n+    .suggestion = make `{$ident}` default\n \n-builtin_macros_asm_expected_other = expected operand, {$is_global_asm ->\n-    [true] options\n-    *[false] clobber_abi, options\n-    }, or additional template string\n+builtin_macros_no_default_variant = no default declared\n+    .help = make a unit variant default by placing `#[default]` above it\n+    .suggestion = make `{$ident}` default\n \n-builtin_macros_asm_duplicate_arg = duplicate argument named `{$name}`\n-    .label = previously here\n-    .arg = duplicate argument\n+builtin_macros_non_exhaustive_default = default variant must be exhaustive\n+    .label = declared `#[non_exhaustive]` here\n+    .help = consider a manual implementation of `Default`\n \n-builtin_macros_asm_pos_after = positional arguments cannot follow named arguments or explicit register arguments\n-    .pos = positional argument\n-    .named = named argument\n-    .explicit = explicit register argument\n+builtin_macros_non_unit_default = the `#[default]` attribute may only be used on unit enum variants\n+    .help = consider a manual implementation of `Default`\n \n-builtin_macros_asm_noreturn = asm outputs are not allowed with the `noreturn` option\n+builtin_macros_requires_cfg_pattern =\n+    macro requires a cfg-pattern as an argument\n+    .label = cfg-pattern required\n \n-builtin_macros_global_asm_clobber_abi = `clobber_abi` cannot be used with `global_asm!`\n+builtin_macros_sugg = consider using a positional formatting argument instead\n \n-builtin_macros_asm_clobber_no_reg = asm with `clobber_abi` must specify explicit registers for outputs\n-builtin_macros_asm_clobber_abi = clobber_abi\n-builtin_macros_asm_clobber_outputs = generic outputs\n+builtin_macros_test_bad_fn = {$kind} functions cannot be used for tests\n+    .label = `{$kind}` because of this\n \n-builtin_macros_asm_opt_already_provided = the `{$symbol}` option was already provided\n-    .label = this option was already provided\n-    .suggestion = remove this option\n+builtin_macros_test_case_non_item = `#[test_case]` attribute is only allowed on items\n \n builtin_macros_test_runner_invalid = `test_runner` argument must be a path\n builtin_macros_test_runner_nargs = `#![test_runner(..)]` accepts exactly 1 argument\n+\n+builtin_macros_unexpected_lit = expected path to a trait, found literal\n+    .label = not a trait\n+    .str_lit = try using `#[derive({$sym})]`\n+    .other = for example, write `#[derive(Debug)]` for `Debug`"}, {"sha": "97bc8ef9d1bbaf755d4d508f15cb2727662f4826", "filename": "compiler/rustc_codegen_gcc/messages.ftl", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_codegen_gcc%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_codegen_gcc%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,68 +1,68 @@\n-codegen_gcc_unwinding_inline_asm =\n-    GCC backend does not support unwinding from inline asm\n-\n-codegen_gcc_lto_not_supported =\n-    LTO is not supported. You may get a linker error.\n+codegen_gcc_invalid_minimum_alignment =\n+    invalid minimum global alignment: {$err}\n \n codegen_gcc_invalid_monomorphization_basic_integer =\n     invalid monomorphization of `{$name}` intrinsic: expected basic integer type, found `{$ty}`\n \n-codegen_gcc_invalid_monomorphization_invalid_float_vector =\n-    invalid monomorphization of `{$name}` intrinsic: unsupported element type `{$elem_ty}` of floating-point vector `{$vec_ty}`\n-\n-codegen_gcc_invalid_monomorphization_not_float =\n-    invalid monomorphization of `{$name}` intrinsic: `{$ty}` is not a floating-point type\n-\n-codegen_gcc_invalid_monomorphization_unrecognized =\n-    invalid monomorphization of `{$name}` intrinsic: unrecognized intrinsic `{$name}`\n-\n codegen_gcc_invalid_monomorphization_expected_signed_unsigned =\n     invalid monomorphization of `{$name}` intrinsic: expected element type `{$elem_ty}` of vector type `{$vec_ty}` to be a signed or unsigned integer type\n \n-codegen_gcc_invalid_monomorphization_unsupported_element =\n-    invalid monomorphization of `{$name}` intrinsic: unsupported {$name} from `{$in_ty}` with element `{$elem_ty}` to `{$ret_ty}`\n+codegen_gcc_invalid_monomorphization_expected_simd =\n+    invalid monomorphization of `{$name}` intrinsic: expected SIMD {$expected_ty} type, found non-SIMD `{$found_ty}`\n+\n+codegen_gcc_invalid_monomorphization_inserted_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected inserted type `{$in_elem}` (element of input `{$in_ty}`), found `{$out_ty}`\n \n codegen_gcc_invalid_monomorphization_invalid_bitmask =\n     invalid monomorphization of `{$name}` intrinsic: invalid bitmask `{$ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n \n-codegen_gcc_invalid_monomorphization_simd_shuffle =\n-    invalid monomorphization of `{$name}` intrinsic: simd_shuffle index must be an array of `u32`, got `{$ty}`\n-\n-codegen_gcc_invalid_monomorphization_expected_simd =\n-    invalid monomorphization of `{$name}` intrinsic: expected SIMD {$expected_ty} type, found non-SIMD `{$found_ty}`\n+codegen_gcc_invalid_monomorphization_invalid_float_vector =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported element type `{$elem_ty}` of floating-point vector `{$vec_ty}`\n \n codegen_gcc_invalid_monomorphization_mask_type =\n     invalid monomorphization of `{$name}` intrinsic: mask element type is `{$ty}`, expected `i_`\n \n+codegen_gcc_invalid_monomorphization_mismatched_lengths =\n+    invalid monomorphization of `{$name}` intrinsic: mismatched lengths: mask length `{$m_len}` != other vector length `{$v_len}`\n+\n+codegen_gcc_invalid_monomorphization_not_float =\n+    invalid monomorphization of `{$name}` intrinsic: `{$ty}` is not a floating-point type\n+\n+codegen_gcc_invalid_monomorphization_return_element =\n+    invalid monomorphization of `{$name}` intrinsic: expected return element type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}` with element type `{$out_ty}`\n+\n+codegen_gcc_invalid_monomorphization_return_integer_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type with integer elements, found `{$ret_ty}` with non-integer `{$out_ty}`\n+\n codegen_gcc_invalid_monomorphization_return_length =\n     invalid monomorphization of `{$name}` intrinsic: expected return type of length {$in_len}, found `{$ret_ty}` with length {$out_len}\n \n codegen_gcc_invalid_monomorphization_return_length_input_type =\n     invalid monomorphization of `{$name}` intrinsic: expected return type with length {$in_len} (same as input type `{$in_ty}`), found `{$ret_ty}` with length {$out_len}\n \n-codegen_gcc_invalid_monomorphization_return_element =\n-    invalid monomorphization of `{$name}` intrinsic: expected return element type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}` with element type `{$out_ty}`\n-\n codegen_gcc_invalid_monomorphization_return_type =\n     invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}`\n \n-codegen_gcc_invalid_monomorphization_inserted_type =\n-    invalid monomorphization of `{$name}` intrinsic: expected inserted type `{$in_elem}` (element of input `{$in_ty}`), found `{$out_ty}`\n-\n-codegen_gcc_invalid_monomorphization_return_integer_type =\n-    invalid monomorphization of `{$name}` intrinsic: expected return type with integer elements, found `{$ret_ty}` with non-integer `{$out_ty}`\n+codegen_gcc_invalid_monomorphization_simd_shuffle =\n+    invalid monomorphization of `{$name}` intrinsic: simd_shuffle index must be an array of `u32`, got `{$ty}`\n \n-codegen_gcc_invalid_monomorphization_mismatched_lengths =\n-    invalid monomorphization of `{$name}` intrinsic: mismatched lengths: mask length `{$m_len}` != other vector length `{$v_len}`\n+codegen_gcc_invalid_monomorphization_unrecognized =\n+    invalid monomorphization of `{$name}` intrinsic: unrecognized intrinsic `{$name}`\n \n codegen_gcc_invalid_monomorphization_unsupported_cast =\n     invalid monomorphization of `{$name}` intrinsic: unsupported cast from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}` with element `{$out_elem}`\n \n+codegen_gcc_invalid_monomorphization_unsupported_element =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported {$name} from `{$in_ty}` with element `{$elem_ty}` to `{$ret_ty}`\n+\n codegen_gcc_invalid_monomorphization_unsupported_operation =\n     invalid monomorphization of `{$name}` intrinsic: unsupported operation on `{$in_ty}` with element `{$in_elem}`\n \n-codegen_gcc_invalid_minimum_alignment =\n-    invalid minimum global alignment: {$err}\n+codegen_gcc_lto_not_supported =\n+    LTO is not supported. You may get a linker error.\n \n codegen_gcc_tied_target_features = the target features {$features} must all be either enabled or disabled together\n     .help = add the missing features in a `target_feature` attribute\n+\n+codegen_gcc_unwinding_inline_asm =\n+    GCC backend does not support unwinding from inline asm"}, {"sha": "55622fdb20ad9136604051c00308c86f0b2aec2d", "filename": "compiler/rustc_codegen_llvm/messages.ftl", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_codegen_llvm%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_codegen_llvm%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,90 +1,90 @@\n-codegen_llvm_unknown_ctarget_feature =\n-    unknown feature specified for `-Ctarget-feature`: `{$feature}`\n-    .note = it is still passed through to the codegen backend\n-    .possible_feature = you might have meant: `{$rust_feature}`\n-    .consider_filing_feature_request = consider filing a feature request\n+codegen_llvm_copy_bitcode = failed to copy bitcode to object file: {$err}\n \n-codegen_llvm_unknown_ctarget_feature_prefix =\n-    unknown feature specified for `-Ctarget-feature`: `{$feature}`\n-    .note = features must begin with a `+` to enable or `-` to disable it\n+codegen_llvm_dlltool_fail_import_library =\n+    Dlltool could not create import library: {$stdout}\n+    {$stderr}\n+\n+codegen_llvm_dynamic_linking_with_lto =\n+    cannot prefer dynamic linking when performing LTO\n+    .note = only 'staticlib', 'bin', and 'cdylib' outputs are supported with LTO\n+\n+codegen_llvm_error_calling_dlltool =\n+    Error calling dlltool '{$dlltool_path}': {$error}\n \n codegen_llvm_error_creating_import_library =\n     Error creating import library for {$lib_name}: {$error}\n \n-codegen_llvm_symbol_already_defined =\n-    symbol `{$symbol_name}` is already defined\n+codegen_llvm_error_writing_def_file =\n+    Error writing .DEF file: {$error}\n+\n+codegen_llvm_from_llvm_diag = {$message}\n \n+codegen_llvm_from_llvm_optimization_diag = {$filename}:{$line}:{$column} {$pass_name} ({$kind}): {$message}\n codegen_llvm_invalid_minimum_alignment =\n     invalid minimum global alignment: {$err}\n \n-codegen_llvm_sanitizer_memtag_requires_mte =\n-    `-Zsanitizer=memtag` requires `-Ctarget-feature=+mte`\n-\n-codegen_llvm_error_writing_def_file =\n-    Error writing .DEF file: {$error}\n+codegen_llvm_load_bitcode = failed to load bitcode of module \"{$name}\"\n+codegen_llvm_load_bitcode_with_llvm_err = failed to load bitcode of module \"{$name}\": {$llvm_err}\n \n-codegen_llvm_error_calling_dlltool =\n-    Error calling dlltool '{$dlltool_path}': {$error}\n+codegen_llvm_lto_bitcode_from_rlib = failed to get bitcode from object file for LTO ({$llvm_err})\n \n-codegen_llvm_dlltool_fail_import_library =\n-    Dlltool could not create import library: {$stdout}\n-    {$stderr}\n+codegen_llvm_lto_disallowed = lto can only be run for executables, cdylibs and static library outputs\n \n-codegen_llvm_target_feature_disable_or_enable =\n-    the target features {$features} must all be either enabled or disabled together\n+codegen_llvm_lto_dylib = lto cannot be used for `dylib` crate type without `-Zdylib-lto`\n \n codegen_llvm_missing_features =\n     add the missing features in a `target_feature` attribute\n \n-codegen_llvm_dynamic_linking_with_lto =\n-    cannot prefer dynamic linking when performing LTO\n-    .note = only 'staticlib', 'bin', and 'cdylib' outputs are supported with LTO\n+codegen_llvm_multiple_source_dicompileunit = multiple source DICompileUnits found\n+codegen_llvm_multiple_source_dicompileunit_with_llvm_err = multiple source DICompileUnits found: {$llvm_err}\n+\n+codegen_llvm_parse_bitcode = failed to parse bitcode for LTO module\n+codegen_llvm_parse_bitcode_with_llvm_err = failed to parse bitcode for LTO module: {$llvm_err}\n \n codegen_llvm_parse_target_machine_config =\n     failed to parse target machine config to target machine: {$error}\n \n-codegen_llvm_lto_disallowed = lto can only be run for executables, cdylibs and static library outputs\n-\n-codegen_llvm_lto_dylib = lto cannot be used for `dylib` crate type without `-Zdylib-lto`\n-\n-codegen_llvm_lto_bitcode_from_rlib = failed to get bitcode from object file for LTO ({$llvm_err})\n-\n-codegen_llvm_write_output = could not write output to {$path}\n-codegen_llvm_write_output_with_llvm_err = could not write output to {$path}: {$llvm_err}\n+codegen_llvm_prepare_thin_lto_context = failed to prepare thin LTO context\n+codegen_llvm_prepare_thin_lto_context_with_llvm_err = failed to prepare thin LTO context: {$llvm_err}\n \n-codegen_llvm_target_machine = could not create LLVM TargetMachine for triple: {$triple}\n-codegen_llvm_target_machine_with_llvm_err = could not create LLVM TargetMachine for triple: {$triple}: {$llvm_err}\n+codegen_llvm_prepare_thin_lto_module = failed to prepare thin LTO module\n+codegen_llvm_prepare_thin_lto_module_with_llvm_err = failed to prepare thin LTO module: {$llvm_err}\n \n codegen_llvm_run_passes = failed to run LLVM passes\n codegen_llvm_run_passes_with_llvm_err = failed to run LLVM passes: {$llvm_err}\n \n+codegen_llvm_sanitizer_memtag_requires_mte =\n+    `-Zsanitizer=memtag` requires `-Ctarget-feature=+mte`\n+\n codegen_llvm_serialize_module = failed to serialize module {$name}\n codegen_llvm_serialize_module_with_llvm_err = failed to serialize module {$name}: {$llvm_err}\n \n-codegen_llvm_write_ir = failed to write LLVM IR to {$path}\n-codegen_llvm_write_ir_with_llvm_err = failed to write LLVM IR to {$path}: {$llvm_err}\n-\n-codegen_llvm_prepare_thin_lto_context = failed to prepare thin LTO context\n-codegen_llvm_prepare_thin_lto_context_with_llvm_err = failed to prepare thin LTO context: {$llvm_err}\n+codegen_llvm_symbol_already_defined =\n+    symbol `{$symbol_name}` is already defined\n \n-codegen_llvm_load_bitcode = failed to load bitcode of module \"{$name}\"\n-codegen_llvm_load_bitcode_with_llvm_err = failed to load bitcode of module \"{$name}\": {$llvm_err}\n+codegen_llvm_target_feature_disable_or_enable =\n+    the target features {$features} must all be either enabled or disabled together\n \n-codegen_llvm_write_thinlto_key = error while writing ThinLTO key data: {$err}\n-codegen_llvm_write_thinlto_key_with_llvm_err = error while writing ThinLTO key data: {$err}: {$llvm_err}\n+codegen_llvm_target_machine = could not create LLVM TargetMachine for triple: {$triple}\n+codegen_llvm_target_machine_with_llvm_err = could not create LLVM TargetMachine for triple: {$triple}: {$llvm_err}\n \n-codegen_llvm_multiple_source_dicompileunit = multiple source DICompileUnits found\n-codegen_llvm_multiple_source_dicompileunit_with_llvm_err = multiple source DICompileUnits found: {$llvm_err}\n+codegen_llvm_unknown_ctarget_feature =\n+    unknown feature specified for `-Ctarget-feature`: `{$feature}`\n+    .note = it is still passed through to the codegen backend\n+    .possible_feature = you might have meant: `{$rust_feature}`\n+    .consider_filing_feature_request = consider filing a feature request\n \n-codegen_llvm_prepare_thin_lto_module = failed to prepare thin LTO module\n-codegen_llvm_prepare_thin_lto_module_with_llvm_err = failed to prepare thin LTO module: {$llvm_err}\n+codegen_llvm_unknown_ctarget_feature_prefix =\n+    unknown feature specified for `-Ctarget-feature`: `{$feature}`\n+    .note = features must begin with a `+` to enable or `-` to disable it\n \n-codegen_llvm_parse_bitcode = failed to parse bitcode for LTO module\n-codegen_llvm_parse_bitcode_with_llvm_err = failed to parse bitcode for LTO module: {$llvm_err}\n+codegen_llvm_write_bytecode = failed to write bytecode to {$path}: {$err}\n \n-codegen_llvm_from_llvm_optimization_diag = {$filename}:{$line}:{$column} {$pass_name} ({$kind}): {$message}\n-codegen_llvm_from_llvm_diag = {$message}\n+codegen_llvm_write_ir = failed to write LLVM IR to {$path}\n+codegen_llvm_write_ir_with_llvm_err = failed to write LLVM IR to {$path}: {$llvm_err}\n \n-codegen_llvm_write_bytecode = failed to write bytecode to {$path}: {$err}\n+codegen_llvm_write_output = could not write output to {$path}\n+codegen_llvm_write_output_with_llvm_err = could not write output to {$path}: {$llvm_err}\n \n-codegen_llvm_copy_bitcode = failed to copy bitcode to object file: {$err}\n+codegen_llvm_write_thinlto_key = error while writing ThinLTO key data: {$err}\n+codegen_llvm_write_thinlto_key_with_llvm_err = error while writing ThinLTO key data: {$err}: {$llvm_err}"}, {"sha": "9aa2b2e2b2ed020013f9a6aaa3bbc89275a776c6", "filename": "compiler/rustc_codegen_ssa/messages.ftl", "status": "modified", "additions": 162, "deletions": 162, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_codegen_ssa%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_codegen_ssa%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,306 +1,306 @@\n-codegen_ssa_lib_def_write_failure = failed to write lib.def file: {$error}\n-\n-codegen_ssa_version_script_write_failure = failed to write version script: {$error}\n+codegen_ssa_L4Bender_exporting_symbols_unimplemented = exporting symbols not implemented yet for L4Bender\n \n-codegen_ssa_symbol_file_write_failure = failed to write symbols file: {$error}\n+codegen_ssa_add_native_library = failed to add native library {$library_path}: {$error}\n \n-codegen_ssa_ld64_unimplemented_modifier = `as-needed` modifier not implemented yet for ld64\n+codegen_ssa_apple_sdk_error_sdk_path = failed to get {$sdk_name} SDK path: {$error}\n \n-codegen_ssa_linker_unsupported_modifier = `as-needed` modifier not supported for current linker\n+codegen_ssa_archive_build_failure =\n+    failed to build archive: {$error}\n \n-codegen_ssa_L4Bender_exporting_symbols_unimplemented = exporting symbols not implemented yet for L4Bender\n+codegen_ssa_atomic_compare_exchange = Atomic compare-exchange intrinsic missing failure memory ordering\n \n-codegen_ssa_no_natvis_directory = error enumerating natvis directory: {$error}\n+codegen_ssa_check_installed_visual_studio = please ensure that Visual Studio 2017 or later, or Build Tools for Visual Studio were installed with the Visual C++ option.\n \n codegen_ssa_copy_path = could not copy {$from} to {$to}: {$error}\n \n codegen_ssa_copy_path_buf = unable to copy {$source_file} to {$output_path}: {$error}\n \n+codegen_ssa_create_temp_dir = couldn't create a temp dir: {$error}\n+\n+codegen_ssa_erroneous_constant = erroneous constant encountered\n+\n+codegen_ssa_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n+\n+codegen_ssa_extern_funcs_not_found = some `extern` functions couldn't be found; some native libraries may need to be installed or have their path specified\n+\n+codegen_ssa_extract_bundled_libs_archive_member = failed to get data from archive member '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_convert_name = failed to convert name '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_mmap_file = failed to mmap file '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_open_file = failed to open file '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_parse_archive = failed to parse archive '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_read_entry = failed to read entry '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_write_file = failed to write file '{$rlib}': {$error}\n+\n+codegen_ssa_failed_to_write = failed to write {$path}: {$error}\n+\n codegen_ssa_ignoring_emit_path = ignoring emit path because multiple .{$extension} files were produced\n \n codegen_ssa_ignoring_output = ignoring -o because multiple .{$extension} files were produced\n \n-codegen_ssa_create_temp_dir = couldn't create a temp dir: {$error}\n+codegen_ssa_illegal_link_ordinal_format = illegal ordinal format in `link_ordinal`\n+    .note = an unsuffixed integer value, e.g., `1`, is expected\n \n codegen_ssa_incompatible_linking_modifiers = link modifiers combination `+bundle,+whole-archive` is unstable when generating rlibs\n \n-codegen_ssa_add_native_library = failed to add native library {$library_path}: {$error}\n-\n-codegen_ssa_multiple_external_func_decl = multiple declarations of external function `{$function}` from library `{$library_name}` have different calling conventions\n+codegen_ssa_insufficient_vs_code_product = VS Code is a different product, and is not sufficient.\n \n-codegen_ssa_rlib_missing_format = could not find formats for rlibs\n+codegen_ssa_invalid_link_ordinal_nargs = incorrect number of arguments to `#[link_ordinal]`\n+    .note = the attribute requires exactly one argument\n \n-codegen_ssa_rlib_only_rmeta_found = could not find rlib for: `{$crate_name}`, found rmeta (metadata) file\n+codegen_ssa_invalid_monomorphization_basic_float_type = invalid monomorphization of `{$name}` intrinsic: expected basic float type, found `{$ty}`\n \n-codegen_ssa_rlib_not_found = could not find rlib for: `{$crate_name}`\n+codegen_ssa_invalid_monomorphization_basic_integer_type = invalid monomorphization of `{$name}` intrinsic: expected basic integer type, found `{$ty}`\n \n-codegen_ssa_rlib_incompatible_dependency_formats = `{$ty1}` and `{$ty2}` do not have equivalent dependency formats (`{$list1}` vs `{$list2}`)\n+codegen_ssa_invalid_monomorphization_cannot_return = invalid monomorphization of `{$name}` intrinsic: cannot return `{$ret_ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n \n-codegen_ssa_linking_failed = linking with `{$linker_path}` failed: {$exit_status}\n+codegen_ssa_invalid_monomorphization_cast_fat_pointer = invalid monomorphization of `{$name}` intrinsic: cannot cast fat pointer `{$ty}`\n \n-codegen_ssa_extern_funcs_not_found = some `extern` functions couldn't be found; some native libraries may need to be installed or have their path specified\n+codegen_ssa_invalid_monomorphization_expected_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of second argument `{$second_arg}` to be a pointer to the element type `{$in_elem}` of the first argument `{$in_ty}`, found `{$expected_element}` != `{$mutability} {$in_elem}`\n \n-codegen_ssa_specify_libraries_to_link = use the `-l` flag to specify native libraries to link\n+codegen_ssa_invalid_monomorphization_expected_pointer = invalid monomorphization of `{$name}` intrinsic: expected pointer, got `{$ty}`\n \n-codegen_ssa_use_cargo_directive = use the `cargo:rustc-link-lib` directive to specify the native libraries to link with Cargo (see https://doc.rust-lang.org/cargo/reference/build-scripts.html#cargorustc-link-libkindname)\n+codegen_ssa_invalid_monomorphization_expected_return_type = invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_ty}`, found `{$ret_ty}`\n \n-codegen_ssa_thorin_read_input_failure = failed to read input file\n+codegen_ssa_invalid_monomorphization_expected_usize = invalid monomorphization of `{$name}` intrinsic: expected `usize`, got `{$ty}`\n \n-codegen_ssa_thorin_parse_input_file_kind = failed to parse input file kind\n+codegen_ssa_invalid_monomorphization_expected_vector_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of vector type `{$vector_type}` to be a signed or unsigned integer type\n \n-codegen_ssa_thorin_parse_input_object_file = failed to parse input object file\n+codegen_ssa_invalid_monomorphization_float_to_int_unchecked = invalid monomorphization of `float_to_int_unchecked` intrinsic: expected basic float type, found `{$ty}`\n \n-codegen_ssa_thorin_parse_input_archive_file = failed to parse input archive file\n+codegen_ssa_invalid_monomorphization_floating_point_type = invalid monomorphization of `{$name}` intrinsic: `{$in_ty}` is not a floating-point type\n \n-codegen_ssa_thorin_parse_archive_member = failed to parse archive member\n+codegen_ssa_invalid_monomorphization_floating_point_vector = invalid monomorphization of `{$name}` intrinsic: unsupported element type `{$f_ty}` of floating-point vector `{$in_ty}`\n \n-codegen_ssa_thorin_invalid_input_kind = input is not an archive or elf object\n+codegen_ssa_invalid_monomorphization_inserted_type = invalid monomorphization of `{$name}` intrinsic: expected inserted type `{$in_elem}` (element of input `{$in_ty}`), found `{$out_ty}`\n \n-codegen_ssa_thorin_decompress_data = failed to decompress compressed section\n+codegen_ssa_invalid_monomorphization_invalid_bitmask = invalid monomorphization of `{$name}` intrinsic: invalid bitmask `{$mask_ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n \n-codegen_ssa_thorin_section_without_name = section without name at offset {$offset}\n+codegen_ssa_invalid_monomorphization_mask_type = invalid monomorphization of `{$name}` intrinsic: mask element type is `{$ty}`, expected `i_`\n \n-codegen_ssa_thorin_relocation_with_invalid_symbol = relocation with invalid symbol for section `{$section}` at offset {$offset}\n+codegen_ssa_invalid_monomorphization_mismatched_lengths = invalid monomorphization of `{$name}` intrinsic: mismatched lengths: mask length `{$m_len}` != other vector length `{$v_len}`\n \n-codegen_ssa_thorin_multiple_relocations = multiple relocations for section `{$section}` at offset {$offset}\n+codegen_ssa_invalid_monomorphization_return_element = invalid monomorphization of `{$name}` intrinsic: expected return element type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}` with element type `{$out_ty}`\n \n-codegen_ssa_thorin_unsupported_relocation = unsupported relocation for section {$section} at offset {$offset}\n+codegen_ssa_invalid_monomorphization_return_integer_type = invalid monomorphization of `{$name}` intrinsic: expected return type with integer elements, found `{$ret_ty}` with non-integer `{$out_ty}`\n \n-codegen_ssa_thorin_missing_dwo_name = missing path attribute to DWARF object ({$id})\n+codegen_ssa_invalid_monomorphization_return_length = invalid monomorphization of `{$name}` intrinsic: expected return type of length {$in_len}, found `{$ret_ty}` with length {$out_len}\n \n-codegen_ssa_thorin_no_compilation_units = input object has no compilation units\n+codegen_ssa_invalid_monomorphization_return_length_input_type = invalid monomorphization of `{$name}` intrinsic: expected return type with length {$in_len} (same as input type `{$in_ty}`), found `{$ret_ty}` with length {$out_len}\n \n-codegen_ssa_thorin_no_die = no top-level debugging information entry in compilation/type unit\n+codegen_ssa_invalid_monomorphization_return_type = invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}`\n \n-codegen_ssa_thorin_top_level_die_not_unit = top-level debugging information entry is not a compilation/type unit\n+codegen_ssa_invalid_monomorphization_second_argument_length = invalid monomorphization of `{$name}` intrinsic: expected second argument with length {$in_len} (same as input type `{$in_ty}`), found `{$arg_ty}` with length {$out_len}\n \n-codegen_ssa_thorin_missing_required_section = input object missing required section `{$section}`\n+codegen_ssa_invalid_monomorphization_shuffle_index_not_constant = invalid monomorphization of `{$name}` intrinsic: shuffle index #{$arg_idx} is not a constant\n \n-codegen_ssa_thorin_parse_unit_abbreviations = failed to parse unit abbreviations\n+codegen_ssa_invalid_monomorphization_shuffle_index_out_of_bounds = invalid monomorphization of `{$name}` intrinsic: shuffle index #{$arg_idx} is out of bounds (limit {$total_len})\n \n-codegen_ssa_thorin_parse_unit_attribute = failed to parse unit attribute\n+codegen_ssa_invalid_monomorphization_simd_argument = invalid monomorphization of `{$name}` intrinsic: expected SIMD argument type, found non-SIMD `{$ty}`\n \n-codegen_ssa_thorin_parse_unit_header = failed to parse unit header\n+codegen_ssa_invalid_monomorphization_simd_first = invalid monomorphization of `{$name}` intrinsic: expected SIMD first type, found non-SIMD `{$ty}`\n \n-codegen_ssa_thorin_parse_unit = failed to parse unit\n+codegen_ssa_invalid_monomorphization_simd_input = invalid monomorphization of `{$name}` intrinsic: expected SIMD input type, found non-SIMD `{$ty}`\n \n-codegen_ssa_thorin_incompatible_index_version = incompatible `{$section}` index version: found version {$actual}, expected version {$format}\n+codegen_ssa_invalid_monomorphization_simd_return = invalid monomorphization of `{$name}` intrinsic: expected SIMD return type, found non-SIMD `{$ty}`\n \n-codegen_ssa_thorin_offset_at_index = read offset at index {$index} of `.debug_str_offsets.dwo` section\n+codegen_ssa_invalid_monomorphization_simd_second = invalid monomorphization of `{$name}` intrinsic: expected SIMD second type, found non-SIMD `{$ty}`\n \n-codegen_ssa_thorin_str_at_offset = read string at offset {$offset} of `.debug_str.dwo` section\n+codegen_ssa_invalid_monomorphization_simd_shuffle = invalid monomorphization of `{$name}` intrinsic: simd_shuffle index must be an array of `u32`, got `{$ty}`\n \n-codegen_ssa_thorin_parse_index = failed to parse `{$section}` index section\n+codegen_ssa_invalid_monomorphization_simd_third = invalid monomorphization of `{$name}` intrinsic: expected SIMD third type, found non-SIMD `{$ty}`\n \n-codegen_ssa_thorin_unit_not_in_index = unit {$unit} from input package is not in its index\n+codegen_ssa_invalid_monomorphization_third_arg_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of third argument `{$third_arg}` to be a signed integer type\n \n-codegen_ssa_thorin_row_not_in_index = row {$row} found in index's hash table not present in index\n+codegen_ssa_invalid_monomorphization_third_argument_length = invalid monomorphization of `{$name}` intrinsic: expected third argument with length {$in_len} (same as input type `{$in_ty}`), found `{$arg_ty}` with length {$out_len}\n \n-codegen_ssa_thorin_section_not_in_row = section not found in unit's row in index\n+codegen_ssa_invalid_monomorphization_unrecognized_intrinsic = invalid monomorphization of `{$name}` intrinsic: unrecognized intrinsic `{$name}`\n \n-codegen_ssa_thorin_empty_unit = unit {$unit} in input DWARF object with no data\n+codegen_ssa_invalid_monomorphization_unsupported_cast = invalid monomorphization of `{$name}` intrinsic: unsupported cast from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}` with element `{$out_elem}`\n \n-codegen_ssa_thorin_multiple_debug_info_section = multiple `.debug_info.dwo` sections\n+codegen_ssa_invalid_monomorphization_unsupported_operation = invalid monomorphization of `{$name}` intrinsic: unsupported operation on `{$in_ty}` with element `{$in_elem}`\n \n-codegen_ssa_thorin_multiple_debug_types_section = multiple `.debug_types.dwo` sections in a package\n+codegen_ssa_invalid_monomorphization_unsupported_symbol = invalid monomorphization of `{$name}` intrinsic: unsupported {$symbol} from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}`\n \n-codegen_ssa_thorin_not_split_unit = regular compilation unit in object (missing dwo identifier)\n+codegen_ssa_invalid_monomorphization_unsupported_symbol_of_size = invalid monomorphization of `{$name}` intrinsic: unsupported {$symbol} from `{$in_ty}` with element `{$in_elem}` of size `{$size}` to `{$ret_ty}`\n \n-codegen_ssa_thorin_duplicate_unit = duplicate split compilation unit ({$unit})\n+codegen_ssa_invalid_monomorphization_vector_argument = invalid monomorphization of `{$name}` intrinsic: vector argument `{$in_ty}`'s element type `{$in_elem}`, expected integer element type\n \n-codegen_ssa_thorin_missing_referenced_unit = unit {$unit} referenced by executable was not found\n+codegen_ssa_invalid_no_sanitize = invalid argument for `no_sanitize`\n+    .note = expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\n \n-codegen_ssa_thorin_not_output_object_created = no output object was created from inputs\n+codegen_ssa_invalid_windows_subsystem = invalid windows subsystem `{$subsystem}`, only `windows` and `console` are allowed\n \n-codegen_ssa_thorin_mixed_input_encodings = input objects haved mixed encodings\n+codegen_ssa_ld64_unimplemented_modifier = `as-needed` modifier not implemented yet for ld64\n \n-codegen_ssa_thorin_io = {$error}\n-codegen_ssa_thorin_object_read = {$error}\n-codegen_ssa_thorin_object_write = {$error}\n-codegen_ssa_thorin_gimli_read = {$error}\n-codegen_ssa_thorin_gimli_write = {$error}\n+codegen_ssa_lib_def_write_failure = failed to write lib.def file: {$error}\n \n codegen_ssa_link_exe_unexpected_error = `link.exe` returned an unexpected error\n \n-codegen_ssa_repair_vs_build_tools = the Visual Studio build tools may need to be repaired using the Visual Studio installer\n-\n-codegen_ssa_missing_cpp_build_tool_component = or a necessary component may be missing from the \"C++ build tools\" workload\n+codegen_ssa_link_script_unavailable = can only use link script when linking with GNU-like linker\n \n-codegen_ssa_select_cpp_build_tool_workload = in the Visual Studio installer, ensure the \"C++ build tools\" workload is selected\n+codegen_ssa_link_script_write_failure = failed to write link script to {$path}: {$error}\n \n-codegen_ssa_visual_studio_not_installed = you may need to install Visual Studio build tools with the \"C++ build tools\" workload\n+codegen_ssa_linker_file_stem = couldn't extract file stem from specified linker\n \n codegen_ssa_linker_not_found = linker `{$linker_path}` not found\n     .note = {$error}\n \n-codegen_ssa_unable_to_exe_linker = could not exec the linker `{$linker_path}`\n-    .note = {$error}\n-    .command_note = {$command_formatted}\n+codegen_ssa_linker_unsupported_modifier = `as-needed` modifier not supported for current linker\n \n-codegen_ssa_msvc_missing_linker = the msvc targets depend on the msvc linker but `link.exe` was not found\n+codegen_ssa_linking_failed = linking with `{$linker_path}` failed: {$exit_status}\n \n-codegen_ssa_check_installed_visual_studio = please ensure that Visual Studio 2017 or later, or Build Tools for Visual Studio were installed with the Visual C++ option.\n+codegen_ssa_metadata_object_file_write = error writing metadata object file: {$error}\n \n-codegen_ssa_insufficient_vs_code_product = VS Code is a different product, and is not sufficient.\n+codegen_ssa_missing_cpp_build_tool_component = or a necessary component may be missing from the \"C++ build tools\" workload\n \n-codegen_ssa_processing_dymutil_failed = processing debug info with `dsymutil` failed: {$status}\n-    .note = {$output}\n+codegen_ssa_missing_memory_ordering = Atomic intrinsic missing memory ordering\n \n-codegen_ssa_unable_to_run_dsymutil = unable to run `dsymutil`: {$error}\n+codegen_ssa_msvc_missing_linker = the msvc targets depend on the msvc linker but `link.exe` was not found\n \n-codegen_ssa_stripping_debug_info_failed = stripping debug info with `{$util}` failed: {$status}\n-    .note = {$output}\n+codegen_ssa_multiple_external_func_decl = multiple declarations of external function `{$function}` from library `{$library_name}` have different calling conventions\n \n-codegen_ssa_unable_to_run = unable to run `{$util}`: {$error}\n+codegen_ssa_multiple_main_functions = entry symbol `main` declared multiple times\n+    .help = did you use `#[no_mangle]` on `fn main`? Use `#[start]` instead\n \n-codegen_ssa_linker_file_stem = couldn't extract file stem from specified linker\n+codegen_ssa_no_natvis_directory = error enumerating natvis directory: {$error}\n \n-codegen_ssa_static_library_native_artifacts = Link against the following native artifacts when linking against this static library. The order and any duplication can be significant on some platforms.\n+codegen_ssa_option_gcc_only = option `-Z gcc-ld` is used even though linker flavor is not gcc\n \n-codegen_ssa_link_script_unavailable = can only use link script when linking with GNU-like linker\n+codegen_ssa_polymorphic_constant_too_generic = codegen encountered polymorphic constant: TooGeneric\n \n-codegen_ssa_link_script_write_failure = failed to write link script to {$path}: {$error}\n+codegen_ssa_processing_dymutil_failed = processing debug info with `dsymutil` failed: {$status}\n+    .note = {$output}\n \n-codegen_ssa_failed_to_write = failed to write {$path}: {$error}\n+codegen_ssa_read_file = failed to read file: {$message}\n \n-codegen_ssa_unable_to_write_debugger_visualizer = Unable to write debugger visualizer file `{$path}`: {$error}\n+codegen_ssa_repair_vs_build_tools = the Visual Studio build tools may need to be repaired using the Visual Studio installer\n \n codegen_ssa_rlib_archive_build_failure = failed to build archive from rlib: {$error}\n \n-codegen_ssa_option_gcc_only = option `-Z gcc-ld` is used even though linker flavor is not gcc\n-\n-codegen_ssa_extract_bundled_libs_open_file = failed to open file '{$rlib}': {$error}\n-codegen_ssa_extract_bundled_libs_mmap_file = failed to mmap file '{$rlib}': {$error}\n-codegen_ssa_extract_bundled_libs_parse_archive = failed to parse archive '{$rlib}': {$error}\n-codegen_ssa_extract_bundled_libs_read_entry = failed to read entry '{$rlib}': {$error}\n-codegen_ssa_extract_bundled_libs_archive_member = failed to get data from archive member '{$rlib}': {$error}\n-codegen_ssa_extract_bundled_libs_convert_name = failed to convert name '{$rlib}': {$error}\n-codegen_ssa_extract_bundled_libs_write_file = failed to write file '{$rlib}': {$error}\n-\n-codegen_ssa_unsupported_arch = unsupported arch `{$arch}` for os `{$os}`\n-\n-codegen_ssa_apple_sdk_error_sdk_path = failed to get {$sdk_name} SDK path: {$error}\n+codegen_ssa_rlib_incompatible_dependency_formats = `{$ty1}` and `{$ty2}` do not have equivalent dependency formats (`{$list1}` vs `{$list2}`)\n \n-codegen_ssa_read_file = failed to read file: {$message}\n+codegen_ssa_rlib_missing_format = could not find formats for rlibs\n \n-codegen_ssa_unsupported_link_self_contained = option `-C link-self-contained` is not supported on this target\n+codegen_ssa_rlib_not_found = could not find rlib for: `{$crate_name}`\n \n-codegen_ssa_archive_build_failure =\n-    failed to build archive: {$error}\n+codegen_ssa_rlib_only_rmeta_found = could not find rlib for: `{$crate_name}`, found rmeta (metadata) file\n \n-codegen_ssa_unknown_archive_kind =\n-    Don't know how to build archive of type: {$kind}\n+codegen_ssa_select_cpp_build_tool_workload = in the Visual Studio installer, ensure the \"C++ build tools\" workload is selected\n \n-codegen_ssa_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n+codegen_ssa_shuffle_indices_evaluation = could not evaluate shuffle_indices at compile time\n \n-codegen_ssa_multiple_main_functions = entry symbol `main` declared multiple times\n-    .help = did you use `#[no_mangle]` on `fn main`? Use `#[start]` instead\n+codegen_ssa_specify_libraries_to_link = use the `-l` flag to specify native libraries to link\n \n-codegen_ssa_metadata_object_file_write = error writing metadata object file: {$error}\n+codegen_ssa_static_library_native_artifacts = Link against the following native artifacts when linking against this static library. The order and any duplication can be significant on some platforms.\n \n-codegen_ssa_invalid_windows_subsystem = invalid windows subsystem `{$subsystem}`, only `windows` and `console` are allowed\n+codegen_ssa_stripping_debug_info_failed = stripping debug info with `{$util}` failed: {$status}\n+    .note = {$output}\n \n-codegen_ssa_erroneous_constant = erroneous constant encountered\n+codegen_ssa_symbol_file_write_failure = failed to write symbols file: {$error}\n \n-codegen_ssa_shuffle_indices_evaluation = could not evaluate shuffle_indices at compile time\n+codegen_ssa_target_feature_safe_trait = `#[target_feature(..)]` cannot be applied to safe trait method\n+    .label = cannot be applied to safe trait method\n+    .label_def = not an `unsafe` function\n \n-codegen_ssa_missing_memory_ordering = Atomic intrinsic missing memory ordering\n+codegen_ssa_thorin_decompress_data = failed to decompress compressed section\n \n-codegen_ssa_unknown_atomic_ordering = unknown ordering in atomic intrinsic\n+codegen_ssa_thorin_duplicate_unit = duplicate split compilation unit ({$unit})\n \n-codegen_ssa_atomic_compare_exchange = Atomic compare-exchange intrinsic missing failure memory ordering\n+codegen_ssa_thorin_empty_unit = unit {$unit} in input DWARF object with no data\n \n-codegen_ssa_unknown_atomic_operation = unknown atomic operation\n+codegen_ssa_thorin_gimli_read = {$error}\n+codegen_ssa_thorin_gimli_write = {$error}\n \n-codegen_ssa_invalid_monomorphization_basic_integer_type = invalid monomorphization of `{$name}` intrinsic: expected basic integer type, found `{$ty}`\n+codegen_ssa_thorin_incompatible_index_version = incompatible `{$section}` index version: found version {$actual}, expected version {$format}\n \n-codegen_ssa_invalid_monomorphization_basic_float_type = invalid monomorphization of `{$name}` intrinsic: expected basic float type, found `{$ty}`\n+codegen_ssa_thorin_invalid_input_kind = input is not an archive or elf object\n \n-codegen_ssa_invalid_monomorphization_float_to_int_unchecked = invalid monomorphization of `float_to_int_unchecked` intrinsic: expected basic float type, found `{$ty}`\n+codegen_ssa_thorin_io = {$error}\n+codegen_ssa_thorin_missing_dwo_name = missing path attribute to DWARF object ({$id})\n \n-codegen_ssa_invalid_monomorphization_floating_point_vector = invalid monomorphization of `{$name}` intrinsic: unsupported element type `{$f_ty}` of floating-point vector `{$in_ty}`\n+codegen_ssa_thorin_missing_referenced_unit = unit {$unit} referenced by executable was not found\n \n-codegen_ssa_invalid_monomorphization_floating_point_type = invalid monomorphization of `{$name}` intrinsic: `{$in_ty}` is not a floating-point type\n+codegen_ssa_thorin_missing_required_section = input object missing required section `{$section}`\n \n-codegen_ssa_invalid_monomorphization_unrecognized_intrinsic = invalid monomorphization of `{$name}` intrinsic: unrecognized intrinsic `{$name}`\n+codegen_ssa_thorin_mixed_input_encodings = input objects haved mixed encodings\n \n-codegen_ssa_invalid_monomorphization_simd_argument = invalid monomorphization of `{$name}` intrinsic: expected SIMD argument type, found non-SIMD `{$ty}`\n+codegen_ssa_thorin_multiple_debug_info_section = multiple `.debug_info.dwo` sections\n \n-codegen_ssa_invalid_monomorphization_simd_input = invalid monomorphization of `{$name}` intrinsic: expected SIMD input type, found non-SIMD `{$ty}`\n+codegen_ssa_thorin_multiple_debug_types_section = multiple `.debug_types.dwo` sections in a package\n \n-codegen_ssa_invalid_monomorphization_simd_first = invalid monomorphization of `{$name}` intrinsic: expected SIMD first type, found non-SIMD `{$ty}`\n+codegen_ssa_thorin_multiple_relocations = multiple relocations for section `{$section}` at offset {$offset}\n \n-codegen_ssa_invalid_monomorphization_simd_second = invalid monomorphization of `{$name}` intrinsic: expected SIMD second type, found non-SIMD `{$ty}`\n+codegen_ssa_thorin_no_compilation_units = input object has no compilation units\n \n-codegen_ssa_invalid_monomorphization_simd_third = invalid monomorphization of `{$name}` intrinsic: expected SIMD third type, found non-SIMD `{$ty}`\n+codegen_ssa_thorin_no_die = no top-level debugging information entry in compilation/type unit\n \n-codegen_ssa_invalid_monomorphization_simd_return = invalid monomorphization of `{$name}` intrinsic: expected SIMD return type, found non-SIMD `{$ty}`\n+codegen_ssa_thorin_not_output_object_created = no output object was created from inputs\n \n-codegen_ssa_invalid_monomorphization_invalid_bitmask = invalid monomorphization of `{$name}` intrinsic: invalid bitmask `{$mask_ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n+codegen_ssa_thorin_not_split_unit = regular compilation unit in object (missing dwo identifier)\n \n-codegen_ssa_polymorphic_constant_too_generic = codegen encountered polymorphic constant: TooGeneric\n+codegen_ssa_thorin_object_read = {$error}\n+codegen_ssa_thorin_object_write = {$error}\n+codegen_ssa_thorin_offset_at_index = read offset at index {$index} of `.debug_str_offsets.dwo` section\n \n-codegen_ssa_invalid_monomorphization_return_length_input_type = invalid monomorphization of `{$name}` intrinsic: expected return type with length {$in_len} (same as input type `{$in_ty}`), found `{$ret_ty}` with length {$out_len}\n+codegen_ssa_thorin_parse_archive_member = failed to parse archive member\n \n-codegen_ssa_invalid_monomorphization_second_argument_length = invalid monomorphization of `{$name}` intrinsic: expected second argument with length {$in_len} (same as input type `{$in_ty}`), found `{$arg_ty}` with length {$out_len}\n+codegen_ssa_thorin_parse_index = failed to parse `{$section}` index section\n \n-codegen_ssa_invalid_monomorphization_third_argument_length = invalid monomorphization of `{$name}` intrinsic: expected third argument with length {$in_len} (same as input type `{$in_ty}`), found `{$arg_ty}` with length {$out_len}\n+codegen_ssa_thorin_parse_input_archive_file = failed to parse input archive file\n \n-codegen_ssa_invalid_monomorphization_return_integer_type = invalid monomorphization of `{$name}` intrinsic: expected return type with integer elements, found `{$ret_ty}` with non-integer `{$out_ty}`\n+codegen_ssa_thorin_parse_input_file_kind = failed to parse input file kind\n \n-codegen_ssa_invalid_monomorphization_simd_shuffle = invalid monomorphization of `{$name}` intrinsic: simd_shuffle index must be an array of `u32`, got `{$ty}`\n+codegen_ssa_thorin_parse_input_object_file = failed to parse input object file\n \n-codegen_ssa_invalid_monomorphization_return_length = invalid monomorphization of `{$name}` intrinsic: expected return type of length {$in_len}, found `{$ret_ty}` with length {$out_len}\n+codegen_ssa_thorin_parse_unit = failed to parse unit\n \n-codegen_ssa_invalid_monomorphization_return_element = invalid monomorphization of `{$name}` intrinsic: expected return element type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}` with element type `{$out_ty}`\n+codegen_ssa_thorin_parse_unit_abbreviations = failed to parse unit abbreviations\n \n-codegen_ssa_invalid_monomorphization_shuffle_index_not_constant = invalid monomorphization of `{$name}` intrinsic: shuffle index #{$arg_idx} is not a constant\n+codegen_ssa_thorin_parse_unit_attribute = failed to parse unit attribute\n \n-codegen_ssa_invalid_monomorphization_shuffle_index_out_of_bounds = invalid monomorphization of `{$name}` intrinsic: shuffle index #{$arg_idx} is out of bounds (limit {$total_len})\n+codegen_ssa_thorin_parse_unit_header = failed to parse unit header\n \n-codegen_ssa_invalid_monomorphization_inserted_type = invalid monomorphization of `{$name}` intrinsic: expected inserted type `{$in_elem}` (element of input `{$in_ty}`), found `{$out_ty}`\n+codegen_ssa_thorin_read_input_failure = failed to read input file\n \n-codegen_ssa_invalid_monomorphization_return_type = invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}`\n+codegen_ssa_thorin_relocation_with_invalid_symbol = relocation with invalid symbol for section `{$section}` at offset {$offset}\n \n-codegen_ssa_invalid_monomorphization_expected_return_type = invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_ty}`, found `{$ret_ty}`\n+codegen_ssa_thorin_row_not_in_index = row {$row} found in index's hash table not present in index\n \n-codegen_ssa_invalid_monomorphization_mismatched_lengths = invalid monomorphization of `{$name}` intrinsic: mismatched lengths: mask length `{$m_len}` != other vector length `{$v_len}`\n+codegen_ssa_thorin_section_not_in_row = section not found in unit's row in index\n \n-codegen_ssa_invalid_monomorphization_mask_type = invalid monomorphization of `{$name}` intrinsic: mask element type is `{$ty}`, expected `i_`\n+codegen_ssa_thorin_section_without_name = section without name at offset {$offset}\n \n-codegen_ssa_invalid_monomorphization_vector_argument = invalid monomorphization of `{$name}` intrinsic: vector argument `{$in_ty}`'s element type `{$in_elem}`, expected integer element type\n+codegen_ssa_thorin_str_at_offset = read string at offset {$offset} of `.debug_str.dwo` section\n \n-codegen_ssa_invalid_monomorphization_cannot_return = invalid monomorphization of `{$name}` intrinsic: cannot return `{$ret_ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n+codegen_ssa_thorin_top_level_die_not_unit = top-level debugging information entry is not a compilation/type unit\n \n-codegen_ssa_invalid_monomorphization_expected_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of second argument `{$second_arg}` to be a pointer to the element type `{$in_elem}` of the first argument `{$in_ty}`, found `{$expected_element}` != `{$mutability} {$in_elem}`\n+codegen_ssa_thorin_unit_not_in_index = unit {$unit} from input package is not in its index\n \n-codegen_ssa_invalid_monomorphization_third_arg_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of third argument `{$third_arg}` to be a signed integer type\n+codegen_ssa_thorin_unsupported_relocation = unsupported relocation for section {$section} at offset {$offset}\n \n-codegen_ssa_invalid_monomorphization_unsupported_symbol_of_size = invalid monomorphization of `{$name}` intrinsic: unsupported {$symbol} from `{$in_ty}` with element `{$in_elem}` of size `{$size}` to `{$ret_ty}`\n+codegen_ssa_unable_to_exe_linker = could not exec the linker `{$linker_path}`\n+    .note = {$error}\n+    .command_note = {$command_formatted}\n \n-codegen_ssa_invalid_monomorphization_unsupported_symbol = invalid monomorphization of `{$name}` intrinsic: unsupported {$symbol} from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}`\n+codegen_ssa_unable_to_run = unable to run `{$util}`: {$error}\n \n-codegen_ssa_invalid_monomorphization_cast_fat_pointer = invalid monomorphization of `{$name}` intrinsic: cannot cast fat pointer `{$ty}`\n+codegen_ssa_unable_to_run_dsymutil = unable to run `dsymutil`: {$error}\n \n-codegen_ssa_invalid_monomorphization_expected_pointer = invalid monomorphization of `{$name}` intrinsic: expected pointer, got `{$ty}`\n+codegen_ssa_unable_to_write_debugger_visualizer = Unable to write debugger visualizer file `{$path}`: {$error}\n \n-codegen_ssa_invalid_monomorphization_expected_usize = invalid monomorphization of `{$name}` intrinsic: expected `usize`, got `{$ty}`\n+codegen_ssa_unknown_archive_kind =\n+    Don't know how to build archive of type: {$kind}\n \n-codegen_ssa_invalid_monomorphization_unsupported_cast = invalid monomorphization of `{$name}` intrinsic: unsupported cast from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}` with element `{$out_elem}`\n+codegen_ssa_unknown_atomic_operation = unknown atomic operation\n \n-codegen_ssa_invalid_monomorphization_unsupported_operation = invalid monomorphization of `{$name}` intrinsic: unsupported operation on `{$in_ty}` with element `{$in_elem}`\n+codegen_ssa_unknown_atomic_ordering = unknown ordering in atomic intrinsic\n \n-codegen_ssa_invalid_monomorphization_expected_vector_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of vector type `{$vector_type}` to be a signed or unsigned integer type\n+codegen_ssa_unsupported_arch = unsupported arch `{$arch}` for os `{$os}`\n \n-codegen_ssa_invalid_no_sanitize = invalid argument for `no_sanitize`\n-    .note = expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\n+codegen_ssa_unsupported_link_self_contained = option `-C link-self-contained` is not supported on this target\n \n-codegen_ssa_invalid_link_ordinal_nargs = incorrect number of arguments to `#[link_ordinal]`\n-    .note = the attribute requires exactly one argument\n+codegen_ssa_use_cargo_directive = use the `cargo:rustc-link-lib` directive to specify the native libraries to link with Cargo (see https://doc.rust-lang.org/cargo/reference/build-scripts.html#cargorustc-link-libkindname)\n \n-codegen_ssa_illegal_link_ordinal_format = illegal ordinal format in `link_ordinal`\n-    .note = an unsuffixed integer value, e.g., `1`, is expected\n+codegen_ssa_version_script_write_failure = failed to write version script: {$error}\n \n-codegen_ssa_target_feature_safe_trait = `#[target_feature(..)]` cannot be applied to safe trait method\n-    .label = cannot be applied to safe trait method\n-    .label_def = not an `unsafe` function\n+codegen_ssa_visual_studio_not_installed = you may need to install Visual Studio build tools with the \"C++ build tools\" workload"}, {"sha": "7d56cf0aa0701a6c4a73772413350cd1b800cb63", "filename": "compiler/rustc_const_eval/messages.ftl", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_const_eval%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_const_eval%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,40 +1,60 @@\n-const_eval_unstable_in_stable =\n-    const-stable function cannot use `#[feature({$gate})]`\n-    .unstable_sugg = if it is not part of the public API, make this function unstably const\n-    .bypass_sugg = otherwise `#[rustc_allow_const_fn_unstable]` can be used to bypass stability checks\n+const_eval_interior_mutability_borrow =\n+    cannot borrow here, since the borrowed element may contain interior mutability\n \n-const_eval_thread_local_access =\n-    thread-local statics cannot be accessed at compile-time\n+const_eval_interior_mutable_data_refer =\n+    {$kind}s cannot refer to interior mutable data\n+    .label = this borrow of an interior mutable value may end up in the final value\n+    .help = to fix this, the value can be extracted to a separate `static` item and then referenced\n+    .teach_note =\n+        A constant containing interior mutable data behind a reference can allow you to modify that data.\n+        This would make multiple uses of a constant to be able to see different values and allow circumventing\n+        the `Send` and `Sync` requirements for shared mutable data, which is unsound.\n \n-const_eval_static_access =\n-    {$kind}s cannot refer to statics\n-    .help = consider extracting the value of the `static` to a `const`, and referring to that\n-    .teach_note = `static` and `const` variables can refer to other `const` variables. A `const` variable, however, cannot refer to a `static` variable.\n-    .teach_help = To fix this, the value can be extracted to a `const` and then used.\n+const_eval_max_num_nodes_in_const = maximum number of nodes exceeded in constant {$global_const_id}\n \n-const_eval_raw_ptr_to_int =\n-    pointers cannot be cast to integers during const eval\n-    .note = at compile-time, pointers do not have an integer value\n-    .note2 = avoiding this restriction via `transmute`, `union`, or raw pointers leads to compile-time undefined behavior\n+const_eval_mut_deref =\n+    mutation through a reference is not allowed in {$kind}s\n+\n+const_eval_non_const_fmt_macro_call =\n+    cannot call non-const formatting macro in {$kind}s\n+\n+const_eval_non_const_fn_call =\n+    cannot call non-const fn `{$def_path_str}` in {$kind}s\n+\n+const_eval_panic_non_str = argument to `panic!()` in a const context must have type `&str`\n \n const_eval_raw_ptr_comparison =\n     pointers cannot be reliably compared during const eval\n     .note = see issue #53020 <https://github.com/rust-lang/rust/issues/53020> for more information\n \n-const_eval_panic_non_str = argument to `panic!()` in a const context must have type `&str`\n+const_eval_raw_ptr_to_int =\n+    pointers cannot be cast to integers during const eval\n+    .note = at compile-time, pointers do not have an integer value\n+    .note2 = avoiding this restriction via `transmute`, `union`, or raw pointers leads to compile-time undefined behavior\n \n-const_eval_mut_deref =\n-    mutation through a reference is not allowed in {$kind}s\n+const_eval_static_access =\n+    {$kind}s cannot refer to statics\n+    .help = consider extracting the value of the `static` to a `const`, and referring to that\n+    .teach_note = `static` and `const` variables can refer to other `const` variables. A `const` variable, however, cannot refer to a `static` variable.\n+    .teach_help = To fix this, the value can be extracted to a `const` and then used.\n+\n+const_eval_thread_local_access =\n+    thread-local statics cannot be accessed at compile-time\n \n const_eval_transient_mut_borrow = mutable references are not allowed in {$kind}s\n \n const_eval_transient_mut_borrow_raw = raw mutable references are not allowed in {$kind}s\n \n-const_eval_max_num_nodes_in_const = maximum number of nodes exceeded in constant {$global_const_id}\n-\n const_eval_unallowed_fn_pointer_call = function pointer calls are not allowed in {$kind}s\n \n-const_eval_unstable_const_fn = `{$def_path}` is not yet stable as a const fn\n+const_eval_unallowed_heap_allocations =\n+    allocations are not allowed in {$kind}s\n+    .label = allocation not allowed in {$kind}s\n+    .teach_note =\n+        The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time.\n+\n+const_eval_unallowed_inline_asm =\n+    inline assembly is not allowed in {$kind}s\n \n const_eval_unallowed_mutable_refs =\n     mutable references are not allowed in the final value of {$kind}s\n@@ -60,32 +80,12 @@ const_eval_unallowed_mutable_refs_raw =\n \n         If you really want global mutable state, try using static mut or a global UnsafeCell.\n \n-const_eval_non_const_fmt_macro_call =\n-    cannot call non-const formatting macro in {$kind}s\n-\n-const_eval_non_const_fn_call =\n-    cannot call non-const fn `{$def_path_str}` in {$kind}s\n-\n const_eval_unallowed_op_in_const_context =\n     {$msg}\n \n-const_eval_unallowed_heap_allocations =\n-    allocations are not allowed in {$kind}s\n-    .label = allocation not allowed in {$kind}s\n-    .teach_note =\n-        The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time.\n-\n-const_eval_unallowed_inline_asm =\n-    inline assembly is not allowed in {$kind}s\n-\n-const_eval_interior_mutable_data_refer =\n-    {$kind}s cannot refer to interior mutable data\n-    .label = this borrow of an interior mutable value may end up in the final value\n-    .help = to fix this, the value can be extracted to a separate `static` item and then referenced\n-    .teach_note =\n-        A constant containing interior mutable data behind a reference can allow you to modify that data.\n-        This would make multiple uses of a constant to be able to see different values and allow circumventing\n-        the `Send` and `Sync` requirements for shared mutable data, which is unsound.\n+const_eval_unstable_const_fn = `{$def_path}` is not yet stable as a const fn\n \n-const_eval_interior_mutability_borrow =\n-    cannot borrow here, since the borrowed element may contain interior mutability\n+const_eval_unstable_in_stable =\n+    const-stable function cannot use `#[feature({$gate})]`\n+    .unstable_sugg = if it is not part of the public API, make this function unstably const\n+    .bypass_sugg = otherwise `#[rustc_allow_const_fn_unstable]` can be used to bypass stability checks"}, {"sha": "22b4ec6b0d1b1ba1b053bdecbc76df36982c8aa9", "filename": "compiler/rustc_driver_impl/messages.ftl", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_driver_impl%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_driver_impl%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,19 +1,19 @@\n-driver_impl_rlink_unable_to_read = failed to read rlink file: `{$err}`\n-\n-driver_impl_rlink_wrong_file_type = The input does not look like a .rlink file\n+driver_impl_ice = the compiler unexpectedly panicked. this is a bug.\n+driver_impl_ice_bug_report = we would appreciate a bug report: {$bug_report_url}\n+driver_impl_ice_exclude_cargo_defaults = some of the compiler flags provided by cargo are hidden\n \n+driver_impl_ice_flags = compiler flags: {$flags}\n+driver_impl_ice_version = rustc {$version} running on {$triple}\n driver_impl_rlink_empty_version_number = The input does not contain version number\n \n driver_impl_rlink_encoding_version_mismatch = .rlink file was produced with encoding version `{$version_array}`, but the current version is `{$rlink_version}`\n \n+driver_impl_rlink_no_a_file = rlink must be a file\n+\n driver_impl_rlink_rustc_version_mismatch = .rlink file was produced by rustc version `{$rustc_version}`, but the current version is `{$current_version}`\n \n-driver_impl_rlink_no_a_file = rlink must be a file\n+driver_impl_rlink_unable_to_read = failed to read rlink file: `{$err}`\n \n-driver_impl_unpretty_dump_fail = pretty-print failed to write `{$path}` due to error `{$err}`\n+driver_impl_rlink_wrong_file_type = The input does not look like a .rlink file\n \n-driver_impl_ice = the compiler unexpectedly panicked. this is a bug.\n-driver_impl_ice_bug_report = we would appreciate a bug report: {$bug_report_url}\n-driver_impl_ice_version = rustc {$version} running on {$triple}\n-driver_impl_ice_flags = compiler flags: {$flags}\n-driver_impl_ice_exclude_cargo_defaults = some of the compiler flags provided by cargo are hidden\n+driver_impl_unpretty_dump_fail = pretty-print failed to write `{$path}` due to error `{$err}`"}, {"sha": "33709734322b6b9a309be5dab7bd44dfbcf1c758", "filename": "compiler/rustc_errors/messages.ftl", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_errors%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_errors%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,19 +1,19 @@\n-errors_target_invalid_address_space =\n-    invalid address space `{$addr_space}` for `{$cause}` in \"data-layout\": {$err}\n+errors_target_inconsistent_architecture =\n+    inconsistent target specification: \"data-layout\" claims architecture is {$dl}-endian, while \"target-endian\" is `{$target}`\n \n-errors_target_invalid_bits =\n-    invalid {$kind} `{$bit}` for `{$cause}` in \"data-layout\": {$err}\n+errors_target_inconsistent_pointer_width =\n+    inconsistent target specification: \"data-layout\" claims pointers are {$pointer_size}-bit, while \"target-pointer-width\" is `{$target}`\n \n-errors_target_missing_alignment =\n-    missing alignment for `{$cause}` in \"data-layout\"\n+errors_target_invalid_address_space =\n+    invalid address space `{$addr_space}` for `{$cause}` in \"data-layout\": {$err}\n \n errors_target_invalid_alignment =\n     invalid alignment for `{$cause}` in \"data-layout\": {$err}\n \n-errors_target_inconsistent_architecture =\n-    inconsistent target specification: \"data-layout\" claims architecture is {$dl}-endian, while \"target-endian\" is `{$target}`\n-\n-errors_target_inconsistent_pointer_width =\n-    inconsistent target specification: \"data-layout\" claims pointers are {$pointer_size}-bit, while \"target-pointer-width\" is `{$target}`\n+errors_target_invalid_bits =\n+    invalid {$kind} `{$bit}` for `{$cause}` in \"data-layout\": {$err}\n \n errors_target_invalid_bits_size = {$err}\n+\n+errors_target_missing_alignment =\n+    missing alignment for `{$cause}` in \"data-layout\""}, {"sha": "6c7e68246ea5f431026c1a20355bc51b317828f3", "filename": "compiler/rustc_expand/messages.ftl", "status": "modified", "additions": 89, "deletions": 89, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_expand%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_expand%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,142 +1,142 @@\n-expand_explain_doc_comment_outer =\n-    outer doc comments expand to `#[doc = \"...\"]`, which is what this macro attempted to match\n-\n-expand_explain_doc_comment_inner =\n-    inner doc comments expand to `#![doc = \"...\"]`, which is what this macro attempted to match\n-\n-expand_expr_repeat_no_syntax_vars =\n-    attempted to repeat an expression containing no syntax variables matched as repeating at this depth\n-\n-expand_must_repeat_once =\n-    this must repeat at least once\n-\n-expand_count_repetition_misplaced =\n-    `count` can not be placed inside the inner-most repetition\n-\n-expand_meta_var_expr_unrecognized_var =\n-    variable `{$key}` is not recognized in meta-variable expression\n-\n-expand_var_still_repeating =\n-    variable '{$ident}' is still repeating at this depth\n-\n-expand_meta_var_dif_seq_matchers = {$msg}\n-\n-expand_macro_const_stability =\n-    macros cannot have const stability attributes\n-    .label = invalid const stability attribute\n-    .label2 = const stability attribute affects this macro\n-\n-expand_macro_body_stability =\n-    macros cannot have body stability attributes\n-    .label = invalid body stability attribute\n-    .label2 = body stability attribute affects this macro\n-\n-expand_resolve_relative_path =\n-    cannot resolve relative path in non-file source `{$path}`\n+expand_arg_not_attributes =\n+    second argument must be `attributes`\n \n expand_attr_no_arguments =\n     attribute must have either one or two arguments\n \n-expand_not_a_meta_item =\n-    not a meta item\n-\n-expand_only_one_word =\n-    must only be one word\n-\n-expand_cannot_be_name_of_macro =\n-    `{$trait_ident}` cannot be a name of {$macro_type} macro\n+expand_attribute_meta_item =\n+    attribute must be a meta item, not a literal\n \n-expand_arg_not_attributes =\n-    second argument must be `attributes`\n+expand_attribute_single_word =\n+    attribute must only be a single word\n \n expand_attributes_wrong_form =\n     attribute must be of form: `attributes(foo, bar)`\n \n-expand_attribute_meta_item =\n-    attribute must be a meta item, not a literal\n+expand_cannot_be_name_of_macro =\n+    `{$trait_ident}` cannot be a name of {$macro_type} macro\n \n-expand_attribute_single_word =\n-    attribute must only be a single word\n+expand_count_repetition_misplaced =\n+    `count` can not be placed inside the inner-most repetition\n \n-expand_helper_attribute_name_invalid =\n-    `{$name}` cannot be a name of derive helper attribute\n+expand_duplicate_matcher_binding = duplicate matcher binding\n+    .label = duplicate binding\n+    .label2 = previous binding\n \n expand_expected_comma_in_list =\n     expected token: `,`\n \n-expand_only_one_argument =\n-    {$name} takes 1 argument\n+expand_explain_doc_comment_inner =\n+    inner doc comments expand to `#![doc = \"...\"]`, which is what this macro attempted to match\n \n-expand_takes_no_arguments =\n-    {$name} takes no arguments\n+expand_explain_doc_comment_outer =\n+    outer doc comments expand to `#[doc = \"...\"]`, which is what this macro attempted to match\n+\n+expand_expr_repeat_no_syntax_vars =\n+    attempted to repeat an expression containing no syntax variables matched as repeating at this depth\n \n expand_feature_included_in_edition =\n     the feature `{$feature}` is included in the Rust {$edition} edition\n \n+expand_feature_not_allowed =\n+    the feature `{$name}` is not in the list of allowed features\n+\n expand_feature_removed =\n     feature has been removed\n     .label = feature has been removed\n     .reason = {$reason}\n \n-expand_feature_not_allowed =\n-    the feature `{$name}` is not in the list of allowed features\n-\n-expand_recursion_limit_reached =\n-    recursion limit reached while expanding `{$descr}`\n-    .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]` attribute to your crate (`{$crate_name}`)\n+expand_helper_attribute_name_invalid =\n+    `{$name}` cannot be a name of derive helper attribute\n \n-expand_malformed_feature_attribute =\n-    malformed `feature` attribute input\n-    .expected = expected just one word\n+expand_incomplete_parse =\n+    macro expansion ignores token `{$token}` and any following\n+    .label = caused by the macro expansion here\n+    .note = the usage of `{$macro_path}!` is likely invalid in {$kind_name} context\n+    .suggestion_add_semi = you might be missing a semicolon here\n \n-expand_remove_expr_not_supported =\n-    removing an expression is not supported in this position\n+expand_invalid_cfg_expected_syntax = expected syntax is\n \n+expand_invalid_cfg_multiple_predicates = multiple `cfg` predicates are specified\n expand_invalid_cfg_no_parens = `cfg` is not followed by parentheses\n expand_invalid_cfg_no_predicate = `cfg` predicate is not specified\n-expand_invalid_cfg_multiple_predicates = multiple `cfg` predicates are specified\n expand_invalid_cfg_predicate_literal = `cfg` predicate key cannot be a literal\n-expand_invalid_cfg_expected_syntax = expected syntax is\n+expand_macro_body_stability =\n+    macros cannot have body stability attributes\n+    .label = invalid body stability attribute\n+    .label2 = body stability attribute affects this macro\n \n-expand_wrong_fragment_kind =\n-    non-{$kind} macro in {$kind} position: {$name}\n+expand_macro_const_stability =\n+    macros cannot have const stability attributes\n+    .label = invalid const stability attribute\n+    .label2 = const stability attribute affects this macro\n \n-expand_unsupported_key_value =\n-    key-value macro attributes are not supported\n+expand_malformed_feature_attribute =\n+    malformed `feature` attribute input\n+    .expected = expected just one word\n \n-expand_incomplete_parse =\n-    macro expansion ignores token `{$token}` and any following\n-    .label = caused by the macro expansion here\n-    .note = the usage of `{$macro_path}!` is likely invalid in {$kind_name} context\n-    .suggestion_add_semi = you might be missing a semicolon here\n+expand_meta_var_dif_seq_matchers = {$msg}\n \n-expand_remove_node_not_supported =\n-    removing {$descr} is not supported in this position\n+expand_meta_var_expr_unrecognized_var =\n+    variable `{$key}` is not recognized in meta-variable expression\n \n expand_module_circular =\n     circular modules: {$modules}\n \n-expand_module_in_block =\n-    cannot declare a non-inline module inside a block unless it has a path attribute\n-    .note = maybe `use` the module `{$name}` instead of redeclaring it\n-\n expand_module_file_not_found =\n     file not found for module `{$name}`\n     .help = to create the module `{$name}`, create file \"{$default_path}\" or \"{$secondary_path}\"\n \n+expand_module_in_block =\n+    cannot declare a non-inline module inside a block unless it has a path attribute\n+    .note = maybe `use` the module `{$name}` instead of redeclaring it\n+\n expand_module_multiple_candidates =\n     file for module `{$name}` found at both \"{$default_path}\" and \"{$secondary_path}\"\n     .help = delete or rename one of them to remove the ambiguity\n \n-expand_trace_macro = trace_macro\n+expand_must_repeat_once =\n+    this must repeat at least once\n+\n+expand_not_a_meta_item =\n+    not a meta item\n+\n+expand_only_one_argument =\n+    {$name} takes 1 argument\n+\n+expand_only_one_word =\n+    must only be one word\n+\n+expand_proc_macro_derive_tokens =\n+    proc-macro derive produced unparsable tokens\n \n expand_proc_macro_panicked =\n     proc macro panicked\n     .help = message: {$message}\n \n-expand_proc_macro_derive_tokens =\n-    proc-macro derive produced unparsable tokens\n+expand_recursion_limit_reached =\n+    recursion limit reached while expanding `{$descr}`\n+    .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]` attribute to your crate (`{$crate_name}`)\n \n-expand_duplicate_matcher_binding = duplicate matcher binding\n-    .label = duplicate binding\n-    .label2 = previous binding\n+expand_remove_expr_not_supported =\n+    removing an expression is not supported in this position\n+\n+expand_remove_node_not_supported =\n+    removing {$descr} is not supported in this position\n+\n+expand_resolve_relative_path =\n+    cannot resolve relative path in non-file source `{$path}`\n+\n+expand_takes_no_arguments =\n+    {$name} takes no arguments\n+\n+expand_trace_macro = trace_macro\n+\n+expand_unsupported_key_value =\n+    key-value macro attributes are not supported\n+\n+expand_var_still_repeating =\n+    variable '{$ident}' is still repeating at this depth\n+\n+expand_wrong_fragment_kind =\n+    non-{$kind} macro in {$kind} position: {$name}"}, {"sha": "02d1dfcd1134c4885fa27bb42486e8588b094c1d", "filename": "compiler/rustc_hir_analysis/messages.ftl", "status": "modified", "additions": 183, "deletions": 183, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,77 +1,144 @@\n-hir_analysis_unrecognized_atomic_operation =\n-    unrecognized atomic operation function: `{$op}`\n-    .label = unrecognized atomic operation\n+hir_analysis_ambiguous_lifetime_bound =\n+    ambiguous lifetime bound, explicit lifetime bound required\n \n-hir_analysis_wrong_number_of_generic_arguments_to_intrinsic =\n-    intrinsic has wrong number of {$descr} parameters: found {$found}, expected {$expected}\n-    .label = expected {$expected} {$descr} {$expected ->\n-        [one] parameter\n-        *[other] parameters\n-    }\n+hir_analysis_assoc_type_binding_not_allowed =\n+    associated type bindings are not allowed here\n+    .label = associated type not allowed here\n \n-hir_analysis_unrecognized_intrinsic_function =\n-    unrecognized intrinsic function: `{$name}`\n-    .label = unrecognized intrinsic\n+hir_analysis_associated_type_trait_uninferred_generic_params = cannot use the associated type of a trait with uninferred generic parameters\n+    .suggestion = use a fully qualified path with inferred lifetimes\n \n-hir_analysis_lifetimes_or_bounds_mismatch_on_trait =\n-    lifetime parameters or bounds on {$item_kind} `{$ident}` do not match the trait declaration\n-    .label = lifetimes do not match {$item_kind} in trait\n-    .generics_label = lifetimes in impl do not match this {$item_kind} in trait\n-    .where_label = this `where` clause might not match the one in the trait\n-    .bounds_label = this bound might be missing in the impl\n+hir_analysis_associated_type_trait_uninferred_generic_params_multipart_suggestion = use a fully qualified path with explicit lifetimes\n \n hir_analysis_async_trait_impl_should_be_async =\n     method `{$method_name}` should be async because the method from the trait is async\n     .trait_item_label = required because the trait method is async\n \n+hir_analysis_auto_deref_reached_recursion_limit = reached the recursion limit while auto-dereferencing `{$ty}`\n+    .label = deref recursion limit reached\n+    .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]` attribute to your crate (`{$crate_name}`)\n+\n+hir_analysis_cannot_capture_late_bound_const_in_anon_const =\n+    cannot capture late-bound const parameter in a constant\n+    .label = parameter defined here\n+\n+hir_analysis_cannot_capture_late_bound_ty_in_anon_const =\n+    cannot capture late-bound type parameter in a constant\n+    .label = parameter defined here\n+\n+hir_analysis_cast_thin_pointer_to_fat_pointer = cannot cast thin pointer `{$expr_ty}` to fat pointer `{$cast_ty}`\n+\n+hir_analysis_closure_implicit_hrtb = implicit types in closure signatures are forbidden when `for<...>` is present\n+    .label = `for<...>` is here\n+\n+hir_analysis_const_bound_for_non_const_trait =\n+    ~const can only be applied to `#[const_trait]` traits\n+\n+hir_analysis_const_impl_for_non_const_trait =\n+    const `impl` for trait `{$trait_name}` which is not marked with `#[const_trait]`\n+    .suggestion = mark `{$trait_name}` as const\n+    .note = marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+    .adding = adding a non-const method body in the future would be a breaking change\n+\n+hir_analysis_const_param_ty_impl_on_non_adt =\n+    the trait `ConstParamTy` may not be implemented for this type\n+    .label = type is not a structure or enumeration\n+\n+hir_analysis_const_specialize = cannot specialize on const impl with non-const impl\n+\n+hir_analysis_copy_impl_on_non_adt =\n+    the trait `Copy` cannot be implemented for this type\n+    .label = type is not a structure or enumeration\n+\n+hir_analysis_copy_impl_on_type_with_dtor =\n+    the trait `Copy` cannot be implemented for this type; the type has a destructor\n+    .label = `Copy` not allowed on types with destructors\n+\n+hir_analysis_drop_impl_negative = negative `Drop` impls are not supported\n+\n hir_analysis_drop_impl_on_wrong_item =\n     the `Drop` trait may only be implemented for local structs, enums, and unions\n     .label = must be a struct, enum, or union in the current crate\n \n+hir_analysis_drop_impl_reservation = reservation `Drop` impls are not supported\n+\n+hir_analysis_empty_specialization = specialization impl does not specialize any associated items\n+    .note = impl is a specialization of this impl\n+\n+hir_analysis_enum_discriminant_overflowed = enum discriminant overflowed\n+    .label = overflowed on value after {$discr}\n+    .note = explicitly set `{$item_name} = {$wrapped_discr}` if that is desired outcome\n+\n+hir_analysis_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n+\n hir_analysis_field_already_declared =\n     field `{$field_name}` is already declared\n     .label = field already declared\n     .previous_decl_label = `{$field_name}` first declared here\n \n-hir_analysis_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n+hir_analysis_function_not_found_in_trait = function not found in this trait\n \n-hir_analysis_const_param_ty_impl_on_non_adt =\n-    the trait `ConstParamTy` may not be implemented for this type\n-    .label = type is not a structure or enumeration\n+hir_analysis_function_not_have_default_implementation = function doesn't have a default implementation\n+    .note = required by this annotation\n \n-hir_analysis_ambiguous_lifetime_bound =\n-    ambiguous lifetime bound, explicit lifetime bound required\n+hir_analysis_functions_names_duplicated = functions names are duplicated\n+    .note = all `#[rustc_must_implement_one_of]` arguments must be unique\n \n-hir_analysis_assoc_type_binding_not_allowed =\n-    associated type bindings are not allowed here\n-    .label = associated type not allowed here\n+hir_analysis_impl_not_marked_default = `{$ident}` specializes an item from a parent `impl`, but that item is not marked `default`\n+    .label = cannot specialize default item `{$ident}`\n+    .ok_label = parent `impl` is here\n+    .note = to specialize, `{$ident}` in the parent `impl` must be marked `default`\n \n-hir_analysis_parenthesized_fn_trait_expansion =\n-    parenthesized trait syntax expands to `{$expanded_type}`\n+hir_analysis_impl_not_marked_default_err = `{$ident}` specializes an item from a parent `impl`, but that item is not marked `default`\n+    .note = parent implementation is in crate `{$cname}`\n \n-hir_analysis_typeof_reserved_keyword_used =\n-    `typeof` is a reserved keyword but unimplemented\n-    .suggestion = consider replacing `typeof(...)` with an actual type\n-    .label = reserved keyword\n+hir_analysis_invalid_union_field =\n+    field must implement `Copy` or be wrapped in `ManuallyDrop<...>` to be used in a union\n+    .note = union fields must not have drop side-effects, which is currently enforced via either `Copy` or `ManuallyDrop<...>`\n \n-hir_analysis_value_of_associated_struct_already_specified =\n-    the value of the associated type `{$item_name}` (from trait `{$def_path}`) is already specified\n-    .label = re-bound here\n-    .previous_bound_label = `{$item_name}` bound here first\n+hir_analysis_invalid_union_field_sugg =\n+    wrap the field type in `ManuallyDrop<...>`\n \n-hir_analysis_unconstrained_opaque_type = unconstrained opaque type\n-    .note = `{$name}` must be used in combination with a concrete type within the same {$what}\n+hir_analysis_lifetimes_or_bounds_mismatch_on_trait =\n+    lifetime parameters or bounds on {$item_kind} `{$ident}` do not match the trait declaration\n+    .label = lifetimes do not match {$item_kind} in trait\n+    .generics_label = lifetimes in impl do not match this {$item_kind} in trait\n+    .where_label = this `where` clause might not match the one in the trait\n+    .bounds_label = this bound might be missing in the impl\n+\n+hir_analysis_linkage_type =\n+    invalid type for variable with `#[linkage]` attribute\n+\n+hir_analysis_main_function_async = `main` function is not allowed to be `async`\n+    .label = `main` function is not allowed to be `async`\n+\n+hir_analysis_main_function_generic_parameters = `main` function is not allowed to have generic parameters\n+    .label = `main` cannot have generic parameters\n+\n+hir_analysis_main_function_return_type_generic = `main` function return type is not allowed to have generic parameters\n \n hir_analysis_manual_implementation =\n     manual implementations of `{$trait_name}` are experimental\n     .label = manual implementations of `{$trait_name}` are experimental\n     .help = add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n-hir_analysis_substs_on_overridden_impl = could not resolve substs on overridden impl\n+hir_analysis_missing_one_of_trait_item = not all trait items implemented, missing one of: `{$missing_items_msg}`\n+    .label = missing one of `{$missing_items_msg}` in implementation\n+    .note = required because of this annotation\n \n-hir_analysis_trait_object_declared_with_no_traits =\n-    at least one trait is required for an object type\n-    .alias_span = this alias does not contain a trait\n+hir_analysis_missing_tilde_const = missing `~const` qualifier for specialization\n+\n+hir_analysis_missing_trait_item = not all trait items implemented, missing: `{$missing_items_msg}`\n+    .label = missing `{$missing_items_msg}` in implementation\n+\n+hir_analysis_missing_trait_item_label = `{$item}` from trait\n+\n+hir_analysis_missing_trait_item_suggestion = implement the missing item: `{$snippet}`\n+\n+hir_analysis_missing_trait_item_unstable = not all trait items implemented, missing: `{$missing_item_name}`\n+    .note = default implementation of `{$missing_item_name}` is unstable\n+    .some_note = use of unstable library feature '{$feature}': {$r}\n+    .none_note = use of unstable library feature '{$feature}'\n \n hir_analysis_missing_type_params =\n     the type {$parameterCount ->\n@@ -95,199 +162,132 @@ hir_analysis_missing_type_params =\n     } to {$parameters}\n     .note = because of the default `Self` reference, type parameters must be specified on object types\n \n-hir_analysis_copy_impl_on_type_with_dtor =\n-    the trait `Copy` cannot be implemented for this type; the type has a destructor\n-    .label = `Copy` not allowed on types with destructors\n-\n hir_analysis_multiple_relaxed_default_bounds =\n     type parameter has more than one relaxed default bound, only one is supported\n \n-hir_analysis_copy_impl_on_non_adt =\n-    the trait `Copy` cannot be implemented for this type\n-    .label = type is not a structure or enumeration\n-\n-hir_analysis_const_impl_for_non_const_trait =\n-    const `impl` for trait `{$trait_name}` which is not marked with `#[const_trait]`\n-    .suggestion = mark `{$trait_name}` as const\n-    .note = marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n-    .adding = adding a non-const method body in the future would be a breaking change\n-\n-hir_analysis_const_bound_for_non_const_trait =\n-    ~const can only be applied to `#[const_trait]` traits\n-\n-hir_analysis_self_in_impl_self =\n-    `Self` is not valid in the self type of an impl block\n-    .note = replace `Self` with a different type\n-\n-hir_analysis_linkage_type =\n-    invalid type for variable with `#[linkage]` attribute\n-\n-hir_analysis_auto_deref_reached_recursion_limit = reached the recursion limit while auto-dereferencing `{$ty}`\n-    .label = deref recursion limit reached\n-    .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]` attribute to your crate (`{$crate_name}`)\n-\n-hir_analysis_where_clause_on_main = `main` function is not allowed to have a `where` clause\n-    .label = `main` cannot have a `where` clause\n-\n-hir_analysis_track_caller_on_main = `main` function is not allowed to be `#[track_caller]`\n-    .suggestion = remove this annotation\n-\n-hir_analysis_target_feature_on_main = `main` function is not allowed to have `#[target_feature]`\n-\n-hir_analysis_start_not_track_caller = `start` is not allowed to be `#[track_caller]`\n-    .label = `start` is not allowed to be `#[track_caller]`\n-\n-hir_analysis_start_not_target_feature = `start` is not allowed to have `#[target_feature]`\n-    .label = `start` is not allowed to have `#[target_feature]`\n-\n-hir_analysis_start_not_async = `start` is not allowed to be `async`\n-    .label = `start` is not allowed to be `async`\n-\n-hir_analysis_start_function_where = start function is not allowed to have a `where` clause\n-    .label = start function cannot have a `where` clause\n-\n-hir_analysis_start_function_parameters = start function is not allowed to have type parameters\n-    .label = start function cannot have type parameters\n-\n-hir_analysis_main_function_return_type_generic = `main` function return type is not allowed to have generic parameters\n+hir_analysis_must_be_name_of_associated_function = must be a name of an associated function\n \n-hir_analysis_main_function_async = `main` function is not allowed to be `async`\n-    .label = `main` function is not allowed to be `async`\n+hir_analysis_must_implement_not_function = not a function\n \n-hir_analysis_main_function_generic_parameters = `main` function is not allowed to have generic parameters\n-    .label = `main` cannot have generic parameters\n+hir_analysis_must_implement_not_function_note = all `#[rustc_must_implement_one_of]` arguments must be associated function names\n \n-hir_analysis_variadic_function_compatible_convention = C-variadic function must have a compatible calling convention, like {$conventions}\n-    .label = C-variadic function must have a compatible calling convention\n+hir_analysis_must_implement_not_function_span_note = required by this annotation\n \n-hir_analysis_cannot_capture_late_bound_ty_in_anon_const =\n-    cannot capture late-bound type parameter in a constant\n-    .label = parameter defined here\n+hir_analysis_must_implement_one_of_attribute = the `#[rustc_must_implement_one_of]` attribute must be used with at least 2 args\n \n-hir_analysis_cannot_capture_late_bound_const_in_anon_const =\n-    cannot capture late-bound const parameter in a constant\n-    .label = parameter defined here\n+hir_analysis_paren_sugar_attribute = the `#[rustc_paren_sugar]` attribute is a temporary means of controlling which traits can use parenthetical notation\n+    .help = add `#![feature(unboxed_closures)]` to the crate attributes to use it\n \n-hir_analysis_variances_of = {$variances_of}\n+hir_analysis_parenthesized_fn_trait_expansion =\n+    parenthesized trait syntax expands to `{$expanded_type}`\n \n hir_analysis_pass_to_variadic_function = can't pass `{$ty}` to variadic function\n     .suggestion = cast the value to `{$cast_ty}`\n     .help = cast the value to `{$cast_ty}`\n \n-hir_analysis_cast_thin_pointer_to_fat_pointer = cannot cast thin pointer `{$expr_ty}` to fat pointer `{$cast_ty}`\n-\n-hir_analysis_invalid_union_field =\n-    field must implement `Copy` or be wrapped in `ManuallyDrop<...>` to be used in a union\n-    .note = union fields must not have drop side-effects, which is currently enforced via either `Copy` or `ManuallyDrop<...>`\n-\n-hir_analysis_invalid_union_field_sugg =\n-    wrap the field type in `ManuallyDrop<...>`\n+hir_analysis_placeholder_not_allowed_item_signatures = the placeholder `_` is not allowed within types on item signatures for {$kind}\n+    .label = not allowed in type signatures\n \n-hir_analysis_return_type_notation_on_non_rpitit =\n-    return type notation used on function that is not `async` and does not return `impl Trait`\n-    .note = function returns `{$ty}`, which is not compatible with associated type return bounds\n-    .label = this function must be `async` or return `impl Trait`\n+hir_analysis_return_type_notation_conflicting_bound =\n+    ambiguous associated function `{$assoc_name}` for `{$ty_name}`\n+    .note = `{$assoc_name}` is declared in two supertraits: `{$first_bound}` and `{$second_bound}`\n \n hir_analysis_return_type_notation_equality_bound =\n     return type notation is not allowed to use type equality\n \n hir_analysis_return_type_notation_missing_method =\n     cannot find associated function `{$assoc_name}` for `{$ty_name}`\n \n-hir_analysis_return_type_notation_conflicting_bound =\n-    ambiguous associated function `{$assoc_name}` for `{$ty_name}`\n-    .note = `{$assoc_name}` is declared in two supertraits: `{$first_bound}` and `{$second_bound}`\n-\n-hir_analysis_placeholder_not_allowed_item_signatures = the placeholder `_` is not allowed within types on item signatures for {$kind}\n-    .label = not allowed in type signatures\n-\n-hir_analysis_associated_type_trait_uninferred_generic_params = cannot use the associated type of a trait with uninferred generic parameters\n-    .suggestion = use a fully qualified path with inferred lifetimes\n-\n-hir_analysis_associated_type_trait_uninferred_generic_params_multipart_suggestion = use a fully qualified path with explicit lifetimes\n-\n-hir_analysis_enum_discriminant_overflowed = enum discriminant overflowed\n-    .label = overflowed on value after {$discr}\n-    .note = explicitly set `{$item_name} = {$wrapped_discr}` if that is desired outcome\n-\n-hir_analysis_paren_sugar_attribute = the `#[rustc_paren_sugar]` attribute is a temporary means of controlling which traits can use parenthetical notation\n-    .help = add `#![feature(unboxed_closures)]` to the crate attributes to use it\n-\n-hir_analysis_must_implement_one_of_attribute = the `#[rustc_must_implement_one_of]` attribute must be used with at least 2 args\n-\n-hir_analysis_must_be_name_of_associated_function = must be a name of an associated function\n+hir_analysis_return_type_notation_on_non_rpitit =\n+    return type notation used on function that is not `async` and does not return `impl Trait`\n+    .note = function returns `{$ty}`, which is not compatible with associated type return bounds\n+    .label = this function must be `async` or return `impl Trait`\n \n-hir_analysis_function_not_have_default_implementation = function doesn't have a default implementation\n-    .note = required by this annotation\n+hir_analysis_self_in_impl_self =\n+    `Self` is not valid in the self type of an impl block\n+    .note = replace `Self` with a different type\n \n-hir_analysis_must_implement_not_function = not a function\n+hir_analysis_simd_ffi_highly_experimental = use of SIMD type{$snip} in FFI is highly experimental and may result in invalid code\n+    .help = add `#![feature(simd_ffi)]` to the crate attributes to enable\n \n-hir_analysis_must_implement_not_function_span_note = required by this annotation\n+hir_analysis_specialization_trait = implementing `rustc_specialization_trait` traits is unstable\n+    .help = add `#![feature(min_specialization)]` to the crate attributes to enable\n \n-hir_analysis_must_implement_not_function_note = all `#[rustc_must_implement_one_of]` arguments must be associated function names\n+hir_analysis_start_function_parameters = start function is not allowed to have type parameters\n+    .label = start function cannot have type parameters\n \n-hir_analysis_function_not_found_in_trait = function not found in this trait\n+hir_analysis_start_function_where = start function is not allowed to have a `where` clause\n+    .label = start function cannot have a `where` clause\n \n-hir_analysis_functions_names_duplicated = functions names are duplicated\n-    .note = all `#[rustc_must_implement_one_of]` arguments must be unique\n+hir_analysis_start_not_async = `start` is not allowed to be `async`\n+    .label = `start` is not allowed to be `async`\n \n-hir_analysis_simd_ffi_highly_experimental = use of SIMD type{$snip} in FFI is highly experimental and may result in invalid code\n-    .help = add `#![feature(simd_ffi)]` to the crate attributes to enable\n+hir_analysis_start_not_target_feature = `start` is not allowed to have `#[target_feature]`\n+    .label = `start` is not allowed to have `#[target_feature]`\n \n-hir_analysis_impl_not_marked_default = `{$ident}` specializes an item from a parent `impl`, but that item is not marked `default`\n-    .label = cannot specialize default item `{$ident}`\n-    .ok_label = parent `impl` is here\n-    .note = to specialize, `{$ident}` in the parent `impl` must be marked `default`\n+hir_analysis_start_not_track_caller = `start` is not allowed to be `#[track_caller]`\n+    .label = `start` is not allowed to be `#[track_caller]`\n \n-hir_analysis_impl_not_marked_default_err = `{$ident}` specializes an item from a parent `impl`, but that item is not marked `default`\n-    .note = parent implementation is in crate `{$cname}`\n+hir_analysis_static_specialize = cannot specialize on `'static` lifetime\n \n-hir_analysis_missing_trait_item = not all trait items implemented, missing: `{$missing_items_msg}`\n-    .label = missing `{$missing_items_msg}` in implementation\n+hir_analysis_substs_on_overridden_impl = could not resolve substs on overridden impl\n \n-hir_analysis_missing_trait_item_suggestion = implement the missing item: `{$snippet}`\n+hir_analysis_target_feature_on_main = `main` function is not allowed to have `#[target_feature]`\n \n-hir_analysis_missing_trait_item_label = `{$item}` from trait\n+hir_analysis_too_large_static = extern static is too large for the current architecture\n \n-hir_analysis_missing_one_of_trait_item = not all trait items implemented, missing one of: `{$missing_items_msg}`\n-    .label = missing one of `{$missing_items_msg}` in implementation\n-    .note = required because of this annotation\n+hir_analysis_track_caller_on_main = `main` function is not allowed to be `#[track_caller]`\n+    .suggestion = remove this annotation\n \n-hir_analysis_missing_trait_item_unstable = not all trait items implemented, missing: `{$missing_item_name}`\n-    .note = default implementation of `{$missing_item_name}` is unstable\n-    .some_note = use of unstable library feature '{$feature}': {$r}\n-    .none_note = use of unstable library feature '{$feature}'\n+hir_analysis_trait_object_declared_with_no_traits =\n+    at least one trait is required for an object type\n+    .alias_span = this alias does not contain a trait\n \n hir_analysis_transparent_enum_variant = transparent enum needs exactly one variant, but has {$number}\n     .label = needs exactly one variant, but has {$number}\n     .many_label = too many variants in `{$path}`\n     .multi_label = variant here\n \n-hir_analysis_transparent_non_zero_sized_enum = the variant of a transparent {$desc} needs at most one non-zero-sized field, but has {$field_count}\n+hir_analysis_transparent_non_zero_sized = transparent {$desc} needs at most one non-zero-sized field, but has {$field_count}\n     .label = needs at most one non-zero-sized field, but has {$field_count}\n     .labels = this field is non-zero-sized\n \n-hir_analysis_transparent_non_zero_sized = transparent {$desc} needs at most one non-zero-sized field, but has {$field_count}\n+hir_analysis_transparent_non_zero_sized_enum = the variant of a transparent {$desc} needs at most one non-zero-sized field, but has {$field_count}\n     .label = needs at most one non-zero-sized field, but has {$field_count}\n     .labels = this field is non-zero-sized\n \n-hir_analysis_too_large_static = extern static is too large for the current architecture\n+hir_analysis_typeof_reserved_keyword_used =\n+    `typeof` is a reserved keyword but unimplemented\n+    .suggestion = consider replacing `typeof(...)` with an actual type\n+    .label = reserved keyword\n \n-hir_analysis_specialization_trait = implementing `rustc_specialization_trait` traits is unstable\n-    .help = add `#![feature(min_specialization)]` to the crate attributes to enable\n+hir_analysis_unconstrained_opaque_type = unconstrained opaque type\n+    .note = `{$name}` must be used in combination with a concrete type within the same {$what}\n \n-hir_analysis_closure_implicit_hrtb = implicit types in closure signatures are forbidden when `for<...>` is present\n-    .label = `for<...>` is here\n+hir_analysis_unrecognized_atomic_operation =\n+    unrecognized atomic operation function: `{$op}`\n+    .label = unrecognized atomic operation\n \n-hir_analysis_empty_specialization = specialization impl does not specialize any associated items\n-    .note = impl is a specialization of this impl\n+hir_analysis_unrecognized_intrinsic_function =\n+    unrecognized intrinsic function: `{$name}`\n+    .label = unrecognized intrinsic\n \n-hir_analysis_const_specialize = cannot specialize on const impl with non-const impl\n+hir_analysis_value_of_associated_struct_already_specified =\n+    the value of the associated type `{$item_name}` (from trait `{$def_path}`) is already specified\n+    .label = re-bound here\n+    .previous_bound_label = `{$item_name}` bound here first\n \n-hir_analysis_static_specialize = cannot specialize on `'static` lifetime\n+hir_analysis_variadic_function_compatible_convention = C-variadic function must have a compatible calling convention, like {$conventions}\n+    .label = C-variadic function must have a compatible calling convention\n \n-hir_analysis_missing_tilde_const = missing `~const` qualifier for specialization\n+hir_analysis_variances_of = {$variances_of}\n \n-hir_analysis_drop_impl_negative = negative `Drop` impls are not supported\n+hir_analysis_where_clause_on_main = `main` function is not allowed to have a `where` clause\n+    .label = `main` cannot have a `where` clause\n \n-hir_analysis_drop_impl_reservation = reservation `Drop` impls are not supported\n+hir_analysis_wrong_number_of_generic_arguments_to_intrinsic =\n+    intrinsic has wrong number of {$descr} parameters: found {$found}, expected {$expected}\n+    .label = expected {$expected} {$descr} {$expected ->\n+        [one] parameter\n+        *[other] parameters\n+    }"}, {"sha": "9761b1d3facabe36016f4c37a962e5b57ca6b81e", "filename": "compiler/rustc_hir_typeck/messages.ftl", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_hir_typeck%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_hir_typeck%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,92 +1,92 @@\n-hir_typeck_field_multiply_specified_in_initializer =\n-    field `{$ident}` specified more than once\n-    .label = used more than once\n-    .previous_use_label = first use of `{$ident}`\n+hir_typeck_add_missing_parentheses_in_range = you must surround the range in parentheses to call its `{$func_name}` function\n \n-hir_typeck_functional_record_update_on_non_struct =\n-    functional record update syntax requires a struct\n+hir_typeck_add_return_type_add = try adding a return type\n \n-hir_typeck_return_stmt_outside_of_fn_body =\n-    return statement outside of function body\n-    .encl_body_label = the return is part of this body...\n-    .encl_fn_label = ...not the enclosing function body\n+hir_typeck_add_return_type_missing_here = a return type might be missing here\n \n-hir_typeck_yield_expr_outside_of_generator =\n-    yield expression outside of generator literal\n+hir_typeck_address_of_temporary_taken = cannot take address of a temporary\n+    .label = temporary value\n \n-hir_typeck_struct_expr_non_exhaustive =\n-    cannot create non-exhaustive {$what} using struct expression\n+hir_typeck_arg_mismatch_indeterminate = argument type mismatch was detected, but rustc had trouble determining where\n+    .note = we would appreciate a bug report: https://github.com/rust-lang/rust/issues/new\n \n-hir_typeck_method_call_on_unknown_type =\n-    the type of this value must be known to call a method on a raw pointer on it\n+hir_typeck_candidate_trait_note = `{$trait_name}` defines an item `{$item_name}`{$action_or_ty ->\n+    [NONE] {\"\"}\n+    [implement] , perhaps you need to implement it\n+    *[other] , perhaps you need to restrict type parameter `{$action_or_ty}` with it\n+}\n \n-hir_typeck_address_of_temporary_taken = cannot take address of a temporary\n-    .label = temporary value\n+hir_typeck_const_select_must_be_const = this argument must be a `const fn`\n+    .help = consult the documentation on `const_eval_select` for more information\n \n-hir_typeck_add_return_type_add = try adding a return type\n+hir_typeck_const_select_must_be_fn = this argument must be a function item\n+    .note = expected a function item, found {$ty}\n+    .help = consult the documentation on `const_eval_select` for more information\n \n-hir_typeck_add_return_type_missing_here = a return type might be missing here\n+hir_typeck_convert_to_str = try converting the passed type into a `&str`\n \n hir_typeck_expected_default_return_type = expected `()` because of default return type\n \n hir_typeck_expected_return_type = expected `{$expected}` because of return type\n \n-hir_typeck_missing_parentheses_in_range = can't call method `{$method_name}` on type `{$ty_str}`\n+hir_typeck_field_multiply_specified_in_initializer =\n+    field `{$ident}` specified more than once\n+    .label = used more than once\n+    .previous_use_label = first use of `{$ident}`\n \n-hir_typeck_add_missing_parentheses_in_range = you must surround the range in parentheses to call its `{$func_name}` function\n+hir_typeck_fru_expr = this expression does not end in a comma...\n+hir_typeck_fru_expr2 = ... so this is interpreted as a `..` range expression, instead of functional record update syntax\n+hir_typeck_fru_note = this expression may have been misinterpreted as a `..` range expression\n+hir_typeck_fru_suggestion =\n+    to set the remaining fields{$expr ->\n+        [NONE]{\"\"}\n+        *[other] {\" \"}from `{$expr}`\n+    }, separate the last named field with a comma\n \n-hir_typeck_lang_start_incorrect_number_params = incorrect number of parameters for the `start` lang item\n-hir_typeck_lang_start_incorrect_number_params_note_expected_count = the `start` lang item should have four parameters, but found {$found_param_count}\n+hir_typeck_functional_record_update_on_non_struct =\n+    functional record update syntax requires a struct\n \n+hir_typeck_help_set_edition_cargo = set `edition = \"{$edition}\"` in `Cargo.toml`\n+hir_typeck_help_set_edition_standalone = pass `--edition {$edition}` to `rustc`\n hir_typeck_lang_start_expected_sig_note = the `start` lang item should have the signature `fn(fn() -> T, isize, *const *const u8, u8) -> isize`\n \n+hir_typeck_lang_start_incorrect_number_params = incorrect number of parameters for the `start` lang item\n+hir_typeck_lang_start_incorrect_number_params_note_expected_count = the `start` lang item should have four parameters, but found {$found_param_count}\n+\n hir_typeck_lang_start_incorrect_param = parameter {$param_num} of the `start` lang item is incorrect\n     .suggestion = change the type from `{$found_ty}` to `{$expected_ty}`\n \n hir_typeck_lang_start_incorrect_ret_ty = the return type of the `start` lang item is incorrect\n     .suggestion = change the type from `{$found_ty}` to `{$expected_ty}`\n \n-hir_typeck_help_set_edition_cargo = set `edition = \"{$edition}\"` in `Cargo.toml`\n-hir_typeck_help_set_edition_standalone = pass `--edition {$edition}` to `rustc`\n-hir_typeck_note_edition_guide = for more on editions, read https://doc.rust-lang.org/edition-guide\n-\n-hir_typeck_convert_to_str = try converting the passed type into a `&str`\n+hir_typeck_method_call_on_unknown_type =\n+    the type of this value must be known to call a method on a raw pointer on it\n \n-hir_typeck_op_trait_generic_params = `{$method_name}` must not have any generic parameters\n+hir_typeck_missing_parentheses_in_range = can't call method `{$method_name}` on type `{$ty_str}`\n \n-hir_typeck_fru_note = this expression may have been misinterpreted as a `..` range expression\n-hir_typeck_fru_expr = this expression does not end in a comma...\n-hir_typeck_fru_expr2 = ... so this is interpreted as a `..` range expression, instead of functional record update syntax\n-hir_typeck_fru_suggestion =\n-    to set the remaining fields{$expr ->\n-        [NONE]{\"\"}\n-        *[other] {\" \"}from `{$expr}`\n-    }, separate the last named field with a comma\n+hir_typeck_no_associated_item = no {$item_kind} named `{$item_name}` found for {$ty_prefix} `{$ty_str}`{$trait_missing_method ->\n+    [true] {\"\"}\n+    *[other] {\" \"}in the current scope\n+}\n \n-hir_typeck_const_select_must_be_const = this argument must be a `const fn`\n-    .help = consult the documentation on `const_eval_select` for more information\n+hir_typeck_note_edition_guide = for more on editions, read https://doc.rust-lang.org/edition-guide\n \n-hir_typeck_const_select_must_be_fn = this argument must be a function item\n-    .note = expected a function item, found {$ty}\n-    .help = consult the documentation on `const_eval_select` for more information\n+hir_typeck_op_trait_generic_params = `{$method_name}` must not have any generic parameters\n \n-hir_typeck_union_pat_multiple_fields = union patterns should have exactly one field\n-hir_typeck_union_pat_dotdot = `..` cannot be used in union patterns\n+hir_typeck_return_stmt_outside_of_fn_body =\n+    return statement outside of function body\n+    .encl_body_label = the return is part of this body...\n+    .encl_fn_label = ...not the enclosing function body\n \n-hir_typeck_arg_mismatch_indeterminate = argument type mismatch was detected, but rustc had trouble determining where\n-    .note = we would appreciate a bug report: https://github.com/rust-lang/rust/issues/new\n+hir_typeck_struct_expr_non_exhaustive =\n+    cannot create non-exhaustive {$what} using struct expression\n \n hir_typeck_suggest_boxing_note = for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n \n hir_typeck_suggest_boxing_when_appropriate = store this in the heap by calling `Box::new`\n \n-hir_typeck_no_associated_item = no {$item_kind} named `{$item_name}` found for {$ty_prefix} `{$ty_str}`{$trait_missing_method ->\n-    [true] {\"\"}\n-    *[other] {\" \"}in the current scope\n-}\n+hir_typeck_union_pat_dotdot = `..` cannot be used in union patterns\n \n-hir_typeck_candidate_trait_note = `{$trait_name}` defines an item `{$item_name}`{$action_or_ty ->\n-    [NONE] {\"\"}\n-    [implement] , perhaps you need to implement it\n-    *[other] , perhaps you need to restrict type parameter `{$action_or_ty}` with it\n-}\n+hir_typeck_union_pat_multiple_fields = union patterns should have exactly one field\n+hir_typeck_yield_expr_outside_of_generator =\n+    yield expression outside of generator literal"}, {"sha": "9fa4e0fb27cf1dd66cb85cb94bd4ebd3c166b689", "filename": "compiler/rustc_incremental/messages.ftl", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_incremental%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_incremental%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,118 +1,118 @@\n-incremental_unrecognized_depnode = unrecognized `DepNode` variant: {$name}\n+incremental_assert_loaded =\n+    we asserted that an existing incremental cache directory should be successfully loaded, but it was not\n \n-incremental_missing_depnode = missing `DepNode` variant\n+incremental_assert_not_loaded =\n+    we asserted that the incremental cache should not be loaded, but it was loaded\n \n-incremental_missing_if_this_changed = no `#[rustc_if_this_changed]` annotation detected\n+incremental_assertion_auto =\n+    `except` specified DepNodes that can not be affected for \"{$name}\": \"{$e}\"\n \n-incremental_no_path = no path from `{$source}` to `{$target}`\n+incremental_associated_value_expected = expected an associated value\n \n-incremental_ok = OK\n+incremental_associated_value_expected_for = associated value expected for `{$ident}`\n \n-incremental_unknown_reuse_kind = unknown cgu-reuse-kind `{$kind}` specified\n+incremental_canonicalize_path = incremental compilation: error canonicalizing path `{$path}`: {$err}\n \n-incremental_missing_query_depgraph =\n-    found CGU-reuse attribute but `-Zquery-dep-graph` was not specified\n+incremental_cargo_help_1 =\n+    incremental compilation can be disabled by setting the environment variable CARGO_INCREMENTAL=0 (see https://doc.rust-lang.org/cargo/reference/profiles.html#incremental)\n+incremental_cargo_help_2 =\n+    the entire build directory can be changed to a different filesystem by setting the environment variable CARGO_TARGET_DIR to a different path (see https://doc.rust-lang.org/cargo/reference/config.html#buildtarget-dir)\n \n-incremental_malformed_cgu_name =\n-    found malformed codegen unit name `{$user_path}`. codegen units names must always start with the name of the crate (`{$crate_name}` in this case).\n+incremental_copy_workproduct_to_cache =\n+    error copying object file `{$from}` to incremental directory as `{$to}`: {$err}\n \n-incremental_no_module_named =\n-    no module named `{$user_path}` (mangled: {$cgu_name}). available modules: {$cgu_names}\n+incremental_create_dep_graph = failed to create dependency graph at `{$path}`: {$err}\n \n-incremental_field_associated_value_expected = associated value expected for `{$name}`\n+incremental_create_incr_comp_dir =\n+    could not create incremental compilation {$tag} directory `{$path}`: {$err}\n \n-incremental_no_field = no field `{$name}`\n+incremental_create_lock =\n+    incremental compilation: could not create session directory lock file: {$lock_err}\n+incremental_create_new = failed to create {$name} at `{$path}`: {$err}\n \n-incremental_assertion_auto =\n-    `except` specified DepNodes that can not be affected for \"{$name}\": \"{$e}\"\n+incremental_decode_incr_cache = could not decode incremental cache: {$err}\n \n-incremental_undefined_clean_dirty_assertions_item =\n-    clean/dirty auto-assertions not yet defined for Node::Item.node={$kind}\n+incremental_delete_full = error deleting incremental compilation session directory `{$path}`: {$err}\n \n-incremental_undefined_clean_dirty_assertions =\n-    clean/dirty auto-assertions not yet defined for {$kind}\n+incremental_delete_incompatible =\n+    failed to delete invalidated or incompatible incremental compilation session directory contents `{$path}`: {$err}\n \n-incremental_repeated_depnode_label = dep-node label `{$label}` is repeated\n+incremental_delete_lock =\n+    error deleting lock file for incremental compilation session directory `{$path}`: {$err}\n \n-incremental_unrecognized_depnode_label = dep-node label `{$label}` not recognized\n+incremental_delete_old = unable to delete old {$name} at `{$path}`: {$err}\n \n-incremental_not_dirty = `{$dep_node_str}` should be dirty but is not\n+incremental_delete_partial = failed to delete partly initialized session dir `{$path}`: {$err}\n \n-incremental_not_clean = `{$dep_node_str}` should be clean but is not\n+incremental_delete_workproduct = file-system error deleting outdated file `{$path}`: {$err}\n \n-incremental_not_loaded = `{$dep_node_str}` should have been loaded from disk but it was not\n+incremental_field_associated_value_expected = associated value expected for `{$name}`\n \n-incremental_unknown_item = unknown item `{$name}`\n+incremental_finalize = error finalizing incremental compilation session directory `{$path}`: {$err}\n \n-incremental_no_cfg = no cfg attribute\n+incremental_finalized_gc_failed =\n+    failed to garbage collect finalized incremental compilation session directory `{$path}`: {$err}\n \n-incremental_associated_value_expected_for = associated value expected for `{$ident}`\n+incremental_hard_link_failed =\n+    hard linking files in the incremental compilation cache failed. copying files instead. consider moving the cache directory to a file system which supports hard linking in session dir `{$path}`\n \n-incremental_associated_value_expected = expected an associated value\n+incremental_invalid_gc_failed =\n+    failed to garbage collect invalid incremental compilation session directory `{$path}`: {$err}\n \n-incremental_unchecked_clean = found unchecked `#[rustc_clean]` attribute\n+incremental_load_dep_graph = could not load dep-graph from `{$path}`: {$err}\n \n-incremental_delete_old = unable to delete old {$name} at `{$path}`: {$err}\n+incremental_lock_unsupported =\n+    the filesystem for the incremental path at {$session_dir} does not appear to support locking, consider changing the incremental path to a filesystem that supports locking or disable incremental compilation\n+incremental_malformed_cgu_name =\n+    found malformed codegen unit name `{$user_path}`. codegen units names must always start with the name of the crate (`{$crate_name}` in this case).\n \n-incremental_create_new = failed to create {$name} at `{$path}`: {$err}\n+incremental_missing_depnode = missing `DepNode` variant\n \n-incremental_write_new = failed to write {$name} to `{$path}`: {$err}\n+incremental_missing_if_this_changed = no `#[rustc_if_this_changed]` annotation detected\n \n-incremental_canonicalize_path = incremental compilation: error canonicalizing path `{$path}`: {$err}\n+incremental_missing_query_depgraph =\n+    found CGU-reuse attribute but `-Zquery-dep-graph` was not specified\n \n-incremental_create_incr_comp_dir =\n-    could not create incremental compilation {$tag} directory `{$path}`: {$err}\n+incremental_move_dep_graph = failed to move dependency graph from `{$from}` to `{$to}`: {$err}\n \n-incremental_create_lock =\n-    incremental compilation: could not create session directory lock file: {$lock_err}\n-incremental_lock_unsupported =\n-    the filesystem for the incremental path at {$session_dir} does not appear to support locking, consider changing the incremental path to a filesystem that supports locking or disable incremental compilation\n-incremental_cargo_help_1 =\n-    incremental compilation can be disabled by setting the environment variable CARGO_INCREMENTAL=0 (see https://doc.rust-lang.org/cargo/reference/profiles.html#incremental)\n-incremental_cargo_help_2 =\n-    the entire build directory can be changed to a different filesystem by setting the environment variable CARGO_TARGET_DIR to a different path (see https://doc.rust-lang.org/cargo/reference/config.html#buildtarget-dir)\n+incremental_no_cfg = no cfg attribute\n \n-incremental_delete_lock =\n-    error deleting lock file for incremental compilation session directory `{$path}`: {$err}\n+incremental_no_field = no field `{$name}`\n \n-incremental_hard_link_failed =\n-    hard linking files in the incremental compilation cache failed. copying files instead. consider moving the cache directory to a file system which supports hard linking in session dir `{$path}`\n+incremental_no_module_named =\n+    no module named `{$user_path}` (mangled: {$cgu_name}). available modules: {$cgu_names}\n \n-incremental_delete_partial = failed to delete partly initialized session dir `{$path}`: {$err}\n+incremental_no_path = no path from `{$source}` to `{$target}`\n \n-incremental_delete_full = error deleting incremental compilation session directory `{$path}`: {$err}\n+incremental_not_clean = `{$dep_node_str}` should be clean but is not\n \n-incremental_finalize = error finalizing incremental compilation session directory `{$path}`: {$err}\n+incremental_not_dirty = `{$dep_node_str}` should be dirty but is not\n \n-incremental_invalid_gc_failed =\n-    failed to garbage collect invalid incremental compilation session directory `{$path}`: {$err}\n+incremental_not_loaded = `{$dep_node_str}` should have been loaded from disk but it was not\n \n-incremental_finalized_gc_failed =\n-    failed to garbage collect finalized incremental compilation session directory `{$path}`: {$err}\n+incremental_ok = OK\n+\n+incremental_repeated_depnode_label = dep-node label `{$label}` is repeated\n \n incremental_session_gc_failed =\n     failed to garbage collect incremental compilation session directory `{$path}`: {$err}\n \n-incremental_assert_not_loaded =\n-    we asserted that the incremental cache should not be loaded, but it was loaded\n-\n-incremental_assert_loaded =\n-    we asserted that an existing incremental cache directory should be successfully loaded, but it was not\n+incremental_unchecked_clean = found unchecked `#[rustc_clean]` attribute\n \n-incremental_delete_incompatible =\n-    failed to delete invalidated or incompatible incremental compilation session directory contents `{$path}`: {$err}\n+incremental_undefined_clean_dirty_assertions =\n+    clean/dirty auto-assertions not yet defined for {$kind}\n \n-incremental_load_dep_graph = could not load dep-graph from `{$path}`: {$err}\n+incremental_undefined_clean_dirty_assertions_item =\n+    clean/dirty auto-assertions not yet defined for Node::Item.node={$kind}\n \n-incremental_decode_incr_cache = could not decode incremental cache: {$err}\n+incremental_unknown_item = unknown item `{$name}`\n \n-incremental_write_dep_graph = failed to write dependency graph to `{$path}`: {$err}\n+incremental_unknown_reuse_kind = unknown cgu-reuse-kind `{$kind}` specified\n \n-incremental_move_dep_graph = failed to move dependency graph from `{$from}` to `{$to}`: {$err}\n+incremental_unrecognized_depnode = unrecognized `DepNode` variant: {$name}\n \n-incremental_create_dep_graph = failed to create dependency graph at `{$path}`: {$err}\n+incremental_unrecognized_depnode_label = dep-node label `{$label}` not recognized\n \n-incremental_copy_workproduct_to_cache =\n-    error copying object file `{$from}` to incremental directory as `{$to}`: {$err}\n+incremental_write_dep_graph = failed to write dependency graph to `{$path}`: {$err}\n \n-incremental_delete_workproduct = file-system error deleting outdated file `{$path}`: {$err}\n+incremental_write_new = failed to write {$name} to `{$path}`: {$err}"}, {"sha": "f44c4a7c1e33cd317c257e3dbed18b4a9405acfa", "filename": "compiler/rustc_infer/messages.ftl", "status": "modified", "additions": 296, "deletions": 295, "changes": 591, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_infer%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_infer%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,285 +1,72 @@\n-infer_opaque_hidden_type =\n-    opaque type's hidden type cannot be another opaque type from the same scope\n-    .label = one of the two opaque types used here has to be outside its defining scope\n-    .opaque_type = opaque type whose hidden type is being assigned\n-    .hidden_type = opaque type being used as hidden type\n-\n-infer_type_annotations_needed = {$source_kind ->\n-    [closure] type annotations needed for the closure `{$source_name}`\n-    [normal] type annotations needed for `{$source_name}`\n-    *[other] type annotations needed\n-}\n-    .label = type must be known at this point\n-\n-infer_label_bad = {$bad_kind ->\n-    *[other] cannot infer type\n-    [more_info] cannot infer {$prefix_kind ->\n-        *[type] type for {$prefix}\n-        [const_with_param] the value of const parameter\n-        [const] the value of the constant\n-    } `{$name}`{$has_parent ->\n-        [true] {\" \"}declared on the {$parent_prefix} `{$parent_name}`\n-        *[false] {\"\"}\n-    }\n-}\n-\n-infer_source_kind_subdiag_let = {$kind ->\n-    [with_pattern] consider giving `{$name}` an explicit type\n-    [closure] consider giving this closure parameter an explicit type\n-    *[other] consider giving this pattern a type\n-}{$x_kind ->\n-    [has_name] , where the {$prefix_kind ->\n-        *[type] type for {$prefix}\n-        [const_with_param] value of const parameter\n-        [const] value of the constant\n-    } `{$arg_name}` is specified\n-    [underscore] , where the placeholders `_` are specified\n-    *[empty] {\"\"}\n-}\n-\n-infer_source_kind_subdiag_generic_label =\n-    cannot infer {$is_type ->\n-    [true] type\n-    *[false] the value\n-    } of the {$is_type ->\n-    [true] type\n-    *[false] const\n-    } {$parent_exists ->\n-    [true] parameter `{$param_name}` declared on the {$parent_prefix} `{$parent_name}`\n-    *[false] parameter {$param_name}\n-    }\n-\n-infer_source_kind_subdiag_generic_suggestion =\n-    consider specifying the generic {$arg_count ->\n-    [one] argument\n-    *[other] arguments\n-    }\n-\n-infer_source_kind_fully_qualified =\n-    try using a fully qualified path to specify the expected types\n-\n-infer_source_kind_closure_return =\n-    try giving this closure an explicit return type\n-\n-# generator_kind  may need to be translated\n-infer_need_type_info_in_generator =\n-    type inside {$generator_kind ->\n-    [async_block] `async` block\n-    [async_closure] `async` closure\n-    [async_fn] `async fn` body\n-    *[generator] generator\n-    } must be known in this context\n-\n-\n-infer_subtype = ...so that the {$requirement ->\n-    [method_compat] method type is compatible with trait\n-    [type_compat] associated type is compatible with trait\n-    [const_compat] const is compatible with trait\n-    [expr_assignable] expression is assignable\n-    [if_else_different] `if` and `else` have incompatible types\n-    [no_else] `if` missing an `else` returns `()`\n-    [fn_main_correct_type] `main` function has the correct type\n-    [fn_start_correct_type] `#[start]` function has the correct type\n-    [intrinsic_correct_type] intrinsic has the correct type\n-    [method_correct_type] method receiver has the correct type\n-    *[other] types are compatible\n-}\n-infer_subtype_2 = ...so that {$requirement ->\n-    [method_compat] method type is compatible with trait\n-    [type_compat] associated type is compatible with trait\n-    [const_compat] const is compatible with trait\n-    [expr_assignable] expression is assignable\n-    [if_else_different] `if` and `else` have incompatible types\n-    [no_else] `if` missing an `else` returns `()`\n-    [fn_main_correct_type] `main` function has the correct type\n-    [fn_start_correct_type] `#[start]` function has the correct type\n-    [intrinsic_correct_type] intrinsic has the correct type\n-    [method_correct_type] method receiver has the correct type\n-    *[other] types are compatible\n-}\n-\n-infer_reborrow = ...so that reference does not outlive borrowed content\n-infer_reborrow_upvar = ...so that closure can access `{$name}`\n-infer_relate_object_bound = ...so that it can be closed over into an object\n-infer_reference_outlives_referent = ...so that the reference type `{$name}` does not outlive the data it points at\n-infer_relate_param_bound = ...so that the type `{$name}` will meet its required lifetime bounds{$continues ->\n-    [true] ...\n+infer_actual_impl_expl_but_actually_implemented_for_ty = ...but `{$trait_path}` is actually implemented for the type `{$ty}`{$has_lifetime ->\n+    [true] , for some specific lifetime `'{$lifetime}`\n     *[false] {\"\"}\n }\n-infer_relate_param_bound_2 = ...that is required by this bound\n-infer_relate_region_param_bound = ...so that the declared lifetime parameter bounds are satisfied\n-infer_compare_impl_item_obligation = ...so that the definition in impl matches the definition from the trait\n-infer_ascribe_user_type_prove_predicate = ...so that the where clause holds\n-\n-infer_nothing = {\"\"}\n-\n-infer_lifetime_mismatch = lifetime mismatch\n-\n-infer_declared_different = this parameter and the return type are declared with different lifetimes...\n-infer_data_returned = ...but data{$label_var1_exists ->\n-    [true] {\" \"}from `{$label_var1}`\n-    *[false] {\"\"}\n-} is returned here\n-\n-infer_data_lifetime_flow = ...but data with one lifetime flows into the other here\n-infer_declared_multiple = this type is declared with multiple lifetimes...\n-infer_types_declared_different = these two types are declared with different lifetimes...\n-infer_data_flows = ...but data{$label_var1_exists ->\n-    [true] {\" \"}from `{$label_var1}`\n-    *[false] -> {\"\"}\n-} flows{$label_var2_exists ->\n-    [true] {\" \"}into `{$label_var2}`\n-    *[false] -> {\"\"}\n-} here\n-\n-infer_lifetime_param_suggestion = consider introducing a named lifetime parameter{$is_impl ->\n-    [true] {\" \"}and update trait if needed\n+infer_actual_impl_expl_but_actually_implements_trait = ...but it actually implements `{$trait_path}`{$has_lifetime ->\n+    [true] , for some specific lifetime `'{$lifetime}`\n     *[false] {\"\"}\n }\n-infer_lifetime_param_suggestion_elided = each elided lifetime in input position becomes a distinct lifetime\n-\n-infer_region_explanation = {$pref_kind ->\n-    *[should_not_happen] [{$pref_kind}]\n-    [ref_valid_for] ...the reference is valid for\n-    [content_valid_for] ...but the borrowed content is only valid for\n-    [type_obj_valid_for] object type is valid for\n-    [source_pointer_valid_for] source pointer is only valid for\n-    [type_satisfy] type must satisfy\n-    [type_outlive] type must outlive\n-    [lf_param_instantiated_with] lifetime parameter instantiated with\n-    [lf_param_must_outlive] but lifetime parameter must outlive\n-    [lf_instantiated_with] lifetime instantiated with\n-    [lf_must_outlive] but lifetime must outlive\n-    [pointer_valid_for] the pointer is valid for\n-    [data_valid_for] but the referenced data is only valid for\n-    [empty] {\"\"}\n-}{$pref_kind ->\n-    [empty] {\"\"}\n-    *[other] {\" \"}\n-}{$desc_kind ->\n-    *[should_not_happen] [{$desc_kind}]\n-    [restatic] the static lifetime\n-    [revar] lifetime {$desc_arg}\n-    [as_defined] the lifetime `{$desc_arg}` as defined here\n-    [as_defined_anon] the anonymous lifetime as defined here\n-    [defined_here] the anonymous lifetime defined here\n-    [defined_here_reg] the lifetime `{$desc_arg}` as defined here\n-}{$suff_kind ->\n-    *[should_not_happen] [{$suff_kind}]\n-    [empty]{\"\"}\n-    [continues] ...\n-    [req_by_binding] {\" \"}as required by this binding\n+infer_actual_impl_expl_but_actually_ty_implements = ...but `{$ty}` actually implements `{$trait_path}`{$has_lifetime ->\n+    [true] , for some specific lifetime `'{$lifetime}`\n+    *[false] {\"\"}\n }\n \n-infer_outlives_content = lifetime of reference outlives lifetime of borrowed content...\n-infer_outlives_bound = lifetime of the source pointer does not outlive lifetime bound of the object type\n-infer_fulfill_req_lifetime = the type `{$ty}` does not fulfill the required lifetime\n-infer_lf_bound_not_satisfied = lifetime bound not satisfied\n-infer_borrowed_too_long = a value of type `{$ty}` is borrowed for too long\n-infer_ref_longer_than_data = in type `{$ty}`, reference has a longer lifetime than the data it references\n-\n-infer_mismatched_static_lifetime = incompatible lifetime on type\n-infer_does_not_outlive_static_from_impl = ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n-infer_implicit_static_lifetime_note = this has an implicit `'static` lifetime requirement\n-infer_implicit_static_lifetime_suggestion = consider relaxing the implicit `'static` requirement\n-infer_msl_introduces_static = introduces a `'static` lifetime requirement\n-infer_msl_unmet_req = because this has an unmet lifetime requirement\n-infer_msl_trait_note = this has an implicit `'static` lifetime requirement\n-infer_msl_trait_sugg = consider relaxing the implicit `'static` requirement\n-infer_suggest_add_let_for_letchains = consider adding `let`\n-\n-infer_explicit_lifetime_required_with_ident = explicit lifetime required in the type of `{$simple_ident}`\n-    .label = lifetime `{$named}` required\n-\n-infer_explicit_lifetime_required_with_param_type = explicit lifetime required in parameter type\n-    .label = lifetime `{$named}` required\n-\n-infer_explicit_lifetime_required_sugg_with_ident = add explicit lifetime `{$named}` to the type of `{$simple_ident}`\n-\n-infer_explicit_lifetime_required_sugg_with_param_type = add explicit lifetime `{$named}` to type\n-\n-infer_actual_impl_expl_expected_signature_two = {$leading_ellipsis ->\n-    [true] ...\n-    *[false] {\"\"}\n-}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n-infer_actual_impl_expl_expected_signature_any = {$leading_ellipsis ->\n+infer_actual_impl_expl_expected_other_any = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n-}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for any lifetime `'{$lifetime_1}`...\n-infer_actual_impl_expl_expected_signature_some = {$leading_ellipsis ->\n+}`{$ty_or_sig}` must implement `{$trait_path}`, for any lifetime `'{$lifetime_1}`...\n+infer_actual_impl_expl_expected_other_nothing = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n-}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for some specific lifetime `'{$lifetime_1}`...\n-infer_actual_impl_expl_expected_signature_nothing = {$leading_ellipsis ->\n+}`{$ty_or_sig}` must implement `{$trait_path}`\n+\n+infer_actual_impl_expl_expected_other_some = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n-}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`\n-infer_actual_impl_expl_expected_passive_two = {$leading_ellipsis ->\n+}`{$ty_or_sig}` must implement `{$trait_path}`, for some specific lifetime `'{$lifetime_1}`...\n+infer_actual_impl_expl_expected_other_two = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n-}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`, for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n+}`{$ty_or_sig}` must implement `{$trait_path}`, for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n infer_actual_impl_expl_expected_passive_any = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n }`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`, for any lifetime `'{$lifetime_1}`...\n+infer_actual_impl_expl_expected_passive_nothing = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`\n infer_actual_impl_expl_expected_passive_some = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n }`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`, for some specific lifetime `'{$lifetime_1}`...\n-infer_actual_impl_expl_expected_passive_nothing = {$leading_ellipsis ->\n+infer_actual_impl_expl_expected_passive_two = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n-}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`\n-infer_actual_impl_expl_expected_other_two = {$leading_ellipsis ->\n+}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`, for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n+infer_actual_impl_expl_expected_signature_any = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n-}`{$ty_or_sig}` must implement `{$trait_path}`, for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n-infer_actual_impl_expl_expected_other_any = {$leading_ellipsis ->\n+}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for any lifetime `'{$lifetime_1}`...\n+infer_actual_impl_expl_expected_signature_nothing = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n-}`{$ty_or_sig}` must implement `{$trait_path}`, for any lifetime `'{$lifetime_1}`...\n-infer_actual_impl_expl_expected_other_some = {$leading_ellipsis ->\n+}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`\n+infer_actual_impl_expl_expected_signature_some = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n-}`{$ty_or_sig}` must implement `{$trait_path}`, for some specific lifetime `'{$lifetime_1}`...\n-infer_actual_impl_expl_expected_other_nothing = {$leading_ellipsis ->\n+}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for some specific lifetime `'{$lifetime_1}`...\n+infer_actual_impl_expl_expected_signature_two = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n-}`{$ty_or_sig}` must implement `{$trait_path}`\n+}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n+infer_ascribe_user_type_prove_predicate = ...so that the where clause holds\n \n-infer_actual_impl_expl_but_actually_implements_trait = ...but it actually implements `{$trait_path}`{$has_lifetime ->\n-    [true] , for some specific lifetime `'{$lifetime}`\n-    *[false] {\"\"}\n-}\n-infer_actual_impl_expl_but_actually_implemented_for_ty = ...but `{$trait_path}` is actually implemented for the type `{$ty}`{$has_lifetime ->\n-    [true] , for some specific lifetime `'{$lifetime}`\n-    *[false] {\"\"}\n-}\n-infer_actual_impl_expl_but_actually_ty_implements = ...but `{$ty}` actually implements `{$trait_path}`{$has_lifetime ->\n-    [true] , for some specific lifetime `'{$lifetime}`\n-    *[false] {\"\"}\n-}\n-\n-infer_trait_placeholder_mismatch = implementation of `{$trait_def_id}` is not general enough\n-    .label_satisfy = doesn't satisfy where-clause\n-    .label_where = due to a where-clause on `{$def_id}`...\n-    .label_dup = implementation of `{$trait_def_id}` is not general enough\n-\n-infer_trait_impl_diff = `impl` item signature doesn't match `trait` item signature\n-    .found = found `{$found}`\n-    .expected = expected `{$expected}`\n-    .expected_found = expected signature `{$expected}`\n-               {\"   \"}found signature `{$found}`\n-\n-infer_tid_rel_help = verify the lifetime relationships in the `trait` and `impl` between the `self` argument, the other inputs and its output\n-infer_tid_consider_borrowing = consider borrowing this type parameter in the trait\n-infer_tid_param_help = the lifetime requirements from the `impl` do not correspond to the requirements in the `trait`\n-\n-infer_dtcs_has_lifetime_req_label = this has an implicit `'static` lifetime requirement\n-infer_dtcs_introduces_requirement = calling this method introduces the `impl`'s `'static` requirement\n-infer_dtcs_has_req_note = the used `impl` has a `'static` requirement\n-infer_dtcs_suggestion = consider relaxing the implicit `'static` requirement\n+infer_await_both_futures = consider `await`ing on both `Future`s\n+infer_await_future = consider `await`ing on the `Future`\n+infer_await_note = calling an async function returns a future\n \n+infer_borrowed_too_long = a value of type `{$ty}` is borrowed for too long\n infer_but_calling_introduces = {$has_param_name ->\n     [true] `{$param_name}`\n     *[false] `fn` parameter\n@@ -314,6 +101,77 @@ infer_but_needs_to_satisfy = {$has_param_name ->\n     .used_here = ...is used here...\n     .introduced_by_bound = `'static` lifetime requirement introduced by this bound\n \n+infer_compare_impl_item_obligation = ...so that the definition in impl matches the definition from the trait\n+infer_consider_specifying_length = consider specifying the actual array length\n+infer_data_flows = ...but data{$label_var1_exists ->\n+    [true] {\" \"}from `{$label_var1}`\n+    *[false] -> {\"\"}\n+} flows{$label_var2_exists ->\n+    [true] {\" \"}into `{$label_var2}`\n+    *[false] -> {\"\"}\n+} here\n+\n+infer_data_lifetime_flow = ...but data with one lifetime flows into the other here\n+infer_data_returned = ...but data{$label_var1_exists ->\n+    [true] {\" \"}from `{$label_var1}`\n+    *[false] {\"\"}\n+} is returned here\n+\n+infer_declared_different = this parameter and the return type are declared with different lifetimes...\n+infer_declared_multiple = this type is declared with multiple lifetimes...\n+infer_does_not_outlive_static_from_impl = ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n+infer_dtcs_has_lifetime_req_label = this has an implicit `'static` lifetime requirement\n+infer_dtcs_has_req_note = the used `impl` has a `'static` requirement\n+infer_dtcs_introduces_requirement = calling this method introduces the `impl`'s `'static` requirement\n+infer_dtcs_suggestion = consider relaxing the implicit `'static` requirement\n+\n+infer_explicit_lifetime_required_sugg_with_ident = add explicit lifetime `{$named}` to the type of `{$simple_ident}`\n+\n+infer_explicit_lifetime_required_sugg_with_param_type = add explicit lifetime `{$named}` to type\n+\n+infer_explicit_lifetime_required_with_ident = explicit lifetime required in the type of `{$simple_ident}`\n+    .label = lifetime `{$named}` required\n+\n+infer_explicit_lifetime_required_with_param_type = explicit lifetime required in parameter type\n+    .label = lifetime `{$named}` required\n+\n+infer_fn_consider_casting = consider casting the fn item to a fn pointer: `{$casting}`\n+\n+infer_fn_uniq_types = different fn items have unique types, even if their signatures are the same\n+infer_fps_cast = consider casting to a fn pointer\n+infer_fps_cast_both = consider casting both fn items to fn pointers using `as {$expected_sig}`\n+\n+infer_fps_items_are_distinct = fn items are distinct from fn pointers\n+infer_fps_remove_ref = consider removing the reference\n+infer_fps_use_ref = consider using a reference\n+infer_fulfill_req_lifetime = the type `{$ty}` does not fulfill the required lifetime\n+infer_implicit_static_lifetime_note = this has an implicit `'static` lifetime requirement\n+infer_implicit_static_lifetime_suggestion = consider relaxing the implicit `'static` requirement\n+infer_label_bad = {$bad_kind ->\n+    *[other] cannot infer type\n+    [more_info] cannot infer {$prefix_kind ->\n+        *[type] type for {$prefix}\n+        [const_with_param] the value of const parameter\n+        [const] the value of the constant\n+    } `{$name}`{$has_parent ->\n+        [true] {\" \"}declared on the {$parent_prefix} `{$parent_name}`\n+        *[false] {\"\"}\n+    }\n+}\n+\n+infer_lf_bound_not_satisfied = lifetime bound not satisfied\n+infer_lifetime_mismatch = lifetime mismatch\n+\n+infer_lifetime_param_suggestion = consider introducing a named lifetime parameter{$is_impl ->\n+    [true] {\" \"}and update trait if needed\n+    *[false] {\"\"}\n+}\n+infer_lifetime_param_suggestion_elided = each elided lifetime in input position becomes a distinct lifetime\n+\n+infer_meant_byte_literal = if you meant to write a byte literal, prefix with `b`\n+infer_meant_char_literal = if you meant to write a `char` literal, use single quotes\n+infer_meant_str_literal = if you meant to write a `str` literal, use double quotes\n+infer_mismatched_static_lifetime = incompatible lifetime on type\n infer_more_targeted = {$has_param_name ->\n     [true] `{$param_name}`\n     *[false] `fn` parameter\n@@ -322,72 +180,215 @@ infer_more_targeted = {$has_param_name ->\n     *[false] an anonymous lifetime `'_`\n } but calling `{$ident}` introduces an implicit `'static` lifetime requirement\n \n-infer_ril_introduced_here = `'static` requirement introduced here\n-infer_ril_introduced_by = requirement introduced by this return type\n-infer_ril_because_of = because of this returned expression\n-infer_ril_static_introduced_by = \"`'static` lifetime requirement introduced by the return type\n+infer_msl_introduces_static = introduces a `'static` lifetime requirement\n+infer_msl_trait_note = this has an implicit `'static` lifetime requirement\n+infer_msl_trait_sugg = consider relaxing the implicit `'static` requirement\n+infer_msl_unmet_req = because this has an unmet lifetime requirement\n+infer_need_type_info_in_generator =\n+    type inside {$generator_kind ->\n+    [async_block] `async` block\n+    [async_closure] `async` closure\n+    [async_fn] `async fn` body\n+    *[generator] generator\n+    } must be known in this context\n \n-infer_where_remove = remove the `where` clause\n-infer_where_copy_predicates = copy the `where` clause predicates from the trait\n \n-infer_srs_remove_and_box = consider removing this semicolon and boxing the expressions\n-infer_srs_remove = consider removing this semicolon\n-infer_srs_add = consider returning the local binding `{$ident}`\n-infer_srs_add_one = consider returning one of these bindings\n+infer_nothing = {\"\"}\n \n-infer_await_both_futures = consider `await`ing on both `Future`s\n-infer_await_future = consider `await`ing on the `Future`\n-infer_await_note = calling an async function returns a future\n+infer_oc_cant_coerce = cannot coerce intrinsics to function pointers\n+infer_oc_closure_selfref = closure/generator type that references itself\n+infer_oc_const_compat = const not compatible with trait\n+infer_oc_fn_main_correct_type = `main` function has wrong type\n+infer_oc_fn_start_correct_type = `#[start]` function has wrong type\n+infer_oc_generic = mismatched types\n+\n+infer_oc_if_else_different = `if` and `else` have incompatible types\n+infer_oc_intrinsic_correct_type = intrinsic has wrong type\n+infer_oc_match_compat = `match` arms have incompatible types\n+infer_oc_method_compat = method not compatible with trait\n+infer_oc_method_correct_type = mismatched `self` parameter type\n+infer_oc_no_diverge = `else` clause of `let...else` does not diverge\n+infer_oc_no_else = `if` may be missing an `else` clause\n+infer_oc_try_compat = `?` operator has incompatible types\n+infer_oc_type_compat = type not compatible with trait\n+infer_opaque_captures_lifetime = hidden type for `{$opaque_ty}` captures lifetime that does not appear in bounds\n+    .label = opaque type defined here\n+\n+infer_opaque_hidden_type =\n+    opaque type's hidden type cannot be another opaque type from the same scope\n+    .label = one of the two opaque types used here has to be outside its defining scope\n+    .opaque_type = opaque type whose hidden type is being assigned\n+    .hidden_type = opaque type being used as hidden type\n \n+infer_outlives_bound = lifetime of the source pointer does not outlive lifetime bound of the object type\n+infer_outlives_content = lifetime of reference outlives lifetime of borrowed content...\n infer_prlf_defined_with_sub = the lifetime `{$sub_symbol}` defined here...\n infer_prlf_defined_without_sub = the lifetime defined here...\n-infer_prlf_must_outlive_with_sup = ...must outlive the lifetime `{$sup_symbol}` defined here\n-infer_prlf_must_outlive_without_sup = ...must outlive the lifetime defined here\n infer_prlf_known_limitation = this is a known limitation that will be removed in the future (see issue #100013 <https://github.com/rust-lang/rust/issues/100013> for more information)\n \n-infer_opaque_captures_lifetime = hidden type for `{$opaque_ty}` captures lifetime that does not appear in bounds\n-    .label = opaque type defined here\n+infer_prlf_must_outlive_with_sup = ...must outlive the lifetime `{$sup_symbol}` defined here\n+infer_prlf_must_outlive_without_sup = ...must outlive the lifetime defined here\n+infer_reborrow = ...so that reference does not outlive borrowed content\n+infer_reborrow_upvar = ...so that closure can access `{$name}`\n+infer_ref_longer_than_data = in type `{$ty}`, reference has a longer lifetime than the data it references\n \n-infer_fps_use_ref = consider using a reference\n-infer_fps_remove_ref = consider removing the reference\n-infer_fps_cast = consider casting to a fn pointer\n-infer_fps_items_are_distinct = fn items are distinct from fn pointers\n-infer_fps_cast_both = consider casting both fn items to fn pointers using `as {$expected_sig}`\n+infer_reference_outlives_referent = ...so that the reference type `{$name}` does not outlive the data it points at\n+infer_region_explanation = {$pref_kind ->\n+    *[should_not_happen] [{$pref_kind}]\n+    [ref_valid_for] ...the reference is valid for\n+    [content_valid_for] ...but the borrowed content is only valid for\n+    [type_obj_valid_for] object type is valid for\n+    [source_pointer_valid_for] source pointer is only valid for\n+    [type_satisfy] type must satisfy\n+    [type_outlive] type must outlive\n+    [lf_param_instantiated_with] lifetime parameter instantiated with\n+    [lf_param_must_outlive] but lifetime parameter must outlive\n+    [lf_instantiated_with] lifetime instantiated with\n+    [lf_must_outlive] but lifetime must outlive\n+    [pointer_valid_for] the pointer is valid for\n+    [data_valid_for] but the referenced data is only valid for\n+    [empty] {\"\"}\n+}{$pref_kind ->\n+    [empty] {\"\"}\n+    *[other] {\" \"}\n+}{$desc_kind ->\n+    *[should_not_happen] [{$desc_kind}]\n+    [restatic] the static lifetime\n+    [revar] lifetime {$desc_arg}\n+    [as_defined] the lifetime `{$desc_arg}` as defined here\n+    [as_defined_anon] the anonymous lifetime as defined here\n+    [defined_here] the anonymous lifetime defined here\n+    [defined_here_reg] the lifetime `{$desc_arg}` as defined here\n+}{$suff_kind ->\n+    *[should_not_happen] [{$suff_kind}]\n+    [empty]{\"\"}\n+    [continues] ...\n+    [req_by_binding] {\" \"}as required by this binding\n+}\n \n-infer_fn_uniq_types = different fn items have unique types, even if their signatures are the same\n-infer_fn_consider_casting = consider casting the fn item to a fn pointer: `{$casting}`\n+infer_relate_object_bound = ...so that it can be closed over into an object\n+infer_relate_param_bound = ...so that the type `{$name}` will meet its required lifetime bounds{$continues ->\n+    [true] ...\n+    *[false] {\"\"}\n+}\n+infer_relate_param_bound_2 = ...that is required by this bound\n+infer_relate_region_param_bound = ...so that the declared lifetime parameter bounds are satisfied\n+infer_ril_because_of = because of this returned expression\n+infer_ril_introduced_by = requirement introduced by this return type\n+infer_ril_introduced_here = `'static` requirement introduced here\n+infer_ril_static_introduced_by = \"`'static` lifetime requirement introduced by the return type\n \n infer_sarwa_option = you can convert from `&Option<T>` to `Option<&T>` using `.as_ref()`\n infer_sarwa_result = you can convert from `&Result<T, E>` to `Result<&T, &E>` using `.as_ref()`\n \n-infer_suggest_accessing_field = you might have meant to use field `{$name}` whose type is `{$ty}`\n+infer_sbfrit_box_return_expr = if you change the return type to expect trait objects, box the returned expressions\n \n infer_sbfrit_change_return_type = you could change the return type to be a boxed trait object\n-infer_sbfrit_box_return_expr = if you change the return type to expect trait objects, box the returned expressions\n+infer_source_kind_closure_return =\n+    try giving this closure an explicit return type\n \n-infer_stp_wrap_one = try wrapping the pattern in `{$variant}`\n+# generator_kind  may need to be translated\n+infer_source_kind_fully_qualified =\n+    try using a fully qualified path to specify the expected types\n+\n+infer_source_kind_subdiag_generic_label =\n+    cannot infer {$is_type ->\n+    [true] type\n+    *[false] the value\n+    } of the {$is_type ->\n+    [true] type\n+    *[false] const\n+    } {$parent_exists ->\n+    [true] parameter `{$param_name}` declared on the {$parent_prefix} `{$parent_name}`\n+    *[false] parameter {$param_name}\n+    }\n+\n+infer_source_kind_subdiag_generic_suggestion =\n+    consider specifying the generic {$arg_count ->\n+    [one] argument\n+    *[other] arguments\n+    }\n+\n+infer_source_kind_subdiag_let = {$kind ->\n+    [with_pattern] consider giving `{$name}` an explicit type\n+    [closure] consider giving this closure parameter an explicit type\n+    *[other] consider giving this pattern a type\n+}{$x_kind ->\n+    [has_name] , where the {$prefix_kind ->\n+        *[type] type for {$prefix}\n+        [const_with_param] value of const parameter\n+        [const] value of the constant\n+    } `{$arg_name}` is specified\n+    [underscore] , where the placeholders `_` are specified\n+    *[empty] {\"\"}\n+}\n+\n+infer_srs_add = consider returning the local binding `{$ident}`\n+infer_srs_add_one = consider returning one of these bindings\n+\n+infer_srs_remove = consider removing this semicolon\n+infer_srs_remove_and_box = consider removing this semicolon and boxing the expressions\n infer_stp_wrap_many = try wrapping the pattern in a variant of `{$path}`\n \n-infer_tuple_trailing_comma = use a trailing comma to create a tuple with one element\n+infer_stp_wrap_one = try wrapping the pattern in `{$variant}`\n+infer_subtype = ...so that the {$requirement ->\n+    [method_compat] method type is compatible with trait\n+    [type_compat] associated type is compatible with trait\n+    [const_compat] const is compatible with trait\n+    [expr_assignable] expression is assignable\n+    [if_else_different] `if` and `else` have incompatible types\n+    [no_else] `if` missing an `else` returns `()`\n+    [fn_main_correct_type] `main` function has the correct type\n+    [fn_start_correct_type] `#[start]` function has the correct type\n+    [intrinsic_correct_type] intrinsic has the correct type\n+    [method_correct_type] method receiver has the correct type\n+    *[other] types are compatible\n+}\n+infer_subtype_2 = ...so that {$requirement ->\n+    [method_compat] method type is compatible with trait\n+    [type_compat] associated type is compatible with trait\n+    [const_compat] const is compatible with trait\n+    [expr_assignable] expression is assignable\n+    [if_else_different] `if` and `else` have incompatible types\n+    [no_else] `if` missing an `else` returns `()`\n+    [fn_main_correct_type] `main` function has the correct type\n+    [fn_start_correct_type] `#[start]` function has the correct type\n+    [intrinsic_correct_type] intrinsic has the correct type\n+    [method_correct_type] method receiver has the correct type\n+    *[other] types are compatible\n+}\n \n-infer_oc_method_compat = method not compatible with trait\n-infer_oc_type_compat = type not compatible with trait\n-infer_oc_const_compat = const not compatible with trait\n-infer_oc_try_compat = `?` operator has incompatible types\n-infer_oc_match_compat = `match` arms have incompatible types\n-infer_oc_if_else_different = `if` and `else` have incompatible types\n-infer_oc_no_else = `if` may be missing an `else` clause\n-infer_oc_no_diverge = `else` clause of `let...else` does not diverge\n-infer_oc_fn_main_correct_type = `main` function has wrong type\n-infer_oc_fn_start_correct_type = `#[start]` function has wrong type\n-infer_oc_intrinsic_correct_type = intrinsic has wrong type\n-infer_oc_method_correct_type = mismatched `self` parameter type\n-infer_oc_closure_selfref = closure/generator type that references itself\n-infer_oc_cant_coerce = cannot coerce intrinsics to function pointers\n-infer_oc_generic = mismatched types\n+infer_suggest_accessing_field = you might have meant to use field `{$name}` whose type is `{$ty}`\n+\n+infer_suggest_add_let_for_letchains = consider adding `let`\n+\n+infer_tid_consider_borrowing = consider borrowing this type parameter in the trait\n+infer_tid_param_help = the lifetime requirements from the `impl` do not correspond to the requirements in the `trait`\n+\n+infer_tid_rel_help = verify the lifetime relationships in the `trait` and `impl` between the `self` argument, the other inputs and its output\n+infer_trait_impl_diff = `impl` item signature doesn't match `trait` item signature\n+    .found = found `{$found}`\n+    .expected = expected `{$expected}`\n+    .expected_found = expected signature `{$expected}`\n+               {\"   \"}found signature `{$found}`\n+\n+infer_trait_placeholder_mismatch = implementation of `{$trait_def_id}` is not general enough\n+    .label_satisfy = doesn't satisfy where-clause\n+    .label_where = due to a where-clause on `{$def_id}`...\n+    .label_dup = implementation of `{$trait_def_id}` is not general enough\n \n-infer_meant_byte_literal = if you meant to write a byte literal, prefix with `b`\n-infer_meant_char_literal = if you meant to write a `char` literal, use single quotes\n-infer_meant_str_literal = if you meant to write a `str` literal, use double quotes\n-infer_consider_specifying_length = consider specifying the actual array length\n infer_try_cannot_convert = `?` operator cannot convert from `{$found}` to `{$expected}`\n+\n+infer_tuple_trailing_comma = use a trailing comma to create a tuple with one element\n+\n+infer_type_annotations_needed = {$source_kind ->\n+    [closure] type annotations needed for the closure `{$source_name}`\n+    [normal] type annotations needed for `{$source_name}`\n+    *[other] type annotations needed\n+}\n+    .label = type must be known at this point\n+\n+infer_types_declared_different = these two types are declared with different lifetimes...\n+infer_where_copy_predicates = copy the `where` clause predicates from the trait\n+\n+infer_where_remove = remove the `where` clause"}, {"sha": "be1a75f020b4d2f9f0ebe5434487ef19a02caa3e", "filename": "compiler/rustc_interface/messages.ftl", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_interface%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_interface%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,52 +1,52 @@\n-interface_ferris_identifier =\n-    Ferris cannot be used as an identifier\n-    .suggestion = try using their name instead\n+interface_cant_emit_mir =\n+    could not emit MIR: {$error}\n \n interface_emoji_identifier =\n     identifiers cannot contain emoji: `{$ident}`\n \n-interface_mixed_bin_crate =\n-    cannot mix `bin` crate type with others\n-\n-interface_mixed_proc_macro_crate =\n-    cannot mix `proc-macro` crate type with others\n-\n interface_error_writing_dependencies =\n     error writing dependencies to `{$path}`: {$error}\n \n-interface_input_file_would_be_overwritten =\n-    the input file \"{$path}\" would be overwritten by the generated executable\n+interface_failed_writing_file =\n+    failed to write file {$path}: {$error}\"\n+\n+interface_ferris_identifier =\n+    Ferris cannot be used as an identifier\n+    .suggestion = try using their name instead\n \n interface_generated_file_conflicts_with_directory =\n     the generated executable for the input file \"{$input_path}\" conflicts with the existing directory \"{$dir_path}\"\n \n-interface_temps_dir_error =\n-    failed to find or create the directory specified by `--temps-dir`\n+interface_ignoring_extra_filename = ignoring -C extra-filename flag due to -o flag\n+\n+interface_ignoring_out_dir = ignoring --out-dir flag due to -o flag\n+\n+interface_input_file_would_be_overwritten =\n+    the input file \"{$path}\" would be overwritten by the generated executable\n+\n+interface_mixed_bin_crate =\n+    cannot mix `bin` crate type with others\n+\n+interface_mixed_proc_macro_crate =\n+    cannot mix `proc-macro` crate type with others\n+\n+interface_multiple_output_types_adaption =\n+    due to multiple output types requested, the explicitly specified output file name will be adapted for each output type\n \n interface_out_dir_error =\n     failed to find or create the directory specified by `--out-dir`\n \n-interface_cant_emit_mir =\n-    could not emit MIR: {$error}\n+interface_proc_macro_crate_panic_abort =\n+    building proc macro crate with `panic=abort` may crash the compiler should the proc-macro panic\n \n interface_rustc_error_fatal =\n     fatal error triggered by #[rustc_error]\n \n interface_rustc_error_unexpected_annotation =\n     unexpected annotation used with `#[rustc_error(...)]`!\n \n-interface_failed_writing_file =\n-    failed to write file {$path}: {$error}\"\n-\n-interface_proc_macro_crate_panic_abort =\n-    building proc macro crate with `panic=abort` may crash the compiler should the proc-macro panic\n+interface_temps_dir_error =\n+    failed to find or create the directory specified by `--temps-dir`\n \n interface_unsupported_crate_type_for_target =\n     dropping unsupported crate type `{$crate_type}` for target `{$target_triple}`\n-\n-interface_multiple_output_types_adaption =\n-    due to multiple output types requested, the explicitly specified output file name will be adapted for each output type\n-\n-interface_ignoring_extra_filename = ignoring -C extra-filename flag due to -o flag\n-\n-interface_ignoring_out_dir = ignoring --out-dir flag due to -o flag"}, {"sha": "d34a3afcba53a345c559a5263248848581e6daaf", "filename": "compiler/rustc_lint/messages.ftl", "status": "modified", "additions": 372, "deletions": 373, "changes": 745, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_lint%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_lint%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -5,534 +5,533 @@ lint_array_into_iter =\n     .use_explicit_into_iter_suggestion =\n         or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value\n \n-lint_enum_intrinsics_mem_discriminant =\n-    the return value of `mem::discriminant` is unspecified when called with a non-enum type\n-    .note = the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `{$ty_param}`, which is not an enum.\n+lint_atomic_ordering_fence = memory fences cannot have `Relaxed` ordering\n+    .help = consider using ordering modes `Acquire`, `Release`, `AcqRel` or `SeqCst`\n \n-lint_enum_intrinsics_mem_variant =\n-    the return value of `mem::variant_count` is unspecified when called with a non-enum type\n-    .note = the type parameter of `variant_count` should be an enum, but it was instantiated with the type `{$ty_param}`, which is not an enum.\n+lint_atomic_ordering_invalid = `{$method}`'s failure ordering may not be `Release` or `AcqRel`, since a failed `{$method}` does not result in a write\n+    .label = invalid failure ordering\n+    .help = consider using `Acquire` or `Relaxed` failure ordering instead\n \n-lint_expectation = this lint expectation is unfulfilled\n-    .note = the `unfulfilled_lint_expectations` lint can't be expected and will always produce this message\n-    .rationale = {$rationale}\n+lint_atomic_ordering_load = atomic loads cannot have `Release` or `AcqRel` ordering\n+    .help = consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n \n-lint_for_loops_over_fallibles =\n-    for loop over {$article} `{$ty}`. This is more readably written as an `if let` statement\n-    .suggestion = consider using `if let` to clear intent\n-    .remove_next = to iterate over `{$recv_snip}` remove the call to `next`\n-    .use_while_let = to check pattern in a loop use `while let`\n-    .use_question_mark = consider unwrapping the `Result` with `?` to iterate over its contents\n+lint_atomic_ordering_store = atomic stores cannot have `Acquire` or `AcqRel` ordering\n+    .help = consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n \n-lint_map_unit_fn = `Iterator::map` call that discard the iterator's values\n-    .note = `Iterator::map`, like many of the methods on `Iterator`, gets executed lazily, meaning that its effects won't be visible until it is iterated\n-    .function_label = this function returns `()`, which is likely not what you wanted\n-    .argument_label = called `Iterator::map` with callable that returns `()`\n-    .map_label = after this call to map, the resulting iterator is `impl Iterator<Item = ()>`, which means the only information carried by the iterator is the number of items\n-    .suggestion = you might have meant to use `Iterator::for_each`\n+lint_bad_attribute_argument = bad attribute argument\n \n-lint_non_binding_let_on_sync_lock =\n-    non-binding let on a synchronization lock\n+lint_bad_opt_access = {$msg}\n \n-lint_non_binding_let_on_drop_type =\n-    non-binding let on a type that implements `Drop`\n+lint_builtin_allow_internal_unsafe =\n+    `allow_internal_unsafe` allows defining macros using unsafe without triggering the `unsafe_code` lint at their call site\n \n-lint_non_binding_let_suggestion =\n-    consider binding to an unused variable to avoid immediately dropping the value\n+lint_builtin_anonymous_params = anonymous parameters are deprecated and will be removed in the next edition\n+    .suggestion = try naming the parameter or explicitly ignoring it\n \n-lint_non_binding_let_multi_suggestion =\n-    consider immediately dropping the value\n+lint_builtin_asm_labels = avoid using named labels in inline assembly\n \n-lint_deprecated_lint_name =\n-    lint name `{$name}` is deprecated and may not have an effect in the future.\n-    .suggestion = change it to\n+lint_builtin_box_pointers = type uses owned (Box type) pointers: {$ty}\n \n-lint_renamed_or_removed_lint = {$msg}\n-    .suggestion = use the new name\n+lint_builtin_clashing_extern_diff_name = `{$this}` redeclares `{$orig}` with a different signature\n+    .previous_decl_label = `{$orig}` previously declared here\n+    .mismatch_label = this signature doesn't match the previous declaration\n \n-lint_suspicious_double_ref_op =\n-    using `.{$call}()` on a double reference, which returns `{$ty}` instead of {$op ->\n-        *[should_not_happen] [{$op}]\n-        [deref] dereferencing\n-        [borrow] borrowing\n-        [clone] cloning\n-    } the inner type\n+lint_builtin_clashing_extern_same_name = `{$this}` redeclared with a different signature\n+    .previous_decl_label = `{$orig}` previously declared here\n+    .mismatch_label = this signature doesn't match the previous declaration\n+lint_builtin_const_no_mangle = const items should never be `#[no_mangle]`\n+    .suggestion = try a static value\n \n-lint_unknown_lint =\n-    unknown lint: `{$name}`\n-    .suggestion = did you mean\n+lint_builtin_decl_unsafe_fn = declaration of an `unsafe` function\n+lint_builtin_decl_unsafe_method = declaration of an `unsafe` method\n+lint_builtin_deprecated_attr_default_suggestion = remove this attribute\n \n-lint_ignored_unless_crate_specified = {$level}({$name}) is ignored unless specified at crate level\n+lint_builtin_deprecated_attr_link = use of deprecated attribute `{$name}`: {$reason}. See {$link}\n+    .msg_suggestion = {$msg}\n+    .default_suggestion = remove this attribute\n+lint_builtin_deprecated_attr_used = use of deprecated attribute `{$name}`: no longer used.\n+lint_builtin_deref_nullptr = dereferencing a null pointer\n+    .label = this code causes undefined behavior when executed\n \n-lint_unknown_gated_lint =\n-    unknown lint: `{$name}`\n-    .note = the `{$name}` lint is unstable\n+lint_builtin_ellipsis_inclusive_range_patterns = `...` range patterns are deprecated\n+    .suggestion = use `..=` for an inclusive range\n \n-lint_hidden_unicode_codepoints = unicode codepoint changing visible direction of text present in {$label}\n-    .label = this {$label} contains {$count ->\n-        [one] an invisible\n-        *[other] invisible\n-    } unicode text flow control {$count ->\n-        [one] codepoint\n-        *[other] codepoints\n+lint_builtin_explicit_outlives = outlives requirements can be inferred\n+    .suggestion = remove {$count ->\n+        [one] this bound\n+        *[other] these bounds\n     }\n-    .note = these kind of unicode codepoints change the way text flows on applications that support them, but can cause confusion because they change the order of characters on the screen\n-    .suggestion_remove = if their presence wasn't intentional, you can remove them\n-    .suggestion_escape = if you want to keep them but make them visible in your source code, you can escape them\n-    .no_suggestion_note_escape = if you want to keep them but make them visible in your source code, you can escape them: {$escaped}\n \n-lint_default_hash_types = prefer `{$preferred}` over `{$used}`, it has better performance\n-    .note = a `use rustc_data_structures::fx::{$preferred}` may be necessary\n-\n-lint_query_instability = using `{$query}` can result in unstable query results\n-    .note = if you believe this case to be fine, allow this lint and add a comment explaining your rationale\n+lint_builtin_export_name_fn = declaration of a function with `export_name`\n+lint_builtin_export_name_method = declaration of a method with `export_name`\n \n-lint_tykind_kind = usage of `ty::TyKind::<kind>`\n-    .suggestion = try using `ty::<kind>` directly\n+lint_builtin_export_name_static = declaration of a static with `export_name`\n+lint_builtin_impl_unsafe_method = implementation of an `unsafe` method\n \n-lint_tykind = usage of `ty::TyKind`\n-    .help = try using `Ty` instead\n+lint_builtin_incomplete_features = the feature `{$name}` is incomplete and may not be safe to use and/or cause compiler crashes\n+    .note = see issue #{$n} <https://github.com/rust-lang/rust/issues/{$n}> for more information\n+    .help = consider using `min_{$name}` instead, which is more stable and complete\n \n-lint_ty_qualified = usage of qualified `ty::{$ty}`\n-    .suggestion = try importing it and using it unqualified\n+lint_builtin_keyword_idents = `{$kw}` is a keyword in the {$next} edition\n+    .suggestion = you can use a raw identifier to stay compatible\n \n-lint_lintpass_by_hand = implementing `LintPass` by hand\n-    .help = try using `declare_lint_pass!` or `impl_lint_pass!` instead\n+lint_builtin_link_section_fn = declaration of a function with `link_section`\n \n-lint_non_existent_doc_keyword = found non-existing keyword `{$keyword}` used in `#[doc(keyword = \"...\")]`\n-    .help = only existing keywords are allowed in core/std\n+lint_builtin_link_section_static = declaration of a static with `link_section`\n \n-lint_diag_out_of_impl =\n-    diagnostics should only be created in `IntoDiagnostic`/`AddToDiagnostic` impls\n+lint_builtin_missing_copy_impl = type could implement `Copy`; consider adding `impl Copy`\n \n-lint_untranslatable_diag = diagnostics should be created using translatable messages\n+lint_builtin_missing_debug_impl =\n+    type does not implement `{$debug}`; consider adding `#[derive(Debug)]` or a manual implementation\n \n-lint_trivial_untranslatable_diag = diagnostic with static strings only\n+lint_builtin_missing_doc = missing documentation for {$article} {$desc}\n \n-lint_bad_opt_access = {$msg}\n+lint_builtin_mutable_transmutes =\n+    transmuting &T to &mut T is undefined behavior, even if the reference is unused, consider instead using an UnsafeCell\n \n-lint_cstring_ptr = getting the inner pointer of a temporary `CString`\n-    .as_ptr_label = this pointer will be invalid\n-    .unwrap_label = this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime\n-    .note = pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned\n-    .help = for more information, see https://doc.rust-lang.org/reference/destructors.html\n+lint_builtin_no_mangle_fn = declaration of a `no_mangle` function\n+lint_builtin_no_mangle_generic = functions generic over types or consts must be mangled\n+    .suggestion = remove this attribute\n \n-lint_multiple_supertrait_upcastable = `{$ident}` is object-safe and has multiple supertraits\n+lint_builtin_no_mangle_method = declaration of a `no_mangle` method\n+lint_builtin_no_mangle_static = declaration of a `no_mangle` static\n+lint_builtin_non_shorthand_field_patterns = the `{$ident}:` in this pattern is redundant\n+    .suggestion = use shorthand field pattern\n \n-lint_identifier_non_ascii_char = identifier contains non-ASCII characters\n+lint_builtin_overridden_symbol_name =\n+    the linker's behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them\n \n-lint_identifier_uncommon_codepoints = identifier contains uncommon Unicode codepoints\n+lint_builtin_overridden_symbol_section =\n+    the program's behavior with overridden link sections on items is unpredictable and Rust cannot provide guarantees when you manually override them\n \n-lint_confusable_identifier_pair = identifier pair considered confusable between `{$existing_sym}` and `{$sym}`\n-    .label = this is where the previous identifier occurred\n+lint_builtin_special_module_name_used_lib = found module declaration for lib.rs\n+    .note = lib.rs is the root of this crate's library target\n+    .help = to refer to it from other targets, use the library's name as the path\n \n-lint_mixed_script_confusables =\n-    the usage of Script Group `{$set}` in this crate consists solely of mixed script confusables\n-    .includes_note = the usage includes {$includes}\n-    .note = please recheck to make sure their usages are indeed what you want\n+lint_builtin_special_module_name_used_main = found module declaration for main.rs\n+    .note = a binary crate cannot be used as library\n \n-lint_non_fmt_panic = panic message is not a string literal\n-    .note = this usage of `{$name}!()` is deprecated; it will be a hard error in Rust 2021\n-    .more_info_note = for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-    .supports_fmt_note = the `{$name}!()` macro supports formatting, so there's no need for the `format!()` macro here\n-    .supports_fmt_suggestion = remove the `format!(..)` macro call\n-    .display_suggestion = add a \"{\"{\"}{\"}\"}\" format string to `Display` the message\n-    .debug_suggestion =\n-        add a \"{\"{\"}:?{\"}\"}\" format string to use the `Debug` implementation of `{$ty}`\n-    .panic_suggestion = {$already_suggested ->\n-        [true] or use\n-        *[false] use\n-    } std::panic::panic_any instead\n+lint_builtin_trivial_bounds = {$predicate_kind_name} bound {$predicate} does not depend on any type or lifetime parameters\n \n-lint_non_fmt_panic_unused =\n-    panic message contains {$count ->\n-        [one] an unused\n-        *[other] unused\n-    } formatting {$count ->\n-        [one] placeholder\n-        *[other] placeholders\n-    }\n-    .note = this message is not used as a format string when given without arguments, but will be in Rust 2021\n-    .add_args_suggestion = add the missing {$count ->\n-        [one] argument\n-        *[other] arguments\n-    }\n-    .add_fmt_suggestion = or add a \"{\"{\"}{\"}\"}\" format string to use the message literally\n+lint_builtin_type_alias_bounds_help = use fully disambiguated paths (i.e., `<T as Trait>::Assoc`) to refer to associated types in type aliases\n \n-lint_non_fmt_panic_braces =\n-    panic message contains {$count ->\n-        [one] a brace\n-        *[other] braces\n-    }\n-    .note = this message is not used as a format string, but will be in Rust 2021\n-    .suggestion = add a \"{\"{\"}{\"}\"}\" format string to use the message literally\n+lint_builtin_type_alias_generic_bounds = bounds on generic parameters are not enforced in type aliases\n+    .suggestion = the bound will not be checked when the type alias is used, and should be removed\n \n-lint_non_camel_case_type = {$sort} `{$name}` should have an upper camel case name\n-    .suggestion = convert the identifier to upper camel case\n-    .label = should have an UpperCamelCase name\n+lint_builtin_type_alias_where_clause = where clauses are not enforced in type aliases\n+    .suggestion = the clause will not be checked when the type alias is used, and should be removed\n \n-lint_non_snake_case = {$sort} `{$name}` should have a snake case name\n-    .rename_or_convert_suggestion = rename the identifier or convert it to a snake case raw identifier\n-    .cannot_convert_note = `{$sc}` cannot be used as a raw identifier\n-    .rename_suggestion = rename the identifier\n-    .convert_suggestion = convert the identifier to snake case\n-    .help = convert the identifier to snake case: `{$sc}`\n-    .label = should have a snake_case name\n+lint_builtin_unexpected_cli_config_name = unexpected `{$name}` as condition name\n+    .help = was set with `--cfg` but isn't in the `--check-cfg` expected names\n \n-lint_non_upper_case_global = {$sort} `{$name}` should have an upper case name\n-    .suggestion = convert the identifier to upper case\n-    .label = should have an UPPER_CASE name\n+lint_builtin_unexpected_cli_config_value = unexpected condition value `{$value}` for condition name `{$name}`\n+    .help = was set with `--cfg` but isn't in the `--check-cfg` expected values\n \n-lint_noop_method_call = call to `.{$method}()` on a reference in this situation does nothing\n-    .label = unnecessary method call\n-    .note = the type `{$receiver_ty}` which `{$method}` is being called on is the same as the type returned from `{$method}`, so the method call does not do anything and can be removed\n+lint_builtin_unnameable_test_items = cannot test inner items\n \n-lint_pass_by_value = passing `{$ty}` by reference\n-    .suggestion = try passing by value\n+lint_builtin_unpermitted_type_init_label = this code causes undefined behavior when executed\n+lint_builtin_unpermitted_type_init_label_suggestion = help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n \n-lint_redundant_semicolons =\n-    unnecessary trailing {$multiple ->\n-        [true] semicolons\n-        *[false] semicolon\n-    }\n-    .suggestion = remove {$multiple ->\n-        [true] these semicolons\n-        *[false] this semicolon\n-    }\n+lint_builtin_unpermitted_type_init_uninit = the type `{$ty}` does not permit being left uninitialized\n \n-lint_drop_trait_constraints =\n-    bounds on `{$predicate}` are most likely incorrect, consider instead using `{$needs_drop}` to detect whether a type can be trivially dropped\n+lint_builtin_unpermitted_type_init_zeroed = the type `{$ty}` does not permit zero-initialization\n+lint_builtin_unreachable_pub = unreachable `pub` {$what}\n+    .suggestion = consider restricting its visibility\n+    .help = or consider exporting it for use by other crates\n \n-lint_drop_glue =\n-    types that do not implement `Drop` can still have drop glue, consider instead using `{$needs_drop}` to detect whether a type is trivially dropped\n+lint_builtin_unsafe_block = usage of an `unsafe` block\n \n-lint_range_endpoint_out_of_range = range endpoint is out of range for `{$ty}`\n+lint_builtin_unsafe_impl = implementation of an `unsafe` trait\n \n-lint_range_use_inclusive_range = use an inclusive range instead\n+lint_builtin_unsafe_trait = declaration of an `unsafe` trait\n \n+lint_builtin_unstable_features = unstable feature\n \n-lint_overflowing_bin_hex = literal out of range for `{$ty}`\n-    .negative_note = the literal `{$lit}` (decimal `{$dec}`) does not fit into the type `{$ty}`\n-    .negative_becomes_note = and the value `-{$lit}` will become `{$actually}{$ty}`\n-    .positive_note = the literal `{$lit}` (decimal `{$dec}`) does not fit into the type `{$ty}` and will become `{$actually}{$ty}`\n-    .suggestion = consider using the type `{$suggestion_ty}` instead\n-    .help = consider using the type `{$suggestion_ty}` instead\n+lint_builtin_unused_doc_comment = unused doc comment\n+    .label = rustdoc does not generate documentation for {$kind}\n+    .plain_help = use `//` for a plain comment\n+    .block_help = use `/* */` for a plain comment\n \n-lint_overflowing_int = literal out of range for `{$ty}`\n-    .note = the literal `{$lit}` does not fit into the type `{$ty}` whose range is `{$min}..={$max}`\n-    .help = consider using the type `{$suggestion_ty}` instead\n+lint_builtin_while_true = denote infinite loops with `loop {\"{\"} ... {\"}\"}`\n+    .suggestion = use `loop`\n \n-lint_only_cast_u8_to_char = only `u8` can be cast into `char`\n-    .suggestion = use a `char` literal instead\n+lint_check_name_deprecated = lint name `{$lint_name}` is deprecated and does not have an effect anymore. Use: {$new_name}\n \n-lint_overflowing_uint = literal out of range for `{$ty}`\n-    .note = the literal `{$lit}` does not fit into the type `{$ty}` whose range is `{$min}..={$max}`\n+lint_check_name_unknown = unknown lint: `{$lint_name}`\n+    .help = did you mean: `{$suggestion}`\n \n-lint_overflowing_literal = literal out of range for `{$ty}`\n-    .note = the literal `{$lit}` does not fit into the type `{$ty}` and will be converted to `{$ty}::INFINITY`\n+lint_check_name_unknown_tool = unknown lint tool: `{$tool_name}`\n \n-lint_unused_comparisons = comparison is useless due to type limits\n+lint_check_name_warning = {$msg}\n \n-lint_improper_ctypes = `extern` {$desc} uses type `{$ty}`, which is not FFI-safe\n-    .label = not FFI-safe\n-    .note = the type is defined here\n+lint_command_line_source = `forbid` lint level was set on command line\n \n-lint_improper_ctypes_opaque = opaque types have no C equivalent\n+lint_confusable_identifier_pair = identifier pair considered confusable between `{$existing_sym}` and `{$sym}`\n+    .label = this is where the previous identifier occurred\n \n-lint_improper_ctypes_fnptr_reason = this function pointer has Rust-specific calling convention\n-lint_improper_ctypes_fnptr_help = consider using an `extern fn(...) -> ...` function pointer instead\n+lint_cstring_ptr = getting the inner pointer of a temporary `CString`\n+    .as_ptr_label = this pointer will be invalid\n+    .unwrap_label = this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime\n+    .note = pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned\n+    .help = for more information, see https://doc.rust-lang.org/reference/destructors.html\n \n-lint_improper_ctypes_tuple_reason = tuples have unspecified layout\n-lint_improper_ctypes_tuple_help = consider using a struct instead\n+lint_default_hash_types = prefer `{$preferred}` over `{$used}`, it has better performance\n+    .note = a `use rustc_data_structures::fx::{$preferred}` may be necessary\n \n-lint_improper_ctypes_str_reason = string slices have no C equivalent\n-lint_improper_ctypes_str_help = consider using `*const u8` and a length instead\n+lint_default_source = `forbid` lint level is the default for {$id}\n \n-lint_improper_ctypes_dyn = trait objects have no C equivalent\n+lint_deprecated_lint_name =\n+    lint name `{$name}` is deprecated and may not have an effect in the future.\n+    .suggestion = change it to\n \n-lint_improper_ctypes_slice_reason = slices have no C equivalent\n-lint_improper_ctypes_slice_help = consider using a raw pointer instead\n+lint_diag_out_of_impl =\n+    diagnostics should only be created in `IntoDiagnostic`/`AddToDiagnostic` impls\n \n-lint_improper_ctypes_128bit = 128-bit integers don't currently have a known stable ABI\n+lint_drop_glue =\n+    types that do not implement `Drop` can still have drop glue, consider instead using `{$needs_drop}` to detect whether a type is trivially dropped\n \n-lint_improper_ctypes_char_reason = the `char` type has no C equivalent\n-lint_improper_ctypes_char_help = consider using `u32` or `libc::wchar_t` instead\n+lint_drop_trait_constraints =\n+    bounds on `{$predicate}` are most likely incorrect, consider instead using `{$needs_drop}` to detect whether a type can be trivially dropped\n \n-lint_improper_ctypes_non_exhaustive = this enum is non-exhaustive\n-lint_improper_ctypes_non_exhaustive_variant = this enum has non-exhaustive variants\n+lint_dropping_copy_types = calls to `std::mem::drop` with a value that implements `Copy` does nothing\n+    .label = argument has type `{$arg_ty}`\n+    .note = use `let _ = ...` to ignore the expression or result\n \n-lint_improper_ctypes_enum_repr_reason = enum has no representation hint\n-lint_improper_ctypes_enum_repr_help =\n-    consider adding a `#[repr(C)]`, `#[repr(transparent)]`, or integer `#[repr(...)]` attribute to this enum\n+lint_dropping_references = calls to `std::mem::drop` with a reference instead of an owned value does nothing\n+    .label = argument has type `{$arg_ty}`\n+    .note = use `let _ = ...` to ignore the expression or result\n \n-lint_improper_ctypes_struct_fieldless_reason = this struct has no fields\n-lint_improper_ctypes_struct_fieldless_help = consider adding a member to this struct\n+lint_enum_intrinsics_mem_discriminant =\n+    the return value of `mem::discriminant` is unspecified when called with a non-enum type\n+    .note = the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `{$ty_param}`, which is not an enum.\n \n-lint_improper_ctypes_union_fieldless_reason = this union has no fields\n-lint_improper_ctypes_union_fieldless_help = consider adding a member to this union\n+lint_enum_intrinsics_mem_variant =\n+    the return value of `mem::variant_count` is unspecified when called with a non-enum type\n+    .note = the type parameter of `variant_count` should be an enum, but it was instantiated with the type `{$ty_param}`, which is not an enum.\n \n-lint_improper_ctypes_struct_non_exhaustive = this struct is non-exhaustive\n-lint_improper_ctypes_union_non_exhaustive = this union is non-exhaustive\n+lint_expectation = this lint expectation is unfulfilled\n+    .note = the `unfulfilled_lint_expectations` lint can't be expected and will always produce this message\n+    .rationale = {$rationale}\n \n-lint_improper_ctypes_struct_layout_reason = this struct has unspecified layout\n-lint_improper_ctypes_struct_layout_help = consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this struct\n+lint_for_loops_over_fallibles =\n+    for loop over {$article} `{$ty}`. This is more readably written as an `if let` statement\n+    .suggestion = consider using `if let` to clear intent\n+    .remove_next = to iterate over `{$recv_snip}` remove the call to `next`\n+    .use_while_let = to check pattern in a loop use `while let`\n+    .use_question_mark = consider unwrapping the `Result` with `?` to iterate over its contents\n \n-lint_improper_ctypes_union_layout_reason = this union has unspecified layout\n-lint_improper_ctypes_union_layout_help = consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this union\n+lint_forgetting_copy_types = calls to `std::mem::forget` with a value that implements `Copy` does nothing\n+    .label = argument has type `{$arg_ty}`\n+    .note = use `let _ = ...` to ignore the expression or result\n+lint_forgetting_references = calls to `std::mem::forget` with a reference instead of an owned value does nothing\n+    .label = argument has type `{$arg_ty}`\n+    .note = use `let _ = ...` to ignore the expression or result\n \n-lint_improper_ctypes_box = box cannot be represented as a single pointer\n+lint_hidden_unicode_codepoints = unicode codepoint changing visible direction of text present in {$label}\n+    .label = this {$label} contains {$count ->\n+        [one] an invisible\n+        *[other] invisible\n+    } unicode text flow control {$count ->\n+        [one] codepoint\n+        *[other] codepoints\n+    }\n+    .note = these kind of unicode codepoints change the way text flows on applications that support them, but can cause confusion because they change the order of characters on the screen\n+    .suggestion_remove = if their presence wasn't intentional, you can remove them\n+    .suggestion_escape = if you want to keep them but make them visible in your source code, you can escape them\n+    .no_suggestion_note_escape = if you want to keep them but make them visible in your source code, you can escape them: {$escaped}\n \n-lint_improper_ctypes_enum_phantomdata = this enum contains a PhantomData field\n+lint_identifier_non_ascii_char = identifier contains non-ASCII characters\n \n-lint_improper_ctypes_struct_zst = this struct contains only zero-sized fields\n+lint_identifier_uncommon_codepoints = identifier contains uncommon Unicode codepoints\n \n-lint_improper_ctypes_array_reason = passing raw arrays by value is not FFI-safe\n-lint_improper_ctypes_array_help = consider passing a pointer to the array\n+lint_ignored_unless_crate_specified = {$level}({$name}) is ignored unless specified at crate level\n \n-lint_improper_ctypes_only_phantomdata = composed only of `PhantomData`\n+lint_improper_ctypes = `extern` {$desc} uses type `{$ty}`, which is not FFI-safe\n+    .label = not FFI-safe\n+    .note = the type is defined here\n \n-lint_variant_size_differences =\n-    enum variant is more than three times larger ({$largest} bytes) than the next largest\n+lint_improper_ctypes_128bit = 128-bit integers don't currently have a known stable ABI\n \n-lint_atomic_ordering_load = atomic loads cannot have `Release` or `AcqRel` ordering\n-    .help = consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n+lint_improper_ctypes_array_help = consider passing a pointer to the array\n \n-lint_atomic_ordering_store = atomic stores cannot have `Acquire` or `AcqRel` ordering\n-    .help = consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n+lint_improper_ctypes_array_reason = passing raw arrays by value is not FFI-safe\n+lint_improper_ctypes_box = box cannot be represented as a single pointer\n \n-lint_atomic_ordering_fence = memory fences cannot have `Relaxed` ordering\n-    .help = consider using ordering modes `Acquire`, `Release`, `AcqRel` or `SeqCst`\n+lint_improper_ctypes_char_help = consider using `u32` or `libc::wchar_t` instead\n \n-lint_atomic_ordering_invalid = `{$method}`'s failure ordering may not be `Release` or `AcqRel`, since a failed `{$method}` does not result in a write\n-    .label = invalid failure ordering\n-    .help = consider using `Acquire` or `Relaxed` failure ordering instead\n+lint_improper_ctypes_char_reason = the `char` type has no C equivalent\n+lint_improper_ctypes_dyn = trait objects have no C equivalent\n \n-lint_unused_op = unused {$op} that must be used\n-    .label = the {$op} produces a value\n-    .suggestion = use `let _ = ...` to ignore the resulting value\n+lint_improper_ctypes_enum_phantomdata = this enum contains a PhantomData field\n \n-lint_unused_result = unused result of type `{$ty}`\n+lint_improper_ctypes_enum_repr_help =\n+    consider adding a `#[repr(C)]`, `#[repr(transparent)]`, or integer `#[repr(...)]` attribute to this enum\n \n-lint_unused_closure =\n-    unused {$pre}{$count ->\n-        [one] closure\n-        *[other] closures\n-    }{$post} that must be used\n-    .note = closures are lazy and do nothing unless called\n+lint_improper_ctypes_enum_repr_reason = enum has no representation hint\n+lint_improper_ctypes_fnptr_help = consider using an `extern fn(...) -> ...` function pointer instead\n \n-lint_unused_generator =\n-    unused {$pre}{$count ->\n-        [one] generator\n-        *[other] generator\n-    }{$post} that must be used\n-    .note = generators are lazy and do nothing unless resumed\n+lint_improper_ctypes_fnptr_reason = this function pointer has Rust-specific calling convention\n+lint_improper_ctypes_non_exhaustive = this enum is non-exhaustive\n+lint_improper_ctypes_non_exhaustive_variant = this enum has non-exhaustive variants\n \n-lint_unused_def = unused {$pre}`{$def}`{$post} that must be used\n-    .suggestion = use `let _ = ...` to ignore the resulting value\n+lint_improper_ctypes_only_phantomdata = composed only of `PhantomData`\n \n-lint_path_statement_drop = path statement drops value\n-    .suggestion = use `drop` to clarify the intent\n+lint_improper_ctypes_opaque = opaque types have no C equivalent\n \n-lint_path_statement_no_effect = path statement with no effect\n+lint_improper_ctypes_slice_help = consider using a raw pointer instead\n \n-lint_unused_delim = unnecessary {$delim} around {$item}\n-    .suggestion = remove these {$delim}\n+lint_improper_ctypes_slice_reason = slices have no C equivalent\n+lint_improper_ctypes_str_help = consider using `*const u8` and a length instead\n \n-lint_unused_import_braces = braces around {$node} is unnecessary\n+lint_improper_ctypes_str_reason = string slices have no C equivalent\n+lint_improper_ctypes_struct_fieldless_help = consider adding a member to this struct\n \n-lint_unused_allocation = unnecessary allocation, use `&` instead\n-lint_unused_allocation_mut = unnecessary allocation, use `&mut` instead\n+lint_improper_ctypes_struct_fieldless_reason = this struct has no fields\n+lint_improper_ctypes_struct_layout_help = consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this struct\n \n-lint_builtin_while_true = denote infinite loops with `loop {\"{\"} ... {\"}\"}`\n-    .suggestion = use `loop`\n+lint_improper_ctypes_struct_layout_reason = this struct has unspecified layout\n+lint_improper_ctypes_struct_non_exhaustive = this struct is non-exhaustive\n+lint_improper_ctypes_struct_zst = this struct contains only zero-sized fields\n \n-lint_builtin_box_pointers = type uses owned (Box type) pointers: {$ty}\n+lint_improper_ctypes_tuple_help = consider using a struct instead\n \n-lint_builtin_non_shorthand_field_patterns = the `{$ident}:` in this pattern is redundant\n-    .suggestion = use shorthand field pattern\n+lint_improper_ctypes_tuple_reason = tuples have unspecified layout\n+lint_improper_ctypes_union_fieldless_help = consider adding a member to this union\n \n-lint_builtin_overridden_symbol_name =\n-    the linker's behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them\n+lint_improper_ctypes_union_fieldless_reason = this union has no fields\n+lint_improper_ctypes_union_layout_help = consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this union\n \n-lint_builtin_overridden_symbol_section =\n-    the program's behavior with overridden link sections on items is unpredictable and Rust cannot provide guarantees when you manually override them\n+lint_improper_ctypes_union_layout_reason = this union has unspecified layout\n+lint_improper_ctypes_union_non_exhaustive = this union is non-exhaustive\n \n-lint_builtin_allow_internal_unsafe =\n-    `allow_internal_unsafe` allows defining macros using unsafe without triggering the `unsafe_code` lint at their call site\n+lint_lintpass_by_hand = implementing `LintPass` by hand\n+    .help = try using `declare_lint_pass!` or `impl_lint_pass!` instead\n \n-lint_builtin_unsafe_block = usage of an `unsafe` block\n+lint_malformed_attribute = malformed lint attribute input\n \n-lint_builtin_unsafe_trait = declaration of an `unsafe` trait\n+lint_map_unit_fn = `Iterator::map` call that discard the iterator's values\n+    .note = `Iterator::map`, like many of the methods on `Iterator`, gets executed lazily, meaning that its effects won't be visible until it is iterated\n+    .function_label = this function returns `()`, which is likely not what you wanted\n+    .argument_label = called `Iterator::map` with callable that returns `()`\n+    .map_label = after this call to map, the resulting iterator is `impl Iterator<Item = ()>`, which means the only information carried by the iterator is the number of items\n+    .suggestion = you might have meant to use `Iterator::for_each`\n \n-lint_builtin_unsafe_impl = implementation of an `unsafe` trait\n+lint_mixed_script_confusables =\n+    the usage of Script Group `{$set}` in this crate consists solely of mixed script confusables\n+    .includes_note = the usage includes {$includes}\n+    .note = please recheck to make sure their usages are indeed what you want\n \n-lint_builtin_no_mangle_fn = declaration of a `no_mangle` function\n-lint_builtin_export_name_fn = declaration of a function with `export_name`\n-lint_builtin_link_section_fn = declaration of a function with `link_section`\n+lint_multiple_supertrait_upcastable = `{$ident}` is object-safe and has multiple supertraits\n \n-lint_builtin_no_mangle_static = declaration of a `no_mangle` static\n-lint_builtin_export_name_static = declaration of a static with `export_name`\n-lint_builtin_link_section_static = declaration of a static with `link_section`\n+lint_node_source = `forbid` level set here\n+    .note = {$reason}\n \n-lint_builtin_no_mangle_method = declaration of a `no_mangle` method\n-lint_builtin_export_name_method = declaration of a method with `export_name`\n+lint_non_binding_let_multi_suggestion =\n+    consider immediately dropping the value\n \n-lint_builtin_decl_unsafe_fn = declaration of an `unsafe` function\n-lint_builtin_decl_unsafe_method = declaration of an `unsafe` method\n-lint_builtin_impl_unsafe_method = implementation of an `unsafe` method\n+lint_non_binding_let_on_drop_type =\n+    non-binding let on a type that implements `Drop`\n \n-lint_builtin_missing_doc = missing documentation for {$article} {$desc}\n+lint_non_binding_let_on_sync_lock =\n+    non-binding let on a synchronization lock\n \n-lint_builtin_missing_copy_impl = type could implement `Copy`; consider adding `impl Copy`\n+lint_non_binding_let_suggestion =\n+    consider binding to an unused variable to avoid immediately dropping the value\n \n-lint_builtin_missing_debug_impl =\n-    type does not implement `{$debug}`; consider adding `#[derive(Debug)]` or a manual implementation\n+lint_non_camel_case_type = {$sort} `{$name}` should have an upper camel case name\n+    .suggestion = convert the identifier to upper camel case\n+    .label = should have an UpperCamelCase name\n \n-lint_builtin_anonymous_params = anonymous parameters are deprecated and will be removed in the next edition\n-    .suggestion = try naming the parameter or explicitly ignoring it\n+lint_non_existent_doc_keyword = found non-existing keyword `{$keyword}` used in `#[doc(keyword = \"...\")]`\n+    .help = only existing keywords are allowed in core/std\n \n-lint_builtin_deprecated_attr_link = use of deprecated attribute `{$name}`: {$reason}. See {$link}\n-    .msg_suggestion = {$msg}\n-    .default_suggestion = remove this attribute\n-lint_builtin_deprecated_attr_used = use of deprecated attribute `{$name}`: no longer used.\n-lint_builtin_deprecated_attr_default_suggestion = remove this attribute\n+lint_non_fmt_panic = panic message is not a string literal\n+    .note = this usage of `{$name}!()` is deprecated; it will be a hard error in Rust 2021\n+    .more_info_note = for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n+    .supports_fmt_note = the `{$name}!()` macro supports formatting, so there's no need for the `format!()` macro here\n+    .supports_fmt_suggestion = remove the `format!(..)` macro call\n+    .display_suggestion = add a \"{\"{\"}{\"}\"}\" format string to `Display` the message\n+    .debug_suggestion =\n+        add a \"{\"{\"}:?{\"}\"}\" format string to use the `Debug` implementation of `{$ty}`\n+    .panic_suggestion = {$already_suggested ->\n+        [true] or use\n+        *[false] use\n+    } std::panic::panic_any instead\n \n-lint_builtin_unused_doc_comment = unused doc comment\n-    .label = rustdoc does not generate documentation for {$kind}\n-    .plain_help = use `//` for a plain comment\n-    .block_help = use `/* */` for a plain comment\n+lint_non_fmt_panic_braces =\n+    panic message contains {$count ->\n+        [one] a brace\n+        *[other] braces\n+    }\n+    .note = this message is not used as a format string, but will be in Rust 2021\n+    .suggestion = add a \"{\"{\"}{\"}\"}\" format string to use the message literally\n \n-lint_builtin_no_mangle_generic = functions generic over types or consts must be mangled\n-    .suggestion = remove this attribute\n+lint_non_fmt_panic_unused =\n+    panic message contains {$count ->\n+        [one] an unused\n+        *[other] unused\n+    } formatting {$count ->\n+        [one] placeholder\n+        *[other] placeholders\n+    }\n+    .note = this message is not used as a format string when given without arguments, but will be in Rust 2021\n+    .add_args_suggestion = add the missing {$count ->\n+        [one] argument\n+        *[other] arguments\n+    }\n+    .add_fmt_suggestion = or add a \"{\"{\"}{\"}\"}\" format string to use the message literally\n \n-lint_builtin_const_no_mangle = const items should never be `#[no_mangle]`\n-    .suggestion = try a static value\n+lint_non_snake_case = {$sort} `{$name}` should have a snake case name\n+    .rename_or_convert_suggestion = rename the identifier or convert it to a snake case raw identifier\n+    .cannot_convert_note = `{$sc}` cannot be used as a raw identifier\n+    .rename_suggestion = rename the identifier\n+    .convert_suggestion = convert the identifier to snake case\n+    .help = convert the identifier to snake case: `{$sc}`\n+    .label = should have a snake_case name\n \n-lint_builtin_mutable_transmutes =\n-    transmuting &T to &mut T is undefined behavior, even if the reference is unused, consider instead using an UnsafeCell\n+lint_non_upper_case_global = {$sort} `{$name}` should have an upper case name\n+    .suggestion = convert the identifier to upper case\n+    .label = should have an UPPER_CASE name\n \n-lint_builtin_unstable_features = unstable feature\n+lint_noop_method_call = call to `.{$method}()` on a reference in this situation does nothing\n+    .label = unnecessary method call\n+    .note = the type `{$receiver_ty}` which `{$method}` is being called on is the same as the type returned from `{$method}`, so the method call does not do anything and can be removed\n \n-lint_ungated_async_fn_track_caller = `#[track_caller]` on async functions is a no-op\n-     .label = this function will not propagate the caller location\n+lint_only_cast_u8_to_char = only `u8` can be cast into `char`\n+    .suggestion = use a `char` literal instead\n \n-lint_builtin_unreachable_pub = unreachable `pub` {$what}\n-    .suggestion = consider restricting its visibility\n-    .help = or consider exporting it for use by other crates\n+lint_opaque_hidden_inferred_bound = opaque type `{$ty}` does not satisfy its associated type bounds\n+    .specifically = this associated type bound is unsatisfied for `{$proj_ty}`\n \n-lint_builtin_unexpected_cli_config_name = unexpected `{$name}` as condition name\n-    .help = was set with `--cfg` but isn't in the `--check-cfg` expected names\n+lint_opaque_hidden_inferred_bound_sugg = add this bound\n \n-lint_builtin_unexpected_cli_config_value = unexpected condition value `{$value}` for condition name `{$name}`\n-    .help = was set with `--cfg` but isn't in the `--check-cfg` expected values\n+lint_overflowing_bin_hex = literal out of range for `{$ty}`\n+    .negative_note = the literal `{$lit}` (decimal `{$dec}`) does not fit into the type `{$ty}`\n+    .negative_becomes_note = and the value `-{$lit}` will become `{$actually}{$ty}`\n+    .positive_note = the literal `{$lit}` (decimal `{$dec}`) does not fit into the type `{$ty}` and will become `{$actually}{$ty}`\n+    .suggestion = consider using the type `{$suggestion_ty}` instead\n+    .help = consider using the type `{$suggestion_ty}` instead\n \n-lint_builtin_type_alias_bounds_help = use fully disambiguated paths (i.e., `<T as Trait>::Assoc`) to refer to associated types in type aliases\n+lint_overflowing_int = literal out of range for `{$ty}`\n+    .note = the literal `{$lit}` does not fit into the type `{$ty}` whose range is `{$min}..={$max}`\n+    .help = consider using the type `{$suggestion_ty}` instead\n \n-lint_builtin_type_alias_where_clause = where clauses are not enforced in type aliases\n-    .suggestion = the clause will not be checked when the type alias is used, and should be removed\n+lint_overflowing_literal = literal out of range for `{$ty}`\n+    .note = the literal `{$lit}` does not fit into the type `{$ty}` and will be converted to `{$ty}::INFINITY`\n \n-lint_builtin_type_alias_generic_bounds = bounds on generic parameters are not enforced in type aliases\n-    .suggestion = the bound will not be checked when the type alias is used, and should be removed\n+lint_overflowing_uint = literal out of range for `{$ty}`\n+    .note = the literal `{$lit}` does not fit into the type `{$ty}` whose range is `{$min}..={$max}`\n \n-lint_builtin_trivial_bounds = {$predicate_kind_name} bound {$predicate} does not depend on any type or lifetime parameters\n+lint_overruled_attribute = {$lint_level}({$lint_source}) incompatible with previous forbid\n+    .label = overruled by previous forbid\n \n-lint_builtin_ellipsis_inclusive_range_patterns = `...` range patterns are deprecated\n-    .suggestion = use `..=` for an inclusive range\n+lint_pass_by_value = passing `{$ty}` by reference\n+    .suggestion = try passing by value\n \n-lint_builtin_unnameable_test_items = cannot test inner items\n+lint_path_statement_drop = path statement drops value\n+    .suggestion = use `drop` to clarify the intent\n \n-lint_builtin_keyword_idents = `{$kw}` is a keyword in the {$next} edition\n-    .suggestion = you can use a raw identifier to stay compatible\n+lint_path_statement_no_effect = path statement with no effect\n \n-lint_builtin_explicit_outlives = outlives requirements can be inferred\n-    .suggestion = remove {$count ->\n-        [one] this bound\n-        *[other] these bounds\n-    }\n+lint_query_instability = using `{$query}` can result in unstable query results\n+    .note = if you believe this case to be fine, allow this lint and add a comment explaining your rationale\n \n-lint_builtin_incomplete_features = the feature `{$name}` is incomplete and may not be safe to use and/or cause compiler crashes\n-    .note = see issue #{$n} <https://github.com/rust-lang/rust/issues/{$n}> for more information\n-    .help = consider using `min_{$name}` instead, which is more stable and complete\n+lint_range_endpoint_out_of_range = range endpoint is out of range for `{$ty}`\n \n-lint_builtin_unpermitted_type_init_zeroed = the type `{$ty}` does not permit zero-initialization\n-lint_builtin_unpermitted_type_init_uninit = the type `{$ty}` does not permit being left uninitialized\n+lint_range_use_inclusive_range = use an inclusive range instead\n \n-lint_builtin_unpermitted_type_init_label = this code causes undefined behavior when executed\n-lint_builtin_unpermitted_type_init_label_suggestion = help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n \n-lint_builtin_clashing_extern_same_name = `{$this}` redeclared with a different signature\n-    .previous_decl_label = `{$orig}` previously declared here\n-    .mismatch_label = this signature doesn't match the previous declaration\n-lint_builtin_clashing_extern_diff_name = `{$this}` redeclares `{$orig}` with a different signature\n-    .previous_decl_label = `{$orig}` previously declared here\n-    .mismatch_label = this signature doesn't match the previous declaration\n+lint_reason_must_be_string_literal = reason must be a string literal\n \n-lint_builtin_deref_nullptr = dereferencing a null pointer\n-    .label = this code causes undefined behavior when executed\n+lint_reason_must_come_last = reason in lint attribute must come last\n \n-lint_builtin_asm_labels = avoid using named labels in inline assembly\n+lint_redundant_semicolons =\n+    unnecessary trailing {$multiple ->\n+        [true] semicolons\n+        *[false] semicolon\n+    }\n+    .suggestion = remove {$multiple ->\n+        [true] these semicolons\n+        *[false] this semicolon\n+    }\n \n-lint_builtin_special_module_name_used_lib = found module declaration for lib.rs\n-    .note = lib.rs is the root of this crate's library target\n-    .help = to refer to it from other targets, use the library's name as the path\n+lint_renamed_or_removed_lint = {$msg}\n+    .suggestion = use the new name\n \n-lint_builtin_special_module_name_used_main = found module declaration for main.rs\n-    .note = a binary crate cannot be used as library\n+lint_requested_level = requested on the command line with `{$level} {$lint_name}`\n \n lint_supertrait_as_deref_target = `{$t}` implements `Deref` with supertrait `{$target_principal}` as target\n     .label = target type is set here\n \n-lint_overruled_attribute = {$lint_level}({$lint_source}) incompatible with previous forbid\n-    .label = overruled by previous forbid\n+lint_suspicious_double_ref_op =\n+    using `.{$call}()` on a double reference, which returns `{$ty}` instead of {$op ->\n+        *[should_not_happen] [{$op}]\n+        [deref] dereferencing\n+        [borrow] borrowing\n+        [clone] cloning\n+    } the inner type\n \n-lint_default_source = `forbid` lint level is the default for {$id}\n+lint_trivial_untranslatable_diag = diagnostic with static strings only\n \n-lint_node_source = `forbid` level set here\n-    .note = {$reason}\n+lint_ty_qualified = usage of qualified `ty::{$ty}`\n+    .suggestion = try importing it and using it unqualified\n \n-lint_command_line_source = `forbid` lint level was set on command line\n+lint_tykind = usage of `ty::TyKind`\n+    .help = try using `Ty` instead\n \n-lint_malformed_attribute = malformed lint attribute input\n+lint_tykind_kind = usage of `ty::TyKind::<kind>`\n+    .suggestion = try using `ty::<kind>` directly\n \n-lint_bad_attribute_argument = bad attribute argument\n+lint_ungated_async_fn_track_caller = `#[track_caller]` on async functions is a no-op\n+     .label = this function will not propagate the caller location\n \n-lint_reason_must_be_string_literal = reason must be a string literal\n+lint_unknown_gated_lint =\n+    unknown lint: `{$name}`\n+    .note = the `{$name}` lint is unstable\n \n-lint_reason_must_come_last = reason in lint attribute must come last\n+lint_unknown_lint =\n+    unknown lint: `{$name}`\n+    .suggestion = did you mean\n \n lint_unknown_tool_in_scoped_lint = unknown tool name `{$tool_name}` found in scoped lint: `{$tool_name}::{$lint_name}`\n     .help = add `#![register_tool({$tool_name})]` to the crate root\n \n lint_unsupported_group = `{$lint_group}` lint group is not supported with \u00b4--force-warn\u00b4\n \n-lint_requested_level = requested on the command line with `{$level} {$lint_name}`\n+lint_untranslatable_diag = diagnostics should be created using translatable messages\n \n-lint_check_name_unknown = unknown lint: `{$lint_name}`\n-    .help = did you mean: `{$suggestion}`\n+lint_unused_allocation = unnecessary allocation, use `&` instead\n+lint_unused_allocation_mut = unnecessary allocation, use `&mut` instead\n \n-lint_check_name_unknown_tool = unknown lint tool: `{$tool_name}`\n+lint_unused_closure =\n+    unused {$pre}{$count ->\n+        [one] closure\n+        *[other] closures\n+    }{$post} that must be used\n+    .note = closures are lazy and do nothing unless called\n \n-lint_check_name_warning = {$msg}\n+lint_unused_comparisons = comparison is useless due to type limits\n \n-lint_check_name_deprecated = lint name `{$lint_name}` is deprecated and does not have an effect anymore. Use: {$new_name}\n+lint_unused_def = unused {$pre}`{$def}`{$post} that must be used\n+    .suggestion = use `let _ = ...` to ignore the resulting value\n \n-lint_opaque_hidden_inferred_bound = opaque type `{$ty}` does not satisfy its associated type bounds\n-    .specifically = this associated type bound is unsatisfied for `{$proj_ty}`\n+lint_unused_delim = unnecessary {$delim} around {$item}\n+    .suggestion = remove these {$delim}\n \n-lint_opaque_hidden_inferred_bound_sugg = add this bound\n+lint_unused_generator =\n+    unused {$pre}{$count ->\n+        [one] generator\n+        *[other] generator\n+    }{$post} that must be used\n+    .note = generators are lazy and do nothing unless resumed\n \n-lint_dropping_references = calls to `std::mem::drop` with a reference instead of an owned value does nothing\n-    .label = argument has type `{$arg_ty}`\n-    .note = use `let _ = ...` to ignore the expression or result\n+lint_unused_import_braces = braces around {$node} is unnecessary\n \n-lint_dropping_copy_types = calls to `std::mem::drop` with a value that implements `Copy` does nothing\n-    .label = argument has type `{$arg_ty}`\n-    .note = use `let _ = ...` to ignore the expression or result\n+lint_unused_op = unused {$op} that must be used\n+    .label = the {$op} produces a value\n+    .suggestion = use `let _ = ...` to ignore the resulting value\n \n-lint_forgetting_references = calls to `std::mem::forget` with a reference instead of an owned value does nothing\n-    .label = argument has type `{$arg_ty}`\n-    .note = use `let _ = ...` to ignore the expression or result\n+lint_unused_result = unused result of type `{$ty}`\n \n-lint_forgetting_copy_types = calls to `std::mem::forget` with a value that implements `Copy` does nothing\n-    .label = argument has type `{$arg_ty}`\n-    .note = use `let _ = ...` to ignore the expression or result\n+lint_variant_size_differences =\n+    enum variant is more than three times larger ({$largest} bytes) than the next largest"}, {"sha": "6d8601b9e2bc5e1ce4d1a936c22df3e91f94032a", "filename": "compiler/rustc_metadata/messages.ftl", "status": "modified", "additions": 191, "deletions": 191, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_metadata%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_metadata%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,288 +1,288 @@\n-metadata_rlib_required =\n-    crate `{$crate_name}` required to be available in rlib format, but was not found in this form\n-\n-metadata_lib_required =\n-    crate `{$crate_name}` required to be available in {$kind} format, but was not found in this form\n+metadata_as_needed_compatibility =\n+    linking modifier `as-needed` is only compatible with `dylib` and `framework` linking kinds\n \n-metadata_rustc_lib_required =\n-    crate `{$crate_name}` required to be available in {$kind} format, but was not found in this form\n-    .note = only .rmeta files are distributed for `rustc_private` crates other than `rustc_driver`\n-    .help = try adding `extern crate rustc_driver;` at the top level of this crate\n+metadata_bad_panic_strategy =\n+    the linked panic runtime `{$runtime}` is not compiled with this crate's panic strategy `{$strategy}`\n \n-metadata_crate_dep_multiple =\n-    cannot satisfy dependencies so `{$crate_name}` only shows up once\n-    .help = having upstream crates all available in one format will likely make this go away\n+metadata_bundle_needs_static =\n+    linking modifier `bundle` is only compatible with `static` linking kind\n \n-metadata_two_panic_runtimes =\n-    cannot link together two panic runtimes: {$prev_name} and {$cur_name}\n+metadata_cannot_find_crate =\n+    can't find crate for `{$crate_name}`{$add_info}\n \n-metadata_bad_panic_strategy =\n-    the linked panic runtime `{$runtime}` is not compiled with this crate's panic strategy `{$strategy}`\n+metadata_cant_find_crate =\n+    can't find crate\n \n-metadata_required_panic_strategy =\n-    the crate `{$crate_name}` requires panic strategy `{$found_strategy}` which is incompatible with this crate's strategy of `{$desired_strategy}`\n+metadata_compiler_missing_profiler =\n+    the compiler may have been built without the profiler runtime\n \n-metadata_incompatible_panic_in_drop_strategy =\n-    the crate `{$crate_name}` is compiled with the panic-in-drop strategy `{$found_strategy}` which is incompatible with this crate's strategy of `{$desired_strategy}`\n+metadata_conflicting_alloc_error_handler =\n+    the `#[alloc_error_handler]` in {$other_crate_name} conflicts with allocation error handler in: {$crate_name}\n \n-metadata_multiple_names_in_link =\n-    multiple `name` arguments in a single `#[link]` attribute\n+metadata_conflicting_global_alloc =\n+    the `#[global_allocator]` in {$other_crate_name} conflicts with global allocator in: {$crate_name}\n \n-metadata_multiple_kinds_in_link =\n-    multiple `kind` arguments in a single `#[link]` attribute\n+metadata_consider_building_std =\n+    consider building the standard library from source with `cargo build -Zbuild-std`\n \n-metadata_link_name_form =\n-    link name must be of the form `name = \"string\"`\n+metadata_consider_downloading_target =\n+    consider downloading the target with `rustup target add {$locator_triple}`\n \n-metadata_link_kind_form =\n-    link kind must be of the form `kind = \"string\"`\n+metadata_crate_dep_multiple =\n+    cannot satisfy dependencies so `{$crate_name}` only shows up once\n+    .help = having upstream crates all available in one format will likely make this go away\n \n-metadata_link_modifiers_form =\n-    link modifiers must be of the form `modifiers = \"string\"`\n+metadata_crate_location_unknown_type =\n+    extern location for {$crate_name} is of an unknown type: {$path}\n \n-metadata_link_cfg_form =\n-    link cfg must be of the form `cfg(/* predicate */)`\n+metadata_crate_not_panic_runtime =\n+    the crate `{$crate_name}` is not a panic runtime\n \n-metadata_wasm_import_form =\n-    wasm import module must be of the form `wasm_import_module = \"string\"`\n+metadata_dl_error =\n+    {$err}\n \n metadata_empty_link_name =\n     link name must not be empty\n     .label = empty link name\n \n-metadata_link_framework_apple =\n-    link kind `framework` is only supported on Apple targets\n+metadata_empty_renaming_target =\n+    an empty renaming target was specified for library `{$lib_name}`\n \n-metadata_framework_only_windows =\n-    link kind `raw-dylib` is only supported on Windows targets\n+metadata_extern_location_not_exist =\n+    extern location for {$crate_name} does not exist: {$location}\n \n-metadata_unknown_link_kind =\n-    unknown link kind `{$kind}`, expected one of: static, dylib, framework, raw-dylib\n-    .label = unknown link kind\n+metadata_extern_location_not_file =\n+    extern location for {$crate_name} is not a file: {$location}\n \n-metadata_multiple_link_modifiers =\n-    multiple `modifiers` arguments in a single `#[link]` attribute\n+metadata_fail_create_file_encoder =\n+    failed to create file encoder: {$err}\n \n-metadata_multiple_cfgs =\n-    multiple `cfg` arguments in a single `#[link]` attribute\n+metadata_fail_seek_file =\n+    failed to seek the file: {$err}\n \n-metadata_link_cfg_single_predicate =\n-    link cfg must have a single predicate argument\n+metadata_fail_write_file =\n+    failed to write to the file: {$err}\n \n-metadata_multiple_wasm_import =\n-    multiple `wasm_import_module` arguments in a single `#[link]` attribute\n+metadata_failed_create_encoded_metadata =\n+    failed to create encoded metadata from file: {$err}\n \n-metadata_unexpected_link_arg =\n-    unexpected `#[link]` argument, expected one of: name, kind, modifiers, cfg, wasm_import_module, import_name_type\n+metadata_failed_create_file =\n+    failed to create the file {$filename}: {$err}\n \n-metadata_invalid_link_modifier =\n-    invalid linking modifier syntax, expected '+' or '-' prefix before one of: bundle, verbatim, whole-archive, as-needed\n+metadata_failed_create_tempdir =\n+    couldn't create a temp dir: {$err}\n \n-metadata_multiple_modifiers =\n-    multiple `{$modifier}` modifiers in a single `modifiers` argument\n+metadata_failed_write_error =\n+    failed to write {$filename}: {$err}\n \n-metadata_bundle_needs_static =\n-    linking modifier `bundle` is only compatible with `static` linking kind\n+metadata_found_crate_versions =\n+    the following crate versions were found:{$found_crates}\n \n-metadata_whole_archive_needs_static =\n-    linking modifier `whole-archive` is only compatible with `static` linking kind\n+metadata_found_staticlib =\n+    found staticlib `{$crate_name}` instead of rlib or dylib{$add_info}\n+    .help = please recompile that crate using --crate-type lib\n \n-metadata_as_needed_compatibility =\n-    linking modifier `as-needed` is only compatible with `dylib` and `framework` linking kinds\n+metadata_framework_only_windows =\n+    link kind `raw-dylib` is only supported on Windows targets\n \n-metadata_unknown_link_modifier =\n-    unknown linking modifier `{$modifier}`, expected one of: bundle, verbatim, whole-archive, as-needed\n+metadata_global_alloc_required =\n+    no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait\n+\n+metadata_import_name_type_form =\n+    import name type must be of the form `import_name_type = \"string\"`\n+\n+metadata_import_name_type_raw =\n+    import name type can only be used with link kind `raw-dylib`\n+\n+metadata_import_name_type_x86 =\n+    import name type is only supported on x86\n+\n+metadata_incompatible_panic_in_drop_strategy =\n+    the crate `{$crate_name}` is compiled with the panic-in-drop strategy `{$found_strategy}` which is incompatible with this crate's strategy of `{$desired_strategy}`\n+\n+metadata_incompatible_rustc =\n+    found crate `{$crate_name}` compiled by an incompatible version of rustc{$add_info}\n+    .help = please recompile that crate using this compiler ({$rustc_version}) (consider running `cargo clean` first)\n \n metadata_incompatible_wasm_link =\n     `wasm_import_module` is incompatible with other arguments in `#[link]` attributes\n \n-metadata_link_requires_name =\n-    `#[link]` attribute requires a `name = \"string\"` argument\n-    .label = missing `name` argument\n+metadata_install_missing_components =\n+    maybe you need to install the missing components with: `rustup component add rust-src rustc-dev llvm-tools-preview`\n \n-metadata_raw_dylib_no_nul =\n-    link name must not contain NUL characters if link kind is `raw-dylib`\n+metadata_invalid_link_modifier =\n+    invalid linking modifier syntax, expected '+' or '-' prefix before one of: bundle, verbatim, whole-archive, as-needed\n \n-metadata_link_ordinal_raw_dylib =\n-    `#[link_ordinal]` is only supported if link kind is `raw-dylib`\n+metadata_invalid_meta_files =\n+    found invalid metadata files for crate `{$crate_name}`{$add_info}\n+\n+metadata_lib_filename_form =\n+    file name should be lib*.rlib or {$dll_prefix}*{$dll_suffix}\n \n metadata_lib_framework_apple =\n     library kind `framework` is only supported on Apple targets\n \n-metadata_empty_renaming_target =\n-    an empty renaming target was specified for library `{$lib_name}`\n+metadata_lib_required =\n+    crate `{$crate_name}` required to be available in {$kind} format, but was not found in this form\n \n-metadata_renaming_no_link =\n-    renaming of the library `{$lib_name}` was specified, however this crate contains no `#[link(...)]` attributes referencing this library\n+metadata_link_cfg_form =\n+    link cfg must be of the form `cfg(/* predicate */)`\n \n-metadata_multiple_renamings =\n-    multiple renamings were specified for library `{$lib_name}`\n+metadata_link_cfg_single_predicate =\n+    link cfg must have a single predicate argument\n \n-metadata_no_link_mod_override =\n-    overriding linking modifiers from command line is not supported\n+metadata_link_framework_apple =\n+    link kind `framework` is only supported on Apple targets\n \n-metadata_unsupported_abi_i686 =\n-    ABI not supported by `#[link(kind = \"raw-dylib\")]` on i686\n+metadata_link_kind_form =\n+    link kind must be of the form `kind = \"string\"`\n \n-metadata_unsupported_abi =\n-    ABI not supported by `#[link(kind = \"raw-dylib\")]` on this architecture\n+metadata_link_modifiers_form =\n+    link modifiers must be of the form `modifiers = \"string\"`\n \n-metadata_fail_create_file_encoder =\n-    failed to create file encoder: {$err}\n+metadata_link_name_form =\n+    link name must be of the form `name = \"string\"`\n \n-metadata_fail_seek_file =\n-    failed to seek the file: {$err}\n+metadata_link_ordinal_raw_dylib =\n+    `#[link_ordinal]` is only supported if link kind is `raw-dylib`\n \n-metadata_fail_write_file =\n-    failed to write to the file: {$err}\n+metadata_link_requires_name =\n+    `#[link]` attribute requires a `name = \"string\"` argument\n+    .label = missing `name` argument\n \n-metadata_crate_not_panic_runtime =\n-    the crate `{$crate_name}` is not a panic runtime\n+metadata_missing_native_library =\n+    could not find native static library `{$libname}`, perhaps an -L flag is missing?\n \n-metadata_no_panic_strategy =\n-    the crate `{$crate_name}` does not have the panic strategy `{$strategy}`\n+metadata_multiple_candidates =\n+    multiple candidates for `{$flavor}` dependency `{$crate_name}` found\n \n-metadata_profiler_builtins_needs_core =\n-    `profiler_builtins` crate (required by compiler options) is not compatible with crate attribute `#![no_core]`\n+metadata_multiple_cfgs =\n+    multiple `cfg` arguments in a single `#[link]` attribute\n \n-metadata_not_profiler_runtime =\n-    the crate `{$crate_name}` is not a profiler runtime\n+metadata_multiple_import_name_type =\n+    multiple `import_name_type` arguments in a single `#[link]` attribute\n \n-metadata_no_multiple_global_alloc =\n-    cannot define multiple global allocators\n-    .label = cannot define a new global allocator\n+metadata_multiple_kinds_in_link =\n+    multiple `kind` arguments in a single `#[link]` attribute\n \n-metadata_prev_global_alloc =\n-    previous global allocator defined here\n+metadata_multiple_link_modifiers =\n+    multiple `modifiers` arguments in a single `#[link]` attribute\n \n-metadata_no_multiple_alloc_error_handler =\n-    cannot define multiple allocation error handlers\n-    .label = cannot define a new allocation error handler\n+metadata_multiple_modifiers =\n+    multiple `{$modifier}` modifiers in a single `modifiers` argument\n \n-metadata_prev_alloc_error_handler =\n-    previous allocation error handler defined here\n+metadata_multiple_names_in_link =\n+    multiple `name` arguments in a single `#[link]` attribute\n \n-metadata_conflicting_global_alloc =\n-    the `#[global_allocator]` in {$other_crate_name} conflicts with global allocator in: {$crate_name}\n+metadata_multiple_renamings =\n+    multiple renamings were specified for library `{$lib_name}`\n \n-metadata_conflicting_alloc_error_handler =\n-    the `#[alloc_error_handler]` in {$other_crate_name} conflicts with allocation error handler in: {$crate_name}\n+metadata_multiple_wasm_import =\n+    multiple `wasm_import_module` arguments in a single `#[link]` attribute\n \n-metadata_global_alloc_required =\n-    no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait\n+metadata_newer_crate_version =\n+    found possibly newer version of crate `{$crate_name}`{$add_info}\n+    .note = perhaps that crate needs to be recompiled?\n \n-metadata_no_transitive_needs_dep =\n-    the crate `{$crate_name}` cannot depend on a crate that needs {$needs_crate_name}, but it depends on `{$deps_crate_name}`\n+metadata_no_crate_with_triple =\n+    couldn't find crate `{$crate_name}` with expected target triple {$locator_triple}{$add_info}\n \n-metadata_failed_write_error =\n-    failed to write {$filename}: {$err}\n+metadata_no_dylib_plugin =\n+    plugin `{$crate_name}` only found in rlib format, but must be available in dylib format\n \n-metadata_missing_native_library =\n-    could not find native static library `{$libname}`, perhaps an -L flag is missing?\n+metadata_no_link_mod_override =\n+    overriding linking modifiers from command line is not supported\n \n-metadata_only_provide_library_name = only provide the library name `{$suggested_name}`, not the full filename\n+metadata_no_multiple_alloc_error_handler =\n+    cannot define multiple allocation error handlers\n+    .label = cannot define a new allocation error handler\n \n-metadata_failed_create_tempdir =\n-    couldn't create a temp dir: {$err}\n+metadata_no_multiple_global_alloc =\n+    cannot define multiple global allocators\n+    .label = cannot define a new global allocator\n \n-metadata_failed_create_file =\n-    failed to create the file {$filename}: {$err}\n+metadata_no_panic_strategy =\n+    the crate `{$crate_name}` does not have the panic strategy `{$strategy}`\n \n-metadata_failed_create_encoded_metadata =\n-    failed to create encoded metadata from file: {$err}\n+metadata_no_transitive_needs_dep =\n+    the crate `{$crate_name}` cannot depend on a crate that needs {$needs_crate_name}, but it depends on `{$deps_crate_name}`\n \n metadata_non_ascii_name =\n     cannot load a crate with a non-ascii name `{$crate_name}`\n \n-metadata_extern_location_not_exist =\n-    extern location for {$crate_name} does not exist: {$location}\n-\n-metadata_extern_location_not_file =\n-    extern location for {$crate_name} is not a file: {$location}\n-\n-metadata_multiple_candidates =\n-    multiple candidates for `{$flavor}` dependency `{$crate_name}` found\n+metadata_not_profiler_runtime =\n+    the crate `{$crate_name}` is not a profiler runtime\n \n-metadata_symbol_conflicts_current =\n-    the current crate is indistinguishable from one of its dependencies: it has the same crate-name `{$crate_name}` and was compiled with the same `-C metadata` arguments. This will result in symbol conflicts between the two.\n+metadata_only_provide_library_name = only provide the library name `{$suggested_name}`, not the full filename\n \n-metadata_symbol_conflicts_others =\n-    found two different crates with name `{$crate_name}` that are not distinguished by differing `-C metadata`. This will result in symbol conflicts between the two.\n+metadata_prev_alloc_error_handler =\n+    previous allocation error handler defined here\n \n-metadata_stable_crate_id_collision =\n-    found crates (`{$crate_name0}` and `{$crate_name1}`) with colliding StableCrateId values.\n+metadata_prev_global_alloc =\n+    previous global allocator defined here\n \n-metadata_dl_error =\n-    {$err}\n+metadata_profiler_builtins_needs_core =\n+    `profiler_builtins` crate (required by compiler options) is not compatible with crate attribute `#![no_core]`\n \n-metadata_newer_crate_version =\n-    found possibly newer version of crate `{$crate_name}`{$add_info}\n-    .note = perhaps that crate needs to be recompiled?\n+metadata_raw_dylib_no_nul =\n+    link name must not contain NUL characters if link kind is `raw-dylib`\n \n-metadata_found_crate_versions =\n-    the following crate versions were found:{$found_crates}\n+metadata_renaming_no_link =\n+    renaming of the library `{$lib_name}` was specified, however this crate contains no `#[link(...)]` attributes referencing this library\n \n-metadata_no_crate_with_triple =\n-    couldn't find crate `{$crate_name}` with expected target triple {$locator_triple}{$add_info}\n+metadata_required_panic_strategy =\n+    the crate `{$crate_name}` requires panic strategy `{$found_strategy}` which is incompatible with this crate's strategy of `{$desired_strategy}`\n \n-metadata_found_staticlib =\n-    found staticlib `{$crate_name}` instead of rlib or dylib{$add_info}\n-    .help = please recompile that crate using --crate-type lib\n+metadata_rlib_required =\n+    crate `{$crate_name}` required to be available in rlib format, but was not found in this form\n \n-metadata_incompatible_rustc =\n-    found crate `{$crate_name}` compiled by an incompatible version of rustc{$add_info}\n-    .help = please recompile that crate using this compiler ({$rustc_version}) (consider running `cargo clean` first)\n+metadata_rustc_lib_required =\n+    crate `{$crate_name}` required to be available in {$kind} format, but was not found in this form\n+    .note = only .rmeta files are distributed for `rustc_private` crates other than `rustc_driver`\n+    .help = try adding `extern crate rustc_driver;` at the top level of this crate\n \n-metadata_invalid_meta_files =\n-    found invalid metadata files for crate `{$crate_name}`{$add_info}\n+metadata_stable_crate_id_collision =\n+    found crates (`{$crate_name0}` and `{$crate_name1}`) with colliding StableCrateId values.\n \n-metadata_cannot_find_crate =\n-    can't find crate for `{$crate_name}`{$add_info}\n+metadata_std_required =\n+    `std` is required by `{$current_crate}` because it does not declare `#![no_std]`\n \n-metadata_no_dylib_plugin =\n-    plugin `{$crate_name}` only found in rlib format, but must be available in dylib format\n+metadata_symbol_conflicts_current =\n+    the current crate is indistinguishable from one of its dependencies: it has the same crate-name `{$crate_name}` and was compiled with the same `-C metadata` arguments. This will result in symbol conflicts between the two.\n \n-metadata_target_not_installed =\n-    the `{$locator_triple}` target may not be installed\n+metadata_symbol_conflicts_others =\n+    found two different crates with name `{$crate_name}` that are not distinguished by differing `-C metadata`. This will result in symbol conflicts between the two.\n \n metadata_target_no_std_support =\n     the `{$locator_triple}` target may not support the standard library\n \n-metadata_consider_downloading_target =\n-    consider downloading the target with `rustup target add {$locator_triple}`\n-\n-metadata_std_required =\n-    `std` is required by `{$current_crate}` because it does not declare `#![no_std]`\n-\n-metadata_consider_building_std =\n-    consider building the standard library from source with `cargo build -Zbuild-std`\n-\n-metadata_compiler_missing_profiler =\n-    the compiler may have been built without the profiler runtime\n+metadata_target_not_installed =\n+    the `{$locator_triple}` target may not be installed\n \n-metadata_install_missing_components =\n-    maybe you need to install the missing components with: `rustup component add rust-src rustc-dev llvm-tools-preview`\n+metadata_two_panic_runtimes =\n+    cannot link together two panic runtimes: {$prev_name} and {$cur_name}\n \n-metadata_cant_find_crate =\n-    can't find crate\n+metadata_unexpected_link_arg =\n+    unexpected `#[link]` argument, expected one of: name, kind, modifiers, cfg, wasm_import_module, import_name_type\n \n-metadata_crate_location_unknown_type =\n-    extern location for {$crate_name} is of an unknown type: {$path}\n+metadata_unknown_import_name_type =\n+    unknown import name type `{$import_name_type}`, expected one of: decorated, noprefix, undecorated\n \n-metadata_lib_filename_form =\n-    file name should be lib*.rlib or {$dll_prefix}*{$dll_suffix}\n+metadata_unknown_link_kind =\n+    unknown link kind `{$kind}`, expected one of: static, dylib, framework, raw-dylib\n+    .label = unknown link kind\n \n-metadata_multiple_import_name_type =\n-    multiple `import_name_type` arguments in a single `#[link]` attribute\n+metadata_unknown_link_modifier =\n+    unknown linking modifier `{$modifier}`, expected one of: bundle, verbatim, whole-archive, as-needed\n \n-metadata_import_name_type_form =\n-    import name type must be of the form `import_name_type = \"string\"`\n+metadata_unsupported_abi =\n+    ABI not supported by `#[link(kind = \"raw-dylib\")]` on this architecture\n \n-metadata_import_name_type_x86 =\n-    import name type is only supported on x86\n+metadata_unsupported_abi_i686 =\n+    ABI not supported by `#[link(kind = \"raw-dylib\")]` on i686\n \n-metadata_unknown_import_name_type =\n-    unknown import name type `{$import_name_type}`, expected one of: decorated, noprefix, undecorated\n+metadata_wasm_import_form =\n+    wasm import module must be of the form `wasm_import_module = \"string\"`\n \n-metadata_import_name_type_raw =\n-    import name type can only be used with link kind `raw-dylib`\n+metadata_whole_archive_needs_static =\n+    linking modifier `whole-archive` is only compatible with `static` linking kind"}, {"sha": "3d581daa9259d2ffa11cea81f11e858af8e029a5", "filename": "compiler/rustc_middle/messages.ftl", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_middle%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_middle%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,45 +1,45 @@\n+middle_cannot_be_normalized =\n+    unable to determine layout for `{$ty}` because `{$failure_ty}` cannot be normalized\n+\n+middle_conflict_types =\n+    this expression supplies two conflicting concrete types for the same opaque type\n+\n+middle_const_eval_non_int =\n+    constant evaluation of enum discriminant resulted in non-integer\n+\n+middle_const_not_used_in_type_alias =\n+    const parameter `{$ct}` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n+\n+middle_cycle =\n+    a cycle occurred during layout computation\n+\n middle_drop_check_overflow =\n     overflow while adding drop-check rules for {$ty}\n     .note = overflowed on {$overflow_ty}\n \n+middle_limit_invalid =\n+    `limit` must be a non-negative integer\n+    .label = {$error_str}\n+\n middle_opaque_hidden_type_mismatch =\n     concrete type differs from previous defining opaque type use\n     .label = expected `{$self_ty}`, got `{$other_ty}`\n \n-middle_conflict_types =\n-    this expression supplies two conflicting concrete types for the same opaque type\n-\n middle_previous_use_here =\n     previous use here\n \n-middle_limit_invalid =\n-    `limit` must be a non-negative integer\n-    .label = {$error_str}\n-\n middle_recursion_limit_reached =\n     reached the recursion limit finding the struct tail for `{$ty}`\n     .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]`\n \n-middle_const_eval_non_int =\n-    constant evaluation of enum discriminant resulted in non-integer\n-\n-middle_unknown_layout =\n-    the type `{$ty}` has an unknown layout\n-\n-middle_values_too_big =\n-    values of the type `{$ty}` are too big for the current architecture\n-\n-middle_cannot_be_normalized =\n-    unable to determine layout for `{$ty}` because `{$failure_ty}` cannot be normalized\n-\n-middle_cycle =\n-    a cycle occurred during layout computation\n+middle_requires_lang_item = requires `{$name}` lang_item\n \n middle_strict_coherence_needs_negative_coherence =\n     to use `strict_coherence` on this trait, the `with_negative_coherence` feature must be enabled\n     .label = due to this attribute\n \n-middle_requires_lang_item = requires `{$name}` lang_item\n+middle_unknown_layout =\n+    the type `{$ty}` has an unknown layout\n \n-middle_const_not_used_in_type_alias =\n-    const parameter `{$ct}` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n+middle_values_too_big =\n+    values of the type `{$ty}` are too big for the current architecture"}, {"sha": "cb265cf2c6acb696bfd2de1d3a75dfd0dc6a49d8", "filename": "compiler/rustc_mir_build/messages.ftl", "status": "modified", "additions": 239, "deletions": 239, "changes": 478, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_mir_build%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_mir_build%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,62 +1,40 @@\n-mir_build_unconditional_recursion = function cannot return without recursing\n-    .label = cannot return without recursing\n-    .help = a `loop` may express intention better if this is on purpose\n-\n-mir_build_unconditional_recursion_call_site_label = recursive call site\n-\n-mir_build_unsafe_op_in_unsafe_fn_call_to_unsafe_fn_requires_unsafe =\n-    call to unsafe function `{$function}` is unsafe and requires unsafe block (error E0133)\n-    .note = consult the function's documentation for information on how to avoid undefined behavior\n-    .label = call to unsafe function\n-\n-mir_build_unsafe_op_in_unsafe_fn_call_to_unsafe_fn_requires_unsafe_nameless =\n-    call to unsafe function is unsafe and requires unsafe block (error E0133)\n-    .note = consult the function's documentation for information on how to avoid undefined behavior\n-    .label = call to unsafe function\n-\n-mir_build_unsafe_op_in_unsafe_fn_inline_assembly_requires_unsafe =\n-    use of inline assembly is unsafe and requires unsafe block (error E0133)\n-    .note = inline assembly is entirely unchecked and can cause undefined behavior\n-    .label = use of inline assembly\n+mir_build_adt_defined_here = `{$ty}` defined here\n \n-mir_build_unsafe_op_in_unsafe_fn_initializing_type_with_requires_unsafe =\n-    initializing type with `rustc_layout_scalar_valid_range` attr is unsafe and requires unsafe\n-    block (error E0133)\n-    .note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n-    .label = initializing type with `rustc_layout_scalar_valid_range` attr\n+mir_build_already_borrowed = cannot borrow value as mutable because it is also borrowed as immutable\n \n-mir_build_unsafe_op_in_unsafe_fn_mutable_static_requires_unsafe =\n-    use of mutable static is unsafe and requires unsafe block (error E0133)\n-    .note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n-    .label = use of mutable static\n+mir_build_already_mut_borrowed = cannot borrow value as immutable because it is also borrowed as mutable\n \n-mir_build_unsafe_op_in_unsafe_fn_extern_static_requires_unsafe =\n-    use of extern static is unsafe and requires unsafe block (error E0133)\n-    .note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n-    .label = use of extern static\n+mir_build_assoc_const_in_pattern = associated consts cannot be referenced in patterns\n \n-mir_build_unsafe_op_in_unsafe_fn_deref_raw_pointer_requires_unsafe =\n-    dereference of raw pointer is unsafe and requires unsafe block (error E0133)\n-    .note = raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n-    .label = dereference of raw pointer\n+mir_build_bindings_with_variant_name =\n+    pattern binding `{$name}` is named the same as one of the variants of the type `{$ty_path}`\n+    .suggestion = to match on the variant, qualify the path\n \n-mir_build_unsafe_op_in_unsafe_fn_union_field_requires_unsafe =\n-    access to union field is unsafe and requires unsafe block (error E0133)\n-    .note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n-    .label = access to union field\n+mir_build_borrow = value is borrowed by `{$name}` here\n \n-mir_build_unsafe_op_in_unsafe_fn_mutation_of_layout_constrained_field_requires_unsafe =\n-    mutation of layout constrained field is unsafe and requires unsafe block (error E0133)\n-    .note = mutating layout constrained fields cannot statically be checked for valid values\n-    .label = mutation of layout constrained field\n+mir_build_borrow_of_layout_constrained_field_requires_unsafe =\n+    borrow of layout constrained field with interior mutability is unsafe and requires unsafe block\n+    .note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n+    .label = borrow of layout constrained field with interior mutability\n \n-mir_build_unsafe_op_in_unsafe_fn_borrow_of_layout_constrained_field_requires_unsafe =\n-    borrow of layout constrained field with interior mutability is unsafe and requires unsafe block (error E0133)\n+mir_build_borrow_of_layout_constrained_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    borrow of layout constrained field with interior mutability is unsafe and requires unsafe function or block\n     .note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n     .label = borrow of layout constrained field with interior mutability\n \n-mir_build_unsafe_op_in_unsafe_fn_call_to_fn_with_requires_unsafe =\n-    call to function `{$function}` with `#[target_feature]` is unsafe and requires unsafe block (error E0133)\n+mir_build_borrow_of_moved_value = borrow of moved value\n+    .label = value moved into `{$name}` here\n+    .occurs_because_label = move occurs because `{$name}` has type `{$ty}` which does not implement the `Copy` trait\n+    .value_borrowed_label = value borrowed here after move\n+    .suggestion = borrow this binding in the pattern to avoid moving the value\n+\n+mir_build_call_to_fn_with_requires_unsafe =\n+    call to function `{$function}` with `#[target_feature]` is unsafe and requires unsafe block\n+    .note = can only be called if the required target features are available\n+    .label = call to function with `#[target_feature]`\n+\n+mir_build_call_to_fn_with_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    call to function `{$function}` with `#[target_feature]` is unsafe and requires unsafe function or block\n     .note = can only be called if the required target features are available\n     .label = call to function with `#[target_feature]`\n \n@@ -70,55 +48,24 @@ mir_build_call_to_unsafe_fn_requires_unsafe_nameless =\n     .note = consult the function's documentation for information on how to avoid undefined behavior\n     .label = call to unsafe function\n \n-mir_build_call_to_unsafe_fn_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n-    call to unsafe function `{$function}` is unsafe and requires unsafe function or block\n-    .note = consult the function's documentation for information on how to avoid undefined behavior\n-    .label = call to unsafe function\n-\n mir_build_call_to_unsafe_fn_requires_unsafe_nameless_unsafe_op_in_unsafe_fn_allowed =\n     call to unsafe function is unsafe and requires unsafe function or block\n     .note = consult the function's documentation for information on how to avoid undefined behavior\n     .label = call to unsafe function\n \n-mir_build_inline_assembly_requires_unsafe =\n-    use of inline assembly is unsafe and requires unsafe block\n-    .note = inline assembly is entirely unchecked and can cause undefined behavior\n-    .label = use of inline assembly\n-\n-mir_build_inline_assembly_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n-    use of inline assembly is unsafe and requires unsafe function or block\n-    .note = inline assembly is entirely unchecked and can cause undefined behavior\n-    .label = use of inline assembly\n-\n-mir_build_initializing_type_with_requires_unsafe =\n-    initializing type with `rustc_layout_scalar_valid_range` attr is unsafe and requires unsafe block\n-    .note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n-    .label = initializing type with `rustc_layout_scalar_valid_range` attr\n-\n-mir_build_initializing_type_with_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n-    initializing type with `rustc_layout_scalar_valid_range` attr is unsafe and requires unsafe function or block\n-    .note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n-    .label = initializing type with `rustc_layout_scalar_valid_range` attr\n+mir_build_call_to_unsafe_fn_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    call to unsafe function `{$function}` is unsafe and requires unsafe function or block\n+    .note = consult the function's documentation for information on how to avoid undefined behavior\n+    .label = call to unsafe function\n \n-mir_build_mutable_static_requires_unsafe =\n-    use of mutable static is unsafe and requires unsafe block\n-    .note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n-    .label = use of mutable static\n+mir_build_confused = missing patterns are not covered because `{$variable}` is interpreted as a constant pattern, not a new variable\n \n-mir_build_mutable_static_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n-    use of mutable static is unsafe and requires unsafe function or block\n-    .note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n-    .label = use of mutable static\n+mir_build_const_param_in_pattern = const parameters cannot be referenced in patterns\n \n-mir_build_extern_static_requires_unsafe =\n-    use of extern static is unsafe and requires unsafe block\n-    .note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n-    .label = use of extern static\n+mir_build_const_pattern_depends_on_generic_parameter =\n+    constant pattern depends on a generic parameter\n \n-mir_build_extern_static_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n-    use of extern static is unsafe and requires unsafe function or block\n-    .note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n-    .label = use of extern static\n+mir_build_could_not_eval_const_pattern = could not evaluate constant pattern\n \n mir_build_deref_raw_pointer_requires_unsafe =\n     dereference of raw pointer is unsafe and requires unsafe block\n@@ -130,117 +77,46 @@ mir_build_deref_raw_pointer_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n     .note = raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n     .label = dereference of raw pointer\n \n-mir_build_union_field_requires_unsafe =\n-    access to union field is unsafe and requires unsafe block\n-    .note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n-    .label = access to union field\n-\n-mir_build_union_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n-    access to union field is unsafe and requires unsafe function or block\n-    .note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n-    .label = access to union field\n-\n-mir_build_mutation_of_layout_constrained_field_requires_unsafe =\n-    mutation of layout constrained field is unsafe and requires unsafe block\n-    .note = mutating layout constrained fields cannot statically be checked for valid values\n-    .label = mutation of layout constrained field\n-\n-mir_build_mutation_of_layout_constrained_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n-    mutation of layout constrained field is unsafe and requires unsafe function or block\n-    .note = mutating layout constrained fields cannot statically be checked for valid values\n-    .label = mutation of layout constrained field\n-\n-mir_build_borrow_of_layout_constrained_field_requires_unsafe =\n-    borrow of layout constrained field with interior mutability is unsafe and requires unsafe block\n-    .note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n-    .label = borrow of layout constrained field with interior mutability\n-\n-mir_build_borrow_of_layout_constrained_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n-    borrow of layout constrained field with interior mutability is unsafe and requires unsafe function or block\n-    .note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n-    .label = borrow of layout constrained field with interior mutability\n-\n-mir_build_call_to_fn_with_requires_unsafe =\n-    call to function `{$function}` with `#[target_feature]` is unsafe and requires unsafe block\n-    .note = can only be called if the required target features are available\n-    .label = call to function with `#[target_feature]`\n-\n-mir_build_call_to_fn_with_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n-    call to function `{$function}` with `#[target_feature]` is unsafe and requires unsafe function or block\n-    .note = can only be called if the required target features are available\n-    .label = call to function with `#[target_feature]`\n-\n-mir_build_unused_unsafe = unnecessary `unsafe` block\n-    .label = unnecessary `unsafe` block\n-\n-mir_build_unused_unsafe_enclosing_block_label = because it's nested under this `unsafe` block\n-mir_build_unused_unsafe_enclosing_fn_label = because it's nested under this `unsafe` fn\n-\n-mir_build_non_exhaustive_patterns_type_not_empty = non-exhaustive patterns: type `{$ty}` is non-empty\n-    .def_note = `{$peeled_ty}` defined here\n-    .type_note = the matched value is of type `{$ty}`\n-    .non_exhaustive_type_note = the matched value is of type `{$ty}`, which is marked as non-exhaustive\n-    .reference_note = references are always considered inhabited\n-    .suggestion = ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n-    .help = ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n-\n-mir_build_static_in_pattern = statics cannot be referenced in patterns\n-\n-mir_build_assoc_const_in_pattern = associated consts cannot be referenced in patterns\n-\n-mir_build_const_param_in_pattern = const parameters cannot be referenced in patterns\n+mir_build_extern_static_requires_unsafe =\n+    use of extern static is unsafe and requires unsafe block\n+    .note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n+    .label = use of extern static\n \n-mir_build_non_const_path = runtime values cannot be referenced in patterns\n+mir_build_extern_static_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    use of extern static is unsafe and requires unsafe function or block\n+    .note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n+    .label = use of extern static\n \n-mir_build_unreachable_pattern = unreachable pattern\n-    .label = unreachable pattern\n-    .catchall_label = matches any value\n+mir_build_float_pattern = floating-point types cannot be used in patterns\n \n-mir_build_const_pattern_depends_on_generic_parameter =\n-    constant pattern depends on a generic parameter\n+mir_build_indirect_structural_match =\n+    to use a constant of type `{$non_sm_ty}` in a pattern, `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n \n-mir_build_could_not_eval_const_pattern = could not evaluate constant pattern\n+mir_build_inform_irrefutable = `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n \n-mir_build_lower_range_bound_must_be_less_than_or_equal_to_upper =\n-    lower range bound must be less than or equal to upper\n-    .label = lower bound larger than upper bound\n-    .teach_note = When matching against a range, the compiler verifies that the range is non-empty. Range patterns include both end-points, so this is equivalent to requiring the start of the range to be less than or equal to the end of the range.\n+mir_build_initializing_type_with_requires_unsafe =\n+    initializing type with `rustc_layout_scalar_valid_range` attr is unsafe and requires unsafe block\n+    .note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n+    .label = initializing type with `rustc_layout_scalar_valid_range` attr\n \n-mir_build_literal_in_range_out_of_bounds =\n-    literal out of range for `{$ty}`\n-    .label = this value doesn't fit in `{$ty}` whose maximum value is `{$max}`\n+mir_build_initializing_type_with_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    initializing type with `rustc_layout_scalar_valid_range` attr is unsafe and requires unsafe function or block\n+    .note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n+    .label = initializing type with `rustc_layout_scalar_valid_range` attr\n \n-mir_build_lower_range_bound_must_be_less_than_upper = lower range bound must be less than upper\n+mir_build_inline_assembly_requires_unsafe =\n+    use of inline assembly is unsafe and requires unsafe block\n+    .note = inline assembly is entirely unchecked and can cause undefined behavior\n+    .label = use of inline assembly\n \n-mir_build_leading_irrefutable_let_patterns = leading irrefutable {$count ->\n-        [one] pattern\n-        *[other] patterns\n-    } in let chain\n-    .note = {$count ->\n-        [one] this pattern\n-        *[other] these patterns\n-    } will always match\n-    .help = consider moving {$count ->\n-        [one] it\n-        *[other] them\n-    } outside of the construct\n+mir_build_inline_assembly_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    use of inline assembly is unsafe and requires unsafe function or block\n+    .note = inline assembly is entirely unchecked and can cause undefined behavior\n+    .label = use of inline assembly\n \n-mir_build_trailing_irrefutable_let_patterns = trailing irrefutable {$count ->\n-        [one] pattern\n-        *[other] patterns\n-    } in let chain\n-    .note = {$count ->\n-        [one] this pattern\n-        *[other] these patterns\n-    } will always match\n-    .help = consider moving {$count ->\n-        [one] it\n-        *[other] them\n-    } into the body\n+mir_build_interpreted_as_const = introduce a variable instead\n \n-mir_build_bindings_with_variant_name =\n-    pattern binding `{$name}` is named the same as one of the variants of the type `{$ty_path}`\n-    .suggestion = to match on the variant, qualify the path\n+mir_build_invalid_pattern = `{$non_sm_ty}` cannot be used in patterns\n \n mir_build_irrefutable_let_patterns_if_let = irrefutable `if let` {$count ->\n         [one] pattern\n@@ -282,80 +158,97 @@ mir_build_irrefutable_let_patterns_while_let = irrefutable `while let` {$count -\n     } will always match, so the loop will never exit\n     .help = consider instead using a `loop {\"{\"} ... {\"}\"}` with a `let` inside it\n \n-mir_build_borrow_of_moved_value = borrow of moved value\n-    .label = value moved into `{$name}` here\n-    .occurs_because_label = move occurs because `{$name}` has type `{$ty}` which does not implement the `Copy` trait\n-    .value_borrowed_label = value borrowed here after move\n-    .suggestion = borrow this binding in the pattern to avoid moving the value\n+mir_build_leading_irrefutable_let_patterns = leading irrefutable {$count ->\n+        [one] pattern\n+        *[other] patterns\n+    } in let chain\n+    .note = {$count ->\n+        [one] this pattern\n+        *[other] these patterns\n+    } will always match\n+    .help = consider moving {$count ->\n+        [one] it\n+        *[other] them\n+    } outside of the construct\n \n-mir_build_multiple_mut_borrows = cannot borrow value as mutable more than once at a time\n+mir_build_literal_in_range_out_of_bounds =\n+    literal out of range for `{$ty}`\n+    .label = this value doesn't fit in `{$ty}` whose maximum value is `{$max}`\n \n-mir_build_already_borrowed = cannot borrow value as mutable because it is also borrowed as immutable\n+mir_build_lower_range_bound_must_be_less_than_or_equal_to_upper =\n+    lower range bound must be less than or equal to upper\n+    .label = lower bound larger than upper bound\n+    .teach_note = When matching against a range, the compiler verifies that the range is non-empty. Range patterns include both end-points, so this is equivalent to requiring the start of the range to be less than or equal to the end of the range.\n \n-mir_build_already_mut_borrowed = cannot borrow value as immutable because it is also borrowed as mutable\n+mir_build_lower_range_bound_must_be_less_than_upper = lower range bound must be less than upper\n \n-mir_build_moved_while_borrowed = cannot move out of value because it is borrowed\n+mir_build_more_information = for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n \n-mir_build_mutable_borrow = value is mutably borrowed by `{$name}` here\n+mir_build_moved = value is moved into `{$name}` here\n \n-mir_build_borrow = value is borrowed by `{$name}` here\n+mir_build_moved_while_borrowed = cannot move out of value because it is borrowed\n \n-mir_build_moved = value is moved into `{$name}` here\n+mir_build_multiple_mut_borrows = cannot borrow value as mutable more than once at a time\n \n-mir_build_union_pattern = cannot use unions in constant patterns\n+mir_build_mutable_borrow = value is mutably borrowed by `{$name}` here\n \n-mir_build_type_not_structural =\n-     to use a constant of type `{$non_sm_ty}` in a pattern, `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n+mir_build_mutable_static_requires_unsafe =\n+    use of mutable static is unsafe and requires unsafe block\n+    .note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n+    .label = use of mutable static\n \n-mir_build_unsized_pattern = cannot use unsized non-slice type `{$non_sm_ty}` in constant patterns\n+mir_build_mutable_static_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    use of mutable static is unsafe and requires unsafe function or block\n+    .note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n+    .label = use of mutable static\n \n-mir_build_invalid_pattern = `{$non_sm_ty}` cannot be used in patterns\n+mir_build_mutation_of_layout_constrained_field_requires_unsafe =\n+    mutation of layout constrained field is unsafe and requires unsafe block\n+    .note = mutating layout constrained fields cannot statically be checked for valid values\n+    .label = mutation of layout constrained field\n \n-mir_build_float_pattern = floating-point types cannot be used in patterns\n+mir_build_mutation_of_layout_constrained_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    mutation of layout constrained field is unsafe and requires unsafe function or block\n+    .note = mutating layout constrained fields cannot statically be checked for valid values\n+    .label = mutation of layout constrained field\n \n-mir_build_pointer_pattern = function pointers and unsized pointers in patterns behave unpredictably and should not be relied upon. See https://github.com/rust-lang/rust/issues/70861 for details.\n+mir_build_non_const_path = runtime values cannot be referenced in patterns\n \n-mir_build_indirect_structural_match =\n-    to use a constant of type `{$non_sm_ty}` in a pattern, `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n+mir_build_non_exhaustive_omitted_pattern = some variants are not matched explicitly\n+    .help = ensure that all variants are matched explicitly by adding the suggested match arms\n+    .note = the matched value is of type `{$scrut_ty}` and the `non_exhaustive_omitted_patterns` attribute was found\n+\n+mir_build_non_exhaustive_patterns_type_not_empty = non-exhaustive patterns: type `{$ty}` is non-empty\n+    .def_note = `{$peeled_ty}` defined here\n+    .type_note = the matched value is of type `{$ty}`\n+    .non_exhaustive_type_note = the matched value is of type `{$ty}`, which is marked as non-exhaustive\n+    .reference_note = references are always considered inhabited\n+    .suggestion = ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+    .help = ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n mir_build_nontrivial_structural_match =\n     to use a constant of type `{$non_sm_ty}` in a pattern, the constant's initializer must be trivial or `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n \n-mir_build_type_not_structural_tip = the traits must be derived, manual `impl`s are not sufficient\n-\n-mir_build_type_not_structural_more_info = see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n-\n mir_build_overlapping_range_endpoints = multiple patterns overlap on their endpoints\n     .range = ... with this range\n     .note = you likely meant to write mutually exclusive ranges\n \n-mir_build_non_exhaustive_omitted_pattern = some variants are not matched explicitly\n-    .help = ensure that all variants are matched explicitly by adding the suggested match arms\n-    .note = the matched value is of type `{$scrut_ty}` and the `non_exhaustive_omitted_patterns` attribute was found\n-\n-mir_build_uncovered = {$count ->\n-        [1] pattern `{$witness_1}`\n-        [2] patterns `{$witness_1}` and `{$witness_2}`\n-        [3] patterns `{$witness_1}`, `{$witness_2}` and `{$witness_3}`\n-        *[other] patterns `{$witness_1}`, `{$witness_2}`, `{$witness_3}` and {$remainder} more\n-    } not covered\n-\n-mir_build_privately_uninhabited = pattern `{$witness_1}` is currently uninhabited, but this variant contains private fields which may become inhabited in the future\n-\n mir_build_pattern_not_covered = refutable pattern in {$origin}\n     .pattern_ty = the matched value is of type `{$pattern_ty}`\n \n-mir_build_inform_irrefutable = `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+mir_build_pointer_pattern = function pointers and unsized pointers in patterns behave unpredictably and should not be relied upon. See https://github.com/rust-lang/rust/issues/70861 for details.\n \n-mir_build_more_information = for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+mir_build_privately_uninhabited = pattern `{$witness_1}` is currently uninhabited, but this variant contains private fields which may become inhabited in the future\n \n-mir_build_adt_defined_here = `{$ty}` defined here\n+mir_build_rustc_box_attribute_error = `#[rustc_box]` attribute used incorrectly\n+    .attributes = no other attributes may be applied\n+    .not_box = `#[rustc_box]` may only be applied to a `Box::new()` call\n+    .missing_box = `#[rustc_box]` requires the `owned_box` lang item\n \n-mir_build_variant_defined_here = not covered\n+mir_build_static_in_pattern = statics cannot be referenced in patterns\n \n-mir_build_interpreted_as_const = introduce a variable instead\n+mir_build_suggest_attempted_int_lit = alternatively, you could prepend the pattern with an underscore to define a new named variable; identifiers cannot begin with digits\n \n-mir_build_confused = missing patterns are not covered because `{$variable}` is interpreted as a constant pattern, not a new variable\n \n mir_build_suggest_if_let = you might want to use `if let` to ignore the {$count ->\n         [one] variant that isn't\n@@ -367,10 +260,117 @@ mir_build_suggest_let_else = you might want to use `let else` to handle the {$co\n         *[other] variants that aren't\n     } matched\n \n-mir_build_suggest_attempted_int_lit = alternatively, you could prepend the pattern with an underscore to define a new named variable; identifiers cannot begin with digits\n+mir_build_trailing_irrefutable_let_patterns = trailing irrefutable {$count ->\n+        [one] pattern\n+        *[other] patterns\n+    } in let chain\n+    .note = {$count ->\n+        [one] this pattern\n+        *[other] these patterns\n+    } will always match\n+    .help = consider moving {$count ->\n+        [one] it\n+        *[other] them\n+    } into the body\n \n+mir_build_type_not_structural =\n+     to use a constant of type `{$non_sm_ty}` in a pattern, `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n \n-mir_build_rustc_box_attribute_error = `#[rustc_box]` attribute used incorrectly\n-    .attributes = no other attributes may be applied\n-    .not_box = `#[rustc_box]` may only be applied to a `Box::new()` call\n-    .missing_box = `#[rustc_box]` requires the `owned_box` lang item\n+mir_build_type_not_structural_more_info = see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n+\n+mir_build_type_not_structural_tip = the traits must be derived, manual `impl`s are not sufficient\n+\n+mir_build_unconditional_recursion = function cannot return without recursing\n+    .label = cannot return without recursing\n+    .help = a `loop` may express intention better if this is on purpose\n+\n+mir_build_unconditional_recursion_call_site_label = recursive call site\n+\n+mir_build_uncovered = {$count ->\n+        [1] pattern `{$witness_1}`\n+        [2] patterns `{$witness_1}` and `{$witness_2}`\n+        [3] patterns `{$witness_1}`, `{$witness_2}` and `{$witness_3}`\n+        *[other] patterns `{$witness_1}`, `{$witness_2}`, `{$witness_3}` and {$remainder} more\n+    } not covered\n+\n+mir_build_union_field_requires_unsafe =\n+    access to union field is unsafe and requires unsafe block\n+    .note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+    .label = access to union field\n+\n+mir_build_union_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    access to union field is unsafe and requires unsafe function or block\n+    .note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+    .label = access to union field\n+\n+mir_build_union_pattern = cannot use unions in constant patterns\n+\n+mir_build_unreachable_pattern = unreachable pattern\n+    .label = unreachable pattern\n+    .catchall_label = matches any value\n+\n+mir_build_unsafe_op_in_unsafe_fn_borrow_of_layout_constrained_field_requires_unsafe =\n+    borrow of layout constrained field with interior mutability is unsafe and requires unsafe block (error E0133)\n+    .note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n+    .label = borrow of layout constrained field with interior mutability\n+\n+mir_build_unsafe_op_in_unsafe_fn_call_to_fn_with_requires_unsafe =\n+    call to function `{$function}` with `#[target_feature]` is unsafe and requires unsafe block (error E0133)\n+    .note = can only be called if the required target features are available\n+    .label = call to function with `#[target_feature]`\n+\n+mir_build_unsafe_op_in_unsafe_fn_call_to_unsafe_fn_requires_unsafe =\n+    call to unsafe function `{$function}` is unsafe and requires unsafe block (error E0133)\n+    .note = consult the function's documentation for information on how to avoid undefined behavior\n+    .label = call to unsafe function\n+\n+mir_build_unsafe_op_in_unsafe_fn_call_to_unsafe_fn_requires_unsafe_nameless =\n+    call to unsafe function is unsafe and requires unsafe block (error E0133)\n+    .note = consult the function's documentation for information on how to avoid undefined behavior\n+    .label = call to unsafe function\n+\n+mir_build_unsafe_op_in_unsafe_fn_deref_raw_pointer_requires_unsafe =\n+    dereference of raw pointer is unsafe and requires unsafe block (error E0133)\n+    .note = raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+    .label = dereference of raw pointer\n+\n+mir_build_unsafe_op_in_unsafe_fn_extern_static_requires_unsafe =\n+    use of extern static is unsafe and requires unsafe block (error E0133)\n+    .note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n+    .label = use of extern static\n+\n+mir_build_unsafe_op_in_unsafe_fn_initializing_type_with_requires_unsafe =\n+    initializing type with `rustc_layout_scalar_valid_range` attr is unsafe and requires unsafe\n+    block (error E0133)\n+    .note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n+    .label = initializing type with `rustc_layout_scalar_valid_range` attr\n+\n+mir_build_unsafe_op_in_unsafe_fn_inline_assembly_requires_unsafe =\n+    use of inline assembly is unsafe and requires unsafe block (error E0133)\n+    .note = inline assembly is entirely unchecked and can cause undefined behavior\n+    .label = use of inline assembly\n+\n+mir_build_unsafe_op_in_unsafe_fn_mutable_static_requires_unsafe =\n+    use of mutable static is unsafe and requires unsafe block (error E0133)\n+    .note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n+    .label = use of mutable static\n+\n+mir_build_unsafe_op_in_unsafe_fn_mutation_of_layout_constrained_field_requires_unsafe =\n+    mutation of layout constrained field is unsafe and requires unsafe block (error E0133)\n+    .note = mutating layout constrained fields cannot statically be checked for valid values\n+    .label = mutation of layout constrained field\n+\n+mir_build_unsafe_op_in_unsafe_fn_union_field_requires_unsafe =\n+    access to union field is unsafe and requires unsafe block (error E0133)\n+    .note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+    .label = access to union field\n+\n+mir_build_unsized_pattern = cannot use unsized non-slice type `{$non_sm_ty}` in constant patterns\n+\n+mir_build_unused_unsafe = unnecessary `unsafe` block\n+    .label = unnecessary `unsafe` block\n+\n+mir_build_unused_unsafe_enclosing_block_label = because it's nested under this `unsafe` block\n+mir_build_unused_unsafe_enclosing_fn_label = because it's nested under this `unsafe` fn\n+\n+mir_build_variant_defined_here = not covered"}, {"sha": "5698367e42ba5e7eb34a0798ea10adbc01d05cb2", "filename": "compiler/rustc_mir_dataflow/messages.ftl", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_mir_dataflow%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_mir_dataflow%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,29 +1,29 @@\n+mir_dataflow_duplicate_values_for =\n+    duplicate values for `{$name}`\n+\n mir_dataflow_path_must_end_in_filename =\n     path must end in a filename\n \n-mir_dataflow_unknown_formatter =\n-    unknown formatter\n+mir_dataflow_peek_argument_not_a_local =\n+    rustc_peek: argument was not a local\n \n-mir_dataflow_duplicate_values_for =\n-    duplicate values for `{$name}`\n+mir_dataflow_peek_argument_untracked =\n+    rustc_peek: argument untracked\n \n-mir_dataflow_requires_an_argument =\n-    `{$name}` requires an argument\n+mir_dataflow_peek_bit_not_set =\n+    rustc_peek: bit not set\n \n-mir_dataflow_stop_after_dataflow_ended_compilation =\n-    stop_after_dataflow ended compilation\n+mir_dataflow_peek_must_be_not_temporary =\n+    dataflow::sanity_check cannot feed a non-temp to rustc_peek\n \n mir_dataflow_peek_must_be_place_or_ref_place =\n     rustc_peek: argument expression must be either `place` or `&place`\n \n-mir_dataflow_peek_must_be_not_temporary =\n-    dataflow::sanity_check cannot feed a non-temp to rustc_peek\n-\n-mir_dataflow_peek_bit_not_set =\n-    rustc_peek: bit not set\n+mir_dataflow_requires_an_argument =\n+    `{$name}` requires an argument\n \n-mir_dataflow_peek_argument_not_a_local =\n-    rustc_peek: argument was not a local\n+mir_dataflow_stop_after_dataflow_ended_compilation =\n+    stop_after_dataflow ended compilation\n \n-mir_dataflow_peek_argument_untracked =\n-    rustc_peek: argument untracked\n+mir_dataflow_unknown_formatter =\n+    unknown formatter"}, {"sha": "b13429d121d10b14cc5ef7a56bce66d2dd47d423", "filename": "compiler/rustc_mir_transform/messages.ftl", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_mir_transform%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_mir_transform%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,3 +1,8 @@\n+mir_transform_arithmetic_overflow = this arithmetic operation will overflow\n+mir_transform_call_to_unsafe_label = call to unsafe function\n+mir_transform_call_to_unsafe_note = consult the function's documentation for information on how to avoid undefined behavior\n+mir_transform_const_defined_here = `const` item defined here\n+\n mir_transform_const_modify = attempting to modify a `const` item\n     .note = each usage of a `const` item creates a new temporary; the original `const` item will not be modified\n \n@@ -6,50 +11,10 @@ mir_transform_const_mut_borrow = taking a mutable reference to a `const` item\n     .note2 = the mutable reference will refer to this temporary, not the original `const` item\n     .note3 = mutable reference created due to call to this method\n \n-mir_transform_const_defined_here = `const` item defined here\n-\n-mir_transform_unaligned_packed_ref = reference to packed field is unaligned\n-    .note = packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\n-    .note_ub = creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n-    .help = copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n-\n-mir_transform_unused_unsafe = unnecessary `unsafe` block\n-    .label = because it's nested under this `unsafe` block\n-\n-mir_transform_requires_unsafe = {$details} is unsafe and requires unsafe {$op_in_unsafe_fn_allowed ->\n-    [true] function or block\n-    *[false] block\n-    }\n-    .not_inherited = items do not inherit unsafety from separate enclosing items\n-\n-mir_transform_call_to_unsafe_label = call to unsafe function\n-mir_transform_call_to_unsafe_note = consult the function's documentation for information on how to avoid undefined behavior\n-mir_transform_use_of_asm_label = use of inline assembly\n-mir_transform_use_of_asm_note = inline assembly is entirely unchecked and can cause undefined behavior\n-mir_transform_initializing_valid_range_label = initializing type with `rustc_layout_scalar_valid_range` attr\n-mir_transform_initializing_valid_range_note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n mir_transform_const_ptr2int_label = cast of pointer to int\n mir_transform_const_ptr2int_note = casting pointers to integers in constants\n-mir_transform_use_of_static_mut_label = use of mutable static\n-mir_transform_use_of_static_mut_note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n-mir_transform_use_of_extern_static_label = use of extern static\n-mir_transform_use_of_extern_static_note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n mir_transform_deref_ptr_label = dereference of raw pointer\n mir_transform_deref_ptr_note = raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n-mir_transform_union_access_label = access to union field\n-mir_transform_union_access_note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n-mir_transform_mutation_layout_constrained_label = mutation of layout constrained field\n-mir_transform_mutation_layout_constrained_note = mutating layout constrained fields cannot statically be checked for valid values\n-mir_transform_mutation_layout_constrained_borrow_label = borrow of layout constrained field with interior mutability\n-mir_transform_mutation_layout_constrained_borrow_note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n-mir_transform_target_feature_call_label = call to function with `#[target_feature]`\n-mir_transform_target_feature_call_note = can only be called if the required target features are available\n-\n-mir_transform_unsafe_op_in_unsafe_fn = {$details} is unsafe and requires unsafe block (error E0133)\n-\n-mir_transform_arithmetic_overflow = this arithmetic operation will overflow\n-mir_transform_operation_will_panic = this operation will panic at runtime\n-\n mir_transform_ffi_unwind_call = call to {$foreign ->\n     [true] foreign function\n     *[false] function pointer\n@@ -58,9 +23,45 @@ mir_transform_ffi_unwind_call = call to {$foreign ->\n mir_transform_fn_item_ref = taking a reference to a function item does not give a function pointer\n     .suggestion = cast `{$ident}` to obtain a function pointer\n \n+mir_transform_initializing_valid_range_label = initializing type with `rustc_layout_scalar_valid_range` attr\n+mir_transform_initializing_valid_range_note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n mir_transform_must_not_suspend = {$pre}`{$def_path}`{$post} held across a suspend point, but should not be\n     .label = the value is held across this suspend point\n     .note = {$reason}\n     .help = consider using a block (`{\"{ ... }\"}`) to shrink the value's scope, ending before the suspend point\n \n+mir_transform_mutation_layout_constrained_borrow_label = borrow of layout constrained field with interior mutability\n+mir_transform_mutation_layout_constrained_borrow_note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n+mir_transform_mutation_layout_constrained_label = mutation of layout constrained field\n+mir_transform_mutation_layout_constrained_note = mutating layout constrained fields cannot statically be checked for valid values\n+mir_transform_operation_will_panic = this operation will panic at runtime\n+\n+mir_transform_requires_unsafe = {$details} is unsafe and requires unsafe {$op_in_unsafe_fn_allowed ->\n+    [true] function or block\n+    *[false] block\n+    }\n+    .not_inherited = items do not inherit unsafety from separate enclosing items\n+\n mir_transform_simd_shuffle_last_const = last argument of `simd_shuffle` is required to be a `const` item\n+\n+mir_transform_target_feature_call_label = call to function with `#[target_feature]`\n+mir_transform_target_feature_call_note = can only be called if the required target features are available\n+\n+mir_transform_unaligned_packed_ref = reference to packed field is unaligned\n+    .note = packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\n+    .note_ub = creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+    .help = copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+mir_transform_union_access_label = access to union field\n+mir_transform_union_access_note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+mir_transform_unsafe_op_in_unsafe_fn = {$details} is unsafe and requires unsafe block (error E0133)\n+\n+mir_transform_unused_unsafe = unnecessary `unsafe` block\n+    .label = because it's nested under this `unsafe` block\n+\n+mir_transform_use_of_asm_label = use of inline assembly\n+mir_transform_use_of_asm_note = inline assembly is entirely unchecked and can cause undefined behavior\n+mir_transform_use_of_extern_static_label = use of extern static\n+mir_transform_use_of_extern_static_note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n+mir_transform_use_of_static_mut_label = use of mutable static\n+mir_transform_use_of_static_mut_note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior"}, {"sha": "fdd47e6f79bd8c3f564031ac3dc08cafa379ff81", "filename": "compiler/rustc_monomorphize/messages.ftl", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_monomorphize%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_monomorphize%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,32 +1,32 @@\n-monomorphize_recursion_limit =\n-    reached the recursion limit while instantiating `{$shrunk}`\n-    .note = `{$def_path_str}` defined here\n-\n-monomorphize_written_to_path = the full type name has been written to '{$path}'\n-\n-monomorphize_type_length_limit = reached the type-length limit while instantiating `{$shrunk}`\n-\n monomorphize_consider_type_length_limit =\n     consider adding a `#![type_length_limit=\"{$type_length}\"]` attribute to your crate\n \n-monomorphize_fatal_error = {$error_message}\n-\n-monomorphize_unknown_partition_strategy = unknown partitioning strategy\n+monomorphize_couldnt_dump_mono_stats =\n+    unexpected error occurred while dumping monomorphization stats: {$error}\n \n-monomorphize_symbol_already_defined = symbol `{$symbol}` is already defined\n+monomorphize_encountered_error_while_instantiating =\n+    the above error was encountered while instantiating `{$formatted_item}`\n \n-monomorphize_unused_generic_params = item has unused generic parameters\n+monomorphize_fatal_error = {$error_message}\n \n monomorphize_large_assignments =\n     moving {$size} bytes\n     .label = value moved from here\n     .note = The current maximum size is {$limit}, but it can be customized with the move_size_limit attribute: `#![move_size_limit = \"...\"]`\n \n-monomorphize_couldnt_dump_mono_stats =\n-    unexpected error occurred while dumping monomorphization stats: {$error}\n+monomorphize_recursion_limit =\n+    reached the recursion limit while instantiating `{$shrunk}`\n+    .note = `{$def_path_str}` defined here\n \n-monomorphize_encountered_error_while_instantiating =\n-    the above error was encountered while instantiating `{$formatted_item}`\n+monomorphize_symbol_already_defined = symbol `{$symbol}` is already defined\n+\n+monomorphize_type_length_limit = reached the type-length limit while instantiating `{$shrunk}`\n \n monomorphize_unknown_cgu_collection_mode =\n     unknown codegen-item collection mode '{$mode}', falling back to 'lazy' mode\n+\n+monomorphize_unknown_partition_strategy = unknown partitioning strategy\n+\n+monomorphize_unused_generic_params = item has unused generic parameters\n+\n+monomorphize_written_to_path = the full type name has been written to '{$path}'"}, {"sha": "9263394508ee3e374838225f420692addc169b2e", "filename": "compiler/rustc_parse/messages.ftl", "status": "modified", "additions": 605, "deletions": 605, "changes": 1210, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_parse%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_parse%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,230 +1,298 @@\n-parse_struct_literal_body_without_path =\n-    struct literal body without path\n-    .suggestion = you might have forgotten to add the struct literal inside the block\n+parse_add_paren = try adding parentheses\n \n-parse_struct_literal_needing_parens =\n-    invalid struct literal\n-    .suggestion = you might need to surround the struct literal in parentheses\n+parse_ambiguous_missing_keyword_for_item_definition = missing `fn` or `struct` for function or struct definition\n+    .suggestion = if you meant to call a macro, try\n+    .help = if you meant to call a macro, remove the `pub` and add a trailing `!` after the identifier\n \n-parse_maybe_report_ambiguous_plus =\n-    ambiguous `+` in a type\n-    .suggestion = use parentheses to disambiguate\n+parse_ambiguous_range_pattern = the range pattern here has ambiguous interpretation\n+    .suggestion = add parentheses to clarify the precedence\n \n-parse_maybe_recover_from_bad_type_plus =\n-    expected a path on the left-hand side of `+`, not `{$ty}`\n+parse_array_brackets_instead_of_braces = this is a block expression, not an array\n+    .suggestion = to make an array, use square brackets instead of curly braces\n \n-parse_add_paren = try adding parentheses\n+parse_assignment_else_not_allowed = <assignment> ... else {\"{\"} ... {\"}\"} is not allowed\n \n-parse_forgot_paren = perhaps you forgot parentheses?\n+parse_assoc_lifetime = associated lifetimes are not supported\n+    .label = the lifetime is given here\n+    .help = if you meant to specify a trait object, write `dyn Trait + 'lifetime`\n \n-parse_expect_path = expected a path\n+parse_associated_static_item_not_allowed = associated `static` items are not allowed\n \n-parse_maybe_recover_from_bad_qpath_stage_2 =\n-    missing angle brackets in associated item path\n-    .suggestion = try: `{$ty}`\n+parse_async_block_in_2015 = `async` blocks are only allowed in Rust 2018 or later\n \n-parse_incorrect_semicolon =\n-    expected item, found `;`\n-    .suggestion = remove this semicolon\n-    .help = {$name} declarations are not followed by a semicolon\n+parse_async_fn_in_2015 = `async fn` is not permitted in Rust 2015\n+    .label = to use `async fn`, switch to Rust 2018 or later\n \n-parse_incorrect_use_of_await =\n-    incorrect use of `await`\n-    .parentheses_suggestion = `await` is not a method call, remove the parentheses\n-    .postfix_suggestion = `await` is a postfix operation\n+parse_async_move_order_incorrect = the order of `move` and `async` is incorrect\n+    .suggestion = try switching the order\n \n-parse_in_in_typo =\n-    expected iterable, found keyword `in`\n-    .suggestion = remove the duplicated `in`\n+parse_attr_after_generic = trailing attribute after generic parameter\n+    .label = attributes must go before parameters\n \n-parse_invalid_variable_declaration =\n-    invalid variable declaration\n+parse_attr_without_generics = attribute without generic parameters\n+    .label = attributes are only permitted when preceding parameters\n \n-parse_switch_mut_let_order =\n-    switch the order of `mut` and `let`\n-parse_missing_let_before_mut = missing keyword\n-parse_use_let_not_auto = write `let` instead of `auto` to introduce a new variable\n-parse_use_let_not_var = write `let` instead of `var` to introduce a new variable\n+parse_attribute_on_param_type = attributes cannot be applied to a function parameter's type\n+    .label = attributes are not allowed here\n \n-parse_invalid_comparison_operator = invalid comparison operator `{$invalid}`\n-    .use_instead = `{$invalid}` is not a valid comparison operator, use `{$correct}`\n-    .spaceship_operator_invalid = `<=>` is not a valid comparison operator, use `std::cmp::Ordering`\n+parse_bad_assoc_type_bounds = bounds on associated types do not belong here\n+    .label = belongs in `where` clause\n \n-parse_invalid_logical_operator = `{$incorrect}` is not a logical operator\n-    .note = unlike in e.g., Python and PHP, `&&` and `||` are used for logical operators\n-    .use_amp_amp_for_conjunction = use `&&` to perform logical conjunction\n-    .use_pipe_pipe_for_disjunction = use `||` to perform logical disjunction\n+parse_bad_item_kind = {$descr} is not supported in {$ctx}\n+    .help = consider moving the {$descr} out to a nearby module scope\n \n-parse_tilde_is_not_unary_operator = `~` cannot be used as a unary operator\n-    .suggestion = use `!` to perform bitwise not\n+parse_bad_return_type_notation_dotdot =\n+    return type notation uses `()` instead of `(..)` for elided arguments\n+    .suggestion = remove the `..`\n \n-parse_unexpected_if_with_if = unexpected `if` in the condition expression\n-    .suggestion = remove the `if`\n+parse_bad_return_type_notation_output =\n+    return type not allowed with return type notation\n+    .suggestion = remove the return type\n \n-parse_unexpected_token_after_not = unexpected {$negated_desc} after identifier\n-parse_unexpected_token_after_not_bitwise = use `!` to perform bitwise not\n-parse_unexpected_token_after_not_logical = use `!` to perform logical negation\n-parse_unexpected_token_after_not_default = use `!` to perform logical negation or bitwise not\n+parse_bare_cr = {$double_quotes ->\n+    [true] bare CR not allowed in string, use `\\r` instead\n+    *[false] character constant must be escaped: `\\r`\n+    }\n+    .escape = escape the character\n \n-parse_malformed_loop_label = malformed loop label\n-    .suggestion = use the correct loop label format\n+parse_bare_cr_in_raw_string = bare CR not allowed in raw string\n \n-parse_lifetime_in_borrow_expression = borrow expressions cannot be annotated with lifetimes\n-    .suggestion = remove the lifetime annotation\n-    .label = annotated with lifetime here\n+parse_binary_float_literal_not_supported = binary float literal is not supported\n+parse_bounds_not_allowed_on_trait_aliases = bounds are not allowed on trait aliases\n \n-parse_field_expression_with_generic = field expressions cannot have generic arguments\n+parse_box_not_pat = expected pattern, found {$descr}\n+    .note = `box` is a reserved keyword\n+    .suggestion = escape `box` to use it as an identifier\n \n-parse_macro_invocation_with_qualified_path = macros cannot use qualified paths\n+parse_box_syntax_removed = `box_syntax` has been removed\n+    .suggestion = use `Box::new()` instead\n \n-parse_unexpected_token_after_label = expected `while`, `for`, `loop` or `{\"{\"}` after a label\n-    .suggestion_remove_label = consider removing the label\n-    .suggestion_enclose_in_block = consider enclosing expression in a block\n+parse_cannot_be_raw_ident = `{$ident}` cannot be a raw identifier\n \n-parse_require_colon_after_labeled_expression = labeled expression must be followed by `:`\n-    .note = labels are used before loops and blocks, allowing e.g., `break 'label` to them\n-    .label = the label\n-    .suggestion = add `:` after the label\n+parse_catch_after_try = keyword `catch` cannot follow a `try` block\n+    .help = try using `match` on the result of the `try` block instead\n \n-parse_do_catch_syntax_removed = found removed `do catch` syntax\n-    .note = following RFC #2388, the new non-placeholder syntax is `try`\n-    .suggestion = replace with the new syntax\n+parse_cfg_attr_bad_delim = wrong `cfg_attr` delimiters\n+parse_colon_as_semi = statements are terminated with a semicolon\n+    .suggestion = use a semicolon instead\n \n-parse_float_literal_requires_integer_part = float literals must have an integer part\n-    .suggestion = must have an integer part\n+parse_comma_after_base_struct = cannot use a comma after the base struct\n+    .note = the base struct must always be the last field\n+    .suggestion = remove this comma\n \n-parse_invalid_int_literal_width = invalid width `{$width}` for integer literal\n-    .help = valid widths are 8, 16, 32, 64 and 128\n+parse_comparison_interpreted_as_generic =\n+    `<` is interpreted as a start of generic arguments for `{$type}`, not a comparison\n+    .label_args = interpreted as generic arguments\n+    .label_comparison = not interpreted as comparison\n+    .suggestion = try comparing the cast value\n \n-parse_invalid_num_literal_base_prefix = invalid base prefix for number literal\n-    .note = base prefixes (`0xff`, `0b1010`, `0o755`) are lowercase\n-    .suggestion = try making the prefix lowercase\n+parse_comparison_operators_cannot_be_chained = comparison operators cannot be chained\n+    .sugg_parentheses_for_function_args = or use `(...)` if you meant to specify fn arguments\n+    .sugg_split_comparison = split the comparison into two\n+    .sugg_parenthesize = parenthesize the comparison\n+parse_compound_assignment_expression_in_let = can't reassign to an uninitialized variable\n+    .suggestion = initialize the variable\n+    .help = if you meant to overwrite, remove the `let` binding\n \n-parse_invalid_num_literal_suffix = invalid suffix `{$suffix}` for number literal\n-    .label = invalid suffix `{$suffix}`\n-    .help = the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+parse_const_bounds_missing_tilde = const bounds must start with `~`\n+    .suggestion = add `~`\n \n-parse_invalid_float_literal_width = invalid width `{$width}` for float literal\n-    .help = valid widths are 32 and 64\n+parse_const_generic_without_braces = expressions must be enclosed in braces to be used as const generic arguments\n+    .suggestion = enclose the `const` expression in braces\n \n-parse_invalid_float_literal_suffix = invalid suffix `{$suffix}` for float literal\n-    .label = invalid suffix `{$suffix}`\n-    .help = valid suffixes are `f32` and `f64`\n+parse_const_global_cannot_be_mutable = const globals cannot be mutable\n+    .label = cannot be mutable\n+    .suggestion = you might want to declare a static instead\n \n-parse_int_literal_too_large = integer literal is too large\n+parse_const_let_mutually_exclusive = `const` and `let` are mutually exclusive\n+    .suggestion = remove `let`\n \n-parse_missing_semicolon_before_array = expected `;`, found `[`\n-    .suggestion = consider adding `;` here\n+parse_cr_doc_comment = bare CR not allowed in {$block ->\n+    [true] block doc-comment\n+    *[false] doc-comment\n+}\n \n-parse_invalid_block_macro_segment = cannot use a `block` macro fragment here\n-    .label = the `block` fragment is within this context\n+parse_default_not_followed_by_item = `default` is not followed by an item\n+    .label = the `default` qualifier\n+    .note = only `fn`, `const`, `type`, or `impl` items may be prefixed by `default`\n \n-parse_expect_dotdot_not_dotdotdot = expected `..`, found `...`\n-    .suggestion = use `..` to fill in the rest of the fields\n+parse_do_catch_syntax_removed = found removed `do catch` syntax\n+    .note = following RFC #2388, the new non-placeholder syntax is `try`\n+    .suggestion = replace with the new syntax\n \n-parse_if_expression_missing_then_block = this `if` expression is missing a block after the condition\n-    .add_then_block = add a block here\n-    .condition_possibly_unfinished = this binary operation is possibly unfinished\n+parse_doc_comment_does_not_document_anything = found a documentation comment that doesn't document anything\n+    .help = doc comments must come before what they document, if a comment was intended use `//`\n+    .suggestion = missing comma here\n \n-parse_if_expression_missing_condition = missing condition for `if` expression\n-    .condition_label = expected condition here\n-    .block_label = if this block is the condition of the `if` expression, then it must be followed by another block\n+parse_doc_comment_on_param_type = documentation comments cannot be applied to a function parameter's type\n+    .label = doc comments are not allowed here\n \n-parse_expected_expression_found_let = expected expression, found `let` statement\n+parse_dot_dot_dot_for_remaining_fields = expected field pattern, found `{$token_str}`\n+    .suggestion = to omit remaining fields, use `..`\n \n-parse_expect_eq_instead_of_eqeq = expected `=`, found `==`\n-    .suggestion = consider using `=` here\n+parse_dot_dot_dot_range_to_pattern_not_allowed = range-to patterns with `...` are not allowed\n+    .suggestion = use `..=` instead\n \n-parse_expected_else_block = expected `{\"{\"}`, found {$first_tok}\n-    .label = expected an `if` or a block after this `else`\n-    .suggestion = add an `if` if this is the condition of a chained `else if` statement\n+parse_dotdotdot = unexpected token: `...`\n+    .suggest_exclusive_range = use `..` for an exclusive range\n+    .suggest_inclusive_range = or `..=` for an inclusive range\n \n-parse_outer_attribute_not_allowed_on_if_else = outer attributes are not allowed on `if` and `else` branches\n-    .branch_label = the attributes are attached to this branch\n-    .ctx_label = the branch belongs to this `{$ctx}`\n-    .suggestion = remove the attributes\n+parse_dotdotdot_rest_pattern = unexpected `...`\n+    .label = not a valid pattern\n+    .suggestion = for a rest pattern, use `..` instead of `...`\n \n-parse_missing_in_in_for_loop = missing `in` in `for` loop\n-    .use_in_not_of = try using `in` here instead\n-    .add_in = try adding `in` here\n+parse_double_colon_in_bound = expected `:` followed by trait or lifetime\n+    .suggestion = use single colon\n \n-parse_missing_expression_in_for_loop = missing expression to iterate on in `for` loop\n-    .suggestion = try adding an expression to the `for` loop\n+parse_dyn_after_mut = `mut` must precede `dyn`\n+    .suggestion = place `mut` before `dyn`\n \n-parse_loop_else = `{$loop_kind}...else` loops are not supported\n-    .note = consider moving this `else` clause to a separate `if` statement and use a `bool` variable to control if it should run\n-    .loop_keyword = `else` is attached to this loop\n+parse_empty_exponent_float = expected at least one digit in exponent\n \n-parse_missing_comma_after_match_arm = expected `,` following `match` arm\n-    .suggestion = missing a comma here to end this `match` arm\n+parse_empty_unicode_escape = empty unicode escape\n+    .label = this escape must have at least 1 hex digit\n \n-parse_catch_after_try = keyword `catch` cannot follow a `try` block\n-    .help = try using `match` on the result of the `try` block instead\n+parse_enum_pattern_instead_of_identifier = expected identifier, found enum pattern\n \n-parse_comma_after_base_struct = cannot use a comma after the base struct\n-    .note = the base struct must always be the last field\n-    .suggestion = remove this comma\n+parse_enum_struct_mutually_exclusive = `enum` and `struct` are mutually exclusive\n+    .suggestion = replace `enum struct` with\n \n parse_eq_field_init = expected `:`, found `=`\n     .suggestion = replace equals symbol with a colon\n \n-parse_dotdotdot = unexpected token: `...`\n-    .suggest_exclusive_range = use `..` for an exclusive range\n-    .suggest_inclusive_range = or `..=` for an inclusive range\n+parse_equals_struct_default = default values on `struct` fields aren't supported\n+    .suggestion = remove this unsupported default value\n \n-parse_left_arrow_operator = unexpected token: `<-`\n-    .suggestion = if you meant to write a comparison against a negative value, add a space in between `<` and `-`\n+parse_escape_only_char = {$byte ->\n+    [true] byte\n+    *[false] character\n+    } constant must be escaped: `{$escaped_msg}`\n+    .escape = escape the character\n \n-parse_remove_let = expected pattern, found `let`\n-    .suggestion = remove the unnecessary `let` keyword\n+parse_expect_dotdot_not_dotdotdot = expected `..`, found `...`\n+    .suggestion = use `..` to fill in the rest of the fields\n \n-parse_use_eq_instead = unexpected `==`\n-    .suggestion = try using `=` instead\n+parse_expect_eq_instead_of_eqeq = expected `=`, found `==`\n+    .suggestion = consider using `=` here\n \n-parse_use_empty_block_not_semi = expected { \"`{}`\" }, found `;`\n-    .suggestion = try using { \"`{}`\" } instead\n+parse_expect_label_found_ident = expected a label, found an identifier\n+    .suggestion = labels start with a tick\n \n-parse_comparison_interpreted_as_generic =\n-    `<` is interpreted as a start of generic arguments for `{$type}`, not a comparison\n-    .label_args = interpreted as generic arguments\n-    .label_comparison = not interpreted as comparison\n-    .suggestion = try comparing the cast value\n+parse_expect_path = expected a path\n \n-parse_shift_interpreted_as_generic =\n-    `<<` is interpreted as a start of generic arguments for `{$type}`, not a shift\n-    .label_args = interpreted as generic arguments\n-    .label_comparison = not interpreted as shift\n-    .suggestion = try shifting the cast value\n+parse_expected_binding_left_of_at = left-hand side of `@` must be a binding\n+    .label_lhs = interpreted as a pattern, not a binding\n+    .label_rhs = also a pattern\n+    .note = bindings are `x`, `mut x`, `ref x`, and `ref mut x`\n+\n+parse_expected_builtin_ident = expected identifier after `builtin #`\n+\n+parse_expected_comma_after_pattern_field = expected `,`\n+\n+parse_expected_else_block = expected `{\"{\"}`, found {$first_tok}\n+    .label = expected an `if` or a block after this `else`\n+    .suggestion = add an `if` if this is the condition of a chained `else if` statement\n+\n+parse_expected_expression_found_let = expected expression, found `let` statement\n+\n+parse_expected_fn_path_found_fn_keyword = expected identifier, found keyword `fn`\n+    .suggestion = use `Fn` to refer to the trait\n+\n+parse_expected_identifier = expected identifier\n+\n+parse_expected_identifier_found_doc_comment = expected identifier, found doc comment\n+parse_expected_identifier_found_doc_comment_str = expected identifier, found doc comment `{$token}`\n+parse_expected_identifier_found_keyword = expected identifier, found keyword\n+parse_expected_identifier_found_keyword_str = expected identifier, found keyword `{$token}`\n+parse_expected_identifier_found_reserved_identifier = expected identifier, found reserved identifier\n+parse_expected_identifier_found_reserved_identifier_str = expected identifier, found reserved identifier `{$token}`\n+parse_expected_identifier_found_reserved_keyword = expected identifier, found reserved keyword\n+parse_expected_identifier_found_reserved_keyword_str = expected identifier, found reserved keyword `{$token}`\n+parse_expected_identifier_found_str = expected identifier, found `{$token}`\n+\n+parse_expected_mut_or_const_in_raw_pointer_type = expected `mut` or `const` keyword in raw pointer type\n+    .suggestion = add `mut` or `const` here\n+\n+parse_expected_semi_found_doc_comment_str = expected `;`, found doc comment `{$token}`\n+parse_expected_semi_found_keyword_str = expected `;`, found keyword `{$token}`\n+parse_expected_semi_found_reserved_identifier_str = expected `;`, found reserved identifier `{$token}`\n+parse_expected_semi_found_reserved_keyword_str = expected `;`, found reserved keyword `{$token}`\n+parse_expected_semi_found_str = expected `;`, found `{$token}`\n+\n+parse_expected_statement_after_outer_attr = expected statement after outer attribute\n+\n+parse_expected_trait_in_trait_impl_found_type = expected a trait, found type\n+\n+parse_extern_crate_name_with_dashes = crate name using dashes are not valid in `extern crate` statements\n+    .label = dash-separated idents are not valid\n+    .suggestion = if the original crate name uses dashes you need to use underscores in the code\n+\n+parse_extern_item_cannot_be_const = extern items cannot be `const`\n+    .suggestion = try using a static value\n+    .note = for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+parse_extra_if_in_let_else = remove the `if` if you meant to write a `let...else` statement\n+\n+parse_extra_impl_keyword_in_trait_impl = unexpected `impl` keyword\n+    .suggestion = remove the extra `impl`\n+    .note = this is parsed as an `impl Trait` type, but a trait is expected at this position\n+\n+\n+parse_field_expression_with_generic = field expressions cannot have generic arguments\n+\n+parse_float_literal_requires_integer_part = float literals must have an integer part\n+    .suggestion = must have an integer part\n+\n+parse_float_literal_unsupported_base = {$base} float literal is not supported\n+\n+parse_fn_pointer_cannot_be_async = an `fn` pointer type cannot be `async`\n+    .label = `async` because of this\n+    .suggestion = remove the `async` qualifier\n+\n+parse_fn_pointer_cannot_be_const = an `fn` pointer type cannot be `const`\n+    .label = `const` because of this\n+    .suggestion = remove the `const` qualifier\n+\n+parse_fn_ptr_with_generics = function pointer types may not have generic parameters\n+    .suggestion = consider moving the lifetime {$arity ->\n+        [one] parameter\n+        *[other] parameters\n+    } to {$for_param_list_exists ->\n+        [true] the\n+        *[false] a\n+    } `for` parameter list\n+\n+parse_forgot_paren = perhaps you forgot parentheses?\n \n parse_found_expr_would_be_stmt = expected expression, found `{$token}`\n     .label = expected expression\n \n-parse_leading_plus_not_supported = leading `+` is not supported\n-    .label = unexpected `+`\n-    .suggestion_remove_plus = try removing the `+`\n+parse_function_body_equals_expr = function body cannot be `= expression;`\n+    .suggestion = surround the expression with `{\"{\"}` and `{\"}\"}` instead of `=` and `;`\n \n-parse_parentheses_with_struct_fields = invalid `struct` delimiters or `fn` call arguments\n-    .suggestion_braces_for_struct = if `{$type}` is a struct, use braces as delimiters\n-    .suggestion_no_fields_for_fn = if `{$type}` is a function, use the arguments directly\n+parse_generic_parameters_without_angle_brackets = generic parameters without surrounding angle brackets\n+    .suggestion = surround the type parameters with angle brackets\n \n-parse_labeled_loop_in_break = parentheses are required around this expression to avoid confusion with a labeled break expression\n+parse_generics_in_path = unexpected generic arguments in path\n \n-parse_sugg_wrap_expression_in_parentheses = wrap the expression in parentheses\n+parse_help_set_edition_cargo = set `edition = \"{$edition}\"` in `Cargo.toml`\n+parse_help_set_edition_standalone = pass `--edition {$edition}` to `rustc`\n+parse_hexadecimal_float_literal_not_supported = hexadecimal float literal is not supported\n+parse_if_expression_missing_condition = missing condition for `if` expression\n+    .condition_label = expected condition here\n+    .block_label = if this block is the condition of the `if` expression, then it must be followed by another block\n \n-parse_array_brackets_instead_of_braces = this is a block expression, not an array\n-    .suggestion = to make an array, use square brackets instead of curly braces\n+parse_if_expression_missing_then_block = this `if` expression is missing a block after the condition\n+    .add_then_block = add a block here\n+    .condition_possibly_unfinished = this binary operation is possibly unfinished\n \n-parse_match_arm_body_without_braces = `match` arm body without braces\n-    .label_statements = {$num_statements ->\n-            [one] this statement is not surrounded by a body\n-           *[other] these statements are not surrounded by a body\n-        }\n-    .label_arrow = while parsing the `match` arm starting here\n-    .suggestion_add_braces = surround the {$num_statements ->\n-            [one] statement\n-           *[other] statements\n-        } with a body\n-    .suggestion_use_comma_not_semicolon = replace `;` with `,` to end a `match` arm expression\n+parse_in_in_typo =\n+    expected iterable, found keyword `in`\n+    .suggestion = remove the duplicated `in`\n+\n+parse_inappropriate_default = {$article} {$descr} cannot be `default`\n+    .label = `default` because of this\n+    .note = only associated `fn`, `const`, and `type` items can be `default`\n \n parse_inclusive_range_extra_equals = unexpected `=` after inclusive range\n     .suggestion_remove_eq = use `..=` instead\n@@ -238,36 +306,18 @@ parse_inclusive_range_no_end = inclusive range with no end\n     .suggestion_open_range = use `..` instead\n     .note = inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n-parse_struct_literal_not_allowed_here = struct literals are not allowed here\n-    .suggestion = surround the struct literal with parentheses\n-\n-parse_invalid_interpolated_expression = invalid interpolated expression\n-\n-parse_hexadecimal_float_literal_not_supported = hexadecimal float literal is not supported\n-parse_octal_float_literal_not_supported = octal float literal is not supported\n-parse_binary_float_literal_not_supported = binary float literal is not supported\n-parse_not_supported = not supported\n-\n-parse_invalid_literal_suffix = suffixes on {$kind} literals are invalid\n-    .label = invalid suffix `{$suffix}`\n-\n-parse_invalid_literal_suffix_on_tuple_index = suffixes on a tuple index are invalid\n-    .label = invalid suffix `{$suffix}`\n-    .tuple_exception_line_1 = `{$suffix}` is *temporarily* accepted on tuple index fields as it was incorrectly accepted on stable for a few releases\n-    .tuple_exception_line_2 = on proc macros, you'll want to use `syn::Index::from` or `proc_macro::Literal::*_unsuffixed` for code that will desugar to tuple field access\n-    .tuple_exception_line_3 = see issue #60210 <https://github.com/rust-lang/rust/issues/60210> for more information\n-\n-parse_expected_builtin_ident = expected identifier after `builtin #`\n-\n-parse_unknown_builtin_construct = unknown `builtin #` construct `{$name}`\n+parse_incorrect_braces_trait_bounds = incorrect braces around trait bounds\n+    .suggestion = remove the parentheses\n \n-parse_non_string_abi_literal = non-string ABI literal\n-    .suggestion = specify the ABI with a string literal\n+parse_incorrect_semicolon =\n+    expected item, found `;`\n+    .suggestion = remove this semicolon\n+    .help = {$name} declarations are not followed by a semicolon\n \n-parse_mismatched_closing_delimiter = mismatched closing delimiter: `{$delimiter}`\n-    .label_unmatched = mismatched closing delimiter\n-    .label_opening_candidate = closing delimiter possibly meant for this\n-    .label_unclosed = unclosed delimiter\n+parse_incorrect_use_of_await =\n+    incorrect use of `await`\n+    .parentheses_suggestion = `await` is not a method call, remove the parentheses\n+    .postfix_suggestion = `await` is a postfix operation\n \n parse_incorrect_visibility_restriction = incorrect visibility restriction\n     .help = some possible visibility restrictions are:\n@@ -276,36 +326,8 @@ parse_incorrect_visibility_restriction = incorrect visibility restriction\n             `pub(in path::to::module)`: visible only on the specified path\n     .suggestion = make this visible only to module `{$inner_str}` with `in`\n \n-parse_assignment_else_not_allowed = <assignment> ... else {\"{\"} ... {\"}\"} is not allowed\n-\n-parse_expected_statement_after_outer_attr = expected statement after outer attribute\n-\n-parse_doc_comment_does_not_document_anything = found a documentation comment that doesn't document anything\n-    .help = doc comments must come before what they document, if a comment was intended use `//`\n-    .suggestion = missing comma here\n-\n-parse_const_let_mutually_exclusive = `const` and `let` are mutually exclusive\n-    .suggestion = remove `let`\n-\n-parse_invalid_expression_in_let_else = a `{$operator}` expression cannot be directly assigned in `let...else`\n-parse_invalid_curly_in_let_else = right curly brace `{\"}\"}` before `else` in a `let...else` statement not allowed\n-parse_extra_if_in_let_else = remove the `if` if you meant to write a `let...else` statement\n-\n-parse_compound_assignment_expression_in_let = can't reassign to an uninitialized variable\n-    .suggestion = initialize the variable\n-    .help = if you meant to overwrite, remove the `let` binding\n-\n-parse_suffixed_literal_in_attribute = suffixed literals are not allowed in attributes\n-    .help = instead of using a suffixed literal (`1u8`, `1.0f32`, etc.), use an unsuffixed version (`1`, `1.0`, etc.)\n-\n-parse_invalid_meta_item = expected unsuffixed literal or identifier, found `{$token}`\n-\n-parse_label_inner_attr_does_not_annotate_this = the inner attribute doesn't annotate this {$item}\n-parse_sugg_change_inner_attr_to_outer = to annotate the {$item}, change the attribute from inner to outer style\n-\n-parse_inner_attr_not_permitted_after_outer_doc_comment = an inner attribute is not permitted following an outer doc comment\n-    .label_attr = not permitted following an outer doc comment\n-    .label_prev_doc_comment = previous doc comment\n+parse_inner_attr_explanation = inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files\n+parse_inner_attr_not_permitted = an inner attribute is not permitted in this context\n     .label_does_not_annotate_this = {parse_label_inner_attr_does_not_annotate_this}\n     .sugg_change_inner_to_outer = {parse_sugg_change_inner_attr_to_outer}\n \n@@ -315,522 +337,480 @@ parse_inner_attr_not_permitted_after_outer_attr = an inner attribute is not perm\n     .label_does_not_annotate_this = {parse_label_inner_attr_does_not_annotate_this}\n     .sugg_change_inner_to_outer = {parse_sugg_change_inner_attr_to_outer}\n \n-parse_inner_attr_not_permitted = an inner attribute is not permitted in this context\n+parse_inner_attr_not_permitted_after_outer_doc_comment = an inner attribute is not permitted following an outer doc comment\n+    .label_attr = not permitted following an outer doc comment\n+    .label_prev_doc_comment = previous doc comment\n     .label_does_not_annotate_this = {parse_label_inner_attr_does_not_annotate_this}\n     .sugg_change_inner_to_outer = {parse_sugg_change_inner_attr_to_outer}\n \n-parse_inner_attr_explanation = inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files\n-parse_outer_attr_explanation = outer attributes, like `#[test]`, annotate the item following them\n-\n parse_inner_doc_comment_not_permitted = expected outer doc comment\n     .note = inner doc comments like this (starting with `//!` or `/*!`) can only appear before items\n     .suggestion = you might have meant to write a regular comment\n     .label_does_not_annotate_this = the inner doc comment doesn't annotate this {$item}\n     .sugg_change_inner_to_outer = to annotate the {$item}, change the doc comment from inner to outer style\n \n-parse_expected_identifier_found_reserved_identifier_str = expected identifier, found reserved identifier `{$token}`\n-parse_expected_identifier_found_keyword_str = expected identifier, found keyword `{$token}`\n-parse_expected_identifier_found_reserved_keyword_str = expected identifier, found reserved keyword `{$token}`\n-parse_expected_identifier_found_doc_comment_str = expected identifier, found doc comment `{$token}`\n-parse_expected_identifier_found_str = expected identifier, found `{$token}`\n+parse_int_literal_too_large = integer literal is too large\n \n-parse_expected_identifier_found_reserved_identifier = expected identifier, found reserved identifier\n-parse_expected_identifier_found_keyword = expected identifier, found keyword\n-parse_expected_identifier_found_reserved_keyword = expected identifier, found reserved keyword\n-parse_expected_identifier_found_doc_comment = expected identifier, found doc comment\n-parse_expected_identifier = expected identifier\n+parse_invalid_block_macro_segment = cannot use a `block` macro fragment here\n+    .label = the `block` fragment is within this context\n \n-parse_sugg_escape_identifier = escape `{$ident_name}` to use it as an identifier\n+parse_invalid_char_in_escape = {parse_invalid_char_in_escape_msg}: `{$ch}`\n+    .label = {parse_invalid_char_in_escape_msg}\n \n-parse_sugg_remove_comma = remove this comma\n-parse_sugg_add_let_for_stmt = you might have meant to introduce a new binding\n+parse_invalid_char_in_escape_msg = invalid character in {$is_hex ->\n+    [true] numeric character\n+    *[false] unicode\n+    } escape\n \n-parse_expected_semi_found_reserved_identifier_str = expected `;`, found reserved identifier `{$token}`\n-parse_expected_semi_found_keyword_str = expected `;`, found keyword `{$token}`\n-parse_expected_semi_found_reserved_keyword_str = expected `;`, found reserved keyword `{$token}`\n-parse_expected_semi_found_doc_comment_str = expected `;`, found doc comment `{$token}`\n-parse_expected_semi_found_str = expected `;`, found `{$token}`\n+parse_invalid_comparison_operator = invalid comparison operator `{$invalid}`\n+    .use_instead = `{$invalid}` is not a valid comparison operator, use `{$correct}`\n+    .spaceship_operator_invalid = `<=>` is not a valid comparison operator, use `std::cmp::Ordering`\n \n-parse_sugg_change_this_to_semi = change this to `;`\n-parse_sugg_add_semi = add `;` here\n-parse_label_unexpected_token = unexpected token\n+parse_invalid_curly_in_let_else = right curly brace `{\"}\"}` before `else` in a `let...else` statement not allowed\n+parse_invalid_digit_literal = invalid digit for a base {$base} literal\n \n-parse_unmatched_angle_brackets = {$num_extra_brackets ->\n-        [one] unmatched angle bracket\n-       *[other] unmatched angle brackets\n-    }\n-    .suggestion = {$num_extra_brackets ->\n-            [one] remove extra angle bracket\n-           *[other] remove extra angle brackets\n-        }\n-\n-parse_generic_parameters_without_angle_brackets = generic parameters without surrounding angle brackets\n-    .suggestion = surround the type parameters with angle brackets\n-\n-parse_comparison_operators_cannot_be_chained = comparison operators cannot be chained\n-    .sugg_parentheses_for_function_args = or use `(...)` if you meant to specify fn arguments\n-    .sugg_split_comparison = split the comparison into two\n-    .sugg_parenthesize = parenthesize the comparison\n-parse_sugg_turbofish_syntax = use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n-\n-parse_question_mark_in_type = invalid `?` in type\n-    .label = `?` is only allowed on expressions, not types\n-    .suggestion = if you meant to express that the type might not contain a value, use the `Option` wrapper type\n+parse_invalid_dyn_keyword = invalid `dyn` keyword\n+    .help = `dyn` is only needed at the start of a trait `+`-separated list\n+    .suggestion = remove this keyword\n \n-parse_unexpected_parentheses_in_for_head = unexpected parentheses surrounding `for` loop head\n-    .suggestion = remove parentheses in `for` loop\n+parse_invalid_expression_in_let_else = a `{$operator}` expression cannot be directly assigned in `let...else`\n+parse_invalid_float_literal_suffix = invalid suffix `{$suffix}` for float literal\n+    .label = invalid suffix `{$suffix}`\n+    .help = valid suffixes are `f32` and `f64`\n \n-parse_doc_comment_on_param_type = documentation comments cannot be applied to a function parameter's type\n-    .label = doc comments are not allowed here\n+parse_invalid_float_literal_width = invalid width `{$width}` for float literal\n+    .help = valid widths are 32 and 64\n \n-parse_attribute_on_param_type = attributes cannot be applied to a function parameter's type\n-    .label = attributes are not allowed here\n+parse_invalid_identifier_with_leading_number = identifiers cannot start with a number\n \n-parse_pattern_method_param_without_body = patterns aren't allowed in methods without bodies\n-    .suggestion = give this argument a name or use an underscore to ignore it\n+parse_invalid_int_literal_width = invalid width `{$width}` for integer literal\n+    .help = valid widths are 8, 16, 32, 64 and 128\n \n-parse_self_param_not_first = unexpected `self` parameter in function\n-    .label = must be the first parameter of an associated function\n+parse_invalid_interpolated_expression = invalid interpolated expression\n \n-parse_const_generic_without_braces = expressions must be enclosed in braces to be used as const generic arguments\n-    .suggestion = enclose the `const` expression in braces\n+parse_invalid_literal_suffix = suffixes on {$kind} literals are invalid\n+    .label = invalid suffix `{$suffix}`\n \n-parse_unexpected_const_param_declaration = unexpected `const` parameter declaration\n-    .label = expected a `const` expression, not a parameter declaration\n-    .suggestion = `const` parameters must be declared for the `impl`\n+parse_invalid_literal_suffix_on_tuple_index = suffixes on a tuple index are invalid\n+    .label = invalid suffix `{$suffix}`\n+    .tuple_exception_line_1 = `{$suffix}` is *temporarily* accepted on tuple index fields as it was incorrectly accepted on stable for a few releases\n+    .tuple_exception_line_2 = on proc macros, you'll want to use `syn::Index::from` or `proc_macro::Literal::*_unsuffixed` for code that will desugar to tuple field access\n+    .tuple_exception_line_3 = see issue #60210 <https://github.com/rust-lang/rust/issues/60210> for more information\n \n-parse_unexpected_const_in_generic_param = expected lifetime, type, or constant, found keyword `const`\n-    .suggestion = the `const` keyword is only needed in the definition of the type\n+parse_invalid_logical_operator = `{$incorrect}` is not a logical operator\n+    .note = unlike in e.g., Python and PHP, `&&` and `||` are used for logical operators\n+    .use_amp_amp_for_conjunction = use `&&` to perform logical conjunction\n+    .use_pipe_pipe_for_disjunction = use `||` to perform logical disjunction\n \n-parse_async_move_order_incorrect = the order of `move` and `async` is incorrect\n-    .suggestion = try switching the order\n+parse_invalid_meta_item = expected unsuffixed literal or identifier, found `{$token}`\n \n-parse_double_colon_in_bound = expected `:` followed by trait or lifetime\n-    .suggestion = use single colon\n+parse_invalid_num_literal_base_prefix = invalid base prefix for number literal\n+    .note = base prefixes (`0xff`, `0b1010`, `0o755`) are lowercase\n+    .suggestion = try making the prefix lowercase\n \n-parse_fn_ptr_with_generics = function pointer types may not have generic parameters\n-    .suggestion = consider moving the lifetime {$arity ->\n-        [one] parameter\n-        *[other] parameters\n-    } to {$for_param_list_exists ->\n-        [true] the\n-        *[false] a\n-    } `for` parameter list\n+parse_invalid_num_literal_suffix = invalid suffix `{$suffix}` for number literal\n+    .label = invalid suffix `{$suffix}`\n+    .help = the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n \n-parse_invalid_identifier_with_leading_number = identifiers cannot start with a number\n+parse_invalid_unicode_escape = invalid unicode character escape\n+    .label = invalid escape\n+    .help = unicode escape must {$surrogate ->\n+    [true] not be a surrogate\n+    *[false] be at most 10FFFF\n+    }\n \n-parse_maybe_fn_typo_with_impl = you might have meant to write `impl` instead of `fn`\n-    .suggestion = replace `fn` with `impl` here\n+parse_invalid_variable_declaration =\n+    invalid variable declaration\n \n-parse_expected_fn_path_found_fn_keyword = expected identifier, found keyword `fn`\n-    .suggestion = use `Fn` to refer to the trait\n+parse_kw_bad_case = keyword `{$kw}` is written in the wrong case\n+    .suggestion = write it in the correct case\n \n-parse_path_single_colon = path separator must be a double colon\n-    .suggestion = use a double colon instead\n+parse_label_inner_attr_does_not_annotate_this = the inner attribute doesn't annotate this {$item}\n+parse_label_unexpected_token = unexpected token\n \n-parse_colon_as_semi = statements are terminated with a semicolon\n-    .suggestion = use a semicolon instead\n+parse_label_while_parsing_or_pattern_here = while parsing this or-pattern starting here\n \n-parse_type_ascription_removed =\n-    if you meant to annotate an expression with a type, the type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n+parse_labeled_loop_in_break = parentheses are required around this expression to avoid confusion with a labeled break expression\n \n-parse_where_clause_before_tuple_struct_body = where clauses are not allowed before tuple struct bodies\n-    .label = unexpected where clause\n-    .name_label = while parsing this tuple struct\n-    .body_label = the struct body\n-    .suggestion = move the body before the where clause\n+parse_leading_plus_not_supported = leading `+` is not supported\n+    .label = unexpected `+`\n+    .suggestion_remove_plus = try removing the `+`\n \n-parse_async_fn_in_2015 = `async fn` is not permitted in Rust 2015\n-    .label = to use `async fn`, switch to Rust 2018 or later\n+parse_leading_underscore_unicode_escape = {parse_leading_underscore_unicode_escape_label}: `_`\n+parse_leading_underscore_unicode_escape_label = invalid start of unicode escape\n \n-parse_async_block_in_2015 = `async` blocks are only allowed in Rust 2018 or later\n+parse_left_arrow_operator = unexpected token: `<-`\n+    .suggestion = if you meant to write a comparison against a negative value, add a space in between `<` and `-`\n \n-parse_self_argument_pointer = cannot pass `self` by raw pointer\n-    .label = cannot pass `self` by raw pointer\n+parse_lifetime_after_mut = lifetime must precede `mut`\n+    .suggestion = place the lifetime before `mut`\n \n-parse_visibility_not_followed_by_item = visibility `{$vis}` is not followed by an item\n-    .label = the visibility\n-    .help = you likely meant to define an item, e.g., `{$vis} fn foo() {\"{}\"}`\n+parse_lifetime_in_borrow_expression = borrow expressions cannot be annotated with lifetimes\n+    .suggestion = remove the lifetime annotation\n+    .label = annotated with lifetime here\n \n-parse_default_not_followed_by_item = `default` is not followed by an item\n-    .label = the `default` qualifier\n-    .note = only `fn`, `const`, `type`, or `impl` items may be prefixed by `default`\n+parse_lone_slash = invalid trailing slash in literal\n+    .label = {parse_lone_slash}\n \n-parse_missing_struct_for_struct_definition = missing `struct` for struct definition\n-    .suggestion = add `struct` here to parse `{$ident}` as a public struct\n+parse_loop_else = `{$loop_kind}...else` loops are not supported\n+    .note = consider moving this `else` clause to a separate `if` statement and use a `bool` variable to control if it should run\n+    .loop_keyword = `else` is attached to this loop\n \n-parse_missing_fn_for_function_definition = missing `fn` for function definition\n-    .suggestion = add `fn` here to parse `{$ident}` as a public function\n+parse_macro_invocation_visibility = can't qualify macro invocation with `pub`\n+    .suggestion = remove the visibility\n+    .help = try adjusting the macro to put `{$vis}` inside the invocation\n \n-parse_missing_fn_for_method_definition = missing `fn` for method definition\n-    .suggestion = add `fn` here to parse `{$ident}` as a public method\n+parse_macro_invocation_with_qualified_path = macros cannot use qualified paths\n \n-parse_ambiguous_missing_keyword_for_item_definition = missing `fn` or `struct` for function or struct definition\n-    .suggestion = if you meant to call a macro, try\n-    .help = if you meant to call a macro, remove the `pub` and add a trailing `!` after the identifier\n+parse_macro_name_remove_bang = macro names aren't followed by a `!`\n+    .suggestion = remove the `!`\n \n-parse_missing_trait_in_trait_impl = missing trait in a trait impl\n-    .suggestion_add_trait = add a trait here\n-    .suggestion_remove_for = for an inherent impl, drop this `for`\n+parse_macro_rules_missing_bang = expected `!` after `macro_rules`\n+    .suggestion = add a `!`\n \n-parse_missing_for_in_trait_impl = missing `for` in a trait impl\n-    .suggestion = add `for` here\n+parse_macro_rules_visibility = can't qualify macro_rules invocation with `{$vis}`\n+    .suggestion = try exporting the macro\n \n-parse_expected_trait_in_trait_impl_found_type = expected a trait, found type\n+parse_malformed_cfg_attr = malformed `cfg_attr` attribute input\n+    .suggestion = missing condition and attribute\n+    .note = for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n \n-parse_extra_impl_keyword_in_trait_impl = unexpected `impl` keyword\n-    .suggestion = remove the extra `impl`\n-    .note = this is parsed as an `impl Trait` type, but a trait is expected at this position\n+parse_malformed_loop_label = malformed loop label\n+    .suggestion = use the correct loop label format\n \n+parse_match_arm_body_without_braces = `match` arm body without braces\n+    .label_statements = {$num_statements ->\n+            [one] this statement is not surrounded by a body\n+           *[other] these statements are not surrounded by a body\n+        }\n+    .label_arrow = while parsing the `match` arm starting here\n+    .suggestion_add_braces = surround the {$num_statements ->\n+            [one] statement\n+           *[other] statements\n+        } with a body\n+    .suggestion_use_comma_not_semicolon = replace `;` with `,` to end a `match` arm expression\n \n-parse_non_item_in_item_list = non-item in item list\n-    .suggestion_use_const_not_let = consider using `const` instead of `let` for associated const\n-    .label_list_start = item list starts here\n-    .label_non_item = non-item starts here\n-    .label_list_end = item list ends here\n-    .suggestion_remove_semicolon = consider removing this semicolon\n+parse_maybe_fn_typo_with_impl = you might have meant to write `impl` instead of `fn`\n+    .suggestion = replace `fn` with `impl` here\n \n-parse_bounds_not_allowed_on_trait_aliases = bounds are not allowed on trait aliases\n+parse_maybe_recover_from_bad_qpath_stage_2 =\n+    missing angle brackets in associated item path\n+    .suggestion = try: `{$ty}`\n \n-parse_trait_alias_cannot_be_auto = trait aliases cannot be `auto`\n-parse_trait_alias_cannot_be_unsafe = trait aliases cannot be `unsafe`\n+parse_maybe_recover_from_bad_type_plus =\n+    expected a path on the left-hand side of `+`, not `{$ty}`\n \n-parse_associated_static_item_not_allowed = associated `static` items are not allowed\n+parse_maybe_report_ambiguous_plus =\n+    ambiguous `+` in a type\n+    .suggestion = use parentheses to disambiguate\n \n-parse_extern_crate_name_with_dashes = crate name using dashes are not valid in `extern crate` statements\n-    .label = dash-separated idents are not valid\n-    .suggestion = if the original crate name uses dashes you need to use underscores in the code\n+parse_meta_bad_delim = wrong meta list delimiters\n+parse_meta_bad_delim_suggestion = the delimiters should be `(` and `)`\n \n-parse_extern_item_cannot_be_const = extern items cannot be `const`\n-    .suggestion = try using a static value\n-    .note = for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+parse_mismatched_closing_delimiter = mismatched closing delimiter: `{$delimiter}`\n+    .label_unmatched = mismatched closing delimiter\n+    .label_opening_candidate = closing delimiter possibly meant for this\n+    .label_unclosed = unclosed delimiter\n \n-parse_const_global_cannot_be_mutable = const globals cannot be mutable\n-    .label = cannot be mutable\n-    .suggestion = you might want to declare a static instead\n+parse_missing_comma_after_match_arm = expected `,` following `match` arm\n+    .suggestion = missing a comma here to end this `match` arm\n \n parse_missing_const_type = missing type for `{$kind}` item\n     .suggestion = provide a type for the item\n \n-parse_enum_struct_mutually_exclusive = `enum` and `struct` are mutually exclusive\n-    .suggestion = replace `enum struct` with\n-\n-parse_unexpected_token_after_struct_name = expected `where`, `{\"{\"}`, `(`, or `;` after struct name\n-parse_unexpected_token_after_struct_name_found_reserved_identifier = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found reserved identifier `{$token}`\n-parse_unexpected_token_after_struct_name_found_keyword = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found keyword `{$token}`\n-parse_unexpected_token_after_struct_name_found_reserved_keyword = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found reserved keyword `{$token}`\n-parse_unexpected_token_after_struct_name_found_doc_comment = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found doc comment `{$token}`\n-parse_unexpected_token_after_struct_name_found_other = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found `{$token}`\n-\n-parse_unexpected_self_in_generic_parameters = unexpected keyword `Self` in generic parameters\n-    .note = you cannot use `Self` as a generic parameter because it is reserved for associated items\n-\n-parse_unexpected_default_value_for_lifetime_in_generic_parameters = unexpected default lifetime parameter\n-    .label = lifetime parameters cannot have default values\n-\n-parse_multiple_where_clauses = cannot define duplicate `where` clauses on an item\n-    .label = previous `where` clause starts here\n-    .suggestion = consider joining the two `where` clauses into one\n-\n-parse_nonterminal_expected_item_keyword = expected an item keyword\n-parse_nonterminal_expected_statement = expected a statement\n-parse_nonterminal_expected_ident = expected ident, found `{$token}`\n-parse_nonterminal_expected_lifetime = expected a lifetime, found `{$token}`\n+parse_missing_expression_in_for_loop = missing expression to iterate on in `for` loop\n+    .suggestion = try adding an expression to the `for` loop\n \n-parse_or_pattern_not_allowed_in_let_binding = top-level or-patterns are not allowed in `let` bindings\n-parse_or_pattern_not_allowed_in_fn_parameters = top-level or-patterns are not allowed in function parameters\n-parse_sugg_remove_leading_vert_in_pattern = remove the `|`\n-parse_sugg_wrap_pattern_in_parens = wrap the pattern in parentheses\n+parse_missing_fn_for_function_definition = missing `fn` for function definition\n+    .suggestion = add `fn` here to parse `{$ident}` as a public function\n \n-parse_note_pattern_alternatives_use_single_vert = alternatives in or-patterns are separated with `|`, not `||`\n+parse_missing_fn_for_method_definition = missing `fn` for method definition\n+    .suggestion = add `fn` here to parse `{$ident}` as a public method\n \n-parse_unexpected_vert_vert_before_function_parameter = unexpected `||` before function parameter\n-    .suggestion = remove the `||`\n+parse_missing_for_in_trait_impl = missing `for` in a trait impl\n+    .suggestion = add `for` here\n \n-parse_label_while_parsing_or_pattern_here = while parsing this or-pattern starting here\n+parse_missing_in_in_for_loop = missing `in` in `for` loop\n+    .use_in_not_of = try using `in` here instead\n+    .add_in = try adding `in` here\n \n-parse_unexpected_vert_vert_in_pattern = unexpected token `||` in pattern\n-    .suggestion = use a single `|` to separate multiple alternative patterns\n+parse_missing_let_before_mut = missing keyword\n+parse_missing_plus_in_bounds = expected `+` between lifetime and {$sym}\n+    .suggestion = add `+`\n \n-parse_trailing_vert_not_allowed = a trailing `|` is not allowed in an or-pattern\n-    .suggestion = remove the `{$token}`\n+parse_missing_semicolon_before_array = expected `;`, found `[`\n+    .suggestion = consider adding `;` here\n \n-parse_dotdotdot_rest_pattern = unexpected `...`\n-    .label = not a valid pattern\n-    .suggestion = for a rest pattern, use `..` instead of `...`\n+parse_missing_struct_for_struct_definition = missing `struct` for struct definition\n+    .suggestion = add `struct` here to parse `{$ident}` as a public struct\n \n-parse_pattern_on_wrong_side_of_at = pattern on wrong side of `@`\n-    .label_pattern = pattern on the left, should be on the right\n-    .label_binding = binding on the right, should be on the left\n-    .suggestion = switch the order\n+parse_missing_trait_in_trait_impl = missing trait in a trait impl\n+    .suggestion_add_trait = add a trait here\n+    .suggestion_remove_for = for an inherent impl, drop this `for`\n \n-parse_expected_binding_left_of_at = left-hand side of `@` must be a binding\n-    .label_lhs = interpreted as a pattern, not a binding\n-    .label_rhs = also a pattern\n-    .note = bindings are `x`, `mut x`, `ref x`, and `ref mut x`\n+parse_modifier_lifetime = `{$sigil}` may only modify trait bounds, not lifetime bounds\n+    .suggestion = remove the `{$sigil}`\n \n-parse_ambiguous_range_pattern = the range pattern here has ambiguous interpretation\n-    .suggestion = add parentheses to clarify the precedence\n+parse_more_than_one_char = character literal may only contain one codepoint\n+    .followed_by = this `{$chr}` is followed by the combining {$len ->\n+        [one] mark\n+        *[other] marks\n+        } `{$escaped_marks}`\n+    .non_printing = there are non-printing characters, the full sequence is `{$escaped}`\n+    .consider_normalized = consider using the normalized form `{$ch}` of this character\n+    .remove_non = consider removing the non-printing characters\n+    .use_double_quotes = if you meant to write a {$is_byte ->\n+        [true] byte string\n+        *[false] `str`\n+        } literal, use double quotes\n \n-parse_unexpected_lifetime_in_pattern = unexpected lifetime `{$symbol}` in pattern\n-    .suggestion = remove the lifetime\n+parse_multiple_skipped_lines = multiple lines skipped by escaped newline\n+    .label = skipping everything up to and including this point\n \n-parse_ref_mut_order_incorrect = the order of `mut` and `ref` is incorrect\n-    .suggestion = try switching the order\n+parse_multiple_where_clauses = cannot define duplicate `where` clauses on an item\n+    .label = previous `where` clause starts here\n+    .suggestion = consider joining the two `where` clauses into one\n \n parse_mut_on_nested_ident_pattern = `mut` must be attached to each individual binding\n     .suggestion = add `mut` to each binding\n parse_mut_on_non_ident_pattern = `mut` must be followed by a named binding\n     .suggestion = remove the `mut` prefix\n-parse_note_mut_pattern_usage = `mut` may be followed by `variable` and `variable @ pattern`\n-\n-parse_repeated_mut_in_pattern = `mut` on a binding may not be repeated\n-    .suggestion = remove the additional `mut`s\n-\n-parse_dot_dot_dot_range_to_pattern_not_allowed = range-to patterns with `...` are not allowed\n-    .suggestion = use `..=` instead\n-\n-parse_enum_pattern_instead_of_identifier = expected identifier, found enum pattern\n-\n-parse_dot_dot_dot_for_remaining_fields = expected field pattern, found `{$token_str}`\n-    .suggestion = to omit remaining fields, use `..`\n+parse_need_plus_after_trait_object_lifetime = lifetime in trait object type must be followed by `+`\n \n-parse_expected_comma_after_pattern_field = expected `,`\n+parse_nested_adt = `{$kw_str}` definition cannot be nested inside `{$keyword}`\n+    .suggestion = consider creating a new `{$kw_str}` definition instead of nesting\n \n-parse_return_types_use_thin_arrow = return types are denoted using `->`\n-    .suggestion = use `->` instead\n+parse_nested_c_variadic_type = C-variadic type `...` may not be nested inside another type\n \n-parse_need_plus_after_trait_object_lifetime = lifetime in trait object type must be followed by `+`\n+parse_no_brace_unicode_escape = incorrect unicode escape sequence\n+    .label = {parse_no_brace_unicode_escape}\n+    .use_braces = format of unicode escape sequences uses braces\n+    .format_of_unicode = format of unicode escape sequences is `\\u{\"{...}\"}`\n \n-parse_expected_mut_or_const_in_raw_pointer_type = expected `mut` or `const` keyword in raw pointer type\n-    .suggestion = add `mut` or `const` here\n+parse_no_digits_literal = no valid digits found for number\n \n-parse_lifetime_after_mut = lifetime must precede `mut`\n-    .suggestion = place the lifetime before `mut`\n+parse_non_item_in_item_list = non-item in item list\n+    .suggestion_use_const_not_let = consider using `const` instead of `let` for associated const\n+    .label_list_start = item list starts here\n+    .label_non_item = non-item starts here\n+    .label_list_end = item list ends here\n+    .suggestion_remove_semicolon = consider removing this semicolon\n \n-parse_dyn_after_mut = `mut` must precede `dyn`\n-    .suggestion = place `mut` before `dyn`\n+parse_non_string_abi_literal = non-string ABI literal\n+    .suggestion = specify the ABI with a string literal\n \n-parse_fn_pointer_cannot_be_const = an `fn` pointer type cannot be `const`\n-    .label = `const` because of this\n-    .suggestion = remove the `const` qualifier\n+parse_nonterminal_expected_ident = expected ident, found `{$token}`\n+parse_nonterminal_expected_item_keyword = expected an item keyword\n+parse_nonterminal_expected_lifetime = expected a lifetime, found `{$token}`\n \n-parse_fn_pointer_cannot_be_async = an `fn` pointer type cannot be `async`\n-    .label = `async` because of this\n-    .suggestion = remove the `async` qualifier\n+parse_nonterminal_expected_statement = expected a statement\n+parse_not_supported = not supported\n \n-parse_nested_c_variadic_type = C-variadic type `...` may not be nested inside another type\n+parse_note_edition_guide = for more on editions, read https://doc.rust-lang.org/edition-guide\n \n-parse_invalid_dyn_keyword = invalid `dyn` keyword\n-    .help = `dyn` is only needed at the start of a trait `+`-separated list\n-    .suggestion = remove this keyword\n+parse_note_mut_pattern_usage = `mut` may be followed by `variable` and `variable @ pattern`\n \n-parse_help_set_edition_cargo = set `edition = \"{$edition}\"` in `Cargo.toml`\n-parse_help_set_edition_standalone = pass `--edition {$edition}` to `rustc`\n-parse_note_edition_guide = for more on editions, read https://doc.rust-lang.org/edition-guide\n+parse_note_pattern_alternatives_use_single_vert = alternatives in or-patterns are separated with `|`, not `||`\n \n-parse_unexpected_token_after_dot = unexpected token: `{$actual}`\n+parse_octal_float_literal_not_supported = octal float literal is not supported\n+parse_or_pattern_not_allowed_in_fn_parameters = top-level or-patterns are not allowed in function parameters\n+parse_or_pattern_not_allowed_in_let_binding = top-level or-patterns are not allowed in `let` bindings\n+parse_out_of_range_hex_escape = out of range hex escape\n+    .label = must be a character in the range [\\x00-\\x7f]\n \n-parse_cannot_be_raw_ident = `{$ident}` cannot be a raw identifier\n+parse_outer_attr_explanation = outer attributes, like `#[test]`, annotate the item following them\n \n-parse_cr_doc_comment = bare CR not allowed in {$block ->\n-    [true] block doc-comment\n-    *[false] doc-comment\n-}\n+parse_outer_attribute_not_allowed_on_if_else = outer attributes are not allowed on `if` and `else` branches\n+    .branch_label = the attributes are attached to this branch\n+    .ctx_label = the branch belongs to this `{$ctx}`\n+    .suggestion = remove the attributes\n \n-parse_no_digits_literal = no valid digits found for number\n+parse_overlong_unicode_escape = overlong unicode escape\n+    .label = must have at most 6 hex digits\n \n-parse_invalid_digit_literal = invalid digit for a base {$base} literal\n+parse_parentheses_with_struct_fields = invalid `struct` delimiters or `fn` call arguments\n+    .suggestion_braces_for_struct = if `{$type}` is a struct, use braces as delimiters\n+    .suggestion_no_fields_for_fn = if `{$type}` is a function, use the arguments directly\n \n-parse_empty_exponent_float = expected at least one digit in exponent\n+parse_parenthesized_lifetime = parenthesized lifetime bounds are not supported\n+    .suggestion = remove the parentheses\n \n-parse_float_literal_unsupported_base = {$base} float literal is not supported\n+parse_path_single_colon = path separator must be a double colon\n+    .suggestion = use a double colon instead\n \n-parse_more_than_one_char = character literal may only contain one codepoint\n-    .followed_by = this `{$chr}` is followed by the combining {$len ->\n-        [one] mark\n-        *[other] marks\n-        } `{$escaped_marks}`\n-    .non_printing = there are non-printing characters, the full sequence is `{$escaped}`\n-    .consider_normalized = consider using the normalized form `{$ch}` of this character\n-    .remove_non = consider removing the non-printing characters\n-    .use_double_quotes = if you meant to write a {$is_byte ->\n-        [true] byte string\n-        *[false] `str`\n-        } literal, use double quotes\n+parse_pattern_method_param_without_body = patterns aren't allowed in methods without bodies\n+    .suggestion = give this argument a name or use an underscore to ignore it\n \n-parse_no_brace_unicode_escape = incorrect unicode escape sequence\n-    .label = {parse_no_brace_unicode_escape}\n-    .use_braces = format of unicode escape sequences uses braces\n-    .format_of_unicode = format of unicode escape sequences is `\\u{\"{...}\"}`\n+parse_pattern_on_wrong_side_of_at = pattern on wrong side of `@`\n+    .label_pattern = pattern on the left, should be on the right\n+    .label_binding = binding on the right, should be on the left\n+    .suggestion = switch the order\n \n-parse_invalid_unicode_escape = invalid unicode character escape\n-    .label = invalid escape\n-    .help = unicode escape must {$surrogate ->\n-    [true] not be a surrogate\n-    *[false] be at most 10FFFF\n-    }\n+parse_question_mark_in_type = invalid `?` in type\n+    .label = `?` is only allowed on expressions, not types\n+    .suggestion = if you meant to express that the type might not contain a value, use the `Option` wrapper type\n \n-parse_escape_only_char = {$byte ->\n-    [true] byte\n-    *[false] character\n-    } constant must be escaped: `{$escaped_msg}`\n-    .escape = escape the character\n+parse_recover_import_as_use = expected item, found {$token_name}\n+    .suggestion = items are imported using the `use` keyword\n \n-parse_bare_cr = {$double_quotes ->\n-    [true] bare CR not allowed in string, use `\\r` instead\n-    *[false] character constant must be escaped: `\\r`\n-    }\n-    .escape = escape the character\n+parse_ref_mut_order_incorrect = the order of `mut` and `ref` is incorrect\n+    .suggestion = try switching the order\n \n-parse_bare_cr_in_raw_string = bare CR not allowed in raw string\n+parse_remove_let = expected pattern, found `let`\n+    .suggestion = remove the unnecessary `let` keyword\n \n-parse_too_short_hex_escape = numeric character escape is too short\n+parse_repeated_mut_in_pattern = `mut` on a binding may not be repeated\n+    .suggestion = remove the additional `mut`s\n \n-parse_invalid_char_in_escape = {parse_invalid_char_in_escape_msg}: `{$ch}`\n-    .label = {parse_invalid_char_in_escape_msg}\n+parse_require_colon_after_labeled_expression = labeled expression must be followed by `:`\n+    .note = labels are used before loops and blocks, allowing e.g., `break 'label` to them\n+    .label = the label\n+    .suggestion = add `:` after the label\n \n-parse_invalid_char_in_escape_msg = invalid character in {$is_hex ->\n-    [true] numeric character\n-    *[false] unicode\n-    } escape\n+parse_return_types_use_thin_arrow = return types are denoted using `->`\n+    .suggestion = use `->` instead\n \n-parse_out_of_range_hex_escape = out of range hex escape\n-    .label = must be a character in the range [\\x00-\\x7f]\n+parse_self_argument_pointer = cannot pass `self` by raw pointer\n+    .label = cannot pass `self` by raw pointer\n \n-parse_leading_underscore_unicode_escape = {parse_leading_underscore_unicode_escape_label}: `_`\n-parse_leading_underscore_unicode_escape_label = invalid start of unicode escape\n+parse_self_param_not_first = unexpected `self` parameter in function\n+    .label = must be the first parameter of an associated function\n \n-parse_overlong_unicode_escape = overlong unicode escape\n-    .label = must have at most 6 hex digits\n+parse_shift_interpreted_as_generic =\n+    `<<` is interpreted as a start of generic arguments for `{$type}`, not a shift\n+    .label_args = interpreted as generic arguments\n+    .label_comparison = not interpreted as shift\n+    .suggestion = try shifting the cast value\n \n-parse_unclosed_unicode_escape = unterminated unicode escape\n-    .label = missing a closing `{\"}\"}`\n-    .terminate = terminate the unicode escape\n+parse_single_colon_import_path = expected `::`, found `:`\n+    .suggestion = use double colon\n+    .note = import paths are delimited using `::`\n \n-parse_unicode_escape_in_byte = unicode escape in byte string\n-    .label = {parse_unicode_escape_in_byte}\n-    .help = unicode escape sequences cannot be used as a byte or in a byte string\n+parse_single_colon_struct_type = found single colon in a struct field type path\n+    .suggestion = write a path separator here\n \n-parse_empty_unicode_escape = empty unicode escape\n-    .label = this escape must have at least 1 hex digit\n+parse_struct_literal_body_without_path =\n+    struct literal body without path\n+    .suggestion = you might have forgotten to add the struct literal inside the block\n \n-parse_zero_chars = empty character literal\n-    .label = {parse_zero_chars}\n+parse_struct_literal_needing_parens =\n+    invalid struct literal\n+    .suggestion = you might need to surround the struct literal in parentheses\n \n-parse_lone_slash = invalid trailing slash in literal\n-    .label = {parse_lone_slash}\n+parse_struct_literal_not_allowed_here = struct literals are not allowed here\n+    .suggestion = surround the struct literal with parentheses\n \n-parse_unskipped_whitespace = whitespace symbol '{$ch}' is not skipped\n-    .label = {parse_unskipped_whitespace}\n+parse_suffixed_literal_in_attribute = suffixed literals are not allowed in attributes\n+    .help = instead of using a suffixed literal (`1u8`, `1.0f32`, etc.), use an unsuffixed version (`1`, `1.0`, etc.)\n \n-parse_multiple_skipped_lines = multiple lines skipped by escaped newline\n-    .label = skipping everything up to and including this point\n+parse_sugg_add_let_for_stmt = you might have meant to introduce a new binding\n \n-parse_unknown_prefix = prefix `{$prefix}` is unknown\n-    .label = unknown prefix\n-    .note =  prefixed identifiers and literals are reserved since Rust 2021\n-    .suggestion_br = use `br` for a raw byte string\n-    .suggestion_whitespace = consider inserting whitespace here\n+parse_sugg_add_semi = add `;` here\n+parse_sugg_change_inner_attr_to_outer = to annotate the {$item}, change the attribute from inner to outer style\n \n-parse_too_many_hashes = too many `#` symbols: raw strings may be delimited by up to 255 `#` symbols, but found {$num}\n+parse_sugg_change_this_to_semi = change this to `;`\n+parse_sugg_escape_identifier = escape `{$ident_name}` to use it as an identifier\n \n-parse_unknown_start_of_token = unknown start of token: {$escaped}\n-    .sugg_quotes = Unicode characters '\u201c' (Left Double Quotation Mark) and '\u201d' (Right Double Quotation Mark) look like '{$ascii_str}' ({$ascii_name}), but are not\n-    .sugg_other = Unicode character '{$ch}' ({$u_name}) looks like '{$ascii_str}' ({$ascii_name}), but it is not\n-    .help_null = source files must contain UTF-8 encoded text, unexpected null bytes might occur when a different encoding is used\n-    .note_repeats = character appears {$repeats ->\n-        [one] once more\n-        *[other] {$repeats} more times\n-    }\n+parse_sugg_remove_comma = remove this comma\n+parse_sugg_remove_leading_vert_in_pattern = remove the `|`\n+parse_sugg_turbofish_syntax = use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n \n-parse_box_syntax_removed = `box_syntax` has been removed\n-    .suggestion = use `Box::new()` instead\n+parse_sugg_wrap_expression_in_parentheses = wrap the expression in parentheses\n \n-parse_bad_return_type_notation_output =\n-    return type not allowed with return type notation\n-    .suggestion = remove the return type\n+parse_sugg_wrap_pattern_in_parens = wrap the pattern in parentheses\n \n-parse_bad_return_type_notation_dotdot =\n-    return type notation uses `()` instead of `(..)` for elided arguments\n-    .suggestion = remove the `..`\n+parse_switch_mut_let_order =\n+    switch the order of `mut` and `let`\n+parse_tilde_const_lifetime = `~const` may only modify trait bounds, not lifetime bounds\n \n-parse_bad_assoc_type_bounds = bounds on associated types do not belong here\n-    .label = belongs in `where` clause\n+parse_tilde_is_not_unary_operator = `~` cannot be used as a unary operator\n+    .suggestion = use `!` to perform bitwise not\n \n-parse_attr_after_generic = trailing attribute after generic parameter\n-    .label = attributes must go before parameters\n+parse_too_many_hashes = too many `#` symbols: raw strings may be delimited by up to 255 `#` symbols, but found {$num}\n \n-parse_attr_without_generics = attribute without generic parameters\n-    .label = attributes are only permitted when preceding parameters\n+parse_too_short_hex_escape = numeric character escape is too short\n \n-parse_where_generics = generic parameters on `where` clauses are reserved for future use\n-    .label = currently unsupported\n+parse_trailing_vert_not_allowed = a trailing `|` is not allowed in an or-pattern\n+    .suggestion = remove the `{$token}`\n \n-parse_generics_in_path = unexpected generic arguments in path\n+parse_trait_alias_cannot_be_auto = trait aliases cannot be `auto`\n+parse_trait_alias_cannot_be_unsafe = trait aliases cannot be `unsafe`\n \n-parse_assoc_lifetime = associated lifetimes are not supported\n-    .label = the lifetime is given here\n-    .help = if you meant to specify a trait object, write `dyn Trait + 'lifetime`\n+parse_type_ascription_removed =\n+    if you meant to annotate an expression with a type, the type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n-parse_tilde_const_lifetime = `~const` may only modify trait bounds, not lifetime bounds\n+parse_unclosed_unicode_escape = unterminated unicode escape\n+    .label = missing a closing `{\"}\"}`\n+    .terminate = terminate the unicode escape\n \n-parse_modifier_lifetime = `{$sigil}` may only modify trait bounds, not lifetime bounds\n-    .suggestion = remove the `{$sigil}`\n+parse_underscore_literal_suffix = underscore literal suffix is not allowed\n \n-parse_parenthesized_lifetime = parenthesized lifetime bounds are not supported\n-    .suggestion = remove the parentheses\n+parse_unexpected_const_in_generic_param = expected lifetime, type, or constant, found keyword `const`\n+    .suggestion = the `const` keyword is only needed in the definition of the type\n \n-parse_const_bounds_missing_tilde = const bounds must start with `~`\n-    .suggestion = add `~`\n+parse_unexpected_const_param_declaration = unexpected `const` parameter declaration\n+    .label = expected a `const` expression, not a parameter declaration\n+    .suggestion = `const` parameters must be declared for the `impl`\n \n-parse_underscore_literal_suffix = underscore literal suffix is not allowed\n+parse_unexpected_default_value_for_lifetime_in_generic_parameters = unexpected default lifetime parameter\n+    .label = lifetime parameters cannot have default values\n \n-parse_expect_label_found_ident = expected a label, found an identifier\n-    .suggestion = labels start with a tick\n+parse_unexpected_if_with_if = unexpected `if` in the condition expression\n+    .suggestion = remove the `if`\n \n-parse_inappropriate_default = {$article} {$descr} cannot be `default`\n-    .label = `default` because of this\n-    .note = only associated `fn`, `const`, and `type` items can be `default`\n+parse_unexpected_lifetime_in_pattern = unexpected lifetime `{$symbol}` in pattern\n+    .suggestion = remove the lifetime\n \n-parse_recover_import_as_use = expected item, found {$token_name}\n-    .suggestion = items are imported using the `use` keyword\n+parse_unexpected_parentheses_in_for_head = unexpected parentheses surrounding `for` loop head\n+    .suggestion = remove parentheses in `for` loop\n \n-parse_single_colon_import_path = expected `::`, found `:`\n-    .suggestion = use double colon\n-    .note = import paths are delimited using `::`\n+parse_unexpected_self_in_generic_parameters = unexpected keyword `Self` in generic parameters\n+    .note = you cannot use `Self` as a generic parameter because it is reserved for associated items\n \n-parse_bad_item_kind = {$descr} is not supported in {$ctx}\n-    .help = consider moving the {$descr} out to a nearby module scope\n+parse_unexpected_token_after_dot = unexpected token: `{$actual}`\n \n-parse_single_colon_struct_type = found single colon in a struct field type path\n-    .suggestion = write a path separator here\n+parse_unexpected_token_after_label = expected `while`, `for`, `loop` or `{\"{\"}` after a label\n+    .suggestion_remove_label = consider removing the label\n+    .suggestion_enclose_in_block = consider enclosing expression in a block\n \n-parse_equals_struct_default = default values on `struct` fields aren't supported\n-    .suggestion = remove this unsupported default value\n+parse_unexpected_token_after_not = unexpected {$negated_desc} after identifier\n+parse_unexpected_token_after_not_bitwise = use `!` to perform bitwise not\n+parse_unexpected_token_after_not_default = use `!` to perform logical negation or bitwise not\n \n-parse_macro_rules_missing_bang = expected `!` after `macro_rules`\n-    .suggestion = add a `!`\n+parse_unexpected_token_after_not_logical = use `!` to perform logical negation\n+parse_unexpected_token_after_struct_name = expected `where`, `{\"{\"}`, `(`, or `;` after struct name\n+parse_unexpected_token_after_struct_name_found_doc_comment = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found doc comment `{$token}`\n+parse_unexpected_token_after_struct_name_found_keyword = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found keyword `{$token}`\n+parse_unexpected_token_after_struct_name_found_other = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found `{$token}`\n \n-parse_macro_name_remove_bang = macro names aren't followed by a `!`\n-    .suggestion = remove the `!`\n+parse_unexpected_token_after_struct_name_found_reserved_identifier = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found reserved identifier `{$token}`\n+parse_unexpected_token_after_struct_name_found_reserved_keyword = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found reserved keyword `{$token}`\n+parse_unexpected_vert_vert_before_function_parameter = unexpected `||` before function parameter\n+    .suggestion = remove the `||`\n \n-parse_macro_rules_visibility = can't qualify macro_rules invocation with `{$vis}`\n-    .suggestion = try exporting the macro\n+parse_unexpected_vert_vert_in_pattern = unexpected token `||` in pattern\n+    .suggestion = use a single `|` to separate multiple alternative patterns\n \n-parse_macro_invocation_visibility = can't qualify macro invocation with `pub`\n-    .suggestion = remove the visibility\n-    .help = try adjusting the macro to put `{$vis}` inside the invocation\n+parse_unicode_escape_in_byte = unicode escape in byte string\n+    .label = {parse_unicode_escape_in_byte}\n+    .help = unicode escape sequences cannot be used as a byte or in a byte string\n \n-parse_nested_adt = `{$kw_str}` definition cannot be nested inside `{$keyword}`\n-    .suggestion = consider creating a new `{$kw_str}` definition instead of nesting\n+parse_unknown_builtin_construct = unknown `builtin #` construct `{$name}`\n \n-parse_function_body_equals_expr = function body cannot be `= expression;`\n-    .suggestion = surround the expression with `{\"{\"}` and `{\"}\"}` instead of `=` and `;`\n+parse_unknown_prefix = prefix `{$prefix}` is unknown\n+    .label = unknown prefix\n+    .note =  prefixed identifiers and literals are reserved since Rust 2021\n+    .suggestion_br = use `br` for a raw byte string\n+    .suggestion_whitespace = consider inserting whitespace here\n \n-parse_box_not_pat = expected pattern, found {$descr}\n-    .note = `box` is a reserved keyword\n-    .suggestion = escape `box` to use it as an identifier\n+parse_unknown_start_of_token = unknown start of token: {$escaped}\n+    .sugg_quotes = Unicode characters '\u201c' (Left Double Quotation Mark) and '\u201d' (Right Double Quotation Mark) look like '{$ascii_str}' ({$ascii_name}), but are not\n+    .sugg_other = Unicode character '{$ch}' ({$u_name}) looks like '{$ascii_str}' ({$ascii_name}), but it is not\n+    .help_null = source files must contain UTF-8 encoded text, unexpected null bytes might occur when a different encoding is used\n+    .note_repeats = character appears {$repeats ->\n+        [one] once more\n+        *[other] {$repeats} more times\n+    }\n \n parse_unmatched_angle = unmatched angle {$plural ->\n     [true] brackets\n@@ -841,19 +821,39 @@ parse_unmatched_angle = unmatched angle {$plural ->\n     *[false] bracket\n     }\n \n-parse_missing_plus_in_bounds = expected `+` between lifetime and {$sym}\n-    .suggestion = add `+`\n+parse_unmatched_angle_brackets = {$num_extra_brackets ->\n+        [one] unmatched angle bracket\n+       *[other] unmatched angle brackets\n+    }\n+    .suggestion = {$num_extra_brackets ->\n+            [one] remove extra angle bracket\n+           *[other] remove extra angle brackets\n+        }\n \n-parse_incorrect_braces_trait_bounds = incorrect braces around trait bounds\n-    .suggestion = remove the parentheses\n+parse_unskipped_whitespace = whitespace symbol '{$ch}' is not skipped\n+    .label = {parse_unskipped_whitespace}\n \n-parse_kw_bad_case = keyword `{$kw}` is written in the wrong case\n-    .suggestion = write it in the correct case\n+parse_use_empty_block_not_semi = expected { \"`{}`\" }, found `;`\n+    .suggestion = try using { \"`{}`\" } instead\n \n-parse_meta_bad_delim = wrong meta list delimiters\n-parse_cfg_attr_bad_delim = wrong `cfg_attr` delimiters\n-parse_meta_bad_delim_suggestion = the delimiters should be `(` and `)`\n+parse_use_eq_instead = unexpected `==`\n+    .suggestion = try using `=` instead\n \n-parse_malformed_cfg_attr = malformed `cfg_attr` attribute input\n-    .suggestion = missing condition and attribute\n-    .note = for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n+parse_use_let_not_auto = write `let` instead of `auto` to introduce a new variable\n+parse_use_let_not_var = write `let` instead of `var` to introduce a new variable\n+\n+parse_visibility_not_followed_by_item = visibility `{$vis}` is not followed by an item\n+    .label = the visibility\n+    .help = you likely meant to define an item, e.g., `{$vis} fn foo() {\"{}\"}`\n+\n+parse_where_clause_before_tuple_struct_body = where clauses are not allowed before tuple struct bodies\n+    .label = unexpected where clause\n+    .name_label = while parsing this tuple struct\n+    .body_label = the struct body\n+    .suggestion = move the body before the where clause\n+\n+parse_where_generics = generic parameters on `where` clauses are reserved for future use\n+    .label = currently unsupported\n+\n+parse_zero_chars = empty character literal\n+    .label = {parse_zero_chars}"}, {"sha": "7f9222dac6c4c69c9aa7a11c25d955610a150327", "filename": "compiler/rustc_passes/messages.ftl", "status": "modified", "additions": 536, "deletions": 536, "changes": 1072, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_passes%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_passes%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -4,533 +4,489 @@\n -passes_see_issue =\n     see issue #{$issue} <https://github.com/rust-lang/rust/issues/{$issue}> for more information\n \n-passes_incorrect_do_not_recommend_location =\n-    `#[do_not_recommend]` can only be placed on trait implementations\n+passes_abi =\n+    abi: {$abi}\n \n-passes_outer_crate_level_attr =\n-    crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n+passes_align =\n+    align: {$align}\n \n-passes_inner_crate_level_attr =\n-    crate-level attribute should be in the root module\n+passes_allow_incoherent_impl =\n+    `rustc_allow_incoherent_impl` attribute should be applied to impl items.\n+    .label = the only currently supported targets are inherent methods\n \n-passes_ignored_attr_with_macro =\n-    `#[{$sym}]` is ignored on struct fields, match arms and macro defs\n-    .warn = {-passes_previously_accepted}\n-    .note = {-passes_see_issue(issue: \"80564\")}\n+passes_allow_internal_unstable =\n+    attribute should be applied to a macro\n+    .label = not a macro\n \n-passes_ignored_attr =\n-    `#[{$sym}]` is ignored on struct fields and match arms\n-    .warn = {-passes_previously_accepted}\n-    .note = {-passes_see_issue(issue: \"80564\")}\n+passes_attr_application_enum =\n+    attribute should be applied to an enum\n+    .label = not an enum\n \n-passes_inline_ignored_function_prototype =\n-    `#[inline]` is ignored on function prototypes\n+passes_attr_application_struct =\n+    attribute should be applied to a struct\n+    .label = not a struct\n \n-passes_inline_ignored_constants =\n-    `#[inline]` is ignored on constants\n-    .warn = {-passes_previously_accepted}\n-    .note = {-passes_see_issue(issue: \"65833\")}\n+passes_attr_application_struct_enum_function_method_union =\n+    attribute should be applied to a struct, enum, function, associated function, or union\n+    .label = not a struct, enum, function, associated function, or union\n \n-passes_inline_not_fn_or_closure =\n-    attribute should be applied to function or closure\n-    .label = not a function or closure\n+passes_attr_application_struct_enum_union =\n+    attribute should be applied to a struct, enum, or union\n+    .label = not a struct, enum, or union\n \n-passes_no_coverage_ignored_function_prototype =\n-    `#[no_coverage]` is ignored on function prototypes\n+passes_attr_application_struct_union =\n+    attribute should be applied to a struct or union\n+    .label = not a struct or union\n \n-passes_no_coverage_propagate =\n-    `#[no_coverage]` does not propagate into items and must be applied to the contained functions directly\n+passes_attr_crate_level =\n+    this attribute can only be applied at the crate level\n+    .suggestion = to apply to the crate, use an inner attribute\n+    .note = read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n \n-passes_no_coverage_fn_defn =\n-    `#[no_coverage]` may only be applied to function definitions\n+passes_attr_only_in_functions =\n+    `{$attr}` attribute can only be used on functions\n \n-passes_no_coverage_not_coverable =\n-    `#[no_coverage]` must be applied to coverable code\n-    .label = not coverable code\n+passes_attr_only_on_main =\n+    `{$attr}` attribute can only be used on `fn main()`\n \n-passes_should_be_applied_to_fn =\n-    attribute should be applied to a function definition\n-    .label = {$on_crate ->\n-        [true] cannot be applied to crates\n-        *[false] not a function definition\n-    }\n+passes_attr_only_on_root_main =\n+    `{$attr}` attribute can only be used on root `fn main()`\n \n-passes_naked_tracked_caller =\n-    cannot use `#[track_caller]` with `#[naked]`\n+passes_both_ffi_const_and_pure =\n+    `#[ffi_const]` function cannot be `#[ffi_pure]`\n \n-passes_should_be_applied_to_struct_enum =\n-    attribute should be applied to a struct or enum\n-    .label = not a struct or enum\n+passes_break_inside_async_block =\n+    `{$name}` inside of an `async` block\n+    .label = cannot `{$name}` inside of an `async` block\n+    .async_block_label = enclosing `async` block\n \n-passes_should_be_applied_to_trait =\n-    attribute should be applied to a trait\n-    .label = not a trait\n+passes_break_inside_closure =\n+    `{$name}` inside of a closure\n+    .label = cannot `{$name}` inside of a closure\n+    .closure_label = enclosing closure\n \n-passes_target_feature_on_statement =\n+passes_break_non_loop =\n+    `break` with value from a `{$kind}` loop\n+    .label = can only break with a value inside `loop` or breakable block\n+    .label2 = you can't `break` with a value in a `{$kind}` loop\n+    .suggestion = use `break` on its own without a value inside this `{$kind}` loop\n+    .break_expr_suggestion = alternatively, you might have meant to use the available loop label\n+\n+passes_cannot_inline_naked_function =\n+    naked functions cannot be inlined\n+\n+passes_cannot_stabilize_deprecated =\n+    an API can't be stabilized after it is deprecated\n+    .label = invalid version\n+    .item = the stability attribute annotates this item\n+\n+passes_change_fields_to_be_of_unit_type =\n+    consider changing the { $num ->\n+      [one] field\n+     *[other] fields\n+    } to be of unit type to suppress this warning while preserving the field numbering, or remove the { $num ->\n+      [one] field\n+     *[other] fields\n+    }\n+\n+passes_cold =\n     {passes_should_be_applied_to_fn}\n     .warn = {-passes_previously_accepted}\n     .label = {passes_should_be_applied_to_fn.label}\n \n-passes_should_be_applied_to_static =\n-    attribute should be applied to a static\n-    .label = not a static\n+passes_collapse_debuginfo =\n+    `collapse_debuginfo` attribute should be applied to macro definitions\n+    .label = not a macro definition\n \n-passes_doc_expect_str =\n-    doc {$attr_name} attribute expects a string: #[doc({$attr_name} = \"a\")]\n+passes_const_impl_const_trait =\n+    const `impl`s must be for traits marked with `#[const_trait]`\n+    .note = this trait must be annotated with `#[const_trait]`\n \n-passes_doc_alias_empty =\n-    {$attr_str} attribute cannot have empty value\n+passes_const_trait =\n+    attribute should be applied to a trait\n+\n+passes_continue_labeled_block =\n+    `continue` pointing to a labeled block\n+    .label = labeled blocks cannot be `continue`'d\n+    .block_label = labeled block the `continue` points to\n+\n+passes_dead_codes =\n+    { $multiple ->\n+      *[true] multiple {$descr}s are\n+       [false] { $num ->\n+         [one] {$descr} {$name_list} is\n+        *[other] {$descr}s {$name_list} are\n+       }\n+    } never {$participle}\n+\n+passes_debug_visualizer_invalid =\n+    invalid argument\n+    .note_1 = expected: `natvis_file = \"...\"`\n+    .note_2 = OR\n+    .note_3 = expected: `gdb_script_file = \"...\"`\n+\n+passes_debug_visualizer_placement =\n+    attribute should be applied to a module\n+\n+passes_debug_visualizer_unreadable =\n+    couldn't read {$file}: {$error}\n+\n+passes_deprecated =\n+    attribute is ignored here\n+\n+passes_deprecated_annotation_has_no_effect =\n+    this `#[deprecated]` annotation has no effect\n+    .suggestion = remove the unnecessary deprecation attribute\n+\n+passes_deprecated_attribute =\n+    deprecated attribute must be paired with either stable or unstable attribute\n+\n+passes_diagnostic_item_first_defined =\n+    the diagnostic item is first defined here\n \n passes_doc_alias_bad_char =\n     {$char_} character isn't allowed in {$attr_str}\n \n-passes_doc_alias_start_end =\n-    {$attr_str} cannot start or end with ' '\n-\n passes_doc_alias_bad_location =\n     {$attr_str} isn't allowed on {$location}\n \n-passes_doc_alias_not_an_alias =\n-    {$attr_str} is the same as the item's name\n-\n passes_doc_alias_duplicated = doc alias is duplicated\n     .label = first defined here\n \n-passes_doc_alias_not_string_literal =\n-    `#[doc(alias(\"a\"))]` expects string literals\n+passes_doc_alias_empty =\n+    {$attr_str} attribute cannot have empty value\n \n passes_doc_alias_malformed =\n     doc alias attribute expects a string `#[doc(alias = \"a\")]` or a list of strings `#[doc(alias(\"a\", \"b\"))]`\n \n-passes_doc_keyword_empty_mod =\n-    `#[doc(keyword = \"...\")]` should be used on empty modules\n+passes_doc_alias_not_an_alias =\n+    {$attr_str} is the same as the item's name\n \n-passes_doc_keyword_not_mod =\n-    `#[doc(keyword = \"...\")]` should be used on modules\n+passes_doc_alias_not_string_literal =\n+    `#[doc(alias(\"a\"))]` expects string literals\n \n-passes_doc_keyword_invalid_ident =\n-    `{$doc_keyword}` is not a valid identifier\n+passes_doc_alias_start_end =\n+    {$attr_str} cannot start or end with ' '\n+\n+passes_doc_attr_not_crate_level =\n+    `#![doc({$attr_name} = \"...\")]` isn't allowed as a crate-level attribute\n+\n+passes_doc_cfg_hide_takes_list =\n+    `#[doc(cfg_hide(...)]` takes a list of attributes\n+\n+passes_doc_expect_str =\n+    doc {$attr_name} attribute expects a string: #[doc({$attr_name} = \"a\")]\n \n passes_doc_fake_variadic_not_valid =\n     `#[doc(fake_variadic)]` must be used on the first of a set of tuple or fn pointer trait impls with varying arity\n \n-passes_doc_keyword_only_impl =\n-    `#[doc(keyword = \"...\")]` should be used on impl blocks\n+passes_doc_inline_conflict =\n+    conflicting doc inlining attributes\n+    .help = remove one of the conflicting attributes\n \n passes_doc_inline_conflict_first =\n     this attribute...\n \n passes_doc_inline_conflict_second =\n     {\".\"}..conflicts with this attribute\n \n-passes_doc_inline_conflict =\n-    conflicting doc inlining attributes\n-    .help = remove one of the conflicting attributes\n-\n passes_doc_inline_only_use =\n     this attribute can only be applied to a `use` item\n     .label = only applicable on `use` items\n     .not_a_use_item_label = not a `use` item\n     .note = read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline> for more information\n \n-passes_doc_attr_not_crate_level =\n-    `#![doc({$attr_name} = \"...\")]` isn't allowed as a crate-level attribute\n+passes_doc_invalid =\n+    invalid `doc` attribute\n \n-passes_attr_crate_level =\n-    this attribute can only be applied at the crate level\n-    .suggestion = to apply to the crate, use an inner attribute\n-    .note = read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n+passes_doc_keyword_empty_mod =\n+    `#[doc(keyword = \"...\")]` should be used on empty modules\n \n-passes_doc_test_unknown =\n-    unknown `doc(test)` attribute `{$path}`\n+passes_doc_keyword_invalid_ident =\n+    `{$doc_keyword}` is not a valid identifier\n+\n+passes_doc_keyword_not_mod =\n+    `#[doc(keyword = \"...\")]` should be used on modules\n+\n+passes_doc_keyword_only_impl =\n+    `#[doc(keyword = \"...\")]` should be used on impl blocks\n \n passes_doc_test_takes_list =\n     `#[doc(test(...)]` takes a list of attributes\n \n-passes_doc_cfg_hide_takes_list =\n-    `#[doc(cfg_hide(...)]` takes a list of attributes\n+passes_doc_test_unknown =\n+    unknown `doc(test)` attribute `{$path}`\n \n passes_doc_test_unknown_any =\n     unknown `doc` attribute `{$path}`\n \n+passes_doc_test_unknown_include =\n+    unknown `doc` attribute `{$path}`\n+    .suggestion = use `doc = include_str!` instead\n+\n passes_doc_test_unknown_spotlight =\n     unknown `doc` attribute `{$path}`\n     .note = `doc(spotlight)` was renamed to `doc(notable_trait)`\n     .suggestion = use `notable_trait` instead\n     .no_op_note = `doc(spotlight)` is now a no-op\n \n-passes_doc_test_unknown_include =\n-    unknown `doc` attribute `{$path}`\n-    .suggestion = use `doc = include_str!` instead\n-\n-passes_doc_invalid =\n-    invalid `doc` attribute\n+passes_duplicate_diagnostic_item_in_crate =\n+    duplicate diagnostic item in crate `{$crate_name}`: `{$name}`.\n+    .note = the diagnostic item is first defined in crate `{$orig_crate_name}`.\n \n-passes_pass_by_value =\n-    `pass_by_value` attribute should be applied to a struct, enum or type alias\n-    .label = is not a struct, enum or type alias\n+passes_duplicate_feature_err =\n+    the feature `{$feature}` has already been declared\n \n-passes_allow_incoherent_impl =\n-    `rustc_allow_incoherent_impl` attribute should be applied to impl items.\n-    .label = the only currently supported targets are inherent methods\n+passes_duplicate_lang_item =\n+    found duplicate lang item `{$lang_item_name}`\n+    .first_defined_span = the lang item is first defined here\n+    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n+    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n+    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n+    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n+    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n+    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n \n-passes_has_incoherent_inherent_impl =\n-    `rustc_has_incoherent_inherent_impls` attribute should be applied to types or traits.\n-    .label = only adts, extern types and traits are supported\n+passes_duplicate_lang_item_crate =\n+    duplicate lang item in crate `{$crate_name}`: `{$lang_item_name}`.\n+    .first_defined_span = the lang item is first defined here\n+    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n+    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n+    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n+    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n+    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n+    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n \n-passes_both_ffi_const_and_pure =\n-    `#[ffi_const]` function cannot be `#[ffi_pure]`\n+passes_duplicate_lang_item_crate_depends =\n+    duplicate lang item in crate `{$crate_name}` (which `{$dependency_of}` depends on): `{$lang_item_name}`.\n+    .first_defined_span = the lang item is first defined here\n+    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n+    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n+    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n+    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n+    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n+    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n \n-passes_ffi_pure_invalid_target =\n-    `#[ffi_pure]` may only be used on foreign functions\n+passes_export_name =\n+    attribute should be applied to a free function, impl method or static\n+    .label = not a free function, impl method or static\n+\n+passes_expr_not_allowed_in_context =\n+    {$expr} is not allowed in a `{$context}`\n+\n+passes_extern_main =\n+    the `main` function cannot be declared in an `extern` block\n+\n+passes_feature_only_on_nightly =\n+    `#![feature]` may not be used on the {$release_channel} release channel\n+\n+passes_feature_previously_declared =\n+    feature `{$feature}` is declared {$declared}, but was previously declared {$prev_declared}\n+\n+passes_feature_stable_twice =\n+    feature `{$feature}` is declared stable since {$since}, but was previously declared stable since {$prev_since}\n \n passes_ffi_const_invalid_target =\n     `#[ffi_const]` may only be used on foreign functions\n \n+passes_ffi_pure_invalid_target =\n+    `#[ffi_pure]` may only be used on foreign functions\n+\n passes_ffi_returns_twice_invalid_target =\n     `#[ffi_returns_twice]` may only be used on foreign functions\n \n-passes_must_use_async =\n-    `must_use` attribute on `async` functions applies to the anonymous `Future` returned by the function, not the value within\n-    .label = this attribute does nothing, the `Future`s returned by async functions are already `must_use`\n-\n-passes_must_use_no_effect =\n-    `#[must_use]` has no effect when applied to {$article} {$target}\n-\n-passes_must_not_suspend =\n-    `must_not_suspend` attribute should be applied to a struct, enum, or trait\n-    .label = is not a struct, enum, or trait\n+passes_has_incoherent_inherent_impl =\n+    `rustc_has_incoherent_inherent_impls` attribute should be applied to types or traits.\n+    .label = only adts, extern types and traits are supported\n \n-passes_cold =\n-    {passes_should_be_applied_to_fn}\n-    .warn = {-passes_previously_accepted}\n-    .label = {passes_should_be_applied_to_fn.label}\n+passes_homogeneous_aggregate =\n+    homogeneous_aggregate: {$homogeneous_aggregate}\n \n-passes_link =\n-    attribute should be applied to an `extern` block with non-Rust ABI\n+passes_ignored_attr =\n+    `#[{$sym}]` is ignored on struct fields and match arms\n     .warn = {-passes_previously_accepted}\n-    .label = not an `extern` block\n+    .note = {-passes_see_issue(issue: \"80564\")}\n \n-passes_link_name =\n-    attribute should be applied to a foreign function or static\n+passes_ignored_attr_with_macro =\n+    `#[{$sym}]` is ignored on struct fields, match arms and macro defs\n     .warn = {-passes_previously_accepted}\n-    .label = not a foreign function or static\n-    .help = try `#[link(name = \"{$value}\")]` instead\n-\n-passes_no_link =\n-    attribute should be applied to an `extern crate` item\n-    .label = not an `extern crate` item\n-\n-passes_export_name =\n-    attribute should be applied to a free function, impl method or static\n-    .label = not a free function, impl method or static\n-\n-passes_rustc_layout_scalar_valid_range_not_struct =\n-    attribute should be applied to a struct\n-    .label = not a struct\n+    .note = {-passes_see_issue(issue: \"80564\")}\n \n-passes_rustc_layout_scalar_valid_range_arg =\n-    expected exactly one integer literal argument\n+passes_ignored_derived_impls =\n+    `{$name}` has {$trait_list_len ->\n+      [one] a derived impl\n+     *[other] derived impls\n+    } for the {$trait_list_len ->\n+      [one] trait {$trait_list}, but this is\n+     *[other] traits {$trait_list}, but these are\n+    } intentionally ignored during dead code analysis\n \n-passes_rustc_legacy_const_generics_only =\n-    #[rustc_legacy_const_generics] functions must only have const generics\n-    .label = non-const generic parameter\n+passes_implied_feature_not_exist =\n+    feature `{$implied_by}` implying `{$feature}` does not exist\n \n-passes_rustc_legacy_const_generics_index =\n-    #[rustc_legacy_const_generics] must have one index for each generic parameter\n-    .label = generic parameters\n+passes_incorrect_do_not_recommend_location =\n+    `#[do_not_recommend]` can only be placed on trait implementations\n \n-passes_rustc_legacy_const_generics_index_exceed =\n-    index exceeds number of arguments\n-    .label = there {$arg_count ->\n-        [one] is\n-        *[other] are\n-    } only {$arg_count} {$arg_count ->\n+passes_incorrect_target =\n+    `{$name}` language item must be applied to a {$kind} with {$at_least ->\n+        [true] at least {$num}\n+        *[false] {$num}\n+    } generic {$num ->\n+        [one] argument\n+        *[other] arguments\n+    }\n+    .label = this {$kind} has {$actual_num} generic {$actual_num ->\n         [one] argument\n         *[other] arguments\n     }\n \n-passes_rustc_legacy_const_generics_index_negative =\n-    arguments should be non-negative integers\n-\n-passes_rustc_dirty_clean =\n-    attribute requires -Z query-dep-graph to be enabled\n-\n-passes_link_section =\n-    attribute should be applied to a function or static\n-    .warn = {-passes_previously_accepted}\n-    .label = not a function or static\n-\n-passes_no_mangle_foreign =\n-    `#[no_mangle]` has no effect on a foreign {$foreign_item_kind}\n-    .warn = {-passes_previously_accepted}\n-    .label = foreign {$foreign_item_kind}\n-    .note = symbol names in extern blocks are not mangled\n-    .suggestion = remove this attribute\n+passes_ineffective_unstable_impl = an `#[unstable]` annotation here has no effect\n+    .note = see issue #55436 <https://github.com/rust-lang/rust/issues/55436> for more information\n \n-passes_no_mangle =\n-    attribute should be applied to a free function, impl method or static\n+passes_inline_ignored_constants =\n+    `#[inline]` is ignored on constants\n     .warn = {-passes_previously_accepted}\n-    .label = not a free function, impl method or static\n-\n-passes_repr_ident =\n-    meta item in `repr` must be an identifier\n-\n-passes_repr_conflicting =\n-    conflicting representation hints\n-\n-passes_used_static =\n-    attribute must be applied to a `static` variable\n-\n-passes_used_compiler_linker =\n-    `used(compiler)` and `used(linker)` can't be used together\n-\n-passes_allow_internal_unstable =\n-    attribute should be applied to a macro\n-    .label = not a macro\n-\n-passes_debug_visualizer_placement =\n-    attribute should be applied to a module\n-\n-passes_debug_visualizer_invalid =\n-    invalid argument\n-    .note_1 = expected: `natvis_file = \"...\"`\n-    .note_2 = OR\n-    .note_3 = expected: `gdb_script_file = \"...\"`\n-\n-passes_debug_visualizer_unreadable =\n-    couldn't read {$file}: {$error}\n-\n-passes_rustc_allow_const_fn_unstable =\n-    attribute should be applied to `const fn`\n-    .label = not a `const fn`\n-\n-passes_rustc_std_internal_symbol =\n-    attribute should be applied to functions or statics\n-    .label = not a function or static\n-\n-passes_const_trait =\n-    attribute should be applied to a trait\n-\n-passes_stability_promotable =\n-    attribute cannot be applied to an expression\n-\n-passes_deprecated =\n-    attribute is ignored here\n-\n-passes_macro_use =\n-    `#[{$name}]` only has an effect on `extern crate` and modules\n-\n-passes_macro_export =\n-    `#[macro_export]` only has an effect on macro definitions\n-\n-passes_plugin_registrar =\n-    `#[plugin_registrar]` only has an effect on functions\n-\n-passes_unused_empty_lints_note =\n-    attribute `{$name}` with an empty list has no effect\n-\n-passes_unused_no_lints_note =\n-    attribute `{$name}` without any lints has no effect\n-\n-passes_unused_default_method_body_const_note =\n-    `default_method_body_is_const` has been replaced with `#[const_trait]` on traits\n+    .note = {-passes_see_issue(issue: \"65833\")}\n \n-passes_unused =\n-    unused attribute\n-    .suggestion = remove this attribute\n+passes_inline_ignored_function_prototype =\n+    `#[inline]` is ignored on function prototypes\n \n-passes_non_exported_macro_invalid_attrs =\n+passes_inline_not_fn_or_closure =\n     attribute should be applied to function or closure\n     .label = not a function or closure\n \n-passes_unused_duplicate =\n-    unused attribute\n-    .suggestion = remove this attribute\n-    .note = attribute also specified here\n-    .warn = {-passes_previously_accepted}\n-\n-passes_unused_multiple =\n-    multiple `{$name}` attributes\n-    .suggestion = remove this attribute\n-    .note = attribute also specified here\n-\n-passes_rustc_lint_opt_ty =\n-    `#[rustc_lint_opt_ty]` should be applied to a struct\n-    .label = not a struct\n-\n-passes_rustc_lint_opt_deny_field_access =\n-    `#[rustc_lint_opt_deny_field_access]` should be applied to a field\n-    .label = not a field\n-\n-passes_link_ordinal =\n-    attribute should be applied to a foreign function or static\n-    .label = not a foreign function or static\n-\n-passes_collapse_debuginfo =\n-    `collapse_debuginfo` attribute should be applied to macro definitions\n-    .label = not a macro definition\n-\n-passes_deprecated_annotation_has_no_effect =\n-    this `#[deprecated]` annotation has no effect\n-    .suggestion = remove the unnecessary deprecation attribute\n-\n-passes_unknown_external_lang_item =\n-    unknown external lang item: `{$lang_item}`\n-\n-passes_missing_panic_handler =\n-    `#[panic_handler]` function required, but not found\n-\n-passes_missing_lang_item =\n-    language item required, but not found: `{$name}`\n-    .note = this can occur when a binary crate with `#![no_std]` is compiled for a target where `{$name}` is defined in the standard library\n-    .help = you may be able to compile for a target that doesn't need `{$name}`, specify a target with `--target` or in `.cargo/config`\n-\n-passes_lang_item_on_incorrect_target =\n-    `{$name}` language item must be applied to a {$expected_target}\n-    .label = attribute should be applied to a {$expected_target}, not a {$actual_target}\n-\n-passes_unknown_lang_item =\n-    definition of an unknown language item: `{$name}`\n-    .label = definition of unknown language item `{$name}`\n+passes_inner_crate_level_attr =\n+    crate-level attribute should be in the root module\n \n passes_invalid_attr_at_crate_level =\n     `{$name}` attribute cannot be used at crate level\n     .suggestion = perhaps you meant to use an outer attribute\n \n-passes_duplicate_diagnostic_item_in_crate =\n-    duplicate diagnostic item in crate `{$crate_name}`: `{$name}`.\n-    .note = the diagnostic item is first defined in crate `{$orig_crate_name}`.\n+passes_invalid_deprecation_version =\n+    invalid deprecation version found\n+    .label = invalid deprecation version\n+    .item = the stability attribute annotates this item\n \n-passes_diagnostic_item_first_defined =\n-    the diagnostic item is first defined here\n+passes_invalid_macro_export_arguments = `{$name}` isn't a valid `#[macro_export]` argument\n \n-passes_abi =\n-    abi: {$abi}\n+passes_invalid_macro_export_arguments_too_many_items = `#[macro_export]` can only take 1 or 0 arguments\n \n-passes_align =\n-    align: {$align}\n+passes_invalid_stability =\n+    invalid stability version found\n+    .label = invalid stability version\n+    .item = the stability attribute annotates this item\n \n-passes_size =\n-    size: {$size}\n+passes_lang_item_on_incorrect_target =\n+    `{$name}` language item must be applied to a {$expected_target}\n+    .label = attribute should be applied to a {$expected_target}, not a {$actual_target}\n \n-passes_homogeneous_aggregate =\n-    homogeneous_aggregate: {$homogeneous_aggregate}\n+passes_layout =\n+    layout error: {$layout_error}\n \n passes_layout_of =\n     layout_of({$normalized_ty}) = {$ty_layout}\n \n-passes_unrecognized_field =\n-    unrecognized field name `{$name}`\n-\n-passes_layout =\n-    layout error: {$layout_error}\n+passes_link =\n+    attribute should be applied to an `extern` block with non-Rust ABI\n+    .warn = {-passes_previously_accepted}\n+    .label = not an `extern` block\n \n-passes_feature_stable_twice =\n-    feature `{$feature}` is declared stable since {$since}, but was previously declared stable since {$prev_since}\n+passes_link_name =\n+    attribute should be applied to a foreign function or static\n+    .warn = {-passes_previously_accepted}\n+    .label = not a foreign function or static\n+    .help = try `#[link(name = \"{$value}\")]` instead\n \n-passes_feature_previously_declared =\n-    feature `{$feature}` is declared {$declared}, but was previously declared {$prev_declared}\n+passes_link_ordinal =\n+    attribute should be applied to a foreign function or static\n+    .label = not a foreign function or static\n \n-passes_expr_not_allowed_in_context =\n-    {$expr} is not allowed in a `{$context}`\n+passes_link_section =\n+    attribute should be applied to a function or static\n+    .warn = {-passes_previously_accepted}\n+    .label = not a function or static\n \n-passes_const_impl_const_trait =\n-    const `impl`s must be for traits marked with `#[const_trait]`\n-    .note = this trait must be annotated with `#[const_trait]`\n+passes_macro_export =\n+    `#[macro_export]` only has an effect on macro definitions\n \n-passes_break_non_loop =\n-    `break` with value from a `{$kind}` loop\n-    .label = can only break with a value inside `loop` or breakable block\n-    .label2 = you can't `break` with a value in a `{$kind}` loop\n-    .suggestion = use `break` on its own without a value inside this `{$kind}` loop\n-    .break_expr_suggestion = alternatively, you might have meant to use the available loop label\n+passes_macro_use =\n+    `#[{$name}]` only has an effect on `extern crate` and modules\n \n-passes_continue_labeled_block =\n-    `continue` pointing to a labeled block\n-    .label = labeled blocks cannot be `continue`'d\n-    .block_label = labeled block the `continue` points to\n+passes_maybe_string_interpolation = you might have meant to use string interpolation in this string literal\n+passes_missing_const_err =\n+    attributes `#[rustc_const_unstable]` and `#[rustc_const_stable]` require the function or method to be `const`\n+    .help = make the function or method const\n+    .label = attribute specified here\n \n-passes_break_inside_closure =\n-    `{$name}` inside of a closure\n-    .label = cannot `{$name}` inside of a closure\n-    .closure_label = enclosing closure\n+passes_missing_const_stab_attr =\n+    {$descr} has missing const stability attribute\n \n-passes_break_inside_async_block =\n-    `{$name}` inside of an `async` block\n-    .label = cannot `{$name}` inside of an `async` block\n-    .async_block_label = enclosing `async` block\n+passes_missing_lang_item =\n+    language item required, but not found: `{$name}`\n+    .note = this can occur when a binary crate with `#![no_std]` is compiled for a target where `{$name}` is defined in the standard library\n+    .help = you may be able to compile for a target that doesn't need `{$name}`, specify a target with `--target` or in `.cargo/config`\n \n-passes_outside_loop =\n-    `{$name}` outside of a loop{$is_break ->\n-        [true] {\" or labeled block\"}\n-        *[false] {\"\"}\n-    }\n-    .label = cannot `{$name}` outside of a loop{$is_break ->\n-        [true] {\" or labeled block\"}\n-        *[false] {\"\"}\n-    }\n+passes_missing_panic_handler =\n+    `#[panic_handler]` function required, but not found\n \n-passes_unlabeled_in_labeled_block =\n-    unlabeled `{$cf_type}` inside of a labeled block\n-    .label = `{$cf_type}` statements that would diverge to or through a labeled block need to bear a label\n+passes_missing_stability_attr =\n+    {$descr} has missing stability attribute\n \n-passes_unlabeled_cf_in_while_condition =\n-    `break` or `continue` with no label in the condition of a `while` loop\n-    .label = unlabeled `{$cf_type}` in the condition of a `while` loop\n+passes_multiple_rustc_main =\n+    multiple functions with a `#[rustc_main]` attribute\n+    .first = first `#[rustc_main]` function\n+    .additional = additional `#[rustc_main]` function\n \n-passes_cannot_inline_naked_function =\n-    naked functions cannot be inlined\n+passes_multiple_start_functions =\n+    multiple `start` functions\n+    .label = multiple `start` functions\n+    .previous = previous `#[start]` function here\n \n-passes_undefined_naked_function_abi =\n-    Rust ABI is unsupported in naked functions\n+passes_must_not_suspend =\n+    `must_not_suspend` attribute should be applied to a struct, enum, or trait\n+    .label = is not a struct, enum, or trait\n \n-passes_no_patterns =\n-    patterns not allowed in naked function parameters\n+passes_must_use_async =\n+    `must_use` attribute on `async` functions applies to the anonymous `Future` returned by the function, not the value within\n+    .label = this attribute does nothing, the `Future`s returned by async functions are already `must_use`\n \n-passes_params_not_allowed =\n-    referencing function parameters is not allowed in naked functions\n-    .help = follow the calling convention in asm block to use parameters\n+passes_must_use_no_effect =\n+    `#[must_use]` has no effect when applied to {$article} {$target}\n \n passes_naked_functions_asm_block =\n     naked functions must contain a single asm block\n     .label_multiple_asm = multiple asm blocks are unsupported in naked functions\n     .label_non_asm = non-asm is unsupported in naked functions\n \n-passes_naked_functions_operands =\n-    only `const` and `sym` operands are supported in naked functions\n-\n passes_naked_functions_asm_options =\n     asm options unsupported in naked functions: {$unsupported_options}\n \n passes_naked_functions_must_use_noreturn =\n     asm in naked functions must use `noreturn` option\n     .suggestion = consider specifying that the asm block is responsible for returning from the function\n \n-passes_attr_only_on_main =\n-    `{$attr}` attribute can only be used on `fn main()`\n+passes_naked_functions_operands =\n+    only `const` and `sym` operands are supported in naked functions\n \n-passes_attr_only_on_root_main =\n-    `{$attr}` attribute can only be used on root `fn main()`\n+passes_naked_tracked_caller =\n+    cannot use `#[track_caller]` with `#[naked]`\n \n-passes_attr_only_in_functions =\n-    `{$attr}` attribute can only be used on functions\n+passes_no_coverage_fn_defn =\n+    `#[no_coverage]` may only be applied to function definitions\n \n-passes_multiple_rustc_main =\n-    multiple functions with a `#[rustc_main]` attribute\n-    .first = first `#[rustc_main]` function\n-    .additional = additional `#[rustc_main]` function\n+passes_no_coverage_ignored_function_prototype =\n+    `#[no_coverage]` is ignored on function prototypes\n \n-passes_multiple_start_functions =\n-    multiple `start` functions\n-    .label = multiple `start` functions\n-    .previous = previous `#[start]` function here\n+passes_no_coverage_not_coverable =\n+    `#[no_coverage]` must be applied to coverable code\n+    .label = not coverable code\n \n-passes_extern_main =\n-    the `main` function cannot be declared in an `extern` block\n+passes_no_coverage_propagate =\n+    `#[no_coverage]` does not propagate into items and must be applied to the contained functions directly\n \n-passes_unix_sigpipe_values =\n-    valid values for `#[unix_sigpipe = \"...\"]` are `inherit`, `sig_ign`, or `sig_dfl`\n+passes_no_link =\n+    attribute should be applied to an `extern crate` item\n+    .label = not an `extern crate` item\n \n passes_no_main_function =\n     `main` function not found in crate `{$crate_name}`\n@@ -546,222 +502,266 @@ passes_no_main_function =\n     .teach_note = If you don't know the basics of Rust, you can go look to the Rust Book to get started: https://doc.rust-lang.org/book/\n     .non_function_main = non-function item at `crate::main` is found\n \n-passes_duplicate_lang_item =\n-    found duplicate lang item `{$lang_item_name}`\n-    .first_defined_span = the lang item is first defined here\n-    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n-    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n-    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n-    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n-    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n-    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n+passes_no_mangle =\n+    attribute should be applied to a free function, impl method or static\n+    .warn = {-passes_previously_accepted}\n+    .label = not a free function, impl method or static\n \n-passes_duplicate_lang_item_crate =\n-    duplicate lang item in crate `{$crate_name}`: `{$lang_item_name}`.\n-    .first_defined_span = the lang item is first defined here\n-    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n-    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n-    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n-    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n-    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n-    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n+passes_no_mangle_foreign =\n+    `#[no_mangle]` has no effect on a foreign {$foreign_item_kind}\n+    .warn = {-passes_previously_accepted}\n+    .label = foreign {$foreign_item_kind}\n+    .note = symbol names in extern blocks are not mangled\n+    .suggestion = remove this attribute\n \n-passes_duplicate_lang_item_crate_depends =\n-    duplicate lang item in crate `{$crate_name}` (which `{$dependency_of}` depends on): `{$lang_item_name}`.\n-    .first_defined_span = the lang item is first defined here\n-    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n-    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n-    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n-    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n-    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n-    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n+passes_no_patterns =\n+    patterns not allowed in naked function parameters\n \n-passes_incorrect_target =\n-    `{$name}` language item must be applied to a {$kind} with {$at_least ->\n-        [true] at least {$num}\n-        *[false] {$num}\n-    } generic {$num ->\n-        [one] argument\n-        *[other] arguments\n+passes_non_exported_macro_invalid_attrs =\n+    attribute should be applied to function or closure\n+    .label = not a function or closure\n+\n+passes_object_lifetime_err =\n+    {$repr}\n+\n+passes_only_has_effect_on =\n+    `#[{$attr_name}]` only has an effect on {$target_name ->\n+        [function] functions\n+        [module] modules\n+        [implementation_block] implementation blocks\n+        *[unspecified] (unspecified--this is a compiler bug)\n     }\n-    .label = this {$kind} has {$actual_num} generic {$actual_num ->\n-        [one] argument\n-        *[other] arguments\n+\n+passes_outer_crate_level_attr =\n+    crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n+\n+passes_outside_loop =\n+    `{$name}` outside of a loop{$is_break ->\n+        [true] {\" or labeled block\"}\n+        *[false] {\"\"}\n+    }\n+    .label = cannot `{$name}` outside of a loop{$is_break ->\n+        [true] {\" or labeled block\"}\n+        *[false] {\"\"}\n     }\n \n-passes_useless_assignment =\n-    useless assignment of {$is_field_assign ->\n-        [true] field\n-        *[false] variable\n-    } of type `{$ty}` to itself\n+passes_params_not_allowed =\n+    referencing function parameters is not allowed in naked functions\n+    .help = follow the calling convention in asm block to use parameters\n+\n+passes_parent_info =\n+    {$num ->\n+      [one] {$descr}\n+     *[other] {$descr}s\n+    } in this {$parent_descr}\n+\n+passes_pass_by_value =\n+    `pass_by_value` attribute should be applied to a struct, enum or type alias\n+    .label = is not a struct, enum or type alias\n+\n+passes_plugin_registrar =\n+    `#[plugin_registrar]` only has an effect on functions\n+\n+passes_proc_macro_bad_sig = {$kind} has incorrect signature\n+\n+passes_repr_conflicting =\n+    conflicting representation hints\n+\n+passes_repr_ident =\n+    meta item in `repr` must be an identifier\n+\n+passes_rustc_allow_const_fn_unstable =\n+    attribute should be applied to `const fn`\n+    .label = not a `const fn`\n+\n+passes_rustc_dirty_clean =\n+    attribute requires -Z query-dep-graph to be enabled\n+\n+passes_rustc_layout_scalar_valid_range_arg =\n+    expected exactly one integer literal argument\n+\n+passes_rustc_layout_scalar_valid_range_not_struct =\n+    attribute should be applied to a struct\n+    .label = not a struct\n \n-passes_only_has_effect_on =\n-    `#[{$attr_name}]` only has an effect on {$target_name ->\n-        [function] functions\n-        [module] modules\n-        [implementation_block] implementation blocks\n-        *[unspecified] (unspecified--this is a compiler bug)\n+passes_rustc_legacy_const_generics_index =\n+    #[rustc_legacy_const_generics] must have one index for each generic parameter\n+    .label = generic parameters\n+\n+passes_rustc_legacy_const_generics_index_exceed =\n+    index exceeds number of arguments\n+    .label = there {$arg_count ->\n+        [one] is\n+        *[other] are\n+    } only {$arg_count} {$arg_count ->\n+        [one] argument\n+        *[other] arguments\n     }\n \n-passes_object_lifetime_err =\n-    {$repr}\n+passes_rustc_legacy_const_generics_index_negative =\n+    arguments should be non-negative integers\n \n-passes_unrecognized_repr_hint =\n-    unrecognized representation hint\n-    .help = valid reprs are `C`, `align`, `packed`, `transparent`, `simd`, `i8`, `u8`, `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `i128`, `u128`, `isize`, `usize`\n+passes_rustc_legacy_const_generics_only =\n+    #[rustc_legacy_const_generics] functions must only have const generics\n+    .label = non-const generic parameter\n \n-passes_attr_application_enum =\n-    attribute should be applied to an enum\n-    .label = not an enum\n+passes_rustc_lint_opt_deny_field_access =\n+    `#[rustc_lint_opt_deny_field_access]` should be applied to a field\n+    .label = not a field\n \n-passes_attr_application_struct =\n-    attribute should be applied to a struct\n+passes_rustc_lint_opt_ty =\n+    `#[rustc_lint_opt_ty]` should be applied to a struct\n     .label = not a struct\n \n-passes_attr_application_struct_union =\n-    attribute should be applied to a struct or union\n-    .label = not a struct or union\n-\n-passes_attr_application_struct_enum_union =\n-    attribute should be applied to a struct, enum, or union\n-    .label = not a struct, enum, or union\n+passes_rustc_std_internal_symbol =\n+    attribute should be applied to functions or statics\n+    .label = not a function or static\n \n-passes_attr_application_struct_enum_function_method_union =\n-    attribute should be applied to a struct, enum, function, associated function, or union\n-    .label = not a struct, enum, function, associated function, or union\n+passes_should_be_applied_to_fn =\n+    attribute should be applied to a function definition\n+    .label = {$on_crate ->\n+        [true] cannot be applied to crates\n+        *[false] not a function definition\n+    }\n \n-passes_transparent_incompatible =\n-    transparent {$target} cannot have other repr hints\n+passes_should_be_applied_to_static =\n+    attribute should be applied to a static\n+    .label = not a static\n \n-passes_deprecated_attribute =\n-    deprecated attribute must be paired with either stable or unstable attribute\n+passes_should_be_applied_to_struct_enum =\n+    attribute should be applied to a struct or enum\n+    .label = not a struct or enum\n \n-passes_useless_stability =\n-    this stability annotation is useless\n-    .label = useless stability annotation\n-    .item = the stability attribute annotates this item\n+passes_should_be_applied_to_trait =\n+    attribute should be applied to a trait\n+    .label = not a trait\n \n-passes_invalid_stability =\n-    invalid stability version found\n-    .label = invalid stability version\n-    .item = the stability attribute annotates this item\n+passes_size =\n+    size: {$size}\n \n-passes_cannot_stabilize_deprecated =\n-    an API can't be stabilized after it is deprecated\n-    .label = invalid version\n-    .item = the stability attribute annotates this item\n+passes_skipping_const_checks = skipping const checks\n \n-passes_invalid_deprecation_version =\n-    invalid deprecation version found\n-    .label = invalid deprecation version\n-    .item = the stability attribute annotates this item\n+passes_stability_promotable =\n+    attribute cannot be applied to an expression\n \n-passes_missing_stability_attr =\n-    {$descr} has missing stability attribute\n+passes_string_interpolation_only_works = string interpolation only works in `format!` invocations\n \n-passes_missing_const_stab_attr =\n-    {$descr} has missing const stability attribute\n+passes_target_feature_on_statement =\n+    {passes_should_be_applied_to_fn}\n+    .warn = {-passes_previously_accepted}\n+    .label = {passes_should_be_applied_to_fn.label}\n \n passes_trait_impl_const_stable =\n     trait implementations cannot be const stable yet\n     .note = see issue #67792 <https://github.com/rust-lang/rust/issues/67792> for more information\n \n-passes_feature_only_on_nightly =\n-    `#![feature]` may not be used on the {$release_channel} release channel\n-\n-passes_unknown_feature =\n-    unknown feature `{$feature}`\n-\n-passes_implied_feature_not_exist =\n-    feature `{$implied_by}` implying `{$feature}` does not exist\n-\n-passes_duplicate_feature_err =\n-    the feature `{$feature}` has already been declared\n+passes_transparent_incompatible =\n+    transparent {$target} cannot have other repr hints\n \n-passes_missing_const_err =\n-    attributes `#[rustc_const_unstable]` and `#[rustc_const_stable]` require the function or method to be `const`\n-    .help = make the function or method const\n-    .label = attribute specified here\n+passes_undefined_naked_function_abi =\n+    Rust ABI is unsupported in naked functions\n \n-passes_dead_codes =\n-    { $multiple ->\n-      *[true] multiple {$descr}s are\n-       [false] { $num ->\n-         [one] {$descr} {$name_list} is\n-        *[other] {$descr}s {$name_list} are\n-       }\n-    } never {$participle}\n+passes_unix_sigpipe_values =\n+    valid values for `#[unix_sigpipe = \"...\"]` are `inherit`, `sig_ign`, or `sig_dfl`\n \n-passes_change_fields_to_be_of_unit_type =\n-    consider changing the { $num ->\n-      [one] field\n-     *[other] fields\n-    } to be of unit type to suppress this warning while preserving the field numbering, or remove the { $num ->\n-      [one] field\n-     *[other] fields\n-    }\n+passes_unknown_external_lang_item =\n+    unknown external lang item: `{$lang_item}`\n \n-passes_parent_info =\n-    {$num ->\n-      [one] {$descr}\n-     *[other] {$descr}s\n-    } in this {$parent_descr}\n+passes_unknown_feature =\n+    unknown feature `{$feature}`\n \n-passes_ignored_derived_impls =\n-    `{$name}` has {$trait_list_len ->\n-      [one] a derived impl\n-     *[other] derived impls\n-    } for the {$trait_list_len ->\n-      [one] trait {$trait_list}, but this is\n-     *[other] traits {$trait_list}, but these are\n-    } intentionally ignored during dead code analysis\n+passes_unknown_lang_item =\n+    definition of an unknown language item: `{$name}`\n+    .label = definition of unknown language item `{$name}`\n \n-passes_proc_macro_bad_sig = {$kind} has incorrect signature\n+passes_unlabeled_cf_in_while_condition =\n+    `break` or `continue` with no label in the condition of a `while` loop\n+    .label = unlabeled `{$cf_type}` in the condition of a `while` loop\n \n-passes_skipping_const_checks = skipping const checks\n+passes_unlabeled_in_labeled_block =\n+    unlabeled `{$cf_type}` inside of a labeled block\n+    .label = `{$cf_type}` statements that would diverge to or through a labeled block need to bear a label\n \n-passes_invalid_macro_export_arguments = `{$name}` isn't a valid `#[macro_export]` argument\n+passes_unnecessary_partial_stable_feature = the feature `{$feature}` has been partially stabilized since {$since} and is succeeded by the feature `{$implies}`\n+    .suggestion = if you are using features which are still unstable, change to using `{$implies}`\n+    .suggestion_remove = if you are using features which are now stable, remove this line\n \n-passes_invalid_macro_export_arguments_too_many_items = `#[macro_export]` can only take 1 or 0 arguments\n+passes_unnecessary_stable_feature = the feature `{$feature}` has been stable since {$since} and no longer requires an attribute to enable\n \n passes_unreachable_due_to_uninhabited = unreachable {$descr}\n     .label = unreachable {$descr}\n     .label_orig = any code following this expression is unreachable\n     .note = this expression has type `{$ty}`, which is uninhabited\n \n-passes_unused_var_maybe_capture_ref = unused variable: `{$name}`\n-    .help = did you mean to capture by reference instead?\n+passes_unrecognized_field =\n+    unrecognized field name `{$name}`\n+\n+passes_unrecognized_repr_hint =\n+    unrecognized representation hint\n+    .help = valid reprs are `C`, `align`, `packed`, `transparent`, `simd`, `i8`, `u8`, `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `i128`, `u128`, `isize`, `usize`\n+\n+passes_unused =\n+    unused attribute\n+    .suggestion = remove this attribute\n+\n+passes_unused_assign = value assigned to `{$name}` is never read\n+    .help = maybe it is overwritten before being read?\n+\n+passes_unused_assign_passed = value passed to `{$name}` is never read\n+    .help = maybe it is overwritten before being read?\n \n passes_unused_capture_maybe_capture_ref = value captured by `{$name}` is never read\n     .help = did you mean to capture by reference instead?\n \n-passes_unused_var_remove_field = unused variable: `{$name}`\n-passes_unused_var_remove_field_suggestion = try removing the field\n+passes_unused_default_method_body_const_note =\n+    `default_method_body_is_const` has been replaced with `#[const_trait]` on traits\n \n-passes_unused_var_assigned_only = variable `{$name}` is assigned to, but never used\n-    .note = consider using `_{$name}` instead\n+passes_unused_duplicate =\n+    unused attribute\n+    .suggestion = remove this attribute\n+    .note = attribute also specified here\n+    .warn = {-passes_previously_accepted}\n \n-passes_unnecessary_stable_feature = the feature `{$feature}` has been stable since {$since} and no longer requires an attribute to enable\n+passes_unused_empty_lints_note =\n+    attribute `{$name}` with an empty list has no effect\n \n-passes_unnecessary_partial_stable_feature = the feature `{$feature}` has been partially stabilized since {$since} and is succeeded by the feature `{$implies}`\n-    .suggestion = if you are using features which are still unstable, change to using `{$implies}`\n-    .suggestion_remove = if you are using features which are now stable, remove this line\n+passes_unused_multiple =\n+    multiple `{$name}` attributes\n+    .suggestion = remove this attribute\n+    .note = attribute also specified here\n \n-passes_ineffective_unstable_impl = an `#[unstable]` annotation here has no effect\n-    .note = see issue #55436 <https://github.com/rust-lang/rust/issues/55436> for more information\n+passes_unused_no_lints_note =\n+    attribute `{$name}` without any lints has no effect\n \n-passes_unused_assign = value assigned to `{$name}` is never read\n-    .help = maybe it is overwritten before being read?\n+passes_unused_var_assigned_only = variable `{$name}` is assigned to, but never used\n+    .note = consider using `_{$name}` instead\n \n-passes_unused_assign_passed = value passed to `{$name}` is never read\n-    .help = maybe it is overwritten before being read?\n+passes_unused_var_maybe_capture_ref = unused variable: `{$name}`\n+    .help = did you mean to capture by reference instead?\n \n-passes_maybe_string_interpolation = you might have meant to use string interpolation in this string literal\n-passes_string_interpolation_only_works = string interpolation only works in `format!` invocations\n+passes_unused_var_remove_field = unused variable: `{$name}`\n+passes_unused_var_remove_field_suggestion = try removing the field\n+\n+passes_unused_variable_try_ignore = unused variable: `{$name}`\n+    .suggestion = try ignoring the field\n \n passes_unused_variable_try_prefix = unused variable: `{$name}`\n     .label = unused variable\n     .suggestion = if this is intentional, prefix it with an underscore\n \n-passes_unused_variable_try_ignore = unused variable: `{$name}`\n-    .suggestion = try ignoring the field\n+passes_used_compiler_linker =\n+    `used(compiler)` and `used(linker)` can't be used together\n+\n+passes_used_static =\n+    attribute must be applied to a `static` variable\n+\n+passes_useless_assignment =\n+    useless assignment of {$is_field_assign ->\n+        [true] field\n+        *[false] variable\n+    } of type `{$ty}` to itself\n+\n+passes_useless_stability =\n+    this stability annotation is useless\n+    .label = useless stability annotation\n+    .item = the stability attribute annotates this item"}, {"sha": "b68e8a78aab86d68035cbc2619640041fe9d32ee", "filename": "compiler/rustc_privacy/messages.ftl", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_privacy%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_privacy%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -2,22 +2,22 @@ privacy_field_is_private = field `{$field_name}` of {$variant_descr} `{$def_path\n privacy_field_is_private_is_update_syntax_label = field `{$field_name}` is private\n privacy_field_is_private_label = private field\n \n-privacy_item_is_private = {$kind} `{$descr}` is private\n-    .label = private {$kind}\n-privacy_unnamed_item_is_private = {$kind} is private\n-    .label = private {$kind}\n+privacy_from_private_dep_in_public_interface =\n+    {$kind} `{$descr}` from private dependency '{$krate}' in public interface\n \n privacy_in_public_interface = {$vis_descr} {$kind} `{$descr}` in public interface\n     .label = can't leak {$vis_descr} {$kind}\n     .visibility_label = `{$descr}` declared as {$vis_descr}\n \n-privacy_report_effective_visibility = {$descr}\n-\n-privacy_from_private_dep_in_public_interface =\n-    {$kind} `{$descr}` from private dependency '{$krate}' in public interface\n-\n+privacy_item_is_private = {$kind} `{$descr}` is private\n+    .label = private {$kind}\n privacy_private_in_public_lint =\n     {$vis_descr} {$kind} `{$descr}` in public interface (error {$kind ->\n         [trait] E0445\n         *[other] E0446\n     })\n+\n+privacy_report_effective_visibility = {$descr}\n+\n+privacy_unnamed_item_is_private = {$kind} is private\n+    .label = private {$kind}"}, {"sha": "49b423d1adeb5b4e8b6f12b278b09838fa47f5ce", "filename": "compiler/rustc_query_system/messages.ftl", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_query_system%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_query_system%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,30 +1,30 @@\n-query_system_reentrant = internal compiler error: reentrant incremental verify failure, suppressing message\n-\n-query_system_increment_compilation = internal compiler error: encountered incremental compilation error with {$dep_node}\n-    .help = This is a known issue with the compiler. Run {$run_cmd} to allow your project to compile\n-\n-query_system_increment_compilation_note1 = Please follow the instructions below to create a bug report with the provided information\n-query_system_increment_compilation_note2 = See <https://github.com/rust-lang/rust/issues/84970> for more information\n-\n query_system_cycle = cycle detected when {$stack_bottom}\n \n-query_system_cycle_usage = cycle used when {$usage}\n+query_system_cycle_recursive_trait_alias = trait aliases cannot be recursive\n \n-query_system_cycle_stack_single = ...which immediately requires {$stack_bottom} again\n+query_system_cycle_recursive_ty_alias = type aliases cannot be recursive\n+query_system_cycle_recursive_ty_alias_help1 = consider using a struct, enum, or union instead to break the cycle\n+query_system_cycle_recursive_ty_alias_help2 = see <https://doc.rust-lang.org/reference/types.html#recursive-types> for more information\n \n query_system_cycle_stack_middle = ...which requires {$desc}...\n \n query_system_cycle_stack_multiple = ...which again requires {$stack_bottom}, completing the cycle\n \n-query_system_cycle_recursive_ty_alias = type aliases cannot be recursive\n-query_system_cycle_recursive_ty_alias_help1 = consider using a struct, enum, or union instead to break the cycle\n-query_system_cycle_recursive_ty_alias_help2 = see <https://doc.rust-lang.org/reference/types.html#recursive-types> for more information\n+query_system_cycle_stack_single = ...which immediately requires {$stack_bottom} again\n \n-query_system_cycle_recursive_trait_alias = trait aliases cannot be recursive\n+query_system_cycle_usage = cycle used when {$usage}\n \n query_system_cycle_which_requires = ...which requires {$desc}...\n \n+query_system_increment_compilation = internal compiler error: encountered incremental compilation error with {$dep_node}\n+    .help = This is a known issue with the compiler. Run {$run_cmd} to allow your project to compile\n+\n+query_system_increment_compilation_note1 = Please follow the instructions below to create a bug report with the provided information\n+query_system_increment_compilation_note2 = See <https://github.com/rust-lang/rust/issues/84970> for more information\n+\n+query_system_layout_of_depth = query depth increased by {$depth} when {$desc}\n+\n query_system_query_overflow = queries overflow the depth limit!\n     .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]` attribute to your crate (`{$crate_name}`)\n \n-query_system_layout_of_depth = query depth increased by {$depth} when {$desc}\n+query_system_reentrant = internal compiler error: reentrant incremental verify failure, suppressing message"}, {"sha": "539b88aa9d342efc4230558bc97d362870c39edb", "filename": "compiler/rustc_resolve/messages.ftl", "status": "modified", "additions": 175, "deletions": 175, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_resolve%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_resolve%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,79 +1,90 @@\n-resolve_parent_module_reset_for_binding =\n-    parent module is reset for binding\n+resolve_accessible_unsure = not sure whether the path is accessible or not\n+    .note = the type may have associated items, but we are currently not checking them\n+\n+resolve_add_as_non_derive =\n+    add as non-Derive macro\n+    `#[{$macro_path}]`\n \n resolve_ampersand_used_without_explicit_lifetime_name =\n     `&` without an explicit lifetime name cannot be used here\n     .note = explicit lifetime name needed here\n \n-resolve_underscore_lifetime_name_cannot_be_used_here =\n-    `'_` cannot be used here\n-    .note = `'_` is a reserved lifetime name\n+resolve_ancestor_only =\n+    visibilities can only be restricted to ancestor modules\n \n-resolve_crate_may_not_be_imported =\n-    `$crate` may not be imported\n+resolve_associated_const_with_similar_name_exists =\n+    there is an associated constant with a similar name\n \n-resolve_crate_root_imports_must_be_named_explicitly =\n-    crate root imports need to be explicitly named: `use crate as name;`\n+resolve_associated_fn_with_similar_name_exists =\n+    there is an associated function with a similar name\n \n-resolve_generic_params_from_outer_function =\n-    can't use generic parameters from outer function\n-    .label = use of generic parameter from outer function\n-    .suggestion = try using a local generic parameter instead\n+resolve_associated_type_with_similar_name_exists =\n+    there is an associated type with a similar name\n \n-resolve_self_type_implicitly_declared_by_impl =\n-    `Self` type implicitly declared here, by this `impl`\n+resolve_attempt_to_use_non_constant_value_in_constant =\n+    attempt to use a non-constant value in a constant\n+\n+resolve_attempt_to_use_non_constant_value_in_constant_label_with_suggestion =\n+    non-constant value\n+\n+resolve_attempt_to_use_non_constant_value_in_constant_with_suggestion =\n+    consider using `{$suggestion}` instead of `{$current}`\n+\n+resolve_attempt_to_use_non_constant_value_in_constant_without_suggestion =\n+    this would need to be a `{$suggestion}`\n+\n+resolve_binding_shadows_something_unacceptable =\n+    {$shadowing_binding}s cannot shadow {$shadowed_binding}s\n+    .label = cannot be named the same as {$article} {$shadowed_binding}\n+    .label_shadowed_binding = the {$shadowed_binding} `{$name}` is {$participle} here\n+\n+resolve_binding_shadows_something_unacceptable_suggestion =\n+    try specify the pattern arguments\n+\n+resolve_cannot_capture_dynamic_environment_in_fn_item =\n+    can't capture dynamic environment in a fn item\n+    .help = use the `|| {\"{\"} ... {\"}\"}` closure form instead\n \n resolve_cannot_use_self_type_here =\n     can't use `Self` here\n \n-resolve_use_a_type_here_instead =\n-    use a type here instead\n-\n-resolve_type_param_from_outer_fn =\n-    type parameter from outer function\n+resolve_const_not_member_of_trait =\n+    const `{$const_}` is not a member of trait `{$trait_}`\n+    .label = not a member of trait `{$trait_}`\n \n resolve_const_param_from_outer_fn =\n     const parameter from outer function\n \n-resolve_try_using_local_generic_parameter =\n-    try using a local generic parameter instead\n-\n-resolve_try_adding_local_generic_param_on_method =\n-    try adding a local generic parameter in this method instead\n-\n-resolve_help_try_using_local_generic_param =\n-    try using a local generic parameter instead\n+resolve_const_param_in_enum_discriminant =\n+    const parameters may not be used in enum discriminant values\n \n-resolve_name_is_already_used_as_generic_parameter =\n-    the name `{$name}` is already used for a generic parameter in this item's generic parameters\n-    .label = already used\n-    .first_use_of_name = first use of `{$name}`\n+resolve_const_param_in_non_trivial_anon_const =\n+    const parameters may only be used as standalone arguments, i.e. `{$name}`\n \n-resolve_method_not_member_of_trait =\n-    method `{$method}` is not a member of trait `{$trait_}`\n-    .label = not a member of trait `{$trait_}`\n+resolve_const_param_in_ty_of_const_param =\n+    const parameters may not be used in the type of const parameters\n \n-resolve_associated_fn_with_similar_name_exists =\n-    there is an associated function with a similar name\n+resolve_crate_may_not_be_imported =\n+    `$crate` may not be imported\n \n-resolve_type_not_member_of_trait =\n-    type `{$type_}` is not a member of trait `{$trait_}`\n-    .label = not a member of trait `{$trait_}`\n+resolve_crate_root_imports_must_be_named_explicitly =\n+    crate root imports need to be explicitly named: `use crate as name;`\n \n-resolve_associated_type_with_similar_name_exists =\n-    there is an associated type with a similar name\n+resolve_expected_found =\n+    expected module, found {$res} `{$path_str}`\n+    .label = not a module\n \n-resolve_const_not_member_of_trait =\n-    const `{$const_}` is not a member of trait `{$trait_}`\n-    .label = not a member of trait `{$trait_}`\n+resolve_forward_declared_generic_param =\n+    generic parameters with a default cannot use forward declared identifiers\n+    .label = defaulted generic parameters cannot be forward declared\n \n-resolve_associated_const_with_similar_name_exists =\n-    there is an associated constant with a similar name\n+resolve_generic_params_from_outer_function =\n+    can't use generic parameters from outer function\n+    .label = use of generic parameter from outer function\n+    .suggestion = try using a local generic parameter instead\n \n-resolve_variable_bound_with_different_mode =\n-    variable `{$variable_name}` is bound inconsistently across alternatives separated by `|`\n-    .label = bound in different ways\n-    .first_binding_span = first binding\n+resolve_help_try_using_local_generic_param =\n+    try using a local generic parameter instead\n \n resolve_ident_bound_more_than_once_in_parameter_list =\n     identifier `{$identifier}` is bound more than once in this parameter list\n@@ -83,182 +94,171 @@ resolve_ident_bound_more_than_once_in_same_pattern =\n     identifier `{$identifier}` is bound more than once in the same pattern\n     .label = used in a pattern more than once\n \n-resolve_undeclared_label =\n-    use of undeclared label `{$name}`\n-    .label = undeclared label `{$name}`\n+resolve_imported_crate = `$crate` may not be imported\n \n-resolve_label_with_similar_name_reachable =\n-    a label with a similar name is reachable\n+resolve_indeterminate =\n+    cannot determine resolution for the visibility\n \n-resolve_try_using_similarly_named_label =\n-    try using similarly named label\n+resolve_invalid_asm_sym =\n+    invalid `sym` operand\n+    .label = is a local variable\n+    .help = `sym` operands must refer to either a function or a static\n \n-resolve_unreachable_label_with_similar_name_exists =\n-    a label with a similar name exists but is unreachable\n+resolve_label_with_similar_name_reachable =\n+    a label with a similar name is reachable\n \n-resolve_self_import_can_only_appear_once_in_the_list =\n-    `self` import can only appear once in an import list\n-    .label = can only appear once in an import list\n+resolve_lifetime_param_in_enum_discriminant =\n+    lifetime parameters may not be used in enum discriminant values\n \n-resolve_self_import_only_in_import_list_with_non_empty_prefix =\n-    `self` import can only appear in an import list with a non-empty prefix\n-    .label = can only appear in an import list with a non-empty prefix\n+resolve_lifetime_param_in_non_trivial_anon_const =\n+    lifetime parameters may not be used in const expressions\n \n-resolve_cannot_capture_dynamic_environment_in_fn_item =\n-    can't capture dynamic environment in a fn item\n-    .help = use the `|| {\"{\"} ... {\"}\"}` closure form instead\n+resolve_lifetime_param_in_ty_of_const_param =\n+    lifetime parameters may not be used in the type of const parameters\n \n-resolve_attempt_to_use_non_constant_value_in_constant =\n+resolve_lowercase_self =\n     attempt to use a non-constant value in a constant\n+    .suggestion = try using `Self`\n \n-resolve_attempt_to_use_non_constant_value_in_constant_with_suggestion =\n-    consider using `{$suggestion}` instead of `{$current}`\n-\n-resolve_attempt_to_use_non_constant_value_in_constant_label_with_suggestion =\n-    non-constant value\n+resolve_macro_expected_found =\n+    expected {$expected}, found {$found} `{$macro_path}`\n \n-resolve_attempt_to_use_non_constant_value_in_constant_without_suggestion =\n-    this would need to be a `{$suggestion}`\n+resolve_macro_use_extern_crate_self = `#[macro_use]` is not supported on `extern crate self`\n \n-resolve_self_imports_only_allowed_within =\n-    `self` imports are only allowed within a {\"{\"} {\"}\"} list\n+resolve_method_not_member_of_trait =\n+    method `{$method}` is not a member of trait `{$trait_}`\n+    .label = not a member of trait `{$trait_}`\n \n-resolve_self_imports_only_allowed_within_suggestion =\n-    consider importing the module directly\n+resolve_module_only =\n+    visibility must resolve to a module\n \n-resolve_self_imports_only_allowed_within_multipart_suggestion =\n-    alternatively, use the multi-path `use` syntax to import `self`\n+resolve_name_is_already_used_as_generic_parameter =\n+    the name `{$name}` is already used for a generic parameter in this item's generic parameters\n+    .label = already used\n+    .first_use_of_name = first use of `{$name}`\n \n-resolve_binding_shadows_something_unacceptable =\n-    {$shadowing_binding}s cannot shadow {$shadowed_binding}s\n-    .label = cannot be named the same as {$article} {$shadowed_binding}\n-    .label_shadowed_binding = the {$shadowed_binding} `{$name}` is {$participle} here\n+resolve_param_in_enum_discriminant =\n+    generic parameters may not be used in enum discriminant values\n+    .label = cannot perform const operation using `{$name}`\n \n-resolve_binding_shadows_something_unacceptable_suggestion =\n-    try specify the pattern arguments\n+resolve_param_in_non_trivial_anon_const =\n+    generic parameters may not be used in const operations\n+    .label = cannot perform const operation using `{$name}`\n \n-resolve_forward_declared_generic_param =\n-    generic parameters with a default cannot use forward declared identifiers\n-    .label = defaulted generic parameters cannot be forward declared\n+resolve_param_in_non_trivial_anon_const_help =\n+    use `#![feature(generic_const_exprs)]` to allow generic const expressions\n \n resolve_param_in_ty_of_const_param =\n     the type of const parameters must not depend on other generic parameters\n     .label = the type must not depend on the parameter `{$name}`\n \n-resolve_type_param_in_ty_of_const_param =\n-    type parameters may not be used in the type of const parameters\n-\n-resolve_const_param_in_ty_of_const_param =\n-    const parameters may not be used in the type of const parameters\n-\n-resolve_lifetime_param_in_ty_of_const_param =\n-    lifetime parameters may not be used in the type of const parameters\n-\n-resolve_self_in_generic_param_default =\n-    generic parameters cannot use `Self` in their defaults\n-    .label = `Self` in generic parameter default\n-\n-resolve_param_in_non_trivial_anon_const =\n-    generic parameters may not be used in const operations\n-    .label = cannot perform const operation using `{$name}`\n+resolve_parent_module_reset_for_binding =\n+    parent module is reset for binding\n \n-resolve_param_in_non_trivial_anon_const_help =\n-    use `#![feature(generic_const_exprs)]` to allow generic const expressions\n+resolve_proc_macro_same_crate = can't use a procedural macro from the same crate that defines it\n+    .help = you can define integration tests in a directory named `tests`\n \n-resolve_type_param_in_non_trivial_anon_const =\n-    type parameters may not be used in const expressions\n+resolve_relative_2018 =\n+    relative paths are not supported in visibilities in 2018 edition or later\n+    .suggestion = try\n \n-resolve_const_param_in_non_trivial_anon_const =\n-    const parameters may only be used as standalone arguments, i.e. `{$name}`\n+resolve_remove_surrounding_derive =\n+    remove from the surrounding `derive()`\n \n-resolve_lifetime_param_in_non_trivial_anon_const =\n-    lifetime parameters may not be used in const expressions\n+resolve_self_import_can_only_appear_once_in_the_list =\n+    `self` import can only appear once in an import list\n+    .label = can only appear once in an import list\n \n-resolve_unreachable_label =\n-    use of unreachable label `{$name}`\n-    .label = unreachable label `{$name}`\n-    .label_definition_span = unreachable label defined here\n-    .note = labels are unreachable through functions, closures, async blocks and modules\n+resolve_self_import_only_in_import_list_with_non_empty_prefix =\n+    `self` import can only appear in an import list with a non-empty prefix\n+    .label = can only appear in an import list with a non-empty prefix\n \n-resolve_unreachable_label_suggestion_use_similarly_named =\n-    try using similarly named label\n+resolve_self_imports_only_allowed_within =\n+    `self` imports are only allowed within a {\"{\"} {\"}\"} list\n \n-resolve_unreachable_label_similar_name_reachable =\n-    a label with a similar name is reachable\n+resolve_self_imports_only_allowed_within_multipart_suggestion =\n+    alternatively, use the multi-path `use` syntax to import `self`\n \n-resolve_unreachable_label_similar_name_unreachable =\n-    a label with a similar name exists but is also unreachable\n+resolve_self_imports_only_allowed_within_suggestion =\n+    consider importing the module directly\n \n-resolve_trait_impl_mismatch =\n-    item `{$name}` is an associated {$kind}, which doesn't match its trait `{$trait_path}`\n-    .label = does not match trait\n-    .label_trait_item = item in trait\n+resolve_self_in_generic_param_default =\n+    generic parameters cannot use `Self` in their defaults\n+    .label = `Self` in generic parameter default\n \n-resolve_invalid_asm_sym =\n-    invalid `sym` operand\n-    .label = is a local variable\n-    .help = `sym` operands must refer to either a function or a static\n+resolve_self_type_implicitly_declared_by_impl =\n+    `Self` type implicitly declared here, by this `impl`\n \n-resolve_lowercase_self =\n-    attempt to use a non-constant value in a constant\n-    .suggestion = try using `Self`\n+resolve_tool_module_imported =\n+    cannot use a tool module through an import\n+    .note = the tool module imported here\n \n resolve_trait_impl_duplicate =\n     duplicate definitions with name `{$name}`:\n     .label = duplicate definition\n     .old_span_label = previous definition here\n     .trait_item_span = item in trait\n \n-resolve_relative_2018 =\n-    relative paths are not supported in visibilities in 2018 edition or later\n-    .suggestion = try\n+resolve_trait_impl_mismatch =\n+    item `{$name}` is an associated {$kind}, which doesn't match its trait `{$trait_path}`\n+    .label = does not match trait\n+    .label_trait_item = item in trait\n \n-resolve_ancestor_only =\n-    visibilities can only be restricted to ancestor modules\n+resolve_try_adding_local_generic_param_on_method =\n+    try adding a local generic parameter in this method instead\n \n-resolve_expected_found =\n-    expected module, found {$res} `{$path_str}`\n-    .label = not a module\n+resolve_try_using_local_generic_parameter =\n+    try using a local generic parameter instead\n \n-resolve_indeterminate =\n-    cannot determine resolution for the visibility\n+resolve_try_using_similarly_named_label =\n+    try using similarly named label\n \n-resolve_tool_module_imported =\n-    cannot use a tool module through an import\n-    .note = the tool module imported here\n+resolve_type_not_member_of_trait =\n+    type `{$type_}` is not a member of trait `{$trait_}`\n+    .label = not a member of trait `{$trait_}`\n \n-resolve_module_only =\n-    visibility must resolve to a module\n+resolve_type_param_from_outer_fn =\n+    type parameter from outer function\n \n-resolve_macro_expected_found =\n-    expected {$expected}, found {$found} `{$macro_path}`\n+resolve_type_param_in_enum_discriminant =\n+    type parameters may not be used in enum discriminant values\n \n-resolve_remove_surrounding_derive =\n-    remove from the surrounding `derive()`\n+resolve_type_param_in_non_trivial_anon_const =\n+    type parameters may not be used in const expressions\n \n-resolve_add_as_non_derive =\n-    add as non-Derive macro\n-    `#[{$macro_path}]`\n+resolve_type_param_in_ty_of_const_param =\n+    type parameters may not be used in the type of const parameters\n \n-resolve_proc_macro_same_crate = can't use a procedural macro from the same crate that defines it\n-    .help = you can define integration tests in a directory named `tests`\n+resolve_undeclared_label =\n+    use of undeclared label `{$name}`\n+    .label = undeclared label `{$name}`\n \n-resolve_imported_crate = `$crate` may not be imported\n+resolve_underscore_lifetime_name_cannot_be_used_here =\n+    `'_` cannot be used here\n+    .note = `'_` is a reserved lifetime name\n \n-resolve_macro_use_extern_crate_self = `#[macro_use]` is not supported on `extern crate self`\n+resolve_unreachable_label =\n+    use of unreachable label `{$name}`\n+    .label = unreachable label `{$name}`\n+    .label_definition_span = unreachable label defined here\n+    .note = labels are unreachable through functions, closures, async blocks and modules\n \n-resolve_accessible_unsure = not sure whether the path is accessible or not\n-    .note = the type may have associated items, but we are currently not checking them\n+resolve_unreachable_label_similar_name_reachable =\n+    a label with a similar name is reachable\n \n-resolve_param_in_enum_discriminant =\n-    generic parameters may not be used in enum discriminant values\n-    .label = cannot perform const operation using `{$name}`\n+resolve_unreachable_label_similar_name_unreachable =\n+    a label with a similar name exists but is also unreachable\n \n-resolve_type_param_in_enum_discriminant =\n-    type parameters may not be used in enum discriminant values\n+resolve_unreachable_label_suggestion_use_similarly_named =\n+    try using similarly named label\n \n-resolve_const_param_in_enum_discriminant =\n-    const parameters may not be used in enum discriminant values\n+resolve_unreachable_label_with_similar_name_exists =\n+    a label with a similar name exists but is unreachable\n \n-resolve_lifetime_param_in_enum_discriminant =\n-    lifetime parameters may not be used in enum discriminant values\n+resolve_use_a_type_here_instead =\n+    use a type here instead\n+\n+resolve_variable_bound_with_different_mode =\n+    variable `{$variable_name}` is bound inconsistently across alternatives separated by `|`\n+    .label = bound in different ways\n+    .first_binding_span = first binding"}, {"sha": "5a0b8f9f73cba4e73984a28acfabfc53e2a4fcca", "filename": "compiler/rustc_session/messages.ftl", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_session%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_session%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,105 +1,105 @@\n-session_incorrect_cgu_reuse_type =\n-    CGU-reuse for `{$cgu_user_name}` is `{$actual_reuse}` but should be {$at_least ->\n-    [one] {\"at least \"}\n-    *[other] {\"\"}\n-    }`{$expected_reuse}`\n+session_binary_float_literal_not_supported = binary float literal is not supported\n+session_branch_protection_requires_aarch64 = `-Zbranch-protection` is only supported on aarch64\n+\n+session_cannot_enable_crt_static_linux = sanitizer is incompatible with statically linked libc, disable it using `-C target-feature=-crt-static`\n+\n+session_cannot_mix_and_match_sanitizers = `-Zsanitizer={$first}` is incompatible with `-Zsanitizer={$second}`\n \n session_cgu_not_recorded =\n     CGU-reuse for `{$cgu_user_name}` is (mangled: `{$cgu_name}`) was not recorded\n \n-session_feature_gate_error = {$explain}\n+session_crate_name_does_not_match = `--crate-name` and `#[crate_name]` are required to match, but `{$s}` != `{$name}`\n+\n+session_crate_name_empty = crate name must not be empty\n+\n+session_crate_name_invalid = crate names cannot start with a `-`, but `{$s}` has a leading hyphen\n+\n+session_expr_parentheses_needed = parentheses are required to parse this as an expression\n \n session_feature_diagnostic_for_issue =\n     see issue #{$n} <https://github.com/rust-lang/rust/issues/{$n}> for more information\n \n session_feature_diagnostic_help =\n     add `#![feature({$feature})]` to the crate attributes to enable\n \n-session_not_circumvent_feature = `-Zunleash-the-miri-inside-of-you` may not be used to circumvent feature gates, except when testing error paths in the CTFE engine\n-\n-session_profile_use_file_does_not_exist = file `{$path}` passed to `-C profile-use` does not exist.\n-\n-session_linker_plugin_lto_windows_not_supported = linker plugin based LTO is not supported together with `-C prefer-dynamic` when targeting Windows-like targets\n+session_feature_gate_error = {$explain}\n \n-session_profile_sample_use_file_does_not_exist = file `{$path}` passed to `-C profile-sample-use` does not exist.\n+session_file_is_not_writeable = output file {$file} is not writeable -- check its permissions\n \n-session_target_requires_unwind_tables = target requires unwind tables, they cannot be disabled with `-C force-unwind-tables=no`\n+session_hexadecimal_float_literal_not_supported = hexadecimal float literal is not supported\n+session_incorrect_cgu_reuse_type =\n+    CGU-reuse for `{$cgu_user_name}` is `{$actual_reuse}` but should be {$at_least ->\n+    [one] {\"at least \"}\n+    *[other] {\"\"}\n+    }`{$expected_reuse}`\n \n session_instrumentation_not_supported = {$us} instrumentation is not supported for this target\n \n-session_sanitizer_not_supported = {$us} sanitizer is not supported for this target\n-\n-session_sanitizers_not_supported = {$us} sanitizers are not supported for this target\n-\n-session_cannot_mix_and_match_sanitizers = `-Zsanitizer={$first}` is incompatible with `-Zsanitizer={$second}`\n-\n-session_cannot_enable_crt_static_linux = sanitizer is incompatible with statically linked libc, disable it using `-C target-feature=-crt-static`\n+session_int_literal_too_large = integer literal is too large\n+    .note = value exceeds limit of `{$limit}`\n \n-session_sanitizer_cfi_requires_lto = `-Zsanitizer=cfi` requires `-Clto`, `-Clto=thin`, or `-Clinker-plugin-lto`\n+session_invalid_character_in_create_name = invalid character `{$character}` in crate name: `{$crate_name}`\n \n-session_sanitizer_cfi_canonical_jump_tables_requires_cfi = `-Zsanitizer-cfi-canonical-jump-tables` requires `-Zsanitizer=cfi`\n+session_invalid_float_literal_suffix = invalid suffix `{$suffix}` for float literal\n+    .label = invalid suffix `{$suffix}`\n+    .help = valid suffixes are `f32` and `f64`\n \n-session_sanitizer_cfi_generalize_pointers_requires_cfi = `-Zsanitizer-cfi-generalize-pointers` requires `-Zsanitizer=cfi` or `-Zsanitizer=kcfi`\n+session_invalid_float_literal_width = invalid width `{$width}` for float literal\n+    .help = valid widths are 32 and 64\n \n-session_sanitizer_cfi_normalize_integers_requires_cfi = `-Zsanitizer-cfi-normalize-integers` requires `-Zsanitizer=cfi` or `-Zsanitizer=kcfi`\n+session_invalid_int_literal_width = invalid width `{$width}` for integer literal\n+    .help = valid widths are 8, 16, 32, 64 and 128\n \n-session_split_lto_unit_requires_lto = `-Zsplit-lto-unit` requires `-Clto`, `-Clto=thin`, or `-Clinker-plugin-lto`\n+session_invalid_literal_suffix = suffixes on {$kind} literals are invalid\n+    .label = invalid suffix `{$suffix}`\n \n-session_unstable_virtual_function_elimination = `-Zvirtual-function-elimination` requires `-Clto`\n+session_invalid_num_literal_base_prefix = invalid base prefix for number literal\n+    .note = base prefixes (`0xff`, `0b1010`, `0o755`) are lowercase\n+    .suggestion = try making the prefix lowercase\n \n-session_unsupported_dwarf_version = requested DWARF version {$dwarf_version} is greater than 5\n+session_invalid_num_literal_suffix = invalid suffix `{$suffix}` for number literal\n+    .label = invalid suffix `{$suffix}`\n+    .help = the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n \n-session_target_stack_protector_not_supported = `-Z stack-protector={$stack_protector}` is not supported for target {$target_triple} and will be ignored\n+session_linker_plugin_lto_windows_not_supported = linker plugin based LTO is not supported together with `-C prefer-dynamic` when targeting Windows-like targets\n \n-session_branch_protection_requires_aarch64 = `-Zbranch-protection` is only supported on aarch64\n+session_not_circumvent_feature = `-Zunleash-the-miri-inside-of-you` may not be used to circumvent feature gates, except when testing error paths in the CTFE engine\n \n-session_split_debuginfo_unstable_platform = `-Csplit-debuginfo={$debuginfo}` is unstable on this platform\n+session_not_supported = not supported\n \n-session_file_is_not_writeable = output file {$file} is not writeable -- check its permissions\n+session_nul_in_c_str = null characters in C string literals are not supported\n \n-session_crate_name_does_not_match = `--crate-name` and `#[crate_name]` are required to match, but `{$s}` != `{$name}`\n+session_octal_float_literal_not_supported = octal float literal is not supported\n+session_optimization_fuel_exhausted = optimization-fuel-exhausted: {$msg}\n \n-session_crate_name_invalid = crate names cannot start with a `-`, but `{$s}` has a leading hyphen\n+session_profile_sample_use_file_does_not_exist = file `{$path}` passed to `-C profile-sample-use` does not exist.\n \n-session_crate_name_empty = crate name must not be empty\n+session_profile_use_file_does_not_exist = file `{$path}` passed to `-C profile-use` does not exist.\n \n-session_invalid_character_in_create_name = invalid character `{$character}` in crate name: `{$crate_name}`\n+session_sanitizer_cfi_canonical_jump_tables_requires_cfi = `-Zsanitizer-cfi-canonical-jump-tables` requires `-Zsanitizer=cfi`\n \n-session_expr_parentheses_needed = parentheses are required to parse this as an expression\n+session_sanitizer_cfi_generalize_pointers_requires_cfi = `-Zsanitizer-cfi-generalize-pointers` requires `-Zsanitizer=cfi` or `-Zsanitizer=kcfi`\n \n-session_skipping_const_checks = skipping const checks\n-session_unleashed_feature_help_named = skipping check for `{$gate}` feature\n-session_unleashed_feature_help_unnamed = skipping check that does not even have a feature gate\n+session_sanitizer_cfi_normalize_integers_requires_cfi = `-Zsanitizer-cfi-normalize-integers` requires `-Zsanitizer=cfi` or `-Zsanitizer=kcfi`\n \n-session_hexadecimal_float_literal_not_supported = hexadecimal float literal is not supported\n-session_octal_float_literal_not_supported = octal float literal is not supported\n-session_binary_float_literal_not_supported = binary float literal is not supported\n-session_not_supported = not supported\n+session_sanitizer_cfi_requires_lto = `-Zsanitizer=cfi` requires `-Clto`, `-Clto=thin`, or `-Clinker-plugin-lto`\n \n-session_invalid_literal_suffix = suffixes on {$kind} literals are invalid\n-    .label = invalid suffix `{$suffix}`\n+session_sanitizer_not_supported = {$us} sanitizer is not supported for this target\n \n-session_invalid_num_literal_base_prefix = invalid base prefix for number literal\n-    .note = base prefixes (`0xff`, `0b1010`, `0o755`) are lowercase\n-    .suggestion = try making the prefix lowercase\n+session_sanitizers_not_supported = {$us} sanitizers are not supported for this target\n \n-session_invalid_num_literal_suffix = invalid suffix `{$suffix}` for number literal\n-    .label = invalid suffix `{$suffix}`\n-    .help = the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+session_skipping_const_checks = skipping const checks\n+session_split_debuginfo_unstable_platform = `-Csplit-debuginfo={$debuginfo}` is unstable on this platform\n \n-session_invalid_float_literal_width = invalid width `{$width}` for float literal\n-    .help = valid widths are 32 and 64\n+session_split_lto_unit_requires_lto = `-Zsplit-lto-unit` requires `-Clto`, `-Clto=thin`, or `-Clinker-plugin-lto`\n \n-session_invalid_float_literal_suffix = invalid suffix `{$suffix}` for float literal\n-    .label = invalid suffix `{$suffix}`\n-    .help = valid suffixes are `f32` and `f64`\n+session_target_requires_unwind_tables = target requires unwind tables, they cannot be disabled with `-C force-unwind-tables=no`\n \n-session_int_literal_too_large = integer literal is too large\n-    .note = value exceeds limit of `{$limit}`\n+session_target_stack_protector_not_supported = `-Z stack-protector={$stack_protector}` is not supported for target {$target_triple} and will be ignored\n \n-session_invalid_int_literal_width = invalid width `{$width}` for integer literal\n-    .help = valid widths are 8, 16, 32, 64 and 128\n+session_unleashed_feature_help_named = skipping check for `{$gate}` feature\n+session_unleashed_feature_help_unnamed = skipping check that does not even have a feature gate\n \n-session_optimization_fuel_exhausted = optimization-fuel-exhausted: {$msg}\n+session_unstable_virtual_function_elimination = `-Zvirtual-function-elimination` requires `-Clto`\n \n-session_nul_in_c_str = null characters in C string literals are not supported\n+session_unsupported_dwarf_version = requested DWARF version {$dwarf_version} is greater than 5"}, {"sha": "217ba71b6310802f861486da088b57b4a36e46f6", "filename": "compiler/rustc_trait_selection/messages.ftl", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_trait_selection%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_trait_selection%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,17 +1,13 @@\n trait_selection_dump_vtable_entries = vtable entries for `{$trait_ref}`: {$entries}\n \n-trait_selection_unable_to_construct_constant_value = unable to construct a constant value for the unevaluated constant {$unevaluated}\n-\n trait_selection_empty_on_clause_in_rustc_on_unimplemented = empty `on`-clause in `#[rustc_on_unimplemented]`\n     .label = empty on-clause here\n \n+trait_selection_inherent_projection_normalization_overflow = overflow evaluating associated type `{$ty}`\n+\n trait_selection_invalid_on_clause_in_rustc_on_unimplemented = invalid `on`-clause in `#[rustc_on_unimplemented]`\n     .label = invalid on-clause here\n \n-trait_selection_no_value_in_rustc_on_unimplemented = this attribute must have a valid value\n-    .label = expected value here\n-    .note = eg `#[rustc_on_unimplemented(message=\"foo\")]`\n-\n trait_selection_negative_positive_conflict = found both positive and negative implementation of trait `{$trait_desc}`{$self_desc ->\n         [none] {\"\"}\n        *[default] {\" \"}for type `{$self_desc}`\n@@ -21,4 +17,8 @@ trait_selection_negative_positive_conflict = found both positive and negative im\n     .positive_implementation_here = positive implementation here\n     .positive_implementation_in_crate = positive implementation in crate `{$positive_impl_cname}`\n \n-trait_selection_inherent_projection_normalization_overflow = overflow evaluating associated type `{$ty}`\n+trait_selection_no_value_in_rustc_on_unimplemented = this attribute must have a valid value\n+    .label = expected value here\n+    .note = eg `#[rustc_on_unimplemented(message=\"foo\")]`\n+\n+trait_selection_unable_to_construct_constant_value = unable to construct a constant value for the unevaluated constant {$unevaluated}"}, {"sha": "c416aa52a24a4823f1d4f84cad8b7e499624086d", "filename": "compiler/rustc_ty_utils/messages.ftl", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_ty_utils%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/compiler%2Frustc_ty_utils%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fmessages.ftl?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -1,65 +1,65 @@\n-ty_utils_needs_drop_overflow = overflow while checking whether `{$query_ty}` requires drop\n+ty_utils_address_and_deref_not_supported = dereferencing or taking the address is not supported in generic constants\n \n-ty_utils_generic_constant_too_complex = overly complex generic constant\n-    .help = consider moving this anonymous constant into a `const` function\n-    .maybe_supported = this operation may be supported in the future\n+ty_utils_adt_not_supported = struct/enum construction is not supported in generic constants\n \n-ty_utils_borrow_not_supported = borrowing is not supported in generic constants\n+ty_utils_array_not_supported = array construction is not supported in generic constants\n \n-ty_utils_address_and_deref_not_supported = dereferencing or taking the address is not supported in generic constants\n+ty_utils_assign_not_supported = assignment is not supported in generic constants\n \n-ty_utils_array_not_supported = array construction is not supported in generic constants\n+ty_utils_binary_not_supported = unsupported binary operation in generic constants\n \n ty_utils_block_not_supported = blocks are not supported in generic constants\n \n-ty_utils_never_to_any_not_supported = coercing the `never` type is not supported in generic constants\n-\n-ty_utils_tuple_not_supported = tuple construction is not supported in generic constants\n+ty_utils_borrow_not_supported = borrowing is not supported in generic constants\n \n-ty_utils_index_not_supported = indexing is not supported in generic constants\n+ty_utils_box_not_supported = allocations are not allowed in generic constants\n \n-ty_utils_field_not_supported = field access is not supported in generic constants\n+ty_utils_closure_and_return_not_supported = closures and function keywords are not supported in generic constants\n \n ty_utils_const_block_not_supported = const blocks are not supported in generic constants\n \n-ty_utils_adt_not_supported = struct/enum construction is not supported in generic constants\n+ty_utils_control_flow_not_supported = control flow is not supported in generic constants\n \n-ty_utils_pointer_not_supported = pointer casts are not allowed in generic constants\n+ty_utils_field_not_supported = field access is not supported in generic constants\n \n-ty_utils_yield_not_supported = generator control flow is not allowed in generic constants\n+ty_utils_generic_constant_too_complex = overly complex generic constant\n+    .help = consider moving this anonymous constant into a `const` function\n+    .maybe_supported = this operation may be supported in the future\n \n-ty_utils_loop_not_supported = loops and loop control flow are not supported in generic constants\n+ty_utils_impl_trait_duplicate_arg = non-defining opaque type use in defining scope\n+    .label = generic argument `{$arg}` used twice\n+    .note = for this opaque type\n \n-ty_utils_box_not_supported = allocations are not allowed in generic constants\n+ty_utils_impl_trait_not_param = non-defining opaque type use in defining scope\n+    .label = argument `{$arg}` is not a generic parameter\n+    .note = for this opaque type\n \n-ty_utils_binary_not_supported = unsupported binary operation in generic constants\n+ty_utils_index_not_supported = indexing is not supported in generic constants\n+\n+ty_utils_inline_asm_not_supported = assembly is not supported in generic constants\n \n ty_utils_logical_op_not_supported = unsupported operation in generic constants, short-circuiting operations would imply control flow\n \n-ty_utils_assign_not_supported = assignment is not supported in generic constants\n+ty_utils_loop_not_supported = loops and loop control flow are not supported in generic constants\n \n-ty_utils_closure_and_return_not_supported = closures and function keywords are not supported in generic constants\n+ty_utils_multiple_array_fields_simd_type = monomorphising SIMD type `{$ty}` with more than one array field\n \n-ty_utils_control_flow_not_supported = control flow is not supported in generic constants\n+ty_utils_needs_drop_overflow = overflow while checking whether `{$query_ty}` requires drop\n \n-ty_utils_inline_asm_not_supported = assembly is not supported in generic constants\n+ty_utils_never_to_any_not_supported = coercing the `never` type is not supported in generic constants\n \n-ty_utils_operation_not_supported = unsupported operation in generic constants\n+ty_utils_non_primitive_simd_type = monomorphising SIMD type `{$ty}` with a non-primitive-scalar (integer/float/pointer) element type `{$e_ty}`\n \n-ty_utils_unexpected_fnptr_associated_item = `FnPtr` trait with unexpected associated item\n+ty_utils_operation_not_supported = unsupported operation in generic constants\n \n-ty_utils_zero_length_simd_type = monomorphising SIMD type `{$ty}` of zero length\n+ty_utils_oversized_simd_type = monomorphising SIMD type `{$ty}` of length greater than {$max_lanes}\n \n-ty_utils_multiple_array_fields_simd_type = monomorphising SIMD type `{$ty}` with more than one array field\n+ty_utils_pointer_not_supported = pointer casts are not allowed in generic constants\n \n-ty_utils_oversized_simd_type = monomorphising SIMD type `{$ty}` of length greater than {$max_lanes}\n+ty_utils_tuple_not_supported = tuple construction is not supported in generic constants\n \n-ty_utils_non_primitive_simd_type = monomorphising SIMD type `{$ty}` with a non-primitive-scalar (integer/float/pointer) element type `{$e_ty}`\n+ty_utils_unexpected_fnptr_associated_item = `FnPtr` trait with unexpected associated item\n \n-ty_utils_impl_trait_duplicate_arg = non-defining opaque type use in defining scope\n-    .label = generic argument `{$arg}` used twice\n-    .note = for this opaque type\n+ty_utils_yield_not_supported = generator control flow is not allowed in generic constants\n \n-ty_utils_impl_trait_not_param = non-defining opaque type use in defining scope\n-    .label = argument `{$arg}` is not a generic parameter\n-    .note = for this opaque type\n+ty_utils_zero_length_simd_type = monomorphising SIMD type `{$ty}` of zero length"}, {"sha": "5f8eaebf531fd5061f79c4633d3f349e7e70eec6", "filename": "src/tools/tidy/src/fluent_alphabetical.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/src%2Ftools%2Ftidy%2Fsrc%2Ffluent_alphabetical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/src%2Ftools%2Ftidy%2Fsrc%2Ffluent_alphabetical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffluent_alphabetical.rs?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -0,0 +1,72 @@\n+//! Checks that all Flunt files have messages in alphabetical order\n+\n+use crate::walk::{filter_dirs, walk};\n+use std::{fs::OpenOptions, io::Write, path::Path};\n+\n+use regex::Regex;\n+\n+lazy_static::lazy_static! {\n+    static ref MESSAGE: Regex = Regex::new(r#\"(?m)^([a-zA-Z0-9_]+)\\s*=\\s*\"#).unwrap();\n+}\n+\n+fn filter_fluent(path: &Path) -> bool {\n+    if let Some(ext) = path.extension() { ext.to_str() != Some(\"ftl\") } else { true }\n+}\n+\n+fn check_alphabetic(filename: &str, fluent: &str, bad: &mut bool) {\n+    let mut matches = MESSAGE.captures_iter(fluent).peekable();\n+    while let Some(m) = matches.next() {\n+        if let Some(next) = matches.peek() {\n+            let name = m.get(1).unwrap();\n+            let next = next.get(1).unwrap();\n+            if name.as_str() > next.as_str() {\n+                tidy_error!(\n+                    bad,\n+                    \"{filename}: message `{}` appears before `{}`, but is alphabetically later than it\n+run tidy with `--bless` to sort the file correctly\",\n+                    name.as_str(),\n+                    next.as_str()\n+                );\n+            }\n+        } else {\n+            break;\n+        }\n+    }\n+}\n+\n+fn sort_messages(fluent: &str) -> String {\n+    let mut chunks = vec![];\n+    let mut cur = String::new();\n+    for line in fluent.lines() {\n+        if MESSAGE.is_match(line) {\n+            chunks.push(std::mem::take(&mut cur));\n+        }\n+        cur += line;\n+        cur.push('\\n');\n+    }\n+    chunks.push(cur);\n+    chunks.sort();\n+    let mut out = chunks.join(\"\");\n+    out = out.trim().to_string();\n+    out.push('\\n');\n+    out\n+}\n+\n+pub fn check(path: &Path, bless: bool, bad: &mut bool) {\n+    walk(\n+        path,\n+        |path, is_dir| filter_dirs(path) || (!is_dir && filter_fluent(path)),\n+        &mut |ent, contents| {\n+            if bless {\n+                let sorted = sort_messages(contents);\n+                if sorted != contents {\n+                    let mut f =\n+                        OpenOptions::new().write(true).truncate(true).open(ent.path()).unwrap();\n+                    f.write(sorted.as_bytes()).unwrap();\n+                }\n+            } else {\n+                check_alphabetic(ent.path().to_str().unwrap(), contents, bad);\n+            }\n+        },\n+    );\n+}"}, {"sha": "e467514a7a3d7c27ccf1858104da8a291700b738", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -59,6 +59,7 @@ pub mod edition;\n pub mod error_codes;\n pub mod extdeps;\n pub mod features;\n+pub mod fluent_alphabetical;\n pub mod mir_opt_tests;\n pub mod pal;\n pub mod primitive_docs;"}, {"sha": "1c4d96c321c6962595ddcc12c1ce0e76e94f1ec4", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c86212f9bccb4d5ec625b0607053b067732724ab/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86212f9bccb4d5ec625b0607053b067732724ab/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=c86212f9bccb4d5ec625b0607053b067732724ab", "patch": "@@ -96,6 +96,7 @@ fn main() {\n \n         // Checks that only make sense for the compiler.\n         check!(error_codes, &root_path, &[&compiler_path, &librustdoc_path], verbose);\n+        check!(fluent_alphabetical, &compiler_path, bless);\n \n         // Checks that only make sense for the std libs.\n         check!(pal, &library_path);"}]}