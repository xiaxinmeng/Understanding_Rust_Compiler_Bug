{"sha": "c0741c13abe687667f28557c85386a97eaf276e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwNzQxYzEzYWJlNjg3NjY3ZjI4NTU3Yzg1Mzg2YTk3ZWFmMjc2ZTQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-11-22T22:24:12Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-11-23T01:14:18Z"}, "message": "Remove the global bindings table in the typechecker", "tree": {"sha": "955b88a4800e0f3c0fb4789391dee2c1d1c91d75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/955b88a4800e0f3c0fb4789391dee2c1d1c91d75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0741c13abe687667f28557c85386a97eaf276e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0741c13abe687667f28557c85386a97eaf276e4", "html_url": "https://github.com/rust-lang/rust/commit/c0741c13abe687667f28557c85386a97eaf276e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0741c13abe687667f28557c85386a97eaf276e4/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3cb25d5d1ede9d9ef06db6c30cd8448ed425127", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3cb25d5d1ede9d9ef06db6c30cd8448ed425127", "html_url": "https://github.com/rust-lang/rust/commit/d3cb25d5d1ede9d9ef06db6c30cd8448ed425127"}], "stats": {"total": 403, "additions": 304, "deletions": 99}, "files": [{"sha": "24ae00e098b2fa16fd30a1007198c6d31d2bcd4f", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 304, "deletions": 99, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/c0741c13abe687667f28557c85386a97eaf276e4/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0741c13abe687667f28557c85386a97eaf276e4/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=c0741c13abe687667f28557c85386a97eaf276e4", "patch": "@@ -18,7 +18,6 @@ import std.option.some;\n type ty_table = hashmap[ast.def_id, @ty];\n type crate_ctxt = rec(session.session sess,\n                       @ty_table item_types,\n-                      hashmap[int,@ty] bindings,\n                       mutable int next_var_id);\n \n type fn_ctxt = rec(@ty ret_ty,\n@@ -42,7 +41,10 @@ tag sty {\n     ty_vec(@ty);\n     ty_tup(vec[tup(bool /* mutability */, @ty)]);\n     ty_fn(vec[arg], @ty);                           // TODO: effect\n-    ty_var(int);\n+    ty_var(int);                                    // ephemeral type var\n+    ty_local(ast.def_id);                           // type of a local var\n+    // TODO: ty_param(ast.def_id), for fn type params\n+    // TODO: ty_fn_arg(@ty), for a possibly-aliased function argument\n }\n \n tag type_err {\n@@ -381,6 +383,20 @@ fn collect_item_types(@ast.crate crate) -> tup(@ast.crate, @ty_table) {\n             item_to_ty);\n }\n \n+// Expression utilities\n+\n+fn last_expr_of_block(&ast.block bloc) -> option.t[@ast.expr] {\n+    auto len = _vec.len[@ast.stmt](bloc.node.stmts);\n+    if (len == 0u) {\n+        ret none[@ast.expr];\n+    }\n+    auto last_stmt = bloc.node.stmts.(len - 1u);\n+    alt (last_stmt.node) {\n+        case (ast.stmt_expr(?e)) { ret some[@ast.expr](e); }\n+        case (_)                 { ret none[@ast.expr]; }\n+    }\n+}\n+\n // Type utilities\n \n // FIXME: remove me when == works on these tags.\n@@ -457,13 +473,10 @@ fn stmt_ty(@ast.stmt s) -> @ty {\n }\n \n fn block_ty(&ast.block b) -> @ty {\n-    auto len = _vec.len[@ast.stmt](b.node.stmts);\n-    if (len == 0u) {\n-        ret plain_ty(ty_nil);\n+    alt (last_expr_of_block(b)) {\n+        case (some[@ast.expr](?e)) { ret expr_ty(e); }\n+        case (none[@ast.expr])     { ret plain_ty(ty_nil); }\n     }\n-    // FIXME: should rewind to last non-dead stmt? Or perhaps\n-    // we prohibit all dead stmts?\n-    ret stmt_ty(b.node.stmts.(len - 1u));\n }\n \n fn expr_ty(@ast.expr expr) -> @ty {\n@@ -491,7 +504,7 @@ fn expr_ty(@ast.expr expr) -> @ty {\n \n // Type unification\n \n-fn unify(&@crate_ctxt ccx, @ty expected, @ty actual) -> unify_result {\n+fn unify(&fn_ctxt fcx, @ty expected, @ty actual) -> unify_result {\n     // Wraps the given type in an appropriate cname.\n     //\n     // TODO: This doesn't do anything yet. We should carry the cname up from\n@@ -508,10 +521,41 @@ fn unify(&@crate_ctxt ccx, @ty expected, @ty actual) -> unify_result {\n         ret ures_err(terr_mismatch, expected, actual);\n     }\n \n-    fn unify_step(&@crate_ctxt ccx, @ty expected, @ty actual)\n-            -> unify_result {\n+    fn unify_step(&fn_ctxt fcx, &hashmap[int,@ty] bindings, @ty expected,\n+                  @ty actual) -> unify_result {\n         // TODO: rewrite this using tuple pattern matching when available, to\n         // avoid all this rightward drift and spikiness.\n+\n+        // If the RHS is a variable type, then just do the appropriate\n+        // binding.\n+        alt (actual.struct) {\n+            case (ty_var(?actual_id)) {\n+                alt (bindings.find(actual_id)) {\n+                    case (some[@ty](?actual_ty)) {\n+                        // FIXME: change the binding here?\n+                        // FIXME: \"be\"\n+                        ret unify_step(fcx, bindings, expected, actual_ty);\n+                    }\n+                    case (none[@ty]) {\n+                        bindings.insert(actual_id, expected);\n+                        ret ures_ok(expected);\n+                    }\n+                }\n+            }\n+            case (ty_local(?actual_id)) {\n+                auto actual_ty = fcx.locals.get(actual_id);\n+                auto result = unify_step(fcx, bindings, expected, actual_ty);\n+                alt (result) {\n+                    case (ures_ok(?result_ty)) {\n+                        fcx.locals.insert(actual_id, result_ty);\n+                    }\n+                    case (_) { /* empty */ }\n+                }\n+                ret result;\n+            }\n+            case (_) { /* empty */ }\n+        }\n+\n         alt (expected.struct) {\n             case (ty_nil)        { ret struct_cmp(expected, actual); }\n             case (ty_bool)       { ret struct_cmp(expected, actual); }\n@@ -524,7 +568,8 @@ fn unify(&@crate_ctxt ccx, @ty expected, @ty actual) -> unify_result {\n             case (ty_box(?expected_sub)) {\n                 alt (actual.struct) {\n                     case (ty_box(?actual_sub)) {\n-                        auto result = unify_step(ccx,\n+                        auto result = unify_step(fcx,\n+                                                 bindings,\n                                                  expected_sub,\n                                                  actual_sub);\n                         alt (result) {\n@@ -548,7 +593,8 @@ fn unify(&@crate_ctxt ccx, @ty expected, @ty actual) -> unify_result {\n             case (ty_vec(?expected_sub)) {\n                 alt (actual.struct) {\n                     case (ty_vec(?actual_sub)) {\n-                        auto result = unify_step(ccx,\n+                        auto result = unify_step(fcx,\n+                                                 bindings,\n                                                  expected_sub,\n                                                  actual_sub);\n                         alt (result) {\n@@ -594,7 +640,8 @@ fn unify(&@crate_ctxt ccx, @ty expected, @ty actual) -> unify_result {\n                                 ret ures_err(err, expected, actual);\n                             }\n \n-                            auto result = unify_step(ccx,\n+                            auto result = unify_step(fcx,\n+                                                     bindings,\n                                                      expected_elem._1,\n                                                      actual_elem._1);\n                             alt (result) {\n@@ -646,7 +693,8 @@ fn unify(&@crate_ctxt ccx, @ty expected, @ty actual) -> unify_result {\n                                 result_mode = ast.val;\n                             }\n \n-                            auto result = unify_step(ccx,\n+                            auto result = unify_step(fcx,\n+                                                     bindings,\n                                                      expected_input.ty,\n                                                      actual_input.ty);\n \n@@ -666,7 +714,8 @@ fn unify(&@crate_ctxt ccx, @ty expected, @ty actual) -> unify_result {\n \n                         // Check the output.\n                         auto result_out;\n-                        auto result = unify_step(ccx,\n+                        auto result = unify_step(fcx,\n+                                                 bindings,\n                                                  expected_output,\n                                                  actual_output);\n                         alt (result) {\n@@ -689,37 +738,59 @@ fn unify(&@crate_ctxt ccx, @ty expected, @ty actual) -> unify_result {\n             }\n \n             case (ty_var(?expected_id)) {\n-                if (ccx.bindings.contains_key(expected_id)) {\n-                    check (ccx.bindings.contains_key(expected_id));\n-                    auto binding = ccx.bindings.get(expected_id);\n-                    ret unify_step(ccx, binding, actual);\n+                alt (bindings.find(expected_id)) {\n+                    case (some[@ty](?expected_ty)) {\n+                        // FIXME: change the binding here?\n+                        // FIXME: \"be\"\n+                        ret unify_step(fcx, bindings, expected_ty, actual);\n+                    }\n+                    case (none[@ty]) {\n+                        bindings.insert(expected_id, actual);\n+                        ret ures_ok(actual);\n+                    }\n                 }\n+            }\n \n-                ccx.bindings.insert(expected_id, actual);\n-                ret ures_ok(actual);\n+            case (ty_local(?expected_id)) {\n+                auto expected_ty = fcx.locals.get(expected_id);\n+                auto result = unify_step(fcx, bindings, expected_ty, actual);\n+                alt (result) {\n+                    case (ures_ok(?result_ty)) {\n+                        \n+                        fcx.locals.insert(expected_id, result_ty);\n+                    }\n+                    case (_) { /* empty */ }\n+                }\n+                ret result;\n             }\n         }\n \n         // TODO: remove me once match-exhaustiveness checking works\n         fail;\n     }\n \n-    ret unify_step(ccx, expected, actual);\n+    fn hash_int(&int x) -> uint { ret x as uint; }\n+    fn eq_int(&int a, &int b) -> bool { ret a == b; }\n+    auto hasher = hash_int;\n+    auto eqer = eq_int;\n+    auto bindings = map.mk_hashmap[int,@ty](hasher, eqer);\n+\n+    ret unify_step(fcx, bindings, expected, actual);\n }\n \n // Requires that the two types unify, and prints an error message if they\n // don't. Returns the unified type.\n-fn demand(&@crate_ctxt ccx, &span sp, @ty expected, @ty actual) -> @ty {\n-    alt (unify(ccx, expected, actual)) {\n+fn demand(&fn_ctxt fcx, &span sp, @ty expected, @ty actual) -> @ty {\n+    alt (unify(fcx, expected, actual)) {\n         case (ures_ok(?ty)) {\n             ret ty;\n         }\n \n         case (ures_err(?err, ?expected, ?actual)) {\n-            ccx.sess.span_err(sp, \"mismatched types: expected \"\n-                              + ty_to_str(expected) + \" but found \"\n-                              + ty_to_str(actual) + \" (\" +\n-                              type_err_to_str(err) + \")\");\n+            fcx.ccx.sess.span_err(sp, \"mismatched types: expected \"\n+                                  + ty_to_str(expected) + \" but found \"\n+                                  + ty_to_str(actual) + \" (\" +\n+                                  type_err_to_str(err) + \")\");\n \n             // TODO: In the future, try returning \"expected\", reporting the\n             // error, and continue.\n@@ -729,32 +800,130 @@ fn demand(&@crate_ctxt ccx, &span sp, @ty expected, @ty actual) -> @ty {\n }\n \n // Returns true if the two types unify and false if they don't.\n-fn are_compatible(&@crate_ctxt ccx, @ty expected, @ty actual) -> bool {\n-    alt (unify(ccx, expected, actual)) {\n+fn are_compatible(&fn_ctxt fcx, @ty expected, @ty actual) -> bool {\n+    alt (unify(fcx, expected, actual)) {\n         case (ures_ok(_))        { ret true;  }\n         case (ures_err(_, _, _)) { ret false; }\n     }\n }\n \n-// Writeback: the phase that writes inferred types back into the AST.\n+// Type unification over typed expressions. Note that the expression that you\n+// pass to this function must have been passed to check_expr() first.\n+//\n+// TODO: enforce this via a predicate.\n+// TODO: propagate the types downward. This makes the typechecker quadratic,\n+//       but we can mitigate that if expected == actual == unified.\n+\n+fn demand_expr(&fn_ctxt fcx, @ty expected, @ast.expr e) -> @ast.expr {\n+    // FIXME: botch to work around typestate bug in rustboot\n+    let vec[@ast.expr] v = vec();\n+    auto e_1 = ast.expr_vec(v, ast.ann_none);\n+\n+    alt (e.node) {\n+        case (ast.expr_vec(?es, ?ann)) {\n+            auto t = demand(fcx, e.span, ann_to_type(ann), expected);\n+            e_1 = ast.expr_vec(es, ast.ann_type(t));\n+        }\n+        case (ast.expr_tup(?es, ?ann)) {\n+            auto t = demand(fcx, e.span, ann_to_type(ann), expected);\n+            e_1 = ast.expr_tup(es, ast.ann_type(t));\n+        }\n+        case (ast.expr_rec(?es, ?ann)) {\n+            auto t = demand(fcx, e.span, ann_to_type(ann), expected);\n+            e_1 = ast.expr_rec(es, ast.ann_type(t));\n+        }\n+        case (ast.expr_call(?sube, ?es, ?ann)) {\n+            auto t = demand(fcx, e.span, ann_to_type(ann), expected);\n+            e_1 = ast.expr_call(sube, es, ast.ann_type(t));\n+        }\n+        case (ast.expr_binary(?bop, ?lhs, ?rhs, ?ann)) {\n+            auto t = demand(fcx, e.span, ann_to_type(ann), expected);\n+            e_1 = ast.expr_binary(bop, lhs, rhs, ast.ann_type(t));\n+        }\n+        case (ast.expr_unary(?uop, ?sube, ?ann)) {\n+            auto t = demand(fcx, e.span, ann_to_type(ann), expected);\n+            e_1 = ast.expr_unary(uop, sube, ast.ann_type(t));\n+        }\n+        case (ast.expr_lit(?lit, ?ann)) {\n+            auto t = demand(fcx, e.span, ann_to_type(ann), expected);\n+            e_1 = ast.expr_lit(lit, ast.ann_type(t));\n+        }\n+        case (ast.expr_cast(?sube, ?ast_ty, ?ann)) {\n+            auto t = demand(fcx, e.span, ann_to_type(ann), expected);\n+            e_1 = ast.expr_cast(sube, ast_ty, ast.ann_type(t));\n+        }\n+        case (ast.expr_if(?cond, ?then, ?els, ?ann)) {\n+            auto t = demand(fcx, e.span, ann_to_type(ann), expected);\n+            e_1 = ast.expr_if(cond, then, els, ast.ann_type(t));\n+        }\n+        case (ast.expr_while(?cond, ?bloc, ?ann)) {\n+            auto t = demand(fcx, e.span, ann_to_type(ann), expected);\n+            e_1 = ast.expr_while(cond, bloc, ast.ann_type(t));\n+        }\n+        case (ast.expr_do_while(?bloc, ?cond, ?ann)) {\n+            auto t = demand(fcx, e.span, ann_to_type(ann), expected);\n+            e_1 = ast.expr_do_while(bloc, cond, ast.ann_type(t));\n+        }\n+        case (ast.expr_block(?bloc, ?ann)) {\n+            auto t = demand(fcx, e.span, ann_to_type(ann), expected);\n+            e_1 = ast.expr_block(bloc, ast.ann_type(t));\n+        }\n+        case (ast.expr_assign(?lhs, ?rhs, ?ann)) {\n+            auto t = demand(fcx, e.span, ann_to_type(ann), expected);\n+            e_1 = ast.expr_assign(lhs, rhs, ast.ann_type(t));\n+        }\n+        case (ast.expr_field(?lhs, ?rhs, ?ann)) {\n+            auto t = demand(fcx, e.span, ann_to_type(ann), expected);\n+            e_1 = ast.expr_field(lhs, rhs, ast.ann_type(t));\n+        }\n+        case (ast.expr_index(?base, ?index, ?ann)) {\n+            auto t = demand(fcx, e.span, ann_to_type(ann), expected);\n+            e_1 = ast.expr_index(base, index, ast.ann_type(t));\n+        }\n+        case (ast.expr_name(?name, ?d, ?ann)) {\n+            auto t = demand(fcx, e.span, ann_to_type(ann), expected);\n+            e_1 = ast.expr_name(name, d, ast.ann_type(t));\n+        }\n+        case (_) {\n+            fail;\n+        }\n+    }\n \n-fn resolve_vars(@crate_ctxt ccx, @ty t) -> @ty {\n-    alt (t.struct) {\n-        case (ty_var(?v)) {\n-            check (ccx.bindings.contains_key(v));\n-            ret resolve_vars(ccx, ccx.bindings.get(v));\n+    ret @fold.respan[ast.expr_](e.span, e_1);\n+}\n+\n+// Type unification over typed blocks.\n+fn demand_block(&fn_ctxt fcx, @ty expected, &ast.block bloc) -> ast.block {\n+    alt (last_expr_of_block(bloc)) {\n+        case (some[@ast.expr](?e_0)) {\n+            auto e_1 = demand_expr(fcx, expected, e_0);\n+\n+            auto len = _vec.len[@ast.stmt](bloc.node.stmts);\n+            auto last_stmt_0 = bloc.node.stmts.(len - 1u);\n+            auto prev_stmts = _vec.pop[@ast.stmt](bloc.node.stmts);\n+            auto last_stmt_1 = @fold.respan[ast.stmt_](last_stmt_0.span,\n+                                                       ast.stmt_expr(e_1));\n+            auto stmts_1 = prev_stmts + vec(last_stmt_1);\n+\n+            auto block_ = rec(stmts=stmts_1, index=bloc.node.index);\n+            ret fold.respan[ast.block_](bloc.span, block_);\n+        }\n+        case (none[@ast.expr]) {\n+            demand(fcx, bloc.span, expected, plain_ty(ty_nil));\n+            ret bloc;\n         }\n     }\n-    ret t;\n }\n \n+// Writeback: the phase that writes inferred types back into the AST.\n+\n fn writeback_local(&fn_ctxt fcx, &span sp, @ast.local local)\n         -> @ast.decl {\n     if (!fcx.locals.contains_key(local.id)) {\n         fcx.ccx.sess.span_err(sp, \"unable to determine type of local: \"\n                               + local.ident);\n     }\n-    auto local_ty = resolve_vars(fcx.ccx, fcx.locals.get(local.id));\n+    auto local_ty = fcx.locals.get(local.id);\n     auto local_wb = @rec(ann=ast.ann_type(local_ty) with *local);\n     ret @fold.respan[ast.decl_](sp, ast.decl_local(local_wb));\n }\n@@ -792,13 +961,16 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n \n         case (ast.expr_binary(?binop, ?lhs, ?rhs, _)) {\n-            auto lhs_1 = check_expr(fcx, lhs);\n-            auto rhs_1 = check_expr(fcx, rhs);\n-            auto lhs_t = expr_ty(lhs_1);\n-            auto rhs_t = expr_ty(rhs_1);\n+            auto lhs_0 = check_expr(fcx, lhs);\n+            auto rhs_0 = check_expr(fcx, rhs);\n+            auto lhs_t0 = expr_ty(lhs_0);\n+            auto rhs_t0 = expr_ty(rhs_0);\n+\n             // FIXME: Binops have a bit more subtlety than this.\n-            demand(fcx.ccx, expr.span, lhs_t, rhs_t);\n-            auto t = lhs_t;\n+            auto lhs_1 = demand_expr(fcx, rhs_t0, lhs_0);\n+            auto rhs_1 = demand_expr(fcx, expr_ty(lhs_1), rhs_0);\n+\n+            auto t = lhs_t0;\n             alt (binop) {\n                 case (ast.eq) { t = plain_ty(ty_bool); }\n                 case (ast.lt) { t = plain_ty(ty_bool); }\n@@ -823,23 +995,25 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         }\n \n         case (ast.expr_name(?name, ?defopt, _)) {\n-            auto ty = @rec(struct=ty_nil, cname=none[str]);\n+            auto t = @rec(struct=ty_nil, cname=none[str]);\n             alt (option.get[ast.def](defopt)) {\n                 case (ast.def_arg(?id)) {\n                     check (fcx.locals.contains_key(id));\n-                    ty = fcx.locals.get(id);\n+                    t = fcx.locals.get(id);\n                 }\n                 case (ast.def_local(?id)) {\n-                    check (fcx.locals.contains_key(id));\n-                    ty = fcx.locals.get(id);\n+                    alt (fcx.locals.find(id)) {\n+                        case (some[@ty](?t1)) { t = t1; }\n+                        case (none[@ty])      { t = plain_ty(ty_local(id)); }\n+                    }\n                 }\n                 case (ast.def_fn(?id)) {\n                     check (fcx.ccx.item_types.contains_key(id));\n-                    ty = fcx.ccx.item_types.get(id);\n+                    t = fcx.ccx.item_types.get(id);\n                 }\n                 case (ast.def_const(?id)) {\n                     check (fcx.ccx.item_types.contains_key(id));\n-                    ty = fcx.ccx.item_types.get(id);\n+                    t = fcx.ccx.item_types.get(id);\n                 }\n                 case (_) {\n                     // FIXME: handle other names.\n@@ -850,65 +1024,103 @@ fn check_expr(&fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             }\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_name(name, defopt,\n-                                                      ast.ann_type(ty)));\n+                                                      ast.ann_type(t)));\n         }\n \n         case (ast.expr_assign(?lhs, ?rhs, _)) {\n-            auto lhs_1 = check_expr(fcx, lhs);\n-            auto rhs_1 = check_expr(fcx, rhs);\n-            auto lhs_t = expr_ty(lhs_1);\n-            auto rhs_t = expr_ty(rhs_1);\n-            demand(fcx.ccx, expr.span, lhs_t, rhs_t);\n+            auto lhs_0 = check_expr(fcx, lhs);\n+            auto rhs_0 = check_expr(fcx, rhs);\n+            auto lhs_t0 = expr_ty(lhs_0);\n+            auto rhs_t0 = expr_ty(rhs_0);\n+\n+            auto lhs_1 = demand_expr(fcx, rhs_t0, lhs_0);\n+            auto rhs_1 = demand_expr(fcx, expr_ty(lhs_1), rhs_0);\n+\n+            auto ann = ast.ann_type(rhs_t0);\n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_assign(lhs_1, rhs_1,\n-                                                        ast.ann_type(rhs_t)));\n+                                        ast.expr_assign(lhs_1, rhs_1, ann));\n         }\n \n         case (ast.expr_if(?cond, ?thn, ?elsopt, _)) {\n-            auto cond_1 = check_expr(fcx, cond);\n-            auto thn_1 = check_block(fcx, thn);\n-            demand(fcx.ccx, cond.span, plain_ty(ty_bool), expr_ty(cond_1));\n-            auto thn_t = block_ty(thn_1);\n-            auto elsopt_1 = none[ast.block];\n-            auto elsopt_t = plain_ty(ty_nil);\n+            auto cond_0 = check_expr(fcx, cond);\n+            auto cond_1 = demand_expr(fcx, plain_ty(ty_bool), cond_0);\n+\n+            auto thn_0 = check_block(fcx, thn);\n+            auto thn_t = block_ty(thn_0);\n+\n+            auto elsopt_1;\n+            auto elsopt_t;\n             alt (elsopt) {\n                 case (some[ast.block](?els)) {\n-                    auto els_1 = check_block(fcx, els);\n+                    auto els_0 = check_block(fcx, els);\n+                    auto els_1 = demand_block(fcx, thn_t, els_0);\n                     elsopt_1 = some[ast.block](els_1);\n                     elsopt_t = block_ty(els_1);\n                 }\n+                case (none[ast.block]) {\n+                    elsopt_1 = none[ast.block];\n+                    elsopt_t = plain_ty(ty_nil);\n+                }\n             }\n-            demand(fcx.ccx, expr.span, thn_t, elsopt_t);\n+\n+            auto thn_1 = demand_block(fcx, elsopt_t, thn_0);\n+\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_if(cond_1, thn_1, elsopt_1,\n-                                                    ast.ann_type(thn_t)));\n+                                                    ast.ann_type(elsopt_t)));\n         }\n \n         case (ast.expr_call(?f, ?args, _)) {\n-            auto f_1 = check_expr(fcx, f);\n-            let @ty ret_t = plain_ty(ty_nil);\n-            alt (expr_ty(f_1).struct) {\n-                case (ty_fn(_, ?r)) {\n-                    ret_t = r;\n+            // Check the function.\n+            auto f_0 = check_expr(fcx, f);\n+\n+            // Check the arguments and generate the argument signature.\n+            let vec[@ast.expr] args_0 = vec();\n+            let vec[arg] arg_tys_0 = vec();\n+            for (@ast.expr a in args) {\n+                auto a_0 = check_expr(fcx, a);\n+                append[@ast.expr](args_0, a_0);\n+\n+                // FIXME: this breaks aliases. We need a ty_fn_arg.\n+                append[arg](arg_tys_0, rec(mode=ast.val, ty=expr_ty(a_0)));\n+            }\n+            auto rt_0 = plain_ty(ty_var(-2));   // FIXME: broken!\n+            auto t_0 = plain_ty(ty_fn(arg_tys_0, rt_0));\n+\n+            // Unify and write back to the function.\n+            auto f_1 = demand_expr(fcx, t_0, f_0);\n+\n+            // Take the argument types out of the resulting function type.\n+            auto t_1 = expr_ty(f_1);\n+            let vec[arg] arg_tys_1 = vec();     // TODO: typestate botch\n+            let @ty rt_1 = plain_ty(ty_nil);    // TODO: typestate botch\n+            alt (t_1.struct) {\n+                case (ty_fn(?arg_tys, ?rt)) {\n+                    arg_tys_1 = arg_tys;\n+                    rt_1 = rt;\n                 }\n                 case (_) {\n                     fcx.ccx.sess.span_err(f_1.span,\n-                                          \"callee has non-function type: \"\n-                                          + ty_to_str(expr_ty(f_1)));\n+                                          \"mismatched types: callee has \" +\n+                                          \"non-function type: \" +\n+                                          ty_to_str(t_1));\n                 }\n             }\n+\n+            // Unify and write back to the arguments.\n+            auto i = 0u;\n             let vec[@ast.expr] args_1 = vec();\n-            let vec[arg] args_t = vec();\n-            for (@ast.expr a in args) {\n-                auto a_1 = check_expr(fcx, a);\n-                append[@ast.expr](args_1, a_1);\n-                append[arg](args_t, rec(mode=ast.val, ty=expr_ty(a_1)));\n+            while (i < _vec.len[@ast.expr](args_0)) {\n+                auto arg_ty_1 = arg_tys_1.(i);\n+                auto e = demand_expr(fcx, arg_ty_1.ty, args_0.(i));\n+                append[@ast.expr](args_1, e);\n+\n+                i += 1u;\n             }\n-            demand(fcx.ccx, expr.span, expr_ty(f_1),\n-                   plain_ty(ty_fn(args_t, ret_t)));\n+\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_call(f_1, args_1,\n-                                                      ast.ann_type(ret_t)));\n+                                                      ast.ann_type(rt_1)));\n         }\n \n         case (ast.expr_cast(?e, ?t, _)) {\n@@ -965,12 +1177,13 @@ fn check_stmt(&fn_ctxt fcx, &@ast.stmt stmt)\n                     auto init = local.init;\n                     alt (local.init) {\n                         case (some[@ast.expr](?expr)) {\n-                            auto expr_t = check_expr(fcx, expr);\n-                            rhs_ty = expr_ty(expr_t);\n-                            init = some[@ast.expr](expr_t);\n+                            auto expr_0 = check_expr(fcx, expr);\n+                            auto lty = plain_ty(ty_local(local.id));\n+                            auto expr_1 = demand_expr(fcx, lty, expr_0);\n+                            init = some[@ast.expr](expr_1);\n                         }\n                     }\n-                    demand(fcx.ccx, decl.span, local_ty, rhs_ty);\n+\n                     auto local_1 = @rec(init = init with *local);\n                     auto decl_1 = @rec(node=ast.decl_local(local_1)\n                                        with *decl);\n@@ -989,8 +1202,7 @@ fn check_stmt(&fn_ctxt fcx, &@ast.stmt stmt)\n         case (ast.stmt_ret(?expr_opt)) {\n             alt (expr_opt) {\n                 case (none[@ast.expr]) {\n-                    if (!are_compatible(fcx.ccx, fcx.ret_ty,\n-                                        plain_ty(ty_nil))) {\n+                    if (!are_compatible(fcx, fcx.ret_ty, plain_ty(ty_nil))) {\n                         fcx.ccx.sess.err(\"ret; in function \"\n                                          + \"returning non-nil\");\n                     }\n@@ -1000,7 +1212,7 @@ fn check_stmt(&fn_ctxt fcx, &@ast.stmt stmt)\n \n                 case (some[@ast.expr](?expr)) {\n                     auto expr_t = check_expr(fcx, expr);\n-                    demand(fcx.ccx, expr.span, fcx.ret_ty, expr_ty(expr_t));\n+                    demand(fcx, expr.span, fcx.ret_ty, expr_ty(expr_t));\n                     ret @fold.respan[ast.stmt_](stmt.span,\n                                                 ast.stmt_ret(some(expr_t)));\n                 }\n@@ -1014,15 +1226,14 @@ fn check_stmt(&fn_ctxt fcx, &@ast.stmt stmt)\n \n         case (ast.stmt_check_expr(?expr)) {\n             auto expr_t = check_expr(fcx, expr);\n-            demand(fcx.ccx, expr.span, plain_ty(ty_bool), expr_ty(expr_t));\n+            demand(fcx, expr.span, plain_ty(ty_bool), expr_ty(expr_t));\n             ret @fold.respan[ast.stmt_](stmt.span,\n                                         ast.stmt_check_expr(expr_t));\n         }\n \n         case (ast.stmt_expr(?expr)) {\n             auto expr_t = check_expr(fcx, expr);\n-            if (!are_compatible(fcx.ccx, expr_ty(expr_t),\n-                                plain_ty(ty_nil))) {\n+            if (!are_compatible(fcx, expr_ty(expr_t), plain_ty(ty_nil))) {\n                 // TODO: real warning function\n                 log \"warning: expression used as statement should have \" +\n                     \"void type\";\n@@ -1073,14 +1284,8 @@ fn check_fn(&@crate_ctxt ccx, &span sp, ast.ident ident, &ast._fn f,\n fn check_crate(session.session sess, @ast.crate crate) -> @ast.crate {\n     auto result = collect_item_types(crate);\n \n-    fn hash_int(&int x) -> uint { ret x as uint; }\n-    fn eq_int(&int a, &int b) -> bool { ret a == b; }\n-    auto hasher = hash_int;\n-    auto eqer = eq_int;\n-\n     auto ccx = @rec(sess=sess,\n                     item_types=result._1,\n-                    bindings = map.mk_hashmap[int,@ty](hasher, eqer),\n                     mutable next_var_id=0);\n \n     auto fld = fold.new_identity_fold[@crate_ctxt]();"}]}