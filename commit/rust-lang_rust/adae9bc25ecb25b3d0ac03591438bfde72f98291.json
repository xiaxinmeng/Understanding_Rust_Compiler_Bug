{"sha": "adae9bc25ecb25b3d0ac03591438bfde72f98291", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkYWU5YmMyNWVjYjI1YjNkMGFjMDM1OTE0MzhiZmRlNzJmOTgyOTE=", "commit": {"author": {"name": "Austin Hicks", "email": "camlorn@camlorn.net", "date": "2016-11-21T19:23:15Z"}, "committer": {"name": "Austin Hicks", "email": "camlorn@camlorn.net", "date": "2016-12-14T17:28:21Z"}, "message": "Make tidy", "tree": {"sha": "0a55d125ac45f9bf55c7a668963abf67104d8c5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a55d125ac45f9bf55c7a668963abf67104d8c5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adae9bc25ecb25b3d0ac03591438bfde72f98291", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adae9bc25ecb25b3d0ac03591438bfde72f98291", "html_url": "https://github.com/rust-lang/rust/commit/adae9bc25ecb25b3d0ac03591438bfde72f98291", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adae9bc25ecb25b3d0ac03591438bfde72f98291/comments", "author": {"login": "ahicks92", "id": 6968705, "node_id": "MDQ6VXNlcjY5Njg3MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/6968705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahicks92", "html_url": "https://github.com/ahicks92", "followers_url": "https://api.github.com/users/ahicks92/followers", "following_url": "https://api.github.com/users/ahicks92/following{/other_user}", "gists_url": "https://api.github.com/users/ahicks92/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahicks92/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahicks92/subscriptions", "organizations_url": "https://api.github.com/users/ahicks92/orgs", "repos_url": "https://api.github.com/users/ahicks92/repos", "events_url": "https://api.github.com/users/ahicks92/events{/privacy}", "received_events_url": "https://api.github.com/users/ahicks92/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ahicks92", "id": 6968705, "node_id": "MDQ6VXNlcjY5Njg3MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/6968705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahicks92", "html_url": "https://github.com/ahicks92", "followers_url": "https://api.github.com/users/ahicks92/followers", "following_url": "https://api.github.com/users/ahicks92/following{/other_user}", "gists_url": "https://api.github.com/users/ahicks92/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahicks92/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahicks92/subscriptions", "organizations_url": "https://api.github.com/users/ahicks92/orgs", "repos_url": "https://api.github.com/users/ahicks92/repos", "events_url": "https://api.github.com/users/ahicks92/events{/privacy}", "received_events_url": "https://api.github.com/users/ahicks92/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d23dc7956ab31a2758b723213bf6235ba57ed55", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d23dc7956ab31a2758b723213bf6235ba57ed55", "html_url": "https://github.com/rust-lang/rust/commit/3d23dc7956ab31a2758b723213bf6235ba57ed55"}], "stats": {"total": 40, "additions": 26, "deletions": 14}, "files": [{"sha": "ebda879e9086f4556b761c50447cda9e7d1c26cd", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/adae9bc25ecb25b3d0ac03591438bfde72f98291/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adae9bc25ecb25b3d0ac03591438bfde72f98291/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=adae9bc25ecb25b3d0ac03591438bfde72f98291", "patch": "@@ -538,28 +538,36 @@ impl<'a, 'gcx, 'tcx> Struct {\n             min_size: Size::from_bytes(0),\n         };\n \n-        if is_enum_variant { assert!(fields.len() >= 1, \"Enum variants must have at least a discriminant field.\") }\n+        if is_enum_variant {\n+            assert!(fields.len() >= 1, \"Enum variants must have at least a discriminant field.\")\n+        }\n+\n         if fields.len() == 0 {return Ok(ret)};\n \n         ret.offsets = vec![Size::from_bytes(0); fields.len()];\n         let mut inverse_memory_index: Vec<u32> = (0..fields.len() as u32).collect();\n \n         if repr == attr::ReprAny {\n             let start = if is_enum_variant {1} else {0};\n-            // FIXME(camlorn): we can't reorder the last field because it is possible for structs to be coerced to unsized.\n+            // FIXME(camlorn): we can't reorder the last field because\n+            // it is possible for structs to be coerced to unsized.\n             // Example: struct Foo<T: ?Sized> { x: i32, y: T }\n             // We can coerce &Foo<u8> to &Foo<Trait>.\n             let end = inverse_memory_index.len()-1;\n             if end > start {\n                 let optimizing  = &mut inverse_memory_index[start..end];\n                 optimizing.sort_by_key(|&x| fields[x as usize].align(dl).abi());\n             }\n-            if is_enum_variant { assert_eq!(inverse_memory_index[0], 0, \"Enums must have field 0 as the field with lowest offset.\") }\n+            if is_enum_variant {\n+                assert_eq!(inverse_memory_index[0], 0,\n+                  \"Enums must have field 0 as the field with lowest offset.\")\n+            }\n         }\n-        \n+\n         // At this point, inverse_memory_index holds field indices by increasing offset.\n         // That is, if field 5 has offset 0, the first element of inverse_memory_index is 5.\n-        // We now write field offsets to the corresponding offset slot; field 5 with offset 0 puts 0 in offsets[5].\n+        // We now write field offsets to the corresponding offset slot;\n+        // field 5 with offset 0 puts 0 in offsets[5].\n         // At the bottom of this function, we use inverse_memory_index to produce memory_index.\n \n         let mut offset = Size::from_bytes(0);\n@@ -976,7 +984,10 @@ impl<'a, 'gcx, 'tcx> Layout {\n             ty::TyFnPtr(_) => Scalar { value: Pointer, non_zero: true },\n \n             // The never type.\n-            ty::TyNever => Univariant { variant: Struct::new(dl, &vec![], attr::ReprAny, false, ty)?, non_zero: false },\n+            ty::TyNever => Univariant {\n+                variant: Struct::new(dl, &vec![], attr::ReprAny, false, ty)?,\n+                non_zero: false\n+            },\n \n             // Potentially-fat pointers.\n             ty::TyBox(pointee) |\n@@ -1179,7 +1190,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                               .collect::<Result<Vec<_>, _>>()?,\n                             hint, false, ty)?;\n \n-                        // We have to fix the last element of path here as only we know the right value.\n+                        // We have to fix the last element of path here.\n                         let mut i = *path.last().unwrap();\n                         i = st.memory_index[i as usize];\n                         *path.last_mut().unwrap() = i;"}, {"sha": "751c9c3440f66326a06454204416c9cf237f388f", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/adae9bc25ecb25b3d0ac03591438bfde72f98291/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adae9bc25ecb25b3d0ac03591438bfde72f98291/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=adae9bc25ecb25b3d0ac03591438bfde72f98291", "patch": "@@ -750,7 +750,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                 if let Layout::General { ref variants, ref size, discr, .. } = *layout {\n                     let discr_size = Primitive::Int(discr).size(&cx.tcx.data_layout).bytes();\n \n-                    debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\", t, size.bytes(), layout);\n+                    debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n+                      t, size.bytes(), layout);\n \n                     let (largest, slargest, largest_index) = enum_definition.variants\n                         .iter()"}, {"sha": "f6b5bde6ebb445b359427f970ff024971871ab66", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adae9bc25ecb25b3d0ac03591438bfde72f98291/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adae9bc25ecb25b3d0ac03591438bfde72f98291/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=adae9bc25ecb25b3d0ac03591438bfde72f98291", "patch": "@@ -891,15 +891,15 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         let layout = cx.layout_of(self.ty);\n-        \n-        // The following code is slightly convoluted as to allow us to avoid allocating in the Univariant case.\n-        // tmp exists only so we can take a reference to it in the second match arm below.\n+\n         let tmp;\n         let offsets = match *layout {\n             layout::Univariant { ref variant, .. } => &variant.offsets,\n             layout::Vector { element, count } => {\n                 let element_size = element.size(&cx.tcx().data_layout).bytes();\n-                tmp = (0..count).map(|i| layout::Size::from_bytes(i*element_size)).collect::<Vec<layout::Size>>();\n+                tmp = (0..count).\n+                  map(|i| layout::Size::from_bytes(i*element_size))\n+                  .collect::<Vec<layout::Size>>();\n                 &tmp\n             }\n             _ => bug!(\"{} is not a struct\", self.ty)"}, {"sha": "a3e95a153418dbd3116fceacc3aa23614930a3bd", "filename": "src/test/run-pass/enum-size-variance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adae9bc25ecb25b3d0ac03591438bfde72f98291/src%2Ftest%2Frun-pass%2Fenum-size-variance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adae9bc25ecb25b3d0ac03591438bfde72f98291/src%2Ftest%2Frun-pass%2Fenum-size-variance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-size-variance.rs?ref=adae9bc25ecb25b3d0ac03591438bfde72f98291", "patch": "@@ -11,8 +11,8 @@\n #![warn(variant_size_differences)]\n #![allow(dead_code)]\n \n-// Note that the following test only works because all fields of the enum variants are of the same size.\n-// If this test is modified so that the reordering logic in librustc/ty/layout.rs kicks in, it will fail.\n+// Note that the following test works because all fields of the enum variants are of the same size.\n+// If this test is modified and the reordering logic in librustc/ty/layout.rs kicks in, it fails.\n \n enum Enum1 { }\n "}]}