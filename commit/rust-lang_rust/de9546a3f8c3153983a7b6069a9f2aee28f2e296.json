{"sha": "de9546a3f8c3153983a7b6069a9f2aee28f2e296", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlOTU0NmEzZjhjMzE1Mzk4M2E3YjYwNjlhOWYyYWVlMjhmMmUyOTY=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-09-08T23:29:07Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-09-10T03:50:06Z"}, "message": "std::vec: Replace each_permutation with a new Permutations iterator\n\nIntroduce ElementSwaps and Permutations. ElementSwaps is an iterator\nthat for a given sequence length yields the element swaps needed\nto visit each possible permutation of the sequence in turn.\n\nWe use an algorithm that generates a sequence such that each permutation\nis only one swap apart.\n\n    let mut v = [1, 2, 3];\n    for perm in v.permutations_iter() {\n        // yields 1 2 3 | 1 3 2 | 3 1 2 | 3 2 1 | 2 3 1 | 2 1 3\n    }\n\nThe `.permutations_iter()` yields clones of the input vector for each\npermutation.\n\nIf a copyless traversal is needed, it can be constructed with\n`ElementSwaps`:\n\n    for (a, b) in ElementSwaps::new(3) {\n        // yields (2, 1), (1, 0), (2, 1) ...\n        v.swap(a, b);\n        // ..\n    }", "tree": {"sha": "e47a777ac41654cc0ba72c3c754e3f911e84ad3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e47a777ac41654cc0ba72c3c754e3f911e84ad3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de9546a3f8c3153983a7b6069a9f2aee28f2e296", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de9546a3f8c3153983a7b6069a9f2aee28f2e296", "html_url": "https://github.com/rust-lang/rust/commit/de9546a3f8c3153983a7b6069a9f2aee28f2e296", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de9546a3f8c3153983a7b6069a9f2aee28f2e296/comments", "author": null, "committer": null, "parents": [{"sha": "6212729315be2ac80785ffcecfe0a80c9955c4cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/6212729315be2ac80785ffcecfe0a80c9955c4cf", "html_url": "https://github.com/rust-lang/rust/commit/6212729315be2ac80785ffcecfe0a80c9955c4cf"}], "stats": {"total": 284, "additions": 165, "deletions": 119}, "files": [{"sha": "0a453d13714b3fa6a997a81a95c863e6c8e04ccf", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 165, "deletions": 119, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/de9546a3f8c3153983a7b6069a9f2aee28f2e296/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de9546a3f8c3153983a7b6069a9f2aee28f2e296/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=de9546a3f8c3153983a7b6069a9f2aee28f2e296", "patch": "@@ -408,56 +408,106 @@ pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (~[T], ~[U]) {\n     (ts, us)\n }\n \n-/**\n- * Iterate over all permutations of vector `v`.\n- *\n- * Permutations are produced in lexicographic order with respect to the order\n- * of elements in `v` (so if `v` is sorted then the permutations are\n- * lexicographically sorted).\n- *\n- * The total number of permutations produced is `v.len()!`.  If `v` contains\n- * repeated elements, then some permutations are repeated.\n- *\n- * See [Algorithms to generate\n- * permutations](http://en.wikipedia.org/wiki/Permutation).\n- *\n- *  # Arguments\n- *\n- *  * `values` - A vector of values from which the permutations are\n- *  chosen\n- *\n- *  * `fun` - The function to iterate over the combinations\n- */\n-pub fn each_permutation<T:Clone>(values: &[T], fun: &fn(perm : &[T]) -> bool) -> bool {\n-    let length = values.len();\n-    let mut permutation = vec::from_fn(length, |i| values[i].clone());\n-    if length <= 1 {\n-        fun(permutation);\n-        return true;\n-    }\n-    let mut indices = vec::from_fn(length, |i| i);\n-    loop {\n-        if !fun(permutation) { return true; }\n-        // find largest k such that indices[k] < indices[k+1]\n-        // if no such k exists, all permutations have been generated\n-        let mut k = length - 2;\n-        while k > 0 && indices[k] >= indices[k+1] {\n-            k -= 1;\n-        }\n-        if k == 0 && indices[0] > indices[1] { return true; }\n-        // find largest l such that indices[k] < indices[l]\n-        // k+1 is guaranteed to be such\n-        let mut l = length - 1;\n-        while indices[k] >= indices[l] {\n-            l -= 1;\n-        }\n-        // swap indices[k] and indices[l]; sort indices[k+1..]\n-        // (they're just reversed)\n-        indices.swap(k, l);\n-        indices.mut_slice(k+1, length).reverse();\n-        // fixup permutation based on indices\n-        for i in range(k, length) {\n-            permutation[i] = values[indices[i]].clone();\n+/// An Iterator that yields the element swaps needed to produce\n+/// a sequence of all possible permutations for an indexed sequence of\n+/// elements. Each permutation is only a single swap apart.\n+///\n+/// The Steinhaus\u2013Johnson\u2013Trotter algorithm is used.\n+///\n+/// Generates even and odd permutations alternatingly.\n+///\n+/// The last generated swap is always (0, 1), and it returns the\n+/// sequence to its initial order.\n+pub struct ElementSwaps {\n+    priv sdir: ~[SizeDirection],\n+    /// If true, emit the last swap that returns the sequence to initial state\n+    priv emit_reset: bool,\n+}\n+\n+impl ElementSwaps {\n+    /// Create an `ElementSwaps` iterator for a sequence of `length` elements\n+    pub fn new(length: uint) -> ElementSwaps {\n+        // Initialize `sdir` with a direction that position should move in\n+        // (all negative at the beginning) and the `size` of the\n+        // element (equal to the original index).\n+        ElementSwaps{\n+            emit_reset: true,\n+            sdir: range(0, length)\n+                    .map(|i| SizeDirection{ size: i, dir: Neg })\n+                    .to_owned_vec()\n+        }\n+    }\n+}\n+\n+enum Direction { Pos, Neg }\n+\n+/// An Index and Direction together\n+struct SizeDirection {\n+    size: uint,\n+    dir: Direction,\n+}\n+\n+impl Iterator<(uint, uint)> for ElementSwaps {\n+    #[inline]\n+    fn next(&mut self) -> Option<(uint, uint)> {\n+        fn new_pos(i: uint, s: Direction) -> uint {\n+            i + match s { Pos => 1, Neg => -1 }\n+        }\n+\n+        // Find the index of the largest mobile element:\n+        // The direction should point into the vector, and the\n+        // swap should be with a smaller `size` element.\n+        let max = self.sdir.iter().map(|&x| x).enumerate()\n+                           .filter(|&(i, sd)|\n+                                new_pos(i, sd.dir) < self.sdir.len() &&\n+                                self.sdir[new_pos(i, sd.dir)].size < sd.size)\n+                           .max_by(|&(_, sd)| sd.size);\n+        match max {\n+            Some((i, sd)) => {\n+                let j = new_pos(i, sd.dir);\n+                self.sdir.swap(i, j);\n+\n+                // Swap the direction of each larger SizeDirection\n+                for x in self.sdir.mut_iter() {\n+                    if x.size > sd.size {\n+                        x.dir = match x.dir { Pos => Neg, Neg => Pos };\n+                    }\n+                }\n+                Some((i, j))\n+            },\n+            None => if self.emit_reset && self.sdir.len() > 1 {\n+                self.emit_reset = false;\n+                Some((0, 1))\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+/// An Iterator that uses `ElementSwaps` to iterate through\n+/// all possible permutations of a vector.\n+///\n+/// The first iteration yields a clone of the vector as it is,\n+/// then each successive element is the vector with one\n+/// swap applied.\n+///\n+/// Generates even and odd permutations alternatingly.\n+pub struct Permutations<T> {\n+    priv swaps: ElementSwaps,\n+    priv v: ~[T],\n+}\n+\n+impl<T: Clone> Iterator<~[T]> for Permutations<T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<~[T]> {\n+        match self.swaps.next() {\n+            None => None,\n+            Some((a, b)) => {\n+                let elt = self.v.clone();\n+                self.v.swap(a, b);\n+                Some(elt)\n+            }\n         }\n     }\n }\n@@ -1141,6 +1191,7 @@ impl<'self, T: TotalOrd> ImmutableTotalOrdVector<T> for &'self [T] {\n pub trait ImmutableCopyableVector<T> {\n     fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n     unsafe fn unsafe_get(&self, elem: uint) -> T;\n+    fn permutations_iter(self) -> Permutations<T>;\n }\n \n /// Extension methods for vectors\n@@ -1170,6 +1221,16 @@ impl<'self,T:Clone> ImmutableCopyableVector<T> for &'self [T] {\n     unsafe fn unsafe_get(&self, index: uint) -> T {\n         (*self.unsafe_ref(index)).clone()\n     }\n+\n+    /// Create an iterator that yields every possible permutation of the\n+    /// vector in succession.\n+    fn permutations_iter(self) -> Permutations<T> {\n+        Permutations{\n+            swaps: ElementSwaps::new(self.len()),\n+            v: self.to_owned(),\n+        }\n+    }\n+\n }\n \n #[allow(missing_doc)]\n@@ -2847,28 +2908,6 @@ mod tests {\n         assert_eq!(v, ~[1, 3, 5]);\n     }\n \n-    #[test]\n-    fn test_each_permutation() {\n-        let mut results: ~[~[int]];\n-\n-        results = ~[];\n-        do each_permutation([]) |v| { results.push(v.to_owned()); true };\n-        assert_eq!(results, ~[~[]]);\n-\n-        results = ~[];\n-        do each_permutation([7]) |v| { results.push(v.to_owned()); true };\n-        assert_eq!(results, ~[~[7]]);\n-\n-        results = ~[];\n-        do each_permutation([1,1]) |v| { results.push(v.to_owned()); true };\n-        assert_eq!(results, ~[~[1,1],~[1,1]]);\n-\n-        results = ~[];\n-        do each_permutation([5,2,0]) |v| { results.push(v.to_owned()); true };\n-        assert!(results ==\n-            ~[~[5,2,0],~[5,0,2],~[2,5,0],~[2,0,5],~[0,5,2],~[0,2,5]]);\n-    }\n-\n     #[test]\n     fn test_zip_unzip() {\n         let z1 = ~[(1, 4), (2, 5), (3, 6)];\n@@ -2880,6 +2919,58 @@ mod tests {\n         assert_eq!((3, 6), (left[2], right[2]));\n     }\n \n+    #[test]\n+    fn test_element_swaps() {\n+        let mut v = [1, 2, 3];\n+        for (i, (a, b)) in ElementSwaps::new(v.len()).enumerate() {\n+            v.swap(a, b);\n+            match i {\n+                0 => assert_eq!(v, [1, 3, 2]),\n+                1 => assert_eq!(v, [3, 1, 2]),\n+                2 => assert_eq!(v, [3, 2, 1]),\n+                3 => assert_eq!(v, [2, 3, 1]),\n+                4 => assert_eq!(v, [2, 1, 3]),\n+                5 => assert_eq!(v, [1, 2, 3]),\n+                _ => fail!(),\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_permutations() {\n+        use hashmap;\n+        {\n+            let v: [int, ..0] = [];\n+            let mut it = v.permutations_iter();\n+            assert_eq!(it.next(), None);\n+        }\n+        {\n+            let v = [~\"Hello\"];\n+            let mut it = v.permutations_iter();\n+            assert_eq!(it.next(), None);\n+        }\n+        {\n+            let v = [1, 2, 3];\n+            let mut it = v.permutations_iter();\n+            assert_eq!(it.next(), Some(~[1,2,3]));\n+            assert_eq!(it.next(), Some(~[1,3,2]));\n+            assert_eq!(it.next(), Some(~[3,1,2]));\n+            assert_eq!(it.next(), Some(~[3,2,1]));\n+            assert_eq!(it.next(), Some(~[2,3,1]));\n+            assert_eq!(it.next(), Some(~[2,1,3]));\n+            assert_eq!(it.next(), None);\n+        }\n+        {\n+            // check that we have N! unique permutations\n+            let mut set = hashmap::HashSet::new();\n+            let v = ['A', 'B', 'C', 'D', 'E', 'F'];\n+            for perm in v.permutations_iter() {\n+                set.insert(perm);\n+            }\n+            assert_eq!(set.len(), 2 * 3 * 4 * 5 * 6);\n+        }\n+    }\n+\n     #[test]\n     fn test_position_elem() {\n         assert!([].position_elem(&1).is_none());\n@@ -3175,13 +3266,12 @@ mod tests {\n     fn test_permute_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do each_permutation(v) |_elt| {\n+        for _ in v.permutations_iter() {\n             if i == 2 {\n                 fail!()\n             }\n             i += 1;\n-            true\n-        };\n+        }\n     }\n \n     #[test]\n@@ -3493,50 +3583,6 @@ mod tests {\n         assert_eq!(values, [1,4,3,2,5]);\n     }\n \n-    #[test]\n-    fn test_permutations0() {\n-        let values = [];\n-        let mut v : ~[~[int]] = ~[];\n-        do each_permutation(values) |p| {\n-            v.push(p.to_owned());\n-            true\n-        };\n-        assert_eq!(v, ~[~[]]);\n-    }\n-\n-    #[test]\n-    fn test_permutations1() {\n-        let values = [1];\n-        let mut v : ~[~[int]] = ~[];\n-        do each_permutation(values) |p| {\n-            v.push(p.to_owned());\n-            true\n-        };\n-        assert_eq!(v, ~[~[1]]);\n-    }\n-\n-    #[test]\n-    fn test_permutations2() {\n-        let values = [1,2];\n-        let mut v : ~[~[int]] = ~[];\n-        do each_permutation(values) |p| {\n-            v.push(p.to_owned());\n-            true\n-        };\n-        assert_eq!(v, ~[~[1,2],~[2,1]]);\n-    }\n-\n-    #[test]\n-    fn test_permutations3() {\n-        let values = [1,2,3];\n-        let mut v : ~[~[int]] = ~[];\n-        do each_permutation(values) |p| {\n-            v.push(p.to_owned());\n-            true\n-        };\n-        assert_eq!(v, ~[~[1,2,3],~[1,3,2],~[2,1,3],~[2,3,1],~[3,1,2],~[3,2,1]]);\n-    }\n-\n     #[test]\n     fn test_vec_zero() {\n         use num::Zero;"}]}