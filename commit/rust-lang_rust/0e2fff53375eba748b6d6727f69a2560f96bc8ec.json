{"sha": "0e2fff53375eba748b6d6727f69a2560f96bc8ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlMmZmZjUzMzc1ZWJhNzQ4YjZkNjcyN2Y2OWEyNTYwZjk2YmM4ZWM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-07T02:00:00Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-07T19:53:17Z"}, "message": "rustc: Change lots of AST nodes to use interior vectors", "tree": {"sha": "0c7e27b7d5cf9fe41a1fc00cdbcbf87baf71368f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c7e27b7d5cf9fe41a1fc00cdbcbf87baf71368f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e2fff53375eba748b6d6727f69a2560f96bc8ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e2fff53375eba748b6d6727f69a2560f96bc8ec", "html_url": "https://github.com/rust-lang/rust/commit/0e2fff53375eba748b6d6727f69a2560f96bc8ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e2fff53375eba748b6d6727f69a2560f96bc8ec/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbcbaa6601a56c543f9200ce3bc047c366eff3ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbcbaa6601a56c543f9200ce3bc047c366eff3ed", "html_url": "https://github.com/rust-lang/rust/commit/bbcbaa6601a56c543f9200ce3bc047c366eff3ed"}], "stats": {"total": 773, "additions": 400, "deletions": 373}, "files": [{"sha": "8c4118137afd192742f86de35c31c40e6c0a5e4f", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -82,8 +82,8 @@ fn filter_stmt(&ast::crate_cfg cfg,\n fn fold_block(&ast::crate_cfg cfg, &ast::block_ b,\n               fold::ast_fold fld) -> ast::block_  {\n     auto filter = bind filter_stmt(cfg, _);\n-    auto filtered_stmts = vec::filter_map(filter, b.stmts);\n-    ret rec(stmts=vec::map(fld.fold_stmt, filtered_stmts),\n+    auto filtered_stmts = ivec::filter_map(filter, b.stmts);\n+    ret rec(stmts=ivec::map(fld.fold_stmt, filtered_stmts),\n             expr=option::map(fld.fold_expr, b.expr),\n             id=b.id);\n }"}, {"sha": "1f910575e1f196b11e4d44bd0a513f86fa1bb0a9", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -71,14 +71,14 @@ fn mk_main(&test_ctxt cx) -> @ast::item {\n     auto ret_ty = @rec(node=ast::ty_nil,\n                        span=rec(lo=0u, hi=0u));\n \n-    let ast::fn_decl decl = rec(inputs = [],\n+    let ast::fn_decl decl = rec(inputs = ~[],\n                                 output = ret_ty,\n                                 purity = ast::impure_fn,\n                                 cf = ast::return,\n                                 constraints = ~[]);\n     auto proto = ast::proto_fn;\n \n-    let ast::block_ body_ = rec(stmts = [],\n+    let ast::block_ body_ = rec(stmts = ~[],\n                                  expr = option::none,\n                                  id = cx.next_node_id());\n     auto body = rec(node = body_, span = rec(lo=0u, hi=0u));\n@@ -87,7 +87,7 @@ fn mk_main(&test_ctxt cx) -> @ast::item {\n                    proto = proto,\n                    body = body);\n \n-    auto item_ = ast::item_fn(fn_, []);\n+    auto item_ = ast::item_fn(fn_, ~[]);\n     let ast::item item = rec(ident = \"main\",\n                              attrs = ~[],\n                              id = cx.next_node_id(),"}, {"sha": "435fa1a0a8f669f1a086be428b83dbcd3446721a", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -1,5 +1,6 @@\n // Metadata encoding\n \n+import std::ivec;\n import std::str;\n import std::vec;\n import std::uint;\n@@ -33,7 +34,7 @@ fn encode_def_id(&ebml::writer ebml_w, &def_id id) {\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_tag_variant_paths(&ebml::writer ebml_w, &vec[variant] variants,\n+fn encode_tag_variant_paths(&ebml::writer ebml_w, &variant[] variants,\n                             &vec[str] path,\n                             &mutable vec[tup(str, uint)] index) {\n     for (variant variant in variants) {\n@@ -164,9 +165,9 @@ fn encode_kind(&ebml::writer ebml_w, u8 c) {\n \n fn def_to_str(&def_id did) -> str { ret #fmt(\"%d:%d\", did._0, did._1); }\n \n-fn encode_type_param_count(&ebml::writer ebml_w, &vec[ty_param] tps) {\n+fn encode_type_param_count(&ebml::writer ebml_w, &ty_param[] tps) {\n     ebml::start_tag(ebml_w, tag_items_data_item_ty_param_count);\n-    ebml::write_vint(ebml_w.writer, vec::len[ty_param](tps));\n+    ebml::write_vint(ebml_w.writer, ivec::len[ty_param](tps));\n     ebml::end_tag(ebml_w);\n }\n \n@@ -207,9 +208,9 @@ fn encode_tag_id(&ebml::writer ebml_w, &def_id id) {\n }\n \n fn encode_tag_variant_info(&@crate_ctxt cx, &ebml::writer ebml_w,\n-                           node_id id, &vec[variant] variants,\n+                           node_id id, &variant[] variants,\n                            &mutable vec[tup(int, uint)] index,\n-                           &vec[ty_param] ty_params) {\n+                           &ty_param[] ty_params) {\n     for (variant variant in variants) {\n         index += [tup(variant.node.id, ebml_w.writer.tell())];\n         ebml::start_tag(ebml_w, tag_items_data_item);"}, {"sha": "eeccfd401b6d9e2aa1e3abb5001c807fe8974aff", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -53,7 +53,7 @@ fn check_crate(@ty::ctxt tcx, &@ast::crate crate) {\n     tcx.sess.abort_if_errors();\n }\n \n-fn visit_fn(@ctx cx, &ast::_fn f, &vec[ast::ty_param] tp, &span sp,\n+fn visit_fn(@ctx cx, &ast::_fn f, &ast::ty_param[] tp, &span sp,\n             &fn_ident name, ast::node_id id, &scope sc, &vt[scope] v) {\n     visit::visit_fn_decl(f.decl, sc, v);\n     for (ast::arg arg_ in f.decl.inputs) {\n@@ -132,7 +132,7 @@ fn visit_expr(@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n     if (!handled) { visit::visit_expr(ex, sc, v); }\n }\n \n-fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n+fn check_call(&ctx cx, &@ast::expr f, &(@ast::expr)[] args, &scope sc) ->\n    rec(vec[node_id] root_vars, vec[ty::t] unsafe_ts) {\n     auto fty = ty::expr_ty(*cx.tcx, f);\n     auto arg_ts = fty_args(cx, fty);\n@@ -261,7 +261,7 @@ fn check_tail_call(&ctx cx, &@ast::expr call) {\n     }\n }\n \n-fn check_alt(&ctx cx, &@ast::expr input, &vec[ast::arm] arms, &scope sc,\n+fn check_alt(&ctx cx, &@ast::expr input, &ast::arm[] arms, &scope sc,\n              &vt[scope] v) {\n     visit::visit_expr(input, sc, v);\n     auto root = expr_root(cx, input, true);"}, {"sha": "97ab74e1e1fe7df2a819eea44bac44b3646e34f5", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -47,7 +47,7 @@ export crate_map;\n tag scope {\n     scope_crate(@ast::crate);\n     scope_item(@ast::item);\n-    scope_fn(ast::fn_decl, vec[ast::ty_param]);\n+    scope_fn(ast::fn_decl, ast::ty_param[]);\n     scope_native_item(@ast::native_item);\n     scope_loop(@ast::local); // there's only 1 decl per loop.\n     scope_block(ast::block);\n@@ -346,7 +346,7 @@ fn visit_native_item_with_scope(&@ast::native_item ni, &scopes sc,\n     visit::visit_native_item(ni, cons(scope_native_item(ni), @sc), v);\n }\n \n-fn visit_fn_with_scope(&@env e, &ast::_fn f, &vec[ast::ty_param] tp, &span sp,\n+fn visit_fn_with_scope(&@env e, &ast::_fn f, &ast::ty_param[] tp, &span sp,\n                        &fn_ident name, node_id id, &scopes sc,\n                        &vt[scopes] v) {\n     // here's where we need to set up the mapping\n@@ -376,7 +376,7 @@ fn visit_expr_with_scope(&@ast::expr x, &scopes sc, &vt[scopes] v) {\n             case (ast::expr_for_each(?d, _, _)) {\n                 cons[scope](scope_loop(d), @sc)\n             }\n-            case (ast::expr_fn(?f)) { cons(scope_fn(f.decl, []), @sc) }\n+            case (ast::expr_fn(?f)) { cons(scope_fn(f.decl, ~[]), @sc) }\n             case (_) { sc }\n         };\n     visit::visit_expr(x, new_sc, v);\n@@ -638,8 +638,7 @@ fn lookup_in_scope(&env e, scopes sc, &span sp, &ident name, namespace ns) ->\n             }\n             case (scope_native_item(?it)) {\n                 alt (it.node) {\n-                    case (ast::native_item_fn(_, ?decl, ?ty_params))\n-                         {\n+                    case (ast::native_item_fn(_, ?decl, ?ty_params)) {\n                         ret lookup_in_fn(name, decl, ty_params, ns);\n                     }\n                 }\n@@ -690,7 +689,7 @@ fn lookup_in_scope(&env e, scopes sc, &span sp, &ident name, namespace ns) ->\n \n }\n \n-fn lookup_in_ty_params(&ident name, &vec[ast::ty_param] ty_params) ->\n+fn lookup_in_ty_params(&ident name, &ast::ty_param[] ty_params) ->\n    option::t[def] {\n     auto i = 0u;\n     for (ast::ty_param tp in ty_params) {\n@@ -720,7 +719,7 @@ fn lookup_in_pat(&ident name, &ast::pat pat) -> option::t[def] {\n }\n \n fn lookup_in_fn(&ident name, &ast::fn_decl decl,\n-                &vec[ast::ty_param] ty_params,\n+                &ast::ty_param[] ty_params,\n                 namespace ns) -> option::t[def] {\n     alt (ns) {\n         case (ns_value) {\n@@ -736,7 +735,7 @@ fn lookup_in_fn(&ident name, &ast::fn_decl decl,\n     }\n }\n \n-fn lookup_in_obj(&ident name, &ast::_obj ob, &vec[ast::ty_param] ty_params,\n+fn lookup_in_obj(&ident name, &ast::_obj ob, &ast::ty_param[] ty_params,\n                  namespace ns) -> option::t[def] {\n     alt (ns) {\n         case (ns_value) {\n@@ -1229,18 +1228,22 @@ fn check_item(@env e, &@ast::item i, &() x, &vt[()] v) {\n     alt (i.node) {\n         case (ast::item_fn(?f, ?ty_params)) {\n             check_fn(*e, i.span, f);\n-            ensure_unique(*e, i.span, ty_params, ident_id, \"type parameter\");\n+            ensure_unique_ivec(*e, i.span, ty_params, ident_id,\n+                               \"type parameter\");\n         }\n         case (ast::item_obj(?ob, ?ty_params, _)) {\n             fn field_name(&ast::obj_field field) -> ident { ret field.ident; }\n-            ensure_unique(*e, i.span, ob.fields, field_name, \"object field\");\n+            ensure_unique_ivec(*e, i.span, ob.fields, field_name,\n+                               \"object field\");\n             for (@ast::method m in ob.methods) {\n                 check_fn(*e, m.span, m.node.meth);\n             }\n-            ensure_unique(*e, i.span, ty_params, ident_id, \"type parameter\");\n+            ensure_unique_ivec(*e, i.span, ty_params, ident_id,\n+                               \"type parameter\");\n         }\n         case (ast::item_tag(_, ?ty_params)) {\n-            ensure_unique(*e, i.span, ty_params, ident_id, \"type parameter\");\n+            ensure_unique_ivec(*e, i.span, ty_params, ident_id,\n+                               \"type parameter\");\n         }\n         case (_) { }\n     }\n@@ -1315,7 +1318,7 @@ fn check_block(@env e, &ast::block b, &() x, &vt[()] v) {\n \n fn check_fn(&env e, &span sp, &ast::_fn f) {\n     fn arg_name(&ast::arg a) -> ident { ret a.ident; }\n-    ensure_unique(e, sp, f.decl.inputs, arg_name, \"argument\");\n+    ensure_unique_ivec(e, sp, f.decl.inputs, arg_name, \"argument\");\n }\n \n type checker = @rec(mutable vec[ident] seen, str kind, session sess);\n@@ -1341,6 +1344,14 @@ fn ensure_unique[T](&env e, &span sp, &vec[T] elts, fn(&T) -> ident  id,\n     auto ch = checker(e, kind);\n     for (T elt in elts) { add_name(ch, sp, id(elt)); }\n }\n+\n+// FIXME: Remove me.\n+fn ensure_unique_ivec[T](&env e, &span sp, &T[] elts, fn(&T) -> ident  id,\n+                         &str kind) {\n+    auto ch = checker(e, kind);\n+    for (T elt in elts) { add_name(ch, sp, id(elt)); }\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "8f7f26e16934e94fea0b360fcc8b104b0646369f", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 76, "deletions": 74, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -155,8 +155,8 @@ type crate_ctxt =\n type local_ctxt =\n     rec(vec[str] path,\n         vec[str] module_path,\n-        vec[ast::ty_param] obj_typarams,\n-        vec[ast::obj_field] obj_fields,\n+        ast::ty_param[] obj_typarams,\n+        ast::obj_field[] obj_fields,\n         @crate_ctxt ccx);\n \n \n@@ -4382,8 +4382,10 @@ fn trans_if(&@block_ctxt cx, &@ast::expr cond, &ast::block thn,\n \n fn trans_for(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n              &ast::block body) -> result {\n+    // FIXME: We bind to an alias here to avoid a segfault... this is\n+    // obviously a bug.\n     fn inner(&@block_ctxt cx, @ast::local local, ValueRef curr, ty::t t,\n-             ast::block body, @block_ctxt outer_next_cx) -> result {\n+             &ast::block body, @block_ctxt outer_next_cx) -> result {\n         auto next_cx = new_sub_block_ctxt(cx, \"next\");\n         auto scope_cx =\n             new_loop_scope_block_ctxt(cx, option::some[@block_ctxt](next_cx),\n@@ -4778,7 +4780,7 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n                     cx.build.ICmp(lib::llvm::LLVMIntEQ, lldiscrim,\n                                   C_int(variant_tag));\n                 cx.build.CondBr(lleq, matched_cx.llbb, next_cx.llbb);\n-                if (vec::len(subpats) > 0u) {\n+                if (std::ivec::len(subpats) > 0u) {\n                     llblobptr =\n                         matched_cx.build.GEP(lltagptr, [C_int(0), C_int(1)]);\n                 }\n@@ -4790,7 +4792,7 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n             auto tps_ivec = ~[];\n             for (ty::t tp in ty_params) { tps_ivec += ~[tp]; }\n \n-            if (vec::len(subpats) > 0u) {\n+            if (std::ivec::len(subpats) > 0u) {\n                 auto i = 0;\n                 for (@ast::pat subpat in subpats) {\n                     auto rslt =\n@@ -4834,9 +4836,11 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n             }\n         }\n         case (ast::pat_tag(_, ?subpats)) {\n-            if (vec::len[@ast::pat](subpats) == 0u) { ret rslt(cx, llval); }\n-            // Get the appropriate variant for this tag.\n+            if (std::ivec::len[@ast::pat](subpats) == 0u) {\n+                ret rslt(cx, llval);\n+            }\n \n+            // Get the appropriate variant for this tag.\n             auto vdef;\n             alt (cx.fcx.lcx.ccx.tcx.def_map.find(pat.id)) {\n                 case (some(?x)) { vdef = ast::variant_def_ids(x); }\n@@ -4874,7 +4878,7 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n     }\n }\n \n-fn trans_alt(&@block_ctxt cx, &@ast::expr expr, &vec[ast::arm] arms,\n+fn trans_alt(&@block_ctxt cx, &@ast::expr expr, &ast::arm[] arms,\n              ast::node_id id, &out_method output) -> result {\n     auto expr_res = trans_expr(cx, expr);\n     auto this_cx = expr_res.bcx;\n@@ -5308,7 +5312,7 @@ fn trans_cast(&@block_ctxt cx, &@ast::expr e, ast::node_id id) -> result {\n }\n \n fn trans_bind_thunk(&@local_ctxt cx, &span sp, &ty::t incoming_fty,\n-                    &ty::t outgoing_fty, &vec[option::t[@ast::expr]] args,\n+                    &ty::t outgoing_fty, &(option::t[@ast::expr])[] args,\n                     &ty::t closure_ty, &vec[ty::t] bound_tys,\n                     uint ty_param_count) -> ValueRef {\n \n@@ -5474,7 +5478,7 @@ fn trans_bind_thunk(&@local_ctxt cx, &span sp, &ty::t incoming_fty,\n }\n \n fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n-              &vec[option::t[@ast::expr]] args, ast::node_id id) -> result {\n+              &(option::t[@ast::expr])[] args, ast::node_id id) -> result {\n     auto f_res = trans_lval(cx, f);\n     if (f_res.is_mem) {\n         cx.fcx.lcx.ccx.sess.unimpl(\"re-binding existing function\");\n@@ -5720,7 +5724,7 @@ fn trans_arg_expr(&@block_ctxt cx, &ty::arg arg, TypeRef lldestty0,\n //  - trans_args\n fn trans_args(&@block_ctxt cx, ValueRef llenv, &option::t[ValueRef] llobj,\n               &option::t[generic_info] gen, &option::t[ValueRef] lliterbody,\n-              &vec[@ast::expr] es, &ty::t fn_ty) ->\n+              &(@ast::expr)[] es, &ty::t fn_ty) ->\n    tup(@block_ctxt, vec[ValueRef], ValueRef) {\n     let ty::arg[] args = ty::ty_fn_args(cx.fcx.lcx.ccx.tcx, fn_ty);\n     let vec[ValueRef] llargs = [];\n@@ -5812,7 +5816,7 @@ fn trans_args(&@block_ctxt cx, ValueRef llenv, &option::t[ValueRef] llobj,\n }\n \n fn trans_call(&@block_ctxt cx, &@ast::expr f, &option::t[ValueRef] lliterbody,\n-              &vec[@ast::expr] args, ast::node_id id) -> result {\n+              &(@ast::expr)[] args, ast::node_id id) -> result {\n     // NB: 'f' isn't necessarily a function; it might be an entire self-call\n     // expression because of the hack that allows us to process self-calls\n     // with trans_call.\n@@ -5896,8 +5900,7 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f, &option::t[ValueRef] lliterbody,\n     ret rslt(bcx, retval);\n }\n \n-fn trans_tup(&@block_ctxt cx, &vec[ast::elt] elts, ast::node_id id)\n-    -> result {\n+fn trans_tup(&@block_ctxt cx, &ast::elt[] elts, ast::node_id id) -> result {\n     auto bcx = cx;\n     auto t = node_id_type(bcx.fcx.lcx.ccx, id);\n     auto tup_res = alloc_ty(bcx, t);\n@@ -5916,7 +5919,7 @@ fn trans_tup(&@block_ctxt cx, &vec[ast::elt] elts, ast::node_id id)\n     ret rslt(bcx, tup_val);\n }\n \n-fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args, ast::node_id id) ->\n+fn trans_vec(&@block_ctxt cx, &(@ast::expr)[] args, ast::node_id id) ->\n    result {\n     auto t = node_id_type(cx.fcx.lcx.ccx, id);\n     auto unit_ty = t;\n@@ -5928,7 +5931,7 @@ fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args, ast::node_id id) ->\n     auto unit_sz = size_of(bcx, unit_ty);\n     bcx = unit_sz.bcx;\n     auto data_sz =\n-        bcx.build.Mul(C_int(vec::len[@ast::expr](args) as int), unit_sz.val);\n+        bcx.build.Mul(C_uint(std::ivec::len[@ast::expr](args)), unit_sz.val);\n     // FIXME: pass tydesc properly.\n \n     auto vec_val =\n@@ -5941,7 +5944,8 @@ fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args, ast::node_id id) ->\n     auto body = bcx.build.GEP(vec_val, [C_int(0), C_int(abi::vec_elt_data)]);\n     auto pseudo_tup_ty =\n         ty::mk_imm_tup(cx.fcx.lcx.ccx.tcx,\n-                       std::ivec::init_elt[ty::t](unit_ty, vec::len(args)));\n+                       std::ivec::init_elt[ty::t](unit_ty,\n+                                                  std::ivec::len(args)));\n     let int i = 0;\n     for (@ast::expr e in args) {\n         auto src = trans_lval(bcx, e);\n@@ -5975,7 +5979,7 @@ fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args, ast::node_id id) ->\n \n \n // TODO: Move me to ivec::\n-fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, ast::node_id id) ->\n+fn trans_ivec(@block_ctxt bcx, &(@ast::expr)[] args, ast::node_id id) ->\n         result {\n     auto typ = node_id_type(bcx.fcx.lcx.ccx, id);\n     auto unit_ty;\n@@ -5993,11 +5997,12 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, ast::node_id id) ->\n \n     add_clean_temp(bcx, llvecptr, typ);\n \n-    auto lllen = bcx.build.Mul(C_uint(vec::len(args)), unit_sz);\n+    auto lllen = bcx.build.Mul(C_uint(std::ivec::len(args)), unit_sz);\n     // Allocate the vector pieces and store length and allocated length.\n \n     auto llfirsteltptr;\n-    if (vec::len(args) > 0u && vec::len(args) <= abi::ivec_default_length) {\n+    if (std::ivec::len(args) > 0u &&\n+            std::ivec::len(args) <= abi::ivec_default_length) {\n         // Interior case.\n \n         bcx.build.Store(lllen,\n@@ -6022,7 +6027,7 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, ast::node_id id) ->\n         auto llstubptr = bcx.build.PointerCast(llvecptr, T_ptr(llstubty));\n         bcx.build.Store(C_int(0), bcx.build.InBoundsGEP(llstubptr, stub_z));\n         auto llheapty = T_ivec_heap_part(llunitty);\n-        if (vec::len(args) == 0u) {\n+        if (std::ivec::len(args) == 0u) {\n             // Null heap pointer indicates a zero-length vector.\n \n             bcx.build.Store(llalen, bcx.build.InBoundsGEP(llstubptr, stub_a));\n@@ -6067,7 +6072,7 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, ast::node_id id) ->\n     ret rslt(bcx, llvecptr);\n }\n \n-fn trans_rec(&@block_ctxt cx, &vec[ast::field] fields,\n+fn trans_rec(&@block_ctxt cx, &ast::field[] fields,\n              &option::t[@ast::expr] base, ast::node_id id) -> result {\n     auto bcx = cx;\n     auto t = node_id_type(bcx.fcx.lcx.ccx, id);\n@@ -6172,7 +6177,7 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n             auto sub_cx = extend_path(cx.fcx.lcx, ccx.names.next(\"anon\"));\n             auto s = mangle_internal_name_by_path(ccx, sub_cx.path);\n             auto llfn = decl_internal_fastcall_fn(ccx.llmod, s, llfnty);\n-            trans_fn(sub_cx, e.span, f, llfn, none, [], e.id);\n+            trans_fn(sub_cx, e.span, f, llfn, none, ~[], e.id);\n             ret rslt(cx, create_fn_pair(ccx, s, llfnty, llfn, false));\n         }\n         case (ast::expr_block(?blk)) {\n@@ -6696,16 +6701,17 @@ fn trans_chan(&@block_ctxt cx, &@ast::expr e, ast::node_id id) -> result {\n }\n \n fn trans_spawn(&@block_ctxt cx, &ast::spawn_dom dom, &option::t[str] name,\n-               &@ast::expr func, &vec[@ast::expr] args, ast::node_id id) ->\n-   result {\n+               &@ast::expr func, &(@ast::expr)[] args, ast::node_id id)\n+        -> result {\n     auto bcx = cx;\n     // Make the task name\n \n     auto tname =\n         alt (name) {\n             case (none) {\n-                auto argss = vec::map(expr_to_str, args);\n-                #fmt(\"%s(%s)\", expr_to_str(func), str::connect(argss, \", \"))\n+                auto argss = std::ivec::map(expr_to_str, args);\n+                #fmt(\"%s(%s)\", expr_to_str(func),\n+                     str::connect_ivec(argss, \", \"))\n             }\n             case (some(?n)) { n }\n         };\n@@ -6979,21 +6985,21 @@ fn recv_val(&@block_ctxt cx, ValueRef to, &@ast::expr from, &ty::t unit_ty,\n // instead \"inlining\" the construction of the object and returning the object\n // itself.\n fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj, \n-                  &vec[ast::ty_param] ty_params, ast::node_id id) -> result {\n+                  &ast::ty_param[] ty_params, ast::node_id id) -> result {\n \n     // Right now, we're assuming that anon objs don't take ty params, even\n     // though the AST supports it.  It's nonsensical to write an expression\n     // like \"obj[T](){ ... with ... }\", since T is never instantiated;\n     // nevertheless, such an expression will parse.  Idea for the future:\n     // support typarams.\n \n-    assert (vec::len(ty_params) == 0u);\n+    assert (std::ivec::len(ty_params) == 0u);\n     auto ccx = bcx.fcx.lcx.ccx;\n \n     // Fields.\n     // FIXME (part of issue #538): Where do we fill in the field *values* from\n     // the outer object?\n-    let vec[ast::anon_obj_field] additional_fields = [];\n+    let ast::anon_obj_field[] additional_fields = ~[];\n     let vec[result] additional_field_vals = [];\n     let ty::t[] additional_field_tys = ~[];\n     alt (anon_obj.fields) {\n@@ -7021,8 +7027,8 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n         ret rec(mut=f.mut, ty=f.ty, ident=f.ident, id=f.id);\n     }\n     let ast::_obj wrapper_obj = rec(\n-        fields = vec::map(anon_obj_field_to_obj_field, \n-                          additional_fields),\n+        fields = std::ivec::map(anon_obj_field_to_obj_field, \n+                                additional_fields),\n         methods = anon_obj.methods,\n         dtor = none[@ast::method]);\n \n@@ -7079,8 +7085,7 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n     auto pair = \n         alloca(bcx, \n                T_struct([val_ty(vtbl),\n-                         T_obj_ptr(ccx.tn,\n-                                   vec::len[ast::ty_param](ty_params))]));\n+                         T_obj_ptr(ccx.tn, std::ivec::len(ty_params))]));\n \n     // Take care of cleanups.\n     auto t = node_id_type(ccx, id);\n@@ -7101,8 +7106,8 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n     // typarams, fields, and a pointer to our with_obj.\n     let TypeRef llbox_ty = T_opaque_obj_ptr(ccx.tn);\n \n-    if (vec::len[ast::ty_param](ty_params) == 0u &&\n-        vec::len[ast::anon_obj_field](additional_fields) == 0u &&\n+    if (std::ivec::len[ast::ty_param](ty_params) == 0u &&\n+        std::ivec::len[ast::anon_obj_field](additional_fields) == 0u &&\n         anon_obj.with_obj == none) {\n         // If the object we're translating has no fields or type parameters\n         // and no with_obj, there's not much to do.\n@@ -7544,12 +7549,10 @@ fn trans_block(&@block_ctxt cx, &ast::block b, &out_method output) -> result {\n \n fn new_local_ctxt(&@crate_ctxt ccx) -> @local_ctxt {\n     let vec[str] pth = [];\n-    let vec[ast::ty_param] obj_typarams = [];\n-    let vec[ast::obj_field] obj_fields = [];\n     ret @rec(path=pth,\n              module_path=[ccx.link_meta.name],\n-             obj_typarams=obj_typarams,\n-             obj_fields=obj_fields,\n+             obj_typarams=~[],\n+             obj_fields=~[],\n              ccx=ccx);\n }\n \n@@ -7621,8 +7624,8 @@ fn new_fn_ctxt(@local_ctxt cx, &span sp, ValueRef llfndecl) -> @fn_ctxt {\n // field of the fn_ctxt with\n fn create_llargs_for_fn_args(&@fn_ctxt cx, ast::proto proto,\n                              option::t[ty_self_pair] ty_self, ty::t ret_ty,\n-                             &vec[ast::arg] args,\n-                             &vec[ast::ty_param] ty_params) {\n+                             &ast::arg[] args,\n+                             &ast::ty_param[] ty_params) {\n     // Skip the implicit arguments 0, 1, and 2.  TODO: Pull out 3u and define\n     // it as a constant, since we're using it in several places in trans this\n     // way.\n@@ -7684,8 +7687,7 @@ fn copy_any_self_to_alloca(@fn_ctxt fcx, option::t[ty_self_pair] ty_self) {\n     }\n }\n \n-fn copy_args_to_allocas(@fn_ctxt fcx, vec[ast::arg] args,\n-                        &ty::arg[] arg_tys) {\n+fn copy_args_to_allocas(@fn_ctxt fcx, &ast::arg[] args, &ty::arg[] arg_tys) {\n     auto bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n     let uint arg_n = 0u;\n     for (ast::arg aarg in args) {\n@@ -7707,7 +7709,7 @@ fn copy_args_to_allocas(@fn_ctxt fcx, vec[ast::arg] args,\n     }\n }\n \n-fn add_cleanups_for_args(&@block_ctxt bcx, vec[ast::arg] args,\n+fn add_cleanups_for_args(&@block_ctxt bcx, &ast::arg[] args,\n                          &ty::arg[] arg_tys) {\n     let uint arg_n = 0u;\n     for (ast::arg aarg in args) {\n@@ -7745,7 +7747,7 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, val_self_pair llself) {\n     // its magic.\n \n     auto fields_tup_ty = ty::mk_imm_tup(fcx.lcx.ccx.tcx, field_tys);\n-    auto n_typarams = vec::len[ast::ty_param](bcx.fcx.lcx.obj_typarams);\n+    auto n_typarams = std::ivec::len[ast::ty_param](bcx.fcx.lcx.obj_typarams);\n     let TypeRef llobj_box_ty = T_obj_ptr(bcx.fcx.lcx.ccx.tn, n_typarams);\n     auto box_cell =\n         bcx.build.GEP(llself.v, [C_int(0), C_int(abi::obj_field_box)]);\n@@ -7801,7 +7803,7 @@ fn finish_fn(&@fn_ctxt fcx, BasicBlockRef lltop) {\n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n fn trans_fn(@local_ctxt cx, &span sp, &ast::_fn f, ValueRef llfndecl,\n-            option::t[ty_self_pair] ty_self, &vec[ast::ty_param] ty_params,\n+            option::t[ty_self_pair] ty_self, &ast::ty_param[] ty_params,\n             ast::node_id id) {\n     set_uwtable(llfndecl);\n \n@@ -7847,11 +7849,11 @@ fn trans_fn(@local_ctxt cx, &span sp, &ast::_fn f, ValueRef llfndecl,\n // process_fwding_mthd: Create the forwarding function that appears in a\n // vtable slot for method calls that \"fall through\" to an inner object.  A\n // helper function for create_vtbl.\n-fn process_fwding_mthd(@local_ctxt cx, &span sp, @ty::method m, \n+fn process_fwding_mthd(@local_ctxt cx, &span sp, @ty::method m,\n                        TypeRef llself_ty, ty::t self_ty,\n-                       &vec[ast::ty_param] ty_params,\n+                       &ast::ty_param[] ty_params,\n                        ty::t with_obj_ty,\n-                       ty::t[] additional_field_tys) -> ValueRef {\n+                       &ty::t[] additional_field_tys) -> ValueRef {\n \n     // NB: self_ty (and llself_ty) is the type of the outer object;\n     // with_obj_ty is the type of the inner object.\n@@ -7880,7 +7882,7 @@ fn process_fwding_mthd(@local_ctxt cx, &span sp, @ty::method m,\n         type_of_fn_full(\n             cx.ccx, sp, m.proto,\n             some[TypeRef](llself_ty), m.inputs, m.output,\n-            vec::len[ast::ty_param](ty_params));\n+            std::ivec::len[ast::ty_param](ty_params));\n     let ValueRef llforwarding_fn =\n         decl_internal_fastcall_fn(cx.ccx.llmod, s, llforwarding_fn_ty);\n \n@@ -7997,7 +7999,7 @@ fn process_fwding_mthd(@local_ctxt cx, &span sp, @ty::method m,\n                         some[TypeRef](llself_ty),\n                         m.inputs,\n                         m.output,\n-                        vec::len[ast::ty_param](ty_params));\n+                        std::ivec::len[ast::ty_param](ty_params));\n     llorig_mthd = bcx.build.PointerCast(llorig_mthd, \n                                         T_ptr(T_ptr(llorig_mthd_ty)));\n     llorig_mthd = bcx.build.Load(llorig_mthd);\n@@ -8032,7 +8034,7 @@ fn process_fwding_mthd(@local_ctxt cx, &span sp, @ty::method m,\n // process_normal_mthd: Create the contents of a normal vtable slot.  A helper\n // function for create_vtbl.\n fn process_normal_mthd(@local_ctxt cx, @ast::method m, TypeRef llself_ty, \n-                       ty::t self_ty, &vec[ast::ty_param] ty_params) \n+                       ty::t self_ty, &ast::ty_param[] ty_params) \n     -> ValueRef {\n \n     auto llfnty = T_nil();\n@@ -8042,7 +8044,7 @@ fn process_normal_mthd(@local_ctxt cx, @ast::method m, TypeRef llself_ty,\n                 type_of_fn_full(\n                     cx.ccx, m.span, proto, \n                     some[TypeRef](llself_ty), inputs, output,\n-                    vec::len[ast::ty_param](ty_params));\n+                    std::ivec::len[ast::ty_param](ty_params));\n         }\n     }\n     let @local_ctxt mcx =\n@@ -8066,9 +8068,9 @@ fn process_normal_mthd(@local_ctxt cx, @ast::method m, TypeRef llself_ty,\n // Create a vtable for an object being translated.  Returns a pointer into\n // read-only memory.\n fn create_vtbl(@local_ctxt cx, &span sp, TypeRef llself_ty, ty::t self_ty,\n-               &ast::_obj ob, &vec[ast::ty_param] ty_params,\n+               &ast::_obj ob, &ast::ty_param[] ty_params,\n                option::t[ty::t] with_obj_ty,\n-               ty::t[] additional_field_tys) -> ValueRef {\n+               &ty::t[] additional_field_tys) -> ValueRef {\n \n     // Used only inside create_vtbl to distinguish different kinds of slots\n     // we'll have to create.\n@@ -8232,7 +8234,7 @@ fn create_vtbl(@local_ctxt cx, &span sp, TypeRef llself_ty, ty::t self_ty,\n }\n \n fn trans_dtor(@local_ctxt cx, TypeRef llself_ty, ty::t self_ty,\n-              &vec[ast::ty_param] ty_params, &@ast::method dtor) -> ValueRef {\n+              &ast::ty_param[] ty_params, &@ast::method dtor) -> ValueRef {\n     auto llfnty = T_dtor(cx.ccx, dtor.span, llself_ty);\n     let str s = mangle_internal_name_by_path(cx.ccx, cx.path + [\"drop\"]);\n     let ValueRef llfn = decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n@@ -8247,7 +8249,7 @@ fn trans_dtor(@local_ctxt cx, TypeRef llself_ty, ty::t self_ty,\n // trans_obj: creates an LLVM function that is the object constructor for the\n // object being translated.\n fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n-             &vec[ast::ty_param] ty_params) {\n+             &ast::ty_param[] ty_params) {\n     // To make a function, we have to create a function context and, inside\n     // that, a number of block contexts for which code is generated.\n \n@@ -8265,10 +8267,10 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n     // The fields of our object will become the arguments to the function\n     // we're creating.\n \n-    let vec[ast::arg] fn_args = [];\n+    let ast::arg[] fn_args = ~[];\n     for (ast::obj_field f in ob.fields) {\n         fn_args +=\n-            [rec(mode=ast::alias(false), ty=f.ty, ident=f.ident, id=f.id)];\n+            ~[rec(mode=ast::alias(false), ty=f.ty, ident=f.ident, id=f.id)];\n     }\n     auto fcx = new_fn_ctxt(cx, sp, llctor_decl);\n \n@@ -8325,7 +8327,7 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n     // FIXME: we should probably also allocate a box for empty objs that have\n     // a dtor, since otherwise they are never dropped, and the dtor never\n     // runs.\n-    if (vec::len[ast::ty_param](ty_params) == 0u &&\n+    if (std::ivec::len[ast::ty_param](ty_params) == 0u &&\n             std::ivec::len[ty::arg](arg_tys) == 0u) {\n         // If the object we're translating has no fields or type parameters,\n         // there's not much to do.\n@@ -8449,7 +8451,7 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n }\n \n fn trans_res_ctor(@local_ctxt cx, &span sp, &ast::_fn dtor,\n-                  ast::node_id ctor_id, &vec[ast::ty_param] ty_params) {\n+                  ast::node_id ctor_id, &ast::ty_param[] ty_params) {\n     // Create a function for the constructor\n     auto llctor_decl;\n     alt (cx.ccx.item_ids.find(ctor_id)) {\n@@ -8493,21 +8495,21 @@ fn trans_res_ctor(@local_ctxt cx, &span sp, &ast::_fn dtor,\n \n fn trans_tag_variant(@local_ctxt cx, ast::node_id tag_id,\n                      &ast::variant variant, int index, bool is_degen,\n-                     &vec[ast::ty_param] ty_params) {\n+                     &ast::ty_param[] ty_params) {\n     if (vec::len[ast::variant_arg](variant.node.args) == 0u) {\n         ret; // nullary constructors are just constants\n \n     }\n     // Translate variant arguments to function arguments.\n \n-    let vec[ast::arg] fn_args = [];\n+    let ast::arg[] fn_args = ~[];\n     auto i = 0u;\n     for (ast::variant_arg varg in variant.node.args) {\n         fn_args +=\n-            [rec(mode=ast::alias(false),\n-                 ty=varg.ty,\n-                 ident=\"arg\" + uint::to_str(i, 10u),\n-                 id=varg.id)];\n+            ~[rec(mode=ast::alias(false),\n+                  ty=varg.ty,\n+                  ident=\"arg\" + uint::to_str(i, 10u),\n+                  id=varg.id)];\n     }\n     assert (cx.ccx.item_ids.contains_key(variant.node.id));\n     let ValueRef llfndecl;\n@@ -8650,7 +8652,7 @@ fn trans_item(@local_ctxt cx, &ast::item item) {\n         }\n         case (ast::item_tag(?variants, ?tps)) {\n             auto sub_cx = extend_path(cx, item.ident);\n-            auto degen = vec::len(variants) == 1u;\n+            auto degen = std::ivec::len(variants) == 1u;\n             auto i = 0;\n             for (ast::variant variant in variants) {\n                 trans_tag_variant(sub_cx, item.id, variant, i, degen, tps);\n@@ -8681,20 +8683,20 @@ fn get_pair_fn_ty(TypeRef llpairty) -> TypeRef {\n }\n \n fn decl_fn_and_pair(&@crate_ctxt ccx, &span sp, &vec[str] path, str flav,\n-                    vec[ast::ty_param] ty_params, ast::node_id node_id) {\n+                    &ast::ty_param[] ty_params, ast::node_id node_id) {\n     decl_fn_and_pair_full(ccx, sp, path, flav, ty_params, node_id,\n                           node_id_type(ccx, node_id));\n }\n \n fn decl_fn_and_pair_full(&@crate_ctxt ccx, &span sp, &vec[str] path, str flav,\n-                         vec[ast::ty_param] ty_params, ast::node_id node_id,\n+                         &ast::ty_param[] ty_params, ast::node_id node_id,\n                          ty::t node_type) {\n     auto llfty;\n     alt (ty::struct(ccx.tcx, node_type)) {\n         case (ty::ty_fn(?proto, ?inputs, ?output, _, _)) {\n             llfty =\n                 type_of_fn(ccx, sp, proto, inputs, output,\n-                           vec::len[ast::ty_param](ty_params));\n+                           std::ivec::len[ast::ty_param](ty_params));\n         }\n         case (_) {\n             ccx.sess.bug(\"decl_fn_and_pair(): fn item doesn't have fn type!\");\n@@ -8764,7 +8766,7 @@ fn native_fn_ty_param_count(&@crate_ctxt cx, ast::node_id id) -> uint {\n                             \"actually a fn\");\n         }\n         case (ast::native_item_fn(_, _, ?tps)) {\n-            count = vec::len[ast::ty_param](tps);\n+            count = std::ivec::len[ast::ty_param](tps);\n         }\n     }\n     ret count;\n@@ -9035,7 +9037,7 @@ fn trans_constant(@crate_ctxt ccx, &@ast::item it, &vec[str] pt,\n     alt (it.node) {\n         case (ast::item_tag(?variants, _)) {\n             auto i = 0u;\n-            auto n_variants = vec::len[ast::variant](variants);\n+            auto n_variants = std::ivec::len[ast::variant](variants);\n             while (i < n_variants) {\n                 auto variant = variants.(i);\n                 auto p = new_pt + [it.ident, variant.node.name, \"discrim\"];"}, {"sha": "e82414959ac835d904dd396f5ada41371ab32bd2", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -52,7 +52,7 @@ fn collect_ids_local(&@local l, @mutable node_id[] rs) {\n     *rs += ~[l.node.id];\n }\n \n-fn node_ids_in_fn(&_fn f, &vec[ty_param] tps, &span sp, &fn_ident i,\n+fn node_ids_in_fn(&_fn f, &ty_param[] tps, &span sp, &fn_ident i,\n                   node_id id, @mutable node_id[] rs) {\n     auto collect_ids = walk::default_visitor();\n     collect_ids =\n@@ -70,15 +70,15 @@ fn init_vecs(&crate_ctxt ccx, &node_id[] node_ids, uint len) {\n     }\n }\n \n-fn visit_fn(&crate_ctxt ccx, uint num_constraints, &_fn f, &vec[ty_param] tps,\n+fn visit_fn(&crate_ctxt ccx, uint num_constraints, &_fn f, &ty_param[] tps,\n             &span sp, &fn_ident i, node_id id) {\n     let @mutable node_id[] node_ids = @mutable ~[];\n     node_ids_in_fn(f, tps, sp, i, id, node_ids);\n     auto node_id_vec = *node_ids;\n     init_vecs(ccx, node_id_vec, num_constraints);\n }\n \n-fn annotate_in_fn(&crate_ctxt ccx, &_fn f, &vec[ty_param] tps,\n+fn annotate_in_fn(&crate_ctxt ccx, &_fn f, &ty_param[] tps,\n                   &span sp, &fn_ident i, node_id id) {\n     auto f_info = get_fn_info(ccx, id);\n     visit_fn(ccx, num_constraints(f_info), f, tps, sp, i, id);"}, {"sha": "217f253ab60f59b5da9194c770385a82a24146e5", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -120,7 +120,7 @@ fn check_states_stmt(&fn_ctxt fcx, &@stmt s) {\n }\n \n fn check_states_against_conditions(&fn_ctxt fcx, &_fn f,\n-                                   &vec[ast::ty_param] tps,\n+                                   &ast::ty_param[] tps,\n                                    node_id id, &span sp, &fn_ident i) {\n     /* Postorder traversal instead of pre is important\n        because we want the smallest possible erroneous statement\n@@ -176,7 +176,7 @@ fn check_states_against_conditions(&fn_ctxt fcx, &_fn f,\n     check_unused_vars(fcx);\n }\n \n-fn check_fn_states(&fn_ctxt fcx, &_fn f, &vec[ast::ty_param] tps,\n+fn check_fn_states(&fn_ctxt fcx, &_fn f, &ast::ty_param[] tps,\n                    node_id id, &span sp, &fn_ident i) {\n     /* Compute the pre- and post-states for this function */\n \n@@ -189,7 +189,7 @@ fn check_fn_states(&fn_ctxt fcx, &_fn f, &vec[ast::ty_param] tps,\n     check_states_against_conditions(fcx, f, tps, id, sp, i);\n }\n \n-fn fn_states(&crate_ctxt ccx, &_fn f, &vec[ast::ty_param] tps,\n+fn fn_states(&crate_ctxt ccx, &_fn f, &ast::ty_param[] tps,\n              &span sp, &fn_ident i, node_id id) {\n     /* Look up the var-to-bit-num map for this function */\n "}, {"sha": "95b0723eb3410429aa7cf932351371fa850e6a81", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -64,13 +64,12 @@ fn collect_pred(&@expr e, &ctxt cx, &visit::vt[ctxt] v) {\n     visit::visit_expr(e, cx, v);\n }\n \n-fn do_nothing(&_fn f, &vec[ty_param] tp, &span sp, &fn_ident i,\n+fn do_nothing(&_fn f, &ty_param[] tp, &span sp, &fn_ident i,\n               node_id iid, &ctxt cx, &visit::vt[ctxt] v) {\n }\n  \n-fn find_locals(&ty::ctxt tcx, &_fn f, &vec[ty_param] tps,\n-               &span sp, &fn_ident i, node_id id)\n-    -> ctxt {\n+fn find_locals(&ty::ctxt tcx, &_fn f, &ty_param[] tps, &span sp, &fn_ident i,\n+               node_id id) -> ctxt {\n     let ctxt cx = rec(cs=@mutable ~[], tcx=tcx);\n     auto visitor = visit::default_visitor[ctxt]();\n \n@@ -118,9 +117,8 @@ fn add_constraint(&ty::ctxt tcx, aux::constr c, uint next, constr_map tbl) ->\n \n /* builds a table mapping each local var defined in f\n    to a bit number in the precondition/postcondition vectors */\n-fn mk_fn_info(&crate_ctxt ccx, &_fn f, &vec[ty_param] tp,\n-              &span f_sp, &fn_ident f_name,\n-              node_id id) {\n+fn mk_fn_info(&crate_ctxt ccx, &_fn f, &ty_param[] tp,\n+              &span f_sp, &fn_ident f_name, node_id id) {\n     auto res_map = @new_int_hash[constraint]();\n     let uint next = 0u;\n "}, {"sha": "7318fd28f86be8145c32f831e8240a71025aca40", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 40, "deletions": 43, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -102,9 +102,8 @@ fn find_pre_post_obj(&crate_ctxt ccx, _obj o) {\n                 ccx=ccx);\n         find_pre_post_fn(fcx, m.node.meth);\n     }\n-    auto f = bind do_a_method(ccx, _);\n-    vec::map[@method, ()](f, o.methods);\n-    option::map[@method, ()](f, o.dtor);\n+    for (@method m in o.methods) { do_a_method(ccx, m); }\n+    option::map[@method, ()](bind do_a_method(ccx, _), o.dtor);\n }\n \n fn find_pre_post_item(&crate_ctxt ccx, &item i) {\n@@ -151,26 +150,21 @@ fn find_pre_post_item(&crate_ctxt ccx, &item i) {\n    sets the precondition in a to be the result of combining\n    the preconditions for <args>, and the postcondition in a to \n    be the union of all postconditions for <args> */\n-fn find_pre_post_exprs(&fn_ctxt fcx, &vec[@expr] args, node_id id) {\n-    if (vec::len[@expr](args) > 0u) {\n+fn find_pre_post_exprs(&fn_ctxt fcx, &(@expr)[] args, node_id id) {\n+    if (ivec::len[@expr](args) > 0u) {\n         log \"find_pre_post_exprs: oper =\";\n         log_expr(*args.(0));\n     }\n     fn do_one(fn_ctxt fcx, &@expr e) { find_pre_post_expr(fcx, e); }\n-    auto f = bind do_one(fcx, _);\n-    vec::map[@expr, ()](f, args);\n+    for (@expr e in args) { do_one(fcx, e); }\n+\n     fn get_pp(crate_ctxt ccx, &@expr e) -> pre_and_post {\n         ret expr_pp(ccx, e);\n     }\n-    auto g = bind get_pp(fcx.ccx, _);\n-    auto pps = vec::map[@expr, pre_and_post](g, args);\n-\n-    // TODO: Remove this vec->ivec conversion.\n-    auto pps_ivec = ~[];\n-    for (pre_and_post pp in pps) { pps_ivec += ~[pp]; }\n+    auto pps = ivec::map[@expr, pre_and_post](bind get_pp(fcx.ccx, _), args);\n \n-    set_pre_and_post(fcx.ccx, id, seq_preconds(fcx, pps_ivec),\n-                     seq_postconds(fcx, ivec::map(get_post, pps_ivec)));\n+    set_pre_and_post(fcx.ccx, id, seq_preconds(fcx, pps),\n+                     seq_postconds(fcx, ivec::map(get_post, pps)));\n }\n \n fn find_pre_post_loop(&fn_ctxt fcx, &@local l, &@expr index, &block body,\n@@ -264,10 +258,10 @@ fn gen_if_local(&fn_ctxt fcx, @expr lhs, @expr rhs, node_id larger_id,\n                         rec(id=d_id._1,\n                             c=ninit(path_to_ident(fcx.ccx.tcx, pth))));\n                 }\n-                case (_) { find_pre_post_exprs(fcx, [lhs, rhs], larger_id); }\n+                case (_) { find_pre_post_exprs(fcx, ~[lhs, rhs], larger_id); }\n             }\n         }\n-        case (_) { find_pre_post_exprs(fcx, [lhs, rhs], larger_id); }\n+        case (_) { find_pre_post_exprs(fcx, ~[lhs, rhs], larger_id); }\n     }\n }\n \n@@ -280,12 +274,8 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n \n     alt (e.node) {\n         case (expr_call(?operator, ?operands)) {\n-            auto args = vec::clone(operands);\n-            vec::push(args, operator);\n-\n-            // TODO: Remove this vec->ivec conversion.\n-            auto operands_ivec = ~[];\n-            for (@expr e in operands) { operands_ivec += ~[e]; }\n+            auto args = /* copy */ operands;\n+            args += ~[operator];\n \n             find_pre_post_exprs(fcx, args, e.id);\n             /* see if the call has any constraints on its type */\n@@ -295,8 +285,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n                         bit_num(fcx,\n                                 rec(id=c.node.id._1,\n                                     c=substitute_constr_args(fcx.ccx.tcx,\n-                                                             operands_ivec,\n-                                                             c)));\n+                                                             args, c)));\n                     require(i, expr_pp(fcx.ccx, e));\n                 }\n \n@@ -307,8 +296,8 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             }\n         }\n         case (expr_spawn(_, _, ?operator, ?operands)) {\n-            auto args = vec::clone(operands);\n-            vec::push(args, operator);\n+            auto args = /* copy */ operands;\n+            args += ~[operator];\n             find_pre_post_exprs(fcx, args, e.id);\n         }\n         case (expr_vec(?args, _, _)) {\n@@ -359,23 +348,26 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n         }\n         case (expr_rec(?fields, ?maybe_base)) {\n             auto es = field_exprs(fields);\n-            vec::plus_option(es, maybe_base);\n+            alt (maybe_base) {\n+              case (none) { /* no-op */ }\n+              case (some(?b)) { es += ~[b]; }\n+            }\n             find_pre_post_exprs(fcx, es, e.id);\n         }\n         case (expr_move(?lhs, ?rhs)) {\n             alt (lhs.node) {\n                 case (expr_path(?p)) {\n                     gen_if_local(fcx, lhs, rhs, e.id, lhs.id, p);\n                 }\n-                case (_) { find_pre_post_exprs(fcx, [lhs, rhs], e.id); }\n+                case (_) { find_pre_post_exprs(fcx, ~[lhs, rhs], e.id); }\n             }\n             if (is_path(rhs)) {\n                 forget_in_postcond(fcx, e.id, rhs.id);\n             }\n         }\n         case (expr_swap(?lhs, ?rhs)) {\n             // Both sides must already be initialized\n-            find_pre_post_exprs(fcx, [lhs, rhs], e.id);\n+            find_pre_post_exprs(fcx, ~[lhs, rhs], e.id);\n             forget_in_postcond_still_init(fcx, e.id, lhs.id);\n             forget_in_postcond_still_init(fcx, e.id, rhs.id);\n             // Could be more precise and swap the roles of lhs and rhs\n@@ -387,7 +379,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n                     gen_if_local(fcx, lhs, rhs, e.id, lhs.id, p);\n                     forget_in_postcond_still_init(fcx, e.id, lhs.id);\n                 }\n-                case (_) { find_pre_post_exprs(fcx, [lhs, rhs], e.id); }\n+                case (_) { find_pre_post_exprs(fcx, ~[lhs, rhs], e.id); }\n             }\n         }\n         case (expr_recv(?lhs, ?rhs)) {\n@@ -400,15 +392,15 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n                     // doesn't check that rhs is an lval, but\n                     // that's probably ok\n \n-                    find_pre_post_exprs(fcx, [lhs, rhs], e.id);\n+                    find_pre_post_exprs(fcx, ~[lhs, rhs], e.id);\n                 }\n             }\n         }\n         case (expr_assign_op(_, ?lhs, ?rhs)) {\n             /* Different from expr_assign in that the lhs *must*\n                already be initialized */\n \n-            find_pre_post_exprs(fcx, [lhs, rhs], e.id);\n+            find_pre_post_exprs(fcx, ~[lhs, rhs], e.id);\n             forget_in_postcond_still_init(fcx, e.id, lhs.id);\n         }\n         case (expr_lit(_)) { clear_pp(expr_pp(fcx.ccx, e)); }\n@@ -449,11 +441,11 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n                                   expr_postcond(fcx.ccx, l));\n             }\n             else {\n-                find_pre_post_exprs(fcx, [l, r], e.id);\n+                find_pre_post_exprs(fcx, ~[l, r], e.id);\n             }\n         }\n         case (expr_send(?l, ?r)) {\n-            find_pre_post_exprs(fcx, [l, r], e.id);\n+            find_pre_post_exprs(fcx, ~[l, r], e.id);\n         }\n         case (expr_unary(_, ?operand)) {\n             find_pre_post_expr(fcx, operand);\n@@ -497,16 +489,16 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             find_pre_post_loop(fcx, d, index, body, e.id);\n         }\n         case (expr_index(?val, ?sub)) {\n-            find_pre_post_exprs(fcx, [val, sub], e.id);\n+            find_pre_post_exprs(fcx, ~[val, sub], e.id);\n         }\n         case (expr_alt(?ex, ?alts)) {\n             find_pre_post_expr(fcx, ex);\n             fn do_an_alt(&fn_ctxt fcx, &arm an_alt) -> pre_and_post {\n                 find_pre_post_block(fcx, an_alt.block);\n                 ret block_pp(fcx.ccx, an_alt.block);\n             }\n-            auto f = bind do_an_alt(fcx, _);\n-            auto alt_pps = vec::map[arm, pre_and_post](f, alts);\n+            auto alt_pps = [];\n+            for (arm a in alts) { alt_pps += [do_an_alt(fcx, a)]; }\n             fn combine_pp(pre_and_post antec, fn_ctxt fcx, &pre_and_post pp,\n                           &pre_and_post next) -> pre_and_post {\n                 union(pp.precondition, seq_preconds(fcx, ~[antec, next]));\n@@ -559,8 +551,14 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n         }\n \n         case (expr_bind(?operator, ?maybe_args)) {\n-            auto args = vec::cat_options[@expr](maybe_args);\n-            vec::push[@expr](args, operator); /* ??? order of eval? */\n+            auto args = ~[];\n+            for (option::t[@expr] expr_opt in maybe_args) {\n+                alt (expr_opt) {\n+                  case (none) { /* no-op */ }\n+                  case (some(?expr)) { args += ~[expr]; }\n+                }\n+            }\n+            args += ~[operator]; /* ??? order of eval? */\n \n             find_pre_post_exprs(fcx, args, e.id);\n         }\n@@ -659,8 +657,7 @@ fn find_pre_post_block(&fn_ctxt fcx, block b) {\n         log \"is:\";\n         log_pp(stmt_pp(fcx.ccx, *s));\n     }\n-    auto do_one = bind do_one_(fcx, _);\n-    vec::map[@stmt, ()](do_one, b.node.stmts);\n+    for (@stmt s in b.node.stmts) { do_one_(fcx, s); }\n     fn do_inner_(fn_ctxt fcx, &@expr e) { find_pre_post_expr(fcx, e); }\n     auto do_inner = bind do_inner_(fcx, _);\n     option::map[@expr, ()](do_inner, b.node.expr);\n@@ -705,7 +702,7 @@ fn find_pre_post_fn(&fn_ctxt fcx, &_fn f) {\n     }\n }\n \n-fn fn_pre_post(crate_ctxt ccx, &_fn f, &vec[ty_param] tps,\n+fn fn_pre_post(crate_ctxt ccx, &_fn f, &ty_param[] tps,\n                &span sp, &fn_ident i, node_id id) {\n     assert (ccx.fm.contains_key(id));\n     auto fcx = rec(enclosing=ccx.fm.get(id), id=id,"}, {"sha": "4e206add74434a7a247784c4a785bf32fb5da36d", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -1,3 +1,4 @@\n+import std::ivec;\n import std::vec;\n import std::vec::plus_option;\n import std::vec::cat_options;\n@@ -100,7 +101,7 @@ tag oper_type {\n     oper_pure;\n }\n \n-fn seq_states(&fn_ctxt fcx, prestate pres, vec[@expr] exprs) ->\n+fn seq_states(&fn_ctxt fcx, prestate pres, &(@expr)[] exprs) ->\n    tup(bool, poststate) {\n     auto changed = false;\n     auto post = pres;\n@@ -162,15 +163,15 @@ fn find_pre_post_state_two(&fn_ctxt fcx, &prestate pres, &@expr a, &@expr b,\n }\n \n fn find_pre_post_state_call(&fn_ctxt fcx, &prestate pres, &@expr a,\n-                            node_id id, &vec[@expr] bs,\n+                            node_id id, &(@expr)[] bs,\n                             controlflow cf) -> bool {\n     auto changed = find_pre_post_state_expr(fcx, pres, a);\n     ret find_pre_post_state_exprs(fcx,\n           expr_poststate(fcx.ccx, a), id, bs, cf) || changed;\n }\n \n fn find_pre_post_state_exprs(&fn_ctxt fcx, &prestate pres, node_id id,\n-                             &vec[@expr] es, controlflow cf) -> bool {\n+                             &(@expr)[] es, controlflow cf) -> bool {\n     auto rs = seq_states(fcx, pres, es);\n     auto changed = rs._0 | set_prestate_ann(fcx.ccx, id, pres);\n     /* if this is a failing call, it sets everything as initialized */\n@@ -313,8 +314,16 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n                                          return);\n         }\n         case (expr_bind(?operator, ?maybe_args)) {\n-            ret find_pre_post_state_call(fcx, pres, operator, e.id,\n-                                         cat_options(maybe_args), return);\n+            auto args = ~[];\n+            for (option::t[@expr] a_opt in maybe_args) {\n+                alt (a_opt) {\n+                  case (none) { /* no-op */ }\n+                  case (some(?a)) { args += ~[a]; }\n+                }\n+            }\n+\n+            ret find_pre_post_state_call(fcx, pres, operator, e.id, args,\n+                                         return);\n         }\n         case (expr_path(_)) { ret pure_exp(fcx.ccx, e.id, pres); }\n         case (expr_log(_, ?ex)) {\n@@ -514,7 +523,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n                 find_pre_post_state_expr(fcx, pres, val);\n             auto e_post = expr_poststate(fcx.ccx, val);\n             auto a_post;\n-            if (vec::len(alts) > 0u) {\n+            if (ivec::len(alts) > 0u) {\n                 a_post = false_postcond(num_constrs);\n                 for (arm an_alt in alts) {\n                     changed |= find_pre_post_state_block"}, {"sha": "d6673b55800525329bcebb0dc932d758beda59d6", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -52,7 +52,7 @@ export check_crate;\n \n type ty_table = hashmap[ast::def_id, ty::t];\n \n-type obj_info = rec(vec[ast::obj_field] obj_fields, ast::node_id this_obj);\n+type obj_info = rec(ast::obj_field[] obj_fields, ast::node_id this_obj);\n \n type crate_ctxt =\n     rec(mutable vec[obj_info] obj_infos,\n@@ -481,7 +481,7 @@ mod collect {\n     }\n     fn ty_of_fn_decl(&@ctxt cx, &fn(&@ast::ty) -> ty::t  convert,\n                      &fn(&ast::arg) -> arg  ty_of_arg, &ast::fn_decl decl,\n-                     ast::proto proto, &vec[ast::ty_param] ty_params,\n+                     ast::proto proto, &ast::ty_param[] ty_params,\n                      &option::t[ast::def_id] def_id) ->\n        ty::ty_param_count_and_ty {\n         auto input_tys = ~[];\n@@ -495,7 +495,7 @@ mod collect {\n         auto t_fn =\n             ty::mk_fn(cx.tcx, proto, input_tys, output_ty, decl.cf,\n                       out_constrs);\n-        auto ty_param_count = vec::len[ast::ty_param](ty_params);\n+        auto ty_param_count = ivec::len[ast::ty_param](ty_params);\n         auto tpt = tup(ty_param_count, t_fn);\n         alt (def_id) {\n             case (some(?did)) { cx.tcx.tcache.insert(did, tpt); }\n@@ -506,15 +506,15 @@ mod collect {\n     fn ty_of_native_fn_decl(&@ctxt cx, &fn(&@ast::ty) -> ty::t  convert,\n                             &fn(&ast::arg) -> arg  ty_of_arg,\n                             &ast::fn_decl decl, ast::native_abi abi,\n-                            &vec[ast::ty_param] ty_params,\n+                            &ast::ty_param[] ty_params,\n                             &ast::def_id def_id) ->\n        ty::ty_param_count_and_ty {\n         auto input_tys = ~[];\n         for (ast::arg a in decl.inputs) { input_tys += ~[ty_of_arg(a)]; }\n         auto output_ty = convert(decl.output);\n \n         auto t_fn = ty::mk_native_fn(cx.tcx, abi, input_tys, output_ty);\n-        auto ty_param_count = vec::len[ast::ty_param](ty_params);\n+        auto ty_param_count = ivec::len[ast::ty_param](ty_params);\n         auto tpt = tup(ty_param_count, t_fn);\n         cx.tcx.tcache.insert(def_id, tpt);\n         ret tpt;\n@@ -577,14 +577,14 @@ mod collect {\n                 constrs=out_constrs);\n     }\n     fn ty_of_obj(@ctxt cx, &ast::ident id, &ast::_obj obj_info,\n-                 &vec[ast::ty_param] ty_params) -> ty::ty_param_count_and_ty {\n+                 &ast::ty_param[] ty_params) -> ty::ty_param_count_and_ty {\n         auto methods = get_obj_method_types(cx, obj_info);\n         auto t_obj = ty::mk_obj(cx.tcx, ty::sort_methods(methods));\n         t_obj = ty::rename(cx.tcx, t_obj, id);\n-        ret tup(vec::len(ty_params), t_obj);\n+        ret tup(ivec::len(ty_params), t_obj);\n     }\n     fn ty_of_obj_ctor(@ctxt cx, &ast::ident id, &ast::_obj obj_info,\n-                      ast::node_id ctor_id, &vec[ast::ty_param] ty_params) ->\n+                      ast::node_id ctor_id, &ast::ty_param[] ty_params) ->\n        ty::ty_param_count_and_ty {\n         auto t_obj = ty_of_obj(cx, id, obj_info, ty_params);\n \n@@ -630,23 +630,23 @@ mod collect {\n                 // call to resolve any named types.\n \n                 auto typ = convert(t);\n-                auto ty_param_count = vec::len[ast::ty_param](tps);\n+                auto ty_param_count = ivec::len[ast::ty_param](tps);\n                 auto tpt = tup(ty_param_count, typ);\n                 cx.tcx.tcache.insert(local_def(it.id), tpt);\n                 ret tpt;\n             }\n             case (ast::item_res(?f, _, ?tps, _)) {\n                 auto t_arg = ty_of_arg(cx, f.decl.inputs.(0));\n-                auto t_res = tup(vec::len(tps), ty::mk_res\n+                auto t_res = tup(ivec::len(tps), ty::mk_res\n                                  (cx.tcx, local_def(it.id), t_arg.ty,\n-                                  mk_ty_params(cx, vec::len(tps))));\n+                                  mk_ty_params(cx, ivec::len(tps))));\n                 cx.tcx.tcache.insert(local_def(it.id), t_res);\n                 ret t_res;\n             }\n             case (ast::item_tag(_, ?tps)) {\n                 // Create a new generic polytype.\n \n-                auto ty_param_count = vec::len[ast::ty_param](tps);\n+                auto ty_param_count = ivec::len[ast::ty_param](tps);\n \n                 let ty::t[] subtys = mk_ty_params(cx, ty_param_count);\n                 auto t = ty::mk_tag(cx.tcx, local_def(it.id), subtys);\n@@ -681,11 +681,11 @@ mod collect {\n         }\n     }\n     fn get_tag_variant_types(&@ctxt cx, &ast::def_id tag_id,\n-                             &vec[ast::variant] variants,\n-                             &vec[ast::ty_param] ty_params) {\n+                             &ast::variant[] variants,\n+                             &ast::ty_param[] ty_params) {\n         // Create a set of parameter types shared among all the variants.\n \n-        auto ty_param_count = vec::len[ast::ty_param](ty_params);\n+        auto ty_param_count = ivec::len[ast::ty_param](ty_params);\n         let ty::t[] ty_param_tys = mk_ty_params(cx, ty_param_count);\n         for (ast::variant variant in variants) {\n             // Nullary tag constructors get turned into constants; n-ary tag\n@@ -757,7 +757,7 @@ mod collect {\n \n                 auto method_types = get_obj_method_types(cx, object);\n                 auto i = 0u;\n-                while (i < vec::len[@ast::method](object.methods)) {\n+                while (i < ivec::len[@ast::method](object.methods)) {\n                     write::ty_only(cx.tcx, object.methods.(i).node.id,\n                                    ty::method_ty_to_fn_ty(cx.tcx,\n                                                           method_types.(i)));\n@@ -789,15 +789,15 @@ mod collect {\n             case (ast::item_res(?f, ?dtor_id, ?tps, ?ctor_id)) {\n                 auto t_arg = ty_of_arg(cx, f.decl.inputs.(0));\n                 auto t_res = ty::mk_res(cx.tcx, local_def(it.id), t_arg.ty,\n-                                        mk_ty_params(cx, vec::len(tps)));\n+                                        mk_ty_params(cx, ivec::len(tps)));\n                 auto t_ctor = ty::mk_fn(cx.tcx, ast::proto_fn, ~[t_arg],\n                                         t_res, ast::return, ~[]);\n                 auto t_dtor = ty::mk_fn(cx.tcx, ast::proto_fn, ~[t_arg],\n                                         ty::mk_nil(cx.tcx), ast::return, ~[]);\n                 write::ty_only(cx.tcx, it.id, t_res);\n                 write::ty_only(cx.tcx, ctor_id, t_ctor);\n                 cx.tcx.tcache.insert(local_def(ctor_id),\n-                                     tup(vec::len(tps), t_ctor));\n+                                     tup(ivec::len(tps), t_ctor));\n                 write::ty_only(cx.tcx, dtor_id, t_dtor);\n             }\n             case (_) {\n@@ -995,8 +995,8 @@ fn are_compatible(&@fn_ctxt fcx, &ty::t expected, &ty::t actual) -> bool {\n \n // Returns the types of the arguments to a tag variant.\n fn variant_arg_types(&@crate_ctxt ccx, &span sp, &ast::def_id vid,\n-                     &ty::t[] tag_ty_params) -> vec[ty::t] {\n-    let vec[ty::t] result = [];\n+                     &ty::t[] tag_ty_params) -> ty::t[] {\n+    let ty::t[] result = ~[];\n     auto tpt = ty::lookup_item_type(ccx.tcx, vid);\n     alt (ty::struct(ccx.tcx, tpt._1)) {\n         case (ty::ty_fn(_, ?ins, _, _, _)) {\n@@ -1006,7 +1006,7 @@ fn variant_arg_types(&@crate_ctxt ccx, &span sp, &ast::def_id vid,\n                 auto arg_ty =\n                     ty::substitute_type_params(ccx.tcx, tag_ty_params,\n                                                arg.ty);\n-                result += [arg_ty];\n+                result += ~[arg_ty];\n             }\n         }\n         case (_) {\n@@ -1121,12 +1121,12 @@ mod writeback {\n         wbcx.ignore = false;\n     }\n     fn visit_fn_pre(@wb_ctxt wbcx, &ast::_fn f,\n-                    &vec[ast::ty_param] tps, &span sp,\n+                    &ast::ty_param[] tps, &span sp,\n                     &ast::fn_ident i, ast::node_id d) {\n         wbcx.ignore = true;\n     }\n     fn visit_fn_post(@wb_ctxt wbcx, &ast::_fn f,\n-                     &vec[ast::ty_param] tps, &span sp,\n+                     &ast::ty_param[] tps, &span sp,\n                      &ast::fn_ident i, ast::node_id d) {\n         wbcx.ignore = false;\n     }\n@@ -1335,11 +1335,11 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat, ty::t expected) {\n                 auto arg_types =\n                     variant_arg_types(fcx.ccx, pat.span, v_def_ids._1,\n                                       expected_tps);\n-                auto subpats_len = vec::len[@ast::pat](subpats);\n-                if (vec::len[ty::t](arg_types) > 0u) {\n+                auto subpats_len = std::ivec::len[@ast::pat](subpats);\n+                if (std::ivec::len[ty::t](arg_types) > 0u) {\n                     // N-ary variant.\n \n-                    auto arg_len = vec::len[ty::t](arg_types);\n+                    auto arg_len = ivec::len[ty::t](arg_types);\n                     if (arg_len != subpats_len) {\n                         // TODO: note definition of tag variant\n                         // TODO (issue #448): Wrap a #fmt string over multiple\n@@ -1430,7 +1430,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n     // expressions.\n \n     fn check_call_or_bind(&@fn_ctxt fcx, &span sp, &@ast::expr f,\n-                          &vec[option::t[@ast::expr]] args, bool is_call) {\n+                          &(option::t[@ast::expr])[] args, bool is_call) {\n         // Check the function.\n \n         check_expr(fcx, f);\n@@ -1458,7 +1458,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         // Check that the correct number of arguments were supplied.\n \n         auto expected_arg_count = ivec::len[ty::arg](arg_tys);\n-        auto supplied_arg_count = vec::len[option::t[@ast::expr]](args);\n+        auto supplied_arg_count = ivec::len[option::t[@ast::expr]](args);\n         if (expected_arg_count != supplied_arg_count) {\n             fcx.ccx.tcx.sess.span_fatal(sp,\n                                       #fmt(\"this function takes %u \\\n@@ -1501,10 +1501,10 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n     // A generic function for checking call expressions\n \n     fn check_call(&@fn_ctxt fcx, &span sp, &@ast::expr f,\n-                  &vec[@ast::expr] args) {\n-        let vec[option::t[@ast::expr]] args_opt_0 = [];\n+                  &(@ast::expr)[] args) {\n+        let (option::t[@ast::expr])[] args_opt_0 = ~[];\n         for (@ast::expr arg in args) {\n-            args_opt_0 += [some[@ast::expr](arg)];\n+            args_opt_0 += ~[some[@ast::expr](arg)];\n         }\n         // Call the generic checker.\n \n@@ -1909,7 +1909,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             auto ty_of_arg = bind collect::ty_of_arg(cx, _);\n             auto fty =\n                 collect::ty_of_fn_decl(cx, convert, ty_of_arg, f.decl,\n-                                       f.proto, [], none)._1;\n+                                       f.proto, ~[], none)._1;\n             write::ty_only_fixup(fcx, id, fty);\n             check_fn(fcx.ccx, f.decl, f.proto, f.body, id);\n         }\n@@ -1949,7 +1949,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     // to the resulting function type.\n \n                     auto i = 0u;\n-                    while (i < vec::len[option::t[@ast::expr]](args)) {\n+                    while (i < ivec::len[option::t[@ast::expr]](args)) {\n                         alt (args.(i)) {\n                             case (some(_)) {/* no-op */ }\n                             case (none) { arg_tys_1 += ~[arg_tys.(i)]; }\n@@ -2051,7 +2051,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         }\n         case (ast::expr_vec(?args, ?mut, ?kind)) {\n             let ty::t t;\n-            if (vec::len[@ast::expr](args) == 0u) {\n+            if (ivec::len[@ast::expr](args) == 0u) {\n                 t = next_ty_var(fcx);\n             } else {\n                 check_expr(fcx, args.(0));\n@@ -2075,7 +2075,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         }\n         case (ast::expr_tup(?elts)) {\n             let ty::mt[] elts_mt = ~[];\n-            ivec::reserve(elts_mt, vec::len(elts));\n+            ivec::reserve(elts_mt, ivec::len(elts));\n             for (ast::elt e in elts) {\n                 check_expr(fcx, e.expr);\n                 auto ety = expr_ty(fcx.ccx.tcx, e.expr);\n@@ -2250,7 +2250,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n             // We're entering an object, so gather up the info we need.\n \n-            let vec[ast::anon_obj_field] fields = [];\n+            let ast::anon_obj_field[] fields = ~[];\n             alt (anon_obj.fields) {\n                 case (none) { }\n                 case (some(?v)) { fields = v; }\n@@ -2265,8 +2265,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n             vec::push[obj_info](fcx.ccx.obj_infos,\n                                 rec(obj_fields=\n-                                    vec::map(anon_obj_field_to_obj_field, \n-                                             fields),\n+                                    ivec::map(anon_obj_field_to_obj_field, \n+                                              fields),\n                                     this_obj=id));\n \n             // FIXME: These next three functions are largely ripped off from\n@@ -2343,7 +2343,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             // collect::convert for regular objects.)\n \n             auto i = 0u;\n-            while (i < vec::len[@ast::method](anon_obj.methods)) {\n+            while (i < ivec::len[@ast::method](anon_obj.methods)) {\n                 write::ty_only(fcx.ccx.tcx, anon_obj.methods.(i).node.id,\n                                ty::method_ty_to_fn_ty(fcx.ccx.tcx,\n                                                       method_types.(i)));"}, {"sha": "1597feb3dc3de2a88ec95e26cdea803f5dfcb7b0", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -111,7 +111,7 @@ tag meta_item_ {\n \n type block = spanned[block_];\n \n-type block_ = rec(vec[@stmt] stmts, option::t[@expr] expr, node_id id);\n+type block_ = rec((@stmt)[] stmts, option::t[@expr] expr, node_id id);\n \n type pat = rec(node_id id,\n                pat_ node,\n@@ -121,7 +121,7 @@ tag pat_ {\n     pat_wild;\n     pat_bind(ident);\n     pat_lit(@lit);\n-    pat_tag(path, vec[@pat]);\n+    pat_tag(path, (@pat)[]);\n }\n \n tag mutability { mut; imm; maybe_mut; }\n@@ -246,13 +246,13 @@ type expr = rec(node_id id,\n                 span span);\n \n tag expr_ {\n-    expr_vec(vec[@expr], mutability, seq_kind);\n-    expr_tup(vec[elt]);\n-    expr_rec(vec[field], option::t[@expr]);\n-    expr_call(@expr, vec[@expr]);\n+    expr_vec((@expr)[], mutability, seq_kind);\n+    expr_tup(elt[]);\n+    expr_rec(field[], option::t[@expr]);\n+    expr_call(@expr, (@expr)[]);\n     expr_self_method(ident);\n-    expr_bind(@expr, vec[option::t[@expr]]);\n-    expr_spawn(spawn_dom, option::t[str], @expr, vec[@expr]);\n+    expr_bind(@expr, (option::t[@expr])[]);\n+    expr_spawn(spawn_dom, option::t[str], @expr, (@expr)[]);\n     expr_binary(binop, @expr, @expr);\n     expr_unary(unop, @expr);\n     expr_lit(@lit);\n@@ -263,7 +263,7 @@ tag expr_ {\n     expr_for(@local, @expr, block);\n     expr_for_each(@local, @expr, block);\n     expr_do_while(block, @expr);\n-    expr_alt(@expr, vec[arm]);\n+    expr_alt(@expr, arm[]);\n     expr_fn(_fn);\n     expr_block(block);\n     /*\n@@ -279,7 +279,7 @@ tag expr_ {\n     expr_field(@expr, ident);\n     expr_index(@expr, @expr);\n     expr_path(path);\n-    expr_ext(path, vec[@expr], option::t[str], @expr);\n+    expr_ext(path, (@expr)[], option::t[str], @expr);\n     expr_fail(option::t[@expr]);\n     expr_break;\n     expr_cont;\n@@ -298,7 +298,7 @@ tag expr_ {\n     expr_if_check(@expr, block, option::t[@expr]);\n     expr_port(option::t[@ty]);\n     expr_chan(@expr);\n-    expr_anon_obj(anon_obj, vec[ty_param]);\n+    expr_anon_obj(anon_obj, ty_param[]);\n }\n \n type lit = spanned[lit_];\n@@ -438,7 +438,7 @@ type constr = spanned[constr_];\n type arg = rec(mode mode, @ty ty, ident ident, node_id id);\n \n type fn_decl =\n-    rec(vec[arg] inputs,\n+    rec(arg[] inputs,\n         @ty output,\n         purity purity,\n         controlflow cf,\n@@ -470,13 +470,13 @@ type anon_obj_field = rec(mutability mut, @ty ty, @expr expr, ident ident,\n                           node_id id);\n \n type _obj =\n-    rec(vec[obj_field] fields, vec[@method] methods, option::t[@method] dtor);\n+    rec(obj_field[] fields, (@method)[] methods, option::t[@method] dtor);\n \n type anon_obj =\n     rec(\n         // New fields and methods, if they exist.\n-        option::t[vec[anon_obj_field]] fields,\n-        vec[@method] methods,\n+        option::t[anon_obj_field[]] fields,\n+        (@method)[] methods,\n \n         // with_obj: the original object being extended, if it exists.\n         option::t[@expr] with_obj);\n@@ -533,14 +533,14 @@ type item = rec(ident ident,\n \n tag item_ {\n     item_const(@ty, @expr);\n-    item_fn(_fn, vec[ty_param]);\n+    item_fn(_fn, ty_param[]);\n     item_mod(_mod);\n     item_native_mod(native_mod);\n-    item_ty(@ty, vec[ty_param]);\n-    item_tag(vec[variant], vec[ty_param]);\n-    item_obj(_obj, vec[ty_param], node_id /* constructor id */);\n+    item_ty(@ty, ty_param[]);\n+    item_tag(variant[], ty_param[]);\n+    item_obj(_obj, ty_param[], node_id /* constructor id */);\n     item_res(_fn /* dtor */, node_id /* dtor id */,\n-             vec[ty_param], node_id /* ctor id */);\n+             ty_param[], node_id /* ctor id */);\n }\n \n type native_item = rec(ident ident,\n@@ -551,7 +551,7 @@ type native_item = rec(ident ident,\n \n tag native_item_ {\n     native_item_ty;\n-    native_item_fn(option::t[str], fn_decl, vec[ty_param]);\n+    native_item_fn(option::t[str], fn_decl, ty_param[]);\n }\n \n fn is_exported(ident i, _mod m) -> bool {\n@@ -609,7 +609,7 @@ fn hash_ty(&@ty t) -> uint { ret t.span.lo << 16u + t.span.hi; }\n \n fn block_from_expr(@expr e) -> block {\n     let block_ blk_ =\n-        rec(stmts=[],\n+        rec(stmts=~[],\n             expr=option::some[@expr](e),\n             id=e.id);\n     ret rec(node=blk_, span=e.span);"}, {"sha": "7b0accb573beab570702e7f7f6503a19925a889a", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -8,8 +8,8 @@ import std::map::new_str_hash;\n import codemap;\n \n type syntax_expander = \n-    fn(&ext_ctxt, span, &vec[@ast::expr], option::t[str]) -> @ast::expr;\n-type macro_definer = fn(&ext_ctxt, span, &vec[@ast::expr],\n+    fn(&ext_ctxt, span, &(@ast::expr)[], option::t[str]) -> @ast::expr;\n+type macro_definer = fn(&ext_ctxt, span, &(@ast::expr)[],\n                         option::t[str]) -> tup(str, syntax_extension);\n \n tag syntax_extension {"}, {"sha": "fad55953519cf09215e5f81dbd096a98fd4f679c", "filename": "src/comp/syntax/ext/env.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -5,16 +5,17 @@\n  * should all get sucked into either the compiler syntax extension plugin\n  * interface.\n  */\n+import std::ivec;\n import std::str;\n import std::vec;\n import std::option;\n import std::generic_os;\n import base::*;\n export expand_syntax_ext;\n \n-fn expand_syntax_ext(&ext_ctxt cx, codemap::span sp, &vec[@ast::expr] args,\n+fn expand_syntax_ext(&ext_ctxt cx, codemap::span sp, &(@ast::expr)[] args,\n                      option::t[str] body) -> @ast::expr {\n-    if (vec::len[@ast::expr](args) != 1u) {\n+    if (ivec::len[@ast::expr](args) != 1u) {\n         cx.span_fatal(sp, \"malformed #env call\");\n     }\n     // FIXME: if this was more thorough it would manufacture an"}, {"sha": "0f3b38a808bd50d8b7e725052fde8ff98a146b6b", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -5,6 +5,7 @@\n  * should all get sucked into either the standard library extfmt module or the\n  * compiler syntax extension plugin interface.\n  */\n+import std::ivec;\n import std::str;\n import std::vec;\n import std::option;\n@@ -15,9 +16,9 @@ import base::*;\n import codemap::span;\n export expand_syntax_ext;\n \n-fn expand_syntax_ext(&ext_ctxt cx, span sp, &vec[@ast::expr] args,\n+fn expand_syntax_ext(&ext_ctxt cx, span sp, &(@ast::expr)[] args,\n                      option::t[str] body) -> @ast::expr {\n-    if (vec::len[@ast::expr](args) == 0u) {\n+    if (ivec::len[@ast::expr](args) == 0u) {\n         cx.span_fatal(sp, \"#fmt requires a format string\");\n     }\n     auto fmt = expr_to_str(cx, args.(0), \"first argument to #fmt must be a \"\n@@ -37,7 +38,7 @@ fn expand_syntax_ext(&ext_ctxt cx, span sp, &vec[@ast::expr] args,\n // be factored out in common with other code that builds expressions.\n // FIXME: Cleanup the naming of these functions\n fn pieces_to_expr(&ext_ctxt cx, span sp, vec[piece] pieces,\n-                  vec[@ast::expr] args) -> @ast::expr {\n+                  &(@ast::expr)[] args) -> @ast::expr {\n     fn make_new_lit(&ext_ctxt cx, span sp, ast::lit_ lit) ->\n        @ast::expr {\n         auto sp_lit = @rec(node=lit, span=sp);\n@@ -67,26 +68,26 @@ fn pieces_to_expr(&ext_ctxt cx, span sp, vec[piece] pieces,\n         auto pathexpr = ast::expr_path(sp_path);\n         ret @rec(id=cx.next_id(), node=pathexpr, span=sp);\n     }\n-    fn make_vec_expr(&ext_ctxt cx, span sp, vec[@ast::expr] exprs) ->\n+    fn make_vec_expr(&ext_ctxt cx, span sp, &(@ast::expr)[] exprs) ->\n        @ast::expr {\n         auto vecexpr = ast::expr_vec(exprs, ast::imm, ast::sk_rc);\n         ret @rec(id=cx.next_id(), node=vecexpr, span=sp);\n     }\n     fn make_call(&ext_ctxt cx, span sp, &ast::ident[] fn_path,\n-                 vec[@ast::expr] args) -> @ast::expr {\n+                 &(@ast::expr)[] args) -> @ast::expr {\n         auto pathexpr = make_path_expr(cx, sp, fn_path);\n         auto callexpr = ast::expr_call(pathexpr, args);\n         ret @rec(id=cx.next_id(), node=callexpr, span=sp);\n     }\n     fn make_rec_expr(&ext_ctxt cx, span sp,\n                      vec[tup(ast::ident, @ast::expr)] fields) -> @ast::expr {\n-        let vec[ast::field] astfields = [];\n+        let ast::field[] astfields = ~[];\n         for (tup(ast::ident, @ast::expr) field in fields) {\n             auto ident = field._0;\n             auto val = field._1;\n             auto astfield =\n                 rec(node=rec(mut=ast::imm, ident=ident, expr=val), span=sp);\n-            astfields += [astfield];\n+            astfields += ~[astfield];\n         }\n         auto recexpr = ast::expr_rec(astfields, option::none[@ast::expr]);\n         ret @rec(id=cx.next_id(), node=recexpr, span=sp);\n@@ -109,7 +110,7 @@ fn pieces_to_expr(&ext_ctxt cx, span sp, vec[piece] pieces,\n        @ast::expr {\n         fn make_flags(&ext_ctxt cx, span sp, vec[flag] flags) ->\n            @ast::expr {\n-            let vec[@ast::expr] flagexprs = [];\n+            let (@ast::expr)[] flagexprs = ~[];\n             for (flag f in flags) {\n                 auto fstr;\n                 alt (f) {\n@@ -121,14 +122,14 @@ fn pieces_to_expr(&ext_ctxt cx, span sp, vec[piece] pieces,\n                     case (flag_sign_always) { fstr = \"flag_sign_always\"; }\n                     case (flag_alternate) { fstr = \"flag_alternate\"; }\n                 }\n-                flagexprs += [make_rt_path_expr(cx, sp, fstr)];\n+                flagexprs += ~[make_rt_path_expr(cx, sp, fstr)];\n             }\n             // FIXME: 0-length vectors can't have their type inferred\n             // through the rec that these flags are a member of, so\n             // this is a hack placeholder flag\n \n-            if (vec::len[@ast::expr](flagexprs) == 0u) {\n-                flagexprs += [make_rt_path_expr(cx, sp, \"flag_none\")];\n+            if (ivec::len[@ast::expr](flagexprs) == 0u) {\n+                flagexprs += ~[make_rt_path_expr(cx, sp, \"flag_none\")];\n             }\n             ret make_vec_expr(cx, sp, flagexprs);\n         }\n@@ -141,7 +142,7 @@ fn pieces_to_expr(&ext_ctxt cx, span sp, vec[piece] pieces,\n                 case (count_is(?c)) {\n                     auto count_lit = make_new_int(cx, sp, c);\n                     auto count_is_path = make_path_vec(\"count_is\");\n-                    auto count_is_args = [count_lit];\n+                    auto count_is_args = ~[count_lit];\n                     ret make_call(cx, sp, count_is_path, count_is_args);\n                 }\n                 case (_) {\n@@ -185,7 +186,7 @@ fn pieces_to_expr(&ext_ctxt cx, span sp, vec[piece] pieces,\n         auto fname = \"conv_\" + conv_type;\n         auto path = make_path_vec(fname);\n         auto cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n-        auto args = [cnv_expr, arg];\n+        auto args = ~[cnv_expr, arg];\n         ret make_call(cx, arg.span, path, args);\n     }\n     fn make_new_conv(&ext_ctxt cx, span sp, conv cnv, @ast::expr arg)\n@@ -328,7 +329,7 @@ fn pieces_to_expr(&ext_ctxt cx, span sp, vec[piece] pieces,\n     auto fmt_sp = args.(0).span;\n     auto n = 0u;\n     auto tmp_expr = make_new_str(cx, sp, \"\");\n-    auto nargs = vec::len[@ast::expr](args);\n+    auto nargs = ivec::len[@ast::expr](args);\n     for (piece pc in pieces) {\n         alt (pc) {\n             case (piece_string(?s)) {"}, {"sha": "46b1fd636ce62da0078f3125cabaccb81a2be49a", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -34,7 +34,7 @@ fn position[T](&T x, &vec[T] v) -> option::t[uint] {\n }\n \n // substitute, in a position that's required to be an ident\n-fn subst_ident(&ext_ctxt cx, &vec[@ast::expr] args, \n+fn subst_ident(&ext_ctxt cx, &(@ast::expr)[] args, \n                @vec[ident] param_names, &ident i, ast_fold fld) -> ident {\n     alt (position(i, *param_names)) {\n         case (some[uint](?idx)) {\n@@ -48,7 +48,7 @@ fn subst_ident(&ext_ctxt cx, &vec[@ast::expr] args,\n     }\n }\n \n-fn subst_path(&ext_ctxt cx, &vec[@ast::expr] args, \n+fn subst_path(&ext_ctxt cx, &(@ast::expr)[] args, \n               @vec[ident] param_names, &path_ p, ast_fold fld) -> path_ {\n     // Don't substitute into qualified names.\n     if (ivec::len(p.types) > 0u || ivec::len(p.idents) != 1u) { ret p; }\n@@ -70,7 +70,7 @@ fn subst_path(&ext_ctxt cx, &vec[@ast::expr] args,\n }\n \n \n-fn subst_expr(&ext_ctxt cx, &vec[@ast::expr] args, @vec[ident] param_names, \n+fn subst_expr(&ext_ctxt cx, &(@ast::expr)[] args, @vec[ident] param_names, \n               &ast::expr_ e, ast_fold fld, \n               fn(&ast::expr_, ast_fold) -> ast::expr_ orig) -> ast::expr_ {\n     ret alt(e) {\n@@ -90,20 +90,21 @@ fn subst_expr(&ext_ctxt cx, &vec[@ast::expr] args, @vec[ident] param_names,\n }\n \n \n-fn add_new_extension(&ext_ctxt cx, span sp, &vec[@ast::expr] args,\n+fn add_new_extension(&ext_ctxt cx, span sp, &(@ast::expr)[] args,\n                      option::t[str] body) -> tup(str, syntax_extension) {\n-    if (len(args) < 2u) {\n+    if (ivec::len(args) < 2u) {\n         cx.span_fatal(sp, \"malformed extension description\");\n     }\n \n-    fn generic_extension(&ext_ctxt cx, span sp, &vec[@ast::expr] args,\n+    fn generic_extension(&ext_ctxt cx, span sp, &(@ast::expr)[] args,\n                          option::t[str] body, @vec[ident] param_names,\n                          @ast::expr dest_form) -> @ast::expr {\n-        if (len(args) != len(*param_names)) {\n+        if (ivec::len(args) != len(*param_names)) {\n             cx.span_fatal(sp, #fmt(\"extension expects %u arguments, got %u\",\n-                                 len(*param_names), len(args)));\n+                                 len(*param_names), ivec::len(args)));\n         }\n \n+        // FIXME: This binds to alias arguments.\n         auto afp = default_ast_fold();\n         auto f_pre = \n             rec(fold_ident = bind subst_ident(cx, args, param_names, _, _),\n@@ -120,7 +121,7 @@ fn add_new_extension(&ext_ctxt cx, span sp, &vec[@ast::expr] args,\n \n     let vec[ident] param_names = vec::empty[ident]();\n     let uint idx = 1u;\n-    while(1u+idx < len(args)) {\n+    while(1u+idx < ivec::len(args)) {\n         param_names +=\n             [expr_to_ident(cx, args.(idx),\n                            \"this parameter name must be an identifier.\")];\n@@ -129,7 +130,7 @@ fn add_new_extension(&ext_ctxt cx, span sp, &vec[@ast::expr] args,\n \n     ret tup(expr_to_str(cx, args.(0), \"first arg must be a literal string.\"),\n             normal(bind generic_extension(_,_,_,_,@param_names,\n-                                          args.(len(args)-1u))));\n+                                          args.(ivec::len(args)-1u))));\n }\n \n "}, {"sha": "780ffaf13b1eef1f3768f469b8f1f2fd65f6028c", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -172,7 +172,8 @@ fn noop_fold_native_item(&@native_item ni, ast_fold fld) -> @native_item {\n                  case (native_item_ty) { native_item_ty }\n                  case (native_item_fn(?st, ?fdec, ?typms)) {\n                      native_item_fn(st, \n-                                    rec(inputs=map(fold_arg, fdec.inputs),\n+                                    rec(inputs=ivec::map(fold_arg,\n+                                                         fdec.inputs),\n                                         output=fld.fold_ty(fdec.output),\n                                         purity=fdec.purity, cf=fdec.cf,\n                                         constraints=ivec::map(fld.fold_constr,\n@@ -216,11 +217,11 @@ fn noop_fold_item_underscore(&item_ i, ast_fold fld) -> item_ {\n             item_ty(fld.fold_ty(t), typms)\n                 }\n         case (item_tag(?variants, ?typms)) {\n-            item_tag(map(fld.fold_variant, variants), typms)\n+            item_tag(ivec::map(fld.fold_variant, variants), typms)\n                 }\n         case (item_obj(?o, ?typms, ?d)) {\n-            item_obj(rec(fields=map(fold_obj_field,o.fields),\n-                         methods=map(fld.fold_method,o.methods),\n+            item_obj(rec(fields=ivec::map(fold_obj_field,o.fields),\n+                         methods=ivec::map(fld.fold_method,o.methods),\n                          dtor=option::map(fld.fold_method,o.dtor)),\n                      typms, d)\n                 }\n@@ -237,7 +238,7 @@ fn noop_fold_method(&method_ m, ast_fold fld) -> method_ {\n \n \n fn noop_fold_block(&block_ b, ast_fold fld) -> block_ {\n-    ret rec(stmts=map(fld.fold_stmt, b.stmts),\n+    ret rec(stmts=ivec::map(fld.fold_stmt, b.stmts),\n             expr=option::map(fld.fold_expr, b.expr), id=b.id);\n }\n \n@@ -261,7 +262,7 @@ fn noop_fold_pat(&pat_ p, ast_fold fld) -> pat_ {\n         case (pat_bind(?ident)) { pat_bind(fld.fold_ident(ident))}\n         case (pat_lit(_)) { p }\n         case (pat_tag(?pth, ?pats)) {\n-            pat_tag(fld.fold_path(pth), map(fld.fold_pat, pats))\n+            pat_tag(fld.fold_path(pth), ivec::map(fld.fold_pat, pats))\n         }\n     };\n }\n@@ -298,41 +299,41 @@ fn noop_fold_expr(&expr_ e, ast_fold fld) -> expr_ {\n         auto fold_anon_obj_field = bind fold_anon_obj_field_(_,fld);\n \n         ret rec(fields=alt(ao.fields) {\n-                    case (option::none[vec[anon_obj_field]]) { ao.fields }\n-                    case (option::some[vec[anon_obj_field]](?v)) {\n-                        option::some[vec[anon_obj_field]]\n-                            (map(fold_anon_obj_field, v))\n+                    case (option::none[anon_obj_field[]]) { ao.fields }\n+                    case (option::some[anon_obj_field[]](?v)) {\n+                        option::some[anon_obj_field[]]\n+                            (ivec::map(fold_anon_obj_field, v))\n                     }},\n-                methods=map(fld.fold_method, ao.methods),\n+                methods=ivec::map(fld.fold_method, ao.methods),\n                 with_obj=option::map(fld.fold_expr, ao.with_obj))\n     }\n     auto fold_anon_obj = bind fold_anon_obj_(_,fld);\n     \n \n     ret alt (e) {\n         case (expr_vec(?exprs, ?mut, ?seq_kind)) {\n-            expr_vec(map(fld.fold_expr, exprs), mut, seq_kind)\n+            expr_vec(ivec::map(fld.fold_expr, exprs), mut, seq_kind)\n                 }\n         case (expr_tup(?elts)) {\n-            expr_tup(map(fold_elt, elts))\n+            expr_tup(ivec::map(fold_elt, elts))\n                 }\n         case (expr_rec(?fields, ?maybe_expr)) {\n-            expr_rec(map(fold_field, fields),\n+            expr_rec(ivec::map(fold_field, fields),\n                      option::map(fld.fold_expr, maybe_expr))\n                 }\n         case (expr_call(?f, ?args)) {\n-            expr_call(fld.fold_expr(f), map(fld.fold_expr, args))\n+            expr_call(fld.fold_expr(f), ivec::map(fld.fold_expr, args))\n                 }\n         case (expr_self_method(?id)) {\n             expr_self_method(fld.fold_ident(id))\n                 }\n         case (expr_bind(?f, ?args)) {\n             auto opt_map_se = bind option::map(fld.fold_expr,_);\n-            expr_bind(fld.fold_expr(f), map(opt_map_se, args))\n+            expr_bind(fld.fold_expr(f), ivec::map(opt_map_se, args))\n                 }\n         case (expr_spawn(?spawn_dom, ?name, ?f, ?args)) {\n             expr_spawn(spawn_dom, name, fld.fold_expr(f), \n-                       map(fld.fold_expr, args))\n+                       ivec::map(fld.fold_expr, args))\n                 }\n         case (expr_binary(?binop, ?lhs, ?rhs)) {\n             expr_binary(binop, fld.fold_expr(lhs), fld.fold_expr(rhs))\n@@ -368,7 +369,7 @@ fn noop_fold_expr(&expr_ e, ast_fold fld) -> expr_ {\n             expr_do_while(fld.fold_block(block), fld.fold_expr(expr))\n                 }\n         case (expr_alt(?expr, ?arms)) {\n-            expr_alt(fld.fold_expr(expr), map(fld.fold_arm, arms))\n+            expr_alt(fld.fold_expr(expr), ivec::map(fld.fold_arm, arms))\n                 }\n         case (expr_fn(?f)) {\n             expr_fn(fld.fold_fn(f))\n@@ -404,7 +405,7 @@ fn noop_fold_expr(&expr_ e, ast_fold fld) -> expr_ {\n             expr_path(fld.fold_path(pth))\n                 }\n         case (expr_ext(?pth, ?args, ?body, ?expanded)) {\n-            expr_ext(fld.fold_path(pth), map(fld.fold_expr, args),\n+            expr_ext(fld.fold_path(pth), ivec::map(fld.fold_expr, args),\n                      body, fld.fold_expr(expanded))\n                 }\n         case (expr_fail(_)) { e }\n@@ -450,7 +451,7 @@ fn noop_fold_constr(&constr_ c, ast_fold fld) -> constr_ {\n fn noop_fold_fn(&_fn f, ast_fold fld) -> _fn {\n     auto fold_arg = bind fold_arg_(_, fld);\n \n-    ret rec(decl= rec(inputs=vec::map(fold_arg, f.decl.inputs),\n+    ret rec(decl= rec(inputs=ivec::map(fold_arg, f.decl.inputs),\n                       output=fld.fold_ty(f.decl.output),\n                       purity=f.decl.purity,\n                       cf=f.decl.cf,"}, {"sha": "455d95e0f93063e7b075666613389d085529c04c", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 62, "deletions": 60, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -260,7 +260,7 @@ fn parse_ty_fn(ast::proto proto, &parser p, uint lo) -> ast::ty_ {\n     auto inputs =\n         parse_seq_ivec(token::LPAREN, token::RPAREN, some(token::COMMA),\n                        parse_fn_input_ty, p);\n-    auto constrs = parse_constrs([], p);\n+    auto constrs = parse_constrs(~[], p);\n     let @ast::ty output;\n     auto cf = ast::return;\n     if (p.peek() == token::RARROW) {\n@@ -329,13 +329,13 @@ fn parse_ty_field(&parser p) -> ast::ty_field {\n \n // if i is the jth ident in args, return j\n // otherwise, fail\n-fn ident_index(&parser p, &vec[ast::arg] args, &ast::ident i) -> uint {\n+fn ident_index(&parser p, &ast::arg[] args, &ast::ident i) -> uint {\n     auto j = 0u;\n     for (ast::arg a in args) { if (a.ident == i) { ret j; } j += 1u; }\n     p.fatal(\"Unbound variable \" + i + \" in constraint arg\");\n }\n \n-fn parse_constr_arg(vec[ast::arg] args, &parser p) -> @ast::constr_arg {\n+fn parse_constr_arg(&ast::arg[] args, &parser p) -> @ast::constr_arg {\n     auto sp = p.get_span();\n     auto carg = ast::carg_base;\n     if (p.peek() == token::BINOP(token::STAR)) {\n@@ -347,7 +347,7 @@ fn parse_constr_arg(vec[ast::arg] args, &parser p) -> @ast::constr_arg {\n     ret @rec(node=carg, span=sp);\n }\n \n-fn parse_ty_constr(&vec[ast::arg] fn_args, &parser p) -> @ast::constr {\n+fn parse_ty_constr(&ast::arg[] fn_args, &parser p) -> @ast::constr {\n     auto lo = p.get_lo_pos();\n     auto path = parse_path(p);\n     auto pf = bind parse_constr_arg(fn_args, _);\n@@ -364,7 +364,7 @@ fn parse_ty_constr(&vec[ast::arg] fn_args, &parser p) -> @ast::constr {\n // Use the args list to translate each bound variable \n // mentioned in a constraint to an arg index.\n // Seems weird to do this in the parser, but I'm not sure how else to.\n-fn parse_constrs(&vec[ast::arg] args, &parser p)\n+fn parse_constrs(&ast::arg[] args, &parser p)\n         -> ast::spanned[(@ast::constr)[]] {\n     auto lo = p.get_lo_pos();\n     auto hi = p.get_hi_pos();\n@@ -383,7 +383,7 @@ fn parse_constrs(&vec[ast::arg] args, &parser p)\n \n fn parse_ty_constrs(@ast::ty t, &parser p) -> @ast::ty {\n     if (p.peek() == token::COLON) {\n-        auto constrs = parse_constrs([], p);\n+        auto constrs = parse_constrs(~[], p);\n         ret @spanned(t.span.lo, constrs.span.hi,\n                      ast::ty_constr(t, constrs.node));\n     }\n@@ -776,16 +776,16 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n             ret rec(mut=m, expr=e);\n         }\n         auto es =\n-            parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n-                      parse_elt, p);\n+            parse_seq_ivec(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                           parse_elt, p);\n         hi = es.span.hi;\n         ex = ast::expr_tup(es.node);\n     } else if (p.peek() == token::LBRACKET) {\n         p.bump();\n         auto mut = parse_mutability(p);\n         auto es =\n-            parse_seq_to_end(token::RBRACKET, some(token::COMMA), parse_expr,\n-                             p);\n+            parse_seq_to_end_ivec(token::RBRACKET, some(token::COMMA),\n+                                  parse_expr, p);\n         ex = ast::expr_vec(es, mut, ast::sk_rc);\n     } else if (p.peek() == token::TILDE) {\n         p.bump();\n@@ -795,8 +795,8 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n                 p.bump();\n                 auto mut = parse_mutability(p);\n                 auto es =\n-                    parse_seq_to_end(token::RBRACKET, some(token::COMMA),\n-                                     parse_expr, p);\n+                    parse_seq_to_end_ivec(token::RBRACKET, some(token::COMMA),\n+                                          parse_expr, p);\n                 ex = ast::expr_vec(es, mut, ast::sk_unique);\n             }\n             case (token::LIT_STR(?s)) {\n@@ -817,20 +817,22 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         auto ty_params = parse_ty_params(p);\n \n         // Only make people type () if they're actually adding new fields\n-        let option::t[vec[ast::anon_obj_field]] fields = none;\n+        let option::t[ast::anon_obj_field[]] fields = none;\n         if (p.peek() == token::LPAREN) {\n             p.bump();\n             fields =\n-                some(parse_seq_to_end(token::RPAREN, some(token::COMMA),\n-                                      parse_anon_obj_field, p));\n+                some(parse_seq_to_end_ivec(token::RPAREN, some(token::COMMA),\n+                                           parse_anon_obj_field, p));\n         }\n-        let vec[@ast::method] meths = [];\n+        let (@ast::method)[] meths = ~[];\n         let option::t[@ast::expr] with_obj = none;\n         expect(p, token::LBRACE);\n         while (p.peek() != token::RBRACE) {\n             if (eat_word(p, \"with\")) {\n                 with_obj = some(parse_expr(p));\n-            } else { vec::push(meths, parse_method(p)); }\n+            } else {\n+                meths += ~[parse_method(p)];\n+            }\n         }\n         hi = p.get_hi_pos();\n         expect(p, token::RBRACE);\n@@ -845,7 +847,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         ex = ast::expr_anon_obj(ob, ty_params);\n     } else if (eat_word(p, \"rec\")) {\n         expect(p, token::LPAREN);\n-        auto fields = [parse_field(p)];\n+        auto fields = ~[parse_field(p)];\n         auto more = true;\n         auto base = none;\n         while (more) {\n@@ -860,7 +862,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n                 more = false;\n             } else if (p.peek() == token::COMMA) {\n                 p.bump();\n-                fields += [parse_field(p)];\n+                fields += ~[parse_field(p)];\n             } else { unexpected(p, p.peek()); }\n         }\n         ex = ast::expr_rec(fields, base);\n@@ -873,8 +875,8 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n             }\n         }\n         auto es =\n-            parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n-                      parse_expr_opt, p);\n+            parse_seq_ivec(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                           parse_expr_opt, p);\n         hi = es.span.hi;\n         ex = ast::expr_bind(e, es.node);\n     } else if (p.peek() == token::POUND) {\n@@ -969,8 +971,8 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n \n         let @ast::expr f = parse_self_method(p);\n         auto es =\n-            parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n-                      parse_expr, p);\n+            parse_seq_ivec(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                           parse_expr, p);\n         hi = es.span.hi;\n         ex = ast::expr_call(f, es.node);\n     } else if (is_ident(p.peek()) && !is_word(p, \"true\") &&\n@@ -998,8 +1000,8 @@ fn parse_syntax_ext_naked(&parser p, uint lo) -> @ast::expr {\n     if (ivec::len(pth.node.idents) == 0u) {\n         p.fatal(\"expected a syntax expander name\");\n     }\n-    auto es = parse_seq(token::LPAREN, token::RPAREN,\n-                        some(token::COMMA), parse_expr, p);\n+    auto es = parse_seq_ivec(token::LPAREN, token::RPAREN,\n+                             some(token::COMMA), parse_expr, p);\n     auto hi = es.span.hi;\n     auto ext_span = rec(lo=lo, hi=hi);\n     auto ex = expand_syntax_ext(p, ext_span, pth, es.node, none);\n@@ -1013,7 +1015,7 @@ fn parse_syntax_ext_naked(&parser p, uint lo) -> @ast::expr {\n  * loading rust crates to process extensions.\n  */\n fn expand_syntax_ext(&parser p, span sp, &ast::path path,\n-                     vec[@ast::expr] args, option::t[str] body) ->\n+                     &(@ast::expr)[] args, option::t[str] body) ->\n    ast::expr_ {\n     assert (ivec::len(path.node.idents) > 0u);\n     auto extname = path.node.idents.(0);\n@@ -1030,7 +1032,7 @@ fn expand_syntax_ext(&parser p, span sp, &ast::path path,\n             auto name_and_extension = ext(ext_cx, sp, args, body);\n             p.get_syntax_expanders().insert(name_and_extension._0,\n                                             name_and_extension._1);\n-            ret ast::expr_tup(vec::empty[ast::elt]());\n+            ret ast::expr_tup(~[]);\n         }\n     }\n }\n@@ -1057,8 +1059,8 @@ fn parse_dot_or_call_expr_with(&parser p, @ast::expr e) -> @ast::expr {\n                     // Call expr.\n \n                     auto es =\n-                        parse_seq(token::LPAREN, token::RPAREN,\n-                                  some(token::COMMA), parse_expr, p);\n+                        parse_seq_ivec(token::LPAREN, token::RPAREN,\n+                                       some(token::COMMA), parse_expr, p);\n                     hi = es.span.hi;\n                     e = mk_expr(p, lo, hi, ast::expr_call(e, es.node));\n                 }\n@@ -1349,7 +1351,7 @@ fn parse_alt_expr(&parser p) -> @ast::expr {\n     auto lo = p.get_last_lo_pos();\n     auto discriminant = parse_expr(p);\n     expect(p, token::LBRACE);\n-    let vec[ast::arm] arms = [];\n+    let ast::arm[] arms = ~[];\n     while (p.peek() != token::RBRACE) {\n         // Optionally eat the case keyword.\n         // FIXME remove this (and the optional parens) once we've updated our\n@@ -1360,7 +1362,7 @@ fn parse_alt_expr(&parser p) -> @ast::expr {\n         auto pat = parse_pat(p);\n         if (parens) { expect(p, token::RPAREN); }\n         auto block = parse_block(p);\n-        arms += [rec(pat=pat, block=block)];\n+        arms += ~[rec(pat=pat, block=block)];\n     }\n     auto hi = p.get_hi_pos();\n     p.bump();\n@@ -1374,8 +1376,8 @@ fn parse_spawn_expr(&parser p) -> @ast::expr {\n \n     auto fn_expr = parse_bottom_expr(p);\n     auto es =\n-        parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n-                  parse_expr, p);\n+        parse_seq_ivec(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                       parse_expr, p);\n     auto hi = es.span.hi;\n     ret mk_expr(p, lo, hi, ast::expr_spawn\n                 (ast::dom_implicit, option::none, fn_expr, es.node));\n@@ -1449,17 +1451,17 @@ fn parse_pat(&parser p) -> @ast::pat {\n             } else {\n                 auto tag_path = parse_path_and_ty_param_substs(p);\n                 hi = tag_path.span.hi;\n-                let vec[@ast::pat] args;\n+                let (@ast::pat)[] args;\n                 alt (p.peek()) {\n                     case (token::LPAREN) {\n                         auto f = parse_pat;\n                         auto a =\n-                            parse_seq(token::LPAREN, token::RPAREN,\n-                                      some(token::COMMA), f, p);\n+                            parse_seq_ivec(token::LPAREN, token::RPAREN,\n+                                           some(token::COMMA), f, p);\n                         args = a.node;\n                         hi = a.span.hi;\n                     }\n-                    case (_) { args = []; }\n+                    case (_) { args = ~[]; }\n                 }\n                 pat = ast::pat_tag(tag_path, args);\n             }\n@@ -1645,7 +1647,7 @@ fn stmt_ends_with_semi(&ast::stmt stmt) -> bool {\n \n fn parse_block(&parser p) -> ast::block {\n     auto lo = p.get_lo_pos();\n-    let vec[@ast::stmt] stmts = [];\n+    let (@ast::stmt)[] stmts = ~[];\n     let option::t[@ast::expr] expr = none;\n     expect(p, token::LBRACE);\n     while (p.peek() != token::RBRACE) {\n@@ -1658,7 +1660,7 @@ fn parse_block(&parser p) -> ast::block {\n                 alt (stmt_to_expr(stmt)) {\n                     case (some(?e)) {\n                         alt (p.peek()) {\n-                            case (token::SEMI) { p.bump(); stmts += [stmt]; }\n+                            case (token::SEMI) { p.bump(); stmts += ~[stmt]; }\n                             case (token::RBRACE) { expr = some(e); }\n                             case (?t) {\n                                 if (stmt_ends_with_semi(*stmt)) {\n@@ -1668,13 +1670,13 @@ fn parse_block(&parser p) -> ast::block {\n                                                             t));\n                                     fail;\n                                 }\n-                                stmts += [stmt];\n+                                stmts += ~[stmt];\n                             }\n                         }\n                     }\n                     case (none) {\n                         // Not an expression statement.\n-                        stmts += [stmt];\n+                        stmts += ~[stmt];\n \n                         if (p.get_file_type() == SOURCE_FILE\n                             && stmt_ends_with_semi(*stmt)) {\n@@ -1693,20 +1695,20 @@ fn parse_block(&parser p) -> ast::block {\n \n fn parse_ty_param(&parser p) -> ast::ty_param { ret parse_ident(p); }\n \n-fn parse_ty_params(&parser p) -> vec[ast::ty_param] {\n-    let vec[ast::ty_param] ty_params = [];\n+fn parse_ty_params(&parser p) -> ast::ty_param[] {\n+    let ast::ty_param[] ty_params = ~[];\n     if (p.peek() == token::LBRACKET) {\n         ty_params =\n-            parse_seq(token::LBRACKET, token::RBRACKET, some(token::COMMA),\n-                      parse_ty_param, p).node;\n+            parse_seq_ivec(token::LBRACKET, token::RBRACKET,\n+                           some(token::COMMA), parse_ty_param, p).node;\n     }\n     ret ty_params;\n }\n \n fn parse_fn_decl(&parser p, ast::purity purity) -> ast::fn_decl {\n-    let ast::spanned[vec[ast::arg]] inputs =\n-        parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA), parse_arg,\n-                  p);\n+    let ast::spanned[ast::arg[]] inputs =\n+        parse_seq_ivec(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                       parse_arg, p);\n     let ty_or_bang rslt;\n     auto constrs = parse_constrs(inputs.node, p).node;\n     if (p.peek() == token::RARROW) {\n@@ -1740,7 +1742,7 @@ fn parse_fn(&parser p, ast::proto proto, ast::purity purity) -> ast::_fn {\n     ret rec(decl=decl, proto=proto, body=body);\n }\n \n-fn parse_fn_header(&parser p) -> tup(ast::ident, vec[ast::ty_param]) {\n+fn parse_fn_header(&parser p) -> tup(ast::ident, ast::ty_param[]) {\n     auto id = parse_value_ident(p);\n     auto ty_params = parse_ty_params(p);\n     ret tup(id, ty_params);\n@@ -1791,7 +1793,7 @@ fn parse_method(&parser p) -> @ast::method {\n fn parse_dtor(&parser p) -> @ast::method {\n     auto lo = p.get_last_lo_pos();\n     let ast::block b = parse_block(p);\n-    let vec[ast::arg] inputs = [];\n+    let ast::arg[] inputs = ~[];\n     let @ast::ty output = @spanned(lo, lo, ast::ty_nil);\n     let ast::fn_decl d =\n         rec(inputs=inputs,\n@@ -1812,16 +1814,16 @@ fn parse_item_obj(&parser p, ast::layer lyr, &ast::attribute[] attrs) ->\n     auto lo = p.get_last_lo_pos();\n     auto ident = parse_value_ident(p);\n     auto ty_params = parse_ty_params(p);\n-    let ast::spanned[vec[ast::obj_field]] fields =\n-        parse_seq[ast::obj_field](token::LPAREN, token::RPAREN,\n-                                  some(token::COMMA), parse_obj_field, p);\n-    let vec[@ast::method] meths = [];\n+    let ast::spanned[ast::obj_field[]] fields =\n+        parse_seq_ivec(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                       parse_obj_field, p);\n+    let (@ast::method)[] meths = ~[];\n     let option::t[@ast::method] dtor = none;\n     expect(p, token::LBRACE);\n     while (p.peek() != token::RBRACE) {\n         if (eat_word(p, \"drop\")) {\n             dtor = some(parse_dtor(p));\n-        } else { vec::push(meths, parse_method(p)); }\n+        } else { meths += ~[parse_method(p)]; }\n     }\n     auto hi = p.get_hi_pos();\n     expect(p, token::RBRACE);\n@@ -1840,8 +1842,8 @@ fn parse_item_res(&parser p, ast::layer lyr, &ast::attribute[] attrs) ->\n     auto arg_ident = parse_value_ident(p);\n     expect(p, token::RPAREN);\n     auto dtor = parse_block(p);\n-    auto decl = rec(inputs=[rec(mode=ast::alias(false), ty=t, ident=arg_ident,\n-                                id=p.get_id())],\n+    auto decl = rec(inputs=~[rec(mode=ast::alias(false), ty=t,\n+                                 ident=arg_ident, id=p.get_id())],\n                     output=@spanned(lo, lo, ast::ty_nil),\n                     purity=ast::impure_fn,\n                     cf=ast::return,\n@@ -2015,7 +2017,7 @@ fn parse_item_tag(&parser p, &ast::attribute[] attrs) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto id = parse_ident(p);\n     auto ty_params = parse_ty_params(p);\n-    let vec[ast::variant] variants = [];\n+    let ast::variant[] variants = ~[];\n     // Newtype syntax\n     if (p.peek() == token::EQ) {\n         if (p.get_bad_expr_words().contains_key(id)) {\n@@ -2029,7 +2031,7 @@ fn parse_item_tag(&parser p, &ast::attribute[] attrs) -> @ast::item {\n                                    args=[rec(ty=ty, id=p.get_id())],\n                                    id=p.get_id()));\n         ret mk_item(p, lo, ty.span.hi, id,\n-                    ast::item_tag([variant], ty_params), attrs);\n+                    ast::item_tag(~[variant], ty_params), attrs);\n     }\n     expect(p, token::LBRACE);\n     while (p.peek() != token::RBRACE) {\n@@ -2058,7 +2060,7 @@ fn parse_item_tag(&parser p, &ast::attribute[] attrs) -> @ast::item {\n                     rec(name=p.get_str(name),\n                         args=args,\n                         id=p.get_id());\n-                variants += [spanned(vlo, vhi, vr)];\n+                variants += ~[spanned(vlo, vhi, vr)];\n             }\n             case (token::RBRACE) {/* empty */ }\n             case (_) {"}, {"sha": "82d198f307ad7dd7b824a53de2d596bfa72dd945", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -103,7 +103,7 @@ fn item_to_str(&@ast::item i) -> str { be to_str(i, print_item); }\n \n fn path_to_str(&ast::path p) -> str { be to_str(p, print_path); }\n \n-fn fun_to_str(&ast::_fn f, str name, vec[ast::ty_param] params) -> str {\n+fn fun_to_str(&ast::_fn f, str name, &ast::ty_param[] params) -> str {\n     auto writer = io::string_writer();\n     auto s = rust_printer(writer.get_writer());\n     print_fn(s, f.decl, f.proto, name, params);\n@@ -257,9 +257,9 @@ fn commasep_cmnt_ivec[IN](&ps s, breaks b, &IN[] elts, fn(&ps, &IN)  op,\n     end(s);\n }\n \n-fn commasep_exprs(&ps s, breaks b, vec[@ast::expr] exprs) {\n+fn commasep_exprs(&ps s, breaks b, &(@ast::expr)[] exprs) {\n     fn expr_span(&@ast::expr expr) -> codemap::span { ret expr.span; }\n-    commasep_cmnt(s, b, exprs, print_expr, expr_span);\n+    commasep_cmnt_ivec(s, b, exprs, print_expr, expr_span);\n }\n \n fn print_mod(&ps s, ast::_mod _mod, &ast::attribute[] attrs) {\n@@ -463,7 +463,7 @@ fn print_item(&ps s, &@ast::item item) {\n             break_offset(s.s, 0u, 0);\n         }\n         case (ast::item_tag(?variants, ?params)) {\n-            auto newtype = vec::len(variants) == 1u &&\n+            auto newtype = ivec::len(variants) == 1u &&\n                 str::eq(item.ident, variants.(0).node.name) &&\n                 vec::len(variants.(0).node.args) == 1u;\n             if (newtype) {\n@@ -515,12 +515,13 @@ fn print_item(&ps s, &@ast::item item) {\n                 end(s);\n             }\n             fn get_span(&ast::obj_field f) -> codemap::span { ret f.ty.span; }\n-            commasep_cmnt(s, consistent, _obj.fields, print_field, get_span);\n+            commasep_cmnt_ivec(s, consistent, _obj.fields, print_field,\n+                               get_span);\n             pclose(s);\n             space(s.s);\n             bopen(s);\n             for (@ast::method meth in _obj.methods) {\n-                let vec[ast::ty_param] typarams = [];\n+                let ast::ty_param[] typarams = ~[];\n                 hardbreak_if_not_bol(s);\n                 maybe_print_comment(s, meth.span.lo);\n                 print_fn(s, meth.node.meth.decl, meth.node.meth.proto,\n@@ -687,7 +688,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             fn get_span(&ast::elt elt) -> codemap::span { ret elt.expr.span; }\n             word(s.s, \"tup\");\n             popen(s);\n-            commasep_cmnt(s, inconsistent, exprs, printElt, get_span);\n+            commasep_cmnt_ivec(s, inconsistent, exprs, printElt, get_span);\n             pclose(s);\n         }\n         case (ast::expr_rec(?fields, ?wth)) {\n@@ -704,10 +705,10 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             }\n             word(s.s, \"rec\");\n             popen(s);\n-            commasep_cmnt(s, consistent, fields, print_field, get_span);\n+            commasep_cmnt_ivec(s, consistent, fields, print_field, get_span);\n             alt (wth) {\n                 case (some(?expr)) {\n-                    if (vec::len(fields) > 0u) { space(s.s); }\n+                    if (ivec::len(fields) > 0u) { space(s.s); }\n                     ibox(s, indent_unit);\n                     word_space(s, \"with\");\n                     print_expr(s, expr);\n@@ -737,7 +738,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n             word_nbsp(s, \"bind\");\n             print_expr(s, func);\n             popen(s);\n-            commasep(s, inconsistent, args, print_opt);\n+            commasep_ivec(s, inconsistent, args, print_opt);\n             pclose(s);\n         }\n         case (ast::expr_spawn(_, _, ?e, ?es)) {\n@@ -959,7 +960,7 @@ fn print_expr(&ps s, &@ast::expr expr) {\n         case (ast::expr_ext(?path, ?args, ?body, _)) {\n             word(s.s, \"#\");\n             print_path(s, path);\n-            if (vec::len(args) > 0u) {\n+            if (ivec::len(args) > 0u) {\n                 popen(s);\n                 commasep_exprs(s, inconsistent, args);\n                 pclose(s);\n@@ -1062,9 +1063,9 @@ fn print_pat(&ps s, &@ast::pat pat) {\n         case (ast::pat_lit(?lit)) { print_literal(s, lit); }\n         case (ast::pat_tag(?path, ?args)) {\n             print_path(s, path);\n-            if (vec::len(args) > 0u) {\n+            if (ivec::len(args) > 0u) {\n                 popen(s);\n-                commasep(s, inconsistent, args, print_pat);\n+                commasep_ivec(s, inconsistent, args, print_pat);\n                 pclose(s);\n             }\n         }\n@@ -1073,7 +1074,7 @@ fn print_pat(&ps s, &@ast::pat pat) {\n }\n \n fn print_fn(&ps s, ast::fn_decl decl, ast::proto proto, str name,\n-            vec[ast::ty_param] typarams) {\n+            &ast::ty_param[] typarams) {\n     alt (decl.purity) {\n         case (ast::impure_fn) {\n             if (proto == ast::proto_iter) {\n@@ -1097,7 +1098,7 @@ fn print_fn_args_and_ret(&ps s, &ast::fn_decl decl) {\n         word(s.s, x.ident);\n         end(s);\n     }\n-    commasep(s, inconsistent, decl.inputs, print_arg);\n+    commasep_ivec(s, inconsistent, decl.inputs, print_arg);\n     pclose(s);\n     maybe_print_comment(s, decl.output.span.lo);\n     if (decl.output.node != ast::ty_nil) {\n@@ -1115,11 +1116,11 @@ fn print_alias(&ps s, ast::mode m) {\n     }\n }\n \n-fn print_type_params(&ps s, &vec[ast::ty_param] params) {\n-    if (vec::len(params) > 0u) {\n+fn print_type_params(&ps s, &ast::ty_param[] params) {\n+    if (ivec::len(params) > 0u) {\n         word(s.s, \"[\");\n         fn printParam(&ps s, &ast::ty_param param) { word(s.s, param); }\n-        commasep(s, inconsistent, params, printParam);\n+        commasep_ivec(s, inconsistent, params, printParam);\n         word(s.s, \"]\");\n     }\n }"}, {"sha": "076a81b4260af47be761396a2acedd57111db003", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -33,7 +33,7 @@ type visitor[E] =\n          fn(&@expr, &E, &vt[E])  visit_expr,\n          fn(&@ty, &E, &vt[E])  visit_ty,\n          fn(&@constr, &E, &vt[E])  visit_constr,\n-         fn(&_fn, &vec[ty_param], &span, &fn_ident, node_id, &E, &vt[E])\n+         fn(&_fn, &ty_param[], &span, &fn_ident, node_id, &E, &vt[E])\n              visit_fn);\n \n fn default_visitor[E]() -> visitor[E] {\n@@ -121,13 +121,13 @@ fn visit_item[E](&@item i, &E e, &vt[E] v) {\n         case (item_obj(?ob, _, _)) {\n             for (obj_field f in ob.fields) { vt(v).visit_ty(f.ty, e, v); }\n             for (@method m in ob.methods) {\n-                vt(v).visit_fn(m.node.meth, [], m.span, some(m.node.ident),\n+                vt(v).visit_fn(m.node.meth, ~[], m.span, some(m.node.ident),\n                                m.node.id, e, v);\n             }\n             alt (ob.dtor) {\n                 case (none) { }\n                 case (some(?m)) {\n-                    vt(v).visit_fn(m.node.meth, [], m.span,\n+                    vt(v).visit_fn(m.node.meth, ~[], m.span,\n                                    some(m.node.ident),\n                                    m.node.id, e, v);\n                 }\n@@ -210,7 +210,7 @@ fn visit_fn_decl[E](&fn_decl fd, &E e, &vt[E] v) {\n     vt(v).visit_ty(fd.output, e, v);\n }\n \n-fn visit_fn[E](&_fn f, &vec[ty_param] tp, &span sp, &fn_ident i,\n+fn visit_fn[E](&_fn f, &ty_param[] tp, &span sp, &fn_ident i,\n                node_id id, &E e, &vt[E] v) {\n     visit_fn_decl(f.decl, e, v);\n     vt(v).visit_block(f.body, e, v);\n@@ -245,7 +245,7 @@ fn visit_expr_opt[E](option::t[@expr] eo, &E e, &vt[E] v) {\n     }\n }\n \n-fn visit_exprs[E](vec[@expr] exprs, &E e, &vt[E] v) {\n+fn visit_exprs[E](&(@expr)[] exprs, &E e, &vt[E] v) {\n     for (@expr ex in exprs) { vt(v).visit_expr(ex, e, v); }\n }\n \n@@ -320,7 +320,7 @@ fn visit_expr[E](&@expr ex, &E e, &vt[E] v) {\n             for (arm a in arms) { vt(v).visit_arm(a, e, v); }\n         }\n         case (expr_fn(?f)) {\n-            vt(v).visit_fn(f, [], ex.span, none, ex.id, e, v);\n+            vt(v).visit_fn(f, ~[], ex.span, none, ex.id, e, v);\n         }\n         case (expr_block(?b)) { vt(v).visit_block(b, e, v); }\n         case (expr_assign(?a, ?b)) {\n@@ -386,7 +386,7 @@ fn visit_expr[E](&@expr ex, &E e, &vt[E] v) {\n                 case (some(?ex)) { vt(v).visit_expr(ex, e, v); }\n             }\n             for (@method m in anon_obj.methods) {\n-                vt(v).visit_fn(m.node.meth, [], m.span, some(m.node.ident),\n+                vt(v).visit_fn(m.node.meth, ~[], m.span, some(m.node.ident),\n                                m.node.id, e, v);\n             }\n         }"}, {"sha": "59d7d75a7de7244102d6eed883d3be6683e6d432", "filename": "src/comp/syntax/walk.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fsyntax%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Fsyntax%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fwalk.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -39,9 +39,9 @@ type ast_visitor =\n         fn(&@ast::ty)  visit_ty_pre,\n         fn(&@ast::ty)  visit_ty_post,\n         fn(&@ast::constr)  visit_constr,\n-        fn(&ast::_fn, &vec[ast::ty_param], &span, &ast::fn_ident,\n+        fn(&ast::_fn, &ast::ty_param[], &span, &ast::fn_ident,\n            ast::node_id) visit_fn_pre,\n-        fn(&ast::_fn, &vec[ast::ty_param], &span, &ast::fn_ident,\n+        fn(&ast::_fn, &ast::ty_param[], &span, &ast::fn_ident,\n            ast::node_id) visit_fn_post);\n \n fn walk_crate(&ast_visitor v, &ast::crate c) {\n@@ -117,14 +117,14 @@ fn walk_item(&ast_visitor v, @ast::item i) {\n             for (@ast::method m in ob.methods) {\n                 v.visit_method_pre(m);\n                 // Methods don't have ty params?\n-                walk_fn(v, m.node.meth, [], m.span,\n+                walk_fn(v, m.node.meth, ~[], m.span,\n                         some(m.node.ident), m.node.id);\n                 v.visit_method_post(m);\n             }\n             alt (ob.dtor) {\n                 case (none) { }\n                 case (some(?m)) {\n-                    walk_fn(v, m.node.meth, [], m.span,\n+                    walk_fn(v, m.node.meth, ~[], m.span,\n                             some(m.node.ident), m.node.id);\n                 }\n             }\n@@ -218,7 +218,7 @@ fn walk_fn_decl(&ast_visitor v, &ast::fn_decl fd) {\n     walk_ty(v, fd.output);\n }\n \n-fn walk_fn(&ast_visitor v, &ast::_fn f, &vec[ast::ty_param] tps,\n+fn walk_fn(&ast_visitor v, &ast::_fn f, &ast::ty_param[] tps,\n            &span sp, &ast::fn_ident i, ast::node_id d) {\n     if (!v.keep_going()) { ret; }\n     v.visit_fn_pre(f, tps, sp, i, d);\n@@ -262,7 +262,7 @@ fn walk_expr_opt(&ast_visitor v, option::t[@ast::expr] eo) {\n     alt (eo) { case (none) { } case (some(?e)) { walk_expr(v, e); } }\n }\n \n-fn walk_exprs(&ast_visitor v, vec[@ast::expr] exprs) {\n+fn walk_exprs(&ast_visitor v, &(@ast::expr)[] exprs) {\n     for (@ast::expr e in exprs) { walk_expr(v, e); }\n }\n \n@@ -341,7 +341,7 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n             }\n         }\n         case (ast::expr_fn(?f)) {\n-            walk_fn(v, f, [], e.span, none, e.id);\n+            walk_fn(v, f, ~[], e.span, none, e.id);\n         }\n         case (ast::expr_block(?b)) { walk_block(v, b); }\n         case (ast::expr_assign(?a, ?b)) {\n@@ -402,7 +402,7 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n             // Methods\n             for (@ast::method m in anon_obj.methods) {\n                 v.visit_method_pre(m);\n-                walk_fn(v, m.node.meth, [], m.span, some(m.node.ident),\n+                walk_fn(v, m.node.meth, ~[], m.span, some(m.node.ident),\n                         m.node.id);\n                 v.visit_method_post(m);\n             }\n@@ -445,7 +445,7 @@ fn def_visit_ty(&@ast::ty t) { }\n \n fn def_visit_constr(&@ast::constr c) { }\n \n-fn def_visit_fn(&ast::_fn f, &vec[ast::ty_param] tps,\n+fn def_visit_fn(&ast::_fn f, &ast::ty_param[] tps,\n   &span sp, &ast::fn_ident i, ast::node_id d) { }\n \n fn default_visitor() -> ast_visitor {"}, {"sha": "04243a204c966472ef463e8be5ce55973690ee2d", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2fff53375eba748b6d6727f69a2560f96bc8ec/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=0e2fff53375eba748b6d6727f69a2560f96bc8ec", "patch": "@@ -50,16 +50,18 @@ fn new_def_hash[V]() -> std::map::hashmap[ast::def_id, V] {\n \n fn elt_expr(&ast::elt e) -> @ast::expr { ret e.expr; }\n \n-fn elt_exprs(&vec[ast::elt] elts) -> vec[@ast::expr] {\n-    auto f = elt_expr;\n-    ret vec::map[ast::elt, @ast::expr](f, elts);\n+fn elt_exprs(&ast::elt[] elts) -> (@ast::expr)[] {\n+    auto es = ~[];\n+    for (ast::elt e in elts) { es += ~[e.expr]; }\n+    ret es;\n }\n \n fn field_expr(&ast::field f) -> @ast::expr { ret f.node.expr; }\n \n-fn field_exprs(vec[ast::field] fields) -> vec[@ast::expr] {\n-    auto f = field_expr;\n-    ret vec::map[ast::field, @ast::expr](f, fields);\n+fn field_exprs(&ast::field[] fields) -> (@ast::expr)[] {\n+    auto es = ~[];\n+    for (ast::field f in fields) { es += ~[f.node.expr]; }\n+    ret es;\n }\n \n fn log_expr(&ast::expr e) { log print::pprust::expr_to_str(@e); }\n@@ -76,11 +78,11 @@ fn log_block_err(&ast::block b) { log_err print::pprust::block_to_str(b); }\n \n fn log_item_err(&@ast::item i) { log_err print::pprust::item_to_str(i); }\n \n-fn log_fn(&ast::_fn f, str name, vec[ast::ty_param] params) {\n+fn log_fn(&ast::_fn f, str name, &ast::ty_param[] params) {\n     log print::pprust::fun_to_str(f, name, params);\n }\n \n-fn log_fn_err(&ast::_fn f, str name, vec[ast::ty_param] params) {\n+fn log_fn_err(&ast::_fn f, str name, &ast::ty_param[] params) {\n     log_err print::pprust::fun_to_str(f, name, params);\n }\n "}]}