{"sha": "34c58e897fc6336e31da9c7d6301a1c3520a5cde", "node_id": "C_kwDOAAsO6NoAKDM0YzU4ZTg5N2ZjNjMzNmUzMWRhOWM3ZDYzMDFhMWMzNTIwYTVjZGU", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-12-05T17:19:18Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-12-06T09:33:34Z"}, "message": "Stacked Borrows: factor the logic determining the new permissions on retag into a separate function", "tree": {"sha": "5d172a35029be7f78e5bcd7089346739a13501e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d172a35029be7f78e5bcd7089346739a13501e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34c58e897fc6336e31da9c7d6301a1c3520a5cde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34c58e897fc6336e31da9c7d6301a1c3520a5cde", "html_url": "https://github.com/rust-lang/rust/commit/34c58e897fc6336e31da9c7d6301a1c3520a5cde", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34c58e897fc6336e31da9c7d6301a1c3520a5cde/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9397ea136851ebe5d03ba64a50f6ea3171dc210f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9397ea136851ebe5d03ba64a50f6ea3171dc210f", "html_url": "https://github.com/rust-lang/rust/commit/9397ea136851ebe5d03ba64a50f6ea3171dc210f"}], "stats": {"total": 354, "additions": 187, "deletions": 167}, "files": [{"sha": "24b3489e0d1d67e61503017feb699a39bfc0b7f7", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34c58e897fc6336e31da9c7d6301a1c3520a5cde/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c58e897fc6336e31da9c7d6301a1c3520a5cde/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs?ref=34c58e897fc6336e31da9c7d6301a1c3520a5cde", "patch": "@@ -459,10 +459,10 @@ impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n             Operation::Dealloc(_) => format!(\" due to deallocation\"),\n             Operation::Access(AccessOp { kind, tag, .. }) =>\n                 format!(\" due to {kind:?} access for {tag:?}\"),\n-            Operation::Retag(RetagOp { orig_tag, permission, .. }) => {\n+            Operation::Retag(RetagOp { orig_tag, permission, new_tag, .. }) => {\n                 let permission = permission\n                     .expect(\"start_grant should set the current permission before popping a tag\");\n-                format!(\" due to {permission:?} retag from {orig_tag:?}\")\n+                format!(\" due to {permission:?} retag from {orig_tag:?} (that retag created {new_tag:?})\")\n             }\n         };\n "}, {"sha": "ffbc00864022f4c642d6d9ec6c41f75628d874e4", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/mod.rs", "status": "modified", "additions": 180, "deletions": 160, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/34c58e897fc6336e31da9c7d6301a1c3520a5cde/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c58e897fc6336e31da9c7d6301a1c3520a5cde/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs?ref=34c58e897fc6336e31da9c7d6301a1c3520a5cde", "patch": "@@ -1,13 +1,13 @@\n //! Implements \"Stacked Borrows\".  See <https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md>\n //! for further information.\n \n+pub mod diagnostics;\n mod item;\n mod stack;\n-pub mod diagnostics;\n \n use log::trace;\n use std::cmp;\n-use std::fmt::{self, Write};\n+use std::fmt::Write;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_middle::mir::{Mutability, RetagKind};\n@@ -23,9 +23,9 @@ use crate::borrow_tracker::{\n };\n use crate::*;\n \n+use diagnostics::RetagCause;\n pub use item::{Item, Permission};\n pub use stack::Stack;\n-use diagnostics::RetagCause;\n \n pub type AllocState = Stacks;\n \n@@ -42,30 +42,104 @@ pub struct Stacks {\n     modified_since_last_gc: bool,\n }\n \n-/// Indicates which kind of reference is being created.\n-/// Used by high-level `reborrow` to compute which permissions to grant to the\n-/// new pointer.\n-#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n-enum RefKind {\n-    /// `Box`.\n-    Box,\n-    /// `&mut`.\n-    Unique { two_phase: bool },\n-    /// `&` with or without interior mutability.\n-    Shared,\n-    /// `*mut`/`*const` (raw pointers).\n-    Raw { mutable: bool },\n+/// Indicates which permissions to grant to the retagged pointer.\n+#[derive(Clone, Debug)]\n+enum NewPermission {\n+    Uniform {\n+        perm: Permission,\n+        access: Option<AccessKind>,\n+        protector: Option<ProtectorKind>,\n+    },\n+    FreezeSensitive {\n+        freeze_perm: Permission,\n+        freeze_access: Option<AccessKind>,\n+        freeze_protector: Option<ProtectorKind>,\n+        nonfreeze_perm: Permission,\n+        nonfreeze_access: Option<AccessKind>,\n+        // nonfreeze_protector must always be None\n+    },\n }\n \n-impl fmt::Display for RefKind {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+impl NewPermission {\n+    /// A key function: determine the permissions to grant at a retag for the given kind of\n+    /// reference/pointer.\n+    fn from_ref_ty<'tcx>(\n+        ty: ty::Ty<'tcx>,\n+        kind: RetagKind,\n+        cx: &crate::MiriInterpCx<'_, 'tcx>,\n+    ) -> Self {\n+        let protector = (kind == RetagKind::FnEntry).then_some(ProtectorKind::StrongProtector);\n+        match ty.kind() {\n+            ty::Ref(_, pointee, Mutability::Mut) => {\n+                if kind == RetagKind::TwoPhase {\n+                    // We mostly just give up on 2phase-borrows, and treat these exactly like raw pointers.\n+                    assert!(protector.is_none()); // RetagKind can't be both FnEntry and TwoPhase.\n+                    NewPermission::Uniform {\n+                        perm: Permission::SharedReadWrite,\n+                        access: None,\n+                        protector: None,\n+                    }\n+                } else if pointee.is_unpin(*cx.tcx, cx.param_env()) {\n+                    // A regular full mutable reference.\n+                    NewPermission::Uniform {\n+                        perm: Permission::Unique,\n+                        access: Some(AccessKind::Write),\n+                        protector,\n+                    }\n+                } else {\n+                    NewPermission::Uniform {\n+                        perm: Permission::SharedReadWrite,\n+                        // FIXME: We emit `dereferenceable` for `!Unpin` mutable references, so we\n+                        // should do fake accesses here. But then we run into\n+                        // <https://github.com/rust-lang/unsafe-code-guidelines/issues/381>, so for now\n+                        // we don't do that.\n+                        access: None,\n+                        protector,\n+                    }\n+                }\n+            }\n+            ty::RawPtr(ty::TypeAndMut { mutbl: Mutability::Mut, .. }) => {\n+                assert!(protector.is_none()); // RetagKind can't be both FnEntry and Raw.\n+                // Mutable raw pointer. No access, not protected.\n+                NewPermission::Uniform {\n+                    perm: Permission::SharedReadWrite,\n+                    access: None,\n+                    protector: None,\n+                }\n+            }\n+            ty::Ref(_, _pointee, Mutability::Not) => {\n+                NewPermission::FreezeSensitive {\n+                    freeze_perm: Permission::SharedReadOnly,\n+                    freeze_access: Some(AccessKind::Read),\n+                    freeze_protector: protector,\n+                    nonfreeze_perm: Permission::SharedReadWrite,\n+                    // Inside UnsafeCell, this does *not* count as an access, as there\n+                    // might actually be mutable references further up the stack that\n+                    // we have to keep alive.\n+                    nonfreeze_access: None,\n+                    // We do not protect inside UnsafeCell.\n+                    // This fixes https://github.com/rust-lang/rust/issues/55005.\n+                }\n+            }\n+            ty::RawPtr(ty::TypeAndMut { mutbl: Mutability::Not, .. }) => {\n+                assert!(protector.is_none()); // RetagKind can't be both FnEntry and Raw.\n+                // `*const T`, when freshly created, are read-only in the frozen part.\n+                NewPermission::FreezeSensitive {\n+                    freeze_perm: Permission::SharedReadOnly,\n+                    freeze_access: Some(AccessKind::Read),\n+                    freeze_protector: None,\n+                    nonfreeze_perm: Permission::SharedReadWrite,\n+                    nonfreeze_access: None,\n+                }\n+            }\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    fn protector(&self) -> Option<ProtectorKind> {\n         match self {\n-            RefKind::Box => write!(f, \"Box\"),\n-            RefKind::Unique { two_phase: false } => write!(f, \"unique reference\"),\n-            RefKind::Unique { two_phase: true } => write!(f, \"unique reference (two-phase)\"),\n-            RefKind::Shared => write!(f, \"shared reference\"),\n-            RefKind::Raw { mutable: true } => write!(f, \"raw (mutable) pointer\"),\n-            RefKind::Raw { mutable: false } => write!(f, \"raw (constant) pointer\"),\n+            NewPermission::Uniform { protector, .. } => *protector,\n+            NewPermission::FreezeSensitive { freeze_protector, .. } => *freeze_protector,\n         }\n     }\n }\n@@ -520,10 +594,9 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         &mut self,\n         place: &MPlaceTy<'tcx, Provenance>,\n         size: Size,\n-        kind: RefKind,\n-        retag_cause: RetagCause, // What caused this retag, for diagnostics only\n+        new_perm: NewPermission,\n         new_tag: BorTag,\n-        protect: Option<ProtectorKind>,\n+        retag_cause: RetagCause, // What caused this retag, for diagnostics only\n     ) -> InterpResult<'tcx, Option<AllocId>> {\n         let this = self.eval_context_mut();\n \n@@ -534,20 +607,16 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n             let global = this.machine.borrow_tracker.as_ref().unwrap().borrow();\n             let ty = place.layout.ty;\n             if global.tracked_pointer_tags.contains(&new_tag) {\n-                let mut kind_str = format!(\"{kind}\");\n-                match kind {\n-                    RefKind::Unique { two_phase: false }\n-                        if !ty.is_unpin(*this.tcx, this.param_env()) =>\n-                    {\n-                        write!(kind_str, \" (!Unpin pointee type {ty})\").unwrap()\n-                    },\n-                    RefKind::Shared\n-                        if !ty.is_freeze(*this.tcx, this.param_env()) =>\n-                    {\n-                        write!(kind_str, \" (!Freeze pointee type {ty})\").unwrap()\n-                    },\n-                    _ => write!(kind_str, \" (pointee type {ty})\").unwrap(),\n-                };\n+                let mut kind_str = String::new();\n+                match new_perm {\n+                    NewPermission::Uniform { perm, .. } =>\n+                        write!(kind_str, \"{perm:?} permission\").unwrap(),\n+                    NewPermission::FreezeSensitive { freeze_perm, .. } if ty.is_freeze(*this.tcx, this.param_env()) =>\n+                        write!(kind_str, \"{freeze_perm:?} permission\").unwrap(),\n+                    NewPermission::FreezeSensitive { freeze_perm, nonfreeze_perm, .. }  =>\n+                        write!(kind_str, \"{freeze_perm:?}/{nonfreeze_perm:?} permission for frozen/non-frozen parts\").unwrap(),\n+                }\n+                write!(kind_str, \" (pointee type {ty})\").unwrap();\n                 this.emit_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(\n                     new_tag.inner(),\n                     Some(kind_str),\n@@ -581,7 +650,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     );\n                     let mut dcx = dcx.build(&mut stacked_borrows.history, base_offset);\n                     dcx.log_creation();\n-                    if protect.is_some() {\n+                    if new_perm.protector().is_some() {\n                         dcx.log_protector();\n                     }\n                 },\n@@ -594,8 +663,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n \n         if size == Size::ZERO {\n             trace!(\n-                \"reborrow of size 0: {} reference {:?} derived from {:?} (pointee {})\",\n-                kind,\n+                \"reborrow of size 0: reference {:?} derived from {:?} (pointee {})\",\n                 new_tag,\n                 place.ptr,\n                 place.layout.ty,\n@@ -632,16 +700,15 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         }\n \n         trace!(\n-            \"reborrow: {} reference {:?} derived from {:?} (pointee {}): {:?}, size {}\",\n-            kind,\n+            \"reborrow: reference {:?} derived from {:?} (pointee {}): {:?}, size {}\",\n             new_tag,\n             orig_tag,\n             place.layout.ty,\n             Pointer::new(alloc_id, base_offset),\n             size.bytes()\n         );\n \n-        if let Some(protect) = protect {\n+        if let Some(protect) = new_perm.protector() {\n             // See comment in `Stack::item_invalidated` for why we store the tag twice.\n             this.frame_mut().extra.borrow_tracker.as_mut().unwrap().protected_tags.push(new_tag);\n             this.machine\n@@ -653,30 +720,45 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                 .insert(new_tag, protect);\n         }\n \n-        // Update the stacks.\n-        // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n-        // There could be existing unique pointers reborrowed from them that should remain valid!\n-        let (perm, access) = match kind {\n-            RefKind::Unique { two_phase } => {\n-                // Permission is Unique only if the type is `Unpin` and this is not twophase\n-                if !two_phase && place.layout.ty.is_unpin(*this.tcx, this.param_env()) {\n-                    (Permission::Unique, Some(AccessKind::Write))\n-                } else {\n-                    // FIXME: We emit `dereferenceable` for `!Unpin` mutable references, so we\n-                    // should do fake accesses here. But then we run into\n-                    // <https://github.com/rust-lang/unsafe-code-guidelines/issues/381>, so for now\n-                    // we don't do that.\n-                    (Permission::SharedReadWrite, None)\n+        // Update the stacks, according to the new permission information we are given.\n+        match new_perm {\n+            NewPermission::Uniform { perm, access, protector } => {\n+                assert!(perm != Permission::SharedReadOnly);\n+                // Here we can avoid `borrow()` calls because we have mutable references.\n+                // Note that this asserts that the allocation is mutable -- but since we are creating a\n+                // mutable pointer, that seems reasonable.\n+                let (alloc_extra, machine) = this.get_alloc_extra_mut(alloc_id)?;\n+                let stacked_borrows = alloc_extra.borrow_tracker_sb_mut().get_mut();\n+                let item = Item::new(new_tag, perm, protector.is_some());\n+                let range = alloc_range(base_offset, size);\n+                let global = machine.borrow_tracker.as_ref().unwrap().borrow();\n+                let dcx = DiagnosticCxBuilder::retag(\n+                    machine,\n+                    retag_cause,\n+                    new_tag,\n+                    orig_tag,\n+                    alloc_range(base_offset, size),\n+                );\n+                stacked_borrows.for_each(range, dcx, |stack, dcx, exposed_tags| {\n+                    stack.grant(orig_tag, item, access, &global, dcx, exposed_tags)\n+                })?;\n+                drop(global);\n+                if let Some(access) = access {\n+                    assert_eq!(access, AccessKind::Write);\n+                    // Make sure the data race model also knows about this.\n+                    if let Some(data_race) = alloc_extra.data_race.as_mut() {\n+                        data_race.write(alloc_id, range, machine)?;\n+                    }\n                 }\n             }\n-            RefKind::Box => (Permission::Unique, Some(AccessKind::Write)),\n-            RefKind::Raw { mutable: true } => {\n-                // Creating a raw ptr does not count as an access\n-                (Permission::SharedReadWrite, None)\n-            }\n-            RefKind::Shared | RefKind::Raw { mutable: false } => {\n-                // Shared references and *const are a whole different kind of game, the\n-                // permission is not uniform across the entire range!\n+            NewPermission::FreezeSensitive {\n+                freeze_perm,\n+                freeze_access,\n+                freeze_protector,\n+                nonfreeze_perm,\n+                nonfreeze_access,\n+            } => {\n+                // The permission is not uniform across the entire range!\n                 // We need a frozen-sensitive reborrow.\n                 // We have to use shared references to alloc/memory_extra here since\n                 // `visit_freeze_sensitive` needs to access the global state.\n@@ -686,22 +768,12 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     // Adjust range.\n                     range.start += base_offset;\n                     // We are only ever `SharedReadOnly` inside the frozen bits.\n-                    let (perm, access) = if frozen {\n-                        (Permission::SharedReadOnly, Some(AccessKind::Read))\n+                    let (perm, access, protector) = if frozen {\n+                        (freeze_perm, freeze_access, freeze_protector)\n                     } else {\n-                        // Inside UnsafeCell, this does *not* count as an access, as there\n-                        // might actually be mutable references further up the stack that\n-                        // we have to keep alive.\n-                        (Permission::SharedReadWrite, None)\n+                        (nonfreeze_perm, nonfreeze_access, None)\n                     };\n-                    let protected = if frozen {\n-                        protect.is_some()\n-                    } else {\n-                        // We do not protect inside UnsafeCell.\n-                        // This fixes https://github.com/rust-lang/rust/issues/55005.\n-                        false\n-                    };\n-                    let item = Item::new(new_tag, perm, protected);\n+                    let item = Item::new(new_tag, perm, protector.is_some());\n                     let global = this.machine.borrow_tracker.as_ref().unwrap().borrow();\n                     let dcx = DiagnosticCxBuilder::retag(\n                         &this.machine,\n@@ -723,34 +795,6 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                     }\n                     Ok(())\n                 })?;\n-                return Ok(Some(alloc_id));\n-            }\n-        };\n-\n-        // Here we can avoid `borrow()` calls because we have mutable references.\n-        // Note that this asserts that the allocation is mutable -- but since we are creating a\n-        // mutable pointer, that seems reasonable.\n-        let (alloc_extra, machine) = this.get_alloc_extra_mut(alloc_id)?;\n-        let stacked_borrows = alloc_extra.borrow_tracker_sb_mut().get_mut();\n-        let item = Item::new(new_tag, perm, protect.is_some());\n-        let range = alloc_range(base_offset, size);\n-        let global = machine.borrow_tracker.as_ref().unwrap().borrow();\n-        let dcx = DiagnosticCxBuilder::retag(\n-            machine,\n-            retag_cause,\n-            new_tag,\n-            orig_tag,\n-            alloc_range(base_offset, size),\n-        );\n-        stacked_borrows.for_each(range, dcx, |stack, dcx, exposed_tags| {\n-            stack.grant(orig_tag, item, access, &global, dcx, exposed_tags)\n-        })?;\n-        drop(global);\n-        if let Some(access) = access {\n-            assert_eq!(access, AccessKind::Write);\n-            // Make sure the data race model also knows about this.\n-            if let Some(data_race) = alloc_extra.data_race.as_mut() {\n-                data_race.write(alloc_id, range, machine)?;\n             }\n         }\n \n@@ -762,9 +806,8 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n     fn sb_retag_reference(\n         &mut self,\n         val: &ImmTy<'tcx, Provenance>,\n-        kind: RefKind,\n-        retag_cause: RetagCause, // What caused this retag, for diagnostics only\n-        protect: Option<ProtectorKind>,\n+        new_perm: NewPermission,\n+        cause: RetagCause, // What caused this retag, for diagnostics only\n     ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n         let this = self.eval_context_mut();\n         // We want a place for where the ptr *points to*, so we get one.\n@@ -782,7 +825,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         let new_tag = this.machine.borrow_tracker.as_mut().unwrap().get_mut().new_ptr();\n \n         // Reborrow.\n-        let alloc_id = this.sb_reborrow(&place, size, kind, retag_cause, new_tag, protect)?;\n+        let alloc_id = this.sb_reborrow(&place, size, new_perm, new_tag, cause)?;\n \n         // Adjust pointer.\n         let new_place = place.map_provenance(|p| {\n@@ -815,25 +858,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         val: &ImmTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n         let this = self.eval_context_mut();\n-        let ref_kind = match val.layout.ty.kind() {\n-            ty::Ref(_, _, mutbl) => {\n-                match mutbl {\n-                    Mutability::Mut =>\n-                        RefKind::Unique { two_phase: kind == RetagKind::TwoPhase },\n-                    Mutability::Not => RefKind::Shared,\n-                }\n-            }\n-            ty::RawPtr(tym) => {\n-                RefKind::Raw { mutable: tym.mutbl == Mutability::Mut }\n-            }\n-            _ => unreachable!(),\n-        };\n+        let new_perm = NewPermission::from_ref_ty(val.layout.ty, kind, this);\n         let retag_cause = match kind {\n             RetagKind::TwoPhase { .. } => RetagCause::TwoPhase,\n             RetagKind::FnEntry => unreachable!(),\n             RetagKind::Raw | RetagKind::Default => RetagCause::Normal,\n         };\n-        this.sb_retag_reference(&val, ref_kind, retag_cause, None)\n+        this.sb_retag_reference(&val, new_perm, retag_cause)\n     }\n \n     fn sb_retag_place_contents(\n@@ -844,7 +875,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n         let retag_fields = this.machine.borrow_tracker.as_mut().unwrap().get_mut().retag_fields;\n         let retag_cause = match kind {\n-            RetagKind::Raw | RetagKind::TwoPhase { .. } => unreachable!(),\n+            RetagKind::Raw | RetagKind::TwoPhase { .. } => unreachable!(), // these can only happen in `retag_ptr_value`\n             RetagKind::FnEntry => RetagCause::FnEntry,\n             RetagKind::Default => RetagCause::Normal,\n         };\n@@ -863,12 +894,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             fn retag_ptr_inplace(\n                 &mut self,\n                 place: &PlaceTy<'tcx, Provenance>,\n-                ref_kind: RefKind,\n+                new_perm: NewPermission,\n                 retag_cause: RetagCause,\n-                protector: Option<ProtectorKind>,\n             ) -> InterpResult<'tcx> {\n                 let val = self.ecx.read_immediate(&self.ecx.place_to_op(place)?)?;\n-                let val = self.ecx.sb_retag_reference(&val, ref_kind, retag_cause, protector)?;\n+                let val = self.ecx.sb_retag_reference(&val, new_perm, retag_cause)?;\n                 self.ecx.write_immediate(*val, place)?;\n                 Ok(())\n             }\n@@ -885,13 +915,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n             fn visit_box(&mut self, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n                 // Boxes get a weak protectors, since they may be deallocated.\n-                self.retag_ptr_inplace(\n-                    place,\n-                    RefKind::Box,\n-                    self.retag_cause,\n-                    /*protector*/\n-                    (self.kind == RetagKind::FnEntry).then_some(ProtectorKind::WeakProtector),\n-                )\n+                let new_perm = NewPermission::Uniform {\n+                    perm: Permission::Unique,\n+                    access: Some(AccessKind::Write),\n+                    protector: (self.kind == RetagKind::FnEntry)\n+                        .then_some(ProtectorKind::WeakProtector),\n+                };\n+                self.retag_ptr_inplace(place, new_perm, self.retag_cause)\n             }\n \n             fn visit_value(&mut self, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n@@ -905,20 +935,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n                 // Check the type of this value to see what to do with it (retag, or recurse).\n                 match place.layout.ty.kind() {\n-                    ty::Ref(_, _, mutbl) => {\n-                        let ref_kind = match mutbl {\n-                            Mutability::Mut =>\n-                                RefKind::Unique { two_phase: false },\n-                            Mutability::Not => RefKind::Shared,\n-                        };\n-                        self.retag_ptr_inplace(\n-                            place,\n-                            ref_kind,\n-                            self.retag_cause,\n-                            /*protector*/\n-                            (self.kind == RetagKind::FnEntry)\n-                                .then_some(ProtectorKind::StrongProtector),\n-                        )?;\n+                    ty::Ref(..) => {\n+                        let new_perm =\n+                            NewPermission::from_ref_ty(place.layout.ty, self.kind, self.ecx);\n+                        self.retag_ptr_inplace(place, new_perm, self.retag_cause)?;\n                     }\n                     ty::RawPtr(..) => {\n                         // We do *not* want to recurse into raw pointers -- wide raw pointers have\n@@ -972,12 +992,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let ptr_layout = this.layout_of(this.tcx.mk_mut_ptr(return_place.layout.ty))?;\n         let val = ImmTy::from_immediate(return_place.to_ref(this), ptr_layout);\n         // Reborrow it. With protection! That is part of the point.\n-        let val = this.sb_retag_reference(\n-            &val,\n-            RefKind::Unique { two_phase: false },\n-            RetagCause::FnReturn,\n-            /*protector*/ Some(ProtectorKind::StrongProtector),\n-        )?;\n+        let new_perm = NewPermission::Uniform {\n+            perm: Permission::Unique,\n+            access: Some(AccessKind::Write),\n+            protector: Some(ProtectorKind::StrongProtector),\n+        };\n+        let val = this.sb_retag_reference(&val, new_perm, RetagCause::FnReturn)?;\n         // And use reborrowed pointer for return place.\n         let return_place = this.ref_to_mplace(&val)?;\n         this.frame_mut().return_place = return_place.into();"}, {"sha": "d0fb9f9b0b5fe7409878f0c6abd96ebcd74e1975", "filename": "src/tools/miri/src/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34c58e897fc6336e31da9c7d6301a1c3520a5cde/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c58e897fc6336e31da9c7d6301a1c3520a5cde/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs?ref=34c58e897fc6336e31da9c7d6301a1c3520a5cde", "patch": "@@ -63,9 +63,9 @@ impl MachineStopType for TerminationInfo {}\n \n /// Miri specific diagnostics\n pub enum NonHaltingDiagnostic {\n-    /// (new_tag, new_kind, (alloc_id, base_offset, orig_tag))\n+    /// (new_tag, new_perm, (alloc_id, base_offset, orig_tag))\n     ///\n-    /// new_kind is `None` for base tags.\n+    /// new_perm is `None` for base tags.\n     CreatedPointerTag(NonZeroU64, Option<String>, Option<(AllocId, AllocRange, ProvenanceExtra)>),\n     /// This `Item` was popped from the borrow stack. The string explains the reason.\n     PoppedPointerTag(Item, String),\n@@ -393,10 +393,10 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n \n         let msg = match &e {\n             CreatedPointerTag(tag, None, _) => format!(\"created base tag {tag:?}\"),\n-            CreatedPointerTag(tag, Some(kind), None) => format!(\"created {tag:?} for {kind}\"),\n-            CreatedPointerTag(tag, Some(kind), Some((alloc_id, range, orig_tag))) =>\n+            CreatedPointerTag(tag, Some(perm), None) => format!(\"created {tag:?} with {perm} derived from unknown tag\"),\n+            CreatedPointerTag(tag, Some(perm), Some((alloc_id, range, orig_tag))) =>\n                 format!(\n-                    \"created tag {tag:?} for {kind} at {alloc_id:?}{range:?} derived from {orig_tag:?}\"\n+                    \"created tag {tag:?} with {perm} at {alloc_id:?}{range:?} derived from {orig_tag:?}\"\n                 ),\n             PoppedPointerTag(item, cause) => format!(\"popped tracked tag for item {item:?}{cause}\"),\n             CreatedCallId(id) => format!(\"function call with id {id}\"),"}]}