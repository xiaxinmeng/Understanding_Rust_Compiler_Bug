{"sha": "f1f453cf3b124711b2e20315937403d89913bcd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxZjQ1M2NmM2IxMjQ3MTFiMmUyMDMxNTkzNzQwM2Q4OTkxM2JjZDI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-25T08:55:44Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-06-05T11:41:02Z"}, "message": "trans: generalize OperandValue::FatPtr to all pairs of immediates.", "tree": {"sha": "a63d32314e952de2106cbf876855aefeecf98e8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a63d32314e952de2106cbf876855aefeecf98e8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1f453cf3b124711b2e20315937403d89913bcd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1f453cf3b124711b2e20315937403d89913bcd2", "html_url": "https://github.com/rust-lang/rust/commit/f1f453cf3b124711b2e20315937403d89913bcd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1f453cf3b124711b2e20315937403d89913bcd2/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "156b1fb9e15f63a8525e934a6857c37823b49c0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/156b1fb9e15f63a8525e934a6857c37823b49c0e", "html_url": "https://github.com/rust-lang/rust/commit/156b1fb9e15f63a8525e934a6857c37823b49c0e"}], "stats": {"total": 329, "additions": 238, "deletions": 91}, "files": [{"sha": "884833ca79a2fec425e1fefbd45b983f06993137", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f1f453cf3b124711b2e20315937403d89913bcd2/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f453cf3b124711b2e20315937403d89913bcd2/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=f1f453cf3b124711b2e20315937403d89913bcd2", "patch": "@@ -39,6 +39,7 @@ use monomorphize;\n use type_::Type;\n use value::Value;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::layout::Layout;\n use rustc::traits::{self, SelectionContext, ProjectionMode};\n use rustc::ty::fold::TypeFoldable;\n use rustc::hir;\n@@ -99,6 +100,63 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n     }\n }\n \n+/// Returns Some([a, b]) if the type has a pair of fields with types a and b.\n+pub fn type_pair_fields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n+                                  -> Option<[Ty<'tcx>; 2]> {\n+    match ty.sty {\n+        ty::TyEnum(adt, substs) | ty::TyStruct(adt, substs) => {\n+            assert_eq!(adt.variants.len(), 1);\n+            let fields = &adt.variants[0].fields;\n+            if fields.len() != 2 {\n+                return None;\n+            }\n+            Some([monomorphize::field_ty(ccx.tcx(), substs, &fields[0]),\n+                  monomorphize::field_ty(ccx.tcx(), substs, &fields[1])])\n+        }\n+        ty::TyClosure(_, ty::ClosureSubsts { upvar_tys: tys, .. }) |\n+        ty::TyTuple(tys) => {\n+            if tys.len() != 2 {\n+                return None;\n+            }\n+            Some([tys[0], tys[1]])\n+        }\n+        _ => None\n+    }\n+}\n+\n+/// Returns true if the type is represented as a pair of immediates.\n+pub fn type_is_imm_pair<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n+                                  -> bool {\n+    let tcx = ccx.tcx();\n+    let layout = tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+        match ty.layout(&infcx) {\n+            Ok(layout) => layout,\n+            Err(err) => {\n+                bug!(\"type_is_imm_pair: layout for `{:?}` failed: {}\",\n+                     ty, err);\n+            }\n+        }\n+    });\n+\n+    match *layout {\n+        Layout::FatPointer { .. } => true,\n+        Layout::Univariant { ref variant, .. } => {\n+            // There must be only 2 fields.\n+            if variant.offset_after_field.len() != 2 {\n+                return false;\n+            }\n+\n+            match type_pair_fields(ccx, ty) {\n+                Some([a, b]) => {\n+                    type_is_immediate(ccx, a) && type_is_immediate(ccx, b)\n+                }\n+                None => false\n+            }\n+        }\n+        _ => false\n+    }\n+}\n+\n /// Identify types which have size zero at runtime.\n pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     use machine::llsize_of_alloc;"}, {"sha": "cf41f5bf2bcbf8e41cf6eda1d61146db98e9f26f", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 69, "deletions": 38, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/f1f453cf3b124711b2e20315937403d89913bcd2/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f453cf3b124711b2e20315937403d89913bcd2/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=f1f453cf3b124711b2e20315937403d89913bcd2", "patch": "@@ -17,7 +17,7 @@ use adt;\n use base;\n use build;\n use callee::{Callee, CalleeData, Fn, Intrinsic, NamedTupleConstructor, Virtual};\n-use common::{self, type_is_fat_ptr, Block, BlockAndBuilder, LandingPad};\n+use common::{self, Block, BlockAndBuilder, LandingPad};\n use common::{C_bool, C_str_slice, C_struct, C_u32, C_undef};\n use consts;\n use debuginfo::DebugLoc;\n@@ -36,7 +36,7 @@ use super::analyze::CleanupKind;\n use super::constant::Const;\n use super::lvalue::{LvalueRef, load_fat_ptr};\n use super::operand::OperandRef;\n-use super::operand::OperandValue::{self, FatPtr, Immediate, Ref};\n+use super::operand::OperandValue::*;\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n@@ -410,8 +410,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         }\n                     }\n \n-                    let val = self.trans_operand(&bcx, arg).val;\n-                    self.trans_argument(&bcx, val, &mut llargs, &fn_ty,\n+                    let op = self.trans_operand(&bcx, arg);\n+                    self.trans_argument(&bcx, op, &mut llargs, &fn_ty,\n                                         &mut idx, &mut callee.data);\n                 }\n                 if let Some(tup) = untuple {\n@@ -449,7 +449,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n                             // Make a fake operand for store_return\n                             let op = OperandRef {\n-                                val: OperandValue::Ref(dst),\n+                                val: Ref(dst),\n                                 ty: sig.output.unwrap()\n                             };\n                             self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n@@ -487,7 +487,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         ret_bcx.at_start(|ret_bcx| {\n                             debug_loc.apply_to_bcx(ret_bcx);\n                             let op = OperandRef {\n-                                val: OperandValue::Immediate(invokeret),\n+                                val: Immediate(invokeret),\n                                 ty: sig.output.unwrap()\n                             };\n                             self.store_return(&ret_bcx, ret_dest, fn_ty.ret, op);\n@@ -498,7 +498,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     fn_ty.apply_attrs_callsite(llret);\n                     if let Some((_, target)) = *destination {\n                         let op = OperandRef {\n-                            val: OperandValue::Immediate(llret),\n+                            val: Immediate(llret),\n                             ty: sig.output.unwrap()\n                         };\n                         self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n@@ -513,25 +513,36 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n     fn trans_argument(&mut self,\n                       bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                      val: OperandValue,\n+                      mut op: OperandRef<'tcx>,\n                       llargs: &mut Vec<ValueRef>,\n                       fn_ty: &FnType,\n                       next_idx: &mut usize,\n                       callee: &mut CalleeData) {\n-        // Treat the values in a fat pointer separately.\n-        if let FatPtr(ptr, meta) = val {\n-            if *next_idx == 0 {\n-                if let Virtual(idx) = *callee {\n-                    let llfn = bcx.with_block(|bcx| {\n-                        meth::get_virtual_method(bcx, meta, idx)\n-                    });\n-                    let llty = fn_ty.llvm_type(bcx.ccx()).ptr_to();\n-                    *callee = Fn(bcx.pointercast(llfn, llty));\n+        if let Pair(a, b) = op.val {\n+            // Treat the values in a fat pointer separately.\n+            if common::type_is_fat_ptr(bcx.tcx(), op.ty) {\n+                let (ptr, meta) = (a, b);\n+                if *next_idx == 0 {\n+                    if let Virtual(idx) = *callee {\n+                        let llfn = bcx.with_block(|bcx| {\n+                            meth::get_virtual_method(bcx, meta, idx)\n+                        });\n+                        let llty = fn_ty.llvm_type(bcx.ccx()).ptr_to();\n+                        *callee = Fn(bcx.pointercast(llfn, llty));\n+                    }\n                 }\n+\n+                let imm_op = |x| OperandRef {\n+                    val: Immediate(x),\n+                    // We won't be checking the type again.\n+                    ty: bcx.tcx().types.err\n+                };\n+                self.trans_argument(bcx, imm_op(ptr), llargs, fn_ty, next_idx, callee);\n+                self.trans_argument(bcx, imm_op(meta), llargs, fn_ty, next_idx, callee);\n+                return;\n             }\n-            self.trans_argument(bcx, Immediate(ptr), llargs, fn_ty, next_idx, callee);\n-            self.trans_argument(bcx, Immediate(meta), llargs, fn_ty, next_idx, callee);\n-            return;\n+\n+            op = op.pack_if_pair(bcx);\n         }\n \n         let arg = &fn_ty.args[*next_idx];\n@@ -547,15 +558,15 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         }\n \n         // Force by-ref if we have to load through a cast pointer.\n-        let (mut llval, by_ref) = match val {\n+        let (mut llval, by_ref) = match op.val {\n             Immediate(llval) if arg.is_indirect() || arg.cast.is_some() => {\n                 let llscratch = build::AllocaFcx(bcx.fcx(), arg.original_ty, \"arg\");\n                 bcx.store(llval, llscratch);\n                 (llscratch, true)\n             }\n             Immediate(llval) => (llval, false),\n             Ref(llval) => (llval, true),\n-            FatPtr(_, _) => bug!(\"fat pointers handled above\")\n+            Pair(..) => bug!(\"pairs handled above\")\n         };\n \n         if by_ref && !arg.is_indirect() {\n@@ -602,12 +613,16 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     let ptr = adt::trans_field_ptr_builder(bcx, &base_repr, base, Disr(0), n);\n                     let val = if common::type_is_fat_ptr(bcx.tcx(), ty) {\n                         let (lldata, llextra) = load_fat_ptr(bcx, ptr);\n-                        FatPtr(lldata, llextra)\n+                        Pair(lldata, llextra)\n                     } else {\n                         // trans_argument will load this if it needs to\n                         Ref(ptr)\n                     };\n-                    self.trans_argument(bcx, val, llargs, fn_ty, next_idx, callee);\n+                    let op = OperandRef {\n+                        val: val,\n+                        ty: ty\n+                    };\n+                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, callee);\n                 }\n \n             }\n@@ -619,11 +634,29 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         elem = bcx.trunc(elem, Type::i1(bcx.ccx()));\n                     }\n                     // If the tuple is immediate, the elements are as well\n-                    let val = Immediate(elem);\n-                    self.trans_argument(bcx, val, llargs, fn_ty, next_idx, callee);\n+                    let op = OperandRef {\n+                        val: Immediate(elem),\n+                        ty: ty\n+                    };\n+                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, callee);\n+                }\n+            }\n+            Pair(a, b) => {\n+                let elems = [a, b];\n+                for (n, &ty) in arg_types.iter().enumerate() {\n+                    let mut elem = elems[n];\n+                    // Truncate bools to i1, if needed\n+                    if ty.is_bool() && common::val_ty(elem) != Type::i1(bcx.ccx()) {\n+                        elem = bcx.trunc(elem, Type::i1(bcx.ccx()));\n+                    }\n+                    // Pair is always made up of immediates\n+                    let op = OperandRef {\n+                        val: Immediate(elem),\n+                        ty: ty\n+                    };\n+                    self.trans_argument(bcx, op, llargs, fn_ty, next_idx, callee);\n                 }\n             }\n-            FatPtr(_, _) => bug!(\"tuple is a fat pointer?!\")\n         }\n \n     }\n@@ -779,7 +812,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let f = Callee::def(bcx.ccx(), def_id, substs);\n                 let datum = f.reify(bcx.ccx());\n                 val = OperandRef {\n-                    val: OperandValue::Immediate(datum.val),\n+                    val: Immediate(datum.val),\n                     ty: datum.ty\n                 };\n             }\n@@ -806,17 +839,15 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 self.temps[idx as usize] = TempRef::Operand(Some(op));\n             }\n             DirectOperand(idx) => {\n-                let op = if type_is_fat_ptr(bcx.tcx(), op.ty) {\n-                    let llval = op.immediate();\n-                    let ptr = bcx.extract_value(llval, 0);\n-                    let meta = bcx.extract_value(llval, 1);\n-\n-                    OperandRef {\n-                        val: OperandValue::FatPtr(ptr, meta),\n-                        ty: op.ty\n-                    }\n+                // If there is a cast, we have to store and reload.\n+                let op = if ret_ty.cast.is_some() {\n+                    let tmp = bcx.with_block(|bcx| {\n+                        base::alloc_ty(bcx, op.ty, \"tmp_ret\")\n+                    });\n+                    ret_ty.store(bcx, op.immediate(), tmp);\n+                    self.trans_load(bcx, tmp, op.ty)\n                 } else {\n-                    op\n+                    op.unpack_if_pair(bcx)\n                 };\n                 self.temps[idx as usize] = TempRef::Operand(Some(op));\n             }"}, {"sha": "e73d02a1e29f17fffc1252ed5c71409b323498ab", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f1f453cf3b124711b2e20315937403d89913bcd2/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f453cf3b124711b2e20315937403d89913bcd2/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=f1f453cf3b124711b2e20315937403d89913bcd2", "patch": "@@ -98,9 +98,15 @@ impl<'tcx> Const<'tcx> {\n         Const::new(val, ty)\n     }\n \n+    fn get_pair(&self) -> (ValueRef, ValueRef) {\n+        (const_get_elt(self.llval, &[0]),\n+         const_get_elt(self.llval, &[1]))\n+    }\n+\n     fn get_fat_ptr(&self) -> (ValueRef, ValueRef) {\n-        (const_get_elt(self.llval, &[abi::FAT_PTR_ADDR as u32]),\n-         const_get_elt(self.llval, &[abi::FAT_PTR_EXTRA as u32]))\n+        assert_eq!(abi::FAT_PTR_ADDR, 0);\n+        assert_eq!(abi::FAT_PTR_EXTRA, 1);\n+        self.get_pair()\n     }\n \n     fn as_lvalue(&self) -> ConstLvalue<'tcx> {\n@@ -115,9 +121,9 @@ impl<'tcx> Const<'tcx> {\n         let llty = type_of::immediate_type_of(ccx, self.ty);\n         let llvalty = val_ty(self.llval);\n \n-        let val = if common::type_is_fat_ptr(ccx.tcx(), self.ty) {\n-            let (data, extra) = self.get_fat_ptr();\n-            OperandValue::FatPtr(data, extra)\n+        let val = if common::type_is_imm_pair(ccx, self.ty) {\n+            let (a, b) = self.get_pair();\n+            OperandValue::Pair(a, b)\n         } else if common::type_is_immediate(ccx, self.ty) && llty == llvalty {\n             // If the types match, we can use the value directly.\n             OperandValue::Immediate(self.llval)\n@@ -656,7 +662,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                 consts::ptrcast(data_ptr, ll_cast_ty)\n                             }\n                         } else {\n-                            bug!(\"Unexpected non-FatPtr operand\")\n+                            bug!(\"Unexpected non-fat-pointer operand\")\n                         }\n                     }\n                 };"}, {"sha": "9e04f1cb207b34bc228b571965b6e7c5b14391cd", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 80, "deletions": 20, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/f1f453cf3b124711b2e20315937403d89913bcd2/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f453cf3b124711b2e20315937403d89913bcd2/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=f1f453cf3b124711b2e20315937403d89913bcd2", "patch": "@@ -13,12 +13,12 @@ use rustc::ty::Ty;\n use rustc::mir::repr as mir;\n use base;\n use common::{self, Block, BlockAndBuilder};\n-use datum;\n use value::Value;\n+use type_of;\n+use type_::Type;\n \n use std::fmt;\n \n-use super::lvalue::load_fat_ptr;\n use super::{MirContext, TempRef};\n \n /// The representation of a Rust value. The enum variant is in fact\n@@ -31,9 +31,8 @@ pub enum OperandValue {\n     Ref(ValueRef),\n     /// A single LLVM value.\n     Immediate(ValueRef),\n-    /// A fat pointer. The first ValueRef is the data and the second\n-    /// is the extra.\n-    FatPtr(ValueRef, ValueRef)\n+    /// A pair of immediate LLVM values. Used by fat pointers too.\n+    Pair(ValueRef, ValueRef)\n }\n \n /// An `OperandRef` is an \"SSA\" reference to a Rust value, along with\n@@ -64,15 +63,15 @@ impl<'tcx> fmt::Debug for OperandRef<'tcx> {\n                 write!(f, \"OperandRef(Immediate({:?}) @ {:?})\",\n                        Value(i), self.ty)\n             }\n-            OperandValue::FatPtr(a, d) => {\n-                write!(f, \"OperandRef(FatPtr({:?}, {:?}) @ {:?})\",\n-                       Value(a), Value(d), self.ty)\n+            OperandValue::Pair(a, b) => {\n+                write!(f, \"OperandRef(Pair({:?}, {:?}) @ {:?})\",\n+                       Value(a), Value(b), self.ty)\n             }\n         }\n     }\n }\n \n-impl<'tcx> OperandRef<'tcx> {\n+impl<'bcx, 'tcx> OperandRef<'tcx> {\n     /// Asserts that this operand refers to a scalar and returns\n     /// a reference to its value.\n     pub fn immediate(self) -> ValueRef {\n@@ -81,6 +80,54 @@ impl<'tcx> OperandRef<'tcx> {\n             _ => bug!()\n         }\n     }\n+\n+    /// If this operand is a Pair, we return an\n+    /// Immediate aggregate with the two values.\n+    pub fn pack_if_pair(mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>)\n+                        -> OperandRef<'tcx> {\n+        if let OperandValue::Pair(a, b) = self.val {\n+            // Reconstruct the immediate aggregate.\n+            let llty = type_of::type_of(bcx.ccx(), self.ty);\n+            let mut llpair = common::C_undef(llty);\n+            let elems = [a, b];\n+            for i in 0..2 {\n+                let mut elem = elems[i];\n+                // Extend boolean i1's to i8.\n+                if common::val_ty(elem) == Type::i1(bcx.ccx()) {\n+                    elem = bcx.zext(elem, Type::i8(bcx.ccx()));\n+                }\n+                llpair = bcx.insert_value(llpair, elem, i);\n+            }\n+            self.val = OperandValue::Immediate(llpair);\n+        }\n+        self\n+    }\n+\n+    /// If this operand is a pair in an Immediate,\n+    /// we return a Pair with the two halves.\n+    pub fn unpack_if_pair(mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>)\n+                          -> OperandRef<'tcx> {\n+        if let OperandValue::Immediate(llval) = self.val {\n+            // Deconstruct the immediate aggregate.\n+            if common::type_is_imm_pair(bcx.ccx(), self.ty) {\n+                let mut a = bcx.extract_value(llval, 0);\n+                let mut b = bcx.extract_value(llval, 1);\n+\n+                let pair_fields = common::type_pair_fields(bcx.ccx(), self.ty);\n+                if let Some([a_ty, b_ty]) = pair_fields {\n+                    if a_ty.is_bool() {\n+                        a = bcx.trunc(a, Type::i1(bcx.ccx()));\n+                    }\n+                    if b_ty.is_bool() {\n+                        b = bcx.trunc(b, Type::i1(bcx.ccx()));\n+                    }\n+                }\n+\n+                self.val = OperandValue::Pair(a, b);\n+            }\n+        }\n+        self\n+    }\n }\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n@@ -92,15 +139,24 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     {\n         debug!(\"trans_load: {:?} @ {:?}\", Value(llval), ty);\n \n-        let val = match datum::appropriate_rvalue_mode(bcx.ccx(), ty) {\n-            datum::ByValue => {\n-                OperandValue::Immediate(base::load_ty_builder(bcx, llval, ty))\n-            }\n-            datum::ByRef if common::type_is_fat_ptr(bcx.tcx(), ty) => {\n-                let (lldata, llextra) = load_fat_ptr(bcx, llval);\n-                OperandValue::FatPtr(lldata, llextra)\n-            }\n-            datum::ByRef => OperandValue::Ref(llval)\n+        let val = if common::type_is_imm_pair(bcx.ccx(), ty) {\n+            let a_ptr = bcx.struct_gep(llval, 0);\n+            let b_ptr = bcx.struct_gep(llval, 1);\n+\n+            // This is None only for fat pointers, which don't\n+            // need any special load-time behavior anyway.\n+            let pair_fields = common::type_pair_fields(bcx.ccx(), ty);\n+            let (a, b) = if let Some([a_ty, b_ty]) = pair_fields {\n+                (base::load_ty_builder(bcx, a_ptr, a_ty),\n+                 base::load_ty_builder(bcx, b_ptr, b_ty))\n+            } else {\n+                (bcx.load(a_ptr), bcx.load(b_ptr))\n+            };\n+            OperandValue::Pair(a, b)\n+        } else if common::type_is_immediate(bcx.ccx(), ty) {\n+            OperandValue::Immediate(base::load_ty_builder(bcx, llval, ty))\n+        } else {\n+            OperandValue::Ref(llval)\n         };\n \n         OperandRef { val: val, ty: ty }\n@@ -173,8 +229,12 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         match operand.val {\n             OperandValue::Ref(r) => base::memcpy_ty(bcx, lldest, r, operand.ty),\n             OperandValue::Immediate(s) => base::store_ty(bcx, s, lldest, operand.ty),\n-            OperandValue::FatPtr(data, extra) => {\n-                base::store_fat_ptr(bcx, data, extra, lldest, operand.ty);\n+            OperandValue::Pair(a, b) => {\n+                use build::*;\n+                let a = base::from_immediate(bcx, a);\n+                let b = base::from_immediate(bcx, b);\n+                Store(bcx, a, StructGEP(bcx, lldest, 0));\n+                Store(bcx, b, StructGEP(bcx, lldest, 1));\n             }\n         }\n     }"}, {"sha": "d019677d0e69139f589719741d91733c157f8ebc", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f1f453cf3b124711b2e20315937403d89913bcd2/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f453cf3b124711b2e20315937403d89913bcd2/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=f1f453cf3b124711b2e20315937403d89913bcd2", "patch": "@@ -16,14 +16,12 @@ use rustc::mir::repr as mir;\n use asm;\n use base;\n use callee::Callee;\n-use common::{self, val_ty,\n-             C_null, C_uint, C_undef, BlockAndBuilder, Result};\n+use common::{self, val_ty, C_null, C_uint, BlockAndBuilder, Result};\n use datum::{Datum, Lvalue};\n use debuginfo::DebugLoc;\n use adt;\n use machine;\n use type_of;\n-use type_::Type;\n use tvec;\n use value::Value;\n use Disr;\n@@ -68,9 +66,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 // `CoerceUnsized` can be passed by a where-clause,\n                 // so the (generic) MIR may not be able to expand it.\n                 let operand = self.trans_operand(&bcx, source);\n+                let operand = operand.pack_if_pair(&bcx);\n                 bcx.with_block(|bcx| {\n                     match operand.val {\n-                        OperandValue::FatPtr(..) => bug!(),\n+                        OperandValue::Pair(..) => bug!(),\n                         OperandValue::Immediate(llval) => {\n                             // unsize from an immediate structure. We don't\n                             // really need a temporary alloca here, but\n@@ -255,7 +254,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         assert!(common::type_is_fat_ptr(bcx.tcx(), cast_ty));\n \n                         match operand.val {\n-                            OperandValue::FatPtr(lldata, llextra) => {\n+                            OperandValue::Pair(lldata, llextra) => {\n                                 // unsize from a fat pointer - this is a\n                                 // \"trait-object-to-supertrait\" coercion, for\n                                 // example,\n@@ -264,15 +263,15 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 // the types match up.\n                                 let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx(), cast_ty);\n                                 let lldata = bcx.pointercast(lldata, llcast_ty);\n-                                OperandValue::FatPtr(lldata, llextra)\n+                                OperandValue::Pair(lldata, llextra)\n                             }\n                             OperandValue::Immediate(lldata) => {\n                                 // \"standard\" unsize\n                                 let (lldata, llextra) = bcx.with_block(|bcx| {\n                                     base::unsize_thin_ptr(bcx, lldata,\n                                                           operand.ty, cast_ty)\n                                 });\n-                                OperandValue::FatPtr(lldata, llextra)\n+                                OperandValue::Pair(lldata, llextra)\n                             }\n                             OperandValue::Ref(_) => {\n                                 bug!(\"by-ref operand {:?} in trans_rvalue_operand\",\n@@ -343,21 +342,21 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     mir::CastKind::Misc => { // Casts from a fat-ptr.\n                         let ll_cast_ty = type_of::immediate_type_of(bcx.ccx(), cast_ty);\n                         let ll_from_ty = type_of::immediate_type_of(bcx.ccx(), operand.ty);\n-                        if let OperandValue::FatPtr(data_ptr, meta_ptr) = operand.val {\n+                        if let OperandValue::Pair(data_ptr, meta_ptr) = operand.val {\n                             if common::type_is_fat_ptr(bcx.tcx(), cast_ty) {\n                                 let ll_cft = ll_cast_ty.field_types();\n                                 let ll_fft = ll_from_ty.field_types();\n                                 let data_cast = bcx.pointercast(data_ptr, ll_cft[0]);\n                                 assert_eq!(ll_cft[1].kind(), ll_fft[1].kind());\n-                                OperandValue::FatPtr(data_cast, meta_ptr)\n+                                OperandValue::Pair(data_cast, meta_ptr)\n                             } else { // cast to thin-ptr\n                                 // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n                                 // pointer-cast of that pointer to desired pointer type.\n                                 let llval = bcx.pointercast(data_ptr, ll_cast_ty);\n                                 OperandValue::Immediate(llval)\n                             }\n                         } else {\n-                            bug!(\"Unexpected non-FatPtr operand\")\n+                            bug!(\"Unexpected non-Pair operand\")\n                         }\n                     }\n                 };\n@@ -386,8 +385,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     }\n                 } else {\n                     OperandRef {\n-                        val: OperandValue::FatPtr(tr_lvalue.llval,\n-                                                  tr_lvalue.llextra),\n+                        val: OperandValue::Pair(tr_lvalue.llval,\n+                                                tr_lvalue.llextra),\n                         ty: ref_ty,\n                     }\n                 };\n@@ -408,8 +407,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let rhs = self.trans_operand(&bcx, rhs);\n                 let llresult = if common::type_is_fat_ptr(bcx.tcx(), lhs.ty) {\n                     match (lhs.val, rhs.val) {\n-                        (OperandValue::FatPtr(lhs_addr, lhs_extra),\n-                         OperandValue::FatPtr(rhs_addr, rhs_extra)) => {\n+                        (OperandValue::Pair(lhs_addr, lhs_extra),\n+                         OperandValue::Pair(rhs_addr, rhs_extra)) => {\n                             bcx.with_block(|bcx| {\n                                 base::compare_fat_ptrs(bcx,\n                                                        lhs_addr, lhs_extra,\n@@ -441,7 +440,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let val_ty = self.mir.binop_ty(bcx.tcx(), op, lhs.ty, rhs.ty);\n                 let operand_ty = bcx.tcx().mk_tup(vec![val_ty, bcx.tcx().types.bool]);\n                 let operand = OperandRef {\n-                    val: OperandValue::Immediate(result),\n+                    val: result,\n                     ty: operand_ty\n                 };\n \n@@ -579,7 +578,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                       op: mir::BinOp,\n                                       lhs: ValueRef,\n                                       rhs: ValueRef,\n-                                      input_ty: Ty<'tcx>) -> ValueRef {\n+                                      input_ty: Ty<'tcx>) -> OperandValue {\n         let (val, of) = match op {\n             // These are checked using intrinsics\n             mir::BinOp::Add | mir::BinOp::Sub | mir::BinOp::Mul => {\n@@ -592,10 +591,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let intrinsic = get_overflow_intrinsic(oop, bcx, input_ty);\n                 let res = bcx.call(intrinsic, &[lhs, rhs], None);\n \n-                let val = bcx.extract_value(res, 0);\n-                let of = bcx.extract_value(res, 1);\n-\n-                (val, bcx.zext(of, Type::bool(bcx.ccx())))\n+                (bcx.extract_value(res, 0),\n+                 bcx.extract_value(res, 1))\n             }\n             mir::BinOp::Shl | mir::BinOp::Shr => {\n                 let lhs_llty = val_ty(lhs);\n@@ -608,19 +605,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let of = bcx.icmp(llvm::IntNE, outer_bits, C_null(rhs_llty));\n                 let val = self.trans_scalar_binop(bcx, op, lhs, rhs, input_ty);\n \n-                (val, bcx.zext(of, Type::bool(bcx.ccx())))\n+                (val, of)\n             }\n             _ => {\n                 bug!(\"Operator `{:?}` is not a checkable operator\", op)\n             }\n         };\n \n-        let val_ty = val_ty(val);\n-        let res_ty = Type::struct_(bcx.ccx(), &[val_ty, Type::bool(bcx.ccx())], false);\n-\n-        let mut res_val = C_undef(res_ty);\n-        res_val = bcx.insert_value(res_val, val, 0);\n-        bcx.insert_value(res_val, of, 1)\n+        OperandValue::Pair(val, of)\n     }\n }\n "}]}