{"sha": "bac4bb96137cad937e4986b37d9e4273d1f01dcf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhYzRiYjk2MTM3Y2FkOTM3ZTQ5ODZiMzdkOWU0MjczZDFmMDFkY2Y=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-06-25T03:22:42Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-11T18:09:19Z"}, "message": "Refactor methods onto Printer struct.\n\nNo (intentional) changes to behavior. This is intended to avoid the\nanti-pattern of having to import individual methods throughout code.", "tree": {"sha": "cca8214e224cc36925a3684a201a097ba0ebd809", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cca8214e224cc36925a3684a201a097ba0ebd809"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bac4bb96137cad937e4986b37d9e4273d1f01dcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bac4bb96137cad937e4986b37d9e4273d1f01dcf", "html_url": "https://github.com/rust-lang/rust/commit/bac4bb96137cad937e4986b37d9e4273d1f01dcf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bac4bb96137cad937e4986b37d9e4273d1f01dcf/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1f180bde3fedc67db04e595a29c9cb4e03f7eaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1f180bde3fedc67db04e595a29c9cb4e03f7eaf", "html_url": "https://github.com/rust-lang/rust/commit/a1f180bde3fedc67db04e595a29c9cb4e03f7eaf"}], "stats": {"total": 1051, "additions": 521, "deletions": 530}, "files": [{"sha": "d4e4ee6d49107edc13c1b30797bf762aa7b36a3a", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 185, "deletions": 186, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/bac4bb96137cad937e4986b37d9e4273d1f01dcf/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac4bb96137cad937e4986b37d9e4273d1f01dcf/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=bac4bb96137cad937e4986b37d9e4273d1f01dcf", "patch": "@@ -15,8 +15,7 @@ use syntax::ast;\n use syntax::codemap::{CodeMap, Spanned};\n use syntax::parse::ParseSess;\n use syntax::parse::lexer::comments;\n-use syntax::print::pp::{self, break_offset, word, space, hardbreak};\n-use syntax::print::pp::{Breaks, eof};\n+use syntax::print::pp::{self, Breaks};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n use syntax::print::pprust::{self as ast_pp, PrintState};\n use syntax::ptr::P;\n@@ -132,7 +131,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n \n     s.print_mod(&krate.module, &krate.attrs)?;\n     s.print_remaining_comments()?;\n-    eof(&mut s.s)\n+    s.s.eof()\n }\n \n impl<'a> State<'a> {\n@@ -199,15 +198,15 @@ pub fn to_string<F>(ann: &PpAnn, f: F) -> String\n             ann,\n         };\n         f(&mut printer).unwrap();\n-        eof(&mut printer.s).unwrap();\n+        printer.s.eof().unwrap();\n     }\n     String::from_utf8(wr).unwrap()\n }\n \n pub fn visibility_qualified(vis: &hir::Visibility, w: &str) -> String {\n     to_string(NO_ANN, |s| {\n         s.print_visibility(vis)?;\n-        word(&mut s.s, w)\n+        s.s.word(w)\n     })\n }\n \n@@ -226,15 +225,15 @@ fn needs_parentheses(expr: &hir::Expr) -> bool {\n impl<'a> State<'a> {\n     pub fn cbox(&mut self, u: usize) -> io::Result<()> {\n         self.boxes.push(pp::Breaks::Consistent);\n-        pp::cbox(&mut self.s, u)\n+        self.s.cbox(u)\n     }\n \n     pub fn nbsp(&mut self) -> io::Result<()> {\n-        word(&mut self.s, \" \")\n+        self.s.word(\" \")\n     }\n \n     pub fn word_nbsp(&mut self, w: &str) -> io::Result<()> {\n-        word(&mut self.s, w)?;\n+        self.s.word(w)?;\n         self.nbsp()\n     }\n \n@@ -251,7 +250,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn bopen(&mut self) -> io::Result<()> {\n-        word(&mut self.s, \"{\")?;\n+        self.s.word(\"{\")?;\n         self.end() // close the head-box\n     }\n \n@@ -265,7 +264,7 @@ impl<'a> State<'a> {\n                              -> io::Result<()> {\n         self.maybe_print_comment(span.hi)?;\n         self.break_offset_if_not_bol(1, -(indented as isize))?;\n-        word(&mut self.s, \"}\")?;\n+        self.s.word(\"}\")?;\n         if close_box {\n             self.end()?; // close the outer-box\n         }\n@@ -283,19 +282,19 @@ impl<'a> State<'a> {\n     }\n     pub fn space_if_not_bol(&mut self) -> io::Result<()> {\n         if !self.is_bol() {\n-            space(&mut self.s)?;\n+            self.s.space()?;\n         }\n         Ok(())\n     }\n     pub fn break_offset_if_not_bol(&mut self, n: usize, off: isize) -> io::Result<()> {\n         if !self.is_bol() {\n-            break_offset(&mut self.s, n, off)\n+            self.s.break_offset(n, off)\n         } else {\n             if off != 0 && self.s.last_token().is_hardbreak_tok() {\n                 // We do something pretty sketchy here: tuck the nonzero\n                 // offset-adjustment we were going to deposit along with the\n                 // break into the previous hardbreak.\n-                self.s.replace_last_token(pp::hardbreak_tok_offset(off));\n+                self.s.replace_last_token(pp::Printer::hardbreak_tok_offset(off));\n             }\n             Ok(())\n         }\n@@ -304,11 +303,11 @@ impl<'a> State<'a> {\n     // Synthesizes a comment that was not textually present in the original source\n     // file.\n     pub fn synth_comment(&mut self, text: String) -> io::Result<()> {\n-        word(&mut self.s, \"/*\")?;\n-        space(&mut self.s)?;\n-        word(&mut self.s, &text[..])?;\n-        space(&mut self.s)?;\n-        word(&mut self.s, \"*/\")\n+        self.s.word(\"/*\")?;\n+        self.s.space()?;\n+        self.s.word(&text[..])?;\n+        self.s.space()?;\n+        self.s.word(\"*/\")\n     }\n \n \n@@ -329,7 +328,7 @@ impl<'a> State<'a> {\n             op(self, elt)?;\n             i += 1;\n             if i < len {\n-                word(&mut self.s, \",\")?;\n+                self.s.word(\",\")?;\n                 self.maybe_print_trailing_comment(get_span(elt), Some(get_span(&elts[i]).hi))?;\n                 self.space_if_not_bol()?;\n             }\n@@ -373,31 +372,31 @@ impl<'a> State<'a> {\n         self.ibox(0)?;\n         match ty.node {\n             hir::TySlice(ref ty) => {\n-                word(&mut self.s, \"[\")?;\n+                self.s.word(\"[\")?;\n                 self.print_type(&ty)?;\n-                word(&mut self.s, \"]\")?;\n+                self.s.word(\"]\")?;\n             }\n             hir::TyPtr(ref mt) => {\n-                word(&mut self.s, \"*\")?;\n+                self.s.word(\"*\")?;\n                 match mt.mutbl {\n                     hir::MutMutable => self.word_nbsp(\"mut\")?,\n                     hir::MutImmutable => self.word_nbsp(\"const\")?,\n                 }\n                 self.print_type(&mt.ty)?;\n             }\n             hir::TyRptr(ref lifetime, ref mt) => {\n-                word(&mut self.s, \"&\")?;\n+                self.s.word(\"&\")?;\n                 self.print_opt_lifetime(lifetime)?;\n                 self.print_mt(mt)?;\n             }\n             hir::TyNever => {\n-                word(&mut self.s, \"!\")?;\n+                self.s.word(\"!\")?;\n             },\n             hir::TyTup(ref elts) => {\n                 self.popen()?;\n                 self.commasep(Inconsistent, &elts[..], |s, ty| s.print_type(&ty))?;\n                 if elts.len() == 1 {\n-                    word(&mut self.s, \",\")?;\n+                    self.s.word(\",\")?;\n                 }\n                 self.pclose()?;\n             }\n@@ -436,22 +435,22 @@ impl<'a> State<'a> {\n                 self.print_bounds(\"impl \", &bounds[..])?;\n             }\n             hir::TyArray(ref ty, v) => {\n-                word(&mut self.s, \"[\")?;\n+                self.s.word(\"[\")?;\n                 self.print_type(&ty)?;\n-                word(&mut self.s, \"; \")?;\n+                self.s.word(\"; \")?;\n                 self.ann.nested(self, Nested::Body(v))?;\n-                word(&mut self.s, \"]\")?;\n+                self.s.word(\"]\")?;\n             }\n             hir::TyTypeof(e) => {\n-                word(&mut self.s, \"typeof(\")?;\n+                self.s.word(\"typeof(\")?;\n                 self.ann.nested(self, Nested::Body(e))?;\n-                word(&mut self.s, \")\")?;\n+                self.s.word(\")\")?;\n             }\n             hir::TyInfer => {\n-                word(&mut self.s, \"_\")?;\n+                self.s.word(\"_\")?;\n             }\n             hir::TyErr => {\n-                word(&mut self.s, \"?\")?;\n+                self.s.word(\"?\")?;\n             }\n         }\n         self.end()\n@@ -474,7 +473,7 @@ impl<'a> State<'a> {\n                               arg_names,\n                               None)?;\n                 self.end()?; // end head-ibox\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end() // end the outer fn box\n             }\n             hir::ForeignItemStatic(ref t, m) => {\n@@ -485,7 +484,7 @@ impl<'a> State<'a> {\n                 self.print_name(item.name)?;\n                 self.word_space(\":\")?;\n                 self.print_type(&t)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end the head-ibox\n                 self.end() // end the outer cbox\n             }\n@@ -498,17 +497,17 @@ impl<'a> State<'a> {\n                               default: Option<hir::BodyId>,\n                               vis: &hir::Visibility)\n                               -> io::Result<()> {\n-        word(&mut self.s, &visibility_qualified(vis, \"\"))?;\n+        self.s.word(&visibility_qualified(vis, \"\"))?;\n         self.word_space(\"const\")?;\n         self.print_name(name)?;\n         self.word_space(\":\")?;\n         self.print_type(ty)?;\n         if let Some(expr) = default {\n-            space(&mut self.s)?;\n+            self.s.space()?;\n             self.word_space(\"=\")?;\n             self.ann.nested(self, Nested::Body(expr))?;\n         }\n-        word(&mut self.s, \";\")\n+        self.s.word(\";\")\n     }\n \n     fn print_associated_type(&mut self,\n@@ -522,11 +521,11 @@ impl<'a> State<'a> {\n             self.print_bounds(\":\", bounds)?;\n         }\n         if let Some(ty) = ty {\n-            space(&mut self.s)?;\n+            self.s.space()?;\n             self.word_space(\"=\")?;\n             self.print_type(ty)?;\n         }\n-        word(&mut self.s, \";\")\n+        self.s.word(\";\")\n     }\n \n     /// Pretty-print an item\n@@ -545,12 +544,12 @@ impl<'a> State<'a> {\n                     } else {\n                         self.print_name(p)?;\n                     }\n-                    space(&mut self.s)?;\n-                    word(&mut self.s, \"as\")?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n+                    self.s.word(\"as\")?;\n+                    self.s.space()?;\n                 }\n                 self.print_name(item.name)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n@@ -561,14 +560,14 @@ impl<'a> State<'a> {\n                 match kind {\n                     hir::UseKind::Single => {\n                         if path.segments.last().unwrap().name != item.name {\n-                            space(&mut self.s)?;\n+                            self.s.space()?;\n                             self.word_space(\"as\")?;\n                             self.print_name(item.name)?;\n                         }\n-                        word(&mut self.s, \";\")?;\n+                        self.s.word(\";\")?;\n                     }\n-                    hir::UseKind::Glob => word(&mut self.s, \"::*;\")?,\n-                    hir::UseKind::ListStem => word(&mut self.s, \"::{};\")?\n+                    hir::UseKind::Glob => self.s.word(\"::*;\")?,\n+                    hir::UseKind::ListStem => self.s.word(\"::{};\")?\n                 }\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n@@ -581,25 +580,25 @@ impl<'a> State<'a> {\n                 self.print_name(item.name)?;\n                 self.word_space(\":\")?;\n                 self.print_type(&ty)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.end()?; // end the head-ibox\n \n                 self.word_space(\"=\")?;\n                 self.ann.nested(self, Nested::Body(expr))?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end the outer cbox\n             }\n             hir::ItemConst(ref ty, expr) => {\n                 self.head(&visibility_qualified(&item.vis, \"const\"))?;\n                 self.print_name(item.name)?;\n                 self.word_space(\":\")?;\n                 self.print_type(&ty)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.end()?; // end the head-ibox\n \n                 self.word_space(\"=\")?;\n                 self.ann.nested(self, Nested::Body(expr))?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end the outer cbox\n             }\n             hir::ItemFn(ref decl, unsafety, constness, abi, ref typarams, body) => {\n@@ -613,7 +612,7 @@ impl<'a> State<'a> {\n                               &item.vis,\n                               &[],\n                               Some(body))?;\n-                word(&mut self.s, \" \")?;\n+                self.s.word(\" \")?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n                 self.ann.nested(self, Nested::Body(body))?;\n@@ -635,7 +634,7 @@ impl<'a> State<'a> {\n             }\n             hir::ItemGlobalAsm(ref ga) => {\n                 self.head(&visibility_qualified(&item.vis, \"global asm\"))?;\n-                word(&mut self.s, &ga.asm.as_str())?;\n+                self.s.word(&ga.asm.as_str())?;\n                 self.end()?\n             }\n             hir::ItemTy(ref ty, ref params) => {\n@@ -647,10 +646,10 @@ impl<'a> State<'a> {\n                 self.end()?; // end the inner ibox\n \n                 self.print_where_clause(&params.where_clause)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_type(&ty)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end the outer ibox\n             }\n             hir::ItemEnum(ref enum_definition, ref params) => {\n@@ -670,7 +669,7 @@ impl<'a> State<'a> {\n                 self.print_unsafety(unsafety)?;\n                 self.word_nbsp(\"impl\")?;\n                 self.print_trait_ref(trait_ref)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"for\")?;\n                 self.word_space(\"..\")?;\n                 self.bopen()?;\n@@ -691,20 +690,20 @@ impl<'a> State<'a> {\n \n                 if generics.is_parameterized() {\n                     self.print_generics(generics)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                 }\n \n                 match polarity {\n                     hir::ImplPolarity::Negative => {\n-                        word(&mut self.s, \"!\")?;\n+                        self.s.word(\"!\")?;\n                     }\n                     _ => {}\n                 }\n \n                 match opt_trait {\n                     &Some(ref t) => {\n                         self.print_trait_ref(t)?;\n-                        space(&mut self.s)?;\n+                        self.s.space()?;\n                         self.word_space(\"for\")?;\n                     }\n                     &None => {}\n@@ -713,7 +712,7 @@ impl<'a> State<'a> {\n                 self.print_type(&ty)?;\n                 self.print_where_clause(&generics.where_clause)?;\n \n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.bopen()?;\n                 self.print_inner_attributes(&item.attrs)?;\n                 for impl_item in impl_items {\n@@ -731,7 +730,7 @@ impl<'a> State<'a> {\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 for b in bounds.iter() {\n                     if let TraitTyParamBound(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n-                        space(&mut self.s)?;\n+                        self.s.space()?;\n                         self.word_space(\"for ?\")?;\n                         self.print_trait_ref(&ptr.trait_ref)?;\n                     } else {\n@@ -740,7 +739,7 @@ impl<'a> State<'a> {\n                 }\n                 self.print_bounds(\":\", &real_bounds[..])?;\n                 self.print_where_clause(&generics.where_clause)?;\n-                word(&mut self.s, \" \")?;\n+                self.s.word(\" \")?;\n                 self.bopen()?;\n                 for trait_item in trait_items {\n                     self.ann.nested(self, Nested::TraitItem(trait_item.id))?;\n@@ -757,7 +756,7 @@ impl<'a> State<'a> {\n \n     fn print_formal_lifetime_list(&mut self, lifetimes: &[hir::LifetimeDef]) -> io::Result<()> {\n         if !lifetimes.is_empty() {\n-            word(&mut self.s, \"for<\")?;\n+            self.s.word(\"for<\")?;\n             let mut comma = false;\n             for lifetime_def in lifetimes {\n                 if comma {\n@@ -766,7 +765,7 @@ impl<'a> State<'a> {\n                 self.print_lifetime_def(lifetime_def)?;\n                 comma = true;\n             }\n-            word(&mut self.s, \">\")?;\n+            self.s.word(\">\")?;\n         }\n         Ok(())\n     }\n@@ -787,7 +786,7 @@ impl<'a> State<'a> {\n         self.print_name(name)?;\n         self.print_generics(generics)?;\n         self.print_where_clause(&generics.where_clause)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.print_variants(&enum_definition.variants, span)\n     }\n \n@@ -802,7 +801,7 @@ impl<'a> State<'a> {\n             self.print_outer_attributes(&v.node.attrs)?;\n             self.ibox(indent_unit)?;\n             self.print_variant(v)?;\n-            word(&mut self.s, \",\")?;\n+            self.s.word(\",\")?;\n             self.end()?;\n             self.maybe_print_trailing_comment(v.span, None)?;\n         }\n@@ -814,7 +813,7 @@ impl<'a> State<'a> {\n             hir::Public => self.word_nbsp(\"pub\"),\n             hir::Visibility::Crate => self.word_nbsp(\"pub(crate)\"),\n             hir::Visibility::Restricted { ref path, .. } => {\n-                word(&mut self.s, \"pub(\")?;\n+                self.s.word(\"pub(\")?;\n                 self.print_path(path, false)?;\n                 self.word_nbsp(\")\")\n             }\n@@ -852,7 +851,7 @@ impl<'a> State<'a> {\n             }\n             self.print_where_clause(&generics.where_clause)?;\n             if print_finalizer {\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n             }\n             self.end()?;\n             self.end() // close the outer-box\n@@ -870,7 +869,7 @@ impl<'a> State<'a> {\n                 self.print_name(field.name)?;\n                 self.word_nbsp(\":\")?;\n                 self.print_type(&field.ty)?;\n-                word(&mut self.s, \",\")?;\n+                self.s.word(\",\")?;\n             }\n \n             self.bclose(span)\n@@ -882,7 +881,7 @@ impl<'a> State<'a> {\n         let generics = hir::Generics::empty();\n         self.print_struct(&v.node.data, &generics, v.node.name, v.span, false)?;\n         if let Some(d) = v.node.disr_expr {\n-            space(&mut self.s)?;\n+            self.s.space()?;\n             self.word_space(\"=\")?;\n             self.ann.nested(self, Nested::Body(d))?;\n         }\n@@ -917,7 +916,7 @@ impl<'a> State<'a> {\n             }\n             hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Required(ref arg_names)) => {\n                 self.print_method_sig(ti.name, sig, &hir::Inherited, arg_names, None)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n             }\n             hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body)) => {\n                 self.head(\"\")?;\n@@ -975,11 +974,11 @@ impl<'a> State<'a> {\n             hir::StmtSemi(ref expr, _) => {\n                 self.space_if_not_bol()?;\n                 self.print_expr(&expr)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n             }\n         }\n         if stmt_ends_with_semi(&st.node) {\n-            word(&mut self.s, \";\")?;\n+            self.s.word(\";\")?;\n         }\n         self.maybe_print_trailing_comment(st.span, None)\n     }\n@@ -1047,17 +1046,17 @@ impl<'a> State<'a> {\n                     hir::ExprIf(ref i, ref then, ref e) => {\n                         self.cbox(indent_unit - 1)?;\n                         self.ibox(0)?;\n-                        word(&mut self.s, \" else if \")?;\n+                        self.s.word(\" else if \")?;\n                         self.print_expr(&i)?;\n-                        space(&mut self.s)?;\n+                        self.s.space()?;\n                         self.print_expr(&then)?;\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"final else\"\n                     hir::ExprBlock(ref b) => {\n                         self.cbox(indent_unit - 1)?;\n                         self.ibox(0)?;\n-                        word(&mut self.s, \" else \")?;\n+                        self.s.word(\" else \")?;\n                         self.print_block(&b)\n                     }\n                     // BLEAH, constraints would be great here\n@@ -1077,7 +1076,7 @@ impl<'a> State<'a> {\n                     -> io::Result<()> {\n         self.head(\"if\")?;\n         self.print_expr(test)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.print_expr(blk)?;\n         self.print_else(elseopt)\n     }\n@@ -1090,10 +1089,10 @@ impl<'a> State<'a> {\n                         -> io::Result<()> {\n         self.head(\"if let\")?;\n         self.print_pat(pat)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.word_space(\"=\")?;\n         self.print_expr(expr)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.print_block(blk)?;\n         self.print_else(elseopt)\n     }\n@@ -1119,19 +1118,19 @@ impl<'a> State<'a> {\n \n     fn print_expr_vec(&mut self, exprs: &[hir::Expr]) -> io::Result<()> {\n         self.ibox(indent_unit)?;\n-        word(&mut self.s, \"[\")?;\n+        self.s.word(\"[\")?;\n         self.commasep_exprs(Inconsistent, exprs)?;\n-        word(&mut self.s, \"]\")?;\n+        self.s.word(\"]\")?;\n         self.end()\n     }\n \n     fn print_expr_repeat(&mut self, element: &hir::Expr, count: hir::BodyId) -> io::Result<()> {\n         self.ibox(indent_unit)?;\n-        word(&mut self.s, \"[\")?;\n+        self.s.word(\"[\")?;\n         self.print_expr(element)?;\n         self.word_space(\";\")?;\n         self.ann.nested(self, Nested::Body(count))?;\n-        word(&mut self.s, \"]\")?;\n+        self.s.word(\"]\")?;\n         self.end()\n     }\n \n@@ -1141,7 +1140,7 @@ impl<'a> State<'a> {\n                          wth: &Option<P<hir::Expr>>)\n                          -> io::Result<()> {\n         self.print_qpath(qpath, true)?;\n-        word(&mut self.s, \"{\")?;\n+        self.s.word(\"{\")?;\n         self.commasep_cmnt(Consistent,\n                            &fields[..],\n                            |s, field| {\n@@ -1158,26 +1157,26 @@ impl<'a> State<'a> {\n             Some(ref expr) => {\n                 self.ibox(indent_unit)?;\n                 if !fields.is_empty() {\n-                    word(&mut self.s, \",\")?;\n-                    space(&mut self.s)?;\n+                    self.s.word(\",\")?;\n+                    self.s.space()?;\n                 }\n-                word(&mut self.s, \"..\")?;\n+                self.s.word(\"..\")?;\n                 self.print_expr(&expr)?;\n                 self.end()?;\n             }\n             _ => if !fields.is_empty() {\n-                word(&mut self.s, \",\")?\n+                self.s.word(\",\")?\n             },\n         }\n-        word(&mut self.s, \"}\")?;\n+        self.s.word(\"}\")?;\n         Ok(())\n     }\n \n     fn print_expr_tup(&mut self, exprs: &[hir::Expr]) -> io::Result<()> {\n         self.popen()?;\n         self.commasep_exprs(Inconsistent, exprs)?;\n         if exprs.len() == 1 {\n-            word(&mut self.s, \",\")?;\n+            self.s.word(\",\")?;\n         }\n         self.pclose()\n     }\n@@ -1193,7 +1192,7 @@ impl<'a> State<'a> {\n                               -> io::Result<()> {\n         let base_args = &args[1..];\n         self.print_expr(&args[0])?;\n-        word(&mut self.s, \".\")?;\n+        self.s.word(\".\")?;\n         self.print_name(segment.name)?;\n         if !segment.parameters.lifetimes().is_empty() ||\n                 !segment.parameters.types().is_empty() ||\n@@ -1209,21 +1208,21 @@ impl<'a> State<'a> {\n                          rhs: &hir::Expr)\n                          -> io::Result<()> {\n         self.print_expr(lhs)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.word_space(op.node.as_str())?;\n         self.print_expr(rhs)\n     }\n \n     fn print_expr_unary(&mut self, op: hir::UnOp, expr: &hir::Expr) -> io::Result<()> {\n-        word(&mut self.s, op.as_str())?;\n+        self.s.word(op.as_str())?;\n         self.print_expr_maybe_paren(expr)\n     }\n \n     fn print_expr_addr_of(&mut self,\n                           mutability: hir::Mutability,\n                           expr: &hir::Expr)\n                           -> io::Result<()> {\n-        word(&mut self.s, \"&\")?;\n+        self.s.word(\"&\")?;\n         self.print_mutability(mutability)?;\n         self.print_expr_maybe_paren(expr)\n     }\n@@ -1270,7 +1269,7 @@ impl<'a> State<'a> {\n             }\n             hir::ExprCast(ref expr, ref ty) => {\n                 self.print_expr(&expr)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"as\")?;\n                 self.print_type(&ty)?;\n             }\n@@ -1289,7 +1288,7 @@ impl<'a> State<'a> {\n                 }\n                 self.head(\"while\")?;\n                 self.print_expr(&test)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.print_block(&blk)?;\n             }\n             hir::ExprLoop(ref blk, opt_sp_name, _) => {\n@@ -1298,15 +1297,15 @@ impl<'a> State<'a> {\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"loop\")?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.print_block(&blk)?;\n             }\n             hir::ExprMatch(ref expr, ref arms, _) => {\n                 self.cbox(indent_unit)?;\n                 self.ibox(4)?;\n                 self.word_nbsp(\"match\")?;\n                 self.print_expr(&expr)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.bopen()?;\n                 for arm in arms {\n                     self.print_arm(arm)?;\n@@ -1317,7 +1316,7 @@ impl<'a> State<'a> {\n                 self.print_capture_clause(capture_clause)?;\n \n                 self.print_closure_args(&decl, body)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n \n                 // this is a bare expression\n                 self.ann.nested(self, Nested::Body(body))?;\n@@ -1337,68 +1336,68 @@ impl<'a> State<'a> {\n             }\n             hir::ExprAssign(ref lhs, ref rhs) => {\n                 self.print_expr(&lhs)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_expr(&rhs)?;\n             }\n             hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n                 self.print_expr(&lhs)?;\n-                space(&mut self.s)?;\n-                word(&mut self.s, op.node.as_str())?;\n+                self.s.space()?;\n+                self.s.word(op.node.as_str())?;\n                 self.word_space(\"=\")?;\n                 self.print_expr(&rhs)?;\n             }\n             hir::ExprField(ref expr, name) => {\n                 self.print_expr(&expr)?;\n-                word(&mut self.s, \".\")?;\n+                self.s.word(\".\")?;\n                 self.print_name(name.node)?;\n             }\n             hir::ExprTupField(ref expr, id) => {\n                 self.print_expr(&expr)?;\n-                word(&mut self.s, \".\")?;\n+                self.s.word(\".\")?;\n                 self.print_usize(id.node)?;\n             }\n             hir::ExprIndex(ref expr, ref index) => {\n                 self.print_expr(&expr)?;\n-                word(&mut self.s, \"[\")?;\n+                self.s.word(\"[\")?;\n                 self.print_expr(&index)?;\n-                word(&mut self.s, \"]\")?;\n+                self.s.word(\"]\")?;\n             }\n             hir::ExprPath(ref qpath) => {\n                 self.print_qpath(qpath, true)?\n             }\n             hir::ExprBreak(label, ref opt_expr) => {\n-                word(&mut self.s, \"break\")?;\n-                space(&mut self.s)?;\n+                self.s.word(\"break\")?;\n+                self.s.space()?;\n                 if let Some(label_ident) = label.ident {\n                     self.print_name(label_ident.node.name)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                 }\n                 if let Some(ref expr) = *opt_expr {\n                     self.print_expr(expr)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                 }\n             }\n             hir::ExprAgain(label) => {\n-                word(&mut self.s, \"continue\")?;\n-                space(&mut self.s)?;\n+                self.s.word(\"continue\")?;\n+                self.s.space()?;\n                 if let Some(label_ident) = label.ident {\n                     self.print_name(label_ident.node.name)?;\n-                    space(&mut self.s)?\n+                    self.s.space()?\n                 }\n             }\n             hir::ExprRet(ref result) => {\n-                word(&mut self.s, \"return\")?;\n+                self.s.word(\"return\")?;\n                 match *result {\n                     Some(ref expr) => {\n-                        word(&mut self.s, \" \")?;\n+                        self.s.word(\" \")?;\n                         self.print_expr(&expr)?;\n                     }\n                     _ => (),\n                 }\n             }\n             hir::ExprInlineAsm(ref a, ref outputs, ref inputs) => {\n-                word(&mut self.s, \"asm!\")?;\n+                self.s.word(\"asm!\")?;\n                 self.popen()?;\n                 self.print_string(&a.asm.as_str(), a.asm_str_style)?;\n                 self.word_space(\":\")?;\n@@ -1420,7 +1419,7 @@ impl<'a> State<'a> {\n                     out_idx += 1;\n                     Ok(())\n                 })?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\":\")?;\n \n                 let mut in_idx = 0;\n@@ -1432,7 +1431,7 @@ impl<'a> State<'a> {\n                     in_idx += 1;\n                     Ok(())\n                 })?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\":\")?;\n \n                 self.commasep(Inconsistent, &a.clobbers, |s, co| {\n@@ -1452,7 +1451,7 @@ impl<'a> State<'a> {\n                 }\n \n                 if !options.is_empty() {\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                     self.word_space(\":\")?;\n                     self.commasep(Inconsistent, &options, |s, &co| {\n                         s.print_string(co, ast::StrStyle::Cooked)?;\n@@ -1501,17 +1500,17 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_usize(&mut self, i: usize) -> io::Result<()> {\n-        word(&mut self.s, &i.to_string())\n+        self.s.word(&i.to_string())\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) -> io::Result<()> {\n-        word(&mut self.s, &name.as_str())?;\n+        self.s.word(&name.as_str())?;\n         self.ann.post(self, NodeName(&name))\n     }\n \n     pub fn print_for_decl(&mut self, loc: &hir::Local, coll: &hir::Expr) -> io::Result<()> {\n         self.print_local_decl(loc)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.word_space(\"in\")?;\n         self.print_expr(coll)\n     }\n@@ -1524,7 +1523,7 @@ impl<'a> State<'a> {\n \n         for (i, segment) in path.segments.iter().enumerate() {\n             if i > 0 {\n-                word(&mut self.s, \"::\")?\n+                self.s.word(\"::\")?\n             }\n             if segment.name != keywords::CrateRoot.name() &&\n                segment.name != keywords::DollarCrate.name() {\n@@ -1545,14 +1544,14 @@ impl<'a> State<'a> {\n                 self.print_path(path, colons_before_params)\n             }\n             hir::QPath::Resolved(Some(ref qself), ref path) => {\n-                word(&mut self.s, \"<\")?;\n+                self.s.word(\"<\")?;\n                 self.print_type(qself)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"as\")?;\n \n                 for (i, segment) in path.segments[..path.segments.len() - 1].iter().enumerate() {\n                     if i > 0 {\n-                        word(&mut self.s, \"::\")?\n+                        self.s.word(\"::\")?\n                     }\n                     if segment.name != keywords::CrateRoot.name() &&\n                        segment.name != keywords::DollarCrate.name() {\n@@ -1561,17 +1560,17 @@ impl<'a> State<'a> {\n                     }\n                 }\n \n-                word(&mut self.s, \">\")?;\n-                word(&mut self.s, \"::\")?;\n+                self.s.word(\">\")?;\n+                self.s.word(\"::\")?;\n                 let item_segment = path.segments.last().unwrap();\n                 self.print_name(item_segment.name)?;\n                 self.print_path_parameters(&item_segment.parameters, colons_before_params)\n             }\n             hir::QPath::TypeRelative(ref qself, ref item_segment) => {\n-                word(&mut self.s, \"<\")?;\n+                self.s.word(\"<\")?;\n                 self.print_type(qself)?;\n-                word(&mut self.s, \">\")?;\n-                word(&mut self.s, \"::\")?;\n+                self.s.word(\">\")?;\n+                self.s.word(\"::\")?;\n                 self.print_name(item_segment.name)?;\n                 self.print_path_parameters(&item_segment.parameters, colons_before_params)\n             }\n@@ -1589,7 +1588,7 @@ impl<'a> State<'a> {\n                 let start_or_comma = |this: &mut Self| {\n                     if empty.get() {\n                         empty.set(false);\n-                        word(&mut this.s, start)\n+                        this.s.word(start)\n                     } else {\n                         this.word_space(\",\")\n                     }\n@@ -1611,26 +1610,26 @@ impl<'a> State<'a> {\n                 // \"non-exhaustive patterns: `Some::<..>(_)` not covered\".\n                 if data.infer_types && false {\n                     start_or_comma(self)?;\n-                    word(&mut self.s, \"..\")?;\n+                    self.s.word(\"..\")?;\n                 }\n \n                 for binding in data.bindings.iter() {\n                     start_or_comma(self)?;\n                     self.print_name(binding.name)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                     self.word_space(\"=\")?;\n                     self.print_type(&binding.ty)?;\n                 }\n \n                 if !empty.get() {\n-                    word(&mut self.s, \">\")?\n+                    self.s.word(\">\")?\n                 }\n             }\n \n             hir::ParenthesizedParameters(ref data) => {\n-                word(&mut self.s, \"(\")?;\n+                self.s.word(\"(\")?;\n                 self.commasep(Inconsistent, &data.inputs, |s, ty| s.print_type(&ty))?;\n-                word(&mut self.s, \")\")?;\n+                self.s.word(\")\")?;\n \n                 if let Some(ref ty) = data.output {\n                     self.space_if_not_bol()?;\n@@ -1649,7 +1648,7 @@ impl<'a> State<'a> {\n         // Pat isn't normalized, but the beauty of it\n         // is that it doesn't matter\n         match pat.node {\n-            PatKind::Wild => word(&mut self.s, \"_\")?,\n+            PatKind::Wild => self.s.word(\"_\")?,\n             PatKind::Binding(binding_mode, _, ref path1, ref sub) => {\n                 match binding_mode {\n                     hir::BindByRef(mutbl) => {\n@@ -1663,7 +1662,7 @@ impl<'a> State<'a> {\n                 }\n                 self.print_name(path1.node)?;\n                 if let Some(ref p) = *sub {\n-                    word(&mut self.s, \"@\")?;\n+                    self.s.word(\"@\")?;\n                     self.print_pat(&p)?;\n                 }\n             }\n@@ -1675,9 +1674,9 @@ impl<'a> State<'a> {\n                     if ddpos != 0 {\n                         self.word_space(\",\")?;\n                     }\n-                    word(&mut self.s, \"..\")?;\n+                    self.s.word(\"..\")?;\n                     if ddpos != elts.len() {\n-                        word(&mut self.s, \",\")?;\n+                        self.s.word(\",\")?;\n                         self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p))?;\n                     }\n                 } else {\n@@ -1708,10 +1707,10 @@ impl<'a> State<'a> {\n                     if !fields.is_empty() {\n                         self.word_space(\",\")?;\n                     }\n-                    word(&mut self.s, \"..\")?;\n+                    self.s.word(\"..\")?;\n                 }\n-                space(&mut self.s)?;\n-                word(&mut self.s, \"}\")?;\n+                self.s.space()?;\n+                self.s.word(\"}\")?;\n             }\n             PatKind::Tuple(ref elts, ddpos) => {\n                 self.popen()?;\n@@ -1720,42 +1719,42 @@ impl<'a> State<'a> {\n                     if ddpos != 0 {\n                         self.word_space(\",\")?;\n                     }\n-                    word(&mut self.s, \"..\")?;\n+                    self.s.word(\"..\")?;\n                     if ddpos != elts.len() {\n-                        word(&mut self.s, \",\")?;\n+                        self.s.word(\",\")?;\n                         self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p))?;\n                     }\n                 } else {\n                     self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p))?;\n                     if elts.len() == 1 {\n-                        word(&mut self.s, \",\")?;\n+                        self.s.word(\",\")?;\n                     }\n                 }\n                 self.pclose()?;\n             }\n             PatKind::Box(ref inner) => {\n-                word(&mut self.s, \"box \")?;\n+                self.s.word(\"box \")?;\n                 self.print_pat(&inner)?;\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n-                word(&mut self.s, \"&\")?;\n+                self.s.word(\"&\")?;\n                 if mutbl == hir::MutMutable {\n-                    word(&mut self.s, \"mut \")?;\n+                    self.s.word(\"mut \")?;\n                 }\n                 self.print_pat(&inner)?;\n             }\n             PatKind::Lit(ref e) => self.print_expr(&e)?,\n             PatKind::Range(ref begin, ref end, ref end_kind) => {\n                 self.print_expr(&begin)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 match *end_kind {\n-                    RangeEnd::Included => word(&mut self.s, \"...\")?,\n-                    RangeEnd::Excluded => word(&mut self.s, \"..\")?,\n+                    RangeEnd::Included => self.s.word(\"...\")?,\n+                    RangeEnd::Excluded => self.s.word(\"..\")?,\n                 }\n                 self.print_expr(&end)?;\n             }\n             PatKind::Slice(ref before, ref slice, ref after) => {\n-                word(&mut self.s, \"[\")?;\n+                self.s.word(\"[\")?;\n                 self.commasep(Inconsistent, &before[..], |s, p| s.print_pat(&p))?;\n                 if let Some(ref p) = *slice {\n                     if !before.is_empty() {\n@@ -1764,13 +1763,13 @@ impl<'a> State<'a> {\n                     if p.node != PatKind::Wild {\n                         self.print_pat(&p)?;\n                     }\n-                    word(&mut self.s, \"..\")?;\n+                    self.s.word(\"..\")?;\n                     if !after.is_empty() {\n                         self.word_space(\",\")?;\n                     }\n                 }\n                 self.commasep(Inconsistent, &after[..], |s, p| s.print_pat(&p))?;\n-                word(&mut self.s, \"]\")?;\n+                self.s.word(\"]\")?;\n             }\n         }\n         self.ann.post(self, NodePat(pat))\n@@ -1780,7 +1779,7 @@ impl<'a> State<'a> {\n         // I have no idea why this check is necessary, but here it\n         // is :(\n         if arm.attrs.is_empty() {\n-            space(&mut self.s)?;\n+            self.s.space()?;\n         }\n         self.cbox(indent_unit)?;\n         self.ibox(0)?;\n@@ -1790,16 +1789,16 @@ impl<'a> State<'a> {\n             if first {\n                 first = false;\n             } else {\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"|\")?;\n             }\n             self.print_pat(&p)?;\n         }\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         if let Some(ref e) = arm.guard {\n             self.word_space(\"if\")?;\n             self.print_expr(&e)?;\n-            space(&mut self.s)?;\n+            self.s.space()?;\n         }\n         self.word_space(\"=>\")?;\n \n@@ -1810,13 +1809,13 @@ impl<'a> State<'a> {\n \n                 // If it is a user-provided unsafe block, print a comma after it\n                 if let hir::UnsafeBlock(hir::UserProvided) = blk.rules {\n-                    word(&mut self.s, \",\")?;\n+                    self.s.word(\",\")?;\n                 }\n             }\n             _ => {\n                 self.end()?; // close the ibox for the pattern\n                 self.print_expr(&arm.body)?;\n-                word(&mut self.s, \",\")?;\n+                self.s.word(\",\")?;\n             }\n         }\n         self.end() // close enclosing cbox\n@@ -1848,20 +1847,20 @@ impl<'a> State<'a> {\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n             s.ibox(indent_unit)?;\n             if let Some(name) = arg_names.get(i) {\n-                word(&mut s.s, &name.node.as_str())?;\n-                word(&mut s.s, \":\")?;\n-                space(&mut s.s)?;\n+                s.s.word(&name.node.as_str())?;\n+                s.s.word(\":\")?;\n+                s.s.space()?;\n             } else if let Some(body_id) = body_id {\n                 s.ann.nested(s, Nested::BodyArgPat(body_id, i))?;\n-                word(&mut s.s, \":\")?;\n-                space(&mut s.s)?;\n+                s.s.word(\":\")?;\n+                s.s.space()?;\n             }\n             i += 1;\n             s.print_type(ty)?;\n             s.end()\n         })?;\n         if decl.variadic {\n-            word(&mut self.s, \", ...\")?;\n+            self.s.word(\", ...\")?;\n         }\n         self.pclose()?;\n \n@@ -1870,7 +1869,7 @@ impl<'a> State<'a> {\n     }\n \n     fn print_closure_args(&mut self, decl: &hir::FnDecl, body_id: hir::BodyId) -> io::Result<()> {\n-        word(&mut self.s, \"|\")?;\n+        self.s.word(\"|\")?;\n         let mut i = 0;\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n             s.ibox(indent_unit)?;\n@@ -1879,13 +1878,13 @@ impl<'a> State<'a> {\n             i += 1;\n \n             if ty.node != hir::TyInfer {\n-                word(&mut s.s, \":\")?;\n-                space(&mut s.s)?;\n+                s.s.word(\":\")?;\n+                s.s.space()?;\n                 s.print_type(ty)?;\n             }\n             s.end()\n         })?;\n-        word(&mut self.s, \"|\")?;\n+        self.s.word(\"|\")?;\n \n         if let hir::DefaultReturn(..) = decl.output {\n             return Ok(());\n@@ -1911,7 +1910,7 @@ impl<'a> State<'a> {\n \n     pub fn print_bounds(&mut self, prefix: &str, bounds: &[hir::TyParamBound]) -> io::Result<()> {\n         if !bounds.is_empty() {\n-            word(&mut self.s, prefix)?;\n+            self.s.word(prefix)?;\n             let mut first = true;\n             for bound in bounds {\n                 self.nbsp()?;\n@@ -1926,7 +1925,7 @@ impl<'a> State<'a> {\n                         self.print_poly_trait_ref(tref)\n                     }\n                     TraitTyParamBound(ref tref, TraitBoundModifier::Maybe) => {\n-                        word(&mut self.s, \"?\")?;\n+                        self.s.word(\"?\")?;\n                         self.print_poly_trait_ref(tref)\n                     }\n                     RegionTyParamBound(ref lt) => {\n@@ -1948,7 +1947,7 @@ impl<'a> State<'a> {\n         self.print_lifetime(&lifetime.lifetime)?;\n         let mut sep = \":\";\n         for v in &lifetime.bounds {\n-            word(&mut self.s, sep)?;\n+            self.s.word(sep)?;\n             self.print_lifetime(v)?;\n             sep = \"+\";\n         }\n@@ -1961,7 +1960,7 @@ impl<'a> State<'a> {\n             return Ok(());\n         }\n \n-        word(&mut self.s, \"<\")?;\n+        self.s.word(\"<\")?;\n \n         let mut ints = Vec::new();\n         for i in 0..total {\n@@ -1979,7 +1978,7 @@ impl<'a> State<'a> {\n             }\n         })?;\n \n-        word(&mut self.s, \">\")?;\n+        self.s.word(\">\")?;\n         Ok(())\n     }\n \n@@ -1988,7 +1987,7 @@ impl<'a> State<'a> {\n         self.print_bounds(\":\", &param.bounds)?;\n         match param.default {\n             Some(ref default) => {\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_type(&default)\n             }\n@@ -2001,7 +2000,7 @@ impl<'a> State<'a> {\n             return Ok(());\n         }\n \n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.word_space(\"where\")?;\n \n         for (i, predicate) in where_clause.predicates.iter().enumerate() {\n@@ -2022,21 +2021,21 @@ impl<'a> State<'a> {\n                                                                                 ref bounds,\n                                                                                 ..}) => {\n                     self.print_lifetime(lifetime)?;\n-                    word(&mut self.s, \":\")?;\n+                    self.s.word(\":\")?;\n \n                     for (i, bound) in bounds.iter().enumerate() {\n                         self.print_lifetime(bound)?;\n \n                         if i != 0 {\n-                            word(&mut self.s, \":\")?;\n+                            self.s.word(\":\")?;\n                         }\n                     }\n                 }\n                 &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{ref lhs_ty,\n                                                                         ref rhs_ty,\n                                                                         ..}) => {\n                     self.print_type(lhs_ty)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                     self.word_space(\"=\")?;\n                     self.print_type(rhs_ty)?;\n                 }\n@@ -2087,7 +2086,7 @@ impl<'a> State<'a> {\n                        -> io::Result<()> {\n         self.ibox(indent_unit)?;\n         if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n-            word(&mut self.s, \"for\")?;\n+            self.s.word(\"for\")?;\n             self.print_generics(generics)?;\n         }\n         let generics = hir::Generics {\n@@ -2142,7 +2141,7 @@ impl<'a> State<'a> {\n         // If there aren't any remaining comments, then we need to manually\n         // make sure there is a line break at the end.\n         if self.next_comment().is_none() {\n-            hardbreak(&mut self.s)?;\n+            self.s.hardbreak()?;\n         }\n         loop {\n             match self.next_comment() {\n@@ -2185,7 +2184,7 @@ impl<'a> State<'a> {\n                                 abi: Abi,\n                                 vis: &hir::Visibility)\n                                 -> io::Result<()> {\n-        word(&mut self.s, &visibility_qualified(vis, \"\"))?;\n+        self.s.word(&visibility_qualified(vis, \"\"))?;\n         self.print_unsafety(unsafety)?;\n \n         match constness {\n@@ -2198,7 +2197,7 @@ impl<'a> State<'a> {\n             self.word_nbsp(&abi.to_string())?;\n         }\n \n-        word(&mut self.s, \"fn\")\n+        self.s.word(\"fn\")\n     }\n \n     pub fn print_unsafety(&mut self, s: hir::Unsafety) -> io::Result<()> {"}, {"sha": "f6be709009177920bb2a58f62593943826036fdb", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bac4bb96137cad937e4986b37d9e4273d1f01dcf/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac4bb96137cad937e4986b37d9e4273d1f01dcf/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=bac4bb96137cad937e4986b37d9e4273d1f01dcf", "patch": "@@ -21,7 +21,6 @@ use std::io;\n use std::mem;\n use std::usize;\n use syntax::ast;\n-use syntax::print::pp;\n use syntax::print::pprust::PrintState;\n use util::nodemap::NodeMap;\n use hir;\n@@ -157,7 +156,7 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n             ps.synth_comment(\n                 format!(\"id {}: {}{}{}{}\", id, entry_str,\n                         gens_str, action_kills_str, scope_kills_str))?;\n-            pp::space(&mut ps.s)?;\n+            ps.s.space()?;\n         }\n         Ok(())\n     }"}, {"sha": "d5702155c24c4b6785c1bc488242d15756229a70", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bac4bb96137cad937e4986b37d9e4273d1f01dcf/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac4bb96137cad937e4986b37d9e4273d1f01dcf/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=bac4bb96137cad937e4986b37d9e4273d1f01dcf", "patch": "@@ -30,7 +30,7 @@ use rustc_mir::util::{write_mir_pretty, write_mir_graphviz};\n \n use syntax::ast::{self, BlockCheckMode};\n use syntax::fold::{self, Folder};\n-use syntax::print::{pp, pprust};\n+use syntax::print::{pprust};\n use syntax::print::pprust::PrintState;\n use syntax::ptr::P;\n use syntax::util::small_vector::SmallVector;\n@@ -357,24 +357,24 @@ impl<'hir> pprust::PpAnn for IdentifiedAnnotation<'hir> {\n             pprust::NodeName(_) => Ok(()),\n \n             pprust::NodeItem(item) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(item.id.to_string())\n             }\n             pprust::NodeSubItem(id) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(id.to_string())\n             }\n             pprust::NodeBlock(blk) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(format!(\"block {}\", blk.id))\n             }\n             pprust::NodeExpr(expr) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(expr.id.to_string())?;\n                 s.pclose()\n             }\n             pprust::NodePat(pat) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(format!(\"pat {}\", pat.id))\n             }\n         }\n@@ -414,24 +414,24 @@ impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n         match node {\n             pprust_hir::NodeName(_) => Ok(()),\n             pprust_hir::NodeItem(item) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(item.id.to_string())\n             }\n             pprust_hir::NodeSubItem(id) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(id.to_string())\n             }\n             pprust_hir::NodeBlock(blk) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(format!(\"block {}\", blk.id))\n             }\n             pprust_hir::NodeExpr(expr) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(expr.id.to_string())?;\n                 s.pclose()\n             }\n             pprust_hir::NodePat(pat) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(format!(\"pat {}\", pat.id))\n             }\n         }\n@@ -456,13 +456,13 @@ impl<'a> pprust::PpAnn for HygieneAnnotation<'a> {\n     fn post(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n             pprust::NodeIdent(&ast::Ident { name, ctxt }) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 // FIXME #16420: this doesn't display the connections\n                 // between syntax contexts\n                 s.synth_comment(format!(\"{}{:?}\", name.as_u32(), ctxt))\n             }\n             pprust::NodeName(&name) => {\n-                pp::space(&mut s.s)?;\n+                s.s.space()?;\n                 s.synth_comment(name.as_u32().to_string())\n             }\n             _ => Ok(()),\n@@ -514,10 +514,10 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n     fn post(&self, s: &mut pprust_hir::State, node: pprust_hir::AnnNode) -> io::Result<()> {\n         match node {\n             pprust_hir::NodeExpr(expr) => {\n-                pp::space(&mut s.s)?;\n-                pp::word(&mut s.s, \"as\")?;\n-                pp::space(&mut s.s)?;\n-                pp::word(&mut s.s, &self.tables.get().expr_ty(expr).to_string())?;\n+                s.s.space()?;\n+                s.s.word(\"as\")?;\n+                s.s.space()?;\n+                s.s.word(&self.tables.get().expr_ty(expr).to_string())?;\n                 s.pclose()\n             }\n             _ => Ok(()),\n@@ -945,13 +945,13 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                     for node_id in uii.all_matching_node_ids(hir_map) {\n                         let node = hir_map.get(node_id);\n                         pp_state.print_node(node)?;\n-                        pp::space(&mut pp_state.s)?;\n+                        pp_state.s.space()?;\n                         let path = annotation.node_path(node_id)\n                             .expect(\"--unpretty missing node paths\");\n                         pp_state.synth_comment(path)?;\n-                        pp::hardbreak(&mut pp_state.s)?;\n+                        pp_state.s.hardbreak()?;\n                     }\n-                    pp::eof(&mut pp_state.s)\n+                    pp_state.s.eof()\n                 })\n             }\n             _ => unreachable!(),"}, {"sha": "74b2ea1df323a178519b6b4a29f81bb6258b3ec2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bac4bb96137cad937e4986b37d9e4273d1f01dcf/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac4bb96137cad937e4986b37d9e4273d1f01dcf/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=bac4bb96137cad937e4986b37d9e4273d1f01dcf", "patch": "@@ -1480,10 +1480,9 @@ impl<'a> Parser<'a> {\n         match ty.node {\n             TyKind::Rptr(ref lifetime, ref mut_ty) => {\n                 let sum_with_parens = pprust::to_string(|s| {\n-                    use print::pp::word;\n                     use print::pprust::PrintState;\n \n-                    word(&mut s.s, \"&\")?;\n+                    s.s.word(\"&\")?;\n                     s.print_opt_lifetime(lifetime)?;\n                     s.print_mutability(mut_ty.mutbl)?;\n                     s.popen()?;\n@@ -2542,14 +2541,13 @@ impl<'a> Parser<'a> {\n                         };\n                         let sugg = pprust::to_string(|s| {\n                             use print::pprust::PrintState;\n-                            use print::pp::word;\n                             s.popen()?;\n                             s.print_expr(&e)?;\n-                            word(&mut s.s, \".\")?;\n+                            s.s.word( \".\")?;\n                             s.print_usize(float.trunc() as usize)?;\n                             s.pclose()?;\n-                            word(&mut s.s, \".\")?;\n-                            word(&mut s.s, fstr.splitn(2, \".\").last().unwrap())\n+                            s.s.word(\".\")?;\n+                            s.s.word(fstr.splitn(2, \".\").last().unwrap())\n                         });\n                         err.span_suggestion(\n                             lo.to(self.prev_span),"}, {"sha": "3ce9e9d07b30cfa198cb43d48f3fba19688e436e", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/bac4bb96137cad937e4986b37d9e4273d1f01dcf/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac4bb96137cad937e4986b37d9e4273d1f01dcf/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=bac4bb96137cad937e4986b37d9e4273d1f01dcf", "patch": "@@ -262,7 +262,7 @@ pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n }\n \n pub struct Printer<'a> {\n-    pub out: Box<io::Write+'a>,\n+    out: Box<io::Write+'a>,\n     buf_len: usize,\n     /// Width of lines we're constrained to\n     margin: isize,\n@@ -577,75 +577,75 @@ impl<'a> Printer<'a> {\n           }\n         }\n     }\n-}\n \n-// Convenience functions to talk to the printer.\n+    // Convenience functions to talk to the printer.\n \n-/// \"raw box\"\n-pub fn rbox(p: &mut Printer, indent: usize, b: Breaks) -> io::Result<()> {\n-    p.pretty_print(Token::Begin(BeginToken {\n-        offset: indent as isize,\n-        breaks: b\n-    }))\n-}\n+    /// \"raw box\"\n+    pub fn rbox(&mut self, indent: usize, b: Breaks) -> io::Result<()> {\n+        self.pretty_print(Token::Begin(BeginToken {\n+            offset: indent as isize,\n+            breaks: b\n+        }))\n+    }\n \n-/// Inconsistent breaking box\n-pub fn ibox(p: &mut Printer, indent: usize) -> io::Result<()> {\n-    rbox(p, indent, Breaks::Inconsistent)\n-}\n+    /// Inconsistent breaking box\n+    pub fn ibox(&mut self, indent: usize) -> io::Result<()> {\n+        self.rbox(indent, Breaks::Inconsistent)\n+    }\n \n-/// Consistent breaking box\n-pub fn cbox(p: &mut Printer, indent: usize) -> io::Result<()> {\n-    rbox(p, indent, Breaks::Consistent)\n-}\n+    /// Consistent breaking box\n+    pub fn cbox(&mut self, indent: usize) -> io::Result<()> {\n+        self.rbox(indent, Breaks::Consistent)\n+    }\n \n-pub fn break_offset(p: &mut Printer, n: usize, off: isize) -> io::Result<()> {\n-    p.pretty_print(Token::Break(BreakToken {\n-        offset: off,\n-        blank_space: n as isize\n-    }))\n-}\n+    pub fn break_offset(&mut self, n: usize, off: isize) -> io::Result<()> {\n+        self.pretty_print(Token::Break(BreakToken {\n+            offset: off,\n+            blank_space: n as isize\n+        }))\n+    }\n \n-pub fn end(p: &mut Printer) -> io::Result<()> {\n-    p.pretty_print(Token::End)\n-}\n+    pub fn end(&mut self) -> io::Result<()> {\n+        self.pretty_print(Token::End)\n+    }\n \n-pub fn eof(p: &mut Printer) -> io::Result<()> {\n-    p.pretty_print(Token::Eof)\n-}\n+    pub fn eof(&mut self) -> io::Result<()> {\n+        self.pretty_print(Token::Eof)\n+    }\n \n-pub fn word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n-    p.pretty_print(Token::String(wrd.to_string(), wrd.len() as isize))\n-}\n+    pub fn word(&mut self, wrd: &str) -> io::Result<()> {\n+        self.pretty_print(Token::String(wrd.to_string(), wrd.len() as isize))\n+    }\n \n-pub fn huge_word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n-    p.pretty_print(Token::String(wrd.to_string(), SIZE_INFINITY))\n-}\n+    pub fn huge_word(&mut self, wrd: &str) -> io::Result<()> {\n+        self.pretty_print(Token::String(wrd.to_string(), SIZE_INFINITY))\n+    }\n \n-pub fn zero_word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n-    p.pretty_print(Token::String(wrd.to_string(), 0))\n-}\n+    pub fn zero_word(&mut self, wrd: &str) -> io::Result<()> {\n+        self.pretty_print(Token::String(wrd.to_string(), 0))\n+    }\n \n-pub fn spaces(p: &mut Printer, n: usize) -> io::Result<()> {\n-    break_offset(p, n, 0)\n-}\n+    fn spaces(&mut self, n: usize) -> io::Result<()> {\n+        self.break_offset(n, 0)\n+    }\n \n-pub fn zerobreak(p: &mut Printer) -> io::Result<()> {\n-    spaces(p, 0)\n-}\n+    pub fn zerobreak(&mut self) -> io::Result<()> {\n+        self.spaces(0)\n+    }\n \n-pub fn space(p: &mut Printer) -> io::Result<()> {\n-    spaces(p, 1)\n-}\n+    pub fn space(&mut self) -> io::Result<()> {\n+        self.spaces(1)\n+    }\n \n-pub fn hardbreak(p: &mut Printer) -> io::Result<()> {\n-    spaces(p, SIZE_INFINITY as usize)\n-}\n+    pub fn hardbreak(&mut self) -> io::Result<()> {\n+        self.spaces(SIZE_INFINITY as usize)\n+    }\n \n-pub fn hardbreak_tok_offset(off: isize) -> Token {\n-    Token::Break(BreakToken {offset: off, blank_space: SIZE_INFINITY})\n-}\n+    pub fn hardbreak_tok_offset(off: isize) -> Token {\n+        Token::Break(BreakToken {offset: off, blank_space: SIZE_INFINITY})\n+    }\n \n-pub fn hardbreak_tok() -> Token {\n-    hardbreak_tok_offset(0)\n+    pub fn hardbreak_tok() -> Token {\n+        Self::hardbreak_tok_offset(0)\n+    }\n }"}, {"sha": "49f122b905f4acfe4e1b628a23c891f8288f13b9", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 255, "deletions": 260, "changes": 515, "blob_url": "https://github.com/rust-lang/rust/blob/bac4bb96137cad937e4986b37d9e4273d1f01dcf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac4bb96137cad937e4986b37d9e4273d1f01dcf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=bac4bb96137cad937e4986b37d9e4273d1f01dcf", "patch": "@@ -21,8 +21,7 @@ use syntax_pos::{self, BytePos};\n use parse::token::{self, BinOpToken, Token};\n use parse::lexer::comments;\n use parse::{self, ParseSess};\n-use print::pp::{self, break_offset, word, space, zerobreak, hardbreak};\n-use print::pp::{Breaks, eof};\n+use print::pp::{self, Breaks};\n use print::pp::Breaks::{Consistent, Inconsistent};\n use ptr::P;\n use std_inject;\n@@ -128,7 +127,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n \n     s.print_mod(&krate.module, &krate.attrs)?;\n     s.print_remaining_comments()?;\n-    eof(&mut s.s)\n+    s.s.eof()\n }\n \n impl<'a> State<'a> {\n@@ -179,7 +178,7 @@ pub fn to_string<F>(f: F) -> String where\n     {\n         let mut printer = rust_printer(Box::new(&mut wr));\n         f(&mut printer).unwrap();\n-        eof(&mut printer.s).unwrap();\n+        printer.s.eof().unwrap();\n     }\n     String::from_utf8(wr).unwrap()\n }\n@@ -456,13 +455,13 @@ pub trait PrintState<'a> {\n     fn literals(&self) -> &Option<Vec<comments::Literal>>;\n \n     fn word_space(&mut self, w: &str) -> io::Result<()> {\n-        word(self.writer(), w)?;\n-        space(self.writer())\n+        self.writer().word(w)?;\n+        self.writer().space()\n     }\n \n-    fn popen(&mut self) -> io::Result<()> { word(self.writer(), \"(\") }\n+    fn popen(&mut self) -> io::Result<()> { self.writer().word(\"(\") }\n \n-    fn pclose(&mut self) -> io::Result<()> { word(self.writer(), \")\") }\n+    fn pclose(&mut self) -> io::Result<()> { self.writer().word(\")\") }\n \n     fn is_begin(&mut self) -> bool {\n         match self.writer().last_token() {\n@@ -485,25 +484,25 @@ pub trait PrintState<'a> {\n \n     fn hardbreak_if_not_bol(&mut self) -> io::Result<()> {\n         if !self.is_bol() {\n-            hardbreak(self.writer())?\n+            self.writer().hardbreak()?\n         }\n         Ok(())\n     }\n \n     // \"raw box\"\n     fn rbox(&mut self, u: usize, b: pp::Breaks) -> io::Result<()> {\n         self.boxes().push(b);\n-        pp::rbox(self.writer(), u, b)\n+        self.writer().rbox(u, b)\n     }\n \n     fn ibox(&mut self, u: usize) -> io::Result<()> {\n         self.boxes().push(pp::Breaks::Inconsistent);\n-        pp::ibox(self.writer(), u)\n+        self.writer().ibox(u)\n     }\n \n     fn end(&mut self) -> io::Result<()> {\n         self.boxes().pop().unwrap();\n-        pp::end(self.writer())\n+        self.writer().end()\n     }\n \n     fn commasep<T, F>(&mut self, b: Breaks, elts: &[T], mut op: F) -> io::Result<()>\n@@ -556,36 +555,36 @@ pub trait PrintState<'a> {\n         match cmnt.style {\n             comments::Mixed => {\n                 assert_eq!(cmnt.lines.len(), 1);\n-                zerobreak(self.writer())?;\n-                word(self.writer(), &cmnt.lines[0])?;\n-                zerobreak(self.writer())\n+                self.writer().zerobreak()?;\n+                self.writer().word(&cmnt.lines[0])?;\n+                self.writer().zerobreak()\n             }\n             comments::Isolated => {\n                 self.hardbreak_if_not_bol()?;\n                 for line in &cmnt.lines {\n                     // Don't print empty lines because they will end up as trailing\n                     // whitespace\n                     if !line.is_empty() {\n-                        word(self.writer(), &line[..])?;\n+                        self.writer().word(&line[..])?;\n                     }\n-                    hardbreak(self.writer())?;\n+                    self.writer().hardbreak()?;\n                 }\n                 Ok(())\n             }\n             comments::Trailing => {\n                 if !self.is_bol() {\n-                    word(self.writer(), \" \")?;\n+                    self.writer().word(\" \")?;\n                 }\n                 if cmnt.lines.len() == 1 {\n-                    word(self.writer(), &cmnt.lines[0])?;\n-                    hardbreak(self.writer())\n+                    self.writer().word(&cmnt.lines[0])?;\n+                    self.writer().hardbreak()\n                 } else {\n                     self.ibox(0)?;\n                     for line in &cmnt.lines {\n                         if !line.is_empty() {\n-                            word(self.writer(), &line[..])?;\n+                            self.writer().word(&line[..])?;\n                         }\n-                        hardbreak(self.writer())?;\n+                        self.writer().hardbreak()?;\n                     }\n                     self.end()\n                 }\n@@ -597,9 +596,9 @@ pub trait PrintState<'a> {\n                     _ => false\n                 };\n                 if is_semi || self.is_begin() || self.is_end() {\n-                    hardbreak(self.writer())?;\n+                    self.writer().hardbreak()?;\n                 }\n-                hardbreak(self.writer())\n+                self.writer().hardbreak()\n             }\n         }\n     }\n@@ -621,53 +620,49 @@ pub trait PrintState<'a> {\n     fn print_literal(&mut self, lit: &ast::Lit) -> io::Result<()> {\n         self.maybe_print_comment(lit.span.lo)?;\n         if let Some(ref ltrl) = self.next_lit(lit.span.lo) {\n-            return word(self.writer(), &(*ltrl).lit);\n+            return self.writer().word(&(*ltrl).lit);\n         }\n         match lit.node {\n             ast::LitKind::Str(st, style) => self.print_string(&st.as_str(), style),\n             ast::LitKind::Byte(byte) => {\n                 let mut res = String::from(\"b'\");\n                 res.extend(ascii::escape_default(byte).map(|c| c as char));\n                 res.push('\\'');\n-                word(self.writer(), &res[..])\n+                self.writer().word(&res[..])\n             }\n             ast::LitKind::Char(ch) => {\n                 let mut res = String::from(\"'\");\n                 res.extend(ch.escape_default());\n                 res.push('\\'');\n-                word(self.writer(), &res[..])\n+                self.writer().word(&res[..])\n             }\n             ast::LitKind::Int(i, t) => {\n                 match t {\n                     ast::LitIntType::Signed(st) => {\n-                        word(self.writer(), &st.val_to_string(i as i128))\n+                        self.writer().word(&st.val_to_string(i as i128))\n                     }\n                     ast::LitIntType::Unsigned(ut) => {\n-                        word(self.writer(), &ut.val_to_string(i))\n+                        self.writer().word(&ut.val_to_string(i))\n                     }\n                     ast::LitIntType::Unsuffixed => {\n-                        word(self.writer(), &format!(\"{}\", i))\n+                        self.writer().word(&format!(\"{}\", i))\n                     }\n                 }\n             }\n             ast::LitKind::Float(ref f, t) => {\n-                word(self.writer(),\n-                     &format!(\n-                         \"{}{}\",\n-                         &f,\n-                         t.ty_to_string()))\n+                self.writer().word(&format!(\"{}{}\", &f, t.ty_to_string()))\n             }\n-            ast::LitKind::FloatUnsuffixed(ref f) => word(self.writer(), &f.as_str()),\n+            ast::LitKind::FloatUnsuffixed(ref f) => self.writer().word(&f.as_str()),\n             ast::LitKind::Bool(val) => {\n-                if val { word(self.writer(), \"true\") } else { word(self.writer(), \"false\") }\n+                if val { self.writer().word(\"true\") } else { self.writer().word(\"false\") }\n             }\n             ast::LitKind::ByteStr(ref v) => {\n                 let mut escaped: String = String::new();\n                 for &ch in v.iter() {\n                     escaped.extend(ascii::escape_default(ch)\n                                          .map(|c| c as char));\n                 }\n-                word(self.writer(), &format!(\"b\\\"{}\\\"\", escaped))\n+                self.writer().word(&format!(\"b\\\"{}\\\"\", escaped))\n             }\n         }\n     }\n@@ -684,7 +679,7 @@ pub trait PrintState<'a> {\n                          string=st))\n             }\n         };\n-        word(self.writer(), &st[..])\n+        self.writer().word(&st[..])\n     }\n \n     fn print_inner_attributes(&mut self,\n@@ -745,29 +740,29 @@ pub trait PrintState<'a> {\n         }\n         self.maybe_print_comment(attr.span.lo)?;\n         if attr.is_sugared_doc {\n-            word(self.writer(), &attr.value_str().unwrap().as_str())?;\n-            hardbreak(self.writer())\n+            self.writer().word(&attr.value_str().unwrap().as_str())?;\n+            self.writer().hardbreak()\n         } else {\n             match attr.style {\n-                ast::AttrStyle::Inner => word(self.writer(), \"#![\")?,\n-                ast::AttrStyle::Outer => word(self.writer(), \"#[\")?,\n+                ast::AttrStyle::Inner => self.writer().word(\"#![\")?,\n+                ast::AttrStyle::Outer => self.writer().word(\"#[\")?,\n             }\n             if let Some(mi) = attr.meta() {\n                 self.print_meta_item(&mi)?\n             } else {\n                 for (i, segment) in attr.path.segments.iter().enumerate() {\n                     if i > 0 {\n-                        word(self.writer(), \"::\")?\n+                        self.writer().word(\"::\")?\n                     }\n                     if segment.identifier.name != keywords::CrateRoot.name() &&\n                        segment.identifier.name != keywords::DollarCrate.name() {\n-                        word(self.writer(), &segment.identifier.name.as_str())?;\n+                        self.writer().word(&segment.identifier.name.as_str())?;\n                     }\n                 }\n-                space(self.writer())?;\n+                self.writer().space()?;\n                 self.print_tts(attr.tokens.clone())?;\n             }\n-            word(self.writer(), \"]\")\n+            self.writer().word(\"]\")\n         }\n     }\n \n@@ -786,15 +781,15 @@ pub trait PrintState<'a> {\n         self.ibox(INDENT_UNIT)?;\n         match item.node {\n             ast::MetaItemKind::Word => {\n-                word(self.writer(), &item.name.as_str())?;\n+                self.writer().word(&item.name.as_str())?;\n             }\n             ast::MetaItemKind::NameValue(ref value) => {\n                 self.word_space(&item.name.as_str())?;\n                 self.word_space(\"=\")?;\n                 self.print_literal(value)?;\n             }\n             ast::MetaItemKind::List(ref items) => {\n-                word(self.writer(), &item.name.as_str())?;\n+                self.writer().word(&item.name.as_str())?;\n                 self.popen()?;\n                 self.commasep(Consistent,\n                               &items[..],\n@@ -815,20 +810,20 @@ pub trait PrintState<'a> {\n     fn print_tt(&mut self, tt: tokenstream::TokenTree) -> io::Result<()> {\n         match tt {\n             TokenTree::Token(_, ref tk) => {\n-                word(self.writer(), &token_to_string(tk))?;\n+                self.writer().word(&token_to_string(tk))?;\n                 match *tk {\n                     parse::token::DocComment(..) => {\n-                        hardbreak(self.writer())\n+                        self.writer().hardbreak()\n                     }\n                     _ => Ok(())\n                 }\n             }\n             TokenTree::Delimited(_, ref delimed) => {\n-                word(self.writer(), &token_to_string(&delimed.open_token()))?;\n-                space(self.writer())?;\n+                self.writer().word(&token_to_string(&delimed.open_token()))?;\n+                self.writer().space()?;\n                 self.print_tts(delimed.stream())?;\n-                space(self.writer())?;\n-                word(self.writer(), &token_to_string(&delimed.close_token()))\n+                self.writer().space()?;\n+                self.writer().word(&token_to_string(&delimed.close_token()))\n             },\n         }\n     }\n@@ -837,19 +832,19 @@ pub trait PrintState<'a> {\n         self.ibox(0)?;\n         for (i, tt) in tts.into_trees().enumerate() {\n             if i != 0 {\n-                space(self.writer())?;\n+                self.writer().space()?;\n             }\n             self.print_tt(tt)?;\n         }\n         self.end()\n     }\n \n     fn space_if_not_bol(&mut self) -> io::Result<()> {\n-        if !self.is_bol() { space(self.writer())?; }\n+        if !self.is_bol() { self.writer().space()?; }\n         Ok(())\n     }\n \n-    fn nbsp(&mut self) -> io::Result<()> { word(self.writer(), \" \") }\n+    fn nbsp(&mut self) -> io::Result<()> { self.writer().word(\" \") }\n }\n \n impl<'a> PrintState<'a> for State<'a> {\n@@ -877,11 +872,11 @@ impl<'a> PrintState<'a> for State<'a> {\n impl<'a> State<'a> {\n     pub fn cbox(&mut self, u: usize) -> io::Result<()> {\n         self.boxes.push(pp::Breaks::Consistent);\n-        pp::cbox(&mut self.s, u)\n+        self.s.cbox(u)\n     }\n \n     pub fn word_nbsp(&mut self, w: &str) -> io::Result<()> {\n-        word(&mut self.s, w)?;\n+        self.s.word(w)?;\n         self.nbsp()\n     }\n \n@@ -898,7 +893,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn bopen(&mut self) -> io::Result<()> {\n-        word(&mut self.s, \"{\")?;\n+        self.s.word(\"{\")?;\n         self.end() // close the head-box\n     }\n \n@@ -910,7 +905,7 @@ impl<'a> State<'a> {\n                              indented: usize, close_box: bool) -> io::Result<()> {\n         self.maybe_print_comment(span.hi)?;\n         self.break_offset_if_not_bol(1, -(indented as isize))?;\n-        word(&mut self.s, \"}\")?;\n+        self.s.word(\"}\")?;\n         if close_box {\n             self.end()?; // close the outer-box\n         }\n@@ -930,13 +925,13 @@ impl<'a> State<'a> {\n     pub fn break_offset_if_not_bol(&mut self, n: usize,\n                                    off: isize) -> io::Result<()> {\n         if !self.is_bol() {\n-            break_offset(&mut self.s, n, off)\n+            self.s.break_offset(n, off)\n         } else {\n             if off != 0 && self.s.last_token().is_hardbreak_tok() {\n                 // We do something pretty sketchy here: tuck the nonzero\n                 // offset-adjustment we were going to deposit along with the\n                 // break into the previous hardbreak.\n-                self.s.replace_last_token(pp::hardbreak_tok_offset(off));\n+                self.s.replace_last_token(pp::Printer::hardbreak_tok_offset(off));\n             }\n             Ok(())\n         }\n@@ -945,11 +940,11 @@ impl<'a> State<'a> {\n     // Synthesizes a comment that was not textually present in the original source\n     // file.\n     pub fn synth_comment(&mut self, text: String) -> io::Result<()> {\n-        word(&mut self.s, \"/*\")?;\n-        space(&mut self.s)?;\n-        word(&mut self.s, &text[..])?;\n-        space(&mut self.s)?;\n-        word(&mut self.s, \"*/\")\n+        self.s.word(\"/*\")?;\n+        self.s.space()?;\n+        self.s.word(&text[..])?;\n+        self.s.space()?;\n+        self.s.word(\"*/\")\n     }\n \n \n@@ -970,7 +965,7 @@ impl<'a> State<'a> {\n             op(self, elt)?;\n             i += 1;\n             if i < len {\n-                word(&mut self.s, \",\")?;\n+                self.s.word(\",\")?;\n                 self.maybe_print_trailing_comment(get_span(elt),\n                                                   Some(get_span(&elts[i]).hi))?;\n                 self.space_if_not_bol()?;\n@@ -1016,32 +1011,32 @@ impl<'a> State<'a> {\n         self.ibox(0)?;\n         match ty.node {\n             ast::TyKind::Slice(ref ty) => {\n-                word(&mut self.s, \"[\")?;\n+                self.s.word(\"[\")?;\n                 self.print_type(ty)?;\n-                word(&mut self.s, \"]\")?;\n+                self.s.word(\"]\")?;\n             }\n             ast::TyKind::Ptr(ref mt) => {\n-                word(&mut self.s, \"*\")?;\n+                self.s.word(\"*\")?;\n                 match mt.mutbl {\n                     ast::Mutability::Mutable => self.word_nbsp(\"mut\")?,\n                     ast::Mutability::Immutable => self.word_nbsp(\"const\")?,\n                 }\n                 self.print_type(&mt.ty)?;\n             }\n             ast::TyKind::Rptr(ref lifetime, ref mt) => {\n-                word(&mut self.s, \"&\")?;\n+                self.s.word(\"&\")?;\n                 self.print_opt_lifetime(lifetime)?;\n                 self.print_mt(mt)?;\n             }\n             ast::TyKind::Never => {\n-                word(&mut self.s, \"!\")?;\n+                self.s.word(\"!\")?;\n             },\n             ast::TyKind::Tup(ref elts) => {\n                 self.popen()?;\n                 self.commasep(Inconsistent, &elts[..],\n                               |s, ty| s.print_type(ty))?;\n                 if elts.len() == 1 {\n-                    word(&mut self.s, \",\")?;\n+                    self.s.word(\",\")?;\n                 }\n                 self.pclose()?;\n             }\n@@ -1079,25 +1074,25 @@ impl<'a> State<'a> {\n                 self.print_bounds(\"impl \", &bounds[..])?;\n             }\n             ast::TyKind::Array(ref ty, ref v) => {\n-                word(&mut self.s, \"[\")?;\n+                self.s.word(\"[\")?;\n                 self.print_type(ty)?;\n-                word(&mut self.s, \"; \")?;\n+                self.s.word(\"; \")?;\n                 self.print_expr(v)?;\n-                word(&mut self.s, \"]\")?;\n+                self.s.word(\"]\")?;\n             }\n             ast::TyKind::Typeof(ref e) => {\n-                word(&mut self.s, \"typeof(\")?;\n+                self.s.word(\"typeof(\")?;\n                 self.print_expr(e)?;\n-                word(&mut self.s, \")\")?;\n+                self.s.word(\")\")?;\n             }\n             ast::TyKind::Infer => {\n-                word(&mut self.s, \"_\")?;\n+                self.s.word(\"_\")?;\n             }\n             ast::TyKind::Err => {\n-                word(&mut self.s, \"?\")?;\n+                self.s.word(\"?\")?;\n             }\n             ast::TyKind::ImplicitSelf => {\n-                word(&mut self.s, \"Self\")?;\n+                self.s.word(\"Self\")?;\n             }\n             ast::TyKind::Mac(ref m) => {\n                 self.print_mac(m, token::Paren)?;\n@@ -1119,7 +1114,7 @@ impl<'a> State<'a> {\n                               Abi::Rust, Some(item.ident),\n                               generics, &item.vis)?;\n                 self.end()?; // end head-ibox\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end() // end the outer fn box\n             }\n             ast::ForeignItemKind::Static(ref t, m) => {\n@@ -1130,7 +1125,7 @@ impl<'a> State<'a> {\n                 self.print_ident(item.ident)?;\n                 self.word_space(\":\")?;\n                 self.print_type(t)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end the head-ibox\n                 self.end() // end the outer cbox\n             }\n@@ -1144,17 +1139,17 @@ impl<'a> State<'a> {\n                               vis: &ast::Visibility)\n                               -> io::Result<()>\n     {\n-        word(&mut self.s, &visibility_qualified(vis, \"\"))?;\n+        self.s.word(&visibility_qualified(vis, \"\"))?;\n         self.word_space(\"const\")?;\n         self.print_ident(ident)?;\n         self.word_space(\":\")?;\n         self.print_type(ty)?;\n         if let Some(expr) = default {\n-            space(&mut self.s)?;\n+            self.s.space()?;\n             self.word_space(\"=\")?;\n             self.print_expr(expr)?;\n         }\n-        word(&mut self.s, \";\")\n+        self.s.word(\";\")\n     }\n \n     fn print_associated_type(&mut self,\n@@ -1168,11 +1163,11 @@ impl<'a> State<'a> {\n             self.print_bounds(\":\", bounds)?;\n         }\n         if let Some(ty) = ty {\n-            space(&mut self.s)?;\n+            self.s.space()?;\n             self.word_space(\"=\")?;\n             self.print_type(ty)?;\n         }\n-        word(&mut self.s, \";\")\n+        self.s.word(\";\")\n     }\n \n     /// Pretty-print an item\n@@ -1191,19 +1186,19 @@ impl<'a> State<'a> {\n                     } else {\n                         self.print_name(p)?;\n                     }\n-                    space(&mut self.s)?;\n-                    word(&mut self.s, \"as\")?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n+                    self.s.word(\"as\")?;\n+                    self.s.space()?;\n                 }\n                 self.print_ident(item.ident)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n             ast::ItemKind::Use(ref vp) => {\n                 self.head(&visibility_qualified(&item.vis, \"use\"))?;\n                 self.print_view_path(vp)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n@@ -1215,25 +1210,25 @@ impl<'a> State<'a> {\n                 self.print_ident(item.ident)?;\n                 self.word_space(\":\")?;\n                 self.print_type(ty)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.end()?; // end the head-ibox\n \n                 self.word_space(\"=\")?;\n                 self.print_expr(expr)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end the outer cbox\n             }\n             ast::ItemKind::Const(ref ty, ref expr) => {\n                 self.head(&visibility_qualified(&item.vis, \"const\"))?;\n                 self.print_ident(item.ident)?;\n                 self.word_space(\":\")?;\n                 self.print_type(ty)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.end()?; // end the head-ibox\n \n                 self.word_space(\"=\")?;\n                 self.print_expr(expr)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end the outer cbox\n             }\n             ast::ItemKind::Fn(ref decl, unsafety, constness, abi, ref typarams, ref body) => {\n@@ -1247,7 +1242,7 @@ impl<'a> State<'a> {\n                     typarams,\n                     &item.vis\n                 )?;\n-                word(&mut self.s, \" \")?;\n+                self.s.word(\" \")?;\n                 self.print_block_with_attrs(body, &item.attrs)?;\n             }\n             ast::ItemKind::Mod(ref _mod) => {\n@@ -1267,7 +1262,7 @@ impl<'a> State<'a> {\n             }\n             ast::ItemKind::GlobalAsm(ref ga) => {\n                 self.head(&visibility_qualified(&item.vis, \"global_asm!\"))?;\n-                word(&mut self.s, &ga.asm.as_str())?;\n+                self.s.word(&ga.asm.as_str())?;\n                 self.end()?;\n             }\n             ast::ItemKind::Ty(ref ty, ref params) => {\n@@ -1279,10 +1274,10 @@ impl<'a> State<'a> {\n                 self.end()?; // end the inner ibox\n \n                 self.print_where_clause(&params.where_clause)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_type(ty)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?; // end the outer ibox\n             }\n             ast::ItemKind::Enum(ref enum_definition, ref params) => {\n@@ -1308,7 +1303,7 @@ impl<'a> State<'a> {\n                 self.print_unsafety(unsafety)?;\n                 self.word_nbsp(\"impl\")?;\n                 self.print_trait_ref(trait_ref)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"for\")?;\n                 self.word_space(\"..\")?;\n                 self.bopen()?;\n@@ -1329,23 +1324,23 @@ impl<'a> State<'a> {\n \n                 if generics.is_parameterized() {\n                     self.print_generics(generics)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                 }\n \n                 if polarity == ast::ImplPolarity::Negative {\n-                    word(&mut self.s, \"!\")?;\n+                    self.s.word(\"!\")?;\n                 }\n \n                 if let Some(ref t) = *opt_trait {\n                     self.print_trait_ref(t)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                     self.word_space(\"for\")?;\n                 }\n \n                 self.print_type(ty)?;\n                 self.print_where_clause(&generics.where_clause)?;\n \n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.bopen()?;\n                 self.print_inner_attributes(&item.attrs)?;\n                 for impl_item in impl_items {\n@@ -1363,7 +1358,7 @@ impl<'a> State<'a> {\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 for b in bounds.iter() {\n                     if let TraitTyParamBound(ref ptr, ast::TraitBoundModifier::Maybe) = *b {\n-                        space(&mut self.s)?;\n+                        self.s.space()?;\n                         self.word_space(\"for ?\")?;\n                         self.print_trait_ref(&ptr.trait_ref)?;\n                     } else {\n@@ -1372,7 +1367,7 @@ impl<'a> State<'a> {\n                 }\n                 self.print_bounds(\":\", &real_bounds[..])?;\n                 self.print_where_clause(&generics.where_clause)?;\n-                word(&mut self.s, \" \")?;\n+                self.s.word(\" \")?;\n                 self.bopen()?;\n                 for trait_item in trait_items {\n                     self.print_trait_item(trait_item)?;\n@@ -1381,23 +1376,23 @@ impl<'a> State<'a> {\n             }\n             ast::ItemKind::Mac(codemap::Spanned { ref node, .. }) => {\n                 self.print_path(&node.path, false, 0, false)?;\n-                word(&mut self.s, \"! \")?;\n+                self.s.word(\"! \")?;\n                 self.print_ident(item.ident)?;\n                 self.cbox(INDENT_UNIT)?;\n                 self.popen()?;\n                 self.print_tts(node.stream())?;\n                 self.pclose()?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?;\n             }\n             ast::ItemKind::MacroDef(ref tts) => {\n-                word(&mut self.s, \"macro_rules! \")?;\n+                self.s.word(\"macro_rules! \")?;\n                 self.print_ident(item.ident)?;\n                 self.cbox(INDENT_UNIT)?;\n                 self.popen()?;\n                 self.print_tts(tts.stream())?;\n                 self.pclose()?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?;\n             }\n         }\n@@ -1410,7 +1405,7 @@ impl<'a> State<'a> {\n \n     fn print_formal_lifetime_list(&mut self, lifetimes: &[ast::LifetimeDef]) -> io::Result<()> {\n         if !lifetimes.is_empty() {\n-            word(&mut self.s, \"for<\")?;\n+            self.s.word(\"for<\")?;\n             let mut comma = false;\n             for lifetime_def in lifetimes {\n                 if comma {\n@@ -1420,7 +1415,7 @@ impl<'a> State<'a> {\n                 self.print_lifetime_bounds(&lifetime_def.lifetime, &lifetime_def.bounds)?;\n                 comma = true;\n             }\n-            word(&mut self.s, \">\")?;\n+            self.s.word(\">\")?;\n         }\n         Ok(())\n     }\n@@ -1438,7 +1433,7 @@ impl<'a> State<'a> {\n         self.print_ident(ident)?;\n         self.print_generics(generics)?;\n         self.print_where_clause(&generics.where_clause)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.print_variants(&enum_definition.variants, span)\n     }\n \n@@ -1452,7 +1447,7 @@ impl<'a> State<'a> {\n             self.print_outer_attributes(&v.node.attrs)?;\n             self.ibox(INDENT_UNIT)?;\n             self.print_variant(v)?;\n-            word(&mut self.s, \",\")?;\n+            self.s.word(\",\")?;\n             self.end()?;\n             self.maybe_print_trailing_comment(v.span, None)?;\n         }\n@@ -1506,7 +1501,7 @@ impl<'a> State<'a> {\n             }\n             self.print_where_clause(&generics.where_clause)?;\n             if print_finalizer {\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n             }\n             self.end()?;\n             self.end() // close the outer-box\n@@ -1524,7 +1519,7 @@ impl<'a> State<'a> {\n                 self.print_ident(field.ident.unwrap())?;\n                 self.word_nbsp(\":\")?;\n                 self.print_type(&field.ty)?;\n-                word(&mut self.s, \",\")?;\n+                self.s.word(\",\")?;\n             }\n \n             self.bclose(span)\n@@ -1537,7 +1532,7 @@ impl<'a> State<'a> {\n         self.print_struct(&v.node.data, &generics, v.node.name, v.span, false)?;\n         match v.node.disr_expr {\n             Some(ref d) => {\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_expr(d)\n             }\n@@ -1580,7 +1575,7 @@ impl<'a> State<'a> {\n                     self.nbsp()?;\n                     self.print_block_with_attrs(body, &ti.attrs)?;\n                 } else {\n-                    word(&mut self.s, \";\")?;\n+                    self.s.word(\";\")?;\n                 }\n             }\n             ast::TraitItemKind::Type(ref bounds, ref default) => {\n@@ -1590,12 +1585,12 @@ impl<'a> State<'a> {\n             ast::TraitItemKind::Macro(codemap::Spanned { ref node, .. }) => {\n                 // code copied from ItemKind::Mac:\n                 self.print_path(&node.path, false, 0, false)?;\n-                word(&mut self.s, \"! \")?;\n+                self.s.word(\"! \")?;\n                 self.cbox(INDENT_UNIT)?;\n                 self.popen()?;\n                 self.print_tts(node.stream())?;\n                 self.pclose()?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?\n             }\n         }\n@@ -1624,12 +1619,12 @@ impl<'a> State<'a> {\n             ast::ImplItemKind::Macro(codemap::Spanned { ref node, .. }) => {\n                 // code copied from ItemKind::Mac:\n                 self.print_path(&node.path, false, 0, false)?;\n-                word(&mut self.s, \"! \")?;\n+                self.s.word(\"! \")?;\n                 self.cbox(INDENT_UNIT)?;\n                 self.popen()?;\n                 self.print_tts(node.stream())?;\n                 self.pclose()?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?\n             }\n         }\n@@ -1653,21 +1648,21 @@ impl<'a> State<'a> {\n                     self.word_space(\"=\")?;\n                     self.print_expr(init)?;\n                 }\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n                 self.end()?;\n             }\n             ast::StmtKind::Item(ref item) => self.print_item(item)?,\n             ast::StmtKind::Expr(ref expr) => {\n                 self.space_if_not_bol()?;\n                 self.print_expr_outer_attr_style(expr, false)?;\n                 if parse::classify::expr_requires_semi_to_be_stmt(expr) {\n-                    word(&mut self.s, \";\")?;\n+                    self.s.word(\";\")?;\n                 }\n             }\n             ast::StmtKind::Semi(ref expr) => {\n                 self.space_if_not_bol()?;\n                 self.print_expr_outer_attr_style(expr, false)?;\n-                word(&mut self.s, \";\")?;\n+                self.s.word(\";\")?;\n             }\n             ast::StmtKind::Mac(ref mac) => {\n                 let (ref mac, style, ref attrs) = **mac;\n@@ -1679,7 +1674,7 @@ impl<'a> State<'a> {\n                 };\n                 self.print_mac(mac, delim)?;\n                 if style == ast::MacStmtStyle::Semicolon {\n-                    word(&mut self.s, \";\")?;\n+                    self.s.word(\";\")?;\n                 }\n             }\n         }\n@@ -1750,30 +1745,30 @@ impl<'a> State<'a> {\n                     ast::ExprKind::If(ref i, ref then, ref e) => {\n                         self.cbox(INDENT_UNIT - 1)?;\n                         self.ibox(0)?;\n-                        word(&mut self.s, \" else if \")?;\n+                        self.s.word(\" else if \")?;\n                         self.print_expr(i)?;\n-                        space(&mut self.s)?;\n+                        self.s.space()?;\n                         self.print_block(then)?;\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"another else-if-let\"\n                     ast::ExprKind::IfLet(ref pat, ref expr, ref then, ref e) => {\n                         self.cbox(INDENT_UNIT - 1)?;\n                         self.ibox(0)?;\n-                        word(&mut self.s, \" else if let \")?;\n+                        self.s.word(\" else if let \")?;\n                         self.print_pat(pat)?;\n-                        space(&mut self.s)?;\n+                        self.s.space()?;\n                         self.word_space(\"=\")?;\n                         self.print_expr(expr)?;\n-                        space(&mut self.s)?;\n+                        self.s.space()?;\n                         self.print_block(then)?;\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"final else\"\n                     ast::ExprKind::Block(ref b) => {\n                         self.cbox(INDENT_UNIT - 1)?;\n                         self.ibox(0)?;\n-                        word(&mut self.s, \" else \")?;\n+                        self.s.word(\" else \")?;\n                         self.print_block(b)\n                     }\n                     // BLEAH, constraints would be great here\n@@ -1790,7 +1785,7 @@ impl<'a> State<'a> {\n                     elseopt: Option<&ast::Expr>) -> io::Result<()> {\n         self.head(\"if\")?;\n         self.print_expr(test)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.print_block(blk)?;\n         self.print_else(elseopt)\n     }\n@@ -1799,21 +1794,21 @@ impl<'a> State<'a> {\n                         elseopt: Option<&ast::Expr>) -> io::Result<()> {\n         self.head(\"if let\")?;\n         self.print_pat(pat)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.word_space(\"=\")?;\n         self.print_expr(expr)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.print_block(blk)?;\n         self.print_else(elseopt)\n     }\n \n     pub fn print_mac(&mut self, m: &ast::Mac, delim: token::DelimToken)\n                      -> io::Result<()> {\n         self.print_path(&m.node.path, false, 0, false)?;\n-        word(&mut self.s, \"!\")?;\n+        self.s.word(\"!\")?;\n         match delim {\n             token::Paren => self.popen()?,\n-            token::Bracket => word(&mut self.s, \"[\")?,\n+            token::Bracket => self.s.word(\"[\")?,\n             token::Brace => {\n                 self.head(\"\")?;\n                 self.bopen()?;\n@@ -1823,7 +1818,7 @@ impl<'a> State<'a> {\n         self.print_tts(m.node.stream())?;\n         match delim {\n             token::Paren => self.pclose(),\n-            token::Bracket => word(&mut self.s, \"]\"),\n+            token::Bracket => self.s.word(\"]\"),\n             token::Brace => self.bclose(m.span),\n             token::NoDelim => Ok(()),\n         }\n@@ -1863,18 +1858,18 @@ impl<'a> State<'a> {\n                            place: &ast::Expr,\n                            expr: &ast::Expr) -> io::Result<()> {\n         self.print_expr_maybe_paren(place)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.word_space(\"<-\")?;\n         self.print_expr_maybe_paren(expr)\n     }\n \n     fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>],\n                       attrs: &[Attribute]) -> io::Result<()> {\n         self.ibox(INDENT_UNIT)?;\n-        word(&mut self.s, \"[\")?;\n+        self.s.word(\"[\")?;\n         self.print_inner_attributes_inline(attrs)?;\n         self.commasep_exprs(Inconsistent, &exprs[..])?;\n-        word(&mut self.s, \"]\")?;\n+        self.s.word(\"]\")?;\n         self.end()\n     }\n \n@@ -1883,12 +1878,12 @@ impl<'a> State<'a> {\n                          count: &ast::Expr,\n                          attrs: &[Attribute]) -> io::Result<()> {\n         self.ibox(INDENT_UNIT)?;\n-        word(&mut self.s, \"[\")?;\n+        self.s.word(\"[\")?;\n         self.print_inner_attributes_inline(attrs)?;\n         self.print_expr(element)?;\n         self.word_space(\";\")?;\n         self.print_expr(count)?;\n-        word(&mut self.s, \"]\")?;\n+        self.s.word(\"]\")?;\n         self.end()\n     }\n \n@@ -1898,7 +1893,7 @@ impl<'a> State<'a> {\n                          wth: &Option<P<ast::Expr>>,\n                          attrs: &[Attribute]) -> io::Result<()> {\n         self.print_path(path, true, 0, false)?;\n-        word(&mut self.s, \"{\")?;\n+        self.s.word(\"{\")?;\n         self.print_inner_attributes_inline(attrs)?;\n         self.commasep_cmnt(\n             Consistent,\n@@ -1917,18 +1912,18 @@ impl<'a> State<'a> {\n             Some(ref expr) => {\n                 self.ibox(INDENT_UNIT)?;\n                 if !fields.is_empty() {\n-                    word(&mut self.s, \",\")?;\n-                    space(&mut self.s)?;\n+                    self.s.word(\",\")?;\n+                    self.s.space()?;\n                 }\n-                word(&mut self.s, \"..\")?;\n+                self.s.word(\"..\")?;\n                 self.print_expr(expr)?;\n                 self.end()?;\n             }\n             _ => if !fields.is_empty() {\n-                word(&mut self.s, \",\")?\n+                self.s.word(\",\")?\n             }\n         }\n-        word(&mut self.s, \"}\")?;\n+        self.s.word(\"}\")?;\n         Ok(())\n     }\n \n@@ -1938,7 +1933,7 @@ impl<'a> State<'a> {\n         self.print_inner_attributes_inline(attrs)?;\n         self.commasep_exprs(Inconsistent, &exprs[..])?;\n         if exprs.len() == 1 {\n-            word(&mut self.s, \",\")?;\n+            self.s.word(\",\")?;\n         }\n         self.pclose()\n     }\n@@ -1955,7 +1950,7 @@ impl<'a> State<'a> {\n                               args: &[P<ast::Expr>]) -> io::Result<()> {\n         let base_args = &args[1..];\n         self.print_expr(&args[0])?;\n-        word(&mut self.s, \".\")?;\n+        self.s.word(\".\")?;\n         self.print_ident(segment.identifier)?;\n         if let Some(ref parameters) = segment.parameters {\n             self.print_path_parameters(parameters, true)?;\n@@ -1972,7 +1967,7 @@ impl<'a> State<'a> {\n         } else {\n             self.print_expr(lhs)?;\n         }\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.word_space(op.node.to_string())?;\n         if self.check_expr_bin_needs_paren(rhs, op) {\n             self.print_expr_maybe_paren(rhs)\n@@ -1984,14 +1979,14 @@ impl<'a> State<'a> {\n     fn print_expr_unary(&mut self,\n                         op: ast::UnOp,\n                         expr: &ast::Expr) -> io::Result<()> {\n-        word(&mut self.s, ast::UnOp::to_string(op))?;\n+        self.s.word(ast::UnOp::to_string(op))?;\n         self.print_expr_maybe_paren(expr)\n     }\n \n     fn print_expr_addr_of(&mut self,\n                           mutability: ast::Mutability,\n                           expr: &ast::Expr) -> io::Result<()> {\n-        word(&mut self.s, \"&\")?;\n+        self.s.word(\"&\")?;\n         self.print_mutability(mutability)?;\n         self.print_expr_maybe_paren(expr)\n     }\n@@ -2058,7 +2053,7 @@ impl<'a> State<'a> {\n                 } else {\n                     self.print_expr_maybe_paren(expr)?;\n                 }\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"as\")?;\n                 self.print_type(ty)?;\n             }\n@@ -2080,7 +2075,7 @@ impl<'a> State<'a> {\n                 }\n                 self.head(\"while\")?;\n                 self.print_expr(test)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n             ast::ExprKind::WhileLet(ref pat, ref expr, ref blk, opt_ident) => {\n@@ -2090,10 +2085,10 @@ impl<'a> State<'a> {\n                 }\n                 self.head(\"while let\")?;\n                 self.print_pat(pat)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_expr(expr)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n             ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_ident) => {\n@@ -2103,10 +2098,10 @@ impl<'a> State<'a> {\n                 }\n                 self.head(\"for\")?;\n                 self.print_pat(pat)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"in\")?;\n                 self.print_expr(iter)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n             ast::ExprKind::Loop(ref blk, opt_ident) => {\n@@ -2115,15 +2110,15 @@ impl<'a> State<'a> {\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"loop\")?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n             ast::ExprKind::Match(ref expr, ref arms) => {\n                 self.cbox(INDENT_UNIT)?;\n                 self.ibox(4)?;\n                 self.word_nbsp(\"match\")?;\n                 self.print_expr(expr)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.bopen()?;\n                 self.print_inner_attributes_no_trailing_hardbreak(attrs)?;\n                 for arm in arms {\n@@ -2135,7 +2130,7 @@ impl<'a> State<'a> {\n                 self.print_capture_clause(capture_clause)?;\n \n                 self.print_fn_block_args(decl)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.print_expr(body)?;\n                 self.end()?; // need to close a box\n \n@@ -2153,41 +2148,41 @@ impl<'a> State<'a> {\n             }\n             ast::ExprKind::Assign(ref lhs, ref rhs) => {\n                 self.print_expr(lhs)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_expr(rhs)?;\n             }\n             ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                 self.print_expr(lhs)?;\n-                space(&mut self.s)?;\n-                word(&mut self.s, op.node.to_string())?;\n+                self.s.space()?;\n+                self.s.word(op.node.to_string())?;\n                 self.word_space(\"=\")?;\n                 self.print_expr(rhs)?;\n             }\n             ast::ExprKind::Field(ref expr, id) => {\n                 self.print_expr(expr)?;\n-                word(&mut self.s, \".\")?;\n+                self.s.word(\".\")?;\n                 self.print_ident(id.node)?;\n             }\n             ast::ExprKind::TupField(ref expr, id) => {\n                 self.print_expr(expr)?;\n-                word(&mut self.s, \".\")?;\n+                self.s.word(\".\")?;\n                 self.print_usize(id.node)?;\n             }\n             ast::ExprKind::Index(ref expr, ref index) => {\n                 self.print_expr(expr)?;\n-                word(&mut self.s, \"[\")?;\n+                self.s.word(\"[\")?;\n                 self.print_expr(index)?;\n-                word(&mut self.s, \"]\")?;\n+                self.s.word(\"]\")?;\n             }\n             ast::ExprKind::Range(ref start, ref end, limits) => {\n                 if let Some(ref e) = *start {\n                     self.print_expr(e)?;\n                 }\n                 if limits == ast::RangeLimits::HalfOpen {\n-                    word(&mut self.s, \"..\")?;\n+                    self.s.word(\"..\")?;\n                 } else {\n-                    word(&mut self.s, \"...\")?;\n+                    self.s.word(\"...\")?;\n                 }\n                 if let Some(ref e) = *end {\n                     self.print_expr(e)?;\n@@ -2200,34 +2195,34 @@ impl<'a> State<'a> {\n                 self.print_qpath(path, qself, true)?\n             }\n             ast::ExprKind::Break(opt_ident, ref opt_expr) => {\n-                word(&mut self.s, \"break\")?;\n-                space(&mut self.s)?;\n+                self.s.word(\"break\")?;\n+                self.s.space()?;\n                 if let Some(ident) = opt_ident {\n                     self.print_ident(ident.node)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                 }\n                 if let Some(ref expr) = *opt_expr {\n                     self.print_expr(expr)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                 }\n             }\n             ast::ExprKind::Continue(opt_ident) => {\n-                word(&mut self.s, \"continue\")?;\n-                space(&mut self.s)?;\n+                self.s.word(\"continue\")?;\n+                self.s.space()?;\n                 if let Some(ident) = opt_ident {\n                     self.print_ident(ident.node)?;\n-                    space(&mut self.s)?\n+                    self.s.space()?\n                 }\n             }\n             ast::ExprKind::Ret(ref result) => {\n-                word(&mut self.s, \"return\")?;\n+                self.s.word(\"return\")?;\n                 if let Some(ref expr) = *result {\n-                    word(&mut self.s, \" \")?;\n+                    self.s.word(\" \")?;\n                     self.print_expr(expr)?;\n                 }\n             }\n             ast::ExprKind::InlineAsm(ref a) => {\n-                word(&mut self.s, \"asm!\")?;\n+                self.s.word(\"asm!\")?;\n                 self.popen()?;\n                 self.print_string(&a.asm.as_str(), a.asm_str_style)?;\n                 self.word_space(\":\")?;\n@@ -2247,7 +2242,7 @@ impl<'a> State<'a> {\n                     s.pclose()?;\n                     Ok(())\n                 })?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\":\")?;\n \n                 self.commasep(Inconsistent, &a.inputs, |s, &(co, ref o)| {\n@@ -2257,7 +2252,7 @@ impl<'a> State<'a> {\n                     s.pclose()?;\n                     Ok(())\n                 })?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\":\")?;\n \n                 self.commasep(Inconsistent, &a.clobbers,\n@@ -2278,7 +2273,7 @@ impl<'a> State<'a> {\n                 }\n \n                 if !options.is_empty() {\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                     self.word_space(\":\")?;\n                     self.commasep(Inconsistent, &options,\n                                   |s, &co| {\n@@ -2298,11 +2293,11 @@ impl<'a> State<'a> {\n             },\n             ast::ExprKind::Try(ref e) => {\n                 self.print_expr(e)?;\n-                word(&mut self.s, \"?\")?\n+                self.s.word(\"?\")?\n             }\n             ast::ExprKind::Catch(ref blk) => {\n                 self.head(\"do catch\")?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.print_block_with_attrs(blk, attrs)?\n             }\n         }\n@@ -2320,23 +2315,23 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_ident(&mut self, ident: ast::Ident) -> io::Result<()> {\n-        word(&mut self.s, &ident.name.as_str())?;\n+        self.s.word(&ident.name.as_str())?;\n         self.ann.post(self, NodeIdent(&ident))\n     }\n \n     pub fn print_usize(&mut self, i: usize) -> io::Result<()> {\n-        word(&mut self.s, &i.to_string())\n+        self.s.word(&i.to_string())\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) -> io::Result<()> {\n-        word(&mut self.s, &name.as_str())?;\n+        self.s.word(&name.as_str())?;\n         self.ann.post(self, NodeName(&name))\n     }\n \n     pub fn print_for_decl(&mut self, loc: &ast::Local,\n                           coll: &ast::Expr) -> io::Result<()> {\n         self.print_local_decl(loc)?;\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.word_space(\"in\")?;\n         self.print_expr(coll)\n     }\n@@ -2356,7 +2351,7 @@ impl<'a> State<'a> {\n         }\n         for (i, segment) in segments.enumerate() {\n             if i > 0 {\n-                word(&mut self.s, \"::\")?\n+                self.s.word(\"::\")?\n             }\n             self.print_path_segment(segment, colons_before_params)?;\n         }\n@@ -2385,16 +2380,16 @@ impl<'a> State<'a> {\n                    colons_before_params: bool)\n                    -> io::Result<()>\n     {\n-        word(&mut self.s, \"<\")?;\n+        self.s.word(\"<\")?;\n         self.print_type(&qself.ty)?;\n         if qself.position > 0 {\n-            space(&mut self.s)?;\n+            self.s.space()?;\n             self.word_space(\"as\")?;\n             let depth = path.segments.len() - qself.position;\n             self.print_path(path, false, depth, false)?;\n         }\n-        word(&mut self.s, \">\")?;\n-        word(&mut self.s, \"::\")?;\n+        self.s.word(\">\")?;\n+        self.s.word(\"::\")?;\n         let item_segment = path.segments.last().unwrap();\n         self.print_ident(item_segment.identifier)?;\n         match item_segment.parameters {\n@@ -2409,12 +2404,12 @@ impl<'a> State<'a> {\n                              -> io::Result<()>\n     {\n         if colons_before_params {\n-            word(&mut self.s, \"::\")?\n+            self.s.word(\"::\")?\n         }\n \n         match *parameters {\n             ast::PathParameters::AngleBracketed(ref data) => {\n-                word(&mut self.s, \"<\")?;\n+                self.s.word(\"<\")?;\n \n                 let mut comma = false;\n                 for lifetime in &data.lifetimes {\n@@ -2441,22 +2436,22 @@ impl<'a> State<'a> {\n                         self.word_space(\",\")?\n                     }\n                     self.print_ident(binding.ident)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                     self.word_space(\"=\")?;\n                     self.print_type(&binding.ty)?;\n                     comma = true;\n                 }\n \n-                word(&mut self.s, \">\")?\n+                self.s.word(\">\")?\n             }\n \n             ast::PathParameters::Parenthesized(ref data) => {\n-                word(&mut self.s, \"(\")?;\n+                self.s.word(\"(\")?;\n                 self.commasep(\n                     Inconsistent,\n                     &data.inputs,\n                     |s, ty| s.print_type(ty))?;\n-                word(&mut self.s, \")\")?;\n+                self.s.word(\")\")?;\n \n                 if let Some(ref ty) = data.output {\n                     self.space_if_not_bol()?;\n@@ -2475,7 +2470,7 @@ impl<'a> State<'a> {\n         /* Pat isn't normalized, but the beauty of it\n          is that it doesn't matter */\n         match pat.node {\n-            PatKind::Wild => word(&mut self.s, \"_\")?,\n+            PatKind::Wild => self.s.word(\"_\")?,\n             PatKind::Ident(binding_mode, ref path1, ref sub) => {\n                 match binding_mode {\n                     ast::BindingMode::ByRef(mutbl) => {\n@@ -2489,7 +2484,7 @@ impl<'a> State<'a> {\n                 }\n                 self.print_ident(path1.node)?;\n                 if let Some(ref p) = *sub {\n-                    word(&mut self.s, \"@\")?;\n+                    self.s.word(\"@\")?;\n                     self.print_pat(p)?;\n                 }\n             }\n@@ -2501,9 +2496,9 @@ impl<'a> State<'a> {\n                     if ddpos != 0 {\n                         self.word_space(\",\")?;\n                     }\n-                    word(&mut self.s, \"..\")?;\n+                    self.s.word(\"..\")?;\n                     if ddpos != elts.len() {\n-                        word(&mut self.s, \",\")?;\n+                        self.s.word(\",\")?;\n                         self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(p))?;\n                     }\n                 } else {\n@@ -2535,10 +2530,10 @@ impl<'a> State<'a> {\n                     |f| f.node.pat.span)?;\n                 if etc {\n                     if !fields.is_empty() { self.word_space(\",\")?; }\n-                    word(&mut self.s, \"..\")?;\n+                    self.s.word(\"..\")?;\n                 }\n-                space(&mut self.s)?;\n-                word(&mut self.s, \"}\")?;\n+                self.s.space()?;\n+                self.s.word(\"}\")?;\n             }\n             PatKind::Tuple(ref elts, ddpos) => {\n                 self.popen()?;\n@@ -2547,42 +2542,42 @@ impl<'a> State<'a> {\n                     if ddpos != 0 {\n                         self.word_space(\",\")?;\n                     }\n-                    word(&mut self.s, \"..\")?;\n+                    self.s.word(\"..\")?;\n                     if ddpos != elts.len() {\n-                        word(&mut self.s, \",\")?;\n+                        self.s.word(\",\")?;\n                         self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(p))?;\n                     }\n                 } else {\n                     self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(p))?;\n                     if elts.len() == 1 {\n-                        word(&mut self.s, \",\")?;\n+                        self.s.word(\",\")?;\n                     }\n                 }\n                 self.pclose()?;\n             }\n             PatKind::Box(ref inner) => {\n-                word(&mut self.s, \"box \")?;\n+                self.s.word(\"box \")?;\n                 self.print_pat(inner)?;\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n-                word(&mut self.s, \"&\")?;\n+                self.s.word(\"&\")?;\n                 if mutbl == ast::Mutability::Mutable {\n-                    word(&mut self.s, \"mut \")?;\n+                    self.s.word(\"mut \")?;\n                 }\n                 self.print_pat(inner)?;\n             }\n             PatKind::Lit(ref e) => self.print_expr(&**e)?,\n             PatKind::Range(ref begin, ref end, ref end_kind) => {\n                 self.print_expr(begin)?;\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 match *end_kind {\n-                    RangeEnd::Included => word(&mut self.s, \"...\")?,\n-                    RangeEnd::Excluded => word(&mut self.s, \"..\")?,\n+                    RangeEnd::Included => self.s.word(\"...\")?,\n+                    RangeEnd::Excluded => self.s.word(\"..\")?,\n                 }\n                 self.print_expr(end)?;\n             }\n             PatKind::Slice(ref before, ref slice, ref after) => {\n-                word(&mut self.s, \"[\")?;\n+                self.s.word(\"[\")?;\n                 self.commasep(Inconsistent,\n                                    &before[..],\n                                    |s, p| s.print_pat(p))?;\n@@ -2591,13 +2586,13 @@ impl<'a> State<'a> {\n                     if p.node != PatKind::Wild {\n                         self.print_pat(p)?;\n                     }\n-                    word(&mut self.s, \"..\")?;\n+                    self.s.word(\"..\")?;\n                     if !after.is_empty() { self.word_space(\",\")?; }\n                 }\n                 self.commasep(Inconsistent,\n                                    &after[..],\n                                    |s, p| s.print_pat(p))?;\n-                word(&mut self.s, \"]\")?;\n+                self.s.word(\"]\")?;\n             }\n             PatKind::Mac(ref m) => self.print_mac(m, token::Paren)?,\n         }\n@@ -2608,7 +2603,7 @@ impl<'a> State<'a> {\n         // I have no idea why this check is necessary, but here it\n         // is :(\n         if arm.attrs.is_empty() {\n-            space(&mut self.s)?;\n+            self.s.space()?;\n         }\n         self.cbox(INDENT_UNIT)?;\n         self.ibox(0)?;\n@@ -2619,16 +2614,16 @@ impl<'a> State<'a> {\n             if first {\n                 first = false;\n             } else {\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"|\")?;\n             }\n             self.print_pat(p)?;\n         }\n-        space(&mut self.s)?;\n+        self.s.space()?;\n         if let Some(ref e) = arm.guard {\n             self.word_space(\"if\")?;\n             self.print_expr(e)?;\n-            space(&mut self.s)?;\n+            self.s.space()?;\n         }\n         self.word_space(\"=>\")?;\n \n@@ -2639,13 +2634,13 @@ impl<'a> State<'a> {\n \n                 // If it is a user-provided unsafe block, print a comma after it\n                 if let BlockCheckMode::Unsafe(ast::UserProvided) = blk.rules {\n-                    word(&mut self.s, \",\")?;\n+                    self.s.word(\",\")?;\n                 }\n             }\n             _ => {\n                 self.end()?; // close the ibox for the pattern\n                 self.print_expr(&arm.body)?;\n-                word(&mut self.s, \",\")?;\n+                self.s.word(\",\")?;\n             }\n         }\n         self.end() // close enclosing cbox\n@@ -2655,17 +2650,17 @@ impl<'a> State<'a> {\n         match explicit_self.node {\n             SelfKind::Value(m) => {\n                 self.print_mutability(m)?;\n-                word(&mut self.s, \"self\")\n+                self.s.word(\"self\")\n             }\n             SelfKind::Region(ref lt, m) => {\n-                word(&mut self.s, \"&\")?;\n+                self.s.word(\"&\")?;\n                 self.print_opt_lifetime(lt)?;\n                 self.print_mutability(m)?;\n-                word(&mut self.s, \"self\")\n+                self.s.word(\"self\")\n             }\n             SelfKind::Explicit(ref typ, m) => {\n                 self.print_mutability(m)?;\n-                word(&mut self.s, \"self\")?;\n+                self.s.word(\"self\")?;\n                 self.word_space(\":\")?;\n                 self.print_type(typ)\n             }\n@@ -2696,7 +2691,7 @@ impl<'a> State<'a> {\n         self.popen()?;\n         self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, false))?;\n         if decl.variadic {\n-            word(&mut self.s, \", ...\")?;\n+            self.s.word(\", ...\")?;\n         }\n         self.pclose()?;\n \n@@ -2707,9 +2702,9 @@ impl<'a> State<'a> {\n             &mut self,\n             decl: &ast::FnDecl)\n             -> io::Result<()> {\n-        word(&mut self.s, \"|\")?;\n+        self.s.word(\"|\")?;\n         self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, true))?;\n-        word(&mut self.s, \"|\")?;\n+        self.s.word(\"|\")?;\n \n         if let ast::FunctionRetTy::Default(..) = decl.output {\n             return Ok(());\n@@ -2739,7 +2734,7 @@ impl<'a> State<'a> {\n                         bounds: &[ast::TyParamBound])\n                         -> io::Result<()> {\n         if !bounds.is_empty() {\n-            word(&mut self.s, prefix)?;\n+            self.s.word(prefix)?;\n             let mut first = true;\n             for bound in bounds {\n                 self.nbsp()?;\n@@ -2754,7 +2749,7 @@ impl<'a> State<'a> {\n                         self.print_poly_trait_ref(tref)\n                     }\n                     TraitTyParamBound(ref tref, TraitBoundModifier::Maybe) => {\n-                        word(&mut self.s, \"?\")?;\n+                        self.s.word(\"?\")?;\n                         self.print_poly_trait_ref(tref)\n                     }\n                     RegionTyParamBound(ref lt) => {\n@@ -2782,10 +2777,10 @@ impl<'a> State<'a> {\n     {\n         self.print_lifetime(lifetime)?;\n         if !bounds.is_empty() {\n-            word(&mut self.s, \": \")?;\n+            self.s.word(\": \")?;\n             for (i, bound) in bounds.iter().enumerate() {\n                 if i != 0 {\n-                    word(&mut self.s, \" + \")?;\n+                    self.s.word(\" + \")?;\n                 }\n                 self.print_lifetime(bound)?;\n             }\n@@ -2802,7 +2797,7 @@ impl<'a> State<'a> {\n             return Ok(());\n         }\n \n-        word(&mut self.s, \"<\")?;\n+        self.s.word(\"<\")?;\n \n         let mut ints = Vec::new();\n         for i in 0..total {\n@@ -2821,7 +2816,7 @@ impl<'a> State<'a> {\n             }\n         })?;\n \n-        word(&mut self.s, \">\")?;\n+        self.s.word(\">\")?;\n         Ok(())\n     }\n \n@@ -2831,7 +2826,7 @@ impl<'a> State<'a> {\n         self.print_bounds(\":\", &param.bounds)?;\n         match param.default {\n             Some(ref default) => {\n-                space(&mut self.s)?;\n+                self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_type(default)\n             }\n@@ -2845,7 +2840,7 @@ impl<'a> State<'a> {\n             return Ok(())\n         }\n \n-        space(&mut self.s)?;\n+        self.s.space()?;\n         self.word_space(\"where\")?;\n \n         for (i, predicate) in where_clause.predicates.iter().enumerate() {\n@@ -2871,7 +2866,7 @@ impl<'a> State<'a> {\n                                                                        ref rhs_ty,\n                                                                        ..}) => {\n                     self.print_type(lhs_ty)?;\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                     self.word_space(\"=\")?;\n                     self.print_type(rhs_ty)?;\n                 }\n@@ -2888,7 +2883,7 @@ impl<'a> State<'a> {\n \n                 if path.segments.last().unwrap().identifier.name !=\n                         ident.name {\n-                    space(&mut self.s)?;\n+                    self.s.space()?;\n                     self.word_space(\"as\")?;\n                     self.print_ident(ident)?;\n                 }\n@@ -2898,26 +2893,26 @@ impl<'a> State<'a> {\n \n             ast::ViewPathGlob(ref path) => {\n                 self.print_path(path, false, 0, true)?;\n-                word(&mut self.s, \"::*\")\n+                self.s.word(\"::*\")\n             }\n \n             ast::ViewPathList(ref path, ref idents) => {\n                 if path.segments.is_empty() {\n-                    word(&mut self.s, \"{\")?;\n+                    self.s.word(\"{\")?;\n                 } else {\n                     self.print_path(path, false, 0, true)?;\n-                    word(&mut self.s, \"::{\")?;\n+                    self.s.word(\"::{\")?;\n                 }\n                 self.commasep(Inconsistent, &idents[..], |s, w| {\n                     s.print_ident(w.node.name)?;\n                     if let Some(ident) = w.node.rename {\n-                        space(&mut s.s)?;\n+                        s.s.space()?;\n                         s.word_space(\"as\")?;\n                         s.print_ident(ident)?;\n                     }\n                     Ok(())\n                 })?;\n-                word(&mut self.s, \"}\")\n+                self.s.word(\"}\")\n             }\n         }\n     }\n@@ -2950,8 +2945,8 @@ impl<'a> State<'a> {\n                     };\n                     if !invalid {\n                         self.print_pat(&input.pat)?;\n-                        word(&mut self.s, \":\")?;\n-                        space(&mut self.s)?;\n+                        self.s.word(\":\")?;\n+                        self.s.space()?;\n                     }\n                     self.print_type(&input.ty)?;\n                 }\n@@ -2990,7 +2985,7 @@ impl<'a> State<'a> {\n                        -> io::Result<()> {\n         self.ibox(INDENT_UNIT)?;\n         if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n-            word(&mut self.s, \"for\")?;\n+            self.s.word(\"for\")?;\n             self.print_generics(generics)?;\n         }\n         let generics = ast::Generics {\n@@ -3036,7 +3031,7 @@ impl<'a> State<'a> {\n         // If there aren't any remaining comments, then we need to manually\n         // make sure there is a line break at the end.\n         if self.next_comment().is_none() {\n-            hardbreak(&mut self.s)?;\n+            self.s.hardbreak()?;\n         }\n         while let Some(ref cmnt) = self.next_comment() {\n             self.print_comment(cmnt)?;\n@@ -3074,7 +3069,7 @@ impl<'a> State<'a> {\n                                 constness: ast::Constness,\n                                 abi: Abi,\n                                 vis: &ast::Visibility) -> io::Result<()> {\n-        word(&mut self.s, &visibility_qualified(vis, \"\"))?;\n+        self.s.word(&visibility_qualified(vis, \"\"))?;\n \n         match constness {\n             ast::Constness::NotConst => {}\n@@ -3088,7 +3083,7 @@ impl<'a> State<'a> {\n             self.word_nbsp(&abi.to_string())?;\n         }\n \n-        word(&mut self.s, \"fn\")\n+        self.s.word(\"fn\")\n     }\n \n     pub fn print_unsafety(&mut self, s: ast::Unsafety) -> io::Result<()> {"}]}