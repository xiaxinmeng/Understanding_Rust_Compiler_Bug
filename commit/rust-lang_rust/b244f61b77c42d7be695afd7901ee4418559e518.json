{"sha": "b244f61b77c42d7be695afd7901ee4418559e518", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNDRmNjFiNzdjNDJkN2JlNjk1YWZkNzkwMWVlNDQxODU1OWU1MTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-12T19:09:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-12T19:09:24Z"}, "message": "Auto merge of #58341 - alexreg:cosmetic-2-doc-comments, r=steveklabnik\n\nCosmetic improvements to doc comments\n\nThis has been factored out from https://github.com/rust-lang/rust/pull/58036 to only include changes to documentation comments (throughout the rustc codebase).\n\nr? @steveklabnik\n\nOnce you're happy with this, maybe we could get it through with r=1, so it doesn't constantly get invalidated? (I'm not sure this will be an issue, but just in case...) Anyway, thanks for your advice so far!", "tree": {"sha": "fe7f5306514a208d95bfffe4b6886cc898d29287", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe7f5306514a208d95bfffe4b6886cc898d29287"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b244f61b77c42d7be695afd7901ee4418559e518", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b244f61b77c42d7be695afd7901ee4418559e518", "html_url": "https://github.com/rust-lang/rust/commit/b244f61b77c42d7be695afd7901ee4418559e518", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b244f61b77c42d7be695afd7901ee4418559e518/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c84e7976423bb910bb5eb5eecffc7e33a897a97f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c84e7976423bb910bb5eb5eecffc7e33a897a97f", "html_url": "https://github.com/rust-lang/rust/commit/c84e7976423bb910bb5eb5eecffc7e33a897a97f"}, {"sha": "f943296a7631faaffcf5c19e4cfbc424b14d1fc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f943296a7631faaffcf5c19e4cfbc424b14d1fc0", "html_url": "https://github.com/rust-lang/rust/commit/f943296a7631faaffcf5c19e4cfbc424b14d1fc0"}], "stats": {"total": 5672, "additions": 2850, "deletions": 2822}, "files": [{"sha": "78ba1d376be79bd8e77967879bd34b13093722d6", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -60,17 +60,17 @@ pub trait Step: 'static + Clone + Debug + PartialEq + Eq + Hash {\n     /// Run this rule for all hosts without cross compiling.\n     const ONLY_HOSTS: bool = false;\n \n-    /// Primary function to execute this rule. Can call `builder.ensure(...)`\n+    /// Primary function to execute this rule. Can call `builder.ensure()`\n     /// with other steps to run those.\n     fn run(self, builder: &Builder) -> Self::Output;\n \n     /// When bootstrap is passed a set of paths, this controls whether this rule\n     /// will execute. However, it does not get called in a \"default\" context\n-    /// when we are not passed any paths; in that case, make_run is called\n+    /// when we are not passed any paths; in that case, `make_run` is called\n     /// directly.\n     fn should_run(run: ShouldRun) -> ShouldRun;\n \n-    /// Build up a \"root\" rule, either as a default rule or from a path passed\n+    /// Builds up a \"root\" rule, either as a default rule or from a path passed\n     /// to us.\n     ///\n     /// When path is `None`, we are executing in a context where no paths were\n@@ -648,7 +648,7 @@ impl<'a> Builder<'a> {\n         add_lib_path(vec![self.rustc_libdir(compiler)], cmd);\n     }\n \n-    /// Get a path to the compiler specified.\n+    /// Gets a path to the compiler specified.\n     pub fn rustc(&self, compiler: Compiler) -> PathBuf {\n         if compiler.is_snapshot(self) {\n             self.initial_rustc.clone()\n@@ -659,7 +659,7 @@ impl<'a> Builder<'a> {\n         }\n     }\n \n-    /// Get the paths to all of the compiler's codegen backends.\n+    /// Gets the paths to all of the compiler's codegen backends.\n     fn codegen_backends(&self, compiler: Compiler) -> impl Iterator<Item = PathBuf> {\n         fs::read_dir(self.sysroot_codegen_backends(compiler))\n             .into_iter()"}, {"sha": "5f84816789a689cb09690954c3f240facc974c4f", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -227,10 +227,10 @@ lazy_static! {\n     pub static ref INTERNER: Interner = Interner::default();\n }\n \n-/// This is essentially a HashMap which allows storing any type in its input and\n+/// This is essentially a `HashMap` which allows storing any type in its input and\n /// any type in its output. It is a write-once cache; values are never evicted,\n /// which means that references to the value can safely be returned from the\n-/// get() method.\n+/// `get()` method.\n #[derive(Debug)]\n pub struct Cache(\n     RefCell<HashMap<"}, {"sha": "2a2533a3c1407d773667f281968bdbcecdea5950", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -66,7 +66,7 @@ impl Step for Rustc {\n         });\n     }\n \n-    /// Build the compiler.\n+    /// Builds the compiler.\n     ///\n     /// This will build the compiler for a particular stage of the build using\n     /// the `compiler` targeting the `target` architecture. The artifacts"}, {"sha": "b52e1a7b0e6816032c9ca07f4d500888f7637592", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -3,7 +3,7 @@\n //! Responsible for cleaning out a build directory of all old and stale\n //! artifacts to prepare for a fresh build. Currently doesn't remove the\n //! `build/cache` directory (download cache) or the `build/$target/llvm`\n-//! directory unless the --all flag is present.\n+//! directory unless the `--all` flag is present.\n \n use std::fs;\n use std::io::{self, ErrorKind};"}, {"sha": "8fabb8c3fd08f504f4c2bb56a8d80f98aee8adfb", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -48,7 +48,7 @@ impl Step for Std {\n         });\n     }\n \n-    /// Build the standard library.\n+    /// Builds the standard library.\n     ///\n     /// This will build the standard library for a particular stage of the build\n     /// using the `compiler` targeting the `target` architecture. The artifacts\n@@ -269,7 +269,7 @@ impl Step for StartupObjects {\n         });\n     }\n \n-    /// Build and prepare startup objects like rsbegin.o and rsend.o\n+    /// Builds and prepare startup objects like rsbegin.o and rsend.o\n     ///\n     /// These are primarily used on Windows right now for linking executables/dlls.\n     /// They don't require any library support as they're just plain old object\n@@ -334,7 +334,7 @@ impl Step for Test {\n         });\n     }\n \n-    /// Build libtest.\n+    /// Builds libtest.\n     ///\n     /// This will build libtest and supporting libraries for a particular stage of\n     /// the build using the `compiler` targeting the `target` architecture. The\n@@ -455,7 +455,7 @@ impl Step for Rustc {\n         });\n     }\n \n-    /// Build the compiler.\n+    /// Builds the compiler.\n     ///\n     /// This will build the compiler for a particular stage of the build using\n     /// the `compiler` targeting the `target` architecture. The artifacts"}, {"sha": "bc1fdad356be3eee5e959b3063dbb3a62acde22d", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -342,7 +342,7 @@ impl Step for Mingw {\n         run.builder.ensure(Mingw { host: run.target });\n     }\n \n-    /// Build the `rust-mingw` installer component.\n+    /// Builds the `rust-mingw` installer component.\n     ///\n     /// This contains all the bits and pieces to run the MinGW Windows targets\n     /// without any extra installed software (e.g., we bundle gcc, libraries, etc)."}, {"sha": "d14b23e5988cbb85266875a5dee55de259e19eef", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -259,7 +259,7 @@ impl Step for TheBook {\n         });\n     }\n \n-    /// Build the book and associated stuff.\n+    /// Builds the book and associated stuff.\n     ///\n     /// We need to build:\n     ///\n@@ -611,7 +611,7 @@ impl Step for WhitelistedRustc {\n         });\n     }\n \n-    /// Generate whitelisted compiler crate documentation.\n+    /// Generates whitelisted compiler crate documentation.\n     ///\n     /// This will generate all documentation for crates that are whitelisted\n     /// to be included in the standard documentation. This documentation is\n@@ -683,7 +683,7 @@ impl Step for Rustc {\n         });\n     }\n \n-    /// Generate compiler documentation.\n+    /// Generates compiler documentation.\n     ///\n     /// This will generate all documentation for compiler and dependencies.\n     /// Compiler documentation is distributed separately, so we make sure\n@@ -784,7 +784,7 @@ impl Step for Rustdoc {\n         });\n     }\n \n-    /// Generate compiler documentation.\n+    /// Generates compiler documentation.\n     ///\n     /// This will generate all documentation for compiler and dependencies.\n     /// Compiler documentation is distributed separately, so we make sure"}, {"sha": "6a93c95c3d97fb4d6012a876c1fcb7e076ebf9c0", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -69,7 +69,7 @@\n //! ## Copying stage0 {std,test,rustc}\n //!\n //! This copies the build output from Cargo into\n-//! `build/$HOST/stage0-sysroot/lib/rustlib/$ARCH/lib`. FIXME: This step's\n+//! `build/$HOST/stage0-sysroot/lib/rustlib/$ARCH/lib`. FIXME: this step's\n //! documentation should be expanded -- the information already here may be\n //! incorrect.\n //!\n@@ -504,7 +504,7 @@ impl Build {\n         cleared\n     }\n \n-    /// Get the space-separated set of activated features for the standard\n+    /// Gets the space-separated set of activated features for the standard\n     /// library.\n     fn std_features(&self) -> String {\n         let mut features = \"panic-unwind\".to_string();\n@@ -521,7 +521,7 @@ impl Build {\n         features\n     }\n \n-    /// Get the space-separated set of activated features for the compiler.\n+    /// Gets the space-separated set of activated features for the compiler.\n     fn rustc_features(&self) -> String {\n         let mut features = String::new();\n         if self.config.jemalloc {\n@@ -609,7 +609,7 @@ impl Build {\n         self.out.join(&*target).join(\"crate-docs\")\n     }\n \n-    /// Returns true if no custom `llvm-config` is set for the specified target.\n+    /// Returns `true` if no custom `llvm-config` is set for the specified target.\n     ///\n     /// If no custom `llvm-config` was specified then Rust's llvm will be used.\n     fn is_rust_llvm(&self, target: Interned<String>) -> bool {\n@@ -857,13 +857,13 @@ impl Build {\n             .map(|p| &**p)\n     }\n \n-    /// Returns true if this is a no-std `target`, if defined\n+    /// Returns `true` if this is a no-std `target`, if defined\n     fn no_std(&self, target: Interned<String>) -> Option<bool> {\n         self.config.target_config.get(&target)\n             .map(|t| t.no_std)\n     }\n \n-    /// Returns whether the target will be tested using the `remote-test-client`\n+    /// Returns `true` if the target will be tested using the `remote-test-client`\n     /// and `remote-test-server` binaries.\n     fn remote_tested(&self, target: Interned<String>) -> bool {\n         self.qemu_rootfs(target).is_some() || target.contains(\"android\") ||\n@@ -1059,7 +1059,7 @@ impl Build {\n         self.rust_info.version(self, channel::CFG_RELEASE_NUM)\n     }\n \n-    /// Return the full commit hash\n+    /// Returns the full commit hash.\n     fn rust_sha(&self) -> Option<&str> {\n         self.rust_info.sha()\n     }\n@@ -1079,7 +1079,7 @@ impl Build {\n         panic!(\"failed to find version in {}'s Cargo.toml\", package)\n     }\n \n-    /// Returns whether unstable features should be enabled for the compiler\n+    /// Returns `true` if unstable features should be enabled for the compiler\n     /// we're building.\n     fn unstable_features(&self) -> bool {\n         match &self.config.channel[..] {\n@@ -1327,7 +1327,7 @@ impl<'a> Compiler {\n         self\n     }\n \n-    /// Returns whether this is a snapshot compiler for `build`'s configuration\n+    /// Returns `true` if this is a snapshot compiler for `build`'s configuration\n     pub fn is_snapshot(&self, build: &Build) -> bool {\n         self.stage == 0 && self.host == build.build\n     }"}, {"sha": "a882550f734f40ead12195582c15e84dc2dedc9a", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -30,9 +30,9 @@ const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n /// The two modes of the test runner; tests or benchmarks.\n #[derive(Debug, PartialEq, Eq, Hash, Copy, Clone, PartialOrd, Ord)]\n pub enum TestKind {\n-    /// Run `cargo test`\n+    /// Run `cargo test`.\n     Test,\n-    /// Run `cargo bench`\n+    /// Run `cargo bench`.\n     Bench,\n }\n \n@@ -1288,7 +1288,7 @@ impl Step for DocTest {\n         run.never()\n     }\n \n-    /// Run `rustdoc --test` for all documentation in `src/doc`.\n+    /// Runs `rustdoc --test` for all documentation in `src/doc`.\n     ///\n     /// This will run all tests in our markdown documentation (e.g., the book)\n     /// located in `src/doc`. The `rustdoc` that's run is the one that sits next to\n@@ -1408,7 +1408,7 @@ impl Step for ErrorIndex {\n         });\n     }\n \n-    /// Run the error index generator tool to execute the tests located in the error\n+    /// Runs the error index generator tool to execute the tests located in the error\n     /// index.\n     ///\n     /// The `error_index_generator` tool lives in `src/tools` and is used to\n@@ -1614,7 +1614,7 @@ impl Step for Crate {\n         }\n     }\n \n-    /// Run all unit tests plus documentation tests for a given crate defined\n+    /// Runs all unit tests plus documentation tests for a given crate defined\n     /// by a `Cargo.toml` (single manifest)\n     ///\n     /// This is what runs tests for crates like the standard library, compiler, etc.\n@@ -1833,7 +1833,7 @@ fn envify(s: &str) -> String {\n /// the standard library and such to the emulator ahead of time. This step\n /// represents this and is a dependency of all test suites.\n ///\n-/// Most of the time this is a noop. For some steps such as shipping data to\n+/// Most of the time this is a no-op. For some steps such as shipping data to\n /// QEMU we have to build our own tools so we've got conditional dependencies\n /// on those programs as well. Note that the remote test client is built for\n /// the build target (us) and the server is built for the target.\n@@ -1904,7 +1904,7 @@ impl Step for Distcheck {\n         run.builder.ensure(Distcheck);\n     }\n \n-    /// Run \"distcheck\", a 'make check' from a tarball\n+    /// Runs \"distcheck\", a 'make check' from a tarball\n     fn run(self, builder: &Builder) {\n         builder.info(\"Distcheck\");\n         let dir = builder.out.join(\"tmp\").join(\"distcheck\");\n@@ -1965,7 +1965,7 @@ impl Step for Bootstrap {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    /// Test the build system itself\n+    /// Tests the build system itself.\n     fn run(self, builder: &Builder) {\n         let mut cmd = Command::new(&builder.initial_cargo);\n         cmd.arg(\"test\")"}, {"sha": "c09e9332895d87f12b84671d215d6b62afc34025", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -40,7 +40,7 @@ impl Step for ToolBuild {\n         run.never()\n     }\n \n-    /// Build a tool in `src/tools`\n+    /// Builds a tool in `src/tools`\n     ///\n     /// This will build the specified tool with the specified `host` compiler in\n     /// `stage` into the normal cargo output directory.\n@@ -621,7 +621,7 @@ tool_extended!((self, builder),\n );\n \n impl<'a> Builder<'a> {\n-    /// Get a `Command` which is ready to run `tool` in `stage` built for\n+    /// Gets a `Command` which is ready to run `tool` in `stage` built for\n     /// `host`.\n     pub fn tool_cmd(&self, tool: Tool) -> Command {\n         let mut cmd = Command::new(self.tool_exe(tool));"}, {"sha": "29aa98971fb567a846b7cd18d5cf5197f355a571", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -33,7 +33,7 @@ pub fn exe(name: &str, target: &str) -> String {\n     }\n }\n \n-/// Returns whether the file name given looks like a dynamic library.\n+/// Returns `true` if the file name given looks like a dynamic library.\n pub fn is_dylib(name: &str) -> bool {\n     name.ends_with(\".dylib\") || name.ends_with(\".so\") || name.ends_with(\".dll\")\n }"}, {"sha": "bd99dc118e66a36ab2f819aac565669f2fc947c3", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -163,7 +163,7 @@ pub fn mtime(path: &Path) -> SystemTime {\n         .unwrap_or(UNIX_EPOCH)\n }\n \n-/// Returns whether `dst` is up to date given that the file or files in `src`\n+/// Returns `true` if `dst` is up to date given that the file or files in `src`\n /// are used to generate it.\n ///\n /// Uses last-modified time checks to verify this.\n@@ -190,12 +190,12 @@ pub struct NativeLibBoilerplate {\n }\n \n impl NativeLibBoilerplate {\n-    /// On OSX we don't want to ship the exact filename that compiler-rt builds.\n+    /// On macOS we don't want to ship the exact filename that compiler-rt builds.\n     /// This conflicts with the system and ours is likely a wildly different\n     /// version, so they can't be substituted.\n     ///\n     /// As a result, we rename it here but we need to also use\n-    /// `install_name_tool` on OSX to rename the commands listed inside of it to\n+    /// `install_name_tool` on macOS to rename the commands listed inside of it to\n     /// ensure it's linked against correctly.\n     pub fn fixup_sanitizer_lib_name(&self, sanitizer_name: &str) {\n         if env::var(\"TARGET\").unwrap() != \"x86_64-apple-darwin\" {"}, {"sha": "40c71f12cd8a6320e9751024c25fcc81716440cd", "filename": "src/liballoc/borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fborrow.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -137,11 +137,11 @@ impl<T> ToOwned for T\n /// ```\n /// use std::borrow::{Cow, ToOwned};\n ///\n-/// struct Items<'a, X: 'a> where [X]: ToOwned<Owned=Vec<X>> {\n+/// struct Items<'a, X: 'a> where [X]: ToOwned<Owned = Vec<X>> {\n ///     values: Cow<'a, [X]>,\n /// }\n ///\n-/// impl<'a, X: Clone + 'a> Items<'a, X> where [X]: ToOwned<Owned=Vec<X>> {\n+/// impl<'a, X: Clone + 'a> Items<'a, X> where [X]: ToOwned<Owned = Vec<X>> {\n ///     fn new(v: Cow<'a, [X]>) -> Self {\n ///         Items { values: v }\n ///     }"}, {"sha": "3b94379b58f8f03c2e09e09bba1254263b53b423", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -863,7 +863,7 @@ struct Hole<'a, T: 'a> {\n }\n \n impl<'a, T> Hole<'a, T> {\n-    /// Create a new Hole at index `pos`.\n+    /// Create a new `Hole` at index `pos`.\n     ///\n     /// Unsafe because pos must be within the data slice.\n     #[inline]"}, {"sha": "5ec5064b735150b45465fc1c0fc996daf52ac285", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -2368,7 +2368,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n \n     /// Gets a mutable reference to the value in the entry.\n     ///\n-    /// If you need a reference to the `OccupiedEntry` which may outlive the\n+    /// If you need a reference to the `OccupiedEntry` that may outlive the\n     /// destruction of the `Entry` value, see [`into_mut`].\n     ///\n     /// [`into_mut`]: #method.into_mut"}, {"sha": "eb0667228d1fff347f64b859fede02b99e8dc88f", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -50,11 +50,11 @@ pub const CAPACITY: usize = 2 * B - 1;\n ///\n /// We have a separate type for the header and rely on it matching the prefix of `LeafNode`, in\n /// order to statically allocate a single dummy node to avoid allocations. This struct is\n-/// `repr(C)` to prevent them from being reordered.  `LeafNode` does not just contain a\n+/// `repr(C)` to prevent them from being reordered. `LeafNode` does not just contain a\n /// `NodeHeader` because we do not want unnecessary padding between `len` and the keys.\n-/// Crucially, `NodeHeader` can be safely transmuted to different K and V.  (This is exploited\n+/// Crucially, `NodeHeader` can be safely transmuted to different K and V. (This is exploited\n /// by `as_header`.)\n-/// See `into_key_slice` for an explanation of K2.  K2 cannot be safely transmuted around\n+/// See `into_key_slice` for an explanation of K2. K2 cannot be safely transmuted around\n /// because the size of `NodeHeader` depends on its alignment!\n #[repr(C)]\n struct NodeHeader<K, V, K2 = ()> {\n@@ -1295,7 +1295,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         }\n     }\n \n-    /// Returns whether it is valid to call `.merge()`, i.e., whether there is enough room in\n+    /// Returns `true` if it is valid to call `.merge()`, i.e., whether there is enough room in\n     /// a node to hold the combination of the nodes to the left and right of this handle along\n     /// with the key/value pair at this handle.\n     pub fn can_merge(&self) -> bool {\n@@ -1573,7 +1573,7 @@ unsafe fn move_edges<K, V>(\n impl<BorrowType, K, V, HandleType>\n         Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, HandleType> {\n \n-    /// Check whether the underlying node is an `Internal` node or a `Leaf` node.\n+    /// Checks whether the underlying node is an `Internal` node or a `Leaf` node.\n     pub fn force(self) -> ForceResult<\n         Handle<NodeRef<BorrowType, K, V, marker::Leaf>, HandleType>,\n         Handle<NodeRef<BorrowType, K, V, marker::Internal>, HandleType>"}, {"sha": "870e3e47692b02ba605dea74239aa740e088c452", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -556,7 +556,7 @@ impl<T: Ord> BTreeSet<T> {\n         Recover::replace(&mut self.map, value)\n     }\n \n-    /// Removes a value from the set. Returns `true` if the value was\n+    /// Removes a value from the set. Returns whether the value was\n     /// present in the set.\n     ///\n     /// The value may be any borrowed form of the set's value type,\n@@ -988,7 +988,7 @@ impl<'a, T> DoubleEndedIterator for Range<'a, T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for Range<'_, T> {}\n \n-/// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n+/// Compares `x` and `y`, but return `short` if x is None and `long` if y is None\n fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>, short: Ordering, long: Ordering) -> Ordering {\n     match (x, y) {\n         (None, _) => short,"}, {"sha": "b6fdaa89992122f98c94938e9e091cfedf41a0e4", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -124,7 +124,7 @@ impl<T> VecDeque<T> {\n         ptr::write(self.ptr().add(off), value);\n     }\n \n-    /// Returns `true` if and only if the buffer is at full capacity.\n+    /// Returns `true` if the buffer is at full capacity.\n     #[inline]\n     fn is_full(&self) -> bool {\n         self.cap() - self.len() == 1\n@@ -560,7 +560,7 @@ impl<T> VecDeque<T> {\n     /// Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n-    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// requests. Therefore, capacity can not be relied upon to be precisely\n     /// minimal. Prefer `reserve` if future insertions are expected.\n     ///\n     /// # Errors\n@@ -924,15 +924,15 @@ impl<T> VecDeque<T> {\n         self.tail == self.head\n     }\n \n-    /// Create a draining iterator that removes the specified range in the\n+    /// Creates a draining iterator that removes the specified range in the\n     /// `VecDeque` and yields the removed items.\n     ///\n     /// Note 1: The element range is removed even if the iterator is not\n     /// consumed until the end.\n     ///\n     /// Note 2: It is unspecified how many elements are removed from the deque,\n     /// if the `Drain` value is not dropped, but the borrow it holds expires\n-    /// (eg. due to mem::forget).\n+    /// (e.g., due to `mem::forget`).\n     ///\n     /// # Panics\n     ///\n@@ -1922,7 +1922,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Panics\n     ///\n-    /// If `mid` is greater than `len()`.  Note that `mid == len()`\n+    /// If `mid` is greater than `len()`. Note that `mid == len()`\n     /// does _not_ panic and is a no-op rotation.\n     ///\n     /// # Complexity\n@@ -1967,7 +1967,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Panics\n     ///\n-    /// If `k` is greater than `len()`.  Note that `k == len()`\n+    /// If `k` is greater than `len()`. Note that `k == len()`\n     /// does _not_ panic and is a no-op rotation.\n     ///\n     /// # Complexity"}, {"sha": "d2ba9b001916c572e142fedfbc6d312842928cb0", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -27,7 +27,7 @@\n //! will then parse the format string and determine if the list of arguments\n //! provided is suitable to pass to this format string.\n //!\n-//! To convert a single value to a string, use the [`to_string`] method.  This\n+//! To convert a single value to a string, use the [`to_string`] method. This\n //! will use the [`Display`] formatting trait.\n //!\n //! ## Positional parameters\n@@ -102,7 +102,7 @@\n //! When requesting that an argument be formatted with a particular type, you\n //! are actually requesting that an argument ascribes to a particular trait.\n //! This allows multiple actual types to be formatted via `{:x}` (like [`i8`] as\n-//! well as [`isize`]).  The current mapping of types to traits is:\n+//! well as [`isize`]). The current mapping of types to traits is:\n //!\n //! * *nothing* \u21d2 [`Display`]\n //! * `?` \u21d2 [`Debug`]\n@@ -427,7 +427,7 @@\n //! 3. An asterisk `.*`:\n //!\n //!    `.*` means that this `{...}` is associated with *two* format inputs rather than one: the\n-//!    first input holds the `usize` precision, and the second holds the value to print.  Note that\n+//!    first input holds the `usize` precision, and the second holds the value to print. Note that\n //!    in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part refers\n //!    to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n //!"}, {"sha": "eb3410078513de3e25a945caaf58645462afab1f", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -63,18 +63,18 @@ macro_rules! vec {\n \n /// Creates a `String` using interpolation of runtime expressions.\n ///\n-/// The first argument `format!` receives is a format string.  This must be a string\n-/// literal.  The power of the formatting string is in the `{}`s contained.\n+/// The first argument `format!` receives is a format string. This must be a string\n+/// literal. The power of the formatting string is in the `{}`s contained.\n ///\n /// Additional parameters passed to `format!` replace the `{}`s within the\n /// formatting string in the order given unless named or positional parameters\n-/// are used, see [`std::fmt`][fmt] for more information.\n+/// are used; see [`std::fmt`][fmt] for more information.\n ///\n /// A common use for `format!` is concatenation and interpolation of strings.\n /// The same convention is used with [`print!`] and [`write!`] macros,\n /// depending on the intended destination of the string.\n ///\n-/// To convert a single value to a string, use the [`to_string`] method.  This\n+/// To convert a single value to a string, use the [`to_string`] method. This\n /// will use the [`Display`] formatting trait.\n ///\n /// [fmt]: ../std/fmt/index.html"}, {"sha": "fe28fe5095ccef29333311057ac65cb415f31da0", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -335,7 +335,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// enough to want to do that it's easiest to just have a dedicated method. Slightly\n     /// more efficient logic can be provided for this than the general case.\n     ///\n-    /// Returns true if the reallocation attempt has succeeded, or false otherwise.\n+    /// Returns `true` if the reallocation attempt has succeeded.\n     ///\n     /// # Panics\n     ///\n@@ -504,7 +504,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// the requested space. This is not really unsafe, but the unsafe\n     /// code *you* write that relies on the behavior of this function may break.\n     ///\n-    /// Returns true if the reallocation attempt has succeeded, or false otherwise.\n+    /// Returns `true` if the reallocation attempt has succeeded.\n     ///\n     /// # Panics\n     ///"}, {"sha": "12f75d84211e6f03e555b4c7e32e2aabc7c5255c", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -512,7 +512,7 @@ impl<T: ?Sized> Rc<T> {\n         this.strong()\n     }\n \n-    /// Returns true if there are no other `Rc` or [`Weak`][weak] pointers to\n+    /// Returns `true` if there are no other `Rc` or [`Weak`][weak] pointers to\n     /// this inner value.\n     ///\n     /// [weak]: struct.Weak.html\n@@ -561,7 +561,7 @@ impl<T: ?Sized> Rc<T> {\n \n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n-    /// Returns true if the two `Rc`s point to the same value (not\n+    /// Returns `true` if the two `Rc`s point to the same value (not\n     /// just values that compare as equal).\n     ///\n     /// # Examples\n@@ -1334,8 +1334,8 @@ impl<T: ?Sized> Weak<T> {\n         })\n     }\n \n-    /// Return `None` when the pointer is dangling and there is no allocated `RcBox`,\n-    /// i.e., this `Weak` was created by `Weak::new`\n+    /// Returns `None` when the pointer is dangling and there is no allocated `RcBox`\n+    /// (i.e., when this `Weak` was created by `Weak::new`).\n     #[inline]\n     fn inner(&self) -> Option<&RcBox<T>> {\n         if is_dangling(self.ptr) {\n@@ -1345,7 +1345,7 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns true if the two `Weak`s point to the same value (not just values\n+    /// Returns `true` if the two `Weak`s point to the same value (not just values\n     /// that compare as equal).\n     ///\n     /// # Notes"}, {"sha": "c4f4a80a017df80aed003097f3252e0bea645b67", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -205,10 +205,10 @@ impl<T> [T] {\n     ///\n     /// The comparator function must define a total ordering for the elements in the slice. If\n     /// the ordering is not total, the order of the elements is unspecified. An order is a\n-    /// total order if it is (for all a, b and c):\n+    /// total order if it is (for all `a`, `b` and `c`):\n     ///\n-    /// * total and antisymmetric: exactly one of a < b, a == b or a > b is true; and\n-    /// * transitive, a < b and b < c implies a < c. The same must hold for both == and >.\n+    /// * total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is true, and\n+    /// * transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n     ///\n     /// For example, while [`f64`] doesn't implement [`Ord`] because `NaN != NaN`, we can use\n     /// `partial_cmp` as our sort function when we know the slice doesn't contain a `NaN`."}, {"sha": "84c35c6f1bd2b0b943faa86cbf24d65fe87114e1", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -963,7 +963,7 @@ impl String {\n     /// Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n-    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// requests. Therefore, capacity can not be relied upon to be precisely\n     /// minimal. Prefer `reserve` if future insertions are expected.\n     ///\n     /// # Errors\n@@ -1377,9 +1377,7 @@ impl String {\n         self.vec.len()\n     }\n \n-    /// Returns `true` if this `String` has a length of zero.\n-    ///\n-    /// Returns `false` otherwise.\n+    /// Returns `true` if this `String` has a length of zero, and `false` otherwise.\n     ///\n     /// # Examples\n     ///"}, {"sha": "b7d7995b540bac75fd23000e8351cd76c66bfd1b", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -560,7 +560,7 @@ impl<T: ?Sized> Arc<T> {\n \n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n-    /// Returns true if the two `Arc`s point to the same value (not\n+    /// Returns `true` if the two `Arc`s point to the same value (not\n     /// just values that compare as equal).\n     ///\n     /// # Examples\n@@ -1191,8 +1191,8 @@ impl<T: ?Sized> Weak<T> {\n         })\n     }\n \n-    /// Return `None` when the pointer is dangling and there is no allocated `ArcInner`,\n-    /// i.e., this `Weak` was created by `Weak::new`\n+    /// Returns `None` when the pointer is dangling and there is no allocated `ArcInner`,\n+    /// (i.e., when this `Weak` was created by `Weak::new`).\n     #[inline]\n     fn inner(&self) -> Option<&ArcInner<T>> {\n         if is_dangling(self.ptr) {\n@@ -1202,7 +1202,7 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns true if the two `Weak`s point to the same value (not just values\n+    /// Returns `true` if the two `Weak`s point to the same value (not just values\n     /// that compare as equal).\n     ///\n     /// # Notes"}, {"sha": "7bc1aac7c8b59643723339646360a8abaf439564", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -2,7 +2,7 @@\n \n use std::alloc::{Global, Alloc, Layout, System};\n \n-/// https://github.com/rust-lang/rust/issues/45955\n+/// Issue #45955.\n #[test]\n fn alloc_system_overaligned_request() {\n     check_overalign_requests(System)"}, {"sha": "57723e4d2128182001b917c90a7ba81b39bd2710", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -463,7 +463,7 @@ impl<T> Vec<T> {\n     /// Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n-    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// requests. Therefore, capacity can not be relied upon to be precisely\n     /// minimal. Prefer `reserve` if future insertions are expected.\n     ///\n     /// # Panics\n@@ -525,7 +525,7 @@ impl<T> Vec<T> {\n     /// Does nothing if the capacity is already sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n-    /// requests. Therefore capacity can not be relied upon to be precisely\n+    /// requests. Therefore, capacity can not be relied upon to be precisely\n     /// minimal. Prefer `reserve` if future insertions are expected.\n     ///\n     /// # Errors\n@@ -738,7 +738,7 @@ impl<T> Vec<T> {\n     /// Forces the length of the vector to `new_len`.\n     ///\n     /// This is a low-level operation that maintains none of the normal\n-    /// invariants of the type.  Normally changing the length of a vector\n+    /// invariants of the type. Normally changing the length of a vector\n     /// is done using one of the safe operations instead, such as\n     /// [`truncate`], [`resize`], [`extend`], or [`clear`].\n     ///\n@@ -2608,7 +2608,7 @@ impl<T> Drain<'_, T> {\n     /// The range from `self.vec.len` to `self.tail_start` contains elements\n     /// that have been moved out.\n     /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n-    /// Return whether we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n+    /// Returns `true` if we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n     unsafe fn fill<I: Iterator<Item=T>>(&mut self, replace_with: &mut I) -> bool {\n         let vec = self.vec.as_mut();\n         let range_start = vec.len;\n@@ -2628,7 +2628,7 @@ impl<T> Drain<'_, T> {\n         true\n     }\n \n-    /// Make room for inserting more elements before the tail.\n+    /// Makes room for inserting more elements before the tail.\n     unsafe fn move_tail(&mut self, extra_capacity: usize) {\n         let vec = self.vec.as_mut();\n         let used_capacity = self.tail_start + self.tail_len;"}, {"sha": "f49e226a5cb68ed04b5064008cb102f41982ca5c", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -425,7 +425,7 @@ impl fmt::Display for CannotReallocInPlace {\n /// The `GlobalAlloc` trait is an `unsafe` trait for a number of reasons, and\n /// implementors must ensure that they adhere to these contracts:\n ///\n-/// * It's undefined behavior if global allocators unwind.  This restriction may\n+/// * It's undefined behavior if global allocators unwind. This restriction may\n ///   be lifted in the future, but currently a panic from any of these\n ///   functions may lead to memory unsafety.\n ///"}, {"sha": "01ab523a4c3f6ce8bd3c825d2b7c2e735034419b", "filename": "src/libcore/any.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -18,7 +18,7 @@\n //!\n //! Consider a situation where we want to log out a value passed to a function.\n //! We know the value we're working on implements Debug, but we don't know its\n-//! concrete type.  We want to give special treatment to certain types: in this\n+//! concrete type. We want to give special treatment to certain types: in this\n //! case printing out the length of String values prior to their value.\n //! We don't know the concrete type of our value at compile time, so we need to\n //! use runtime reflection instead.\n@@ -31,8 +31,8 @@\n //! fn log<T: Any + Debug>(value: &T) {\n //!     let value_any = value as &dyn Any;\n //!\n-//!     // try to convert our value to a String.  If successful, we want to\n-//!     // output the String's length as well as its value.  If not, it's a\n+//!     // Try to convert our value to a `String`. If successful, we want to\n+//!     // output the String`'s length as well as its value. If not, it's a\n //!     // different type: just print it out unadorned.\n //!     match value_any.downcast_ref::<String>() {\n //!         Some(as_string) => {"}, {"sha": "8383d305518ab39e7ea822ab67ef3715358c7213", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -130,7 +130,7 @@\n //!\n //! This is simply a special - but common - case of the previous: hiding mutability for operations\n //! that appear to be immutable. The `clone` method is expected to not change the source value, and\n-//! is declared to take `&self`, not `&mut self`. Therefore any mutation that happens in the\n+//! is declared to take `&self`, not `&mut self`. Therefore, any mutation that happens in the\n //! `clone` method must use cell types. For example, `Rc<T>` maintains its reference counts within a\n //! `Cell<T>`.\n //!\n@@ -1133,7 +1133,7 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     /// The `RefCell` is already immutably borrowed, so this cannot fail.\n     ///\n     /// This is an associated function that needs to be used as\n-    /// `Ref::clone(...)`.  A `Clone` implementation or a method would interfere\n+    /// `Ref::clone(...)`. A `Clone` implementation or a method would interfere\n     /// with the widespread use of `r.borrow().clone()` to clone the contents of\n     /// a `RefCell`.\n     #[stable(feature = \"cell_extras\", since = \"1.15.0\")]\n@@ -1145,7 +1145,7 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n         }\n     }\n \n-    /// Make a new `Ref` for a component of the borrowed data.\n+    /// Makes a new `Ref` for a component of the borrowed data.\n     ///\n     /// The `RefCell` is already immutably borrowed, so this cannot fail.\n     ///\n@@ -1174,7 +1174,7 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n         }\n     }\n \n-    /// Split a `Ref` into multiple `Ref`s for different components of the\n+    /// Splits a `Ref` into multiple `Ref`s for different components of the\n     /// borrowed data.\n     ///\n     /// The `RefCell` is already immutably borrowed, so this cannot fail.\n@@ -1217,13 +1217,13 @@ impl<T: ?Sized + fmt::Display> fmt::Display for Ref<'_, T> {\n }\n \n impl<'b, T: ?Sized> RefMut<'b, T> {\n-    /// Make a new `RefMut` for a component of the borrowed data, e.g., an enum\n+    /// Makes a new `RefMut` for a component of the borrowed data, e.g., an enum\n     /// variant.\n     ///\n     /// The `RefCell` is already mutably borrowed, so this cannot fail.\n     ///\n     /// This is an associated function that needs to be used as\n-    /// `RefMut::map(...)`.  A method would interfere with methods of the same\n+    /// `RefMut::map(...)`. A method would interfere with methods of the same\n     /// name on the contents of a `RefCell` used through `Deref`.\n     ///\n     /// # Examples\n@@ -1253,7 +1253,7 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n         }\n     }\n \n-    /// Split a `RefMut` into multiple `RefMut`s for different components of the\n+    /// Splits a `RefMut` into multiple `RefMut`s for different components of the\n     /// borrowed data.\n     ///\n     /// The underlying `RefCell` will remain mutably borrowed until both\n@@ -1416,7 +1416,7 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n /// co-exist with it. A `&mut T` must always be unique.\n ///\n /// Note that while mutating or mutably aliasing the contents of an `&UnsafeCell<T>` is\n-/// okay (provided you enforce the invariants some other way), it is still undefined behavior\n+/// ok (provided you enforce the invariants some other way), it is still undefined behavior\n /// to have multiple `&mut UnsafeCell<T>` aliases.\n ///\n /// # Examples"}, {"sha": "133c9169df858c050e3bf536cb8b988c82dfd030", "filename": "src/libcore/char/decode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fchar%2Fdecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fchar%2Fdecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fdecode.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -20,7 +20,7 @@ pub struct DecodeUtf16Error {\n     code: u16,\n }\n \n-/// Create an iterator over the UTF-16 encoded code points in `iter`,\n+/// Creates an iterator over the UTF-16 encoded code points in `iter`,\n /// returning unpaired surrogates as `Err`s.\n ///\n /// # Examples"}, {"sha": "72967b9adf7a05f726ec774c30f56d09db1c7459", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -524,7 +524,7 @@ impl char {\n         }\n     }\n \n-    /// Returns true if this `char` is an alphabetic code point, and false if not.\n+    /// Returns `true` if this `char` is an alphabetic code point, and false if not.\n     ///\n     /// # Examples\n     ///\n@@ -548,7 +548,7 @@ impl char {\n         }\n     }\n \n-    /// Returns true if this `char` satisfies the 'XID_Start' Unicode property, and false\n+    /// Returns `true` if this `char` satisfies the 'XID_Start' Unicode property, and false\n     /// otherwise.\n     ///\n     /// 'XID_Start' is a Unicode Derived Property specified in\n@@ -562,7 +562,7 @@ impl char {\n         derived_property::XID_Start(self)\n     }\n \n-    /// Returns true if this `char` satisfies the 'XID_Continue' Unicode property, and false\n+    /// Returns `true` if this `char` satisfies the 'XID_Continue' Unicode property, and false\n     /// otherwise.\n     ///\n     /// 'XID_Continue' is a Unicode Derived Property specified in\n@@ -576,7 +576,7 @@ impl char {\n         derived_property::XID_Continue(self)\n     }\n \n-    /// Returns true if this `char` is lowercase, and false otherwise.\n+    /// Returns `true` if this `char` is lowercase.\n     ///\n     /// 'Lowercase' is defined according to the terms of the Unicode Derived Core\n     /// Property `Lowercase`.\n@@ -604,7 +604,7 @@ impl char {\n         }\n     }\n \n-    /// Returns true if this `char` is uppercase, and false otherwise.\n+    /// Returns `true` if this `char` is uppercase.\n     ///\n     /// 'Uppercase' is defined according to the terms of the Unicode Derived Core\n     /// Property `Uppercase`.\n@@ -632,7 +632,7 @@ impl char {\n         }\n     }\n \n-    /// Returns true if this `char` is whitespace, and false otherwise.\n+    /// Returns `true` if this `char` is whitespace.\n     ///\n     /// 'Whitespace' is defined according to the terms of the Unicode Derived Core\n     /// Property `White_Space`.\n@@ -659,7 +659,7 @@ impl char {\n         }\n     }\n \n-    /// Returns true if this `char` is alphanumeric, and false otherwise.\n+    /// Returns `true` if this `char` is alphanumeric.\n     ///\n     /// 'Alphanumeric'-ness is defined in terms of the Unicode General Categories\n     /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n@@ -684,7 +684,7 @@ impl char {\n         self.is_alphabetic() || self.is_numeric()\n     }\n \n-    /// Returns true if this `char` is a control code point, and false otherwise.\n+    /// Returns `true` if this `char` is a control code point.\n     ///\n     /// 'Control code point' is defined in terms of the Unicode General\n     /// Category `Cc`.\n@@ -704,7 +704,7 @@ impl char {\n         general_category::Cc(self)\n     }\n \n-    /// Returns true if this `char` is an extended grapheme character, and false otherwise.\n+    /// Returns `true` if this `char` is an extended grapheme character.\n     ///\n     /// 'Extended grapheme character' is defined in terms of the Unicode Shaping and Rendering\n     /// Category `Grapheme_Extend`.\n@@ -713,7 +713,7 @@ impl char {\n         derived_property::Grapheme_Extend(self)\n     }\n \n-    /// Returns true if this `char` is numeric, and false otherwise.\n+    /// Returns `true` if this `char` is numeric.\n     ///\n     /// 'Numeric'-ness is defined in terms of the Unicode General Categories\n     /// 'Nd', 'Nl', 'No'."}, {"sha": "81fcdeee12d29e96614069f3b52e9ae79c2b8790", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -26,7 +26,7 @@ use self::Ordering::*;\n /// relations](http://en.wikipedia.org/wiki/Partial_equivalence_relation).\n ///\n /// This trait allows for partial equality, for types that do not have a full\n-/// equivalence relation.  For example, in floating point numbers `NaN != NaN`,\n+/// equivalence relation. For example, in floating point numbers `NaN != NaN`,\n /// so floating point types implement `PartialEq` but not `Eq`.\n ///\n /// Formally, the equality must be (for all `a`, `b` and `c`):"}, {"sha": "4a7c6e15a4df1bf947384c8304ffc2cc290feb54", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -220,7 +220,7 @@ pub trait AsMut<T: ?Sized> {\n ///\n /// There is one exception to implementing `Into`, and it's kind of esoteric.\n /// If the destination type is not part of the current crate, and it uses a\n-/// generic variable, then you can't implement `From` directly.  For example,\n+/// generic variable, then you can't implement `From` directly. For example,\n /// take this crate:\n ///\n /// ```compile_fail"}, {"sha": "5ad05b3824764f5ba3038c638357c988ce44a89b", "filename": "src/libcore/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -54,7 +54,7 @@\n ///\n /// ## How can I implement `Default`?\n ///\n-/// Provide an implementation for the `default()` method that returns the value of\n+/// Provides an implementation for the `default()` method that returns the value of\n /// your type that should be the default:\n ///\n /// ```"}, {"sha": "d88793f2801e72abdf5449d8f8cf19b5ae66fa2c", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -184,7 +184,7 @@ impl<'a> VaList<'a> {\n         va_arg(self)\n     }\n \n-    /// Copy the `va_list` at the current location.\n+    /// Copies the `va_list` at the current location.\n     #[unstable(feature = \"c_variadic\",\n                reason = \"the `c_variadic` feature has not been properly tested on \\\n                          all supported platforms\",\n@@ -213,7 +213,7 @@ extern \"rust-intrinsic\" {\n     /// `va_copy`.\n     fn va_end(ap: &mut VaList);\n \n-    /// Copy the current location of arglist `src` to the arglist `dst`.\n+    /// Copies the current location of arglist `src` to the arglist `dst`.\n     #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n                   not(target_arch = \"x86_64\")),\n               windows))]"}, {"sha": "2ce58c803b878ec2b153d063183b130fbe86b1e5", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -483,12 +483,12 @@ impl Display for Arguments<'_> {\n /// implementations, such as [`debug_struct`][debug_struct].\n ///\n /// `Debug` implementations using either `derive` or the debug builder API\n-/// on [`Formatter`] support pretty printing using the alternate flag: `{:#?}`.\n+/// on [`Formatter`] support pretty-printing using the alternate flag: `{:#?}`.\n ///\n /// [debug_struct]: ../../std/fmt/struct.Formatter.html#method.debug_struct\n /// [`Formatter`]: ../../std/fmt/struct.Formatter.html\n ///\n-/// Pretty printing with `#?`:\n+/// Pretty-printing with `#?`:\n ///\n /// ```\n /// #[derive(Debug)]"}, {"sha": "0f142347a95babd3f429f459b1c78893d0805579", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -60,7 +60,7 @@ pub trait Future {\n     /// progress, meaning that each time the current task is woken up, it should\n     /// actively re-`poll` pending futures that it still has an interest in.\n     ///\n-    /// The `poll` function is not called repeatedly in a tight loop-- instead,\n+    /// The `poll` function is not called repeatedly in a tight loop -- instead,\n     /// it should only be called when the future indicates that it is ready to\n     /// make progress (by calling `wake()`). If you're familiar with the\n     /// `poll(2)` or `select(2)` syscalls on Unix it's worth noting that futures"}, {"sha": "235c79307ab8dfa3b48844c165a55afdb288e063", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -10,7 +10,7 @@ use mem;\n /// An implementation of SipHash 1-3.\n ///\n /// This is currently the default hashing function used by standard library\n-/// (eg. `collections::HashMap` uses it by default).\n+/// (e.g., `collections::HashMap` uses it by default).\n ///\n /// See: <https://131002.net/siphash>\n #[unstable(feature = \"hashmap_internals\", issue = \"0\")]\n@@ -90,7 +90,7 @@ macro_rules! compress {\n     });\n }\n \n-/// Load an integer of the desired type from a byte stream, in LE order. Uses\n+/// Loads an integer of the desired type from a byte stream, in LE order. Uses\n /// `copy_nonoverlapping` to let the compiler generate the most efficient way\n /// to load it from a possibly unaligned address.\n ///\n@@ -107,7 +107,7 @@ macro_rules! load_int_le {\n     });\n }\n \n-/// Load an u64 using up to 7 bytes of a byte slice.\n+/// Loads an u64 using up to 7 bytes of a byte slice.\n ///\n /// Unsafe because: unchecked indexing at start..start+len\n #[inline]"}, {"sha": "89de5c1bc8af80d5c2652849fe760ca5247e19d0", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -34,7 +34,7 @@ use intrinsics;\n ///     use std::hint::unreachable_unchecked;\n ///\n ///     // `b.saturating_add(1)` is always positive (not zero),\n-///     // hence `checked_div` will never return None.\n+///     // hence `checked_div` will never return `None`.\n ///     // Therefore, the else branch is unreachable.\n ///     a.checked_div(b.saturating_add(1))\n ///         .unwrap_or_else(|| unsafe { unreachable_unchecked() })"}, {"sha": "f6de7566be914281686e5109f20760886c7abfd0", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,6 +1,6 @@\n-//! rustc compiler intrinsics.\n+//! Compiler intrinsics.\n //!\n-//! The corresponding definitions are in librustc_codegen_llvm/intrinsic.rs.\n+//! The corresponding definitions are in `librustc_codegen_llvm/intrinsic.rs`.\n //!\n //! # Volatiles\n //!\n@@ -315,35 +315,35 @@ extern \"rust-intrinsic\" {\n     /// [`AtomicBool::swap`](../../std/sync/atomic/struct.AtomicBool.html#method.swap).\n     pub fn atomic_xchg_relaxed<T>(dst: *mut T, src: T) -> T;\n \n-    /// Add to the current value, returning the previous value.\n+    /// Adds to the current value, returning the previous value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::SeqCst`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd<T>(dst: *mut T, src: T) -> T;\n-    /// Add to the current value, returning the previous value.\n+    /// Adds to the current value, returning the previous value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::Acquire`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_acq<T>(dst: *mut T, src: T) -> T;\n-    /// Add to the current value, returning the previous value.\n+    /// Adds to the current value, returning the previous value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::Release`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_rel<T>(dst: *mut T, src: T) -> T;\n-    /// Add to the current value, returning the previous value.\n+    /// Adds to the current value, returning the previous value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::AcqRel`](../../std/sync/atomic/enum.Ordering.html)\n     /// as the `order`. For example,\n     /// [`AtomicIsize::fetch_add`](../../std/sync/atomic/struct.AtomicIsize.html#method.fetch_add).\n     pub fn atomic_xadd_acqrel<T>(dst: *mut T, src: T) -> T;\n-    /// Add to the current value, returning the previous value.\n+    /// Adds to the current value, returning the previous value.\n     /// The stabilized version of this intrinsic is available on the\n     /// `std::sync::atomic` types via the `fetch_add` method by passing\n     /// [`Ordering::Relaxed`](../../std/sync/atomic/enum.Ordering.html)\n@@ -556,31 +556,31 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_umax_relaxed<T>(dst: *mut T, src: T) -> T;\n \n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a noop.\n+    /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n     /// The `locality` argument must be a constant integer and is a temporal locality specifier\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n     pub fn prefetch_read_data<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a noop.\n+    /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n     /// The `locality` argument must be a constant integer and is a temporal locality specifier\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n     pub fn prefetch_write_data<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a noop.\n+    /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n     /// The `locality` argument must be a constant integer and is a temporal locality specifier\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache\n     pub fn prefetch_read_instruction<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n-    /// if supported; otherwise, it is a noop.\n+    /// if supported; otherwise, it is a no-op.\n     /// Prefetches have no effect on the behavior of the program but can change its performance\n     /// characteristics.\n     ///\n@@ -697,7 +697,7 @@ extern \"rust-intrinsic\" {\n     /// Creates a value initialized to zero.\n     ///\n     /// `init` is unsafe because it returns a zeroed-out datum,\n-    /// which is unsafe unless T is `Copy`.  Also, even if T is\n+    /// which is unsafe unless `T` is `Copy`. Also, even if T is\n     /// `Copy`, an all-zero value may not correspond to any legitimate\n     /// state for the type in question.\n     pub fn init<T>() -> T;\n@@ -857,7 +857,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// // The no-copy, unsafe way, still using transmute, but not UB.\n     /// // This is equivalent to the original, but safer, and reuses the\n-    /// // same Vec internals. Therefore the new inner type must have the\n+    /// // same `Vec` internals. Therefore, the new inner type must have the\n     /// // exact same size, and the same alignment, as the old type.\n     /// // The same caveats exist for this method as transmute, for\n     /// // the original inner type (`&i32`) to the converted inner type\n@@ -875,8 +875,8 @@ extern \"rust-intrinsic\" {\n     /// ```\n     /// use std::{slice, mem};\n     ///\n-    /// // There are multiple ways to do this; and there are multiple problems\n-    /// // with the following, transmute, way.\n+    /// // There are multiple ways to do this, and there are multiple problems\n+    /// // with the following (transmute) way.\n     /// fn split_at_mut_transmute<T>(slice: &mut [T], mid: usize)\n     ///                              -> (&mut [T], &mut [T]) {\n     ///     let len = slice.len();\n@@ -988,7 +988,7 @@ extern \"rust-intrinsic\" {\n     ///   beginning at `dst` with the same size.\n     ///\n     /// Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n-    /// whether `T` is [`Copy`].  If `T` is not [`Copy`], using *both* the values\n+    /// whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n     /// in the region beginning at `*src` and the region beginning at `*dst` can\n     /// [violate memory safety][read-ownership].\n     ///\n@@ -1055,7 +1055,7 @@ extern \"rust-intrinsic\" {\n     /// [`copy_nonoverlapping`] can be used instead.\n     ///\n     /// `copy` is semantically equivalent to C's [`memmove`], but with the argument\n-    /// order swapped.  Copying takes place as if the bytes were copied from `src`\n+    /// order swapped. Copying takes place as if the bytes were copied from `src`\n     /// to a temporary array and then copied from the array to `dst`.\n     ///\n     /// [`copy_nonoverlapping`]: ./fn.copy_nonoverlapping.html\n@@ -1072,7 +1072,7 @@ extern \"rust-intrinsic\" {\n     /// * Both `src` and `dst` must be properly aligned.\n     ///\n     /// Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n-    /// whether `T` is [`Copy`].  If `T` is not [`Copy`], using both the values\n+    /// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the values\n     /// in the region beginning at `*src` and the region beginning at `*dst` can\n     /// [violate memory safety][read-ownership].\n     ///\n@@ -1200,19 +1200,19 @@ extern \"rust-intrinsic\" {\n     /// unless size is equal to zero.\n     pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: usize);\n \n-    /// Perform a volatile load from the `src` pointer.\n+    /// Performs a volatile load from the `src` pointer.\n     /// The stabilized version of this intrinsic is\n     /// [`std::ptr::read_volatile`](../../std/ptr/fn.read_volatile.html).\n     pub fn volatile_load<T>(src: *const T) -> T;\n-    /// Perform a volatile store to the `dst` pointer.\n+    /// Performs a volatile store to the `dst` pointer.\n     /// The stabilized version of this intrinsic is\n     /// [`std::ptr::write_volatile`](../../std/ptr/fn.write_volatile.html).\n     pub fn volatile_store<T>(dst: *mut T, val: T);\n \n-    /// Perform a volatile load from the `src` pointer\n+    /// Performs a volatile load from the `src` pointer\n     /// The pointer is not required to be aligned.\n     pub fn unaligned_volatile_load<T>(src: *const T) -> T;\n-    /// Perform a volatile store to the `dst` pointer.\n+    /// Performs a volatile store to the `dst` pointer.\n     /// The pointer is not required to be aligned.\n     pub fn unaligned_volatile_store<T>(dst: *mut T, val: T);\n "}, {"sha": "a3e9cfa94931297cfbfc32aab5fb55e81ddf2990", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -20,19 +20,19 @@ pub trait Step: Clone + PartialOrd + Sized {\n     /// without overflow.\n     fn steps_between(start: &Self, end: &Self) -> Option<usize>;\n \n-    /// Replaces this step with `1`, returning itself\n+    /// Replaces this step with `1`, returning itself.\n     fn replace_one(&mut self) -> Self;\n \n-    /// Replaces this step with `0`, returning itself\n+    /// Replaces this step with `0`, returning itself.\n     fn replace_zero(&mut self) -> Self;\n \n-    /// Adds one to this step, returning the result\n+    /// Adds one to this step, returning the result.\n     fn add_one(&self) -> Self;\n \n-    /// Subtracts one to this step, returning the result\n+    /// Subtracts one to this step, returning the result.\n     fn sub_one(&self) -> Self;\n \n-    /// Add an usize, returning None on overflow\n+    /// Adds a `usize`, returning `None` on overflow.\n     fn add_usize(&self, n: usize) -> Option<Self>;\n }\n "}, {"sha": "d6eab40213edb0fe9902fb95838ca294a99c82e9", "filename": "src/libcore/iter/traits/exact_size.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -104,7 +104,7 @@ pub trait ExactSizeIterator: Iterator {\n         lower\n     }\n \n-    /// Returns whether the iterator is empty.\n+    /// Returns `true` if the iterator is empty.\n     ///\n     /// This method has a default implementation using `self.len()`, so you\n     /// don't need to implement it yourself."}, {"sha": "861e9c3157a790d51da98e72c698566f2b5b1391", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -120,7 +120,7 @@ pub trait Iterator {\n     /// // ... and then None once it's over.\n     /// assert_eq!(None, iter.next());\n     ///\n-    /// // More calls may or may not return None. Here, they always will.\n+    /// // More calls may or may not return `None`. Here, they always will.\n     /// assert_eq!(None, iter.next());\n     /// assert_eq!(None, iter.next());\n     /// ```\n@@ -564,9 +564,9 @@ pub trait Iterator {\n     /// Calls a closure on each element of an iterator.\n     ///\n     /// This is equivalent to using a [`for`] loop on the iterator, although\n-    /// `break` and `continue` are not possible from a closure.  It's generally\n+    /// `break` and `continue` are not possible from a closure. It's generally\n     /// more idiomatic to use a `for` loop, but `for_each` may be more legible\n-    /// when processing items at the end of longer iterator chains.  In some\n+    /// when processing items at the end of longer iterator chains. In some\n     /// cases `for_each` may also be faster than a loop, because it will use\n     /// internal iteration on adaptors like `Chain`.\n     ///\n@@ -1215,7 +1215,7 @@ pub trait Iterator {\n     /// assert_eq!(iter.next(), Some(4));\n     /// assert_eq!(iter.next(), None);\n     ///\n-    /// // it will always return None after the first time.\n+    /// // it will always return `None` after the first time.\n     /// assert_eq!(iter.next(), None);\n     /// assert_eq!(iter.next(), None);\n     /// assert_eq!(iter.next(), None);\n@@ -1515,7 +1515,7 @@ pub trait Iterator {\n     /// is propagated back to the caller immediately (short-circuiting).\n     ///\n     /// The initial value is the value the accumulator will have on the first\n-    /// call.  If applying the closure succeeded against every element of the\n+    /// call. If applying the closure succeeded against every element of the\n     /// iterator, `try_fold()` returns the final accumulator as success.\n     ///\n     /// Folding is useful whenever you have a collection of something, and want\n@@ -1528,10 +1528,10 @@ pub trait Iterator {\n     /// do something better than the default `for` loop implementation.\n     ///\n     /// In particular, try to have this call `try_fold()` on the internal parts\n-    /// from which this iterator is composed.  If multiple calls are needed,\n+    /// from which this iterator is composed. If multiple calls are needed,\n     /// the `?` operator may be convenient for chaining the accumulator value\n     /// along, but beware any invariants that need to be upheld before those\n-    /// early returns.  This is a `&mut self` method, so iteration needs to be\n+    /// early returns. This is a `&mut self` method, so iteration needs to be\n     /// resumable after hitting an error here.\n     ///\n     /// # Examples"}, {"sha": "2eb506cedd4f83a02e951d1e9ad93f783bb4fe78", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,4 +1,4 @@\n-/// Entry point of thread panic, for details, see std::macros\n+/// Entry point of thread panic. For details, see `std::macros`.\n #[macro_export]\n #[cfg_attr(not(stage0), allow_internal_unstable(core_panic, __rust_unstable_column))]\n #[cfg_attr(stage0, allow_internal_unstable)]\n@@ -434,7 +434,7 @@ macro_rules! writeln {\n /// * Iterators that dynamically terminate.\n ///\n /// If the determination that the code is unreachable proves incorrect, the\n-/// program immediately terminates with a [`panic!`].  The function [`unreachable_unchecked`],\n+/// program immediately terminates with a [`panic!`]. The function [`unreachable_unchecked`],\n /// which belongs to the [`std::hint`] module, informs the compiler to\n /// optimize the code out of the release version entirely.\n ///\n@@ -495,7 +495,7 @@ macro_rules! unreachable {\n /// A standardized placeholder for marking unfinished code.\n ///\n /// This can be useful if you are prototyping and are just looking to have your\n-/// code typecheck, or if you're implementing a trait that requires multiple\n+/// code type-check, or if you're implementing a trait that requires multiple\n /// methods, and you're only planning on using one of them.\n ///\n /// # Panics"}, {"sha": "2a493e88fe89617ccdb0121fb42befc58e5848a5", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -295,7 +295,7 @@ pub const fn size_of<T>() -> usize {\n /// Returns the size of the pointed-to value in bytes.\n ///\n /// This is usually the same as `size_of::<T>()`. However, when `T` *has* no\n-/// statically known size, e.g., a slice [`[T]`][slice] or a [trait object],\n+/// statically-known size, e.g., a slice [`[T]`][slice] or a [trait object],\n /// then `size_of_val` can be used to get the dynamically-known size.\n ///\n /// [slice]: ../../std/primitive.slice.html\n@@ -403,7 +403,7 @@ pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n     unsafe { intrinsics::min_align_of_val(val) }\n }\n \n-/// Returns whether dropping values of type `T` matters.\n+/// Returns `true` if dropping values of type `T` matters.\n ///\n /// This is purely an optimization hint, and may be implemented conservatively:\n /// it may return `true` for types that don't actually need to be dropped.\n@@ -958,7 +958,7 @@ impl<T> ManuallyDrop<T> {\n         ManuallyDrop { value }\n     }\n \n-    /// Extract the value from the `ManuallyDrop` container.\n+    /// Extracts the value from the `ManuallyDrop` container.\n     ///\n     /// This allows the value to be dropped again.\n     ///\n@@ -1038,26 +1038,29 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// A newtype to construct uninitialized instances of `T`.\n ///\n /// The compiler, in general, assumes that variables are properly initialized\n-/// at their respective type.  For example, a variable of reference type must\n-/// be aligned and non-NULL.  This is an invariant that must *always* be upheld,\n-/// even in unsafe code.  As a consequence, 0-initializing a variable of reference\n+/// at their respective type. For example, a variable of reference type must\n+/// be aligned and non-NULL. This is an invariant that must *always* be upheld,\n+/// even in unsafe code. As a consequence, zero-initializing a variable of reference\n /// type causes instantaneous undefined behavior, no matter whether that reference\n /// ever gets used to access memory:\n+///\n /// ```rust,no_run\n /// use std::mem;\n ///\n /// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n /// ```\n+///\n /// This is exploited by the compiler for various optimizations, such as eliding\n /// run-time checks and optimizing `enum` layout.\n ///\n-/// Not initializing memory at all (instead of 0-initializing it) causes the same\n+/// Not initializing memory at all (instead of zero--initializing it) causes the same\n /// issue: after all, the initial value of the variable might just happen to be\n /// one that violates the invariant.\n ///\n /// `MaybeUninit` serves to enable unsafe code to deal with uninitialized data:\n /// it is a signal to the compiler indicating that the data here might *not*\n /// be initialized:\n+///\n /// ```rust\n /// #![feature(maybe_uninit)]\n /// use std::mem::MaybeUninit;\n@@ -1070,6 +1073,7 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// // initializing `x`!\n /// let x = unsafe { x.into_initialized() };\n /// ```\n+///\n /// The compiler then knows to not optimize this code.\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n@@ -1090,7 +1094,7 @@ impl<T> MaybeUninit<T> {\n         MaybeUninit { value: ManuallyDrop::new(val) }\n     }\n \n-    /// Create a new `MaybeUninit` in an uninitialized state.\n+    /// Creates a new `MaybeUninit` in an uninitialized state.\n     ///\n     /// Note that dropping a `MaybeUninit` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n@@ -1100,8 +1104,8 @@ impl<T> MaybeUninit<T> {\n         MaybeUninit { uninit: () }\n     }\n \n-    /// Create a new `MaybeUninit` in an uninitialized state, with the memory being\n-    /// filled with `0` bytes.  It depends on `T` whether that already makes for\n+    /// Creates a new `MaybeUninit` in an uninitialized state, with the memory being\n+    /// filled with `0` bytes. It depends on `T` whether that already makes for\n     /// proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n     /// but `MaybeUninit<&'static i32>::zeroed()` is not because references must not\n     /// be null.\n@@ -1118,9 +1122,9 @@ impl<T> MaybeUninit<T> {\n         u\n     }\n \n-    /// Set the value of the `MaybeUninit`. This overwrites any previous value without dropping it.\n-    /// For your convenience, this also returns a mutable reference to the (now\n-    /// safely initialized) content of `self`.\n+    /// Sets the value of the `MaybeUninit`. This overwrites any previous value without dropping it.\n+    /// For your convenience, this also returns a mutable reference to the (now safely initialized)\n+    /// contents of `self`.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn set(&mut self, val: T) -> &mut T {\n@@ -1130,7 +1134,7 @@ impl<T> MaybeUninit<T> {\n         }\n     }\n \n-    /// Extract the value from the `MaybeUninit` container.  This is a great way\n+    /// Extracts the value from the `MaybeUninit` container. This is a great way\n     /// to ensure that the data will get dropped, because the resulting `T` is\n     /// subject to the usual drop handling.\n     ///\n@@ -1145,15 +1149,15 @@ impl<T> MaybeUninit<T> {\n         ManuallyDrop::into_inner(self.value)\n     }\n \n-    /// Deprecated alternative to `into_initialized`.  Will never get stabilized.\n+    /// Deprecated alternative to `into_initialized`. Will never get stabilized.\n     /// Exists only to transition stdsimd to `into_initialized`.\n     #[inline(always)]\n     #[allow(unused)]\n     pub(crate) unsafe fn into_inner(self) -> T {\n         self.into_initialized()\n     }\n \n-    /// Get a reference to the contained value.\n+    /// Gets a reference to the contained value.\n     ///\n     /// # Unsafety\n     ///\n@@ -1165,7 +1169,7 @@ impl<T> MaybeUninit<T> {\n         &*self.value\n     }\n \n-    /// Get a mutable reference to the contained value.\n+    /// Gets a mutable reference to the contained value.\n     ///\n     /// # Unsafety\n     ///\n@@ -1180,30 +1184,30 @@ impl<T> MaybeUninit<T> {\n         &mut *self.value\n     }\n \n-    /// Get a pointer to the contained value. Reading from this pointer or turning it\n+    /// Gets a pointer to the contained value. Reading from this pointer or turning it\n     /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn as_ptr(&self) -> *const T {\n         unsafe { &*self.value as *const T }\n     }\n \n-    /// Get a mutable pointer to the contained value. Reading from this pointer or turning it\n+    /// Get sa mutable pointer to the contained value. Reading from this pointer or turning it\n     /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn as_mut_ptr(&mut self) -> *mut T {\n         unsafe { &mut *self.value as *mut T }\n     }\n \n-    /// Get a pointer to the first element of the array.\n+    /// Gets a pointer to the first element of the array.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn first_ptr(this: &[MaybeUninit<T>]) -> *const T {\n         this as *const [MaybeUninit<T>] as *const T\n     }\n \n-    /// Get a mutable pointer to the first element of the array.\n+    /// Gets a mutable pointer to the first element of the array.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn first_ptr_mut(this: &mut [MaybeUninit<T>]) -> *mut T {"}, {"sha": "3b57bb7544b35bb3b8b18d4422f01527ab7da3c3", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -61,7 +61,7 @@ mod fpu_precision {\n         unsafe { asm!(\"fldcw $0\" :: \"m\" (cw) :: \"volatile\") }\n     }\n \n-    /// Set the precision field of the FPU to `T` and return a `FPUControlWord`\n+    /// Sets the precision field of the FPU to `T` and returns a `FPUControlWord`.\n     pub fn set_precision<T>() -> FPUControlWord {\n         let cw = 0u16;\n "}, {"sha": "47ea5aa5ff000b8c8b1b08f8656375112e4b0802", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -37,7 +37,7 @@\n //!\n //! In addition, there are numerous helper functions that are used in the paper but not available\n //! in Rust (or at least in core). Our version is additionally complicated by the need to handle\n-//! overflow and underflow and the desire to handle subnormal numbers.  Bellerophon and\n+//! overflow and underflow and the desire to handle subnormal numbers. Bellerophon and\n //! Algorithm R have trouble with overflow, subnormals, and underflow. We conservatively switch to\n //! Algorithm M (with the modifications described in section 8 of the paper) well before the\n //! inputs get into the critical region.\n@@ -54,7 +54,7 @@\n //! operations as well, if you want 0.5 ULP accuracy you need to do *everything* in full precision\n //! and round *exactly once, at the end*, by considering all truncated bits at once.\n //!\n-//! FIXME Although some code duplication is necessary, perhaps parts of the code could be shuffled\n+//! FIXME: Although some code duplication is necessary, perhaps parts of the code could be shuffled\n //! around such that less code is duplicated. Large parts of the algorithms are independent of the\n //! float type to output, or only needs access to a few constants, which could be passed in as\n //! parameters.\n@@ -148,7 +148,7 @@ macro_rules! from_str_float_impl {\n             /// # Return value\n             ///\n             /// `Err(ParseFloatError)` if the string did not represent a valid\n-            /// number.  Otherwise, `Ok(n)` where `n` is the floating-point\n+            /// number. Otherwise, `Ok(n)` where `n` is the floating-point\n             /// number represented by `src`.\n             #[inline]\n             fn from_str(src: &str) -> Result<Self, ParseFloatError> {\n@@ -209,7 +209,7 @@ fn pfe_invalid() -> ParseFloatError {\n     ParseFloatError { kind: FloatErrorKind::Invalid }\n }\n \n-/// Split decimal string into sign and the rest, without inspecting or validating the rest.\n+/// Splits a decimal string into sign and the rest, without inspecting or validating the rest.\n fn extract_sign(s: &str) -> (Sign, &str) {\n     match s.as_bytes()[0] {\n         b'+' => (Sign::Positive, &s[1..]),\n@@ -219,7 +219,7 @@ fn extract_sign(s: &str) -> (Sign, &str) {\n     }\n }\n \n-/// Convert a decimal string into a floating point number.\n+/// Converts a decimal string into a floating point number.\n fn dec2flt<T: RawFloat>(s: &str) -> Result<T, ParseFloatError> {\n     if s.is_empty() {\n         return Err(pfe_empty())"}, {"sha": "126713185711b3fecd0a4046e8e8bf4c0bee8ccc", "filename": "src/libcore/num/dec2flt/num.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -27,7 +27,7 @@ pub fn compare_with_half_ulp(f: &Big, ones_place: usize) -> Ordering {\n     Equal\n }\n \n-/// Convert an ASCII string containing only decimal digits to a `u64`.\n+/// Converts an ASCII string containing only decimal digits to a `u64`.\n ///\n /// Does not perform checks for overflow or invalid characters, so if the caller is not careful,\n /// the result is bogus and can panic (though it won't be `unsafe`). Additionally, empty strings\n@@ -44,7 +44,7 @@ pub fn from_str_unchecked<'a, T>(bytes: T) -> u64 where T : IntoIterator<Item=&'\n     result\n }\n \n-/// Convert a string of ASCII digits into a bignum.\n+/// Converts a string of ASCII digits into a bignum.\n ///\n /// Like `from_str_unchecked`, this function relies on the parser to weed out non-digits.\n pub fn digits_to_big(integral: &[u8], fractional: &[u8]) -> Big {\n@@ -69,7 +69,7 @@ pub fn to_u64(x: &Big) -> u64 {\n }\n \n \n-/// Extract a range of bits.\n+/// Extracts a range of bits.\n \n /// Index 0 is the least significant bit and the range is half-open as usual.\n /// Panics if asked to extract more bits than fit into the return type."}, {"sha": "933f8c1d3f781e959c7dbe309a92fbc9ca784bb6", "filename": "src/libcore/num/dec2flt/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -42,7 +42,7 @@ pub enum ParseResult<'a> {\n     Invalid,\n }\n \n-/// Check if the input string is a valid floating point number and if so, locate the integral\n+/// Checks if the input string is a valid floating point number and if so, locate the integral\n /// part, the fractional part, and the exponent in it. Does not handle signs.\n pub fn parse_decimal(s: &str) -> ParseResult {\n     if s.is_empty() {"}, {"sha": "b65f539b29c97c105df01ada310443a104a0eb9f", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -59,10 +59,10 @@ pub trait RawFloat\n     /// Type used by `to_bits` and `from_bits`.\n     type Bits: Add<Output = Self::Bits> + From<u8> + TryFrom<u64>;\n \n-    /// Raw transmutation to integer.\n+    /// Performs a raw transmutation to an integer.\n     fn to_bits(self) -> Self::Bits;\n \n-    /// Raw transmutation from integer.\n+    /// Performs a raw transmutation from an integer.\n     fn from_bits(v: Self::Bits) -> Self;\n \n     /// Returns the category that this number falls into.\n@@ -71,14 +71,14 @@ pub trait RawFloat\n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8);\n \n-    /// Decode the float.\n+    /// Decodes the float.\n     fn unpack(self) -> Unpacked;\n \n-    /// Cast from a small integer that can be represented exactly.  Panic if the integer can't be\n+    /// Casts from a small integer that can be represented exactly. Panic if the integer can't be\n     /// represented, the other code in this module makes sure to never let that happen.\n     fn from_int(x: u64) -> Self;\n \n-    /// Get the value 10<sup>e</sup> from a pre-computed table.\n+    /// Gets the value 10<sup>e</sup> from a pre-computed table.\n     /// Panics for `e >= CEIL_LOG5_OF_MAX_SIG`.\n     fn short_fast_pow10(e: usize) -> Self;\n \n@@ -240,7 +240,7 @@ impl RawFloat for f64 {\n     fn from_bits(v: Self::Bits) -> Self { Self::from_bits(v) }\n }\n \n-/// Convert an Fp to the closest machine float type.\n+/// Converts an `Fp` to the closest machine float type.\n /// Does not handle subnormal results.\n pub fn fp_to_float<T: RawFloat>(x: Fp) -> T {\n     let x = x.normalize();\n@@ -319,7 +319,7 @@ pub fn big_to_fp(f: &Big) -> Fp {\n     }\n }\n \n-/// Find the largest floating point number strictly smaller than the argument.\n+/// Finds the largest floating point number strictly smaller than the argument.\n /// Does not handle subnormals, zero, or exponent underflow.\n pub fn prev_float<T: RawFloat>(x: T) -> T {\n     match x.classify() {"}, {"sha": "dc0580764acb74838221593997cb5a194337c153", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -144,7 +144,7 @@ pub mod consts {\n #[lang = \"f32\"]\n #[cfg(not(test))]\n impl f32 {\n-    /// Returns `true` if this value is `NaN` and false otherwise.\n+    /// Returns `true` if this value is `NaN`.\n     ///\n     /// ```\n     /// use std::f32;\n@@ -169,8 +169,8 @@ impl f32 {\n         f32::from_bits(self.to_bits() & 0x7fff_ffff)\n     }\n \n-    /// Returns `true` if this value is positive infinity or negative infinity and\n-    /// false otherwise.\n+    /// Returns `true` if this value is positive infinity or negative infinity, and\n+    /// `false` otherwise.\n     ///\n     /// ```\n     /// use std::f32;\n@@ -272,7 +272,7 @@ impl f32 {\n         }\n     }\n \n-    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n+    /// Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n     /// positive sign bit and positive infinity.\n     ///\n     /// ```\n@@ -288,7 +288,7 @@ impl f32 {\n         !self.is_sign_negative()\n     }\n \n-    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n+    /// Returns `true` if `self` has a negative sign, including `-0.0`, `NaN`s with\n     /// negative sign bit and negative infinity.\n     ///\n     /// ```"}, {"sha": "c3677f8c8faea466532e864c1d68110fff0ffc3c", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -144,7 +144,7 @@ pub mod consts {\n #[lang = \"f64\"]\n #[cfg(not(test))]\n impl f64 {\n-    /// Returns `true` if this value is `NaN` and false otherwise.\n+    /// Returns `true` if this value is `NaN`.\n     ///\n     /// ```\n     /// use std::f64;\n@@ -169,8 +169,8 @@ impl f64 {\n         f64::from_bits(self.to_bits() & 0x7fff_ffff_ffff_ffff)\n     }\n \n-    /// Returns `true` if this value is positive infinity or negative infinity and\n-    /// false otherwise.\n+    /// Returns `true` if this value is positive infinity or negative infinity, and\n+    /// `false` otherwise.\n     ///\n     /// ```\n     /// use std::f64;\n@@ -272,7 +272,7 @@ impl f64 {\n         }\n     }\n \n-    /// Returns `true` if and only if `self` has a positive sign, including `+0.0`, `NaN`s with\n+    /// Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n     /// positive sign bit and positive infinity.\n     ///\n     /// ```\n@@ -296,7 +296,7 @@ impl f64 {\n         self.is_sign_positive()\n     }\n \n-    /// Returns `true` if and only if `self` has a negative sign, including `-0.0`, `NaN`s with\n+    /// Returns `true` if `self` has a negative sign, including `-0.0`, `NaN`s with\n     /// negative sign bit and negative infinity.\n     ///\n     /// ```"}, {"sha": "6fb67ea9c9acbf7536caccc37ca7282618b8ddd5", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -52,7 +52,7 @@ assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", s\n             }\n \n             impl $Ty {\n-                /// Create a non-zero without checking the value.\n+                /// Creates a non-zero without checking the value.\n                 ///\n                 /// # Safety\n                 ///\n@@ -63,7 +63,7 @@ assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", s\n                     $Ty(n)\n                 }\n \n-                /// Create a non-zero if the given value is not zero.\n+                /// Creates a non-zero if the given value is not zero.\n                 #[$stability]\n                 #[inline]\n                 pub fn new(n: $Int) -> Option<Self> {"}, {"sha": "0252edee231254a0afe3e0786e3701cd5cfb5669", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -49,7 +49,7 @@\n /// }\n ///\n /// // Notice that the implementation uses the associated type `Output`.\n-/// impl<T: Add<Output=T>> Add for Point<T> {\n+/// impl<T: Add<Output = T>> Add for Point<T> {\n ///     type Output = Point<T>;\n ///\n ///     fn add(self, other: Point<T>) -> Point<T> {\n@@ -157,7 +157,7 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// }\n ///\n /// // Notice that the implementation uses the associated type `Output`.\n-/// impl<T: Sub<Output=T>> Sub for Point<T> {\n+/// impl<T: Sub<Output = T>> Sub for Point<T> {\n ///     type Output = Point<T>;\n ///\n ///     fn sub(self, other: Point<T>) -> Point<T> {\n@@ -518,7 +518,7 @@ pub trait Rem<RHS=Self> {\n \n macro_rules! rem_impl_integer {\n     ($($t:ty)*) => ($(\n-        /// This operation satisfies `n % d == n - (n / d) * d`.  The\n+        /// This operation satisfies `n % d == n - (n / d) * d`. The\n         /// result has the same sign as the left operand.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Rem for $t {"}, {"sha": "b3dd5d20299c1706ec50582ca7f1cf8180b64d86", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -52,7 +52,7 @@ impl fmt::Debug for RangeFull {\n /// (`start..end`).\n ///\n /// The `Range` `start..end` contains all values with `x >= start` and\n-/// `x < end`.  It is empty unless `start < end`.\n+/// `x < end`. It is empty unless `start < end`.\n ///\n /// # Examples\n ///\n@@ -297,7 +297,7 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// A range bounded inclusively below and above (`start..=end`).\n ///\n /// The `RangeInclusive` `start..=end` contains all values with `x >= start`\n-/// and `x <= end`.  It is empty unless `start <= end`.\n+/// and `x <= end`. It is empty unless `start <= end`.\n ///\n /// This iterator is [fused], but the specific values of `start` and `end` after\n /// iteration has finished are **unspecified** other than that [`.is_empty()`]"}, {"sha": "9fa2c81954ee16a8ffc4a31bf6cd4f94f525f15f", "filename": "src/libcore/ops/try.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,7 +1,7 @@\n /// A trait for customizing the behavior of the `?` operator.\n ///\n /// A type implementing `Try` is one that has a canonical way to view it\n-/// in terms of a success/failure dichotomy.  This trait allows both\n+/// in terms of a success/failure dichotomy. This trait allows both\n /// extracting those success or failure values from an existing instance and\n /// creating a new instance from a success or failure value.\n #[unstable(feature = \"try_trait\", issue = \"42327\")]"}, {"sha": "76ef36ac30962d19dfef4a5792f742b03ee0bbb5", "filename": "src/libcore/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -214,7 +214,7 @@ impl<T> Option<T> {\n     ///\n     /// # Examples\n     ///\n-    /// Convert an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, preserving the original.\n+    /// Converts an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, preserving the original.\n     /// The [`map`] method takes the `self` argument by value, consuming the original,\n     /// so this technique uses `as_ref` to first take an `Option` to a reference\n     /// to the value inside the original.\n@@ -395,7 +395,7 @@ impl<T> Option<T> {\n     ///\n     /// # Examples\n     ///\n-    /// Convert an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, consuming the original:\n+    /// Converts an `Option<`[`String`]`>` into an `Option<`[`usize`]`>`, consuming the original:\n     ///\n     /// [`String`]: ../../std/string/struct.String.html\n     /// [`usize`]: ../../std/primitive.usize.html\n@@ -963,7 +963,7 @@ impl<T: Default> Option<T> {\n     ///\n     /// # Examples\n     ///\n-    /// Convert a string to an integer, turning poorly-formed strings\n+    /// Converts a string to an integer, turning poorly-formed strings\n     /// into 0 (the default value for integers). [`parse`] converts\n     /// a string to any other type that implements [`FromStr`], returning\n     /// [`None`] on error."}, {"sha": "ee9098d73ee92ff8ad2933dbfd7ea0a5c91e9602", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -199,7 +199,7 @@ impl<P: Deref> Pin<P> {\n         Pin { pointer }\n     }\n \n-    /// Get a pinned shared reference from this pinned pointer.\n+    /// Gets a pinned shared reference from this pinned pointer.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn as_ref(self: &Pin<P>) -> Pin<&P::Target> {\n@@ -208,7 +208,7 @@ impl<P: Deref> Pin<P> {\n }\n \n impl<P: DerefMut> Pin<P> {\n-    /// Get a pinned mutable reference from this pinned pointer.\n+    /// Gets a pinned mutable reference from this pinned pointer.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn as_mut(self: &mut Pin<P>) -> Pin<&mut P::Target> {\n@@ -247,7 +247,7 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n         Pin::new_unchecked(new_pointer)\n     }\n \n-    /// Get a shared reference out of a pin.\n+    /// Gets a shared reference out of a pin.\n     ///\n     /// Note: `Pin` also implements `Deref` to the target, which can be used\n     /// to access the inner value. However, `Deref` only provides a reference\n@@ -262,14 +262,14 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n }\n \n impl<'a, T: ?Sized> Pin<&'a mut T> {\n-    /// Convert this `Pin<&mut T>` into a `Pin<&T>` with the same lifetime.\n+    /// Converts this `Pin<&mut T>` into a `Pin<&T>` with the same lifetime.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n     pub fn into_ref(self: Pin<&'a mut T>) -> Pin<&'a T> {\n         Pin { pointer: self.pointer }\n     }\n \n-    /// Get a mutable reference to the data inside of this `Pin`.\n+    /// Gets a mutable reference to the data inside of this `Pin`.\n     ///\n     /// This requires that the data inside this `Pin` is `Unpin`.\n     ///\n@@ -286,7 +286,7 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n         self.pointer\n     }\n \n-    /// Get a mutable reference to the data inside of this `Pin`.\n+    /// Gets a mutable reference to the data inside of this `Pin`.\n     ///\n     /// # Safety\n     ///"}, {"sha": "866c8d0896b3c637a714d13dd8f4106b115ae98b", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -12,7 +12,7 @@\n //! to access only a single value, in which case the documentation omits the size\n //! and implicitly assumes it to be `size_of::<T>()` bytes.\n //!\n-//! The precise rules for validity are not determined yet.  The guarantees that are\n+//! The precise rules for validity are not determined yet. The guarantees that are\n //! provided at this point are very minimal:\n //!\n //! * A [null] pointer is *never* valid, not even for accesses of [size zero][zst].\n@@ -104,7 +104,7 @@ pub use intrinsics::write_bytes;\n ///\n /// * `to_drop` must be [valid] for reads.\n ///\n-/// * `to_drop` must be properly aligned.  See the example below for how to drop\n+/// * `to_drop` must be properly aligned. See the example below for how to drop\n ///   an unaligned pointer.\n ///\n /// Additionally, if `T` is not [`Copy`], using the pointed-to value after\n@@ -135,7 +135,7 @@ pub use intrinsics::write_bytes;\n /// unsafe {\n ///     // Get a raw pointer to the last element in `v`.\n ///     let ptr = &mut v[1] as *mut _;\n-///     // Shorten `v` to prevent the last item from being dropped.  We do that first,\n+///     // Shorten `v` to prevent the last item from being dropped. We do that first,\n ///     // to prevent issues if the `drop_in_place` below panics.\n ///     v.set_len(1);\n ///     // Without a call `drop_in_place`, the last item would never be dropped,\n@@ -531,7 +531,7 @@ pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n ///\n /// `read` creates a bitwise copy of `T`, regardless of whether `T` is [`Copy`].\n /// If `T` is not [`Copy`], using both the returned value and the value at\n-/// `*src` can violate memory safety.  Note that assigning to `*src` counts as a\n+/// `*src` can violate memory safety. Note that assigning to `*src` counts as a\n /// use because it will attempt to drop the value at `*src`.\n ///\n /// [`write`] can be used to overwrite data without causing it to be dropped.\n@@ -588,7 +588,7 @@ pub unsafe fn read<T>(src: *const T) -> T {\n /// * `src` must be [valid] for reads.\n ///\n /// Like [`read`], `read_unaligned` creates a bitwise copy of `T`, regardless of\n-/// whether `T` is [`Copy`].  If `T` is not [`Copy`], using both the returned\n+/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the returned\n /// value and the value at `*src` can [violate memory safety][read-ownership].\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL.\n@@ -825,7 +825,7 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n ///\n /// The compiler shouldn't change the relative order or number of volatile\n /// memory operations. However, volatile memory operations on zero-sized types\n-/// (e.g., if a zero-sized type is passed to `read_volatile`) are no-ops\n+/// (e.g., if a zero-sized type is passed to `read_volatile`) are noops\n /// and may be ignored.\n ///\n /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n@@ -839,7 +839,7 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// * `src` must be properly aligned.\n ///\n /// Like [`read`], `read_unaligned` creates a bitwise copy of `T`, regardless of\n-/// whether `T` is [`Copy`].  If `T` is not [`Copy`], using both the returned\n+/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the returned\n /// value and the value at `*src` can [violate memory safety][read-ownership].\n /// However, storing non-[`Copy`] types in volatile memory is almost certainly\n /// incorrect.\n@@ -903,7 +903,7 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n ///\n /// The compiler shouldn't change the relative order or number of volatile\n /// memory operations. However, volatile memory operations on zero-sized types\n-/// (e.g., if a zero-sized type is passed to `write_volatile`) are no-ops\n+/// (e.g., if a zero-sized type is passed to `write_volatile`) are noops\n /// and may be ignored.\n ///\n /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n@@ -1093,7 +1093,7 @@ impl<T: ?Sized> *const T {\n     /// unless `x` and `y` point into the same allocated object.\n     ///\n     /// Always use `.offset(count)` instead when possible, because `offset`\n-    /// allows the compiler to optimize better.  If you need to cross object\n+    /// allows the compiler to optimize better. If you need to cross object\n     /// boundaries, cast the pointer to an integer and do the arithmetic there.\n     ///\n     /// # Examples\n@@ -1712,7 +1712,7 @@ impl<T: ?Sized> *mut T {\n     /// unless `x` and `y` point into the same allocated object.\n     ///\n     /// Always use `.offset(count)` instead when possible, because `offset`\n-    /// allows the compiler to optimize better.  If you need to cross object\n+    /// allows the compiler to optimize better. If you need to cross object\n     /// boundaries, cast the pointer to an integer and do the arithmetic there.\n     ///\n     /// # Examples\n@@ -2473,7 +2473,7 @@ impl<T: ?Sized> PartialEq for *mut T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Eq for *mut T {}\n \n-/// Compare raw pointers for equality.\n+/// Compares raw pointers for equality.\n ///\n /// This is the same as using the `==` operator, but less generic:\n /// the arguments have to be `*const T` raw pointers,"}, {"sha": "92d29f6ee8a30c83ba9ec50c9cbf7983c61fc22b", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -896,7 +896,7 @@ impl<T: Default, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Convert a string to an integer, turning poorly-formed strings\n+    /// Converts a string to an integer, turning poorly-formed strings\n     /// into 0 (the default value for integers). [`parse`] converts\n     /// a string to any other type that implements [`FromStr`], returning an\n     /// [`Err`] on error."}, {"sha": "cbba546b8dabad1137a3cc235c199cad5a424faa", "filename": "src/libcore/slice/memchr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmemchr.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -11,7 +11,7 @@ const HI_U64: u64 = 0x8080808080808080;\n const LO_USIZE: usize = LO_U64 as usize;\n const HI_USIZE: usize = HI_U64 as usize;\n \n-/// Returns whether `x` contains any zero byte.\n+/// Returns `true` if `x` contains any zero byte.\n ///\n /// From *Matters Computational*, J. Arndt:\n ///"}, {"sha": "acca9748372ca15b521a7e4c82a37aa481f1092b", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1197,7 +1197,7 @@ impl<T> [T] {\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to returning at most `n` items. This starts at the end of\n-    /// the slice and works backwards.  The matched element is not contained in\n+    /// the slice and works backwards. The matched element is not contained in\n     /// the subslices.\n     ///\n     /// The last element returned, if any, will contain the remainder of the\n@@ -3145,7 +3145,7 @@ unsafe impl<T: Sync> Sync for Iter<'_, T> {}\n unsafe impl<T: Sync> Send for Iter<'_, T> {}\n \n impl<'a, T> Iter<'a, T> {\n-    /// View the underlying data as a subslice of the original data.\n+    /// Views the underlying data as a subslice of the original data.\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n@@ -3247,7 +3247,7 @@ unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n unsafe impl<T: Send> Send for IterMut<'_, T> {}\n \n impl<'a, T> IterMut<'a, T> {\n-    /// View the underlying data as a subslice of the original data.\n+    /// Views the underlying data as a subslice of the original data.\n     ///\n     /// To avoid creating `&mut` references that alias, this is forced\n     /// to consume the iterator.\n@@ -4123,7 +4123,7 @@ pub struct ChunksExact<'a, T:'a> {\n }\n \n impl<'a, T> ChunksExact<'a, T> {\n-    /// Return the remainder of the original slice that is not going to be\n+    /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n     #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n@@ -4247,7 +4247,7 @@ pub struct ChunksExactMut<'a, T:'a> {\n }\n \n impl<'a, T> ChunksExactMut<'a, T> {\n-    /// Return the remainder of the original slice that is not going to be\n+    /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n     #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n@@ -4619,7 +4619,7 @@ pub struct RChunksExact<'a, T:'a> {\n }\n \n impl<'a, T> RChunksExact<'a, T> {\n-    /// Return the remainder of the original slice that is not going to be\n+    /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n     #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n@@ -4744,7 +4744,7 @@ pub struct RChunksExactMut<'a, T:'a> {\n }\n \n impl<'a, T> RChunksExactMut<'a, T> {\n-    /// Return the remainder of the original slice that is not going to be\n+    /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n     #[stable(feature = \"rchunks\", since = \"1.31.0\")]"}, {"sha": "9b35b51349a02612de93e6f276f6316a1ab7cfcf", "filename": "src/libcore/slice/rotate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Frotate.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -26,7 +26,7 @@ impl<T> RawArray<T> {\n }\n \n /// Rotates the range `[mid-left, mid+right)` such that the element at `mid`\n-/// becomes the first element.  Equivalently, rotates the range `left`\n+/// becomes the first element. Equivalently, rotates the range `left`\n /// elements to the left or `right` elements to the right.\n ///\n /// # Safety\n@@ -36,10 +36,10 @@ impl<T> RawArray<T> {\n /// # Algorithm\n ///\n /// For longer rotations, swap the left-most `delta = min(left, right)`\n-/// elements with the right-most `delta` elements.  LLVM vectorizes this,\n+/// elements with the right-most `delta` elements. LLVM vectorizes this,\n /// which is profitable as we only reach this step for a \"large enough\"\n-/// rotation.  Doing this puts `delta` elements on the larger side into the\n-/// correct position, leaving a smaller rotate problem.  Demonstration:\n+/// rotation. Doing this puts `delta` elements on the larger side into the\n+/// correct position, leaving a smaller rotate problem. Demonstration:\n ///\n /// ```text\n /// [ 6 7 8 9 10 11 12 13 . 1 2 3 4 5 ]"}, {"sha": "6c08e545c5c0f7473a795fb5f3e0c0ae42151ffb", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,6 +1,6 @@\n-//! String manipulation\n+//! String manipulation.\n //!\n-//! For more details, see std::str\n+//! For more details, see the `std::str` module.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -226,7 +226,7 @@ impl Utf8Error {\n     #[stable(feature = \"utf8_error\", since = \"1.5.0\")]\n     pub fn valid_up_to(&self) -> usize { self.valid_up_to }\n \n-    /// Provide more information about the failure:\n+    /// Provides more information about the failure:\n     ///\n     /// * `None`: the end of the input was reached unexpectedly.\n     ///   `self.valid_up_to()` is 1 to 3 bytes from the end of the input.\n@@ -612,7 +612,7 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n impl FusedIterator for Chars<'_> {}\n \n impl<'a> Chars<'a> {\n-    /// View the underlying data as a subslice of the original data.\n+    /// Views the underlying data as a subslice of the original data.\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n@@ -702,7 +702,7 @@ impl<'a> DoubleEndedIterator for CharIndices<'a> {\n impl FusedIterator for CharIndices<'_> {}\n \n impl<'a> CharIndices<'a> {\n-    /// View the underlying data as a subslice of the original data.\n+    /// Views the underlying data as a subslice of the original data.\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n@@ -1579,9 +1579,9 @@ mod traits {\n \n     /// Implements ordering of strings.\n     ///\n-    /// Strings are ordered  lexicographically by their byte values.  This orders Unicode code\n-    /// points based on their positions in the code charts.  This is not necessarily the same as\n-    /// \"alphabetical\" order, which varies by language and locale.  Sorting strings according to\n+    /// Strings are ordered  lexicographically by their byte values. This orders Unicode code\n+    /// points based on their positions in the code charts. This is not necessarily the same as\n+    /// \"alphabetical\" order, which varies by language and locale. Sorting strings according to\n     /// culturally-accepted standards requires locale-specific data that is outside the scope of\n     /// the `str` type.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1607,9 +1607,9 @@ mod traits {\n \n     /// Implements comparison operations on strings.\n     ///\n-    /// Strings are compared lexicographically by their byte values.  This compares Unicode code\n-    /// points based on their positions in the code charts.  This is not necessarily the same as\n-    /// \"alphabetical\" order, which varies by language and locale.  Comparing strings according to\n+    /// Strings are compared lexicographically by their byte values. This compares Unicode code\n+    /// points based on their positions in the code charts. This is not necessarily the same as\n+    /// \"alphabetical\" order, which varies by language and locale. Comparing strings according to\n     /// culturally-accepted standards requires locale-specific data that is outside the scope of\n     /// the `str` type.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2643,7 +2643,7 @@ impl str {\n         Bytes(self.as_bytes().iter().cloned())\n     }\n \n-    /// Split a string slice by whitespace.\n+    /// Splits a string slice by whitespace.\n     ///\n     /// The iterator returned will return string slices that are sub-slices of\n     /// the original string slice, separated by any amount of whitespace.\n@@ -2686,7 +2686,7 @@ impl str {\n         SplitWhitespace { inner: self.split(IsWhitespace).filter(IsNotEmpty) }\n     }\n \n-    /// Split a string slice by ASCII whitespace.\n+    /// Splits a string slice by ASCII whitespace.\n     ///\n     /// The iterator returned will return string slices that are sub-slices of\n     /// the original string slice, separated by any amount of ASCII whitespace.\n@@ -3504,7 +3504,7 @@ impl str {\n     ///\n     /// A string is a sequence of bytes. `start` in this context means the first\n     /// position of that byte string; for a left-to-right language like English or\n-    /// Russian, this will be left side; and for right-to-left languages like\n+    /// Russian, this will be left side, and for right-to-left languages like\n     /// like Arabic or Hebrew, this will be the right side.\n     ///\n     /// # Examples\n@@ -3541,7 +3541,7 @@ impl str {\n     ///\n     /// A string is a sequence of bytes. `end` in this context means the last\n     /// position of that byte string; for a left-to-right language like English or\n-    /// Russian, this will be right side; and for right-to-left languages like\n+    /// Russian, this will be right side, and for right-to-left languages like\n     /// like Arabic or Hebrew, this will be the left side.\n     ///\n     /// # Examples\n@@ -3787,7 +3787,7 @@ impl str {\n     ///\n     /// A string is a sequence of bytes. `start` in this context means the first\n     /// position of that byte string; for a left-to-right language like English or\n-    /// Russian, this will be left side; and for right-to-left languages like\n+    /// Russian, this will be left side, and for right-to-left languages like\n     /// like Arabic or Hebrew, this will be the right side.\n     ///\n     /// # Examples\n@@ -3819,7 +3819,7 @@ impl str {\n     ///\n     /// A string is a sequence of bytes. `end` in this context means the last\n     /// position of that byte string; for a left-to-right language like English or\n-    /// Russian, this will be right side; and for right-to-left languages like\n+    /// Russian, this will be right side, and for right-to-left languages like\n     /// like Arabic or Hebrew, this will be the left side.\n     ///\n     /// # Examples"}, {"sha": "2571780ad0bab11987bd02cff0fb79cdb30ac55a", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,7 +1,7 @@\n //! The string Pattern API.\n //!\n-//! For more details, see the traits `Pattern`, `Searcher`,\n-//! `ReverseSearcher` and `DoubleEndedSearcher`.\n+//! For more details, see the traits [`Pattern`], [`Searcher`],\n+//! [`ReverseSearcher`], and [`DoubleEndedSearcher`].\n \n #![unstable(feature = \"pattern\",\n             reason = \"API not fully fleshed out and ready to be stabilized\",\n@@ -117,7 +117,7 @@ pub unsafe trait Searcher<'a> {\n     /// `[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]`\n     fn next(&mut self) -> SearchStep;\n \n-    /// Find the next `Match` result. See `next()`\n+    /// Finds the next `Match` result. See `next()`\n     ///\n     /// Unlike next(), there is no guarantee that the returned ranges\n     /// of this and next_reject will overlap. This will return (start_match, end_match),\n@@ -134,7 +134,7 @@ pub unsafe trait Searcher<'a> {\n         }\n     }\n \n-    /// Find the next `Reject` result. See `next()` and `next_match()`\n+    /// Finds the next `Reject` result. See `next()` and `next_match()`\n     ///\n     /// Unlike next(), there is no guarantee that the returned ranges\n     /// of this and next_match will overlap.\n@@ -185,7 +185,7 @@ pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n     /// `[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]`\n     fn next_back(&mut self) -> SearchStep;\n \n-    /// Find the next `Match` result. See `next_back()`\n+    /// Finds the next `Match` result. See `next_back()`\n     #[inline]\n     fn next_match_back(&mut self) -> Option<(usize, usize)>{\n         loop {\n@@ -197,7 +197,7 @@ pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n         }\n     }\n \n-    /// Find the next `Reject` result. See `next_back()`\n+    /// Finds the next `Reject` result. See `next_back()`\n     #[inline]\n     fn next_reject_back(&mut self) -> Option<(usize, usize)>{\n         loop {"}, {"sha": "c811f96ace3baba30f317458db80230eaca8837e", "filename": "src/libcore/task/poll.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fpoll.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -22,7 +22,7 @@ pub enum Poll<T> {\n }\n \n impl<T> Poll<T> {\n-    /// Change the ready value of this `Poll` with the closure provided\n+    /// Changes the ready value of this `Poll` with the closure provided.\n     pub fn map<U, F>(self, f: F) -> Poll<U>\n         where F: FnOnce(T) -> U\n     {\n@@ -32,7 +32,7 @@ impl<T> Poll<T> {\n         }\n     }\n \n-    /// Returns whether this is `Poll::Ready`\n+    /// Returns `true` if this is `Poll::Ready`\n     #[inline]\n     pub fn is_ready(&self) -> bool {\n         match *self {\n@@ -41,15 +41,15 @@ impl<T> Poll<T> {\n         }\n     }\n \n-    /// Returns whether this is `Poll::Pending`\n+    /// Returns `true` if this is `Poll::Pending`\n     #[inline]\n     pub fn is_pending(&self) -> bool {\n         !self.is_ready()\n     }\n }\n \n impl<T, E> Poll<Result<T, E>> {\n-    /// Change the success value of this `Poll` with the closure provided\n+    /// Changes the success value of this `Poll` with the closure provided.\n     pub fn map_ok<U, F>(self, f: F) -> Poll<Result<U, E>>\n         where F: FnOnce(T) -> U\n     {\n@@ -60,7 +60,7 @@ impl<T, E> Poll<Result<T, E>> {\n         }\n     }\n \n-    /// Change the error value of this `Poll` with the closure provided\n+    /// Changes the error value of this `Poll` with the closure provided.\n     pub fn map_err<U, F>(self, f: F) -> Poll<Result<T, U>>\n         where F: FnOnce(E) -> U\n     {"}, {"sha": "6d54989706cac9c46c2a1282c299d84fdb449bf3", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -41,11 +41,11 @@ impl Waker {\n         unsafe { self.inner.as_ref().wake() }\n     }\n \n-    /// Returns whether or not this `Waker` and `other` awaken the same task.\n+    /// Returns `true` if or not this `Waker` and `other` awaken the same task.\n     ///\n     /// This function works on a best-effort basis, and may return false even\n     /// when the `Waker`s would awaken the same task. However, if this function\n-    /// returns true, it is guaranteed that the `Waker`s will awaken the same\n+    /// returns `true`, it is guaranteed that the `Waker`s will awaken the same\n     /// task.\n     ///\n     /// This function is primarily used for optimization purposes.\n@@ -54,7 +54,7 @@ impl Waker {\n         self.inner == other.inner\n     }\n \n-    /// Returns whether or not this `Waker` and `other` `LocalWaker` awaken\n+    /// Returns `true` if or not this `Waker` and `other` `LocalWaker` awaken\n     /// the same task.\n     ///\n     /// This function works on a best-effort basis, and may return false even\n@@ -150,7 +150,7 @@ impl LocalWaker {\n         unsafe { self.0.inner.as_ref().wake_local() }\n     }\n \n-    /// Returns whether or not this `LocalWaker` and `other` `LocalWaker` awaken the same task.\n+    /// Returns `true` if or not this `LocalWaker` and `other` `LocalWaker` awaken the same task.\n     ///\n     /// This function works on a best-effort basis, and may return false even\n     /// when the `LocalWaker`s would awaken the same task. However, if this function\n@@ -163,7 +163,7 @@ impl LocalWaker {\n         self.0.will_wake(&other.0)\n     }\n \n-    /// Returns whether or not this `LocalWaker` and `other` `Waker` awaken the same task.\n+    /// Returns `true` if or not this `LocalWaker` and `other` `Waker` awaken the same task.\n     ///\n     /// This function works on a best-effort basis, and may return false even\n     /// when the `Waker`s would awaken the same task. However, if this function\n@@ -223,14 +223,14 @@ pub unsafe trait UnsafeWake: Send + Sync {\n     /// Drops this instance of `UnsafeWake`, deallocating resources\n     /// associated with it.\n     ///\n-    /// FIXME(cramertj)\n+    // FIXME(cramertj):\n     /// This method is intended to have a signature such as:\n     ///\n     /// ```ignore (not-a-doctest)\n     /// fn drop_raw(self: *mut Self);\n     /// ```\n     ///\n-    /// Unfortunately in Rust today that signature is not object safe.\n+    /// Unfortunately, in Rust today that signature is not object safe.\n     /// Nevertheless it's recommended to implement this function *as if* that\n     /// were its signature. As such it is not safe to call on an invalid\n     /// pointer, nor is the validity of the pointer guaranteed after this"}, {"sha": "51a6017de1b5fead95d446117fa7f452118da28f", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -881,7 +881,7 @@ fn test_iterator_flat_map() {\n     assert_eq!(i, ys.len());\n }\n \n-/// Test `FlatMap::fold` with items already picked off the front and back,\n+/// Tests `FlatMap::fold` with items already picked off the front and back,\n /// to make sure all parts of the `FlatMap` are folded correctly.\n #[test]\n fn test_iterator_flat_map_fold() {\n@@ -919,7 +919,7 @@ fn test_iterator_flatten() {\n     assert_eq!(i, ys.len());\n }\n \n-/// Test `Flatten::fold` with items already picked off the front and back,\n+/// Tests `Flatten::fold` with items already picked off the front and back,\n /// to make sure all parts of the `Flatten` are folded correctly.\n #[test]\n fn test_iterator_flatten_fold() {"}, {"sha": "ac7e11754aa3a21955d9036134dd0ce055140403", "filename": "src/libcore/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -43,7 +43,7 @@ pub const NANOSECOND: Duration = Duration::from_nanos(1);\n /// timeouts.\n ///\n /// Each `Duration` is composed of a whole number of seconds and a fractional part\n-/// represented in nanoseconds.  If the underlying system does not support\n+/// represented in nanoseconds. If the underlying system does not support\n /// nanosecond-level precision, APIs binding a system timeout will typically round up\n /// the number of nanoseconds.\n ///\n@@ -515,7 +515,7 @@ impl Duration {\n         }\n     }\n \n-    /// Multiply `Duration` by `f64`.\n+    /// Multiplies `Duration` by `f64`.\n     ///\n     /// # Panics\n     /// This method will panic if result is not finite, negative or overflows `Duration`."}, {"sha": "7e7a9df93cd7b055130f575598ddd11686565453", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -393,7 +393,7 @@ impl<'a> Id<'a> {\n     /// digit (i.e., the regular expression `[a-zA-Z_][a-zA-Z_0-9]*`).\n     ///\n     /// (Note: this format is a strict subset of the `ID` format\n-    /// defined by the DOT language.  This function may change in the\n+    /// defined by the DOT language. This function may change in the\n     /// future to accept a broader subset, or the entirety, of DOT's\n     /// `ID` format.)\n     ///\n@@ -530,7 +530,7 @@ impl<'a> LabelText<'a> {\n     }\n \n     /// Decomposes content into string suitable for making EscStr that\n-    /// yields same content as self.  The result obeys the law\n+    /// yields same content as self. The result obeys the law\n     /// render(`lt`) == render(`EscStr(lt.pre_escaped_content())`) for\n     /// all `lt: LabelText`.\n     fn pre_escaped_content(self) -> Cow<'a, str> {"}, {"sha": "3a00d6376658c1a64751ddd349181ff7325ab23c", "filename": "src/libpanic_unwind/dummy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibpanic_unwind%2Fdummy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibpanic_unwind%2Fdummy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdummy.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,6 +1,6 @@\n-//! Unwinding for wasm32\n+//! Unwinding for *wasm32* target.\n //!\n-//! Right now we don't support this, so this is just stubs\n+//! Right now we don't support this, so this is just stubs.\n \n use alloc::boxed::Box;\n use core::any::Any;"}, {"sha": "ce24406b556420af262f0b33198014ad95367132", "filename": "src/libpanic_unwind/dwarf/eh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -6,7 +6,7 @@\n //!   http://www.airs.com/blog/archives/464\n //!\n //! A reference implementation may be found in the GCC source tree\n-//! (<root>/libgcc/unwind-c.c as of this writing)\n+//! (`<root>/libgcc/unwind-c.c` as of this writing).\n \n #![allow(non_upper_case_globals)]\n #![allow(unused)]"}, {"sha": "0360696426dc94ba8441e7c1cbdc9bfb6a1bb671", "filename": "src/libpanic_unwind/dwarf/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,5 +1,5 @@\n //! Utilities for parsing DWARF-encoded data streams.\n-//! See http://www.dwarfstd.org,\n+//! See <http://www.dwarfstd.org>,\n //! DWARF-4 standard, Section 7 - \"Data Representation\"\n \n // This module is used only by x86_64-pc-windows-gnu for now, but we"}, {"sha": "1f5ccfb0f121032070fb484dff5150b82e90bcca", "filename": "src/libpanic_unwind/emcc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibpanic_unwind%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibpanic_unwind%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Femcc.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,9 +1,9 @@\n-//! Unwinding for emscripten\n+//! Unwinding for *emscripten* target.\n //!\n //! Whereas Rust's usual unwinding implementation for Unix platforms\n-//! calls into the libunwind APIs directly, on emscripten we instead\n+//! calls into the libunwind APIs directly, on Emscripten we instead\n //! call into the C++ unwinding APIs. This is just an expedience since\n-//! emscripten's runtime always implements those APIs and does not\n+//! Emscripten's runtime always implements those APIs and does not\n //! implement libunwind.\n \n #![allow(private_no_mangle_fns)]"}, {"sha": "607fe28e3f28de7021de6bded40a5825be2f25f1", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,4 +1,4 @@\n-//! Implementation of panics backed by libgcc/libunwind (in some form)\n+//! Implementation of panics backed by libgcc/libunwind (in some form).\n //!\n //! For background on exception handling and stack unwinding please see\n //! \"Exception Handling in LLVM\" (llvm.org/docs/ExceptionHandling.html) and\n@@ -23,14 +23,14 @@\n //!\n //! In the search phase, the job of a personality routine is to examine\n //! exception object being thrown, and to decide whether it should be caught at\n-//! that stack frame.  Once the handler frame has been identified, cleanup phase\n+//! that stack frame. Once the handler frame has been identified, cleanup phase\n //! begins.\n //!\n //! In the cleanup phase, the unwinder invokes each personality routine again.\n //! This time it decides which (if any) cleanup code needs to be run for\n-//! the current stack frame.  If so, the control is transferred to a special\n+//! the current stack frame. If so, the control is transferred to a special\n //! branch in the function body, the \"landing pad\", which invokes destructors,\n-//! frees memory, etc.  At the end of the landing pad, control is transferred\n+//! frees memory, etc. At the end of the landing pad, control is transferred\n //! back to the unwinder and unwinding resumes.\n //!\n //! Once stack has been unwound down to the handler frame level, unwinding stops\n@@ -39,7 +39,7 @@\n //! ## `eh_personality` and `eh_unwind_resume`\n //!\n //! These language items are used by the compiler when generating unwind info.\n-//! The first one is the personality routine described above.  The second one\n+//! The first one is the personality routine described above. The second one\n //! allows compilation target to customize the process of resuming unwind at the\n //! end of the landing pads. `eh_unwind_resume` is used only if\n //! `custom_unwind_resume` flag in the target options is set."}, {"sha": "6f7965095b638504873c644ccc7a6804234cd6e4", "filename": "src/libproc_macro/bridge/scoped_cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -38,7 +38,7 @@ impl<T: LambdaL> ScopedCell<T> {\n         ScopedCell(Cell::new(value))\n     }\n \n-    /// Set the value in `self` to `replacement` while\n+    /// Sets the value in `self` to `replacement` while\n     /// running `f`, which gets the old value, mutably.\n     /// The old value will be restored after `f` exits, even\n     /// by panic, including modifications made to it by `f`.\n@@ -73,7 +73,7 @@ impl<T: LambdaL> ScopedCell<T> {\n         f(RefMutL(put_back_on_drop.value.as_mut().unwrap()))\n     }\n \n-    /// Set the value in `self` to `value` while running `f`.\n+    /// Sets the value in `self` to `value` while running `f`.\n     pub fn set<'a, R>(&self, value: <T as ApplyL<'a>>::Out, f: impl FnOnce() -> R) -> R {\n         self.replace(value, |_| f())\n     }"}, {"sha": "65eebb5ec37374a47fcbf356ac7e5e390d8316b8", "filename": "src/libproc_macro/diagnostic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fdiagnostic.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -56,7 +56,7 @@ pub struct Diagnostic {\n \n macro_rules! diagnostic_child_methods {\n     ($spanned:ident, $regular:ident, $level:expr) => (\n-        /// Add a new child diagnostic message to `self` with the level\n+        /// Adds a new child diagnostic message to `self` with the level\n         /// identified by this method's name with the given `spans` and\n         /// `message`.\n         #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n@@ -67,7 +67,7 @@ macro_rules! diagnostic_child_methods {\n             self\n         }\n \n-        /// Add a new child diagnostic message to `self` with the level\n+        /// Adds a new child diagnostic message to `self` with the level\n         /// identified by this method's name with the given `message`.\n         #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n         pub fn $regular<T: Into<String>>(mut self, message: T) -> Diagnostic {\n@@ -93,7 +93,7 @@ impl<'a> Iterator for Children<'a> {\n \n #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n impl Diagnostic {\n-    /// Create a new diagnostic with the given `level` and `message`.\n+    /// Creates a new diagnostic with the given `level` and `message`.\n     #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n     pub fn new<T: Into<String>>(level: Level, message: T) -> Diagnostic {\n         Diagnostic {\n@@ -104,7 +104,7 @@ impl Diagnostic {\n         }\n     }\n \n-    /// Create a new diagnostic with the given `level` and `message` pointing to\n+    /// Creates a new diagnostic with the given `level` and `message` pointing to\n     /// the given set of `spans`.\n     #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n     pub fn spanned<S, T>(spans: S, level: Level, message: T) -> Diagnostic"}, {"sha": "238f8f635415b5a1a9cbcb411b29392411087b11", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -89,7 +89,7 @@ impl TokenStream {\n /// or characters not existing in the language.\n /// All tokens in the parsed stream get `Span::call_site()` spans.\n ///\n-/// NOTE: Some errors may cause panics instead of returning `LexError`. We reserve the right to\n+/// NOTE: some errors may cause panics instead of returning `LexError`. We reserve the right to\n /// change these errors into `LexError`s later.\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl FromStr for TokenStream {\n@@ -245,7 +245,7 @@ impl !Sync for Span {}\n \n macro_rules! diagnostic_method {\n     ($name:ident, $level:expr) => (\n-        /// Create a new `Diagnostic` with the given `message` at the span\n+        /// Creates a new `Diagnostic` with the given `message` at the span\n         /// `self`.\n         #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n         pub fn $name<T: Into<String>>(self, message: T) -> Diagnostic {\n@@ -291,19 +291,19 @@ impl Span {\n         Span(self.0.source())\n     }\n \n-    /// Get the starting line/column in the source file for this span.\n+    /// Gets the starting line/column in the source file for this span.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n     pub fn start(&self) -> LineColumn {\n         self.0.start()\n     }\n \n-    /// Get the ending line/column in the source file for this span.\n+    /// Gets the ending line/column in the source file for this span.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n     pub fn end(&self) -> LineColumn {\n         self.0.end()\n     }\n \n-    /// Create a new span encompassing `self` and `other`.\n+    /// Creates a new span encompassing `self` and `other`.\n     ///\n     /// Returns `None` if `self` and `other` are from different files.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n@@ -369,7 +369,7 @@ impl !Sync for LineColumn {}\n pub struct SourceFile(bridge::client::SourceFile);\n \n impl SourceFile {\n-    /// Get the path to this source file.\n+    /// Gets the path to this source file.\n     ///\n     /// ### Note\n     /// If the code span associated with this `SourceFile` was generated by an external macro, this"}, {"sha": "f18ee3dced72d10c0e47de8af2c0ba7ef341f630", "filename": "src/librustc/dep_graph/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdebug.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -22,7 +22,7 @@ impl DepNodeFilter {\n         }\n     }\n \n-    /// True if all nodes always pass the filter.\n+    /// Returns `true` if all nodes always pass the filter.\n     pub fn accepts_all(&self) -> bool {\n         self.text.is_empty()\n     }"}, {"sha": "796739c8721741df37065610fe8e541524dd4bb7", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -302,7 +302,7 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n-            /// Create a new, parameterless DepNode. This method will assert\n+            /// Creates a new, parameterless DepNode. This method will assert\n             /// that the DepNode corresponding to the given DepKind actually\n             /// does not require any parameters.\n             #[inline(always)]\n@@ -314,7 +314,7 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n-            /// Extract the DefId corresponding to this DepNode. This will work\n+            /// Extracts the DefId corresponding to this DepNode. This will work\n             /// if two conditions are met:\n             ///\n             /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n@@ -798,7 +798,7 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for HirId {\n }\n \n /// A \"work product\" corresponds to a `.o` (or other) file that we\n-/// save in between runs. These ids do not have a DefId but rather\n+/// save in between runs. These IDs do not have a `DefId` but rather\n /// some independent path or string that persists between runs without\n /// the need to be mapped or unmapped. (This ensures we can serialize\n /// them even in the absence of a tcx.)"}, {"sha": "94b832bea628ef915287bb3e293191aa27764173", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -43,7 +43,7 @@ impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n     ///\n     /// Here, `[op]` represents whatever nodes `op` reads in the\n     /// course of execution; `Map(key)` represents the node for this\n-    /// map; and `CurrentTask` represents the current task when\n+    /// map, and `CurrentTask` represents the current task when\n     /// `memoize` is invoked.\n     ///\n     /// **Important:** when `op` is invoked, the current task will be"}, {"sha": "59ec459de964160d70b9161ca67dd17a8ae234b5", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -61,13 +61,13 @@ struct DepGraphData {\n \n     colors: DepNodeColorMap,\n \n-    /// A set of loaded diagnostics which has been emitted.\n+    /// A set of loaded diagnostics that have been emitted.\n     emitted_diagnostics: Mutex<FxHashSet<DepNodeIndex>>,\n \n     /// Used to wait for diagnostics to be emitted.\n     emitted_diagnostics_cond_var: Condvar,\n \n-    /// When we load, there may be `.o` files, cached mir, or other such\n+    /// When we load, there may be `.o` files, cached MIR, or other such\n     /// things available to us. If we find that they are not dirty, we\n     /// load the path to the file storing those work-products here into\n     /// this map. We can later look for and extract that data.\n@@ -115,7 +115,7 @@ impl DepGraph {\n         }\n     }\n \n-    /// True if we are actually building the full dep-graph.\n+    /// Returns `true` if we are actually building the full dep-graph, and `false` otherwise.\n     #[inline]\n     pub fn is_fully_enabled(&self) -> bool {\n         self.data.is_some()\n@@ -320,8 +320,8 @@ impl DepGraph {\n         }\n     }\n \n-    /// Execute something within an \"anonymous\" task, that is, a task the\n-    /// DepNode of which is determined by the list of inputs it read from.\n+    /// Executes something within an \"anonymous\" task, that is, a task the\n+    /// `DepNode` of which is determined by the list of inputs it read from.\n     pub fn with_anon_task<OP,R>(&self, dep_kind: DepKind, op: OP) -> (R, DepNodeIndex)\n         where OP: FnOnce() -> R\n     {\n@@ -356,8 +356,8 @@ impl DepGraph {\n         }\n     }\n \n-    /// Execute something within an \"eval-always\" task which is a task\n-    // that runs whenever anything changes.\n+    /// Executes something within an \"eval-always\" task which is a task\n+    /// that runs whenever anything changes.\n     pub fn with_eval_always_task<'a, C, A, R>(\n         &self,\n         key: DepNode,\n@@ -438,7 +438,7 @@ impl DepGraph {\n         self.data.as_ref().unwrap().previous.node_to_index(dep_node)\n     }\n \n-    /// Check whether a previous work product exists for `v` and, if\n+    /// Checks whether a previous work product exists for `v` and, if\n     /// so, return the path that leads to it. Used to skip doing work.\n     pub fn previous_work_product(&self, v: &WorkProductId) -> Option<WorkProduct> {\n         self.data\n@@ -589,7 +589,7 @@ impl DepGraph {\n         }\n     }\n \n-    /// Try to mark a dep-node which existed in the previous compilation session as green\n+    /// Try to mark a dep-node which existed in the previous compilation session as green.\n     fn try_mark_previous_green<'tcx>(\n         &self,\n         tcx: TyCtxt<'_, 'tcx, 'tcx>,\n@@ -773,8 +773,8 @@ impl DepGraph {\n         Some(dep_node_index)\n     }\n \n-    /// Atomically emits some loaded diagnotics assuming that this only gets called with\n-    /// did_allocation set to true on one thread\n+    /// Atomically emits some loaded diagnotics, assuming that this only gets called with\n+    /// `did_allocation` set to `true` on a single thread.\n     #[cold]\n     #[inline(never)]\n     fn emit_diagnostics<'tcx>(\n@@ -913,7 +913,7 @@ impl DepGraph {\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct WorkProduct {\n     pub cgu_name: String,\n-    /// Saved files associated with this CGU\n+    /// Saved files associated with this CGU.\n     pub saved_files: Vec<(WorkProductFileKind, String)>,\n }\n \n@@ -937,17 +937,17 @@ pub(super) struct CurrentDepGraph {\n     #[allow(dead_code)]\n     forbidden_edge: Option<EdgeFilter>,\n \n-    // Anonymous DepNodes are nodes the ID of which we compute from the list of\n-    // their edges. This has the beneficial side-effect that multiple anonymous\n-    // nodes can be coalesced into one without changing the semantics of the\n-    // dependency graph. However, the merging of nodes can lead to a subtle\n-    // problem during red-green marking: The color of an anonymous node from\n-    // the current session might \"shadow\" the color of the node with the same\n-    // ID from the previous session. In order to side-step this problem, we make\n-    // sure that anon-node IDs allocated in different sessions don't overlap.\n-    // This is implemented by mixing a session-key into the ID fingerprint of\n-    // each anon node. The session-key is just a random number generated when\n-    // the DepGraph is created.\n+    /// Anonymous `DepNode`s are nodes whose IDs we compute from the list of\n+    /// their edges. This has the beneficial side-effect that multiple anonymous\n+    /// nodes can be coalesced into one without changing the semantics of the\n+    /// dependency graph. However, the merging of nodes can lead to a subtle\n+    /// problem during red-green marking: The color of an anonymous node from\n+    /// the current session might \"shadow\" the color of the node with the same\n+    /// ID from the previous session. In order to side-step this problem, we make\n+    /// sure that anonymous `NodeId`s allocated in different sessions don't overlap.\n+    /// This is implemented by mixing a session-key into the ID fingerprint of\n+    /// each anon node. The session-key is just a random number generated when\n+    /// the `DepGraph` is created.\n     anon_id_seed: Fingerprint,\n \n     total_read_count: u64,"}, {"sha": "ddc1eebe645ae4b3cbba047bea93ec7f47cd3749", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -91,7 +91,7 @@ struct CheckAttrVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n-    /// Check any attribute.\n+    /// Checks any attribute.\n     fn check_attributes(&self, item: &hir::Item, target: Target) {\n         if target == Target::Fn || target == Target::Const {\n             self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(item.id));\n@@ -115,7 +115,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         self.check_used(item, target);\n     }\n \n-    /// Check if an `#[inline]` is applied to a function or a closure.\n+    /// Checks if an `#[inline]` is applied to a function or a closure.\n     fn check_inline(&self, attr: &hir::Attribute, span: &Span, target: Target) {\n         if target != Target::Fn && target != Target::Closure {\n             struct_span_err!(self.tcx.sess,\n@@ -127,7 +127,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         }\n     }\n \n-    /// Check if the `#[non_exhaustive]` attribute on an `item` is valid.\n+    /// Checks if the `#[non_exhaustive]` attribute on an `item` is valid.\n     fn check_non_exhaustive(&self, attr: &hir::Attribute, item: &hir::Item, target: Target) {\n         match target {\n             Target::Struct | Target::Enum => { /* Valid */ },\n@@ -143,7 +143,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         }\n     }\n \n-    /// Check if the `#[marker]` attribute on an `item` is valid.\n+    /// Checks if the `#[marker]` attribute on an `item` is valid.\n     fn check_marker(&self, attr: &hir::Attribute, item: &hir::Item, target: Target) {\n         match target {\n             Target::Trait => { /* Valid */ },\n@@ -157,7 +157,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         }\n     }\n \n-    /// Check if the `#[repr]` attributes on `item` are valid.\n+    /// Checks if the `#[repr]` attributes on `item` are valid.\n     fn check_repr(&self, item: &hir::Item, target: Target) {\n         // Extract the names of all repr hints, e.g., [foo, bar, align] for:\n         // ```"}, {"sha": "b15bea017762ea277a443d94a2e1160cbf7d03c0", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -182,7 +182,7 @@ impl<T> ::std::ops::IndexMut<Namespace> for PerNS<T> {\n }\n \n impl<T> PerNS<Option<T>> {\n-    /// Returns whether all the items in this collection are `None`.\n+    /// Returns `true` if all the items in this collection are `None`.\n     pub fn is_empty(&self) -> bool {\n         self.type_ns.is_none() && self.value_ns.is_none() && self.macro_ns.is_none()\n     }"}, {"sha": "ed1c15a73c260fc33128cb19f9095c00c1464390", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -229,7 +229,7 @@ impl fmt::Debug for DefId {\n }\n \n impl DefId {\n-    /// Make a local `DefId` with the given index.\n+    /// Makes a local `DefId` from the given `DefIndex`.\n     #[inline]\n     pub fn local(index: DefIndex) -> DefId {\n         DefId { krate: LOCAL_CRATE, index: index }"}, {"sha": "9436c600c9fd3a06c20f269d3a93a02ce6f8163d", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -4,7 +4,7 @@\n //! `super::itemlikevisit::ItemLikeVisitor` trait.**\n //!\n //! If you have decided to use this visitor, here are some general\n-//! notes on how to do it:\n+//! notes on how to do so:\n //!\n //! Each overridden visit method has full control over what\n //! happens with its node, it can do its own traversal of the node's children,\n@@ -86,7 +86,7 @@ pub enum NestedVisitorMap<'this, 'tcx: 'this> {\n     /// using this setting.\n     OnlyBodies(&'this Map<'tcx>),\n \n-    /// Visit all nested things, including item-likes.\n+    /// Visits all nested things, including item-likes.\n     ///\n     /// **This is an unusual choice.** It is used when you want to\n     /// process everything within their lexical context. Typically you\n@@ -96,7 +96,7 @@ pub enum NestedVisitorMap<'this, 'tcx: 'this> {\n \n impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n     /// Returns the map to use for an \"intra item-like\" thing (if any).\n-    /// e.g., function body.\n+    /// E.g., function body.\n     pub fn intra(self) -> Option<&'this Map<'tcx>> {\n         match self {\n             NestedVisitorMap::None => None,\n@@ -106,7 +106,7 @@ impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n     }\n \n     /// Returns the map to use for an \"item-like\" thing (if any).\n-    /// e.g., item, impl-item.\n+    /// E.g., item, impl-item.\n     pub fn inter(self) -> Option<&'this Map<'tcx>> {\n         match self {\n             NestedVisitorMap::None => None,\n@@ -117,7 +117,7 @@ impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n }\n \n /// Each method of the Visitor trait is a hook to be potentially\n-/// overridden.  Each method's default implementation recursively visits\n+/// overridden. Each method's default implementation recursively visits\n /// the substructure of the input via the corresponding `walk` method;\n /// e.g., the `visit_mod` method by default calls `intravisit::walk_mod`.\n ///\n@@ -129,7 +129,7 @@ impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n /// on `visit_nested_item` for details on how to visit nested items.\n ///\n /// If you want to ensure that your code handles every variant\n-/// explicitly, you need to override each method.  (And you also need\n+/// explicitly, you need to override each method. (And you also need\n /// to monitor future changes to `Visitor` in case a new method with a\n /// new default implementation gets introduced.)\n pub trait Visitor<'v> : Sized {\n@@ -203,7 +203,7 @@ pub trait Visitor<'v> : Sized {\n         }\n     }\n \n-    /// Visit the top-level item and (optionally) nested items / impl items. See\n+    /// Visits the top-level item and (optionally) nested items / impl items. See\n     /// `visit_nested_item` for details.\n     fn visit_item(&mut self, i: &'v Item) {\n         walk_item(self, i)\n@@ -214,7 +214,7 @@ pub trait Visitor<'v> : Sized {\n     }\n \n     /// When invoking `visit_all_item_likes()`, you need to supply an\n-    /// item-like visitor.  This method converts a \"intra-visit\"\n+    /// item-like visitor. This method converts a \"intra-visit\"\n     /// visitor into an item-like visitor that walks the entire tree.\n     /// If you use this, you probably don't want to process the\n     /// contents of nested item-like things, since the outer loop will"}, {"sha": "6ff4db750044a793f02d3bc66ae81faded362752", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -3,24 +3,24 @@\n //! Since the AST and HIR are fairly similar, this is mostly a simple procedure,\n //! much like a fold. Where lowering involves a bit more work things get more\n //! interesting and there are some invariants you should know about. These mostly\n-//! concern spans and ids.\n+//! concern spans and IDs.\n //!\n //! Spans are assigned to AST nodes during parsing and then are modified during\n //! expansion to indicate the origin of a node and the process it went through\n-//! being expanded. Ids are assigned to AST nodes just before lowering.\n+//! being expanded. IDs are assigned to AST nodes just before lowering.\n //!\n-//! For the simpler lowering steps, ids and spans should be preserved. Unlike\n+//! For the simpler lowering steps, IDs and spans should be preserved. Unlike\n //! expansion we do not preserve the process of lowering in the spans, so spans\n //! should not be modified here. When creating a new node (as opposed to\n-//! 'folding' an existing one), then you create a new id using `next_id()`.\n+//! 'folding' an existing one), then you create a new ID using `next_id()`.\n //!\n-//! You must ensure that ids are unique. That means that you should only use the\n-//! id from an AST node in a single HIR node (you can assume that AST node ids\n-//! are unique). Every new node must have a unique id. Avoid cloning HIR nodes.\n-//! If you do, you must then set the new node's id to a fresh one.\n+//! You must ensure that IDs are unique. That means that you should only use the\n+//! ID from an AST node in a single HIR node (you can assume that AST node IDs\n+//! are unique). Every new node must have a unique ID. Avoid cloning HIR nodes.\n+//! If you do, you must then set the new node's ID to a fresh one.\n //!\n //! Spans are used for error messages and for tools to map semantics back to\n-//! source code. It is therefore not as important with spans as ids to be strict\n+//! source code. It is therefore not as important with spans as IDs to be strict\n //! about use (you can't break the compiler by screwing up a span). Obviously, a\n //! HIR node can only have a single span. But multiple nodes can have the same\n //! span and spans don't need to be kept in order, etc. Where code is preserved\n@@ -145,7 +145,7 @@ pub trait Resolver {\n         is_value: bool,\n     ) -> hir::Path;\n \n-    /// Obtain the resolution for a node-id.\n+    /// Obtain the resolution for a `NodeId`.\n     fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution>;\n \n     /// Obtain the possible resolutions for the given `use` statement.\n@@ -274,10 +274,10 @@ enum ParenthesizedGenericArgs {\n }\n \n /// What to do when we encounter an **anonymous** lifetime\n-/// reference. Anonymous lifetime references come in two flavors.  You\n+/// reference. Anonymous lifetime references come in two flavors. You\n /// have implicit, or fully elided, references to lifetimes, like the\n /// one in `&T` or `Ref<T>`, and you have `'_` lifetimes, like `&'_ T`\n-/// or `Ref<'_, T>`.  These often behave the same, but not always:\n+/// or `Ref<'_, T>`. These often behave the same, but not always:\n ///\n /// - certain usages of implicit references are deprecated, like\n ///   `Ref<T>`, and we sometimes just give hard errors in those cases\n@@ -3302,7 +3302,7 @@ impl<'a> LoweringContext<'a> {\n \n     /// Paths like the visibility path in `pub(super) use foo::{bar, baz}` are repeated\n     /// many times in the HIR tree; for each occurrence, we need to assign distinct\n-    /// node-ids. (See e.g., #56128.)\n+    /// `NodeId`s. (See, e.g., #56128.)\n     fn renumber_segment_ids(&mut self, path: &P<hir::Path>) -> P<hir::Path> {\n         debug!(\"renumber_segment_ids(path = {:?})\", path);\n         let mut path = path.clone();"}, {"sha": "6919628c7675552c18863a5724712dca46295ab7", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,9 +1,9 @@\n //! This module provides a simplified abstraction for working with\n-//! code blocks identified by their integer node-id.  In particular,\n+//! code blocks identified by their integer `NodeId`. In particular,\n //! it captures a common set of attributes that all \"function-like\n-//! things\" (represented by `FnLike` instances) share.  For example,\n+//! things\" (represented by `FnLike` instances) share. For example,\n //! all `FnLike` instances have a type signature (be it explicit or\n-//! inferred).  And all `FnLike` instances have a body, i.e., the code\n+//! inferred). And all `FnLike` instances have a body, i.e., the code\n //! that is run when the function-like thing it represents is invoked.\n //!\n //! With the above abstraction in place, one can treat the program"}, {"sha": "8fe10a85ef380de12a3e00b874dc3a6ed53adefd", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -12,7 +12,7 @@ use syntax_pos::Span;\n \n use crate::hir::map::{ITEM_LIKE_SPACE, REGULAR_SPACE};\n \n-/// Creates def ids for nodes in the AST.\n+/// Creates `DefId`s for nodes in the AST.\n pub struct DefCollector<'a> {\n     definitions: &'a mut Definitions,\n     parent_def: Option<DefIndex>,"}, {"sha": "f454d691d4188c41ad65c39980038ac9a0fe7ffe", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,5 +1,5 @@\n-//! For each definition, we track the following data.  A definition\n-//! here is defined somewhat circularly as \"something with a def-id\",\n+//! For each definition, we track the following data. A definition\n+//! here is defined somewhat circularly as \"something with a `DefId`\",\n //! but it generally corresponds to things like structs, enums, etc.\n //! There are also some rather random cases (like const initializer\n //! expressions) that are mostly just leftovers.\n@@ -163,10 +163,10 @@ pub struct Definitions {\n /// any) with a `DisambiguatedDefPathData`.\n #[derive(Clone, PartialEq, Debug, Hash, RustcEncodable, RustcDecodable)]\n pub struct DefKey {\n-    /// Parent path.\n+    /// The parent path.\n     pub parent: Option<DefIndex>,\n \n-    /// Identifier of this node.\n+    /// The identifier of this node.\n     pub disambiguated_data: DisambiguatedDefPathData,\n }\n \n@@ -207,12 +207,12 @@ impl DefKey {\n     }\n }\n \n-/// Pair of `DefPathData` and an integer disambiguator. The integer is\n+/// A pair of `DefPathData` and an integer disambiguator. The integer is\n /// normally 0, but in the event that there are multiple defs with the\n /// same `parent` and `data`, we use this field to disambiguate\n /// between them. This introduces some artificial ordering dependency\n /// but means that if you have (e.g.) two impls for the same type in\n-/// the same module, they do get distinct def-ids.\n+/// the same module, they do get distinct `DefId`s.\n #[derive(Clone, PartialEq, Debug, Hash, RustcEncodable, RustcDecodable)]\n pub struct DisambiguatedDefPathData {\n     pub data: DefPathData,\n@@ -221,10 +221,10 @@ pub struct DisambiguatedDefPathData {\n \n #[derive(Clone, Debug, Hash, RustcEncodable, RustcDecodable)]\n pub struct DefPath {\n-    /// the path leading from the crate root to the item\n+    /// The path leading from the crate root to the item.\n     pub data: Vec<DisambiguatedDefPathData>,\n \n-    /// what krate root is this path relative to?\n+    /// The crate root this path is relative to.\n     pub krate: CrateNum,\n }\n \n@@ -260,9 +260,9 @@ impl DefPath {\n         DefPath { data: data, krate: krate }\n     }\n \n-    /// Returns a string representation of the DefPath without\n+    /// Returns a string representation of the `DefPath` without\n     /// the crate-prefix. This method is useful if you don't have\n-    /// a TyCtxt available.\n+    /// a `TyCtxt` available.\n     pub fn to_string_no_crate(&self) -> String {\n         let mut s = String::with_capacity(self.data.len() * 16);\n \n@@ -277,7 +277,7 @@ impl DefPath {\n         s\n     }\n \n-    /// Return filename friendly string of the DefPah with the\n+    /// Returns a filename-friendly string for the `DefPath`, with the\n     /// crate-prefix.\n     pub fn to_string_friendly<F>(&self, crate_imported_name: F) -> String\n         where F: FnOnce(CrateNum) -> Symbol\n@@ -302,9 +302,9 @@ impl DefPath {\n         s\n     }\n \n-    /// Return filename friendly string of the DefPah without\n+    /// Returns a filename-friendly string of the `DefPath`, without\n     /// the crate-prefix. This method is useful if you don't have\n-    /// a TyCtxt available.\n+    /// a `TyCtxt` available.\n     pub fn to_filename_friendly_no_crate(&self) -> String {\n         let mut s = String::with_capacity(self.data.len() * 16);\n \n@@ -394,18 +394,18 @@ impl Borrow<Fingerprint> for DefPathHash {\n }\n \n impl Definitions {\n-    /// Create new empty definition map.\n+    /// Creates new empty definition map.\n     ///\n-    /// The DefIndex returned from a new Definitions are as follows:\n-    /// 1. At DefIndexAddressSpace::Low,\n+    /// The `DefIndex` returned from a new `Definitions` are as follows:\n+    /// 1. At `DefIndexAddressSpace::Low`,\n     ///     CRATE_ROOT has index 0:0, and then new indexes are allocated in\n     ///     ascending order.\n-    /// 2. At DefIndexAddressSpace::High,\n-    ///     the first FIRST_FREE_HIGH_DEF_INDEX indexes are reserved for\n-    ///     internal use, then 1:FIRST_FREE_HIGH_DEF_INDEX are allocated in\n+    /// 2. At `DefIndexAddressSpace::High`,\n+    ///     the first `FIRST_FREE_HIGH_DEF_INDEX` indexes are reserved for\n+    ///     internal use, then `1:FIRST_FREE_HIGH_DEF_INDEX` are allocated in\n     ///     ascending order.\n-    ///\n-    /// FIXME: there is probably a better place to put this comment.\n+    //\n+    // FIXME: there is probably a better place to put this comment.\n     pub fn new() -> Self {\n         Self::default()\n     }\n@@ -414,7 +414,7 @@ impl Definitions {\n         &self.table\n     }\n \n-    /// Get the number of definitions.\n+    /// Gets the number of definitions.\n     pub fn def_index_counts_lo_hi(&self) -> (usize, usize) {\n         (self.table.index_to_key[DefIndexAddressSpace::Low.index()].len(),\n          self.table.index_to_key[DefIndexAddressSpace::High.index()].len())\n@@ -497,8 +497,8 @@ impl Definitions {\n         self.node_to_hir_id[node_id]\n     }\n \n-    /// Retrieve the span of the given `DefId` if `DefId` is in the local crate, the span exists and\n-    /// it's not DUMMY_SP\n+    /// Retrieves the span of the given `DefId` if `DefId` is in the local crate, the span exists\n+    /// and it's not `DUMMY_SP`.\n     #[inline]\n     pub fn opt_span(&self, def_id: DefId) -> Option<Span> {\n         if def_id.krate == LOCAL_CRATE {\n@@ -508,7 +508,7 @@ impl Definitions {\n         }\n     }\n \n-    /// Add a definition with a parent definition.\n+    /// Adds a root definition (no parent).\n     pub fn create_root_def(&mut self,\n                            crate_name: &str,\n                            crate_disambiguator: CrateDisambiguator)\n@@ -606,7 +606,7 @@ impl Definitions {\n         index\n     }\n \n-    /// Initialize the ast::NodeId to HirId mapping once it has been generated during\n+    /// Initialize the `ast::NodeId` to `HirId` mapping once it has been generated during\n     /// AST to HIR lowering.\n     pub fn init_node_id_to_hir_id_mapping(&mut self,\n                                           mapping: IndexVec<ast::NodeId, hir::HirId>) {"}, {"sha": "692b7fd37d28d2868fa94f21fd5e81c9d3379855", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -36,7 +36,7 @@ mod hir_id_validator;\n pub const ITEM_LIKE_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::Low;\n pub const REGULAR_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::High;\n \n-/// Represents an entry and its parent NodeId.\n+/// Represents an entry and its parent `NodeId`.\n #[derive(Copy, Clone, Debug)]\n pub struct Entry<'hir> {\n     parent: NodeId,\n@@ -162,8 +162,7 @@ impl Forest {\n     }\n }\n \n-/// Represents a mapping from Node IDs to AST elements and their parent\n-/// Node IDs\n+/// Represents a mapping from `NodeId`s to AST elements and their parent `NodeId`s.\n #[derive(Clone)]\n pub struct Map<'hir> {\n     /// The backing storage for all the AST nodes.\n@@ -473,7 +472,7 @@ impl<'hir> Map<'hir> {\n         self.local_def_id(self.body_owner(id))\n     }\n \n-    /// Given a node id, returns the `BodyId` associated with it,\n+    /// Given a `NodeId`, returns the `BodyId` associated with it,\n     /// if the node is a body owner, otherwise returns `None`.\n     pub fn maybe_body_owned_by(&self, id: NodeId) -> Option<BodyId> {\n         if let Some(entry) = self.find_entry(id) {\n@@ -558,7 +557,7 @@ impl<'hir> Map<'hir> {\n         self.trait_auto_impl(trait_did).is_some()\n     }\n \n-    /// Get the attributes on the krate. This is preferable to\n+    /// Gets the attributes on the crate. This is preferable to\n     /// invoking `krate.attrs` because it registers a tighter\n     /// dep-graph access.\n     pub fn krate_attrs(&self) -> &'hir [ast::Attribute] {\n@@ -653,8 +652,7 @@ impl<'hir> Map<'hir> {\n         self.get_generics(id).map(|generics| generics.span).filter(|sp| *sp != DUMMY_SP)\n     }\n \n-    /// Retrieve the Node corresponding to `id`, returning None if\n-    /// cannot be found.\n+    /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n     pub fn find(&self, id: NodeId) -> Option<Node<'hir>> {\n         let result = self.find_entry(id).and_then(|entry| {\n             if let Node::Crate = entry.node {\n@@ -683,8 +681,8 @@ impl<'hir> Map<'hir> {\n     /// returns the enclosing item. Note that this might not be the actual parent\n     /// node in the AST - some kinds of nodes are not in the map and these will\n     /// never appear as the parent_node. So you can always walk the `parent_nodes`\n-    /// from a node to the root of the ast (unless you get the same id back here\n-    /// that can happen if the id is not in the map itself or is just weird).\n+    /// from a node to the root of the ast (unless you get the same ID back here\n+    /// that can happen if the ID is not in the map itself or is just weird).\n     pub fn get_parent_node(&self, id: NodeId) -> NodeId {\n         if self.dep_graph.is_fully_enabled() {\n             let hir_id_owner = self.node_to_hir_id(id).owner;\n@@ -725,7 +723,7 @@ impl<'hir> Map<'hir> {\n \n     /// If there is some error when walking the parents (e.g., a node does not\n     /// have a parent in the map or a node can't be found), then we return the\n-    /// last good node id we found. Note that reaching the crate root (`id == 0`),\n+    /// last good `NodeId` we found. Note that reaching the crate root (`id == 0`),\n     /// is not an error, since items in the crate module have the crate root as\n     /// parent.\n     fn walk_parent_nodes<F, F2>(&self,\n@@ -761,7 +759,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    /// Retrieve the `NodeId` for `id`'s enclosing method, unless there's a\n+    /// Retrieves the `NodeId` for `id`'s enclosing method, unless there's a\n     /// `while` or `loop` before reaching it, as block tail returns are not\n     /// available in them.\n     ///\n@@ -809,7 +807,7 @@ impl<'hir> Map<'hir> {\n         self.walk_parent_nodes(id, match_fn, match_non_returning_block).ok()\n     }\n \n-    /// Retrieve the `NodeId` for `id`'s parent item, or `id` itself if no\n+    /// Retrieves the `NodeId` for `id`'s parent item, or `id` itself if no\n     /// parent item is in this map. The \"parent item\" is the closest parent node\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n@@ -1126,7 +1124,7 @@ pub struct NodesMatchingSuffix<'a, 'hir:'a> {\n }\n \n impl<'a, 'hir> NodesMatchingSuffix<'a, 'hir> {\n-    /// Returns true only if some suffix of the module path for parent\n+    /// Returns `true` only if some suffix of the module path for parent\n     /// matches `self.in_which`.\n     ///\n     /// In other words: let `[x_0,x_1,...,x_k]` be `self.in_which`;"}, {"sha": "d9759da9dfca8080eb8a1f2d75501a1d183326e7", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 167, "deletions": 164, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -62,14 +62,14 @@ pub mod map;\n pub mod pat_util;\n pub mod print;\n \n-/// A HirId uniquely identifies a node in the HIR of the current crate. It is\n-/// composed of the `owner`, which is the DefIndex of the directly enclosing\n-/// hir::Item, hir::TraitItem, or hir::ImplItem (i.e., the closest \"item-like\"),\n+/// Uniquely identifies a node in the HIR of the current crate. It is\n+/// composed of the `owner`, which is the `DefIndex` of the directly enclosing\n+/// `hir::Item`, `hir::TraitItem`, or `hir::ImplItem` (i.e., the closest \"item-like\"),\n /// and the `local_id` which is unique within the given owner.\n ///\n /// This two-level structure makes for more stable values: One can move an item\n /// around within the source code, or add or remove stuff before it, without\n-/// the local_id part of the HirId changing, which is a very useful property in\n+/// the `local_id` part of the `HirId` changing, which is a very useful property in\n /// incremental compilation where we have to persist things through changes to\n /// the code base.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n@@ -130,7 +130,7 @@ mod item_local_id_inner {\n \n pub use self::item_local_id_inner::ItemLocalId;\n \n-/// The `HirId` corresponding to CRATE_NODE_ID and CRATE_DEF_INDEX\n+/// The `HirId` corresponding to `CRATE_NODE_ID` and `CRATE_DEF_INDEX`.\n pub const CRATE_HIR_ID: HirId = HirId {\n     owner: CRATE_DEF_INDEX,\n     local_id: ItemLocalId::from_u32_const(0)\n@@ -149,8 +149,8 @@ pub struct Lifetime {\n     pub hir_id: HirId,\n     pub span: Span,\n \n-    /// Either \"'a\", referring to a named lifetime definition,\n-    /// or \"\" (aka keywords::Invalid), for elision placeholders.\n+    /// Either \"`'a`\", referring to a named lifetime definition,\n+    /// or \"``\" (i.e., `keywords::Invalid`), for elision placeholders.\n     ///\n     /// HIR lowering inserts these placeholders in type paths that\n     /// refer to type definitions needing lifetime parameters,\n@@ -163,8 +163,9 @@ pub enum ParamName {\n     /// Some user-given name like `T` or `'x`.\n     Plain(Ident),\n \n-    /// Synthetic name generated when user elided a lifetime in an impl header,\n-    /// e.g., the lifetimes in cases like these:\n+    /// Synthetic name generated when user elided a lifetime in an impl header.\n+    ///\n+    /// E.g., the lifetimes in cases like these:\n     ///\n     ///     impl Foo for &u32\n     ///     impl Foo<'_> for u32\n@@ -180,7 +181,7 @@ pub enum ParamName {\n \n     /// Indicates an illegal name was given and an error has been\n     /// repored (so we should squelch other derived errors). Occurs\n-    /// when e.g., `'_` is used in the wrong place.\n+    /// when, e.g., `'_` is used in the wrong place.\n     Error,\n }\n \n@@ -205,17 +206,17 @@ pub enum LifetimeName {\n     /// User-given names or fresh (synthetic) names.\n     Param(ParamName),\n \n-    /// User typed nothing. e.g., the lifetime in `&u32`.\n+    /// User wrote nothing (e.g., the lifetime in `&u32`).\n     Implicit,\n \n     /// Indicates an error during lowering (usually `'_` in wrong place)\n     /// that was already reported.\n     Error,\n \n-    /// User typed `'_`.\n+    /// User wrote specifies `'_`.\n     Underscore,\n \n-    /// User wrote `'static`\n+    /// User wrote `'static`.\n     Static,\n }\n \n@@ -280,7 +281,7 @@ impl Lifetime {\n     }\n }\n \n-/// A \"Path\" is essentially Rust's notion of a name; for instance:\n+/// A `Path` is essentially Rust's notion of a name; for instance,\n /// `std::cmp::PartialEq`. It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n@@ -340,7 +341,7 @@ pub struct PathSegment {\n }\n \n impl PathSegment {\n-    /// Convert an identifier to the corresponding segment.\n+    /// Converts an identifier to the corresponding segment.\n     pub fn from_ident(ident: Ident) -> PathSegment {\n         PathSegment {\n             ident,\n@@ -597,14 +598,14 @@ impl Generics {\n     }\n }\n \n-/// Synthetic Type Parameters are converted to an other form during lowering, this allows\n-/// to track the original form they had. Useful for error messages.\n+/// Synthetic type parameters are converted to another form during lowering; this allows\n+/// us to track the original form they had, and is useful for error messages.\n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum SyntheticTyParamKind {\n     ImplTrait\n }\n \n-/// A `where` clause in a definition\n+/// A where-clause in a definition.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereClause {\n     pub id: NodeId,\n@@ -624,7 +625,7 @@ impl WhereClause {\n     }\n }\n \n-/// A single predicate in a `where` clause\n+/// A single predicate in a where-clause.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum WherePredicate {\n     /// A type binding (e.g., `for<'c> Foo: Send + Clone + 'c`).\n@@ -645,27 +646,27 @@ impl WherePredicate {\n     }\n }\n \n-/// A type bound, eg `for<'c> Foo: Send+Clone+'c`\n+/// A type bound (e.g., `for<'c> Foo: Send + Clone + 'c`).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereBoundPredicate {\n     pub span: Span,\n-    /// Any generics from a `for` binding\n+    /// Any generics from a `for` binding.\n     pub bound_generic_params: HirVec<GenericParam>,\n-    /// The type being bounded\n+    /// The type being bounded.\n     pub bounded_ty: P<Ty>,\n-    /// Trait and lifetime bounds (`Clone+Send+'static`)\n+    /// Trait and lifetime bounds (e.g., `Clone + Send + 'static`).\n     pub bounds: GenericBounds,\n }\n \n-/// A lifetime predicate, e.g., `'a: 'b+'c`\n+/// A lifetime predicate (e.g., `'a: 'b + 'c`).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n     pub bounds: GenericBounds,\n }\n \n-/// An equality predicate (unsupported), e.g., `T=int`\n+/// An equality predicate (e.g., `T = int`); currently unsupported.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereEqPredicate {\n     pub id: NodeId,\n@@ -759,7 +760,7 @@ impl Crate {\n         }\n     }\n \n-    /// A parallel version of visit_all_item_likes\n+    /// A parallel version of `visit_all_item_likes`.\n     pub fn par_visit_all_item_likes<'hir, V>(&'hir self, visitor: &V)\n         where V: itemlikevisit::ParItemLikeVisitor<'hir> + Sync + Send\n     {\n@@ -800,14 +801,14 @@ pub struct MacroDef {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Block {\n-    /// Statements in a block\n+    /// Statements in a block.\n     pub stmts: HirVec<Stmt>,\n     /// An expression at the end of the block\n-    /// without a semicolon, if any\n+    /// without a semicolon, if any.\n     pub expr: Option<P<Expr>>,\n     pub id: NodeId,\n     pub hir_id: HirId,\n-    /// Distinguishes between `unsafe { ... }` and `{ ... }`\n+    /// Distinguishes between `unsafe { ... }` and `{ ... }`.\n     pub rules: BlockCheckMode,\n     pub span: Span,\n     /// If true, then there may exist `break 'a` values that aim to\n@@ -874,18 +875,18 @@ impl Pat {\n     }\n }\n \n-/// A single field in a struct pattern\n+/// A single field in a struct pattern.\n ///\n /// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n /// are treated the same as` x: x, y: ref y, z: ref mut z`,\n-/// except is_shorthand is true\n+/// except `is_shorthand` is true.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct FieldPat {\n     pub id: NodeId,\n     pub hir_id: HirId,\n-    /// The identifier for the field\n+    /// The identifier for the field.\n     pub ident: Ident,\n-    /// The pattern the field is destructured to\n+    /// The pattern the field is destructured to.\n     pub pat: P<Pat>,\n     pub is_shorthand: bool,\n }\n@@ -922,41 +923,41 @@ pub enum RangeEnd {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum PatKind {\n-    /// Represents a wildcard pattern (`_`)\n+    /// Represents a wildcard pattern (i.e., `_`).\n     Wild,\n \n     /// A fresh binding `ref mut binding @ OPT_SUBPATTERN`.\n     /// The `NodeId` is the canonical ID for the variable being bound,\n-    /// e.g., in `Ok(x) | Err(x)`, both `x` use the same canonical ID,\n+    /// (e.g., in `Ok(x) | Err(x)`, both `x` use the same canonical ID),\n     /// which is the pattern ID of the first `x`.\n     Binding(BindingAnnotation, NodeId, HirId, Ident, Option<P<Pat>>),\n \n-    /// A struct or struct variant pattern, e.g., `Variant {x, y, ..}`.\n+    /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n     Struct(QPath, HirVec<Spanned<FieldPat>>, bool),\n \n     /// A tuple struct/variant pattern `Variant(x, y, .., z)`.\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n-    /// 0 <= position <= subpats.len()\n+    /// `0 <= position <= subpats.len()`\n     TupleStruct(QPath, HirVec<P<Pat>>, Option<usize>),\n \n     /// A path pattern for an unit struct/variant or a (maybe-associated) constant.\n     Path(QPath),\n \n-    /// A tuple pattern `(a, b)`.\n+    /// A tuple pattern (e.g., `(a, b)`).\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n-    /// 0 <= position <= subpats.len()\n+    /// `0 <= position <= subpats.len()`\n     Tuple(HirVec<P<Pat>>, Option<usize>),\n-    /// A `box` pattern\n+    /// A `box` pattern.\n     Box(P<Pat>),\n-    /// A reference pattern, e.g., `&mut (a, b)`\n+    /// A reference pattern (e.g., `&mut (a, b)`).\n     Ref(P<Pat>, Mutability),\n-    /// A literal\n+    /// A literal.\n     Lit(P<Expr>),\n-    /// A range pattern, e.g., `1...2` or `1..2`\n+    /// A range pattern (e.g., `1...2` or `1..2`).\n     Range(P<Expr>, P<Expr>, RangeEnd),\n     /// `[a, b, ..i, y, z]` is represented as:\n-    ///     `PatKind::Slice(box [a, b], Some(i), box [y, z])`\n+    ///     `PatKind::Slice(box [a, b], Some(i), box [y, z])`.\n     Slice(HirVec<P<Pat>>, Option<P<Pat>>, HirVec<P<Pat>>),\n }\n \n@@ -967,7 +968,7 @@ pub enum Mutability {\n }\n \n impl Mutability {\n-    /// Return MutMutable only if both arguments are mutable.\n+    /// Returns `MutMutable` only if both arguments are mutable.\n     pub fn and(self, other: Self) -> Self {\n         match self {\n             MutMutable => other,\n@@ -978,41 +979,41 @@ impl Mutability {\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash)]\n pub enum BinOpKind {\n-    /// The `+` operator (addition)\n+    /// The `+` operator (addition).\n     Add,\n-    /// The `-` operator (subtraction)\n+    /// The `-` operator (subtraction).\n     Sub,\n-    /// The `*` operator (multiplication)\n+    /// The `*` operator (multiplication).\n     Mul,\n-    /// The `/` operator (division)\n+    /// The `/` operator (division).\n     Div,\n-    /// The `%` operator (modulus)\n+    /// The `%` operator (modulus).\n     Rem,\n-    /// The `&&` operator (logical and)\n+    /// The `&&` operator (logical and).\n     And,\n-    /// The `||` operator (logical or)\n+    /// The `||` operator (logical or).\n     Or,\n-    /// The `^` operator (bitwise xor)\n+    /// The `^` operator (bitwise xor).\n     BitXor,\n-    /// The `&` operator (bitwise and)\n+    /// The `&` operator (bitwise and).\n     BitAnd,\n-    /// The `|` operator (bitwise or)\n+    /// The `|` operator (bitwise or).\n     BitOr,\n-    /// The `<<` operator (shift left)\n+    /// The `<<` operator (shift left).\n     Shl,\n-    /// The `>>` operator (shift right)\n+    /// The `>>` operator (shift right).\n     Shr,\n-    /// The `==` operator (equality)\n+    /// The `==` operator (equality).\n     Eq,\n-    /// The `<` operator (less than)\n+    /// The `<` operator (less than).\n     Lt,\n-    /// The `<=` operator (less than or equal to)\n+    /// The `<=` operator (less than or equal to).\n     Le,\n-    /// The `!=` operator (not equal to)\n+    /// The `!=` operator (not equal to).\n     Ne,\n-    /// The `>=` operator (greater than or equal to)\n+    /// The `>=` operator (greater than or equal to).\n     Ge,\n-    /// The `>` operator (greater than)\n+    /// The `>` operator (greater than).\n     Gt,\n }\n \n@@ -1077,7 +1078,7 @@ impl BinOpKind {\n         }\n     }\n \n-    /// Returns `true` if the binary operator takes its arguments by value\n+    /// Returns `true` if the binary operator takes its arguments by value.\n     pub fn is_by_value(self) -> bool {\n         !self.is_comparison()\n     }\n@@ -1112,11 +1113,11 @@ pub type BinOp = Spanned<BinOpKind>;\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, Hash)]\n pub enum UnOp {\n-    /// The `*` operator for dereferencing\n+    /// The `*` operator (deferencing).\n     UnDeref,\n-    /// The `!` operator for logical inversion\n+    /// The `!` operator (logical negation).\n     UnNot,\n-    /// The `-` operator for negation\n+    /// The `-` operator (negation).\n     UnNeg,\n }\n \n@@ -1129,7 +1130,7 @@ impl UnOp {\n         }\n     }\n \n-    /// Returns `true` if the unary operator takes its argument by value\n+    /// Returns `true` if the unary operator takes its argument by value.\n     pub fn is_by_value(self) -> bool {\n         match self {\n             UnNeg | UnNot => true,\n@@ -1138,7 +1139,7 @@ impl UnOp {\n     }\n }\n \n-/// A statement\n+/// A statement.\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Stmt {\n     pub id: NodeId,\n@@ -1156,15 +1157,15 @@ impl fmt::Debug for Stmt {\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub enum StmtKind {\n-    /// A local (let) binding:\n+    /// A local (`let`) binding.\n     Local(P<Local>),\n-    /// An item binding:\n+    /// An item binding.\n     Item(P<ItemId>),\n \n-    /// Expr without trailing semi-colon (must have unit type):\n+    /// An expression without a trailing semi-colon (must have unit type).\n     Expr(P<Expr>),\n \n-    /// Expr with trailing semi-colon (may have any type):\n+    /// An expression with a trailing semi-colon (may have any type).\n     Semi(P<Expr>),\n }\n \n@@ -1179,12 +1180,12 @@ impl StmtKind {\n     }\n }\n \n-/// Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`\n+/// Represents a `let` statement (i.e., `let <pat>:<ty> = <expr>;`).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Local {\n     pub pat: P<Pat>,\n     pub ty: Option<P<Ty>>,\n-    /// Initializer expression to set the value, if any\n+    /// Initializer expression to set the value, if any.\n     pub init: Option<P<Expr>>,\n     pub id: NodeId,\n     pub hir_id: HirId,\n@@ -1193,7 +1194,7 @@ pub struct Local {\n     pub source: LocalSource,\n }\n \n-/// represents one arm of a 'match'\n+/// Represents a single arm of a `match` expression.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Arm {\n     pub attrs: HirVec<Attribute>,\n@@ -1419,16 +1420,16 @@ impl fmt::Debug for Expr {\n pub enum ExprKind {\n     /// A `box x` expression.\n     Box(P<Expr>),\n-    /// An array (`[a, b, c, d]`)\n+    /// An array (e.g., `[a, b, c, d]`).\n     Array(HirVec<Expr>),\n-    /// A function call\n+    /// A function call.\n     ///\n     /// The first field resolves to the function itself (usually an `ExprKind::Path`),\n     /// and the second field is the list of arguments.\n     /// This also represents calling the constructor of\n     /// tuple-like ADTs such as tuple structs and enum variants.\n     Call(P<Expr>, HirVec<Expr>),\n-    /// A method call (`x.foo::<'static, Bar, Baz>(a, b, c, d)`)\n+    /// A method call (e.g., `x.foo::<'static, Bar, Baz>(a, b, c, d)`).\n     ///\n     /// The `PathSegment`/`Span` represent the method name and its generic arguments\n     /// (within the angle brackets).\n@@ -1438,63 +1439,64 @@ pub enum ExprKind {\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n     /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d])`.\n     MethodCall(PathSegment, Span, HirVec<Expr>),\n-    /// A tuple (`(a, b, c ,d)`)\n+    /// A tuple (e.g., `(a, b, c ,d)`).\n     Tup(HirVec<Expr>),\n-    /// A binary operation (For example: `a + b`, `a * b`)\n+    /// A binary operation (e.g., `a + b`, `a * b`).\n     Binary(BinOp, P<Expr>, P<Expr>),\n-    /// A unary operation (For example: `!x`, `*x`)\n+    /// A unary operation (e.g., `!x`, `*x`).\n     Unary(UnOp, P<Expr>),\n-    /// A literal (For example: `1`, `\"foo\"`)\n+    /// A literal (e.g., `1`, `\"foo\"`).\n     Lit(Lit),\n-    /// A cast (`foo as f64`)\n+    /// A cast (e.g., `foo as f64`).\n     Cast(P<Expr>, P<Ty>),\n+    /// A type reference (e.g., `Foo`).\n     Type(P<Expr>, P<Ty>),\n-    /// An `if` block, with an optional else block\n+    /// An `if` block, with an optional else block.\n     ///\n-    /// `if expr { expr } else { expr }`\n+    /// I.e., `if <expr> { <expr> } else { <expr> }`.\n     If(P<Expr>, P<Expr>, Option<P<Expr>>),\n     /// A while loop, with an optional label\n     ///\n-    /// `'label: while expr { block }`\n+    /// I.e., `'label: while expr { <block> }`.\n     While(P<Expr>, P<Block>, Option<Label>),\n-    /// Conditionless loop (can be exited with break, continue, or return)\n+    /// A conditionless loop (can be exited with `break`, `continue`, or `return`).\n     ///\n-    /// `'label: loop { block }`\n+    /// I.e., `'label: loop { <block> }`.\n     Loop(P<Block>, Option<Label>, LoopSource),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind.\n     Match(P<Expr>, HirVec<Arm>, MatchSource),\n-    /// A closure (for example, `move |a, b, c| {a + b + c}`).\n+    /// A closure (e.g., `move |a, b, c| {a + b + c}`).\n     ///\n-    /// The final span is the span of the argument block `|...|`\n+    /// The final span is the span of the argument block `|...|`.\n     ///\n     /// This may also be a generator literal, indicated by the final boolean,\n-    /// in that case there is an GeneratorClause.\n+    /// in that case there is an `GeneratorClause`.\n     Closure(CaptureClause, P<FnDecl>, BodyId, Span, Option<GeneratorMovability>),\n-    /// A block (`'label: { ... }`)\n+    /// A block (e.g., `'label: { ... }`).\n     Block(P<Block>, Option<Label>),\n \n-    /// An assignment (`a = foo()`)\n+    /// An assignment (e.g., `a = foo()`).\n     Assign(P<Expr>, P<Expr>),\n-    /// An assignment with an operator\n+    /// An assignment with an operator.\n     ///\n-    /// For example, `a += 1`.\n+    /// E.g., `a += 1`.\n     AssignOp(BinOp, P<Expr>, P<Expr>),\n-    /// Access of a named (`obj.foo`) or unnamed (`obj.0`) struct or tuple field\n+    /// Access of a named (e.g., `obj.foo`) or unnamed (e.g., `obj.0`) struct or tuple field.\n     Field(P<Expr>, Ident),\n-    /// An indexing operation (`foo[2]`)\n+    /// An indexing operation (`foo[2]`).\n     Index(P<Expr>, P<Expr>),\n \n     /// Path to a definition, possibly containing lifetime or type parameters.\n     Path(QPath),\n \n-    /// A referencing operation (`&a` or `&mut a`)\n+    /// A referencing operation (i.e., `&a` or `&mut a`).\n     AddrOf(Mutability, P<Expr>),\n-    /// A `break`, with an optional label to break\n+    /// A `break`, with an optional label to break.\n     Break(Destination, Option<P<Expr>>),\n-    /// A `continue`, with an optional label\n+    /// A `continue`, with an optional label.\n     Continue(Destination),\n-    /// A `return`, with an optional value to be returned\n+    /// A `return`, with an optional value to be returned.\n     Ret(Option<P<Expr>>),\n \n     /// Inline assembly (from `asm!`), with its outputs and inputs.\n@@ -1512,10 +1514,10 @@ pub enum ExprKind {\n     /// to be repeated; the second is the number of times to repeat it.\n     Repeat(P<Expr>, AnonConst),\n \n-    /// A suspension point for generators. This is `yield <expr>` in Rust.\n+    /// A suspension point for generators (i.e., `yield <expr>`).\n     Yield(P<Expr>),\n \n-    /// Placeholder for an expression that wasn't syntactically well formed in some way.\n+    /// A placeholder for an expression that wasn't syntactically well formed in some way.\n     Err,\n }\n \n@@ -1525,12 +1527,12 @@ pub enum QPath {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n     /// type, if the path points to an associated item in a trait.\n     ///\n-    /// e.g., an unqualified path like `Clone::clone` has `None` for `Self`,\n+    /// E.g., an unqualified path like `Clone::clone` has `None` for `Self`,\n     /// while `<Vec<T> as Clone>::clone` has `Some(Vec<T>)` for `Self`,\n     /// even though they both have the same two-segment `Clone::clone` `Path`.\n     Resolved(Option<P<Ty>>, P<Path>),\n \n-    /// Type-related paths, e.g., `<T>::default` or `<T>::Output`.\n+    /// Type-related paths (e.g., `<T>::default` or `<T>::Output`).\n     /// Will be resolved by type-checking to an associated item.\n     ///\n     /// UFCS source paths can desugar into this, with `Vec::new` turning into\n@@ -1539,41 +1541,41 @@ pub enum QPath {\n     TypeRelative(P<Ty>, P<PathSegment>)\n }\n \n-/// Hints at the original code for a let statement\n+/// Hints at the original code for a let statement.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum LocalSource {\n-    /// A `match _ { .. }`\n+    /// A `match _ { .. }`.\n     Normal,\n-    /// A desugared `for _ in _ { .. }` loop\n+    /// A desugared `for _ in _ { .. }` loop.\n     ForLoopDesugar,\n }\n \n-/// Hints at the original code for a `match _ { .. }`\n+/// Hints at the original code for a `match _ { .. }`.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum MatchSource {\n-    /// A `match _ { .. }`\n+    /// A `match _ { .. }`.\n     Normal,\n-    /// An `if let _ = _ { .. }` (optionally with `else { .. }`)\n+    /// An `if let _ = _ { .. }` (optionally with `else { .. }`).\n     IfLetDesugar {\n         contains_else_clause: bool,\n     },\n     /// A `while let _ = _ { .. }` (which was desugared to a\n-    /// `loop { match _ { .. } }`)\n+    /// `loop { match _ { .. } }`).\n     WhileLetDesugar,\n-    /// A desugared `for _ in _ { .. }` loop\n+    /// A desugared `for _ in _ { .. }` loop.\n     ForLoopDesugar,\n-    /// A desugared `?` operator\n+    /// A desugared `?` operator.\n     TryDesugar,\n }\n \n-/// The loop type that yielded an ExprKind::Loop\n+/// The loop type that yielded an `ExprKind::Loop`.\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum LoopSource {\n-    /// A `loop { .. }` loop\n+    /// A `loop { .. }` loop.\n     Loop,\n-    /// A `while let _ = _ { .. }` loop\n+    /// A `while let _ = _ { .. }` loop.\n     WhileLet,\n-    /// A `for _ in _ { .. }` loop\n+    /// A `for _ in _ { .. }` loop.\n     ForLoop,\n }\n \n@@ -1739,7 +1741,7 @@ impl fmt::Debug for Ty {\n     }\n }\n \n-/// Not represented directly in the AST, referred to by name through a ty_path.\n+/// Not represented directly in the AST; referred to by name through a `ty_path`.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum PrimTy {\n     Int(IntTy),\n@@ -1766,38 +1768,38 @@ pub struct ExistTy {\n     pub impl_trait_fn: Option<DefId>,\n }\n \n+/// The various kinds of types recognized by the compiler.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-/// The different kinds of types recognized by the compiler\n pub enum TyKind {\n-    /// A variable length slice (`[T]`)\n+    /// A variable length slice (i.e., `[T]`).\n     Slice(P<Ty>),\n-    /// A fixed length array (`[T; n]`)\n+    /// A fixed length array (i.e., `[T; n]`).\n     Array(P<Ty>, AnonConst),\n-    /// A raw pointer (`*const T` or `*mut T`)\n+    /// A raw pointer (i.e., `*const T` or `*mut T`).\n     Ptr(MutTy),\n-    /// A reference (`&'a T` or `&'a mut T`)\n+    /// A reference (i.e., `&'a T` or `&'a mut T`).\n     Rptr(Lifetime, MutTy),\n-    /// A bare function (e.g., `fn(usize) -> bool`)\n+    /// A bare function (e.g., `fn(usize) -> bool`).\n     BareFn(P<BareFnTy>),\n-    /// The never type (`!`)\n+    /// The never type (`!`).\n     Never,\n-    /// A tuple (`(A, B, C, D,...)`)\n+    /// A tuple (`(A, B, C, D,...)`).\n     Tup(HirVec<Ty>),\n     /// A path to a type definition (`module::module::...::Type`), or an\n-    /// associated type, e.g., `<Vec<T> as Trait>::Type` or `<T>::Target`.\n+    /// associated type (e.g., `<Vec<T> as Trait>::Type` or `<T>::Target`).\n     ///\n     /// Type parameters may be stored in each `PathSegment`.\n     Path(QPath),\n     /// A type definition itself. This is currently only used for the `existential type`\n     /// item that `impl Trait` in return position desugars to.\n     ///\n-    /// The generic arg list are the lifetimes (and in the future possibly parameters) that are\n-    /// actually bound on the `impl Trait`.\n+    /// The generic argument list contains the lifetimes (and in the future possibly parameters)\n+    /// that are actually bound on the `impl Trait`.\n     Def(ItemId, HirVec<GenericArg>),\n     /// A trait object type `Bound1 + Bound2 + Bound3`\n     /// where `Bound` is a trait or a lifetime.\n     TraitObject(HirVec<PolyTraitRef>, Lifetime),\n-    /// Unused for now\n+    /// Unused for now.\n     Typeof(AnonConst),\n     /// `TyKind::Infer` means the type should be inferred instead of it having been\n     /// specified. This can appear anywhere in a type.\n@@ -1827,15 +1829,15 @@ pub struct InlineAsm {\n     pub ctxt: SyntaxContext,\n }\n \n-/// represents an argument in a function header\n+/// Represents an argument in a function header.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Arg {\n     pub pat: P<Pat>,\n     pub id: NodeId,\n     pub hir_id: HirId,\n }\n \n-/// Represents the header (not the body) of a function declaration\n+/// Represents the header (not the body) of a function declaration.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct FnDecl {\n     pub inputs: HirVec<Ty>,\n@@ -1958,7 +1960,7 @@ pub enum FunctionRetTy {\n     /// closures default to inference. Span points to where return\n     /// type would be inserted.\n     DefaultReturn(Span),\n-    /// Everything else\n+    /// Everything else.\n     Return(P<Ty>),\n }\n \n@@ -2011,7 +2013,7 @@ pub struct VariantKind {\n     pub ident: Ident,\n     pub attrs: HirVec<Attribute>,\n     pub data: VariantData,\n-    /// Explicit discriminant, e.g., `Foo = 1`\n+    /// Explicit discriminant (e.g., `Foo = 1`).\n     pub disr_expr: Option<AnonConst>,\n }\n \n@@ -2047,7 +2049,7 @@ pub struct TraitRef {\n }\n \n impl TraitRef {\n-    /// Get the `DefId` of the referenced trait. It _must_ actually be a trait or trait alias.\n+    /// Gets the `DefId` of the referenced trait. It _must_ actually be a trait or trait alias.\n     pub fn trait_def_id(&self) -> DefId {\n         match self.path.def {\n             Def::Trait(did) => did,\n@@ -2062,10 +2064,10 @@ impl TraitRef {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct PolyTraitRef {\n-    /// The `'a` in `<'a> Foo<&'a T>`\n+    /// The `'a` in `<'a> Foo<&'a T>`.\n     pub bound_generic_params: HirVec<GenericParam>,\n \n-    /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`\n+    /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`.\n     pub trait_ref: TraitRef,\n \n     pub span: Span,\n@@ -2223,7 +2225,7 @@ pub struct FnHeader {\n pub enum ItemKind {\n     /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n-    /// e.g., `extern crate foo` or `extern crate foo_bar as foo`\n+    /// E.g., `extern crate foo` or `extern crate foo_bar as foo`.\n     ExternCrate(Option<Name>),\n \n     /// `use foo::bar::*;` or `use foo::bar::baz as quux;`\n@@ -2320,7 +2322,7 @@ impl ItemKind {\n /// contains the item's id, naturally, but also the item's name and\n /// some other high-level details (like whether it is an associated\n /// type or method, and whether it is public). This allows other\n-/// passes to find the impl they want without loading the id (which\n+/// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct TraitItemRef {\n@@ -2332,10 +2334,10 @@ pub struct TraitItemRef {\n }\n \n /// A reference from an impl to one of its associated items. This\n-/// contains the item's id, naturally, but also the item's name and\n+/// contains the item's ID, naturally, but also the item's name and\n /// some other high-level details (like whether it is an associated\n /// type or method, and whether it is public). This allows other\n-/// passes to find the impl they want without loading the id (which\n+/// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ImplItemRef {\n@@ -2366,15 +2368,15 @@ pub struct ForeignItem {\n     pub vis: Visibility,\n }\n \n-/// An item within an `extern` block\n+/// An item within an `extern` block.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum ForeignItemKind {\n-    /// A foreign function\n+    /// A foreign function.\n     Fn(P<FnDecl>, HirVec<Ident>, Generics),\n     /// A foreign static item (`static ext: u8`), with optional mutability\n-    /// (the boolean is true when mutable)\n+    /// (the boolean is true when mutable).\n     Static(P<Ty>, bool),\n-    /// A foreign type\n+    /// A foreign type.\n     Type,\n }\n \n@@ -2458,36 +2460,37 @@ pub struct CodegenFnAttrs {\n bitflags! {\n     #[derive(RustcEncodable, RustcDecodable)]\n     pub struct CodegenFnAttrFlags: u32 {\n-        /// #[cold], a hint to LLVM that this function, when called, is never on\n-        /// the hot path\n+        /// `#[cold]`: a hint to LLVM that this function, when called, is never on\n+        /// the hot path.\n         const COLD                      = 1 << 0;\n-        /// #[allocator], a hint to LLVM that the pointer returned from this\n-        /// function is never null\n+        /// `#[allocator]`: a hint to LLVM that the pointer returned from this\n+        /// function is never null.\n         const ALLOCATOR                 = 1 << 1;\n-        /// #[unwind], an indicator that this function may unwind despite what\n-        /// its ABI signature may otherwise imply\n+        /// `#[unwind]`: an indicator that this function may unwind despite what\n+        /// its ABI signature may otherwise imply.\n         const UNWIND                    = 1 << 2;\n-        /// #[rust_allocator_nounwind], an indicator that an imported FFI\n+        /// `#[rust_allocator_nounwind]`, an indicator that an imported FFI\n         /// function will never unwind. Probably obsolete by recent changes with\n         /// #[unwind], but hasn't been removed/migrated yet\n         const RUSTC_ALLOCATOR_NOUNWIND  = 1 << 3;\n-        /// #[naked], indicates to LLVM that no function prologue/epilogue\n-        /// should be generated\n+        /// `#[naked]`: an indicator to LLVM that no function prologue/epilogue\n+        /// should be generated.\n         const NAKED                     = 1 << 4;\n-        /// #[no_mangle], the function's name should be the same as its symbol\n+        /// `#[no_mangle]`: an indicator that the function's name should be the same\n+        /// as its symbol.\n         const NO_MANGLE                 = 1 << 5;\n-        /// #[rustc_std_internal_symbol], and indicator that this symbol is a\n+        /// `#[rustc_std_internal_symbol]`: an indicator that this symbol is a\n         /// \"weird symbol\" for the standard library in that it has slightly\n         /// different linkage, visibility, and reachability rules.\n         const RUSTC_STD_INTERNAL_SYMBOL = 1 << 6;\n-        /// #[no_debug], indicates that no debugging information should be\n-        /// generated for this function by LLVM\n+        /// `#[no_debug]`: an indicator that no debugging information should be\n+        /// generated for this function by LLVM.\n         const NO_DEBUG                  = 1 << 7;\n-        /// #[thread_local], indicates a static is actually a thread local\n+        /// `#[thread_local]`: indicates a static is actually a thread local\n         /// piece of memory\n         const THREAD_LOCAL              = 1 << 8;\n-        /// #[used], indicates that LLVM can't eliminate this function (but the\n-        /// linker can!)\n+        /// `#[used]`: indicates that LLVM can't eliminate this function (but the\n+        /// linker can!).\n         const USED                      = 1 << 9;\n     }\n }\n@@ -2506,7 +2509,7 @@ impl CodegenFnAttrs {\n         }\n     }\n \n-    /// True if `#[inline]` or `#[inline(always)]` is present.\n+    /// Returns `true` if `#[inline]` or `#[inline(always)]` is present.\n     pub fn requests_inline(&self) -> bool {\n         match self.inline {\n             InlineAttr::Hint | InlineAttr::Always => true,"}, {"sha": "e2df290a455c4afb6f0118072d003f8b87e4f451", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -129,7 +129,7 @@ impl hir::Pat {\n         }\n     }\n \n-    /// Return variants that are necessary to exist for the pattern to match.\n+    /// Returns variants that are necessary to exist for the pattern to match.\n     pub fn necessary_variants(&self) -> Vec<DefId> {\n         let mut variants = vec![];\n         self.walk(|p| {\n@@ -154,11 +154,9 @@ impl hir::Pat {\n \n     /// Checks if the pattern contains any `ref` or `ref mut` bindings, and if\n     /// yes whether it contains mutable or just immutables ones.\n-    ///\n-    /// FIXME(tschottdorf): this is problematic as the HIR is being scraped, but\n-    /// ref bindings are be implicit after #42640 (default match binding modes).\n-    ///\n-    /// See #44848.\n+    //\n+    // FIXME(tschottdorf): this is problematic as the HIR is being scraped, but\n+    // ref bindings are be implicit after #42640 (default match binding modes). See issue #44848.\n     pub fn contains_explicit_ref_binding(&self) -> Option<hir::Mutability> {\n         let mut result = None;\n         self.each_binding(|annotation, _, _, _| {"}, {"sha": "34cd3ae5427e0ff849f6456615533a396bb3f5a6", "filename": "src/librustc/infer/at.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fat.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,6 +1,6 @@\n-//! A nice interface for working with the infcx.  The basic idea is to\n+//! A nice interface for working with the infcx. The basic idea is to\n //! do `infcx.at(cause, param_env)`, which sets the \"cause\" of the\n-//! operation as well as the surrounding parameter environment.  Then\n+//! operation as well as the surrounding parameter environment. Then\n //! you can do something like `.sub(a, b)` or `.eq(a, b)` to create a\n //! subtype or equality relationship respectively. The first argument\n //! is always the \"expected\" output from the POV of diagnostics.\n@@ -78,7 +78,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Make `a <: b` where `a` may or may not be expected\n+    /// Makes `a <: b`, where `a` may or may not be expected.\n     pub fn sub_exp<T>(self,\n                       a_is_expected: bool,\n                       a: T,\n@@ -89,7 +89,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         self.trace_exp(a_is_expected, a, b).sub(&a, &b)\n     }\n \n-    /// Make `actual <: expected`. For example, if type-checking a\n+    /// Makes `actual <: expected`. For example, if type-checking a\n     /// call like `foo(x)`, where `foo: fn(i32)`, you might have\n     /// `sup(i32, x)`, since the \"expected\" type is the type that\n     /// appears in the signature.\n@@ -102,7 +102,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         self.sub_exp(false, actual, expected)\n     }\n \n-    /// Make `expected <: actual`\n+    /// Makes `expected <: actual`.\n     pub fn sub<T>(self,\n                   expected: T,\n                   actual: T)\n@@ -112,7 +112,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         self.sub_exp(true, expected, actual)\n     }\n \n-    /// Make `expected <: actual`\n+    /// Makes `expected <: actual`.\n     pub fn eq_exp<T>(self,\n                      a_is_expected: bool,\n                      a: T,\n@@ -123,7 +123,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         self.trace_exp(a_is_expected, a, b).eq(&a, &b)\n     }\n \n-    /// Make `expected <: actual`\n+    /// Makes `expected <: actual`.\n     pub fn eq<T>(self,\n                  expected: T,\n                  actual: T)\n@@ -155,7 +155,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Compute the least-upper-bound, or mutual supertype, of two\n+    /// Computes the least-upper-bound, or mutual supertype, of two\n     /// values. The order of the arguments doesn't matter, but since\n     /// this can result in an error (e.g., if asked to compute LUB of\n     /// u32 and i32), it is meaningful to call one of them the\n@@ -169,7 +169,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n         self.trace(expected, actual).lub(&expected, &actual)\n     }\n \n-    /// Compute the greatest-lower-bound, or mutual subtype, of two\n+    /// Computes the greatest-lower-bound, or mutual subtype, of two\n     /// values. As with `lub` order doesn't matter, except for error\n     /// cases.\n     pub fn glb<T>(self,\n@@ -210,9 +210,9 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> Trace<'a, 'gcx, 'tcx> {\n-    /// Make `a <: b` where `a` may or may not be expected (if\n+    /// Makes `a <: b` where `a` may or may not be expected (if\n     /// `a_is_expected` is true, then `a` is expected).\n-    /// Make `expected <: actual`\n+    /// Makes `expected <: actual`.\n     pub fn sub<T>(self,\n                   a: &T,\n                   b: &T)\n@@ -229,7 +229,7 @@ impl<'a, 'gcx, 'tcx> Trace<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    /// Make `a == b`; the expectation is set by the call to\n+    /// Makes `a == b`; the expectation is set by the call to\n     /// `trace()`.\n     pub fn eq<T>(self,\n                  a: &T,"}, {"sha": "d06334c3ba64377dba6a44cbb9986d0d0c477fd9", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -112,14 +112,14 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     /// A hacky variant of `canonicalize_query` that does not\n-    /// canonicalize `'static`.  Unfortunately, the existing leak\n+    /// canonicalize `'static`. Unfortunately, the existing leak\n     /// check treaks `'static` differently in some cases (see also\n     /// #33684), so if we are performing an operation that may need to\n     /// prove \"leak-check\" related things, we leave `'static`\n     /// alone.\n-    ///\n-    /// FIXME(#48536) -- once we have universes, we can remove this and just use\n-    /// `canonicalize_query`.\n+    //\n+    // FIXME(#48536): once we have universes, we can remove this and just use\n+    // `canonicalize_query`.\n     pub fn canonicalize_hr_query_hack<V>(\n         &self,\n         value: &V,\n@@ -595,7 +595,7 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n             .var_universe(vid)\n     }\n \n-    /// Create a canonical variable (with the given `info`)\n+    /// Creates a canonical variable (with the given `info`)\n     /// representing the region `r`; return a region referencing it.\n     fn canonical_var_for_region(\n         &mut self,"}, {"sha": "613e153ae33d4c73d0659f4c230aa715a3c594a4", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -289,7 +289,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     ///\n     /// This is only meant to be invoked as part of constructing an\n     /// inference context at the start of a query (see\n-    /// `InferCtxtBuilder::enter_with_canonical`).  It basically\n+    /// `InferCtxtBuilder::enter_with_canonical`). It basically\n     /// brings the canonical value \"into scope\" within your new infcx.\n     ///\n     /// At the end of processing, the substitution S (once\n@@ -424,7 +424,7 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n         self.var_values.len()\n     }\n \n-    /// Make an identity substitution from this one: each bound var\n+    /// Makes an identity substitution from this one: each bound var\n     /// is matched to the same bound var, preserving the original kinds.\n     /// For example, if we have:\n     /// `self.var_values == [Type(u32), Lifetime('a), Type(u64)]`"}, {"sha": "aef0152b6ed7332764057c554fcdc6b65c09cd43", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -119,7 +119,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// If you DO want to keep track of pending obligations (which\n     /// include all region obligations, so this includes all cases\n     /// that care about regions) with this function, you have to\n-    /// do it yourself, by e.g. having them be a part of the answer.\n+    /// do it yourself, by e.g., having them be a part of the answer.\n     pub fn make_query_response_ignoring_pending_obligations<T>(\n         &self,\n         inference_vars: CanonicalVarValues<'tcx>,\n@@ -267,7 +267,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     ///   they should be ignored).\n     /// - It **can happen** (though it rarely does currently) that\n     ///   equating types and things will give rise to subobligations\n-    ///   that must be processed.  In this case, those subobligations\n+    ///   that must be processed. In this case, those subobligations\n     ///   are propagated back in the return value.\n     /// - Finally, the query result (of type `R`) is propagated back,\n     ///   after applying the substitution `S`.\n@@ -506,7 +506,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n \n     /// Given a \"guess\" at the values for the canonical variables in\n     /// the input, try to unify with the *actual* values found in the\n-    /// query result.  Often, but not always, this is a no-op, because\n+    /// query result. Often, but not always, this is a no-op, because\n     /// we already found the mapping in the \"guessing\" step.\n     ///\n     /// See also: `query_response_substitution_guess`"}, {"sha": "361fbfea09798efa0d3b9356f6fa878e0f55e459", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -165,8 +165,8 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n         Glb::new(self, a_is_expected)\n     }\n \n-    /// Here dir is either EqTo, SubtypeOf, or SupertypeOf. The\n-    /// idea is that we should ensure that the type `a_ty` is equal\n+    /// Here, `dir` is either `EqTo`, `SubtypeOf`, or `SupertypeOf`.\n+    /// The idea is that we should ensure that the type `a_ty` is equal\n     /// to, a subtype of, or a supertype of (respectively) the type\n     /// to which `b_vid` is bound.\n     ///\n@@ -280,7 +280,7 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n struct Generalizer<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n \n-    /// Span, used when creating new type variables and things.\n+    /// The span, used when creating new type variables and things.\n     span: Span,\n \n     /// The vid of the type variable that is in the process of being\n@@ -310,7 +310,7 @@ struct Generalization<'tcx> {\n     /// particular around 'bivariant' type parameters that are only\n     /// constrained by a where-clause. As an example, imagine a type:\n     ///\n-    ///     struct Foo<A, B> where A: Iterator<Item=B> {\n+    ///     struct Foo<A, B> where A: Iterator<Item = B> {\n     ///         data: A\n     ///     }\n     ///\n@@ -323,7 +323,7 @@ struct Generalization<'tcx> {\n     /// <: ?C`, but no particular relationship between `?B` and `?D`\n     /// (after all, we do not know the variance of the normalized form\n     /// of `A::Item` with respect to `A`). If we do nothing else, this\n-    /// may mean that `?D` goes unconstrained (as in #41677).  So, in\n+    /// may mean that `?D` goes unconstrained (as in #41677). So, in\n     /// this scenario where we create a new type variable in a\n     /// bivariant context, we set the `needs_wf` flag to true. This\n     /// will force the calling code to check that `WF(Foo<?C, ?D>)`"}, {"sha": "89237b34c7f6b1cde1f3fc0967f095feadf0bb73", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -659,7 +659,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         None\n     }\n \n-    /// Add a `,` to the type representation only if it is appropriate.\n+    /// Adds a `,` to the type representation only if it is appropriate.\n     fn push_comma(\n         &self,\n         value: &mut DiagnosticStyledString,\n@@ -715,7 +715,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         substs.truncate_to(self.tcx, &generics)\n     }\n \n-    /// Compare two given types, eliding parts that are the same between them and highlighting\n+    /// Compares two given types, eliding parts that are the same between them and highlighting\n     /// relevant differences, and return two representation of those types for highlighted printing.\n     fn cmp(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> (DiagnosticStyledString, DiagnosticStyledString) {\n         fn equals<'tcx>(a: &Ty<'tcx>, b: &Ty<'tcx>) -> bool {"}, {"sha": "5d5a9b36087a256db4781bb480a52e94a9af2c12", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n     ///     x.push(y);\n     ///     ^ ...but data from `y` flows into `x` here\n     /// }\n-    /// ````\n+    /// ```\n     ///\n     /// It will later be extended to trait objects.\n     pub(super) fn try_report_anon_anon_conflict(&self) -> Option<ErrorReported> {"}, {"sha": "5f6a8802b4defbe7a8b9f7b5e66a41d4384b6f80", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -22,13 +22,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// closure `f`. In our example above, what this closure will do\n     /// is to unify the expectation (`Option<&[u32]>`) with the actual\n     /// return type (`Option<?T>`, where `?T` represents the variable\n-    /// instantiated for `T`).  This will cause `?T` to be unified\n+    /// instantiated for `T`). This will cause `?T` to be unified\n     /// with `&?a [u32]`, where `?a` is a fresh lifetime variable. The\n     /// input type (`?T`) is then returned by `f()`.\n     ///\n     /// At this point, `fudge_regions_if_ok` will normalize all type\n     /// variables, converting `?T` to `&?a [u32]` and end the\n-    /// snapshot.  The problem is that we can't just return this type\n+    /// snapshot. The problem is that we can't just return this type\n     /// out, because it references the region variable `?a`, and that\n     /// region variable was popped when we popped the snapshot.\n     ///"}, {"sha": "7f01078737d73cd3af8e7f0ff8acd17df1faaf53", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -54,7 +54,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    /// Replace all regions (resp. types) bound by `binder` with placeholder\n+    /// Replaces all regions (resp. types) bound by `binder` with placeholder\n     /// regions (resp. types) and return a map indicating which bound-region\n     /// placeholder region. This is the first step of checking subtyping\n     /// when higher-ranked things are involved."}, {"sha": "e40bb9724076354dfc36734dcfd90b0d0832b2d3", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,7 +1,7 @@\n //! # Lattice Variables\n //!\n //! This file contains generic code for operating on inference variables\n-//! that are characterized by an upper- and lower-bound.  The logic and\n+//! that are characterized by an upper- and lower-bound. The logic and\n //! reasoning is explained in detail in the large comment in `infer.rs`.\n //!\n //! The code in here is defined quite generically so that it can be\n@@ -13,7 +13,7 @@\n //!\n //! Although all the functions are generic, we generally write the\n //! comments in a way that is specific to type variables and the LUB\n-//! operation.  It's just easier that way.\n+//! operation. It's just easier that way.\n //!\n //! In general all of the functions are defined parametrically\n //! over a `LatticeValue`, which is a value defined with respect to"}, {"sha": "03ade8825368273ff756a282d20cf7a6352bf8c4", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,4 +1,4 @@\n-//! The code to do lexical region resolution.\n+//! Lexical region resolution.\n \n use crate::infer::region_constraints::Constraint;\n use crate::infer::region_constraints::GenericKind;\n@@ -492,20 +492,20 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n             match *value {\n                 VarValue::Value(_) => { /* Inference successful */ }\n                 VarValue::ErrorValue => {\n-                    /* Inference impossible, this value contains\n+                    /* Inference impossible: this value contains\n                        inconsistent constraints.\n \n                        I think that in this case we should report an\n-                       error now---unlike the case above, we can't\n+                       error now -- unlike the case above, we can't\n                        wait to see whether the user needs the result\n-                       of this variable.  The reason is that the mere\n+                       of this variable. The reason is that the mere\n                        existence of this variable implies that the\n                        region graph is inconsistent, whether or not it\n                        is used.\n \n                        For example, we may have created a region\n                        variable that is the GLB of two other regions\n-                       which do not have a GLB.  Even if that variable\n+                       which do not have a GLB. Even if that variable\n                        is not used, it implies that those two regions\n                        *should* have a GLB.\n "}, {"sha": "c183c1adb122d2ffccd83cabcdd235a62a452137", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -221,7 +221,7 @@ pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n /// replaced with.\n pub type PlaceholderMap<'tcx> = BTreeMap<ty::BoundRegion, ty::Region<'tcx>>;\n \n-/// See `error_reporting` module for more details\n+/// See the `error_reporting` module for more details.\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub enum ValuePairs<'tcx> {\n     Types(ExpectedFound<Ty<'tcx>>),\n@@ -233,7 +233,7 @@ pub enum ValuePairs<'tcx> {\n /// The trace designates the path through inference that we took to\n /// encounter an error or subtyping constraint.\n ///\n-/// See `error_reporting` module for more details.\n+/// See the `error_reporting` module for more details.\n #[derive(Clone)]\n pub struct TypeTrace<'tcx> {\n     cause: ObligationCause<'tcx>,\n@@ -454,9 +454,9 @@ impl fmt::Display for FixupError {\n     }\n }\n \n-/// Helper type of a temporary returned by tcx.infer_ctxt().\n+/// Helper type of a temporary returned by `tcx.infer_ctxt()`.\n /// Necessary because we can't write the following bound:\n-/// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(InferCtxt<'b, 'gcx, 'tcx>).\n+/// `F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(InferCtxt<'b, 'gcx, 'tcx>)`.\n pub struct InferCtxtBuilder<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     global_tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     arena: SyncDroplessArena,\n@@ -487,7 +487,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n     /// inference context that contains each of the bound values\n     /// within instantiated as a fresh variable. The `f` closure is\n     /// invoked with the new infcx, along with the instantiated value\n-    /// `V` and a substitution `S`.  This substitution `S` maps from\n+    /// `V` and a substitution `S`. This substitution `S` maps from\n     /// the bound values in `C` to their instantiated values in `V`\n     /// (in other words, `S(C) = V`).\n     pub fn enter_with_canonical<T, R>(\n@@ -563,7 +563,7 @@ impl<'tcx, T> InferOk<'tcx, T> {\n         }\n     }\n \n-    /// Extract `value`, registering any obligations into `fulfill_cx`\n+    /// Extracts `value`, registering any obligations into `fulfill_cx`.\n     pub fn into_value_registering_obligations(\n         self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n@@ -794,7 +794,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .commit(region_constraints_snapshot);\n     }\n \n-    /// Execute `f` and commit the bindings\n+    /// Executes `f` and commit the bindings.\n     pub fn commit_unconditionally<R, F>(&self, f: F) -> R\n     where\n         F: FnOnce() -> R,\n@@ -806,7 +806,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         r\n     }\n \n-    /// Execute `f` and commit the bindings if closure `f` returns `Ok(_)`\n+    /// Executes `f` and commit the bindings if closure `f` returns `Ok(_)`.\n     pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E>\n     where\n         F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> Result<T, E>,\n@@ -838,7 +838,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         r\n     }\n \n-    /// Execute `f` then unroll any bindings it creates\n+    /// Executes `f` then unroll any bindings it creates.\n     pub fn probe<R, F>(&self, f: F) -> R\n     where\n         F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n@@ -996,14 +996,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.float_unification_table.borrow_mut().new_key(None)\n     }\n \n-    /// Create a fresh region variable with the next available index.\n+    /// Creates a fresh region variable with the next available index.\n     /// The variable will be created in the maximum universe created\n     /// thus far, allowing it to name any region created thus far.\n     pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region<'tcx> {\n         self.next_region_var_in_universe(origin, self.universe())\n     }\n \n-    /// Create a fresh region variable with the next available index\n+    /// Creates a fresh region variable with the next available index\n     /// in the given universe; typically, you can use\n     /// `next_region_var` and just use the maximal universe.\n     pub fn next_region_var_in_universe(\n@@ -1069,8 +1069,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         Substs::for_item(self.tcx, def_id, |param, _| self.var_for_def(span, param))\n     }\n \n-    /// True if errors have been reported since this infcx was\n-    /// created.  This is sometimes used as a heuristic to skip\n+    /// Returns `true` if errors have been reported since this infcx was\n+    /// created. This is sometimes used as a heuristic to skip\n     /// reporting errors that often occur as a result of earlier\n     /// errors, but where it's hard to be 100% sure (e.g., unresolved\n     /// inference variables, regionck errors).\n@@ -1278,7 +1278,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         value.fold_with(&mut r)\n     }\n \n-    /// Returns true if `T` contains unresolved type variables. In the\n+    /// Returns `true` if `T` contains unresolved type variables. In the\n     /// process of visiting `T`, this will resolve (where possible)\n     /// type variables in `T`, but it never constructs the final,\n     /// resolved type, so it's more efficient than\n@@ -1361,7 +1361,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.replace_bound_vars(value, fld_r, fld_t)\n     }\n \n-    /// See `verify_generic_bound` method in `region_constraints`\n+    /// See the [`region_constraints::verify_generic_bound`] method.\n     pub fn verify_generic_bound(\n         &self,\n         origin: SubregionOrigin<'tcx>,\n@@ -1413,7 +1413,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         closure_kind_ty.to_opt_closure_kind()\n     }\n \n-    /// Obtain the signature of a closure.  For closures, unlike\n+    /// Obtain the signature of a closure. For closures, unlike\n     /// `tcx.fn_sig(def_id)`, this method will work during the\n     /// type-checking of the enclosing function and return the closure\n     /// signature in its partially inferred state.\n@@ -1458,8 +1458,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Clears the selection, evaluation, and projection caches. This is useful when\n-    /// repeatedly attempting to select an Obligation while changing only\n-    /// its ParamEnv, since FulfillmentContext doesn't use 'probe'\n+    /// repeatedly attempting to select an `Obligation` while changing only\n+    /// its `ParamEnv`, since `FulfillmentContext` doesn't use probing.\n     pub fn clear_caches(&self) {\n         self.selection_cache.clear();\n         self.evaluation_cache.clear();\n@@ -1470,7 +1470,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.universe.get()\n     }\n \n-    /// Create and return a fresh universe that extends all previous\n+    /// Creates and return a fresh universe that extends all previous\n     /// universes. Updates `self.universe` to that new universe.\n     pub fn create_next_universe(&self) -> ty::UniverseIndex {\n         let u = self.universe.get().next_universe();"}, {"sha": "f37e24b292e0351e172ad633fdc068df1ea75c3b", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -47,17 +47,17 @@ where\n \n     /// How are we relating `a` and `b`?\n     ///\n-    /// - covariant means `a <: b`\n-    /// - contravariant means `b <: a`\n-    /// - invariant means `a == b\n-    /// - bivariant means that it doesn't matter\n+    /// - Covariant means `a <: b`.\n+    /// - Contravariant means `b <: a`.\n+    /// - Invariant means `a == b.\n+    /// - Bivariant means that it doesn't matter.\n     ambient_variance: ty::Variance,\n \n     /// When we pass through a set of binders (e.g., when looking into\n-    /// a `fn` type), we push a new bound region scope onto here.  This\n+    /// a `fn` type), we push a new bound region scope onto here. This\n     /// will contain the instantiated region for each region in those\n     /// binders. When we then encounter a `ReLateBound(d, br)`, we can\n-    /// use the debruijn index `d` to find the right scope, and then\n+    /// use the De Bruijn index `d` to find the right scope, and then\n     /// bound region name `br` to find the specific instantiation from\n     /// within that scope. See `replace_bound_region`.\n     ///\n@@ -114,7 +114,7 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// Define the normalization strategy to use, eager or lazy.\n     fn normalization() -> NormalizationStrategy;\n \n-    /// Enable some optimizations if we do not expect inference variables\n+    /// Enables some optimizations if we do not expect inference variables\n     /// in the RHS of the relation.\n     fn forbid_inference_vars() -> bool;\n }\n@@ -208,7 +208,7 @@ where\n     /// When we encounter binders during the type traversal, we record\n     /// the value to substitute for each of the things contained in\n     /// that binder. (This will be either a universal placeholder or\n-    /// an existential inference variable.) Given the debruijn index\n+    /// an existential inference variable.) Given the De Bruijn index\n     /// `debruijn` (and name `br`) of some binder we have now\n     /// encountered, this routine finds the value that we instantiated\n     /// the region with; to do so, it indexes backwards into the list"}, {"sha": "0e2c49a00dafe90a2dc2887586940d93deebee27", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -46,7 +46,7 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// lifetime parameter on `foo`.)\n     pub concrete_ty: Ty<'tcx>,\n \n-    /// True if the `impl Trait` bounds include region bounds.\n+    /// Returns `true` if the `impl Trait` bounds include region bounds.\n     /// For example, this would be true for:\n     ///\n     ///     fn foo<'a, 'b, 'c>() -> impl Trait<'c> + 'a + 'b\n@@ -71,7 +71,7 @@ pub struct OpaqueTypeDecl<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    /// Replace all opaque types in `value` with fresh inference variables\n+    /// Replaces all opaque types in `value` with fresh inference variables\n     /// and creates appropriate obligations. For example, given the input:\n     ///\n     ///     impl Iterator<Item = impl Debug>\n@@ -88,7 +88,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// # Parameters\n     ///\n-    /// - `parent_def_id` -- the def-id of the function in which the opaque type\n+    /// - `parent_def_id` -- the `DefId` of the function in which the opaque type\n     ///   is defined\n     /// - `body_id` -- the body-id with which the resulting obligations should\n     ///   be associated\n@@ -132,7 +132,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// # The Problem\n     ///\n-    /// Let's work through an example to explain how it works.  Assume\n+    /// Let's work through an example to explain how it works. Assume\n     /// the current function is as follows:\n     ///\n     /// ```text\n@@ -164,7 +164,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// replace each of the references (`Foo1<'a>`, `Foo2<'b>`) with\n     /// fresh inference variables C1 and C2. We wish to use the values\n     /// of these variables to infer the underlying types of `Foo1` and\n-    /// `Foo2`.  That is, this gives rise to higher-order (pattern) unification\n+    /// `Foo2`. That is, this gives rise to higher-order (pattern) unification\n     /// constraints like:\n     ///\n     /// ```text\n@@ -199,7 +199,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// Ordinarily, the subtyping rules would ensure that these are\n     /// sufficiently large. But since `impl Bar<'a>` isn't a specific\n-    /// type per se, we don't get such constraints by default.  This\n+    /// type per se, we don't get such constraints by default. This\n     /// is where this function comes into play. It adds extra\n     /// constraints to ensure that all the regions which appear in the\n     /// inferred type are regions that could validly appear.\n@@ -813,7 +813,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/// Whether `opaque_node_id` is a sibling or a child of a sibling of `def_id`\n+/// Returns `true` if `opaque_node_id` is a sibling or a child of a sibling of `def_id`.\n ///\n /// ```rust\n /// pub mod foo {\n@@ -827,11 +827,10 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n /// }\n /// ```\n ///\n-/// Here, `def_id` will be the `DefId` of the existential type `Baz`.\n-/// `opaque_node_id` is the `NodeId` of the reference to Baz --\n-///  so either the return type of f1 or f2.\n-/// We will return true if the reference is within the same module as the existential type\n-/// So true for f1, false for f2.\n+/// Here, `def_id` is the `DefId` of the existential type `Baz` and `opaque_node_id` is the\n+/// `NodeId` of the reference to `Baz` (i.e., the return type of both `f1` and `f2`).\n+/// We return `true` if the reference is within the same module as the existential type\n+/// (i.e., `true` for `f1`, `false` for `f2`).\n pub fn may_define_existential_type(\n     tcx: TyCtxt<'_, '_, '_>,\n     def_id: DefId,"}, {"sha": "43afb60ee17317321148c749e43efd14dc5cf1c7", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -63,7 +63,7 @@ pub struct OutlivesEnvironment<'tcx> {\n }\n \n /// \"Region-bound pairs\" tracks outlives relations that are known to\n-/// be true, either because of explicit where clauses like `T: 'a` or\n+/// be true, either because of explicit where-clauses like `T: 'a` or\n /// because of implied bounds.\n pub type RegionBoundPairs<'tcx> = Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>;\n "}, {"sha": "78353e52ad46264b4ec1ce575ab84a9336e6feb3", "filename": "src/librustc/infer/outlives/free_region_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -24,7 +24,7 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         }\n     }\n \n-    /// Compute the least-upper-bound of two free regions. In some\n+    /// Computes the least-upper-bound of two free regions. In some\n     /// cases, this is more conservative than necessary, in order to\n     /// avoid making arbitrary choices. See\n     /// `TransitiveRelation::postdom_upper_bound` for more details."}, {"sha": "c40fbfb25e42246972347f4fb0cc8c7e9c1c7f34", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -55,7 +55,7 @@\n //! fn foo<U, F: for<'a> FnMut(&'a U)>(_f: F) {}\n //! ```\n //!\n-//! the type of the closure's first argument would be `&'a ?U`.  We\n+//! the type of the closure's first argument would be `&'a ?U`. We\n //! might later infer `?U` to something like `&'b u32`, which would\n //! imply that `'b: 'a`.\n "}, {"sha": "494f708c6a7b79b4a0c27c8b455b7cd8ee438ed8", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -74,7 +74,7 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n     /// This is an \"approximate\" check -- it may not find all\n     /// applicable bounds, and not all the bounds it returns can be\n     /// relied upon. In particular, this check ignores region\n-    /// identity.  So, for example, if we have `<T as\n+    /// identity. So, for example, if we have `<T as\n     /// Trait<'0>>::Item` where `'0` is a region variable, and the\n     /// user has `<T as Trait<'a>>::Item: 'b` in the environment, then\n     /// the clause from the environment only applies if `'0 = 'a`,\n@@ -96,7 +96,7 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n         })\n     }\n \n-    /// Searches the where clauses in scope for regions that\n+    /// Searches the where-clauses in scope for regions that\n     /// `projection_ty` is known to outlive. Currently requires an\n     /// exact match.\n     pub fn projection_declared_bounds_from_trait(\n@@ -251,7 +251,7 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n             .map(move |r| r.subst(tcx, projection_ty.substs))\n     }\n \n-    /// Given the def-id of an associated item, returns any region\n+    /// Given the `DefId` of an associated item, returns any region\n     /// bounds attached to that associated item from the trait definition.\n     ///\n     /// For example:\n@@ -262,7 +262,7 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n     /// }\n     /// ```\n     ///\n-    /// If we were given the def-id of `Foo::Bar`, we would return\n+    /// If we were given the `DefId` of `Foo::Bar`, we would return\n     /// `'a`. You could then apply the substitutions from the\n     /// projection to convert this into your namespace. This also\n     /// works if the user writes `where <Self as Foo<'a>>::Bar: 'a` on"}, {"sha": "65d25333c7179050b14bba2a3adc357c4d06fb34", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 45, "deletions": 35, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,4 +1,4 @@\n-//! See README.md\n+//! See `README.md`.\n \n use self::CombineMapType::*;\n use self::UndoLog::*;\n@@ -108,16 +108,16 @@ pub struct RegionConstraintData<'tcx> {\n     pub givens: FxHashSet<(Region<'tcx>, ty::RegionVid)>,\n }\n \n-/// A constraint that influences the inference process.\n+/// Represents a constraint that influences the inference process.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n pub enum Constraint<'tcx> {\n-    /// One region variable is subregion of another\n+    /// A region variable is a subregion of another.\n     VarSubVar(RegionVid, RegionVid),\n \n-    /// Concrete region is subregion of region variable\n+    /// A concrete region is a subregion of region variable.\n     RegSubVar(Region<'tcx>, RegionVid),\n \n-    /// Region variable is subregion of concrete region. This does not\n+    /// A region variable is a subregion of a concrete region. This does not\n     /// directly affect inference, but instead is checked after\n     /// inference is complete.\n     VarSubReg(RegionVid, Region<'tcx>),\n@@ -138,9 +138,9 @@ impl Constraint<'_> {\n     }\n }\n \n-/// VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n+/// `VerifyGenericBound(T, _, R, RS)`: the parameter type `T` (or\n /// associated type) must outlive the region `R`. `T` is known to\n-/// outlive `RS`. Therefore verify that `R <= RS[i]` for some\n+/// outlive `RS`. Therefore, verify that `R <= RS[i]` for some\n /// `i`. Inference variables may be involved (but this verification\n /// step doesn't influence inference).\n #[derive(Debug, Clone)]\n@@ -164,7 +164,7 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n-/// Describes the things that some `GenericKind` value G is known to\n+/// Describes the things that some `GenericKind` value `G` is known to\n /// outlive. Each variant of `VerifyBound` can be thought of as a\n /// function:\n ///\n@@ -187,13 +187,15 @@ pub enum VerifyBound<'tcx> {\n     /// following, where `G` is the generic for which this verify\n     /// bound was created:\n     ///\n-    ///     fn(min) -> bool {\n-    ///       if G == K {\n+    /// ```rust\n+    /// fn(min) -> bool {\n+    ///     if G == K {\n     ///         B(min)\n-    ///       } else {\n+    ///     } else {\n     ///         false\n-    ///       }\n     ///     }\n+    /// }\n+    /// ```\n     ///\n     /// In other words, if the generic `G` that we are checking is\n     /// equal to `K`, then check the associated verify bound\n@@ -202,45 +204,52 @@ pub enum VerifyBound<'tcx> {\n     /// This is used when we have something in the environment that\n     /// may or may not be relevant, depending on the region inference\n     /// results. For example, we may have `where <T as\n-    /// Trait<'a>>::Item: 'b` in our where clauses. If we are\n+    /// Trait<'a>>::Item: 'b` in our where-clauses. If we are\n     /// generating the verify-bound for `<T as Trait<'0>>::Item`, then\n     /// this where-clause is only relevant if `'0` winds up inferred\n     /// to `'a`.\n     ///\n     /// So we would compile to a verify-bound like\n     ///\n-    ///     IfEq(<T as Trait<'a>>::Item, AnyRegion('a))\n+    /// ```\n+    /// IfEq(<T as Trait<'a>>::Item, AnyRegion('a))\n+    /// ```\n     ///\n     /// meaning, if the subject G is equal to `<T as Trait<'a>>::Item`\n     /// (after inference), and `'a: min`, then `G: min`.\n     IfEq(Ty<'tcx>, Box<VerifyBound<'tcx>>),\n \n     /// Given a region `R`, expands to the function:\n     ///\n-    ///     fn(min) -> bool {\n-    ///       R: min\n-    ///     }\n+    /// ```\n+    /// fn(min) -> bool {\n+    ///     R: min\n+    /// }\n+    /// ```\n     ///\n     /// This is used when we can establish that `G: R` -- therefore,\n     /// if `R: min`, then by transitivity `G: min`.\n     OutlivedBy(Region<'tcx>),\n \n     /// Given a set of bounds `B`, expands to the function:\n     ///\n-    ///     fn(min) -> bool {\n-    ///       exists (b in B) { b(min) }\n-    ///     }\n+    /// ```rust\n+    /// fn(min) -> bool {\n+    ///     exists (b in B) { b(min) }\n+    /// }\n+    /// ```\n     ///\n     /// In other words, if we meet some bound in `B`, that suffices.\n-    /// This is used when all the bounds in `B` are known to apply to\n-    /// G.\n+    /// This is used when all the bounds in `B` are known to apply to `G`.\n     AnyBound(Vec<VerifyBound<'tcx>>),\n \n     /// Given a set of bounds `B`, expands to the function:\n     ///\n-    ///     fn(min) -> bool {\n-    ///       forall (b in B) { b(min) }\n-    ///     }\n+    /// ```rust\n+    /// fn(min) -> bool {\n+    ///     forall (b in B) { b(min) }\n+    /// }\n+    /// ```\n     ///\n     /// In other words, if we meet *all* bounds in `B`, that suffices.\n     /// This is used when *some* bound in `B` is known to suffice, but\n@@ -256,19 +265,19 @@ struct TwoRegions<'tcx> {\n \n #[derive(Copy, Clone, PartialEq)]\n enum UndoLog<'tcx> {\n-    /// We added `RegionVid`\n+    /// We added `RegionVid`.\n     AddVar(RegionVid),\n \n-    /// We added the given `constraint`\n+    /// We added the given `constraint`.\n     AddConstraint(Constraint<'tcx>),\n \n-    /// We added the given `verify`\n+    /// We added the given `verify`.\n     AddVerify(usize),\n \n-    /// We added the given `given`\n+    /// We added the given `given`.\n     AddGiven(Region<'tcx>, ty::RegionVid),\n \n-    /// We added a GLB/LUB \"combination variable\"\n+    /// We added a GLB/LUB \"combination variable\".\n     AddCombination(CombineMapType, TwoRegions<'tcx>),\n \n     /// During skolemization, we sometimes purge entries from the undo\n@@ -303,7 +312,7 @@ pub struct RegionSnapshot {\n /// When working with placeholder regions, we often wish to find all of\n /// the regions that are either reachable from a placeholder region, or\n /// which can reach a placeholder region, or both. We call such regions\n-/// *tainted* regions.  This struct allows you to decide what set of\n+/// *tainted* regions. This struct allows you to decide what set of\n /// tainted regions you want.\n #[derive(Debug)]\n pub struct TaintDirections {\n@@ -359,7 +368,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n     /// Takes (and clears) the current set of constraints. Note that\n     /// the set of variables remains intact, but all relationships\n-    /// between them are reset.  This is used during NLL checking to\n+    /// between them are reset. This is used during NLL checking to\n     /// grab the set of constraints that arose from a particular\n     /// operation.\n     ///\n@@ -707,7 +716,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         }\n     }\n \n-    /// See `Verify::VerifyGenericBound`\n+    /// See [`Verify::VerifyGenericBound`].\n     pub fn verify_generic_bound(\n         &mut self,\n         origin: SubregionOrigin<'tcx>,\n@@ -837,7 +846,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             }).collect()\n     }\n \n-    /// See [`RegionInference::region_constraints_added_in_snapshot`]\n+    /// See [`RegionInference::region_constraints_added_in_snapshot`].\n     pub fn region_constraints_added_in_snapshot(&self, mark: &RegionSnapshot) -> Option<bool> {\n         self.undo_log[mark.length..]\n             .iter()\n@@ -925,7 +934,8 @@ impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n }\n \n impl<'tcx> RegionConstraintData<'tcx> {\n-    /// True if this region constraint data contains no constraints.\n+    /// Returns `true` if this region constraint data contains no constraints, and `false`\n+    /// otherwise.\n     pub fn is_empty(&self) -> bool {\n         let RegionConstraintData {\n             constraints,"}, {"sha": "09a0a6ce9c97c56709b6af6b935b67fc4d518120", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -218,7 +218,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         self.sub_relations.find(vid)\n     }\n \n-    /// True if `a` and `b` have same \"sub-root\" (i.e., exists some\n+    /// Returns `true` if `a` and `b` have same \"sub-root\" (i.e., exists some\n     /// type X such that `forall i in {a, b}. (i <: X || X <: i)`.\n     pub fn sub_unified(&mut self, a: ty::TyVid, b: ty::TyVid) -> bool {\n         self.sub_root_var(a) == self.sub_root_var(b)\n@@ -245,9 +245,9 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         }\n     }\n \n-    /// Creates a snapshot of the type variable state.  This snapshot\n+    /// Creates a snapshot of the type variable state. This snapshot\n     /// must later be committed (`commit()`) or rolled back\n-    /// (`rollback_to()`).  Nested snapshots are permitted, but must\n+    /// (`rollback_to()`). Nested snapshots are permitted, but must\n     /// be processed in a stack-like fashion.\n     pub fn snapshot(&mut self) -> Snapshot<'tcx> {\n         Snapshot {\n@@ -306,7 +306,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n             .collect()\n     }\n \n-    /// Find the set of type variables that existed *before* `s`\n+    /// Finds the set of type variables that existed *before* `s`\n     /// but which have only been unified since `s` started, and\n     /// return the types with which they were unified. So if we had\n     /// a type variable `V0`, then we started the snapshot, then we"}, {"sha": "b90ef4ea2213a905e93c25b244d99424432918a8", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -3,15 +3,15 @@\n //! The lint checking is mostly consolidated into one pass which runs\n //! after all other analyses. Throughout compilation, lint warnings\n //! can be added via the `add_lint` method on the Session structure. This\n-//! requires a span and an id of the node that the lint is being added to. The\n+//! requires a span and an ID of the node that the lint is being added to. The\n //! lint isn't actually emitted at that time because it is unknown what the\n //! actual lint level at that location is.\n //!\n //! To actually emit lint warnings/errors, a separate pass is used.\n //! A context keeps track of the current state of all lint levels.\n //! Upon entering a node of the ast which can modify the lint settings, the\n //! previous lint state is pushed onto a stack and the ast is then recursed\n-//! upon.  As the ast is traversed, this keeps track of the current lint level\n+//! upon. As the ast is traversed, this keeps track of the current lint level\n //! for all lint attributes.\n \n use self::TargetLint::*;\n@@ -703,7 +703,7 @@ impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n impl<'a, 'tcx> LintContext<'tcx> for LateContext<'a, 'tcx> {\n     type PassObject = LateLintPassObject;\n \n-    /// Get the overall compiler `Session` object.\n+    /// Gets the overall compiler `Session` object.\n     fn sess(&self) -> &Session {\n         &self.tcx.sess\n     }\n@@ -736,7 +736,7 @@ impl<'a, 'tcx> LintContext<'tcx> for LateContext<'a, 'tcx> {\n impl<'a> LintContext<'a> for EarlyContext<'a> {\n     type PassObject = EarlyLintPassObject;\n \n-    /// Get the overall compiler `Session` object.\n+    /// Gets the overall compiler `Session` object.\n     fn sess(&self) -> &Session {\n         &self.sess\n     }\n@@ -1200,7 +1200,7 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n }\n \n \n-/// Perform lint checking on a crate.\n+/// Performs lint checking on a crate.\n ///\n /// Consumes the `lint_store` field of the `Session`.\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {"}, {"sha": "9fcc3be66aa2530133caf27b536fd67142daa2ef", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -72,7 +72,7 @@ pub struct Lint {\n     /// `default_level`.\n     pub edition_lint_opts: Option<(Edition, Level)>,\n \n-    /// Whether this lint is reported even inside expansions of external macros\n+    /// `true` if this lint is reported even inside expansions of external macros.\n     pub report_in_external_macro: bool,\n }\n \n@@ -86,7 +86,7 @@ impl Lint {\n         }\n     }\n \n-    /// Get the lint's name, with ASCII letters converted to lowercase.\n+    /// Gets the lint's name, with ASCII letters converted to lowercase.\n     pub fn name_lower(&self) -> String {\n         self.name.to_ascii_lowercase()\n     }\n@@ -99,7 +99,7 @@ impl Lint {\n     }\n }\n \n-/// Declare a static item of type `&'static Lint`.\n+/// Declares a static item of type `&'static Lint`.\n #[macro_export]\n macro_rules! declare_lint {\n     ($vis: vis $NAME: ident, $Level: ident, $desc: expr) => (\n@@ -150,7 +150,7 @@ macro_rules! declare_tool_lint {\n     );\n }\n \n-/// Declare a static `LintArray` and return it as an expression.\n+/// Declares a static `LintArray` and return it as an expression.\n #[macro_export]\n macro_rules! lint_array {\n     ($( $lint:expr ),* ,) => { lint_array!( $($lint),* ) };\n@@ -164,7 +164,7 @@ pub type LintArray = Vec<&'static Lint>;\n pub trait LintPass {\n     fn name(&self) -> &'static str;\n \n-    /// Get descriptions of the lints this `LintPass` object can emit.\n+    /// Gets descriptions of the lints this `LintPass` object can emit.\n     ///\n     /// N.B., there is no enforcement that the object only emits lints it registered.\n     /// And some `rustc` internal `LintPass`es register lints to be emitted by other\n@@ -487,7 +487,7 @@ impl hash::Hash for LintId {\n }\n \n impl LintId {\n-    /// Get the `LintId` for a `Lint`.\n+    /// Gets the `LintId` for a `Lint`.\n     pub fn of(lint: &'static Lint) -> LintId {\n         LintId {\n             lint,\n@@ -498,7 +498,7 @@ impl LintId {\n         self.lint.name\n     }\n \n-    /// Get the name of the lint.\n+    /// Gets the name of the lint.\n     pub fn to_string(&self) -> String {\n         self.lint.name_lower()\n     }\n@@ -518,7 +518,7 @@ impl_stable_hash_for!(enum self::Level {\n });\n \n impl Level {\n-    /// Convert a level to a lower-case string.\n+    /// Converts a level to a lower-case string.\n     pub fn as_str(self) -> &'static str {\n         match self {\n             Allow => \"allow\",\n@@ -528,7 +528,7 @@ impl Level {\n         }\n     }\n \n-    /// Convert a lower-case string to a level.\n+    /// Converts a lower-case string to a level.\n     pub fn from_str(x: &str) -> Option<Level> {\n         match x {\n             \"allow\" => Some(Allow),"}, {"sha": "8da20ba426663f926d49610bd4d28ef29f4ba216", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,4 +1,4 @@\n-//! A different sort of visitor for walking fn bodies.  Unlike the\n+//! A different sort of visitor for walking fn bodies. Unlike the\n //! normal visitor, which just walks the entire body in one shot, the\n //! `ExprUseVisitor` determines how expressions are being used.\n \n@@ -800,8 +800,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         self.consume_expr(&arm.body);\n     }\n \n-    /// Walks a pat that occurs in isolation (i.e., top-level of fn\n-    /// arg or let binding.  *Not* a match arm or nested pat.)\n+    /// Walks a pat that occurs in isolation (i.e., top-level of fn argument or\n+    /// let binding, and *not* a match arm or nested pat.)\n     fn walk_irrefutable_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &hir::Pat) {\n         let mut mode = Unknown;\n         self.determine_pat_move_mode(cmt_discr.clone(), pat, &mut mode);"}, {"sha": "fc345df6551507bcea35dcd2c42e15529b8c8bdd", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,9 +1,7 @@\n-//! This file handles the relationships between free regions --\n-//! meaning lifetime parameters. Ordinarily, free regions are\n-//! unrelated to one another, but they can be related via implied or\n-//! explicit bounds.  In that case, we track the bounds using the\n-//! `TransitiveRelation` type and use that to decide when one free\n-//! region outlives another and so forth.\n+//! This module handles the relationships between \"free regions\", i.e., lifetime parameters.\n+//! Ordinarily, free regions are unrelated to one another, but they can be related via implied\n+//! or explicit bounds. In that case, we track the bounds using the `TransitiveRelation` type,\n+//! and use that to decide when one free region outlives another, and so forth.\n \n use crate::infer::outlives::free_region_map::{FreeRegionMap, FreeRegionRelations};\n use crate::hir::def_id::DefId;\n@@ -16,17 +14,17 @@ use crate::ty::{self, TyCtxt, Region};\n /// regions.\n ///\n /// This stuff is a bit convoluted and should be refactored, but as we\n-/// move to NLL it'll all go away anyhow.\n+/// transition to NLL, it'll all go away anyhow.\n pub struct RegionRelations<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n-    /// context used to fetch the region maps\n+    /// The context used to fetch the region maps.\n     pub context: DefId,\n \n-    /// region maps for the given context\n+    /// The region maps for the given context.\n     pub region_scope_tree: &'a region::ScopeTree,\n \n-    /// free-region relationships\n+    /// Free-region relationships.\n     pub free_regions: &'a FreeRegionMap<'tcx>,\n }\n \n@@ -45,7 +43,7 @@ impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Determines whether one region is a subregion of another.  This is intended to run *after\n+    /// Determines whether one region is a subregion of another. This is intended to run *after\n     /// inference* and sadly the logic is somewhat duplicated with the code in infer.rs.\n     pub fn is_subregion_of(&self,\n                            sub_region: ty::Region<'tcx>,\n@@ -86,7 +84,7 @@ impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n         result\n     }\n \n-    /// Determines whether this free-region is required to be 'static\n+    /// Determines whether this free region is required to be `'static`.\n     fn is_static(&self, super_region: ty::Region<'tcx>) -> bool {\n         debug!(\"is_static(super_region={:?})\", super_region);\n         match *super_region {"}, {"sha": "a18574f030ced82c67e07d19861a1963e8034868", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,27 +1,27 @@\n-//! A classic liveness analysis based on dataflow over the AST.  Computes,\n+//! A classic liveness analysis based on dataflow over the AST. Computes,\n //! for each local variable in a function, whether that variable is live\n-//! at a given point.  Program execution points are identified by their\n-//! id.\n+//! at a given point. Program execution points are identified by their\n+//! IDs.\n //!\n //! # Basic idea\n //!\n-//! The basic model is that each local variable is assigned an index.  We\n+//! The basic model is that each local variable is assigned an index. We\n //! represent sets of local variables using a vector indexed by this\n-//! index.  The value in the vector is either 0, indicating the variable\n-//! is dead, or the id of an expression that uses the variable.\n+//! index. The value in the vector is either 0, indicating the variable\n+//! is dead, or the ID of an expression that uses the variable.\n //!\n-//! We conceptually walk over the AST in reverse execution order.  If we\n-//! find a use of a variable, we add it to the set of live variables.  If\n+//! We conceptually walk over the AST in reverse execution order. If we\n+//! find a use of a variable, we add it to the set of live variables. If\n //! we find an assignment to a variable, we remove it from the set of live\n-//! variables.  When we have to merge two flows, we take the union of\n-//! those two flows---if the variable is live on both paths, we simply\n-//! pick one id.  In the event of loops, we continue doing this until a\n+//! variables. When we have to merge two flows, we take the union of\n+//! those two flows -- if the variable is live on both paths, we simply\n+//! pick one ID. In the event of loops, we continue doing this until a\n //! fixed point is reached.\n //!\n //! ## Checking initialization\n //!\n-//! At the function entry point, all variables must be dead.  If this is\n-//! not the case, we can report an error using the id found in the set of\n+//! At the function entry point, all variables must be dead. If this is\n+//! not the case, we can report an error using the ID found in the set of\n //! live variables, which identifies a use of the variable which is not\n //! dominated by an assignment.\n //!\n@@ -38,20 +38,20 @@\n //!\n //! The actual implementation contains two (nested) walks over the AST.\n //! The outer walk has the job of building up the ir_maps instance for the\n-//! enclosing function.  On the way down the tree, it identifies those AST\n+//! enclosing function. On the way down the tree, it identifies those AST\n //! nodes and variable IDs that will be needed for the liveness analysis\n-//! and assigns them contiguous IDs.  The liveness id for an AST node is\n-//! called a `live_node` (it's a newtype'd u32) and the id for a variable\n-//! is called a `variable` (another newtype'd u32).\n+//! and assigns them contiguous IDs. The liveness ID for an AST node is\n+//! called a `live_node` (it's a newtype'd `u32`) and the ID for a variable\n+//! is called a `variable` (another newtype'd `u32`).\n //!\n //! On the way back up the tree, as we are about to exit from a function\n-//! declaration we allocate a `liveness` instance.  Now that we know\n+//! declaration we allocate a `liveness` instance. Now that we know\n //! precisely how many nodes and variables we need, we can allocate all\n-//! the various arrays that we will need to precisely the right size.  We then\n+//! the various arrays that we will need to precisely the right size. We then\n //! perform the actual propagation on the `liveness` instance.\n //!\n //! This propagation is encoded in the various `propagate_through_*()`\n-//! methods.  It effectively does a reverse walk of the AST; whenever we\n+//! methods. It effectively does a reverse walk of the AST; whenever we\n //! reach a loop node, we iterate until a fixed point is reached.\n //!\n //! ## The `RWU` struct\n@@ -60,21 +60,21 @@\n //! variable `V` (these are encapsulated in the `RWU` struct):\n //!\n //! - `reader`: the `LiveNode` ID of some node which will read the value\n-//!    that `V` holds on entry to `N`.  Formally: a node `M` such\n+//!    that `V` holds on entry to `N`. Formally: a node `M` such\n //!    that there exists a path `P` from `N` to `M` where `P` does not\n-//!    write `V`.  If the `reader` is `invalid_node()`, then the current\n+//!    write `V`. If the `reader` is `invalid_node()`, then the current\n //!    value will never be read (the variable is dead, essentially).\n //!\n //! - `writer`: the `LiveNode` ID of some node which will write the\n-//!    variable `V` and which is reachable from `N`.  Formally: a node `M`\n+//!    variable `V` and which is reachable from `N`. Formally: a node `M`\n //!    such that there exists a path `P` from `N` to `M` and `M` writes\n-//!    `V`.  If the `writer` is `invalid_node()`, then there is no writer\n+//!    `V`. If the `writer` is `invalid_node()`, then there is no writer\n //!    of `V` that follows `N`.\n //!\n-//! - `used`: a boolean value indicating whether `V` is *used*.  We\n+//! - `used`: a boolean value indicating whether `V` is *used*. We\n //!   distinguish a *read* from a *use* in that a *use* is some read that\n-//!   is not just used to generate a new value.  For example, `x += 1` is\n-//!   a read but not a use.  This is used to generate better warnings.\n+//!   is not just used to generate a new value. For example, `x += 1` is\n+//!   a read but not a use. This is used to generate better warnings.\n //!\n //! ## Special Variables\n //!\n@@ -87,7 +87,7 @@\n //! - `fallthrough_ln`: a live node that represents a fallthrough\n //!\n //! - `clean_exit_var`: a synthetic variable that is only 'read' from the\n-//!   fallthrough node.  It is only live if the function could converge\n+//!   fallthrough node. It is only live if the function could converge\n //!   via means other than an explicit `return` expression. That is, it is\n //!   only dead if the end of the function's block can never be reached.\n //!   It is the responsibility of typeck to ensure that there are no"}, {"sha": "b98f094aef9214c5353d439c0b72d17f90adb877", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -3,7 +3,7 @@\n //! The job of the categorization module is to analyze an expression to\n //! determine what kind of memory is used in evaluating it (for example,\n //! where dereferences occur and what kind of pointer is dereferenced;\n-//! whether the memory is mutable; etc)\n+//! whether the memory is mutable, etc.).\n //!\n //! Categorization effectively transforms all of our expressions into\n //! expressions of the following forms (the actual enum has many more\n@@ -16,21 +16,21 @@\n //!       | E.comp    // access to an interior component\n //!\n //! Imagine a routine ToAddr(Expr) that evaluates an expression and returns an\n-//! address where the result is to be found.  If Expr is a place, then this\n-//! is the address of the place.  If Expr is an rvalue, this is the address of\n+//! address where the result is to be found. If Expr is a place, then this\n+//! is the address of the place. If `Expr` is an rvalue, this is the address of\n //! some temporary spot in memory where the result is stored.\n //!\n-//! Now, cat_expr() classifies the expression Expr and the address A=ToAddr(Expr)\n+//! Now, `cat_expr()` classifies the expression `Expr` and the address `A = ToAddr(Expr)`\n //! as follows:\n //!\n-//! - cat: what kind of expression was this?  This is a subset of the\n+//! - `cat`: what kind of expression was this? This is a subset of the\n //!   full expression forms which only includes those that we care about\n //!   for the purpose of the analysis.\n-//! - mutbl: mutability of the address A\n-//! - ty: the type of data found at the address A\n+//! - `mutbl`: mutability of the address `A`.\n+//! - `ty`: the type of data found at the address `A`.\n //!\n //! The resulting categorization tree differs somewhat from the expressions\n-//! themselves.  For example, auto-derefs are explicit.  Also, an index a[b] is\n+//! themselves. For example, auto-derefs are explicit. Also, an index a[b] is\n //! decomposed into two operations: a dereference to reach the array data and\n //! then an index to jump forward to the relevant item.\n //!"}, {"sha": "fd188b33d7e1fd253fb8785b6dddccf88e11212f", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -85,11 +85,11 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n /// values live long enough; phrased another way, the starting point\n /// of each range is not really the important thing in the above\n /// picture, but rather the ending point.\n-///\n-/// FIXME (pnkfelix): This currently derives `PartialOrd` and `Ord` to\n-/// placate the same deriving in `ty::FreeRegion`, but we may want to\n-/// actually attach a more meaningful ordering to scopes than the one\n-/// generated via deriving here.\n+//\n+// FIXME(pnkfelix): this currently derives `PartialOrd` and `Ord` to\n+// placate the same deriving in `ty::FreeRegion`, but we may want to\n+// actually attach a more meaningful ordering to scopes than the one\n+// generated via deriving here.\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Copy, RustcEncodable, RustcDecodable)]\n pub struct Scope {\n     pub id: hir::ItemLocalId,\n@@ -140,14 +140,14 @@ pub enum ScopeData {\n ///\n /// For example, given `{ let (a, b) = EXPR_1; let c = EXPR_2; ... }`:\n ///\n-/// * the subscope with `first_statement_index == 0` is scope of both\n+/// * The subscope with `first_statement_index == 0` is scope of both\n ///   `a` and `b`; it does not include EXPR_1, but does include\n ///   everything after that first `let`. (If you want a scope that\n ///   includes EXPR_1 as well, then do not use `Scope::Remainder`,\n ///   but instead another `Scope` that encompasses the whole block,\n ///   e.g., `Scope::Node`.\n ///\n-/// * the subscope with `first_statement_index == 1` is scope of `c`,\n+/// * The subscope with `first_statement_index == 1` is scope of `c`,\n ///   and thus does not include EXPR_2, but covers the `...`.\n \n newtype_index! {\n@@ -160,7 +160,7 @@ impl_stable_hash_for!(struct crate::middle::region::FirstStatementIndex { privat\n static_assert!(ASSERT_SCOPE_DATA: mem::size_of::<ScopeData>() == 4);\n \n impl Scope {\n-    /// Returns a item-local id associated with this scope.\n+    /// Returns a item-local ID associated with this scope.\n     ///\n     /// N.B., likely to be replaced as API is refined; e.g., pnkfelix\n     /// anticipates `fn entry_node_id` and `fn each_exit_node_id`.\n@@ -180,8 +180,8 @@ impl Scope {\n         }\n     }\n \n-    /// Returns the span of this Scope.  Note that in general the\n-    /// returned span may not correspond to the span of any node id in\n+    /// Returns the span of this `Scope`. Note that in general the\n+    /// returned span may not correspond to the span of any `NodeId` in\n     /// the AST.\n     pub fn span(&self, tcx: TyCtxt<'_, '_, '_>, scope_tree: &ScopeTree) -> Span {\n         let node_id = self.node_id(tcx, scope_tree);\n@@ -225,19 +225,19 @@ pub struct ScopeTree {\n     /// have lifetime parameters free in this body.\n     root_parent: Option<ast::NodeId>,\n \n-    /// `parent_map` maps from a scope id to the enclosing scope id;\n+    /// `parent_map` maps from a scope ID to the enclosing scope id;\n     /// this is usually corresponding to the lexical nesting, though\n     /// in the case of closures the parent scope is the innermost\n     /// conditional expression or repeating block. (Note that the\n-    /// enclosing scope id for the block associated with a closure is\n+    /// enclosing scope ID for the block associated with a closure is\n     /// the closure itself.)\n     parent_map: FxHashMap<Scope, (Scope, ScopeDepth)>,\n \n-    /// `var_map` maps from a variable or binding id to the block in\n+    /// `var_map` maps from a variable or binding ID to the block in\n     /// which that variable is declared.\n     var_map: FxHashMap<hir::ItemLocalId, Scope>,\n \n-    /// maps from a node-id to the associated destruction scope (if any)\n+    /// maps from a `NodeId` to the associated destruction scope (if any)\n     destruction_scopes: FxHashMap<hir::ItemLocalId, Scope>,\n \n     /// `rvalue_scopes` includes entries for those expressions whose cleanup scope is\n@@ -252,8 +252,8 @@ pub struct ScopeTree {\n \n     /// Encodes the hierarchy of fn bodies. Every fn body (including\n     /// closures) forms its own distinct region hierarchy, rooted in\n-    /// the block that is the fn body. This map points from the id of\n-    /// that root block to the id of the root block for the enclosing\n+    /// the block that is the fn body. This map points from the ID of\n+    /// that root block to the ID of the root block for the enclosing\n     /// fn, if any. Thus the map structures the fn bodies into a\n     /// hierarchy based on their lexical mapping. This is used to\n     /// handle the relationships between regions in a fn and in a\n@@ -382,7 +382,7 @@ struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n     /// upon exiting the parent scope, we cannot statically know how\n     /// many times the expression executed, and thus if the expression\n     /// creates temporaries we cannot know statically how many such\n-    /// temporaries we would have to cleanup. Therefore we ensure that\n+    /// temporaries we would have to cleanup. Therefore, we ensure that\n     /// the temporaries never outlast the conditional/repeating\n     /// expression, preventing the need for dynamic checks and/or\n     /// arbitrary amounts of stack space. Terminating scopes end\n@@ -465,7 +465,7 @@ impl<'tcx> ScopeTree {\n     }\n \n     /// Records that `sub_closure` is defined within `sup_closure`. These ids\n-    /// should be the id of the block that is the fn body, which is\n+    /// should be the ID of the block that is the fn body, which is\n     /// also the root of the region hierarchy for that fn.\n     fn record_closure_parent(&mut self,\n                              sub_closure: hir::ItemLocalId,\n@@ -551,8 +551,8 @@ impl<'tcx> ScopeTree {\n         self.is_subscope_of(scope2, scope1)\n     }\n \n-    /// Returns true if `subscope` is equal to or is lexically nested inside `superscope` and false\n-    /// otherwise.\n+    /// Returns `true` if `subscope` is equal to or is lexically nested inside `superscope`, and\n+    /// `false` otherwise.\n     pub fn is_subscope_of(&self,\n                           subscope: Scope,\n                           superscope: Scope)\n@@ -575,7 +575,7 @@ impl<'tcx> ScopeTree {\n         return true;\n     }\n \n-    /// Returns the id of the innermost containing body\n+    /// Returns the ID of the innermost containing body\n     pub fn containing_body(&self, mut scope: Scope) -> Option<hir::ItemLocalId> {\n         loop {\n             if let ScopeData::CallSite = scope.data {\n@@ -586,7 +586,7 @@ impl<'tcx> ScopeTree {\n         }\n     }\n \n-    /// Finds the nearest common ancestor of two scopes.  That is, finds the\n+    /// Finds the nearest common ancestor of two scopes. That is, finds the\n     /// smallest scope which is greater than or equal to both `scope_a` and\n     /// `scope_b`.\n     pub fn nearest_common_ancestor(&self, scope_a: Scope, scope_b: Scope) -> Scope {\n@@ -1051,7 +1051,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n         visitor.visit_pat(pat);\n     }\n \n-    /// True if `pat` match the `P&` nonterminal:\n+    /// Returns `true` if `pat` match the `P&` non-terminal.\n     ///\n     ///     P& = ref X\n     ///        | StructName { ..., P&, ... }"}, {"sha": "4e42816b3c610f1c801aa57c65f98afe9dc8dcf5", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -3,7 +3,7 @@\n //! Name resolution for lifetimes follows MUCH simpler rules than the\n //! full resolve. For example, lifetime names are never exported or\n //! used between functions, and they operate in a purely top-down\n-//! way. Therefore we break lifetime name resolution into a separate pass.\n+//! way. Therefore, we break lifetime name resolution into a separate pass.\n \n use crate::hir::def::Def;\n use crate::hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n@@ -207,7 +207,7 @@ struct NamedRegionMap {\n     pub object_lifetime_defaults: NodeMap<Vec<ObjectLifetimeDefault>>,\n }\n \n-/// See `NamedRegionMap`.\n+/// See [`NamedRegionMap`].\n #[derive(Default)]\n pub struct ResolveLifetimes {\n     defs: FxHashMap<LocalDefId, Lrc<FxHashMap<ItemLocalId, Region>>>,\n@@ -227,21 +227,19 @@ struct LifetimeContext<'a, 'tcx: 'a> {\n     map: &'a mut NamedRegionMap,\n     scope: ScopeRef<'a>,\n \n-    /// Deep breath. Our representation for poly trait refs contains a single\n+    /// This is slightly complicated. Our representation for poly-trait-refs contains a single\n     /// binder and thus we only allow a single level of quantification. However,\n     /// the syntax of Rust permits quantification in two places, e.g., `T: for <'a> Foo<'a>`\n-    /// and `for <'a, 'b> &'b T: Foo<'a>`. In order to get the de Bruijn indices\n+    /// and `for <'a, 'b> &'b T: Foo<'a>`. In order to get the De Bruijn indices\n     /// correct when representing these constraints, we should only introduce one\n     /// scope. However, we want to support both locations for the quantifier and\n     /// during lifetime resolution we want precise information (so we can't\n     /// desugar in an earlier phase).\n     ///\n-    /// SO, if we encounter a quantifier at the outer scope, we set\n-    /// trait_ref_hack to true (and introduce a scope), and then if we encounter\n-    /// a quantifier at the inner scope, we error. If trait_ref_hack is false,\n+    /// So, if we encounter a quantifier at the outer scope, we set\n+    /// `trait_ref_hack` to `true` (and introduce a scope), and then if we encounter\n+    /// a quantifier at the inner scope, we error. If `trait_ref_hack` is `false`,\n     /// then we introduce the scope at the inner quantifier.\n-    ///\n-    /// I'm sorry.\n     trait_ref_hack: bool,\n \n     /// Used to disallow the use of in-band lifetimes in `fn` or `Fn` syntax.\n@@ -1676,7 +1674,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// If early bound lifetimes are present, we separate them into their own list (and likewise\n     /// for late bound). They will be numbered sequentially, starting from the lowest index that is\n     /// already in scope (for a fn item, that will be 0, but for a method it might not be). Late\n-    /// bound lifetimes are resolved by name and associated with a binder id (`binder_id`), so the\n+    /// bound lifetimes are resolved by name and associated with a binder ID (`binder_id`), so the\n     /// ordering is not important there.\n     fn visit_early_late<F>(\n         &mut self,\n@@ -2610,7 +2608,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    /// Returns true if, in the current scope, replacing `'_` would be\n+    /// Returns `true` if, in the current scope, replacing `'_` would be\n     /// equivalent to a single-use lifetime.\n     fn track_lifetime_uses(&self) -> bool {\n         let mut scope = self.scope;\n@@ -2714,7 +2712,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n /// - it does not appear in a where-clause.\n ///\n /// \"Constrained\" basically means that it appears in any type but\n-/// not amongst the inputs to a projection.  In other words, `<&'a\n+/// not amongst the inputs to a projection. In other words, `<&'a\n /// T as Trait<''b>>::Foo` does not constrain `'a` or `'b`.\n fn insert_late_bound_lifetimes(\n     map: &mut NamedRegionMap,"}, {"sha": "68ce4024ae4e6f7ad51dfd01db97b209dd2f318a", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -51,7 +51,7 @@ enum AnnotationKind {\n pub struct DeprecationEntry {\n     /// The metadata of the attribute associated with this entry.\n     pub attr: Deprecation,\n-    /// The def id where the attr was originally attached. `None` for non-local\n+    /// The `DefId` where the attr was originally attached. `None` for non-local\n     /// `DefId`'s.\n     origin: Option<HirId>,\n }\n@@ -475,7 +475,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-/// Check whether an item marked with `deprecated(since=\"X\")` is currently\n+/// Checks whether an item marked with `deprecated(since=\"X\")` is currently\n /// deprecated (i.e., whether X is not greater than the current rustc version).\n pub fn deprecation_in_effect(since: &str) -> bool {\n     fn parse_version(ver: &str) -> Vec<u32> {"}, {"sha": "312924e5e90f549418a5bc7565f383f0912a8fc4", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -54,7 +54,7 @@ pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     })\n }\n \n-/// Returns whether the specified `lang_item` doesn't actually need to be\n+/// Returns `true` if the specified `lang_item` doesn't actually need to be\n /// present for this compilation.\n ///\n /// Not all lang items are always required for each compilation, particularly in"}, {"sha": "e96392edd64bfbb87b047a6d5f9578ea254d597f", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,4 +1,4 @@\n-//! The virtual memory representation of the MIR interpreter\n+//! The virtual memory representation of the MIR interpreter.\n \n use super::{\n     Pointer, EvalResult, AllocId, ScalarMaybeUndef, write_target_uint, read_target_uint, Scalar,\n@@ -54,7 +54,7 @@ pub trait AllocationExtra<Tag, MemoryExtra>: ::std::fmt::Debug + Clone {\n     /// Hook for performing extra checks on a memory read access.\n     ///\n     /// Takes read-only access to the allocation so we can keep all the memory read\n-    /// operations take `&self`.  Use a `RefCell` in `AllocExtra` if you\n+    /// operations take `&self`. Use a `RefCell` in `AllocExtra` if you\n     /// need to mutate.\n     #[inline(always)]\n     fn memory_read(\n@@ -133,7 +133,7 @@ impl<'tcx> ::serialize::UseSpecializedDecodable for &'tcx Allocation {}\n \n /// Alignment and bounds checks\n impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n-    /// Check if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n+    /// Checks if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n     /// of an allocation (i.e., at the first *inaccessible* location) *is* considered\n     /// in-bounds!  This follows C's/LLVM's rules.\n     /// If you want to check bounds before doing a memory access, better use `check_bounds`.\n@@ -145,7 +145,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n         ptr.check_in_alloc(Size::from_bytes(allocation_size), InboundsCheck::Live)\n     }\n \n-    /// Check if the memory range beginning at `ptr` and of size `Size` is \"in-bounds\".\n+    /// Checks if the memory range beginning at `ptr` and of size `Size` is \"in-bounds\".\n     #[inline(always)]\n     pub fn check_bounds(\n         &self,\n@@ -161,7 +161,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n /// Byte accessors\n impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// The last argument controls whether we error out when there are undefined\n-    /// or pointer bytes.  You should never call this, call `get_bytes` or\n+    /// or pointer bytes. You should never call this, call `get_bytes` or\n     /// `get_bytes_with_undef_and_ptr` instead,\n     ///\n     /// This function also guarantees that the resulting pointer will remain stable\n@@ -462,7 +462,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n \n /// Relocations\n impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n-    /// Return all relocations overlapping with the given ptr-offset pair.\n+    /// Returns all relocations overlapping with the given ptr-offset pair.\n     pub fn relocations(\n         &self,\n         cx: &impl HasDataLayout,\n@@ -476,7 +476,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         self.relocations.range(Size::from_bytes(start)..end)\n     }\n \n-    /// Check that there are no relocations overlapping with the given range.\n+    /// Checks that there are no relocations overlapping with the given range.\n     #[inline(always)]\n     fn check_relocations(\n         &self,\n@@ -491,10 +491,10 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         }\n     }\n \n-    /// Remove all relocations inside the given range.\n+    /// Removes all relocations inside the given range.\n     /// If there are relocations overlapping with the edges, they\n     /// are removed as well *and* the bytes they cover are marked as\n-    /// uninitialized.  This is a somewhat odd \"spooky action at a distance\",\n+    /// uninitialized. This is a somewhat odd \"spooky action at a distance\",\n     /// but it allows strictly more code to run than if we would just error\n     /// immediately in that case.\n     fn clear_relocations(\n@@ -633,7 +633,7 @@ impl UndefMask {\n         m\n     }\n \n-    /// Check whether the range `start..end` (end-exclusive) is entirely defined.\n+    /// Checks whether the range `start..end` (end-exclusive) is entirely defined.\n     ///\n     /// Returns `Ok(())` if it's defined. Otherwise returns the index of the byte\n     /// at which the first undefined access begins."}, {"sha": "d456f29439d2c3972ed5bb3f30a582cb5dfe38d7", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -19,7 +19,7 @@ use syntax::symbol::Symbol;\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub enum ErrorHandled {\n-    /// Already reported a lint or an error for this evaluation\n+    /// Already reported a lint or an error for this evaluation.\n     Reported,\n     /// Don't emit an error, the evaluation failed because the MIR was generic\n     /// and the substs didn't fully monomorphize it.\n@@ -212,7 +212,7 @@ pub type AssertMessage<'tcx> = EvalErrorKind<'tcx, mir::Operand<'tcx>>;\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub enum EvalErrorKind<'tcx, O> {\n     /// This variant is used by machines to signal their own errors that do not\n-    /// match an existing variant\n+    /// match an existing variant.\n     MachineError(String),\n \n     FunctionAbiMismatch(Abi, Abi),"}, {"sha": "0c43fe4a79faa7115ab343335dd080f6a9f1517f", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -260,23 +260,23 @@ impl fmt::Display for AllocId {\n \n #[derive(Debug, Clone, Eq, PartialEq, Hash, RustcDecodable, RustcEncodable)]\n pub enum AllocKind<'tcx> {\n-    /// The alloc id is used as a function pointer\n+    /// The alloc ID is used as a function pointer\n     Function(Instance<'tcx>),\n-    /// The alloc id points to a \"lazy\" static variable that did not get computed (yet).\n+    /// The alloc ID points to a \"lazy\" static variable that did not get computed (yet).\n     /// This is also used to break the cycle in recursive statics.\n     Static(DefId),\n-    /// The alloc id points to memory\n+    /// The alloc ID points to memory.\n     Memory(&'tcx Allocation),\n }\n \n pub struct AllocMap<'tcx> {\n-    /// Lets you know what an AllocId refers to\n+    /// Lets you know what an `AllocId` refers to.\n     id_to_kind: FxHashMap<AllocId, AllocKind<'tcx>>,\n \n-    /// Used to ensure that statics only get one associated AllocId\n+    /// Used to ensure that statics only get one associated `AllocId`.\n     type_interner: FxHashMap<AllocKind<'tcx>, AllocId>,\n \n-    /// The AllocId to assign to the next requested id.\n+    /// The `AllocId` to assign to the next requested ID.\n     /// Always incremented, never gets smaller.\n     next_id: AllocId,\n }\n@@ -360,7 +360,7 @@ impl<'tcx> AllocMap<'tcx> {\n         }\n     }\n \n-    /// Generate an `AllocId` for a static or return a cached one in case this function has been\n+    /// Generates an `AllocId` for a static or return a cached one in case this function has been\n     /// called on the same static before.\n     pub fn intern_static(&mut self, static_id: DefId) -> AllocId {\n         self.intern(AllocKind::Static(static_id))"}, {"sha": "5ec7de4308a13da5c888fc802d2981c327ff5a1e", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -13,25 +13,26 @@ pub struct RawConst<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n-/// Represents a constant value in Rust. Scalar and ScalarPair are optimizations which\n-/// matches the LocalState optimizations for easy conversions between Value and ConstValue.\n+/// Represents a constant value in Rust. `Scalar` and `ScalarPair` are optimizations that\n+/// match the `LocalState` optimizations for easy conversions between `Value` and `ConstValue`.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n pub enum ConstValue<'tcx> {\n-    /// Used only for types with layout::abi::Scalar ABI and ZSTs\n+    /// Used only for types with `layout::abi::Scalar` ABI and ZSTs.\n     ///\n-    /// Not using the enum `Value` to encode that this must not be `Undef`\n+    /// Not using the enum `Value` to encode that this must not be `Undef`.\n     Scalar(Scalar),\n \n-    /// Used only for slices and strings (`&[T]`, `&str`, `*const [T]`, `*mut str`, `Box<str>`, ...)\n+    /// Used only for slices and strings (`&[T]`, `&str`, `*const [T]`, `*mut str`, `Box<str>`,\n+    /// etc.).\n     ///\n     /// Empty slices don't necessarily have an address backed by an `AllocId`, thus we also need to\n     /// enable integer pointers. The `Scalar` type covers exactly those two cases. While we could\n     /// create dummy-`AllocId`s, the additional code effort for the conversions doesn't seem worth\n     /// it.\n     Slice(Scalar, u64),\n \n-    /// An allocation + offset into the allocation.\n-    /// Invariant: The AllocId matches the allocation.\n+    /// An allocation together with an offset into the allocation.\n+    /// Invariant: the `AllocId` matches the allocation.\n     ByRef(AllocId, &'tcx Allocation, Size),\n }\n "}, {"sha": "3513d652b534672fb31fed9cf33dff7e251e9e6f", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -108,7 +108,7 @@ pub struct Mir<'tcx> {\n     /// in scope, but a separate set of locals.\n     pub promoted: IndexVec<Promoted, Mir<'tcx>>,\n \n-    /// Yield type of the function, if it is a generator.\n+    /// Yields type of the function, if it is a generator.\n     pub yield_ty: Option<Ty<'tcx>>,\n \n     /// Generator drop glue\n@@ -380,7 +380,7 @@ impl<'tcx> Mir<'tcx> {\n         }\n     }\n \n-    /// Check if `sub` is a sub scope of `sup`\n+    /// Checks if `sub` is a sub scope of `sup`\n     pub fn is_sub_scope(&self, mut sub: SourceScope, sup: SourceScope) -> bool {\n         while sub != sup {\n             match self.source_scopes[sub].parent_scope {\n@@ -391,12 +391,12 @@ impl<'tcx> Mir<'tcx> {\n         true\n     }\n \n-    /// Return the return type, it always return first element from `local_decls` array\n+    /// Returns the return type, it always return first element from `local_decls` array\n     pub fn return_ty(&self) -> Ty<'tcx> {\n         self.local_decls[RETURN_PLACE].ty\n     }\n \n-    /// Get the location of the terminator for the given block\n+    /// Gets the location of the terminator for the given block\n     pub fn terminator_loc(&self, bb: BasicBlock) -> Location {\n         Location {\n             block: bb,\n@@ -526,7 +526,7 @@ pub enum BorrowKind {\n     /// We can also report errors with this kind of borrow differently.\n     Shallow,\n \n-    /// Data must be immutable but not aliasable.  This kind of borrow\n+    /// Data must be immutable but not aliasable. This kind of borrow\n     /// cannot currently be expressed by the user and is used only in\n     /// implicit closure bindings. It is needed when the closure is\n     /// borrowing or mutating a mutable referent, e.g.:\n@@ -565,8 +565,8 @@ pub enum BorrowKind {\n \n     /// Data is mutable and not aliasable.\n     Mut {\n-        /// True if this borrow arose from method-call auto-ref\n-        /// (i.e., `adjustment::Adjust::Borrow`)\n+        /// `true` if this borrow arose from method-call auto-ref\n+        /// (i.e., `adjustment::Adjust::Borrow`).\n         allow_two_phase_borrow: bool,\n     },\n }\n@@ -610,7 +610,7 @@ pub struct VarBindingForm<'tcx> {\n     /// If an explicit type was provided for this variable binding,\n     /// this holds the source Span of that type.\n     ///\n-    /// NOTE: If you want to change this to a `HirId`, be wary that\n+    /// NOTE: if you want to change this to a `HirId`, be wary that\n     /// doing so breaks incremental compilation (as of this writing),\n     /// while a `Span` does not cause our tests to fail.\n     pub opt_ty_info: Option<Span>,\n@@ -737,7 +737,7 @@ pub struct LocalDecl<'tcx> {\n     /// `ClearCrossCrate` as long as it carries as `HirId`.\n     pub is_user_variable: Option<ClearCrossCrate<BindingForm<'tcx>>>,\n \n-    /// True if this is an internal local\n+    /// `true` if this is an internal local.\n     ///\n     /// These locals are not based on types in the source code and are only used\n     /// for a few desugarings at the moment.\n@@ -864,7 +864,7 @@ pub struct LocalDecl<'tcx> {\n }\n \n impl<'tcx> LocalDecl<'tcx> {\n-    /// Returns true only if local is a binding that can itself be\n+    /// Returns `true` only if local is a binding that can itself be\n     /// made mutable via the addition of the `mut` keyword, namely\n     /// something like the occurrences of `x` in:\n     /// - `fn foo(x: Type) { ... }`,\n@@ -886,7 +886,7 @@ impl<'tcx> LocalDecl<'tcx> {\n         }\n     }\n \n-    /// Returns true if local is definitely not a `ref ident` or\n+    /// Returns `true` if local is definitely not a `ref ident` or\n     /// `ref mut ident` binding. (Such bindings cannot be made into\n     /// mutable bindings, but the inverse does not necessarily hold).\n     pub fn is_nonref_binding(&self) -> bool {\n@@ -904,7 +904,7 @@ impl<'tcx> LocalDecl<'tcx> {\n         }\n     }\n \n-    /// Create a new `LocalDecl` for a temporary.\n+    /// Creates a new `LocalDecl` for a temporary.\n     #[inline]\n     pub fn new_temp(ty: Ty<'tcx>, span: Span) -> Self {\n         Self::new_local(ty, Mutability::Mut, false, span)\n@@ -925,7 +925,7 @@ impl<'tcx> LocalDecl<'tcx> {\n         self\n     }\n \n-    /// Create a new `LocalDecl` for a internal temporary.\n+    /// Creates a new `LocalDecl` for a internal temporary.\n     #[inline]\n     pub fn new_internal(ty: Ty<'tcx>, span: Span) -> Self {\n         Self::new_local(ty, Mutability::Mut, true, span)\n@@ -1019,7 +1019,7 @@ pub struct BasicBlockData<'tcx> {\n \n     /// Terminator for this block.\n     ///\n-    /// NB. This should generally ONLY be `None` during construction.\n+    /// N.B., this should generally ONLY be `None` during construction.\n     /// Therefore, you should generally access it via the\n     /// `terminator()` or `terminator_mut()` methods. The only\n     /// exception is that certain passes, such as `simplify_cfg`, swap\n@@ -1637,7 +1637,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n         }\n     }\n \n-    /// Return the list of labels for the edges to the successor basic blocks.\n+    /// Returns the list of labels for the edges to the successor basic blocks.\n     pub fn fmt_successor_labels(&self) -> Vec<Cow<'static, str>> {\n         use self::TerminatorKind::*;\n         match *self {\n@@ -1760,7 +1760,7 @@ pub enum StatementKind<'tcx> {\n     /// error messages to these specific patterns.\n     ///\n     /// Note that this also is emitted for regular `let` bindings to ensure that locals that are\n-    /// never accessed still get some sanity checks for e.g. `let x: ! = ..;`\n+    /// never accessed still get some sanity checks for, e.g., `let x: ! = ..;`\n     FakeRead(FakeReadCause, Place<'tcx>),\n \n     /// Write the discriminant for a variant to the enum Place.\n@@ -1775,14 +1775,14 @@ pub enum StatementKind<'tcx> {\n     /// End the current live range for the storage of the local.\n     StorageDead(Local),\n \n-    /// Execute a piece of inline Assembly.\n+    /// Executes a piece of inline Assembly.\n     InlineAsm {\n         asm: Box<InlineAsm>,\n         outputs: Box<[Place<'tcx>]>,\n         inputs: Box<[(Span, Operand<'tcx>)]>,\n     },\n \n-    /// Retag references in the given place, ensuring they got fresh tags.  This is\n+    /// Retag references in the given place, ensuring they got fresh tags. This is\n     /// part of the Stacked Borrows model. These statements are currently only interpreted\n     /// by miri and only generated when \"-Z mir-emit-retag\" is passed.\n     /// See <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/>\n@@ -1904,7 +1904,7 @@ pub enum Place<'tcx> {\n     Projection(Box<PlaceProjection<'tcx>>),\n }\n \n-/// The def-id of a static, along with its normalized type (which is\n+/// The `DefId` of a static, along with its normalized type (which is\n /// stored to avoid requiring normalization when reading MIR).\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct Static<'tcx> {\n@@ -2009,10 +2009,10 @@ impl<'tcx> Place<'tcx> {\n         Place::Projection(Box::new(PlaceProjection { base: self, elem }))\n     }\n \n-    /// Find the innermost `Local` from this `Place`, *if* it is either a local itself or\n+    /// Finds the innermost `Local` from this `Place`, *if* it is either a local itself or\n     /// a single deref of a local.\n-    ///\n-    /// FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n+    //\n+    // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n     pub fn local(&self) -> Option<Local> {\n         match self {\n             Place::Local(local) |\n@@ -2024,7 +2024,7 @@ impl<'tcx> Place<'tcx> {\n         }\n     }\n \n-    /// Find the innermost `Local` from this `Place`.\n+    /// Finds the innermost `Local` from this `Place`.\n     pub fn base_local(&self) -> Option<Local> {\n         match self {\n             Place::Local(local) => Some(*local),\n@@ -2141,7 +2141,7 @@ impl<'tcx> Debug for Operand<'tcx> {\n \n impl<'tcx> Operand<'tcx> {\n     /// Convenience helper to make a constant that refers to the fn\n-    /// with given def-id and substs. Since this is used to synthesize\n+    /// with given `DefId` and substs. Since this is used to synthesize\n     /// MIR, assumes `user_ty` is None.\n     pub fn function_handle<'a>(\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -2199,7 +2199,7 @@ pub enum Rvalue<'tcx> {\n     /// be defined to return, say, a 0) if ADT is not an enum.\n     Discriminant(Place<'tcx>),\n \n-    /// Create an aggregate value, like a tuple or struct.  This is\n+    /// Creates an aggregate value, like a tuple or struct. This is\n     /// only needed because we want to distinguish `dest = Foo { x:\n     /// ..., y: ... }` from `dest.x = ...; dest.y = ...;` in the case\n     /// that `Foo` has a destructor. These rvalues can be optimized\n@@ -2211,13 +2211,13 @@ pub enum Rvalue<'tcx> {\n pub enum CastKind {\n     Misc,\n \n-    /// Convert unique, zero-sized type for a fn to fn()\n+    /// Converts unique, zero-sized type for a fn to fn()\n     ReifyFnPointer,\n \n-    /// Convert non capturing closure to fn()\n+    /// Converts non capturing closure to fn()\n     ClosureFnPointer,\n \n-    /// Convert safe fn() to unsafe fn()\n+    /// Converts safe fn() to unsafe fn()\n     UnsafeFnPointer,\n \n     /// \"Unsize\" -- convert a thin-or-fat pointer to a fat pointer.\n@@ -2301,9 +2301,9 @@ impl BinOp {\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum NullOp {\n-    /// Return the size of a value of that type\n+    /// Returns the size of a value of that type\n     SizeOf,\n-    /// Create a new uninitialized box for a value of that type\n+    /// Creates a new uninitialized box for a value of that type\n     Box,\n }\n \n@@ -2847,7 +2847,7 @@ impl Location {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum UnsafetyViolationKind {\n     General,\n-    /// Permitted in const fn and regular fns\n+    /// Permitted in const fn and regular fns.\n     GeneralAndConstFn,\n     ExternStatic(ast::NodeId),\n     BorrowPacked(ast::NodeId),\n@@ -2884,7 +2884,7 @@ pub struct BorrowCheckResult<'gcx> {\n \n /// After we borrow check a closure, we are left with various\n /// requirements that we have inferred between the free regions that\n-/// appear in the closure's signature or on its field types.  These\n+/// appear in the closure's signature or on its field types. These\n /// requirements are then verified and proved by the closure's\n /// creating function. This struct encodes those requirements.\n ///\n@@ -2934,7 +2934,7 @@ pub struct BorrowCheckResult<'gcx> {\n /// internally within the rest of the NLL code).\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct ClosureRegionRequirements<'gcx> {\n-    /// The number of external regions defined on the closure.  In our\n+    /// The number of external regions defined on the closure. In our\n     /// example above, it would be 3 -- one for `'static`, then `'1`\n     /// and `'2`. This is just used for a sanity check later on, to\n     /// make sure that the number of regions we see at the callsite"}, {"sha": "2296fe5763c94740f291d7c7149254475dfae726", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -57,7 +57,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for MonoItem<'tcx> {\n \n pub struct CodegenUnit<'tcx> {\n     /// A name for this CGU. Incremental compilation requires that\n-    /// name be unique amongst **all** crates.  Therefore, it should\n+    /// name be unique amongst **all** crates. Therefore, it should\n     /// contain something unique to this crate (e.g., a module path)\n     /// as well as the crate name and disambiguator.\n     name: InternedString,"}, {"sha": "bf4ac7496d2e76e25c929afcb45d9a857a8d646e", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -278,7 +278,7 @@ impl<'tcx> Rvalue<'tcx> {\n     }\n \n     #[inline]\n-    /// Returns whether this rvalue is deeply initialized (most rvalues) or\n+    /// Returns `true` if this rvalue is deeply initialized (most rvalues) or\n     /// whether its only shallowly initialized (`Rvalue::Box`).\n     pub fn initialization_state(&self) -> RvalueInitializationState {\n         match *self {"}, {"sha": "b6c7ca11f1f2b059f5bf4b494d9932cbd7ccda03", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -475,7 +475,7 @@ impl BorrowckMode {\n }\n \n pub enum Input {\n-    /// Load source from file\n+    /// Loads source from file\n     File(PathBuf),\n     Str {\n         /// String that is shown in place of a filename\n@@ -523,7 +523,7 @@ impl OutputFilenames {\n             .unwrap_or_else(|| self.temp_path(flavor, None))\n     }\n \n-    /// Get the path where a compilation artifact of the given type for the\n+    /// Gets the path where a compilation artifact of the given type for the\n     /// given codegen unit should be placed on disk. If codegen_unit_name is\n     /// None, a path distinct from those of any codegen unit will be generated.\n     pub fn temp_path(&self, flavor: OutputType, codegen_unit_name: Option<&str>) -> PathBuf {\n@@ -532,7 +532,7 @@ impl OutputFilenames {\n     }\n \n     /// Like temp_path, but also supports things where there is no corresponding\n-    /// OutputType, like no-opt-bitcode or lto-bitcode.\n+    /// OutputType, like noopt-bitcode or lto-bitcode.\n     pub fn temp_path_ext(&self, ext: &str, codegen_unit_name: Option<&str>) -> PathBuf {\n         let base = self.out_directory.join(&self.filestem());\n \n@@ -616,7 +616,7 @@ impl Default for Options {\n }\n \n impl Options {\n-    /// True if there is a reason to build the dep graph.\n+    /// Returns `true` if there is a reason to build the dep graph.\n     pub fn build_dep_graph(&self) -> bool {\n         self.incremental.is_some() || self.debugging_opts.dump_dep_graph\n             || self.debugging_opts.query_dep_graph\n@@ -632,7 +632,7 @@ impl Options {\n         FilePathMapping::new(self.remap_path_prefix.clone())\n     }\n \n-    /// True if there will be an output file generated\n+    /// Returns `true` if there will be an output file generated\n     pub fn will_create_output_file(&self) -> bool {\n         !self.debugging_opts.parse_only && // The file is just being parsed\n             !self.debugging_opts.ls // The file is just being queried"}, {"sha": "51b6205facb9e9003dd299874ef7bbec2ec8892d", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -51,7 +51,7 @@ pub mod filesearch;\n pub mod search_paths;\n \n pub struct OptimizationFuel {\n-    /// If -zfuel=crate=n is specified, initially set to n. Otherwise 0.\n+    /// If `-zfuel=crate=n` is specified, initially set to `n`, otherwise `0`.\n     remaining: u64,\n     /// We're rejecting all further optimizations.\n     out_of_fuel: bool,\n@@ -64,7 +64,7 @@ pub struct Session {\n     pub host: Target,\n     pub opts: config::Options,\n     pub host_tlib_path: SearchPath,\n-    /// This is `None` if the host and target are the same.\n+    /// `None` if the host and target are the same.\n     pub target_tlib_path: Option<SearchPath>,\n     pub parse_sess: ParseSess,\n     pub sysroot: PathBuf,\n@@ -104,7 +104,7 @@ pub struct Session {\n     /// The maximum length of types during monomorphization.\n     pub type_length_limit: Once<usize>,\n \n-    /// The maximum number of stackframes allowed in const eval\n+    /// The maximum number of stackframes allowed in const eval.\n     pub const_eval_stack_frame_limit: usize,\n \n     /// The metadata::creader module may inject an allocator/panic_runtime\n@@ -123,13 +123,13 @@ pub struct Session {\n     /// `-Zquery-dep-graph` is specified.\n     pub cgu_reuse_tracker: CguReuseTracker,\n \n-    /// Used by -Z profile-queries in util::common\n+    /// Used by `-Z profile-queries` in `util::common`.\n     pub profile_channel: Lock<Option<mpsc::Sender<ProfileQueriesMsg>>>,\n \n-    /// Used by -Z self-profile\n+    /// Used by `-Z self-profile`.\n     pub self_profiling_active: bool,\n \n-    /// Used by -Z self-profile\n+    /// Used by `-Z self-profile`.\n     pub self_profiling: Lock<SelfProfiler>,\n \n     /// Some measurements that are being gathered during compilation.\n@@ -140,14 +140,14 @@ pub struct Session {\n \n     next_node_id: OneThread<Cell<ast::NodeId>>,\n \n-    /// If -zfuel=crate=n is specified, Some(crate).\n+    /// If `-zfuel=crate=n` is specified, `Some(crate)`.\n     optimization_fuel_crate: Option<String>,\n \n-    /// Tracks fuel info if If -zfuel=crate=n is specified\n+    /// Tracks fuel info if `-zfuel=crate=n` is specified.\n     optimization_fuel: Lock<OptimizationFuel>,\n \n     // The next two are public because the driver needs to read them.\n-    /// If -zprint-fuel=crate, Some(crate).\n+    /// If `-zprint-fuel=crate`, `Some(crate)`.\n     pub print_fuel_crate: Option<String>,\n     /// Always set to zero and incremented so that we can print fuel expended by a crate.\n     pub print_fuel: AtomicU64,\n@@ -156,20 +156,20 @@ pub struct Session {\n     /// false positives about a job server in our environment.\n     pub jobserver: Client,\n \n-    /// Metadata about the allocators for the current crate being compiled\n+    /// Metadata about the allocators for the current crate being compiled.\n     pub has_global_allocator: Once<bool>,\n \n-    /// Metadata about the panic handlers for the current crate being compiled\n+    /// Metadata about the panic handlers for the current crate being compiled.\n     pub has_panic_handler: Once<bool>,\n \n     /// Cap lint level specified by a driver specifically.\n     pub driver_lint_caps: FxHashMap<lint::LintId, lint::Level>,\n }\n \n pub struct PerfStats {\n-    /// The accumulated time spent on computing symbol hashes\n+    /// The accumulated time spent on computing symbol hashes.\n     pub symbol_hash_time: Lock<Duration>,\n-    /// The accumulated time spent decoding def path tables from metadata\n+    /// The accumulated time spent decoding def path tables from metadata.\n     pub decode_def_path_tables_time: Lock<Duration>,\n     /// Total number of values canonicalized queries constructed.\n     pub queries_canonicalized: AtomicUsize,\n@@ -539,7 +539,7 @@ impl Session {\n         self.opts.debugging_opts.print_llvm_passes\n     }\n \n-    /// Get the features enabled for the current compilation session.\n+    /// Gets the features enabled for the current compilation session.\n     /// DO NOT USE THIS METHOD if there is a TyCtxt available, as it circumvents\n     /// dependency tracking. Use tcx.features() instead.\n     #[inline]\n@@ -989,7 +989,7 @@ impl Session {\n         self.opts.edition\n     }\n \n-    /// True if we cannot skip the PLT for shared library calls.\n+    /// Returns `true` if we cannot skip the PLT for shared library calls.\n     pub fn needs_plt(&self) -> bool {\n         // Check if the current target usually needs PLT to be enabled.\n         // The user can use the command line flag to override it."}, {"sha": "012b9e5034caee0586c0ddb4ed9529b89e7ff2e8", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -57,7 +57,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         AutoTraitFinder { tcx }\n     }\n \n-    /// Make a best effort to determine whether and under which conditions an auto trait is\n+    /// Makes a best effort to determine whether and under which conditions an auto trait is\n     /// implemented for a type. For example, if you have\n     ///\n     /// ```"}, {"sha": "d6b7b3b99cacd8c18bcaf974a6c39bed6b136767", "filename": "src/librustc/traits/codegen/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -14,8 +14,8 @@ use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::subst::{Subst, Substs};\n use crate::ty::fold::TypeFoldable;\n \n-/// Attempts to resolve an obligation to a vtable.. The result is\n-/// a shallow vtable resolution -- meaning that we do not\n+/// Attempts to resolve an obligation to a vtable. The result is\n+/// a shallow vtable resolution, meaning that we do not\n /// (necessarily) resolve all nested obligations on the impl. Note\n /// that type check should guarantee to us that all nested\n /// obligations *could be* resolved if we wanted to."}, {"sha": "a57007e51d3b14900cb8f582a3740ca5a7217a02", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,4 +1,4 @@\n-//! See rustc guide chapters on [trait-resolution] and [trait-specialization] for more info on how\n+//! See Rustc Guide chapters on [trait-resolution] and [trait-specialization] for more info on how\n //! this works.\n //!\n //! [trait-resolution]: https://rust-lang.github.io/rustc-guide/traits/resolution.html\n@@ -34,7 +34,7 @@ pub struct OverlapResult<'tcx> {\n     pub impl_header: ty::ImplHeader<'tcx>,\n     pub intercrate_ambiguity_causes: Vec<IntercrateAmbiguityCause>,\n \n-    /// True if the overlap might've been permitted before the shift\n+    /// `true` if the overlap might've been permitted before the shift\n     /// to universes.\n     pub involves_placeholder: bool,\n }\n@@ -111,7 +111,7 @@ fn with_fresh_ty_vars<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, '\n }\n \n /// Can both impl `a` and impl `b` be satisfied by a common type (including\n-/// `where` clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n+/// where-clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n fn overlap<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     a_def_id: DefId,\n@@ -242,7 +242,7 @@ pub enum OrphanCheckErr<'tcx> {\n }\n \n /// Checks the coherence orphan rules. `impl_def_id` should be the\n-/// def-id of a trait impl. To pass, either the trait must be local, or else\n+/// `DefId` of a trait impl. To pass, either the trait must be local, or else\n /// two conditions must be satisfied:\n ///\n /// 1. All type parameters in `Self` must be \"covered\" by some local type constructor.\n@@ -268,7 +268,7 @@ pub fn orphan_check<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     orphan_check_trait_ref(tcx, trait_ref, InCrate::Local)\n }\n \n-/// Check whether a trait-ref is potentially implementable by a crate.\n+/// Checks whether a trait-ref is potentially implementable by a crate.\n ///\n /// The current rule is that a trait-ref orphan checks in a crate C:\n ///"}, {"sha": "3a47b554b2ab15503753bc98bd3ded2eae57c864", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -583,7 +583,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n \n-    /// Get the parent trait chain start\n+    /// Gets the parent trait chain start\n     fn get_parent_trait_ref(&self, code: &ObligationCauseCode<'tcx>) -> Option<String> {\n         match code {\n             &ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n@@ -1376,7 +1376,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Returns whether the trait predicate may apply for *some* assignment\n+    /// Returns `true` if the trait predicate may apply for *some* assignment\n     /// to the type parameters.\n     fn predicate_can_apply(&self,\n                            param_env: ty::ParamEnv<'tcx>,"}, {"sha": "587f57bb09dee7f0e4201e575563910ccbf12b41", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -23,7 +23,7 @@ impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n     fn as_predicate(&self) -> &Self::Predicate { &self.obligation.predicate }\n }\n \n-/// The fulfillment context is used to drive trait resolution.  It\n+/// The fulfillment context is used to drive trait resolution. It\n /// consists of a list of obligations that must be (eventually)\n /// satisfied. The job is to track which are satisfied, which yielded\n /// errors, and which are still pending. At any point, users can call\n@@ -140,7 +140,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     /// creating a fresh type variable `$0` as well as a projection\n     /// predicate `<SomeType as SomeTrait>::X == $0`. When the\n     /// inference engine runs, it will attempt to find an impl of\n-    /// `SomeTrait` or a where clause that lets us unify `$0` with\n+    /// `SomeTrait` or a where-clause that lets us unify `$0` with\n     /// something concrete. If this fails, we'll unify `$0` with\n     /// `projection_ty` again.\n     fn normalize_projection_type<'a, 'gcx>(&mut self,\n@@ -509,7 +509,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n     }\n }\n \n-/// Return the set of type variables contained in a trait ref\n+/// Returns the set of type variables contained in a trait ref\n fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n                                        t: ty::PolyTraitRef<'tcx>) -> Vec<Ty<'tcx>>\n {"}, {"sha": "a32838f0e4c0c356ce9c459817d2c4b13e771890", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -73,14 +73,14 @@ pub use self::FulfillmentErrorCode::*;\n pub use self::SelectionError::*;\n pub use self::Vtable::*;\n \n-// Whether to enable bug compatibility with issue #43355\n+/// Whether to enable bug compatibility with issue #43355.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum IntercrateMode {\n     Issue43355,\n     Fixed\n }\n \n-// The mode that trait queries run in\n+/// The mode that trait queries run in.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum TraitQueryMode {\n     // Standard/un-canonicalized queries get accurate\n@@ -93,45 +93,45 @@ pub enum TraitQueryMode {\n     Canonical,\n }\n \n-/// An `Obligation` represents some trait reference (e.g., `int:Eq`) for\n-/// which the vtable must be found.  The process of finding a vtable is\n+/// An `Obligation` represents some trait reference (e.g., `int: Eq`) for\n+/// which the vtable must be found. The process of finding a vtable is\n /// called \"resolving\" the `Obligation`. This process consists of\n /// either identifying an `impl` (e.g., `impl Eq for int`) that\n /// provides the required vtable, or else finding a bound that is in\n /// scope. The eventual result is usually a `Selection` (defined below).\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct Obligation<'tcx, T> {\n-    /// Why do we have to prove this thing?\n+    /// The reason we have to prove this thing.\n     pub cause: ObligationCause<'tcx>,\n \n-    /// In which environment should we prove this thing?\n+    /// The environment in which we should prove this thing.\n     pub param_env: ty::ParamEnv<'tcx>,\n \n-    /// What are we trying to prove?\n+    /// The thing we are trying to prove.\n     pub predicate: T,\n \n     /// If we started proving this as a result of trying to prove\n     /// something else, track the total depth to ensure termination.\n     /// If this goes over a certain threshold, we abort compilation --\n     /// in such cases, we can not say whether or not the predicate\n-    /// holds for certain. Stupid halting problem. Such a drag.\n+    /// holds for certain. Stupid halting problem; such a drag.\n     pub recursion_depth: usize,\n }\n \n pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n \n-/// Why did we incur this obligation? Used for error reporting.\n+/// The reason why we incurred this obligation; used for error reporting.\n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct ObligationCause<'tcx> {\n     pub span: Span,\n \n-    // The id of the fn body that triggered this obligation. This is\n-    // used for region obligations to determine the precise\n-    // environment in which the region obligation should be evaluated\n-    // (in particular, closures can add new assumptions). See the\n-    // field `region_obligations` of the `FulfillmentContext` for more\n-    // information.\n+    /// The ID of the fn body that triggered this obligation. This is\n+    /// used for region obligations to determine the precise\n+    /// environment in which the region obligation should be evaluated\n+    /// (in particular, closures can add new assumptions). See the\n+    /// field `region_obligations` of the `FulfillmentContext` for more\n+    /// information.\n     pub body_id: ast::NodeId,\n \n     pub code: ObligationCauseCode<'tcx>\n@@ -152,20 +152,20 @@ impl<'tcx> ObligationCause<'tcx> {\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub enum ObligationCauseCode<'tcx> {\n-    /// Not well classified or should be obvious from span.\n+    /// Not well classified or should be obvious from the span.\n     MiscObligation,\n \n-    /// A slice or array is WF only if `T: Sized`\n+    /// A slice or array is WF only if `T: Sized`.\n     SliceOrArrayElem,\n \n-    /// A tuple is WF only if its middle elements are Sized\n+    /// A tuple is WF only if its middle elements are `Sized`.\n     TupleElem,\n \n-    /// This is the trait reference from the given projection\n+    /// This is the trait reference from the given projection.\n     ProjectionWf(ty::ProjectionTy<'tcx>),\n \n-    /// In an impl of trait X for type Y, type Y must\n-    /// also implement all supertraits of X.\n+    /// In an impl of trait `X` for type `Y`, type `Y` must\n+    /// also implement all supertraits of `X`.\n     ItemObligation(DefId),\n \n     /// A type like `&'a T` is WF only if `T: 'a`.\n@@ -271,7 +271,7 @@ pub struct DerivedObligationCause<'tcx> {\n     /// directly.\n     parent_trait_ref: ty::PolyTraitRef<'tcx>,\n \n-    /// The parent trait had this cause\n+    /// The parent trait had this cause.\n     parent_code: Rc<ObligationCauseCode<'tcx>>\n }\n \n@@ -280,14 +280,14 @@ pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;\n pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n \n /// The following types:\n-/// * `WhereClause`\n-/// * `WellFormed`\n-/// * `FromEnv`\n-/// * `DomainGoal`\n-/// * `Goal`\n-/// * `Clause`\n-/// * `Environment`\n-/// * `InEnvironment`\n+/// * `WhereClause`,\n+/// * `WellFormed`,\n+/// * `FromEnv`,\n+/// * `DomainGoal`,\n+/// * `Goal`,\n+/// * `Clause`,\n+/// * `Environment`,\n+/// * `InEnvironment`,\n /// are used for representing the trait system in the form of\n /// logic programming clauses. They are part of the interface\n /// for the chalk SLG solver.\n@@ -399,10 +399,10 @@ pub type Clauses<'tcx> = &'tcx List<Clause<'tcx>>;\n /// with the goal to solve and proceeds from there).\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct ProgramClause<'tcx> {\n-    /// This goal will be considered true...\n+    /// This goal will be considered true ...\n     pub goal: DomainGoal<'tcx>,\n \n-    /// ...if we can prove these hypotheses (there may be no hypotheses at all):\n+    /// ... if we can prove these hypotheses (there may be no hypotheses at all):\n     pub hypotheses: Goals<'tcx>,\n \n     /// Useful for filtering clauses.\n@@ -485,7 +485,6 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n /// For example, the vtable may be tied to a specific impl (case A),\n /// or it may be relative to some bound that is in scope (case B).\n ///\n-///\n /// ```\n /// impl<T:Clone> Clone<T> for Option<T> { ... } // Impl_1\n /// impl<T:Clone> Clone<T> for Box<T> { ... }    // Impl_2\n@@ -517,7 +516,7 @@ pub enum Vtable<'tcx, N> {\n     /// Vtable identifying a particular impl.\n     VtableImpl(VtableImplData<'tcx, N>),\n \n-    /// Vtable for auto trait implementations\n+    /// Vtable for auto trait implementations.\n     /// This carries the information and nested obligations with regards\n     /// to an auto implementation for a trait `Trait`. The nested obligations\n     /// ensure the trait implementation holds for all the constituent types.\n@@ -529,18 +528,18 @@ pub enum Vtable<'tcx, N> {\n     /// any).\n     VtableParam(Vec<N>),\n \n-    /// Virtual calls through an object\n+    /// Virtual calls through an object.\n     VtableObject(VtableObjectData<'tcx, N>),\n \n     /// Successful resolution for a builtin trait.\n     VtableBuiltin(VtableBuiltinData<N>),\n \n-    /// Vtable automatically generated for a closure. The def ID is the ID\n+    /// Vtable automatically generated for a closure. The `DefId` is the ID\n     /// of the closure expression. This is a `VtableImpl` in spirit, but the\n     /// impl is generated by the compiler and does not appear in the source.\n     VtableClosure(VtableClosureData<'tcx, N>),\n \n-    /// Same as above, but for a fn pointer type with the given signature.\n+    /// Same as above, but for a function pointer type with the given signature.\n     VtableFnPointer(VtableFnPointerData<'tcx, N>),\n \n     /// Vtable automatically generated for a generator."}, {"sha": "b31aa5998f3654ec2c29e155d06c751176189f8d", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -6,7 +6,7 @@\n //!   - have a suitable receiver from which we can extract a vtable and coerce to a \"thin\" version\n //!     that doesn't contain the vtable;\n //!   - not reference the erased type `Self` except for in this receiver;\n-//!   - not have generic type parameters\n+//!   - not have generic type parameters.\n \n use super::elaborate_predicates;\n \n@@ -22,17 +22,17 @@ use syntax_pos::Span;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum ObjectSafetyViolation {\n-    /// Self : Sized declared on the trait\n+    /// `Self: Sized` declared on the trait.\n     SizedSelf,\n \n     /// Supertrait reference references `Self` an in illegal location\n-    /// (e.g., `trait Foo : Bar<Self>`)\n+    /// (e.g., `trait Foo : Bar<Self>`).\n     SupertraitSelf,\n \n-    /// Method has something illegal\n+    /// Method has something illegal.\n     Method(ast::Name, MethodViolationCode),\n \n-    /// Associated const\n+    /// Associated const.\n     AssociatedConst(ast::Name),\n }\n \n@@ -84,7 +84,7 @@ pub enum MethodViolationCode {\n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n     /// Returns the object safety violations that affect\n-    /// astconv - currently, Self in supertraits. This is needed\n+    /// astconv -- currently, `Self` in supertraits. This is needed\n     /// because `object_safety_violations` can't be used during\n     /// type collection.\n     pub fn astconv_object_safety_violations(self, trait_def_id: DefId)\n@@ -399,8 +399,8 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         None\n     }\n \n-    /// performs a type substitution to produce the version of receiver_ty when `Self = self_ty`\n-    /// e.g., for receiver_ty = `Rc<Self>` and self_ty = `Foo`, returns `Rc<Foo>`\n+    /// Performs a type substitution to produce the version of receiver_ty when `Self = self_ty`\n+    /// e.g., for receiver_ty = `Rc<Self>` and self_ty = `Foo`, returns `Rc<Foo>`.\n     fn receiver_for_self_ty(\n         self, receiver_ty: Ty<'tcx>, self_ty: Ty<'tcx>, method_def_id: DefId\n     ) -> Ty<'tcx> {\n@@ -419,9 +419,9 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         result\n     }\n \n-    /// creates the object type for the current trait. For example,\n+    /// Creates the object type for the current trait. For example,\n     /// if the current trait is `Deref`, then this will be\n-    /// `dyn Deref<Target=Self::Target> + 'static`\n+    /// `dyn Deref<Target = Self::Target> + 'static`.\n     fn object_ty_for_trait(self, trait_def_id: DefId, lifetime: ty::Region<'tcx>) -> Ty<'tcx> {\n         debug!(\"object_ty_for_trait: trait_def_id={:?}\", trait_def_id);\n \n@@ -470,25 +470,27 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         object_ty\n     }\n \n-    /// checks the method's receiver (the `self` argument) can be dispatched on when `Self` is a\n+    /// Checks the method's receiver (the `self` argument) can be dispatched on when `Self` is a\n     /// trait object. We require that `DispatchableFromDyn` be implemented for the receiver type\n     /// in the following way:\n-    /// - let `Receiver` be the type of the `self` argument, i.e `Self`, `&Self`, `Rc<Self>`\n+    /// - let `Receiver` be the type of the `self` argument, i.e `Self`, `&Self`, `Rc<Self>`,\n     /// - require the following bound:\n     ///\n-    ///        Receiver[Self => T]: DispatchFromDyn<Receiver[Self => dyn Trait]>\n+    ///   ```\n+    ///   Receiver[Self => T]: DispatchFromDyn<Receiver[Self => dyn Trait]>\n+    ///   ```\n     ///\n-    ///    where `Foo[X => Y]` means \"the same type as `Foo`, but with `X` replaced with `Y`\"\n+    ///   where `Foo[X => Y]` means \"the same type as `Foo`, but with `X` replaced with `Y`\"\n     ///   (substitution notation).\n     ///\n-    /// some examples of receiver types and their required obligation\n-    /// - `&'a mut self` requires `&'a mut Self: DispatchFromDyn<&'a mut dyn Trait>`\n-    /// - `self: Rc<Self>` requires `Rc<Self>: DispatchFromDyn<Rc<dyn Trait>>`\n-    /// - `self: Pin<Box<Self>>` requires `Pin<Box<Self>>: DispatchFromDyn<Pin<Box<dyn Trait>>>`\n+    /// Some examples of receiver types and their required obligation:\n+    /// - `&'a mut self` requires `&'a mut Self: DispatchFromDyn<&'a mut dyn Trait>`,\n+    /// - `self: Rc<Self>` requires `Rc<Self>: DispatchFromDyn<Rc<dyn Trait>>`,\n+    /// - `self: Pin<Box<Self>>` requires `Pin<Box<Self>>: DispatchFromDyn<Pin<Box<dyn Trait>>>`.\n     ///\n     /// The only case where the receiver is not dispatchable, but is still a valid receiver\n     /// type (just not object-safe), is when there is more than one level of pointer indirection.\n-    /// e.g., `self: &&Self`, `self: &Rc<Self>`, `self: Box<Box<Self>>`. In these cases, there\n+    /// E.g., `self: &&Self`, `self: &Rc<Self>`, `self: Box<Box<Self>>`. In these cases, there\n     /// is no way, or at least no inexpensive way, to coerce the receiver from the version where\n     /// `Self = dyn Trait` to the version where `Self = T`, where `T` is the unknown erased type\n     /// contained by the trait object, because the object that needs to be coerced is behind"}, {"sha": "5a44d886e3c0a893100b755490578bf7e4983901", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -55,7 +55,7 @@ pub enum Reveal {\n     /// Also, `impl Trait` is normalized to the concrete type,\n     /// which has to be already collected by type-checking.\n     ///\n-    /// NOTE: As `impl Trait`'s concrete type should *never*\n+    /// NOTE: as `impl Trait`'s concrete type should *never*\n     /// be observable directly by the user, `Reveal::All`\n     /// should not be used by checks which may expose\n     /// type equality or type contents to the user.\n@@ -751,9 +751,9 @@ fn prune_cache_value_obligations<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx,\n ///\n /// Concern #2. Even within the snapshot, if those original\n /// obligations are not yet proven, then we are able to do projections\n-/// that may yet turn out to be wrong.  This *may* lead to some sort\n+/// that may yet turn out to be wrong. This *may* lead to some sort\n /// of trouble, though we don't have a concrete example of how that\n-/// can occur yet.  But it seems risky at best.\n+/// can occur yet. But it seems risky at best.\n fn get_paranoid_cache_value_obligation<'a, 'gcx, 'tcx>(\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -786,7 +786,7 @@ fn get_paranoid_cache_value_obligation<'a, 'gcx, 'tcx>(\n /// cycles to arise, where you basically had a setup like `<MyType<$0>\n /// as Trait>::Foo == $0`. Here, normalizing `<MyType<$0> as\n /// Trait>::Foo> to `[type error]` would lead to an obligation of\n-/// `<MyType<[type error]> as Trait>::Foo`.  We are supposed to report\n+/// `<MyType<[type error]> as Trait>::Foo`. We are supposed to report\n /// an error for this obligation, but we legitimately should not,\n /// because it contains `[type error]`. Yuck! (See issue #29857 for\n /// one case where this arose.)\n@@ -844,7 +844,7 @@ impl<'tcx> Progress<'tcx> {\n     }\n }\n \n-/// Compute the result of a projection type (if we can).\n+/// Computes the result of a projection type (if we can).\n ///\n /// IMPORTANT:\n /// - `obligation` must be fully normalized\n@@ -1553,7 +1553,7 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n // # Cache\n \n /// The projection cache. Unlike the standard caches, this can include\n-/// infcx-dependent type variables - therefore, we have to roll the\n+/// infcx-dependent type variables, therefore we have to roll the\n /// cache back each time we roll a snapshot back, to avoid assumptions\n /// on yet-unresolved inference variables. Types with placeholder\n /// regions also have to be removed when the respective snapshot ends.\n@@ -1564,9 +1564,9 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n /// (for the lifetime of the infcx).\n ///\n /// Entries in the projection cache might contain inference variables\n-/// that will be resolved by obligations on the projection cache entry - e.g.\n+/// that will be resolved by obligations on the projection cache entry (e.g.,\n /// when a type parameter in the associated type is constrained through\n-/// an \"RFC 447\" projection on the impl.\n+/// an \"RFC 447\" projection on the impl).\n ///\n /// When working with a fulfillment context, the derived obligations of each\n /// projection cache entry will be registered on the fulfillcx, so any users\n@@ -1578,10 +1578,9 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n /// If that is done, after evaluation the obligations, it is a good idea to\n /// call `ProjectionCache::complete` to make sure the obligations won't be\n /// re-evaluated and avoid an exponential worst-case.\n-///\n-/// FIXME: we probably also want some sort of cross-infcx cache here to\n-/// reduce the amount of duplication. Let's see what we get with the Chalk\n-/// reforms.\n+//\n+// FIXME: we probably also want some sort of cross-infcx cache here to\n+// reduce the amount of duplication. Let's see what we get with the Chalk reforms.\n #[derive(Default)]\n pub struct ProjectionCache<'tcx> {\n     map: SnapshotMap<ProjectionCacheKey<'tcx>, ProjectionCacheEntry<'tcx>>,"}, {"sha": "e6f9c7ebe6fe4931885ec1cbf609600b9e3ae8d2", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -184,7 +184,7 @@ impl_stable_hash_for!(struct DtorckConstraint<'tcx> {\n /// outlive. This is similar but not *quite* the same as the\n /// `needs_drop` test in the compiler already -- that is, for every\n /// type T for which this function return true, needs-drop would\n-/// return false. But the reverse does not hold: in particular,\n+/// return `false`. But the reverse does not hold: in particular,\n /// `needs_drop` returns false for `PhantomData`, but it is not\n /// trivial for dropck-outlives.\n ///"}, {"sha": "224076ce17e72c29c114233c3083d3c9b7923276", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -24,7 +24,7 @@ impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n     /// the normalized value along with various outlives relations (in\n     /// the form of obligations that must be discharged).\n     ///\n-    /// NB. This will *eventually* be the main means of\n+    /// N.B., this will *eventually* be the main means of\n     /// normalizing, but for now should be used only when we actually\n     /// know that normalization will succeed, since error reporting\n     /// and other details are still \"under development\"."}, {"sha": "0c1252680c1dbb861058ebcbfc4d5f880136a04e", "filename": "src/librustc/traits/query/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -45,7 +45,7 @@ impl<'cx, 'tcx> TyCtxt<'cx, 'tcx, 'tcx> {\n     /// a `T` (with regions erased). This is appropriate when the\n     /// binder is being instantiated at the call site.\n     ///\n-    /// NB. Currently, higher-ranked type bounds inhibit\n+    /// N.B., currently, higher-ranked type bounds inhibit\n     /// normalization. Therefore, each time we erase them in\n     /// codegen, we need to normalize the contents.\n     pub fn normalize_erasing_late_bound_regions<T>("}, {"sha": "6fe361d5adf6d66a57f4d836702564c96bc54490", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -13,7 +13,7 @@ use std::mem;\n \n /// Outlives bounds are relationships between generic parameters,\n /// whether they both be regions (`'a: 'b`) or whether types are\n-/// involved (`T: 'a`).  These relationships can be extracted from the\n+/// involved (`T: 'a`). These relationships can be extracted from the\n /// full set of predicates we understand or also from types (in which\n /// case they are called implied bounds). They are fed to the\n /// `OutlivesEnv` which in turn is supplied to the region checker and\n@@ -66,7 +66,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for OutlivesBound<'tcx> {\n \n impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// Implied bounds are region relationships that we deduce\n-    /// automatically.  The idea is that (e.g.) a caller must check that a\n+    /// automatically. The idea is that (e.g.) a caller must check that a\n     /// function's argument types are well-formed immediately before\n     /// calling that fn, and hence the *callee* can assume that its\n     /// argument types are well-formed. This may imply certain relationships"}, {"sha": "e3d7a4d57a5643841cc0104b8347e207e7124615", "filename": "src/librustc/traits/query/type_op/normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -52,7 +52,7 @@ pub trait Normalizable<'gcx, 'tcx>: fmt::Debug + TypeFoldable<'tcx> + Lift<'gcx>\n         canonicalized: Canonicalized<'gcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n     ) -> Fallible<CanonicalizedQueryResponse<'gcx, Self>>;\n \n-    /// Convert from the `'gcx` (lifted) form of `Self` into the `tcx`\n+    /// Converts from the `'gcx` (lifted) form of `Self` into the `tcx`\n     /// form of `Self`.\n     fn shrink_to_tcx_lifetime(\n         v: &'a CanonicalizedQueryResponse<'gcx, Self>,"}, {"sha": "557784b3e3c8238ff62080e2c14a590de01333ce", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -162,11 +162,11 @@ pub struct SelectionCache<'tcx> {\n }\n \n /// The selection process begins by considering all impls, where\n-/// clauses, and so forth that might resolve an obligation.  Sometimes\n+/// clauses, and so forth that might resolve an obligation. Sometimes\n /// we'll be able to say definitively that (e.g.) an impl does not\n /// apply to the obligation: perhaps it is defined for `usize` but the\n /// obligation is for `int`. In that case, we drop the impl out of the\n-/// list.  But the other cases are considered *candidates*.\n+/// list. But the other cases are considered *candidates*.\n ///\n /// For selection to succeed, there must be exactly one matching\n /// candidate. If the obligation is fully known, this is guaranteed\n@@ -331,7 +331,7 @@ enum BuiltinImplConditions<'tcx> {\n ///     - `EvaluatedToErr` implies `EvaluatedToRecur`\n ///     - the \"union\" of evaluation results is equal to their maximum -\n ///     all the \"potential success\" candidates can potentially succeed,\n-///     so they are no-ops when unioned with a definite error, and within\n+///     so they are noops when unioned with a definite error, and within\n ///     the categories it's easy to see that the unions are correct.\n pub enum EvaluationResult {\n     /// Evaluation successful\n@@ -383,31 +383,30 @@ pub enum EvaluationResult {\n     /// ```\n     ///\n     /// When we try to prove it, we first go the first option, which\n-    /// recurses. This shows us that the impl is \"useless\" - it won't\n+    /// recurses. This shows us that the impl is \"useless\" -- it won't\n     /// tell us that `T: Trait` unless it already implemented `Trait`\n     /// by some other means. However, that does not prevent `T: Trait`\n     /// does not hold, because of the bound (which can indeed be satisfied\n     /// by `SomeUnsizedType` from another crate).\n-    ///\n-    /// FIXME: when an `EvaluatedToRecur` goes past its parent root, we\n-    /// ought to convert it to an `EvaluatedToErr`, because we know\n-    /// there definitely isn't a proof tree for that obligation. Not\n-    /// doing so is still sound - there isn't any proof tree, so the\n-    /// branch still can't be a part of a minimal one - but does not\n-    /// re-enable caching.\n+    //\n+    // FIXME: when an `EvaluatedToRecur` goes past its parent root, we\n+    // ought to convert it to an `EvaluatedToErr`, because we know\n+    // there definitely isn't a proof tree for that obligation. Not\n+    // doing so is still sound -- there isn't any proof tree, so the\n+    // branch still can't be a part of a minimal one -- but does not re-enable caching.\n     EvaluatedToRecur,\n-    /// Evaluation failed\n+    /// Evaluation failed.\n     EvaluatedToErr,\n }\n \n impl EvaluationResult {\n-    /// True if this evaluation result is known to apply, even\n+    /// Returns `true` if this evaluation result is known to apply, even\n     /// considering outlives constraints.\n     pub fn must_apply_considering_regions(self) -> bool {\n         self == EvaluatedToOk\n     }\n \n-    /// True if this evaluation result is known to apply, ignoring\n+    /// Returns `true` if this evaluation result is known to apply, ignoring\n     /// outlives constraints.\n     pub fn must_apply_modulo_regions(self) -> bool {\n         self <= EvaluatedToOkModuloRegions\n@@ -981,8 +980,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     /// that recursion is ok. This routine returns true if the top of the\n     /// stack (`cycle[0]`):\n     ///\n-    /// - is a defaulted trait, and\n-    /// - it also appears in the backtrace at some position `X`; and,\n+    /// - is a defaulted trait,\n+    /// - it also appears in the backtrace at some position `X`,\n     /// - all the predicates at positions `X..` between `X` an the top are\n     ///   also defaulted traits.\n     pub fn coinductive_match<I>(&mut self, cycle: I) -> bool\n@@ -1003,7 +1002,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     /// Further evaluate `candidate` to decide whether all type parameters match and whether nested\n-    /// obligations are met. Returns true if `candidate` remains viable after this further\n+    /// obligations are met. Returns whether `candidate` remains viable after this further\n     /// scrutiny.\n     fn evaluate_candidate<'o>(\n         &mut self,\n@@ -1434,7 +1433,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Returns true if the global caches can be used.\n+    /// Returns `true` if the global caches can be used.\n     /// Do note that if the type itself is not in the\n     /// global tcx, the local caches will be used.\n     fn can_use_global_caches(&self, param_env: ty::ParamEnv<'tcx>) -> bool {\n@@ -1850,7 +1849,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n-    /// Check for the artificial impl that the compiler will create for an obligation like `X :\n+    /// Checks for the artificial impl that the compiler will create for an obligation like `X :\n     /// FnMut<..>` where `X` is a closure type.\n     ///\n     /// Note: the type parameters on a closure candidate are modeled as *output* type\n@@ -2231,8 +2230,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     // type variables and then we also attempt to evaluate recursive\n     // bounds to see if they are satisfied.\n \n-    /// Returns true if `victim` should be dropped in favor of\n-    /// `other`.  Generally speaking we will drop duplicate\n+    /// Returns `true` if `victim` should be dropped in favor of\n+    /// `other`. Generally speaking we will drop duplicate\n     /// candidates and prefer where-clause candidates.\n     ///\n     /// See the comment for \"SelectionCandidate\" for more details.\n@@ -3221,7 +3220,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     /// we currently treat the input type parameters on the trait as\n     /// outputs. This means that when we have a match we have only\n     /// considered the self type, so we have to go back and make sure\n-    /// to relate the argument types too.  This is kind of wrong, but\n+    /// to relate the argument types too. This is kind of wrong, but\n     /// since we control the full set of impls, also not that wrong,\n     /// and it DOES yield better error messages (since we don't report\n     /// errors as if there is no applicable impl, but rather report\n@@ -3235,7 +3234,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     ///     impl Fn(int) for Closure { ... }\n     ///\n     /// Now imagine our obligation is `Fn(usize) for Closure`. So far\n-    /// we have matched the self-type `Closure`. At this point we'll\n+    /// we have matched the self type `Closure`. At this point we'll\n     /// compare the `int` to `usize` and generate an error.\n     ///\n     /// Note that this checking occurs *after* the impl has selected,\n@@ -3597,7 +3596,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     /// Normalize `where_clause_trait_ref` and try to match it against\n-    /// `obligation`.  If successful, return any predicates that\n+    /// `obligation`. If successful, return any predicates that\n     /// result from the normalization. Normalization is necessary\n     /// because where-clauses are stored in the parameter environment\n     /// unnormalized."}, {"sha": "804f1b9d820a2c983b95d361abb5d1af8dcf56c9", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -58,12 +58,12 @@ pub struct OverlapError {\n /// Suppose we have selected \"source impl\" with `V` instantiated with `u32`.\n /// This function will produce a substitution with `T` and `U` both mapping to `u32`.\n ///\n-/// Where clauses add some trickiness here, because they can be used to \"define\"\n+/// where-clauses add some trickiness here, because they can be used to \"define\"\n /// an argument indirectly:\n ///\n /// ```rust\n /// impl<'a, I, T: 'a> Iterator for Cloned<I>\n-///    where I: Iterator<Item=&'a T>, T: Clone\n+///    where I: Iterator<Item = &'a T>, T: Clone\n /// ```\n ///\n /// In a case like this, the substitution for `T` is determined indirectly,\n@@ -145,10 +145,10 @@ pub fn find_associated_item<'a, 'tcx>(\n     }\n }\n \n-/// Is impl1 a specialization of impl2?\n+/// Is `impl1` a specialization of `impl2`?\n ///\n /// Specialization is determined by the sets of types to which the impls apply;\n-/// impl1 specializes impl2 if it applies to a subset of the types impl2 applies\n+/// `impl1` specializes `impl2` if it applies to a subset of the types `impl2` applies\n /// to.\n pub(super) fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     (impl1_def_id, impl2_def_id): (DefId, DefId))"}, {"sha": "561859c7c3177631ddac7e8688545f39f430c82d", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'gcx, 'tcx> Children {\n         }\n     }\n \n-    /// Remove an impl from this set of children. Used when replacing\n+    /// Removes an impl from this set of children. Used when replacing\n     /// an impl with a parent. The impl must be present in the list of\n     /// children already.\n     fn remove_existing(&mut self,\n@@ -399,7 +399,7 @@ impl<'a, 'gcx, 'tcx> Graph {\n         self.children.entry(parent).or_default().insert_blindly(tcx, child);\n     }\n \n-    /// The parent of a given impl, which is the def id of the trait when the\n+    /// The parent of a given impl, which is the `DefId` of the trait when the\n     /// impl is a \"specialization root\".\n     pub fn parent(&self, child: DefId) -> DefId {\n         *self.parent.get(&child).unwrap()"}, {"sha": "ff4fc87542dc35862bad1656c12f8b55d292ed5f", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -15,7 +15,7 @@ use crate::ty::subst::Substs;\n ///    Here the pointer will be dereferenced N times (where a dereference can\n ///    happen to raw or borrowed pointers or any smart pointer which implements\n ///    Deref, including Box<_>). The types of dereferences is given by\n-///    `autoderefs`.  It can then be auto-referenced zero or one times, indicated\n+///    `autoderefs`. It can then be auto-referenced zero or one times, indicated\n ///    by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n ///    `false`.\n ///\n@@ -38,7 +38,7 @@ use crate::ty::subst::Substs;\n ///    stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n ///    the underlying conversions from `[i32; 4]` to `[i32]`.\n ///\n-/// 3. Coercing a `Box<T>` to `Box<dyn Trait>` is an interesting special case.  In\n+/// 3. Coercing a `Box<T>` to `Box<dyn Trait>` is an interesting special case. In\n ///    that case, we have the pointer we need coming in, so there are no\n ///    autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n ///    At some point, of course, `Box` should move out of the compiler, in which\n@@ -78,7 +78,7 @@ pub enum Adjust<'tcx> {\n     /// This will do things like convert thin pointers to fat\n     /// pointers, or convert structs containing thin pointers to\n     /// structs containing fat pointers, or convert between fat\n-    /// pointers.  We don't store the details of how the transform is\n+    /// pointers. We don't store the details of how the transform is\n     /// done (in fact, we don't know that, because it might depend on\n     /// the precise type parameters). We just store the target\n     /// type. Codegen backends and miri figure out what has to be done\n@@ -110,12 +110,12 @@ impl<'a, 'gcx, 'tcx> OverloadedDeref<'tcx> {\n }\n \n /// At least for initial deployment, we want to limit two-phase borrows to\n-/// only a few specific cases. Right now, those mostly \"things that desugar\"\n-/// into method calls\n-///     - using x.some_method() syntax, where some_method takes &mut self\n-///     - using Foo::some_method(&mut x, ...) syntax\n-///     - binary assignment operators (+=, -=, *=, etc.)\n-/// Anything else should be rejected until generalized two phase borrow support\n+/// only a few specific cases. Right now, those are mostly \"things that desugar\"\n+/// into method calls:\n+/// - using `x.some_method()` syntax, where some_method takes `&mut self`,\n+/// - using `Foo::some_method(&mut x, ...)` syntax,\n+/// - binary assignment operators (`+=`, `-=`, `*=`, etc.).\n+/// Anything else should be rejected until generalized two-phase borrow support\n /// is implemented. Right now, dataflow can't handle the general case where there\n /// is more than one use of a mutable borrow, and we don't want to accept too much\n /// new code via two-phase borrows, so we try to limit where we create two-phase\n@@ -144,10 +144,10 @@ impl From<AutoBorrowMutability> for hir::Mutability {\n \n #[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum AutoBorrow<'tcx> {\n-    /// Convert from T to &T.\n+    /// Converts from T to &T.\n     Ref(ty::Region<'tcx>, AutoBorrowMutability),\n \n-    /// Convert from T to *T.\n+    /// Converts from T to *T.\n     RawPtr(hir::Mutability),\n }\n "}, {"sha": "fff5dcf433ed9184e673e3904be9a86c069edc8d", "filename": "src/librustc/ty/constness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fconstness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fconstness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fconstness.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -37,7 +37,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         }\n     }\n \n-    /// Returns true if this function must conform to `min_const_fn`\n+    /// Returns `true` if this function must conform to `min_const_fn`\n     pub fn is_min_const_fn(self, def_id: DefId) -> bool {\n         // Bail out if the signature doesn't contain `const`\n         if !self.is_const_fn_raw(def_id) {"}, {"sha": "95287efd0acb0c288cb7e4f45e1d09cbe4112db2", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,4 +1,4 @@\n-//! type context book-keeping\n+//! Type context book-keeping.\n \n use crate::dep_graph::DepGraph;\n use crate::dep_graph::{self, DepNode, DepConstructor};\n@@ -332,13 +332,13 @@ pub struct TypeckTables<'tcx> {\n     /// belongs, but it may not exist if it's a tuple field (`tuple.0`).\n     field_indices: ItemLocalMap<usize>,\n \n-    /// Stores the types for various nodes in the AST.  Note that this table\n-    /// is not guaranteed to be populated until after typeck.  See\n+    /// Stores the types for various nodes in the AST. Note that this table\n+    /// is not guaranteed to be populated until after typeck. See\n     /// typeck::check::fn_ctxt for details.\n     node_types: ItemLocalMap<Ty<'tcx>>,\n \n     /// Stores the type parameters which were substituted to obtain the type\n-    /// of this node.  This only applies to nodes that refer to entities\n+    /// of this node. This only applies to nodes that refer to entities\n     /// parameterized by type parameters, such as generic fns, types, or\n     /// other items.\n     node_substs: ItemLocalMap<&'tcx Substs<'tcx>>,\n@@ -413,7 +413,7 @@ pub struct TypeckTables<'tcx> {\n     pub tainted_by_errors: bool,\n \n     /// Stores the free-region relationships that were deduced from\n-    /// its where clauses and parameter types. These are then\n+    /// its where-clauses and parameter types. These are then\n     /// read-again by borrowck.\n     pub free_region_map: FreeRegionMap<'tcx>,\n \n@@ -837,7 +837,7 @@ pub type CanonicalUserType<'gcx> = Canonical<'gcx, UserType<'gcx>>;\n \n impl CanonicalUserType<'gcx> {\n     /// Returns `true` if this represents a substitution of the form `[?0, ?1, ?2]`,\n-    /// i.e. each thing is mapped to a canonical variable with the same index.\n+    /// i.e., each thing is mapped to a canonical variable with the same index.\n     pub fn is_identity(&self) -> bool {\n         match self.value {\n             UserType::Ty(_) => false,\n@@ -872,7 +872,7 @@ impl CanonicalUserType<'gcx> {\n     }\n }\n \n-/// A user-given type annotation attached to a constant.  These arise\n+/// A user-given type annotation attached to a constant. These arise\n /// from constants that are named via paths, like `Foo::<A>::new` and\n /// so forth.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n@@ -1053,7 +1053,7 @@ pub struct GlobalCtxt<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    /// Get the global TyCtxt.\n+    /// Gets the global `TyCtxt`.\n     #[inline]\n     pub fn global_tcx(self) -> TyCtxt<'gcx, 'gcx, 'gcx> {\n         TyCtxt {\n@@ -1153,12 +1153,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         value.lift_to_tcx(self.global_tcx())\n     }\n \n-    /// Returns true if self is the same as self.global_tcx().\n+    /// Returns `true` if self is the same as self.global_tcx().\n     fn is_global(self) -> bool {\n         ptr::eq(self.interners, &self.global_interners)\n     }\n \n-    /// Create a type context and call the closure with a `TyCtxt` reference\n+    /// Creates a type context and call the closure with a `TyCtxt` reference\n     /// to the context. The closure enforces that the type context and any interned\n     /// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n     /// reference to the context, to allow formatting values that need it.\n@@ -1353,7 +1353,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Convert a `DefId` into its fully expanded `DefPath` (every\n+    /// Converts a `DefId` into its fully expanded `DefPath` (every\n     /// `DefId` is really just an interned def-path).\n     ///\n     /// Note that if `id` is not local to this crate, the result will"}, {"sha": "aa4d1e5ea90cbf9609df79e989be33a606d481a9", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -4,7 +4,7 @@\n //! instance of a \"folder\" (a type which implements `TypeFolder`). Then\n //! the setup is intended to be:\n //!\n-//!   T.fold_with(F) --calls--> F.fold_T(T) --calls--> T.super_fold_with(F)\n+//!     T.fold_with(F) --calls--> F.fold_T(T) --calls--> T.super_fold_with(F)\n //!\n //! This way, when you define a new folder F, you can override\n //! `fold_T()` to customize the behavior, and invoke `T.super_fold_with()`\n@@ -25,9 +25,11 @@\n //! proper thing.\n //!\n //! A `TypeFoldable` T can also be visited by a `TypeVisitor` V using similar setup:\n-//!   T.visit_with(V) --calls--> V.visit_T(T) --calls--> T.super_visit_with(V).\n-//! These methods return true to indicate that the visitor has found what it is looking for\n-//! and does not need to visit anything else.\n+//!\n+//!     T.visit_with(V) --calls--> V.visit_T(T) --calls--> T.super_visit_with(V).\n+//!\n+//! These methods return true to indicate that the visitor has found what it is\n+//! looking for, and does not need to visit anything else.\n \n use crate::hir::def_id::DefId;\n use crate::ty::{self, Binder, Ty, TyCtxt, TypeFlags};\n@@ -52,15 +54,15 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n         self.super_visit_with(visitor)\n     }\n \n-    /// True if `self` has any late-bound regions that are either\n+    /// Returns `true` if `self` has any late-bound regions that are either\n     /// bound by `binder` or bound by some binder outside of `binder`.\n     /// If `binder` is `ty::INNERMOST`, this indicates whether\n     /// there are any late-bound regions that appear free.\n     fn has_vars_bound_at_or_above(&self, binder: ty::DebruijnIndex) -> bool {\n         self.visit_with(&mut HasEscapingVarsVisitor { outer_index: binder })\n     }\n \n-    /// True if this `self` has any regions that escape `binder` (and\n+    /// Returns `true` if this `self` has any regions that escape `binder` (and\n     /// hence are not bound by it).\n     fn has_vars_bound_above(&self, binder: ty::DebruijnIndex) -> bool {\n         self.has_vars_bound_at_or_above(binder.shifted_in(1))\n@@ -141,7 +143,7 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     }\n }\n \n-/// The TypeFolder trait defines the actual *folding*. There is a\n+/// The `TypeFolder` trait defines the actual *folding*. There is a\n /// method defined for every foldable type. Each of these has a\n /// default implementation that does an \"identity\" fold. Within each\n /// identity fold, it should invoke `foo.fold_with(self)` to fold each\n@@ -262,7 +264,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         });\n     }\n \n-    /// True if `callback` returns true for every region appearing free in `value`.\n+    /// Returns `true` if `callback` returns true for every region appearing free in `value`.\n     pub fn all_free_regions_meet(\n         self,\n         value: &impl TypeFoldable<'tcx>,\n@@ -271,7 +273,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         !self.any_free_region_meets(value, |r| !callback(r))\n     }\n \n-    /// True if `callback` returns true for some region appearing free in `value`.\n+    /// Returns `true` if `callback` returns true for some region appearing free in `value`.\n     pub fn any_free_region_meets(\n         self,\n         value: &impl TypeFoldable<'tcx>,\n@@ -292,8 +294,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             /// ^          ^          ^     ^\n             /// |          |          |     | here, would be shifted in 1\n             /// |          |          | here, would be shifted in 2\n-            /// |          | here, would be INNERMOST shifted in by 1\n-            /// | here, initially, binder would be INNERMOST\n+            /// |          | here, would be `INNERMOST` shifted in by 1\n+            /// | here, initially, binder would be `INNERMOST`\n             /// ```\n             ///\n             /// You see that, initially, *any* bound value is free,\n@@ -496,12 +498,12 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for BoundVarReplacer<'a, 'gcx, 'tcx>\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    /// Replace all regions bound by the given `Binder` with the\n+    /// Replaces all regions bound by the given `Binder` with the\n     /// results returned by the closure; the closure is expected to\n     /// return a free region (relative to this binder), and hence the\n     /// binder is removed in the return type. The closure is invoked\n     /// once for each unique `BoundRegion`; multiple references to the\n-    /// same `BoundRegion` will reuse the previous result.  A map is\n+    /// same `BoundRegion` will reuse the previous result. A map is\n     /// returned at the end with each bound region and the free region\n     /// that replaced it.\n     ///\n@@ -520,7 +522,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t)\n     }\n \n-    /// Replace all escaping bound vars. The `fld_r` closure replaces escaping\n+    /// Replaces all escaping bound vars. The `fld_r` closure replaces escaping\n     /// bound regions while the `fld_t` closure replaces escaping bound types.\n     pub fn replace_escaping_bound_vars<T, F, G>(\n         self,\n@@ -554,7 +556,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Replace all types or regions bound by the given `Binder`. The `fld_r`\n+    /// Replaces all types or regions bound by the given `Binder`. The `fld_r`\n     /// closure replaces bound regions while the `fld_t` closure replaces bound\n     /// types.\n     pub fn replace_bound_vars<T, F, G>(\n@@ -570,7 +572,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t)\n     }\n \n-    /// Replace any late-bound regions bound in `value` with\n+    /// Replaces any late-bound regions bound in `value` with\n     /// free variants attached to `all_outlive_scope`.\n     pub fn liberate_late_bound_regions<T>(\n         &self,\n@@ -615,21 +617,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         collector.regions\n     }\n \n-    /// Replace any late-bound regions bound in `value` with `'erased`. Useful in codegen but also\n+    /// Replaces any late-bound regions bound in `value` with `'erased`. Useful in codegen but also\n     /// method lookup and a few other places where precise region relationships are not required.\n     pub fn erase_late_bound_regions<T>(self, value: &Binder<T>) -> T\n         where T : TypeFoldable<'tcx>\n     {\n         self.replace_late_bound_regions(value, |_| self.types.re_erased).0\n     }\n \n-    /// Rewrite any late-bound regions so that they are anonymous.  Region numbers are\n+    /// Rewrite any late-bound regions so that they are anonymous. Region numbers are\n     /// assigned starting at 1 and increasing monotonically in the order traversed\n     /// by the fold operation.\n     ///\n     /// The chief purpose of this function is to canonicalize regions so that two\n     /// `FnSig`s or `TraitRef`s which are equivalent up to region naming will become\n-    /// structurally identical.  For example, `for<'a, 'b> fn(&'a isize, &'b isize)` and\n+    /// structurally identical. For example, `for<'a, 'b> fn(&'a isize, &'b isize)` and\n     /// `for<'a, 'b> fn(&'b isize, &'a isize)` will become identical after anonymization.\n     pub fn anonymize_late_bound_regions<T>(self, sig: &Binder<T>) -> Binder<T>\n         where T : TypeFoldable<'tcx>,\n@@ -793,7 +795,7 @@ pub fn shift_out_vars<'a, 'gcx, 'tcx, T>(\n /// scope to which it is attached, etc. An escaping var represents\n /// a bound var for which this processing has not yet been done.\n struct HasEscapingVarsVisitor {\n-    /// Anything bound by `outer_index` or \"above\" is escaping\n+    /// Anything bound by `outer_index` or \"above\" is escaping.\n     outer_index: ty::DebruijnIndex,\n }\n \n@@ -856,10 +858,10 @@ struct LateBoundRegionsCollector {\n     current_index: ty::DebruijnIndex,\n     regions: FxHashSet<ty::BoundRegion>,\n \n-    /// If true, we only want regions that are known to be\n+    /// `true` if we only want regions that are known to be\n     /// \"constrained\" when you equate this type with another type. In\n     /// particular, if you have e.g., `&'a u32` and `&'b u32`, equating\n-    /// them constraints `'a == 'b`.  But if you have `<&'a u32 as\n+    /// them constraints `'a == 'b`. But if you have `<&'a u32 as\n     /// Trait>::Foo` and `<&'b u32 as Trait>::Foo`, normalizing those\n     /// types may mean that `'a` and `'b` don't appear in the results,\n     /// so they are not considered *constrained*."}, {"sha": "3b393c3ca15bb2374250a9bf70f8bf7fa0d113e0", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -22,22 +22,22 @@ pub struct DefIdForest {\n }\n \n impl<'a, 'gcx, 'tcx> DefIdForest {\n-    /// Create an empty forest.\n+    /// Creates an empty forest.\n     pub fn empty() -> DefIdForest {\n         DefIdForest {\n             root_ids: SmallVec::new(),\n         }\n     }\n \n-    /// Create a forest consisting of a single tree representing the entire\n+    /// Creates a forest consisting of a single tree representing the entire\n     /// crate.\n     #[inline]\n     pub fn full(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest {\n         let crate_id = tcx.hir().local_def_id(CRATE_NODE_ID);\n         DefIdForest::from_id(crate_id)\n     }\n \n-    /// Create a forest containing a DefId and all its descendants.\n+    /// Creates a forest containing a DefId and all its descendants.\n     pub fn from_id(id: DefId) -> DefIdForest {\n         let mut root_ids = SmallVec::new();\n         root_ids.push(id);\n@@ -46,12 +46,12 @@ impl<'a, 'gcx, 'tcx> DefIdForest {\n         }\n     }\n \n-    /// Test whether the forest is empty.\n+    /// Tests whether the forest is empty.\n     pub fn is_empty(&self) -> bool {\n         self.root_ids.is_empty()\n     }\n \n-    /// Test whether the forest contains a given DefId.\n+    /// Tests whether the forest contains a given DefId.\n     pub fn contains(&self,\n                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                     id: DefId) -> bool"}, {"sha": "5fc22e3c02b60cf5502d82529e6ed784c17e2c9c", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -22,17 +22,17 @@ pub enum InstanceDef<'tcx> {\n     /// `<T as Trait>::method` where `method` receives unsizeable `self: Self`.\n     VtableShim(DefId),\n \n-    /// \\<fn() as FnTrait>::call_*\n-    /// def-id is FnTrait::call_*\n+    /// `<fn() as FnTrait>::call_*`\n+    /// `DefId` is `FnTrait::call_*`\n     FnPtrShim(DefId, Ty<'tcx>),\n \n-    /// <Trait as Trait>::fn\n+    /// `<Trait as Trait>::fn`\n     Virtual(DefId, usize),\n \n-    /// <[mut closure] as FnOnce>::call_once\n+    /// `<[mut closure] as FnOnce>::call_once`\n     ClosureOnceShim { call_once: DefId },\n \n-    /// drop_in_place::<T>; None for empty drop glue.\n+    /// `drop_in_place::<T>; None` for empty drop glue.\n     DropGlue(DefId, Option<Ty<'tcx>>),\n \n     ///`<T as Clone>::clone` shim.\n@@ -220,7 +220,7 @@ impl<'a, 'b, 'tcx> Instance<'tcx> {\n         self.def.def_id()\n     }\n \n-    /// Resolve a (def_id, substs) pair to an (optional) instance -- most commonly,\n+    /// Resolves a `(def_id, substs)` pair to an (optional) instance -- most commonly,\n     /// this is used to find the precise code that will run for a trait method invocation,\n     /// if known.\n     ///"}, {"sha": "5dc31caf295af34beebadc38236ad403d2c11cd8", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -43,7 +43,7 @@ pub fn with_forced_impl_filename_line<F: FnOnce() -> R, R>(f: F) -> R {\n     })\n }\n \n-/// Add the `crate::` prefix to paths where appropriate.\n+/// Adds the `crate::` prefix to paths where appropriate.\n pub fn with_crate_prefix<F: FnOnce() -> R, R>(f: F) -> R {\n     SHOULD_PREFIX_WITH_CRATE.with(|flag| {\n         let old = flag.get();\n@@ -55,7 +55,7 @@ pub fn with_crate_prefix<F: FnOnce() -> R, R>(f: F) -> R {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    /// Returns a string identifying this def-id. This string is\n+    /// Returns a string identifying this `DefId`. This string is\n     /// suitable for user output. It is relative to the current crate\n     /// root, unless with_forced_absolute_paths was used.\n     pub fn item_path_str(self, def_id: DefId) -> String {\n@@ -468,7 +468,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         buffer.push(&format!(\"<impl at {}>\", span_str));\n     }\n \n-    /// Returns the def-id of `def_id`'s parent in the def tree. If\n+    /// Returns the `DefId` of `def_id`'s parent in the def tree. If\n     /// this returns `None`, then `def_id` represents a crate root or\n     /// inlined root.\n     pub fn parent_def_id(self, def_id: DefId) -> Option<DefId> {\n@@ -478,9 +478,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n /// As a heuristic, when we see an impl, if we see that the\n-/// 'self-type' is a type defined in the same module as the impl,\n+/// 'self type' is a type defined in the same module as the impl,\n /// we can omit including the path to the impl itself. This\n-/// function tries to find a \"characteristic def-id\" for a\n+/// function tries to find a \"characteristic `DefId`\" for a\n /// type. It's just a heuristic so it makes some questionable\n /// decisions and we may want to adjust it later.\n pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n@@ -535,7 +535,7 @@ pub trait ItemPathBuffer {\n \n #[derive(Debug)]\n pub enum RootMode {\n-    /// Try to make a path relative to the local crate.  In\n+    /// Try to make a path relative to the local crate. In\n     /// particular, local paths have no prefix, and if the path comes\n     /// from an extern crate, start with the path to the `extern\n     /// crate` declaration."}, {"sha": "6c507c0015d7bcaa19e51ccc260b2bdc310a9e0e", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -46,7 +46,7 @@ impl IntegerExt for Integer {\n         }\n     }\n \n-    /// Get the Integer type from an attr::IntType.\n+    /// Gets the Integer type from an attr::IntType.\n     fn from_attr<C: HasDataLayout>(cx: &C, ity: attr::IntType) -> Integer {\n         let dl = cx.data_layout();\n \n@@ -62,7 +62,7 @@ impl IntegerExt for Integer {\n         }\n     }\n \n-    /// Find the appropriate Integer type and signedness for the given\n+    /// Finds the appropriate Integer type and signedness for the given\n     /// signed discriminant range and #[repr] attribute.\n     /// N.B.: u128 values above i128::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n@@ -1686,7 +1686,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                             tcx.types.re_static,\n                             tcx.mk_array(tcx.types.usize, 3),\n                         )\n-                        /* FIXME use actual fn pointers\n+                        /* FIXME: use actual fn pointers\n                         Warning: naively computing the number of entries in the\n                         vtable by counting the methods on the trait + methods on\n                         all parent traits does not work, because some methods can"}, {"sha": "70f72acad1fb68be2cc00cf62da3aec4bb53ff3c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -135,8 +135,8 @@ pub enum AssociatedItemContainer {\n }\n \n impl AssociatedItemContainer {\n-    /// Asserts that this is the def-id of an associated item declared\n-    /// in a trait, and returns the trait def-id.\n+    /// Asserts that this is the `DefId` of an associated item declared\n+    /// in a trait, and returns the trait `DefId`.\n     pub fn assert_trait(&self) -> DefId {\n         match *self {\n             TraitContainer(id) => id,\n@@ -154,7 +154,7 @@ impl AssociatedItemContainer {\n \n /// The \"header\" of an impl is everything outside the body: a Self type, a trait\n /// ref (in the case of a trait impl), and a set of predicates (from the\n-/// bounds/where clauses).\n+/// bounds / where-clauses).\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct ImplHeader<'tcx> {\n     pub impl_def_id: DefId,\n@@ -328,7 +328,7 @@ pub enum Variance {\n /// item.\n pub struct CrateVariancesMap {\n     /// For each item with generics, maps to a vector of the variance\n-    /// of its generics.  If an item has no generics, it will have no\n+    /// of its generics. If an item has no generics, it will have no\n     /// entry.\n     pub variances: FxHashMap<DefId, Lrc<Vec<ty::Variance>>>,\n \n@@ -338,7 +338,7 @@ pub struct CrateVariancesMap {\n \n impl Variance {\n     /// `a.xform(b)` combines the variance of a context with the\n-    /// variance of a type with the following meaning.  If we are in a\n+    /// variance of a type with the following meaning. If we are in a\n     /// context with variance `a`, and we encounter a type argument in\n     /// a position with variance `b`, then `a.xform(b)` is the new\n     /// variance with which the argument appears.\n@@ -362,10 +362,10 @@ impl Variance {\n     /// The ambient variance is covariant. A `fn` type is\n     /// contravariant with respect to its parameters, so the variance\n     /// within which both pointer types appear is\n-    /// `Covariant.xform(Contravariant)`, or `Contravariant`.  `*const\n+    /// `Covariant.xform(Contravariant)`, or `Contravariant`. `*const\n     /// T` is covariant with respect to `T`, so the variance within\n     /// which the first `Vec<i32>` appears is\n-    /// `Contravariant.xform(Covariant)` or `Contravariant`.  The same\n+    /// `Contravariant.xform(Covariant)` or `Contravariant`. The same\n     /// is true for its `i32` argument. In the `*mut T` case, the\n     /// variance of `Vec<i32>` is `Contravariant.xform(Invariant)`,\n     /// and hence the outermost type is `Invariant` with respect to\n@@ -489,12 +489,12 @@ pub struct TyS<'tcx> {\n     /// So, for a type without any late-bound things, like `u32`, this\n     /// will be *innermost*, because that is the innermost binder that\n     /// captures nothing. But for a type `&'D u32`, where `'D` is a\n-    /// late-bound region with debruijn index `D`, this would be `D + 1`\n+    /// late-bound region with De Bruijn index `D`, this would be `D + 1`\n     /// -- the binder itself does not capture `D`, but `D` is captured\n     /// by an inner binder.\n     ///\n     /// We call this concept an \"exclusive\" binder `D` because all\n-    /// debruijn indices within the type are contained within `0..D`\n+    /// De Bruijn indices within the type are contained within `0..D`\n     /// (exclusive).\n     outer_exclusive_binder: ty::DebruijnIndex,\n }\n@@ -720,9 +720,9 @@ pub struct UpvarPath {\n     pub hir_id: hir::HirId,\n }\n \n-/// Upvars do not get their own node-id. Instead, we use the pair of\n-/// the original var id (that is, the root variable that is referenced\n-/// by the upvar) and the id of the closure expression.\n+/// Upvars do not get their own `NodeId`. Instead, we use the pair of\n+/// the original var ID (that is, the root variable that is referenced\n+/// by the upvar) and the ID of the closure expression.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct UpvarId {\n     pub var_path: UpvarPath,\n@@ -734,7 +734,7 @@ pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     ImmBorrow,\n \n-    /// Data must be immutable but not aliasable.  This kind of borrow\n+    /// Data must be immutable but not aliasable. This kind of borrow\n     /// cannot currently be expressed by the user and is used only in\n     /// implicit closure bindings. It is needed when the closure\n     /// is borrowing or mutating a mutable referent, e.g.:\n@@ -1096,7 +1096,7 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n     /// Performs a substitution suitable for going from a\n     /// poly-trait-ref to supertraits that must hold if that\n     /// poly-trait-ref holds. This is slightly different from a normal\n-    /// substitution in terms of what happens with bound regions.  See\n+    /// substitution in terms of what happens with bound regions. See\n     /// lengthy comment below for details.\n     pub fn subst_supertrait(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                             trait_ref: &ty::PolyTraitRef<'tcx>)\n@@ -1235,7 +1235,7 @@ pub type PolySubtypePredicate<'tcx> = ty::Binder<SubtypePredicate<'tcx>>;\n /// This kind of predicate has no *direct* correspondent in the\n /// syntax, but it roughly corresponds to the syntactic forms:\n ///\n-/// 1. `T: TraitRef<..., Item=Type>`\n+/// 1. `T: TraitRef<..., Item = Type>`\n /// 2. `<T as TraitRef<...>>::Item == Type` (NYI)\n ///\n /// In particular, form #1 is \"desugared\" to the combination of a\n@@ -1456,8 +1456,8 @@ impl<'tcx> Predicate<'tcx> {\n }\n \n /// Represents the bounds declared on a particular set of type\n-/// parameters.  Should eventually be generalized into a flag list of\n-/// where clauses.  You can obtain a `InstantiatedPredicates` list from a\n+/// parameters. Should eventually be generalized into a flag list of\n+/// where-clauses. You can obtain a `InstantiatedPredicates` list from a\n /// `GenericPredicates` by using the `instantiate` method. Note that this method\n /// reflects an important semantic invariant of `InstantiatedPredicates`: while\n /// the `GenericPredicates` are expressed in terms of the bound type\n@@ -1471,7 +1471,7 @@ impl<'tcx> Predicate<'tcx> {\n ///     struct Foo<T,U:Bar<T>> { ... }\n ///\n /// Here, the `GenericPredicates` for `Foo` would contain a list of bounds like\n-/// `[[], [U:Bar<T>]]`.  Now if there were some particular reference\n+/// `[[], [U:Bar<T>]]`. Now if there were some particular reference\n /// like `Foo<isize,usize>`, then the `InstantiatedPredicates` would be `[[],\n /// [usize:Bar<isize>]]`.\n #[derive(Clone)]\n@@ -1537,7 +1537,7 @@ impl UniverseIndex {\n \n     /// Returns the \"next\" universe index in order -- this new index\n     /// is considered to extend all previous universes. This\n-    /// corresponds to entering a `forall` quantifier.  So, for\n+    /// corresponds to entering a `forall` quantifier. So, for\n     /// example, suppose we have this type in universe `U`:\n     ///\n     /// ```\n@@ -1619,20 +1619,20 @@ pub struct ParamEnv<'tcx> {\n \n impl<'tcx> ParamEnv<'tcx> {\n     /// Construct a trait environment suitable for contexts where\n-    /// there are no where clauses in scope. Hidden types (like `impl\n+    /// there are no where-clauses in scope. Hidden types (like `impl\n     /// Trait`) are left hidden, so this is suitable for ordinary\n     /// type-checking.\n     #[inline]\n     pub fn empty() -> Self {\n         Self::new(List::empty(), Reveal::UserFacing, None)\n     }\n \n-    /// Construct a trait environment with no where clauses in scope\n+    /// Construct a trait environment with no where-clauses in scope\n     /// where the values of all `impl Trait` and other hidden types\n     /// are revealed. This is suitable for monomorphized, post-typeck\n     /// environments like codegen or doing optimizations.\n     ///\n-    /// N.B. If you want to have predicates in scope, use `ParamEnv::new`,\n+    /// N.B., if you want to have predicates in scope, use `ParamEnv::new`,\n     /// or invoke `param_env.with_reveal_all()`.\n     #[inline]\n     pub fn reveal_all() -> Self {\n@@ -1651,7 +1651,7 @@ impl<'tcx> ParamEnv<'tcx> {\n \n     /// Returns a new parameter environment with the same clauses, but\n     /// which \"reveals\" the true results of projections in all cases\n-    /// (even for associated types that are specializable).  This is\n+    /// (even for associated types that are specializable). This is\n     /// the desired behavior during codegen and certain other special\n     /// contexts; normally though we want to use `Reveal::UserFacing`,\n     /// which is the default.\n@@ -1736,7 +1736,7 @@ impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>> for ParamEnvAnd<'gcx, T>\n \n #[derive(Copy, Clone, Debug)]\n pub struct Destructor {\n-    /// The def-id of the destructor method\n+    /// The `DefId` of the destructor method\n     pub did: DefId,\n }\n \n@@ -1781,20 +1781,21 @@ pub struct VariantDef {\n }\n \n impl<'a, 'gcx, 'tcx> VariantDef {\n-    /// Create a new `VariantDef`.\n+    /// Creates a new `VariantDef`.\n     ///\n-    /// - `did` is the DefId used for the variant - for tuple-structs, it is the constructor DefId,\n-    /// and for everything else, it is the variant DefId.\n+    /// - `did` is the `DefId` used for the variant.\n+    /// This is the constructor `DefId` for tuple stucts, and the variant `DefId` for everything\n+    /// else.\n     /// - `attribute_def_id` is the DefId that has the variant's attributes.\n-    /// this is the struct DefId for structs, and the variant DefId for variants.\n+    /// This is the struct `DefId` for structs, and the variant `DefId` for variants.\n     ///\n-    /// Note that we *could* use the constructor DefId, because the constructor attributes\n+    /// Note that we *could* use the constructor `DefId`, because the constructor attributes\n     /// redirect to the base attributes, but compiling a small crate requires\n-    /// loading the AdtDefs for all the structs in the universe (e.g., coherence for any\n+    /// loading the `AdtDef`s for all the structs in the universe (e.g., coherence for any\n     /// built-in trait), and we do not want to load attributes twice.\n     ///\n     /// If someone speeds up attribute loading to not be a performance concern, they can\n-    /// remove this hack and use the constructor DefId everywhere.\n+    /// remove this hack and use the constructor `DefId` everywhere.\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                did: DefId,\n                ident: Ident,\n@@ -2049,13 +2050,13 @@ impl ReprOptions {\n     }\n \n     /// Returns `true` if this `#[repr()]` should inhibit struct field reordering\n-    /// optimizations, such as with repr(C), repr(packed(1)), or repr(<int>).\n+    /// optimizations, such as with `repr(C)`, `repr(packed(1))`, or `repr(<int>)`.\n     pub fn inhibit_struct_field_reordering_opt(&self) -> bool {\n         self.flags.intersects(ReprFlags::IS_UNOPTIMISABLE) || self.pack == 1 ||\n             self.int.is_some()\n     }\n \n-    /// Returns true if this `#[repr()]` should inhibit union abi optimisations\n+    /// Returns `true` if this `#[repr()]` should inhibit union ABI optimisations.\n     pub fn inhibit_union_abi_opt(&self) -> bool {\n         self.c()\n     }\n@@ -2170,14 +2171,14 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.flags.contains(AdtFlags::HAS_CTOR)\n     }\n \n-    /// Returns whether this type is `#[fundamental]` for the purposes\n+    /// Returns `true` if this type is `#[fundamental]` for the purposes\n     /// of coherence checking.\n     #[inline]\n     pub fn is_fundamental(&self) -> bool {\n         self.flags.contains(AdtFlags::IS_FUNDAMENTAL)\n     }\n \n-    /// Returns `true` if this is PhantomData<T>.\n+    /// Returns `true` if this is `PhantomData<T>`.\n     #[inline]\n     pub fn is_phantom_data(&self) -> bool {\n         self.flags.contains(AdtFlags::IS_PHANTOM_DATA)\n@@ -2199,7 +2200,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.flags.contains(AdtFlags::IS_BOX)\n     }\n \n-    /// Returns whether this type has a destructor.\n+    /// Returns `true` if this type has a destructor.\n     pub fn has_dtor(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n         self.destructor(tcx).is_some()\n     }\n@@ -2320,7 +2321,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         })\n     }\n \n-    /// Compute the discriminant value used by a specific variant.\n+    /// Computes the discriminant value used by a specific variant.\n     /// Unlike `discriminants`, this is (amortized) constant-time,\n     /// only doing at most one query for evaluating an explicit\n     /// discriminant (the last one before the requested variant),\n@@ -2336,9 +2337,9 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         explicit_value.checked_add(tcx, offset as u128).0\n     }\n \n-    /// Yields a DefId for the discriminant and an offset to add to it\n+    /// Yields a `DefId` for the discriminant and an offset to add to it\n     /// Alternatively, if there is no explicit discriminant, returns the\n-    /// inferred discriminant directly\n+    /// inferred discriminant directly.\n     pub fn discriminant_def_for_variant(\n         &self,\n         variant_index: VariantIdx,\n@@ -2368,15 +2369,15 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n \n     /// Returns a list of types such that `Self: Sized` if and only\n-    /// if that type is Sized, or `TyErr` if this type is recursive.\n+    /// if that type is `Sized`, or `TyErr` if this type is recursive.\n     ///\n-    /// Oddly enough, checking that the sized-constraint is Sized is\n+    /// Oddly enough, checking that the sized-constraint is `Sized` is\n     /// actually more expressive than checking all members:\n-    /// the Sized trait is inductive, so an associated type that references\n-    /// Self would prevent its containing ADT from being Sized.\n+    /// the `Sized` trait is inductive, so an associated type that references\n+    /// `Self` would prevent its containing ADT from being `Sized`.\n     ///\n     /// Due to normalization being eager, this applies even if\n-    /// the associated type is behind a pointer, e.g., issue #31299.\n+    /// the associated type is behind a pointer (e.g., issue #31299).\n     pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx [Ty<'tcx>] {\n         match tcx.try_adt_sized_constraint(DUMMY_SP, self.did) {\n             Ok(tys) => tys,\n@@ -2480,7 +2481,7 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n     }\n }\n \n-/// Represents the various closure traits in the Rust language. This\n+/// Represents the various closure traits in the language. This\n /// will determine the type of the environment (`self`, in the\n /// desugaring) argument that the closure expects.\n ///\n@@ -2552,15 +2553,15 @@ impl<'tcx> TyS<'tcx> {\n         TypeWalker::new(self)\n     }\n \n-    /// Iterator that walks the immediate children of `self`.  Hence\n+    /// Iterator that walks the immediate children of `self`. Hence\n     /// `Foo<Bar<i32>, u32>` yields the sequence `[Bar<i32>, u32]`\n     /// (but not `i32`, like `walk`).\n     pub fn walk_shallow(&'tcx self) -> smallvec::IntoIter<walk::TypeWalkerArray<'tcx>> {\n         walk::walk_shallow(self)\n     }\n \n     /// Walks `ty` and any types appearing within `ty`, invoking the\n-    /// callback `f` on each type. If the callback returns false, then the\n+    /// callback `f` on each type. If the callback returns `false`, then the\n     /// children of the current type are ignored.\n     ///\n     /// Note: prefer `ty.walk()` where possible.\n@@ -2670,7 +2671,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.typeck_tables_of(self.hir().body_owner_def_id(body))\n     }\n \n-    /// Returns an iterator of the def-ids for all body-owners in this\n+    /// Returns an iterator of the `DefId`s for all body-owners in this\n     /// crate. If you would prefer to iterate over the bodies\n     /// themselves, you can do `self.hir().krate().body_ids.iter()`.\n     pub fn body_owners(\n@@ -2917,7 +2918,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Return the possibly-auto-generated MIR of a (DefId, Subst) pair.\n+    /// Returns the possibly-auto-generated MIR of a `(DefId, Subst)` pair.\n     pub fn instance_mir(self, instance: ty::InstanceDef<'gcx>)\n                         -> &'gcx Mir<'gcx>\n     {\n@@ -2937,7 +2938,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Get the attributes of a definition.\n+    /// Gets the attributes of a definition.\n     pub fn get_attrs(self, did: DefId) -> Attributes<'gcx> {\n         if let Some(id) = self.hir().as_local_hir_id(did) {\n             Attributes::Borrowed(self.hir().attrs_by_hir_id(id))\n@@ -2946,7 +2947,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Determine whether an item is annotated with an attribute.\n+    /// Determines whether an item is annotated with an attribute.\n     pub fn has_attr(self, did: DefId, attr: &str) -> bool {\n         attr::contains_name(&self.get_attrs(did), attr)\n     }\n@@ -2960,14 +2961,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.optimized_mir(def_id).generator_layout.as_ref().unwrap()\n     }\n \n-    /// Given the def-id of an impl, return the def_id of the trait it implements.\n-    /// If it implements no trait, return `None`.\n+    /// Given the `DefId` of an impl, returns the `DefId` of the trait it implements.\n+    /// If it implements no trait, returns `None`.\n     pub fn trait_id_of_impl(self, def_id: DefId) -> Option<DefId> {\n         self.impl_trait_ref(def_id).map(|tr| tr.def_id)\n     }\n \n-    /// If the given defid describes a method belonging to an impl, return the\n-    /// def-id of the impl that the method belongs to. Otherwise, return `None`.\n+    /// If the given defid describes a method belonging to an impl, returns the\n+    /// `DefId` of the impl that the method belongs to; otherwise, returns `None`.\n     pub fn impl_of_method(self, def_id: DefId) -> Option<DefId> {\n         let item = if def_id.krate != LOCAL_CRATE {\n             if let Some(Def::Method(_)) = self.describe_def(def_id) {\n@@ -2998,9 +2999,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    // Hygienically compare a use-site name (`use_name`) for a field or an associated item with its\n-    // supposed definition name (`def_name`). The method also needs `DefId` of the supposed\n-    // definition's parent/scope to perform comparison.\n+    /// Hygienically compares a use-site name (`use_name`) for a field or an associated item with\n+    /// its supposed definition name (`def_name`). The method also needs `DefId` of the supposed\n+    /// definition's parent/scope to perform comparison.\n     pub fn hygienic_eq(self, use_name: Ident, def_name: Ident, def_parent_def_id: DefId) -> bool {\n         self.adjust_ident(use_name, def_parent_def_id, DUMMY_NODE_ID).0 == def_name.modern()\n     }\n@@ -3082,7 +3083,7 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Asso\n               parent_item.node)\n }\n \n-/// Calculates the Sized-constraint.\n+/// Calculates the `Sized` constraint.\n ///\n /// In fact, there are only a few options for the types in the constraint:\n ///     - an obviously-unsized type\n@@ -3135,9 +3136,9 @@ fn def_span<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Span {\n     tcx.hir().span_if_local(def_id).unwrap()\n }\n \n-/// If the given def ID describes an item belonging to a trait,\n-/// return the ID of the trait that the trait item belongs to.\n-/// Otherwise, return `None`.\n+/// If the given `DefId` describes an item belonging to a trait,\n+/// returns the `DefId` of the trait that the trait item belongs to;\n+/// otherwise, returns `None`.\n fn trait_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option<DefId> {\n     tcx.opt_associated_item(def_id)\n         .and_then(|associated_item| {\n@@ -3232,10 +3233,9 @@ fn instance_def_size_estimate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-/// If `def_id` is an issue 33140 hack impl, return its self type. Otherwise\n-/// return None.\n+/// If `def_id` is an issue 33140 hack impl, returns its self type; otherwise, returns `None`.\n ///\n-/// See ImplOverlapKind::Issue33140 for more details.\n+/// See [`ImplOverlapKind::Issue33140`] for more details.\n fn issue33140_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 def_id: DefId)\n                                 -> Option<Ty<'tcx>>"}, {"sha": "16b4af535943bb8d3e76003609ac207a418bc7ef", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -31,37 +31,38 @@ use {\n     rustc_data_structures::stable_hasher::{StableHasherResult, StableHasher, HashStable},\n };\n \n-/// Indicates the state of a query for a given key in a query map\n+/// Indicates the state of a query for a given key in a query map.\n pub(super) enum QueryResult<'tcx> {\n-    /// An already executing query. The query job can be used to await for its completion\n+    /// An already executing query. The query job can be used to await for its completion.\n     Started(Lrc<QueryJob<'tcx>>),\n \n-    /// The query panicked. Queries trying to wait on this will raise a fatal error / silently panic\n+    /// The query panicked. Queries trying to wait on this will raise a fatal error or\n+    /// silently panic.\n     Poisoned,\n }\n \n-/// A span and a query key\n+/// Represents a span and a query key.\n #[derive(Clone, Debug)]\n pub struct QueryInfo<'tcx> {\n-    /// The span for a reason this query was required\n+    /// The span corresponding to the reason for which this query was required.\n     pub span: Span,\n     pub query: Query<'tcx>,\n }\n \n-/// A object representing an active query job.\n+/// Representss an object representing an active query job.\n pub struct QueryJob<'tcx> {\n     pub info: QueryInfo<'tcx>,\n \n     /// The parent query job which created this job and is implicitly waiting on it.\n     pub parent: Option<Lrc<QueryJob<'tcx>>>,\n \n-    /// The latch which is used to wait on this job\n+    /// The latch that is used to wait on this job.\n     #[cfg(parallel_compiler)]\n     latch: QueryLatch<'tcx>,\n }\n \n impl<'tcx> QueryJob<'tcx> {\n-    /// Creates a new query job\n+    /// Creates a new query job.\n     pub fn new(info: QueryInfo<'tcx>, parent: Option<Lrc<QueryJob<'tcx>>>) -> Self {\n         QueryJob {\n             info,\n@@ -230,7 +231,7 @@ impl<'tcx> QueryLatch<'tcx> {\n         }\n     }\n \n-    /// Remove a single waiter from the list of waiters.\n+    /// Removes a single waiter from the list of waiters.\n     /// This is used to break query cycles.\n     fn extract_waiter(\n         &self,"}, {"sha": "67a5c7d6c9a64b8e7ab95ee27ca88a9859953385", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -102,12 +102,12 @@ define_queries! { <'tcx>\n         /// Records the type of every item.\n         [] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n \n-        /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n+        /// Maps from the `DefId` of an item (trait/struct/enum/fn) to its\n         /// associated generics.\n         [] fn generics_of: GenericsOfItem(DefId) -> &'tcx ty::Generics,\n \n-        /// Maps from the def-id of an item (trait/struct/enum/fn) to the\n-        /// predicates (where clauses) that must be proven true in order\n+        /// Maps from the `DefId` of an item (trait/struct/enum/fn) to the\n+        /// predicates (where-clauses) that must be proven true in order\n         /// to reference it. This is almost always the \"predicates query\"\n         /// that you want.\n         ///\n@@ -123,8 +123,8 @@ define_queries! { <'tcx>\n         /// user.)\n         [] fn predicates_of: PredicatesOfItem(DefId) -> Lrc<ty::GenericPredicates<'tcx>>,\n \n-        /// Maps from the def-id of an item (trait/struct/enum/fn) to the\n-        /// predicates (where clauses) directly defined on it. This is\n+        /// Maps from the `DefId` of an item (trait/struct/enum/fn) to the\n+        /// predicates (where-clauses) directly defined on it. This is\n         /// equal to the `explicit_predicates_of` predicates plus the\n         /// `inferred_outlives_of` predicates.\n         [] fn predicates_defined_on: PredicatesDefinedOnItem(DefId)\n@@ -138,7 +138,7 @@ define_queries! { <'tcx>\n         /// Foo<'a, T> { x: &'a T }`, this would return `T: 'a`).\n         [] fn inferred_outlives_of: InferredOutlivesOf(DefId) -> Lrc<Vec<ty::Predicate<'tcx>>>,\n \n-        /// Maps from the def-id of a trait to the list of\n+        /// Maps from the `DefId` of a trait to the list of\n         /// super-predicates. This is a subset of the full list of\n         /// predicates. We store these in a separate map because we must\n         /// evaluate them even during type conversion, often before the\n@@ -216,7 +216,7 @@ define_queries! { <'tcx>\n     },\n \n     Codegen {\n-        /// Set of all the def-ids in this crate that have MIR associated with\n+        /// Set of all the `DefId`s in this crate that have MIR associated with\n         /// them. This includes all the body owners, but also things like struct\n         /// constructors.\n         [] fn mir_keys: mir_keys(CrateNum) -> Lrc<DefIdSet>,\n@@ -226,11 +226,11 @@ define_queries! { <'tcx>\n         /// the value isn't known except to the pass itself.\n         [] fn mir_const_qualif: MirConstQualif(DefId) -> (u8, Lrc<BitSet<mir::Local>>),\n \n-        /// Fetch the MIR for a given def-id right after it's built - this includes\n+        /// Fetch the MIR for a given `DefId` right after it's built - this includes\n         /// unreachable code.\n         [] fn mir_built: MirBuilt(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n \n-        /// Fetch the MIR for a given def-id up till the point where it is\n+        /// Fetch the MIR for a given `DefId` up till the point where it is\n         /// ready for const evaluation.\n         ///\n         /// See the README for the `mir` module for details.\n@@ -244,7 +244,7 @@ define_queries! { <'tcx>\n     },\n \n     TypeChecking {\n-        /// The result of unsafety-checking this def-id.\n+        /// The result of unsafety-checking this `DefId`.\n         [] fn unsafety_check_result: UnsafetyCheckResult(DefId) -> mir::UnsafetyCheckResult,\n \n         /// HACK: when evaluated, this reports a \"unsafe derive on repr(packed)\" error\n@@ -307,23 +307,23 @@ define_queries! { <'tcx>\n     TypeChecking {\n         /// Gets a complete map from all types to their inherent impls.\n         /// Not meant to be used directly outside of coherence.\n-        /// (Defined only for LOCAL_CRATE)\n+        /// (Defined only for `LOCAL_CRATE`.)\n         [] fn crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum)\n             -> Lrc<CrateInherentImpls>,\n \n-        /// Checks all types in the krate for overlap in their inherent impls. Reports errors.\n+        /// Checks all types in the crate for overlap in their inherent impls. Reports errors.\n         /// Not meant to be used directly outside of coherence.\n-        /// (Defined only for LOCAL_CRATE)\n+        /// (Defined only for `LOCAL_CRATE`.)\n         [] fn crate_inherent_impls_overlap_check: inherent_impls_overlap_check_dep_node(CrateNum)\n             -> (),\n     },\n \n     Other {\n         /// Evaluate a constant without running sanity checks\n         ///\n-        /// DO NOT USE THIS outside const eval. Const eval uses this to break query cycles during\n-        /// validation. Please add a comment to every use site explaining why using `const_eval`\n-        /// isn't sufficient\n+        /// **Do not use this** outside const eval. Const eval uses this to break query cycles\n+        /// during validation. Please add a comment to every use site explaining why using\n+        /// `const_eval` isn't sufficient\n         [] fn const_eval_raw: const_eval_raw_dep_node(ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n             -> ConstEvalRawResult<'tcx>,\n \n@@ -344,7 +344,7 @@ define_queries! { <'tcx>\n     Other {\n         [] fn reachable_set: reachability_dep_node(CrateNum) -> ReachableSet,\n \n-        /// Per-body `region::ScopeTree`. The `DefId` should be the owner-def-id for the body;\n+        /// Per-body `region::ScopeTree`. The `DefId` should be the owner `DefId` for the body;\n         /// in the case of closures, this will be redirected to the enclosing function.\n         [] fn region_scope_tree: RegionScopeTree(DefId) -> Lrc<region::ScopeTree>,\n \n@@ -398,7 +398,7 @@ define_queries! { <'tcx>\n             -> Lrc<specialization_graph::Graph>,\n         [] fn is_object_safe: ObjectSafety(DefId) -> bool,\n \n-        /// Get the ParameterEnvironment for a given item; this environment\n+        /// Gets the ParameterEnvironment for a given item; this environment\n         /// will be in \"user-facing\" mode, meaning that it is suitabe for\n         /// type-checking etc, and it does not normalize specializable\n         /// associated types. This is almost always what you want,\n@@ -485,7 +485,7 @@ define_queries! { <'tcx>\n \n         [] fn foreign_modules: ForeignModules(CrateNum) -> Lrc<Vec<ForeignModule>>,\n \n-        /// Identifies the entry-point (e.g. the `main` function) for a given\n+        /// Identifies the entry-point (e.g., the `main` function) for a given\n         /// crate, returning `None` if there is no entry point (such as for library crates).\n         [] fn entry_fn: EntryFn(CrateNum) -> Option<(DefId, EntryFnType)>,\n         [] fn plugin_registrar_fn: PluginRegistrarFn(CrateNum) -> Option<DefId>,"}, {"sha": "f948abc7f6fd366a74c85da9715fbef3407302b4", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -103,7 +103,7 @@ impl AbsoluteBytePos {\n }\n \n impl<'sess> OnDiskCache<'sess> {\n-    /// Create a new OnDiskCache instance from the serialized data in `data`.\n+    /// Creates a new OnDiskCache instance from the serialized data in `data`.\n     pub fn new(sess: &'sess Session, data: Vec<u8>, start_pos: usize) -> OnDiskCache<'sess> {\n         debug_assert!(sess.opts.incremental.is_some());\n \n@@ -325,7 +325,7 @@ impl<'sess> OnDiskCache<'sess> {\n         })\n     }\n \n-    /// Load a diagnostic emitted during the previous compilation session.\n+    /// Loads a diagnostic emitted during the previous compilation session.\n     pub fn load_diagnostics<'a, 'tcx>(&self,\n                                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       dep_node_index: SerializedDepNodeIndex)\n@@ -339,7 +339,7 @@ impl<'sess> OnDiskCache<'sess> {\n         diagnostics.unwrap_or_default()\n     }\n \n-    /// Store a diagnostic emitted during the current compilation session.\n+    /// Stores a diagnostic emitted during the current compilation session.\n     /// Anything stored like this will be available via `load_diagnostics` in\n     /// the next compilation session.\n     #[inline(never)]\n@@ -353,7 +353,7 @@ impl<'sess> OnDiskCache<'sess> {\n     }\n \n     /// Returns the cached query result if there is something in the cache for\n-    /// the given SerializedDepNodeIndex. Otherwise returns None.\n+    /// the given `SerializedDepNodeIndex`; otherwise returns `None`.\n     pub fn try_load_query_result<'tcx, T>(&self,\n                                           tcx: TyCtxt<'_, 'tcx, 'tcx>,\n                                           dep_node_index: SerializedDepNodeIndex)\n@@ -366,7 +366,7 @@ impl<'sess> OnDiskCache<'sess> {\n                           \"query result\")\n     }\n \n-    /// Store a diagnostic emitted during computation of an anonymous query.\n+    /// Stores a diagnostic emitted during computation of an anonymous query.\n     /// Since many anonymous queries can share the same `DepNode`, we aggregate\n     /// them -- as opposed to regular queries where we assume that there is a\n     /// 1:1 relationship between query-key and `DepNode`."}, {"sha": "9b2a70a6a6d20583ed52fa6fd0ecc6bcb5844f8c", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,6 +1,6 @@\n-//! The implementation of the query system itself. Defines the macros\n-//! that generate the actual methods on tcx which find and execute the\n-//! provider, manage the caches, and so forth.\n+//! The implementation of the query system itself. This defines the macros that\n+//! generate the actual methods on tcx which find and execute the provider,\n+//! manage the caches, and so forth.\n \n use crate::dep_graph::{DepNodeIndex, DepNode, DepKind, SerializedDepNodeIndex};\n use crate::errors::DiagnosticBuilder;\n@@ -1017,16 +1017,16 @@ macro_rules! define_queries_inner {\n         }\n \n         impl<'a, $tcx, 'lcx> TyCtxt<'a, $tcx, 'lcx> {\n-            /// Return a transparent wrapper for `TyCtxt` which ensures queries\n-            /// are executed instead of returing their result\n+            /// Returns a transparent wrapper for `TyCtxt`, which ensures queries\n+            /// are executed instead of just returing their results.\n             #[inline(always)]\n             pub fn ensure(self) -> TyCtxtEnsure<'a, $tcx, 'lcx> {\n                 TyCtxtEnsure {\n                     tcx: self,\n                 }\n             }\n \n-            /// Return a transparent wrapper for `TyCtxt` which uses\n+            /// Returns a transparent wrapper for `TyCtxt` which uses\n             /// `span` as the location of queries performed through it.\n             #[inline(always)]\n             pub fn at(self, span: Span) -> TyCtxtAt<'a, $tcx, 'lcx> {\n@@ -1067,7 +1067,7 @@ macro_rules! define_queries_struct {\n     (tcx: $tcx:tt,\n      input: ($(([$($modifiers:tt)*] [$($attr:tt)*] [$name:ident]))*)) => {\n         pub struct Queries<$tcx> {\n-            /// This provides access to the incr. comp. on-disk cache for query results.\n+            /// This provides access to the incrimental comilation on-disk cache for query results.\n             /// Do not access this directly. It is only meant to be used by\n             /// `DepGraph::try_mark_green()` and the query infrastructure.\n             pub(crate) on_disk_cache: OnDiskCache<'tcx>,\n@@ -1123,22 +1123,22 @@ macro_rules! define_provider_struct {\n ///\n /// Now, if force_from_dep_node() would always fail, it would be pretty useless.\n /// Fortunately, we can use some contextual information that will allow us to\n-/// reconstruct query-keys for certain kinds of DepNodes. In particular, we\n-/// enforce by construction that the GUID/fingerprint of certain DepNodes is a\n-/// valid DefPathHash. Since we also always build a huge table that maps every\n-/// DefPathHash in the current codebase to the corresponding DefId, we have\n+/// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n+/// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n+/// valid `DefPathHash`. Since we also always build a huge table that maps every\n+/// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n /// everything we need to re-run the query.\n ///\n /// Take the `mir_validated` query as an example. Like many other queries, it\n-/// just has a single parameter: the DefId of the item it will compute the\n-/// validated MIR for. Now, when we call `force_from_dep_node()` on a dep-node\n-/// with kind `MirValidated`, we know that the GUID/fingerprint of the dep-node\n-/// is actually a DefPathHash, and can therefore just look up the corresponding\n-/// DefId in `tcx.def_path_hash_to_def_id`.\n+/// just has a single parameter: the `DefId` of the item it will compute the\n+/// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n+/// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n+/// is actually a `DefPathHash`, and can therefore just look up the corresponding\n+/// `DefId` in `tcx.def_path_hash_to_def_id`.\n ///\n /// When you implement a new query, it will likely have a corresponding new\n-/// DepKind, and you'll have to support it here in `force_from_dep_node()`. As\n-/// a rule of thumb, if your query takes a DefId or DefIndex as sole parameter,\n+/// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n+/// a rule of thumb, if your query takes a `DefId` or `DefIndex` as sole parameter,\n /// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n /// add it to the \"We don't have enough information to reconstruct...\" group in\n /// the match below."}, {"sha": "db248072d9b5009f7c7c426b14d00591b4173f5b", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -30,7 +30,7 @@ pub trait TypeRelation<'a, 'gcx: 'a+'tcx, 'tcx: 'a> : Sized {\n     /// Returns a static string we can use for printouts.\n     fn tag(&self) -> &'static str;\n \n-    /// Returns true if the value `a` is the \"expected\" type in the\n+    /// Returns `true` if the value `a` is the \"expected\" type in the\n     /// relation. Just affects error messages.\n     fn a_is_expected(&self) -> bool;\n "}, {"sha": "a8f9301ba51c96c74fea8e5e3ef0035a87247384", "filename": "src/librustc/ty/steal.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fsteal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fsteal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsteal.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -12,14 +12,14 @@ use rustc_data_structures::sync::{RwLock, ReadGuard, MappedReadGuard};\n /// Steal<Mir<'tcx>>` (to be very specific). Now we can read from this\n /// as much as we want (using `borrow()`), but you can also\n /// `steal()`. Once you steal, any further attempt to read will panic.\n-/// Therefore we know that -- assuming no ICE -- nobody is observing\n+/// Therefore, we know that -- assuming no ICE -- nobody is observing\n /// the fact that the MIR was updated.\n ///\n /// Obviously, whenever you have a query that yields a `Steal` value,\n /// you must treat it with caution, and make sure that you know that\n /// -- once the value is stolen -- it will never be read from again.\n-///\n-/// FIXME(#41710) -- what is the best way to model linear queries?\n+//\n+// FIXME(#41710): what is the best way to model linear queries?\n pub struct Steal<T> {\n     value: RwLock<Option<T>>\n }"}, {"sha": "66efd2aea155a7f704bf76287f15587a6dc5b47a", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -47,7 +47,7 @@ pub enum BoundRegion {\n \n     /// Named region parameters for functions (a in &'a T)\n     ///\n-    /// The def-id is needed to distinguish free regions in\n+    /// The `DefId` is needed to distinguish free regions in\n     /// the event of shadowing.\n     BrNamed(DefId, InternedString),\n \n@@ -87,7 +87,7 @@ pub enum TyKind<'tcx> {\n     Bool,\n \n     /// The primitive character type; holds a Unicode scalar value\n-    /// (a non-surrogate code point).  Written as `char`.\n+    /// (a non-surrogate code point). Written as `char`.\n     Char,\n \n     /// A primitive signed integer type. For example, `i32`.\n@@ -116,7 +116,7 @@ pub enum TyKind<'tcx> {\n     /// An array with the given length. Written as `[T; n]`.\n     Array(Ty<'tcx>, &'tcx ty::LazyConst<'tcx>),\n \n-    /// The pointee of an array slice.  Written as `[T]`.\n+    /// The pointee of an array slice. Written as `[T]`.\n     Slice(Ty<'tcx>),\n \n     /// A raw pointer. Written as `*mut T` or `*const T`\n@@ -138,7 +138,7 @@ pub enum TyKind<'tcx> {\n     /// ```\n     FnDef(DefId, &'tcx Substs<'tcx>),\n \n-    /// A pointer to a function.  Written as `fn() -> i32`.\n+    /// A pointer to a function. Written as `fn() -> i32`.\n     ///\n     /// For example the type of `bar` here:\n     ///\n@@ -166,10 +166,10 @@ pub enum TyKind<'tcx> {\n     /// The never type `!`\n     Never,\n \n-    /// A tuple type.  For example, `(i32, bool)`.\n+    /// A tuple type. For example, `(i32, bool)`.\n     Tuple(&'tcx List<Ty<'tcx>>),\n \n-    /// The projection of an associated type.  For example,\n+    /// The projection of an associated type. For example,\n     /// `<T as Trait<..>>::N`.\n     Projection(ProjectionTy<'tcx>),\n \n@@ -278,7 +278,7 @@ static_assert!(MEM_SIZE_OF_TY_KIND: ::std::mem::size_of::<TyKind<'_>>() == 24);\n ///\n /// All right, you say, but why include the type parameters from the\n /// original function then? The answer is that codegen may need them\n-/// when monomorphizing, and they may not appear in the upvars.  A\n+/// when monomorphizing, and they may not appear in the upvars. A\n /// closure could capture no variables but still make use of some\n /// in-scope type parameter with a bound (e.g., if our example above\n /// had an extra `U: Default`, and the closure called `U::default()`).\n@@ -295,9 +295,9 @@ static_assert!(MEM_SIZE_OF_TY_KIND: ::std::mem::size_of::<TyKind<'_>>() == 24);\n /// ## Generators\n ///\n /// Perhaps surprisingly, `ClosureSubsts` are also used for\n-/// generators.  In that case, what is written above is only half-true\n+/// generators. In that case, what is written above is only half-true\n /// -- the set of type parameters is similar, but the role of CK and\n-/// CS are different.  CK represents the \"yield type\" and CS\n+/// CS are different. CK represents the \"yield type\" and CS\n /// represents the \"return type\" of the generator.\n ///\n /// It'd be nice to split this struct into ClosureSubsts and\n@@ -442,17 +442,17 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n         self.split(def_id, tcx).return_ty\n     }\n \n-    /// Return the \"generator signature\", which consists of its yield\n+    /// Returns the \"generator signature\", which consists of its yield\n     /// and return types.\n     ///\n-    /// NB. Some bits of the code prefers to see this wrapped in a\n+    /// N.B., some bits of the code prefers to see this wrapped in a\n     /// binder, but it never contains bound regions. Probably this\n     /// function should be removed.\n     pub fn poly_sig(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> PolyGenSig<'tcx> {\n         ty::Binder::dummy(self.sig(def_id, tcx))\n     }\n \n-    /// Return the \"generator signature\", which consists of its yield\n+    /// Returns the \"generator signature\", which consists of its yield\n     /// and return types.\n     pub fn sig(self, def_id: DefId, tcx: TyCtxt<'_, '_, '_>) -> GenSig<'tcx> {\n         ty::GenSig {\n@@ -520,11 +520,11 @@ impl<'tcx> UpvarSubsts<'tcx> {\n \n #[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Ord, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum ExistentialPredicate<'tcx> {\n-    /// e.g., Iterator\n+    /// E.g., `Iterator`.\n     Trait(ExistentialTraitRef<'tcx>),\n-    /// e.g., Iterator::Item = T\n+    /// E.g., `Iterator::Item = T`.\n     Projection(ExistentialProjection<'tcx>),\n-    /// e.g., Send\n+    /// E.g., `Send`.\n     AutoTrait(DefId),\n }\n \n@@ -655,12 +655,12 @@ impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n }\n \n /// A complete reference to a trait. These take numerous guises in syntax,\n-/// but perhaps the most recognizable form is in a where clause:\n+/// but perhaps the most recognizable form is in a where-clause:\n ///\n ///     T: Foo<U>\n ///\n-/// This would be represented by a trait-reference where the def-id is the\n-/// def-id for the trait `Foo` and the substs define `T` as parameter 0,\n+/// This would be represented by a trait-reference where the `DefId` is the\n+/// `DefId` for the trait `Foo` and the substs define `T` as parameter 0,\n /// and `U` as parameter 1.\n ///\n /// Trait references also appear in object types like `Foo<U>`, but in\n@@ -766,9 +766,9 @@ impl<'a, 'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n         }\n     }\n \n-    /// Object types don't have a self-type specified. Therefore, when\n+    /// Object types don't have a self type specified. Therefore, when\n     /// we convert the principal trait-ref into a normal trait-ref,\n-    /// you must give *some* self-type. A common choice is `mk_err()`\n+    /// you must give *some* self type. A common choice is `mk_err()`\n     /// or some placeholder type.\n     pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n         -> ty::TraitRef<'tcx>  {\n@@ -789,9 +789,9 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n         self.skip_binder().def_id\n     }\n \n-    /// Object types don't have a self-type specified. Therefore, when\n+    /// Object types don't have a self type specified. Therefore, when\n     /// we convert the principal trait-ref into a normal trait-ref,\n-    /// you must give *some* self-type. A common choice is `mk_err()`\n+    /// you must give *some* self type. A common choice is `mk_err()`\n     /// or some placeholder type.\n     pub fn with_self_ty(&self, tcx: TyCtxt<'_, '_, 'tcx>,\n                         self_ty: Ty<'tcx>)\n@@ -829,7 +829,7 @@ impl<T> Binder<T> {\n \n     /// Skips the binder and returns the \"bound\" value. This is a\n     /// risky thing to do because it's easy to get confused about\n-    /// debruijn indices and the like. It is usually better to\n+    /// De Bruijn indices and the like. It is usually better to\n     /// discharge the binder using `no_bound_vars` or\n     /// `replace_late_bound_regions` or something like\n     /// that. `skip_binder` is only valid when you are either\n@@ -840,7 +840,7 @@ impl<T> Binder<T> {\n     ///\n     /// Some examples where `skip_binder` is reasonable:\n     ///\n-    /// - extracting the def-id from a PolyTraitRef;\n+    /// - extracting the `DefId` from a PolyTraitRef;\n     /// - comparing the self type of a PolyTraitRef to see if it is equal to\n     ///   a type parameter `X`, since the type `X` does not reference any regions\n     pub fn skip_binder(&self) -> &T {\n@@ -884,8 +884,8 @@ impl<T> Binder<T> {\n     }\n \n     /// Given two things that have the same binder level,\n-    /// and an operation that wraps on their contents, execute the operation\n-    /// and then wrap its result.\n+    /// and an operation that wraps on their contents, executes the operation\n+    /// and then wraps its result.\n     ///\n     /// `f` should consider bound regions at depth 1 to be free, and\n     /// anything it produces with bound regions at depth 1 will be\n@@ -896,7 +896,7 @@ impl<T> Binder<T> {\n         Binder(f(self.0, u.0))\n     }\n \n-    /// Split the contents into two things that share the same binder\n+    /// Splits the contents into two things that share the same binder\n     /// level as the original, returning two distinct binders.\n     ///\n     /// `f` should consider bound regions at depth 1 to be free, and\n@@ -1118,14 +1118,14 @@ pub type Region<'tcx> = &'tcx RegionKind;\n /// ## Bound Regions\n ///\n /// These are regions that are stored behind a binder and must be substituted\n-/// with some concrete region before being used. There are 2 kind of\n-/// bound regions: early-bound, which are bound in an item's Generics,\n-/// and are substituted by a Substs,  and late-bound, which are part of\n-/// higher-ranked types (e.g., `for<'a> fn(&'a ())`) and are substituted by\n+/// with some concrete region before being used. There are two kind of\n+/// bound regions: early-bound, which are bound in an item's `Generics`,\n+/// and are substituted by a `Substs`, and late-bound, which are part of\n+/// higher-ranked types (e.g., `for<'a> fn(&'a ())`), and are substituted by\n /// the likes of `liberate_late_bound_regions`. The distinction exists\n /// because higher-ranked lifetimes aren't supported in all places. See [1][2].\n ///\n-/// Unlike Param-s, bound regions are not supposed to exist \"in the wild\"\n+/// Unlike `Param`s, bound regions are not supposed to exist \"in the wild\"\n /// outside their binder, e.g., in types passed to type inference, and\n /// should first be substituted (by placeholder regions, free regions,\n /// or region variables).\n@@ -1141,7 +1141,7 @@ pub type Region<'tcx> = &'tcx RegionKind;\n /// To do this, we replace the bound regions with placeholder markers,\n /// which don't satisfy any relation not explicitly provided.\n ///\n-/// There are 2 kinds of placeholder regions in rustc: `ReFree` and\n+/// There are two kinds of placeholder regions in rustc: `ReFree` and\n /// `RePlaceholder`. When checking an item's body, `ReFree` is supposed\n /// to be used. These also support explicit bounds: both the internally-stored\n /// *scope*, which the region is assumed to outlive, as well as other\n@@ -1189,7 +1189,7 @@ pub enum RegionKind {\n     /// Static data that has an \"infinite\" lifetime. Top in the region lattice.\n     ReStatic,\n \n-    /// A region variable.  Should not exist after typeck.\n+    /// A region variable. Should not exist after typeck.\n     ReVar(RegionVid),\n \n     /// A placeholder region - basically the higher-ranked version of ReFree.\n@@ -1346,11 +1346,11 @@ impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n \n impl DebruijnIndex {\n     /// Returns the resulting index when this value is moved into\n-    /// `amount` number of new binders. So e.g., if you had\n+    /// `amount` number of new binders. So, e.g., if you had\n     ///\n     ///    for<'a> fn(&'a x)\n     ///\n-    /// and you wanted to change to\n+    /// and you wanted to change it to\n     ///\n     ///    for<'a> fn(for<'b> fn(&'a x))\n     ///\n@@ -1378,7 +1378,7 @@ impl DebruijnIndex {\n         *self = self.shifted_out(amount);\n     }\n \n-    /// Adjusts any Debruijn Indices so as to make `to_binder` the\n+    /// Adjusts any De Bruijn indices so as to make `to_binder` the\n     /// innermost binder. That is, if we have something bound at `to_binder`,\n     /// it will now be bound at INNERMOST. This is an appropriate thing to do\n     /// when moving a region out from inside binders:\n@@ -1388,12 +1388,12 @@ impl DebruijnIndex {\n     /// // Binder:  D3           D2        D1            ^^\n     /// ```\n     ///\n-    /// Here, the region `'a` would have the debruijn index D3,\n+    /// Here, the region `'a` would have the De Bruijn index D3,\n     /// because it is the bound 3 binders out. However, if we wanted\n     /// to refer to that region `'a` in the second argument (the `_`),\n     /// those two binders would not be in scope. In that case, we\n     /// might invoke `shift_out_to_binder(D3)`. This would adjust the\n-    /// debruijn index of `'a` to D1 (the innermost binder).\n+    /// De Bruijn index of `'a` to D1 (the innermost binder).\n     ///\n     /// If we invoke `shift_out_to_binder` and the region is in fact\n     /// bound by one of the binders we are shifting out of, that is an\n@@ -1444,7 +1444,7 @@ impl RegionKind {\n         }\n     }\n \n-    /// Adjusts any Debruijn Indices so as to make `to_binder` the\n+    /// Adjusts any De Bruijn indices so as to make `to_binder` the\n     /// innermost binder. That is, if we have something bound at `to_binder`,\n     /// it will now be bound at INNERMOST. This is an appropriate thing to do\n     /// when moving a region out from inside binders:\n@@ -1454,12 +1454,12 @@ impl RegionKind {\n     /// // Binder:  D3           D2        D1            ^^\n     /// ```\n     ///\n-    /// Here, the region `'a` would have the debruijn index D3,\n+    /// Here, the region `'a` would have the De Bruijn index D3,\n     /// because it is the bound 3 binders out. However, if we wanted\n     /// to refer to that region `'a` in the second argument (the `_`),\n     /// those two binders would not be in scope. In that case, we\n     /// might invoke `shift_out_to_binder(D3)`. This would adjust the\n-    /// debruijn index of `'a` to D1 (the innermost binder).\n+    /// De Bruijn index of `'a` to D1 (the innermost binder).\n     ///\n     /// If we invoke `shift_out_to_binder` and the region is in fact\n     /// bound by one of the binders we are shifting out of, that is an\n@@ -1528,7 +1528,7 @@ impl RegionKind {\n         flags\n     }\n \n-    /// Given an early-bound or free region, returns the def-id where it was bound.\n+    /// Given an early-bound or free region, returns the `DefId` where it was bound.\n     /// For example, consider the regions in this snippet of code:\n     ///\n     /// ```\n@@ -1543,10 +1543,10 @@ impl RegionKind {\n     /// }\n     /// ```\n     ///\n-    /// Here, `free_region_binding_scope('a)` would return the def-id\n+    /// Here, `free_region_binding_scope('a)` would return the `DefId`\n     /// of the impl, and for all the other highlighted regions, it\n-    /// would return the def-id of the function. In other cases (not shown), this\n-    /// function might return the def-id of a closure.\n+    /// would return the `DefId` of the function. In other cases (not shown), this\n+    /// function might return the `DefId` of a closure.\n     pub fn free_region_binding_scope(&self, tcx: TyCtxt<'_, '_, '_>) -> DefId {\n         match self {\n             ty::ReEarlyBound(br) => {\n@@ -1772,7 +1772,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    /// Returns true if this type is a floating point type and false otherwise.\n+    /// Returns `true` if this type is a floating point type.\n     pub fn is_floating_point(&self) -> bool {\n         match self.sty {\n             Float(_) |"}, {"sha": "7559ea90b1782059186053d3b8cd5c76e5716c1a", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -171,7 +171,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     /// Creates a `Substs` that maps each generic parameter to a higher-ranked\n     /// var bound at index `0`. For types, we use a `BoundVar` index equal to\n     /// the type parameter index. For regions, we use the `BoundRegion::BrNamed`\n-    /// variant (which has a def-id).\n+    /// variant (which has a `DefId`).\n     pub fn bound_vars_for_item(\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         def_id: DefId\n@@ -492,7 +492,7 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n         self.shift_vars_through_binders(ty)\n     }\n \n-    /// It is sometimes necessary to adjust the debruijn indices during substitution. This occurs\n+    /// It is sometimes necessary to adjust the De Bruijn indices during substitution. This occurs\n     /// when we are substituting a type with escaping bound vars into a context where we have\n     /// passed through binders. That's quite a mouthful. Let's see an example:\n     ///\n@@ -511,9 +511,9 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n     ///\n     /// Here the `'a` lifetime is bound in the outer function, but appears as an argument of the\n     /// inner one. Therefore, that appearance will have a DebruijnIndex of 2, because we must skip\n-    /// over the inner binder (remember that we count Debruijn indices from 1). However, in the\n+    /// over the inner binder (remember that we count De Bruijn indices from 1). However, in the\n     /// definition of `MetaFunc`, the binder is not visible, so the type `&'a int` will have a\n-    /// debruijn index of 1. It's only during the substitution that we can see we must increase the\n+    /// De Bruijn index of 1. It's only during the substitution that we can see we must increase the\n     /// depth by 1 to account for the binder that we passed through.\n     ///\n     /// As a second example, consider this twist:\n@@ -532,7 +532,7 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n     ///                      DebruijnIndex of 2\n     ///\n     /// As indicated in the diagram, here the same type `&'a int` is substituted once, but in the\n-    /// first case we do not increase the Debruijn index and in the second case we do. The reason\n+    /// first case we do not increase the De Bruijn index and in the second case we do. The reason\n     /// is that only in the second case have we passed through a fn binder.\n     fn shift_vars_through_binders(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         debug!(\"shift_vars(ty={:?}, binders_passed={:?}, has_escaping_bound_vars={:?})\",\n@@ -565,7 +565,7 @@ pub struct UserSubsts<'tcx> {\n     /// The substitutions for the item as given by the user.\n     pub substs: &'tcx Substs<'tcx>,\n \n-    /// The self-type, in the case of a `<T>::Item` path (when applied\n+    /// The self type, in the case of a `<T>::Item` path (when applied\n     /// to an inherent impl). See `UserSelfTy` below.\n     pub user_self_ty: Option<UserSelfTy<'tcx>>,\n }\n@@ -585,8 +585,8 @@ BraceStructLiftImpl! {\n     }\n }\n \n-/// Specifies the user-given self-type. In the case of a path that\n-/// refers to a member in an inherent impl, this self-type is\n+/// Specifies the user-given self type. In the case of a path that\n+/// refers to a member in an inherent impl, this self type is\n /// sometimes needed to constrain the type parameters on the impl. For\n /// example, in this code:\n ///\n@@ -596,11 +596,11 @@ BraceStructLiftImpl! {\n /// ```\n ///\n /// when you then have a path like `<Foo<&'static u32>>::method`,\n-/// this struct would carry the def-id of the impl along with the\n-/// self-type `Foo<u32>`. Then we can instantiate the parameters of\n+/// this struct would carry the `DefId` of the impl along with the\n+/// self type `Foo<u32>`. Then we can instantiate the parameters of\n /// the impl (with the substs from `UserSubsts`) and apply those to\n-/// the self-type, giving `Foo<?A>`. Finally, we unify that with\n-/// the self-type here, which contains `?A` to be `&'static u32`\n+/// the self type, giving `Foo<?A>`. Finally, we unify that with\n+/// the self type here, which contains `?A` to be `&'static u32`\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct UserSelfTy<'tcx> {\n     pub impl_def_id: DefId,"}, {"sha": "9ce8bf2e60a31dbddd74508d8159d70d2e8fdebe", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -39,7 +39,7 @@ pub struct TraitDef {\n #[derive(Default)]\n pub struct TraitImpls {\n     blanket_impls: Vec<DefId>,\n-    /// Impls indexed by their simplified self-type, for fast lookup.\n+    /// Impls indexed by their simplified self type, for fast lookup.\n     non_blanket_impls: FxHashMap<fast_reject::SimplifiedType, Vec<DefId>>,\n }\n \n@@ -84,7 +84,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Iterate over every impl that could possibly match the\n-    /// self-type `self_ty`.\n+    /// self type `self_ty`.\n     pub fn for_each_relevant_impl<F: FnMut(DefId)>(self,\n                                                    def_id: DefId,\n                                                    self_ty: Ty<'tcx>,\n@@ -134,7 +134,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Return a vector containing all impls\n+    /// Returns a vector containing all impls\n     pub fn all_impls(self, def_id: DefId) -> Vec<DefId> {\n         let impls = self.trait_impls_of(def_id);\n "}, {"sha": "0578162f84d02476ae4b5790df52e31a7ebba091", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,4 +1,4 @@\n-//! misc. type-system utilities too small to deserve their own file\n+//! Miscellaneous type-system utilities that are too small to deserve their own modules.\n \n use crate::hir::def::Def;\n use crate::hir::def_id::DefId;\n@@ -23,7 +23,7 @@ use syntax_pos::{Span, DUMMY_SP};\n \n #[derive(Copy, Clone, Debug)]\n pub struct Discr<'tcx> {\n-    /// bit representation of the discriminant, so `-128i8` is `0xFF_u128`\n+    /// Bit representation of the discriminant (e.g., `-128i8` is `0xFF_u128`).\n     pub val: u128,\n     pub ty: Ty<'tcx>\n }\n@@ -46,7 +46,7 @@ impl<'tcx> fmt::Display for Discr<'tcx> {\n }\n \n impl<'tcx> Discr<'tcx> {\n-    /// Adds 1 to the value and wraps around if the maximum for the type is reached\n+    /// Adds `1` to the value and wraps around if the maximum for the type is reached.\n     pub fn wrap_incr<'a, 'gcx>(self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n         self.checked_add(tcx, 1).0\n     }\n@@ -342,9 +342,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// Requires that trait definitions have been processed so that we can\n     /// elaborate predicates and walk supertraits.\n-    ///\n-    /// FIXME callers may only have a &[Predicate], not a Vec, so that's\n-    /// what this code should accept.\n+    //\n+    // FIXME: callers may only have a `&[Predicate]`, not a `Vec`, so that's\n+    // what this code should accept.\n     pub fn required_region_bounds(self,\n                                   erased_self_ty: Ty<'tcx>,\n                                   predicates: Vec<ty::Predicate<'tcx>>)\n@@ -417,7 +417,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         Some(ty::Destructor { did: dtor_did? })\n     }\n \n-    /// Return the set of types that are required to be alive in\n+    /// Returns the set of types that are required to be alive in\n     /// order to run the destructor of `def` (see RFCs 769 and\n     /// 1238).\n     ///\n@@ -507,17 +507,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         result\n     }\n \n-    /// True if `def_id` refers to a closure (e.g., `|x| x * 2`). Note\n-    /// that closures have a def-id, but the closure *expression* also\n+    /// Returns `true` if `def_id` refers to a closure (e.g., `|x| x * 2`). Note\n+    /// that closures have a `DefId`, but the closure *expression* also\n     /// has a `HirId` that is located within the context where the\n     /// closure appears (and, sadly, a corresponding `NodeId`, since\n     /// those are not yet phased out). The parent of the closure's\n-    /// def-id will also be the context where it appears.\n+    /// `DefId` will also be the context where it appears.\n     pub fn is_closure(self, def_id: DefId) -> bool {\n         self.def_key(def_id).disambiguated_data.data == DefPathData::ClosureExpr\n     }\n \n-    /// True if `def_id` refers to a trait (i.e., `trait Foo { ... }`).\n+    /// Returns `true` if `def_id` refers to a trait (i.e., `trait Foo { ... }`).\n     pub fn is_trait(self, def_id: DefId) -> bool {\n         if let DefPathData::Trait(_) = self.def_key(def_id).disambiguated_data.data {\n             true\n@@ -526,7 +526,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// True if `def_id` refers to a trait alias (i.e., `trait Foo = ...;`).\n+    /// Returns `true` if `def_id` refers to a trait alias (i.e., `trait Foo = ...;`),\n+    /// and `false` otherwise.\n     pub fn is_trait_alias(self, def_id: DefId) -> bool {\n         if let DefPathData::TraitAlias(_) = self.def_key(def_id).disambiguated_data.data {\n             true\n@@ -535,17 +536,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// True if this def-id refers to the implicit constructor for\n-    /// a tuple struct like `struct Foo(u32)`.\n+    /// Returns `true` if this `DefId` refers to the implicit constructor for\n+    /// a tuple struct like `struct Foo(u32)`, and `false` otherwise.\n     pub fn is_struct_constructor(self, def_id: DefId) -> bool {\n         self.def_key(def_id).disambiguated_data.data == DefPathData::StructCtor\n     }\n \n     /// Given the `DefId` of a fn or closure, returns the `DefId` of\n     /// the innermost fn item that the closure is contained within.\n-    /// This is a significant def-id because, when we do\n+    /// This is a significant `DefId` because, when we do\n     /// type-checking, we type-check this fn item and all of its\n-    /// (transitive) closures together.  Therefore, when we fetch the\n+    /// (transitive) closures together. Therefore, when we fetch the\n     /// `typeck_tables_of` the closure, for example, we really wind up\n     /// fetching the `typeck_tables_of` the enclosing fn item.\n     pub fn closure_base_def_id(self, def_id: DefId) -> DefId {\n@@ -558,10 +559,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         def_id\n     }\n \n-    /// Given the def-id and substs a closure, creates the type of\n+    /// Given the `DefId` and substs a closure, creates the type of\n     /// `self` argument that the closure expects. For example, for a\n     /// `Fn` closure, this would return a reference type `&T` where\n-    /// `T=closure_ty`.\n+    /// `T = closure_ty`.\n     ///\n     /// Returns `None` if this closure's kind has not yet been inferred.\n     /// This should only be possible during type checking.\n@@ -585,7 +586,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         Some(ty::Binder::bind(env_ty))\n     }\n \n-    /// Given the def-id of some item that has no type parameters, make\n+    /// Given the `DefId` of some item that has no type parameters, make\n     /// a suitable \"empty substs\" for it.\n     pub fn empty_substs_for_def_id(self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n         Substs::for_item(self, item_def_id, |param, _| {\n@@ -598,7 +599,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    /// Return whether the node pointed to by def_id is a static item, and its mutability\n+    /// Returns `true` if the node pointed to by `def_id` is a static item, and its mutability.\n     pub fn is_static(&self, def_id: DefId) -> Option<hir::Mutability> {\n         if let Some(node) = self.hir().get_if_local(def_id) {\n             match node {\n@@ -730,7 +731,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n     /// Checks whether values of this type `T` implement the `Freeze`\n     /// trait -- frozen types are those that do not contain a\n-    /// `UnsafeCell` anywhere.  This is a language concept used to\n+    /// `UnsafeCell` anywhere. This is a language concept used to\n     /// distinguish \"true immutability\", which is relevant to\n     /// optimization as well as the rules around static values. Note\n     /// that the `Freeze` trait is not exposed to end users and is"}, {"sha": "ffb5471e34fbf7e351e831700da368bc1821834f", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -227,7 +227,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Push new obligations into `out`. Returns true if it was able\n+    /// Pushes new obligations into `out`. Returns `true` if it was able\n     /// to generate all the predicates needed to validate that `ty0`\n     /// is WF. Returns false if `ty0` is an unresolved type variable,\n     /// in which case we are not able to simplify at all.\n@@ -502,7 +502,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/// Given an object type like `SomeTrait+Send`, computes the lifetime\n+/// Given an object type like `SomeTrait + Send`, computes the lifetime\n /// bounds that must hold on the elided self type. These are derived\n /// from the declarations of `SomeTrait`, `Send`, and friends -- if\n /// they declare `trait SomeTrait : 'static`, for example, then"}, {"sha": "dd635e5c946f0eaa59196880b31de4bb8281f8ac", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -63,11 +63,11 @@ pub fn install_panic_hook() {\n /// Parameters to the `Dump` variant of type `ProfileQueriesMsg`.\n #[derive(Clone,Debug)]\n pub struct ProfQDumpParams {\n-    /// A base path for the files we will dump\n+    /// A base path for the files we will dump.\n     pub path:String,\n-    /// To ensure that the compiler waits for us to finish our dumps\n+    /// To ensure that the compiler waits for us to finish our dumps.\n     pub ack:Sender<()>,\n-    /// toggle dumping a log file with every `ProfileQueriesMsg`\n+    /// Toggle dumping a log file with every `ProfileQueriesMsg`.\n     pub dump_profq_msg_log:bool,\n }\n \n@@ -131,7 +131,7 @@ pub fn time_depth() -> usize {\n     TIME_DEPTH.with(|slot| slot.get())\n }\n \n-/// Set the current depth of `time()` calls. The idea is to call\n+/// Sets the current depth of `time()` calls. The idea is to call\n /// `set_time_depth()` with the result from `time_depth()` in the\n /// parent thread.\n pub fn set_time_depth(depth: usize) {"}, {"sha": "63c7b76d1b6a5026491cf543cda3336035e5caef", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,4 +1,4 @@\n-//! An efficient hash map for node IDs\n+//! An efficient hash map for `NodeId`s.\n \n use crate::hir::def_id::DefId;\n use crate::hir::{HirId, ItemLocalId};"}, {"sha": "1cb9f47bb31f1f42a63708e53de50db44a6cfcd2", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -23,18 +23,18 @@ use crate::hir;\n /// The \"region highlights\" are used to control region printing during\n /// specific error messages. When a \"region highlight\" is enabled, it\n /// gives an alternate way to print specific regions. For now, we\n-/// always print those regions using a number, so something like `'0`.\n+/// always print those regions using a number, so something like \"`'0`\".\n ///\n /// Regions not selected by the region highlight mode are presently\n /// unaffected.\n #[derive(Copy, Clone, Default)]\n pub struct RegionHighlightMode {\n-    /// If enabled, when we see the selected region, use `\"'N\"`\n+    /// If enabled, when we see the selected region, use \"`'N`\"\n     /// instead of the ordinary behavior.\n     highlight_regions: [Option<(ty::RegionKind, usize)>; 3],\n \n     /// If enabled, when printing a \"free region\" that originated from\n-    /// the given `ty::BoundRegion`, print it as `'1`. Free regions that would ordinarily\n+    /// the given `ty::BoundRegion`, print it as \"`'1`\". Free regions that would ordinarily\n     /// have names print as normal.\n     ///\n     /// This is used when you have a signature like `fn foo(x: &u32,\n@@ -51,12 +51,12 @@ thread_local! {\n }\n \n impl RegionHighlightMode {\n-    /// Read and return current region highlight settings (accesses thread-local state).a\n+    /// Reads and returns the current region highlight settings (accesses thread-local state).\n     pub fn get() -> Self {\n         REGION_HIGHLIGHT_MODE.with(|c| c.get())\n     }\n \n-    /// Internal helper to update current settings during the execution of `op`.\n+    // Internal helper to update current settings during the execution of `op`.\n     fn set<R>(\n         old_mode: Self,\n         new_mode: Self,\n@@ -70,8 +70,8 @@ impl RegionHighlightMode {\n         })\n     }\n \n-    /// If `region` and `number` are both `Some`, invoke\n-    /// `highlighting_region`. Otherwise, just invoke `op` directly.\n+    /// If `region` and `number` are both `Some`, invokes\n+    /// `highlighting_region`; otherwise, just invokes `op` directly.\n     pub fn maybe_highlighting_region<R>(\n         region: Option<ty::Region<'_>>,\n         number: Option<usize>,\n@@ -86,8 +86,8 @@ impl RegionHighlightMode {\n         op()\n     }\n \n-    /// During the execution of `op`, highlight the region inference\n-    /// vairable `vid` as `'N`.  We can only highlight one region vid\n+    /// During the execution of `op`, highlights the region inference\n+    /// variable `vid` as `'N`. We can only highlight one region `vid`\n     /// at a time.\n     pub fn highlighting_region<R>(\n         region: ty::Region<'_>,\n@@ -109,7 +109,7 @@ impl RegionHighlightMode {\n         Self::set(old_mode, new_mode, op)\n     }\n \n-    /// Convenience wrapper for `highlighting_region`\n+    /// Convenience wrapper for `highlighting_region`.\n     pub fn highlighting_region_vid<R>(\n         vid: ty::RegionVid,\n         number: usize,\n@@ -118,7 +118,7 @@ impl RegionHighlightMode {\n         Self::highlighting_region(&ty::ReVar(vid), number, op)\n     }\n \n-    /// Returns true if any placeholders are highlighted.\n+    /// Returns `true` if any placeholders are highlighted, and `false` otherwise.\n     fn any_region_vids_highlighted(&self) -> bool {\n         Self::get()\n             .highlight_regions\n@@ -129,8 +129,7 @@ impl RegionHighlightMode {\n             })\n     }\n \n-    /// Returns `Some(n)` with the number to use for the given region,\n-    /// if any.\n+    /// Returns `Some(n)` with the number to use for the given region, if any.\n     fn region_highlighted(&self, region: ty::Region<'_>) -> Option<usize> {\n         Self::get()\n             .highlight_regions\n@@ -143,7 +142,7 @@ impl RegionHighlightMode {\n     }\n \n     /// During the execution of `op`, highlight the given bound\n-    /// region. We can only highlight one bound region at a time.  See\n+    /// region. We can only highlight one bound region at a time. See\n     /// the field `highlight_bound_region` for more detailed notes.\n     pub fn highlighting_bound_region<R>(\n         br: ty::BoundRegion,\n@@ -162,7 +161,7 @@ impl RegionHighlightMode {\n         )\n     }\n \n-    /// Returns true if any placeholders are highlighted.\n+    /// Returns `true` if any placeholders are highlighted, and `false` otherwise.\n     pub fn any_placeholders_highlighted(&self) -> bool {\n         Self::get()\n             .highlight_regions\n@@ -173,7 +172,7 @@ impl RegionHighlightMode {\n             })\n     }\n \n-    /// Returns `Some(N)` if the placeholder `p` is highlighted to print as `'N`.\n+    /// Returns `Some(N)` if the placeholder `p` is highlighted to print as \"`'N`\".\n     pub fn placeholder_highlight(&self, p: ty::PlaceholderRegion) -> Option<usize> {\n         self.region_highlighted(&ty::RePlaceholder(p))\n     }"}, {"sha": "9f68d770b9e8765e9bc6df7b079629cd97885416", "filename": "src/librustc_apfloat/ieee.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -186,7 +186,7 @@ impl Semantics for X87DoubleExtendedS {\n     ///  exponent = all 1's, integer bit 0, significand 0 (\"pseudoinfinity\")\n     ///  exponent = all 1's, integer bit 0, significand nonzero (\"pseudoNaN\")\n     ///  exponent = 0, integer bit 1 (\"pseudodenormal\")\n-    ///  exponent!=0 nor all 1's, integer bit 0 (\"unnormal\")\n+    ///  exponent != 0 nor all 1's, integer bit 0 (\"unnormal\")\n     /// At the moment, the first two are treated as NaNs, the second two as Normal.\n     fn from_bits(bits: u128) -> IeeeFloat<Self> {\n         let sign = bits & (1 << (Self::BITS - 1));\n@@ -1549,11 +1549,11 @@ impl<S: Semantics> IeeeFloat<S> {\n         }\n     }\n \n-    /// Returns TRUE if, when truncating the current number, with BIT the\n+    /// Returns `true` if, when truncating the current number, with `bit` the\n     /// new LSB, with the given lost fraction and rounding mode, the result\n     /// would need to be rounded away from zero (i.e., by increasing the\n-    /// signficand). This routine must work for Category::Zero of both signs, and\n-    /// Category::Normal numbers.\n+    /// signficand). This routine must work for `Category::Zero` of both signs, and\n+    /// `Category::Normal` numbers.\n     fn round_away_from_zero(&self, round: Round, loss: Loss, bit: usize) -> bool {\n         // NaNs and infinities should not have lost fractions.\n         assert!(self.is_finite_non_zero() || self.is_zero());\n@@ -2257,7 +2257,7 @@ impl Loss {\n         more_significant\n     }\n \n-    /// Return the fraction lost were a bignum truncated losing the least\n+    /// Returns the fraction lost were a bignum truncated losing the least\n     /// significant `bits` bits.\n     fn through_truncation(limbs: &[Limb], bits: usize) -> Loss {\n         if bits == 0 {\n@@ -2320,12 +2320,12 @@ mod sig {\n         Ordering::Equal\n     }\n \n-    /// Extract the given bit.\n+    /// Extracts the given bit.\n     pub(super) fn get_bit(limbs: &[Limb], bit: usize) -> bool {\n         limbs[bit / LIMB_BITS] & (1 << (bit % LIMB_BITS)) != 0\n     }\n \n-    /// Set the given bit.\n+    /// Sets the given bit.\n     pub(super) fn set_bit(limbs: &mut [Limb], bit: usize) {\n         limbs[bit / LIMB_BITS] |= 1 << (bit % LIMB_BITS);\n     }\n@@ -2335,7 +2335,7 @@ mod sig {\n         limbs[bit / LIMB_BITS] &= !(1 << (bit % LIMB_BITS));\n     }\n \n-    /// Shift `dst` left `bits` bits, subtract `bits` from its exponent.\n+    /// Shifts `dst` left `bits` bits, subtract `bits` from its exponent.\n     pub(super) fn shift_left(dst: &mut [Limb], exp: &mut ExpInt, bits: usize) {\n         if bits > 0 {\n             // Our exponent should not underflow.\n@@ -2367,7 +2367,7 @@ mod sig {\n         }\n     }\n \n-    /// Shift `dst` right `bits` bits noting lost fraction.\n+    /// Shifts `dst` right `bits` bits noting lost fraction.\n     pub(super) fn shift_right(dst: &mut [Limb], exp: &mut ExpInt, bits: usize) -> Loss {\n         let loss = Loss::through_truncation(dst, bits);\n \n@@ -2403,7 +2403,7 @@ mod sig {\n         loss\n     }\n \n-    /// Copy the bit vector of width `src_bits` from `src`, starting at bit SRC_LSB,\n+    /// Copies the bit vector of width `src_bits` from `src`, starting at bit SRC_LSB,\n     /// to `dst`, such that the bit SRC_LSB becomes the least significant bit of `dst`.\n     /// All high bits above `src_bits` in `dst` are zero-filled.\n     pub(super) fn extract(dst: &mut [Limb], src: &[Limb], src_bits: usize, src_lsb: usize) {"}, {"sha": "46d046d7b41b4384107ee1751505dfc17ef67b4e", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -375,7 +375,7 @@ pub trait Float\n     fn from_str_r(s: &str, round: Round) -> Result<StatusAnd<Self>, ParseError>;\n     fn to_bits(self) -> u128;\n \n-    /// Convert a floating point number to an integer according to the\n+    /// Converts a floating point number to an integer according to the\n     /// rounding mode. In case of an invalid operation exception,\n     /// deterministic values are returned, namely zero for NaNs and the\n     /// minimal or maximal value respectively for underflow or overflow.\n@@ -388,7 +388,7 @@ pub trait Float\n     ///\n     /// The *is_exact output tells whether the result is exact, in the sense\n     /// that converting it back to the original floating point type produces\n-    /// the original value. This is almost equivalent to result==Status::OK,\n+    /// the original value. This is almost equivalent to `result == Status::OK`,\n     /// except for negative zeroes.\n     fn to_i128_r(self, width: usize, round: Round, is_exact: &mut bool) -> StatusAnd<i128> {\n         let status;\n@@ -458,48 +458,48 @@ pub trait Float\n         }\n     }\n \n-    /// IEEE-754R isSignMinus: Returns true if and only if the current value is\n+    /// IEEE-754R isSignMinus: Returns whether the current value is\n     /// negative.\n     ///\n     /// This applies to zeros and NaNs as well.\n     fn is_negative(self) -> bool;\n \n-    /// IEEE-754R isNormal: Returns true if and only if the current value is normal.\n+    /// IEEE-754R isNormal: Returns whether the current value is normal.\n     ///\n     /// This implies that the current value of the float is not zero, subnormal,\n     /// infinite, or NaN following the definition of normality from IEEE-754R.\n     fn is_normal(self) -> bool {\n         !self.is_denormal() && self.is_finite_non_zero()\n     }\n \n-    /// Returns true if and only if the current value is zero, subnormal, or\n+    /// Returns `true` if the current value is zero, subnormal, or\n     /// normal.\n     ///\n     /// This means that the value is not infinite or NaN.\n     fn is_finite(self) -> bool {\n         !self.is_nan() && !self.is_infinite()\n     }\n \n-    /// Returns true if and only if the float is plus or minus zero.\n+    /// Returns `true` if the float is plus or minus zero.\n     fn is_zero(self) -> bool {\n         self.category() == Category::Zero\n     }\n \n-    /// IEEE-754R isSubnormal(): Returns true if and only if the float is a\n+    /// IEEE-754R isSubnormal(): Returns whether the float is a\n     /// denormal.\n     fn is_denormal(self) -> bool;\n \n-    /// IEEE-754R isInfinite(): Returns true if and only if the float is infinity.\n+    /// IEEE-754R isInfinite(): Returns whether the float is infinity.\n     fn is_infinite(self) -> bool {\n         self.category() == Category::Infinity\n     }\n \n-    /// Returns true if and only if the float is a quiet or signaling NaN.\n+    /// Returns `true` if the float is a quiet or signaling NaN.\n     fn is_nan(self) -> bool {\n         self.category() == Category::NaN\n     }\n \n-    /// Returns true if and only if the float is a signaling NaN.\n+    /// Returns `true` if the float is a signaling NaN.\n     fn is_signaling(self) -> bool;\n \n     // Simple Queries\n@@ -518,19 +518,19 @@ pub trait Float\n         self.is_zero() && self.is_negative()\n     }\n \n-    /// Returns true if and only if the number has the smallest possible non-zero\n+    /// Returns `true` if the number has the smallest possible non-zero\n     /// magnitude in the current semantics.\n     fn is_smallest(self) -> bool {\n         Self::SMALLEST.copy_sign(self).bitwise_eq(self)\n     }\n \n-    /// Returns true if and only if the number has the largest possible finite\n+    /// Returns `true` if the number has the largest possible finite\n     /// magnitude in the current semantics.\n     fn is_largest(self) -> bool {\n         Self::largest().copy_sign(self).bitwise_eq(self)\n     }\n \n-    /// Returns true if and only if the number is an exact integer.\n+    /// Returns `true` if the number is an exact integer.\n     fn is_integer(self) -> bool {\n         // This could be made more efficient; I'm going for obviously correct.\n         if !self.is_finite() {\n@@ -572,11 +572,11 @@ pub trait Float\n }\n \n pub trait FloatConvert<T: Float>: Float {\n-    /// Convert a value of one floating point type to another.\n+    /// Converts a value of one floating point type to another.\n     /// The return value corresponds to the IEEE754 exceptions. *loses_info\n     /// records whether the transformation lost information, i.e., whether\n     /// converting the result back to the original type will produce the\n-    /// original value (this is almost the same as return value==Status::OK,\n+    /// original value (this is almost the same as return `value == Status::OK`,\n     /// but there are edge cases where this is not so).\n     fn convert_r(self, round: Round, loses_info: &mut bool) -> StatusAnd<T>;\n     fn convert(self, loses_info: &mut bool) -> StatusAnd<T> {"}, {"sha": "b528967dd65ff6f884b39dbfbbcaa1c2889cd13a", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -239,7 +239,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     {\n         //! Iterates over each loan that has been issued\n         //! on entrance to `node`, regardless of whether it is\n-        //! actually *in scope* at that point.  Sometimes loans\n+        //! actually *in scope* at that point. Sometimes loans\n         //! are issued for future scopes and thus they may have been\n         //! *issued* but not yet be in effect.\n "}, {"sha": "ae1d49afd4931d6cbf8f27a50e3049a48bfae59c", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -53,7 +53,7 @@ struct GuaranteeLifetimeContext<'a, 'tcx: 'a> {\n impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n     fn check(&self, cmt: &mc::cmt_<'tcx>, discr_scope: Option<ast::NodeId>) -> R {\n         //! Main routine. Walks down `cmt` until we find the\n-        //! \"guarantor\".  Reports an error if `self.loan_region` is\n+        //! \"guarantor\". Reports an error if `self.loan_region` is\n         //! larger than scope of `cmt`.\n         debug!(\"guarantee_lifetime.check(cmt={:?}, loan_region={:?})\",\n                cmt,"}, {"sha": "1971c6663120be30c59245a7fdd7035073c54e65", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -285,7 +285,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n     }\n \n     /// Guarantees that `addr_of(cmt)` will be valid for the duration of `static_scope_r`, or\n-    /// reports an error.  This may entail taking out loans, which will be added to the\n+    /// reports an error. This may entail taking out loans, which will be added to the\n     /// `req_loan_map`.\n     fn guarantee_valid(&mut self,\n                        borrow_id: hir::ItemLocalId,"}, {"sha": "85c4ca7bd379ee7e7ade5623719af201a5ad97bd", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -296,11 +296,11 @@ pub struct Loan<'tcx> {\n     /// gen_scope indicates where loan is introduced. Typically the\n     /// loan is introduced at the point of the borrow, but in some\n     /// cases, notably method arguments, the loan may be introduced\n-    /// only later, once it comes into scope.  See also\n+    /// only later, once it comes into scope. See also\n     /// `GatherLoanCtxt::compute_gen_scope`.\n     gen_scope: region::Scope,\n \n-    /// kill_scope indicates when the loan goes out of scope.  This is\n+    /// kill_scope indicates when the loan goes out of scope. This is\n     /// either when the lifetime expires or when the local variable\n     /// which roots the loan-path goes out of scope, whichever happens\n     /// faster. See also `GatherLoanCtxt::compute_kill_scope`."}, {"sha": "325d3559f0ab647478704dac3a085366b735b646", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -114,7 +114,7 @@ pub struct Move {\n     /// Path being moved.\n     pub path: MovePathIndex,\n \n-    /// id of node that is doing the move.\n+    /// ID of node that is doing the move.\n     pub id: hir::ItemLocalId,\n \n     /// Kind of move, for error messages.\n@@ -129,7 +129,7 @@ pub struct Assignment {\n     /// Path being assigned.\n     pub path: MovePathIndex,\n \n-    /// id where assignment occurs\n+    /// ID where assignment occurs\n     pub id: hir::ItemLocalId,\n \n     /// span of node where assignment occurs\n@@ -168,8 +168,8 @@ fn loan_path_is_precise(loan_path: &LoanPath<'_>) -> bool {\n }\n \n impl<'a, 'tcx> MoveData<'tcx> {\n-    /// return true if there are no trackable assignments or moves\n-    /// in this move data - that means that there is nothing that\n+    /// Returns `true` if there are no trackable assignments or moves\n+    /// in this move data -- that means that there is nothing that\n     /// could cause a borrow error.\n     pub fn is_empty(&self) -> bool {\n         self.moves.borrow().is_empty() &&"}, {"sha": "de2a3c4cb22a822ca2ba30b3d3d0e6c1df90fffd", "filename": "src/librustc_borrowck/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdataflow.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -178,7 +178,7 @@ fn build_local_id_to_index(body: Option<&hir::Body>,\n \n     return index;\n \n-    /// Add mappings from the ast nodes for the formal bindings to\n+    /// Adds mappings from the ast nodes for the formal bindings to\n     /// the entry-node in the graph.\n     fn add_entries_from_fn_body(index: &mut FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>,\n                                 body: &hir::Body,"}, {"sha": "f7d2699a27e3f7604a0df0cccb766ccb5bf6019c", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -174,13 +174,13 @@ pub trait ArgTypeExt<'ll, 'tcx> {\n }\n \n impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n-    /// Get the LLVM type for a place of the original Rust type of\n+    /// Gets the LLVM type for a place of the original Rust type of\n     /// this argument/return, i.e., the result of `type_of::type_of`.\n     fn memory_ty(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type {\n         self.layout.llvm_type(cx)\n     }\n \n-    /// Store a direct/indirect value described by this ArgType into a\n+    /// Stores a direct/indirect value described by this ArgType into a\n     /// place for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n     /// or results of call/invoke instructions into their destinations."}, {"sha": "e02f7df2efcc958717382fb43b5ba5ad5e815893", "filename": "src/librustc_codegen_llvm/back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -51,7 +51,7 @@ fn is_relevant_child(c: &Child) -> bool {\n }\n \n impl<'a> ArchiveBuilder<'a> {\n-    /// Create a new static archive, ready for modifying the archive specified\n+    /// Creates a new static archive, ready for modifying the archive specified\n     /// by `config`.\n     pub fn new(config: ArchiveConfig<'a>) -> ArchiveBuilder<'a> {\n         ArchiveBuilder {"}, {"sha": "725009e1377aff25df06ad4ae8ce62d5603336d9", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -42,7 +42,7 @@ pub use rustc_codegen_utils::link::{find_crate_name, filename_for_input, default\n                                     out_filename, check_file_is_writeable};\n \n \n-/// Perform the linkage portion of the compilation phase. This will generate all\n+/// Performs the linkage portion of the compilation phase. This will generate all\n /// of the requested outputs for this compilation session.\n pub(crate) fn link_binary(sess: &Session,\n                           codegen_results: &CodegenResults,"}, {"sha": "be7733bf554bb44f0eec86b5a26660181116e223", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -791,7 +791,7 @@ impl ThinLTOImports {\n         self.imports.get(llvm_module_name).map(|v| &v[..]).unwrap_or(&[])\n     }\n \n-    /// Load the ThinLTO import map from ThinLTOData.\n+    /// Loads the ThinLTO import map from ThinLTOData.\n     unsafe fn from_thin_lto_data(data: *const llvm::ThinLTOData) -> ThinLTOImports {\n         unsafe extern \"C\" fn imported_module_callback(payload: *mut libc::c_void,\n                                                       importing_module_name: *const libc::c_char,"}, {"sha": "b403660fa512dd83002699a2fe446091d54cc1ef", "filename": "src/librustc_codegen_llvm/back/wasm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -112,7 +112,7 @@ pub fn rewrite_imports(path: &Path, import_map: &FxHashMap<String, String>) {\n     }\n }\n \n-/// Add or augment the existing `producers` section to encode information about\n+/// Adds or augment the existing `producers` section to encode information about\n /// the Rust compiler used to produce the wasm file.\n pub fn add_producer_section(\n     path: &Path,"}, {"sha": "70986a4e1794163a15a8ca3fa33344037fe754e1", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -7,11 +7,11 @@\n //!\n //! Hopefully useful general knowledge about codegen:\n //!\n-//!   * There's no way to find out the Ty type of a Value.  Doing so\n-//!     would be \"trying to get the eggs out of an omelette\" (credit:\n-//!     pcwalton).  You can, instead, find out its llvm::Type by calling val_ty,\n-//!     but one llvm::Type corresponds to many `Ty`s; for instance, tup(int, int,\n-//!     int) and rec(x=int, y=int, z=int) will have the same llvm::Type.\n+//! * There's no way to find out the `Ty` type of a Value. Doing so\n+//!   would be \"trying to get the eggs out of an omelette\" (credit:\n+//!   pcwalton). You can, instead, find out its `llvm::Type` by calling `val_ty`,\n+//!   but one `llvm::Type` corresponds to many `Ty`s; for instance, `tup(int, int,\n+//!   int)` and `rec(x=int, y=int, z=int)` will have the same `llvm::Type`.\n \n use super::ModuleLlvm;\n use rustc_codegen_ssa::{ModuleCodegen, ModuleKind};"}, {"sha": "9426328da327d2b2c6f4c0d3eb7b4ed74746a4d4", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,6 +1,6 @@\n //! Handles codegen of callees as well as other call-related\n-//! things.  Callees are a superset of normal rust values and sometimes\n-//! have different representations.  In particular, top-level fn items\n+//! things. Callees are a superset of normal rust values and sometimes\n+//! have different representations. In particular, top-level fn items\n //! and methods are represented as just a fn ptr and not a full\n //! closure.\n "}, {"sha": "a4b976dfbd9bac9f79c636b0154840fc326f20f6", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -75,7 +75,7 @@ pub struct CodegenCx<'ll, 'tcx: 'll> {\n     pub statics_to_rauw: RefCell<Vec<(&'ll Value, &'ll Value)>>,\n \n     /// Statics that will be placed in the llvm.used variable\n-    /// See http://llvm.org/docs/LangRef.html#the-llvm-used-global-variable for details\n+    /// See <http://llvm.org/docs/LangRef.html#the-llvm-used-global-variable> for details\n     pub used_statics: RefCell<Vec<&'ll Value>>,\n \n     pub lltypes: RefCell<FxHashMap<(Ty<'tcx>, Option<VariantIdx>), &'ll Type>>,\n@@ -807,7 +807,7 @@ impl CodegenCx<'b, 'tcx> {\n }\n \n impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n-    /// Generate a new symbol name with the given prefix. This symbol name must\n+    /// Generates a new symbol name with the given prefix. This symbol name must\n     /// only be used for definitions with `internal` or `private` linkage.\n     pub fn generate_local_symbol_name(&self, prefix: &str) -> String {\n         let idx = self.local_gen_sym_counter.get();"}, {"sha": "791526c98c85ce31f6fc272929c6b6d8a12519ff", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -16,7 +16,7 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n use syntax_pos::BytePos;\n \n-/// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n+/// Produces DIScope DIEs for each MIR Scope which has variables defined in it.\n /// If debuginfo is disabled, the returned vector is empty.\n pub fn create_mir_scopes(\n     cx: &CodegenCx<'ll, '_>,"}, {"sha": "cf18b995b61dadbf125a58793b13509dceb10ca6", "filename": "src/librustc_codegen_llvm/debuginfo/doc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fdoc.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -160,7 +160,7 @@\n //!\n //! This algorithm also provides a stable ID for types that are defined in one\n //! crate but instantiated from metadata within another crate. We just have to\n-//! take care to always map crate and node IDs back to the original crate\n+//! take care to always map crate and `NodeId`s back to the original crate\n //! context.\n //!\n //! As a side-effect these unique type IDs also help to solve a problem arising\n@@ -170,7 +170,7 @@\n //! with different concrete substitutions for `'a`, and thus there will be N\n //! `Ty` instances for the type `Struct<'a>` even though it is not generic\n //! otherwise. Unfortunately this means that we cannot use `ty::type_id()` as\n-//! cheap identifier for type metadata---we have done this in the past, but it\n+//! cheap identifier for type metadata -- we have done this in the past, but it\n //! led to unnecessary metadata duplication in the best case and LLVM\n //! assertions in the worst. However, the unique type ID as described above\n //! *can* be used as identifier. Since it is comparatively expensive to"}, {"sha": "625f6cd45fb3e716b236eb7b2afa92b4fb704ead", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -102,7 +102,7 @@ impl<'a, 'tcx> CrateDebugContext<'a, 'tcx> {\n     }\n }\n \n-/// Create any deferred debug metadata nodes\n+/// Creates any deferred debug metadata nodes\n pub fn finalize(cx: &CodegenCx) {\n     if cx.dbg_cx.is_none() {\n         return;"}, {"sha": "f2d92eefad3e3a4bf5c3e5f286f680e81437b57d", "filename": "src/librustc_codegen_llvm/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -36,7 +36,7 @@ pub fn create_DIArray(\n     };\n }\n \n-/// Return syntax_pos::Loc corresponding to the beginning of the span\n+/// Returns syntax_pos::Loc corresponding to the beginning of the span\n pub fn span_start(cx: &CodegenCx, span: Span) -> syntax_pos::Loc {\n     cx.sess().source_map().lookup_char_pos(span.lo())\n }"}, {"sha": "3232f4e8f51ac6f280ecb507c0b8816f7166c2a1", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1337,7 +1337,7 @@ extern \"C\" {\n     pub fn LLVMGetSections(ObjFile: &'a ObjectFile) -> &'a mut SectionIterator<'a>;\n     /// Destroys a section iterator.\n     pub fn LLVMDisposeSectionIterator(SI: &'a mut SectionIterator<'a>);\n-    /// Returns true if the section iterator is at the end of the section\n+    /// Returns `true` if the section iterator is at the end of the section\n     /// list:\n     pub fn LLVMIsSectionIteratorAtEnd(ObjFile: &'a ObjectFile, SI: &SectionIterator<'a>) -> Bool;\n     /// Moves the section iterator to point to the next section."}, {"sha": "39f48b266c2197a6ab172f14b1d28a0881f1aa8b", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -226,7 +226,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         }\n     }\n \n-    /// Get the LLVM type corresponding to a Rust type, i.e., `rustc::ty::Ty`.\n+    /// Gets the LLVM type corresponding to a Rust type, i.e., `rustc::ty::Ty`.\n     /// The pointee type of the pointer in `PlaceRef` is always this type.\n     /// For sized types, it is also the right LLVM type for an `alloca`\n     /// containing a value of that type, and most immediates (except `bool`)."}, {"sha": "3cbe3793f10cf02edf55111bd630c97ee4256991", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -91,7 +91,7 @@ impl LinkerInfo {\n     }\n }\n \n-/// Linker abstraction used by back::link to build up the command to invoke a\n+/// Linker abstraction used by `back::link` to build up the command to invoke a\n /// linker.\n ///\n /// This trait is the total list of requirements needed by `back::link` and\n@@ -145,7 +145,7 @@ pub struct GccLinker<'a> {\n impl<'a> GccLinker<'a> {\n     /// Argument that must be passed *directly* to the linker\n     ///\n-    /// These arguments need to be prepended with '-Wl,' when a gcc-style linker is used\n+    /// These arguments need to be prepended with `-Wl`, when a GCC-style linker is used.\n     fn linker_arg<S>(&mut self, arg: S) -> &mut Self\n         where S: AsRef<OsStr>\n     {"}, {"sha": "79662a4bfe53f12d0673cfd873b01deca86524c4", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -662,7 +662,7 @@ pub enum WorkItem<B: WriteBackendMethods> {\n     /// Copy the post-LTO artifacts from the incremental cache to the output\n     /// directory.\n     CopyPostLtoArtifacts(CachedModuleCodegen),\n-    /// Perform (Thin)LTO on the given module.\n+    /// Performs (Thin)LTO on the given module.\n     LTO(lto::LtoModuleCodegen<B>),\n }\n \n@@ -1797,7 +1797,7 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n         drop(self.coordinator_send.send(Box::new(Message::CodegenComplete::<B>)));\n     }\n \n-    /// Consume this context indicating that codegen was entirely aborted, and\n+    /// Consumes this context indicating that codegen was entirely aborted, and\n     /// we need to exit as quickly as possible.\n     ///\n     /// This method blocks the current thread until all worker threads have"}, {"sha": "7aa75f139d2ae4456aef58df025fa4428ff883c6", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -7,11 +7,11 @@\n //!\n //! Hopefully useful general knowledge about codegen:\n //!\n-//!   * There's no way to find out the Ty type of a Value.  Doing so\n-//!     would be \"trying to get the eggs out of an omelette\" (credit:\n-//!     pcwalton).  You can, instead, find out its llvm::Type by calling val_ty,\n-//!     but one llvm::Type corresponds to many `Ty`s; for instance, tup(int, int,\n-//!     int) and rec(x=int, y=int, z=int) will have the same llvm::Type.\n+//! * There's no way to find out the `Ty` type of a Value. Doing so\n+//!   would be \"trying to get the eggs out of an omelette\" (credit:\n+//!   pcwalton). You can, instead, find out its `llvm::Type` by calling `val_ty`,\n+//!   but one `llvm::Type` corresponds to many `Ty`s; for instance, `tup(int, int,\n+//!   int)` and `rec(x=int, y=int, z=int)` will have the same `llvm::Type`.\n \n use crate::{ModuleCodegen, ModuleKind, CachedModuleCodegen};\n \n@@ -156,7 +156,7 @@ pub fn compare_simd_types<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     bx.sext(cmp, ret_ty)\n }\n \n-/// Retrieve the information we are losing (making dynamic) in an unsizing\n+/// Retrieves the information we are losing (making dynamic) in an unsizing\n /// adjustment.\n ///\n /// The `old_info` argument is a bit funny. It is intended for use\n@@ -347,7 +347,7 @@ fn cast_shift_rhs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n-/// Returns whether this session's target will use SEH-based unwinding.\n+/// Returns `true` if this session's target will use SEH-based unwinding.\n ///\n /// This is only true for MSVC targets, and even then the 64-bit MSVC target\n /// currently uses SEH-ish unwinding with DWARF info tables to the side (same as\n@@ -436,7 +436,7 @@ pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     mir::codegen_mir::<Bx>(cx, lldecl, &mir, instance, sig);\n }\n \n-/// Create the `main` function which will initialize the rust runtime and call\n+/// Creates the `main` function which will initialize the rust runtime and call\n /// users main function.\n pub fn maybe_create_entry_wrapper<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     cx: &'a Bx::CodegenCx"}, {"sha": "a083bd5d8d18aa1e1e7da7f626b25d8c04906449", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -53,7 +53,7 @@ pub mod back;\n pub struct ModuleCodegen<M> {\n     /// The name of the module. When the crate may be saved between\n     /// compilations, incremental compilation requires that name be\n-    /// unique amongst **all** crates.  Therefore, it should contain\n+    /// unique amongst **all** crates. Therefore, it should contain\n     /// something unique to this crate (e.g., a module path) as well\n     /// as the crate name and disambiguator.\n     /// We currently generate these names via CodegenUnit::build_cgu_name().\n@@ -126,7 +126,7 @@ bitflags::bitflags! {\n     }\n }\n \n-/// Misc info we load from metadata to persist beyond the tcx\n+/// Misc info we load from metadata to persist beyond the tcx.\n pub struct CrateInfo {\n     pub panic_runtime: Option<CrateNum>,\n     pub compiler_builtins: Option<CrateNum>,"}, {"sha": "caca1789fc98c5989ced9c96018a3f6adfa71572", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -884,7 +884,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n     }\n \n-    /// Return the landingpad wrapper around the given basic block\n+    /// Returns the landing-pad wrapper around the given basic block.\n     ///\n     /// No-op in MSVC SEH scheme.\n     fn landing_pad_to("}, {"sha": "203d84bff5bb3a9afd001908359c60f75d0ef740", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -422,7 +422,7 @@ fn create_funclets<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     }).unzip()\n }\n \n-/// Produce, for each argument, a `Value` pointing at the\n+/// Produces, for each argument, a `Value` pointing at the\n /// argument's value. As arguments are places, these are always\n /// indirect.\n fn arg_local_refs<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>("}, {"sha": "9d6826d8756b77ca5b7f0cc0ae6252703123de03", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -13,16 +13,16 @@ use super::operand::OperandValue;\n \n #[derive(Copy, Clone, Debug)]\n pub struct PlaceRef<'tcx, V> {\n-    /// Pointer to the contents of the place\n+    /// Pointer to the contents of the place.\n     pub llval: V,\n \n-    /// This place's extra data if it is unsized, or null\n+    /// This place's extra data if it is unsized, or null.\n     pub llextra: Option<V>,\n \n-    /// Monomorphized type of this place, including variant information\n+    /// Monomorphized type of this place, including variant information.\n     pub layout: TyLayout<'tcx>,\n \n-    /// What alignment we know for this place\n+    /// What alignment we know for this place.\n     pub align: Align,\n }\n \n@@ -277,7 +277,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> PlaceRef<'tcx, V> {\n         }\n     }\n \n-    /// Set the discriminant for a new value of the given case of the given\n+    /// Sets the discriminant for a new value of the given case of the given\n     /// representation.\n     pub fn codegen_set_discr<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         &self,"}, {"sha": "6a400a7d7a45d80835aea14c6d568eeffb4f7f32", "filename": "src/librustc_codegen_ssa/traits/declare.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdeclare.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -29,7 +29,7 @@ pub trait DeclareMethods<'tcx>: BackendTypes {\n     /// Declare a global with an intention to define it.\n     ///\n     /// Use this function when you intend to define a global. This function will\n-    /// return None if the name already has a definition associated with it. In that\n+    /// return `None` if the name already has a definition associated with it. In that\n     /// case an error should be reported to the user, because it usually happens due\n     /// to user\u2019s fault (e.g., misuse of #[no_mangle] or #[export_name] attributes).\n     fn define_global(&self, name: &str, ty: Self::Type) -> Option<Self::Value>;\n@@ -53,10 +53,10 @@ pub trait DeclareMethods<'tcx>: BackendTypes {\n     /// can happen with #[no_mangle] or #[export_name], for example.\n     fn define_internal_fn(&self, name: &str, fn_sig: ty::PolyFnSig<'tcx>) -> Self::Value;\n \n-    /// Get declared value by name.\n+    /// Gets declared value by name.\n     fn get_declared_value(&self, name: &str) -> Option<Self::Value>;\n \n-    /// Get defined or externally defined (AvailableExternally linkage) value by\n+    /// Gets defined or externally defined (AvailableExternally linkage) value by\n     /// name.\n     fn get_defined_value(&self, name: &str) -> Option<Self::Value>;\n }"}, {"sha": "7c5e615f22452dbb02f72f283560a7c0765f032d", "filename": "src/librustc_codegen_ssa/traits/type_.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -39,13 +39,13 @@ pub trait BaseTypeMethods<'tcx>: Backend<'tcx> {\n     fn type_ptr_to(&self, ty: Self::Type) -> Self::Type;\n     fn element_type(&self, ty: Self::Type) -> Self::Type;\n \n-    /// Return the number of elements in `self` if it is a LLVM vector type.\n+    /// Returns the number of elements in `self` if it is a LLVM vector type.\n     fn vector_length(&self, ty: Self::Type) -> usize;\n \n     fn func_params_types(&self, ty: Self::Type) -> Vec<Self::Type>;\n     fn float_width(&self, ty: Self::Type) -> usize;\n \n-    /// Retrieve the bit width of the integer type `self`.\n+    /// Retrieves the bit width of the integer type `self`.\n     fn int_width(&self, ty: Self::Type) -> u64;\n \n     fn val_ty(&self, v: Self::Value) -> Self::Type;"}, {"sha": "f1bd3f03aef8d13840aa668d4e64dbec18661b39", "filename": "src/librustc_data_structures/base_n.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Fbase_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Fbase_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbase_n.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,4 +1,4 @@\n-/// Convert unsigned integers into a string representation with some base.\n+/// Converts unsigned integers into a string representation with some base.\n /// Bases up to and including 36 can be used for case-insensitive things.\n \n use std::str;"}, {"sha": "ff7964646d60882c5da87b331c33a011ca644e53", "filename": "src/librustc_data_structures/bit_set.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -27,7 +27,7 @@ pub struct BitSet<T: Idx> {\n }\n \n impl<T: Idx> BitSet<T> {\n-    /// Create a new, empty bitset with a given `domain_size`.\n+    /// Creates a new, empty bitset with a given `domain_size`.\n     #[inline]\n     pub fn new_empty(domain_size: usize) -> BitSet<T> {\n         let num_words = num_words(domain_size);\n@@ -38,7 +38,7 @@ impl<T: Idx> BitSet<T> {\n         }\n     }\n \n-    /// Create a new, filled bitset with a given `domain_size`.\n+    /// Creates a new, filled bitset with a given `domain_size`.\n     #[inline]\n     pub fn new_filled(domain_size: usize) -> BitSet<T> {\n         let num_words = num_words(domain_size);\n@@ -51,7 +51,7 @@ impl<T: Idx> BitSet<T> {\n         result\n     }\n \n-    /// Get the domain size.\n+    /// Gets the domain size.\n     pub fn domain_size(&self) -> usize {\n         self.domain_size\n     }\n@@ -85,7 +85,7 @@ impl<T: Idx> BitSet<T> {\n         self.words.iter().map(|e| e.count_ones() as usize).sum()\n     }\n \n-    /// True if `self` contains `elem`.\n+    /// Returns `true` if `self` contains `elem`.\n     #[inline]\n     pub fn contains(&self, elem: T) -> bool {\n         assert!(elem.index() < self.domain_size);\n@@ -106,7 +106,7 @@ impl<T: Idx> BitSet<T> {\n         self.words.iter().all(|a| *a == 0)\n     }\n \n-    /// Insert `elem`. Returns true if the set has changed.\n+    /// Insert `elem`. Returns whether the set has changed.\n     #[inline]\n     pub fn insert(&mut self, elem: T) -> bool {\n         assert!(elem.index() < self.domain_size);\n@@ -126,7 +126,7 @@ impl<T: Idx> BitSet<T> {\n         self.clear_excess_bits();\n     }\n \n-    /// Returns true if the set has changed.\n+    /// Returns `true` if the set has changed.\n     #[inline]\n     pub fn remove(&mut self, elem: T) -> bool {\n         assert!(elem.index() < self.domain_size);\n@@ -138,26 +138,26 @@ impl<T: Idx> BitSet<T> {\n         new_word != word\n     }\n \n-    /// Set `self = self | other` and return true if `self` changed\n+    /// Sets `self = self | other` and returns `true` if `self` changed\n     /// (i.e., if new bits were added).\n     pub fn union(&mut self, other: &impl UnionIntoBitSet<T>) -> bool {\n         other.union_into(self)\n     }\n \n-    /// Set `self = self - other` and return true if `self` changed.\n+    /// Sets `self = self - other` and returns `true` if `self` changed.\n     /// (i.e., if any bits were removed).\n     pub fn subtract(&mut self, other: &impl SubtractFromBitSet<T>) -> bool {\n         other.subtract_from(self)\n     }\n \n-    /// Set `self = self & other` and return true if `self` changed.\n+    /// Sets `self = self & other` and return `true` if `self` changed.\n     /// (i.e., if any bits were removed).\n     pub fn intersect(&mut self, other: &BitSet<T>) -> bool {\n         assert_eq!(self.domain_size, other.domain_size);\n         bitwise(&mut self.words, &other.words, |a, b| { a & b })\n     }\n \n-    /// Get a slice of the underlying words.\n+    /// Gets a slice of the underlying words.\n     pub fn words(&self) -> &[Word] {\n         &self.words\n     }\n@@ -611,7 +611,7 @@ impl<T: Idx> GrowableBitSet<T> {\n         GrowableBitSet { bit_set: BitSet::new_empty(bits) }\n     }\n \n-    /// Returns true if the set has changed.\n+    /// Returns `true` if the set has changed.\n     #[inline]\n     pub fn insert(&mut self, elem: T) -> bool {\n         self.ensure(elem.index() + 1);\n@@ -645,7 +645,7 @@ pub struct BitMatrix<R: Idx, C: Idx> {\n }\n \n impl<R: Idx, C: Idx> BitMatrix<R, C> {\n-    /// Create a new `rows x columns` matrix, initially empty.\n+    /// Creates a new `rows x columns` matrix, initially empty.\n     pub fn new(num_rows: usize, num_columns: usize) -> BitMatrix<R, C> {\n         // For every element, we need one bit for every other\n         // element. Round up to an even number of words.\n@@ -668,7 +668,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     /// Sets the cell at `(row, column)` to true. Put another way, insert\n     /// `column` to the bitset for `row`.\n     ///\n-    /// Returns true if this changed the matrix, and false otherwise.\n+    /// Returns `true` if this changed the matrix.\n     pub fn insert(&mut self, row: R, column: C) -> bool {\n         assert!(row.index() < self.num_rows && column.index() < self.num_columns);\n         let (start, _) = self.range(row);\n@@ -691,7 +691,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n         (self.words[start + word_index] & mask) != 0\n     }\n \n-    /// Returns those indices that are true in rows `a` and `b`.  This\n+    /// Returns those indices that are true in rows `a` and `b`. This\n     /// is an O(n) operation where `n` is the number of elements\n     /// (somewhat independent from the actual size of the\n     /// intersection, in particular).\n@@ -715,8 +715,8 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n         result\n     }\n \n-    /// Add the bits from row `read` to the bits from row `write`,\n-    /// return true if anything changed.\n+    /// Adds the bits from row `read` to the bits from row `write`, and\n+    /// returns `true` if anything changed.\n     ///\n     /// This is used when computing transitive reachability because if\n     /// you have an edge `write -> read`, because in that case\n@@ -772,7 +772,7 @@ where\n }\n \n impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n-    /// Create a new empty sparse bit matrix with no rows or columns.\n+    /// Creates a new empty sparse bit matrix with no rows or columns.\n     pub fn new(num_columns: usize) -> Self {\n         Self {\n             num_columns,\n@@ -793,7 +793,7 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     /// Sets the cell at `(row, column)` to true. Put another way, insert\n     /// `column` to the bitset for `row`.\n     ///\n-    /// Returns true if this changed the matrix, and false otherwise.\n+    /// Returns `true` if this changed the matrix.\n     pub fn insert(&mut self, row: R, column: C) -> bool {\n         self.ensure_row(row).insert(column)\n     }\n@@ -806,8 +806,8 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         self.row(row).map_or(false, |r| r.contains(column))\n     }\n \n-    /// Add the bits from row `read` to the bits from row `write`,\n-    /// return true if anything changed.\n+    /// Adds the bits from row `read` to the bits from row `write`, and\n+    /// returns `true` if anything changed.\n     ///\n     /// This is used when computing transitive reachability because if\n     /// you have an edge `write -> read`, because in that case"}, {"sha": "de4b1bcd0c2a191f1df095ccf2b476ccaac680f1", "filename": "src/librustc_data_structures/graph/implementation/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -14,7 +14,7 @@\n //! stored. The edges are stored in a central array, but they are also\n //! threaded onto two linked lists for each node, one for incoming edges\n //! and one for outgoing edges. Note that every edge is a member of some\n-//! incoming list and some outgoing list.  Basically you can load the\n+//! incoming list and some outgoing list. Basically you can load the\n //! first index of the linked list from the node data structures (the\n //! field `first_edge`) and then, for each edge, load the next index from\n //! the field `next_edge`). Each of those fields is an array that should\n@@ -79,7 +79,7 @@ pub const OUTGOING: Direction = Direction { repr: 0 };\n pub const INCOMING: Direction = Direction { repr: 1 };\n \n impl NodeIndex {\n-    /// Returns unique id (unique with respect to the graph holding associated node).\n+    /// Returns unique ID (unique with respect to the graph holding associated node).\n     pub fn node_id(self) -> usize {\n         self.0\n     }"}, {"sha": "24c5448639e7d7db911414abb7a1d248b8aab166", "filename": "src/librustc_data_structures/graph/scc/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -200,7 +200,7 @@ where\n         }\n     }\n \n-    /// Visit a node during the DFS. We first examine its current\n+    /// Visits a node during the DFS. We first examine its current\n     /// state -- if it is not yet visited (`NotVisited`), we can push\n     /// it onto the stack and start walking its successors.\n     ///"}, {"sha": "09aec50e4bb118551e68079a2c2a8a873a515ab6", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -12,7 +12,7 @@ use rustc_serialize as serialize;\n \n /// Represents some newtyped `usize` wrapper.\n ///\n-/// (purpose: avoid mixing indexes for different bitvector domains.)\n+/// Purpose: avoid mixing indexes for different bitvector domains.\n pub trait Idx: Copy + 'static + Ord + Debug + Hash {\n     fn new(idx: usize) -> Self;\n \n@@ -144,19 +144,19 @@ macro_rules! newtype_index {\n                 unsafe { $type { private: value } }\n             }\n \n-            /// Extract value of this index as an integer.\n+            /// Extracts the value of this index as an integer.\n             #[inline]\n             $v fn index(self) -> usize {\n                 self.as_usize()\n             }\n \n-            /// Extract value of this index as a usize.\n+            /// Extracts the value of this index as a `u32`.\n             #[inline]\n             $v fn as_u32(self) -> u32 {\n                 self.private\n             }\n \n-            /// Extract value of this index as a u32.\n+            /// Extracts the value of this index as a `usize`.\n             #[inline]\n             $v fn as_usize(self) -> usize {\n                 self.as_u32() as usize\n@@ -641,7 +641,7 @@ impl<I: Idx, T> IndexVec<I, T> {\n         self.raw.get_mut(index.index())\n     }\n \n-    /// Return mutable references to two distinct elements, a and b. Panics if a == b.\n+    /// Returns mutable references to two distinct elements, a and b. Panics if a == b.\n     #[inline]\n     pub fn pick2_mut(&mut self, a: I, b: I) -> (&mut T, &mut T) {\n         let (ai, bi) = (a.index(), b.index());"}, {"sha": "a0363e165e0493c15bd813fe080e714dad1fd9c3", "filename": "src/librustc_data_structures/obligation_forest/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -7,8 +7,8 @@ use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering;\n \n impl<O: ForestObligation> ObligationForest<O> {\n-    /// Create a graphviz representation of the obligation forest.  Given a directory this will\n-    /// create files with name of the format `<counter>_<description>.gv`.  The counter is\n+    /// Creates a graphviz representation of the obligation forest. Given a directory this will\n+    /// create files with name of the format `<counter>_<description>.gv`. The counter is\n     /// global and is maintained internally.\n     ///\n     /// Calling this will do nothing unless the environment variable"}, {"sha": "4490e5f86d2bd195b651d79d4062fcff6e751303", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -64,15 +64,15 @@\n //! #### Snapshots\n //!\n //! The `ObligationForest` supports a limited form of snapshots; see\n-//! `start_snapshot`; `commit_snapshot`; and `rollback_snapshot`. In\n+//! `start_snapshot`, `commit_snapshot`, and `rollback_snapshot`. In\n //! particular, you can use a snapshot to roll back new root\n //! obligations. However, it is an error to attempt to\n //! `process_obligations` during a snapshot.\n //!\n //! ### Implementation details\n //!\n //! For the most part, comments specific to the implementation are in the\n-//! code.  This file only contains a very high-level overview. Basically,\n+//! code. This file only contains a very high-level overview. Basically,\n //! the forest is stored in a vector. Each element of the vector is a node\n //! in some tree. Each node in the vector has the index of an (optional)\n //! parent and (for convenience) its root (which may be itself). It also\n@@ -163,7 +163,7 @@ pub struct ObligationForest<O: ForestObligation> {\n \n     obligation_tree_id_generator: ObligationTreeIdGenerator,\n \n-    /// Per tree error cache.  This is used to deduplicate errors,\n+    /// Per tree error cache. This is used to deduplicate errors,\n     /// which is necessary to avoid trait resolution overflow in\n     /// some cases.\n     ///\n@@ -268,13 +268,13 @@ impl<O: ForestObligation> ObligationForest<O> {\n         }\n     }\n \n-    /// Return the total number of nodes in the forest that have not\n+    /// Returns the total number of nodes in the forest that have not\n     /// yet been fully resolved.\n     pub fn len(&self) -> usize {\n         self.nodes.len()\n     }\n \n-    /// Registers an obligation\n+    /// Registers an obligation.\n     ///\n     /// This CAN be done in a snapshot\n     pub fn register_obligation(&mut self, obligation: O) {\n@@ -341,7 +341,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         }\n     }\n \n-    /// Convert all remaining obligations to the given error.\n+    /// Converts all remaining obligations to the given error.\n     ///\n     /// This cannot be done during a snapshot.\n     pub fn to_errors<E: Clone>(&mut self, error: E) -> Vec<Error<O, E>> {\n@@ -380,10 +380,10 @@ impl<O: ForestObligation> ObligationForest<O> {\n             .insert(node.obligation.as_predicate().clone());\n     }\n \n-    /// Perform a pass through the obligation list. This must\n+    /// Performs a pass through the obligation list. This must\n     /// be called in a loop until `outcome.stalled` is false.\n     ///\n-    /// This CANNOT be unrolled (presently, at least).\n+    /// This _cannot_ be unrolled (presently, at least).\n     pub fn process_obligations<P>(&mut self, processor: &mut P, do_completed: DoCompleted)\n                                   -> Outcome<O, P::Error>\n         where P: ObligationProcessor<Obligation=O>\n@@ -461,7 +461,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         }\n     }\n \n-    /// Mark all NodeState::Success nodes as NodeState::Done and\n+    /// Mark all `NodeState::Success` nodes as `NodeState::Done` and\n     /// report all cycles between them. This should be called\n     /// after `mark_as_waiting` marks all nodes with pending\n     /// subobligations as NodeState::Waiting.\n@@ -566,7 +566,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         }\n     }\n \n-    /// Marks all nodes that depend on a pending node as NodeState::Waiting.\n+    /// Marks all nodes that depend on a pending node as `NodeState::Waiting`.\n     fn mark_as_waiting(&self) {\n         for node in &self.nodes {\n             if node.state.get() == NodeState::Waiting {"}, {"sha": "236559dcd7c10c84c6a71293f9c15691898cc53b", "filename": "src/librustc_data_structures/owning_ref/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -286,7 +286,7 @@ impl<T> Erased for T {}\n pub unsafe trait IntoErased<'a> {\n     /// Owner with the dereference type substituted to `Erased`.\n     type Erased;\n-    /// Perform the type erasure.\n+    /// Performs the type erasure.\n     fn into_erased(self) -> Self::Erased;\n }\n \n@@ -296,7 +296,7 @@ pub unsafe trait IntoErased<'a> {\n pub unsafe trait IntoErasedSend<'a> {\n     /// Owner with the dereference type substituted to `Erased + Send`.\n     type Erased: Send;\n-    /// Perform the type erasure.\n+    /// Performs the type erasure.\n     fn into_erased_send(self) -> Self::Erased;\n }\n \n@@ -306,7 +306,7 @@ pub unsafe trait IntoErasedSend<'a> {\n pub unsafe trait IntoErasedSendSync<'a> {\n     /// Owner with the dereference type substituted to `Erased + Send + Sync`.\n     type Erased: Send + Sync;\n-    /// Perform the type erasure.\n+    /// Performs the type erasure.\n     fn into_erased_send_sync(self) -> Self::Erased;\n }\n \n@@ -844,7 +844,7 @@ pub trait ToHandleMut {\n impl<O, H> OwningHandle<O, H>\n     where O: StableAddress, O::Target: ToHandle<Handle = H>, H: Deref,\n {\n-    /// Create a new `OwningHandle` for a type that implements `ToHandle`. For types\n+    /// Creates a new `OwningHandle` for a type that implements `ToHandle`. For types\n     /// that don't implement `ToHandle`, callers may invoke `new_with_fn`, which accepts\n     /// a callback to perform the conversion.\n     pub fn new(o: O) -> Self {\n@@ -855,7 +855,7 @@ impl<O, H> OwningHandle<O, H>\n impl<O, H> OwningHandle<O, H>\n     where O: StableAddress, O::Target: ToHandleMut<HandleMut = H>, H: DerefMut,\n {\n-    /// Create a new mutable `OwningHandle` for a type that implements `ToHandleMut`.\n+    /// Creates a new mutable `OwningHandle` for a type that implements `ToHandleMut`.\n     pub fn new_mut(o: O) -> Self {\n         OwningHandle::new_with_fn(o, |x| unsafe { O::Target::to_handle_mut(x) })\n     }\n@@ -864,7 +864,7 @@ impl<O, H> OwningHandle<O, H>\n impl<O, H> OwningHandle<O, H>\n     where O: StableAddress, H: Deref,\n {\n-    /// Create a new OwningHandle. The provided callback will be invoked with\n+    /// Creates a new OwningHandle. The provided callback will be invoked with\n     /// a pointer to the object owned by `o`, and the returned value is stored\n     /// as the object to which this `OwningHandle` will forward `Deref` and\n     /// `DerefMut`.\n@@ -882,7 +882,7 @@ impl<O, H> OwningHandle<O, H>\n         }\n     }\n \n-    /// Create a new OwningHandle. The provided callback will be invoked with\n+    /// Creates a new OwningHandle. The provided callback will be invoked with\n     /// a pointer to the object owned by `o`, and the returned value is stored\n     /// as the object to which this `OwningHandle` will forward `Deref` and\n     /// `DerefMut`."}, {"sha": "06f157f972932e84005c4e744d67f287044cfb90", "filename": "src/librustc_data_structures/sip128.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsip128.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -44,7 +44,7 @@ macro_rules! compress {\n     });\n }\n \n-/// Load an integer of the desired type from a byte stream, in LE order. Uses\n+/// Loads an integer of the desired type from a byte stream, in LE order. Uses\n /// `copy_nonoverlapping` to let the compiler generate the most efficient way\n /// to load it from a possibly unaligned address.\n ///\n@@ -61,7 +61,7 @@ macro_rules! load_int_le {\n     });\n }\n \n-/// Load an u64 using up to 7 bytes of a byte slice.\n+/// Loads an u64 using up to 7 bytes of a byte slice.\n ///\n /// Unsafe because: unchecked indexing at start..start+len\n #[inline]"}, {"sha": "df4f61768375e35d4a1915760870e6e1cae19570", "filename": "src/librustc_data_structures/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsvh.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -17,7 +17,7 @@ pub struct Svh {\n }\n \n impl Svh {\n-    /// Create a new `Svh` given the hash. If you actually want to\n+    /// Creates a new `Svh` given the hash. If you actually want to\n     /// compute the SVH from some HIR, you want the `calculate_svh`\n     /// function found in `librustc_incremental`.\n     pub fn new(hash: u64) -> Svh {"}, {"sha": "0974607fabea8f1caaa69961205f8bef50295087", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -82,7 +82,7 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n     }\n \n     /// Applies the (partial) function to each edge and returns a new\n-    /// relation.  If `f` returns `None` for any end-point, returns\n+    /// relation. If `f` returns `None` for any end-point, returns\n     /// `None`.\n     pub fn maybe_map<F, U>(&self, mut f: F) -> Option<TransitiveRelation<U>>\n         where F: FnMut(&T) -> Option<U>,\n@@ -111,7 +111,7 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n         }\n     }\n \n-    /// Check whether `a < target` (transitively)\n+    /// Checks whether `a < target` (transitively)\n     pub fn contains(&self, a: &T, b: &T) -> bool {\n         match (self.index(a), self.index(b)) {\n             (Some(a), Some(b)) => self.with_closure(|closure| closure.contains(a.0, b.0)),\n@@ -122,7 +122,7 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n     /// Thinking of `x R y` as an edge `x -> y` in a graph, this\n     /// returns all things reachable from `a`.\n     ///\n-    /// Really this probably ought to be `impl Iterator<Item=&T>`, but\n+    /// Really this probably ought to be `impl Iterator<Item = &T>`, but\n     /// I'm too lazy to make that work, and -- given the caching\n     /// strategy -- it'd be a touch tricky anyhow.\n     pub fn reachable_from(&self, a: &T) -> Vec<&T> {\n@@ -152,20 +152,20 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n     /// the query is `postdom_upper_bound(a, b)`:\n     ///\n     /// ```text\n-    /// // returns Some(x), which is also LUB\n+    /// // Returns Some(x), which is also LUB.\n     /// a -> a1 -> x\n     ///            ^\n     ///            |\n     /// b -> b1 ---+\n     ///\n-    /// // returns Some(x), which is not LUB (there is none)\n-    /// // diagonal edges run left-to-right\n+    /// // Returns `Some(x)`, which is not LUB (there is none)\n+    /// // diagonal edges run left-to-right.\n     /// a -> a1 -> x\n     ///   \\/       ^\n     ///   /\\       |\n     /// b -> b1 ---+\n     ///\n-    /// // returns None\n+    /// // Returns `None`.\n     /// a -> a1\n     /// b -> b1\n     /// ```"}, {"sha": "193025aafad20f9bf452b2fff07e67059f4ac3b8", "filename": "src/librustc_data_structures/work_queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_data_structures%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fwork_queue.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -14,7 +14,7 @@ pub struct WorkQueue<T: Idx> {\n }\n \n impl<T: Idx> WorkQueue<T> {\n-    /// Create a new work queue with all the elements from (0..len).\n+    /// Creates a new work queue with all the elements from (0..len).\n     #[inline]\n     pub fn with_all(len: usize) -> Self {\n         WorkQueue {\n@@ -23,7 +23,7 @@ impl<T: Idx> WorkQueue<T> {\n         }\n     }\n \n-    /// Create a new work queue that starts empty, where elements range from (0..len).\n+    /// Creates a new work queue that starts empty, where elements range from (0..len).\n     #[inline]\n     pub fn with_none(len: usize) -> Self {\n         WorkQueue {\n@@ -54,7 +54,7 @@ impl<T: Idx> WorkQueue<T> {\n         }\n     }\n \n-    /// True if nothing is enqueued.\n+    /// Returns `true` if nothing is enqueued.\n     #[inline]\n     pub fn is_empty(&self) -> bool {\n         self.deque.is_empty()"}, {"sha": "09804a706ec98f19ef7c6157948fba66b21cee36", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -711,7 +711,7 @@ pub struct InnerExpansionResult<'a> {\n     pub hir_forest: hir_map::Forest,\n }\n \n-/// Run the \"early phases\" of the compiler: initial `cfg` processing,\n+/// Runs the \"early phases\" of the compiler: initial `cfg` processing,\n /// loading compiler plugins (including those from `addl_plugins`),\n /// syntax expansion, secondary `cfg` expansion, synthesis of a test\n /// harness if one is to be provided, injection of a dependency on the\n@@ -1167,7 +1167,7 @@ pub fn default_provide_extern(providers: &mut ty::query::Providers) {\n     cstore::provide_extern(providers);\n }\n \n-/// Run the resolution, typechecking, region checking and other\n+/// Runs the resolution, typec-hecking, region checking and other\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes<'tcx, F, R>(\n@@ -1334,7 +1334,7 @@ where\n     )\n }\n \n-/// Run the codegen backend, after which the AST and analysis can\n+/// Runs the codegen backend, after which the AST and analysis can\n /// be discarded.\n pub fn phase_4_codegen<'a, 'tcx>(\n     codegen_backend: &dyn CodegenBackend,"}, {"sha": "990ad4ada01a2dcd22c629ebe9fa12eb33eb25dd", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -114,7 +114,7 @@ pub mod target_features {\n     use rustc::session::Session;\n     use rustc_codegen_utils::codegen_backend::CodegenBackend;\n \n-    /// Add `target_feature = \"...\"` cfgs for a variety of platform\n+    /// Adds `target_feature = \"...\"` cfgs for a variety of platform\n     /// specific features (SSE, NEON etc.).\n     ///\n     /// This is performed by checking whether a whitelisted set of\n@@ -1324,7 +1324,7 @@ fn print_flag_list<T>(cmdline_opt: &str,\n \n /// Process command line options. Emits messages as appropriate. If compilation\n /// should continue, returns a getopts::Matches object parsed from args,\n-/// otherwise returns None.\n+/// otherwise returns `None`.\n ///\n /// The compiler's handling of options is a little complicated as it ties into\n /// our stability story, and it's even *more* complicated by historical\n@@ -1488,7 +1488,7 @@ pub fn in_rustc_thread<F, R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     in_named_rustc_thread(\"rustc\".to_string(), f)\n }\n \n-/// Get a list of extra command-line flags provided by the user, as strings.\n+/// Gets a list of extra command-line flags provided by the user, as strings.\n ///\n /// This function is used during ICEs to show more information useful for\n /// debugging, since some ICEs only happens with non-default compiler flags\n@@ -1553,7 +1553,7 @@ impl Display for CompilationFailure {\n     }\n }\n \n-/// Run a procedure which will detect panics in the compiler and print nicer\n+/// Runs a procedure which will detect panics in the compiler and print nicer\n /// error messages rather than just failing the test.\n ///\n /// The diagnostic emitter yielded to the procedure should be used for reporting"}, {"sha": "2ec755bd626919864c5efc671ed5b11f9076727c", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,4 +1,4 @@\n-//! # Standalone Tests for the Inference Module\n+//! Standalone tests for the inference module.\n \n use driver;\n use errors;\n@@ -508,8 +508,8 @@ fn subst_ty_renumber_bound() {\n     })\n }\n \n-/// Test substituting a bound region into a function, which introduces another level of binding.\n-/// This requires adjusting the Debruijn index.\n+/// Tests substituting a bound region into a function, which introduces another level of binding.\n+/// This requires adjusting the De Bruijn index.\n #[test]\n fn subst_ty_renumber_some_bounds() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n@@ -544,7 +544,7 @@ fn subst_ty_renumber_some_bounds() {\n     })\n }\n \n-/// Test that we correctly compute whether a type has escaping regions or not.\n+/// Tests that we correctly compute whether a type has escaping regions or not.\n #[test]\n fn escaping() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n@@ -571,7 +571,7 @@ fn escaping() {\n     })\n }\n \n-/// Test applying a substitution where the value being substituted for an early-bound region is a\n+/// Tests applying a substitution where the value being substituted for an early-bound region is a\n /// late-bound region.\n #[test]\n fn subst_region_renumber_region() {"}, {"sha": "2c410f69bfc662cd8a0128e9c800b499aa1100fa", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -118,7 +118,7 @@ impl Diagnostic {\n         self.level == Level::Cancelled\n     }\n \n-    /// Add a span/label to be included in the resulting snippet.\n+    /// Adds a span/label to be included in the resulting snippet.\n     /// This is pushed onto the `MultiSpan` that was created when the\n     /// diagnostic was first built. If you don't call this function at\n     /// all, and you just supplied a `Span` to create the diagnostic,"}, {"sha": "9d5e8d10b1772ff8c56108d2ae7feed832fa683a", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -26,7 +26,7 @@ pub struct DiagnosticBuilder<'a> {\n \n /// In general, the `DiagnosticBuilder` uses deref to allow access to\n /// the fields and methods of the embedded `diagnostic` in a\n-/// transparent way.  *However,* many of the methods are intended to\n+/// transparent way. *However,* many of the methods are intended to\n /// be used in a chained way, and hence ought to return `self`. In\n /// that case, we can't just naively forward to the method on the\n /// `diagnostic`, because the return type would be a `&Diagnostic`\n@@ -150,7 +150,7 @@ impl<'a> DiagnosticBuilder<'a> {\n         self.cancel();\n     }\n \n-    /// Add a span/label to be included in the resulting snippet.\n+    /// Adds a span/label to be included in the resulting snippet.\n     /// This is pushed onto the `MultiSpan` that was created when the\n     /// diagnostic was first built. If you don't call this function at\n     /// all, and you just supplied a `Span` to create the diagnostic,"}, {"sha": "1c0c9d137e40fedfa4084f2696a9919d6730a180", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -22,7 +22,7 @@ pub trait Emitter {\n     /// Emit a structured diagnostic.\n     fn emit(&mut self, db: &DiagnosticBuilder<'_>);\n \n-    /// Check if should show explanations about \"rustc --explain\"\n+    /// Checks if should show explanations about \"rustc --explain\"\n     fn should_show_explain(&self) -> bool {\n         true\n     }\n@@ -868,7 +868,7 @@ impl EmitterWriter {\n         }\n     }\n \n-    /// Add a left margin to every line but the first, given a padding length and the label being\n+    /// Adds a left margin to every line but the first, given a padding length and the label being\n     /// displayed, keeping the provided highlighting.\n     fn msg_to_buffer(&self,\n                      buffer: &mut StyledBuffer,\n@@ -895,7 +895,7 @@ impl EmitterWriter {\n         //    `max_line_num_len`\n         let padding = \" \".repeat(padding + label.len() + 5);\n \n-        /// Return whether `style`, or the override if present and the style is `NoStyle`.\n+        /// Returns `true` if `style`, or the override if present and the style is `NoStyle`.\n         fn style_or_override(style: Style, override_style: Option<Style>) -> Style {\n             if let Some(o) = override_style {\n                 if style == Style::NoStyle {"}, {"sha": "93d33d9936187601db7e83ba94df4b05783a21fc", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -390,7 +390,7 @@ impl Handler {\n \n     /// Resets the diagnostic error count as well as the cached emitted diagnostics.\n     ///\n-    /// NOTE: DO NOT call this function from rustc. It is only meant to be called from external\n+    /// NOTE: *do not* call this function from rustc. It is only meant to be called from external\n     /// tools that want to reuse a `Parser` cleaning the previously emitted diagnostics as well as\n     /// the overall count of emitted error diagnostics.\n     pub fn reset_err_count(&self) {"}, {"sha": "ce63bcafd797c9ac38d206ed71e0d4e648c7632b", "filename": "src/librustc_fs_util/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_fs_util%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_fs_util%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_fs_util%2Flib.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -58,7 +58,7 @@ pub enum LinkOrCopy {\n     Copy,\n }\n \n-/// Copy `p` into `q`, preferring to use hard-linking if possible. If\n+/// Copies `p` into `q`, preferring to use hard-linking if possible. If\n /// `q` already exists, it is removed first.\n /// The result indicates which of the two operations has been performed.\n pub fn link_or_copy<P: AsRef<Path>, Q: AsRef<Path>>(p: P, q: Q) -> io::Result<LinkOrCopy> {"}, {"sha": "fe44e0cbe614333fab41428cead6d9445f252bb6", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -12,7 +12,7 @@\n //! In this code, we report errors on each `rustc_if_this_changed`\n //! annotation. If a path exists in all cases, then we would report\n //! \"all path(s) exist\". Otherwise, we report: \"no path to `foo`\" for\n-//! each case where no path exists.  `compile-fail` tests can then be\n+//! each case where no path exists. `compile-fail` tests can then be\n //! used to check when paths exist or do not.\n //!\n //! The full form of the `rustc_if_this_changed` annotation is"}, {"sha": "c13a3533032a8298b531a6e04bacdf337112c735", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -5,14 +5,13 @@\n //!\n //! - `#[rustc_clean(cfg=\"rev2\", except=\"TypeckTables\")]` if we are\n //!   in `#[cfg(rev2)]`, then the fingerprints associated with\n-//!   `DepNode::TypeckTables(X)` must be DIFFERENT (`X` is the def-id of the\n+//!   `DepNode::TypeckTables(X)` must be DIFFERENT (`X` is the `DefId` of the\n //!   current node).\n //! - `#[rustc_clean(cfg=\"rev2\")]` same as above, except that the\n //!   fingerprints must be the SAME (along with all other fingerprints).\n //!\n //! Errors are reported if we are in the suitable configuration but\n //! the required condition is not met.\n-//!\n \n use std::iter::FromIterator;\n use std::vec::Vec;\n@@ -84,7 +83,7 @@ const BASE_STRUCT: &[&str] = &[\n     label_strs::TypeOfItem,\n ];\n \n-/// Trait Definition DepNodes\n+/// Trait definition `DepNode`s.\n const BASE_TRAIT_DEF: &[&str] = &[\n     label_strs::AssociatedItemDefIds,\n     label_strs::GenericsOfItem,\n@@ -95,7 +94,7 @@ const BASE_TRAIT_DEF: &[&str] = &[\n     label_strs::TraitImpls,\n ];\n \n-/// extra DepNodes for methods (+fn)\n+/// Extra `DepNode`s for functions and methods.\n const EXTRA_ASSOCIATED: &[&str] = &[\n     label_strs::AssociatedItems,\n ];\n@@ -126,22 +125,22 @@ const LABELS_CONST_IN_TRAIT: &[&[&str]] = &[\n     EXTRA_TRAIT,\n ];\n \n-/// Function DepNode\n+/// Function `DepNode`s.\n const LABELS_FN: &[&[&str]] = &[\n     BASE_HIR,\n     BASE_MIR,\n     BASE_FN,\n ];\n \n-/// Method DepNodes\n+/// Method `DepNode`s.\n const LABELS_FN_IN_IMPL: &[&[&str]] = &[\n     BASE_HIR,\n     BASE_MIR,\n     BASE_FN,\n     EXTRA_ASSOCIATED,\n ];\n \n-/// Trait-Method DepNodes\n+/// Trait method `DepNode`s.\n const LABELS_FN_IN_TRAIT: &[&[&str]] = &[\n     BASE_HIR,\n     BASE_MIR,\n@@ -150,24 +149,24 @@ const LABELS_FN_IN_TRAIT: &[&[&str]] = &[\n     EXTRA_TRAIT,\n ];\n \n-/// For generic cases like inline-assembly/mod/etc\n+/// For generic cases like inline-assembly, modules, etc.\n const LABELS_HIR_ONLY: &[&[&str]] = &[\n     BASE_HIR,\n ];\n \n-/// Impl DepNodes\n+/// Impl `DepNode`s.\n const LABELS_IMPL: &[&[&str]] = &[\n     BASE_HIR,\n     BASE_IMPL,\n ];\n \n-/// Abstract Data Type (Struct, Enum, Unions) DepNodes\n+/// Abstract data type (struct, enum, union) `DepNode`s.\n const LABELS_ADT: &[&[&str]] = &[\n     BASE_HIR,\n     BASE_STRUCT,\n ];\n \n-/// Trait Definition DepNodes\n+/// Trait definition `DepNode`s.\n #[allow(dead_code)]\n const LABELS_TRAIT: &[&[&str]] = &[\n     BASE_HIR,\n@@ -269,7 +268,7 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n         Some(assertion)\n     }\n \n-    /// Get the \"auto\" assertion on pre-validated attr, along with the `except` labels\n+    /// Gets the \"auto\" assertion on pre-validated attr, along with the `except` labels.\n     fn assertion_auto(&mut self, item_id: ast::NodeId, attr: &Attribute, is_clean: bool)\n         -> Assertion\n     {"}, {"sha": "f363f718496fa9ff5f48032eb75de98cc85946a6", "filename": "src/librustc_incremental/persist/file_format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -17,15 +17,15 @@ use std::env;\n use rustc::session::config::nightly_options;\n use rustc_serialize::opaque::Encoder;\n \n-/// The first few bytes of files generated by incremental compilation\n+/// The first few bytes of files generated by incremental compilation.\n const FILE_MAGIC: &[u8] = b\"RSIC\";\n \n-/// Change this if the header format changes\n+/// Change this if the header format changes.\n const HEADER_FORMAT_VERSION: u16 = 0;\n \n /// A version string that hopefully is always different for compiler versions\n /// with different encodings of incremental compilation artifacts. Contains\n-/// the git commit hash.\n+/// the Git commit hash.\n const RUSTC_VERSION: Option<&str> = option_env!(\"CFG_VERSION\");\n \n pub fn write_file_header(stream: &mut Encoder) {"}, {"sha": "7dcd5c94bf2989628f4eb43df94e301f1a1944c4", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -444,7 +444,7 @@ fn copy_files(sess: &Session,\n     Ok(files_linked > 0 || files_copied == 0)\n }\n \n-/// Generate unique directory path of the form:\n+/// Generates unique directory path of the form:\n /// {crate_dir}/s-{timestamp}-{random-number}-working\n fn generate_session_dir_path(crate_dir: &Path) -> PathBuf {\n     let timestamp = timestamp_to_string(SystemTime::now());\n@@ -509,7 +509,7 @@ fn delete_session_dir_lock_file(sess: &Session,\n     }\n }\n \n-/// Find the most recent published session directory that is not in the\n+/// Finds the most recent published session directory that is not in the\n /// ignore-list.\n fn find_source_directory(crate_dir: &Path,\n                          source_directories_already_tried: &FxHashSet<PathBuf>)"}, {"sha": "9f1a1d5cd92b355538d8236056e7fa879ee30bf1", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -13,10 +13,13 @@\n //! `LintPass` (also, note that such lints will need to be defined in\n //! `rustc::lint::builtin`, not here).\n //!\n-//! If you define a new `LintPass`, you will also need to add it to the\n-//! `add_builtin!` or `add_builtin_with_new!` invocation in `lib.rs`.\n-//! Use the former for unit-like structs and the latter for structs with\n-//! a `pub fn new()`.\n+//! If you define a new `EarlyLintPass`, you will also need to add it to the\n+//! `add_early_builtin!` or `add_early_builtin_with_new!` invocation in\n+//! `lib.rs`. Use the former for unit-like structs and the latter for structs\n+//! with a `pub fn new()`.\n+//!\n+//! If you define a new `LateLintPass`, you will also need to add it to the\n+//! `late_lint_methods!` invocation in `lib.rs`.\n \n use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n@@ -317,8 +320,7 @@ declare_lint! {\n }\n \n pub struct MissingDoc {\n-    /// Stack of whether #[doc(hidden)] is set\n-    /// at each level which has lint attributes.\n+    /// Stack of whether `#[doc(hidden)]` is set at each level which has lint attributes.\n     doc_hidden_stack: Vec<bool>,\n \n     /// Private traits or trait items that leaked through. Don't check their methods.\n@@ -670,8 +672,8 @@ declare_lint! {\n     \"detects anonymous parameters\"\n }\n \n-/// Checks for use of anonymous parameters (RFC 1685)\n-#[derive(Clone)]\n+/// Checks for use of anonymous parameters (RFC 1685).\n+#[derive(Copy, Clone)]\n pub struct AnonymousParameters;\n \n impl LintPass for AnonymousParameters {\n@@ -726,7 +728,7 @@ impl EarlyLintPass for AnonymousParameters {\n     }\n }\n \n-/// Checks for use of attributes which have been deprecated.\n+/// Check for use of attributes which have been deprecated.\n #[derive(Clone)]\n pub struct DeprecatedAttr {\n     // This is not free to compute, so we want to keep it around, rather than\n@@ -1083,7 +1085,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n     }\n }\n \n-/// Lint for items marked `pub` that aren't reachable from other crates\n+/// Lint for items marked `pub` that aren't reachable from other crates.\n+#[derive(Copy, Clone)]\n pub struct UnreachablePub;\n \n declare_lint! {\n@@ -1156,7 +1159,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnreachablePub {\n     }\n }\n \n-/// Lint for trait and lifetime bounds in type aliases being mostly ignored:\n+/// Lint for trait and lifetime bounds in type aliases being mostly ignored.\n /// They are relevant when using associated types, but otherwise neither checked\n /// at definition site nor enforced at use site.\n \n@@ -1543,8 +1546,8 @@ declare_lint! {\n     \"detects edition keywords being used as an identifier\"\n }\n \n-/// Checks for uses of edition keywords used as an identifier\n-#[derive(Clone)]\n+/// Check for uses of edition keywords used as an identifier.\n+#[derive(Copy, Clone)]\n pub struct KeywordIdents;\n \n impl LintPass for KeywordIdents {"}, {"sha": "141ba19479daa0b88debde464b7eef92e46f9ee3", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -479,7 +479,7 @@ fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n-    /// Check if the given type is \"ffi-safe\" (has a stable, well-defined\n+    /// Checks if the given type is \"ffi-safe\" (has a stable, well-defined\n     /// representation which can be exported to C code).\n     fn check_type_for_ffi(&self,\n                           cache: &mut FxHashSet<Ty<'tcx>>,"}, {"sha": "6f2718381c2ec80661e33b14febd201fd1619dfc", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -513,7 +513,7 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    /// Load custom derive macros.\n+    /// Loads custom derive macros.\n     ///\n     /// Note that this is intentionally similar to how we load plugins today,\n     /// but also intentionally separate. Plugins are likely always going to be"}, {"sha": "d646879b4d45ddb6083eaabf493a0eb3e8afe867", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -46,7 +46,7 @@ pub struct CrateMetadata {\n     /// Original name of the crate.\n     pub name: Symbol,\n \n-    /// Name of the crate as imported.  I.e., if imported with\n+    /// Name of the crate as imported. I.e., if imported with\n     /// `extern crate foo as bar;` this will be `bar`.\n     pub imported_name: Symbol,\n \n@@ -66,9 +66,9 @@ pub struct CrateMetadata {\n \n     pub root: schema::CrateRoot,\n \n-    /// For each public item in this crate, we encode a key.  When the\n+    /// For each public item in this crate, we encode a key. When the\n     /// crate is loaded, we read all the keys and put them in this\n-    /// hashmap, which gives the reverse mapping.  This allows us to\n+    /// hashmap, which gives the reverse mapping. This allows us to\n     /// quickly retrace a `DefPath`, which is needed for incremental\n     /// compilation support.\n     pub def_path_table: Lrc<DefPathTable>,"}, {"sha": "1c4e3bc6a50e700e858ccb57d3d4c448fee572d4", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -434,7 +434,7 @@ impl<'tcx> EntryKind<'tcx> {\n     }\n }\n \n-/// Create the \"fake\" DefPathTable for a given proc macro crate.\n+/// Creates the \"fake\" DefPathTable for a given proc macro crate.\n ///\n /// The DefPathTable is as follows:\n ///"}, {"sha": "9dd160c24c37397fb7f46b9201d4aae30aed83a4", "filename": "src/librustc_metadata/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdynamic_lib.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -32,7 +32,7 @@ impl DynamicLibrary {\n         }\n     }\n \n-    /// Load a dynamic library into the global namespace (RTLD_GLOBAL on Unix)\n+    /// Loads a dynamic library into the global namespace (RTLD_GLOBAL on Unix)\n     /// and do it now (don't use RTLD_LAZY on Unix).\n     pub fn open_global_now(filename: &Path) -> Result<DynamicLibrary, String> {\n         let maybe_library = dl::open_global_now(filename.as_os_str());"}, {"sha": "9aff1133ea920b1252a818aec7663e541d78c27f", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -3,7 +3,7 @@\n //!\n //! ```\n //! <common::data> // big list of item-like things...\n-//!    <common::data_item> // ...for most def-ids, there is an entry.\n+//!    <common::data_item> // ...for most `DefId`s, there is an entry.\n //!    </common::data_item>\n //! </common::data>\n //! ```\n@@ -85,7 +85,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n         }\n     }\n \n-    /// Emit the data for a def-id to the metadata. The function to\n+    /// Emit the data for a `DefId` to the metadata. The function to\n     /// emit the data is `op`, and it will be given `data` as\n     /// arguments. This `record` function will call `op` to generate\n     /// the `Entry` (which may point to other encoded information)\n@@ -129,7 +129,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n }\n \n /// Trait used for data that can be passed from outside a dep-graph\n-/// task.  The data must either be of some safe type, such as a\n+/// task. The data must either be of some safe type, such as a\n /// `DefId` index, or implement the `read` method so that it can add\n /// a read of whatever dep-graph nodes are appropriate.\n pub trait DepGraphRead {\n@@ -212,9 +212,9 @@ impl<T> DepGraphRead for Untracked<T> {\n }\n \n /// Newtype that can be used to package up misc data extracted from a\n-/// HIR node that doesn't carry its own id. This will allow an\n+/// HIR node that doesn't carry its own ID. This will allow an\n /// arbitrary `T` to be passed in, but register a read on the given\n-/// node-id.\n+/// `NodeId`.\n pub struct FromId<T>(pub ast::NodeId, pub T);\n \n impl<T> DepGraphRead for FromId<T> {"}, {"sha": "6a1aada5ac7063d8a31825819c89ee3c02fe44d2", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -27,7 +27,7 @@\n //!\n //! The reason for this is that any of B's types could be composed of C's types,\n //! any function in B could return a type from C, etc. To be able to guarantee\n-//! that we can always typecheck/translate any function, we have to have\n+//! that we can always type-check/translate any function, we have to have\n //! complete knowledge of the whole ecosystem, not just our immediate\n //! dependencies.\n //!\n@@ -918,7 +918,7 @@ fn get_metadata_section_imp(target: &Target,\n     }\n }\n \n-// A diagnostic function for dumping crate metadata to an output stream\n+/// A diagnostic function for dumping crate metadata to an output stream.\n pub fn list_file_metadata(target: &Target,\n                           path: &Path,\n                           loader: &dyn MetadataLoader,"}, {"sha": "53e4ffc8bd6e7eb7b2a1535f6942cbafc6f75a22", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -26,12 +26,12 @@ crate struct BorrowSet<'tcx> {\n     crate location_map: FxHashMap<Location, BorrowIndex>,\n \n     /// Locations which activate borrows.\n-    /// NOTE: A given location may activate more than one borrow in the future\n+    /// NOTE: a given location may activate more than one borrow in the future\n     /// when more general two-phase borrow support is introduced, but for now we\n-    /// only need to store one borrow index\n+    /// only need to store one borrow index.\n     crate activation_map: FxHashMap<Location, Vec<BorrowIndex>>,\n \n-    /// Map from local to all the borrows on that local\n+    /// Map from local to all the borrows on that local.\n     crate local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n \n     crate locals_state_at_exit: LocalsStateAtExit,\n@@ -45,8 +45,8 @@ impl<'tcx> Index<BorrowIndex> for BorrowSet<'tcx> {\n     }\n }\n \n-/// Location where a two phase borrow is activated, if a borrow\n-/// is in fact a two phase borrow.\n+/// Location where a two-phase borrow is activated, if a borrow\n+/// is in fact a two-phase borrow.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n crate enum TwoPhaseActivation {\n     NotTwoPhase,\n@@ -311,7 +311,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> GatherBorrows<'a, 'gcx, 'tcx> {\n-    /// Returns true if the borrow represented by `kind` is\n+    /// Returns `true` if the borrow represented by `kind` is\n     /// allowed to be split into separate Reservation and\n     /// Activation phases.\n     fn allow_two_phase_borrow(&self, kind: mir::BorrowKind) -> bool {"}, {"sha": "2da8eb8ec05443cba783b510b436e245d64292dc", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -33,7 +33,7 @@ struct MoveSite {\n     /// then tell us where the move occurred.\n     moi: MoveOutIndex,\n \n-    /// True if we traversed a back edge while walking from the point\n+    /// `true` if we traversed a back edge while walking from the point\n     /// of error to the move site.\n     traversed_back_edge: bool\n }\n@@ -1793,7 +1793,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Check if a place is a thread-local static.\n+    /// Checks if a place is a thread-local static.\n     pub fn is_place_thread_local(&self, place: &Place<'tcx>) -> bool {\n         if let Place::Static(statik) = place {\n             let attrs = self.infcx.tcx.get_attrs(statik.def_id);\n@@ -2314,7 +2314,7 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n         }\n     }\n \n-    /// Return the name of the provided `Ty` (that must be a reference)'s region with a\n+    /// Returns the name of the provided `Ty` (that must be a reference)'s region with a\n     /// synthesized lifetime name where required.\n     fn get_region_name_for_ty(&self, ty: ty::Ty<'tcx>, counter: usize) -> String {\n         match ty.sty {\n@@ -2389,15 +2389,15 @@ impl UseSpans {\n         }\n     }\n \n-    /// Return `false` if this place is not used in a closure.\n+    /// Returns `false` if this place is not used in a closure.\n     fn for_closure(&self) -> bool {\n         match *self {\n             UseSpans::ClosureUse { is_generator, .. } => !is_generator,\n             _ => false,\n         }\n     }\n \n-    /// Return `false` if this place is not used in a generator.\n+    /// Returns `false` if this place is not used in a generator.\n     fn for_generator(&self) -> bool {\n         match *self {\n             UseSpans::ClosureUse { is_generator, .. } => is_generator,"}, {"sha": "f7d079c5494ef55c40a58c67f919fb484c694cdd", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -420,11 +420,11 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     access_place_error_reported: FxHashSet<(Place<'tcx>, Span)>,\n     /// This field keeps track of when borrow conflict errors are reported\n     /// for reservations, so that we don't report seemingly duplicate\n-    /// errors for corresponding activations\n-    ///\n-    /// FIXME: Ideally this would be a set of BorrowIndex, not Places,\n-    /// but it is currently inconvenient to track down the BorrowIndex\n-    /// at the time we detect and report a reservation error.\n+    /// errors for corresponding activations.\n+    //\n+    // FIXME: ideally this would be a set of `BorrowIndex`, not `Place`s,\n+    // but it is currently inconvenient to track down the `BorrowIndex`\n+    // at the time we detect and report a reservation error.\n     reservation_error_reported: FxHashSet<Place<'tcx>>,\n     /// This field keeps track of move errors that are to be reported for given move indicies.\n     ///\n@@ -452,7 +452,7 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     /// If the function we're checking is a closure, then we'll need to report back the list of\n     /// mutable upvars that have been used. This field keeps track of them.\n     used_mut_upvars: SmallVec<[Field; 8]>,\n-    /// Non-lexical region inference context, if NLL is enabled.  This\n+    /// Non-lexical region inference context, if NLL is enabled. This\n     /// contains the results from region inference and lets us e.g.\n     /// find out which CFG points are contained in each borrow region.\n     nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n@@ -835,12 +835,12 @@ enum WriteKind {\n \n /// When checking permissions for a place access, this flag is used to indicate that an immutable\n /// local place can be mutated.\n-///\n-/// FIXME: @nikomatsakis suggested that this flag could be removed with the following modifications:\n-/// - Merge `check_access_permissions()` and `check_if_reassignment_to_immutable_state()`\n-/// - Split `is_mutable()` into `is_assignable()` (can be directly assigned) and\n-///   `is_declared_mutable()`\n-/// - Take flow state into consideration in `is_assignable()` for local variables\n+//\n+// FIXME: @nikomatsakis suggested that this flag could be removed with the following modifications:\n+// - Merge `check_access_permissions()` and `check_if_reassignment_to_immutable_state()`.\n+// - Split `is_mutable()` into `is_assignable()` (can be directly assigned) and\n+//   `is_declared_mutable()`.\n+// - Take flow state into consideration in `is_assignable()` for local variables.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum LocalMutationIsAllowed {\n     Yes,\n@@ -895,7 +895,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// place is initialized and (b) it is not borrowed in some way that would prevent this\n     /// access.\n     ///\n-    /// Returns true if an error is reported, false otherwise.\n+    /// Returns `true` if an error is reported.\n     fn access_place(\n         &mut self,\n         context: Context,\n@@ -1785,9 +1785,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Check the permissions for the given place and read or write kind\n+    /// Checks the permissions for the given place and read or write kind\n     ///\n-    /// Returns true if an error is reported, false otherwise.\n+    /// Returns `true` if an error is reported.\n     fn check_access_permissions(\n         &mut self,\n         (place, span): (&Place<'tcx>, Span),"}, {"sha": "008c081aeb601f7f26062b85e4a21987edb4caf2", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -615,7 +615,7 @@ fn is_closure_or_generator(ty: ty::Ty<'_>) -> bool {\n     ty.is_closure() || ty.is_generator()\n }\n \n-/// Add a suggestion to a struct definition given a field access to a local.\n+/// Adds a suggestion to a struct definition given a field access to a local.\n /// This function expects the local to be a reference to a struct in order to produce a suggestion.\n ///\n /// ```text"}, {"sha": "c4b2a5daef89ab50c8ed4a1e7fd78fedeeac8e78", "filename": "src/librustc_mir/borrow_check/nll/constraints/graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -71,7 +71,7 @@ impl ConstraintGraphDirecton for Reverse {\n }\n \n impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n-    /// Create a \"dependency graph\" where each region constraint `R1:\n+    /// Creates a \"dependency graph\" where each region constraint `R1:\n     /// R2` is treated as an edge `R1 -> R2`. We use this graph to\n     /// construct SCCs for region inference but also for error\n     /// reporting.\n@@ -186,7 +186,7 @@ crate struct RegionGraph<'s, D: ConstraintGraphDirecton> {\n }\n \n impl<'s, D: ConstraintGraphDirecton> RegionGraph<'s, D> {\n-    /// Create a \"dependency graph\" where each region constraint `R1:\n+    /// Creates a \"dependency graph\" where each region constraint `R1:\n     /// R2` is treated as an edge `R1 -> R2`. We use this graph to\n     /// construct SCCs for region inference but also for error\n     /// reporting."}, {"sha": "b1091eb5ac81f8578225f187cdc73ce9b6ac0f02", "filename": "src/librustc_mir/borrow_check/nll/constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -31,7 +31,7 @@ impl ConstraintSet {\n     /// easy to find the constraints affecting a particular region.\n     ///\n     /// N.B., this graph contains a \"frozen\" view of the current\n-    /// constraints.  any new constraints added to the `ConstraintSet`\n+    /// constraints. Any new constraints added to the `ConstraintSet`\n     /// after the graph is built will not be present in the graph.\n     crate fn graph(&self, num_region_vars: usize) -> graph::NormalConstraintGraph {\n         graph::ConstraintGraph::new(graph::Normal, self, num_region_vars)\n@@ -43,7 +43,7 @@ impl ConstraintSet {\n         graph::ConstraintGraph::new(graph::Reverse, self, num_region_vars)\n     }\n \n-    /// Compute cycles (SCCs) in the graph of regions. In particular,\n+    /// Computes cycles (SCCs) in the graph of regions. In particular,\n     /// find all regions R1, R2 such that R1: R2 and R2: R1 and group\n     /// them into an SCC, and find the relationships between SCCs.\n     crate fn compute_sccs("}, {"sha": "a6a6962bb151709fbd418c175a766a112e592ca1", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -285,7 +285,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Check if a borrow location is within a loop.\n+    /// Checks if a borrow location is within a loop.\n     fn is_borrow_location_in_loop(\n         &self,\n         borrow_location: Location,\n@@ -407,7 +407,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Check if a borrowed value was captured by a trait object. We do this by\n+    /// Checks if a borrowed value was captured by a trait object. We do this by\n     /// looking forward in the MIR from the reserve location and checking if we see\n     /// a unsized cast to a trait object on our data.\n     fn was_captured_by_trait_object(&self, borrow: &BorrowData<'tcx>) -> bool {"}, {"sha": "9714398d9d63a374524ce7d538588b84b75ac3b7", "filename": "src/librustc_mir/borrow_check/nll/facts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -13,7 +13,7 @@ use std::path::Path;\n crate type AllFacts = PoloniusAllFacts<RegionVid, BorrowIndex, LocationIndex>;\n \n crate trait AllFactsExt {\n-    /// Returns true if there is a need to gather `AllFacts` given the\n+    /// Returns `true` if there is a need to gather `AllFacts` given the\n     /// current `-Z` flags.\n     fn enabled(tcx: TyCtxt<'_, '_, '_>) -> bool;\n "}, {"sha": "3255899c86cb3fc8f4dfa1fee8218825ae5c0079", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -53,8 +53,8 @@ struct InvalidationGenerator<'cx, 'tcx: 'cx, 'gcx: 'tcx> {\n     borrow_set: &'cx BorrowSet<'tcx>,\n }\n \n-/// Visits the whole MIR and generates invalidates() facts\n-/// Most of the code implementing this was stolen from borrow_check/mod.rs\n+/// Visits the whole MIR and generates `invalidates()` facts.\n+/// Most of the code implementing this was stolen from `borrow_check/mod.rs`.\n impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n     fn visit_statement(\n         &mut self,\n@@ -272,7 +272,7 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n }\n \n impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n-    /// Simulates mutation of a place\n+    /// Simulates mutation of a place.\n     fn mutate_place(\n         &mut self,\n         context: Context,\n@@ -288,7 +288,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n         );\n     }\n \n-    /// Simulates consumption of an operand\n+    /// Simulates consumption of an operand.\n     fn consume_operand(\n         &mut self,\n         context: Context,\n@@ -384,7 +384,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n         }\n     }\n \n-    /// Simulates an access to a place\n+    /// Simulates an access to a place.\n     fn access_place(\n         &mut self,\n         context: Context,\n@@ -472,7 +472,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n     }\n \n \n-    /// Generate a new invalidates(L, B) fact\n+    /// Generates a new `invalidates(L, B)` fact.\n     fn generate_invalidates(&mut self, b: BorrowIndex, l: Location) {\n         let lidx = self.location_table.start_index(l);\n         self.all_facts.invalidates.push((lidx, b));"}, {"sha": "419ee73b28ad3e7b9a0e2966756ca7effed41b72", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -57,7 +57,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Debugging aid: Invokes the `with_msg` callback repeatedly with\n-    /// our internal region constraints.  These are dumped into the\n+    /// our internal region constraints. These are dumped into the\n     /// -Zdump-mir file so that we can figure out why the region\n     /// inference resulted in the values that it did when debugging.\n     fn for_each_constraint("}, {"sha": "f741af0b228b5428d1be9c75c1640d85e07b21b8", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -738,8 +738,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// If `r2` represents a placeholder region, then this returns\n-    /// true if `r1` cannot name that placeholder in its\n-    /// value. Otherwise, returns false.\n+    /// `true` if `r1` cannot name that placeholder in its\n+    /// value; otherwise, returns `false`.\n     fn cannot_name_placeholder(&self, r1: RegionVid, r2: RegionVid) -> bool {\n         debug!(\"cannot_name_value_of(r1={:?}, r2={:?})\", r1, r2);\n "}, {"sha": "089640ab7024b19ab8c866f2f72d4d8c80888f76", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -173,7 +173,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         value\n     }\n \n-    /// Check for the case where `fr` maps to something that the\n+    /// Checks for the case where `fr` maps to something that the\n     /// *user* has a name for. In that case, we'll be able to map\n     /// `fr` to a `Region<'tcx>`, and that region will be one of\n     /// named variants.\n@@ -272,7 +272,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    /// Get a span of a named region to provide context for error messages that\n+    /// Gets a span of a named region to provide context for error messages that\n     /// mention that span, for example:\n     ///\n     /// ```\n@@ -306,7 +306,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    /// Find an argument that contains `fr` and label it with a fully\n+    /// Finds an argument that contains `fr` and label it with a fully\n     /// elaborated type, returning something like `'1`. Result looks\n     /// like:\n     ///\n@@ -428,7 +428,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// to. For example, we might produce an annotation like this:\n     ///\n     /// ```\n-    ///  | fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T>> {\n+    ///  | fn a<T>(items: &[T]) -> Box<dyn Iterator<Item = &T>> {\n     ///  |                - let's call the lifetime of this reference `'1`\n     /// ```\n     ///\n@@ -437,7 +437,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// `argument_hir_ty`, a `hir::Ty` (the syntax of the type\n     /// annotation). We are descending through the types stepwise,\n     /// looking in to find the region `needle_fr` in the internal\n-    /// type.  Once we find that, we can use the span of the `hir::Ty`\n+    /// type. Once we find that, we can use the span of the `hir::Ty`\n     /// to add the highlight.\n     ///\n     /// This is a somewhat imperfect process, so long the way we also\n@@ -621,7 +621,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         None\n     }\n \n-    /// Find a closure upvar that contains `fr` and label it with a\n+    /// Finds a closure upvar that contains `fr` and label it with a\n     /// fully elaborated type, returning something like `'1`. Result\n     /// looks like:\n     ///\n@@ -647,7 +647,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         })\n     }\n \n-    /// Check for arguments appearing in the (closure) return type. It\n+    /// Checks for arguments appearing in the (closure) return type. It\n     /// must be a closure since, in a free fn, such an argument would\n     /// have to either also appear in an argument (if using elision)\n     /// or be early bound (named, not in argument).\n@@ -714,7 +714,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         })\n     }\n \n-    /// Create a synthetic region named `'1`, incrementing the\n+    /// Creates a synthetic region named `'1`, incrementing the\n     /// counter.\n     fn synthesize_region_name(&self, counter: &mut usize) -> InternedString {\n         let c = *counter;"}, {"sha": "6de05777fe8881b0206de160f550fed1356b99a1", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -35,7 +35,7 @@ use self::values::{LivenessValues, RegionValueElements, RegionValues};\n use super::ToRegionVid;\n \n pub struct RegionInferenceContext<'tcx> {\n-    /// Contains the definition for every region variable.  Region\n+    /// Contains the definition for every region variable. Region\n     /// variables are identified by their index (`RegionVid`). The\n     /// definition contains information about where the region came\n     /// from as well as its final inferred value.\n@@ -124,7 +124,7 @@ pub(crate) enum Cause {\n }\n \n /// A \"type test\" corresponds to an outlives constraint between a type\n-/// and a lifetime, like `T: 'x` or `<T as Foo>::Bar: 'x`.  They are\n+/// and a lifetime, like `T: 'x` or `<T as Foo>::Bar: 'x`. They are\n /// translated from the `Verify` region constraints in the ordinary\n /// inference context.\n ///\n@@ -137,10 +137,10 @@ pub(crate) enum Cause {\n ///\n /// In some cases, however, there are outlives relationships that are\n /// not converted into a region constraint, but rather into one of\n-/// these \"type tests\".  The distinction is that a type test does not\n+/// these \"type tests\". The distinction is that a type test does not\n /// influence the inference result, but instead just examines the\n /// values that we ultimately inferred for each region variable and\n-/// checks that they meet certain extra criteria.  If not, an error\n+/// checks that they meet certain extra criteria. If not, an error\n /// can be issued.\n ///\n /// One reason for this is that these type tests typically boil down\n@@ -286,7 +286,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Initializes the region variables for each universally\n     /// quantified region (lifetime parameter). The first N variables\n     /// always correspond to the regions appearing in the function\n-    /// signature (both named and anonymous) and where clauses. This\n+    /// signature (both named and anonymous) and where-clauses. This\n     /// function iterates over those regions and initializes them with\n     /// minimum values.\n     ///\n@@ -368,12 +368,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.universal_regions.to_region_vid(r)\n     }\n \n-    /// Add annotations for `#[rustc_regions]`; see `UniversalRegions::annotate`.\n+    /// Adds annotations for `#[rustc_regions]`; see `UniversalRegions::annotate`.\n     crate fn annotate(&self, tcx: TyCtxt<'_, '_, 'tcx>, err: &mut DiagnosticBuilder<'_>) {\n         self.universal_regions.annotate(tcx, err)\n     }\n \n-    /// Returns true if the region `r` contains the point `p`.\n+    /// Returns `true` if the region `r` contains the point `p`.\n     ///\n     /// Panics if called before `solve()` executes,\n     crate fn region_contains(&self, r: impl ToRegionVid, p: impl ToElementIndex) -> bool {\n@@ -393,7 +393,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.scc_universes[scc]\n     }\n \n-    /// Perform region inference and report errors if we see any\n+    /// Performs region inference and report errors if we see any\n     /// unsatisfiable constraints. If this is a closure, returns the\n     /// region requirements to propagate to our creator, if any.\n     pub(super) fn solve<'gcx>(\n@@ -533,7 +533,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n     }\n \n-    /// True if all the elements in the value of `scc_b` are nameable\n+    /// Returns `true` if all the elements in the value of `scc_b` are nameable\n     /// in `scc_a`. Used during constraint propagation, and only once\n     /// the value of `scc_b` has been computed.\n     fn universe_compatible(&self, scc_b: ConstraintSccIndex, scc_a: ConstraintSccIndex) -> bool {\n@@ -928,8 +928,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         lub\n     }\n \n-    /// Test if `test` is true when applied to `lower_bound` at\n-    /// `point`, and returns true or false.\n+    /// Tests if `test` is true when applied to `lower_bound` at\n+    /// `point`.\n     fn eval_verify_bound(\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n@@ -990,15 +990,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// different results. (For example, there might be two regions\n     /// with the same value that are not in the same SCC).\n     ///\n-    /// NB. This is not an ideal approach and I would like to revisit\n+    /// N.B., this is not an ideal approach and I would like to revisit\n     /// it. However, it works pretty well in practice. In particular,\n     /// this is needed to deal with projection outlives bounds like\n     ///\n     ///     <T as Foo<'0>>::Item: '1\n     ///\n     /// In particular, this routine winds up being important when\n     /// there are bounds like `where <T as Foo<'a>>::Item: 'b` in the\n-    /// environment.  In this case, if we can show that `'0 == 'a`,\n+    /// environment. In this case, if we can show that `'0 == 'a`,\n     /// and that `'b: '1`, then we know that the clause is\n     /// satisfied. In such cases, particularly due to limitations of\n     /// the trait solver =), we usually wind up with a where-clause like\n@@ -1077,7 +1077,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Once regions have been propagated, this method is used to see\n     /// whether any of the constraints were too strong. In particular,\n     /// we want to check for a case where a universally quantified\n-    /// region exceeded its bounds.  Consider:\n+    /// region exceeded its bounds. Consider:\n     ///\n     ///     fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n     ///\n@@ -1126,7 +1126,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    /// Check the final value for the free region `fr` to see if it\n+    /// Checks the final value for the free region `fr` to see if it\n     /// grew too large. In particular, examine what `end(X)` points\n     /// wound up in `fr`'s final value; for each `end(X)` where `X !=\n     /// fr`, we want to check that `fr: X`. If not, that's either an"}, {"sha": "ef27fdbde387fa0c17ad82d84041ceeebba88aa7", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -166,7 +166,7 @@ impl<N: Idx> LivenessValues<N> {\n         self.points.rows()\n     }\n \n-    /// Adds the given element to the value for the given region. Returns true if\n+    /// Adds the given element to the value for the given region. Returns whether\n     /// the element is newly added (i.e., was not already present).\n     crate fn add_element(&mut self, row: N, location: Location) -> bool {\n         debug!(\"LivenessValues::add(r={:?}, location={:?})\", row, location);\n@@ -175,7 +175,7 @@ impl<N: Idx> LivenessValues<N> {\n     }\n \n     /// Adds all the elements in the given bit array into the given\n-    /// region. Returns true if any of them are newly added.\n+    /// region. Returns whether any of them are newly added.\n     crate fn add_elements(&mut self, row: N, locations: &HybridBitSet<PointIndex>) -> bool {\n         debug!(\n             \"LivenessValues::add_elements(row={:?}, locations={:?})\",\n@@ -189,7 +189,7 @@ impl<N: Idx> LivenessValues<N> {\n         self.points.insert_all_into_row(row);\n     }\n \n-    /// True if the region `r` contains the given element.\n+    /// Returns `true` if the region `r` contains the given element.\n     crate fn contains(&self, row: N, location: Location) -> bool {\n         let index = self.elements.point_from_location(location);\n         self.points.contains(row, index)\n@@ -291,7 +291,7 @@ impl<N: Idx> RegionValues<N> {\n         }\n     }\n \n-    /// Adds the given element to the value for the given region. Returns true if\n+    /// Adds the given element to the value for the given region. Returns whether\n     /// the element is newly added (i.e., was not already present).\n     crate fn add_element(&mut self, r: N, elem: impl ToElementIndex) -> bool {\n         debug!(\"add(r={:?}, elem={:?})\", r, elem);\n@@ -303,15 +303,15 @@ impl<N: Idx> RegionValues<N> {\n         self.points.insert_all_into_row(r);\n     }\n \n-    /// Add all elements in `r_from` to `r_to` (because e.g., `r_to:\n+    /// Adds all elements in `r_from` to `r_to` (because e.g., `r_to:\n     /// r_from`).\n     crate fn add_region(&mut self, r_to: N, r_from: N) -> bool {\n         self.points.union_rows(r_from, r_to)\n             | self.free_regions.union_rows(r_from, r_to)\n             | self.placeholders.union_rows(r_from, r_to)\n     }\n \n-    /// True if the region `r` contains the given element.\n+    /// Returns `true` if the region `r` contains the given element.\n     crate fn contains(&self, r: N, elem: impl ToElementIndex) -> bool {\n         elem.contained_in_row(self, r)\n     }\n@@ -325,7 +325,7 @@ impl<N: Idx> RegionValues<N> {\n         }\n     }\n \n-    /// True if `sup_region` contains all the CFG points that\n+    /// Returns `true` if `sup_region` contains all the CFG points that\n     /// `sub_region` contains. Ignores universal regions.\n     crate fn contains_points(&self, sup_region: N, sub_region: N) -> bool {\n         if let Some(sub_row) = self.points.row(sub_region) {"}, {"sha": "7ddfd55dbbb94a9acfadc91c216f0916746d7e44", "filename": "src/librustc_mir/borrow_check/nll/type_check/free_region_relations.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -19,7 +19,7 @@ crate struct UniversalRegionRelations<'tcx> {\n     universal_regions: Rc<UniversalRegions<'tcx>>,\n \n     /// Stores the outlives relations that are known to hold from the\n-    /// implied bounds, in-scope where clauses, and that sort of\n+    /// implied bounds, in-scope where-clauses, and that sort of\n     /// thing.\n     outlives: TransitiveRelation<RegionVid>,\n \n@@ -35,7 +35,7 @@ crate struct UniversalRegionRelations<'tcx> {\n /// added via implicit bounds.\n ///\n /// Each region here is guaranteed to be a key in the `indices`\n-/// map.  We use the \"original\" regions (i.e., the keys from the\n+/// map. We use the \"original\" regions (i.e., the keys from the\n /// map, and not the values) because the code in\n /// `process_registered_region_obligations` has some special-cased\n /// logic expecting to see (e.g.) `ReStatic`, and if we supplied\n@@ -44,7 +44,7 @@ type RegionBoundPairs<'tcx> = Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>;\n \n /// As part of computing the free region relations, we also have to\n /// normalize the input-output types, which we then need later. So we\n-/// return those.  This vector consists of first the input types and\n+/// return those. This vector consists of first the input types and\n /// then the output type as the last element.\n type NormalizedInputsAndOutput<'tcx> = Vec<Ty<'tcx>>;\n \n@@ -129,8 +129,8 @@ impl UniversalRegionRelations<'tcx> {\n     }\n \n     /// Helper for `non_local_upper_bound` and\n-    /// `non_local_lower_bound`.  Repeatedly invokes `postdom_parent`\n-    /// until we find something that is not local. Returns None if we\n+    /// `non_local_lower_bound`. Repeatedly invokes `postdom_parent`\n+    /// until we find something that is not local. Returns `None` if we\n     /// never do so.\n     fn non_local_bound(\n         &self,\n@@ -177,7 +177,7 @@ impl UniversalRegionRelations<'tcx> {\n         })\n     }\n \n-    /// True if fr1 is known to outlive fr2.\n+    /// Returns `true` if fr1 is known to outlive fr2.\n     ///\n     /// This will only ever be true for universally quantified regions.\n     crate fn outlives(&self, fr1: RegionVid, fr2: RegionVid) -> bool {"}, {"sha": "b9f9d83161b79649a7cb9b9a885b104c69113006", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/liveness_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fliveness_map.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -79,7 +79,7 @@ impl NllLivenessMap {\n         }\n     }\n \n-    /// True if there are no local variables that need liveness computation.\n+    /// Returns `true` if there are no local variables that need liveness computation.\n     crate fn is_empty(&self) -> bool {\n         self.to_local.is_empty()\n     }"}, {"sha": "28a8cad8ca20059ff577517c3d296646bd4eddf6", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -23,7 +23,7 @@ mod trace;\n /// that indicate which types must be live at which point in the CFG.\n /// This vector is consumed by `constraint_generation`.\n ///\n-/// NB. This computation requires normalization; therefore, it must be\n+/// N.B., this computation requires normalization; therefore, it must be\n /// performed before\n pub(super) fn generate<'gcx, 'tcx>(\n     typeck: &mut TypeChecker<'_, 'gcx, 'tcx>,\n@@ -46,7 +46,7 @@ pub(super) fn generate<'gcx, 'tcx>(\n     trace::trace(typeck, mir, elements, flow_inits, move_data, &liveness_map, location_table);\n }\n \n-/// Compute all regions that are (currently) known to outlive free\n+/// Computes all regions that are (currently) known to outlive free\n /// regions. For these regions, we do not need to compute\n /// liveness, since the outlives constraints will ensure that they\n /// are live over the whole fn body anyhow."}, {"sha": "4a0b4b7c205c65a93db5a10126f30cb6e68feec7", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -192,7 +192,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Compute all points where local is \"use live\" -- meaning its\n+    /// Computes all points where local is \"use live\" -- meaning its\n     /// current value may be used later (except by a drop). This is\n     /// done by walking backwards from each use of `live_local` until we\n     /// find a `def` of local.\n@@ -215,7 +215,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Compute all points where local is \"drop live\" -- meaning its\n+    /// Computes all points where local is \"drop live\" -- meaning its\n     /// current value may be dropped later (but not used). This is\n     /// done by iterating over the drops of `local` where `local` (or\n     /// some subpart of `local`) is initialized. For each such drop,\n@@ -407,7 +407,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx> {\n }\n \n impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n-    /// True if the local variable (or some part of it) is initialized in\n+    /// Returns `true` if the local variable (or some part of it) is initialized in\n     /// the terminator of `block`. We need to check this to determine if a\n     /// DROP of some local variable will have an effect -- note that\n     /// drops, as they may unwind, are always terminators.\n@@ -429,7 +429,7 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n         self.flow_inits.has_any_child_of(mpi).is_some()\n     }\n \n-    /// True if the path `mpi` (or some part of it) is initialized at\n+    /// Returns `true` if the path `mpi` (or some part of it) is initialized at\n     /// the exit of `block`.\n     ///\n     /// **Warning:** Does not account for the result of `Call`\n@@ -439,7 +439,7 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n         self.flow_inits.has_any_child_of(mpi).is_some()\n     }\n \n-    /// Store the result that all regions in `value` are live for the\n+    /// Stores the result that all regions in `value` are live for the\n     /// points `live_at`.\n     fn add_use_live_facts_for(\n         &mut self,"}, {"sha": "49f90eb90aaf043896d7e07698ac1f7e5e8c45dc", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -839,7 +839,7 @@ pub enum Locations {\n     /// older NLL analysis, we required this only at the entry point\n     /// to the function. By the nature of the constraints, this wound\n     /// up propagating to all points reachable from start (because\n-    /// `'1` -- as a universal region -- is live everywhere).  In the\n+    /// `'1` -- as a universal region -- is live everywhere). In the\n     /// newer analysis, though, this doesn't work: `_0` is considered\n     /// dead at the start (it has no usable value) and hence this type\n     /// equality is basically a no-op. Then, later on, when we do `_0\n@@ -2079,7 +2079,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Add the constraints that arise from a borrow expression `&'a P` at the location `L`.\n+    /// Adds the constraints that arise from a borrow expression `&'a P` at the location `L`.\n     ///\n     /// # Parameters\n     ///"}, {"sha": "28835b959d76f831cb278e5502a73e059f74f3da", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -14,7 +14,7 @@ use rustc::ty::{self, Ty};\n /// - \"Invariant\" `a == b`\n /// - \"Contravariant\" `a :> b`\n ///\n-/// NB. The type `a` is permitted to have unresolved inference\n+/// N.B., the type `a` is permitted to have unresolved inference\n /// variables, but not the type `b`.\n pub(super) fn relate_types<'tcx>(\n     infcx: &InferCtxt<'_, '_, 'tcx>,"}, {"sha": "b1d7147ca66f42b0deceedeaef8061894e757ba5", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -35,15 +35,15 @@ pub struct UniversalRegions<'tcx> {\n     pub fr_static: RegionVid,\n \n     /// A special region vid created to represent the current MIR fn\n-    /// body.  It will outlive the entire CFG but it will not outlive\n+    /// body. It will outlive the entire CFG but it will not outlive\n     /// any other universal regions.\n     pub fr_fn_body: RegionVid,\n \n     /// We create region variables such that they are ordered by their\n     /// `RegionClassification`. The first block are globals, then\n-    /// externals, then locals. So things from:\n-    /// - `FIRST_GLOBAL_INDEX..first_extern_index` are global;\n-    /// - `first_extern_index..first_local_index` are external; and\n+    /// externals, then locals. So, things from:\n+    /// - `FIRST_GLOBAL_INDEX..first_extern_index` are global,\n+    /// - `first_extern_index..first_local_index` are external,\n     /// - `first_local_index..num_universals` are local.\n     first_extern_index: usize,\n \n@@ -54,21 +54,21 @@ pub struct UniversalRegions<'tcx> {\n     num_universals: usize,\n \n     /// The \"defining\" type for this function, with all universal\n-    /// regions instantiated.  For a closure or generator, this is the\n+    /// regions instantiated. For a closure or generator, this is the\n     /// closure type, but for a top-level function it's the `FnDef`.\n     pub defining_ty: DefiningTy<'tcx>,\n \n     /// The return type of this function, with all regions replaced by\n     /// their universal `RegionVid` equivalents.\n     ///\n-    /// NB. Associated types in this type have not been normalized,\n+    /// N.B., associated types in this type have not been normalized,\n     /// as the name suggests. =)\n     pub unnormalized_output_ty: Ty<'tcx>,\n \n     /// The fully liberated input types of this function, with all\n     /// regions replaced by their universal `RegionVid` equivalents.\n     ///\n-    /// NB. Associated types in these types have not been normalized,\n+    /// N.B., associated types in these types have not been normalized,\n     /// as the name suggests. =)\n     pub unnormalized_input_tys: &'tcx [Ty<'tcx>],\n \n@@ -92,7 +92,7 @@ pub enum DefiningTy<'tcx> {\n     /// `ClosureSubsts::generator_return_ty`.\n     Generator(DefId, ty::GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n \n-    /// The MIR is a fn item with the given def-id and substs. The signature\n+    /// The MIR is a fn item with the given `DefId` and substs. The signature\n     /// of the function can be bound then with the `fn_sig` query.\n     FnDef(DefId, &'tcx Substs<'tcx>),\n \n@@ -174,13 +174,13 @@ pub enum RegionClassification {\n \n     /// A **local** lifetime is one about which we know the full set\n     /// of relevant constraints (that is, relationships to other named\n-    /// regions).  For a closure, this includes any region bound in\n-    /// the closure's signature.  For a fn item, this includes all\n+    /// regions). For a closure, this includes any region bound in\n+    /// the closure's signature. For a fn item, this includes all\n     /// regions other than global ones.\n     ///\n     /// Continuing with the example from `External`, if we were\n     /// analyzing the closure, then `'x` would be local (and `'a` and\n-    /// `'b` are external).  If we are analyzing the function item\n+    /// `'b` are external). If we are analyzing the function item\n     /// `foo`, then `'a` and `'b` are local (and `'x` is not in\n     /// scope).\n     Local,\n@@ -245,7 +245,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n         region_mapping\n     }\n \n-    /// True if `r` is a member of this set of universal regions.\n+    /// Returns `true` if `r` is a member of this set of universal regions.\n     pub fn is_universal_region(&self, r: RegionVid) -> bool {\n         (FIRST_GLOBAL_INDEX..self.num_universals).contains(&r.index())\n     }\n@@ -271,7 +271,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n         (FIRST_GLOBAL_INDEX..self.num_universals).map(RegionVid::new)\n     }\n \n-    /// True if `r` is classified as an local region.\n+    /// Returns `true` if `r` is classified as an local region.\n     pub fn is_local_free_region(&self, r: RegionVid) -> bool {\n         self.region_classification(r) == Some(RegionClassification::Local)\n     }\n@@ -290,7 +290,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n         self.first_local_index\n     }\n \n-    /// Get an iterator over all the early-bound regions that have names.\n+    /// Gets an iterator over all the early-bound regions that have names.\n     pub fn named_universal_regions<'s>(\n         &'s self,\n     ) -> impl Iterator<Item = (ty::Region<'tcx>, ty::RegionVid)> + 's {\n@@ -692,7 +692,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'gcx, 'tcx> {\n     /// indices vector. Typically, we identify late-bound regions as we process the inputs and\n     /// outputs of the closure/function. However, sometimes there are late-bound regions which do\n     /// not appear in the fn parameters but which are nonetheless in scope. The simplest case of\n-    /// this are unused functions, like fn foo<'a>() { } (see eg., #51351). Despite not being used,\n+    /// this are unused functions, like fn foo<'a>() { } (see e.g., #51351). Despite not being used,\n     /// users can still reference these regions (e.g., let x: &'a u32 = &22;), so we need to create\n     /// entries for them and store them in the indices map. This code iterates over the complete\n     /// set of late-bound regions and checks for any that we have not yet seen, adding them to the\n@@ -746,7 +746,7 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n         }\n     }\n \n-    /// Replace all free regions in `value` with region vids, as\n+    /// Replaces all free regions in `value` with region vids, as\n     /// returned by `to_region_vid`.\n     pub fn fold_to_region_vids<T>(&self, tcx: TyCtxt<'_, '_, 'tcx>, value: &T) -> T\n     where"}, {"sha": "9073ae6bed5b2963240cadb4abc4b9bb7a35c935", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -8,7 +8,7 @@ use rustc::mir::{ProjectionElem, BorrowKind};\n use rustc::ty::TyCtxt;\n use rustc_data_structures::graph::dominators::Dominators;\n \n-/// Returns true if the borrow represented by `kind` is\n+/// Returns `true` if the borrow represented by `kind` is\n /// allowed to be split into separate Reservation and\n /// Activation phases.\n pub(super) fn allow_two_phase_borrow<'a, 'tcx, 'gcx: 'tcx>("}, {"sha": "d6d2861b557ab1d2956b1526b0ada6358d786ac3", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -6,7 +6,7 @@ use crate::borrow_check::borrow_set::LocalsStateAtExit;\n \n /// Extension methods for the `Place` type.\n crate trait PlaceExt<'tcx> {\n-    /// Returns true if we can safely ignore borrows of this place.\n+    /// Returns `true` if we can safely ignore borrows of this place.\n     /// This is true whenever there is no action that the user can do\n     /// to the place `self` that would invalidate the borrow. This is true\n     /// for borrows of raw pointer dereferents as well as shared references."}, {"sha": "b5175cf41dd5c6293d7ba989d40636ab58646ea9", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -275,10 +275,10 @@ fn place_components_conflict<'gcx, 'tcx>(\n \n /// A linked list of places running up the stack; begins with the\n /// innermost place and extends to projections (e.g., `a.b` would have\n-/// the place `a` with a \"next\" pointer to `a.b`).  Created by\n+/// the place `a` with a \"next\" pointer to `a.b`). Created by\n /// `unroll_place`.\n ///\n-/// N.B., this particular impl strategy is not the most obvious.  It was\n+/// N.B., this particular impl strategy is not the most obvious. It was\n /// chosen because it makes a measurable difference to NLL\n /// performance, as this code (`borrow_conflicts_with_place`) is somewhat hot.\n struct PlaceComponents<'p, 'tcx: 'p> {"}, {"sha": "cb71ff27ceb53f86dcfe3d88daa58a3a725340a7", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -727,7 +727,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     ///\n     /// The return value is a list of \"otherwise\" blocks. These are\n     /// points in execution where we found that *NONE* of the\n-    /// candidates apply.  In principle, this means that the input\n+    /// candidates apply. In principle, this means that the input\n     /// list was not exhaustive, though at present we sometimes are\n     /// not smart enough to recognize all exhaustive inputs.\n     ///\n@@ -874,7 +874,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// This is the most subtle part of the matching algorithm.  At\n+    /// This is the most subtle part of the matching algorithm. At\n     /// this point, the input candidates have been fully simplified,\n     /// and so we know that all remaining match-pairs require some\n     /// sort of test. To decide what test to do, we take the highest\n@@ -894,10 +894,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// 4. etc.\n     ///\n     /// Once we know what sort of test we are going to perform, this\n-    /// test may also help us with other candidates. So we walk over\n+    /// Tests may also help us with other candidates. So we walk over\n     /// the candidates (from high to low priority) and check. This\n     /// gives us, for each outcome of the test, a transformed list of\n-    /// candidates.  For example, if we are testing the current\n+    /// candidates. For example, if we are testing the current\n     /// variant of `x.0`, and we have a candidate `{x.0 @ Some(v), x.1\n     /// @ 22}`, then we would have a resulting candidate of `{(x.0 as\n     /// Some).0 @ v, x.1 @ 22}`. Note that the first match-pair is now\n@@ -1093,7 +1093,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// for the case where the guard fails.\n     ///\n     /// Note: we check earlier that if there is a guard, there cannot\n-    /// be move bindings.  This isn't really important for the\n+    /// be move bindings. This isn't really important for the\n     /// self-consistency of this fn, but the reason for it should be\n     /// clear: after we've done the assignments, if there were move\n     /// bindings, further tests would be a use-after-move (which would"}, {"sha": "75189777aa31113f9c2322ea55e4c0051e277f78", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -443,7 +443,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// appropriate.\n     ///\n     /// So, for example, if this candidate is `x @ Some(P0)` and the\n-    /// test is a variant test, then we would add `(x as Option).0 @\n+    /// Tests is a variant test, then we would add `(x as Option).0 @\n     /// P0` to the `resulting_candidates` entry corresponding to the\n     /// variant `Some`.\n     ///"}, {"sha": "900f7f1744a134839e45d91653d56e1576b99112", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -9,7 +9,7 @@ use rustc::mir::*;\n use syntax_pos::{Span, DUMMY_SP};\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n-    /// Add a new temporary value of type `ty` storing the result of\n+    /// Adds a new temporary value of type `ty` storing the result of\n     /// evaluating `expr`.\n     ///\n     /// N.B., **No cleanup is scheduled for this temporary.** You should"}, {"sha": "11ed8167dbdc62d390ef6dd403568e37b33ecbff", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -26,7 +26,7 @@ use syntax_pos::Span;\n \n use super::lints;\n \n-/// Construct the MIR for a given def-id.\n+/// Construct the MIR for a given `DefId`.\n pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'tcx> {\n     let id = tcx.hir().as_local_node_id(def_id).unwrap();\n \n@@ -173,9 +173,9 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n     })\n }\n \n-/// A pass to lift all the types and substitutions in a Mir\n+/// A pass to lift all the types and substitutions in a MIR\n /// to the global tcx. Sadly, we don't have a \"folder\" that\n-/// can change 'tcx so we have to transmute afterwards.\n+/// can change `'tcx` so we have to transmute afterwards.\n struct GlobalizeMir<'a, 'gcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     span: Span\n@@ -335,60 +335,60 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fn_span: Span,\n     arg_count: usize,\n \n-    /// the current set of scopes, updated as we traverse;\n-    /// see the `scope` module for more details\n+    /// The current set of scopes, updated as we traverse;\n+    /// see the `scope` module for more details.\n     scopes: Vec<scope::Scope<'tcx>>,\n \n-    /// the block-context: each time we build the code within an hair::Block,\n+    /// The block-context: each time we build the code within an hair::Block,\n     /// we push a frame here tracking whether we are building a statement or\n     /// if we are pushing the tail expression of the block. This is used to\n     /// embed information in generated temps about whether they were created\n     /// for a block tail expression or not.\n     ///\n     /// It would be great if we could fold this into `self.scopes`\n-    /// somehow; but right now I think that is very tightly tied to\n+    /// somehow, but right now I think that is very tightly tied to\n     /// the code generation in ways that we cannot (or should not)\n     /// start just throwing new entries onto that vector in order to\n     /// distinguish the context of EXPR1 from the context of EXPR2 in\n-    /// `{ STMTS; EXPR1 } + EXPR2`\n+    /// `{ STMTS; EXPR1 } + EXPR2`.\n     block_context: BlockContext,\n \n     /// The current unsafe block in scope, even if it is hidden by\n-    /// a PushUnsafeBlock\n+    /// a `PushUnsafeBlock`.\n     unpushed_unsafe: Safety,\n \n-    /// The number of `push_unsafe_block` levels in scope\n+    /// The number of `push_unsafe_block` levels in scope.\n     push_unsafe_count: usize,\n \n-    /// the current set of breakables; see the `scope` module for more\n-    /// details\n+    /// The current set of breakables; see the `scope` module for more\n+    /// details.\n     breakable_scopes: Vec<scope::BreakableScope<'tcx>>,\n \n-    /// the vector of all scopes that we have created thus far;\n-    /// we track this for debuginfo later\n+    /// The vector of all scopes that we have created thus far;\n+    /// we track this for debuginfo later.\n     source_scopes: IndexVec<SourceScope, SourceScopeData>,\n     source_scope_local_data: IndexVec<SourceScope, SourceScopeLocalData>,\n     source_scope: SourceScope,\n \n-    /// the guard-context: each time we build the guard expression for\n+    /// The guard-context: each time we build the guard expression for\n     /// a match arm, we push onto this stack, and then pop when we\n     /// finish building it.\n     guard_context: Vec<GuardFrame>,\n \n-    /// Maps node ids of variable bindings to the `Local`s created for them.\n+    /// Maps `NodeId`s of variable bindings to the `Local`s created for them.\n     /// (A match binding can have two locals; the 2nd is for the arm's guard.)\n     var_indices: NodeMap<LocalsForNode>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     canonical_user_type_annotations: ty::CanonicalUserTypeAnnotations<'tcx>,\n     upvar_decls: Vec<UpvarDecl>,\n     unit_temp: Option<Place<'tcx>>,\n \n-    /// cached block with the RESUME terminator; this is created\n+    /// Cached block with the `RESUME` terminator; this is created\n     /// when first set of cleanups are built.\n     cached_resume_block: Option<BasicBlock>,\n-    /// cached block with the RETURN terminator\n+    /// Cached block with the `RETURN` terminator.\n     cached_return_block: Option<BasicBlock>,\n-    /// cached block with the UNREACHABLE terminator\n+    /// Cached block with the `UNREACHABLE` terminator.\n     cached_unreachable_block: Option<BasicBlock>,\n }\n \n@@ -407,7 +407,7 @@ impl BlockContext {\n     fn push(&mut self, bf: BlockFrame) { self.0.push(bf); }\n     fn pop(&mut self) -> Option<BlockFrame> { self.0.pop() }\n \n-    /// Traverses the frames on the BlockContext, searching for either\n+    /// Traverses the frames on the `BlockContext`, searching for either\n     /// the first block-tail expression frame with no intervening\n     /// statement frame.\n     ///\n@@ -453,13 +453,13 @@ impl BlockContext {\n \n #[derive(Debug)]\n enum LocalsForNode {\n-    /// In the usual case, a node-id for an identifier maps to at most\n-    /// one Local declaration.\n+    /// In the usual case, a `NodeId` for an identifier maps to at most\n+    /// one `Local` declaration.\n     One(Local),\n \n     /// The exceptional case is identifiers in a match arm's pattern\n     /// that are referenced in a guard of that match arm. For these,\n-    /// we can have `2+k` Locals, where `k` is the number of candidate\n+    /// we can have `2 + k` Locals, where `k` is the number of candidate\n     /// patterns (separated by `|`) in the arm.\n     ///\n     /// * `for_arm_body` is the Local used in the arm body (which is\n@@ -505,11 +505,11 @@ struct GuardFrame {\n     ///      P1(id1) if (... (match E2 { P2(id2) if ... => B2 })) => B1,\n     /// }\n     ///\n-    /// here, when building for FIXME\n+    /// here, when building for FIXME.\n     locals: Vec<GuardFrameLocal>,\n }\n \n-/// ForGuard indicates whether we are talking about:\n+/// `ForGuard` indicates whether we are talking about:\n ///   1. the temp for a local binding used solely within guard expressions,\n ///   2. the temp that holds reference to (1.), which is actually what the\n ///      guard expressions see, or"}, {"sha": "3392495f7a11b2717dfe25de143cf13ae0e0cacf", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -210,7 +210,7 @@ impl DropKind {\n }\n \n impl<'tcx> Scope<'tcx> {\n-    /// Invalidate all the cached blocks in the scope.\n+    /// Invalidates all the cached blocks in the scope.\n     ///\n     /// Should always be run for all inner scopes when a drop is pushed into some scope enclosing a\n     /// larger extent of code.\n@@ -390,7 +390,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n \n     /// Branch out of `block` to `target`, exiting all scopes up to\n-    /// and including `region_scope`.  This will insert whatever drops are\n+    /// and including `region_scope`. This will insert whatever drops are\n     /// needed. See module comment for details.\n     pub fn exit_scope(&mut self,\n                       span: Span,\n@@ -846,7 +846,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         next_target.unit()\n     }\n \n-    /// Create an Assert terminator and return the success block.\n+    /// Creates an Assert terminator and return the success block.\n     /// If the boolean condition operand is not the expected value,\n     /// a runtime panic will be caused with the given message.\n     pub fn assert(&mut self, block: BasicBlock,"}, {"sha": "fb0c19f764c1367bdfeffc74b16e1e4865ce88fe", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -38,7 +38,7 @@ const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n /// `simd_shuffle` and const patterns in match arms.\n ///\n /// The function containing the `match` that is currently being analyzed may have generic bounds\n-/// that inform us about the generic bounds of the constant. E.g. using an associated constant\n+/// that inform us about the generic bounds of the constant. E.g., using an associated constant\n /// of a function's generic parameter will require knowledge about the bounds on the generic\n /// parameter. These bounds are passed to `mk_eval_cx` via the `ParamEnv` argument.\n pub(crate) fn mk_eval_cx<'a, 'mir, 'tcx>(\n@@ -464,7 +464,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n         Ok(())\n     }\n \n-    /// Called immediately before a stack frame gets popped\n+    /// Called immediately before a stack frame gets popped.\n     #[inline(always)]\n     fn stack_pop(\n         _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n@@ -474,7 +474,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     }\n }\n \n-/// Project to a field of a (variant of a) const\n+/// Projects to a field of a (variant of a) const.\n pub fn const_field<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -542,10 +542,10 @@ fn validate_and_turn_into_const<'a, 'tcx>(\n                 op,\n                 path,\n                 Some(&mut ref_tracking),\n-                /* const_mode */ true,\n+                true, // const mode\n             )?;\n         }\n-        // Now that we validated, turn this into a proper constant\n+        // Now that we validated, turn this into a proper constant.\n         let def_id = cid.instance.def.def_id();\n         let normalize = tcx.is_static(def_id).is_none() && cid.promoted.is_none();\n         op_to_const(&ecx, op, normalize)"}, {"sha": "d43fa4257e06cce9cf3a79238416a6e278a8877d", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -26,14 +26,14 @@ pub trait FlowsAtLocation {\n     /// effects don't apply to the unwind edge).\n     fn reset_to_exit_of(&mut self, bb: BasicBlock);\n \n-    /// Build gen + kill sets for statement at `loc`.\n+    /// Builds gen and kill sets for statement at `loc`.\n     ///\n     /// Note that invoking this method alone does not change the\n     /// `curr_state` -- you must invoke `apply_local_effect`\n     /// afterwards.\n     fn reconstruct_statement_effect(&mut self, loc: Location);\n \n-    /// Build gen + kill sets for terminator for `loc`.\n+    /// Builds gen and kill sets for terminator for `loc`.\n     ///\n     /// Note that invoking this method alone does not change the\n     /// `curr_state` -- you must invoke `apply_local_effect`"}, {"sha": "151a004dce9426aca4c25cf77ab9f8b0ba17da8d", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -44,8 +44,8 @@ pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n /// In both cases, the contents can only be accessed if and only if\n /// their parents are initialized. This implies for example that there\n /// is no need to maintain separate drop flags to track such state.\n-///\n-/// FIXME: we have to do something for moving slice patterns.\n+//\n+// FIXME: we have to do something for moving slice patterns.\n fn place_contents_drop_state_cannot_differ<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                                             mir: &Mir<'tcx>,\n                                                             place: &mir::Place<'tcx>) -> bool {"}, {"sha": "c7f6983be619227091c3e85d89e67a24145e3145", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -143,7 +143,7 @@ where MWF: MirWithFlowState<'tcx>,\n         Ok(())\n     }\n \n-    /// Build the verbose row: full MIR data, and detailed gen/kill/entry sets\n+    /// Builds the verbose row: full MIR data, and detailed gen/kill/entry sets.\n     fn node_label_verbose_row<W: io::Write>(&self,\n                                             n: &Node,\n                                             w: &mut W,\n@@ -193,7 +193,7 @@ where MWF: MirWithFlowState<'tcx>,\n         Ok(())\n     }\n \n-    /// Build the summary row: terminator, gen/kill/entry bit sets\n+    /// Builds the summary row: terminator, gen/kill/entry bit sets.\n     fn node_label_final_row<W: io::Write>(&self,\n                                           n: &Node,\n                                           w: &mut W,"}, {"sha": "cc92ebfab89b76f84d8c734a50f77a00cf86da4e", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -143,13 +143,6 @@ impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeUninitializedPlaces<'a, 'gcx, 't\n /// initialized upon reaching a particular point in the control flow\n /// for a function.\n ///\n-/// FIXME: Note that once flow-analysis is complete, this should be\n-/// the set-complement of MaybeUninitializedPlaces; thus we can get rid\n-/// of one or the other of these two. I'm inclined to get rid of\n-/// MaybeUninitializedPlaces, simply because the sets will tend to be\n-/// smaller in this analysis and thus easier for humans to process\n-/// when debugging.\n-///\n /// For example, in code like the following, we have corresponding\n /// dataflow information shown in the right-hand comments.\n ///"}, {"sha": "c24a776605cb856cd8571dfff5fba1a72a217ba5", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -574,21 +574,21 @@ pub trait BitDenotation<'tcx>: BitSetOperator {\n     /// the block's start, not necessarily the state immediately prior\n     /// to the statement/terminator under analysis.\n     ///\n-    /// In either case, the passed reference is mutable; but this is a\n+    /// In either case, the passed reference is mutable, but this is a\n     /// wart from using the `BlockSets` type in the API; the intention\n     /// is that the `statement_effect` and `terminator_effect` methods\n     /// mutate only the gen/kill sets.\n-    ///\n-    /// FIXME: We should consider enforcing the intention described in\n-    /// the previous paragraph by passing the three sets in separate\n-    /// parameters to encode their distinct mutabilities.\n+    //\n+    // FIXME: we should consider enforcing the intention described in\n+    // the previous paragraph by passing the three sets in separate\n+    // parameters to encode their distinct mutabilities.\n     fn accumulates_intrablock_state() -> bool { false }\n \n     /// A name describing the dataflow analysis that this\n-    /// BitDenotation is supporting.  The name should be something\n-    /// suitable for plugging in as part of a filename e.g., avoid\n+    /// `BitDenotation` is supporting. The name should be something\n+    /// suitable for plugging in as part of a filename (i.e., avoid\n     /// space-characters or other things that tend to look bad on a\n-    /// file system, like slashes or periods. It is also better for\n+    /// file system, like slashes or periods). It is also better for\n     /// the name to be reasonably short, again because it will be\n     /// plugged into a filename.\n     fn name() -> &'static str;\n@@ -676,11 +676,11 @@ pub trait BitDenotation<'tcx>: BitSetOperator {\n     /// flow-dependent, the current MIR cannot encode them via just\n     /// GEN and KILL sets attached to the block, and so instead we add\n     /// this extra machinery to represent the flow-dependent effect.\n-    ///\n-    /// FIXME: Right now this is a bit of a wart in the API. It might\n-    /// be better to represent this as an additional gen- and\n-    /// kill-sets associated with each edge coming out of the basic\n-    /// block.\n+    //\n+    // FIXME: right now this is a bit of a wart in the API. It might\n+    // be better to represent this as an additional gen- and\n+    // kill-sets associated with each edge coming out of the basic\n+    // block.\n     fn propagate_call_return(\n         &self,\n         in_out: &mut BitSet<Self::Idx>,"}, {"sha": "6dcc0325ec1acd90d08e8fb5ae4cae57d9c3797f", "filename": "src/librustc_mir/dataflow/move_paths/abs_domain.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,12 +1,12 @@\n //! The move-analysis portion of borrowck needs to work in an abstract\n-//! domain of lifted Places.  Most of the Place variants fall into a\n+//! domain of lifted `Place`s. Most of the `Place` variants fall into a\n //! one-to-one mapping between the concrete and abstract (e.g., a\n-//! field-deref on a local-variable, `x.field`, has the same meaning\n-//! in both domains). Indexed-Projections are the exception: `a[x]`\n+//! field-deref on a local variable, `x.field`, has the same meaning\n+//! in both domains). Indexed projections are the exception: `a[x]`\n //! needs to be treated as mapping to the same move path as `a[y]` as\n-//! well as `a[13]`, et cetera.\n+//! well as `a[13]`, etc.\n //!\n-//! (In theory the analysis could be extended to work with sets of\n+//! (In theory, the analysis could be extended to work with sets of\n //! paths, so that `a[0]` and `a[13]` could be kept distinct, while\n //! `a[x]` would still overlap them both. But that is not this\n //! representation does today.)"}, {"sha": "cd937d702fd77149d6dd12013ba8029bcc3c3424", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,8 +1,6 @@\n-//! This module contains the code to convert from the wacky tcx data\n-//! structures into the hair. The `builder` is generally ignorant of\n-//! the tcx etc, and instead goes through the `Cx` for most of its\n-//! work.\n-//!\n+//! This module contains the fcuntaiontliy to convert from the wacky tcx data\n+//! structures into the HAIR. The `builder` is generally ignorant of the tcx,\n+//! etc., and instead goes through the `Cx` for most of its work.\n \n use crate::hair::*;\n use crate::hair::util::UserAnnotatedTyHelpers;\n@@ -44,10 +42,10 @@ pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     /// What kind of body is being compiled.\n     pub body_owner_kind: hir::BodyOwnerKind,\n \n-    /// True if this constant/function needs overflow checks.\n+    /// Whether this constant/function needs overflow checks.\n     check_overflow: bool,\n \n-    /// See field with the same name on `Mir`\n+    /// See field with the same name on `Mir`.\n     control_flow_destroyed: Vec<(Span, String)>,\n }\n \n@@ -100,7 +98,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n-    /// Normalizes `ast` into the appropriate `mirror` type.\n+    /// Normalizes `ast` into the appropriate \"mirror\" type.\n     pub fn mirror<M: Mirror<'tcx>>(&mut self, ast: M) -> M::Output {\n         ast.make_mirror(self)\n     }"}, {"sha": "e615b009cf370a77c9dfe576059d07cf073ec4ce", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -358,7 +358,7 @@ impl<'tcx> ExprRef<'tcx> {\n /// Mirroring is gradual: when you mirror an outer expression like `e1\n /// + e2`, the references to the inner expressions `e1` and `e2` are\n /// `ExprRef<'tcx>` instances, and they may or may not be eagerly\n-/// mirrored.  This allows a single AST node from the compiler to\n+/// mirrored. This allows a single AST node from the compiler to\n /// expand into one or more Hair nodes, which lets the Hair nodes be\n /// simpler.\n pub trait Mirror<'tcx> {"}, {"sha": "c52a57e17c60b92643fe5fff78d2ac8274de0180", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -6,8 +6,8 @@\n ///\n /// The algorithm implemented here is a modified version of the one described in:\n /// http://moscova.inria.fr/~maranget/papers/warn/index.html\n-/// However, to save future implementors from reading the original paper, I'm going\n-/// to summarise the algorithm here to hopefully save time and be a little clearer\n+/// However, to save future implementors from reading the original paper, we\n+/// summarise the algorithm here to hopefully save time and be a little clearer\n /// (without being so rigorous).\n ///\n /// The core of the algorithm revolves about a \"usefulness\" check. In particular, we\n@@ -351,7 +351,7 @@ pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     /// The module in which the match occurs. This is necessary for\n     /// checking inhabited-ness of types because whether a type is (visibly)\n     /// inhabited can depend on whether it was defined in the current module or\n-    /// not. eg. `struct Foo { _private: ! }` cannot be seen to be empty\n+    /// not. E.g., `struct Foo { _private: ! }` cannot be seen to be empty\n     /// outside it's module and should not be matchable with an empty match\n     /// statement.\n     pub module: DefId,\n@@ -896,7 +896,7 @@ impl<'tcx> IntRange<'tcx> {\n         }\n     }\n \n-    /// Convert a `RangeInclusive` to a `ConstantValue` or inclusive `ConstantRange`.\n+    /// Converts a `RangeInclusive` to a `ConstantValue` or inclusive `ConstantRange`.\n     fn range_to_ctor(\n         tcx: TyCtxt<'_, 'tcx, 'tcx>,\n         ty: Ty<'tcx>,\n@@ -912,7 +912,7 @@ impl<'tcx> IntRange<'tcx> {\n         }\n     }\n \n-    /// Return a collection of ranges that spans the values covered by `ranges`, subtracted\n+    /// Returns a collection of ranges that spans the values covered by `ranges`, subtracted\n     /// by the values covered by `self`: i.e., `ranges \\ self` (in set notation).\n     fn subtract_from(self,\n                      tcx: TyCtxt<'_, 'tcx, 'tcx>,\n@@ -1033,22 +1033,22 @@ fn compute_missing_ctors<'a, 'tcx: 'a>(\n     }\n }\n \n-/// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n+/// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html.\n /// The algorithm from the paper has been modified to correctly handle empty\n /// types. The changes are:\n ///   (0) We don't exit early if the pattern matrix has zero rows. We just\n ///       continue to recurse over columns.\n ///   (1) all_constructors will only return constructors that are statically\n-///       possible. eg. it will only return Ok for Result<T, !>\n+///       possible. E.g., it will only return `Ok` for `Result<T, !>`.\n ///\n /// This finds whether a (row) vector `v` of patterns is 'useful' in relation\n /// to a set of such vectors `m` - this is defined as there being a set of\n /// inputs that will match `v` but not any of the sets in `m`.\n ///\n /// All the patterns at each column of the `matrix ++ v` matrix must\n /// have the same type, except that wildcard (PatternKind::Wild) patterns\n-/// with type TyErr are also allowed, even if the \"type of the column\"\n-/// is not TyErr. That is used to represent private fields, as using their\n+/// with type `TyErr` are also allowed, even if the \"type of the column\"\n+/// is not `TyErr`. That is used to represent private fields, as using their\n /// real type would assert that they are inhabited.\n ///\n /// This is used both for reachability checking (if a pattern isn't useful in\n@@ -1299,7 +1299,7 @@ fn is_useful_specialized<'p, 'a: 'p, 'tcx: 'a>(\n /// Slice patterns, however, can match slices of different lengths. For instance,\n /// `[a, b, ..tail]` can match a slice of length 2, 3, 4 and so on.\n ///\n-/// Returns None in case of a catch-all, which can't be specialized.\n+/// Returns `None` in case of a catch-all, which can't be specialized.\n fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n                           pat: &Pattern<'tcx>,\n                           pcx: PatternContext<'_>)\n@@ -1614,7 +1614,7 @@ fn split_grouped_constructors<'p, 'a: 'p, 'tcx: 'a>(\n     split_ctors\n }\n \n-/// Check whether there exists any shared value in either `ctor` or `pat` by intersecting them.\n+/// Checks whether there exists any shared value in either `ctor` or `pat` by intersecting them.\n fn constructor_intersects_pattern<'p, 'a: 'p, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ctor: &Constructor<'tcx>,"}, {"sha": "6addfa8589b49a2a698e97081e197fdd5d5a6518", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -537,10 +537,9 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor<'_, '_>,\n     }\n }\n \n-/// Ensures that a pattern guard doesn't borrow by mutable reference or\n-/// assign.\n-///\n-/// FIXME: this should be done by borrowck.\n+/// Ensures that a pattern guard doesn't borrow by mutable reference or assign.\n+//\n+// FIXME: this should be done by borrowck.\n fn check_for_mutation_in_guard(cx: &MatchVisitor<'_, '_>, guard: &hir::Guard) {\n     let mut checker = MutationChecker {\n         cx,"}, {"sha": "dd12cd7781b167c12444e66b6ce6638e6842a713", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,4 +1,4 @@\n-//! Code to validate patterns/matches\n+//! Validation of patterns/matches.\n \n mod _match;\n mod check_match;\n@@ -116,7 +116,7 @@ pub enum PatternKind<'tcx> {\n         user_ty_span: Span,\n     },\n \n-    /// x, ref x, x @ P, etc\n+    /// `x`, `ref x`, `x @ P`, etc.\n     Binding {\n         mutability: Mutability,\n         name: ast::Name,\n@@ -126,20 +126,22 @@ pub enum PatternKind<'tcx> {\n         subpattern: Option<Pattern<'tcx>>,\n     },\n \n-    /// Foo(...) or Foo{...} or Foo, where `Foo` is a variant name from an adt with >1 variants\n+    /// `Foo(...)` or `Foo{...}` or `Foo`, where `Foo` is a variant name from an ADT with\n+    /// multiple variants.\n     Variant {\n         adt_def: &'tcx AdtDef,\n         substs: &'tcx Substs<'tcx>,\n         variant_index: VariantIdx,\n         subpatterns: Vec<FieldPattern<'tcx>>,\n     },\n \n-    /// (...), Foo(...), Foo{...}, or Foo, where `Foo` is a variant name from an adt with 1 variant\n+    /// `(...)`, `Foo(...)`, `Foo{...}`, or `Foo`, where `Foo` is a variant name from an ADT with\n+    /// a single variant.\n     Leaf {\n         subpatterns: Vec<FieldPattern<'tcx>>,\n     },\n \n-    /// box P, &P, &mut P, etc\n+    /// `box P`, `&P`, `&mut P`, etc.\n     Deref {\n         subpattern: Pattern<'tcx>,\n     },\n@@ -150,7 +152,7 @@ pub enum PatternKind<'tcx> {\n \n     Range(PatternRange<'tcx>),\n \n-    /// matches against a slice, checking the length and extracting elements.\n+    /// Matches against a slice, checking the length and extracting elements.\n     /// irrefutable when there is a slice pattern and both `prefix` and `suffix` are empty.\n     /// e.g., `&[ref xs..]`.\n     Slice {\n@@ -159,7 +161,7 @@ pub enum PatternKind<'tcx> {\n         suffix: Vec<Pattern<'tcx>>,\n     },\n \n-    /// fixed match against an array, irrefutable\n+    /// Fixed match against an array; irrefutable.\n     Array {\n         prefix: Vec<Pattern<'tcx>>,\n         slice: Option<Pattern<'tcx>>,\n@@ -767,7 +769,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n     /// Takes a HIR Path. If the path is a constant, evaluates it and feeds\n     /// it to `const_to_pat`. Any other path (like enum variants without fields)\n-    /// is converted to the corresponding pattern via `lower_variant_or_leaf`\n+    /// is converted to the corresponding pattern via `lower_variant_or_leaf`.\n     fn lower_path(&mut self,\n                   qpath: &hir::QPath,\n                   id: hir::HirId,\n@@ -851,8 +853,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     }\n \n     /// Converts literals, paths and negation of literals to patterns.\n-    /// The special case for negation exists to allow things like -128i8\n-    /// which would overflow if we tried to evaluate 128i8 and then negate\n+    /// The special case for negation exists to allow things like `-128_i8`\n+    /// which would overflow if we tried to evaluate `128_i8` and then negate\n     /// afterwards.\n     fn lower_lit(&mut self, expr: &'tcx hir::Expr) -> PatternKind<'tcx> {\n         match expr.node {\n@@ -901,7 +903,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n     /// Converts an evaluated constant to a pattern (if possible).\n     /// This means aggregate values (like structs and enums) are converted\n-    /// to a pattern that matches the value (as if you'd compare via eq).\n+    /// to a pattern that matches the value (as if you'd compared via equality).\n     fn const_to_pat(\n         &self,\n         instance: ty::Instance<'tcx>,"}, {"sha": "0c1b5d65b8b68b56507e715841394692410ccafe", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -55,7 +55,7 @@ pub struct Frame<'mir, 'tcx: 'mir, Tag=(), Extra=()> {\n     /// The MIR for the function called on this frame.\n     pub mir: &'mir mir::Mir<'tcx>,\n \n-    /// The def_id and substs of the current function\n+    /// The def_id and substs of the current function.\n     pub instance: ty::Instance<'tcx>,\n \n     /// The span of the call site.\n@@ -64,7 +64,7 @@ pub struct Frame<'mir, 'tcx: 'mir, Tag=(), Extra=()> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Return place and locals\n     ////////////////////////////////////////////////////////////////////////////////\n-    /// Work to perform when returning from this function\n+    /// Work to perform when returning from this function.\n     pub return_to_block: StackPopCleanup,\n \n     /// The location where the result of the current stack frame should be written to,\n@@ -88,7 +88,7 @@ pub struct Frame<'mir, 'tcx: 'mir, Tag=(), Extra=()> {\n     /// The index of the currently evaluated statement.\n     pub stmt: usize,\n \n-    /// Extra data for the machine\n+    /// Extra data for the machine.\n     pub extra: Extra,\n }\n \n@@ -99,7 +99,7 @@ pub enum StackPopCleanup {\n     /// we can validate it at that layout.\n     Goto(Option<mir::BasicBlock>),\n     /// Just do nohing: Used by Main and for the box_alloc hook in miri.\n-    /// `cleanup` says whether locals are deallocated.  Static computation\n+    /// `cleanup` says whether locals are deallocated. Static computation\n     /// wants them leaked to intern what they need (and just throw away\n     /// the entire `ecx` when it is done).\n     None { cleanup: bool },\n@@ -339,7 +339,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         Ok(Immediate::new_slice(Scalar::Ptr(ptr), s.len() as u64, self))\n     }\n \n-    /// Return the actual dynamic size and alignment of the place at the given type.\n+    /// Returns the actual dynamic size and alignment of the place at the given type.\n     /// Only the \"meta\" (metadata) part of the place matters.\n     /// This can fail to provide an answer for extern types.\n     pub(super) fn size_and_align_of("}, {"sha": "78c5c0a6d751c8f1acec74ae6084e27010cc1d20", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,5 +1,5 @@\n //! Intrinsics and other functions that the miri engine executes without\n-//! looking at their MIR.  Intrinsics/functions supported here are shared by CTFE\n+//! looking at their MIR. Intrinsics/functions supported here are shared by CTFE\n //! and miri.\n \n use syntax::symbol::Symbol;\n@@ -37,7 +37,7 @@ fn numeric_intrinsic<'tcx, Tag>(\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    /// Returns whether emulation happened.\n+    /// Returns `true` if emulation happened.\n     pub fn emulate_intrinsic(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n@@ -212,7 +212,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     }\n \n     /// \"Intercept\" a function call because we have something special to do for it.\n-    /// Returns whether an intercept happened.\n+    /// Returns `true` if an intercept happened.\n     pub fn hook_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,"}, {"sha": "8f34b832f0b41451e1f5dc83eb0481dd607f5376", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -21,23 +21,23 @@ pub trait MayLeak: Copy {\n \n /// The functionality needed by memory to manage its allocations\n pub trait AllocMap<K: Hash + Eq, V> {\n-    /// Test if the map contains the given key.\n+    /// Tests if the map contains the given key.\n     /// Deliberately takes `&mut` because that is sufficient, and some implementations\n     /// can be more efficient then (using `RefCell::get_mut`).\n     fn contains_key<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> bool\n         where K: Borrow<Q>;\n \n-    /// Insert new entry into the map.\n+    /// Inserts a new entry into the map.\n     fn insert(&mut self, k: K, v: V) -> Option<V>;\n \n-    /// Remove entry from the map.\n+    /// Removes an entry from the map.\n     fn remove<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> Option<V>\n         where K: Borrow<Q>;\n \n-    /// Return data based the keys and values in the map.\n+    /// Returns data based the keys and values in the map.\n     fn filter_map_collect<T>(&self, f: impl FnMut(&K, &V) -> Option<T>) -> Vec<T>;\n \n-    /// Return a reference to entry `k`.  If no such entry exists, call\n+    /// Returns a reference to entry `k`. If no such entry exists, call\n     /// `vacant` and either forward its error, or add its result to the map\n     /// and return a reference to *that*.\n     fn get_or<E>(\n@@ -46,7 +46,7 @@ pub trait AllocMap<K: Hash + Eq, V> {\n         vacant: impl FnOnce() -> Result<V, E>\n     ) -> Result<&V, E>;\n \n-    /// Return a mutable reference to entry `k`.  If no such entry exists, call\n+    /// Returns a mutable reference to entry `k`. If no such entry exists, call\n     /// `vacant` and either forward its error, or add its result to the map\n     /// and return a reference to *that*.\n     fn get_mut_or<E>(\n@@ -62,15 +62,15 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n     type MemoryKinds: ::std::fmt::Debug + MayLeak + Eq + 'static;\n \n-    /// Tag tracked alongside every pointer.  This is used to implement \"Stacked Borrows\"\n+    /// Tag tracked alongside every pointer. This is used to implement \"Stacked Borrows\"\n     /// <https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html>.\n     /// The `default()` is used for pointers to consts, statics, vtables and functions.\n     type PointerTag: ::std::fmt::Debug + Default + Copy + Eq + Hash + 'static;\n \n     /// Extra data stored in every call frame.\n     type FrameExtra;\n \n-    /// Extra data stored in memory.  A reference to this is available when `AllocExtra`\n+    /// Extra data stored in memory. A reference to this is available when `AllocExtra`\n     /// gets initialized, so you can e.g., have an `Rc` here if there is global state you\n     /// need access to in the `AllocExtra` hooks.\n     type MemoryExtra: Default;\n@@ -105,7 +105,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     ///\n     /// Returns either the mir to use for the call, or `None` if execution should\n     /// just proceed (which usually means this hook did all the work that the\n-    /// called function should usually have done).  In the latter case, it is\n+    /// called function should usually have done). In the latter case, it is\n     /// this hook's responsibility to call `goto_block(ret)` to advance the instruction pointer!\n     /// (This is to support functions like `__rust_maybe_catch_panic` that neither find a MIR\n     /// nor just jump to `ret`, but instead push their own stack frame.)\n@@ -170,15 +170,15 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx>;\n \n-    /// Add the tag for a newly allocated pointer.\n+    /// Adds the tag for a newly allocated pointer.\n     fn tag_new_allocation(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         ptr: Pointer,\n         kind: MemoryKind<Self::MemoryKinds>,\n     ) -> Pointer<Self::PointerTag>;\n \n     /// Executed when evaluating the `*` operator: Following a reference.\n-    /// This has the chance to adjust the tag.  It should not change anything else!\n+    /// This has the chance to adjust the tag. It should not change anything else!\n     /// `mutability` can be `None` in case a raw ptr is being dereferenced.\n     #[inline]\n     fn tag_dereference(\n@@ -189,7 +189,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         Ok(place.ptr)\n     }\n \n-    /// Execute a retagging operation\n+    /// Executes a retagging operation\n     #[inline]\n     fn retag(\n         _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,"}, {"sha": "88b936afaa4c1c0357c6242a902cfbef305a85de", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -3,7 +3,7 @@\n //! Generally, we use `Pointer` to denote memory addresses. However, some operations\n //! have a \"size\"-like parameter, and they take `Scalar` for the address because\n //! if the size is 0, then the pointer can also be a (properly aligned, non-NULL)\n-//! integer.  It is crucial that these operations call `check_align` *before*\n+//! integer. It is crucial that these operations call `check_align` *before*\n //! short-circuiting the empty case!\n \n use std::collections::VecDeque;\n@@ -47,10 +47,10 @@ impl<T: MayLeak> MayLeak for MemoryKind<T> {\n // `Memory` has to depend on the `Machine` because some of its operations\n // (e.g., `get`) call a `Machine` hook.\n pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n-    /// Allocations local to this instance of the miri engine.  The kind\n+    /// Allocations local to this instance of the miri engine. The kind\n     /// helps ensure that the same mechanism is used for allocation and\n-    /// deallocation.  When an allocation is not found here, it is a\n-    /// static and looked up in the `tcx` for read access.  Some machines may\n+    /// deallocation. When an allocation is not found here, it is a\n+    /// static and looked up in the `tcx` for read access. Some machines may\n     /// have to mutate this map even on a read-only access to a static (because\n     /// they do pointer provenance tracking and the allocations in `tcx` have\n     /// the wrong type), so we let the machine override this type.\n@@ -240,7 +240,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    /// Check that the pointer is aligned AND non-NULL. This supports ZSTs in two ways:\n+    /// Checks that the pointer is aligned AND non-NULL. This supports ZSTs in two ways:\n     /// You can pass a scalar, and a `Pointer` does not have to actually still be allocated.\n     pub fn check_align(\n         &self,\n@@ -284,7 +284,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    /// Check if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n+    /// Checks if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n     /// of an allocation (i.e., at the first *inaccessible* location) *is* considered\n     /// in-bounds!  This follows C's/LLVM's rules.\n     /// If you want to check bounds before doing a memory access, better first obtain\n@@ -659,7 +659,7 @@ where\n     }\n }\n \n-/// Reading and writing\n+/// Reading and writing.\n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn copy(\n         &mut self,"}, {"sha": "c0b26442dd918c75a4b859916dbdab81c65bf989", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -87,7 +87,7 @@ impl<'tcx, Tag> Immediate<Tag> {\n         }\n     }\n \n-    /// Convert the immediate into a pointer (or a pointer-sized integer).\n+    /// Converts the immediate into a pointer (or a pointer-sized integer).\n     /// Throws away the second half of a ScalarPair!\n     #[inline]\n     pub fn to_scalar_ptr(self) -> EvalResult<'tcx, Scalar<Tag>> {\n@@ -97,7 +97,7 @@ impl<'tcx, Tag> Immediate<Tag> {\n         }\n     }\n \n-    /// Convert the value into its metadata.\n+    /// Converts the value into its metadata.\n     /// Throws away the first half of a ScalarPair!\n     #[inline]\n     pub fn to_meta(self) -> EvalResult<'tcx, Option<Scalar<Tag>>> {\n@@ -125,7 +125,7 @@ impl<'tcx, Tag> ::std::ops::Deref for ImmTy<'tcx, Tag> {\n }\n \n /// An `Operand` is the result of computing a `mir::Operand`. It can be immediate,\n-/// or still in memory.  The latter is an optimization, to delay reading that chunk of\n+/// or still in memory. The latter is an optimization, to delay reading that chunk of\n /// memory and to avoid having to store arbitrary-sized data here.\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum Operand<Tag=(), Id=AllocId> {\n@@ -247,7 +247,7 @@ pub(super) fn from_known_layout<'tcx>(\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Try reading an immediate in memory; this is interesting particularly for ScalarPair.\n-    /// Return None if the layout does not permit loading this as a value.\n+    /// Returns `None` if the layout does not permit loading this as a value.\n     pub(super) fn try_read_immediate_from_mplace(\n         &self,\n         mplace: MPlaceTy<'tcx, M::PointerTag>,"}, {"sha": "004a11e34d6e1d4b02f07b872b5bc6e99deb6041", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -24,7 +24,7 @@ pub struct MemPlace<Tag=(), Id=AllocId> {\n     /// However, it may never be undef.\n     pub ptr: Scalar<Tag, Id>,\n     pub align: Align,\n-    /// Metadata for unsized places.  Interpretation is up to the type.\n+    /// Metadata for unsized places. Interpretation is up to the type.\n     /// Must not be present for sized types, but can be missing for unsized types\n     /// (e.g., `extern type`).\n     pub meta: Option<Scalar<Tag, Id>>,\n@@ -516,7 +516,7 @@ where\n         })\n     }\n \n-    /// Get the place of a field inside the place, and also the field's type.\n+    /// Gets the place of a field inside the place, and also the field's type.\n     /// Just a convenience function, but used quite a bit.\n     /// This is the only projection that might have a side-effect: We cannot project\n     /// into the field of a local `ScalarPair`, we have to first allocate it.\n@@ -547,7 +547,7 @@ where\n         })\n     }\n \n-    /// Project into a place\n+    /// Projects into a place.\n     pub fn place_projection(\n         &mut self,\n         base: PlaceTy<'tcx, M::PointerTag>,\n@@ -567,7 +567,7 @@ where\n         })\n     }\n \n-    /// Evaluate statics and promoteds to an `MPlace`.  Used to share some code between\n+    /// Evaluate statics and promoteds to an `MPlace`. Used to share some code between\n     /// `eval_place` and `eval_place_to_op`.\n     pub(super) fn eval_place_to_mplace(\n         &self,\n@@ -610,7 +610,7 @@ where\n         })\n     }\n \n-    /// Compute a place.  You should only use this if you intend to write into this\n+    /// Computes a place. You should only use this if you intend to write into this\n     /// place; for reading, a more efficient alternative is `eval_place_for_read`.\n     pub fn eval_place(\n         &mut self,\n@@ -785,7 +785,7 @@ where\n         }\n     }\n \n-    /// Copy the data from an operand to a place.  This does not support transmuting!\n+    /// Copies the data from an operand to a place. This does not support transmuting!\n     /// Use `copy_op_transmute` if the layouts could disagree.\n     #[inline(always)]\n     pub fn copy_op(\n@@ -803,7 +803,7 @@ where\n         Ok(())\n     }\n \n-    /// Copy the data from an operand to a place.  This does not support transmuting!\n+    /// Copies the data from an operand to a place. This does not support transmuting!\n     /// Use `copy_op_transmute` if the layouts could disagree.\n     /// Also, if you use this you are responsible for validating that things git copied at the\n     /// right type.\n@@ -845,7 +845,7 @@ where\n         Ok(())\n     }\n \n-    /// Copy the data from an operand to a place.  The layouts may disagree, but they must\n+    /// Copies the data from an operand to a place. The layouts may disagree, but they must\n     /// have the same size.\n     pub fn copy_op_transmute(\n         &mut self,\n@@ -884,7 +884,7 @@ where\n         Ok(())\n     }\n \n-    /// Make sure that a place is in memory, and return where it is.\n+    /// Ensures that a place is in memory, and returns where it is.\n     /// If the place currently refers to a local that doesn't yet have a matching allocation,\n     /// create such an allocation.\n     /// This is essentially `force_to_memplace`."}, {"sha": "0c988eb6810837b2ef83f282537dbb7253354576", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -41,7 +41,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         Ok(())\n     }\n \n-    /// Returns true as long as there are more things to do.\n+    /// Returns `true` as long as there are more things to do.\n     ///\n     /// This is used by [priroda](https://github.com/oli-obk/priroda)\n     pub fn step(&mut self) -> EvalResult<'tcx, bool> {"}, {"sha": "65d7060b544d65a192b4ffd94424593048164ecc", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -87,7 +87,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         Ok(vtable)\n     }\n \n-    /// Return the drop fn instance as well as the actual dynamic type\n+    /// Returns the drop fn instance as well as the actual dynamic type\n     pub fn read_drop_type_from_vtable(\n         &self,\n         vtable: Pointer<M::PointerTag>,"}, {"sha": "8b97d9ded74498ae846434a37215080ea9a4eb06", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -587,7 +587,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    /// This function checks the data at `op`.  `op` is assumed to cover valid memory if it\n+    /// This function checks the data at `op`. `op` is assumed to cover valid memory if it\n     /// is an indirect operand.\n     /// It will error if the bits at the destination do not match the ones described by the layout.\n     ///"}, {"sha": "e2abf2ffc849c265fc98c62b2e1afbe4739fb905", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -16,26 +16,26 @@ use super::{\n // that's just more convenient to work with (avoids repeating all the `Machine` bounds).\n pub trait Value<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: Copy\n {\n-    /// Get this value's layout.\n+    /// Gets this value's layout.\n     fn layout(&self) -> TyLayout<'tcx>;\n \n-    /// Make this into an `OpTy`.\n+    /// Makes this into an `OpTy`.\n     fn to_op(\n         self,\n         ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n \n-    /// Create this from an `MPlaceTy`.\n+    /// Creates this from an `MPlaceTy`.\n     fn from_mem_place(mplace: MPlaceTy<'tcx, M::PointerTag>) -> Self;\n \n-    /// Project to the given enum variant.\n+    /// Projects to the given enum variant.\n     fn project_downcast(\n         self,\n         ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> EvalResult<'tcx, Self>;\n \n-    /// Project to the n-th field.\n+    /// Projects to the n-th field.\n     fn project_field(\n         self,\n         ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n@@ -135,19 +135,19 @@ macro_rules! make_value_visitor {\n                 -> &$($mutability)? EvalContext<'a, 'mir, 'tcx, M>;\n \n             // Recursive actions, ready to be overloaded.\n-            /// Visit the given value, dispatching as appropriate to more specialized visitors.\n+            /// Visits the given value, dispatching as appropriate to more specialized visitors.\n             #[inline(always)]\n             fn visit_value(&mut self, v: Self::V) -> EvalResult<'tcx>\n             {\n                 self.walk_value(v)\n             }\n-            /// Visit the given value as a union.  No automatic recursion can happen here.\n+            /// Visits the given value as a union. No automatic recursion can happen here.\n             #[inline(always)]\n             fn visit_union(&mut self, _v: Self::V) -> EvalResult<'tcx>\n             {\n                 Ok(())\n             }\n-            /// Visit this vale as an aggregate, you are even getting an iterator yielding\n+            /// Visits this vale as an aggregate, you are even getting an iterator yielding\n             /// all the fields (still in an `EvalResult`, you have to do error handling yourself).\n             /// Recurses into the fields.\n             #[inline(always)]\n@@ -173,7 +173,7 @@ macro_rules! make_value_visitor {\n                 self.visit_value(new_val)\n             }\n \n-            /// Called for recursing into the field of a generator.  These are not known to be\n+            /// Called for recursing into the field of a generator. These are not known to be\n             /// initialized, so we treat them like unions.\n             #[inline(always)]\n             fn visit_generator_field(\n@@ -215,8 +215,8 @@ macro_rules! make_value_visitor {\n             fn visit_scalar(&mut self, _v: Self::V, _layout: &layout::Scalar) -> EvalResult<'tcx>\n             { Ok(()) }\n \n-            /// Called whenever we reach a value of primitive type.  There can be no recursion\n-            /// below such a value.  This is the leaf function.\n+            /// Called whenever we reach a value of primitive type. There can be no recursion\n+            /// below such a value. This is the leaf function.\n             /// We do *not* provide an `ImmTy` here because some implementations might want\n             /// to write to the place this primitive lives in.\n             #[inline(always)]"}, {"sha": "6e639c3a1179a2fc96490ab24d06a6f73e8c2bd8", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -122,7 +122,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n         codegen_fn_attrs.linkage\n     }\n \n-    /// Returns whether this instance is instantiable - whether it has no unsatisfied\n+    /// Returns `true` if this instance is instantiable - whether it has no unsatisfied\n     /// predicates.\n     ///\n     /// In order to codegen an item, all of its predicates must hold, because"}, {"sha": "f342017603ed60501328d73d9b9e04fbab92fce3", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -118,7 +118,7 @@ use crate::monomorphize::item::{MonoItemExt, InstantiationMode};\n pub use rustc::mir::mono::CodegenUnit;\n \n pub enum PartitioningStrategy {\n-    /// Generate one codegen unit per source-level module.\n+    /// Generates one codegen unit per source-level module.\n     PerModule,\n \n     /// Partition the whole crate into a fixed number of codegen units."}, {"sha": "d4145b8e47ea27af3f1e8c9542d74bbe205ad50d", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -306,7 +306,7 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n     }\n }\n \n-/// Build a `Clone::clone` shim for `self_ty`. Here, `def_id` is `Clone::clone`.\n+/// Builds a `Clone::clone` shim for `self_ty`. Here, `def_id` is `Clone::clone`.\n fn build_clone_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               def_id: DefId,\n                               self_ty: Ty<'tcx>)\n@@ -691,7 +691,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n     }\n }\n \n-/// Build a \"call\" shim for `def_id`. The shim calls the\n+/// Builds a \"call\" shim for `def_id`. The shim calls the\n /// function specified by `call_kind`, first adjusting its first\n /// argument according to `rcvr_adjustment`.\n ///"}, {"sha": "66529e579835dfabaf08a2d13bc807a635924725", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -28,7 +28,7 @@ pub struct UnsafetyChecker<'a, 'tcx: 'a> {\n     source_info: SourceInfo,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    /// mark an `unsafe` block as used, so we don't lint it\n+    /// Mark an `unsafe` block as used, so we don't lint it.\n     used_unsafe: FxHashSet<ast::NodeId>,\n     inherited_blocks: Vec<(ast::NodeId, bool)>,\n }\n@@ -574,7 +574,7 @@ fn unsafe_derive_on_repr_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: D\n                   &message);\n }\n \n-/// Return the NodeId for an enclosing scope that is also `unsafe`\n+/// Returns the `NodeId` for an enclosing scope that is also `unsafe`.\n fn is_enclosed(tcx: TyCtxt<'_, '_, '_>,\n                used_unsafe: &FxHashSet<ast::NodeId>,\n                id: ast::NodeId) -> Option<(String, ast::NodeId)> {"}, {"sha": "0f8db5f7334bd795652f45429c33f03e5a3dfce8", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -74,7 +74,7 @@ impl MirPass for ElaborateDrops {\n     }\n }\n \n-/// Return the set of basic blocks whose unwind edges are known\n+/// Returns the set of basic blocks whose unwind edges are known\n /// to not be reachable, because they are `drop` terminators\n /// that can't drop anything.\n fn find_dead_unwinds<'a, 'tcx>("}, {"sha": "84f209f8776d9cba5905679108ad2d15e94a885e", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,8 +1,8 @@\n //! This pass erases all early-bound regions from the types occurring in the MIR.\n //! We want to do this once just before codegen, so codegen does not have to take\n //! care erasing regions all over the place.\n-//! NOTE:  We do NOT erase regions of statements that are relevant for\n-//! \"types-as-contracts\"-validation, namely, AcquireValid, ReleaseValid\n+//! N.B., we do _not_ erase regions of statements that are relevant for\n+//! \"types-as-contracts\"-validation, namely, `AcquireValid` and `ReleaseValid`.\n \n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};"}, {"sha": "28b9e082851c09cf1900ed0f279ead94e106f0a5", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -56,7 +56,7 @@ fn is_mir_available<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> boo\n     tcx.mir_keys(def_id.krate).contains(&def_id)\n }\n \n-/// Finds the full set of def-ids within the current crate that have\n+/// Finds the full set of `DefId`s within the current crate that have\n /// MIR associated with them.\n fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n                       -> Lrc<DefIdSet> {"}, {"sha": "a6726718e2d23aab6e7e05455ea8976fdf1f139c", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -182,7 +182,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         });\n     }\n \n-    /// Copy the initialization of this temp to the\n+    /// Copies the initialization of this temp to the\n     /// promoted MIR, recursing through temps.\n     fn promote_temp(&mut self, temp: Local) -> Local {\n         let old_keep_original = self.keep_original;"}, {"sha": "a1a9e9baf1b2c0c19e0556327597568786ddff3e", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -176,18 +176,18 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n         }\n     }\n \n-    /// Add the given qualification to self.qualif.\n+    /// Adds the given qualification to `self.qualif`.\n     fn add(&mut self, qualif: Qualif) {\n         self.qualif = self.qualif | qualif;\n     }\n \n-    /// Add the given type's qualification to self.qualif.\n+    /// Adds the given type's qualification to `self.qualif`.\n     fn add_type(&mut self, ty: Ty<'tcx>) {\n         self.add(Qualif::MUTABLE_INTERIOR | Qualif::NEEDS_DROP);\n         self.qualif.restrict(ty, self.tcx, self.param_env);\n     }\n \n-    /// Within the provided closure, self.qualif will start\n+    /// Within the provided closure, `self.qualif` will start\n     /// out empty, and its value after the closure returns will\n     /// be combined with the value before the call to nest.\n     fn nest<F: FnOnce(&mut Self)>(&mut self, f: F) {"}, {"sha": "34f850fc4aad2a297e6e9913042e80666f9cd5a3", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -358,7 +358,7 @@ fn check_terminator(\n     }\n }\n \n-/// Returns true if the `def_id` refers to an intrisic which we've whitelisted\n+/// Returns `true` if the `def_id` refers to an intrisic which we've whitelisted\n /// for being called from stable `const fn`s (`min_const_fn`).\n ///\n /// Adding more intrinsics requires sign-off from @rust-lang/lang."}, {"sha": "0ad33bff9d6caf411ef16058e7a644a34238b91a", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -4,7 +4,7 @@ use rustc_data_structures::bit_set::BitSet;\n use crate::transform::{MirPass, MirSource};\n use crate::util::patch::MirPatch;\n \n-/// A pass that removes no-op landing pads and replaces jumps to them with\n+/// A pass that removes noop landing pads and replaces jumps to them with\n /// `None`. This is important because otherwise LLVM generates terrible\n /// code for these.\n pub struct RemoveNoopLandingPads;"}, {"sha": "7be34d001df07c9c4f2bc18f10651afbcb8f9c3e", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -1,7 +1,7 @@\n use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n \n-/// Return `true` if this place is allowed to be less aligned\n+/// Returns `true` if this place is allowed to be less aligned\n /// than its containing struct (because it is within a packed\n /// struct).\n pub fn is_disaligned<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "2e41c6e493bc35b777d67e09931919c436a16f07", "filename": "src/librustc_mir/util/def_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> DefUseAnalysis<'tcx> {\n         }\n     }\n \n-    /// FIXME(pcwalton): This should update the def-use chains.\n+    // FIXME(pcwalton): this should update the def-use chains.\n     pub fn replace_all_defs_and_uses_with(&self,\n                                           local: Local,\n                                           mir: &mut Mir<'tcx>,"}, {"sha": "e86ece138301fce509094698cce6fded42629149", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b244f61b77c42d7be695afd7901ee4418559e518/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=b244f61b77c42d7be695afd7901ee4418559e518", "patch": "@@ -144,9 +144,9 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     /// joined together under the `rest` subpath. They are all controlled\n     /// by the primary drop flag, but only the last rest-field dropped\n     /// should clear it (and it must also not clear anything else).\n-    ///\n-    /// FIXME: I think we should just control the flags externally\n-    /// and then we do not need this machinery.\n+    //\n+    // FIXME: I think we should just control the flags externally,\n+    // and then we do not need this machinery.\n     pub fn elaborate_drop<'a>(&mut self, bb: BasicBlock) {\n         debug!(\"elaborate_drop({:?})\", self);\n         let style = self.elaborator.drop_style(self.path, DropFlagMode::Deep);\n@@ -183,7 +183,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         }\n     }\n \n-    /// Return the place and move path for each field of `variant`,\n+    /// Returns the place and move path for each field of `variant`,\n     /// (the move path is `None` if the field is a rest field).\n     fn move_paths_for_fields(&self,\n                              base_place: &Place<'tcx>,\n@@ -234,7 +234,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         }\n     }\n \n-    /// Create one-half of the drop ladder for a list of fields, and return\n+    /// Creates one-half of the drop ladder for a list of fields, and return\n     /// the list of steps in it in reverse order, with the first step\n     /// dropping 0 fields and so on.\n     ///\n@@ -268,7 +268,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         )\n     }\n \n-    /// Create a full drop ladder, consisting of 2 connected half-drop-ladders\n+    /// Creates a full drop ladder, consisting of 2 connected half-drop-ladders\n     ///\n     /// For example, with 3 fields, the drop ladder is\n     ///\n@@ -818,7 +818,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         }\n     }\n \n-    /// Return a basic block that drop a place using the context\n+    /// Returns a basic block that drop a place using the context\n     /// and path in `c`. If `mode` is something, also clear `c`\n     /// according to it.\n     ///"}]}