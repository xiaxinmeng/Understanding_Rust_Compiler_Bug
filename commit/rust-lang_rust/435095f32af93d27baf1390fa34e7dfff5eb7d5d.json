{"sha": "435095f32af93d27baf1390fa34e7dfff5eb7d5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzNTA5NWYzMmFmOTNkMjdiYWYxMzkwZmEzNGU3ZGZmZjVlYjdkNWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-28T01:35:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-28T01:35:29Z"}, "message": "Auto merge of #32791 - LeoTestard:feature-gate-clean, r=nikomatsakis\n\nFeature gate clean\n\nThis PR does a bit of cleaning in the feature-gate-handling code of libsyntax. It also fixes two bugs (#32782 and #32648). Changes include:\n\n* Change the way the existing features are declared in `feature_gate.rs`. The array of features and the `Features` struct are now defined together by a single macro. `featureck.py` has been updated accordingly. Note: there are now three different arrays for active, removed and accepted features instead of a single one with a `Status` item to tell wether a feature is active, removed, or accepted. This is mainly due to the way I implemented my macro in the first time and I can switch back to a single array if needed. But an advantage of the way it is now is that when an active feature is used, the parser only searches through the list of active features. It goes through the other arrays only if the feature is not found. I like to think that error checking (in this case, checking that an used feature is active) does not slow down compilation of valid code. :) But this is not very important...\n* Feature-gate checking pass now use the `Features` structure instead of looking through a string vector. This should speed them up a bit. The construction of the `Features` struct should be faster too since it is build directly when parsing features instead of calling `has_feature` dozens of times.\n* The MacroVisitor pass has been removed, it was mostly useless since the `#[cfg]-stripping` phase happens before (fixes #32648). The features that must actually be checked before expansion are now checked at the time they are used. This also allows us to check attributes that are generated by macro expansion and not visible to MacroVisitor, but are also removed by macro expansion and thus not visible to PostExpansionVisitor either. This fixes #32782. Note that in order for `#[derive_*]` to be feature-gated but still accepted when generated by `#[derive(Trait)]`, I had to do a little bit of trickery with spans that I'm not totally confident into. Please review that part carefully. (It's in `libsyntax_ext/deriving/mod.rs`.)::\n\nNote: this is a [breaking change], since programs with feature-gated attributes on macro-generated macro invocations were not rejected before. For example:\n\n```rust\nmacro_rules! bar (\n    () => ()\n);\n\nmacro_rules! foo (\n    () => (\n        #[allow_internal_unstable] //~ ERROR allow_internal_unstable side-steps\n        bar!();\n    );\n);\n```\nfoo!();", "tree": {"sha": "ec6af6c540c2beeb3cd5a753defca961154a61e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec6af6c540c2beeb3cd5a753defca961154a61e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/435095f32af93d27baf1390fa34e7dfff5eb7d5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/435095f32af93d27baf1390fa34e7dfff5eb7d5d", "html_url": "https://github.com/rust-lang/rust/commit/435095f32af93d27baf1390fa34e7dfff5eb7d5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/435095f32af93d27baf1390fa34e7dfff5eb7d5d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cda7c1cf2463443aee4a2f51a5141bc7ce4a4f97", "url": "https://api.github.com/repos/rust-lang/rust/commits/cda7c1cf2463443aee4a2f51a5141bc7ce4a4f97", "html_url": "https://github.com/rust-lang/rust/commit/cda7c1cf2463443aee4a2f51a5141bc7ce4a4f97"}, {"sha": "fa23d108638b7117e84c99a8d36a9dbab7b56812", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa23d108638b7117e84c99a8d36a9dbab7b56812", "html_url": "https://github.com/rust-lang/rust/commit/fa23d108638b7117e84c99a8d36a9dbab7b56812"}], "stats": {"total": 1301, "additions": 625, "deletions": 676}, "files": [{"sha": "d39bcd0fbb2bbd273be70a4ceaf1a36391ee0abc", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=435095f32af93d27baf1390fa34e7dfff5eb7d5d", "patch": "@@ -528,19 +528,13 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         middle::recursion_limit::update_recursion_limit(sess, &krate);\n     });\n \n-    time(time_passes, \"gated macro checking\", || {\n-        sess.track_errors(|| {\n-            let features =\n-              syntax::feature_gate::check_crate_macros(sess.codemap(),\n-                                                       &sess.parse_sess.span_diagnostic,\n-                                                       &krate);\n-\n-            // these need to be set \"early\" so that expansion sees `quote` if enabled.\n-            *sess.features.borrow_mut() = features;\n-        })\n+    // these need to be set \"early\" so that expansion sees `quote` if enabled.\n+    sess.track_errors(|| {\n+        *sess.features.borrow_mut() =\n+            syntax::feature_gate::get_features(&sess.parse_sess.span_diagnostic,\n+                                               &krate);\n     })?;\n \n-\n     krate = time(time_passes, \"crate injection\", || {\n         syntax::std_inject::maybe_inject_crates_ref(krate, sess.opts.alt_std_name.clone())\n     });"}, {"sha": "036e46c380398650385e9565e8ab9a719c1336a4", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=435095f32af93d27baf1390fa34e7dfff5eb7d5d", "patch": "@@ -51,27 +51,32 @@ pub fn load_plugins(sess: &Session,\n                     addl_plugins: Option<Vec<String>>) -> Vec<PluginRegistrar> {\n     let mut loader = PluginLoader::new(sess, cstore, crate_name);\n \n-    for attr in &krate.attrs {\n-        if !attr.check_name(\"plugin\") {\n-            continue;\n-        }\n-\n-        let plugins = match attr.meta_item_list() {\n-            Some(xs) => xs,\n-            None => {\n-                call_malformed_plugin_attribute(sess, attr.span);\n+    // do not report any error now. since crate attributes are\n+    // not touched by expansion, every use of plugin without\n+    // the feature enabled will result in an error later...\n+    if sess.features.borrow().plugin {\n+        for attr in &krate.attrs {\n+            if !attr.check_name(\"plugin\") {\n                 continue;\n             }\n-        };\n \n-        for plugin in plugins {\n-            if plugin.value_str().is_some() {\n-                call_malformed_plugin_attribute(sess, attr.span);\n-                continue;\n+            let plugins = match attr.meta_item_list() {\n+                Some(xs) => xs,\n+                None => {\n+                    call_malformed_plugin_attribute(sess, attr.span);\n+                    continue;\n+                }\n+            };\n+\n+            for plugin in plugins {\n+                if plugin.value_str().is_some() {\n+                    call_malformed_plugin_attribute(sess, attr.span);\n+                    continue;\n+                }\n+\n+                let args = plugin.meta_item_list().map(ToOwned::to_owned).unwrap_or_default();\n+                loader.load_plugin(plugin.span, &plugin.name(), args);\n             }\n-\n-            let args = plugin.meta_item_list().map(ToOwned::to_owned).unwrap_or_default();\n-            loader.load_plugin(plugin.span, &plugin.name(), args);\n         }\n     }\n "}, {"sha": "57500f92b79d8281be76f41274d2f0bc7b82491a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 37, "deletions": 30, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=435095f32af93d27baf1390fa34e7dfff5eb7d5d", "patch": "@@ -35,13 +35,26 @@ use std_inject;\n use std::collections::HashSet;\n use std::env;\n \n+// this function is called to detect use of feature-gated or invalid attributes\n+// on macro invoations since they will not be detected after macro expansion\n+fn check_attributes(attrs: &[ast::Attribute], fld: &MacroExpander) {\n+    for attr in attrs.iter() {\n+        feature_gate::check_attribute(&attr, &fld.cx.parse_sess.span_diagnostic,\n+                                      &fld.cx.parse_sess.codemap(),\n+                                      &fld.cx.ecfg.features.unwrap());\n+    }\n+}\n+\n pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n     let expr_span = e.span;\n     return e.and_then(|ast::Expr {id, node, span, attrs}| match node {\n \n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n         ast::ExprKind::Mac(mac) => {\n+            if let Some(ref attrs) = attrs {\n+                check_attributes(attrs, fld);\n+            }\n \n             // Assert that we drop any macro attributes on the floor here\n             drop(attrs);\n@@ -70,10 +83,12 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n \n         ast::ExprKind::InPlace(placer, value_expr) => {\n             // Ensure feature-gate is enabled\n-            feature_gate::check_for_placement_in(\n-                fld.cx.ecfg.features,\n-                &fld.cx.parse_sess.span_diagnostic,\n-                expr_span);\n+            if !fld.cx.ecfg.features.unwrap().placement_in_syntax {\n+                feature_gate::emit_feature_err(\n+                    &fld.cx.parse_sess.span_diagnostic, \"placement_in_syntax\", expr_span,\n+                    feature_gate::GateIssue::Language, feature_gate::EXPLAIN_PLACEMENT_IN\n+                );\n+            }\n \n             let placer = fld.fold_expr(placer);\n             let value_expr = fld.fold_expr(value_expr);\n@@ -370,6 +385,8 @@ pub fn expand_item_mac(it: P<ast::Item>,\n         _ => fld.cx.span_bug(it.span, \"invalid item macro invocation\")\n     });\n \n+    check_attributes(&attrs, fld);\n+\n     let fm = fresh_mark();\n     let items = {\n         let expanded = match fld.cx.syntax_env.find(extname) {\n@@ -444,18 +461,6 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     let allow_internal_unstable = attr::contains_name(&attrs,\n                                                                       \"allow_internal_unstable\");\n \n-                    // ensure any #[allow_internal_unstable]s are\n-                    // detected (including nested macro definitions\n-                    // etc.)\n-                    if allow_internal_unstable && !fld.cx.ecfg.enable_allow_internal_unstable() {\n-                        feature_gate::emit_feature_err(\n-                            &fld.cx.parse_sess.span_diagnostic,\n-                            \"allow_internal_unstable\",\n-                            span,\n-                            feature_gate::GateIssue::Language,\n-                            feature_gate::EXPLAIN_ALLOW_INTERNAL_UNSTABLE)\n-                    }\n-\n                     let export = attr::contains_name(&attrs, \"macro_export\");\n                     let def = ast::MacroDef {\n                         ident: ident,\n@@ -519,6 +524,10 @@ fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n         _ => return expand_non_macro_stmt(stmt, fld)\n     };\n \n+    if let Some(ref attrs) = attrs {\n+        check_attributes(attrs, fld);\n+    }\n+\n     // Assert that we drop any macro attributes on the floor here\n     drop(attrs);\n \n@@ -1066,7 +1075,7 @@ fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n             attrs: ii.attrs,\n             vis: ii.vis,\n             defaultness: ii.defaultness,\n-            node: match ii.node  {\n+            node: match ii.node {\n                 ast::ImplItemKind::Method(sig, body) => {\n                     let (sig, body) = expand_and_rename_method(sig, body, fld);\n                     ast::ImplItemKind::Method(sig, body)\n@@ -1075,13 +1084,11 @@ fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n             },\n             span: fld.new_span(ii.span)\n         }),\n-        ast::ImplItemKind::Macro(_) => {\n-            let (span, mac) = match ii.node {\n-                ast::ImplItemKind::Macro(mac) => (ii.span, mac),\n-                _ => unreachable!()\n-            };\n+        ast::ImplItemKind::Macro(mac) => {\n+            check_attributes(&ii.attrs, fld);\n+\n             let maybe_new_items =\n-                expand_mac_invoc(mac, span,\n+                expand_mac_invoc(mac, ii.span,\n                                  |r| r.make_impl_items(),\n                                  |meths, mark| meths.move_map(|m| mark_impl_item(m, mark)),\n                                  fld);\n@@ -1348,14 +1355,14 @@ impl<'feat> ExpansionConfig<'feat> {\n     }\n \n     feature_tests! {\n-        fn enable_quotes = allow_quote,\n-        fn enable_asm = allow_asm,\n-        fn enable_log_syntax = allow_log_syntax,\n-        fn enable_concat_idents = allow_concat_idents,\n-        fn enable_trace_macros = allow_trace_macros,\n+        fn enable_quotes = quote,\n+        fn enable_asm = asm,\n+        fn enable_log_syntax = log_syntax,\n+        fn enable_concat_idents = concat_idents,\n+        fn enable_trace_macros = trace_macros,\n         fn enable_allow_internal_unstable = allow_internal_unstable,\n-        fn enable_custom_derive = allow_custom_derive,\n-        fn enable_pushpop_unsafe = allow_pushpop_unsafe,\n+        fn enable_custom_derive = custom_derive,\n+        fn enable_pushpop_unsafe = pushpop_unsafe,\n     }\n }\n "}, {"sha": "ed2371fc34823badde1b22da5a32af02c1f001eb", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 425, "deletions": 549, "changes": 974, "blob_url": "https://github.com/rust-lang/rust/blob/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=435095f32af93d27baf1390fa34e7dfff5eb7d5d", "patch": "@@ -22,7 +22,6 @@\n //! gate usage is added, *do not remove it again* even once the feature\n //! becomes stable.\n \n-use self::Status::*;\n use self::AttributeType::*;\n use self::AttributeGate::*;\n \n@@ -40,238 +39,318 @@ use parse::token::InternedString;\n use std::ascii::AsciiExt;\n use std::cmp;\n \n+macro_rules! setter {\n+    ($field: ident) => {{\n+        fn f(features: &mut Features) -> &mut bool {\n+            &mut features.$field\n+        }\n+        f as fn(&mut Features) -> &mut bool\n+    }}\n+}\n+\n+macro_rules! declare_features {\n+    ($((active, $feature: ident, $ver: expr, $issue: expr)),+) => {\n+        /// Represents active features that are currently being implemented or\n+        /// currently being considered for addition/removal.\n+        const ACTIVE_FEATURES: &'static [(&'static str, &'static str,\n+                                          Option<u32>, fn(&mut Features) -> &mut bool)] = &[\n+            $((stringify!($feature), $ver, $issue, setter!($feature))),+\n+        ];\n+\n+        /// A set of features to be used by later passes.\n+        pub struct Features {\n+            /// spans of #![feature] attrs for stable language features. for error reporting\n+            pub declared_stable_lang_features: Vec<Span>,\n+            /// #![feature] attrs for non-language (library) features\n+            pub declared_lib_features: Vec<(InternedString, Span)>,\n+            $(pub $feature: bool),+\n+        }\n+\n+        impl Features {\n+            pub fn new() -> Features {\n+                Features {\n+                    declared_stable_lang_features: Vec::new(),\n+                    declared_lib_features: Vec::new(),\n+                    $($feature: false),+\n+                }\n+            }\n+        }\n+    };\n+\n+    ($((removed, $feature: ident, $ver: expr, $issue: expr)),+) => {\n+        /// Represents features which has since been removed (it was once Active)\n+        const REMOVED_FEATURES: &'static [(&'static str, &'static str, Option<u32>)] = &[\n+            $((stringify!($feature), $ver, $issue)),+\n+        ];\n+    };\n+\n+    ($((accepted, $feature: ident, $ver: expr, $issue: expr)),+) => {\n+        /// Those language feature has since been Accepted (it was once Active)\n+        const ACCEPTED_FEATURES: &'static [(&'static str, &'static str, Option<u32>)] = &[\n+            $((stringify!($feature), $ver, $issue)),+\n+        ];\n+    }\n+}\n+\n // If you change this list without updating src/doc/reference.md, @cmr will be sad\n // Don't ever remove anything from this list; set them to 'Removed'.\n // The version numbers here correspond to the version in which the current status\n // was set. This is most important for knowing when a particular feature became\n // stable (active).\n-// NB: The tidy tool parses this information directly out of the source so take\n-// care when modifying it.\n-const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status)] = &[\n-    (\"globs\", \"1.0.0\", None, Accepted),\n-    (\"macro_rules\", \"1.0.0\", None, Accepted),\n-    (\"struct_variant\", \"1.0.0\", None, Accepted),\n-    (\"asm\", \"1.0.0\", Some(29722), Active),\n-    (\"managed_boxes\", \"1.0.0\", None, Removed),\n-    (\"non_ascii_idents\", \"1.0.0\", Some(28979), Active),\n-    (\"thread_local\", \"1.0.0\", Some(29594), Active),\n-    (\"link_args\", \"1.0.0\", Some(29596), Active),\n-    (\"plugin_registrar\", \"1.0.0\", Some(29597), Active),\n-    (\"log_syntax\", \"1.0.0\", Some(29598), Active),\n-    (\"trace_macros\", \"1.0.0\", Some(29598), Active),\n-    (\"concat_idents\", \"1.0.0\", Some(29599), Active),\n+// NB: The featureck.py script parses this information directly out of the source\n+// so take care when modifying it.\n+\n+declare_features! (\n+    (active, asm, \"1.0.0\", Some(29722)),\n+    (active, concat_idents, \"1.0.0\", Some(29599)),\n+    (active, link_args, \"1.0.0\", Some(29596)),\n+    (active, log_syntax, \"1.0.0\", Some(29598)),\n+    (active, non_ascii_idents, \"1.0.0\", Some(28979)),\n+    (active, plugin_registrar, \"1.0.0\", Some(29597)),\n+    (active, thread_local, \"1.0.0\", Some(29594)),\n+    (active, trace_macros, \"1.0.0\", Some(29598)),\n \n     // rustc internal, for now:\n-    (\"intrinsics\", \"1.0.0\", None, Active),\n-    (\"lang_items\", \"1.0.0\", None, Active),\n+    (active, intrinsics, \"1.0.0\", None),\n+    (active, lang_items, \"1.0.0\", None),\n \n-    (\"simd\", \"1.0.0\", Some(27731), Active),\n-    (\"default_type_params\", \"1.0.0\", None, Accepted),\n-    (\"quote\", \"1.0.0\", Some(29601), Active),\n-    (\"link_llvm_intrinsics\", \"1.0.0\", Some(29602), Active),\n-    (\"linkage\", \"1.0.0\", Some(29603), Active),\n-    (\"struct_inherit\", \"1.0.0\", None, Removed),\n+    (active, link_llvm_intrinsics, \"1.0.0\", Some(29602)),\n+    (active, linkage, \"1.0.0\", Some(29603)),\n+    (active, quote, \"1.0.0\", Some(29601)),\n+    (active, simd, \"1.0.0\", Some(27731)),\n \n-    (\"quad_precision_float\", \"1.0.0\", None, Removed),\n \n     // rustc internal\n-    (\"rustc_diagnostic_macros\", \"1.0.0\", None, Active),\n-    (\"unboxed_closures\", \"1.0.0\", Some(29625), Active),\n-    (\"reflect\", \"1.0.0\", Some(27749), Active),\n-    (\"import_shadowing\", \"1.0.0\", None, Removed),\n-    (\"advanced_slice_patterns\", \"1.0.0\", Some(23121), Active),\n-    (\"tuple_indexing\", \"1.0.0\", None, Accepted),\n-    (\"associated_types\", \"1.0.0\", None, Accepted),\n-    (\"visible_private_types\", \"1.0.0\", None, Removed),\n-    (\"slicing_syntax\", \"1.0.0\", None, Accepted),\n-    (\"box_syntax\", \"1.0.0\", Some(27779), Active),\n-    (\"placement_in_syntax\", \"1.0.0\", Some(27779), Active),\n+    (active, rustc_diagnostic_macros, \"1.0.0\", None),\n+    (active, advanced_slice_patterns, \"1.0.0\", Some(23121)),\n+    (active, box_syntax, \"1.0.0\", Some(27779)),\n+    (active, placement_in_syntax, \"1.0.0\", Some(27779)),\n+    (active, reflect, \"1.0.0\", Some(27749)),\n+    (active, unboxed_closures, \"1.0.0\", Some(29625)),\n \n     // rustc internal.\n-    (\"pushpop_unsafe\", \"1.2.0\", None, Active),\n-\n-    (\"on_unimplemented\", \"1.0.0\", Some(29628), Active),\n-    (\"simd_ffi\", \"1.0.0\", Some(27731), Active),\n-    (\"allocator\", \"1.0.0\", Some(27389), Active),\n-    (\"needs_allocator\", \"1.4.0\", Some(27389), Active),\n-    (\"linked_from\", \"1.3.0\", Some(29629), Active),\n-\n-    (\"if_let\", \"1.0.0\", None, Accepted),\n-    (\"while_let\", \"1.0.0\", None, Accepted),\n-\n-    (\"plugin\", \"1.0.0\", Some(29597), Active),\n-    (\"start\", \"1.0.0\", Some(29633), Active),\n-    (\"main\", \"1.0.0\", Some(29634), Active),\n-\n-    (\"fundamental\", \"1.0.0\", Some(29635), Active),\n-\n-    // A temporary feature gate used to enable parser extensions needed\n-    // to bootstrap fix for #5723.\n-    (\"issue_5723_bootstrap\", \"1.0.0\", None, Accepted),\n-\n-    (\"structural_match\", \"1.8.0\", Some(31434), Active),\n-\n-    // A way to temporarily opt out of opt in copy. This will *never* be accepted.\n-    (\"opt_out_copy\", \"1.0.0\", None, Removed),\n+    (active, pushpop_unsafe, \"1.2.0\", None),\n+\n+    (active, allocator, \"1.0.0\", Some(27389)),\n+    (active, fundamental, \"1.0.0\", Some(29635)),\n+    (active, linked_from, \"1.3.0\", Some(29629)),\n+    (active, main, \"1.0.0\", Some(29634)),\n+    (active, needs_allocator, \"1.4.0\", Some(27389)),\n+    (active, on_unimplemented, \"1.0.0\", Some(29628)),\n+    (active, plugin, \"1.0.0\", Some(29597)),\n+    (active, simd_ffi, \"1.0.0\", Some(27731)),\n+    (active, start, \"1.0.0\", Some(29633)),\n+    (active, structural_match, \"1.8.0\", Some(31434)),\n \n     // OIBIT specific features\n-    (\"optin_builtin_traits\", \"1.0.0\", Some(13231), Active),\n+    (active, optin_builtin_traits, \"1.0.0\", Some(13231)),\n \n     // macro reexport needs more discussion and stabilization\n-    (\"macro_reexport\", \"1.0.0\", Some(29638), Active),\n-\n-    // These are used to test this portion of the compiler, they don't actually\n-    // mean anything\n-    (\"test_accepted_feature\", \"1.0.0\", None, Accepted),\n-    (\"test_removed_feature\", \"1.0.0\", None, Removed),\n+    (active, macro_reexport, \"1.0.0\", Some(29638)),\n \n     // Allows use of #[staged_api]\n     // rustc internal\n-    (\"staged_api\", \"1.0.0\", None, Active),\n+    (active, staged_api, \"1.0.0\", None),\n \n     // Allows using items which are missing stability attributes\n     // rustc internal\n-    (\"unmarked_api\", \"1.0.0\", None, Active),\n-\n-    // Allows using #![no_std]\n-    (\"no_std\", \"1.0.0\", None, Accepted),\n+    (active, unmarked_api, \"1.0.0\", None),\n \n     // Allows using #![no_core]\n-    (\"no_core\", \"1.3.0\", Some(29639), Active),\n+    (active, no_core, \"1.3.0\", Some(29639)),\n \n     // Allows using `box` in patterns; RFC 469\n-    (\"box_patterns\", \"1.0.0\", Some(29641), Active),\n+    (active, box_patterns, \"1.0.0\", Some(29641)),\n \n     // Allows using the unsafe_no_drop_flag attribute (unlikely to\n     // switch to Accepted; see RFC 320)\n-    (\"unsafe_no_drop_flag\", \"1.0.0\", None, Active),\n+    (active, unsafe_no_drop_flag, \"1.0.0\", None),\n \n     // Allows using the unsafe_destructor_blind_to_params attribute;\n     // RFC 1238\n-    (\"dropck_parametricity\", \"1.3.0\", Some(28498), Active),\n+    (active, dropck_parametricity, \"1.3.0\", Some(28498)),\n \n     // Allows the use of custom attributes; RFC 572\n-    (\"custom_attribute\", \"1.0.0\", Some(29642), Active),\n+    (active, custom_attribute, \"1.0.0\", Some(29642)),\n \n     // Allows the use of #[derive(Anything)] as sugar for\n     // #[derive_Anything].\n-    (\"custom_derive\", \"1.0.0\", Some(29644), Active),\n+    (active, custom_derive, \"1.0.0\", Some(29644)),\n \n     // Allows the use of rustc_* attributes; RFC 572\n-    (\"rustc_attrs\", \"1.0.0\", Some(29642), Active),\n+    (active, rustc_attrs, \"1.0.0\", Some(29642)),\n \n     // Allows the use of #[allow_internal_unstable]. This is an\n     // attribute on macro_rules! and can't use the attribute handling\n     // below (it has to be checked before expansion possibly makes\n     // macros disappear).\n     //\n     // rustc internal\n-    (\"allow_internal_unstable\", \"1.0.0\", None, Active),\n+    (active, allow_internal_unstable, \"1.0.0\", None),\n \n     // #23121. Array patterns have some hazards yet.\n-    (\"slice_patterns\", \"1.0.0\", Some(23121), Active),\n-\n-    // Allows use of unary negate on unsigned integers, e.g. -e for e: u8\n-    (\"negate_unsigned\", \"1.0.0\", Some(29645), Removed),\n+    (active, slice_patterns, \"1.0.0\", Some(23121)),\n \n     // Allows the definition of associated constants in `trait` or `impl`\n     // blocks.\n-    (\"associated_consts\", \"1.0.0\", Some(29646), Active),\n+    (active, associated_consts, \"1.0.0\", Some(29646)),\n \n     // Allows the definition of `const fn` functions.\n-    (\"const_fn\", \"1.2.0\", Some(24111), Active),\n+    (active, const_fn, \"1.2.0\", Some(24111)),\n \n     // Allows indexing into constant arrays.\n-    (\"const_indexing\", \"1.4.0\", Some(29947), Active),\n+    (active, const_indexing, \"1.4.0\", Some(29947)),\n \n     // Allows using #[prelude_import] on glob `use` items.\n     //\n     // rustc internal\n-    (\"prelude_import\", \"1.2.0\", None, Active),\n+    (active, prelude_import, \"1.2.0\", None),\n \n     // Allows the definition recursive static items.\n-    (\"static_recursion\", \"1.3.0\", Some(29719), Active),\n+    (active, static_recursion, \"1.3.0\", Some(29719)),\n \n     // Allows default type parameters to influence type inference.\n-    (\"default_type_parameter_fallback\", \"1.3.0\", Some(27336), Active),\n+    (active, default_type_parameter_fallback, \"1.3.0\", Some(27336)),\n \n     // Allows associated type defaults\n-    (\"associated_type_defaults\", \"1.2.0\", Some(29661), Active),\n+    (active, associated_type_defaults, \"1.2.0\", Some(29661)),\n \n     // Allows macros to appear in the type position.\n-    (\"type_macros\", \"1.3.0\", Some(27245), Active),\n+    (active, type_macros, \"1.3.0\", Some(27245)),\n \n     // allow `repr(simd)`, and importing the various simd intrinsics\n-    (\"repr_simd\", \"1.4.0\", Some(27731), Active),\n+    (active, repr_simd, \"1.4.0\", Some(27731)),\n \n     // Allows cfg(target_feature = \"...\").\n-    (\"cfg_target_feature\", \"1.4.0\", Some(29717), Active),\n+    (active, cfg_target_feature, \"1.4.0\", Some(29717)),\n \n     // allow `extern \"platform-intrinsic\" { ... }`\n-    (\"platform_intrinsics\", \"1.4.0\", Some(27731), Active),\n+    (active, platform_intrinsics, \"1.4.0\", Some(27731)),\n \n     // allow `#[unwind]`\n     // rust runtime internal\n-    (\"unwind_attributes\", \"1.4.0\", None, Active),\n+    (active, unwind_attributes, \"1.4.0\", None),\n \n     // allow the use of `#[naked]` on functions.\n-    (\"naked_functions\", \"1.9.0\", Some(32408), Active),\n-\n-    // allow empty structs and enum variants with braces\n-    (\"braced_empty_structs\", \"1.8.0\", Some(29720), Accepted),\n-\n-    // allow overloading augmented assignment operations like `a += b`\n-    (\"augmented_assignments\", \"1.8.0\", Some(28235), Accepted),\n+    (active, naked_functions, \"1.9.0\", Some(32408)),\n \n     // allow `#[no_debug]`\n-    (\"no_debug\", \"1.5.0\", Some(29721), Active),\n+    (active, no_debug, \"1.5.0\", Some(29721)),\n \n     // allow `#[omit_gdb_pretty_printer_section]`\n     // rustc internal.\n-    (\"omit_gdb_pretty_printer_section\", \"1.5.0\", None, Active),\n+    (active, omit_gdb_pretty_printer_section, \"1.5.0\", None),\n \n     // Allows cfg(target_vendor = \"...\").\n-    (\"cfg_target_vendor\", \"1.5.0\", Some(29718), Active),\n+    (active, cfg_target_vendor, \"1.5.0\", Some(29718)),\n \n     // Allow attributes on expressions and non-item statements\n-    (\"stmt_expr_attributes\", \"1.6.0\", Some(15701), Active),\n-\n-    // Allows `#[deprecated]` attribute\n-    (\"deprecated\", \"1.9.0\", Some(29935), Accepted),\n+    (active, stmt_expr_attributes, \"1.6.0\", Some(15701)),\n \n     // allow using type ascription in expressions\n-    (\"type_ascription\", \"1.6.0\", Some(23416), Active),\n+    (active, type_ascription, \"1.6.0\", Some(23416)),\n \n     // Allows cfg(target_thread_local)\n-    (\"cfg_target_thread_local\", \"1.7.0\", Some(29594), Active),\n+    (active, cfg_target_thread_local, \"1.7.0\", Some(29594)),\n \n     // rustc internal\n-    (\"abi_vectorcall\", \"1.7.0\", None, Active),\n+    (active, abi_vectorcall, \"1.7.0\", None),\n \n     // a...b and ...b\n-    (\"inclusive_range_syntax\", \"1.7.0\", Some(28237), Active),\n+    (active, inclusive_range_syntax, \"1.7.0\", Some(28237)),\n \n     // `expr?`\n-    (\"question_mark\", \"1.9.0\", Some(31436), Active),\n+    (active, question_mark, \"1.9.0\", Some(31436)),\n \n     // impl specialization (RFC 1210)\n-    (\"specialization\", \"1.7.0\", Some(31844), Active),\n+    (active, specialization, \"1.7.0\", Some(31844)),\n \n     // pub(restricted) visibilities (RFC 1422)\n-    (\"pub_restricted\", \"1.9.0\", Some(32409), Active),\n-];\n+    (active, pub_restricted, \"1.9.0\", Some(32409))\n+);\n+\n+declare_features! (\n+    (removed, import_shadowing, \"1.0.0\", None),\n+    (removed, managed_boxes, \"1.0.0\", None),\n+    // Allows use of unary negate on unsigned integers, e.g. -e for e: u8\n+    (removed, negate_unsigned, \"1.0.0\", Some(29645)),\n+    // A way to temporarily opt out of opt in copy. This will *never* be accepted.\n+    (removed, opt_out_copy, \"1.0.0\", None),\n+    (removed, quad_precision_float, \"1.0.0\", None),\n+    (removed, struct_inherit, \"1.0.0\", None),\n+    (removed, test_removed_feature, \"1.0.0\", None),\n+    (removed, visible_private_types, \"1.0.0\", None)\n+);\n+\n+declare_features! (\n+    (accepted, associated_types, \"1.0.0\", None),\n+    // allow overloading augmented assignment operations like `a += b`\n+    (accepted, augmented_assignments, \"1.8.0\", Some(28235)),\n+    // allow empty structs and enum variants with braces\n+    (accepted, braced_empty_structs, \"1.8.0\", Some(29720)),\n+    (accepted, default_type_params, \"1.0.0\", None),\n+    (accepted, globs, \"1.0.0\", None),\n+    (accepted, if_let, \"1.0.0\", None),\n+    // A temporary feature gate used to enable parser extensions needed\n+    // to bootstrap fix for #5723.\n+    (accepted, issue_5723_bootstrap, \"1.0.0\", None),\n+    (accepted, macro_rules, \"1.0.0\", None),\n+    // Allows using #![no_std]\n+    (accepted, no_std, \"1.0.0\", None),\n+    (accepted, slicing_syntax, \"1.0.0\", None),\n+    (accepted, struct_variant, \"1.0.0\", None),\n+    // These are used to test this portion of the compiler, they don't actually\n+    // mean anything\n+    (accepted, test_accepted_feature, \"1.0.0\", None),\n+    (accepted, tuple_indexing, \"1.0.0\", None),\n+    (accepted, while_let, \"1.0.0\", None),\n+    // Allows `#[deprecated]` attribute\n+    (accepted, deprecated, \"1.9.0\", Some(29935))\n+);\n+\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n-enum Status {\n-    /// Represents an active feature that is currently being implemented or\n-    /// currently being considered for addition/removal.\n-    Active,\n+#[derive(PartialEq, Copy, Clone, Debug)]\n+pub enum AttributeType {\n+    /// Normal, builtin attribute that is consumed\n+    /// by the compiler before the unused_attribute check\n+    Normal,\n \n-    /// Represents a feature which has since been removed (it was once Active)\n-    Removed,\n+    /// Builtin attribute that may not be consumed by the compiler\n+    /// before the unused_attribute check. These attributes\n+    /// will be ignored by the unused_attribute lint\n+    Whitelisted,\n \n-    /// This language feature has since been Accepted (it was once Active)\n-    Accepted,\n+    /// Builtin attribute that is only allowed at the crate level\n+    CrateLevel,\n+}\n+\n+pub enum AttributeGate {\n+    /// Is gated by a given feature gate, reason\n+    /// and function to check if enabled\n+    Gated(&'static str, &'static str, fn(&Features) -> bool),\n+\n+    /// Ungated attribute, can be used on all release channels\n+    Ungated,\n+}\n+\n+// fn() is not Debug\n+impl ::std::fmt::Debug for AttributeGate {\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+        match *self {\n+            Gated(ref name, ref expl, _) => write!(fmt, \"Gated({}, {})\", name, expl),\n+            Ungated => write!(fmt, \"Ungated\")\n+        }\n+    }\n+}\n+\n+macro_rules! cfg_fn {\n+    ($field: ident) => {{\n+        fn f(features: &Features) -> bool {\n+            features.$field\n+        }\n+        f as fn(&Features) -> bool\n+    }}\n }\n \n // Attributes that have a special meaning to rustc or rustdoc\n@@ -312,88 +391,112 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n     // RFC #1445.\n     (\"structural_match\", Whitelisted, Gated(\"structural_match\",\n                                             \"the semantics of constant patterns is \\\n-                                             not yet settled\")),\n+                                             not yet settled\",\n+                                            cfg_fn!(structural_match))),\n \n     // Not used any more, but we can't feature gate it\n     (\"no_stack_check\", Normal, Ungated),\n \n     (\"plugin\", CrateLevel, Gated(\"plugin\",\n                                  \"compiler plugins are experimental \\\n-                                  and possibly buggy\")),\n+                                  and possibly buggy\",\n+                                 cfg_fn!(plugin))),\n+\n     (\"no_std\", CrateLevel, Ungated),\n     (\"no_core\", CrateLevel, Gated(\"no_core\",\n-                                  \"no_core is experimental\")),\n+                                  \"no_core is experimental\",\n+                                  cfg_fn!(no_core))),\n     (\"lang\", Normal, Gated(\"lang_items\",\n-                           \"language items are subject to change\")),\n+                           \"language items are subject to change\",\n+                           cfg_fn!(lang_items))),\n     (\"linkage\", Whitelisted, Gated(\"linkage\",\n                                    \"the `linkage` attribute is experimental \\\n-                                    and not portable across platforms\")),\n+                                    and not portable across platforms\",\n+                                   cfg_fn!(linkage))),\n     (\"thread_local\", Whitelisted, Gated(\"thread_local\",\n                                         \"`#[thread_local]` is an experimental feature, and does \\\n                                          not currently handle destructors. There is no \\\n                                          corresponding `#[task_local]` mapping to the task \\\n-                                         model\")),\n+                                         model\",\n+                                        cfg_fn!(thread_local))),\n \n     (\"rustc_on_unimplemented\", Normal, Gated(\"on_unimplemented\",\n                                              \"the `#[rustc_on_unimplemented]` attribute \\\n-                                              is an experimental feature\")),\n+                                              is an experimental feature\",\n+                                             cfg_fn!(on_unimplemented))),\n     (\"allocator\", Whitelisted, Gated(\"allocator\",\n-                                     \"the `#[allocator]` attribute is an experimental feature\")),\n+                                     \"the `#[allocator]` attribute is an experimental feature\",\n+                                     cfg_fn!(allocator))),\n     (\"needs_allocator\", Normal, Gated(\"needs_allocator\",\n                                       \"the `#[needs_allocator]` \\\n                                        attribute is an experimental \\\n-                                       feature\")),\n+                                       feature\",\n+                                      cfg_fn!(needs_allocator))),\n     (\"rustc_variance\", Normal, Gated(\"rustc_attrs\",\n                                      \"the `#[rustc_variance]` attribute \\\n                                       is just used for rustc unit tests \\\n-                                      and will never be stable\")),\n+                                      and will never be stable\",\n+                                     cfg_fn!(rustc_attrs))),\n     (\"rustc_error\", Whitelisted, Gated(\"rustc_attrs\",\n                                        \"the `#[rustc_error]` attribute \\\n                                         is just used for rustc unit tests \\\n-                                        and will never be stable\")),\n+                                        and will never be stable\",\n+                                       cfg_fn!(rustc_attrs))),\n     (\"rustc_if_this_changed\", Whitelisted, Gated(\"rustc_attrs\",\n-                                       \"the `#[rustc_if_this_changed]` attribute \\\n-                                        is just used for rustc unit tests \\\n-                                        and will never be stable\")),\n+                                                 \"the `#[rustc_if_this_changed]` attribute \\\n+                                                  is just used for rustc unit tests \\\n+                                                  and will never be stable\",\n+                                                 cfg_fn!(rustc_attrs))),\n     (\"rustc_then_this_would_need\", Whitelisted, Gated(\"rustc_attrs\",\n-                                       \"the `#[rustc_if_this_changed]` attribute \\\n-                                        is just used for rustc unit tests \\\n-                                        and will never be stable\")),\n+                                                      \"the `#[rustc_if_this_changed]` attribute \\\n+                                                       is just used for rustc unit tests \\\n+                                                       and will never be stable\",\n+                                                      cfg_fn!(rustc_attrs))),\n     (\"rustc_dirty\", Whitelisted, Gated(\"rustc_attrs\",\n                                        \"the `#[rustc_dirty]` attribute \\\n                                         is just used for rustc unit tests \\\n-                                        and will never be stable\")),\n+                                        and will never be stable\",\n+                                       cfg_fn!(rustc_attrs))),\n     (\"rustc_clean\", Whitelisted, Gated(\"rustc_attrs\",\n                                        \"the `#[rustc_clean]` attribute \\\n                                         is just used for rustc unit tests \\\n-                                        and will never be stable\")),\n+                                        and will never be stable\",\n+                                       cfg_fn!(rustc_attrs))),\n     (\"rustc_symbol_name\", Whitelisted, Gated(\"rustc_attrs\",\n-                                       \"internal rustc attributes will never be stable\")),\n+                                             \"internal rustc attributes will never be stable\",\n+                                             cfg_fn!(rustc_attrs))),\n     (\"rustc_item_path\", Whitelisted, Gated(\"rustc_attrs\",\n-                                       \"internal rustc attributes will never be stable\")),\n+                                           \"internal rustc attributes will never be stable\",\n+                                           cfg_fn!(rustc_attrs))),\n     (\"rustc_move_fragments\", Normal, Gated(\"rustc_attrs\",\n                                            \"the `#[rustc_move_fragments]` attribute \\\n                                             is just used for rustc unit tests \\\n-                                            and will never be stable\")),\n+                                            and will never be stable\",\n+                                           cfg_fn!(rustc_attrs))),\n     (\"rustc_mir\", Whitelisted, Gated(\"rustc_attrs\",\n                                      \"the `#[rustc_mir]` attribute \\\n                                       is just used for rustc unit tests \\\n-                                      and will never be stable\")),\n+                                      and will never be stable\",\n+                                     cfg_fn!(rustc_attrs))),\n     (\"rustc_no_mir\", Whitelisted, Gated(\"rustc_attrs\",\n                                         \"the `#[rustc_no_mir]` attribute \\\n                                          is just used to make tests pass \\\n-                                         and will never be stable\")),\n+                                         and will never be stable\",\n+                                        cfg_fn!(rustc_attrs))),\n \n     (\"allow_internal_unstable\", Normal, Gated(\"allow_internal_unstable\",\n-                                              EXPLAIN_ALLOW_INTERNAL_UNSTABLE)),\n+                                              EXPLAIN_ALLOW_INTERNAL_UNSTABLE,\n+                                              cfg_fn!(allow_internal_unstable))),\n \n     (\"fundamental\", Whitelisted, Gated(\"fundamental\",\n                                        \"the `#[fundamental]` attribute \\\n-                                        is an experimental feature\")),\n+                                        is an experimental feature\",\n+                                       cfg_fn!(fundamental))),\n \n     (\"linked_from\", Normal, Gated(\"linked_from\",\n                                   \"the `#[linked_from]` attribute \\\n-                                   is an experimental feature\")),\n+                                   is an experimental feature\",\n+                                  cfg_fn!(linked_from))),\n \n     // FIXME: #14408 whitelist docs since rustdoc looks at them\n     (\"doc\", Whitelisted, Ungated),\n@@ -403,7 +506,8 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n     (\"cold\", Whitelisted, Ungated),\n     (\"naked\", Whitelisted, Gated(\"naked_functions\",\n                                  \"the `#[naked]` attribute \\\n-                                  is an experimental feature\")),\n+                                  is an experimental feature\",\n+                                 cfg_fn!(naked_functions))),\n     (\"export_name\", Whitelisted, Ungated),\n     (\"inline\", Whitelisted, Ungated),\n     (\"link\", Whitelisted, Ungated),\n@@ -413,24 +517,30 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n     (\"no_mangle\", Whitelisted, Ungated),\n     (\"no_debug\", Whitelisted, Gated(\"no_debug\",\n                                     \"the `#[no_debug]` attribute \\\n-                                     is an experimental feature\")),\n+                                     is an experimental feature\",\n+                                    cfg_fn!(no_debug))),\n     (\"omit_gdb_pretty_printer_section\", Whitelisted, Gated(\"omit_gdb_pretty_printer_section\",\n                                                        \"the `#[omit_gdb_pretty_printer_section]` \\\n                                                         attribute is just used for the Rust test \\\n-                                                        suite\")),\n+                                                        suite\",\n+                                                       cfg_fn!(omit_gdb_pretty_printer_section))),\n     (\"unsafe_no_drop_flag\", Whitelisted, Gated(\"unsafe_no_drop_flag\",\n                                                \"unsafe_no_drop_flag has unstable semantics \\\n-                                                and may be removed in the future\")),\n+                                                and may be removed in the future\",\n+                                               cfg_fn!(unsafe_no_drop_flag))),\n     (\"unsafe_destructor_blind_to_params\",\n      Normal,\n      Gated(\"dropck_parametricity\",\n            \"unsafe_destructor_blind_to_params has unstable semantics \\\n-            and may be removed in the future\")),\n-    (\"unwind\", Whitelisted, Gated(\"unwind_attributes\", \"#[unwind] is experimental\")),\n+            and may be removed in the future\",\n+           cfg_fn!(dropck_parametricity))),\n+    (\"unwind\", Whitelisted, Gated(\"unwind_attributes\", \"#[unwind] is experimental\",\n+                                  cfg_fn!(unwind_attributes))),\n \n     // used in resolve\n     (\"prelude_import\", Whitelisted, Gated(\"prelude_import\",\n-                                          \"`#[prelude_import]` is for use by rustc only\")),\n+                                          \"`#[prelude_import]` is for use by rustc only\",\n+                                          cfg_fn!(prelude_import))),\n \n     // FIXME: #14407 these are only looked at on-demand so we can't\n     // guarantee they'll have already been checked\n@@ -441,9 +551,11 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n     (\"deprecated\", Normal, Ungated),\n \n     (\"rustc_paren_sugar\", Normal, Gated(\"unboxed_closures\",\n-                                        \"unboxed_closures are still evolving\")),\n+                                        \"unboxed_closures are still evolving\",\n+                                        cfg_fn!(unboxed_closures))),\n     (\"rustc_reflect_like\", Whitelisted, Gated(\"reflect\",\n-                                              \"defining reflective traits is still evolving\")),\n+                                              \"defining reflective traits is still evolving\",\n+                                              cfg_fn!(reflect))),\n \n     // Crate level attributes\n     (\"crate_name\", CrateLevel, Ungated),\n@@ -456,21 +568,12 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n     (\"recursion_limit\", CrateLevel, Ungated),\n ];\n \n-macro_rules! cfg_fn {\n-    (|$x: ident| $e: expr) => {{\n-        fn f($x: &Features) -> bool {\n-            $e\n-        }\n-        f as fn(&Features) -> bool\n-    }}\n-}\n // cfg(...)'s that are feature gated\n const GATED_CFGS: &'static [(&'static str, &'static str, fn(&Features) -> bool)] = &[\n     // (name in cfg, feature, function to check if the feature is enabled)\n-    (\"target_feature\", \"cfg_target_feature\", cfg_fn!(|x| x.cfg_target_feature)),\n-    (\"target_vendor\", \"cfg_target_vendor\", cfg_fn!(|x| x.cfg_target_vendor)),\n-    (\"target_thread_local\", \"cfg_target_thread_local\",\n-     cfg_fn!(|x| x.cfg_target_thread_local)),\n+    (\"target_feature\", \"cfg_target_feature\", cfg_fn!(cfg_target_feature)),\n+    (\"target_vendor\", \"cfg_target_vendor\", cfg_fn!(cfg_target_vendor)),\n+    (\"target_thread_local\", \"cfg_target_thread_local\", cfg_fn!(cfg_target_thread_local)),\n ];\n \n #[derive(Debug, Eq, PartialEq)]\n@@ -551,172 +654,38 @@ impl GatedCfg {\n     }\n }\n \n-\n-#[derive(PartialEq, Copy, Clone, Debug)]\n-pub enum AttributeType {\n-    /// Normal, builtin attribute that is consumed\n-    /// by the compiler before the unused_attribute check\n-    Normal,\n-\n-    /// Builtin attribute that may not be consumed by the compiler\n-    /// before the unused_attribute check. These attributes\n-    /// will be ignored by the unused_attribute lint\n-    Whitelisted,\n-\n-    /// Builtin attribute that is only allowed at the crate level\n-    CrateLevel,\n-}\n-\n-#[derive(PartialEq, Copy, Clone, Debug)]\n-pub enum AttributeGate {\n-    /// Is gated by a given feature gate and reason\n-    Gated(&'static str, &'static str),\n-\n-    /// Ungated attribute, can be used on all release channels\n-    Ungated,\n-}\n-\n-/// A set of features to be used by later passes.\n-pub struct Features {\n-    pub unboxed_closures: bool,\n-    pub rustc_diagnostic_macros: bool,\n-    pub allow_quote: bool,\n-    pub allow_asm: bool,\n-    pub allow_log_syntax: bool,\n-    pub allow_concat_idents: bool,\n-    pub allow_trace_macros: bool,\n-    pub allow_internal_unstable: bool,\n-    pub allow_custom_derive: bool,\n-    pub allow_placement_in: bool,\n-    pub allow_box: bool,\n-    pub allow_pushpop_unsafe: bool,\n-    pub allow_inclusive_range: bool,\n-    pub simd_ffi: bool,\n-    pub unmarked_api: bool,\n-    /// spans of #![feature] attrs for stable language features. for error reporting\n-    pub declared_stable_lang_features: Vec<Span>,\n-    /// #![feature] attrs for non-language (library) features\n-    pub declared_lib_features: Vec<(InternedString, Span)>,\n-    pub const_fn: bool,\n-    pub const_indexing: bool,\n-    pub static_recursion: bool,\n-    pub default_type_parameter_fallback: bool,\n-    pub rustc_attrs: bool,\n-    pub type_macros: bool,\n-    pub cfg_target_feature: bool,\n-    pub cfg_target_vendor: bool,\n-    pub cfg_target_thread_local: bool,\n-    pub staged_api: bool,\n-    pub stmt_expr_attributes: bool,\n-    pub deprecated: bool,\n-    pub question_mark: bool,\n-    pub specialization: bool,\n-    pub pub_restricted: bool,\n-}\n-\n-impl Features {\n-    pub fn new() -> Features {\n-        Features {\n-            unboxed_closures: false,\n-            rustc_diagnostic_macros: false,\n-            allow_quote: false,\n-            allow_asm: false,\n-            allow_log_syntax: false,\n-            allow_concat_idents: false,\n-            allow_trace_macros: false,\n-            allow_internal_unstable: false,\n-            allow_custom_derive: false,\n-            allow_placement_in: false,\n-            allow_box: false,\n-            allow_pushpop_unsafe: false,\n-            allow_inclusive_range: false,\n-            simd_ffi: false,\n-            unmarked_api: false,\n-            declared_stable_lang_features: Vec::new(),\n-            declared_lib_features: Vec::new(),\n-            const_fn: false,\n-            const_indexing: false,\n-            static_recursion: false,\n-            default_type_parameter_fallback: false,\n-            rustc_attrs: false,\n-            type_macros: false,\n-            cfg_target_feature: false,\n-            cfg_target_vendor: false,\n-            cfg_target_thread_local: false,\n-            staged_api: false,\n-            stmt_expr_attributes: false,\n-            deprecated: false,\n-            question_mark: false,\n-            specialization: false,\n-            pub_restricted: false,\n-        }\n-    }\n-}\n-\n-const EXPLAIN_BOX_SYNTAX: &'static str =\n-    \"box expression syntax is experimental; you can call `Box::new` instead.\";\n-\n-const EXPLAIN_PLACEMENT_IN: &'static str =\n-    \"placement-in expression syntax is experimental and subject to change.\";\n-\n-const EXPLAIN_PUSHPOP_UNSAFE: &'static str =\n-    \"push/pop_unsafe macros are experimental and subject to change.\";\n-\n-const EXPLAIN_STMT_ATTR_SYNTAX: &'static str =\n-    \"attributes on non-item statements and expressions are experimental.\";\n-\n-pub fn check_for_box_syntax(f: Option<&Features>, diag: &Handler, span: Span) {\n-    if let Some(&Features { allow_box: true, .. }) = f {\n-        return;\n-    }\n-    emit_feature_err(diag, \"box_syntax\", span, GateIssue::Language, EXPLAIN_BOX_SYNTAX);\n-}\n-\n-pub fn check_for_placement_in(f: Option<&Features>, diag: &Handler, span: Span) {\n-    if let Some(&Features { allow_placement_in: true, .. }) = f {\n-        return;\n-    }\n-    emit_feature_err(diag, \"placement_in_syntax\", span, GateIssue::Language, EXPLAIN_PLACEMENT_IN);\n-}\n-\n-pub fn check_for_pushpop_syntax(f: Option<&Features>, diag: &Handler, span: Span) {\n-    if let Some(&Features { allow_pushpop_unsafe: true, .. }) = f {\n-        return;\n-    }\n-    emit_feature_err(diag, \"pushpop_unsafe\", span, GateIssue::Language, EXPLAIN_PUSHPOP_UNSAFE);\n-}\n-\n struct Context<'a> {\n-    features: Vec<&'static str>,\n+    features: &'a Features,\n     span_handler: &'a Handler,\n     cm: &'a CodeMap,\n     plugin_attributes: &'a [(String, AttributeType)],\n }\n \n-impl<'a> Context<'a> {\n-    fn enable_feature(&mut self, feature: &'static str) {\n-        debug!(\"enabling feature: {}\", feature);\n-        self.features.push(feature);\n-    }\n-\n-    fn gate_feature(&self, feature: &str, span: Span, explain: &str) {\n-        let has_feature = self.has_feature(feature);\n-        debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", feature, span, has_feature);\n-        if !has_feature && !self.cm.span_allows_unstable(span) {\n-            emit_feature_err(self.span_handler, feature, span, GateIssue::Language, explain);\n+macro_rules! gate_feature_fn {\n+    ($cx: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr) => {{\n+        let (cx, has_feature, span, name, explain) = ($cx, $has_feature, $span, $name, $explain);\n+        let has_feature: bool = has_feature(&$cx.features);\n+        debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", name, span, has_feature);\n+        if !has_feature && !cx.cm.span_allows_unstable(span) {\n+            emit_feature_err(cx.span_handler, name, span, GateIssue::Language, explain);\n         }\n+    }}\n+}\n+\n+macro_rules! gate_feature {\n+    ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {\n+        gate_feature_fn!($cx, |x:&Features| x.$feature, $span, stringify!($feature), $explain)\n     }\n-    fn has_feature(&self, feature: &str) -> bool {\n-        self.features.iter().any(|&n| n == feature)\n-    }\n+}\n \n+impl<'a> Context<'a> {\n     fn check_attribute(&self, attr: &ast::Attribute, is_macro: bool) {\n         debug!(\"check_attribute(attr = {:?})\", attr);\n         let name = &*attr.name();\n-        for &(n, ty, gateage) in KNOWN_ATTRIBUTES {\n+        for &(n, ty, ref gateage) in KNOWN_ATTRIBUTES {\n             if n == name {\n-                if let Gated(gate, desc) = gateage {\n-                    self.gate_feature(gate, attr.span, desc);\n+                if let &Gated(ref name, ref desc, ref has_feature) = gateage {\n+                    gate_feature_fn!(self, has_feature, attr.span, name, desc);\n                 }\n                 debug!(\"check_attribute: {:?} is known, {:?}, {:?}\", name, ty, gateage);\n                 return;\n@@ -732,41 +701,50 @@ impl<'a> Context<'a> {\n             }\n         }\n         if name.starts_with(\"rustc_\") {\n-            self.gate_feature(\"rustc_attrs\", attr.span,\n-                              \"unless otherwise specified, attributes \\\n-                               with the prefix `rustc_` \\\n-                               are reserved for internal compiler diagnostics\");\n+            gate_feature!(self, rustc_attrs, attr.span,\n+                          \"unless otherwise specified, attributes \\\n+                           with the prefix `rustc_` \\\n+                           are reserved for internal compiler diagnostics\");\n         } else if name.starts_with(\"derive_\") {\n-            self.gate_feature(\"custom_derive\", attr.span,\n-                              \"attributes of the form `#[derive_*]` are reserved \\\n-                               for the compiler\");\n+            gate_feature!(self, custom_derive, attr.span, EXPLAIN_DERIVE_UNDERSCORE);\n         } else {\n             // Only run the custom attribute lint during regular\n             // feature gate checking. Macro gating runs\n             // before the plugin attributes are registered\n             // so we skip this then\n             if !is_macro {\n-                self.gate_feature(\"custom_attribute\", attr.span,\n-                           &format!(\"The attribute `{}` is currently \\\n-                                    unknown to the compiler and \\\n-                                    may have meaning \\\n-                                    added to it in the future\",\n-                                    name));\n+                gate_feature!(self, custom_attribute, attr.span,\n+                              &format!(\"The attribute `{}` is currently \\\n+                                        unknown to the compiler and \\\n+                                        may have meaning \\\n+                                        added to it in the future\",\n+                                       name));\n             }\n         }\n     }\n }\n \n+pub fn check_attribute(attr: &ast::Attribute, handler: &Handler,\n+                       cm: &CodeMap, features: &Features) {\n+    let cx = Context {\n+        features: features, span_handler: handler,\n+        cm: cm, plugin_attributes: &[]\n+    };\n+    cx.check_attribute(attr, true);\n+}\n+\n fn find_lang_feature_issue(feature: &str) -> Option<u32> {\n-    let info = KNOWN_FEATURES.iter()\n-                              .find(|t| t.0 == feature)\n-                              .unwrap();\n-    let issue = info.2;\n-    if let Active = info.3 {\n+    if let Some(info) = ACTIVE_FEATURES.iter().find(|t| t.0 == feature) {\n+        let issue = info.2;\n         // FIXME (#28244): enforce that active features have issue numbers\n         // assert!(issue.is_some())\n+        issue\n+    } else {\n+        // search in Accepted or Removed features\n+        ACCEPTED_FEATURES.iter().chain(REMOVED_FEATURES.iter())\n+            .find(|t| t.0 == feature)\n+            .unwrap().2\n     }\n-    issue\n }\n \n pub enum GateIssue {\n@@ -798,6 +776,12 @@ pub fn emit_feature_err(diag: &Handler, feature: &str, span: Span, issue: GateIs\n     err.emit();\n }\n \n+const EXPLAIN_BOX_SYNTAX: &'static str =\n+    \"box expression syntax is experimental; you can call `Box::new` instead.\";\n+\n+const EXPLAIN_STMT_ATTR_SYNTAX: &'static str =\n+    \"attributes on non-item statements and expressions are experimental.\";\n+\n pub const EXPLAIN_ASM: &'static str =\n     \"inline assembly is not stable enough for use and is subject to change\";\n \n@@ -815,75 +799,23 @@ pub const EXPLAIN_ALLOW_INTERNAL_UNSTABLE: &'static str =\n pub const EXPLAIN_CUSTOM_DERIVE: &'static str =\n     \"`#[derive]` for custom traits is not stable enough for use and is subject to change\";\n \n-struct MacroVisitor<'a> {\n-    context: &'a Context<'a>\n-}\n-\n-impl<'a, 'v> Visitor<'v> for MacroVisitor<'a> {\n-    fn visit_mac(&mut self, mac: &ast::Mac) {\n-        let path = &mac.node.path;\n-        let name = path.segments.last().unwrap().identifier.name.as_str();\n-\n-        // Issue 22234: If you add a new case here, make sure to also\n-        // add code to catch the macro during or after expansion.\n-        //\n-        // We still keep this MacroVisitor (rather than *solely*\n-        // relying on catching cases during or after expansion) to\n-        // catch uses of these macros within conditionally-compiled\n-        // code, e.g. `#[cfg]`-guarded functions.\n-\n-        if name == \"asm\" {\n-            self.context.gate_feature(\"asm\", path.span, EXPLAIN_ASM);\n-        }\n-\n-        else if name == \"log_syntax\" {\n-            self.context.gate_feature(\"log_syntax\", path.span, EXPLAIN_LOG_SYNTAX);\n-        }\n-\n-        else if name == \"trace_macros\" {\n-            self.context.gate_feature(\"trace_macros\", path.span, EXPLAIN_TRACE_MACROS);\n-        }\n-\n-        else if name == \"concat_idents\" {\n-            self.context.gate_feature(\"concat_idents\", path.span, EXPLAIN_CONCAT_IDENTS);\n-        }\n-    }\n-\n-    fn visit_attribute(&mut self, attr: &'v ast::Attribute) {\n-        self.context.check_attribute(attr, true);\n-    }\n-\n-    fn visit_expr(&mut self, e: &ast::Expr) {\n-        // Issue 22181: overloaded-`box` and placement-`in` are\n-        // implemented via a desugaring expansion, so their feature\n-        // gates go into MacroVisitor since that works pre-expansion.\n-        //\n-        // Issue 22234: we also check during expansion as well.\n-        // But we keep these checks as a pre-expansion check to catch\n-        // uses in e.g. conditionalized code.\n-\n-        if let ast::ExprKind::Box(_) = e.node {\n-            self.context.gate_feature(\"box_syntax\", e.span, EXPLAIN_BOX_SYNTAX);\n-        }\n-\n-        if let ast::ExprKind::InPlace(..) = e.node {\n-            self.context.gate_feature(\"placement_in_syntax\", e.span, EXPLAIN_PLACEMENT_IN);\n-        }\n+pub const EXPLAIN_DERIVE_UNDERSCORE: &'static str =\n+    \"attributes of the form `#[derive_*]` are reserved for the compiler\";\n \n-        visit::walk_expr(self, e);\n-    }\n-}\n+pub const EXPLAIN_PLACEMENT_IN: &'static str =\n+    \"placement-in expression syntax is experimental and subject to change.\";\n \n struct PostExpansionVisitor<'a> {\n     context: &'a Context<'a>,\n }\n \n-impl<'a> PostExpansionVisitor<'a> {\n-    fn gate_feature(&self, feature: &str, span: Span, explain: &str) {\n-        if !self.context.cm.span_allows_unstable(span) {\n-            self.context.gate_feature(feature, span, explain)\n+macro_rules! gate_feature_post {\n+    ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {{\n+        let (cx, span) = ($cx, $span);\n+        if !cx.context.cm.span_allows_unstable(span) {\n+            gate_feature!(cx.context, $feature, span, $explain)\n         }\n-    }\n+    }}\n }\n \n impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n@@ -895,69 +827,68 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n \n     fn visit_name(&mut self, sp: Span, name: ast::Name) {\n         if !name.as_str().is_ascii() {\n-            self.gate_feature(\"non_ascii_idents\", sp,\n-                              \"non-ascii idents are not fully supported.\");\n+            gate_feature_post!(&self, non_ascii_idents, sp,\n+                               \"non-ascii idents are not fully supported.\");\n         }\n     }\n \n     fn visit_item(&mut self, i: &ast::Item) {\n         match i.node {\n             ast::ItemKind::ExternCrate(_) => {\n                 if attr::contains_name(&i.attrs[..], \"macro_reexport\") {\n-                    self.gate_feature(\"macro_reexport\", i.span,\n-                                      \"macros reexports are experimental \\\n-                                       and possibly buggy\");\n+                    gate_feature_post!(&self, macro_reexport, i.span,\n+                                       \"macros reexports are experimental \\\n+                                        and possibly buggy\");\n                 }\n             }\n \n             ast::ItemKind::ForeignMod(ref foreign_module) => {\n                 if attr::contains_name(&i.attrs[..], \"link_args\") {\n-                    self.gate_feature(\"link_args\", i.span,\n+                    gate_feature_post!(&self, link_args, i.span,\n                                       \"the `link_args` attribute is not portable \\\n                                        across platforms, it is recommended to \\\n                                        use `#[link(name = \\\"foo\\\")]` instead\")\n                 }\n-                let maybe_feature = match foreign_module.abi {\n-                    Abi::RustIntrinsic => Some((\"intrinsics\", \"intrinsics are subject to change\")),\n+                match foreign_module.abi {\n+                    Abi::RustIntrinsic =>\n+                        gate_feature_post!(&self, intrinsics, i.span,\n+                                           \"intrinsics are subject to change\"),\n                     Abi::PlatformIntrinsic => {\n-                        Some((\"platform_intrinsics\",\n-                              \"platform intrinsics are experimental and possibly buggy\"))\n+                        gate_feature_post!(&self, platform_intrinsics, i.span,\n+                                           \"platform intrinsics are experimental \\\n+                                            and possibly buggy\")\n                     },\n                     Abi::Vectorcall => {\n-                        Some((\"abi_vectorcall\",\n-                            \"vectorcall is experimental and subject to change\"\n-                        ))\n+                        gate_feature_post!(&self, abi_vectorcall, i.span,\n+                                           \"vectorcall is experimental and subject to change\")\n                     }\n-                    _ => None\n-                };\n-                if let Some((feature, msg)) = maybe_feature {\n-                    self.gate_feature(feature, i.span, msg)\n+                    _ => ()\n                 }\n             }\n \n             ast::ItemKind::Fn(..) => {\n                 if attr::contains_name(&i.attrs[..], \"plugin_registrar\") {\n-                    self.gate_feature(\"plugin_registrar\", i.span,\n-                                      \"compiler plugins are experimental and possibly buggy\");\n+                    gate_feature_post!(&self, plugin_registrar, i.span,\n+                                       \"compiler plugins are experimental and possibly buggy\");\n                 }\n                 if attr::contains_name(&i.attrs[..], \"start\") {\n-                    self.gate_feature(\"start\", i.span,\n+                    gate_feature_post!(&self, start, i.span,\n                                       \"a #[start] function is an experimental \\\n                                        feature whose signature may change \\\n                                        over time\");\n                 }\n                 if attr::contains_name(&i.attrs[..], \"main\") {\n-                    self.gate_feature(\"main\", i.span,\n-                                      \"declaration of a nonstandard #[main] \\\n-                                       function may change over time, for now \\\n-                                       a top-level `fn main()` is required\");\n+                    gate_feature_post!(&self, main, i.span,\n+                                       \"declaration of a nonstandard #[main] \\\n+                                        function may change over time, for now \\\n+                                        a top-level `fn main()` is required\");\n                 }\n             }\n \n             ast::ItemKind::Struct(..) => {\n                 if attr::contains_name(&i.attrs[..], \"simd\") {\n-                    self.gate_feature(\"simd\", i.span,\n-                                      \"SIMD types are experimental and possibly buggy\");\n+                    gate_feature_post!(&self, simd, i.span,\n+                                       \"SIMD types are experimental and possibly buggy\");\n                     self.context.span_handler.span_warn(i.span,\n                                                         \"the `#[simd]` attribute is deprecated, \\\n                                                          use `#[repr(simd)]` instead\");\n@@ -966,8 +897,9 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                     if attr.name() == \"repr\" {\n                         for item in attr.meta_item_list().unwrap_or(&[]) {\n                             if item.name() == \"simd\" {\n-                                self.gate_feature(\"repr_simd\", i.span,\n-                                                  \"SIMD types are experimental and possibly buggy\");\n+                                gate_feature_post!(&self, repr_simd, i.span,\n+                                                   \"SIMD types are experimental \\\n+                                                    and possibly buggy\");\n \n                             }\n                         }\n@@ -976,19 +908,19 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::DefaultImpl(..) => {\n-                self.gate_feature(\"optin_builtin_traits\",\n-                                  i.span,\n-                                  \"default trait implementations are experimental \\\n-                                   and possibly buggy\");\n+                gate_feature_post!(&self, optin_builtin_traits,\n+                                   i.span,\n+                                   \"default trait implementations are experimental \\\n+                                    and possibly buggy\");\n             }\n \n             ast::ItemKind::Impl(_, polarity, _, _, _, _) => {\n                 match polarity {\n                     ast::ImplPolarity::Negative => {\n-                        self.gate_feature(\"optin_builtin_traits\",\n-                                          i.span,\n-                                          \"negative trait bounds are not yet fully implemented; \\\n-                                          use marker types for now\");\n+                        gate_feature_post!(&self, optin_builtin_traits,\n+                                           i.span,\n+                                           \"negative trait bounds are not yet fully implemented; \\\n+                                            use marker types for now\");\n                     },\n                     _ => {}\n                 }\n@@ -1001,7 +933,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_variant_data(&mut self, s: &'v ast::VariantData, _: ast::Ident,\n-                        _: &'v ast::Generics, _: ast::NodeId, span: Span) {\n+                          _: &'v ast::Generics, _: ast::NodeId, span: Span) {\n         if s.fields().is_empty() {\n             if s.is_tuple() {\n                 self.context.span_handler.struct_span_err(span, \"empty tuple structs and enum \\\n@@ -1023,7 +955,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n             _ => false\n         };\n         if links_to_llvm {\n-            self.gate_feature(\"link_llvm_intrinsics\", i.span,\n+            gate_feature_post!(&self, link_llvm_intrinsics, i.span,\n                               \"linking to LLVM intrinsics is experimental\");\n         }\n \n@@ -1033,22 +965,19 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n             ast::ExprKind::Box(_) => {\n-                self.gate_feature(\"box_syntax\",\n-                                  e.span,\n-                                  \"box expression syntax is experimental; \\\n-                                   you can call `Box::new` instead.\");\n+                gate_feature_post!(&self, box_syntax, e.span, EXPLAIN_BOX_SYNTAX);\n             }\n             ast::ExprKind::Type(..) => {\n-                self.gate_feature(\"type_ascription\", e.span,\n+                gate_feature_post!(&self, type_ascription, e.span,\n                                   \"type ascription is experimental\");\n             }\n             ast::ExprKind::Range(_, _, ast::RangeLimits::Closed) => {\n-                self.gate_feature(\"inclusive_range_syntax\",\n+                gate_feature_post!(&self, inclusive_range_syntax,\n                                   e.span,\n                                   \"inclusive range syntax is experimental\");\n             }\n             ast::ExprKind::Try(..) => {\n-                self.gate_feature(\"question_mark\", e.span, \"the `?` operator is not stable\");\n+                gate_feature_post!(&self, question_mark, e.span, \"the `?` operator is not stable\");\n             }\n             _ => {}\n         }\n@@ -1058,19 +987,19 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     fn visit_pat(&mut self, pattern: &ast::Pat) {\n         match pattern.node {\n             PatKind::Vec(_, Some(_), ref last) if !last.is_empty() => {\n-                self.gate_feature(\"advanced_slice_patterns\",\n+                gate_feature_post!(&self, advanced_slice_patterns,\n                                   pattern.span,\n                                   \"multiple-element slice matches anywhere \\\n                                    but at the end of a slice (e.g. \\\n                                    `[0, ..xs, 0]`) are experimental\")\n             }\n             PatKind::Vec(..) => {\n-                self.gate_feature(\"slice_patterns\",\n+                gate_feature_post!(&self, slice_patterns,\n                                   pattern.span,\n                                   \"slice pattern syntax is experimental\");\n             }\n             PatKind::Box(..) => {\n-                self.gate_feature(\"box_patterns\",\n+                gate_feature_post!(&self, box_patterns,\n                                   pattern.span,\n                                   \"box pattern syntax is experimental\");\n             }\n@@ -1088,7 +1017,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n         // check for const fn declarations\n         match fn_kind {\n             FnKind::ItemFn(_, _, _, ast::Constness::Const, _, _) => {\n-                self.gate_feature(\"const_fn\", span, \"const fn is unstable\");\n+                gate_feature_post!(&self, const_fn, span, \"const fn is unstable\");\n             }\n             _ => {\n                 // stability of const fn methods are covered in\n@@ -1100,18 +1029,18 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n \n         match fn_kind {\n             FnKind::ItemFn(_, _, _, _, abi, _) if abi == Abi::RustIntrinsic => {\n-                self.gate_feature(\"intrinsics\",\n+                gate_feature_post!(&self, intrinsics,\n                                   span,\n                                   \"intrinsics are subject to change\")\n             }\n             FnKind::ItemFn(_, _, _, _, abi, _) |\n             FnKind::Method(_, &ast::MethodSig { abi, .. }, _) => match abi {\n                 Abi::RustCall => {\n-                    self.gate_feature(\"unboxed_closures\", span,\n+                    gate_feature_post!(&self, unboxed_closures, span,\n                         \"rust-call ABI is subject to change\");\n                 },\n                 Abi::Vectorcall => {\n-                    self.gate_feature(\"abi_vectorcall\", span,\n+                    gate_feature_post!(&self, abi_vectorcall, span,\n                         \"vectorcall is experimental and subject to change\");\n                 },\n                 _ => {}\n@@ -1124,17 +1053,17 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     fn visit_trait_item(&mut self, ti: &'v ast::TraitItem) {\n         match ti.node {\n             ast::TraitItemKind::Const(..) => {\n-                self.gate_feature(\"associated_consts\",\n+                gate_feature_post!(&self, associated_consts,\n                                   ti.span,\n                                   \"associated constants are experimental\")\n             }\n             ast::TraitItemKind::Method(ref sig, _) => {\n                 if sig.constness == ast::Constness::Const {\n-                    self.gate_feature(\"const_fn\", ti.span, \"const fn is unstable\");\n+                    gate_feature_post!(&self, const_fn, ti.span, \"const fn is unstable\");\n                 }\n             }\n             ast::TraitItemKind::Type(_, Some(_)) => {\n-                self.gate_feature(\"associated_type_defaults\", ti.span,\n+                gate_feature_post!(&self, associated_type_defaults, ti.span,\n                                   \"associated type defaults are unstable\");\n             }\n             _ => {}\n@@ -1144,20 +1073,20 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n \n     fn visit_impl_item(&mut self, ii: &'v ast::ImplItem) {\n         if ii.defaultness == ast::Defaultness::Default {\n-            self.gate_feature(\"specialization\",\n+            gate_feature_post!(&self, specialization,\n                               ii.span,\n                               \"specialization is unstable\");\n         }\n \n         match ii.node {\n             ast::ImplItemKind::Const(..) => {\n-                self.gate_feature(\"associated_consts\",\n+                gate_feature_post!(&self, associated_consts,\n                                   ii.span,\n                                   \"associated constants are experimental\")\n             }\n             ast::ImplItemKind::Method(ref sig, _) => {\n                 if sig.constness == ast::Constness::Const {\n-                    self.gate_feature(\"const_fn\", ii.span, \"const fn is unstable\");\n+                    gate_feature_post!(&self, const_fn, ii.span, \"const fn is unstable\");\n                 }\n             }\n             _ => {}\n@@ -1183,26 +1112,12 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n             }\n             _ => return,\n         };\n-        self.gate_feature(\"pub_restricted\", span, \"`pub(restricted)` syntax is experimental\");\n+        gate_feature_post!(&self, pub_restricted, span, \"`pub(restricted)` syntax is experimental\");\n     }\n }\n \n-fn check_crate_inner<F>(cm: &CodeMap, span_handler: &Handler,\n-                        krate: &ast::Crate,\n-                        plugin_attributes: &[(String, AttributeType)],\n-                        check: F)\n-                       -> Features\n-    where F: FnOnce(&mut Context, &ast::Crate)\n-{\n-    let mut cx = Context {\n-        features: Vec::new(),\n-        span_handler: span_handler,\n-        cm: cm,\n-        plugin_attributes: plugin_attributes,\n-    };\n-\n-    let mut accepted_features = Vec::new();\n-    let mut unknown_features = Vec::new();\n+pub fn get_features(span_handler: &Handler, krate: &ast::Crate) -> Features {\n+    let mut features = Features::new();\n \n     for attr in &krate.attrs {\n         if !attr.check_name(\"feature\") {\n@@ -1225,82 +1140,43 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &Handler,\n                             continue\n                         }\n                     };\n-                    match KNOWN_FEATURES.iter()\n-                                        .find(|& &(n, _, _, _)| name == n) {\n-                        Some(&(name, _, _, Active)) => {\n-                            cx.enable_feature(name);\n-                        }\n-                        Some(&(_, _, _, Removed)) => {\n-                            span_handler.span_err(mi.span, \"feature has been removed\");\n-                        }\n-                        Some(&(_, _, _, Accepted)) => {\n-                            accepted_features.push(mi.span);\n-                        }\n-                        None => {\n-                            unknown_features.push((name, mi.span));\n-                        }\n+                    if let Some(&(_, _, _, setter)) = ACTIVE_FEATURES.iter()\n+                        .find(|& &(n, _, _, _)| name == n) {\n+                        *(setter(&mut features)) = true;\n+                    }\n+                    else if let Some(&(_, _, _)) = REMOVED_FEATURES.iter()\n+                        .find(|& &(n, _, _)| name == n) {\n+                        span_handler.span_err(mi.span, \"feature has been removed\");\n+                    }\n+                    else if let Some(&(_, _, _)) = ACCEPTED_FEATURES.iter()\n+                        .find(|& &(n, _, _)| name == n) {\n+                        features.declared_stable_lang_features.push(mi.span);\n+                    } else {\n+                        features.declared_lib_features.push((name, mi.span));\n                     }\n                 }\n             }\n         }\n     }\n \n-    check(&mut cx, krate);\n-\n-    // FIXME (pnkfelix): Before adding the 99th entry below, change it\n-    // to a single-pass (instead of N calls to `.has_feature`).\n-\n-    Features {\n-        unboxed_closures: cx.has_feature(\"unboxed_closures\"),\n-        rustc_diagnostic_macros: cx.has_feature(\"rustc_diagnostic_macros\"),\n-        allow_quote: cx.has_feature(\"quote\"),\n-        allow_asm: cx.has_feature(\"asm\"),\n-        allow_log_syntax: cx.has_feature(\"log_syntax\"),\n-        allow_concat_idents: cx.has_feature(\"concat_idents\"),\n-        allow_trace_macros: cx.has_feature(\"trace_macros\"),\n-        allow_internal_unstable: cx.has_feature(\"allow_internal_unstable\"),\n-        allow_custom_derive: cx.has_feature(\"custom_derive\"),\n-        allow_placement_in: cx.has_feature(\"placement_in_syntax\"),\n-        allow_box: cx.has_feature(\"box_syntax\"),\n-        allow_pushpop_unsafe: cx.has_feature(\"pushpop_unsafe\"),\n-        allow_inclusive_range: cx.has_feature(\"inclusive_range_syntax\"),\n-        simd_ffi: cx.has_feature(\"simd_ffi\"),\n-        unmarked_api: cx.has_feature(\"unmarked_api\"),\n-        declared_stable_lang_features: accepted_features,\n-        declared_lib_features: unknown_features,\n-        const_fn: cx.has_feature(\"const_fn\"),\n-        const_indexing: cx.has_feature(\"const_indexing\"),\n-        static_recursion: cx.has_feature(\"static_recursion\"),\n-        default_type_parameter_fallback: cx.has_feature(\"default_type_parameter_fallback\"),\n-        rustc_attrs: cx.has_feature(\"rustc_attrs\"),\n-        type_macros: cx.has_feature(\"type_macros\"),\n-        cfg_target_feature: cx.has_feature(\"cfg_target_feature\"),\n-        cfg_target_vendor: cx.has_feature(\"cfg_target_vendor\"),\n-        cfg_target_thread_local: cx.has_feature(\"cfg_target_thread_local\"),\n-        staged_api: cx.has_feature(\"staged_api\"),\n-        stmt_expr_attributes: cx.has_feature(\"stmt_expr_attributes\"),\n-        deprecated: cx.has_feature(\"deprecated\"),\n-        question_mark: cx.has_feature(\"question_mark\"),\n-        specialization: cx.has_feature(\"specialization\"),\n-        pub_restricted: cx.has_feature(\"pub_restricted\"),\n-    }\n-}\n-\n-pub fn check_crate_macros(cm: &CodeMap, span_handler: &Handler, krate: &ast::Crate)\n--> Features {\n-    check_crate_inner(cm, span_handler, krate, &[] as &'static [_],\n-                      |ctx, krate| visit::walk_crate(&mut MacroVisitor { context: ctx }, krate))\n+    features\n }\n \n pub fn check_crate(cm: &CodeMap, span_handler: &Handler, krate: &ast::Crate,\n                    plugin_attributes: &[(String, AttributeType)],\n-                   unstable: UnstableFeatures) -> Features\n-{\n+                   unstable: UnstableFeatures) -> Features {\n     maybe_stage_features(span_handler, krate, unstable);\n-\n-    check_crate_inner(cm, span_handler, krate, plugin_attributes,\n-                      |ctx, krate| visit::walk_crate(&mut PostExpansionVisitor { context: ctx },\n-                                                     krate))\n+    let features = get_features(span_handler, krate);\n+    {\n+        let ctx = Context {\n+            features: &features,\n+            span_handler: span_handler,\n+            cm: cm,\n+            plugin_attributes: plugin_attributes,\n+        };\n+        visit::walk_crate(&mut PostExpansionVisitor { context: &ctx }, krate);\n+    }\n+    features\n }\n \n #[derive(Clone, Copy)]"}, {"sha": "4ca3196b9c5ecd6001cbca3fbf6544f6b2dfb752", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 64, "deletions": 30, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=435095f32af93d27baf1390fa34e7dfff5eb7d5d", "patch": "@@ -96,6 +96,36 @@ fn expand_derive(cx: &mut ExtCtxt,\n             let mut found_partial_eq = false;\n             let mut found_eq = false;\n \n+            // This span is **very** sensitive and crucial to\n+            // getting the stability behavior we want. What we are\n+            // doing is marking the generated `#[derive_*]` with the\n+            // span of the `#[deriving(...)]` attribute (the\n+            // entire attribute, not just the `PartialEq` or `Eq`\n+            // part), but with the current backtrace. The current\n+            // backtrace will contain a topmost entry that IS this\n+            // `#[deriving(...)]` attribute and with the\n+            // \"allow-unstable\" flag set to true.\n+            //\n+            // Note that we do NOT use the span of the `Eq`\n+            // text itself. You might think this is\n+            // equivalent, because the `Eq` appears within the\n+            // `#[deriving(Eq)]` attribute, and hence we would\n+            // inherit the \"allows unstable\" from the\n+            // backtrace.  But in fact this is not always the\n+            // case. The actual source text that led to\n+            // deriving can be `#[$attr]`, for example, where\n+            // `$attr == deriving(Eq)`. In that case, the\n+            // \"#[derive_*]\" would be considered to\n+            // originate not from the deriving call but from\n+            // text outside the deriving call, and hence would\n+            // be forbidden from using unstable\n+            // content.\n+            //\n+            // See tests src/run-pass/rfc1445 for\n+            // examples. --nmatsakis\n+            let span = Span { expn_id: cx.backtrace(), .. span };\n+            assert!(cx.parse_sess.codemap().span_allows_unstable(span));\n+\n             for titem in traits.iter().rev() {\n                 let tname = match titem.node {\n                     MetaItemKind::Word(ref tname) => tname,\n@@ -121,42 +151,13 @@ fn expand_derive(cx: &mut ExtCtxt,\n                 }\n \n                 // #[derive(Foo, Bar)] expands to #[derive_Foo] #[derive_Bar]\n-                item.attrs.push(cx.attribute(titem.span, cx.meta_word(titem.span,\n+                item.attrs.push(cx.attribute(span, cx.meta_word(titem.span,\n                     intern_and_get_ident(&format!(\"derive_{}\", tname)))));\n             }\n \n             // RFC #1445. `#[derive(PartialEq, Eq)]` adds a (trusted)\n             // `#[structural_match]` attribute.\n             if found_partial_eq && found_eq {\n-                // This span is **very** sensitive and crucial to\n-                // getting the stability behavior we want. What we are\n-                // doing is marking `#[structural_match]` with the\n-                // span of the `#[deriving(...)]` attribute (the\n-                // entire attribute, not just the `PartialEq` or `Eq`\n-                // part), but with the current backtrace. The current\n-                // backtrace will contain a topmost entry that IS this\n-                // `#[deriving(...)]` attribute and with the\n-                // \"allow-unstable\" flag set to true.\n-                //\n-                // Note that we do NOT use the span of the `Eq`\n-                // text itself. You might think this is\n-                // equivalent, because the `Eq` appears within the\n-                // `#[deriving(Eq)]` attribute, and hence we would\n-                // inherit the \"allows unstable\" from the\n-                // backtrace.  But in fact this is not always the\n-                // case. The actual source text that led to\n-                // deriving can be `#[$attr]`, for example, where\n-                // `$attr == deriving(Eq)`. In that case, the\n-                // \"#[structural_match]\" would be considered to\n-                // originate not from the deriving call but from\n-                // text outside the deriving call, and hence would\n-                // be forbidden from using unstable\n-                // content.\n-                //\n-                // See tests src/run-pass/rfc1445 for\n-                // examples. --nmatsakis\n-                let span = Span { expn_id: cx.backtrace(), .. span };\n-                assert!(cx.parse_sess.codemap().span_allows_unstable(span));\n                 debug!(\"inserting structural_match with span {:?}\", span);\n                 let structural_match = intern_and_get_ident(\"structural_match\");\n                 item.attrs.push(cx.attribute(span,\n@@ -188,6 +189,39 @@ macro_rules! derive_traits {\n                               mitem: &MetaItem,\n                               annotatable: &Annotatable,\n                               push: &mut FnMut(Annotatable)) {\n+                        if !ecx.parse_sess.codemap().span_allows_unstable(sp)\n+                            && !ecx.ecfg.features.unwrap().custom_derive {\n+                            // FIXME:\n+                            // https://github.com/rust-lang/rust/pull/32671#issuecomment-206245303\n+                            // This is just to avoid breakage with syntex.\n+                            // Remove that to spawn an error instead.\n+                            let cm = ecx.parse_sess.codemap();\n+                            let parent = cm.with_expn_info(ecx.backtrace(),\n+                                                           |info| info.unwrap().call_site.expn_id);\n+                            cm.with_expn_info(parent, |info| {\n+                                if info.is_some() {\n+                                    let mut w = ecx.parse_sess.span_diagnostic.struct_span_warn(\n+                                        sp, feature_gate::EXPLAIN_DERIVE_UNDERSCORE,\n+                                    );\n+                                    if option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_none() {\n+                                        w.fileline_help(\n+                                            sp, &format!(\"add #![feature(custom_derive)] to \\\n+                                                          the crate attributes to enable\")\n+                                        );\n+                                    }\n+                                    w.emit();\n+                                } else {\n+                                    feature_gate::emit_feature_err(\n+                                        &ecx.parse_sess.span_diagnostic,\n+                                        \"custom_derive\", sp, feature_gate::GateIssue::Language,\n+                                        feature_gate::EXPLAIN_DERIVE_UNDERSCORE\n+                                    );\n+\n+                                    return;\n+                                }\n+                            })\n+                        }\n+\n                         warn_if_deprecated(ecx, sp, $name);\n                         $func(ecx, sp, mitem, annotatable, push);\n                     }"}, {"sha": "9ebf8a9b74a6c07efd6550dabfcac4f041e6100d", "filename": "src/test/compile-fail/feature-gate-allow-internal-unstable-nested-macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow-internal-unstable-nested-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow-internal-unstable-nested-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow-internal-unstable-nested-macro.rs?ref=435095f32af93d27baf1390fa34e7dfff5eb7d5d", "patch": "@@ -11,8 +11,8 @@\n macro_rules! bar {\n     () => {\n         // more layers don't help:\n-        #[allow_internal_unstable]\n-        macro_rules! baz { //~ ERROR allow_internal_unstable side-steps\n+        #[allow_internal_unstable] //~ ERROR allow_internal_unstable side-steps\n+        macro_rules! baz {\n             () => {}\n         }\n     }"}, {"sha": "b186278ef8b7b200d5909b880d5c910a95a34c61", "filename": "src/test/compile-fail/feature-gate-allow-internal-unstable-struct.rs", "status": "renamed", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow-internal-unstable-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow-internal-unstable-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow-internal-unstable-struct.rs?ref=435095f32af93d27baf1390fa34e7dfff5eb7d5d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,13 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that the trace_macros feature gate is on.\n+// checks that this attribute is caught on non-macro items.\n+// this needs a different test since this is done after expansion\n \n-fn main() {\n-    // (Infrastructure does not attempt to detect uses in macro definitions.)\n-    macro_rules! expando {\n-        ($x: ident) => { trace_macros!($x) }\n-    }\n+#[allow_internal_unstable] //~ ERROR allow_internal_unstable side-steps\n+struct S;\n \n-    expando!(true); //~ ERROR `trace_macros` is not stable\n-}\n+fn main() {}", "previous_filename": "src/test/compile-fail/trace_macros-gate2.rs"}, {"sha": "edd7fe4a1e588a098db660ec0666eb1c45146391", "filename": "src/test/compile-fail/issue-32655.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Ftest%2Fcompile-fail%2Fissue-32655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Ftest%2Fcompile-fail%2Fissue-32655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32655.rs?ref=435095f32af93d27baf1390fa34e7dfff5eb7d5d", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+#![feature(rustc_attrs)]\n+\n+macro_rules! foo (\n+    () => (\n+        #[derive_Clone] //~ WARN attributes of the form\n+        struct T;\n+    );\n+);\n+\n+macro_rules! bar (\n+    ($e:item) => ($e)\n+);\n+\n+foo!();\n+\n+bar!(\n+    #[derive_Clone] //~ WARN attributes of the form\n+    struct S;\n+);\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}, {"sha": "696ea0ef5473b72083b7455b3da49b41b2c7001a", "filename": "src/test/compile-fail/issue-32782.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Ftest%2Fcompile-fail%2Fissue-32782.rs", "raw_url": "https://github.com/rust-lang/rust/raw/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Ftest%2Fcompile-fail%2Fissue-32782.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32782.rs?ref=435095f32af93d27baf1390fa34e7dfff5eb7d5d", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! bar (\n+    () => ()\n+);\n+\n+macro_rules! foo (\n+    () => (\n+        #[allow_internal_unstable] //~ ERROR allow_internal_unstable side-steps\n+        bar!();\n+    );\n+);\n+\n+foo!();\n+fn main() {}"}, {"sha": "d627de24d679451b66a8d9778720593479bc886b", "filename": "src/test/compile-fail/trace_macros-gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate.rs?ref=435095f32af93d27baf1390fa34e7dfff5eb7d5d", "patch": "@@ -26,5 +26,5 @@ fn main() {\n         ($x: ident) => { trace_macros!($x) }\n     }\n \n-    expando!(true);\n+    expando!(true); //~ ERROR `trace_macros` is not stable\n }"}, {"sha": "66d03cf9d8046fd32b598e797b768c5d71541a21", "filename": "src/test/compile-fail/trace_macros-gate3.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cda7c1cf2463443aee4a2f51a5141bc7ce4a4f97/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda7c1cf2463443aee4a2f51a5141bc7ce4a4f97/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate3.rs?ref=cda7c1cf2463443aee4a2f51a5141bc7ce4a4f97", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that the trace_macros feature gate is on.\n-\n-pub fn main() {\n-    println!(\"arg: {}\", trace_macros!()); //~ ERROR `trace_macros` is not stable\n-    println!(\"arg: {}\", trace_macros!(1)); //~ ERROR `trace_macros` is not stable\n-    println!(\"arg: {}\", trace_macros!(ident)); //~ ERROR `trace_macros` is not stable\n-    println!(\"arg: {}\", trace_macros!(for)); //~ ERROR `trace_macros` is not stable\n-    println!(\"arg: {}\", trace_macros!(true,)); //~ ERROR `trace_macros` is not stable\n-    println!(\"arg: {}\", trace_macros!(false 1)); //~ ERROR `trace_macros` is not stable\n-}"}, {"sha": "0b989d92b3d1d0df4cdb104efda8186671f7c44a", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/435095f32af93d27baf1390fa34e7dfff5eb7d5d/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=435095f32af93d27baf1390fa34e7dfff5eb7d5d", "patch": "@@ -136,18 +136,18 @@ fn collect_lang_features(path: &Path) -> Vec<Feature> {\n \n     let mut features = Vec::new();\n     for line in contents.lines().map(|l| l.trim()) {\n-        if !STATUSES.iter().any(|s| line.contains(s) && line.starts_with(\"(\")) {\n+        if !STATUSES.iter().any(|s| line.starts_with(&format!(\"({}\", s))) {\n             continue\n         }\n         let mut parts = line.split(\",\");\n-        let name = parts.next().unwrap().replace(\"\\\"\", \"\").replace(\"(\", \"\");\n-        let since = parts.next().unwrap().trim().replace(\"\\\"\", \"\");\n-        let status = match parts.skip(1).next().unwrap() {\n-            s if s.contains(\"Active\") => \"unstable\",\n-            s if s.contains(\"Removed\") => \"unstable\",\n-            s if s.contains(\"Accepted\") => \"stable\",\n+        let status = match &parts.next().unwrap().trim().replace(\"(\", \"\")[..] {\n+            \"active\"   => \"unstable\",\n+            \"removed\"  => \"unstable\",\n+            \"accepted\" => \"stable\",\n             s => panic!(\"unknown status: {}\", s),\n         };\n+        let name = parts.next().unwrap().trim().to_owned();\n+        let since = parts.next().unwrap().trim().replace(\"\\\"\", \"\");\n \n         features.push(Feature {\n             name: name,"}]}