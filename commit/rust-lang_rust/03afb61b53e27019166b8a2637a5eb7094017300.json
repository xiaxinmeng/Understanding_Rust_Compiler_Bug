{"sha": "03afb61b53e27019166b8a2637a5eb7094017300", "node_id": "C_kwDOAAsO6NoAKDAzYWZiNjFiNTNlMjcwMTkxNjZiOGEyNjM3YTVlYjcwOTQwMTczMDA", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-11-01T14:04:01Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-11-03T15:24:59Z"}, "message": "Optimize live point computation\n\nThis is just replicating the previous algorithm, but taking advantage of the\nbitset structures to optimize into tighter and better optimized loops.\nParticularly advantageous on enormous MIR blocks, which are relatively rare in\npractice.", "tree": {"sha": "90aa6bca622461efe488186e25102fb9630eee2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90aa6bca622461efe488186e25102fb9630eee2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03afb61b53e27019166b8a2637a5eb7094017300", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03afb61b53e27019166b8a2637a5eb7094017300", "html_url": "https://github.com/rust-lang/rust/commit/03afb61b53e27019166b8a2637a5eb7094017300", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03afb61b53e27019166b8a2637a5eb7094017300/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff0e14829e1806ca0d4226595f7fdf3e8658758f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff0e14829e1806ca0d4226595f7fdf3e8658758f", "html_url": "https://github.com/rust-lang/rust/commit/ff0e14829e1806ca0d4226595f7fdf3e8658758f"}], "stats": {"total": 307, "additions": 278, "deletions": 29}, "files": [{"sha": "100ac578f92ddcccc2ca2434a723b388079dd253", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/03afb61b53e27019166b8a2637a5eb7094017300/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03afb61b53e27019166b8a2637a5eb7094017300/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=03afb61b53e27019166b8a2637a5eb7094017300", "patch": "@@ -60,6 +60,11 @@ impl RegionValueElements {\n         PointIndex::new(start_index)\n     }\n \n+    /// Return the PointIndex for the block start of this index.\n+    crate fn to_block_start(&self, index: PointIndex) -> PointIndex {\n+        PointIndex::new(self.statements_before_block[self.basic_blocks[index]])\n+    }\n+\n     /// Converts a `PointIndex` back to a location. O(1).\n     crate fn to_location(&self, index: PointIndex) -> Location {\n         assert!(index.index() < self.num_points);\n@@ -76,29 +81,6 @@ impl RegionValueElements {\n     crate fn point_in_range(&self, index: PointIndex) -> bool {\n         index.index() < self.num_points\n     }\n-\n-    /// Pushes all predecessors of `index` onto `stack`.\n-    crate fn push_predecessors(\n-        &self,\n-        body: &Body<'_>,\n-        index: PointIndex,\n-        stack: &mut Vec<PointIndex>,\n-    ) {\n-        let Location { block, statement_index } = self.to_location(index);\n-        if statement_index == 0 {\n-            // If this is a basic block head, then the predecessors are\n-            // the terminators of other basic blocks\n-            stack.extend(\n-                body.predecessors()[block]\n-                    .iter()\n-                    .map(|&pred_bb| body.terminator_loc(pred_bb))\n-                    .map(|pred_loc| self.point_from_location(pred_loc)),\n-            );\n-        } else {\n-            // Otherwise, the pred is just the previous statement\n-            stack.push(PointIndex::new(index.index() - 1));\n-        }\n-    }\n }\n \n rustc_index::newtype_index! {"}, {"sha": "73c284071d5cc26c467d65abc0a2a99b45200dce", "filename": "compiler/rustc_borrowck/src/type_check/liveness/trace.rs", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/03afb61b53e27019166b8a2637a5eb7094017300/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03afb61b53e27019166b8a2637a5eb7094017300/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs?ref=03afb61b53e27019166b8a2637a5eb7094017300", "patch": "@@ -205,12 +205,42 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n \n         self.stack.extend(self.cx.local_use_map.uses(local));\n         while let Some(p) = self.stack.pop() {\n-            if self.defs.contains(p) {\n+            // We are live in this block from the closest to us of:\n+            //\n+            //  * Inclusively, the block start\n+            //  * Exclusively, the previous definition (if it's in this block)\n+            //  * Exclusively, the previous live_at setting (an optimization)\n+            let block_start = self.cx.elements.to_block_start(p);\n+            let previous_defs = self.defs.last_set_in(block_start..=p);\n+            let previous_live_at = self.use_live_at.last_set_in(block_start..=p);\n+\n+            let exclusive_start = match (previous_defs, previous_live_at) {\n+                (Some(a), Some(b)) => Some(std::cmp::max(a, b)),\n+                (Some(a), None) | (None, Some(a)) => Some(a),\n+                (None, None) => None,\n+            };\n+\n+            if let Some(exclusive) = exclusive_start {\n+                self.use_live_at.insert_range(exclusive + 1..=p);\n+\n+                // If we have a bound after the start of the block, we should\n+                // not add the predecessors for this block.\n                 continue;\n-            }\n-\n-            if self.use_live_at.insert(p) {\n-                self.cx.elements.push_predecessors(self.cx.body, p, &mut self.stack)\n+            } else {\n+                // Add all the elements of this block.\n+                self.use_live_at.insert_range(block_start..=p);\n+\n+                // Then add the predecessors for this block, which are the\n+                // terminators of predecessor basic blocks. Push those onto the\n+                // stack so that the next iteration(s) will process them.\n+\n+                let block = self.cx.elements.to_location(block_start).block;\n+                self.stack.extend(\n+                    self.cx.body.predecessors()[block]\n+                        .iter()\n+                        .map(|&pred_bb| self.cx.body.terminator_loc(pred_bb))\n+                        .map(|pred_loc| self.cx.elements.point_from_location(pred_loc)),\n+                );\n             }\n         }\n     }"}, {"sha": "08f13d46ee1d760c3d365ab962ba5db2d95efdc8", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 141, "deletions": 1, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/03afb61b53e27019166b8a2637a5eb7094017300/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03afb61b53e27019166b8a2637a5eb7094017300/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=03afb61b53e27019166b8a2637a5eb7094017300", "patch": "@@ -4,7 +4,7 @@ use std::fmt;\n use std::iter;\n use std::marker::PhantomData;\n use std::mem;\n-use std::ops::{BitAnd, BitAndAssign, BitOrAssign, Not, Range, Shl};\n+use std::ops::{BitAnd, BitAndAssign, BitOrAssign, Bound, Not, Range, RangeBounds, Shl};\n use std::slice;\n \n use rustc_macros::{Decodable, Encodable};\n@@ -22,6 +22,29 @@ pub trait BitRelations<Rhs> {\n     fn intersect(&mut self, other: &Rhs) -> bool;\n }\n \n+#[inline]\n+fn inclusive_start_end<T: Idx>(\n+    range: impl RangeBounds<T>,\n+    domain: usize,\n+) -> Option<(usize, usize)> {\n+    // Both start and end are inclusive.\n+    let start = match range.start_bound().cloned() {\n+        Bound::Included(start) => start.index(),\n+        Bound::Excluded(start) => start.index() + 1,\n+        Bound::Unbounded => 0,\n+    };\n+    let end = match range.end_bound().cloned() {\n+        Bound::Included(end) => end.index(),\n+        Bound::Excluded(end) => end.index().checked_sub(1)?,\n+        Bound::Unbounded => domain - 1,\n+    };\n+    assert!(end < domain);\n+    if start > end {\n+        return None;\n+    }\n+    Some((start, end))\n+}\n+\n macro_rules! bit_relations_inherent_impls {\n     () => {\n         /// Sets `self = self | other` and returns `true` if `self` changed\n@@ -151,6 +174,33 @@ impl<T: Idx> BitSet<T> {\n         new_word != word\n     }\n \n+    #[inline]\n+    pub fn insert_range(&mut self, elems: impl RangeBounds<T>) {\n+        let Some((start, end)) = inclusive_start_end(elems, self.domain_size) else {\n+            return;\n+        };\n+\n+        let (start_word_index, start_mask) = word_index_and_mask(start);\n+        let (end_word_index, end_mask) = word_index_and_mask(end);\n+\n+        // Set all words in between start and end (exclusively of both).\n+        for word_index in (start_word_index + 1)..end_word_index {\n+            self.words[word_index] = !0;\n+        }\n+\n+        if start_word_index != end_word_index {\n+            // Start and end are in different words, so we handle each in turn.\n+            //\n+            // We set all leading bits. This includes the start_mask bit.\n+            self.words[start_word_index] |= !(start_mask - 1);\n+            // And all trailing bits (i.e. from 0..=end) in the end word,\n+            // including the end.\n+            self.words[end_word_index] |= end_mask | end_mask - 1;\n+        } else {\n+            self.words[start_word_index] |= end_mask | (end_mask - start_mask);\n+        }\n+    }\n+\n     /// Sets all bits to true.\n     pub fn insert_all(&mut self) {\n         for word in &mut self.words {\n@@ -227,6 +277,36 @@ impl<T: Idx> BitSet<T> {\n         not_already\n     }\n \n+    fn last_set_in(&self, range: impl RangeBounds<T>) -> Option<T> {\n+        let (start, end) = inclusive_start_end(range, self.domain_size)?;\n+        let (start_word_index, _) = word_index_and_mask(start);\n+        let (end_word_index, end_mask) = word_index_and_mask(end);\n+\n+        let end_word = self.words[end_word_index] & (end_mask | (end_mask - 1));\n+        if end_word != 0 {\n+            let pos = max_bit(end_word) + WORD_BITS * end_word_index;\n+            if start <= pos {\n+                return Some(T::new(pos));\n+            }\n+        }\n+\n+        // We exclude end_word_index from the range here, because we don't want\n+        // to limit ourselves to *just* the last word: the bits set it in may be\n+        // after `end`, so it may not work out.\n+        if let Some(offset) =\n+            self.words[start_word_index..end_word_index].iter().rposition(|&w| w != 0)\n+        {\n+            let word_idx = start_word_index + offset;\n+            let start_word = self.words[word_idx];\n+            let pos = max_bit(start_word) + WORD_BITS * word_idx;\n+            if start <= pos {\n+                return Some(T::new(pos));\n+            }\n+        }\n+\n+        None\n+    }\n+\n     bit_relations_inherent_impls! {}\n }\n \n@@ -635,6 +715,16 @@ impl<T: Idx> SparseBitSet<T> {\n         self.elems.iter()\n     }\n \n+    fn last_set_in(&self, range: impl RangeBounds<T>) -> Option<T> {\n+        let mut last_leq = None;\n+        for e in self.iter() {\n+            if range.contains(e) {\n+                last_leq = Some(*e);\n+            }\n+        }\n+        last_leq\n+    }\n+\n     bit_relations_inherent_impls! {}\n }\n \n@@ -709,6 +799,16 @@ impl<T: Idx> HybridBitSet<T> {\n         }\n     }\n \n+    /// Returns the previous element present in the bitset from `elem`,\n+    /// inclusively of elem. That is, will return `Some(elem)` if elem is in the\n+    /// bitset.\n+    pub fn last_set_in(&self, range: impl RangeBounds<T>) -> Option<T> {\n+        match self {\n+            HybridBitSet::Sparse(sparse) => sparse.last_set_in(range),\n+            HybridBitSet::Dense(dense) => dense.last_set_in(range),\n+        }\n+    }\n+\n     pub fn insert(&mut self, elem: T) -> bool {\n         // No need to check `elem` against `self.domain_size` here because all\n         // the match cases check it, one way or another.\n@@ -734,6 +834,41 @@ impl<T: Idx> HybridBitSet<T> {\n         }\n     }\n \n+    pub fn insert_range(&mut self, elems: impl RangeBounds<T>) {\n+        // No need to check `elem` against `self.domain_size` here because all\n+        // the match cases check it, one way or another.\n+        let start = match elems.start_bound().cloned() {\n+            Bound::Included(start) => start.index(),\n+            Bound::Excluded(start) => start.index() + 1,\n+            Bound::Unbounded => 0,\n+        };\n+        let end = match elems.end_bound().cloned() {\n+            Bound::Included(end) => end.index() + 1,\n+            Bound::Excluded(end) => end.index(),\n+            Bound::Unbounded => self.domain_size() - 1,\n+        };\n+        let len = if let Some(l) = end.checked_sub(start) {\n+            l\n+        } else {\n+            return;\n+        };\n+        match self {\n+            HybridBitSet::Sparse(sparse) if sparse.len() + len < SPARSE_MAX => {\n+                // The set is sparse and has space for `elems`.\n+                for elem in start..end {\n+                    sparse.insert(T::new(elem));\n+                }\n+            }\n+            HybridBitSet::Sparse(sparse) => {\n+                // The set is sparse and full. Convert to a dense set.\n+                let mut dense = sparse.to_dense();\n+                dense.insert_range(elems);\n+                *self = HybridBitSet::Dense(dense);\n+            }\n+            HybridBitSet::Dense(dense) => dense.insert_range(elems),\n+        }\n+    }\n+\n     pub fn insert_all(&mut self) {\n         let domain_size = self.domain_size();\n         match self {\n@@ -1205,6 +1340,11 @@ fn word_index_and_mask<T: Idx>(elem: T) -> (usize, Word) {\n     (word_index, mask)\n }\n \n+#[inline]\n+fn max_bit(word: Word) -> usize {\n+    WORD_BITS - 1 - word.leading_zeros() as usize\n+}\n+\n /// Integral type used to represent the bit set.\n pub trait FiniteBitSetTy:\n     BitAnd<Output = Self>"}, {"sha": "e2b07305c9642159cf99c45d2d929827ebe1c5d1", "filename": "compiler/rustc_index/src/bit_set/tests.rs", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/03afb61b53e27019166b8a2637a5eb7094017300/compiler%2Frustc_index%2Fsrc%2Fbit_set%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03afb61b53e27019166b8a2637a5eb7094017300/compiler%2Frustc_index%2Fsrc%2Fbit_set%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set%2Ftests.rs?ref=03afb61b53e27019166b8a2637a5eb7094017300", "patch": "@@ -370,6 +370,101 @@ fn sparse_matrix_operations() {\n     }\n }\n \n+#[test]\n+fn dense_insert_range() {\n+    #[track_caller]\n+    fn check<R>(domain: usize, range: R)\n+    where\n+        R: RangeBounds<usize> + Clone + IntoIterator<Item = usize> + std::fmt::Debug,\n+    {\n+        let mut set = BitSet::new_empty(domain);\n+        set.insert_range(range.clone());\n+        for i in set.iter() {\n+            assert!(range.contains(&i));\n+        }\n+        for i in range.clone() {\n+            assert!(set.contains(i), \"{} in {:?}, inserted {:?}\", i, set, range);\n+        }\n+    }\n+    check(300, 10..10);\n+    check(300, WORD_BITS..WORD_BITS * 2);\n+    check(300, WORD_BITS - 1..WORD_BITS * 2);\n+    check(300, WORD_BITS - 1..WORD_BITS);\n+    check(300, 10..100);\n+    check(300, 10..30);\n+    check(300, 0..5);\n+    check(300, 0..250);\n+    check(300, 200..250);\n+\n+    check(300, 10..=10);\n+    check(300, WORD_BITS..=WORD_BITS * 2);\n+    check(300, WORD_BITS - 1..=WORD_BITS * 2);\n+    check(300, WORD_BITS - 1..=WORD_BITS);\n+    check(300, 10..=100);\n+    check(300, 10..=30);\n+    check(300, 0..=5);\n+    check(300, 0..=250);\n+    check(300, 200..=250);\n+\n+    for i in 0..WORD_BITS * 2 {\n+        for j in i..WORD_BITS * 2 {\n+            check(WORD_BITS * 2, i..j);\n+            check(WORD_BITS * 2, i..=j);\n+            check(300, i..j);\n+            check(300, i..=j);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn dense_last_set_before() {\n+    fn easy(set: &BitSet<usize>, needle: impl RangeBounds<usize>) -> Option<usize> {\n+        let mut last_leq = None;\n+        for e in set.iter() {\n+            if needle.contains(&e) {\n+                last_leq = Some(e);\n+            }\n+        }\n+        last_leq\n+    }\n+\n+    #[track_caller]\n+    fn cmp(set: &BitSet<usize>, needle: impl RangeBounds<usize> + Clone + std::fmt::Debug) {\n+        assert_eq!(\n+            set.last_set_in(needle.clone()),\n+            easy(set, needle.clone()),\n+            \"{:?} in {:?}\",\n+            needle,\n+            set\n+        );\n+    }\n+    let mut set = BitSet::new_empty(300);\n+    cmp(&set, 50..=50);\n+    set.insert(WORD_BITS);\n+    cmp(&set, WORD_BITS..=WORD_BITS);\n+    set.insert(WORD_BITS - 1);\n+    cmp(&set, 0..=WORD_BITS - 1);\n+    cmp(&set, 0..=5);\n+    cmp(&set, 10..100);\n+    set.insert(100);\n+    cmp(&set, 100..110);\n+    cmp(&set, 99..100);\n+    cmp(&set, 99..=100);\n+\n+    for i in 0..=WORD_BITS * 2 {\n+        for j in i..=WORD_BITS * 2 {\n+            for k in 0..WORD_BITS * 2 {\n+                let mut set = BitSet::new_empty(300);\n+                cmp(&set, i..j);\n+                cmp(&set, i..=j);\n+                set.insert(k);\n+                cmp(&set, i..j);\n+                cmp(&set, i..=j);\n+            }\n+        }\n+    }\n+}\n+\n /// Merge dense hybrid set into empty sparse hybrid set.\n #[bench]\n fn union_hybrid_sparse_empty_to_dense(b: &mut Bencher) {"}, {"sha": "5149322355fc2b8187de6fdbe31f6fc78bd92234", "filename": "compiler/rustc_index/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03afb61b53e27019166b8a2637a5eb7094017300/compiler%2Frustc_index%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03afb61b53e27019166b8a2637a5eb7094017300/compiler%2Frustc_index%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Flib.rs?ref=03afb61b53e27019166b8a2637a5eb7094017300", "patch": "@@ -3,7 +3,9 @@\n #![feature(extend_one)]\n #![feature(iter_zip)]\n #![feature(min_specialization)]\n+#![feature(step_trait)]\n #![feature(test)]\n+#![feature(let_else)]\n \n pub mod bit_set;\n pub mod vec;"}]}