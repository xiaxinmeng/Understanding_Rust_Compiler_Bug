{"sha": "f231b59b9e3fc1ea074a269b006421295d5402d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyMzFiNTliOWUzZmMxZWEwNzRhMjY5YjAwNjQyMTI5NWQ1NDAyZDA=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-18T07:15:19Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-26T11:18:37Z"}, "message": "Move invalid_upcast_comparisons to its own module", "tree": {"sha": "347ec190e240dc897e1d189a1332c8f608d1f67d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/347ec190e240dc897e1d189a1332c8f608d1f67d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f231b59b9e3fc1ea074a269b006421295d5402d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f231b59b9e3fc1ea074a269b006421295d5402d0", "html_url": "https://github.com/rust-lang/rust/commit/f231b59b9e3fc1ea074a269b006421295d5402d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f231b59b9e3fc1ea074a269b006421295d5402d0/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caa49c85d6c1d45678d1065c689cc4d168e18dfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/caa49c85d6c1d45678d1065c689cc4d168e18dfb", "html_url": "https://github.com/rust-lang/rust/commit/caa49c85d6c1d45678d1065c689cc4d168e18dfb"}], "stats": {"total": 443, "additions": 227, "deletions": 216}, "files": [{"sha": "d183fc41f315314f549709c7a41131a625d25526", "filename": "clippy_lints/src/invalid_upcast_comparisons.rs", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/f231b59b9e3fc1ea074a269b006421295d5402d0/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f231b59b9e3fc1ea074a269b006421295d5402d0/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs?ref=f231b59b9e3fc1ea074a269b006421295d5402d0", "patch": "@@ -0,0 +1,221 @@\n+use std::cmp::Ordering;\n+\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{self, IntTy, UintTy};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+use rustc_target::abi::LayoutOf;\n+\n+use crate::consts::{constant, Constant};\n+\n+use clippy_utils::comparisons::Rel;\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::source::snippet;\n+use clippy_utils::{comparisons, sext};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for comparisons where the relation is always either\n+    /// true or false, but where one side has been upcast so that the comparison is\n+    /// necessary. Only integer types are checked.\n+    ///\n+    /// **Why is this bad?** An expression like `let x : u8 = ...; (x as u32) > 300`\n+    /// will mistakenly imply that it is possible for `x` to be outside the range of\n+    /// `u8`.\n+    ///\n+    /// **Known problems:**\n+    /// https://github.com/rust-lang/rust-clippy/issues/886\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x: u8 = 1;\n+    /// (x as u32) > 300;\n+    /// ```\n+    pub INVALID_UPCAST_COMPARISONS,\n+    pedantic,\n+    \"a comparison involving an upcast which is always true or false\"\n+}\n+\n+declare_lint_pass!(InvalidUpcastComparisons => [INVALID_UPCAST_COMPARISONS]);\n+\n+#[derive(Copy, Clone, Debug, Eq)]\n+enum FullInt {\n+    S(i128),\n+    U(u128),\n+}\n+\n+impl FullInt {\n+    #[allow(clippy::cast_sign_loss)]\n+    #[must_use]\n+    fn cmp_s_u(s: i128, u: u128) -> Ordering {\n+        if s < 0 {\n+            Ordering::Less\n+        } else if u > (i128::MAX as u128) {\n+            Ordering::Greater\n+        } else {\n+            (s as u128).cmp(&u)\n+        }\n+    }\n+}\n+\n+impl PartialEq for FullInt {\n+    #[must_use]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.partial_cmp(other).expect(\"`partial_cmp` only returns `Some(_)`\") == Ordering::Equal\n+    }\n+}\n+\n+impl PartialOrd for FullInt {\n+    #[must_use]\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(match (self, other) {\n+            (&Self::S(s), &Self::S(o)) => s.cmp(&o),\n+            (&Self::U(s), &Self::U(o)) => s.cmp(&o),\n+            (&Self::S(s), &Self::U(o)) => Self::cmp_s_u(s, o),\n+            (&Self::U(s), &Self::S(o)) => Self::cmp_s_u(o, s).reverse(),\n+        })\n+    }\n+}\n+\n+impl Ord for FullInt {\n+    #[must_use]\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.partial_cmp(other)\n+            .expect(\"`partial_cmp` for FullInt can never return `None`\")\n+    }\n+}\n+\n+fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_>, expr: &'a Expr<'_>) -> Option<(FullInt, FullInt)> {\n+    if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n+        let pre_cast_ty = cx.typeck_results().expr_ty(cast_exp);\n+        let cast_ty = cx.typeck_results().expr_ty(expr);\n+        // if it's a cast from i32 to u32 wrapping will invalidate all these checks\n+        if cx.layout_of(pre_cast_ty).ok().map(|l| l.size) == cx.layout_of(cast_ty).ok().map(|l| l.size) {\n+            return None;\n+        }\n+        match pre_cast_ty.kind() {\n+            ty::Int(int_ty) => Some(match int_ty {\n+                IntTy::I8 => (FullInt::S(i128::from(i8::MIN)), FullInt::S(i128::from(i8::MAX))),\n+                IntTy::I16 => (FullInt::S(i128::from(i16::MIN)), FullInt::S(i128::from(i16::MAX))),\n+                IntTy::I32 => (FullInt::S(i128::from(i32::MIN)), FullInt::S(i128::from(i32::MAX))),\n+                IntTy::I64 => (FullInt::S(i128::from(i64::MIN)), FullInt::S(i128::from(i64::MAX))),\n+                IntTy::I128 => (FullInt::S(i128::MIN), FullInt::S(i128::MAX)),\n+                IntTy::Isize => (FullInt::S(isize::MIN as i128), FullInt::S(isize::MAX as i128)),\n+            }),\n+            ty::Uint(uint_ty) => Some(match uint_ty {\n+                UintTy::U8 => (FullInt::U(u128::from(u8::MIN)), FullInt::U(u128::from(u8::MAX))),\n+                UintTy::U16 => (FullInt::U(u128::from(u16::MIN)), FullInt::U(u128::from(u16::MAX))),\n+                UintTy::U32 => (FullInt::U(u128::from(u32::MIN)), FullInt::U(u128::from(u32::MAX))),\n+                UintTy::U64 => (FullInt::U(u128::from(u64::MIN)), FullInt::U(u128::from(u64::MAX))),\n+                UintTy::U128 => (FullInt::U(u128::MIN), FullInt::U(u128::MAX)),\n+                UintTy::Usize => (FullInt::U(usize::MIN as u128), FullInt::U(usize::MAX as u128)),\n+            }),\n+            _ => None,\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+fn node_as_const_fullint<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<FullInt> {\n+    let val = constant(cx, cx.typeck_results(), expr)?.0;\n+    if let Constant::Int(const_int) = val {\n+        match *cx.typeck_results().expr_ty(expr).kind() {\n+            ty::Int(ity) => Some(FullInt::S(sext(cx.tcx, const_int, ity))),\n+            ty::Uint(_) => Some(FullInt::U(const_int)),\n+            _ => None,\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+fn err_upcast_comparison(cx: &LateContext<'_>, span: Span, expr: &Expr<'_>, always: bool) {\n+    if let ExprKind::Cast(ref cast_val, _) = expr.kind {\n+        span_lint(\n+            cx,\n+            INVALID_UPCAST_COMPARISONS,\n+            span,\n+            &format!(\n+                \"because of the numeric bounds on `{}` prior to casting, this expression is always {}\",\n+                snippet(cx, cast_val.span, \"the expression\"),\n+                if always { \"true\" } else { \"false\" },\n+            ),\n+        );\n+    }\n+}\n+\n+fn upcast_comparison_bounds_err<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    span: Span,\n+    rel: comparisons::Rel,\n+    lhs_bounds: Option<(FullInt, FullInt)>,\n+    lhs: &'tcx Expr<'_>,\n+    rhs: &'tcx Expr<'_>,\n+    invert: bool,\n+) {\n+    if let Some((lb, ub)) = lhs_bounds {\n+        if let Some(norm_rhs_val) = node_as_const_fullint(cx, rhs) {\n+            if rel == Rel::Eq || rel == Rel::Ne {\n+                if norm_rhs_val < lb || norm_rhs_val > ub {\n+                    err_upcast_comparison(cx, span, lhs, rel == Rel::Ne);\n+                }\n+            } else if match rel {\n+                Rel::Lt => {\n+                    if invert {\n+                        norm_rhs_val < lb\n+                    } else {\n+                        ub < norm_rhs_val\n+                    }\n+                },\n+                Rel::Le => {\n+                    if invert {\n+                        norm_rhs_val <= lb\n+                    } else {\n+                        ub <= norm_rhs_val\n+                    }\n+                },\n+                Rel::Eq | Rel::Ne => unreachable!(),\n+            } {\n+                err_upcast_comparison(cx, span, lhs, true)\n+            } else if match rel {\n+                Rel::Lt => {\n+                    if invert {\n+                        norm_rhs_val >= ub\n+                    } else {\n+                        lb >= norm_rhs_val\n+                    }\n+                },\n+                Rel::Le => {\n+                    if invert {\n+                        norm_rhs_val > ub\n+                    } else {\n+                        lb > norm_rhs_val\n+                    }\n+                },\n+                Rel::Eq | Rel::Ne => unreachable!(),\n+            } {\n+                err_upcast_comparison(cx, span, lhs, false)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for InvalidUpcastComparisons {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.kind {\n+            let normalized = comparisons::normalize_comparison(cmp.node, lhs, rhs);\n+            let (rel, normalized_lhs, normalized_rhs) = if let Some(val) = normalized {\n+                val\n+            } else {\n+                return;\n+            };\n+\n+            let lhs_bounds = numeric_cast_precast_bounds(cx, normalized_lhs);\n+            let rhs_bounds = numeric_cast_precast_bounds(cx, normalized_rhs);\n+\n+            upcast_comparison_bounds_err(cx, expr.span, rel, lhs_bounds, normalized_lhs, normalized_rhs, false);\n+            upcast_comparison_bounds_err(cx, expr.span, rel, rhs_bounds, normalized_rhs, normalized_lhs, true);\n+        }\n+    }\n+}"}, {"sha": "c16be6da11a8619ff694dcac42b290e0d12170e2", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f231b59b9e3fc1ea074a269b006421295d5402d0/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f231b59b9e3fc1ea074a269b006421295d5402d0/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=f231b59b9e3fc1ea074a269b006421295d5402d0", "patch": "@@ -242,6 +242,7 @@ mod inherent_to_string;\n mod inline_fn_without_body;\n mod int_plus_one;\n mod integer_division;\n+mod invalid_upcast_comparisons;\n mod items_after_statements;\n mod large_const_arrays;\n mod large_enum_variant;\n@@ -697,6 +698,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &inline_fn_without_body::INLINE_FN_WITHOUT_BODY,\n         &int_plus_one::INT_PLUS_ONE,\n         &integer_division::INTEGER_DIVISION,\n+        &invalid_upcast_comparisons::INVALID_UPCAST_COMPARISONS,\n         &items_after_statements::ITEMS_AFTER_STATEMENTS,\n         &large_const_arrays::LARGE_CONST_ARRAYS,\n         &large_enum_variant::LARGE_ENUM_VARIANT,\n@@ -960,7 +962,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &types::BORROWED_BOX,\n         &types::BOX_VEC,\n         &types::IMPLICIT_HASHER,\n-        &types::INVALID_UPCAST_COMPARISONS,\n         &types::LINKEDLIST,\n         &types::OPTION_OPTION,\n         &types::RC_BUFFER,\n@@ -1114,7 +1115,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box drop_forget_ref::DropForgetRef);\n     store.register_late_pass(|| box empty_enum::EmptyEnum);\n     store.register_late_pass(|| box absurd_extreme_comparisons::AbsurdExtremeComparisons);\n-    store.register_late_pass(|| box types::InvalidUpcastComparisons);\n+    store.register_late_pass(|| box invalid_upcast_comparisons::InvalidUpcastComparisons);\n     store.register_late_pass(|| box regex::Regex::default());\n     store.register_late_pass(|| box copies::CopyAndPaste);\n     store.register_late_pass(|| box copy_iterator::CopyIterator);\n@@ -1374,6 +1375,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&if_not_else::IF_NOT_ELSE),\n         LintId::of(&implicit_saturating_sub::IMPLICIT_SATURATING_SUB),\n         LintId::of(&infinite_iter::MAYBE_INFINITE_ITER),\n+        LintId::of(&invalid_upcast_comparisons::INVALID_UPCAST_COMPARISONS),\n         LintId::of(&items_after_statements::ITEMS_AFTER_STATEMENTS),\n         LintId::of(&large_stack_arrays::LARGE_STACK_ARRAYS),\n         LintId::of(&let_underscore::LET_UNDERSCORE_DROP),\n@@ -1413,7 +1415,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n         LintId::of(&trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n         LintId::of(&types::IMPLICIT_HASHER),\n-        LintId::of(&types::INVALID_UPCAST_COMPARISONS),\n         LintId::of(&types::LINKEDLIST),\n         LintId::of(&types::OPTION_OPTION),\n         LintId::of(&unicode::NON_ASCII_LITERAL),"}, {"sha": "785f2c511d0f1ac8975b910ea436bc20c4a0bf69", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 2, "deletions": 213, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/f231b59b9e3fc1ea074a269b006421295d5402d0/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f231b59b9e3fc1ea074a269b006421295d5402d0/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=f231b59b9e3fc1ea074a269b006421295d5402d0", "patch": "@@ -10,7 +10,6 @@ mod utils;\n mod vec_box;\n \n use std::borrow::Cow;\n-use std::cmp::Ordering;\n use std::collections::BTreeMap;\n \n use clippy_utils::diagnostics::{multispan_sugg, span_lint, span_lint_and_then};\n@@ -27,17 +26,15 @@ use rustc_hir::{\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, IntTy, Ty, TyS, TypeckResults, UintTy};\n+use rustc_middle::ty::{Ty, TyS, TypeckResults};\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::sym;\n-use rustc_target::abi::LayoutOf;\n use rustc_target::spec::abi::Abi;\n use rustc_typeck::hir_ty_to_ty;\n \n-use crate::consts::{constant, Constant};\n use clippy_utils::paths;\n-use clippy_utils::{comparisons, differing_macro_contexts, match_path, sext};\n+use clippy_utils::{differing_macro_contexts, match_path};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for use of `Box<Vec<_>>` anywhere in the code.\n@@ -552,214 +549,6 @@ impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n     }\n }\n \n-declare_clippy_lint! {\n-    /// **What it does:** Checks for comparisons where the relation is always either\n-    /// true or false, but where one side has been upcast so that the comparison is\n-    /// necessary. Only integer types are checked.\n-    ///\n-    /// **Why is this bad?** An expression like `let x : u8 = ...; (x as u32) > 300`\n-    /// will mistakenly imply that it is possible for `x` to be outside the range of\n-    /// `u8`.\n-    ///\n-    /// **Known problems:**\n-    /// https://github.com/rust-lang/rust-clippy/issues/886\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let x: u8 = 1;\n-    /// (x as u32) > 300;\n-    /// ```\n-    pub INVALID_UPCAST_COMPARISONS,\n-    pedantic,\n-    \"a comparison involving an upcast which is always true or false\"\n-}\n-\n-declare_lint_pass!(InvalidUpcastComparisons => [INVALID_UPCAST_COMPARISONS]);\n-\n-#[derive(Copy, Clone, Debug, Eq)]\n-enum FullInt {\n-    S(i128),\n-    U(u128),\n-}\n-\n-impl FullInt {\n-    #[allow(clippy::cast_sign_loss)]\n-    #[must_use]\n-    fn cmp_s_u(s: i128, u: u128) -> Ordering {\n-        if s < 0 {\n-            Ordering::Less\n-        } else if u > (i128::MAX as u128) {\n-            Ordering::Greater\n-        } else {\n-            (s as u128).cmp(&u)\n-        }\n-    }\n-}\n-\n-impl PartialEq for FullInt {\n-    #[must_use]\n-    fn eq(&self, other: &Self) -> bool {\n-        self.partial_cmp(other).expect(\"`partial_cmp` only returns `Some(_)`\") == Ordering::Equal\n-    }\n-}\n-\n-impl PartialOrd for FullInt {\n-    #[must_use]\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        Some(match (self, other) {\n-            (&Self::S(s), &Self::S(o)) => s.cmp(&o),\n-            (&Self::U(s), &Self::U(o)) => s.cmp(&o),\n-            (&Self::S(s), &Self::U(o)) => Self::cmp_s_u(s, o),\n-            (&Self::U(s), &Self::S(o)) => Self::cmp_s_u(o, s).reverse(),\n-        })\n-    }\n-}\n-\n-impl Ord for FullInt {\n-    #[must_use]\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.partial_cmp(other)\n-            .expect(\"`partial_cmp` for FullInt can never return `None`\")\n-    }\n-}\n-\n-fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_>, expr: &'a Expr<'_>) -> Option<(FullInt, FullInt)> {\n-    if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n-        let pre_cast_ty = cx.typeck_results().expr_ty(cast_exp);\n-        let cast_ty = cx.typeck_results().expr_ty(expr);\n-        // if it's a cast from i32 to u32 wrapping will invalidate all these checks\n-        if cx.layout_of(pre_cast_ty).ok().map(|l| l.size) == cx.layout_of(cast_ty).ok().map(|l| l.size) {\n-            return None;\n-        }\n-        match pre_cast_ty.kind() {\n-            ty::Int(int_ty) => Some(match int_ty {\n-                IntTy::I8 => (FullInt::S(i128::from(i8::MIN)), FullInt::S(i128::from(i8::MAX))),\n-                IntTy::I16 => (FullInt::S(i128::from(i16::MIN)), FullInt::S(i128::from(i16::MAX))),\n-                IntTy::I32 => (FullInt::S(i128::from(i32::MIN)), FullInt::S(i128::from(i32::MAX))),\n-                IntTy::I64 => (FullInt::S(i128::from(i64::MIN)), FullInt::S(i128::from(i64::MAX))),\n-                IntTy::I128 => (FullInt::S(i128::MIN), FullInt::S(i128::MAX)),\n-                IntTy::Isize => (FullInt::S(isize::MIN as i128), FullInt::S(isize::MAX as i128)),\n-            }),\n-            ty::Uint(uint_ty) => Some(match uint_ty {\n-                UintTy::U8 => (FullInt::U(u128::from(u8::MIN)), FullInt::U(u128::from(u8::MAX))),\n-                UintTy::U16 => (FullInt::U(u128::from(u16::MIN)), FullInt::U(u128::from(u16::MAX))),\n-                UintTy::U32 => (FullInt::U(u128::from(u32::MIN)), FullInt::U(u128::from(u32::MAX))),\n-                UintTy::U64 => (FullInt::U(u128::from(u64::MIN)), FullInt::U(u128::from(u64::MAX))),\n-                UintTy::U128 => (FullInt::U(u128::MIN), FullInt::U(u128::MAX)),\n-                UintTy::Usize => (FullInt::U(usize::MIN as u128), FullInt::U(usize::MAX as u128)),\n-            }),\n-            _ => None,\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n-fn node_as_const_fullint<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<FullInt> {\n-    let val = constant(cx, cx.typeck_results(), expr)?.0;\n-    if let Constant::Int(const_int) = val {\n-        match *cx.typeck_results().expr_ty(expr).kind() {\n-            ty::Int(ity) => Some(FullInt::S(sext(cx.tcx, const_int, ity))),\n-            ty::Uint(_) => Some(FullInt::U(const_int)),\n-            _ => None,\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n-fn err_upcast_comparison(cx: &LateContext<'_>, span: Span, expr: &Expr<'_>, always: bool) {\n-    if let ExprKind::Cast(ref cast_val, _) = expr.kind {\n-        span_lint(\n-            cx,\n-            INVALID_UPCAST_COMPARISONS,\n-            span,\n-            &format!(\n-                \"because of the numeric bounds on `{}` prior to casting, this expression is always {}\",\n-                snippet(cx, cast_val.span, \"the expression\"),\n-                if always { \"true\" } else { \"false\" },\n-            ),\n-        );\n-    }\n-}\n-\n-fn upcast_comparison_bounds_err<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    span: Span,\n-    rel: comparisons::Rel,\n-    lhs_bounds: Option<(FullInt, FullInt)>,\n-    lhs: &'tcx Expr<'_>,\n-    rhs: &'tcx Expr<'_>,\n-    invert: bool,\n-) {\n-    use clippy_utils::comparisons::Rel;\n-\n-    if let Some((lb, ub)) = lhs_bounds {\n-        if let Some(norm_rhs_val) = node_as_const_fullint(cx, rhs) {\n-            if rel == Rel::Eq || rel == Rel::Ne {\n-                if norm_rhs_val < lb || norm_rhs_val > ub {\n-                    err_upcast_comparison(cx, span, lhs, rel == Rel::Ne);\n-                }\n-            } else if match rel {\n-                Rel::Lt => {\n-                    if invert {\n-                        norm_rhs_val < lb\n-                    } else {\n-                        ub < norm_rhs_val\n-                    }\n-                },\n-                Rel::Le => {\n-                    if invert {\n-                        norm_rhs_val <= lb\n-                    } else {\n-                        ub <= norm_rhs_val\n-                    }\n-                },\n-                Rel::Eq | Rel::Ne => unreachable!(),\n-            } {\n-                err_upcast_comparison(cx, span, lhs, true)\n-            } else if match rel {\n-                Rel::Lt => {\n-                    if invert {\n-                        norm_rhs_val >= ub\n-                    } else {\n-                        lb >= norm_rhs_val\n-                    }\n-                },\n-                Rel::Le => {\n-                    if invert {\n-                        norm_rhs_val > ub\n-                    } else {\n-                        lb > norm_rhs_val\n-                    }\n-                },\n-                Rel::Eq | Rel::Ne => unreachable!(),\n-            } {\n-                err_upcast_comparison(cx, span, lhs, false)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for InvalidUpcastComparisons {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.kind {\n-            let normalized = comparisons::normalize_comparison(cmp.node, lhs, rhs);\n-            let (rel, normalized_lhs, normalized_rhs) = if let Some(val) = normalized {\n-                val\n-            } else {\n-                return;\n-            };\n-\n-            let lhs_bounds = numeric_cast_precast_bounds(cx, normalized_lhs);\n-            let rhs_bounds = numeric_cast_precast_bounds(cx, normalized_rhs);\n-\n-            upcast_comparison_bounds_err(cx, expr.span, rel, lhs_bounds, normalized_lhs, normalized_rhs, false);\n-            upcast_comparison_bounds_err(cx, expr.span, rel, rhs_bounds, normalized_rhs, normalized_lhs, true);\n-        }\n-    }\n-}\n-\n declare_clippy_lint! {\n     /// **What it does:** Checks for public `impl` or `fn` missing generalization\n     /// over different hashers and implicitly defaulting to the default hashing"}]}