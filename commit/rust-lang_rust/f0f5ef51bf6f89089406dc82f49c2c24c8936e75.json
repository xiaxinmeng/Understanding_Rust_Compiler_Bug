{"sha": "f0f5ef51bf6f89089406dc82f49c2c24c8936e75", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwZjVlZjUxYmY2Zjg5MDg5NDA2ZGM4MmY0OWMyYzI0Yzg5MzZlNzU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-05-12T15:58:12Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-05-14T04:23:02Z"}, "message": "address review comments", "tree": {"sha": "df6b553308f7989cf48dc0c9880e6650b13e7af6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df6b553308f7989cf48dc0c9880e6650b13e7af6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0f5ef51bf6f89089406dc82f49c2c24c8936e75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0f5ef51bf6f89089406dc82f49c2c24c8936e75", "html_url": "https://github.com/rust-lang/rust/commit/f0f5ef51bf6f89089406dc82f49c2c24c8936e75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0f5ef51bf6f89089406dc82f49c2c24c8936e75/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c39a2ae4439872017574116cb39cff42020fb8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c39a2ae4439872017574116cb39cff42020fb8f", "html_url": "https://github.com/rust-lang/rust/commit/5c39a2ae4439872017574116cb39cff42020fb8f"}], "stats": {"total": 152, "additions": 90, "deletions": 62}, "files": [{"sha": "d9d0367bdcb10a872878dacdd5b68bd2a1a9c7ea", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f0f5ef51bf6f89089406dc82f49c2c24c8936e75/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f5ef51bf6f89089406dc82f49c2c24c8936e75/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=f0f5ef51bf6f89089406dc82f49c2c24c8936e75", "patch": "@@ -13,6 +13,7 @@ use infer::{InferCtxt, InferOk};\n use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, TyCtxt};\n use rustc_data_structures::obligation_forest::{ObligationForest, Error};\n use rustc_data_structures::obligation_forest::{ForestObligation, ObligationProcessor};\n+use std::marker::PhantomData;\n use std::mem;\n use syntax::ast;\n use util::common::ErrorReported;\n@@ -314,13 +315,14 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n             }).collect()))\n     }\n \n-    fn process_backedge<'c, I>(&mut self, cycle: I)\n-        where I: Clone + Iterator<Item=*const Self::Obligation>,\n+    fn process_backedge<'c, I>(&mut self, cycle: I,\n+                               _marker: PhantomData<&'c PendingPredicateObligation<'tcx>>)\n+        where I: Clone + Iterator<Item=&'c PendingPredicateObligation<'tcx>>,\n     {\n         if coinductive_match(self.selcx, cycle.clone()) {\n             debug!(\"process_child_obligations: coinductive match\");\n         } else {\n-            let cycle : Vec<_> = cycle.map(|c| unsafe { &*c }.obligation.clone()).collect();\n+            let cycle : Vec<_> = cycle.map(|c| c.obligation.clone()).collect();\n             self.selcx.infcx().report_overflow_error_cycle(&cycle);\n         }\n     }\n@@ -536,13 +538,14 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n /// - it also appears in the backtrace at some position `X`; and,\n /// - all the predicates at positions `X..` between `X` an the top are\n ///   also defaulted traits.\n-fn coinductive_match<'a,'gcx,'tcx,I>(selcx: &mut SelectionContext<'a,'gcx,'tcx>, cycle: I) -> bool\n-    where I: Iterator<Item=*const PendingPredicateObligation<'tcx>>\n+fn coinductive_match<'a,'c,'gcx,'tcx,I>(selcx: &mut SelectionContext<'a,'gcx,'tcx>,\n+                                        cycle: I) -> bool\n+    where I: Iterator<Item=&'c PendingPredicateObligation<'tcx>>,\n+          'tcx: 'c\n {\n     let mut cycle = cycle;\n     cycle\n         .all(|bt_obligation| {\n-            let bt_obligation = unsafe { &*bt_obligation };\n             let result = coinductive_obligation(selcx, &bt_obligation.obligation);\n             debug!(\"coinductive_match: bt_obligation={:?} coinductive={}\",\n                    bt_obligation, result);"}, {"sha": "b713b2285a65feb4418b9f7336c41b48e1c45522", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 75, "deletions": 51, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/f0f5ef51bf6f89089406dc82f49c2c24c8936e75/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f5ef51bf6f89089406dc82f49c2c24c8936e75/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=f0f5ef51bf6f89089406dc82f49c2c24c8936e75", "patch": "@@ -21,15 +21,16 @@ use std::cell::Cell;\n use std::collections::hash_map::Entry;\n use std::fmt::Debug;\n use std::hash;\n+use std::marker::PhantomData;\n \n mod node_index;\n use self::node_index::NodeIndex;\n \n #[cfg(test)]\n mod test;\n \n-pub trait ForestObligation : Clone {\n-    type Predicate : Clone + hash::Hash + Eq + ::std::fmt::Debug;\n+pub trait ForestObligation : Clone + Debug {\n+    type Predicate : Clone + hash::Hash + Eq + Debug;\n \n     fn as_predicate(&self) -> &Self::Predicate;\n }\n@@ -42,9 +43,9 @@ pub trait ObligationProcessor {\n                           obligation: &mut Self::Obligation)\n                           -> Result<Option<Vec<Self::Obligation>>, Self::Error>;\n \n-    // FIXME: crazy lifetime troubles\n-    fn process_backedge<I>(&mut self, cycle: I)\n-        where I: Clone + Iterator<Item=*const Self::Obligation>;\n+    fn process_backedge<'c, I>(&mut self, cycle: I,\n+                               _marker: PhantomData<&'c Self::Obligation>)\n+        where I: Clone + Iterator<Item=&'c Self::Obligation>;\n }\n \n struct SnapshotData {\n@@ -66,8 +67,12 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// at a higher index than its parent. This is needed by the\n     /// backtrace iterator (which uses `split_at`).\n     nodes: Vec<Node<O>>,\n+    /// A cache of predicates that have been successfully completed.\n     done_cache: FnvHashSet<O::Predicate>,\n+    /// An cache of the nodes in `nodes`, indexed by predicate.\n     waiting_cache: FnvHashMap<O::Predicate, NodeIndex>,\n+    /// A list of the obligations added in snapshots, to allow\n+    /// for their removal.\n     cache_list: Vec<O::Predicate>,\n     snapshots: Vec<SnapshotData>,\n     scratch: Option<Vec<usize>>,\n@@ -82,33 +87,33 @@ struct Node<O> {\n     obligation: O,\n     state: Cell<NodeState>,\n \n-    // these both go *in the same direction*.\n+    /// Obligations that depend on this obligation for their\n+    /// completion. They must all be in a non-pending state.\n+    dependents: Vec<NodeIndex>,\n+    /// The parent of a node - the original obligation of\n+    /// which it is a subobligation. Except for error reporting,\n+    /// this is just another member of `dependents`.\n     parent: Option<NodeIndex>,\n-    dependants: Vec<NodeIndex>,\n }\n \n /// The state of one node in some tree within the forest. This\n /// represents the current state of processing for the obligation (of\n /// type `O`) associated with this node.\n+///\n+/// Outside of ObligationForest methods, nodes should be either Pending\n+/// or Waiting.\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n enum NodeState {\n-    /// Obligation not yet resolved to success or error.\n+    /// Obligations for which selection had not yet returned a\n+    /// non-ambiguous result.\n     Pending,\n \n-    /// Used before garbage collection\n+    /// This obligation was selected successfuly, but may or\n+    /// may not have subobligations.\n     Success,\n \n-    /// Used in DFS loops\n-    InLoop,\n-\n-    /// Obligation resolved to success; `num_incomplete_children`\n-    /// indicates the number of children still in an \"incomplete\"\n-    /// state. Incomplete means that either the child is still\n-    /// pending, or it has children which are incomplete. (Basically,\n-    /// there is pending work somewhere in the subtree of the child.)\n-    ///\n-    /// Once all children have completed, success nodes are removed\n-    /// from the vector by the compression step.\n+    /// This obligation was selected sucessfully, but it has\n+    /// a pending subobligation.\n     Waiting,\n \n     /// This obligation, along with its subobligations, are complete,\n@@ -118,6 +123,10 @@ enum NodeState {\n     /// This obligation was resolved to an error. Error nodes are\n     /// removed from the vector by the compression step.\n     Error,\n+\n+    /// This is a temporary state used in DFS loops to detect cycles,\n+    /// it should not exist outside of these DFSes.\n+    OnDfsStack,\n }\n \n #[derive(Debug)]\n@@ -144,7 +153,7 @@ pub struct Error<O, E> {\n     pub backtrace: Vec<O>,\n }\n \n-impl<O: Debug + ForestObligation> ObligationForest<O> {\n+impl<O: ForestObligation> ObligationForest<O> {\n     pub fn new() -> ObligationForest<O> {\n         ObligationForest {\n             nodes: vec![],\n@@ -210,7 +219,12 @@ impl<O: Debug + ForestObligation> ObligationForest<O> {\n                 debug!(\"register_obligation_at({:?}, {:?}) - duplicate of {:?}!\",\n                        obligation, parent, o.get());\n                 if let Some(parent) = parent {\n-                    self.nodes[o.get().get()].dependants.push(parent);\n+                    if self.nodes[o.get().get()].dependents.contains(&parent) {\n+                        debug!(\"register_obligation_at({:?}, {:?}) - duplicate subobligation\",\n+                               obligation, parent);\n+                    } else {\n+                        self.nodes[o.get().get()].dependents.push(parent);\n+                    }\n                 }\n             }\n             Entry::Vacant(v) => {\n@@ -230,7 +244,6 @@ impl<O: Debug + ForestObligation> ObligationForest<O> {\n         assert!(!self.in_snapshot());\n         let mut errors = vec![];\n         for index in 0..self.nodes.len() {\n-            debug_assert!(!self.nodes[index].is_popped());\n             if let NodeState::Pending = self.nodes[index].state.get() {\n                 let backtrace = self.error_at(index);\n                 errors.push(Error {\n@@ -269,8 +282,6 @@ impl<O: Debug + ForestObligation> ObligationForest<O> {\n         let mut stalled = true;\n \n         for index in 0..self.nodes.len() {\n-            debug_assert!(!self.nodes[index].is_popped());\n-\n             debug!(\"process_obligations: node {} == {:?}\",\n                    index,\n                    self.nodes[index]);\n@@ -327,57 +338,69 @@ impl<O: Debug + ForestObligation> ObligationForest<O> {\n         }\n     }\n \n-    pub fn process_cycles<P>(&mut self, processor: &mut P)\n+    /// Mark all NodeState::Success nodes as NodeState::Done and\n+    /// report all cycles between them. This should be called\n+    /// after `mark_as_waiting` marks all nodes with pending\n+    /// subobligations as NodeState::Waiting.\n+    fn process_cycles<P>(&mut self, processor: &mut P)\n         where P: ObligationProcessor<Obligation=O>\n     {\n         let mut stack = self.scratch.take().unwrap();\n \n         for node in 0..self.nodes.len() {\n-            self.visit_node(&mut stack, processor, node);\n+            self.find_cycles_from_node(&mut stack, processor, node);\n         }\n \n         self.scratch = Some(stack);\n     }\n \n-    fn visit_node<P>(&self, stack: &mut Vec<usize>, processor: &mut P, index: usize)\n+    fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>,\n+                                processor: &mut P, index: usize)\n         where P: ObligationProcessor<Obligation=O>\n     {\n         let node = &self.nodes[index];\n         let state = node.state.get();\n         match state {\n-            NodeState::InLoop => {\n+            NodeState::OnDfsStack => {\n                 let index =\n                     stack.iter().rposition(|n| *n == index).unwrap();\n                 // I need a Clone closure\n                 #[derive(Clone)]\n                 struct GetObligation<'a, O: 'a>(&'a [Node<O>]);\n                 impl<'a, 'b, O> FnOnce<(&'b usize,)> for GetObligation<'a, O> {\n-                    type Output = *const O;\n-                    extern \"rust-call\" fn call_once(self, args: (&'b usize,)) -> *const O {\n+                    type Output = &'a O;\n+                    extern \"rust-call\" fn call_once(self, args: (&'b usize,)) -> &'a O {\n                         &self.0[*args.0].obligation\n                     }\n                 }\n                 impl<'a, 'b, O> FnMut<(&'b usize,)> for GetObligation<'a, O> {\n-                    extern \"rust-call\" fn call_mut(&mut self, args: (&'b usize,)) -> *const O {\n+                    extern \"rust-call\" fn call_mut(&mut self, args: (&'b usize,)) -> &'a O {\n                         &self.0[*args.0].obligation\n                     }\n                 }\n \n-                processor.process_backedge(stack[index..].iter().map(GetObligation(&self.nodes)));\n+                processor.process_backedge(stack[index..].iter().map(GetObligation(&self.nodes)),\n+                                           PhantomData);\n             }\n             NodeState::Success => {\n-                node.state.set(NodeState::InLoop);\n+                node.state.set(NodeState::OnDfsStack);\n                 stack.push(index);\n                 if let Some(parent) = node.parent {\n-                    self.visit_node(stack, processor, parent.get());\n+                    self.find_cycles_from_node(stack, processor, parent.get());\n                 }\n-                for dependant in &node.dependants {\n-                        self.visit_node(stack, processor, dependant.get());\n+                for dependent in &node.dependents {\n+                    self.find_cycles_from_node(stack, processor, dependent.get());\n                 }\n                 stack.pop();\n                 node.state.set(NodeState::Done);\n             },\n-            _ => return\n+            NodeState::Waiting | NodeState::Pending => {\n+                // this node is still reachable from some pending node. We\n+                // will get to it when they are all processed.\n+            }\n+            NodeState::Done | NodeState::Error => {\n+                // already processed that node\n+            }\n         };\n     }\n \n@@ -391,7 +414,7 @@ impl<O: Debug + ForestObligation> ObligationForest<O> {\n         loop {\n             self.nodes[n].state.set(NodeState::Error);\n             trace.push(self.nodes[n].obligation.clone());\n-            error_stack.extend(self.nodes[n].dependants.iter().map(|x| x.get()));\n+            error_stack.extend(self.nodes[n].dependents.iter().map(|x| x.get()));\n \n             // loop to the parent\n             match self.nodes[n].parent {\n@@ -415,15 +438,15 @@ impl<O: Debug + ForestObligation> ObligationForest<O> {\n             }\n \n             error_stack.extend(\n-                node.dependants.iter().cloned().chain(node.parent).map(|x| x.get())\n+                node.dependents.iter().cloned().chain(node.parent).map(|x| x.get())\n             );\n         }\n \n         self.scratch = Some(error_stack);\n         trace\n     }\n \n-    /// Marks all nodes that depend on a pending node as \"waiting\".\n+    /// Marks all nodes that depend on a pending node as NodeState;:Waiting.\n     fn mark_as_waiting(&self) {\n         for node in &self.nodes {\n             if node.state.get() == NodeState::Waiting {\n@@ -441,7 +464,7 @@ impl<O: Debug + ForestObligation> ObligationForest<O> {\n     fn mark_as_waiting_from(&self, node: &Node<O>) {\n         match node.state.get() {\n             NodeState::Pending | NodeState::Done => {},\n-            NodeState::Waiting | NodeState::Error | NodeState::InLoop => return,\n+            NodeState::Waiting | NodeState::Error | NodeState::OnDfsStack => return,\n             NodeState::Success => {\n                 node.state.set(NodeState::Waiting);\n             }\n@@ -451,8 +474,8 @@ impl<O: Debug + ForestObligation> ObligationForest<O> {\n             self.mark_as_waiting_from(&self.nodes[parent.get()]);\n         }\n \n-        for dependant in &node.dependants {\n-            self.mark_as_waiting_from(&self.nodes[dependant.get()]);\n+        for dependent in &node.dependents {\n+            self.mark_as_waiting_from(&self.nodes[dependent.get()]);\n         }\n     }\n \n@@ -546,12 +569,12 @@ impl<O: Debug + ForestObligation> ObligationForest<O> {\n             }\n \n             let mut i = 0;\n-            while i < node.dependants.len() {\n-                let new_index = node_rewrites[node.dependants[i].get()];\n+            while i < node.dependents.len() {\n+                let new_index = node_rewrites[node.dependents[i].get()];\n                 if new_index >= nodes_len {\n-                    node.dependants.swap_remove(i);\n+                    node.dependents.swap_remove(i);\n                 } else {\n-                    node.dependants[i] = NodeIndex::new(new_index);\n+                    node.dependents[i] = NodeIndex::new(new_index);\n                     i += 1;\n                 }\n             }\n@@ -577,14 +600,15 @@ impl<O> Node<O> {\n             obligation: obligation,\n             parent: parent,\n             state: Cell::new(NodeState::Pending),\n-            dependants: vec![],\n+            dependents: vec![],\n         }\n     }\n \n     fn is_popped(&self) -> bool {\n         match self.state.get() {\n-            NodeState::Pending | NodeState::Success | NodeState::Waiting => false,\n-            NodeState::Error | NodeState::Done | NodeState::InLoop => true,\n+            NodeState::Pending | NodeState::Waiting => false,\n+            NodeState::Error | NodeState::Done => true,\n+            NodeState::OnDfsStack | NodeState::Success => unreachable!()\n         }\n     }\n }"}, {"sha": "8eac8892a3efe42c65f874bc0d5c14370a0aacd1", "filename": "src/librustc_data_structures/obligation_forest/test.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f0f5ef51bf6f89089406dc82f49c2c24c8936e75/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f5ef51bf6f89089406dc82f49c2c24c8936e75/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs?ref=f0f5ef51bf6f89089406dc82f49c2c24c8936e75", "patch": "@@ -25,7 +25,7 @@ impl<'a> super::ForestObligation for &'a str {\n \n struct ClosureObligationProcessor<OF, BF, O, E> {\n     process_obligation: OF,\n-    process_backedge: BF,\n+    _process_backedge: BF,\n     marker: PhantomData<(O, E)>,\n }\n \n@@ -36,7 +36,7 @@ fn C<OF, BF, O>(of: OF, bf: BF) -> ClosureObligationProcessor<OF, BF, O, &'stati\n {\n     ClosureObligationProcessor {\n         process_obligation: of,\n-        process_backedge: bf,\n+        _process_backedge: bf,\n         marker: PhantomData\n     }\n }\n@@ -57,9 +57,10 @@ impl<OF, BF, O, E> ObligationProcessor for ClosureObligationProcessor<OF, BF, O,\n         (self.process_obligation)(obligation)\n     }\n \n-    fn process_backedge(&mut self, cycle: &[Self::Obligation]) {\n-        (self.process_backedge)(cycle);\n-    }\n+    fn process_backedge<'c, I>(&mut self, _cycle: I,\n+                               _marker: PhantomData<&'c Self::Obligation>)\n+        where I: Clone + Iterator<Item=&'c Self::Obligation> {\n+        }\n }\n \n "}]}