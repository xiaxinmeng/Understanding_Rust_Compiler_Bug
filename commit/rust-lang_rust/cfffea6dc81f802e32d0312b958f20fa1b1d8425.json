{"sha": "cfffea6dc81f802e32d0312b958f20fa1b1d8425", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmZmZlYTZkYzgxZjgwMmUzMmQwMzEyYjk1OGYyMGZhMWIxZDg0MjU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-24T10:57:45Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-24T10:57:45Z"}, "message": "Push poison_macros down", "tree": {"sha": "3e11bf65441d7e770ea0fa8fb652c7b9b4cadc0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e11bf65441d7e770ea0fa8fb652c7b9b4cadc0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfffea6dc81f802e32d0312b958f20fa1b1d8425", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfffea6dc81f802e32d0312b958f20fa1b1d8425", "html_url": "https://github.com/rust-lang/rust/commit/cfffea6dc81f802e32d0312b958f20fa1b1d8425", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfffea6dc81f802e32d0312b958f20fa1b1d8425/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0e0a40a6106e979843f97001bb3db59ceb29557", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0e0a40a6106e979843f97001bb3db59ceb29557", "html_url": "https://github.com/rust-lang/rust/commit/f0e0a40a6106e979843f97001bb3db59ceb29557"}], "stats": {"total": 53, "additions": 28, "deletions": 25}, "files": [{"sha": "f6cf59c5fa8660cd339ab5447c2583ce9d414461", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cfffea6dc81f802e32d0312b958f20fa1b1d8425/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfffea6dc81f802e32d0312b958f20fa1b1d8425/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=cfffea6dc81f802e32d0312b958f20fa1b1d8425", "patch": "@@ -66,7 +66,7 @@ use ra_arena::Arena;\n use ra_db::{CrateId, Edition, FileId};\n use ra_prof::profile;\n use ra_syntax::ast;\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashMap;\n \n use crate::{\n     builtin_type::BuiltinType,\n@@ -90,18 +90,6 @@ pub struct CrateDefMap {\n     root: LocalModuleId,\n     modules: Arena<LocalModuleId, ModuleData>,\n \n-    /// Some macros are not well-behavior, which leads to infinite loop\n-    /// e.g. macro_rules! foo { ($ty:ty) => { foo!($ty); } }\n-    /// We mark it down and skip it in collector\n-    ///\n-    /// FIXME:\n-    /// Right now it only handle a poison macro in a single crate,\n-    /// such that if other crate try to call that macro,\n-    /// the whole process will do again until it became poisoned in that crate.\n-    /// We should handle this macro set globally\n-    /// However, do we want to put it as a global variable?\n-    poison_macros: FxHashSet<MacroDefId>,\n-\n     diagnostics: Vec<DefDiagnostic>,\n }\n \n@@ -234,7 +222,6 @@ impl CrateDefMap {\n                 prelude: None,\n                 root,\n                 modules,\n-                poison_macros: FxHashSet::default(),\n                 diagnostics: Vec::new(),\n             }\n         };"}, {"sha": "1d004b6a600e454cd3f962d642ceab4eb4bb43bd", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cfffea6dc81f802e32d0312b958f20fa1b1d8425/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfffea6dc81f802e32d0312b958f20fa1b1d8425/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=cfffea6dc81f802e32d0312b958f20fa1b1d8425", "patch": "@@ -8,7 +8,7 @@ use hir_expand::{\n use ra_cfg::CfgOptions;\n use ra_db::{CrateId, FileId};\n use ra_syntax::{ast, SmolStr};\n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use test_utils::tested_by;\n \n use crate::{\n@@ -57,6 +57,7 @@ pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> C\n         unexpanded_macros: Vec::new(),\n         mod_dirs: FxHashMap::default(),\n         macro_stack_monitor: MacroStackMonitor::default(),\n+        poison_macros: FxHashSet::default(),\n         cfg_options,\n     };\n     collector.collect();\n@@ -103,6 +104,17 @@ struct DefCollector<'a, DB> {\n     /// Some macro use `$tt:tt which mean we have to handle the macro perfectly\n     /// To prevent stack overflow, we add a deep counter here for prevent that.\n     macro_stack_monitor: MacroStackMonitor,\n+    /// Some macros are not well-behavior, which leads to infinite loop\n+    /// e.g. macro_rules! foo { ($ty:ty) => { foo!($ty); } }\n+    /// We mark it down and skip it in collector\n+    ///\n+    /// FIXME:\n+    /// Right now it only handle a poison macro in a single crate,\n+    /// such that if other crate try to call that macro,\n+    /// the whole process will do again until it became poisoned in that crate.\n+    /// We should handle this macro set globally\n+    /// However, do we want to put it as a global variable?\n+    poison_macros: FxHashSet<MacroDefId>,\n \n     cfg_options: &'a CfgOptions,\n }\n@@ -489,7 +501,7 @@ where\n         macro_call_id: MacroCallId,\n         macro_def_id: MacroDefId,\n     ) {\n-        if self.def_map.poison_macros.contains(&macro_def_id) {\n+        if self.poison_macros.contains(&macro_def_id) {\n             return;\n         }\n \n@@ -509,7 +521,7 @@ where\n             .collect(raw_items.items());\n         } else {\n             log::error!(\"Too deep macro expansion: {:?}\", macro_call_id);\n-            self.def_map.poison_macros.insert(macro_def_id);\n+            self.poison_macros.insert(macro_def_id);\n         }\n \n         self.macro_stack_monitor.decrease(macro_def_id);\n@@ -807,7 +819,7 @@ mod tests {\n         db: &impl DefDatabase,\n         def_map: CrateDefMap,\n         monitor: MacroStackMonitor,\n-    ) -> CrateDefMap {\n+    ) -> (CrateDefMap, FxHashSet<MacroDefId>) {\n         let mut collector = DefCollector {\n             db,\n             def_map,\n@@ -816,13 +828,18 @@ mod tests {\n             unexpanded_macros: Vec::new(),\n             mod_dirs: FxHashMap::default(),\n             macro_stack_monitor: monitor,\n+            poison_macros: FxHashSet::default(),\n             cfg_options: &CfgOptions::default(),\n         };\n         collector.collect();\n-        collector.finish()\n+        (collector.def_map, collector.poison_macros)\n     }\n \n-    fn do_limited_resolve(code: &str, limit: u32, poison_limit: u32) -> CrateDefMap {\n+    fn do_limited_resolve(\n+        code: &str,\n+        limit: u32,\n+        poison_limit: u32,\n+    ) -> (CrateDefMap, FxHashSet<MacroDefId>) {\n         let (db, _file_id) = TestDB::with_single_file(&code);\n         let krate = db.test_crate();\n \n@@ -837,7 +854,6 @@ mod tests {\n                 prelude: None,\n                 root,\n                 modules,\n-                poison_macros: FxHashSet::default(),\n                 diagnostics: Vec::new(),\n             }\n         };\n@@ -867,7 +883,7 @@ foo!(KABOOM);\n \n     #[test]\n     fn test_macro_expand_poisoned() {\n-        let def = do_limited_resolve(\n+        let (_, poison_macros) = do_limited_resolve(\n             r#\"\n         macro_rules! foo {\n             ($ty:ty) => { foo!($ty); }\n@@ -878,12 +894,12 @@ foo!(KABOOM);\n             16,\n         );\n \n-        assert_eq!(def.poison_macros.len(), 1);\n+        assert_eq!(poison_macros.len(), 1);\n     }\n \n     #[test]\n     fn test_macro_expand_normal() {\n-        let def = do_limited_resolve(\n+        let (_, poison_macros) = do_limited_resolve(\n             r#\"\n         macro_rules! foo {\n             ($ident:ident) => { struct $ident {} }\n@@ -894,6 +910,6 @@ foo!(Bar);\n             16,\n         );\n \n-        assert_eq!(def.poison_macros.len(), 0);\n+        assert_eq!(poison_macros.len(), 0);\n     }\n }"}]}