{"sha": "c4454a5507be95da969712ac0326055635efe778", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0NDU0YTU1MDdiZTk1ZGE5Njk3MTJhYzAzMjYwNTU2MzVlZmU3Nzg=", "commit": {"author": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2017-03-18T19:24:44Z"}, "committer": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2017-03-21T19:46:20Z"}, "message": "Tweak the constants a bit", "tree": {"sha": "30a095b26d8994940a6bd53d5780b1f1a9a6fcfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30a095b26d8994940a6bd53d5780b1f1a9a6fcfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4454a5507be95da969712ac0326055635efe778", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4454a5507be95da969712ac0326055635efe778", "html_url": "https://github.com/rust-lang/rust/commit/c4454a5507be95da969712ac0326055635efe778", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4454a5507be95da969712ac0326055635efe778/comments", "author": null, "committer": null, "parents": [{"sha": "942173b38fc0c202e8f28f266d6c4df4acfc5a91", "url": "https://api.github.com/repos/rust-lang/rust/commits/942173b38fc0c202e8f28f266d6c4df4acfc5a91", "html_url": "https://github.com/rust-lang/rust/commit/942173b38fc0c202e8f28f266d6c4df4acfc5a91"}], "stats": {"total": 14, "additions": 7, "deletions": 7}, "files": [{"sha": "5233887620a91e48dff6b371181661d6a3f90122", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c4454a5507be95da969712ac0326055635efe778/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4454a5507be95da969712ac0326055635efe778/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=c4454a5507be95da969712ac0326055635efe778", "patch": "@@ -1668,9 +1668,9 @@ fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n     where F: FnMut(&T, &T) -> bool\n {\n     // Slices of up to this length get sorted using insertion sort.\n-    const MAX_INSERTION: usize = 16;\n+    const MAX_INSERTION: usize = 20;\n     // Very short runs are extended using insertion sort to span at least this many elements.\n-    const MIN_RUN: usize = 8;\n+    const MIN_RUN: usize = 10;\n \n     // Sorting has no meaningful behavior on zero-sized types.\n     if size_of::<T>() == 0 {"}, {"sha": "2ff059b464ab442e1096da35ce805aa7496e7aa7", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c4454a5507be95da969712ac0326055635efe778/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4454a5507be95da969712ac0326055635efe778/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=c4454a5507be95da969712ac0326055635efe778", "patch": "@@ -355,7 +355,7 @@ fn partition<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> (usize, bool)\n                 l += 1;\n             }\n \n-            // Find the last element lesser that the pivot.\n+            // Find the last element smaller that the pivot.\n             while l < r && !is_less(v.get_unchecked(r - 1), pivot) {\n                 r -= 1;\n             }\n@@ -472,7 +472,7 @@ fn choose_pivot<T, F>(v: &mut [T], is_less: &mut F) -> (usize, bool)\n {\n     // Minimal length to choose the median-of-medians method.\n     // Shorter slices use the simple median-of-three method.\n-    const SHORTEST_MEDIAN_OF_MEDIANS: usize = 90;\n+    const SHORTEST_MEDIAN_OF_MEDIANS: usize = 80;\n     // Maximal number of swaps that can be performed in this function.\n     const MAX_SWAPS: usize = 4 * 3;\n \n@@ -539,7 +539,7 @@ fn recurse<'a, T, F>(mut v: &'a mut [T], is_less: &mut F, mut pred: Option<&'a T\n     where F: FnMut(&T, &T) -> bool\n {\n     // Slices of up to this length get sorted using insertion sort.\n-    const MAX_INSERTION: usize = 16;\n+    const MAX_INSERTION: usize = 20;\n \n     // True if the last partitioning was reasonably balanced.\n     let mut was_balanced = true;\n@@ -627,8 +627,8 @@ pub fn quicksort<T, F>(v: &mut [T], mut is_less: F)\n         return;\n     }\n \n-    // Limit the number of imbalanced partitions to `floor(log2(len)) + 2`.\n-    let limit = mem::size_of::<usize>() * 8 - v.len().leading_zeros() as usize + 1;\n+    // Limit the number of imbalanced partitions to `floor(log2(len)) + 1`.\n+    let limit = mem::size_of::<usize>() * 8 - v.len().leading_zeros() as usize;\n \n     recurse(v, &mut is_less, None, limit);\n }"}]}