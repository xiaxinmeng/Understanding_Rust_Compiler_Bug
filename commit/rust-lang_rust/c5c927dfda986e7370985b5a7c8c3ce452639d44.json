{"sha": "c5c927dfda986e7370985b5a7c8c3ce452639d44", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1YzkyN2RmZGE5ODZlNzM3MDk4NWI1YTdjOGMzY2U0NTI2MzlkNDQ=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-05-04T11:52:53Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2021-08-05T21:08:28Z"}, "message": "Improve code readability", "tree": {"sha": "316aca9e7aa564bd11d9199124f66097a55ffebb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/316aca9e7aa564bd11d9199124f66097a55ffebb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5c927dfda986e7370985b5a7c8c3ce452639d44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5c927dfda986e7370985b5a7c8c3ce452639d44", "html_url": "https://github.com/rust-lang/rust/commit/c5c927dfda986e7370985b5a7c8c3ce452639d44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5c927dfda986e7370985b5a7c8c3ce452639d44/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38444f61bb89cd8217477e2864e19966ba72acd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/38444f61bb89cd8217477e2864e19966ba72acd4", "html_url": "https://github.com/rust-lang/rust/commit/38444f61bb89cd8217477e2864e19966ba72acd4"}], "stats": {"total": 103, "additions": 46, "deletions": 57}, "files": [{"sha": "edbb5dba1f375daea5d0c1b2ae6fe31508b1900f", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 42, "deletions": 55, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/c5c927dfda986e7370985b5a7c8c3ce452639d44/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5c927dfda986e7370985b5a7c8c3ce452639d44/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=c5c927dfda986e7370985b5a7c8c3ce452639d44", "patch": "@@ -560,64 +560,51 @@ fn string<T: Display>(\n     context: Option<&Context<'_>>,\n     root_path: &str,\n ) {\n-    match klass {\n-        None => write!(out, \"{}\", text),\n-        Some(klass) => {\n-            if let Some(def_span) = klass.get_span() {\n-                let mut text = text.to_string();\n-                if text.contains(\"::\") {\n-                    text =\n-                        text.split(\"::\").enumerate().fold(String::new(), |mut path, (pos, t)| {\n-                            let pre = if pos != 0 { \"::\" } else { \"\" };\n-                            match t {\n-                                \"self\" | \"Self\" => write!(\n-                                    &mut path,\n-                                    \"{}<span class=\\\"{}\\\">{}</span>\",\n-                                    pre,\n-                                    Class::Self_((0, 0)).as_html(),\n-                                    t\n-                                ),\n-                                \"crate\" | \"super\" => write!(\n-                                    &mut path,\n-                                    \"{}<span class=\\\"{}\\\">{}</span>\",\n-                                    pre,\n-                                    Class::KeyWord.as_html(),\n-                                    t\n-                                ),\n-                                t => write!(&mut path, \"{}{}\", pre, t),\n-                            }\n-                            .expect(\"Failed to build source HTML path\");\n-                            path\n-                        });\n+    let klass = match klass {\n+        None => return write!(out, \"{}\", text),\n+        Some(klass) => klass,\n+    };\n+    if let Some(def_span) = klass.get_span() {\n+        let mut text = text.to_string();\n+        if text.contains(\"::\") {\n+            text = text.split(\"::\").intersperse(\"::\").fold(String::new(), |mut path, t| {\n+                match t {\n+                    \"self\" | \"Self\" => write!(\n+                        &mut path,\n+                        \"<span class=\\\"{}\\\">{}</span>\",\n+                        Class::Self_((0, 0)).as_html(),\n+                        t\n+                    ),\n+                    \"crate\" | \"super\" => write!(\n+                        &mut path,\n+                        \"<span class=\\\"{}\\\">{}</span>\",\n+                        Class::KeyWord.as_html(),\n+                        t\n+                    ),\n+                    t => write!(&mut path, \"{}\", t),\n                 }\n-                if let Some(context) = context {\n-                    if let Some(href) =\n-                        context.shared.span_correspondance_map.get(&def_span).and_then(|href| {\n-                            match href {\n-                                LinkFromSrc::Local(span) => {\n-                                    eprintln!(\"==> {:?}:{:?}\", span.lo(), span.hi());\n-                                    context\n-                                        .href_from_span(clean::Span::wrap_raw(*span))\n-                                        .map(|s| format!(\"{}{}\", root_path, s))\n-                                }\n-                                LinkFromSrc::External(def_id) => {\n-                                    format::href(*def_id, context).map(|(url, _, _)| url)\n-                                }\n-                            }\n-                        })\n-                    {\n-                        write!(\n-                            out,\n-                            \"<a class=\\\"{}\\\" href=\\\"{}\\\">{}</a>\",\n-                            klass.as_html(),\n-                            href,\n-                            text\n-                        );\n-                        return;\n+                .expect(\"Failed to build source HTML path\");\n+                path\n+            });\n+        }\n+        if let Some(context) = context {\n+            if let Some(href) =\n+                context.shared.span_correspondance_map.get(&def_span).and_then(|href| {\n+                    match href {\n+                        LinkFromSrc::Local(span) => {\n+                            context\n+                                .href_from_span(clean::Span::wrap_raw(*span))\n+                                .map(|s| format!(\"{}{}\", root_path, s))\n+                        }\n+                        LinkFromSrc::External(def_id) => {\n+                            format::href(*def_id, context).map(|(url, _, _)| url)\n+                        }\n                     }\n-                }\n+                })\n+            {\n+                write!(out, \"<a class=\\\"{}\\\" href=\\\"{}\\\">{}</a>\", klass.as_html(), href, text);\n+                return;\n             }\n-            write!(out, \"<span class=\\\"{}\\\">{}</span>\", klass.as_html(), text);\n         }\n     }\n     write!(out, \"<span class=\\\"{}\\\">{}</span>\", klass.as_html(), text);"}, {"sha": "9990d6f0ce6ad30974495e9a18ca602b558f6de1", "filename": "src/librustdoc/html/render/span_map.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c5c927dfda986e7370985b5a7c8c3ce452639d44/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5c927dfda986e7370985b5a7c8c3ce452639d44/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs?ref=c5c927dfda986e7370985b5a7c8c3ce452639d44", "patch": "@@ -9,6 +9,8 @@ use rustc_hir::{ExprKind, GenericParam, GenericParamKind, HirId, Mod, Node};\n use rustc_middle::ty::TyCtxt;\n use rustc_span::Span;\n \n+use std::path::{Path, PathBuf};\n+\n /// This enum allows us to store two different kinds of information:\n ///\n /// In case the `span` definition comes from the same crate, we can simply get the `span` and use\n@@ -35,10 +37,10 @@ crate enum LinkFromSrc {\n crate fn collect_spans_and_sources(\n     tcx: TyCtxt<'_>,\n     krate: clean::Crate,\n-    src_root: &std::path::Path,\n+    src_root: &Path,\n     include_sources: bool,\n     generate_link_to_definition: bool,\n-) -> (clean::Crate, FxHashMap<std::path::PathBuf, String>, FxHashMap<(u32, u32), LinkFromSrc>) {\n+) -> (clean::Crate, FxHashMap<PathBuf, String>, FxHashMap<(u32, u32), LinkFromSrc>) {\n     let mut visitor = SpanMapVisitor { tcx, matches: FxHashMap::default() };\n \n     if include_sources {"}]}