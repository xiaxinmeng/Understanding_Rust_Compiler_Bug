{"sha": "4be067558962c004b638e4c6f162d50f7c0c98b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiZTA2NzU1ODk2MmMwMDRiNjM4ZTRjNmYxNjJkNTBmN2MwYzk4YjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-05T08:16:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-05T08:16:51Z"}, "message": "Auto merge of #63079 - RalfJung:ctfe-no-align, r=oli-obk\n\nCTFE: simplify ConstValue by not checking for alignment\n\nI hope the test suite actually covers the problematic cases here?\n\nr? @oli-obk\n\nFixes https://github.com/rust-lang/rust/issues/61952", "tree": {"sha": "3e040ed019bd3c2b53b5030356bcd387b2243d84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e040ed019bd3c2b53b5030356bcd387b2243d84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4be067558962c004b638e4c6f162d50f7c0c98b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4be067558962c004b638e4c6f162d50f7c0c98b6", "html_url": "https://github.com/rust-lang/rust/commit/4be067558962c004b638e4c6f162d50f7c0c98b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4be067558962c004b638e4c6f162d50f7c0c98b6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1d7e4ae82c5500407e606c0b2b595597b9981f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1d7e4ae82c5500407e606c0b2b595597b9981f3", "html_url": "https://github.com/rust-lang/rust/commit/e1d7e4ae82c5500407e606c0b2b595597b9981f3"}, {"sha": "0cf43291d7007fa8edc31e0d7dda84acc453d86d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cf43291d7007fa8edc31e0d7dda84acc453d86d", "html_url": "https://github.com/rust-lang/rust/commit/0cf43291d7007fa8edc31e0d7dda84acc453d86d"}], "stats": {"total": 108, "additions": 62, "deletions": 46}, "files": [{"sha": "5381d4697244093928b23f79c5eac80214a331d2", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=4be067558962c004b638e4c6f162d50f7c0c98b6", "patch": "@@ -2,7 +2,7 @@ use std::fmt;\n use rustc_macros::HashStable;\n use rustc_apfloat::{Float, ieee::{Double, Single}};\n \n-use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size, Align}, subst::SubstsRef};\n+use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size}, subst::SubstsRef};\n use crate::ty::PlaceholderConst;\n use crate::hir::def_id::DefId;\n \n@@ -45,18 +45,11 @@ pub enum ConstValue<'tcx> {\n \n     /// A value not represented/representable by `Scalar` or `Slice`\n     ByRef {\n-        /// The alignment exists to allow `const_field` to have `ByRef` access to nonprimitive\n-        /// fields of `repr(packed)` structs. The alignment may be lower than the type of this\n-        /// constant. This permits reads with lower alignment than what the type would normally\n-        /// require.\n-        /// FIXME(RalfJ,oli-obk): The alignment checks are part of miri, but const eval doesn't\n-        /// really need them. Disabling them may be too hard though.\n-        align: Align,\n-        /// Offset into `alloc`\n-        offset: Size,\n         /// The backing memory of the value, may contain more memory than needed for just the value\n         /// in order to share `Allocation`s between values\n         alloc: &'tcx Allocation,\n+        /// Offset into `alloc`\n+        offset: Size,\n     },\n \n     /// Used in the HIR by using `Unevaluated` everywhere and later normalizing to one of the other"}, {"sha": "649a5244728baa2a4d7114aea0512ecc71622472", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=4be067558962c004b638e4c6f162d50f7c0c98b6", "patch": "@@ -1367,8 +1367,8 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            ConstValue::ByRef { offset, align, alloc } =>\n-                ConstValue::ByRef { offset, align, alloc },\n+            ConstValue::ByRef { alloc, offset } =>\n+                ConstValue::ByRef { alloc, offset },\n             ConstValue::Infer(ic) => ConstValue::Infer(ic.fold_with(folder)),\n             ConstValue::Param(p) => ConstValue::Param(p.fold_with(folder)),\n             ConstValue::Placeholder(p) => ConstValue::Placeholder(p),"}, {"sha": "b0c94a139be0807763442c582c9b0719b6f12511", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=4be067558962c004b638e4c6f162d50f7c0c98b6", "patch": "@@ -11,7 +11,7 @@ use crate::value::Value;\n use rustc_codegen_ssa::traits::*;\n \n use crate::consts::const_alloc_to_llvm;\n-use rustc::ty::layout::{HasDataLayout, LayoutOf, self, TyLayout, Size, Align};\n+use rustc::ty::layout::{HasDataLayout, LayoutOf, self, TyLayout, Size};\n use rustc::mir::interpret::{Scalar, GlobalAlloc, Allocation};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n \n@@ -329,20 +329,20 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn from_const_alloc(\n         &self,\n         layout: TyLayout<'tcx>,\n-        align: Align,\n         alloc: &Allocation,\n         offset: Size,\n     ) -> PlaceRef<'tcx, &'ll Value> {\n+        assert_eq!(alloc.align, layout.align.abi);\n         let init = const_alloc_to_llvm(self, alloc);\n-        let base_addr = self.static_addr_of(init, align, None);\n+        let base_addr = self.static_addr_of(init, alloc.align, None);\n \n         let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n             self.const_bitcast(base_addr, self.type_i8p()),\n             &self.const_usize(offset.bytes()),\n             1,\n         )};\n         let llval = self.const_bitcast(llval, self.type_ptr_to(layout.llvm_type(self)));\n-        PlaceRef::new_sized(llval, layout, align)\n+        PlaceRef::new_sized(llval, layout, alloc.align)\n     }\n \n     fn const_ptrcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {"}, {"sha": "0077df3cf5eea191dcbc475038ab32a5055b62d7", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=4be067558962c004b638e4c6f162d50f7c0c98b6", "patch": "@@ -72,8 +72,8 @@ pub fn codegen_static_initializer(\n \n     let alloc = match static_.val {\n         ConstValue::ByRef {\n-            offset, align, alloc,\n-        } if offset.bytes() == 0 && align == alloc.align => {\n+            alloc, offset,\n+        } if offset.bytes() == 0 => {\n             alloc\n         },\n         _ => bug!(\"static const eval returned {:#?}\", static_),"}, {"sha": "5e5804b72657b6009228fb19f447bc6f787f1bcc", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=4be067558962c004b638e4c6f162d50f7c0c98b6", "patch": "@@ -109,8 +109,8 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n                 let b_llval = bx.const_usize((end - start) as u64);\n                 OperandValue::Pair(a_llval, b_llval)\n             },\n-            ConstValue::ByRef { offset, align, alloc } => {\n-                return bx.load_operand(bx.from_const_alloc(layout, align, alloc, offset));\n+            ConstValue::ByRef { alloc, offset } => {\n+                return bx.load_operand(bx.from_const_alloc(layout, alloc, offset));\n             },\n         };\n "}, {"sha": "a632838ba24424b5714d1cd77b47a89c95d4c1a0", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=4be067558962c004b638e4c6f162d50f7c0c98b6", "patch": "@@ -466,8 +466,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n                 match bx.tcx().const_eval(param_env.and(cid)) {\n                     Ok(val) => match val.val {\n-                        mir::interpret::ConstValue::ByRef { offset, align, alloc } => {\n-                            bx.cx().from_const_alloc(layout, align, alloc, offset)\n+                        mir::interpret::ConstValue::ByRef { alloc, offset } => {\n+                            bx.cx().from_const_alloc(layout, alloc, offset)\n                         }\n                         _ => bug!(\"promoteds should have an allocation: {:?}\", val),\n                     },"}, {"sha": "e7ce03f1836198293376a553e1e5ee7027ae4f74", "filename": "src/librustc_codegen_ssa/traits/consts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs?ref=4be067558962c004b638e4c6f162d50f7c0c98b6", "patch": "@@ -35,7 +35,6 @@ pub trait ConstMethods<'tcx>: BackendTypes {\n     fn from_const_alloc(\n         &self,\n         layout: layout::TyLayout<'tcx>,\n-        align: layout::Align,\n         alloc: &Allocation,\n         offset: layout::Size,\n     ) -> PlaceRef<'tcx, Self::Value>;"}, {"sha": "36d80d0cb57672866ec97603ac4c1a61f006830e", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=4be067558962c004b638e4c6f162d50f7c0c98b6", "patch": "@@ -98,7 +98,7 @@ fn op_to_const<'tcx>(\n         Ok(mplace) => {\n             let ptr = mplace.ptr.to_ptr().unwrap();\n             let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n-            ConstValue::ByRef { offset: ptr.offset, align: mplace.align, alloc }\n+            ConstValue::ByRef { alloc, offset: ptr.offset }\n         },\n         // see comment on `let try_as_immediate` above\n         Err(ImmTy { imm: Immediate::Scalar(x), .. }) => match x {\n@@ -112,7 +112,7 @@ fn op_to_const<'tcx>(\n                 let mplace = op.assert_mem_place();\n                 let ptr = mplace.ptr.to_ptr().unwrap();\n                 let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n-                ConstValue::ByRef { offset: ptr.offset, align: mplace.align, alloc }\n+                ConstValue::ByRef { alloc, offset: ptr.offset }\n             },\n         },\n         Err(ImmTy { imm: Immediate::ScalarPair(a, b), .. }) => {\n@@ -326,6 +326,10 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n     const STATIC_KIND: Option<!> = None; // no copying of statics allowed\n \n+    // We do not check for alignment to avoid having to carry an `Align`\n+    // in `ConstValue::ByRef`.\n+    const CHECK_ALIGN: bool = false;\n+\n     #[inline(always)]\n     fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n         false // for now, we don't enforce validity\n@@ -561,9 +565,8 @@ fn validate_and_turn_into_const<'tcx>(\n             let ptr = mplace.ptr.to_ptr()?;\n             Ok(tcx.mk_const(ty::Const {\n                 val: ConstValue::ByRef {\n-                    offset: ptr.offset,\n-                    align: mplace.align,\n                     alloc: ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n+                    offset: ptr.offset,\n                 },\n                 ty: mplace.layout.ty,\n             }))"}, {"sha": "b1a317ee65f6f70bbd623fb60958bbe79a65a4c7", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=4be067558962c004b638e4c6f162d50f7c0c98b6", "patch": "@@ -218,10 +218,8 @@ impl LiteralExpander<'tcx> {\n             (ConstValue::Scalar(Scalar::Ptr(p)), x, y) if x == y => {\n                 let alloc = self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id);\n                 ConstValue::ByRef {\n-                    offset: p.offset,\n-                    // FIXME(oli-obk): this should be the type's layout\n-                    align: alloc.align,\n                     alloc,\n+                    offset: p.offset,\n                 }\n             },\n             // unsize array to slice if pattern is array but match value or other patterns are slice"}, {"sha": "33ffb1d320ec26325b30b3ec48c04ca991098e52", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=4be067558962c004b638e4c6f162d50f7c0c98b6", "patch": "@@ -109,6 +109,9 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// that is added to the memory so that the work is not done twice.\n     const STATIC_KIND: Option<Self::MemoryKinds>;\n \n+    /// Whether memory accesses should be alignment-checked.\n+    const CHECK_ALIGN: bool;\n+\n     /// Whether to enforce the validity invariant\n     fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n "}, {"sha": "aef09df4537be9e690caaf1565f33c420557c9db", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=4be067558962c004b638e4c6f162d50f7c0c98b6", "patch": "@@ -306,11 +306,24 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ///\n     /// Most of the time you should use `check_mplace_access`, but when you just have a pointer,\n     /// this method is still appropriate.\n+    #[inline(always)]\n     pub fn check_ptr_access(\n         &self,\n         sptr: Scalar<M::PointerTag>,\n         size: Size,\n         align: Align,\n+    ) -> InterpResult<'tcx, Option<Pointer<M::PointerTag>>> {\n+        let align = if M::CHECK_ALIGN { Some(align) } else { None };\n+        self.check_ptr_access_align(sptr, size, align)\n+    }\n+\n+    /// Like `check_ptr_access`, but *definitely* checks alignment when `align`\n+    /// is `Some` (overriding `M::CHECK_ALIGN`).\n+    pub(super) fn check_ptr_access_align(\n+        &self,\n+        sptr: Scalar<M::PointerTag>,\n+        size: Size,\n+        align: Option<Align>,\n     ) -> InterpResult<'tcx, Option<Pointer<M::PointerTag>>> {\n         fn check_offset_align(offset: u64, align: Align) -> InterpResult<'static> {\n             if offset % align.bytes() == 0 {\n@@ -338,11 +351,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Ok(bits) => {\n                 let bits = bits as u64; // it's ptr-sized\n                 assert!(size.bytes() == 0);\n-                // Must be non-NULL and aligned.\n+                // Must be non-NULL.\n                 if bits == 0 {\n                     throw_unsup!(InvalidNullPointerUsage)\n                 }\n-                check_offset_align(bits, align)?;\n+                // Must be aligned.\n+                if let Some(align) = align {\n+                    check_offset_align(bits, align)?;\n+                }\n                 None\n             }\n             Err(ptr) => {\n@@ -355,18 +371,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 end_ptr.check_in_alloc(allocation_size, CheckInAllocMsg::MemoryAccessTest)?;\n                 // Test align. Check this last; if both bounds and alignment are violated\n                 // we want the error to be about the bounds.\n-                if alloc_align.bytes() < align.bytes() {\n-                    // The allocation itself is not aligned enough.\n-                    // FIXME: Alignment check is too strict, depending on the base address that\n-                    // got picked we might be aligned even if this check fails.\n-                    // We instead have to fall back to converting to an integer and checking\n-                    // the \"real\" alignment.\n-                    throw_unsup!(AlignmentCheckFailed {\n-                        has: alloc_align,\n-                        required: align,\n-                    })\n+                if let Some(align) = align {\n+                    if alloc_align.bytes() < align.bytes() {\n+                        // The allocation itself is not aligned enough.\n+                        // FIXME: Alignment check is too strict, depending on the base address that\n+                        // got picked we might be aligned even if this check fails.\n+                        // We instead have to fall back to converting to an integer and checking\n+                        // the \"real\" alignment.\n+                        throw_unsup!(AlignmentCheckFailed {\n+                            has: alloc_align,\n+                            required: align,\n+                        });\n+                    }\n+                    check_offset_align(ptr.offset.bytes(), align)?;\n                 }\n-                check_offset_align(ptr.offset.bytes(), align)?;\n \n                 // We can still be zero-sized in this branch, in which case we have to\n                 // return `None`."}, {"sha": "f778eb1734c4b00b0840e3ff31019ba9c4de9ae0", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=4be067558962c004b638e4c6f162d50f7c0c98b6", "patch": "@@ -557,12 +557,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.layout_of(self.monomorphize(val.ty)?)\n         })?;\n         let op = match val.val {\n-            ConstValue::ByRef { offset, align, alloc } => {\n+            ConstValue::ByRef { alloc, offset } => {\n                 let id = self.tcx.alloc_map.lock().create_memory_alloc(alloc);\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen.\n                 let ptr = self.tag_static_base_pointer(Pointer::new(id, offset));\n-                Operand::Indirect(MemPlace::from_ptr(ptr, align))\n+                Operand::Indirect(MemPlace::from_ptr(ptr, layout.align.abi))\n             },\n             ConstValue::Scalar(x) =>\n                 Operand::Immediate(tag_scalar(x).into()),"}, {"sha": "82d6d7db01c8d25efa080a6c291f591e4d04078f", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be067558962c004b638e4c6f162d50f7c0c98b6/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=4be067558962c004b638e4c6f162d50f7c0c98b6", "patch": "@@ -398,7 +398,9 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     // alignment and size determined by the layout (size will be 0,\n                     // alignment should take attributes into account).\n                     .unwrap_or_else(|| (layout.size, layout.align.abi));\n-                let ptr: Option<_> = match self.ecx.memory.check_ptr_access(ptr, size, align) {\n+                let ptr: Option<_> = match\n+                    self.ecx.memory.check_ptr_access_align(ptr, size, Some(align))\n+                {\n                     Ok(ptr) => ptr,\n                     Err(err) => {\n                         info!("}]}