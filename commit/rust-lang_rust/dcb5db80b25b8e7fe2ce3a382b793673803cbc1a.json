{"sha": "dcb5db80b25b8e7fe2ce3a382b793673803cbc1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjYjVkYjgwYjI1YjhlN2ZlMmNlM2EzODJiNzkzNjczODAzY2JjMWE=", "commit": {"author": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2018-12-19T11:56:17Z"}, "committer": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2018-12-20T04:39:52Z"}, "message": "Add `std::os::fortanix_sgx` module", "tree": {"sha": "f8bd289683c752af7ff09901cb4d20f5d701851f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8bd289683c752af7ff09901cb4d20f5d701851f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a", "html_url": "https://github.com/rust-lang/rust/commit/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/comments", "author": null, "committer": null, "parents": [{"sha": "38f5c97c3383fb8424fbde6ccdc1aaad4c28ae0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/38f5c97c3383fb8424fbde6ccdc1aaad4c28ae0f", "html_url": "https://github.com/rust-lang/rust/commit/38f5c97c3383fb8424fbde6ccdc1aaad4c28ae0f"}], "stats": {"total": 387, "additions": 328, "deletions": 59}, "files": [{"sha": "69e0f1e6b4d52666de79db8765b25787660b4dd4", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=dcb5db80b25b8e7fe2ce3a382b793673803cbc1a", "patch": "@@ -817,7 +817,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"fortanix-sgx-abi\"\n-version = \"0.3.1\"\n+version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"compiler_builtins 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2890,7 +2890,7 @@ dependencies = [\n  \"compiler_builtins 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n  \"dlmalloc 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"fortanix-sgx-abi 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"fortanix-sgx-abi 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"panic_abort 0.0.0\",\n  \"panic_unwind 0.0.0\",\n@@ -3447,7 +3447,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2fad85553e09a6f881f739c29f0b00b0f01357c743266d478b68951ce23285f3\"\n \"checksum foreign-types 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1\"\n \"checksum foreign-types-shared 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b\"\n-\"checksum fortanix-sgx-abi 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"26105e20b4c3f7a319db1376b54ac9a46e5761e949405553375095d05a0cee4d\"\n+\"checksum fortanix-sgx-abi 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3f8cbee5e872cf7db61a999a041f9bc4706ca7bf7df4cb914f53fabb1c1bc550\"\n \"checksum fs2 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9564fc758e15025b46aa6643b1b77d047d1a56a1aea6e01002ac0c7026876213\"\n \"checksum fs_extra 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5f2a4a2034423744d2cc7ca2068453168dcdb82c438419e639a26bd87839c674\"\n \"checksum fst 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d94485a00b1827b861dd9d1a2cc9764f9044d4c535514c0760a5a2012ef3399f\""}, {"sha": "9e3d9af5ba253bab47e363510ce471c7ba1c7e60", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=dcb5db80b25b8e7fe2ce3a382b793673803cbc1a", "patch": "@@ -40,7 +40,7 @@ rustc_tsan = { path = \"../librustc_tsan\" }\n dlmalloc = { version = \"0.1\", features = ['rustc-dep-of-std'] }\n \n [target.x86_64-fortanix-unknown-sgx.dependencies]\n-fortanix-sgx-abi = { version = \"0.3.1\", features = ['rustc-dep-of-std'] }\n+fortanix-sgx-abi = { version = \"0.3.2\", features = ['rustc-dep-of-std'] }\n \n [build-dependencies]\n cc = \"1.0\""}, {"sha": "0b7cb41399a64123a02b51c5511eaeb76a1beed7", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=dcb5db80b25b8e7fe2ce3a382b793673803cbc1a", "patch": "@@ -314,7 +314,7 @@\n #![feature(alloc_layout_extra)]\n #![feature(maybe_uninit)]\n #![cfg_attr(target_env = \"sgx\", feature(global_asm, range_contains, slice_index_methods,\n-                                        decl_macro, coerce_unsized))]\n+                                        decl_macro, coerce_unsized, sgx_platform))]\n \n #![default_lib_allocator]\n "}, {"sha": "825e7f359d64c0bd62b5a65bfa851863fda4c3a0", "filename": "src/libstd/os/fortanix_sgx/mod.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Fos%2Ffortanix_sgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Fos%2Ffortanix_sgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Ffortanix_sgx%2Fmod.rs?ref=dcb5db80b25b8e7fe2ce3a382b793673803cbc1a", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Functionality specific to the `x86_64-fortanix-unknown-sgx` target.\n+//!\n+//! This includes functions to deal with memory isolation, usercalls, and the\n+//! SGX instruction set.\n+\n+#![deny(missing_docs, missing_debug_implementations)]\n+#![unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+\n+/// Low-level interfaces to usercalls. See the [ABI documentation] for more\n+/// information.\n+///\n+/// [ABI documentation]: https://docs.rs/fortanix-sgx-abi/\n+pub mod usercalls {\n+    pub use sys::abi::usercalls::*;\n+\n+    /// Primitives for allocating memory in userspace as well as copying data\n+    /// to and from user memory.\n+    pub mod alloc {\n+        pub use sys::abi::usercalls::alloc;\n+    }\n+\n+    /// Lowest-level interfaces to usercalls and usercall ABI type definitions.\n+    pub mod raw {\n+        use sys::abi::usercalls::raw::invoke_with_usercalls;\n+        pub use sys::abi::usercalls::raw::do_usercall;\n+        pub use sys::abi::usercalls::raw::{accept_stream, alloc, async_queues, bind_stream, close,\n+                                           connect_stream, exit, flush, free, insecure_time,\n+                                           launch_thread, read, read_alloc, send, wait, write};\n+\n+        macro_rules! define_usercallnrs {\n+            ($(fn $f:ident($($n:ident: $t:ty),*) $(-> $r:ty)*; )*) => {\n+                /// Usercall numbers as per the ABI.\n+                #[repr(C)]\n+                #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+                #[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]\n+                #[allow(missing_docs)]\n+                pub enum UsercallNrs {\n+                    $($f,)*\n+                }\n+            };\n+        }\n+        invoke_with_usercalls!(define_usercallnrs);\n+\n+        // fortanix-sgx-abi re-exports\n+        pub use sys::abi::usercalls::raw::{ByteBuffer, FifoDescriptor, Return, Usercall};\n+        pub use sys::abi::usercalls::raw::Error;\n+        pub use sys::abi::usercalls::raw::{EV_RETURNQ_NOT_EMPTY, EV_UNPARK, EV_USERCALLQ_NOT_FULL,\n+                                           FD_STDERR, FD_STDIN, FD_STDOUT, RESULT_SUCCESS,\n+                                           USERCALL_USER_DEFINED, WAIT_INDEFINITE, WAIT_NO};\n+        pub use sys::abi::usercalls::raw::{Fd, Result, Tcs};\n+    }\n+}\n+\n+/// Functions for querying mapping information for pointers.\n+pub mod mem {\n+    pub use sys::abi::mem::*;\n+}"}, {"sha": "ba5b938ed4ccf7ce8c61720b0ce493e86a564be9", "filename": "src/libstd/os/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=dcb5db80b25b8e7fe2ce3a382b793673803cbc1a", "patch": "@@ -61,5 +61,6 @@ cfg_if! {\n #[cfg(target_os = \"emscripten\")] pub mod emscripten;\n #[cfg(target_os = \"fuchsia\")]    pub mod fuchsia;\n #[cfg(target_os = \"hermit\")]     pub mod hermit;\n+#[cfg(all(target_vendor = \"fortanix\", target_env = \"sgx\"))] pub mod fortanix_sgx;\n \n pub mod raw;"}, {"sha": "11eb64606c43ed104eaffdb329620995f450ee68", "filename": "src/libstd/sys/sgx/abi/mem.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs?ref=dcb5db80b25b8e7fe2ce3a382b793673803cbc1a", "patch": "@@ -10,13 +10,13 @@\n \n // Do not remove inline: will result in relocation failure\n #[inline(always)]\n-pub unsafe fn rel_ptr<T>(offset: u64) -> *const T {\n+pub(crate) unsafe fn rel_ptr<T>(offset: u64) -> *const T {\n     (image_base() + offset) as *const T\n }\n \n // Do not remove inline: will result in relocation failure\n #[inline(always)]\n-pub unsafe fn rel_ptr_mut<T>(offset: u64) -> *mut T {\n+pub(crate) unsafe fn rel_ptr_mut<T>(offset: u64) -> *mut T {\n     (image_base() + offset) as *mut T\n }\n \n@@ -34,13 +34,17 @@ fn image_base() -> u64 {\n     base\n }\n \n+/// Returns `true` if the specified memory range is in the enclave.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn is_enclave_range(p: *const u8, len: usize) -> bool {\n     let start=p as u64;\n     let end=start + (len as u64);\n     start >= image_base() &&\n         end <= image_base() + (unsafe { ENCLAVE_SIZE } as u64) // unsafe ok: link-time constant\n }\n \n+/// Returns `true` if the specified memory range is in userspace.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn is_user_range(p: *const u8, len: usize) -> bool {\n     let start=p as u64;\n     let end=start + (len as u64);"}, {"sha": "18ba221af5a2376b175a2350d90993f62fdc6cdc", "filename": "src/libstd/sys/sgx/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs?ref=dcb5db80b25b8e7fe2ce3a382b793673803cbc1a", "patch": "@@ -13,10 +13,10 @@ use io::Write;\n \n // runtime features\n mod reloc;\n-mod mem;\n pub(super) mod panic;\n \n // library features\n+pub mod mem;\n pub mod thread;\n pub mod tls;\n #[macro_use]"}, {"sha": "f1689091eb593a9069feeebe036e59e64008fc94", "filename": "src/libstd/sys/sgx/abi/usercalls/alloc.rs", "status": "modified", "additions": 180, "deletions": 31, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=dcb5db80b25b8e7fe2ce3a382b793673803cbc1a", "patch": "@@ -10,7 +10,7 @@\n \n #![allow(unused)]\n \n-use ptr;\n+use ptr::{self, NonNull};\n use mem;\n use cell::UnsafeCell;\n use slice;\n@@ -39,39 +39,78 @@ use super::super::mem::is_user_range;\n ///   as vtable pointers) must not be leaked for confidentiality reasons.\n ///\n /// Non-exhaustive list of specific requirements for reading from userspace:\n-/// * Any bit pattern is valid for this type (no `enum`s). There can be no\n+/// * **Any bit pattern is valid** for this type (no `enum`s). There can be no\n ///   guarantee that the value correctly adheres to the expectations of the\n ///   type, so any value must be valid for this type.\n ///\n /// Non-exhaustive list of specific requirements for writing to userspace:\n-/// * No pointers to enclave memory. Memory addresses of data in enclave memory\n-///   must not be leaked for confidentiality reasons.\n-/// * No internal padding. Padding might contain previously-initialized secret\n-///   data stored at that memory location and must not be leaked for\n+/// * **No pointers to enclave memory.** Memory addresses of data in enclave\n+///   memory must not be leaked for confidentiality reasons.\n+/// * **No internal padding.** Padding might contain previously-initialized\n+///   secret data stored at that memory location and must not be leaked for\n ///   confidentiality reasons.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub unsafe trait UserSafeSized: Copy + Sized {}\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n unsafe impl UserSafeSized for u8 {}\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n unsafe impl<T> UserSafeSized for FifoDescriptor<T> {}\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n unsafe impl UserSafeSized for ByteBuffer {}\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n unsafe impl UserSafeSized for Usercall {}\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n unsafe impl UserSafeSized for Return {}\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n unsafe impl<T: UserSafeSized> UserSafeSized for [T; 2] {}\n \n /// A type that can be represented in memory as one or more `UserSafeSized`s.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub unsafe trait UserSafe {\n-    unsafe fn align_of() -> usize;\n+    /// Equivalent to `mem::align_of::<Self>`.\n+    fn align_of() -> usize;\n \n+    /// Construct a pointer to `Self` given a memory range in user space.\n+    ///\n     /// NB. This takes a size, not a length!\n-    unsafe fn from_raw_sized_unchecked(ptr: *const u8, size: usize) -> *const Self;\n+    ///\n+    /// # Safety\n+    /// The caller must ensure the memory range is in user memory, is the\n+    /// correct size and is correctly aligned and points to the right type.\n+    unsafe fn from_raw_sized_unchecked(ptr: *mut u8, size: usize) -> *mut Self;\n \n+    /// Construct a pointer to `Self` given a memory range.\n+    ///\n     /// NB. This takes a size, not a length!\n-    unsafe fn from_raw_sized(ptr: *const u8, size: usize) -> *const Self {\n+    ///\n+    /// # Safety\n+    /// The caller must ensure the memory range points to the correct type.\n+    ///\n+    /// # Panics\n+    /// This function panics if:\n+    ///\n+    /// * The pointer is not aligned\n+    /// * The pointer is null\n+    /// * The pointed-to range is not in user memory\n+    unsafe fn from_raw_sized(ptr: *mut u8, size: usize) -> NonNull<Self> {\n         let ret = Self::from_raw_sized_unchecked(ptr, size);\n         Self::check_ptr(ret);\n-        ret\n+        NonNull::new_unchecked(ret as _)\n     }\n \n+    /// Check if a pointer may point to Self in user memory.\n+    ///\n+    /// # Safety\n+    /// The caller must ensure the memory range points to the correct type and\n+    /// length (if this is a slice).\n+    ///\n+    /// # Panics\n+    /// This function panics if:\n+    ///\n+    /// * The pointer is not aligned\n+    /// * The pointer is null\n+    /// * The pointed-to range is not in user memory\n     unsafe fn check_ptr(ptr: *const Self) {\n         let is_aligned = |p| -> bool {\n             0 == (p as usize) & (Self::align_of() - 1)\n@@ -83,42 +122,70 @@ pub unsafe trait UserSafe {\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n unsafe impl<T: UserSafeSized> UserSafe for T {\n-    unsafe fn align_of() -> usize {\n+    fn align_of() -> usize {\n         mem::align_of::<T>()\n     }\n \n-    unsafe fn from_raw_sized_unchecked(ptr: *const u8, size: usize) -> *const Self {\n+    unsafe fn from_raw_sized_unchecked(ptr: *mut u8, size: usize) -> *mut Self {\n         assert_eq!(size, mem::size_of::<T>());\n         ptr as _\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n unsafe impl<T: UserSafeSized> UserSafe for [T] {\n-    unsafe fn align_of() -> usize {\n+    fn align_of() -> usize {\n         mem::align_of::<T>()\n     }\n \n-    unsafe fn from_raw_sized_unchecked(ptr: *const u8, size: usize) -> *const Self {\n+    unsafe fn from_raw_sized_unchecked(ptr: *mut u8, size: usize) -> *mut Self {\n         let elem_size = mem::size_of::<T>();\n         assert_eq!(size % elem_size, 0);\n         let len = size / elem_size;\n-        slice::from_raw_parts(ptr as _, len)\n+        slice::from_raw_parts_mut(ptr as _, len)\n     }\n }\n \n /// A reference to some type in userspace memory. `&UserRef<T>` is equivalent\n /// to `&T` in enclave memory. Access to the memory is only allowed by copying\n /// to avoid TOCTTOU issues. After copying, code should make sure to completely\n /// check the value before use.\n+///\n+/// It is also possible to obtain a mutable reference `&mut UserRef<T>`. Unlike\n+/// regular mutable references, these are not exclusive. Userspace may always\n+/// write to the backing memory at any time, so it can't be assumed that there\n+/// the pointed-to memory is uniquely borrowed. The two different refence types\n+/// are used solely to indicate intent: a mutable reference is for writing to\n+/// user memory, an immutable reference for reading from user memory.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub struct UserRef<T: ?Sized>(UnsafeCell<T>);\n /// An owned type in userspace memory. `User<T>` is equivalent to `Box<T>` in\n /// enclave memory. Access to the memory is only allowed by copying to avoid\n /// TOCTTOU issues. The user memory will be freed when the value is dropped.\n /// After copying, code should make sure to completely check the value before\n /// use.\n-pub struct User<T: UserSafe + ?Sized>(*mut UserRef<T>);\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub struct User<T: UserSafe + ?Sized>(NonNull<UserRef<T>>);\n+\n+trait NewUserRef<T: ?Sized> {\n+    unsafe fn new_userref(v: T) -> Self;\n+}\n+\n+impl<T: ?Sized> NewUserRef<*mut T> for NonNull<UserRef<T>> {\n+    unsafe fn new_userref(v: *mut T) -> Self {\n+        NonNull::new_unchecked(v as _)\n+    }\n+}\n \n+impl<T: ?Sized> NewUserRef<NonNull<T>> for NonNull<UserRef<T>> {\n+    unsafe fn new_userref(v: NonNull<T>) -> Self {\n+        NonNull::new_userref(v.as_ptr())\n+    }\n+}\n+\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T: ?Sized> User<T> where T: UserSafe {\n     // This function returns memory that is practically uninitialized, but is\n     // not considered \"unspecified\" or \"undefined\" for purposes of an\n@@ -127,24 +194,28 @@ impl<T: ?Sized> User<T> where T: UserSafe {\n     fn new_uninit_bytes(size: usize) -> Self {\n         unsafe {\n             let ptr = super::alloc(size, T::align_of()).expect(\"User memory allocation failed\");\n-            User(T::from_raw_sized(ptr as _, size) as _)\n+            User(NonNull::new_userref(T::from_raw_sized(ptr as _, size)))\n         }\n     }\n \n+    /// Copy `val` into freshly allocated space in user memory.\n     pub fn new_from_enclave(val: &T) -> Self {\n         unsafe {\n             let ret = Self::new_uninit_bytes(mem::size_of_val(val));\n             ptr::copy(\n                 val as *const T as *const u8,\n-                ret.0 as *mut T as *mut u8,\n+                ret.0.as_ptr() as *mut u8,\n                 mem::size_of_val(val)\n             );\n             ret\n         }\n     }\n \n-    /// Create an owned `User<T>` from a raw pointer. The pointer should be\n-    /// freeable with the `free` usercall and the alignment of `T`.\n+    /// Create an owned `User<T>` from a raw pointer.\n+    ///\n+    /// # Safety\n+    /// The caller must ensure `ptr` points to `T`, is freeable with the `free`\n+    /// usercall and the alignment of `T`, and is uniquely owned.\n     ///\n     /// # Panics\n     /// This function panics if:\n@@ -154,32 +225,39 @@ impl<T: ?Sized> User<T> where T: UserSafe {\n     /// * The pointed-to range is not in user memory\n     pub unsafe fn from_raw(ptr: *mut T) -> Self {\n         T::check_ptr(ptr);\n-        User(ptr as _)\n+        User(NonNull::new_userref(ptr))\n     }\n \n     /// Convert this value into a raw pointer. The value will no longer be\n     /// automatically freed.\n     pub fn into_raw(self) -> *mut T {\n         let ret = self.0;\n         mem::forget(self);\n-        ret as _\n+        ret.as_ptr() as _\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T> User<T> where T: UserSafe {\n+    /// Allocate space for `T` in user memory.\n     pub fn uninitialized() -> Self {\n         Self::new_uninit_bytes(mem::size_of::<T>())\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T> User<[T]> where [T]: UserSafe {\n+    /// Allocate space for a `[T]` of `n` elements in user memory.\n     pub fn uninitialized(n: usize) -> Self {\n         Self::new_uninit_bytes(n * mem::size_of::<T>())\n     }\n \n     /// Create an owned `User<[T]>` from a raw thin pointer and a slice length.\n-    /// The pointer should be freeable with the `free` usercall and the\n-    /// alignment of `T`.\n+    ///\n+    /// # Safety\n+    /// The caller must ensure `ptr` points to `len` elements of `T`, is\n+    /// freeable with the `free` usercall and the alignment of `T`, and is\n+    /// uniquely owned.\n     ///\n     /// # Panics\n     /// This function panics if:\n@@ -188,13 +266,17 @@ impl<T> User<[T]> where [T]: UserSafe {\n     /// * The pointer is null\n     /// * The pointed-to range is not in user memory\n     pub unsafe fn from_raw_parts(ptr: *mut T, len: usize) -> Self {\n-        User(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()) as _)\n+        User(NonNull::new_userref(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>())))\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T: ?Sized> UserRef<T> where T: UserSafe {\n     /// Create a `&UserRef<[T]>` from a raw pointer.\n     ///\n+    /// # Safety\n+    /// The caller must ensure `ptr` points to `T`.\n+    ///\n     /// # Panics\n     /// This function panics if:\n     ///\n@@ -206,7 +288,11 @@ impl<T: ?Sized> UserRef<T> where T: UserSafe {\n         &*(ptr as *const Self)\n     }\n \n-    /// Create a `&mut UserRef<[T]>` from a raw pointer.\n+    /// Create a `&mut UserRef<[T]>` from a raw pointer. See the struct\n+    /// documentation for the nuances regarding a `&mut UserRef<T>`.\n+    ///\n+    /// # Safety\n+    /// The caller must ensure `ptr` points to `T`.\n     ///\n     /// # Panics\n     /// This function panics if:\n@@ -219,6 +305,8 @@ impl<T: ?Sized> UserRef<T> where T: UserSafe {\n         &mut*(ptr as *mut Self)\n     }\n \n+    /// Copy `val` into user memory.\n+    ///\n     /// # Panics\n     /// This function panics if the destination doesn't have the same size as\n     /// the source. This can happen for dynamically-sized types such as slices.\n@@ -233,6 +321,8 @@ impl<T: ?Sized> UserRef<T> where T: UserSafe {\n         }\n     }\n \n+    /// Copy the value from user memory and place it into `dest`.\n+    ///\n     /// # Panics\n     /// This function panics if the destination doesn't have the same size as\n     /// the source. This can happen for dynamically-sized types such as slices.\n@@ -247,35 +337,48 @@ impl<T: ?Sized> UserRef<T> where T: UserSafe {\n         }\n     }\n \n+    /// Obtain a raw pointer from this reference.\n     pub fn as_raw_ptr(&self) -> *const T {\n         self as *const _ as _\n     }\n \n+    /// Obtain a raw pointer from this reference.\n     pub fn as_raw_mut_ptr(&mut self) -> *mut T {\n         self as *mut _ as _\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T> UserRef<T> where T: UserSafe {\n+    /// Copy the value from user memory into enclave memory.\n     pub fn to_enclave(&self) -> T {\n         unsafe { ptr::read(self.0.get()) }\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T> UserRef<[T]> where [T]: UserSafe {\n     /// Create a `&UserRef<[T]>` from a raw thin pointer and a slice length.\n     ///\n+    /// # Safety\n+    /// The caller must ensure `ptr` points to `n` elements of `T`.\n+    ///\n     /// # Panics\n     /// This function panics if:\n     ///\n     /// * The pointer is not aligned\n     /// * The pointer is null\n     /// * The pointed-to range is not in user memory\n     pub unsafe fn from_raw_parts<'a>(ptr: *const T, len: usize) -> &'a Self {\n-        &*(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()) as *const Self)\n+        &*(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()).as_ptr() as *const Self)\n     }\n \n     /// Create a `&mut UserRef<[T]>` from a raw thin pointer and a slice length.\n+    /// See the struct documentation for the nuances regarding a\n+    /// `&mut UserRef<T>`.\n+    ///\n+    /// # Safety\n+    /// The caller must ensure `ptr` points to `n` elements of `T`.\n     ///\n     /// # Panics\n     /// This function panics if:\n@@ -284,21 +387,30 @@ impl<T> UserRef<[T]> where [T]: UserSafe {\n     /// * The pointer is null\n     /// * The pointed-to range is not in user memory\n     pub unsafe fn from_raw_parts_mut<'a>(ptr: *mut T, len: usize) -> &'a mut Self {\n-        &mut*(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()) as *mut Self)\n+        &mut*(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()).as_ptr() as *mut Self)\n     }\n \n+    /// Obtain a raw pointer to the first element of this user slice.\n     pub fn as_ptr(&self) -> *const T {\n         self.0.get() as _\n     }\n \n+    /// Obtain a raw pointer to the first element of this user slice.\n     pub fn as_mut_ptr(&mut self) -> *mut T {\n         self.0.get() as _\n     }\n \n+    /// Obtain the number of elements in this user slice.\n     pub fn len(&self) -> usize {\n         unsafe { (*self.0.get()).len() }\n     }\n \n+    /// Copy the value from user memory and place it into `dest`. Afterwards,\n+    /// `dest` will contain exactly `self.len()` elements.\n+    ///\n+    /// # Panics\n+    /// This function panics if the destination doesn't have the same size as\n+    /// the source. This can happen for dynamically-sized types such as slices.\n     pub fn copy_to_enclave_vec(&self, dest: &mut Vec<T>) {\n         unsafe {\n             if let Some(missing) = self.len().checked_sub(dest.capacity()) {\n@@ -309,12 +421,14 @@ impl<T> UserRef<[T]> where [T]: UserSafe {\n         }\n     }\n \n+    /// Copy the value from user memory into a vector in enclave memory.\n     pub fn to_enclave(&self) -> Vec<T> {\n         let mut ret = Vec::with_capacity(self.len());\n         self.copy_to_enclave_vec(&mut ret);\n         ret\n     }\n \n+    /// Returns an iterator over the slice.\n     pub fn iter(&self) -> Iter<T>\n         where T: UserSafe // FIXME: should be implied by [T]: UserSafe?\n     {\n@@ -323,6 +437,7 @@ impl<T> UserRef<[T]> where [T]: UserSafe {\n         }\n     }\n \n+    /// Returns an iterator that allows modifying each value.\n     pub fn iter_mut(&mut self) -> IterMut<T>\n         where T: UserSafe // FIXME: should be implied by [T]: UserSafe?\n     {\n@@ -332,8 +447,13 @@ impl<T> UserRef<[T]> where [T]: UserSafe {\n     }\n }\n \n+/// Immutable user slice iterator\n+///\n+/// This struct is created by the `iter` method on `UserRef<[T]>`.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub struct Iter<'a, T: 'a + UserSafe>(slice::Iter<'a, T>);\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<'a, T: UserSafe> Iterator for Iter<'a, T> {\n     type Item = &'a UserRef<T>;\n \n@@ -345,8 +465,13 @@ impl<'a, T: UserSafe> Iterator for Iter<'a, T> {\n     }\n }\n \n+/// Mutable user slice iterator\n+///\n+/// This struct is created by the `iter_mut` method on `UserRef<[T]>`.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub struct IterMut<'a, T: 'a + UserSafe>(slice::IterMut<'a, T>);\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<'a, T: UserSafe> Iterator for IterMut<'a, T> {\n     type Item = &'a mut UserRef<T>;\n \n@@ -358,31 +483,36 @@ impl<'a, T: UserSafe> Iterator for IterMut<'a, T> {\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T: ?Sized> Deref for User<T> where T: UserSafe {\n     type Target = UserRef<T>;\n \n     fn deref(&self) -> &Self::Target {\n-        unsafe { &*self.0 }\n+        unsafe { &*self.0.as_ptr() }\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T: ?Sized> DerefMut for User<T> where T: UserSafe {\n     fn deref_mut(&mut self) -> &mut Self::Target {\n-        unsafe { &mut*self.0 }\n+        unsafe { &mut*self.0.as_ptr() }\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T: ?Sized> Drop for User<T> where T: UserSafe {\n     fn drop(&mut self) {\n         unsafe {\n-            let ptr = (*self.0).0.get();\n+            let ptr = (*self.0.as_ptr()).0.get();\n             super::free(ptr as _, mem::size_of_val(&mut*ptr), T::align_of());\n         }\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T: CoerceUnsized<U>, U> CoerceUnsized<UserRef<U>> for UserRef<T> {}\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T, I: SliceIndex<[T]>> Index<I> for UserRef<[T]> where [T]: UserSafe, I::Output: UserSafe {\n     type Output = UserRef<I::Output>;\n \n@@ -394,6 +524,7 @@ impl<T, I: SliceIndex<[T]>> Index<I> for UserRef<[T]> where [T]: UserSafe, I::Ou\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T, I: SliceIndex<[T]>> IndexMut<I> for UserRef<[T]> where [T]: UserSafe, I::Output: UserSafe {\n     #[inline]\n     fn index_mut(&mut self, index: I) -> &mut UserRef<I::Output> {\n@@ -402,3 +533,21 @@ impl<T, I: SliceIndex<[T]>> IndexMut<I> for UserRef<[T]> where [T]: UserSafe, I:\n         }\n     }\n }\n+\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+impl UserRef<super::raw::ByteBuffer> {\n+    /// Copy the user memory range pointed to by the user `ByteBuffer` to\n+    /// enclave memory.\n+    ///\n+    /// # Panics\n+    /// This function panics if:\n+    ///\n+    /// * The pointer in the user `ByteBuffer` is null\n+    /// * The pointed-to range in the user `ByteBuffer` is not in user memory\n+    pub fn copy_user_buffer(&self) -> Vec<u8> {\n+        unsafe {\n+            let buf = self.to_enclave();\n+            User::from_raw_parts(buf.data as _, buf.len).to_enclave()\n+        }\n+    }\n+}"}, {"sha": "a5066abc14462325780eab248734a03e4b2e3b9f", "filename": "src/libstd/sys/sgx/abi/usercalls/mod.rs", "status": "modified", "additions": 37, "deletions": 14, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=dcb5db80b25b8e7fe2ce3a382b793673803cbc1a", "patch": "@@ -8,22 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use fortanix_sgx_abi::*;\n-\n use io::{Error as IoError, Result as IoResult};\n use time::Duration;\n \n-pub mod alloc;\n+pub(crate) mod alloc;\n #[macro_use]\n-mod raw;\n+pub(crate) mod raw;\n \n-pub(crate) fn copy_user_buffer(buf: &alloc::UserRef<ByteBuffer>) -> Vec<u8> {\n-    unsafe {\n-        let buf = buf.to_enclave();\n-        alloc::User::from_raw_parts(buf.data as _, buf.len).to_enclave()\n-    }\n-}\n+use self::raw::*;\n \n+/// Usercall `read`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn read(fd: Fd, buf: &mut [u8]) -> IoResult<usize> {\n     unsafe {\n         let mut userbuf = alloc::User::<[u8]>::uninitialized(buf.len());\n@@ -33,34 +28,44 @@ pub fn read(fd: Fd, buf: &mut [u8]) -> IoResult<usize> {\n     }\n }\n \n+/// Usercall `read_alloc`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn read_alloc(fd: Fd) -> IoResult<Vec<u8>> {\n     unsafe {\n         let mut userbuf = alloc::User::<ByteBuffer>::uninitialized();\n         raw::read_alloc(fd, userbuf.as_raw_mut_ptr()).from_sgx_result()?;\n-        Ok(copy_user_buffer(&userbuf))\n+        Ok(userbuf.copy_user_buffer())\n     }\n }\n \n+/// Usercall `write`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn write(fd: Fd, buf: &[u8]) -> IoResult<usize> {\n     unsafe {\n         let userbuf = alloc::User::new_from_enclave(buf);\n         raw::write(fd, userbuf.as_ptr(), userbuf.len()).from_sgx_result()\n     }\n }\n \n+/// Usercall `flush`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn flush(fd: Fd) -> IoResult<()> {\n     unsafe { raw::flush(fd).from_sgx_result() }\n }\n \n+/// Usercall `close`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn close(fd: Fd) {\n     unsafe { raw::close(fd) }\n }\n \n fn string_from_bytebuffer(buf: &alloc::UserRef<ByteBuffer>, usercall: &str, arg: &str) -> String {\n-    String::from_utf8(copy_user_buffer(buf))\n+    String::from_utf8(buf.copy_user_buffer())\n         .unwrap_or_else(|_| panic!(\"Usercall {}: expected {} to be valid UTF-8\", usercall, arg))\n }\n \n+/// Usercall `bind_stream`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn bind_stream(addr: &str) -> IoResult<(Fd, String)> {\n     unsafe {\n         let addr_user = alloc::User::new_from_enclave(addr.as_bytes());\n@@ -75,6 +80,8 @@ pub fn bind_stream(addr: &str) -> IoResult<(Fd, String)> {\n     }\n }\n \n+/// Usercall `accept_stream`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn accept_stream(fd: Fd) -> IoResult<(Fd, String, String)> {\n     unsafe {\n         let mut bufs = alloc::User::<[ByteBuffer; 2]>::uninitialized();\n@@ -92,6 +99,8 @@ pub fn accept_stream(fd: Fd) -> IoResult<(Fd, String, String)> {\n     }\n }\n \n+/// Usercall `connect_stream`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn connect_stream(addr: &str) -> IoResult<(Fd, String, String)> {\n     unsafe {\n         let addr_user = alloc::User::new_from_enclave(addr.as_bytes());\n@@ -111,31 +120,45 @@ pub fn connect_stream(addr: &str) -> IoResult<(Fd, String, String)> {\n     }\n }\n \n-pub fn launch_thread() -> IoResult<()> {\n-    unsafe { raw::launch_thread().from_sgx_result() }\n+/// Usercall `launch_thread`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub unsafe fn launch_thread() -> IoResult<()> {\n+    raw::launch_thread().from_sgx_result()\n }\n \n+/// Usercall `exit`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn exit(panic: bool) -> ! {\n     unsafe { raw::exit(panic) }\n }\n \n+/// Usercall `wait`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn wait(event_mask: u64, timeout: u64) -> IoResult<u64> {\n     unsafe { raw::wait(event_mask, timeout).from_sgx_result() }\n }\n \n+/// Usercall `send`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn send(event_set: u64, tcs: Option<Tcs>) -> IoResult<()> {\n     unsafe { raw::send(event_set, tcs).from_sgx_result() }\n }\n \n+/// Usercall `insecure_time`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn insecure_time() -> Duration {\n     let t = unsafe { raw::insecure_time() };\n     Duration::new(t / 1_000_000_000, (t % 1_000_000_000) as _)\n }\n \n+/// Usercall `alloc`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn alloc(size: usize, alignment: usize) -> IoResult<*mut u8> {\n     unsafe { raw::alloc(size, alignment).from_sgx_result() }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+#[doc(inline)]\n pub use self::raw::free;\n \n fn check_os_error(err: Result) -> i32 {"}, {"sha": "44b370c44c636b496b97a2fc757479f0c689e254", "filename": "src/libstd/sys/sgx/abi/usercalls/raw.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs?ref=dcb5db80b25b8e7fe2ce3a382b793673803cbc1a", "patch": "@@ -10,7 +10,8 @@\n \n #![allow(unused)]\n \n-use fortanix_sgx_abi::*;\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub use fortanix_sgx_abi::*;\n \n use ptr::NonNull;\n \n@@ -21,7 +22,16 @@ extern \"C\" {\n     fn usercall(nr: u64, p1: u64, p2: u64, _ignore: u64, p3: u64, p4: u64) -> UsercallReturn;\n }\n \n-unsafe fn do_usercall(nr: u64, p1: u64, p2: u64, p3: u64, p4: u64) -> (u64, u64) {\n+/// Perform the raw usercall operation as defined in the ABI calling convention.\n+///\n+/// # Safety\n+/// The caller must ensure to pass parameters appropriate for the usercall `nr`\n+/// and to observe all requirements specified in the ABI.\n+///\n+/// # Panics\n+/// Panics if `nr` is 0.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub unsafe fn do_usercall(nr: u64, p1: u64, p2: u64, p3: u64, p4: u64) -> (u64, u64) {\n     if nr==0 { panic!(\"Invalid usercall number {}\",nr) }\n     let UsercallReturn(a, b) = usercall(nr,p1,p2,0,p3,p4);\n     (a, b)\n@@ -169,6 +179,9 @@ impl<T: RegisterArgument, U: RegisterArgument> ReturnValue for (T, U) {\n macro_rules! enclave_usercalls_internal_define_usercalls {\n     (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty,\n                      $n3:ident: $t3:ty, $n4:ident: $t4:ty) -> $r:ty) => (\n+        /// This is the raw function definition, see the ABI documentation for\n+        /// more information.\n+        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1, $n2: $t2, $n3: $t3, $n4: $t4) -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n@@ -181,6 +194,9 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         }\n     );\n     (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty, $n3:ident: $t3:ty) -> $r:ty) => (\n+        /// This is the raw function definition, see the ABI documentation for\n+        /// more information.\n+        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1, $n2: $t2, $n3: $t3) -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n@@ -193,6 +209,9 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         }\n     );\n     (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty) -> $r:ty) => (\n+        /// This is the raw function definition, see the ABI documentation for\n+        /// more information.\n+        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1, $n2: $t2) -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n@@ -204,6 +223,9 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         }\n     );\n     (def fn $f:ident($n1:ident: $t1:ty) -> $r:ty) => (\n+        /// This is the raw function definition, see the ABI documentation for\n+        /// more information.\n+        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1) -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n@@ -214,6 +236,9 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         }\n     );\n     (def fn $f:ident() -> $r:ty) => (\n+        /// This is the raw function definition, see the ABI documentation for\n+        /// more information.\n+        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n         #[inline(always)]\n         pub unsafe fn $f() -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall("}, {"sha": "50627b8c9130218134aee07953ba205a26a4f67a", "filename": "src/libstd/sys/sgx/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs?ref=dcb5db80b25b8e7fe2ce3a382b793673803cbc1a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ffi::OsString;\n-use super::abi::usercalls::{copy_user_buffer, alloc, ByteBuffer};\n+use super::abi::usercalls::{alloc, raw::ByteBuffer};\n use sync::atomic::{AtomicUsize, Ordering};\n use sys::os_str::Buf;\n use sys_common::FromInner;\n@@ -22,7 +22,7 @@ pub unsafe fn init(argc: isize, argv: *const *const u8) {\n     if argc != 0 {\n         let args = alloc::User::<[ByteBuffer]>::from_raw_parts(argv as _, argc as _);\n         let args = args.iter()\n-            .map( |a| OsString::from_inner(Buf { inner: copy_user_buffer(a) }) )\n+            .map( |a| OsString::from_inner(Buf { inner: a.copy_user_buffer() }) )\n             .collect::<ArgsStore>();\n         ARGS.store(Box::into_raw(Box::new(args)) as _, Ordering::Relaxed);\n     }"}, {"sha": "9cfe821fe5154fdf204161504be41b11aa5a59c4", "filename": "src/libstd/sys/sgx/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs?ref=dcb5db80b25b8e7fe2ce3a382b793673803cbc1a", "patch": "@@ -29,7 +29,7 @@ struct Socket {\n }\n \n impl Socket {\n-    fn new(fd: usercalls::Fd, local_addr: String) -> Socket {\n+    fn new(fd: usercalls::raw::Fd, local_addr: String) -> Socket {\n         Socket { inner: Arc::new(FileDesc::new(fd)), local_addr }\n     }\n }"}, {"sha": "48adc834eb94e5815a489e0f77055c6d12d51cc6", "filename": "src/libstd/sys/sgx/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb5db80b25b8e7fe2ce3a382b793673803cbc1a/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs?ref=dcb5db80b25b8e7fe2ce3a382b793673803cbc1a", "patch": "@@ -75,7 +75,7 @@ impl Thread {\n \n     pub fn yield_now() {\n         assert_eq!(\n-            usercalls::wait(0, usercalls::WAIT_NO).unwrap_err().kind(),\n+            usercalls::wait(0, usercalls::raw::WAIT_NO).unwrap_err().kind(),\n             io::ErrorKind::WouldBlock\n         );\n     }"}]}