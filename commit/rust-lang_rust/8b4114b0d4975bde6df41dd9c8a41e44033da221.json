{"sha": "8b4114b0d4975bde6df41dd9c8a41e44033da221", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiNDExNGIwZDQ5NzViZGU2ZGY0MWRkOWM4YTQxZTQ0MDMzZGEyMjE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-23T13:51:18Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-24T17:14:46Z"}, "message": "typeck/pat.rs: extract `peel_off_references` and define `def_bm` algorithm more declaratively.", "tree": {"sha": "d4e8c038b01b610b09c97a0ebefd1c662b7de109", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4e8c038b01b610b09c97a0ebefd1c662b7de109"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b4114b0d4975bde6df41dd9c8a41e44033da221", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b4114b0d4975bde6df41dd9c8a41e44033da221", "html_url": "https://github.com/rust-lang/rust/commit/8b4114b0d4975bde6df41dd9c8a41e44033da221", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b4114b0d4975bde6df41dd9c8a41e44033da221/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1580eef6565be5708b0668bd813e1b9abedbbb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1580eef6565be5708b0668bd813e1b9abedbbb5", "html_url": "https://github.com/rust-lang/rust/commit/d1580eef6565be5708b0668bd813e1b9abedbbb5"}], "stats": {"total": 121, "additions": 67, "deletions": 54}, "files": [{"sha": "625c57356af38e677fa4405063e5cd548e825bd0", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 67, "deletions": 54, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/8b4114b0d4975bde6df41dd9c8a41e44033da221/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b4114b0d4975bde6df41dd9c8a41e44033da221/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=8b4114b0d4975bde6df41dd9c8a41e44033da221", "patch": "@@ -48,8 +48,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_pat_walk(\n         &self,\n         pat: &'tcx hir::Pat,\n-        mut expected: Ty<'tcx>,\n-        mut def_bm: ty::BindingMode,\n+        expected: Ty<'tcx>,\n+        def_bm: ty::BindingMode,\n         discrim_span: Option<Span>,\n     ) {\n         let tcx = self.tcx;\n@@ -62,53 +62,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         let is_non_ref_pat = self.is_non_ref_pat(pat, path_resolution.map(|(res, ..)| res));\n-        if is_non_ref_pat {\n+        let (expected, def_bm) = if is_non_ref_pat {\n             debug!(\"pattern is non reference pattern\");\n-            let mut exp_ty = self.resolve_type_vars_with_obligations(&expected);\n-\n-            // Peel off as many `&` or `&mut` from the discriminant as possible. For example,\n-            // for `match &&&mut Some(5)` the loop runs three times, aborting when it reaches\n-            // the `Some(5)` which is not of type Ref.\n-            //\n-            // For each ampersand peeled off, update the binding mode and push the original\n-            // type into the adjustments vector.\n-            //\n-            // See the examples in `ui/match-defbm*.rs`.\n-            let mut pat_adjustments = vec![];\n-            while let ty::Ref(_, inner_ty, inner_mutability) = exp_ty.sty {\n-                debug!(\"inspecting {:?}\", exp_ty);\n-\n-                debug!(\"current discriminant is Ref, inserting implicit deref\");\n-                // Preserve the reference type. We'll need it later during HAIR lowering.\n-                pat_adjustments.push(exp_ty);\n-\n-                exp_ty = inner_ty;\n-                def_bm = match def_bm {\n-                    // If default binding mode is by value, make it `ref` or `ref mut`\n-                    // (depending on whether we observe `&` or `&mut`).\n-                    ty::BindByValue(_) =>\n-                        ty::BindByReference(inner_mutability),\n-\n-                    // Once a `ref`, always a `ref`. This is because a `& &mut` can't mutate\n-                    // the underlying value.\n-                    ty::BindByReference(hir::Mutability::MutImmutable) =>\n-                        ty::BindByReference(hir::Mutability::MutImmutable),\n-\n-                    // When `ref mut`, stay a `ref mut` (on `&mut`) or downgrade to `ref`\n-                    // (on `&`).\n-                    ty::BindByReference(hir::Mutability::MutMutable) =>\n-                        ty::BindByReference(inner_mutability),\n-                };\n-            }\n-            expected = exp_ty;\n-\n-            if pat_adjustments.len() > 0 {\n-                debug!(\"default binding mode is now {:?}\", def_bm);\n-                self.inh.tables.borrow_mut()\n-                    .pat_adjustments_mut()\n-                    .insert(pat.hir_id, pat_adjustments);\n-            }\n-        } else if let PatKind::Ref(..) = pat.node {\n+            self.peel_off_references(pat, expected, def_bm)\n+        } else {\n             // When you encounter a `&pat` pattern, reset to \"by\n             // value\". This is so that `x` and `y` here are by value,\n             // as they appear to be:\n@@ -120,12 +77,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // ```\n             //\n             // See issue #46688.\n-            def_bm = ty::BindByValue(hir::MutImmutable);\n-        }\n-\n-        // Lose mutability now that we know binding mode and discriminant type.\n-        let def_bm = def_bm;\n-        let expected = expected;\n+            let def_bm = match pat.node {\n+                PatKind::Ref(..) => ty::BindByValue(hir::MutImmutable),\n+                _ => def_bm,\n+            };\n+            (expected, def_bm)\n+        };\n \n         let ty = match pat.node {\n             PatKind::Wild => {\n@@ -568,6 +525,62 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// Peel off as many immediately nested `& mut?` from the expected type as possible\n+    /// and return the new expected type and binding default binding mode.\n+    /// The adjustments vector, if non-empty is stored in a table.\n+    fn peel_off_references(\n+        &self,\n+        pat: &'tcx hir::Pat,\n+        expected: Ty<'tcx>,\n+        mut def_bm: ty::BindingMode,\n+    ) -> (Ty<'tcx>, ty::BindingMode) {\n+        let mut expected = self.resolve_type_vars_with_obligations(&expected);\n+\n+        // Peel off as many `&` or `&mut` from the scrutinee type as possible. For example,\n+        // for `match &&&mut Some(5)` the loop runs three times, aborting when it reaches\n+        // the `Some(5)` which is not of type Ref.\n+        //\n+        // For each ampersand peeled off, update the binding mode and push the original\n+        // type into the adjustments vector.\n+        //\n+        // See the examples in `ui/match-defbm*.rs`.\n+        let mut pat_adjustments = vec![];\n+        while let ty::Ref(_, inner_ty, inner_mutability) = expected.sty {\n+            debug!(\"inspecting {:?}\", expected);\n+\n+            debug!(\"current discriminant is Ref, inserting implicit deref\");\n+            // Preserve the reference type. We'll need it later during HAIR lowering.\n+            pat_adjustments.push(expected);\n+\n+            expected = inner_ty;\n+            def_bm = match def_bm {\n+                // If default binding mode is by value, make it `ref` or `ref mut`\n+                // (depending on whether we observe `&` or `&mut`).\n+                ty::BindByValue(_) =>\n+                    ty::BindByReference(inner_mutability),\n+\n+                // Once a `ref`, always a `ref`. This is because a `& &mut` can't mutate\n+                // the underlying value.\n+                ty::BindByReference(hir::Mutability::MutImmutable) =>\n+                    ty::BindByReference(hir::Mutability::MutImmutable),\n+\n+                // When `ref mut`, stay a `ref mut` (on `&mut`) or downgrade to `ref`\n+                // (on `&`).\n+                ty::BindByReference(hir::Mutability::MutMutable) =>\n+                    ty::BindByReference(inner_mutability),\n+            };\n+        }\n+\n+        if pat_adjustments.len() > 0 {\n+            debug!(\"default binding mode is now {:?}\", def_bm);\n+            self.inh.tables.borrow_mut()\n+                .pat_adjustments_mut()\n+                .insert(pat.hir_id, pat_adjustments);\n+        }\n+\n+        (expected, def_bm)\n+    }\n+\n     fn borrow_pat_suggestion(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,"}]}