{"sha": "c11a44ab6ce693629a03554b8b35d2218bca83cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxMWE0NGFiNmNlNjkzNjI5YTAzNTU0YjhiMzVkMjIxOGJjYTgzY2Y=", "commit": {"author": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2019-10-23T08:01:22Z"}, "committer": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2019-10-24T15:57:07Z"}, "message": "Use more precise atomic orderings", "tree": {"sha": "b3db9ad1a9bb9d7c1e92c6416755da0ada6880fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3db9ad1a9bb9d7c1e92c6416755da0ada6880fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c11a44ab6ce693629a03554b8b35d2218bca83cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c11a44ab6ce693629a03554b8b35d2218bca83cf", "html_url": "https://github.com/rust-lang/rust/commit/c11a44ab6ce693629a03554b8b35d2218bca83cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c11a44ab6ce693629a03554b8b35d2218bca83cf/comments", "author": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88c70edef66b6885dec6aa8f7a4e73eff2b745ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/88c70edef66b6885dec6aa8f7a4e73eff2b745ef", "html_url": "https://github.com/rust-lang/rust/commit/88c70edef66b6885dec6aa8f7a4e73eff2b745ef"}], "stats": {"total": 53, "additions": 41, "deletions": 12}, "files": [{"sha": "4c14fe75643a891d43060e8a28db41c80b3d6ba0", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 41, "deletions": 12, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c11a44ab6ce693629a03554b8b35d2218bca83cf/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c11a44ab6ce693629a03554b8b35d2218bca83cf/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=c11a44ab6ce693629a03554b8b35d2218bca83cf", "patch": "@@ -51,6 +51,38 @@\n //\n // You'll find a few more details in the implementation, but that's the gist of\n // it!\n+//\n+// Atomic orderings:\n+// When running `Once` we deal with multiple atomics:\n+// `Once.state_and_queue` and an unknown number of `Waiter.signaled`.\n+// * `state_and_queue` is used (1) as a state flag, (2) for synchronizing the\n+//   result of the `Once`, and (3) for synchronizing `Waiter` nodes.\n+//     - At the end of the `call_inner` function we have to make sure the result\n+//       of the `Once` is acquired. So every load which can be the only one to\n+//       load COMPLETED must have at least Acquire ordering, which means all\n+//       three of them.\n+//     - `WaiterQueue::Drop` is the only place that may store COMPLETED, and\n+//       must do so with Release ordering to make the result available.\n+//     - `wait` inserts `Waiter` nodes as a pointer in `state_and_queue`, and\n+//       needs to make the nodes available with Release ordering. The load in\n+//       its `compare_and_swap` can be Relaxed because it only has to compare\n+//       the atomic, not to read other data.\n+//     - `WaiterQueue::Drop` must see the `Waiter` nodes, so it must load\n+//       `state_and_queue` with Acquire ordering.\n+//     - There is just one store where `state_and_queue` is used only as a\n+//       state flag, without having to synchronize data: switching the state\n+//       from INCOMPLETE to RUNNING in `call_inner`. This store can be Relaxed,\n+//       but the read has to be Acquire because of the requirements mentioned\n+//       above.\n+// * `Waiter.signaled` is both used as a flag, and to protect a field with\n+//   interior mutability in `Waiter`. `Waiter.thread` is changed in\n+//   `WaiterQueue::Drop` which then sets `signaled` with Release ordering.\n+//   After `wait` loads `signaled` with Acquire and sees it is true, it needs to\n+//   see the changes to drop the `Waiter` struct correctly.\n+// * There is one place where the two atomics `Once.state_and_queue` and\n+//   `Waiter.signaled` come together, and might be reordered by the compiler or\n+//   processor. Because both use Aquire ordering such a reordering is not\n+//   allowed, so no need for SeqCst.\n \n use crate::cell::Cell;\n use crate::fmt;\n@@ -337,7 +369,7 @@ impl Once {\n         // An `Acquire` load is enough because that makes all the initialization\n         // operations visible to us, and, this being a fast path, weaker\n         // ordering helps with performance. This `Acquire` synchronizes with\n-        // `SeqCst` operations on the slow path.\n+        // `Release` operations on the slow path.\n         self.state_and_queue.load(Ordering::Acquire) == COMPLETE\n     }\n \n@@ -355,12 +387,9 @@ impl Once {\n     #[cold]\n     fn call_inner(&self,\n                   ignore_poisoning: bool,\n-                  init: &mut dyn FnMut(bool)) {\n-\n-        // This cold path uses SeqCst consistently because the\n-        // performance difference really does not matter there, and\n-        // SeqCst minimizes the chances of something going wrong.\n-        let mut state_and_queue = self.state_and_queue.load(Ordering::SeqCst);\n+                  init: &mut dyn FnMut(bool))\n+    {\n+        let mut state_and_queue = self.state_and_queue.load(Ordering::Acquire);\n         loop {\n             match state_and_queue {\n                 COMPLETE => break,\n@@ -373,7 +402,7 @@ impl Once {\n                     // Try to register this thread as the one RUNNING.\n                     let old = self.state_and_queue.compare_and_swap(state_and_queue,\n                                                                     RUNNING,\n-                                                                    Ordering::SeqCst);\n+                                                                    Ordering::Acquire);\n                     if old != state_and_queue {\n                         state_and_queue = old;\n                         continue\n@@ -395,7 +424,7 @@ impl Once {\n                     // pointer to the waiter queue in the more significant bits.\n                     assert!(state_and_queue & STATE_MASK == RUNNING);\n                     wait(&self.state_and_queue, state_and_queue);\n-                    state_and_queue = self.state_and_queue.load(Ordering::SeqCst);\n+                    state_and_queue = self.state_and_queue.load(Ordering::Acquire);\n                 }\n             }\n         }\n@@ -438,7 +467,7 @@ fn wait(state_and_queue: &AtomicUsize, current_state: usize) {\n     // drop our `Waiter` node and leave a hole in the linked list (and a\n     // dangling reference). Guard against spurious wakeups by reparking\n     // ourselves until we are signaled.\n-    while !node.signaled.load(Ordering::SeqCst) {\n+    while !node.signaled.load(Ordering::Acquire) {\n         thread::park();\n     }\n }\n@@ -454,7 +483,7 @@ impl Drop for WaiterQueue<'_> {\n     fn drop(&mut self) {\n         // Swap out our state with however we finished.\n         let state_and_queue = self.state_and_queue.swap(self.set_state_on_drop_to,\n-                                                        Ordering::SeqCst);\n+                                                        Ordering::AcqRel);\n \n         // We should only ever see an old state which was RUNNING.\n         assert_eq!(state_and_queue & STATE_MASK, RUNNING);\n@@ -470,7 +499,7 @@ impl Drop for WaiterQueue<'_> {\n             while !queue.is_null() {\n                 let next = (*queue).next;\n                 let thread = (*queue).thread.replace(None).unwrap();\n-                (*queue).signaled.store(true, Ordering::SeqCst);\n+                (*queue).signaled.store(true, Ordering::Release);\n                 // ^- FIXME (maybe): This is another case of issue #55005\n                 // `store()` has a potentially dangling ref to `signaled`.\n                 queue = next;"}]}