{"sha": "2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlYmI2NzQ4N2MxNTMwODIyZDgzZDZkYTZmNzFmYTYyY2I2OGYyY2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-11T17:15:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-11T17:15:58Z"}, "message": "auto merge of #5291 : pcwalton/rust/drop-lint, r=pcwalton\n\nr? @nikomatsakis", "tree": {"sha": "7c5b611ac00f1054d51fd657d7fb7d143291fce2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c5b611ac00f1054d51fd657d7fb7d143291fce2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "html_url": "https://github.com/rust-lang/rust/commit/2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51cdca0bf0d3efc554c1815df9306ea10e881a14", "url": "https://api.github.com/repos/rust-lang/rust/commits/51cdca0bf0d3efc554c1815df9306ea10e881a14", "html_url": "https://github.com/rust-lang/rust/commit/51cdca0bf0d3efc554c1815df9306ea10e881a14"}, {"sha": "08c840205ea477d4f76216abac45be6a4ce9fa4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/08c840205ea477d4f76216abac45be6a4ce9fa4b", "html_url": "https://github.com/rust-lang/rust/commit/08c840205ea477d4f76216abac45be6a4ce9fa4b"}], "stats": {"total": 2328, "additions": 1138, "deletions": 1190}, "files": [{"sha": "e559af62e360c88829b957a2a990600c57d99ec2", "filename": "doc/rust.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -889,10 +889,10 @@ declared, in an angle-bracket-enclosed, comma-separated list following\n the function name.\n \n ~~~~ {.xfail-test}\n-fn iter<T>(seq: &[T], f: fn(T)) {\n+fn iter<T>(seq: &[T], f: &fn(T)) {\n     for seq.each |elt| { f(elt); }\n }\n-fn map<T, U>(seq: &[T], f: fn(T) -> U) -> ~[U] {\n+fn map<T, U>(seq: &[T], f: &fn(T) -> U) -> ~[U] {\n     let mut acc = ~[];\n     for seq.each |elt| { acc.push(f(elt)); }\n     acc\n@@ -1198,7 +1198,7 @@ These appear after the trait name, using the same syntax used in [generic functi\n trait Seq<T> {\n    fn len() -> uint;\n    fn elt_at(n: uint) -> T;\n-   fn iter(fn(T));\n+   fn iter(&fn(T));\n }\n ~~~~\n \n@@ -2074,7 +2074,7 @@ and moving values from the environment into the lambda expression's captured env\n An example of a lambda expression:\n \n ~~~~\n-fn ten_times(f: fn(int)) {\n+fn ten_times(f: &fn(int)) {\n     let mut i = 0;\n     while i < 10 {\n         f(i);\n@@ -2177,7 +2177,7 @@ If the `expr` is a [field expression](#field-expressions), it is parsed as thoug\n In this example, both calls to `f` are equivalent:\n \n ~~~~\n-# fn f(f: fn(int)) { }\n+# fn f(f: &fn(int)) { }\n # fn g(i: int) { }\n \n f(|j| g(j));\n@@ -2755,7 +2755,7 @@ and the cast expression in `main`.\n Within the body of an item that has type parameter declarations, the names of its type parameters are types:\n \n ~~~~~~~\n-fn map<A: Copy, B: Copy>(f: fn(A) -> B, xs: &[A]) -> ~[B] {\n+fn map<A: Copy, B: Copy>(f: &fn(A) -> B, xs: &[A]) -> ~[B] {\n    if xs.len() == 0 { return ~[]; }\n    let first: B = f(xs[0]);\n    let rest: ~[B] = map(f, xs.slice(1, xs.len()));"}, {"sha": "e4775e1b11b4d5e14386676522e3b9255c661fb1", "filename": "doc/tutorial.md", "status": "modified", "additions": 45, "deletions": 53, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -681,45 +681,6 @@ the value of `North` is 0, `East` is 1, `South` is 2, and `West` is 3.\n When an enum is C-like, you can apply the `as` cast operator to\n convert it to its discriminator value as an `int`.\n \n-<a name=\"single_variant_enum\"></a>\n-\n-There is a special case for enums with a single variant, which are\n-sometimes called \"newtype-style enums\" (after Haskell's \"newtype\"\n-feature). These are used to define new types in such a way that the\n-new name is not just a synonym for an existing type, but its own\n-distinct type: `type` creates a structural synonym, while this form of\n-`enum` creates a nominal synonym. If you say:\n-\n-~~~~\n-enum GizmoId = int;\n-~~~~\n-\n-That is a shorthand for this:\n-\n-~~~~\n-enum GizmoId { GizmoId(int) }\n-~~~~\n-\n-You can extract the contents of such an enum type with the\n-dereference (`*`) unary operator:\n-\n-~~~~\n-# enum GizmoId = int;\n-let my_gizmo_id: GizmoId = GizmoId(10);\n-let id_int: int = *my_gizmo_id;\n-~~~~\n-\n-Types like this can be useful to differentiate between data that have\n-the same type but must be used in different ways.\n-\n-~~~~\n-enum Inches = int;\n-enum Centimeters = int;\n-~~~~\n-\n-The above definitions allow for a simple way for programs to avoid\n-confusing numbers that correspond to different units.\n-\n For enum types with multiple variants, destructuring is the only way to\n get at their contents. All variant constructors can be used as\n patterns, as in this definition of `area`:\n@@ -789,10 +750,10 @@ match mytup {\n \n ## Tuple structs\n \n-Rust also has _nominal tuples_, which behave like both structs and tuples,\n-except that nominal tuple types have names\n-(so `Foo(1, 2)` has a different type from `Bar(1, 2)`),\n-and nominal tuple types' _fields_ do not have names.\n+Rust also has _tuple structs_, which behave like both structs and tuples,\n+except that, unlike tuples, tuple structs have names (so `Foo(1, 2)` has a\n+different type from `Bar(1, 2)`), and tuple structs' _fields_ do not have\n+names.\n \n For example:\n ~~~~\n@@ -803,6 +764,37 @@ match mytup {\n }\n ~~~~\n \n+<a name=\"newtype\"></a>\n+\n+There is a special case for tuple structs with a single field, which are\n+sometimes called \"newtypes\" (after Haskell's \"newtype\" feature). These are\n+used to define new types in such a way that the new name is not just a\n+synonym for an existing type but is rather its own distinct type.\n+\n+~~~~\n+struct GizmoId(int);\n+~~~~\n+\n+For convenience, you can extract the contents of such a struct with the\n+dereference (`*`) unary operator:\n+\n+~~~~\n+# struct GizmoId(int);\n+let my_gizmo_id: GizmoId = GizmoId(10);\n+let id_int: int = *my_gizmo_id;\n+~~~~\n+\n+Types like this can be useful to differentiate between data that have\n+the same type but must be used in different ways.\n+\n+~~~~\n+struct Inches(int);\n+struct Centimeters(int);\n+~~~~\n+\n+The above definitions allow for a simple way for programs to avoid\n+confusing numbers that correspond to different units.\n+\n # Functions\n \n We've already seen several function definitions. Like all other static\n@@ -1369,7 +1361,7 @@ the enclosing scope.\n \n ~~~~\n # use println = core::io::println;\n-fn call_closure_with_ten(b: fn(int)) { b(10); }\n+fn call_closure_with_ten(b: &fn(int)) { b(10); }\n \n let captured_var = 20;\n let closure = |arg| println(fmt!(\"captured_var=%d, arg=%d\", captured_var, arg));\n@@ -1455,7 +1447,7 @@ should almost always declare the type of that argument as `fn()`. That way,\n callers may pass any kind of closure.\n \n ~~~~\n-fn call_twice(f: fn()) { f(); f(); }\n+fn call_twice(f: &fn()) { f(); f(); }\n let closure = || { \"I'm a closure, and it doesn't matter what type I am\"; };\n fn function() { \"I'm a normal function\"; }\n call_twice(closure);\n@@ -1475,7 +1467,7 @@ Consider this function that iterates over a vector of\n integers, passing in a pointer to each integer in the vector:\n \n ~~~~\n-fn each(v: &[int], op: fn(v: &int)) {\n+fn each(v: &[int], op: &fn(v: &int)) {\n    let mut n = 0;\n    while n < v.len() {\n        op(&v[n]);\n@@ -1496,7 +1488,7 @@ argument, we can write it in a way that has a pleasant, block-like\n structure.\n \n ~~~~\n-# fn each(v: &[int], op: fn(v: &int)) { }\n+# fn each(v: &[int], op: &fn(v: &int)) { }\n # fn do_some_work(i: &int) { }\n each([1, 2, 3], |n| {\n     do_some_work(n);\n@@ -1507,7 +1499,7 @@ This is such a useful pattern that Rust has a special form of function\n call that can be written more like a built-in control structure:\n \n ~~~~\n-# fn each(v: &[int], op: fn(v: &int)) { }\n+# fn each(v: &[int], op: &fn(v: &int)) { }\n # fn do_some_work(i: &int) { }\n do each([1, 2, 3]) |n| {\n     do_some_work(n);\n@@ -1554,7 +1546,7 @@ Consider again our `each` function, this time improved to\n break early when the iteratee returns `false`:\n \n ~~~~\n-fn each(v: &[int], op: fn(v: &int) -> bool) {\n+fn each(v: &[int], op: &fn(v: &int) -> bool) {\n    let mut n = 0;\n    while n < v.len() {\n        if !op(&v[n]) {\n@@ -1778,7 +1770,7 @@ vector consisting of the result of applying `function` to each element\n of `vector`:\n \n ~~~~\n-fn map<T, U>(vector: &[T], function: fn(v: &T) -> U) -> ~[U] {\n+fn map<T, U>(vector: &[T], function: &fn(v: &T) -> U) -> ~[U] {\n     let mut accumulator = ~[];\n     for vec::each(vector) |element| {\n         accumulator.push(function(element));\n@@ -1977,12 +1969,12 @@ types might look like the following:\n ~~~~\n trait Seq<T> {\n     fn len(&self) -> uint;\n-    fn iter(&self, b: fn(v: &T));\n+    fn iter(&self, b: &fn(v: &T));\n }\n \n impl<T> Seq<T> for ~[T] {\n     fn len(&self) -> uint { vec::len(*self) }\n-    fn iter(&self, b: fn(v: &T)) {\n+    fn iter(&self, b: &fn(v: &T)) {\n         for vec::each(*self) |elt| { b(elt); }\n     }\n }\n@@ -2294,7 +2286,7 @@ struct level. Note that fields and methods are _public_ by default.\n pub mod farm {\n # pub type Chicken = int;\n # type Cow = int;\n-# enum Human = int;\n+# struct Human(int);\n # impl Human { fn rest(&self) { } }\n # pub fn make_me_a_farm() -> Farm { Farm { chickens: ~[], cows: ~[], farmer: Human(0) } }\n     pub struct Farm {"}, {"sha": "7d0a4d7dcc805ae0dfaeccf3cdb63b29f922d143", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -103,7 +103,7 @@ pub fn is_test_ignored(config: config, testfile: &Path) -> bool {\n     }\n }\n \n-fn iter_header(testfile: &Path, it: fn(~str) -> bool) -> bool {\n+fn iter_header(testfile: &Path, it: &fn(~str) -> bool) -> bool {\n     let rdr = io::file_reader(testfile).get();\n     while !rdr.eof() {\n         let ln = rdr.read_line();"}, {"sha": "f95a530831b931a040938ce8ef0e62b2e6b9da64", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -530,7 +530,7 @@ fn compose_and_run(config: config, testfile: &Path,\n }\n \n fn make_compile_args(config: config, props: TestProps, extras: ~[~str],\n-                     xform: fn(config, (&Path)) -> Path,\n+                     xform: &fn(config, (&Path)) -> Path,\n                      testfile: &Path) -> ProcArgs {\n     let prog = config.rustc_path;\n     let mut args = ~[testfile.to_str(),"}, {"sha": "fa19e24aa0830be77f8385d555df9645284f9a4b", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -61,7 +61,7 @@ pub pure fn capacity<T>(v: @[const T]) -> uint {\n  */\n #[inline(always)]\n pub pure fn build_sized<A>(size: uint,\n-                           builder: &fn(push: pure fn(v: A))) -> @[A] {\n+                           builder: &fn(push: &pure fn(v: A))) -> @[A] {\n     let mut vec: @[const A] = @[];\n     unsafe { raw::reserve(&mut vec, size); }\n     builder(|+x| unsafe { raw::push(&mut vec, x) });\n@@ -79,7 +79,7 @@ pub pure fn build_sized<A>(size: uint,\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build<A>(builder: &fn(push: pure fn(v: A))) -> @[A] {\n+pub pure fn build<A>(builder: &fn(push: &pure fn(v: A))) -> @[A] {\n     build_sized(4, builder)\n }\n \n@@ -97,7 +97,7 @@ pub pure fn build<A>(builder: &fn(push: pure fn(v: A))) -> @[A] {\n  */\n #[inline(always)]\n pub pure fn build_sized_opt<A>(size: Option<uint>,\n-                               builder: &fn(push: pure fn(v: A))) -> @[A] {\n+                               builder: &fn(push: &pure fn(v: A))) -> @[A] {\n     build_sized(size.get_or_default(4), builder)\n }\n "}, {"sha": "512855d8f86c0a0fd9a9557a8d8c86f43071aeda", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -67,7 +67,7 @@ pub pure fn to_str(v: bool) -> ~str { if v { ~\"true\" } else { ~\"false\" } }\n  * Iterates over all truth values by passing them to `blk` in an unspecified\n  * order\n  */\n-pub fn all_values(blk: fn(v: bool)) {\n+pub fn all_values(blk: &fn(v: bool)) {\n     blk(true);\n     blk(false);\n }"}, {"sha": "91a4ded60efd65a69755d9887f6f56bbf2cb4310", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -54,7 +54,7 @@ pub impl<T> Cell<T> {\n     }\n \n     // Calls a closure with a reference to the value.\n-    fn with_ref<R>(&self, op: fn(v: &T) -> R) -> R {\n+    fn with_ref<R>(&self, op: &fn(v: &T) -> R) -> R {\n         let v = self.take();\n         let r = op(&v);\n         self.put_back(v);"}, {"sha": "faa6db45df2f6fe5a94a11bd93134753126ebf9a", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -124,7 +124,7 @@ struct AnnihilateStats {\n     n_bytes_freed: uint\n }\n \n-unsafe fn each_live_alloc(f: fn(box: *mut BoxRepr, uniq: bool) -> bool) {\n+unsafe fn each_live_alloc(f: &fn(box: *mut BoxRepr, uniq: bool) -> bool) {\n     use managed;\n \n     let task: *Task = transmute(rustrt::rust_get_task());"}, {"sha": "4f1f6004aad770b6bf610f543d17775d4a347712", "filename": "src/libcore/container.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -30,10 +30,10 @@ pub trait Map<K, V>: Mutable {\n     pure fn contains_key(&self, key: &K) -> bool;\n \n     /// Visit all keys\n-    pure fn each_key(&self, f: fn(&K) -> bool);\n+    pure fn each_key(&self, f: &fn(&K) -> bool);\n \n     /// Visit all values\n-    pure fn each_value(&self, f: fn(&V) -> bool);\n+    pure fn each_value(&self, f: &fn(&V) -> bool);\n \n     /// Return the value corresponding to the key in the map\n     pure fn find(&self, key: &K) -> Option<&self/V>;\n@@ -71,14 +71,14 @@ pub trait Set<T>: Mutable {\n     pure fn is_superset(&self, other: &Self) -> bool;\n \n     /// Visit the values representing the difference\n-    pure fn difference(&self, other: &Self, f: fn(&T) -> bool);\n+    pure fn difference(&self, other: &Self, f: &fn(&T) -> bool);\n \n     /// Visit the values representing the symmetric difference\n-    pure fn symmetric_difference(&self, other: &Self, f: fn(&T) -> bool);\n+    pure fn symmetric_difference(&self, other: &Self, f: &fn(&T) -> bool);\n \n     /// Visit the values representing the intersection\n-    pure fn intersection(&self, other: &Self, f: fn(&T) -> bool);\n+    pure fn intersection(&self, other: &Self, f: &fn(&T) -> bool);\n \n     /// Visit the values representing the union\n-    pure fn union(&self, other: &Self, f: fn(&T) -> bool);\n+    pure fn union(&self, other: &Self, f: &fn(&T) -> bool);\n }"}, {"sha": "db1dc1e28aa92379793dc5e8ae9da9cf63dd65a5", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -52,6 +52,7 @@ Implicitly, all crates behave as if they included the following prologue:\n #[deny(non_camel_case_types)];\n #[allow(deprecated_mutable_fields)];\n #[deny(deprecated_self)];\n+#[allow(deprecated_drop)];\n \n // On Linux, link to the runtime with -lrt.\n #[cfg(target_os = \"linux\")]"}, {"sha": "1b5d03d9eb8cdaff3e1bde5302bd359a30b7b6e4", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -399,7 +399,7 @@ pub impl<T> DList<T> {\n     }\n \n     /// Iterate over nodes.\n-    pure fn each_node(@mut self, f: fn(@mut DListNode<T>) -> bool) {\n+    pure fn each_node(@mut self, f: &fn(@mut DListNode<T>) -> bool) {\n         let mut link = self.peek_n();\n         while link.is_some() {\n             let nobe = link.get();\n@@ -507,7 +507,7 @@ impl<T> BaseIter<T> for @mut DList<T> {\n     * allow for e.g. breadth-first search with in-place enqueues), but\n     * removing the current node is forbidden.\n     */\n-    pure fn each(&self, f: fn(v: &T) -> bool) {\n+    pure fn each(&self, f: &fn(v: &T) -> bool) {\n         let mut link = self.peek_n();\n         while option::is_some(&link) {\n             let nobe = option::get(link);"}, {"sha": "e4b7bbbd99e87c9529f2f8ba5a252e78b8d9784e", "filename": "src/libcore/either.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -24,8 +24,8 @@ pub enum Either<T, U> {\n }\n \n #[inline(always)]\n-pub fn either<T, U, V>(f_left: fn(&T) -> V,\n-                       f_right: fn(&U) -> V, value: &Either<T, U>) -> V {\n+pub fn either<T, U, V>(f_left: &fn(&T) -> V,\n+                       f_right: &fn(&U) -> V, value: &Either<T, U>) -> V {\n     /*!\n      * Applies a function based on the given either value\n      *\n@@ -148,7 +148,7 @@ pub pure fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n \n pub impl<T, U> Either<T, U> {\n     #[inline(always)]\n-    fn either<V>(&self, f_left: fn(&T) -> V, f_right: fn(&U) -> V) -> V {\n+    fn either<V>(&self, f_left: &fn(&T) -> V, f_right: &fn(&U) -> V) -> V {\n         either(f_left, f_right, self)\n     }\n "}, {"sha": "2adcee495a738e8fbe69cbb3ee0dbcea41b78b3c", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -86,7 +86,7 @@ pub mod linear {\n \n         #[inline(always)]\n         pure fn bucket_sequence(&self, hash: uint,\n-                                op: fn(uint) -> bool) -> uint {\n+                                op: &fn(uint) -> bool) -> uint {\n             let start_idx = self.to_bucket(hash);\n             let len_buckets = self.buckets.len();\n             let mut idx = start_idx;\n@@ -263,7 +263,7 @@ pub mod linear {\n         }\n \n         fn search(&self, hash: uint,\n-                  op: fn(x: &Option<Bucket<K, V>>) -> bool) {\n+                  op: &fn(x: &Option<Bucket<K, V>>) -> bool) {\n             let _ = self.bucket_sequence(hash, |i| op(&self.buckets[i]));\n         }\n     }\n@@ -272,7 +272,7 @@ pub mod linear {\n         BaseIter<(&self/K, &self/V)> for LinearMap<K, V>\n     {\n         /// Visit all key-value pairs\n-        pure fn each(&self, blk: fn(&(&self/K, &self/V)) -> bool) {\n+        pure fn each(&self, blk: &fn(&(&self/K, &self/V)) -> bool) {\n             for uint::range(0, self.buckets.len()) |i| {\n                 let mut broke = false;\n                 do self.buckets[i].map |bucket| {\n@@ -315,12 +315,12 @@ pub mod linear {\n         }\n \n         /// Visit all keys\n-        pure fn each_key(&self, blk: fn(k: &K) -> bool) {\n+        pure fn each_key(&self, blk: &fn(k: &K) -> bool) {\n             self.each(|&(k, _)| blk(k))\n         }\n \n         /// Visit all values\n-        pure fn each_value(&self, blk: fn(v: &V) -> bool) {\n+        pure fn each_value(&self, blk: &fn(v: &V) -> bool) {\n             self.each(|&(_, v)| blk(v))\n         }\n \n@@ -428,7 +428,7 @@ pub mod linear {\n \n         /// Return the value corresponding to the key in the map, or create,\n         /// insert, and return a new value if it doesn't exist.\n-        fn find_or_insert_with(&mut self, k: K, f: fn(&K) -> V) -> &self/V {\n+        fn find_or_insert_with(&mut self, k: K, f: &fn(&K) -> V) -> &self/V {\n             if self.size >= self.resize_at {\n                 // n.b.: We could also do this after searching, so\n                 // that we do not resize if this call to insert is\n@@ -457,7 +457,7 @@ pub mod linear {\n             }\n         }\n \n-        fn consume(&mut self, f: fn(K, V)) {\n+        fn consume(&mut self, f: &fn(K, V)) {\n             let mut buckets = ~[];\n             self.buckets <-> buckets;\n             self.size = 0;\n@@ -526,7 +526,7 @@ pub mod linear {\n \n     impl<T:Hash + IterBytes + Eq> BaseIter<T> for LinearSet<T> {\n         /// Visit all values in order\n-        pure fn each(&self, f: fn(&T) -> bool) { self.map.each_key(f) }\n+        pure fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n         pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n     }\n \n@@ -583,7 +583,7 @@ pub mod linear {\n         }\n \n         /// Visit the values representing the difference\n-        pure fn difference(&self, other: &LinearSet<T>, f: fn(&T) -> bool) {\n+        pure fn difference(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n             for self.each |v| {\n                 if !other.contains(v) {\n                     if !f(v) { return }\n@@ -593,13 +593,15 @@ pub mod linear {\n \n         /// Visit the values representing the symmetric difference\n         pure fn symmetric_difference(&self, other: &LinearSet<T>,\n-                                     f: fn(&T) -> bool) {\n+                                     f: &fn(&T) -> bool) {\n             self.difference(other, f);\n             other.difference(self, f);\n         }\n \n         /// Visit the values representing the intersection\n-        pure fn intersection(&self, other: &LinearSet<T>, f: fn(&T) -> bool) {\n+        pure fn intersection(&self,\n+                             other: &LinearSet<T>,\n+                             f: &fn(&T) -> bool) {\n             for self.each |v| {\n                 if other.contains(v) {\n                     if !f(v) { return }\n@@ -608,7 +610,7 @@ pub mod linear {\n         }\n \n         /// Visit the values representing the union\n-        pure fn union(&self, other: &LinearSet<T>, f: fn(&T) -> bool) {\n+        pure fn union(&self, other: &LinearSet<T>, f: &fn(&T) -> bool) {\n             for self.each |v| {\n                 if !f(v) { return }\n             }"}, {"sha": "b04bb15f5e30b9617ddd4ebca34b4fd442ce954d", "filename": "src/libcore/io.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -118,13 +118,13 @@ pub trait ReaderUtil {\n     fn read_whole_stream(&self) -> ~[u8];\n \n     /// Iterate over every byte until the iterator breaks or EOF.\n-    fn each_byte(&self, it: fn(int) -> bool);\n+    fn each_byte(&self, it: &fn(int) -> bool);\n \n     /// Iterate over every char until the iterator breaks or EOF.\n-    fn each_char(&self, it: fn(char) -> bool);\n+    fn each_char(&self, it: &fn(char) -> bool);\n \n     /// Iterate over every line until the iterator breaks or EOF.\n-    fn each_line(&self, it: fn(&str) -> bool);\n+    fn each_line(&self, it: &fn(&str) -> bool);\n \n     /// Read n (between 1 and 8) little-endian unsigned integer bytes.\n     fn read_le_uint_n(&self, nbytes: uint) -> u64;\n@@ -315,19 +315,19 @@ impl<T:Reader> ReaderUtil for T {\n         bytes\n     }\n \n-    fn each_byte(&self, it: fn(int) -> bool) {\n+    fn each_byte(&self, it: &fn(int) -> bool) {\n         while !self.eof() {\n             if !it(self.read_byte()) { break; }\n         }\n     }\n \n-    fn each_char(&self, it: fn(char) -> bool) {\n+    fn each_char(&self, it: &fn(char) -> bool) {\n         while !self.eof() {\n             if !it(self.read_char()) { break; }\n         }\n     }\n \n-    fn each_line(&self, it: fn(s: &str) -> bool) {\n+    fn each_line(&self, it: &fn(s: &str) -> bool) {\n         while !self.eof() {\n             if !it(self.read_line()) { break; }\n         }\n@@ -618,11 +618,11 @@ impl Reader for BytesReader/&self {\n     fn tell(&self) -> uint { self.pos }\n }\n \n-pub pure fn with_bytes_reader<t>(bytes: &[u8], f: fn(@Reader) -> t) -> t {\n+pub pure fn with_bytes_reader<t>(bytes: &[u8], f: &fn(@Reader) -> t) -> t {\n     f(@BytesReader { bytes: bytes, pos: 0u } as @Reader)\n }\n \n-pub pure fn with_str_reader<T>(s: &str, f: fn(@Reader) -> T) -> T {\n+pub pure fn with_str_reader<T>(s: &str, f: &fn(@Reader) -> T) -> T {\n     str::byte_slice(s, |bytes| with_bytes_reader(bytes, f))\n }\n \n@@ -819,7 +819,7 @@ pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n }\n \n pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n-                          f: fn(v: &[u8]) -> T) -> T {\n+                          f: &fn(v: &[u8]) -> T) -> T {\n     fail_unless!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n@@ -851,7 +851,7 @@ pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n }\n \n pub fn u64_to_be_bytes<T>(n: u64, size: uint,\n-                           f: fn(v: &[u8]) -> T) -> T {\n+                           f: &fn(v: &[u8]) -> T) -> T {\n     fail_unless!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n@@ -1142,14 +1142,14 @@ pub pure fn BytesWriter() -> BytesWriter {\n     BytesWriter { bytes: ~[], mut pos: 0u }\n }\n \n-pub pure fn with_bytes_writer(f: fn(Writer)) -> ~[u8] {\n+pub pure fn with_bytes_writer(f: &fn(Writer)) -> ~[u8] {\n     let wr = @BytesWriter();\n     f(wr as Writer);\n     let @BytesWriter{bytes, _} = wr;\n     return bytes;\n }\n \n-pub pure fn with_str_writer(f: fn(Writer)) -> ~str {\n+pub pure fn with_str_writer(f: &fn(Writer)) -> ~str {\n     let mut v = with_bytes_writer(f);\n \n     // FIXME (#3758): This should not be needed.\n@@ -1251,7 +1251,7 @@ pub mod fsync {\n     // FIXME (#2004) find better way to create resources within lifetime of\n     // outer res\n     pub fn FILE_res_sync(file: &FILERes, opt_level: Option<Level>,\n-                         blk: fn(v: Res<*libc::FILE>)) {\n+                         blk: &fn(v: Res<*libc::FILE>)) {\n         unsafe {\n             blk(Res(Arg {\n                 val: file.f, opt_level: opt_level,\n@@ -1266,7 +1266,7 @@ pub mod fsync {\n \n     // fsync fd after executing blk\n     pub fn fd_res_sync(fd: &FdRes, opt_level: Option<Level>,\n-                       blk: fn(v: Res<fd_t>)) {\n+                       blk: &fn(v: Res<fd_t>)) {\n         blk(Res(Arg {\n             val: fd.fd, opt_level: opt_level,\n             fsync_fn: |fd, l| os::fsync_fd(fd, l) as int\n@@ -1278,7 +1278,7 @@ pub mod fsync {\n \n     // Call o.fsync after executing blk\n     pub fn obj_sync(o: FSyncable, opt_level: Option<Level>,\n-                    blk: fn(v: Res<FSyncable>)) {\n+                    blk: &fn(v: Res<FSyncable>)) {\n         blk(Res(Arg {\n             val: o, opt_level: opt_level,\n             fsync_fn: |o, l| o.fsync(l)"}, {"sha": "8931b4088263eeab3685671e3f3069f29cdcd108", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -23,22 +23,22 @@ use vec;\n pub type InitOp<T> = &self/fn(uint) -> T;\n \n pub trait BaseIter<A> {\n-    pure fn each(&self, blk: fn(v: &A) -> bool);\n+    pure fn each(&self, blk: &fn(v: &A) -> bool);\n     pure fn size_hint(&self) -> Option<uint>;\n }\n \n pub trait ReverseIter<A>: BaseIter<A> {\n-    pure fn each_reverse(&self, blk: fn(&A) -> bool);\n+    pure fn each_reverse(&self, blk: &fn(&A) -> bool);\n }\n \n pub trait ExtendedIter<A> {\n-    pure fn eachi(&self, blk: fn(uint, v: &A) -> bool);\n-    pure fn all(&self, blk: fn(&A) -> bool) -> bool;\n-    pure fn any(&self, blk: fn(&A) -> bool) -> bool;\n-    pure fn foldl<B>(&self, b0: B, blk: fn(&B, &A) -> B) -> B;\n-    pure fn position(&self, f: fn(&A) -> bool) -> Option<uint>;\n-    pure fn map_to_vec<B>(&self, op: fn(&A) -> B) -> ~[B];\n-    pure fn flat_map_to_vec<B,IB: BaseIter<B>>(&self, op: fn(&A) -> IB)\n+    pure fn eachi(&self, blk: &fn(uint, v: &A) -> bool);\n+    pure fn all(&self, blk: &fn(&A) -> bool) -> bool;\n+    pure fn any(&self, blk: &fn(&A) -> bool) -> bool;\n+    pure fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B;\n+    pure fn position(&self, f: &fn(&A) -> bool) -> Option<uint>;\n+    pure fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B];\n+    pure fn flat_map_to_vec<B,IB: BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B];\n }\n \n@@ -48,13 +48,13 @@ pub trait EqIter<A:Eq> {\n }\n \n pub trait Times {\n-    pure fn times(&self, it: fn() -> bool);\n+    pure fn times(&self, it: &fn() -> bool);\n }\n \n pub trait CopyableIter<A:Copy> {\n-    pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A];\n+    pure fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A];\n     pure fn to_vec(&self) -> ~[A];\n-    pure fn find(&self, p: fn(&A) -> bool) -> Option<A>;\n+    pure fn find(&self, p: &fn(&A) -> bool) -> Option<A>;\n }\n \n pub trait CopyableOrderedIter<A:Copy + Ord> {\n@@ -86,12 +86,12 @@ pub trait Buildable<A> {\n      *             onto the sequence being constructed.\n      */\n      static pure fn build_sized(size: uint,\n-                                builder: fn(push: pure fn(A))) -> Self;\n+                                builder: &fn(push: &pure fn(A))) -> Self;\n }\n \n #[inline(always)]\n pub pure fn eachi<A,IA:BaseIter<A>>(self: &IA,\n-                                    blk: fn(uint, &A) -> bool) {\n+                                    blk: &fn(uint, &A) -> bool) {\n     let mut i = 0;\n     for self.each |a| {\n         if !blk(i, a) { break; }\n@@ -101,7 +101,7 @@ pub pure fn eachi<A,IA:BaseIter<A>>(self: &IA,\n \n #[inline(always)]\n pub pure fn all<A,IA:BaseIter<A>>(self: &IA,\n-                                  blk: fn(&A) -> bool) -> bool {\n+                                  blk: &fn(&A) -> bool) -> bool {\n     for self.each |a| {\n         if !blk(a) { return false; }\n     }\n@@ -110,7 +110,7 @@ pub pure fn all<A,IA:BaseIter<A>>(self: &IA,\n \n #[inline(always)]\n pub pure fn any<A,IA:BaseIter<A>>(self: &IA,\n-                                  blk: fn(&A) -> bool) -> bool {\n+                                  blk: &fn(&A) -> bool) -> bool {\n     for self.each |a| {\n         if blk(a) { return true; }\n     }\n@@ -119,7 +119,7 @@ pub pure fn any<A,IA:BaseIter<A>>(self: &IA,\n \n #[inline(always)]\n pub pure fn filter_to_vec<A:Copy,IA:BaseIter<A>>(\n-    self: &IA, prd: fn(&A) -> bool) -> ~[A] {\n+    self: &IA, prd: &fn(&A) -> bool) -> ~[A] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n         for self.each |a| {\n             if prd(a) { push(*a); }\n@@ -129,7 +129,7 @@ pub pure fn filter_to_vec<A:Copy,IA:BaseIter<A>>(\n \n #[inline(always)]\n pub pure fn map_to_vec<A,B,IA:BaseIter<A>>(self: &IA,\n-                                           op: fn(&A) -> B)\n+                                           op: &fn(&A) -> B)\n     -> ~[B] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n         for self.each |a| {\n@@ -140,7 +140,7 @@ pub pure fn map_to_vec<A,B,IA:BaseIter<A>>(self: &IA,\n \n #[inline(always)]\n pub pure fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(\n-    self: &IA, op: fn(&A) -> IB) -> ~[B] {\n+    self: &IA, op: &fn(&A) -> IB) -> ~[B] {\n     do vec::build |push| {\n         for self.each |a| {\n             for op(a).each |&b| {\n@@ -152,7 +152,7 @@ pub pure fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(\n \n #[inline(always)]\n pub pure fn foldl<A,B,IA:BaseIter<A>>(self: &IA, b0: B,\n-                                      blk: fn(&B, &A) -> B)\n+                                      blk: &fn(&B, &A) -> B)\n     -> B {\n     let mut b = b0;\n     for self.each |a| {\n@@ -186,7 +186,7 @@ pub pure fn count<A:Eq,IA:BaseIter<A>>(self: &IA, x: &A) -> uint {\n }\n \n #[inline(always)]\n-pub pure fn position<A,IA:BaseIter<A>>(self: &IA, f: fn(&A) -> bool)\n+pub pure fn position<A,IA:BaseIter<A>>(self: &IA, f: &fn(&A) -> bool)\n     -> Option<uint>\n {\n     let mut i = 0;\n@@ -202,7 +202,7 @@ pub pure fn position<A,IA:BaseIter<A>>(self: &IA, f: fn(&A) -> bool)\n // it would have to be implemented with foldr, which is too inefficient.\n \n #[inline(always)]\n-pub pure fn repeat(times: uint, blk: fn() -> bool) {\n+pub pure fn repeat(times: uint, blk: &fn() -> bool) {\n     let mut i = 0;\n     while i < times {\n         if !blk() { break }\n@@ -242,7 +242,7 @@ pub pure fn max<A:Copy + Ord,IA:BaseIter<A>>(self: &IA) -> A {\n \n #[inline(always)]\n pub pure fn find<A:Copy,IA:BaseIter<A>>(self: &IA,\n-                                   f: fn(&A) -> bool) -> Option<A> {\n+                                   f: &fn(&A) -> bool) -> Option<A> {\n     for self.each |i| {\n         if f(i) { return Some(*i) }\n     }\n@@ -262,7 +262,7 @@ pub pure fn find<A:Copy,IA:BaseIter<A>>(self: &IA,\n  *             onto the sequence being constructed.\n  */\n #[inline(always)]\n-pub pure fn build<A,B: Buildable<A>>(builder: fn(push: pure fn(A)))\n+pub pure fn build<A,B: Buildable<A>>(builder: &fn(push: &pure fn(A)))\n     -> B {\n     Buildable::build_sized(4, builder)\n }\n@@ -283,7 +283,7 @@ pub pure fn build<A,B: Buildable<A>>(builder: fn(push: pure fn(A)))\n #[inline(always)]\n pub pure fn build_sized_opt<A,B: Buildable<A>>(\n     size: Option<uint>,\n-    builder: fn(push: pure fn(A))) -> B {\n+    builder: &fn(push: &pure fn(A))) -> B {\n \n     Buildable::build_sized(size.get_or_default(4), builder)\n }\n@@ -292,7 +292,7 @@ pub pure fn build_sized_opt<A,B: Buildable<A>>(\n \n /// Applies a function to each element of an iterable and returns the results.\n #[inline(always)]\n-pub fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: &IT, f: fn(&T) -> U)\n+pub fn map<T,IT: BaseIter<T>,U,BU: Buildable<U>>(v: &IT, f: &fn(&T) -> U)\n     -> BU {\n     do build_sized_opt(v.size_hint()) |push| {\n         for v.each() |elem| {"}, {"sha": "cef8542823a674b5b7e44a7335de19938dd93fd4", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -100,7 +100,7 @@ pub pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n  */\n #[inline(always)]\n /// Iterate over the range [`start`,`start`+`step`..`stop`)\n-pub pure fn range_step(start: T, stop: T, step: T, it: fn(T) -> bool) {\n+pub pure fn range_step(start: T, stop: T, step: T, it: &fn(T) -> bool) {\n     let mut i = start;\n     if step == 0 {\n         fail!(~\"range_step called with step == 0\");\n@@ -119,13 +119,13 @@ pub pure fn range_step(start: T, stop: T, step: T, it: fn(T) -> bool) {\n \n #[inline(always)]\n /// Iterate over the range [`lo`..`hi`)\n-pub pure fn range(lo: T, hi: T, it: fn(T) -> bool) {\n+pub pure fn range(lo: T, hi: T, it: &fn(T) -> bool) {\n     range_step(lo, hi, 1 as T, it);\n }\n \n #[inline(always)]\n /// Iterate over the range [`hi`..`lo`)\n-pub pure fn range_rev(hi: T, lo: T, it: fn(T) -> bool) {\n+pub pure fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) {\n     range_step(hi, lo, -1 as T, it);\n }\n \n@@ -237,7 +237,7 @@ impl FromStrRadix for T {\n \n /// Convert to a string as a byte slice in a given base.\n #[inline(always)]\n-pub pure fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n+pub pure fn to_str_bytes<U>(n: T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n     let (buf, _) = strconv::to_str_bytes_common(&n, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     f(buf)"}, {"sha": "9abbfb03d7a567a8578f9291c296fd0e9343c6c6", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -67,7 +67,10 @@ pub pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n  * Iterate over the range [`start`,`start`+`step`..`stop`)\n  *\n  */\n-pub pure fn range_step(start: T, stop: T, step: T_SIGNED, it: fn(T) -> bool) {\n+pub pure fn range_step(start: T,\n+                       stop: T,\n+                       step: T_SIGNED,\n+                       it: &fn(T) -> bool) {\n     let mut i = start;\n     if step == 0 {\n         fail!(~\"range_step called with step == 0\");\n@@ -88,13 +91,13 @@ pub pure fn range_step(start: T, stop: T, step: T_SIGNED, it: fn(T) -> bool) {\n \n #[inline(always)]\n /// Iterate over the range [`lo`..`hi`)\n-pub pure fn range(lo: T, hi: T, it: fn(T) -> bool) {\n+pub pure fn range(lo: T, hi: T, it: &fn(T) -> bool) {\n     range_step(lo, hi, 1 as T_SIGNED, it);\n }\n \n #[inline(always)]\n /// Iterate over the range [`hi`..`lo`)\n-pub pure fn range_rev(hi: T, lo: T, it: fn(T) -> bool) {\n+pub pure fn range_rev(hi: T, lo: T, it: &fn(T) -> bool) {\n     range_step(hi, lo, -1 as T_SIGNED, it);\n }\n \n@@ -200,7 +203,7 @@ impl FromStrRadix for T {\n \n /// Convert to a string as a byte slice in a given base.\n #[inline(always)]\n-pub pure fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n+pub pure fn to_str_bytes<U>(n: T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n     let (buf, _) = strconv::to_str_bytes_common(&n, radix, false,\n                             strconv::SignNeg, strconv::DigAll);\n     f(buf)"}, {"sha": "f73ff4442ceee0ba16a18d6be12d1d76cece060f", "filename": "src/libcore/num/uint-template/uint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template%2Fuint.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -101,7 +101,7 @@ pub mod inst {\n     * `true` If execution proceeded correctly, `false` if it was interrupted,\n     * that is if `it` returned `false` at any point.\n     */\n-    pub pure fn iterate(lo: uint, hi: uint, it: fn(uint) -> bool) -> bool {\n+    pub pure fn iterate(lo: uint, hi: uint, it: &fn(uint) -> bool) -> bool {\n         let mut i = lo;\n         while i < hi {\n             if (!it(i)) { return false; }\n@@ -122,7 +122,7 @@ pub mod inst {\n         * use with integer literals of inferred integer-type as\n         * the self-value (eg. `for 100.times { ... }`).\n         */\n-        pure fn times(&self, it: fn() -> bool) {\n+        pure fn times(&self, it: &fn() -> bool) {\n             let mut i = *self;\n             while i > 0 {\n                 if !it() { break }"}, {"sha": "e0393fdf5e35a287101c9a12bc72b1fa6733c8ab", "filename": "src/libcore/option.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -131,15 +131,15 @@ pub pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n }\n \n #[inline(always)]\n-pub pure fn map<T, U>(opt: &r/Option<T>, f: fn(x: &r/T) -> U) -> Option<U> {\n+pub pure fn map<T, U>(opt: &r/Option<T>, f: &fn(x: &r/T) -> U) -> Option<U> {\n     //! Maps a `some` value by reference from one type to another\n \n     match *opt { Some(ref x) => Some(f(x)), None => None }\n }\n \n #[inline(always)]\n pub pure fn map_consume<T, U>(opt: Option<T>,\n-                              f: fn(v: T) -> U) -> Option<U> {\n+                              f: &fn(v: T) -> U) -> Option<U> {\n     /*!\n      * As `map`, but consumes the option and gives `f` ownership to avoid\n      * copying.\n@@ -149,7 +149,7 @@ pub pure fn map_consume<T, U>(opt: Option<T>,\n \n #[inline(always)]\n pub pure fn chain<T, U>(opt: Option<T>,\n-                        f: fn(t: T) -> Option<U>) -> Option<U> {\n+                        f: &fn(t: T) -> Option<U>) -> Option<U> {\n     /*!\n      * Update an optional value by optionally running its content through a\n      * function that returns an option.\n@@ -163,7 +163,7 @@ pub pure fn chain<T, U>(opt: Option<T>,\n \n #[inline(always)]\n pub pure fn chain_ref<T, U>(opt: &Option<T>,\n-                            f: fn(x: &T) -> Option<U>) -> Option<U> {\n+                            f: &fn(x: &T) -> Option<U>) -> Option<U> {\n     /*!\n      * Update an optional value by optionally running its content by reference\n      * through a function that returns an option.\n@@ -184,7 +184,7 @@ pub pure fn or<T>(opta: Option<T>, optb: Option<T>) -> Option<T> {\n }\n \n #[inline(always)]\n-pub pure fn while_some<T>(x: Option<T>, blk: fn(v: T) -> Option<T>) {\n+pub pure fn while_some<T>(x: Option<T>, blk: &fn(v: T) -> Option<T>) {\n     //! Applies a function zero or more times until the result is none.\n \n     let mut opt = x;\n@@ -223,7 +223,7 @@ pub pure fn get_or_default<T:Copy>(opt: Option<T>, def: T) -> T {\n \n #[inline(always)]\n pub pure fn map_default<T, U>(opt: &r/Option<T>, def: U,\n-                              f: fn(&r/T) -> U) -> U {\n+                              f: &fn(&r/T) -> U) -> U {\n     //! Applies a function to the contained value or returns a default\n \n     match *opt { None => def, Some(ref t) => f(t) }\n@@ -279,7 +279,7 @@ pub pure fn expect<T>(opt: Option<T>, reason: &str) -> T {\n impl<T> BaseIter<T> for Option<T> {\n     /// Performs an operation on the contained value by reference\n     #[inline(always)]\n-    pure fn each(&self, f: fn(x: &self/T) -> bool) {\n+    pure fn each(&self, f: &fn(x: &self/T) -> bool) {\n         match *self { None => (), Some(ref t) => { f(t); } }\n     }\n \n@@ -303,43 +303,43 @@ pub impl<T> Option<T> {\n      * through a function that returns an option.\n      */\n     #[inline(always)]\n-    pure fn chain_ref<U>(&self, f: fn(x: &T) -> Option<U>) -> Option<U> {\n+    pure fn chain_ref<U>(&self, f: &fn(x: &T) -> Option<U>) -> Option<U> {\n         chain_ref(self, f)\n     }\n \n     /// Maps a `some` value from one type to another by reference\n     #[inline(always)]\n-    pure fn map<U>(&self, f: fn(&self/T) -> U) -> Option<U> { map(self, f) }\n+    pure fn map<U>(&self, f: &fn(&self/T) -> U) -> Option<U> { map(self, f) }\n \n     /// As `map`, but consumes the option and gives `f` ownership to avoid\n     /// copying.\n     #[inline(always)]\n-    pure fn map_consume<U>(self, f: fn(v: T) -> U) -> Option<U> {\n+    pure fn map_consume<U>(self, f: &fn(v: T) -> U) -> Option<U> {\n         map_consume(self, f)\n     }\n \n     /// Applies a function to the contained value or returns a default\n     #[inline(always)]\n-    pure fn map_default<U>(&self, def: U, f: fn(&self/T) -> U) -> U {\n+    pure fn map_default<U>(&self, def: U, f: &fn(&self/T) -> U) -> U {\n         map_default(self, def, f)\n     }\n \n     /// As `map_default`, but consumes the option and gives `f`\n     /// ownership to avoid copying.\n     #[inline(always)]\n-    pure fn map_consume_default<U>(self, def: U, f: fn(v: T) -> U) -> U {\n+    pure fn map_consume_default<U>(self, def: U, f: &fn(v: T) -> U) -> U {\n         match self { None => def, Some(v) => f(v) }\n     }\n \n     /// Apply a function to the contained value or do nothing\n-    fn mutate(&mut self, f: fn(T) -> T) {\n+    fn mutate(&mut self, f: &fn(T) -> T) {\n         if self.is_some() {\n             *self = Some(f(self.swap_unwrap()));\n         }\n     }\n \n     /// Apply a function to the contained value or set it to a default\n-    fn mutate_default(&mut self, def: T, f: fn(T) -> T) {\n+    fn mutate_default(&mut self, def: T, f: &fn(T) -> T) {\n         if self.is_some() {\n             *self = Some(f(self.swap_unwrap()));\n         } else {\n@@ -420,7 +420,7 @@ pub impl<T:Copy> Option<T> {\n \n     /// Applies a function zero or more times until the result is none.\n     #[inline(always)]\n-    pure fn while_some(self, blk: fn(v: T) -> Option<T>) {\n+    pure fn while_some(self, blk: &fn(v: T) -> Option<T>) {\n         while_some(self, blk)\n     }\n }"}, {"sha": "ba16c14a85add108be30ed3ff723032e0beb4bd9", "filename": "src/libcore/os.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -75,11 +75,11 @@ pub fn getcwd() -> Path {\n     }\n }\n \n-pub fn as_c_charp<T>(s: &str, f: fn(*c_char) -> T) -> T {\n+pub fn as_c_charp<T>(s: &str, f: &fn(*c_char) -> T) -> T {\n     str::as_c_str(s, |b| f(b as *c_char))\n }\n \n-pub fn fill_charp_buf(f: fn(*mut c_char, size_t) -> bool)\n+pub fn fill_charp_buf(f: &fn(*mut c_char, size_t) -> bool)\n     -> Option<~str> {\n     let mut buf = vec::from_elem(TMPBUF_SZ, 0u8 as c_char);\n     do vec::as_mut_buf(buf) |b, sz| {\n@@ -103,7 +103,7 @@ pub mod win32 {\n     use os::TMPBUF_SZ;\n     use libc::types::os::arch::extra::DWORD;\n \n-    pub fn fill_utf16_buf_and_decode(f: fn(*mut u16, DWORD) -> DWORD)\n+    pub fn fill_utf16_buf_and_decode(f: &fn(*mut u16, DWORD) -> DWORD)\n         -> Option<~str> {\n         unsafe {\n             let mut n = TMPBUF_SZ as DWORD;\n@@ -133,7 +133,7 @@ pub mod win32 {\n         }\n     }\n \n-    pub fn as_utf16_p<T>(s: &str, f: fn(*u16) -> T) -> T {\n+    pub fn as_utf16_p<T>(s: &str, f: &fn(*u16) -> T) -> T {\n         let mut t = str::to_utf16(s);\n         // Null terminate before passing on.\n         t += ~[0u16];\n@@ -518,11 +518,11 @@ pub fn tmpdir() -> Path {\n     }\n }\n /// Recursively walk a directory structure\n-pub fn walk_dir(p: &Path, f: fn(&Path) -> bool) {\n+pub fn walk_dir(p: &Path, f: &fn(&Path) -> bool) {\n \n     walk_dir_(p, f);\n \n-    fn walk_dir_(p: &Path, f: fn(&Path) -> bool) -> bool {\n+    fn walk_dir_(p: &Path, f: &fn(&Path) -> bool) -> bool {\n         let mut keepgoing = true;\n         do list_dir(p).each |q| {\n             let path = &p.push(*q);"}, {"sha": "fd823e9dda0d73888476ab7983f569ad68fcb9c6", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -246,7 +246,7 @@ pub fn packet<T>() -> *Packet<T> {\n #[doc(hidden)]\n pub fn entangle_buffer<T:Owned,Tstart:Owned>(\n     buffer: ~Buffer<T>,\n-    init: fn(*libc::c_void, x: &T) -> *Packet<Tstart>)\n+    init: &fn(*libc::c_void, x: &T) -> *Packet<Tstart>)\n     -> (SendPacketBuffered<Tstart, T>, RecvPacketBuffered<Tstart, T>)\n {\n     let p = init(unsafe { reinterpret_cast(&buffer) }, &buffer.data);"}, {"sha": "b66c1c4696fcf917ca597f339a524de15d5f5913", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -82,7 +82,7 @@ pub unsafe fn buf_len<T>(buf: **T) -> uint {\n \n /// Return the first offset `i` such that `f(buf[i]) == true`.\n #[inline(always)]\n-pub unsafe fn position<T>(buf: *T, f: fn(&T) -> bool) -> uint {\n+pub unsafe fn position<T>(buf: *T, f: &fn(&T) -> bool) -> uint {\n     let mut i = 0;\n     loop {\n         if f(&(*offset(buf, i))) { return i; }"}, {"sha": "30c46cd3e35d12c317c3f24b5d738c6dd61de0cf", "filename": "src/libcore/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -26,7 +26,7 @@ use vec;\n  * then build a MovePtrAdaptor wrapped around your struct.\n  */\n pub trait MovePtr {\n-    fn move_ptr(&self, adjustment: fn(*c_void) -> *c_void);\n+    fn move_ptr(&self, adjustment: &fn(*c_void) -> *c_void);\n     fn push_ptr(&self);\n     fn pop_ptr(&self);\n }"}, {"sha": "ad85c5e5ceff4b6f0587c41f8f4a9cc568174e12", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -159,7 +159,7 @@ pub fn ReprVisitor(ptr: *c_void, writer: @Writer) -> ReprVisitor {\n \n impl MovePtr for ReprVisitor {\n     #[inline(always)]\n-    fn move_ptr(&self, adjustment: fn(*c_void) -> *c_void) {\n+    fn move_ptr(&self, adjustment: &fn(*c_void) -> *c_void) {\n         self.ptr = adjustment(self.ptr);\n     }\n     fn push_ptr(&self) {\n@@ -175,7 +175,7 @@ pub impl ReprVisitor {\n     // Various helpers for the TyVisitor impl\n \n     #[inline(always)]\n-    fn get<T>(&self, f: fn(&T)) -> bool {\n+    fn get<T>(&self, f: &fn(&T)) -> bool {\n         unsafe {\n             f(transmute::<*c_void,&T>(copy self.ptr));\n         }"}, {"sha": "e3fd279a996099d3e390093bfe47e62806d7ec15", "filename": "src/libcore/result.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -122,7 +122,7 @@ pub pure fn to_either<T:Copy,U:Copy>(res: &Result<U, T>)\n  *     }\n  */\n #[inline(always)]\n-pub pure fn chain<T, U, V>(res: Result<T, V>, op: fn(T)\n+pub pure fn chain<T, U, V>(res: Result<T, V>, op: &fn(T)\n     -> Result<U, V>) -> Result<U, V> {\n     match res {\n         Ok(t) => op(t),\n@@ -141,7 +141,7 @@ pub pure fn chain<T, U, V>(res: Result<T, V>, op: fn(T)\n #[inline(always)]\n pub pure fn chain_err<T, U, V>(\n     res: Result<T, V>,\n-    op: fn(t: V) -> Result<T, U>)\n+    op: &fn(t: V) -> Result<T, U>)\n     -> Result<T, U> {\n     match res {\n       Ok(t) => Ok(t),\n@@ -164,7 +164,7 @@ pub pure fn chain_err<T, U, V>(\n  *     }\n  */\n #[inline(always)]\n-pub pure fn iter<T, E>(res: &Result<T, E>, f: fn(&T)) {\n+pub pure fn iter<T, E>(res: &Result<T, E>, f: &fn(&T)) {\n     match *res {\n       Ok(ref t) => f(t),\n       Err(_) => ()\n@@ -180,7 +180,7 @@ pub pure fn iter<T, E>(res: &Result<T, E>, f: fn(&T)) {\n  * handling an error.\n  */\n #[inline(always)]\n-pub pure fn iter_err<T, E>(res: &Result<T, E>, f: fn(&E)) {\n+pub pure fn iter_err<T, E>(res: &Result<T, E>, f: &fn(&E)) {\n     match *res {\n       Ok(_) => (),\n       Err(ref e) => f(e)\n@@ -202,7 +202,7 @@ pub pure fn iter_err<T, E>(res: &Result<T, E>, f: fn(&E)) {\n  *     }\n  */\n #[inline(always)]\n-pub pure fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: fn(&T) -> U)\n+pub pure fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: &fn(&T) -> U)\n   -> Result<U, E> {\n     match *res {\n       Ok(ref t) => Ok(op(t)),\n@@ -219,7 +219,7 @@ pub pure fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: fn(&T) -> U)\n  * successful result while handling an error.\n  */\n #[inline(always)]\n-pub pure fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: fn(&E) -> F)\n+pub pure fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: &fn(&E) -> F)\n   -> Result<T, F> {\n     match *res {\n       Ok(copy t) => Ok(t),\n@@ -238,10 +238,10 @@ pub impl<T, E> Result<T, E> {\n     pure fn is_err(&self) -> bool { is_err(self) }\n \n     #[inline(always)]\n-    pure fn iter(&self, f: fn(&T)) { iter(self, f) }\n+    pure fn iter(&self, f: &fn(&T)) { iter(self, f) }\n \n     #[inline(always)]\n-    pure fn iter_err(&self, f: fn(&E)) { iter_err(self, f) }\n+    pure fn iter_err(&self, f: &fn(&E)) { iter_err(self, f) }\n \n     #[inline(always)]\n     pure fn unwrap(self) -> T { unwrap(self) }\n@@ -250,12 +250,12 @@ pub impl<T, E> Result<T, E> {\n     pure fn unwrap_err(self) -> E { unwrap_err(self) }\n \n     #[inline(always)]\n-    pure fn chain<U>(self, op: fn(T) -> Result<U,E>) -> Result<U,E> {\n+    pure fn chain<U>(self, op: &fn(T) -> Result<U,E>) -> Result<U,E> {\n         chain(self, op)\n     }\n \n     #[inline(always)]\n-    pure fn chain_err<F>(self, op: fn(E) -> Result<T,F>) -> Result<T,F> {\n+    pure fn chain_err<F>(self, op: &fn(E) -> Result<T,F>) -> Result<T,F> {\n         chain_err(self, op)\n     }\n }\n@@ -265,7 +265,7 @@ pub impl<T:Copy,E> Result<T, E> {\n     pure fn get(&self) -> T { get(self) }\n \n     #[inline(always)]\n-    pure fn map_err<F:Copy>(&self, op: fn(&E) -> F) -> Result<T,F> {\n+    pure fn map_err<F:Copy>(&self, op: &fn(&E) -> F) -> Result<T,F> {\n         map_err(self, op)\n     }\n }\n@@ -275,7 +275,7 @@ pub impl<T, E: Copy> Result<T, E> {\n     pure fn get_err(&self) -> E { get_err(self) }\n \n     #[inline(always)]\n-    pure fn map<U:Copy>(&self, op: fn(&T) -> U) -> Result<U,E> {\n+    pure fn map<U:Copy>(&self, op: &fn(&T) -> U) -> Result<U,E> {\n         map(self, op)\n     }\n }\n@@ -299,7 +299,7 @@ pub impl<T, E: Copy> Result<T, E> {\n  */\n #[inline(always)]\n pub fn map_vec<T,U:Copy,V:Copy>(\n-    ts: &[T], op: fn(&T) -> Result<V,U>) -> Result<~[V],U> {\n+    ts: &[T], op: &fn(&T) -> Result<V,U>) -> Result<~[V],U> {\n \n     let mut vs: ~[V] = vec::with_capacity(vec::len(ts));\n     for vec::each(ts) |t| {\n@@ -313,7 +313,7 @@ pub fn map_vec<T,U:Copy,V:Copy>(\n \n #[inline(always)]\n pub fn map_opt<T,U:Copy,V:Copy>(\n-    o_t: &Option<T>, op: fn(&T) -> Result<V,U>) -> Result<Option<V>,U> {\n+    o_t: &Option<T>, op: &fn(&T) -> Result<V,U>) -> Result<Option<V>,U> {\n \n     match *o_t {\n       None => Ok(None),\n@@ -335,7 +335,7 @@ pub fn map_opt<T,U:Copy,V:Copy>(\n  */\n #[inline(always)]\n pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n-                op: fn(&S,&T) -> Result<V,U>) -> Result<~[V],U> {\n+                op: &fn(&S,&T) -> Result<V,U>) -> Result<~[V],U> {\n \n     fail_unless!(vec::same_length(ss, ts));\n     let n = vec::len(ts);\n@@ -358,7 +358,7 @@ pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n  */\n #[inline(always)]\n pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n-                         op: fn(&S,&T) -> Result<(),U>) -> Result<(),U> {\n+                         op: &fn(&S,&T) -> Result<(),U>) -> Result<(),U> {\n \n     fail_unless!(vec::same_length(ss, ts));\n     let n = vec::len(ts);"}, {"sha": "a9d96d891c9442be91bd7ae52d44feb7c571f0f0", "filename": "src/libcore/run.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -102,7 +102,7 @@ pub fn spawn_process(prog: &str, args: &[~str],\n }\n \n fn with_argv<T>(prog: &str, args: &[~str],\n-                cb: fn(**libc::c_char) -> T) -> T {\n+                cb: &fn(**libc::c_char) -> T) -> T {\n     let mut argptrs = str::as_c_str(prog, |b| ~[b]);\n     let mut tmps = ~[];\n     for vec::each(args) |arg| {\n@@ -116,7 +116,7 @@ fn with_argv<T>(prog: &str, args: &[~str],\n \n #[cfg(unix)]\n fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n-                cb: fn(*c_void) -> T) -> T {\n+                cb: &fn(*c_void) -> T) -> T {\n     // On posixy systems we can pass a char** for envp, which is\n     // a null-terminated array of \"k=v\\n\" strings.\n     match *env {\n@@ -141,7 +141,7 @@ fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n \n #[cfg(windows)]\n fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n-                cb: fn(*c_void) -> T) -> T {\n+                cb: &fn(*c_void) -> T) -> T {\n     // On win32 we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate.\n@@ -165,7 +165,7 @@ fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n }\n \n fn with_dirp<T>(d: &Option<~str>,\n-                cb: fn(*libc::c_char) -> T) -> T {\n+                cb: &fn(*libc::c_char) -> T) -> T {\n     match *d {\n       Some(ref dir) => str::as_c_str(*dir, cb),\n       None => cb(ptr::null())"}, {"sha": "955e486649b99a3578b44107706f6dcd07c769b4", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -24,7 +24,7 @@ pub fn Frame(fp: *Word) -> Frame {\n     }\n }\n \n-pub fn walk_stack(visit: fn(Frame) -> bool) {\n+pub fn walk_stack(visit: &fn(Frame) -> bool) {\n \n     debug!(\"beginning stack walk\");\n \n@@ -80,7 +80,7 @@ fn breakpoint() {\n     }\n }\n \n-fn frame_address(f: fn(++x: *u8)) {\n+fn frame_address(f: &fn(++x: *u8)) {\n     unsafe {\n         rusti::frame_address(f)\n     }"}, {"sha": "ae778cb7649b7844bff122836f845ea18cb1db5d", "filename": "src/libcore/str.rs", "status": "modified", "additions": 54, "deletions": 48, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -382,7 +382,7 @@ pub pure fn to_bytes(s: &str) -> ~[u8] {\n \n /// Work with the string as a byte slice, not including trailing null.\n #[inline(always)]\n-pub pure fn byte_slice<T>(s: &str, f: fn(v: &[u8]) -> T) -> T {\n+pub pure fn byte_slice<T>(s: &str, f: &fn(v: &[u8]) -> T) -> T {\n     do as_buf(s) |p,n| {\n         unsafe { vec::raw::buf_as_slice(p, n-1u, f) }\n     }\n@@ -483,24 +483,27 @@ pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool)\n \n \n /// Splits a string into substrings using a character function\n-pub pure fn split(s: &str, sepfn: fn(char) -> bool) -> ~[~str] {\n+pub pure fn split(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n     split_inner(s, sepfn, len(s), true)\n }\n \n /**\n  * Splits a string into substrings using a character function, cutting at\n  * most `count` times.\n  */\n-pub pure fn splitn(s: &str, sepfn: fn(char) -> bool, count: uint) -> ~[~str] {\n+pub pure fn splitn(s: &str,\n+                   sepfn: &fn(char) -> bool,\n+                   count: uint)\n+                -> ~[~str] {\n     split_inner(s, sepfn, count, true)\n }\n \n /// Like `split`, but omits empty strings from the returned vector\n-pub pure fn split_nonempty(s: &str, sepfn: fn(char) -> bool) -> ~[~str] {\n+pub pure fn split_nonempty(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n     split_inner(s, sepfn, len(s), false)\n }\n \n-pure fn split_inner(s: &str, sepfn: fn(cc: char) -> bool, count: uint,\n+pure fn split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n                allow_empty: bool) -> ~[~str] {\n     let l = len(s);\n     let mut result = ~[], i = 0u, start = 0u, done = 0u;\n@@ -526,7 +529,7 @@ pure fn split_inner(s: &str, sepfn: fn(cc: char) -> bool, count: uint,\n }\n \n // See Issue #1932 for why this is a naive search\n-pure fn iter_matches(s: &a/str, sep: &b/str, f: fn(uint, uint)) {\n+pure fn iter_matches(s: &a/str, sep: &b/str, f: &fn(uint, uint)) {\n     let sep_len = len(sep), l = len(s);\n     fail_unless!(sep_len > 0u);\n     let mut i = 0u, match_start = 0u, match_i = 0u;\n@@ -553,7 +556,7 @@ pure fn iter_matches(s: &a/str, sep: &b/str, f: fn(uint, uint)) {\n     }\n }\n \n-pure fn iter_between_matches(s: &a/str, sep: &b/str, f: fn(uint, uint)) {\n+pure fn iter_between_matches(s: &a/str, sep: &b/str, f: &fn(uint, uint)) {\n     let mut last_end = 0u;\n     do iter_matches(s, sep) |from, to| {\n         f(last_end, from);\n@@ -912,20 +915,20 @@ Section: Iterating through strings\n  * Return true if a predicate matches all characters or if the string\n  * contains no characters\n  */\n-pub pure fn all(s: &str, it: fn(char) -> bool) -> bool {\n+pub pure fn all(s: &str, it: &fn(char) -> bool) -> bool {\n     all_between(s, 0u, len(s), it)\n }\n \n /**\n  * Return true if a predicate matches any character (and false if it\n  * matches none or there are no characters)\n  */\n-pub pure fn any(ss: &str, pred: fn(char) -> bool) -> bool {\n+pub pure fn any(ss: &str, pred: &fn(char) -> bool) -> bool {\n     !all(ss, |cc| !pred(cc))\n }\n \n /// Apply a function to each character\n-pub pure fn map(ss: &str, ff: fn(char) -> char) -> ~str {\n+pub pure fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n     let mut result = ~\"\";\n     unsafe {\n         reserve(&mut result, len(ss));\n@@ -937,7 +940,7 @@ pub pure fn map(ss: &str, ff: fn(char) -> char) -> ~str {\n }\n \n /// Iterate over the bytes in a string\n-pub pure fn bytes_each(ss: &str, it: fn(u8) -> bool) {\n+pub pure fn bytes_each(ss: &str, it: &fn(u8) -> bool) {\n     let mut pos = 0u;\n     let len = len(ss);\n \n@@ -949,13 +952,13 @@ pub pure fn bytes_each(ss: &str, it: fn(u8) -> bool) {\n \n /// Iterate over the bytes in a string\n #[inline(always)]\n-pub pure fn each(s: &str, it: fn(u8) -> bool) {\n+pub pure fn each(s: &str, it: &fn(u8) -> bool) {\n     eachi(s, |_i, b| it(b) )\n }\n \n /// Iterate over the bytes in a string, with indices\n #[inline(always)]\n-pub pure fn eachi(s: &str, it: fn(uint, u8) -> bool) {\n+pub pure fn eachi(s: &str, it: &fn(uint, u8) -> bool) {\n     let mut i = 0u, l = len(s);\n     while (i < l) {\n         if !it(i, s[i]) { break; }\n@@ -965,13 +968,13 @@ pub pure fn eachi(s: &str, it: fn(uint, u8) -> bool) {\n \n /// Iterates over the chars in a string\n #[inline(always)]\n-pub pure fn each_char(s: &str, it: fn(char) -> bool) {\n+pub pure fn each_char(s: &str, it: &fn(char) -> bool) {\n     each_chari(s, |_i, c| it(c))\n }\n \n /// Iterates over the chars in a string, with indices\n #[inline(always)]\n-pub pure fn each_chari(s: &str, it: fn(uint, char) -> bool) {\n+pub pure fn each_chari(s: &str, it: &fn(uint, char) -> bool) {\n     let mut pos = 0u, ch_pos = 0u;\n     let len = len(s);\n     while pos < len {\n@@ -983,7 +986,7 @@ pub pure fn each_chari(s: &str, it: fn(uint, char) -> bool) {\n }\n \n /// Iterate over the characters in a string\n-pub pure fn chars_each(s: &str, it: fn(char) -> bool) {\n+pub pure fn chars_each(s: &str, it: &fn(char) -> bool) {\n     let mut pos = 0u;\n     let len = len(s);\n     while (pos < len) {\n@@ -994,7 +997,7 @@ pub pure fn chars_each(s: &str, it: fn(char) -> bool) {\n }\n \n /// Apply a function to each substring after splitting by character\n-pub pure fn split_char_each(ss: &str, cc: char, ff: fn(v: &str) -> bool) {\n+pub pure fn split_char_each(ss: &str, cc: char, ff: &fn(v: &str) -> bool) {\n     vec::each(split_char(ss, cc), |s| ff(*s))\n }\n \n@@ -1003,19 +1006,19 @@ pub pure fn split_char_each(ss: &str, cc: char, ff: fn(v: &str) -> bool) {\n  * `count` times\n  */\n pub pure fn splitn_char_each(ss: &str, sep: char, count: uint,\n-                         ff: fn(v: &str) -> bool) {\n+                         ff: &fn(v: &str) -> bool) {\n     vec::each(splitn_char(ss, sep, count), |s| ff(*s))\n }\n \n /// Apply a function to each word\n-pub pure fn words_each(ss: &str, ff: fn(v: &str) -> bool) {\n+pub pure fn words_each(ss: &str, ff: &fn(v: &str) -> bool) {\n     vec::each(words(ss), |s| ff(*s))\n }\n \n /**\n  * Apply a function to each line (by '\\n')\n  */\n-pub pure fn lines_each(ss: &str, ff: fn(v: &str) -> bool) {\n+pub pure fn lines_each(ss: &str, ff: &fn(v: &str) -> bool) {\n     vec::each(lines(ss), |s| ff(*s))\n }\n \n@@ -1195,7 +1198,7 @@ pub pure fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n  * An `option` containing the byte index of the first matching character\n  * or `none` if there is no match\n  */\n-pub pure fn find(s: &str, f: fn(char) -> bool) -> Option<uint> {\n+pub pure fn find(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n     find_between(s, 0u, len(s), f)\n }\n \n@@ -1219,7 +1222,7 @@ pub pure fn find(s: &str, f: fn(char) -> bool) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)`. `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`.\n  */\n-pub pure fn find_from(s: &str, start: uint, f: fn(char)\n+pub pure fn find_from(s: &str, start: uint, f: &fn(char)\n     -> bool) -> Option<uint> {\n     find_between(s, start, len(s), f)\n }\n@@ -1246,8 +1249,11 @@ pub pure fn find_from(s: &str, start: uint, f: fn(char)\n  * or equal to `len(s)`. `start` must be the index of a character\n  * boundary, as defined by `is_char_boundary`.\n  */\n-pub pure fn find_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n-    -> Option<uint> {\n+pub pure fn find_between(s: &str,\n+                         start: uint,\n+                         end: uint,\n+                         f: &fn(char) -> bool)\n+                      -> Option<uint> {\n     fail_unless!(start <= end);\n     fail_unless!(end <= len(s));\n     fail_unless!(is_char_boundary(s, start));\n@@ -1274,7 +1280,7 @@ pub pure fn find_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n  * An option containing the byte index of the last matching character\n  * or `none` if there is no match\n  */\n-pub pure fn rfind(s: &str, f: fn(char) -> bool) -> Option<uint> {\n+pub pure fn rfind(s: &str, f: &fn(char) -> bool) -> Option<uint> {\n     rfind_between(s, len(s), 0u, f)\n }\n \n@@ -1298,7 +1304,7 @@ pub pure fn rfind(s: &str, f: fn(char) -> bool) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)', `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`\n  */\n-pub pure fn rfind_from(s: &str, start: uint, f: fn(char) -> bool)\n+pub pure fn rfind_from(s: &str, start: uint, f: &fn(char) -> bool)\n     -> Option<uint> {\n     rfind_between(s, start, 0u, f)\n }\n@@ -1326,7 +1332,7 @@ pub pure fn rfind_from(s: &str, start: uint, f: fn(char) -> bool)\n  * boundary, as defined by `is_char_boundary`\n  */\n pub pure fn rfind_between(s: &str, start: uint, end: uint,\n-                          f: fn(char) -> bool)\n+                          f: &fn(char) -> bool)\n     -> Option<uint> {\n     fail_unless!(start >= end);\n     fail_unless!(start <= len(s));\n@@ -1589,7 +1595,7 @@ pub pure fn to_utf16(s: &str) -> ~[u16] {\n     u\n }\n \n-pub pure fn utf16_chars(v: &[u16], f: fn(char)) {\n+pub pure fn utf16_chars(v: &[u16], f: &fn(char)) {\n     let len = vec::len(v);\n     let mut i = 0u;\n     while (i < len && v[i] != 0u16) {\n@@ -1815,7 +1821,7 @@ pure fn char_range_at_reverse(ss: &str, start: uint) -> CharRange {\n  * that is if `it` returned `false` at any point.\n  */\n pub pure fn all_between(s: &str, start: uint, end: uint,\n-                    it: fn(char) -> bool) -> bool {\n+                    it: &fn(char) -> bool) -> bool {\n     fail_unless!(is_char_boundary(s, start));\n     let mut i = start;\n     while i < end {\n@@ -1848,7 +1854,7 @@ pub pure fn all_between(s: &str, start: uint, end: uint,\n  * `true` if `it` returns `true` for any character\n  */\n pub pure fn any_between(s: &str, start: uint, end: uint,\n-                    it: fn(char) -> bool) -> bool {\n+                    it: &fn(char) -> bool) -> bool {\n     !all_between(s, start, end, |c| !it(c))\n }\n \n@@ -1886,7 +1892,7 @@ pub const nan_buf: [u8*3] = ['N' as u8, 'a' as u8, 'N' as u8];\n  * let i = str::as_bytes(\"Hello World\") { |bytes| vec::len(bytes) };\n  * ~~~\n  */\n-pub pure fn as_bytes<T>(s: &const ~str, f: fn(&~[u8]) -> T) -> T {\n+pub pure fn as_bytes<T>(s: &const ~str, f: &fn(&~[u8]) -> T) -> T {\n     unsafe {\n         let v: *~[u8] = cast::transmute(copy s);\n         f(&*v)\n@@ -1921,7 +1927,7 @@ pub pure fn as_bytes_slice(s: &a/str) -> &a/[u8] {\n  * let s = str::as_c_str(\"PATH\", { |path| libc::getenv(path) });\n  * ~~~\n  */\n-pub pure fn as_c_str<T>(s: &str, f: fn(*libc::c_char) -> T) -> T {\n+pub pure fn as_c_str<T>(s: &str, f: &fn(*libc::c_char) -> T) -> T {\n     do as_buf(s) |buf, len| {\n         // NB: len includes the trailing null.\n         fail_unless!(len > 0);\n@@ -1943,7 +1949,7 @@ pub pure fn as_c_str<T>(s: &str, f: fn(*libc::c_char) -> T) -> T {\n  * to full strings, or suffixes of them.\n  */\n #[inline(always)]\n-pub pure fn as_buf<T>(s: &str, f: fn(*u8, uint) -> T) -> T {\n+pub pure fn as_buf<T>(s: &str, f: &fn(*u8, uint) -> T) -> T {\n     unsafe {\n         let v : *(*u8,uint) = ::cast::reinterpret_cast(&ptr::addr_of(&s));\n         let (buf,len) = *v;\n@@ -2088,7 +2094,7 @@ pub mod raw {\n \n     /// Form a slice from a *u8 buffer of the given length without copying.\n     pub unsafe fn buf_as_slice<T>(buf: *u8, len: uint,\n-                              f: fn(v: &str) -> T) -> T {\n+                              f: &fn(v: &str) -> T) -> T {\n         let v = (buf, len + 1);\n         fail_unless!(is_utf8(::cast::reinterpret_cast(&v)));\n         f(::cast::transmute(v))\n@@ -2238,21 +2244,21 @@ pub mod traits {\n pub mod traits {}\n \n pub trait StrSlice {\n-    pure fn all(&self, it: fn(char) -> bool) -> bool;\n-    pure fn any(&self, it: fn(char) -> bool) -> bool;\n+    pure fn all(&self, it: &fn(char) -> bool) -> bool;\n+    pure fn any(&self, it: &fn(char) -> bool) -> bool;\n     pure fn contains(&self, needle: &a/str) -> bool;\n     pure fn contains_char(&self, needle: char) -> bool;\n-    pure fn each(&self, it: fn(u8) -> bool);\n-    pure fn eachi(&self, it: fn(uint, u8) -> bool);\n-    pure fn each_char(&self, it: fn(char) -> bool);\n-    pure fn each_chari(&self, it: fn(uint, char) -> bool);\n+    pure fn each(&self, it: &fn(u8) -> bool);\n+    pure fn eachi(&self, it: &fn(uint, u8) -> bool);\n+    pure fn each_char(&self, it: &fn(char) -> bool);\n+    pure fn each_chari(&self, it: &fn(uint, char) -> bool);\n     pure fn ends_with(&self, needle: &str) -> bool;\n     pure fn is_empty(&self) -> bool;\n     pure fn is_whitespace(&self) -> bool;\n     pure fn is_alphanumeric(&self) -> bool;\n     pure fn len(&self) -> uint;\n     pure fn slice(&self, begin: uint, end: uint) -> ~str;\n-    pure fn split(&self, sepfn: fn(char) -> bool) -> ~[~str];\n+    pure fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str];\n     pure fn split_char(&self, sep: char) -> ~[~str];\n     pure fn split_str(&self, sep: &a/str) -> ~[~str];\n     pure fn starts_with(&self, needle: &a/str) -> bool;\n@@ -2276,13 +2282,13 @@ impl StrSlice for &self/str {\n      * contains no characters\n      */\n     #[inline]\n-    pure fn all(&self, it: fn(char) -> bool) -> bool { all(*self, it) }\n+    pure fn all(&self, it: &fn(char) -> bool) -> bool { all(*self, it) }\n     /**\n      * Return true if a predicate matches any character (and false if it\n      * matches none or there are no characters)\n      */\n     #[inline]\n-    pure fn any(&self, it: fn(char) -> bool) -> bool { any(*self, it) }\n+    pure fn any(&self, it: &fn(char) -> bool) -> bool { any(*self, it) }\n     /// Returns true if one string contains another\n     #[inline]\n     pure fn contains(&self, needle: &a/str) -> bool {\n@@ -2295,16 +2301,16 @@ impl StrSlice for &self/str {\n     }\n     /// Iterate over the bytes in a string\n     #[inline]\n-    pure fn each(&self, it: fn(u8) -> bool) { each(*self, it) }\n+    pure fn each(&self, it: &fn(u8) -> bool) { each(*self, it) }\n     /// Iterate over the bytes in a string, with indices\n     #[inline]\n-    pure fn eachi(&self, it: fn(uint, u8) -> bool) { eachi(*self, it) }\n+    pure fn eachi(&self, it: &fn(uint, u8) -> bool) { eachi(*self, it) }\n     /// Iterate over the chars in a string\n     #[inline]\n-    pure fn each_char(&self, it: fn(char) -> bool) { each_char(*self, it) }\n+    pure fn each_char(&self, it: &fn(char) -> bool) { each_char(*self, it) }\n     /// Iterate over the chars in a string, with indices\n     #[inline]\n-    pure fn each_chari(&self, it: fn(uint, char) -> bool) {\n+    pure fn each_chari(&self, it: &fn(uint, char) -> bool) {\n         each_chari(*self, it)\n     }\n     /// Returns true if one string ends with another\n@@ -2345,7 +2351,7 @@ impl StrSlice for &self/str {\n     }\n     /// Splits a string into substrings using a character function\n     #[inline]\n-    pure fn split(&self, sepfn: fn(char) -> bool) -> ~[~str] {\n+    pure fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str] {\n         split(*self, sepfn)\n     }\n     /**"}, {"sha": "179a33ae43ea36d72ef31580270fd6dd64bd0bdd", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -227,7 +227,7 @@ pub mod tests {\n     pub fn synthesize_closure() {\n         unsafe {\n             let x = 10;\n-            let f: fn(int) -> int = |y| x + y;\n+            let f: &fn(int) -> int = |y| x + y;\n \n             fail_unless!(f(20) == 30);\n \n@@ -241,7 +241,7 @@ pub mod tests {\n                 env: environment\n             };\n \n-            let new_f: fn(int) -> int = cast::transmute(new_closure);\n+            let new_f: &fn(int) -> int = cast::transmute(new_closure);\n             fail_unless!(new_f(20) == 30);\n         }\n     }"}, {"sha": "690b3aedc5a4968646e0912bd9e98754158b21a9", "filename": "src/libcore/task/local_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Ftask%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Ftask%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -79,7 +79,7 @@ pub unsafe fn local_data_set<T:Durable>(\n  */\n pub unsafe fn local_data_modify<T:Durable>(\n     key: LocalDataKey<T>,\n-    modify_fn: fn(Option<@T>) -> Option<@T>) {\n+    modify_fn: &fn(Option<@T>) -> Option<@T>) {\n \n     local_modify(rt::rust_get_task(), key, modify_fn)\n }"}, {"sha": "bb05520e1a363a44328104514430023fd153319f", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -176,7 +176,7 @@ pub unsafe fn local_set<T:Durable>(\n \n pub unsafe fn local_modify<T:Durable>(\n     task: *rust_task, key: LocalDataKey<T>,\n-    modify_fn: fn(Option<@T>) -> Option<@T>) {\n+    modify_fn: &fn(Option<@T>) -> Option<@T>) {\n \n     // Could be more efficient by doing the lookup work, but this is easy.\n     let newdata = modify_fn(local_pop(task, key));"}, {"sha": "31c44531efec0727a84cfc1f15c3758f5d757e59", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -295,7 +295,7 @@ pub impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    fn future_result(&self, blk: fn(v: Port<TaskResult>)) -> TaskBuilder {\n+    fn future_result(&self, blk: &fn(v: Port<TaskResult>)) -> TaskBuilder {\n         // FIXME (#3725): Once linked failure and notification are\n         // handled in the library, I can imagine implementing this by just\n         // registering an arbitrary number of task::on_exit handlers and\n@@ -572,7 +572,7 @@ pub fn get_scheduler() -> Scheduler {\n  * }\n  * ~~~\n  */\n-pub unsafe fn unkillable<U>(f: fn() -> U) -> U {\n+pub unsafe fn unkillable<U>(f: &fn() -> U) -> U {\n     struct AllowFailure {\n         t: *rust_task,\n         drop {\n@@ -597,7 +597,7 @@ pub unsafe fn unkillable<U>(f: fn() -> U) -> U {\n }\n \n /// The inverse of unkillable. Only ever to be used nested in unkillable().\n-pub unsafe fn rekillable<U>(f: fn() -> U) -> U {\n+pub unsafe fn rekillable<U>(f: &fn() -> U) -> U {\n     struct DisallowFailure {\n         t: *rust_task,\n         drop {\n@@ -625,7 +625,7 @@ pub unsafe fn rekillable<U>(f: fn() -> U) -> U {\n  * A stronger version of unkillable that also inhibits scheduling operations.\n  * For use with exclusive ARCs, which use pthread mutexes directly.\n  */\n-pub unsafe fn atomically<U>(f: fn() -> U) -> U {\n+pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n     struct DeferInterrupts {\n         t: *rust_task,\n         drop {"}, {"sha": "a0db2525441566e2ca6981bd346e703571230dda", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -108,7 +108,7 @@ fn taskset_remove(tasks: &mut TaskSet, task: *rust_task) {\n     let was_present = tasks.remove(&task);\n     fail_unless!(was_present);\n }\n-pub fn taskset_each(tasks: &TaskSet, blk: fn(v: *rust_task) -> bool) {\n+pub fn taskset_each(tasks: &TaskSet, blk: &fn(v: *rust_task) -> bool) {\n     tasks.each(|k| blk(*k))\n }\n \n@@ -151,17 +151,17 @@ struct AncestorNode {\n     mut ancestors:    AncestorList,\n }\n \n-enum AncestorList = Option<unstable::Exclusive<AncestorNode>>;\n+struct AncestorList(Option<unstable::Exclusive<AncestorNode>>);\n \n // Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n #[inline(always)]\n-fn access_group<U>(x: &TaskGroupArc, blk: fn(TaskGroupInner) -> U) -> U {\n+fn access_group<U>(x: &TaskGroupArc, blk: &fn(TaskGroupInner) -> U) -> U {\n     unsafe { x.with(blk) }\n }\n \n #[inline(always)]\n fn access_ancestors<U>(x: &unstable::Exclusive<AncestorNode>,\n-                       blk: fn(x: &mut AncestorNode) -> U) -> U {\n+                       blk: &fn(x: &mut AncestorNode) -> U) -> U {\n     unsafe { x.with(blk) }\n }\n \n@@ -175,7 +175,7 @@ fn access_ancestors<U>(x: &unstable::Exclusive<AncestorNode>,\n // allocations. Once that bug is fixed, changing the sigil should suffice.\n fn each_ancestor(list:        &mut AncestorList,\n                  bail_opt:    Option<@fn(TaskGroupInner)>,\n-                 forward_blk: fn(TaskGroupInner) -> bool)\n+                 forward_blk: &fn(TaskGroupInner) -> bool)\n               -> bool {\n     // \"Kickoff\" call - there was no last generation.\n     return !coalesce(list, bail_opt, forward_blk, uint::max_value);\n@@ -184,7 +184,7 @@ fn each_ancestor(list:        &mut AncestorList,\n     // whether or not unwinding is needed (i.e., !successful iteration).\n     fn coalesce(list:            &mut AncestorList,\n                 bail_opt:        Option<@fn(TaskGroupInner)>,\n-                forward_blk:     fn(TaskGroupInner) -> bool,\n+                forward_blk:     &fn(TaskGroupInner) -> bool,\n                 last_generation: uint) -> bool {\n         // Need to swap the list out to use it, to appease borrowck.\n         let tmp_list = util::replace(&mut *list, AncestorList(None));\n@@ -288,7 +288,7 @@ fn each_ancestor(list:        &mut AncestorList,\n \n         // Wrapper around exclusive::with that appeases borrowck.\n         fn with_parent_tg<U>(parent_group: &mut Option<TaskGroupArc>,\n-                             blk: fn(TaskGroupInner) -> U) -> U {\n+                             blk: &fn(TaskGroupInner) -> U) -> U {\n             // If this trips, more likely the problem is 'blk' failed inside.\n             let tmp_arc = option::swap_unwrap(&mut *parent_group);\n             let result = do access_group(&tmp_arc) |tg_opt| { blk(tg_opt) };"}, {"sha": "7dc85cba297f1d843cae0583a033f88ba1431eb3", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -32,7 +32,7 @@ pub struct TrieMap<T> {\n impl<T> BaseIter<(uint, &'self T)> for TrieMap<T> {\n     /// Visit all key-value pairs in order\n     #[inline(always)]\n-    pure fn each(&self, f: fn(&(uint, &self/T)) -> bool) {\n+    pure fn each(&self, f: &fn(&(uint, &self/T)) -> bool) {\n         self.root.each(f);\n     }\n     #[inline(always)]\n@@ -42,7 +42,7 @@ impl<T> BaseIter<(uint, &'self T)> for TrieMap<T> {\n impl<T> ReverseIter<(uint, &'self T)> for TrieMap<T> {\n     /// Visit all key-value pairs in reverse order\n     #[inline(always)]\n-    pure fn each_reverse(&self, f: fn(&(uint, &self/T)) -> bool) {\n+    pure fn each_reverse(&self, f: &fn(&(uint, &self/T)) -> bool) {\n         self.root.each_reverse(f);\n     }\n }\n@@ -75,13 +75,16 @@ impl<T> Map<uint, T> for TrieMap<T> {\n \n     /// Visit all keys in order\n     #[inline(always)]\n-    pure fn each_key(&self, f: fn(&uint) -> bool) {\n+    pure fn each_key(&self, f: &fn(&uint) -> bool) {\n         self.each(|&(k, _)| f(&k))\n     }\n \n     /// Visit all values in order\n     #[inline(always)]\n-    pure fn each_value(&self, f: fn(&T) -> bool) { self.each(|&(_, v)| f(v)) }\n+    pure fn each_value(&self,\n+                       f: &fn(&T) -> bool) {\n+        self.each(|&(_, v)| f(v))\n+    }\n \n     /// Return the value corresponding to the key in the map\n     #[inline(hint)]\n@@ -138,18 +141,18 @@ impl<T> TrieMap<T> {\n impl<T> TrieMap<T> {\n     /// Visit all keys in reverse order\n     #[inline(always)]\n-    pure fn each_key_reverse(&self, f: fn(&uint) -> bool) {\n+    pure fn each_key_reverse(&self, f: &fn(&uint) -> bool) {\n         self.each_reverse(|&(k, _)| f(&k))\n     }\n \n     /// Visit all values in reverse order\n     #[inline(always)]\n-    pure fn each_value_reverse(&self, f: fn(&T) -> bool) {\n+    pure fn each_value_reverse(&self, f: &fn(&T) -> bool) {\n         self.each_reverse(|&(_, v)| f(v))\n     }\n \n     /// Iterate over the map and mutate the contained values\n-    fn mutate_values(&mut self, f: fn(uint, &mut T) -> bool) {\n+    fn mutate_values(&mut self, f: &fn(uint, &mut T) -> bool) {\n         self.root.mutate_values(f);\n     }\n }\n@@ -160,13 +163,13 @@ pub struct TrieSet {\n \n impl BaseIter<uint> for TrieSet {\n     /// Visit all values in order\n-    pure fn each(&self, f: fn(&uint) -> bool) { self.map.each_key(f) }\n+    pure fn each(&self, f: &fn(&uint) -> bool) { self.map.each_key(f) }\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl ReverseIter<uint> for TrieSet {\n     /// Visit all values in reverse order\n-    pure fn each_reverse(&self, f: fn(&uint) -> bool) {\n+    pure fn each_reverse(&self, f: &fn(&uint) -> bool) {\n         self.map.each_key_reverse(f)\n     }\n }\n@@ -223,7 +226,7 @@ impl<T> TrieNode<T> {\n }\n \n impl<T> TrieNode<T> {\n-    pure fn each(&self, f: fn(&(uint, &self/T)) -> bool) -> bool {\n+    pure fn each(&self, f: &fn(&(uint, &self/T)) -> bool) -> bool {\n         for uint::range(0, self.children.len()) |idx| {\n             match self.children[idx] {\n                 Internal(ref x) => if !x.each(f) { return false },\n@@ -234,7 +237,7 @@ impl<T> TrieNode<T> {\n         true\n     }\n \n-    pure fn each_reverse(&self, f: fn(&(uint, &self/T)) -> bool) -> bool {\n+    pure fn each_reverse(&self, f: &fn(&(uint, &self/T)) -> bool) -> bool {\n         for uint::range_rev(self.children.len(), 0) |idx| {\n             match self.children[idx - 1] {\n                 Internal(ref x) => if !x.each_reverse(f) { return false },\n@@ -245,7 +248,7 @@ impl<T> TrieNode<T> {\n         true\n     }\n \n-    fn mutate_values(&mut self, f: fn(uint, &mut T) -> bool) -> bool {\n+    fn mutate_values(&mut self, f: &fn(uint, &mut T) -> bool) -> bool {\n         for vec::each_mut(self.children) |child| {\n             match *child {\n                 Internal(ref mut x) => if !x.mutate_values(f) {"}, {"sha": "4f45535d0f856eb7da02cb22434b873209096c79", "filename": "src/libcore/unstable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -232,7 +232,7 @@ fn LittleLock() -> LittleLock {\n \n pub impl LittleLock {\n     #[inline(always)]\n-    unsafe fn lock<T>(&self, f: fn() -> T) -> T {\n+    unsafe fn lock<T>(&self, f: &fn() -> T) -> T {\n         struct Unlock {\n             l: rust_little_lock,\n             drop {\n@@ -284,7 +284,7 @@ pub impl<T:Owned> Exclusive<T> {\n     // accessing the provided condition variable) are prohibited while inside\n     // the exclusive. Supporting that is a work in progress.\n     #[inline(always)]\n-    unsafe fn with<U>(&self, f: fn(x: &mut T) -> U) -> U {\n+    unsafe fn with<U>(&self, f: &fn(x: &mut T) -> U) -> U {\n         unsafe {\n             let rec = get_shared_mutable_state(&self.x);\n             do (*rec).lock.lock {\n@@ -301,7 +301,7 @@ pub impl<T:Owned> Exclusive<T> {\n     }\n \n     #[inline(always)]\n-    unsafe fn with_imm<U>(&self, f: fn(x: &T) -> U) -> U {\n+    unsafe fn with_imm<U>(&self, f: &fn(x: &T) -> U) -> U {\n         do self.with |x| {\n             f(cast::transmute_immut(x))\n         }"}, {"sha": "aed98f3573e71b249980a4a628214331304dad49", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 114, "deletions": 112, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -175,7 +175,7 @@ pub pure fn with_capacity<T>(capacity: uint) -> ~[T] {\n  */\n #[inline(always)]\n pub pure fn build_sized<A>(size: uint,\n-                       builder: fn(push: pure fn(v: A))) -> ~[A] {\n+                       builder: &fn(push: &pure fn(v: A))) -> ~[A] {\n     let mut vec = with_capacity(size);\n     builder(|x| unsafe { vec.push(x) });\n     vec\n@@ -192,7 +192,7 @@ pub pure fn build_sized<A>(size: uint,\n  *             onto the vector being constructed.\n  */\n #[inline(always)]\n-pub pure fn build<A>(builder: fn(push: pure fn(v: A))) -> ~[A] {\n+pub pure fn build<A>(builder: &fn(push: &pure fn(v: A))) -> ~[A] {\n     build_sized(4, builder)\n }\n \n@@ -210,7 +210,7 @@ pub pure fn build<A>(builder: fn(push: pure fn(v: A))) -> ~[A] {\n  */\n #[inline(always)]\n pub pure fn build_sized_opt<A>(size: Option<uint>,\n-                           builder: fn(push: pure fn(v: A))) -> ~[A] {\n+                           builder: &fn(push: &pure fn(v: A))) -> ~[A] {\n     build_sized(size.get_or_default(4), builder)\n }\n \n@@ -305,7 +305,7 @@ pub pure fn const_slice<T>(v: &r/[const T],\n /// Copies\n \n /// Split the vector `v` by applying each element against the predicate `f`.\n-pub fn split<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n+pub fn split<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -328,7 +328,7 @@ pub fn split<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n  * Split the vector `v` by applying each element against the predicate `f` up\n  * to `n` times.\n  */\n-pub fn splitn<T:Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n+pub fn splitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -354,7 +354,7 @@ pub fn splitn<T:Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n  * Reverse split the vector `v` by applying each element against the predicate\n  * `f`.\n  */\n-pub fn rsplit<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n+pub fn rsplit<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0) { return ~[] }\n \n@@ -378,7 +378,7 @@ pub fn rsplit<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n  * Reverse split the vector `v` by applying each element against the predicate\n  * `f` up to `n times.\n  */\n-pub fn rsplitn<T:Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n+pub fn rsplitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { return ~[] }\n \n@@ -405,7 +405,7 @@ pub fn rsplitn<T:Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n  * Partitions a vector into two new vectors: those that satisfies the\n  * predicate, and those that do not.\n  */\n-pub fn partition<T>(v: ~[T], f: fn(&T) -> bool) -> (~[T], ~[T]) {\n+pub fn partition<T>(v: ~[T], f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n     let mut lefts  = ~[];\n     let mut rights = ~[];\n \n@@ -426,7 +426,7 @@ pub fn partition<T>(v: ~[T], f: fn(&T) -> bool) -> (~[T], ~[T]) {\n  * Partitions a vector into two new vectors: those that satisfies the\n  * predicate, and those that do not.\n  */\n-pub pure fn partitioned<T:Copy>(v: &[T], f: fn(&T) -> bool) -> (~[T], ~[T]) {\n+pub pure fn partitioned<T:Copy>(v: &[T], f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n     let mut lefts  = ~[];\n     let mut rights = ~[];\n \n@@ -535,7 +535,7 @@ pub fn remove<T>(v: &mut ~[T], i: uint) -> T {\n     v.pop()\n }\n \n-pub fn consume<T>(mut v: ~[T], f: fn(uint, v: T)) {\n+pub fn consume<T>(mut v: ~[T], f: &fn(uint, v: T)) {\n     unsafe {\n         do as_mut_buf(v) |p, ln| {\n             for uint::range(0, ln) |i| {\n@@ -780,7 +780,7 @@ pub fn grow_set<T:Copy>(v: &mut ~[T], index: uint, initval: &T, val: T) {\n // Functional utilities\n \n /// Apply a function to each element of a vector and return the results\n-pub pure fn map<T, U>(v: &[T], f: fn(t: &T) -> U) -> ~[U] {\n+pub pure fn map<T, U>(v: &[T], f: &fn(t: &T) -> U) -> ~[U] {\n     let mut result = with_capacity(len(v));\n     for each(v) |elem| {\n         unsafe {\n@@ -790,7 +790,7 @@ pub pure fn map<T, U>(v: &[T], f: fn(t: &T) -> U) -> ~[U] {\n     result\n }\n \n-pub fn map_consume<T, U>(v: ~[T], f: fn(v: T) -> U) -> ~[U] {\n+pub fn map_consume<T, U>(v: ~[T], f: &fn(v: T) -> U) -> ~[U] {\n     let mut result = ~[];\n     do consume(v) |_i, x| {\n         result.push(f(x));\n@@ -799,7 +799,7 @@ pub fn map_consume<T, U>(v: ~[T], f: fn(v: T) -> U) -> ~[U] {\n }\n \n /// Apply a function to each element of a vector and return the results\n-pub pure fn mapi<T, U>(v: &[T], f: fn(uint, t: &T) -> U) -> ~[U] {\n+pub pure fn mapi<T, U>(v: &[T], f: &fn(uint, t: &T) -> U) -> ~[U] {\n     let mut i = 0;\n     do map(v) |e| {\n         i += 1;\n@@ -811,15 +811,15 @@ pub pure fn mapi<T, U>(v: &[T], f: fn(uint, t: &T) -> U) -> ~[U] {\n  * Apply a function to each element of a vector and return a concatenation\n  * of each result vector\n  */\n-pub pure fn flat_map<T, U>(v: &[T], f: fn(t: &T) -> ~[U]) -> ~[U] {\n+pub pure fn flat_map<T, U>(v: &[T], f: &fn(t: &T) -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n     for each(v) |elem| { unsafe{ result.push_all_move(f(elem)); } }\n     result\n }\n \n /// Apply a function to each pair of elements and return the results\n pub pure fn map2<T:Copy,U:Copy,V>(v0: &[T], v1: &[U],\n-                                  f: fn(t: &T, v: &U) -> V) -> ~[V] {\n+                                  f: &fn(t: &T, v: &U) -> V) -> ~[V] {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { fail!(); }\n     let mut u: ~[V] = ~[];\n@@ -833,7 +833,7 @@ pub pure fn map2<T:Copy,U:Copy,V>(v0: &[T], v1: &[U],\n \n pub fn filter_map<T, U>(\n     v: ~[T],\n-    f: fn(t: T) -> Option<U>) -> ~[U]\n+    f: &fn(t: T) -> Option<U>) -> ~[U]\n {\n     /*!\n      *\n@@ -854,7 +854,7 @@ pub fn filter_map<T, U>(\n \n pub pure fn filter_mapped<T, U: Copy>(\n     v: &[T],\n-    f: fn(t: &T) -> Option<U>) -> ~[U]\n+    f: &fn(t: &T) -> Option<U>) -> ~[U]\n {\n     /*!\n      *\n@@ -879,7 +879,7 @@ pub pure fn filter_mapped<T, U: Copy>(\n  * Apply function `f` to each element of `v` and return a vector containing\n  * only those elements for which `f` returned true.\n  */\n-pub fn filter<T>(v: ~[T], f: fn(t: &T) -> bool) -> ~[T] {\n+pub fn filter<T>(v: ~[T], f: &fn(t: &T) -> bool) -> ~[T] {\n     let mut result = ~[];\n     // FIXME (#4355 maybe): using v.consume here crashes\n     // do v.consume |_, elem| {\n@@ -896,7 +896,7 @@ pub fn filter<T>(v: ~[T], f: fn(t: &T) -> bool) -> ~[T] {\n  * Apply function `f` to each element of `v` and return a vector containing\n  * only those elements for which `f` returned true.\n  */\n-pub pure fn filtered<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[T] {\n+pub pure fn filtered<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[T] {\n     let mut result = ~[];\n     for each(v) |elem| {\n         if f(elem) { unsafe { result.push(*elem); } }\n@@ -907,7 +907,7 @@ pub pure fn filtered<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[T] {\n /**\n  * Like `filter()`, but in place.  Preserves order of `v`.  Linear time.\n  */\n-pub fn retain<T>(v: &mut ~[T], f: pure fn(t: &T) -> bool) {\n+pub fn retain<T>(v: &mut ~[T], f: &pure fn(t: &T) -> bool) {\n     let len = v.len();\n     let mut deleted: uint = 0;\n \n@@ -963,7 +963,7 @@ pub pure fn connect<T:Copy>(v: &[~[T]], sep: &T) -> ~[T] {\n  * ~~~\n  *\n  */\n-pub pure fn foldl<T, U>(z: T, v: &[U], p: fn(t: T, u: &U) -> T) -> T {\n+pub pure fn foldl<T, U>(z: T, v: &[U], p: &fn(t: T, u: &U) -> T) -> T {\n     let mut accum = z;\n     let mut i = 0;\n     let l = v.len();\n@@ -995,7 +995,7 @@ pub pure fn foldl<T, U>(z: T, v: &[U], p: fn(t: T, u: &U) -> T) -> T {\n  * ~~~\n  *\n  */\n-pub pure fn foldr<T, U: Copy>(v: &[T], z: U, p: fn(t: &T, u: U) -> U) -> U {\n+pub pure fn foldr<T, U: Copy>(v: &[T], z: U, p: &fn(t: &T, u: U) -> U) -> U {\n     let mut accum = z;\n     for rev_each(v) |elt| {\n         accum = p(elt, accum);\n@@ -1008,7 +1008,7 @@ pub pure fn foldr<T, U: Copy>(v: &[T], z: U, p: fn(t: &T, u: U) -> U) -> U {\n  *\n  * If the vector contains no elements then false is returned.\n  */\n-pub pure fn any<T>(v: &[T], f: fn(t: &T) -> bool) -> bool {\n+pub pure fn any<T>(v: &[T], f: &fn(t: &T) -> bool) -> bool {\n     for each(v) |elem| { if f(elem) { return true; } }\n     false\n }\n@@ -1019,7 +1019,7 @@ pub pure fn any<T>(v: &[T], f: fn(t: &T) -> bool) -> bool {\n  * If the vectors contains no elements then false is returned.\n  */\n pub pure fn any2<T, U>(v0: &[T], v1: &[U],\n-                   f: fn(a: &T, b: &U) -> bool) -> bool {\n+                   f: &fn(a: &T, b: &U) -> bool) -> bool {\n     let v0_len = len(v0);\n     let v1_len = len(v1);\n     let mut i = 0u;\n@@ -1035,7 +1035,7 @@ pub pure fn any2<T, U>(v0: &[T], v1: &[U],\n  *\n  * If the vector contains no elements then true is returned.\n  */\n-pub pure fn all<T>(v: &[T], f: fn(t: &T) -> bool) -> bool {\n+pub pure fn all<T>(v: &[T], f: &fn(t: &T) -> bool) -> bool {\n     for each(v) |elem| { if !f(elem) { return false; } }\n     true\n }\n@@ -1045,7 +1045,7 @@ pub pure fn all<T>(v: &[T], f: fn(t: &T) -> bool) -> bool {\n  *\n  * If the vector contains no elements then true is returned.\n  */\n-pub pure fn alli<T>(v: &[T], f: fn(uint, t: &T) -> bool) -> bool {\n+pub pure fn alli<T>(v: &[T], f: &fn(uint, t: &T) -> bool) -> bool {\n     for eachi(v) |i, elem| { if !f(i, elem) { return false; } }\n     true\n }\n@@ -1056,7 +1056,7 @@ pub pure fn alli<T>(v: &[T], f: fn(uint, t: &T) -> bool) -> bool {\n  * If the vectors are not the same size then false is returned.\n  */\n pub pure fn all2<T, U>(v0: &[T], v1: &[U],\n-                   f: fn(t: &T, u: &U) -> bool) -> bool {\n+                   f: &fn(t: &T, u: &U) -> bool) -> bool {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { return false; }\n     let mut i = 0u;\n@@ -1084,7 +1084,7 @@ pub pure fn count<T:Eq>(v: &[T], x: &T) -> uint {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-pub pure fn find<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n+pub pure fn find<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n     find_between(v, 0u, len(v), f)\n }\n \n@@ -1096,7 +1096,7 @@ pub pure fn find<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n  * the element is returned. If `f` matches no elements then none is returned.\n  */\n pub pure fn find_between<T:Copy>(v: &[T], start: uint, end: uint,\n-                      f: fn(t: &T) -> bool) -> Option<T> {\n+                      f: &fn(t: &T) -> bool) -> Option<T> {\n     position_between(v, start, end, f).map(|i| v[*i])\n }\n \n@@ -1107,7 +1107,7 @@ pub pure fn find_between<T:Copy>(v: &[T], start: uint, end: uint,\n  * `f` returns true then an option containing the element is returned. If `f`\n  * matches no elements then none is returned.\n  */\n-pub pure fn rfind<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n+pub pure fn rfind<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> Option<T> {\n     rfind_between(v, 0u, len(v), f)\n }\n \n@@ -1119,7 +1119,7 @@ pub pure fn rfind<T:Copy>(v: &[T], f: fn(t: &T) -> bool) -> Option<T> {\n  * the element is returned. If `f` matches no elements then none is return.\n  */\n pub pure fn rfind_between<T:Copy>(v: &[T], start: uint, end: uint,\n-                               f: fn(t: &T) -> bool) -> Option<T> {\n+                               f: &fn(t: &T) -> bool) -> Option<T> {\n     rposition_between(v, start, end, f).map(|i| v[*i])\n }\n \n@@ -1135,7 +1135,7 @@ pub pure fn position_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n  * then an option containing the index is returned. If `f` matches no elements\n  * then none is returned.\n  */\n-pub pure fn position<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n+pub pure fn position<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n     position_between(v, 0u, len(v), f)\n }\n \n@@ -1147,7 +1147,7 @@ pub pure fn position<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n  * the index is returned. If `f` matches no elements then none is returned.\n  */\n pub pure fn position_between<T>(v: &[T], start: uint, end: uint,\n-                            f: fn(t: &T) -> bool) -> Option<uint> {\n+                            f: &fn(t: &T) -> bool) -> Option<uint> {\n     fail_unless!(start <= end);\n     fail_unless!(end <= len(v));\n     let mut i = start;\n@@ -1167,7 +1167,7 @@ pure fn rposition_elem<T:Eq>(v: &[T], x: &T) -> Option<uint> {\n  * `f` returns true then an option containing the index is returned. If `f`\n  * matches no elements then none is returned.\n  */\n-pub pure fn rposition<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n+pub pure fn rposition<T>(v: &[T], f: &fn(t: &T) -> bool) -> Option<uint> {\n     rposition_between(v, 0u, len(v), f)\n }\n \n@@ -1180,7 +1180,7 @@ pub pure fn rposition<T>(v: &[T], f: fn(t: &T) -> bool) -> Option<uint> {\n  * returned.\n  */\n pub pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n-                             f: fn(t: &T) -> bool) -> Option<uint> {\n+                             f: &fn(t: &T) -> bool) -> Option<uint> {\n     fail_unless!(start <= end);\n     fail_unless!(end <= len(v));\n     let mut i = end;\n@@ -1334,7 +1334,7 @@ pub pure fn reversed<T:Copy>(v: &[const T]) -> ~[T] {\n  * ~~~\n  */\n #[inline(always)]\n-pub pure fn each<T>(v: &r/[T], f: fn(&r/T) -> bool) {\n+pub pure fn each<T>(v: &r/[T], f: &fn(&r/T) -> bool) {\n     //             ^^^^\n     // NB---this CANNOT be &[const T]!  The reason\n     // is that you are passing it to `f()` using\n@@ -1358,7 +1358,7 @@ pub pure fn each<T>(v: &r/[T], f: fn(&r/T) -> bool) {\n /// a vector with mutable contents and you would like\n /// to mutate the contents as you iterate.\n #[inline(always)]\n-pub fn each_mut<T>(v: &mut [T], f: fn(elem: &mut T) -> bool) {\n+pub fn each_mut<T>(v: &mut [T], f: &fn(elem: &mut T) -> bool) {\n     let mut i = 0;\n     let n = v.len();\n     while i < n {\n@@ -1372,7 +1372,7 @@ pub fn each_mut<T>(v: &mut [T], f: fn(elem: &mut T) -> bool) {\n /// Like `each()`, but for the case where you have a vector that *may or may\n /// not* have mutable contents.\n #[inline(always)]\n-pub pure fn each_const<T>(v: &[const T], f: fn(elem: &const T) -> bool) {\n+pub pure fn each_const<T>(v: &[const T], f: &fn(elem: &const T) -> bool) {\n     let mut i = 0;\n     let n = v.len();\n     while i < n {\n@@ -1389,7 +1389,7 @@ pub pure fn each_const<T>(v: &[const T], f: fn(elem: &const T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub pure fn eachi<T>(v: &r/[T], f: fn(uint, v: &r/T) -> bool) {\n+pub pure fn eachi<T>(v: &r/[T], f: &fn(uint, v: &r/T) -> bool) {\n     let mut i = 0;\n     for each(v) |p| {\n         if !f(i, p) { return; }\n@@ -1403,7 +1403,7 @@ pub pure fn eachi<T>(v: &r/[T], f: fn(uint, v: &r/T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub pure fn rev_each<T>(v: &r/[T], blk: fn(v: &r/T) -> bool) {\n+pub pure fn rev_each<T>(v: &r/[T], blk: &fn(v: &r/T) -> bool) {\n     rev_eachi(v, |_i, v| blk(v))\n }\n \n@@ -1413,7 +1413,7 @@ pub pure fn rev_each<T>(v: &r/[T], blk: fn(v: &r/T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub pure fn rev_eachi<T>(v: &r/[T], blk: fn(i: uint, v: &r/T) -> bool) {\n+pub pure fn rev_eachi<T>(v: &r/[T], blk: &fn(i: uint, v: &r/T) -> bool) {\n     let mut i = v.len();\n     while i > 0 {\n         i -= 1;\n@@ -1431,7 +1431,7 @@ pub pure fn rev_eachi<T>(v: &r/[T], blk: fn(i: uint, v: &r/T) -> bool) {\n  * Both vectors must have the same length\n  */\n #[inline]\n-pub pure fn each2<U, T>(v1: &[U], v2: &[T], f: fn(u: &U, t: &T) -> bool) {\n+pub pure fn each2<U, T>(v1: &[U], v2: &[T], f: &fn(u: &U, t: &T) -> bool) {\n     fail_unless!(len(v1) == len(v2));\n     for uint::range(0u, len(v1)) |i| {\n         if !f(&v1[i], &v2[i]) {\n@@ -1450,7 +1450,7 @@ pub pure fn each2<U, T>(v1: &[U], v2: &[T], f: fn(u: &U, t: &T) -> bool) {\n  * The total number of permutations produced is `len(v)!`.  If `v` contains\n  * repeated elements, then some permutations are repeated.\n  */\n-pub pure fn each_permutation<T:Copy>(v: &[T], put: fn(ts: &[T]) -> bool) {\n+pub pure fn each_permutation<T:Copy>(v: &[T], put: &fn(ts: &[T]) -> bool) {\n     let ln = len(v);\n     if ln <= 1 {\n         put(v);\n@@ -1497,7 +1497,7 @@ pub pure fn windowed<TT:Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n #[inline(always)]\n pub pure fn as_imm_buf<T,U>(s: &[T],\n                             /* NB---this CANNOT be const, see below */\n-                            f: fn(*T, uint) -> U) -> U {\n+                            f: &fn(*T, uint) -> U) -> U {\n \n     // NB---Do not change the type of s to `&[const T]`.  This is\n     // unsound.  The reason is that we are going to create immutable pointers\n@@ -1516,7 +1516,7 @@ pub pure fn as_imm_buf<T,U>(s: &[T],\n /// Similar to `as_imm_buf` but passing a `*const T`\n #[inline(always)]\n pub pure fn as_const_buf<T,U>(s: &[const T],\n-                          f: fn(*const T, uint) -> U) -> U {\n+                          f: &fn(*const T, uint) -> U) -> U {\n \n     unsafe {\n         let v : *(*const T,uint) =\n@@ -1529,7 +1529,7 @@ pub pure fn as_const_buf<T,U>(s: &[const T],\n /// Similar to `as_imm_buf` but passing a `*mut T`\n #[inline(always)]\n pub pure fn as_mut_buf<T,U>(s: &mut [T],\n-                        f: fn(*mut T, uint) -> U) -> U {\n+                        f: &fn(*mut T, uint) -> U) -> U {\n \n     unsafe {\n         let v : *(*mut T,uint) =\n@@ -1721,13 +1721,13 @@ pub trait ImmutableVector<T> {\n     pure fn initn(&self, n: uint) -> &self/[T];\n     pure fn last(&self) -> &self/T;\n     pure fn last_opt(&self) -> Option<&self/T>;\n-    pure fn foldr<U: Copy>(&self, z: U, p: fn(t: &T, u: U) -> U) -> U;\n-    pure fn map<U>(&self, f: fn(t: &T) -> U) -> ~[U];\n-    pure fn mapi<U>(&self, f: fn(uint, t: &T) -> U) -> ~[U];\n-    fn map_r<U>(&self, f: fn(x: &T) -> U) -> ~[U];\n-    pure fn alli(&self, f: fn(uint, t: &T) -> bool) -> bool;\n-    pure fn flat_map<U>(&self, f: fn(t: &T) -> ~[U]) -> ~[U];\n-    pure fn filter_mapped<U:Copy>(&self, f: fn(t: &T) -> Option<U>) -> ~[U];\n+    pure fn foldr<U: Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U;\n+    pure fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U];\n+    pure fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U];\n+    fn map_r<U>(&self, f: &fn(x: &T) -> U) -> ~[U];\n+    pure fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool;\n+    pure fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n+    pure fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U];\n }\n \n /// Extension methods for vectors\n@@ -1772,24 +1772,24 @@ impl<T> ImmutableVector<T> for &self/[T] {\n \n     /// Reduce a vector from right to left\n     #[inline]\n-    pure fn foldr<U:Copy>(&self, z: U, p: fn(t: &T, u: U) -> U) -> U {\n+    pure fn foldr<U:Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U {\n         foldr(*self, z, p)\n     }\n \n     /// Apply a function to each element of a vector and return the results\n     #[inline]\n-    pure fn map<U>(&self, f: fn(t: &T) -> U) -> ~[U] { map(*self, f) }\n+    pure fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] { map(*self, f) }\n \n     /**\n      * Apply a function to the index and value of each element in the vector\n      * and return the results\n      */\n-    pure fn mapi<U>(&self, f: fn(uint, t: &T) -> U) -> ~[U] {\n+    pure fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U] {\n         mapi(*self, f)\n     }\n \n     #[inline]\n-    fn map_r<U>(&self, f: fn(x: &T) -> U) -> ~[U] {\n+    fn map_r<U>(&self, f: &fn(x: &T) -> U) -> ~[U] {\n         let mut r = ~[];\n         let mut i = 0;\n         while i < self.len() {\n@@ -1804,15 +1804,15 @@ impl<T> ImmutableVector<T> for &self/[T] {\n      *\n      *     If the vector is empty, true is returned.\n      */\n-    pure fn alli(&self, f: fn(uint, t: &T) -> bool) -> bool {\n+    pure fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool {\n         alli(*self, f)\n     }\n     /**\n      * Apply a function to each element of a vector and return a concatenation\n      * of each result vector\n      */\n     #[inline]\n-    pure fn flat_map<U>(&self, f: fn(t: &T) -> ~[U]) -> ~[U] {\n+    pure fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U] {\n         flat_map(*self, f)\n     }\n     /**\n@@ -1822,15 +1822,15 @@ impl<T> ImmutableVector<T> for &self/[T] {\n      * the resulting vector.\n      */\n     #[inline]\n-    pure fn filter_mapped<U:Copy>(&self, f: fn(t: &T) -> Option<U>) -> ~[U] {\n+    pure fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U] {\n         filter_mapped(*self, f)\n     }\n }\n \n pub trait ImmutableEqVector<T:Eq> {\n-    pure fn position(&self, f: fn(t: &T) -> bool) -> Option<uint>;\n+    pure fn position(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n     pure fn position_elem(&self, t: &T) -> Option<uint>;\n-    pure fn rposition(&self, f: fn(t: &T) -> bool) -> Option<uint>;\n+    pure fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n     pure fn rposition_elem(&self, t: &T) -> Option<uint>;\n }\n \n@@ -1843,7 +1843,7 @@ impl<T:Eq> ImmutableEqVector<T> for &self/[T] {\n      * elements then none is returned.\n      */\n     #[inline]\n-    pure fn position(&self, f: fn(t: &T) -> bool) -> Option<uint> {\n+    pure fn position(&self, f: &fn(t: &T) -> bool) -> Option<uint> {\n         position(*self, f)\n     }\n \n@@ -1861,7 +1861,7 @@ impl<T:Eq> ImmutableEqVector<T> for &self/[T] {\n      * returned. If `f` matches no elements then none is returned.\n      */\n     #[inline]\n-    pure fn rposition(&self, f: fn(t: &T) -> bool) -> Option<uint> {\n+    pure fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint> {\n         rposition(*self, f)\n     }\n \n@@ -1873,9 +1873,9 @@ impl<T:Eq> ImmutableEqVector<T> for &self/[T] {\n }\n \n pub trait ImmutableCopyableVector<T> {\n-    pure fn filtered(&self, f: fn(&T) -> bool) -> ~[T];\n-    pure fn rfind(&self, f: fn(t: &T) -> bool) -> Option<T>;\n-    pure fn partitioned(&self, f: fn(&T) -> bool) -> (~[T], ~[T]);\n+    pure fn filtered(&self, f: &fn(&T) -> bool) -> ~[T];\n+    pure fn rfind(&self, f: &fn(t: &T) -> bool) -> Option<T>;\n+    pure fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n }\n \n /// Extension methods for vectors\n@@ -1888,7 +1888,7 @@ impl<T:Copy> ImmutableCopyableVector<T> for &self/[T] {\n      * containing only those elements for which `f` returned true.\n      */\n     #[inline]\n-    pure fn filtered(&self, f: fn(t: &T) -> bool) -> ~[T] {\n+    pure fn filtered(&self, f: &fn(t: &T) -> bool) -> ~[T] {\n         filtered(*self, f)\n     }\n \n@@ -1900,7 +1900,7 @@ impl<T:Copy> ImmutableCopyableVector<T> for &self/[T] {\n      * returned. If `f` matches no elements then none is returned.\n      */\n     #[inline]\n-    pure fn rfind(&self, f: fn(t: &T) -> bool) -> Option<T> {\n+    pure fn rfind(&self, f: &fn(t: &T) -> bool) -> Option<T> {\n         rfind(*self, f)\n     }\n \n@@ -1909,7 +1909,7 @@ impl<T:Copy> ImmutableCopyableVector<T> for &self/[T] {\n      * those that do not.\n      */\n     #[inline]\n-    pure fn partitioned(&self, f: fn(&T) -> bool) -> (~[T], ~[T]) {\n+    pure fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n         partitioned(*self, f)\n     }\n }\n@@ -1924,10 +1924,10 @@ pub trait OwnedVector<T> {\n     fn remove(&mut self, i: uint) -> T;\n     fn swap_remove(&mut self, index: uint) -> T;\n     fn truncate(&mut self, newlen: uint);\n-    fn retain(&mut self, f: pure fn(t: &T) -> bool);\n-    fn consume(self, f: fn(uint, v: T));\n-    fn filter(self, f: fn(t: &T) -> bool) -> ~[T];\n-    fn partition(self, f: pure fn(&T) -> bool) -> (~[T], ~[T]);\n+    fn retain(&mut self, f: &pure fn(t: &T) -> bool);\n+    fn consume(self, f: &fn(uint, v: T));\n+    fn filter(self, f: &fn(t: &T) -> bool) -> ~[T];\n+    fn partition(self, f: &pure fn(&T) -> bool) -> (~[T], ~[T]);\n     fn grow_fn(&mut self, n: uint, op: iter::InitOp<T>);\n }\n \n@@ -1978,17 +1978,17 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     #[inline]\n-    fn retain(&mut self, f: pure fn(t: &T) -> bool) {\n+    fn retain(&mut self, f: &pure fn(t: &T) -> bool) {\n         retain(self, f);\n     }\n \n     #[inline]\n-    fn consume(self, f: fn(uint, v: T)) {\n+    fn consume(self, f: &fn(uint, v: T)) {\n         consume(self, f)\n     }\n \n     #[inline]\n-    fn filter(self, f: fn(&T) -> bool) -> ~[T] {\n+    fn filter(self, f: &fn(&T) -> bool) -> ~[T] {\n         filter(self, f)\n     }\n \n@@ -1997,7 +1997,7 @@ impl<T> OwnedVector<T> for ~[T] {\n      * those that do not.\n      */\n     #[inline]\n-    fn partition(self, f: fn(&T) -> bool) -> (~[T], ~[T]) {\n+    fn partition(self, f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n         partition(self, f)\n     }\n \n@@ -2138,7 +2138,7 @@ pub mod raw {\n     #[inline(always)]\n     pub unsafe fn buf_as_slice<T,U>(p: *T,\n                                     len: uint,\n-                                    f: fn(v: &[T]) -> U) -> U {\n+                                    f: &fn(v: &[T]) -> U) -> U {\n         let pair = (p, len * sys::nonzero_size_of::<T>());\n         let v : *(&blk/[T]) =\n             ::cast::reinterpret_cast(&addr_of(&pair));\n@@ -2270,99 +2270,101 @@ pub mod bytes {\n \n impl<A> iter::BaseIter<A> for &self/[A] {\n     #[inline(always)]\n-    pure fn each(&self, blk: fn(v: &'self A) -> bool) { each(*self, blk) }\n+    pub pure fn each(&self, blk: &fn(v: &'self A) -> bool) {\n+        each(*self, blk)\n+    }\n     #[inline(always)]\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> iter::BaseIter<A> for ~[A] {\n     #[inline(always)]\n-    pure fn each(&self, blk: fn(v: &'self A) -> bool) { each(*self, blk) }\n+    pure fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> iter::BaseIter<A> for @[A] {\n     #[inline(always)]\n-    pure fn each(&self, blk: fn(v: &'self A) -> bool) { each(*self, blk) }\n+    pure fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<A> iter::ExtendedIter<A> for &self/[A] {\n-    pub pure fn eachi(&self, blk: fn(uint, v: &A) -> bool) {\n+    pub pure fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n         iter::eachi(self, blk)\n     }\n-    pub pure fn all(&self, blk: fn(&A) -> bool) -> bool {\n+    pub pure fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::all(self, blk)\n     }\n-    pub pure fn any(&self, blk: fn(&A) -> bool) -> bool {\n+    pub pure fn any(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::any(self, blk)\n     }\n-    pub pure fn foldl<B>(&self, b0: B, blk: fn(&B, &A) -> B) -> B {\n+    pub pure fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n-    pub pure fn position(&self, f: fn(&A) -> bool) -> Option<uint> {\n+    pub pure fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n         iter::position(self, f)\n     }\n-    pure fn map_to_vec<B>(&self, op: fn(&A) -> B) -> ~[B] {\n+    pure fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n         iter::map_to_vec(self, op)\n     }\n-    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: fn(&A) -> IB)\n+    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n         iter::flat_map_to_vec(self, op)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> iter::ExtendedIter<A> for ~[A] {\n-    pub pure fn eachi(&self, blk: fn(uint, v: &A) -> bool) {\n+    pub pure fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n         iter::eachi(self, blk)\n     }\n-    pub pure fn all(&self, blk: fn(&A) -> bool) -> bool {\n+    pub pure fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::all(self, blk)\n     }\n-    pub pure fn any(&self, blk: fn(&A) -> bool) -> bool {\n+    pub pure fn any(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::any(self, blk)\n     }\n-    pub pure fn foldl<B>(&self, b0: B, blk: fn(&B, &A) -> B) -> B {\n+    pub pure fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n-    pub pure fn position(&self, f: fn(&A) -> bool) -> Option<uint> {\n+    pub pure fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n         iter::position(self, f)\n     }\n-    pure fn map_to_vec<B>(&self, op: fn(&A) -> B) -> ~[B] {\n+    pure fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n         iter::map_to_vec(self, op)\n     }\n-    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: fn(&A) -> IB)\n+    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n         iter::flat_map_to_vec(self, op)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A> iter::ExtendedIter<A> for @[A] {\n-    pub pure fn eachi(&self, blk: fn(uint, v: &A) -> bool) {\n+    pub pure fn eachi(&self, blk: &fn(uint, v: &A) -> bool) {\n         iter::eachi(self, blk)\n     }\n-    pub pure fn all(&self, blk: fn(&A) -> bool) -> bool {\n+    pub pure fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::all(self, blk)\n     }\n-    pub pure fn any(&self, blk: fn(&A) -> bool) -> bool {\n+    pub pure fn any(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::any(self, blk)\n     }\n-    pub pure fn foldl<B>(&self, b0: B, blk: fn(&B, &A) -> B) -> B {\n+    pub pure fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n-    pub pure fn position(&self, f: fn(&A) -> bool) -> Option<uint> {\n+    pub pure fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n         iter::position(self, f)\n     }\n-    pure fn map_to_vec<B>(&self, op: fn(&A) -> B) -> ~[B] {\n+    pure fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n         iter::map_to_vec(self, op)\n     }\n-    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: fn(&A) -> IB)\n+    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n         iter::flat_map_to_vec(self, op)\n     }\n@@ -2386,33 +2388,33 @@ impl<A:Eq> iter::EqIter<A> for @[A] {\n }\n \n impl<A:Copy> iter::CopyableIter<A> for &self/[A] {\n-    pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A] {\n+    pure fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n     pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n-    pub pure fn find(&self, f: fn(&A) -> bool) -> Option<A> {\n+    pub pure fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n         iter::find(self, f)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A:Copy> iter::CopyableIter<A> for ~[A] {\n-    pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A] {\n+    pure fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n     pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n-    pub pure fn find(&self, f: fn(&A) -> bool) -> Option<A> {\n+    pub pure fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n         iter::find(self, f)\n     }\n }\n \n // FIXME(#4148): This should be redundant\n impl<A:Copy> iter::CopyableIter<A> for @[A] {\n-    pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A] {\n+    pure fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n     pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n-    pub pure fn find(&self, f: fn(&A) -> bool) -> Option<A> {\n+    pub pure fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n         iter::find(self, f)\n     }\n }\n@@ -2435,7 +2437,7 @@ impl<A:Copy + Ord> iter::CopyableOrderedIter<A> for @[A] {\n }\n \n impl<A:Copy> iter::CopyableNonstrictIter<A> for &self/[A] {\n-    pure fn each_val(&const self, f: fn(A) -> bool) {\n+    pure fn each_val(&const self, f: &fn(A) -> bool) {\n         let mut i = 0;\n         while i < self.len() {\n             if !f(copy self[i]) { break; }\n@@ -2446,7 +2448,7 @@ impl<A:Copy> iter::CopyableNonstrictIter<A> for &self/[A] {\n \n // FIXME(#4148): This should be redundant\n impl<A:Copy> iter::CopyableNonstrictIter<A> for ~[A] {\n-    pure fn each_val(&const self, f: fn(A) -> bool) {\n+    pure fn each_val(&const self, f: &fn(A) -> bool) {\n         let mut i = 0;\n         while i < self.len() {\n             if !f(copy self[i]) { break; }\n@@ -2457,7 +2459,7 @@ impl<A:Copy> iter::CopyableNonstrictIter<A> for ~[A] {\n \n // FIXME(#4148): This should be redundant\n impl<A:Copy> iter::CopyableNonstrictIter<A> for @[A] {\n-    pure fn each_val(&const self, f: fn(A) -> bool) {\n+    pure fn each_val(&const self, f: &fn(A) -> bool) {\n         let mut i = 0;\n         while i < self.len() {\n             if !f(copy self[i]) { break; }"}, {"sha": "90ada832327f4cb4b66e71bdc010bc0f390e2fc3", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -247,7 +247,7 @@ pub fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::Ty,\n     *crate2\n }\n \n-pub fn under(n: uint, it: fn(uint)) {\n+pub fn under(n: uint, it: &fn(uint)) {\n     let mut i: uint = 0u;\n     while i < n { it(i); i += 1u; }\n }"}, {"sha": "fec3f77668137d1bfd8c0f2c584745032e93b791", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -153,7 +153,7 @@ pub mod jit {\n                     code: entry,\n                     env: ptr::null()\n                 };\n-                let func: fn(++argv: ~[~str]) = cast::transmute(closure);\n+                let func: &fn(++argv: ~[~str]) = cast::transmute(closure);\n \n                 func(~[/*bad*/copy sess.opts.binary]);\n             }"}, {"sha": "2b61c9480457deb831dec84f48355790e6f036e8", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -164,7 +164,7 @@ pub fn parse_input(sess: Session, +cfg: ast::crate_cfg, input: input)\n     }\n }\n \n-pub fn time<T>(do_it: bool, what: ~str, thunk: fn() -> T) -> T {\n+pub fn time<T>(do_it: bool, what: ~str, thunk: &fn() -> T) -> T {\n     if !do_it { return thunk(); }\n     let start = std::time::precise_time_s();\n     let rv = thunk();"}, {"sha": "d2d0ceff6331df663477fee8a0012c254e4cd98c", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -306,7 +306,7 @@ pub fn basic_options() -> @options {\n // Seems out of place, but it uses session, so I'm putting it here\n pub fn expect<T:Copy>(sess: Session,\n                        opt: Option<T>,\n-                       msg: fn() -> ~str)\n+                       msg: &fn() -> ~str)\n                     -> T {\n     diagnostic::expect(sess.diagnostic(), opt, msg)\n }"}, {"sha": "47ee477210b78c04cdb02eccf440dd473cb9d2d9", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -155,7 +155,7 @@ pub fn get_static_methods_if_impl(cstore: @mut cstore::CStore,\n \n pub fn get_item_attrs(cstore: @mut cstore::CStore,\n                       def_id: ast::def_id,\n-                      f: fn(~[@ast::meta_item])) {\n+                      f: &fn(~[@ast::meta_item])) {\n     let cdata = cstore::get_crate_data(cstore, def_id.crate);\n     decoder::get_item_attrs(cdata, def_id.node, f)\n }"}, {"sha": "0909a4437369daa14d085a34acf4b9755658fa81", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -88,7 +88,7 @@ pub fn have_crate_data(cstore: @mut CStore, cnum: ast::crate_num) -> bool {\n }\n \n pub fn iter_crate_data(cstore: @mut CStore,\n-                       i: fn(ast::crate_num, @crate_metadata)) {\n+                       i: &fn(ast::crate_num, @crate_metadata)) {\n     let metas = cstore.metas;\n     for metas.each |&k, &v| {\n         i(k, v);"}, {"sha": "2643012d30ae2255cc12c3dd6671bd2b5b2a5481", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -48,7 +48,7 @@ type cmd = @crate_metadata;\n // what crate that's in and give us a def_id that makes sense for the current\n // build.\n \n-fn lookup_hash(d: ebml::Doc, eq_fn: fn(x:&[u8]) -> bool, hash: uint) ->\n+fn lookup_hash(d: ebml::Doc, eq_fn: &fn(x:&[u8]) -> bool, hash: uint) ->\n    Option<ebml::Doc> {\n     let index = reader::get_doc(d, tag_index);\n     let table = reader::get_doc(index, tag_index_table);\n@@ -193,7 +193,7 @@ fn item_def_id(d: ebml::Doc, cdata: cmd) -> ast::def_id {\n                                                     |d| parse_def_id(d)));\n }\n \n-fn each_reexport(d: ebml::Doc, f: fn(ebml::Doc) -> bool) {\n+fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) {\n     for reader::tagged_docs(d, tag_items_data_item_reexport) |reexport_doc| {\n         if !f(reexport_doc) {\n             return;\n@@ -451,7 +451,7 @@ pub fn each_lang_item(cdata: cmd, f: &fn(ast::node_id, uint) -> bool) {\n /// Iterates over all the paths in the given crate.\n pub fn each_path(intr: @ident_interner, cdata: cmd,\n                  get_crate_data: GetCrateDataCb,\n-                 f: fn(&str, def_like) -> bool) {\n+                 f: &fn(&str, def_like) -> bool) {\n     let root = reader::Doc(cdata.data);\n     let items = reader::get_doc(root, tag_items);\n     let items_data = reader::get_doc(items, tag_items_data);\n@@ -855,7 +855,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n \n pub fn get_item_attrs(cdata: cmd,\n                       node_id: ast::node_id,\n-                      f: fn(~[@ast::meta_item])) {\n+                      f: &fn(~[@ast::meta_item])) {\n \n     let item = lookup_item(node_id, cdata.data);\n     for reader::tagged_docs(item, tag_attributes) |attributes| {\n@@ -1093,7 +1093,7 @@ pub fn get_crate_vers(data: @~[u8]) -> @~str {\n \n fn iter_crate_items(intr: @ident_interner, cdata: cmd,\n                     get_crate_data: GetCrateDataCb,\n-                    proc: fn(path: &str, ast::def_id)) {\n+                    proc: &fn(path: &str, ast::def_id)) {\n     for each_path(intr, cdata, get_crate_data) |path_string, def_like| {\n         match def_like {\n             dl_impl(*) | dl_field => {}"}, {"sha": "fc42ac2ffedb9c43419ae159b559a10b6efbd2bb", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -1054,7 +1054,7 @@ fn create_index<T:Copy + Hash + IterBytes>(index: ~[entry<T>]) ->\n }\n \n fn encode_index<T>(ebml_w: writer::Encoder, buckets: ~[@~[entry<T>]],\n-                   write_fn: fn(io::Writer, T)) {\n+                   write_fn: &fn(io::Writer, T)) {\n     let writer = ebml_w.writer;\n     ebml_w.start_tag(tag_index);\n     let mut bucket_locs: ~[uint] = ~[];"}, {"sha": "63b14cc51be1c4c89fb7efe27ec21fbdc9edd33d", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -217,7 +217,7 @@ fn parse_region(st: @mut PState) -> ty::Region {\n     }\n }\n \n-fn parse_opt<T>(st: @mut PState, f: fn() -> T) -> Option<T> {\n+fn parse_opt<T>(st: @mut PState, f: &fn() -> T) -> Option<T> {\n     match next(st) {\n       'n' => None,\n       's' => Some(f()),"}, {"sha": "b9cb0b1d4b5a3e38eabe65b05600ed5e01b093c6", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -122,7 +122,7 @@ fn enc_mt(w: io::Writer, cx: @ctxt, mt: ty::mt) {\n     enc_ty(w, cx, mt.ty);\n }\n \n-fn enc_opt<T>(w: io::Writer, t: Option<T>, enc_f: fn(T)) {\n+fn enc_opt<T>(w: io::Writer, t: Option<T>, enc_f: &fn(T)) {\n     match &t {\n       &None => w.write_char('n'),\n       &Some(ref v) => {"}, {"sha": "c1a8f79b9b131dace1eab45060767b2bc60fc52d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -795,12 +795,12 @@ impl ebml_writer_helpers for writer::Encoder {\n }\n \n trait write_tag_and_id {\n-    fn tag(&self, tag_id: c::astencode_tag, f: fn());\n+    fn tag(&self, tag_id: c::astencode_tag, f: &fn());\n     fn id(&self, id: ast::node_id);\n }\n \n impl write_tag_and_id for writer::Encoder {\n-    fn tag(&self, tag_id: c::astencode_tag, f: fn()) {\n+    fn tag(&self, tag_id: c::astencode_tag, f: &fn()) {\n         do self.wr_tag(tag_id as uint) { f() }\n     }\n "}, {"sha": "3e637071624170c8e703d59233fd3c58ea306a92", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -510,7 +510,7 @@ pub impl BorrowckCtxt {\n                                  method_map: self.method_map}\n     }\n \n-    fn cat_pattern(&self, cmt: cmt, pat: @ast::pat, op: fn(cmt, @ast::pat)) {\n+    fn cat_pattern(&self, cmt: cmt, pat: @ast::pat, op: &fn(cmt, @ast::pat)) {\n         let mc = self.mc_ctxt();\n         mc.cat_pattern(cmt, pat, op);\n     }"}, {"sha": "48d136ce65f365aeff60cd3a93017cc5a2538058", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -95,7 +95,7 @@ type check_fn = @fn(Context, @freevar_entry);\n // Yields the appropriate function to check the kind of closed over\n // variables. `id` is the node_id for some expression that creates the\n // closure.\n-fn with_appropriate_checker(cx: Context, id: node_id, b: fn(check_fn)) {\n+fn with_appropriate_checker(cx: Context, id: node_id, b: &fn(check_fn)) {\n     fn check_for_uniq(cx: Context, fv: @freevar_entry) {\n         // all captured data must be owned, regardless of whether it is\n         // moved in or copied in."}, {"sha": "93f0557028eae61797d80fa58c8517e50b857274", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -77,6 +77,7 @@ pub enum lint {\n     default_methods,\n     deprecated_self,\n     deprecated_mutable_fields,\n+    deprecated_drop,\n \n     managed_heap_memory,\n     owned_heap_memory,\n@@ -251,6 +252,13 @@ pub fn get_lint_dict() -> LintDict {\n             default: deny\n         }),\n \n+        (@~\"deprecated_drop\",\n+         @LintSpec {\n+            lint: deprecated_drop,\n+            desc: \"deprecated \\\"drop\\\" notation for the destructor\",\n+            default: deny\n+        }),\n+\n         /* FIXME(#3266)--make liveness warnings lintable\n         (@~\"unused_variable\",\n          @LintSpec {\n@@ -342,7 +350,7 @@ pub impl Context {\n      * current lint context, call the provided function, then reset the\n      * lints in effect to their previous state.\n      */\n-    fn with_lint_attrs(&self, attrs: ~[ast::attribute], f: fn(Context)) {\n+    fn with_lint_attrs(&self, attrs: ~[ast::attribute], f: &fn(Context)) {\n \n         let mut new_ctxt = *self;\n         let mut triples = ~[];\n@@ -483,6 +491,7 @@ fn check_item(i: @ast::item, cx: ty::ctxt) {\n     check_item_default_methods(cx, i);\n     check_item_deprecated_self(cx, i);\n     check_item_deprecated_mutable_fields(cx, i);\n+    check_item_deprecated_drop(cx, i);\n }\n \n // Take a visitor, and modify it so that it will not proceed past subitems.\n@@ -720,6 +729,26 @@ fn check_item_deprecated_mutable_fields(cx: ty::ctxt, item: @ast::item) {\n     }\n }\n \n+fn check_item_deprecated_drop(cx: ty::ctxt, item: @ast::item) {\n+    match item.node {\n+        ast::item_struct(struct_def, _) => {\n+            match struct_def.dtor {\n+                None => {}\n+                Some(ref dtor) => {\n+                    cx.sess.span_lint(deprecated_drop,\n+                                      item.id,\n+                                      item.id,\n+                                      dtor.span,\n+                                      ~\"`drop` notation for destructors is \\\n+                                        deprecated; implement the `Drop` \\\n+                                        trait instead\");\n+                }\n+            }\n+        }\n+        _ => {}\n+    }\n+}\n+\n fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n \n     fn check_foreign_fn(cx: ty::ctxt, fn_id: ast::node_id,"}, {"sha": "0c17b371694c4403bdd3a54aff7a7dac875cdabf", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -137,8 +137,8 @@ use syntax::{visit, ast_util};\n // if it detects an outstanding loan (that is, the addr is taken).\n pub type last_use_map = HashMap<node_id, @mut ~[node_id]>;\n \n-enum Variable = uint;\n-enum LiveNode = uint;\n+struct Variable(uint);\n+struct LiveNode(uint);\n \n impl cmp::Eq for Variable {\n     pure fn eq(&self, other: &Variable) -> bool { *(*self) == *(*other) }\n@@ -735,7 +735,7 @@ pub impl Liveness {\n         }\n     }\n \n-    fn pat_bindings(&self, pat: @pat, f: fn(LiveNode, Variable, span)) {\n+    fn pat_bindings(&self, pat: @pat, f: &fn(LiveNode, Variable, span)) {\n         let def_map = self.tcx.def_map;\n         do pat_util::pat_bindings(def_map, pat) |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n@@ -745,7 +745,7 @@ pub impl Liveness {\n     }\n \n     fn arm_pats_bindings(&self,\n-                         pats: &[@pat], f: fn(LiveNode, Variable, span)) {\n+                         pats: &[@pat], f: &fn(LiveNode, Variable, span)) {\n         // only consider the first pattern; any later patterns must have\n         // the same bindings, and we also consider the first pattern to be\n         // the \"authoratative\" set of ids\n@@ -809,15 +809,14 @@ pub impl Liveness {\n         self.assigned_on_entry(copy self.successors[*ln], var)\n     }\n \n-    fn indices(&self, ln: LiveNode, op: fn(uint)) {\n+    fn indices(&self, ln: LiveNode, op: &fn(uint)) {\n         let node_base_idx = self.idx(ln, Variable(0));\n         for uint::range(0, self.ir.num_vars) |var_idx| {\n             op(node_base_idx + var_idx)\n         }\n     }\n \n-    fn indices2(&self, ln: LiveNode, succ_ln: LiveNode,\n-                op: fn(uint, uint)) {\n+    fn indices2(&self, ln: LiveNode, succ_ln: LiveNode, op: &fn(uint, uint)) {\n         let node_base_idx = self.idx(ln, Variable(0u));\n         let succ_base_idx = self.idx(succ_ln, Variable(0u));\n         for uint::range(0u, self.ir.num_vars) |var_idx| {\n@@ -827,7 +826,7 @@ pub impl Liveness {\n \n     fn write_vars(&self, wr: io::Writer,\n                   ln: LiveNode,\n-                  test: fn(uint) -> LiveNode) {\n+                  test: &fn(uint) -> LiveNode) {\n         let node_base_idx = self.idx(ln, Variable(0));\n         for uint::range(0, self.ir.num_vars) |var_idx| {\n             let idx = node_base_idx + var_idx;\n@@ -1510,7 +1509,7 @@ pub impl Liveness {\n     fn with_loop_nodes<R>(&self, loop_node_id: node_id,\n                           break_ln: LiveNode,\n                           cont_ln: LiveNode,\n-                          f: fn() -> R) -> R {\n+                          f: &fn() -> R) -> R {\n       debug!(\"with_loop_nodes: %d %u\", loop_node_id, *break_ln);\n         self.loop_scope.push(loop_node_id);\n         self.break_ln.insert(loop_node_id, break_ln);"}, {"sha": "9e0ecb5a218595ad934aeda074b50544326b1e63", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -856,7 +856,7 @@ pub impl mem_categorization_ctxt {\n     fn cat_pattern(&self,\n                    cmt: cmt,\n                    pat: @ast::pat,\n-                   op: fn(cmt, @ast::pat))\n+                   op: &fn(cmt, @ast::pat))\n     {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against."}, {"sha": "4522977a4ab1293b3c0d45888afca7d56206161b", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -72,7 +72,7 @@ pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: @pat) -> bool {\n }\n \n pub fn pat_bindings(dm: resolve::DefMap, pat: @pat,\n-                it: fn(binding_mode, node_id, span, @path)) {\n+                it: &fn(binding_mode, node_id, span, @path)) {\n     do walk_pat(pat) |p| {\n         match p.node {\n           pat_ident(binding_mode, pth, _) if pat_is_binding(dm, p) => {"}, {"sha": "7ac559161af4fe47ffbfa5dbcb75a223c2642aac", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -3241,7 +3241,7 @@ pub impl Resolver {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n-    fn with_scope(@mut self, name: Option<ident>, f: fn()) {\n+    fn with_scope(@mut self, name: Option<ident>, f: &fn()) {\n         let orig_module = self.current_module;\n \n         // Move down in the graph.\n@@ -3661,7 +3661,7 @@ pub impl Resolver {\n \n     fn with_type_parameter_rib(@mut self,\n                                type_parameters: TypeParameters,\n-                               f: fn()) {\n+                               f: &fn()) {\n         match type_parameters {\n             HasTypeParameters(generics, node_id, initial_index,\n                               rib_kind) => {\n@@ -3702,13 +3702,13 @@ pub impl Resolver {\n         }\n     }\n \n-    fn with_label_rib(@mut self, f: fn()) {\n+    fn with_label_rib(@mut self, f: &fn()) {\n         self.label_ribs.push(@Rib(NormalRibKind));\n         f();\n         self.label_ribs.pop();\n     }\n \n-    fn with_constant_rib(@mut self, f: fn()) {\n+    fn with_constant_rib(@mut self, f: &fn()) {\n         self.value_ribs.push(@Rib(ConstantItemRibKind));\n         f();\n         self.value_ribs.pop();"}, {"sha": "d4ed0004c8f9be66c3e7edbdf93f764ae7073dc0", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -728,8 +728,8 @@ pub fn cast_shift_const_rhs(op: ast::binop,\n \n pub fn cast_shift_rhs(op: ast::binop,\n                       lhs: ValueRef, rhs: ValueRef,\n-                      trunc: fn(ValueRef, TypeRef) -> ValueRef,\n-                      zext: fn(ValueRef, TypeRef) -> ValueRef)\n+                      trunc: &fn(ValueRef, TypeRef) -> ValueRef,\n+                      zext: &fn(ValueRef, TypeRef) -> ValueRef)\n                    -> ValueRef {\n     // Shifts may have any size int on the rhs\n     unsafe {\n@@ -863,7 +863,7 @@ pub fn have_cached_lpad(bcx: block) -> bool {\n     return res;\n }\n \n-pub fn in_lpad_scope_cx(bcx: block, f: fn(+si: &mut scope_info)) {\n+pub fn in_lpad_scope_cx(bcx: block, f: &fn(+si: &mut scope_info)) {\n     let mut bcx = bcx;\n     loop {\n         {\n@@ -1326,7 +1326,7 @@ pub fn leave_block(bcx: block, out_of: block) -> block {\n pub fn with_scope(bcx: block,\n                   opt_node_info: Option<NodeInfo>,\n                   +name: ~str,\n-                  f: fn(block) -> block) -> block {\n+                  f: &fn(block) -> block) -> block {\n     let _icx = bcx.insn_ctxt(\"with_scope\");\n \n     debug!(\"with_scope(bcx=%s, opt_node_info=%?, name=%s)\",\n@@ -1341,7 +1341,7 @@ pub fn with_scope(bcx: block,\n pub fn with_scope_result(bcx: block,\n                          opt_node_info: Option<NodeInfo>,\n                          +name: ~str,\n-                         f: fn(block) -> Result) -> Result {\n+                         f: &fn(block) -> Result) -> Result {\n     let _icx = bcx.insn_ctxt(\"with_scope_result\");\n     let scope_cx = scope_block(bcx, opt_node_info, name);\n     Br(bcx, scope_cx.llbb);\n@@ -1350,7 +1350,7 @@ pub fn with_scope_result(bcx: block,\n }\n \n pub fn with_scope_datumblock(bcx: block, opt_node_info: Option<NodeInfo>,\n-                             +name: ~str, f: fn(block) -> datum::DatumBlock)\n+                             +name: ~str, f: &fn(block) -> datum::DatumBlock)\n                           -> datum::DatumBlock {\n     use middle::trans::datum::DatumBlock;\n \n@@ -1361,7 +1361,7 @@ pub fn with_scope_datumblock(bcx: block, opt_node_info: Option<NodeInfo>,\n     DatumBlock {bcx: leave_block(bcx, scope_cx), datum: datum}\n }\n \n-pub fn block_locals(b: &ast::blk, it: fn(@ast::local)) {\n+pub fn block_locals(b: &ast::blk, it: &fn(@ast::local)) {\n     for vec::each(b.node.stmts) |s| {\n         match s.node {\n           ast::stmt_decl(d, _) => {\n@@ -1401,7 +1401,7 @@ pub fn alloc_local(cx: block, local: @ast::local) -> block {\n }\n \n \n-pub fn with_cond(bcx: block, val: ValueRef, f: fn(block) -> block) -> block {\n+pub fn with_cond(bcx: block, val: ValueRef, f: &fn(block) -> block) -> block {\n     let _icx = bcx.insn_ctxt(\"with_cond\");\n     let next_cx = base::sub_block(bcx, ~\"next\");\n     let cond_cx = base::sub_block(bcx, ~\"cond\");\n@@ -1742,8 +1742,8 @@ pub fn trans_closure(ccx: @CrateContext,\n                      param_substs: Option<@param_substs>,\n                      id: ast::node_id,\n                      impl_id: Option<ast::def_id>,\n-                     maybe_load_env: fn(fn_ctxt),\n-                     finish: fn(block)) {\n+                     maybe_load_env: &fn(fn_ctxt),\n+                     finish: &fn(block)) {\n     ccx.stats.n_closures += 1;\n     let _icx = ccx.insn_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);"}, {"sha": "7e159ef606242853ef4adc63efb6755768327de0", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -37,7 +37,7 @@ pub struct FnType {\n }\n \n pub impl FnType {\n-    fn decl_fn(&self, decl: fn(fnty: TypeRef) -> ValueRef) -> ValueRef {\n+    fn decl_fn(&self, decl: &fn(fnty: TypeRef) -> ValueRef) -> ValueRef {\n         let atys = vec::map(self.arg_tys, |t| t.ty);\n         let rty = self.ret_ty.ty;\n         let fnty = T_fn(atys, rty);"}, {"sha": "d5877ec563123fa79ad68d98da935897b3ac9f61", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -346,7 +346,7 @@ fn x86_64_tys(atys: &[TypeRef],\n     }\n \n     fn x86_64_ty(ty: TypeRef,\n-                 is_mem_cls: fn(cls: &[x86_64_reg_class]) -> bool,\n+                 is_mem_cls: &fn(cls: &[x86_64_reg_class]) -> bool,\n                  attr: Attribute) -> (LLVMType, Option<Attribute>) {\n         let mut cast = false;\n         let mut ty_attr = option::None;"}, {"sha": "9e38252dc9a8ad5a25e7255ac4c6a68313148748", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -438,7 +438,7 @@ pub fn trans_call_inner(\n     call_info: Option<NodeInfo>,\n     fn_expr_ty: ty::t,\n     ret_ty: ty::t,\n-    get_callee: fn(block) -> Callee,\n+    get_callee: &fn(block) -> Callee,\n     args: CallArgs,\n     dest: expr::Dest,\n     autoref_arg: AutorefArg) -> block {"}, {"sha": "11d3e1552028fe5144dc1f5065b36f3ffe2adf13", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -515,7 +515,7 @@ pub impl Datum {\n     fn get_element(&self, bcx: block,\n                    ty: ty::t,\n                    source: DatumCleanup,\n-                   gep: fn(ValueRef) -> ValueRef) -> Datum {\n+                   gep: &fn(ValueRef) -> ValueRef) -> Datum {\n         let base_val = self.to_ref_llval(bcx);\n         Datum {\n             val: gep(base_val),"}, {"sha": "af54d4734314c1d6ea8c63550ef6a2424d61d998", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -190,7 +190,7 @@ fn md_from_metadata<T>(val: debug_metadata) -> T {\n \n fn cached_metadata<T:Copy>(cache: metadata_cache,\n                             mdtag: int,\n-                            eq_fn: fn(md: T) -> bool)\n+                            eq_fn: &fn(md: T) -> bool)\n                          -> Option<T> {\n     unsafe {\n         if cache.contains_key(&mdtag) {"}, {"sha": "e38b0be7bccba6b280d4659d110a3db37c4c9792", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -1135,7 +1135,7 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n pub fn with_field_tys<R>(tcx: ty::ctxt,\n                          ty: ty::t,\n                          node_id_opt: Option<ast::node_id>,\n-                         op: fn(int, (&[ty::field])) -> R) -> R {\n+                         op: &fn(int, (&[ty::field])) -> R) -> R {\n     match ty::get(ty).sty {\n         ty::ty_struct(did, ref substs) => {\n             op(0, struct_mutable_fields(tcx, did, substs))"}, {"sha": "b4ef87491a8a324ded3850bfbc24736730df023c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -582,18 +582,20 @@ pub enum param_bound {\n }\n \n #[deriving_eq]\n-pub enum TyVid = uint;\n+pub struct TyVid(uint);\n \n #[deriving_eq]\n-pub enum IntVid = uint;\n+pub struct IntVid(uint);\n \n #[deriving_eq]\n-pub enum FloatVid = uint;\n+pub struct FloatVid(uint);\n \n #[deriving_eq]\n #[auto_encode]\n #[auto_decode]\n-pub enum RegionVid = uint;\n+pub struct RegionVid {\n+    id: uint\n+}\n \n #[deriving_eq]\n pub enum InferTy {\n@@ -687,11 +689,11 @@ impl ToStr for FloatVid {\n }\n \n impl Vid for RegionVid {\n-    pure fn to_uint(&self) -> uint { **self }\n+    pure fn to_uint(&self) -> uint { self.id }\n }\n \n impl ToStr for RegionVid {\n-    pure fn to_str(&self) -> ~str { fmt!(\"%?\", self) }\n+    pure fn to_str(&self) -> ~str { fmt!(\"%?\", self.id) }\n }\n \n impl ToStr for FnSig {\n@@ -1138,11 +1140,11 @@ pub fn encl_region(cx: ctxt, id: ast::node_id) -> ty::Region {\n     }\n }\n \n-pub fn walk_ty(ty: t, f: fn(t)) {\n+pub fn walk_ty(ty: t, f: &fn(t)) {\n     maybe_walk_ty(ty, |t| { f(t); true });\n }\n \n-pub fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n+pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n     if !f(ty) { return; }\n     match /*bad*/copy get(ty).sty {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n@@ -1170,11 +1172,11 @@ pub fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n     }\n }\n \n-pub fn fold_sty_to_ty(tcx: ty::ctxt, sty: &sty, foldop: fn(t) -> t) -> t {\n+pub fn fold_sty_to_ty(tcx: ty::ctxt, sty: &sty, foldop: &fn(t) -> t) -> t {\n     mk_t(tcx, fold_sty(sty, foldop))\n }\n \n-pub fn fold_sig(sig: &FnSig, fldop: fn(t) -> t) -> FnSig {\n+pub fn fold_sig(sig: &FnSig, fldop: &fn(t) -> t) -> FnSig {\n     let args = do sig.inputs.map |arg| {\n         arg { mode: arg.mode, ty: fldop(arg.ty) }\n     };\n@@ -1185,8 +1187,8 @@ pub fn fold_sig(sig: &FnSig, fldop: fn(t) -> t) -> FnSig {\n     }\n }\n \n-fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n-    fn fold_substs(substs: &substs, fldop: fn(t) -> t) -> substs {\n+fn fold_sty(sty: &sty, fldop: &fn(t) -> t) -> sty {\n+    fn fold_substs(substs: &substs, fldop: &fn(t) -> t) -> substs {\n         substs {self_r: substs.self_r,\n                 self_ty: substs.self_ty.map(|t| fldop(*t)),\n                 tps: substs.tps.map(|t| fldop(*t))}\n@@ -1241,16 +1243,16 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n }\n \n // Folds types from the bottom up.\n-pub fn fold_ty(cx: ctxt, t0: t, fldop: fn(t) -> t) -> t {\n+pub fn fold_ty(cx: ctxt, t0: t, fldop: &fn(t) -> t) -> t {\n     let sty = fold_sty(&get(t0).sty, |t| fold_ty(cx, fldop(t), fldop));\n     fldop(mk_t(cx, sty))\n }\n \n pub fn walk_regions_and_ty(\n     cx: ctxt,\n     ty: t,\n-    walkr: fn(r: Region),\n-    walkt: fn(t: t) -> bool) {\n+    walkr: &fn(r: Region),\n+    walkt: &fn(t: t) -> bool) {\n \n     if (walkt(ty)) {\n         fold_regions_and_ty(\n@@ -1264,14 +1266,14 @@ pub fn walk_regions_and_ty(\n pub fn fold_regions_and_ty(\n     cx: ctxt,\n     ty: t,\n-    fldr: fn(r: Region) -> Region,\n-    fldfnt: fn(t: t) -> t,\n-    fldt: fn(t: t) -> t) -> t {\n+    fldr: &fn(r: Region) -> Region,\n+    fldfnt: &fn(t: t) -> t,\n+    fldt: &fn(t: t) -> t) -> t {\n \n     fn fold_substs(\n         substs: &substs,\n-        fldr: fn(r: Region) -> Region,\n-        fldt: fn(t: t) -> t)\n+        fldr: &fn(r: Region) -> Region,\n+        fldt: &fn(t: t) -> t)\n      -> substs {\n         substs {\n             self_r: substs.self_r.map(|r| fldr(*r)),\n@@ -1325,9 +1327,9 @@ pub fn fold_regions_and_ty(\n pub fn fold_regions(\n     cx: ctxt,\n     ty: t,\n-    fldr: fn(r: Region, in_fn: bool) -> Region) -> t {\n+    fldr: &fn(r: Region, in_fn: bool) -> Region) -> t {\n     fn do_fold(cx: ctxt, ty: t, in_fn: bool,\n-               fldr: fn(Region, bool) -> Region) -> t {\n+               fldr: &fn(Region, bool) -> Region) -> t {\n         debug!(\"do_fold(ty=%s, in_fn=%b)\", ty_to_str(cx, ty), in_fn);\n         if !type_has_regions(ty) { return ty; }\n         fold_regions_and_ty(\n@@ -2274,7 +2276,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n \n pub fn type_structurally_contains(cx: ctxt,\n                                   ty: t,\n-                                  test: fn(x: &sty) -> bool)\n+                                  test: &fn(x: &sty) -> bool)\n                                -> bool {\n     let sty = &get(ty).sty;\n     debug!(\"type_structurally_contains: %s\",\n@@ -4008,7 +4010,7 @@ pub fn struct_fields(cx: ctxt,\n fn struct_item_fields(cx:ctxt,\n                      did: ast::def_id,\n                      substs: &substs,\n-                     frob_mutability: fn(struct_mutability) -> mutability)\n+                     frob_mutability: &fn(struct_mutability) -> mutability)\n     -> ~[field] {\n     do lookup_struct_fields(cx, did).map |f| {\n        // consider all instance vars mut, because the"}, {"sha": "6c27decc283451d251e8819f69a726e79acb921b", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -36,7 +36,7 @@\n  * scopes and (b) the default region may change.  To understand case (a),\n  * consider something like:\n  *\n- *   type foo = { x: &a.int, y: fn(&a.int) }\n+ *   type foo = { x: &a.int, y: &fn(&a.int) }\n  *\n  * The type of `x` is an error because there is no region `a` in scope.\n  * In the type of `y`, however, region `a` is considered a bound region\n@@ -224,7 +224,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n         rscope: &RS,\n         a_seq_ty: ast::mt,\n         vst: ty::vstore,\n-        constr: fn(ty::mt) -> ty::t) -> ty::t\n+        constr: &fn(ty::mt) -> ty::t) -> ty::t\n     {\n         let tcx = self.tcx();\n "}, {"sha": "1bb71c156c3dc346ef0d73e8f228ee783d8032d6", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -33,7 +33,7 @@ pub fn subtype(fcx: @mut FnCtxt, sp: span, expected: ty::t, actual: ty::t) {\n pub fn suptype_with_fn(fcx: @mut FnCtxt,\n                        sp: span, b_is_expected: bool,\n                        ty_a: ty::t, ty_b: ty::t,\n-                       handle_err: fn(span, ty::t, ty::t, &ty::type_err)) {\n+                       handle_err: &fn(span, ty::t, ty::t, &ty::type_err)) {\n     // n.b.: order of actual, expected is reversed\n     match infer::mk_subty(fcx.infcx(), b_is_expected, sp,\n                           ty_b, ty_a) {"}, {"sha": "d6060c1ae316dec5329b5896c2dd0546d3498eb4", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -105,17 +105,24 @@ use syntax::ast::{m_const, m_mutbl, m_imm};\n use syntax::ast;\n use syntax::ast_map;\n \n+#[deriving_eq]\n+pub enum CheckTraitsFlag {\n+    CheckTraitsOnly,\n+    CheckTraitsAndInherentMethods,\n+}\n+\n pub fn lookup(\n     fcx: @mut FnCtxt,\n \n     // In a call `a.b::<X, Y, ...>(...)`:\n-    expr: @ast::expr,        // The expression `a.b`.\n-    self_expr: @ast::expr,   // The expression `a`.\n-    callee_id: node_id, // Where to store the type of `a.b`\n-    m_name: ast::ident,      // The ident `b`.\n-    self_ty: ty::t,          // The type of `a`.\n-    supplied_tps: &[ty::t],  // The list of types X, Y, ... .\n-    deref_args: check::DerefArgs)   // Whether we autopointer first.\n+    expr: @ast::expr,                   // The expression `a.b`.\n+    self_expr: @ast::expr,              // The expression `a`.\n+    callee_id: node_id,                 // Where to store the type of `a.b`\n+    m_name: ast::ident,                 // The ident `b`.\n+    self_ty: ty::t,                     // The type of `a`.\n+    supplied_tps: &[ty::t],             // The list of types X, Y, ... .\n+    deref_args: check::DerefArgs,       // Whether we autopointer first.\n+    check_traits: CheckTraitsFlag)      // Whether we check traits only.\n     -> Option<method_map_entry>\n {\n     let lcx = LookupContext {\n@@ -129,6 +136,7 @@ pub fn lookup(\n         inherent_candidates: @mut ~[],\n         extension_candidates: @mut ~[],\n         deref_args: deref_args,\n+        check_traits: check_traits,\n     };\n     let mme = lcx.do_lookup(self_ty);\n     debug!(\"method lookup for %s yielded %?\",\n@@ -147,6 +155,7 @@ pub struct LookupContext {\n     inherent_candidates: @mut ~[Candidate],\n     extension_candidates: @mut ~[Candidate],\n     deref_args: check::DerefArgs,\n+    check_traits: CheckTraitsFlag,\n }\n \n /**\n@@ -299,7 +308,9 @@ pub impl LookupContext/&self {\n                         self_ty, self_did, &substs);\n                 }\n                 ty_enum(did, _) | ty_struct(did, _) => {\n-                    self.push_inherent_impl_candidates_for_type(did);\n+                    if self.check_traits == CheckTraitsAndInherentMethods {\n+                        self.push_inherent_impl_candidates_for_type(did);\n+                    }\n                 }\n                 _ => { /* No inherent methods in these types */ }\n             }"}, {"sha": "6617fa3b27c91653aee24434766e2beb24db795f", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -89,7 +89,8 @@ use middle::typeck::astconv::{AstConv, ast_path_to_ty};\n use middle::typeck::astconv::{ast_region_to_region, ast_ty_to_ty};\n use middle::typeck::astconv;\n use middle::typeck::check::_match::pat_ctxt;\n-use middle::typeck::check::method::TransformTypeNormally;\n+use middle::typeck::check::method::{CheckTraitsAndInherentMethods};\n+use middle::typeck::check::method::{CheckTraitsOnly, TransformTypeNormally};\n use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n use middle::typeck::check::vtable::{LocationInfo, VtableContext};\n use middle::typeck::CrateCtxt;\n@@ -1142,7 +1143,7 @@ pub fn break_here() {\n pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                expr: @ast::expr,\n                                expected: Option<ty::t>,\n-                               unifier: fn()) -> bool {\n+                               unifier: &fn()) -> bool {\n     debug!(\">> typechecking %s\", fcx.expr_to_str(expr));\n \n     // A generic function to factor out common logic from call and\n@@ -1371,7 +1372,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                              method_name,\n                              expr_t,\n                              tps,\n-                             DontDerefArgs) {\n+                             DontDerefArgs,\n+                             CheckTraitsAndInherentMethods) {\n             Some(ref entry) => {\n                 let method_map = fcx.ccx.method_map;\n                 method_map.insert(expr.id, (*entry));\n@@ -1453,9 +1455,15 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         +args: ~[@ast::expr],\n                         +deref_args: DerefArgs)\n                      -> Option<(ty::t, bool)> {\n-        match method::lookup(fcx, op_ex, self_ex,\n-                             op_ex.callee_id, opname, self_t, ~[],\n-                             deref_args) {\n+        match method::lookup(fcx,\n+                             op_ex,\n+                             self_ex,\n+                             op_ex.callee_id,\n+                             opname,\n+                             self_t,\n+                             ~[],\n+                             deref_args,\n+                             CheckTraitsOnly) {\n           Some(ref origin) => {\n               let method_ty = fcx.node_ty(op_ex.callee_id);\n               let method_map = fcx.ccx.method_map;\n@@ -1602,7 +1610,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     // returns `none`.\n     fn unpack_expected<O:Copy>(fcx: @mut FnCtxt,\n                                 expected: Option<ty::t>,\n-                                unpack: fn(&ty::sty) -> Option<O>)\n+                                unpack: &fn(&ty::sty) -> Option<O>)\n                              -> Option<O> {\n         match expected {\n             Some(t) => {\n@@ -1732,7 +1740,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                              field,\n                              expr_t,\n                              tps,\n-                             DontDerefArgs) {\n+                             DontDerefArgs,\n+                             CheckTraitsAndInherentMethods) {\n             Some(ref entry) => {\n                 let method_map = fcx.ccx.method_map;\n                 method_map.insert(expr.id, (*entry));"}, {"sha": "98f49e48c08491fed70ba22591415b954e9d2a4c", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -30,7 +30,7 @@ pub fn replace_bound_regions_in_fn_sig(\n     isr: isr_alist,\n     self_info: Option<SelfInfo>,\n     fn_sig: &ty::FnSig,\n-    mapf: fn(ty::bound_region) -> ty::Region) ->\n+    mapf: &fn(ty::bound_region) -> ty::Region) ->\n     (isr_alist, Option<SelfInfo>, ty::FnSig) {\n     // Take self_info apart; the self_ty part is the only one we want\n     // to update here.\n@@ -96,7 +96,7 @@ pub fn replace_bound_regions_in_fn_sig(\n         tcx: ty::ctxt,\n         isr: isr_alist,\n         tys: ~[ty::t],\n-        to_r: fn(ty::bound_region) -> ty::Region) -> isr_alist {\n+        to_r: &fn(ty::bound_region) -> ty::Region) -> isr_alist {\n \n         // Takes `isr` (described above), `to_r` (described above),\n         // and `r`, a region.  If `r` is anything other than a bound\n@@ -106,7 +106,7 @@ pub fn replace_bound_regions_in_fn_sig(\n         // updated isr_alist that now contains a mapping from `r` to\n         // the result of calling `to_r` on it.\n         fn append_isr(isr: isr_alist,\n-                      to_r: fn(ty::bound_region) -> ty::Region,\n+                      to_r: &fn(ty::bound_region) -> ty::Region,\n                       r: ty::Region) -> isr_alist {\n             match r {\n               ty::re_free(_, _) | ty::re_static | ty::re_scope(_) |"}, {"sha": "91c987acc6aa725b976b940879e7b50348113cb5", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -84,7 +84,7 @@ use syntax::ast;\n // Note: Coerce is not actually a combiner, in that it does not\n // conform to the same interface, though it performs a similar\n // function.\n-pub enum Coerce = CombineFields;\n+pub struct Coerce(CombineFields);\n \n pub impl Coerce {\n     fn tys(&self, a: ty::t, b: ty::t) -> CoerceResult {"}, {"sha": "bba35f02b0c1e0eab79bc096545d769d63956dd2", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -29,7 +29,7 @@ use util::ppaux::mt_to_str;\n \n use std::list;\n \n-pub enum Glb = CombineFields;  // \"greatest lower bound\" (common subtype)\n+pub struct Glb(CombineFields);  // \"greatest lower bound\" (common subtype)\n \n impl Combine for Glb {\n     fn infcx(&self) -> @mut InferCtxt { self.infcx }\n@@ -228,7 +228,7 @@ impl Combine for Glb {\n                 // NB---I do not believe this algorithm computes\n                 // (necessarily) the GLB.  As written it can\n                 // spuriously fail.  In particular, if there is a case\n-                // like: fn(fn(&a)) and fn(fn(&b)), where a and b are\n+                // like: &fn(fn(&a)) and fn(fn(&b)), where a and b are\n                 // free, it will return fn(&c) where c = GLB(a,b).  If\n                 // however this GLB is not defined, then the result is\n                 // an error, even though something like"}, {"sha": "3a12fb31a1a6f70f2eba5f319e04ad6fdf7cc483", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -29,7 +29,7 @@ use syntax::ast::{pure_fn, ret_style, return_val, unsafe_fn};\n use syntax::ast::{Onceness, purity};\n use syntax::codemap::span;\n \n-pub enum Lub = CombineFields;  // least-upper-bound: common supertype\n+pub struct Lub(CombineFields);  // least-upper-bound: common supertype\n \n pub impl Lub {\n     fn bot_ty(&self, b: ty::t) -> cres<ty::t> { Ok(b) }"}, {"sha": "f68a0db63870b9895952c47299f9a6f4165b7f30", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -481,12 +481,12 @@ fn resolve_borrowings(cx: @mut InferCtxt) {\n */\n \n trait then {\n-    fn then<T:Copy>(&self, f: fn() -> Result<T,ty::type_err>)\n+    fn then<T:Copy>(&self, f: &fn() -> Result<T,ty::type_err>)\n         -> Result<T,ty::type_err>;\n }\n \n impl then for ures {\n-    fn then<T:Copy>(&self, f: fn() -> Result<T,ty::type_err>)\n+    fn then<T:Copy>(&self, f: &fn() -> Result<T,ty::type_err>)\n         -> Result<T,ty::type_err> {\n         self.chain(|_i| f())\n     }\n@@ -506,11 +506,11 @@ impl<T> ToUres for cres<T> {\n }\n \n trait CresCompare<T> {\n-    fn compare(&self, t: T, f: fn() -> ty::type_err) -> cres<T>;\n+    fn compare(&self, t: T, f: &fn() -> ty::type_err) -> cres<T>;\n }\n \n impl<T:Copy + Eq> CresCompare<T> for cres<T> {\n-    fn compare(&self, t: T, f: fn() -> ty::type_err) -> cres<T> {\n+    fn compare(&self, t: T, f: &fn() -> ty::type_err) -> cres<T> {\n         do self.chain |s| {\n             if s == t {\n                 *self\n@@ -584,7 +584,7 @@ pub impl @mut InferCtxt {\n     }\n \n     /// Execute `f` and commit the bindings if successful\n-    fn commit<T,E>(&self, f: fn() -> Result<T,E>) -> Result<T,E> {\n+    fn commit<T,E>(&self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n         fail_unless!(!self.in_snapshot());\n \n         debug!(\"commit()\");\n@@ -599,7 +599,7 @@ pub impl @mut InferCtxt {\n     }\n \n     /// Execute `f`, unroll bindings on failure\n-    fn try<T,E>(&self, f: fn() -> Result<T,E>) -> Result<T,E> {\n+    fn try<T,E>(&self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n         debug!(\"try()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n@@ -613,7 +613,7 @@ pub impl @mut InferCtxt {\n     }\n \n     /// Execute `f` then unroll any bindings it creates\n-    fn probe<T,E>(&self, f: fn() -> Result<T,E>) -> Result<T,E> {\n+    fn probe<T,E>(&self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n         debug!(\"probe()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n@@ -706,7 +706,7 @@ pub impl @mut InferCtxt {\n         }\n     }\n \n-    fn type_error_message(&self, sp: span, mk_msg: fn(~str) -> ~str,\n+    fn type_error_message(&self, sp: span, mk_msg: &fn(~str) -> ~str,\n                           actual_ty: ty::t, err: Option<&ty::type_err>) {\n         let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n "}, {"sha": "33e953b6218d99357b06f823cb879df86b3b01b7", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -153,7 +153,7 @@ The problem we are addressing is that there is a kind of subtyping\n between functions with bound region parameters.  Consider, for\n example, whether the following relation holds:\n \n-    fn(&a/int) <: fn(&b/int)? (Yes, a => b)\n+    fn(&a/int) <: &fn(&b/int)? (Yes, a => b)\n \n The answer is that of course it does.  These two types are basically\n the same, except that in one we used the name `a` and one we used\n@@ -170,7 +170,7 @@ Now let's consider two more function types.  Here, we assume that the\n `self` lifetime is defined somewhere outside and hence is not a\n lifetime parameter bound by the function type (it \"appears free\"):\n \n-    fn<a>(&a/int) <: fn(&self/int)? (Yes, a => self)\n+    fn<a>(&a/int) <: &fn(&self/int)? (Yes, a => self)\n \n This subtyping relation does in fact hold.  To see why, you have to\n consider what subtyping means.  One way to look at `T1 <: T2` is to\n@@ -187,7 +187,7 @@ to the same thing: a function that accepts pointers with any lifetime\n \n So, what if we reverse the order of the two function types, like this:\n \n-    fn(&self/int) <: fn<a>(&a/int)? (No)\n+    fn(&self/int) <: &fn<a>(&a/int)? (No)\n \n Does the subtyping relationship still hold?  The answer of course is\n no.  In this case, the function accepts *only the lifetime `&self`*,\n@@ -196,8 +196,8 @@ accepted any lifetime.\n \n What about these two examples:\n \n-    fn<a,b>(&a/int, &b/int) <: fn<a>(&a/int, &a/int)? (Yes)\n-    fn<a>(&a/int, &a/int) <: fn<a,b>(&a/int, &b/int)? (No)\n+    fn<a,b>(&a/int, &b/int) <: &fn<a>(&a/int, &a/int)? (Yes)\n+    fn<a>(&a/int, &a/int) <: &fn<a,b>(&a/int, &b/int)? (No)\n \n Here, it is true that functions which take two pointers with any two\n lifetimes can be treated as if they only accepted two pointers with\n@@ -221,12 +221,12 @@ Let's walk through some examples and see how this algorithm plays out.\n \n We'll start with the first example, which was:\n \n-    1. fn<a>(&a/T) <: fn<b>(&b/T)?        Yes: a -> b\n+    1. fn<a>(&a/T) <: &fn<b>(&b/T)?        Yes: a -> b\n \n After steps 1 and 2 of the algorithm we will have replaced the types\n like so:\n \n-    1. fn(&A/T) <: fn(&x/T)?\n+    1. fn(&A/T) <: &fn(&x/T)?\n \n Here the upper case `&A` indicates a *region variable*, that is, a\n region whose value is being inferred by the system.  I also replaced\n@@ -255,12 +255,12 @@ So far we have encountered no error, so the subtype check succeeds.\n \n Now let's look first at the third example, which was:\n \n-    3. fn(&self/T)    <: fn<b>(&b/T)?        No!\n+    3. fn(&self/T)    <: &fn<b>(&b/T)?        No!\n \n After steps 1 and 2 of the algorithm we will have replaced the types\n like so:\n \n-    3. fn(&self/T) <: fn(&x/T)?\n+    3. fn(&self/T) <: &fn(&x/T)?\n \n This looks pretty much the same as before, except that on the LHS\n `&self` was not bound, and hence was left as-is and not replaced with\n@@ -275,7 +275,7 @@ You may be wondering about that mysterious last step in the algorithm.\n So far it has not been relevant.  The purpose of that last step is to\n catch something like *this*:\n \n-    fn<a>() -> fn(&a/T) <: fn() -> fn<b>(&b/T)?   No.\n+    fn<a>() -> fn(&a/T) <: &fn() -> fn<b>(&b/T)?   No.\n \n Here the function types are the same but for where the binding occurs.\n The subtype returns a function that expects a value in precisely one\n@@ -289,15 +289,15 @@ So let's step through what happens when we perform this subtype check.\n We first replace the bound regions in the subtype (the supertype has\n no bound regions).  This gives us:\n \n-    fn() -> fn(&A/T) <: fn() -> fn<b>(&b/T)?\n+    fn() -> fn(&A/T) <: &fn() -> fn<b>(&b/T)?\n \n Now we compare the return types, which are covariant, and hence we have:\n \n-    fn(&A/T) <: fn<b>(&b/T)?\n+    fn(&A/T) <: &fn<b>(&b/T)?\n \n Here we skolemize the bound region in the supertype to yield:\n \n-    fn(&A/T) <: fn(&x/T)?\n+    fn(&A/T) <: &fn(&x/T)?\n \n And then proceed to compare the argument types:\n \n@@ -314,7 +314,7 @@ The difference between this example and the first one is that the variable\n `A` already existed at the point where the skolemization occurred.  In\n the first example, you had two functions:\n \n-    fn<a>(&a/T) <: fn<b>(&b/T)\n+    fn<a>(&a/T) <: &fn<b>(&b/T)\n \n and hence `&A` and `&x` were created \"together\".  In general, the\n intention of the skolemized names is that they are supposed to be\n@@ -700,7 +700,7 @@ pub impl RegionVarBindings {\n             match undo_item {\n               Snapshot => {}\n               AddVar(vid) => {\n-                fail_unless!(self.var_spans.len() == *vid + 1);\n+                fail_unless!(self.var_spans.len() == vid.to_uint() + 1);\n                 self.var_spans.pop();\n               }\n               AddConstraint(ref constraint) => {\n@@ -720,7 +720,7 @@ pub impl RegionVarBindings {\n     fn new_region_var(&mut self, span: span) -> RegionVid {\n         let id = self.num_vars();\n         self.var_spans.push(span);\n-        let vid = RegionVid(id);\n+        let vid = RegionVid { id: id };\n         if self.in_snapshot() {\n             self.undo_log.push(AddVar(vid));\n         }\n@@ -863,15 +863,15 @@ pub impl RegionVarBindings {\n     }\n \n     fn resolve_var(&mut self, rid: RegionVid) -> ty::Region {\n-        debug!(\"RegionVarBindings: resolve_var(%?=%u)\", rid, *rid);\n+        debug!(\"RegionVarBindings: resolve_var(%?=%u)\", rid, rid.to_uint());\n         if self.values.is_empty() {\n             self.tcx.sess.span_bug(\n-                self.var_spans[*rid],\n+                self.var_spans[rid.to_uint()],\n                 fmt!(\"Attempt to resolve region variable before values have \\\n                       been computed!\"));\n         }\n \n-        let v = self.values.with_ref(|values| values[*rid]);\n+        let v = self.values.with_ref(|values| values[rid.to_uint()]);\n         match v {\n             Value(r) => r,\n \n@@ -886,13 +886,13 @@ pub impl RegionVarBindings {\n                 // should ultimately have some bounds.\n \n                 self.tcx.sess.span_err(\n-                    self.var_spans[*rid],\n-                    fmt!(\"Unconstrained region variable #%u\", *rid));\n+                    self.var_spans[rid.to_uint()],\n+                    fmt!(\"Unconstrained region variable #%u\", rid.to_uint()));\n \n                 // Touch of a hack: to suppress duplicate messages,\n                 // replace the NoValue entry with ErrorValue.\n                 let mut values = self.values.take();\n-                values[*rid] = ErrorValue;\n+                values[rid.to_uint()] = ErrorValue;\n                 self.values.put_back(values);\n                 re_static\n             }\n@@ -1049,7 +1049,7 @@ priv impl RegionVarBindings {\n \n           (re_infer(ReVar(v_id)), _) | (_, re_infer(ReVar(v_id))) => {\n             self.tcx.sess.span_bug(\n-                self.var_spans[*v_id],\n+                self.var_spans[v_id.to_uint()],\n                 fmt!(\"lub_concrete_regions invoked with \\\n                       non-concrete regions: %?, %?\", a, b));\n           }\n@@ -1111,7 +1111,7 @@ priv impl RegionVarBindings {\n             (re_infer(ReVar(v_id)), _) |\n             (_, re_infer(ReVar(v_id))) => {\n                 self.tcx.sess.span_bug(\n-                    self.var_spans[*v_id],\n+                    self.var_spans[v_id.to_uint()],\n                     fmt!(\"glb_concrete_regions invoked with \\\n                           non-concrete regions: %?, %?\", a, b));\n             }\n@@ -1275,8 +1275,8 @@ pub impl RegionVarBindings {\n                        edge_idx: uint) {\n             let edge_dir = edge_dir as uint;\n             graph.edges[edge_idx].next_edge[edge_dir] =\n-                graph.nodes[*node_id].head_edge[edge_dir];\n-            graph.nodes[*node_id].head_edge[edge_dir] =\n+                graph.nodes[node_id.to_uint()].head_edge[edge_dir];\n+            graph.nodes[node_id.to_uint()].head_edge[edge_dir] =\n                 edge_idx;\n         }\n     }\n@@ -1285,14 +1285,14 @@ pub impl RegionVarBindings {\n         do iterate_until_fixed_point(~\"Expansion\", graph) |nodes, edge| {\n             match edge.constraint {\n               ConstrainRegSubVar(a_region, b_vid) => {\n-                let b_node = &mut nodes[*b_vid];\n+                let b_node = &mut nodes[b_vid.to_uint()];\n                 self.expand_node(a_region, b_vid, b_node)\n               }\n               ConstrainVarSubVar(a_vid, b_vid) => {\n-                match nodes[*a_vid].value {\n+                match nodes[a_vid.to_uint()].value {\n                   NoValue | ErrorValue => false,\n                   Value(a_region) => {\n-                    let b_node = &mut nodes[*b_vid];\n+                    let b_node = &mut nodes[b_vid.to_uint()];\n                     self.expand_node(a_region, b_vid, b_node)\n                   }\n                 }\n@@ -1349,16 +1349,16 @@ pub impl RegionVarBindings {\n                 false\n               }\n               ConstrainVarSubVar(a_vid, b_vid) => {\n-                match nodes[*b_vid].value {\n+                match nodes[b_vid.to_uint()].value {\n                   NoValue | ErrorValue => false,\n                   Value(b_region) => {\n-                    let a_node = &mut nodes[*a_vid];\n+                    let a_node = &mut nodes[a_vid.to_uint()];\n                     self.contract_node(a_vid, a_node, b_region)\n                   }\n                 }\n               }\n               ConstrainVarSubReg(a_vid, b_region) => {\n-                let a_node = &mut nodes[*a_vid];\n+                let a_node = &mut nodes[a_vid.to_uint()];\n                 self.contract_node(a_vid, a_node, b_region)\n               }\n             }\n@@ -1474,7 +1474,7 @@ pub impl RegionVarBindings {\n                        that is not used is not a problem, so if this rule\n                        starts to create problems we'll have to revisit\n                        this portion of the code and think hard about it. =) */\n-                    let node_vid = RegionVid(idx);\n+                    let node_vid = RegionVid { id: idx };\n                     match node.classification {\n                         Expanding => {\n                             self.report_error_for_expanding_node(\n@@ -1525,7 +1525,7 @@ pub impl RegionVarBindings {\n                     }\n \n                     self.tcx.sess.span_err(\n-                        self.var_spans[*node_idx],\n+                        self.var_spans[node_idx.to_uint()],\n                         fmt!(\"cannot infer an appropriate lifetime \\\n                               due to conflicting requirements\"));\n \n@@ -1578,7 +1578,7 @@ pub impl RegionVarBindings {\n                     }\n \n                     self.tcx.sess.span_err(\n-                        self.var_spans[*node_idx],\n+                        self.var_spans[node_idx.to_uint()],\n                         fmt!(\"cannot infer an appropriate lifetime \\\n                               due to conflicting requirements\"));\n \n@@ -1616,7 +1616,7 @@ pub impl RegionVarBindings {\n                              -> ~[SpannedRegion] {\n         let set = HashMap();\n         let mut stack = ~[orig_node_idx];\n-        set.insert(*orig_node_idx, ());\n+        set.insert(orig_node_idx.to_uint(), ());\n         let mut result = ~[];\n         while !vec::is_empty(stack) {\n             let node_idx = stack.pop();\n@@ -1627,7 +1627,7 @@ pub impl RegionVarBindings {\n                       Incoming => from_vid,\n                       Outgoing => to_vid\n                     };\n-                    if set.insert(*vid, ()) {\n+                    if set.insert(vid.to_uint(), ()) {\n                         stack.push(vid);\n                     }\n                   }\n@@ -1657,8 +1657,9 @@ pub impl RegionVarBindings {\n                  graph: &Graph,\n                  node_idx: RegionVid,\n                  dir: Direction,\n-                 op: fn(edge: &GraphEdge) -> bool) {\n-        let mut edge_idx = graph.nodes[*node_idx].head_edge[dir as uint];\n+                 op: &fn(edge: &GraphEdge) -> bool) {\n+        let mut edge_idx =\n+            graph.nodes[node_idx.to_uint()].head_edge[dir as uint];\n         while edge_idx != uint::max_value {\n             let edge_ptr = &graph.edges[edge_idx];\n             if !op(edge_ptr) {"}, {"sha": "b4d8905a93627c2f278ae4dfc227ae27e3769962", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -29,7 +29,7 @@ use syntax::ast::{Onceness, m_const, purity, ret_style};\n use syntax::codemap::span;\n \n \n-pub enum Sub = CombineFields;  // \"subtype\", \"subregion\" etc\n+pub struct Sub(CombineFields);  // \"subtype\", \"subregion\" etc\n \n impl Combine for Sub {\n     fn infcx(&self) -> @mut InferCtxt { self.infcx }"}, {"sha": "abaf658a1a43e9159276aeafda08efca46b70ef2", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -225,7 +225,7 @@ pub fn require_same_types(\n     span: span,\n     t1: ty::t,\n     t2: ty::t,\n-    msg: fn() -> ~str) -> bool {\n+    msg: &fn() -> ~str) -> bool {\n \n     let l_tcx, l_infcx;\n     match maybe_infcx {"}, {"sha": "f74a0960f66749b9245aba6bb39bc4a28ba57be6", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -74,7 +74,8 @@ impl region_scope for MethodRscope {\n     }\n }\n \n-pub enum type_rscope = Option<ty::region_variance>;\n+pub struct type_rscope(Option<ty::region_variance>);\n+\n impl type_rscope {\n     priv fn replacement(&self) -> ty::Region {\n         if self.is_some() {"}, {"sha": "c7945f74f55a54e43803812b340f3e69814cb897", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -17,7 +17,7 @@ use syntax::visit;\n use core::str;\n use std::oldmap::HashMap;\n \n-pub fn indent<R>(op: fn() -> R) -> R {\n+pub fn indent<R>(op: &fn() -> R) -> R {\n     // Use in conjunction with the log post-processor like `src/etc/indenter`\n     // to make debug output more readable.\n     debug!(\">>\");"}, {"sha": "5e5c843da26da610839984beb55cd40540b2999a", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -322,8 +322,7 @@ fn structdoc_from_struct(\n         fields: do struct_def.fields.map |field| {\n             match field.node.kind {\n                 ast::named_field(ident, _, _) => to_str(ident),\n-                ast::unnamed_field => fail!(\n-                    ~\"what is an unnamed struct field?\")\n+                ast::unnamed_field => ~\"(unnamed)\",\n             }\n         },\n         sig: None"}, {"sha": "f5cf98759b3752e7671c0e50ded8cc27e178f138", "filename": "src/librustdoc/rustdoc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustdoc%2Frustdoc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustdoc%2Frustdoc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rc?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -143,7 +143,7 @@ fn run(config: Config) {\n     }\n }\n \n-pub fn time<T>(what: ~str, f: fn() -> T) -> T {\n+pub fn time<T>(what: ~str, f: &fn() -> T) -> T {\n     let start = std::time::precise_time_s();\n     let rv = f();\n     let end = std::time::precise_time_s();"}, {"sha": "0367a771ffbd17b84462eb6bca4ae9b3b59cde06", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -59,7 +59,7 @@ enum CmdAction {\n \n /// A utility function that hands off a pretty printer to a callback.\n fn with_pp(intr: @token::ident_interner,\n-           cb: fn(@pprust::ps, io::Writer)) -> ~str {\n+           cb: &fn(@pprust::ps, io::Writer)) -> ~str {\n     do io::with_str_writer |writer| {\n         let pp = pprust::rust_printer(writer, intr);\n "}, {"sha": "7d2b8eccd6c0e2034b43077d205b8bb05dcadbb7", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -260,7 +260,7 @@ pub fn hash(data: ~str) -> ~str {\n     hasher.result_str()\n }\n \n-pub fn temp_change_dir<T>(dir: &Path, cb: fn() -> T) {\n+pub fn temp_change_dir<T>(dir: &Path, cb: &fn() -> T) {\n     let cwd = os::getcwd();\n \n     os::change_dir(dir);"}, {"sha": "d7d878fa192ddc1edc0a4b082ad5adaeecd06488", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 46, "deletions": 21, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -176,7 +176,7 @@ pub impl<T:Owned> MutexARC<T> {\n      * blocked on the mutex) will also fail immediately.\n      */\n     #[inline(always)]\n-    unsafe fn access<U>(&self, blk: fn(x: &mut T) -> U) -> U {\n+    unsafe fn access<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n         unsafe {\n             let state = get_shared_mutable_state(&self.x);\n             // Borrowck would complain about this if the function were\n@@ -301,7 +301,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n      * poison the ARC, so subsequent readers and writers will both also fail.\n      */\n     #[inline(always)]\n-    fn write<U>(&self, blk: fn(x: &mut T) -> U) -> U {\n+    fn write<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n         unsafe {\n             let state = get_shared_mutable_state(&self.x);\n             do (*borrow_rwlock(state)).write {\n@@ -313,7 +313,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n     }\n     /// As write(), but with a condvar, as sync::rwlock.write_cond().\n     #[inline(always)]\n-    fn write_cond<U>(&self, blk: fn(x: &x/mut T, c: &c/Condvar) -> U) -> U {\n+    fn write_cond<U>(&self, blk: &fn(x: &x/mut T, c: &c/Condvar) -> U) -> U {\n         unsafe {\n             let state = get_shared_mutable_state(&self.x);\n             do (*borrow_rwlock(state)).write_cond |cond| {\n@@ -335,7 +335,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n      * Failing will unlock the ARC while unwinding. However, unlike all other\n      * access modes, this will not poison the ARC.\n      */\n-    fn read<U>(&self, blk: fn(x: &T) -> U) -> U {\n+    fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n         let state = unsafe { get_shared_immutable_state(&self.x) };\n         do (&state.lock).read {\n             check_poison(false, state.failed);\n@@ -360,14 +360,16 @@ pub impl<T:Const + Owned> RWARC<T> {\n      * }\n      * ~~~\n      */\n-    fn write_downgrade<U>(&self, blk: fn(v: RWWriteMode<T>) -> U) -> U {\n+    fn write_downgrade<U>(&self, blk: &fn(v: RWWriteMode<T>) -> U) -> U {\n         unsafe {\n             let state = get_shared_mutable_state(&self.x);\n             do (*borrow_rwlock(state)).write_downgrade |write_mode| {\n                 check_poison(false, (*state).failed);\n-                blk(RWWriteMode((&mut (*state).data,\n-                                 write_mode,\n-                                 PoisonOnFail(&mut (*state).failed))))\n+                blk(RWWriteMode {\n+                    data: &mut (*state).data,\n+                    token: write_mode,\n+                    poison: PoisonOnFail(&mut (*state).failed)\n+                })\n             }\n         }\n     }\n@@ -376,7 +378,11 @@ pub impl<T:Const + Owned> RWARC<T> {\n     fn downgrade(&self, token: RWWriteMode/&a<T>) -> RWReadMode/&a<T> {\n         // The rwlock should assert that the token belongs to us for us.\n         let state = unsafe { get_shared_immutable_state(&self.x) };\n-        let RWWriteMode((data, t, _poison)) = token;\n+        let RWWriteMode {\n+            data: data,\n+            token: t,\n+            poison: _poison\n+        } = token;\n         // Let readers in\n         let new_token = (&state.lock).downgrade(t);\n         // Whatever region the input reference had, it will be safe to use\n@@ -386,7 +392,10 @@ pub impl<T:Const + Owned> RWARC<T> {\n         // Downgrade ensured the token belonged to us. Just a sanity check.\n         fail_unless!(ptr::ref_eq(&state.data, new_data));\n         // Produce new token\n-        RWReadMode((new_data, new_token))\n+        RWReadMode {\n+            data: new_data,\n+            token: new_token,\n+        }\n     }\n }\n \n@@ -398,29 +407,42 @@ fn borrow_rwlock<T:Const + Owned>(state: *const RWARCInner<T>) -> *RWlock {\n     unsafe { cast::transmute(&const (*state).lock) }\n }\n \n-// FIXME (#3154) ice with struct/&<T> prevents these from being structs.\n-\n /// The \"write permission\" token used for RWARC.write_downgrade().\n-pub enum RWWriteMode<T> =\n-    (&self/mut T, sync::RWlockWriteMode/&self, PoisonOnFail);\n+pub struct RWWriteMode<'self, T> {\n+    data: &'self mut T,\n+    token: sync::RWlockWriteMode<'self>,\n+    poison: PoisonOnFail,\n+}\n+\n /// The \"read permission\" token used for RWARC.write_downgrade().\n-pub enum RWReadMode<T> = (&self/T, sync::RWlockReadMode/&self);\n+pub struct RWReadMode<'self, T> {\n+    data: &'self T,\n+    token: sync::RWlockReadMode<'self>,\n+}\n \n pub impl<T:Const + Owned> RWWriteMode/&self<T> {\n     /// Access the pre-downgrade RWARC in write mode.\n-    fn write<U>(&self, blk: fn(x: &mut T) -> U) -> U {\n+    fn write<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n         match *self {\n-            RWWriteMode((ref data, ref token, _)) => {\n+            RWWriteMode {\n+                data: ref data,\n+                token: ref token,\n+                poison: _\n+            } => {\n                 do token.write {\n                     blk(&mut **data)\n                 }\n             }\n         }\n     }\n     /// Access the pre-downgrade RWARC in write mode with a condvar.\n-    fn write_cond<U>(&self, blk: fn(x: &x/mut T, c: &c/Condvar) -> U) -> U {\n+    fn write_cond<U>(&self, blk: &fn(x: &x/mut T, c: &c/Condvar) -> U) -> U {\n         match *self {\n-            RWWriteMode((ref data, ref token, ref poison)) => {\n+            RWWriteMode {\n+                data: ref data,\n+                token: ref token,\n+                poison: ref poison\n+            } => {\n                 do token.write_cond |cond| {\n                     unsafe {\n                         let cvar = Condvar {\n@@ -438,9 +460,12 @@ pub impl<T:Const + Owned> RWWriteMode/&self<T> {\n \n pub impl<T:Const + Owned> RWReadMode/&self<T> {\n     /// Access the post-downgrade rwlock in read mode.\n-    fn read<U>(&self, blk: fn(x: &T) -> U) -> U {\n+    fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n         match *self {\n-            RWReadMode((data, ref token)) => {\n+            RWReadMode {\n+                data: data,\n+                token: ref token\n+            } => {\n                 do token.read { blk(data) }\n             }\n         }"}, {"sha": "695b3d01376c3e1cece1cf9907afc218538a8a84", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -201,7 +201,7 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    fn alloc_pod<T>(&self, op: fn() -> T) -> &self/T {\n+    fn alloc_pod<T>(&self, op: &fn() -> T) -> &self/T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n@@ -246,7 +246,7 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    fn alloc_nonpod<T>(&self, op: fn() -> T) -> &self/T {\n+    fn alloc_nonpod<T>(&self, op: &fn() -> T) -> &self/T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let (ty_ptr, ptr) =\n@@ -268,7 +268,7 @@ pub impl Arena {\n \n     // The external interface\n     #[inline(always)]\n-    fn alloc<T>(&self, op: fn() -> T) -> &self/T {\n+    fn alloc<T>(&self, op: &fn() -> T) -> &self/T {\n         unsafe {\n             if !rusti::needs_drop::<T>() {\n                 self.alloc_pod(op)"}, {"sha": "8dbdb83698c6f2eb4c80c46e412fd6554e894a68", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -33,7 +33,7 @@ pub impl SmallBitv {\n \n     #[inline(always)]\n     fn bits_op(&mut self, right_bits: uint, nbits: uint,\n-               f: fn(uint, uint) -> uint) -> bool {\n+               f: &fn(uint, uint) -> uint) -> bool {\n         let mask = small_mask(nbits);\n         let old_b: uint = self.bits;\n         let new_b = f(old_b, right_bits);\n@@ -130,7 +130,7 @@ pub impl BigBitv {\n \n     #[inline(always)]\n     fn process(&mut self, b: &BigBitv, nbits: uint,\n-               op: fn(uint, uint) -> uint) -> bool {\n+               op: &fn(uint, uint) -> uint) -> bool {\n         let len = b.storage.len();\n         fail_unless!((self.storage.len() == len));\n         let mut changed = false;\n@@ -148,7 +148,7 @@ pub impl BigBitv {\n     }\n \n     #[inline(always)]\n-    fn each_storage(&mut self, op: fn(v: &mut uint) -> bool) {\n+    fn each_storage(&mut self, op: &fn(v: &mut uint) -> bool) {\n         for uint::range(0, self.storage.len()) |i| {\n             let mut w = self.storage[i];\n             let b = op(&mut w);\n@@ -392,7 +392,7 @@ pub impl Bitv {\n     }\n \n     #[inline(always)]\n-    fn each(&self, f: fn(bool) -> bool) {\n+    fn each(&self, f: &fn(bool) -> bool) {\n         let mut i = 0;\n         while i < self.nbits {\n             if !f(self.get(i)) { break; }\n@@ -493,7 +493,7 @@ pub impl Bitv {\n         true\n     }\n \n-    fn ones(&self, f: fn(uint) -> bool) {\n+    fn ones(&self, f: &fn(uint) -> bool) {\n         for uint::range(0, self.nbits) |i| {\n             if self.get(i) {\n                 if !f(i) { break }\n@@ -546,7 +546,7 @@ pub fn from_bools(bools: &[bool]) -> Bitv {\n  * Create a bitv of the specified length where the value at each\n  * index is f(index).\n  */\n-pub fn from_fn(len: uint, f: fn(index: uint) -> bool) -> Bitv {\n+pub fn from_fn(len: uint, f: &fn(index: uint) -> bool) -> Bitv {\n     let mut bitv = Bitv::new(len, false);\n     for uint::range(0, len) |i| {\n         bitv.set(i, f(i));\n@@ -561,7 +561,7 @@ impl ops::Index<uint,bool> for Bitv {\n }\n \n #[inline(always)]\n-pure fn iterate_bits(base: uint, bits: uint, f: fn(uint) -> bool) -> bool {\n+pure fn iterate_bits(base: uint, bits: uint, f: &fn(uint) -> bool) -> bool {\n     if bits == 0 {\n         return true;\n     }\n@@ -622,7 +622,7 @@ pub impl BitvSet {\n     }\n \n     #[inline(always)]\n-    priv fn other_op(&mut self, other: &BitvSet, f: fn(uint, uint) -> uint) {\n+    priv fn other_op(&mut self, other: &BitvSet, f: &fn(uint, uint) -> uint) {\n         fn nbits(mut w: uint) -> uint {\n             let mut bits = 0;\n             for uint::bits.times {\n@@ -669,7 +669,7 @@ pub impl BitvSet {\n impl BaseIter<uint> for BitvSet {\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n \n-    pure fn each(&self, blk: fn(v: &uint) -> bool) {\n+    pure fn each(&self, blk: &fn(v: &uint) -> bool) {\n         for self.bitv.storage.eachi |i, &w| {\n             if !iterate_bits(i * uint::bits, w, |b| blk(&b)) {\n                 return;\n@@ -778,7 +778,7 @@ impl Set<uint> for BitvSet {\n         other.is_subset(self)\n     }\n \n-    pure fn difference(&self, other: &BitvSet, f: fn(&uint) -> bool) {\n+    pure fn difference(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 & !w2, |b| f(&b)) {\n                 return;\n@@ -791,7 +791,7 @@ impl Set<uint> for BitvSet {\n     }\n \n     pure fn symmetric_difference(&self, other: &BitvSet,\n-                                 f: fn(&uint) -> bool) {\n+                                 f: &fn(&uint) -> bool) {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 ^ w2, |b| f(&b)) {\n                 return;\n@@ -802,15 +802,15 @@ impl Set<uint> for BitvSet {\n         );\n     }\n \n-    pure fn intersection(&self, other: &BitvSet, f: fn(&uint) -> bool) {\n+    pure fn intersection(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 & w2, |b| f(&b)) {\n                 return;\n             }\n         }\n     }\n \n-    pure fn union(&self, other: &BitvSet, f: fn(&uint) -> bool) {\n+    pure fn union(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 | w2, |b| f(&b)) {\n                 return;\n@@ -828,7 +828,7 @@ priv impl BitvSet {\n     /// w1, w2) where the bit location is the number of bits offset so far,\n     /// and w1/w2 are the words coming from the two vectors self, other.\n     pure fn each_common(&self, other: &BitvSet,\n-                        f: fn(uint, uint, uint) -> bool) {\n+                        f: &fn(uint, uint, uint) -> bool) {\n         let min = uint::min(self.bitv.storage.len(),\n                             other.bitv.storage.len());\n         for self.bitv.storage.view(0, min).eachi |i, &w| {\n@@ -846,7 +846,7 @@ priv impl BitvSet {\n     /// is true if the word comes from 'self', and false if it comes from\n     /// 'other'.\n     pure fn each_outlier(&self, other: &BitvSet,\n-                         f: fn(bool, uint, uint) -> bool) {\n+                         f: &fn(bool, uint, uint) -> bool) {\n         let len1 = self.bitv.storage.len();\n         let len2 = other.bitv.storage.len();\n         let min = uint::min(len1, len2);"}, {"sha": "a55d4bc97ec560bc0c2a509e7c172c8e08d5e839", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -142,7 +142,7 @@ pub mod reader {\n         }\n     }\n \n-    pub fn docs(d: Doc, it: fn(uint, Doc) -> bool) {\n+    pub fn docs(d: Doc, it: &fn(uint, Doc) -> bool) {\n         let mut pos = d.start;\n         while pos < d.end {\n             let elt_tag = vuint_at(*d.data, pos);\n@@ -155,7 +155,7 @@ pub mod reader {\n         }\n     }\n \n-    pub fn tagged_docs(d: Doc, tg: uint, it: fn(Doc) -> bool) {\n+    pub fn tagged_docs(d: Doc, tg: uint, it: &fn(Doc) -> bool) {\n         let mut pos = d.start;\n         while pos < d.end {\n             let elt_tag = vuint_at(*d.data, pos);\n@@ -175,7 +175,7 @@ pub mod reader {\n         vec::slice::<u8>(*d.data, d.start, d.end).to_vec()\n     }\n \n-    pub fn with_doc_data<T>(d: Doc, f: fn(x: &[u8]) -> T) -> T {\n+    pub fn with_doc_data<T>(d: Doc, f: &fn(x: &[u8]) -> T) -> T {\n         f(vec::slice(*d.data, d.start, d.end))\n     }\n \n@@ -255,7 +255,7 @@ pub mod reader {\n             r_doc\n         }\n \n-        fn push_doc<T>(&self, d: Doc, f: fn() -> T) -> T {\n+        fn push_doc<T>(&self, d: Doc, f: &fn() -> T) -> T {\n             let old_parent = self.parent;\n             let old_pos = self.pos;\n             self.parent = d;\n@@ -274,7 +274,7 @@ pub mod reader {\n     }\n \n     pub impl Decoder {\n-        fn read_opaque<R>(&self, op: fn(Doc) -> R) -> R {\n+        fn read_opaque<R>(&self, op: &fn(Doc) -> R) -> R {\n             do self.push_doc(self.next_doc(EsOpaque)) {\n                 op(copy self.parent)\n             }\n@@ -321,23 +321,23 @@ pub mod reader {\n         fn read_managed_str(&self) -> @str { fail!(~\"read_managed_str()\"); }\n \n         // Compound types:\n-        fn read_owned<T>(&self, f: fn() -> T) -> T {\n+        fn read_owned<T>(&self, f: &fn() -> T) -> T {\n             debug!(\"read_owned()\");\n             f()\n         }\n \n-        fn read_managed<T>(&self, f: fn() -> T) -> T {\n+        fn read_managed<T>(&self, f: &fn() -> T) -> T {\n             debug!(\"read_managed()\");\n             f()\n         }\n \n-        fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T {\n+        fn read_enum<T>(&self, name: &str, f: &fn() -> T) -> T {\n             debug!(\"read_enum(%s)\", name);\n             self._check_label(name);\n             self.push_doc(self.next_doc(EsEnum), f)\n         }\n \n-        fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T {\n+        fn read_enum_variant<T>(&self, f: &fn(uint) -> T) -> T {\n             debug!(\"read_enum_variant()\");\n             let idx = self._next_uint(EsEnumVid);\n             debug!(\"  idx=%u\", idx);\n@@ -346,12 +346,12 @@ pub mod reader {\n             }\n         }\n \n-        fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T {\n+        fn read_enum_variant_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n             debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n             f()\n         }\n \n-        fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T {\n+        fn read_owned_vec<T>(&self, f: &fn(uint) -> T) -> T {\n             debug!(\"read_owned_vec()\");\n             do self.push_doc(self.next_doc(EsVec)) {\n                 let len = self._next_uint(EsVecLen);\n@@ -360,7 +360,7 @@ pub mod reader {\n             }\n         }\n \n-        fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T {\n+        fn read_managed_vec<T>(&self, f: &fn(uint) -> T) -> T {\n             debug!(\"read_managed_vec()\");\n             do self.push_doc(self.next_doc(EsVec)) {\n                 let len = self._next_uint(EsVecLen);\n@@ -369,33 +369,33 @@ pub mod reader {\n             }\n         }\n \n-        fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n+        fn read_vec_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n             debug!(\"read_vec_elt(idx=%u)\", idx);\n             self.push_doc(self.next_doc(EsVecElt), f)\n         }\n \n-        fn read_rec<T>(&self, f: fn() -> T) -> T {\n+        fn read_rec<T>(&self, f: &fn() -> T) -> T {\n             debug!(\"read_rec()\");\n             f()\n         }\n \n-        fn read_struct<T>(&self, name: &str, _len: uint, f: fn() -> T) -> T {\n+        fn read_struct<T>(&self, name: &str, _len: uint, f: &fn() -> T) -> T {\n             debug!(\"read_struct(name=%s)\", name);\n             f()\n         }\n \n-        fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T {\n+        fn read_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n             debug!(\"read_field(name=%s, idx=%u)\", name, idx);\n             self._check_label(name);\n             f()\n         }\n \n-        fn read_tup<T>(&self, len: uint, f: fn() -> T) -> T {\n+        fn read_tup<T>(&self, len: uint, f: &fn() -> T) -> T {\n             debug!(\"read_tup(len=%u)\", len);\n             f()\n         }\n \n-        fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n+        fn read_tup_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n             debug!(\"read_tup_elt(idx=%u)\", idx);\n             f()\n         }\n@@ -469,7 +469,7 @@ pub mod writer {\n             debug!(\"End tag (size = %u)\", size);\n         }\n \n-        fn wr_tag(&self, tag_id: uint, blk: fn()) {\n+        fn wr_tag(&self, tag_id: uint, blk: &fn()) {\n             self.start_tag(tag_id);\n             blk();\n             self.end_tag();\n@@ -566,7 +566,7 @@ pub mod writer {\n     }\n \n     pub impl Encoder {\n-        fn emit_opaque(&self, f: fn()) {\n+        fn emit_opaque(&self, f: &fn()) {\n             do self.wr_tag(EsOpaque as uint) {\n                 f()\n             }\n@@ -623,49 +623,49 @@ pub mod writer {\n             self.emit_borrowed_str(v)\n         }\n \n-        fn emit_borrowed(&self, f: fn()) { f() }\n-        fn emit_owned(&self, f: fn()) { f() }\n-        fn emit_managed(&self, f: fn()) { f() }\n+        fn emit_borrowed(&self, f: &fn()) { f() }\n+        fn emit_owned(&self, f: &fn()) { f() }\n+        fn emit_managed(&self, f: &fn()) { f() }\n \n-        fn emit_enum(&self, name: &str, f: fn()) {\n+        fn emit_enum(&self, name: &str, f: &fn()) {\n             self._emit_label(name);\n             self.wr_tag(EsEnum as uint, f)\n         }\n         fn emit_enum_variant(&self, _v_name: &str, v_id: uint, _cnt: uint,\n-                             f: fn()) {\n+                             f: &fn()) {\n             self._emit_tagged_uint(EsEnumVid, v_id);\n             self.wr_tag(EsEnumBody as uint, f)\n         }\n-        fn emit_enum_variant_arg(&self, _idx: uint, f: fn()) { f() }\n+        fn emit_enum_variant_arg(&self, _idx: uint, f: &fn()) { f() }\n \n-        fn emit_borrowed_vec(&self, len: uint, f: fn()) {\n+        fn emit_borrowed_vec(&self, len: uint, f: &fn()) {\n             do self.wr_tag(EsVec as uint) {\n                 self._emit_tagged_uint(EsVecLen, len);\n                 f()\n             }\n         }\n \n-        fn emit_owned_vec(&self, len: uint, f: fn()) {\n+        fn emit_owned_vec(&self, len: uint, f: &fn()) {\n             self.emit_borrowed_vec(len, f)\n         }\n \n-        fn emit_managed_vec(&self, len: uint, f: fn()) {\n+        fn emit_managed_vec(&self, len: uint, f: &fn()) {\n             self.emit_borrowed_vec(len, f)\n         }\n \n-        fn emit_vec_elt(&self, _idx: uint, f: fn()) {\n+        fn emit_vec_elt(&self, _idx: uint, f: &fn()) {\n             self.wr_tag(EsVecElt as uint, f)\n         }\n \n-        fn emit_rec(&self, f: fn()) { f() }\n-        fn emit_struct(&self, _name: &str, _len: uint, f: fn()) { f() }\n-        fn emit_field(&self, name: &str, _idx: uint, f: fn()) {\n+        fn emit_rec(&self, f: &fn()) { f() }\n+        fn emit_struct(&self, _name: &str, _len: uint, f: &fn()) { f() }\n+        fn emit_field(&self, name: &str, _idx: uint, f: &fn()) {\n             self._emit_label(name);\n             f()\n         }\n \n-        fn emit_tup(&self, _len: uint, f: fn()) { f() }\n-        fn emit_tup_elt(&self, _idx: uint, f: fn()) { f() }\n+        fn emit_tup(&self, _len: uint, f: &fn()) { f() }\n+        fn emit_tup_elt(&self, _idx: uint, f: &fn()) { f() }\n     }\n \n }"}, {"sha": "735f86b34eca7c5a911f8f6d154027f71594f467", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -61,7 +61,7 @@ pub fn find<K:Eq + Ord,V:Copy>(m: Treemap<K, V>, k: K) -> Option<V> {\n }\n \n /// Visit all pairs in the map in order.\n-pub fn traverse<K, V: Copy>(m: Treemap<K, V>, f: fn(&K, &V)) {\n+pub fn traverse<K, V: Copy>(m: Treemap<K, V>, f: &fn(&K, &V)) {\n     match *m {\n       Empty => (),\n       /*"}, {"sha": "8c6a870b98cd4e3fc3e760f6230a28e07b2e37cc", "filename": "src/libstd/json.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -116,15 +116,15 @@ impl serialize::Encoder for Encoder {\n     fn emit_owned_str(&self, v: &str) { self.emit_borrowed_str(v) }\n     fn emit_managed_str(&self, v: &str) { self.emit_borrowed_str(v) }\n \n-    fn emit_borrowed(&self, f: fn()) { f() }\n-    fn emit_owned(&self, f: fn()) { f() }\n-    fn emit_managed(&self, f: fn()) { f() }\n+    fn emit_borrowed(&self, f: &fn()) { f() }\n+    fn emit_owned(&self, f: &fn()) { f() }\n+    fn emit_managed(&self, f: &fn()) { f() }\n \n-    fn emit_enum(&self, _name: &str, f: fn()) {\n+    fn emit_enum(&self, _name: &str, f: &fn()) {\n         f()\n     }\n \n-    fn emit_enum_variant(&self, name: &str, _id: uint, _cnt: uint, f: fn()) {\n+    fn emit_enum_variant(&self, name: &str, _id: uint, _cnt: uint, f: &fn()) {\n         // encoding of enums is special-cased for Option. Specifically:\n         // Some(34) => 34\n         // None => null\n@@ -160,49 +160,49 @@ impl serialize::Encoder for Encoder {\n         }\n     }\n \n-    fn emit_enum_variant_arg(&self, idx: uint, f: fn()) {\n+    fn emit_enum_variant_arg(&self, idx: uint, f: &fn()) {\n         if (idx != 0) {self.wr.write_char(',');}\n         f();\n     }\n \n-    fn emit_borrowed_vec(&self, _len: uint, f: fn()) {\n+    fn emit_borrowed_vec(&self, _len: uint, f: &fn()) {\n         self.wr.write_char('[');\n         f();\n         self.wr.write_char(']');\n     }\n \n-    fn emit_owned_vec(&self, len: uint, f: fn()) {\n+    fn emit_owned_vec(&self, len: uint, f: &fn()) {\n         self.emit_borrowed_vec(len, f)\n     }\n-    fn emit_managed_vec(&self, len: uint, f: fn()) {\n+    fn emit_managed_vec(&self, len: uint, f: &fn()) {\n         self.emit_borrowed_vec(len, f)\n     }\n-    fn emit_vec_elt(&self, idx: uint, f: fn()) {\n+    fn emit_vec_elt(&self, idx: uint, f: &fn()) {\n         if idx != 0 { self.wr.write_char(','); }\n         f()\n     }\n \n-    fn emit_rec(&self, f: fn()) {\n+    fn emit_rec(&self, f: &fn()) {\n         self.wr.write_char('{');\n         f();\n         self.wr.write_char('}');\n     }\n-    fn emit_struct(&self, _name: &str, _len: uint, f: fn()) {\n+    fn emit_struct(&self, _name: &str, _len: uint, f: &fn()) {\n         self.wr.write_char('{');\n         f();\n         self.wr.write_char('}');\n     }\n-    fn emit_field(&self, name: &str, idx: uint, f: fn()) {\n+    fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n         if idx != 0 { self.wr.write_char(','); }\n         self.wr.write_str(escape_str(name));\n         self.wr.write_char(':');\n         f();\n     }\n \n-    fn emit_tup(&self, len: uint, f: fn()) {\n+    fn emit_tup(&self, len: uint, f: &fn()) {\n         self.emit_borrowed_vec(len, f);\n     }\n-    fn emit_tup_elt(&self, idx: uint, f: fn()) {\n+    fn emit_tup_elt(&self, idx: uint, f: &fn()) {\n         self.emit_vec_elt(idx, f)\n     }\n }\n@@ -251,39 +251,39 @@ impl serialize::Encoder for PrettyEncoder {\n     fn emit_owned_str(&self, v: &str) { self.emit_borrowed_str(v) }\n     fn emit_managed_str(&self, v: &str) { self.emit_borrowed_str(v) }\n \n-    fn emit_borrowed(&self, f: fn()) { f() }\n-    fn emit_owned(&self, f: fn()) { f() }\n-    fn emit_managed(&self, f: fn()) { f() }\n+    fn emit_borrowed(&self, f: &fn()) { f() }\n+    fn emit_owned(&self, f: &fn()) { f() }\n+    fn emit_managed(&self, f: &fn()) { f() }\n \n-    fn emit_enum(&self, name: &str, f: fn()) {\n+    fn emit_enum(&self, name: &str, f: &fn()) {\n         if name != \"option\" { fail!(~\"only supports option enum\") }\n         f()\n     }\n-    fn emit_enum_variant(&self, _name: &str, id: uint, _cnt: uint, f: fn()) {\n+    fn emit_enum_variant(&self, _name: &str, id: uint, _cnt: uint, f: &fn()) {\n         if id == 0 {\n             self.emit_nil();\n         } else {\n             f()\n         }\n     }\n-    fn emit_enum_variant_arg(&self, _idx: uint, f: fn()) {\n+    fn emit_enum_variant_arg(&self, _idx: uint, f: &fn()) {\n         f()\n     }\n \n-    fn emit_borrowed_vec(&self, _len: uint, f: fn()) {\n+    fn emit_borrowed_vec(&self, _len: uint, f: &fn()) {\n         self.wr.write_char('[');\n         self.indent += 2;\n         f();\n         self.indent -= 2;\n         self.wr.write_char(']');\n     }\n-    fn emit_owned_vec(&self, len: uint, f: fn()) {\n+    fn emit_owned_vec(&self, len: uint, f: &fn()) {\n         self.emit_borrowed_vec(len, f)\n     }\n-    fn emit_managed_vec(&self, len: uint, f: fn()) {\n+    fn emit_managed_vec(&self, len: uint, f: &fn()) {\n         self.emit_borrowed_vec(len, f)\n     }\n-    fn emit_vec_elt(&self, idx: uint, f: fn()) {\n+    fn emit_vec_elt(&self, idx: uint, f: &fn()) {\n         if idx == 0 {\n             self.wr.write_char('\\n');\n         } else {\n@@ -293,17 +293,17 @@ impl serialize::Encoder for PrettyEncoder {\n         f()\n     }\n \n-    fn emit_rec(&self, f: fn()) {\n+    fn emit_rec(&self, f: &fn()) {\n         self.wr.write_char('{');\n         self.indent += 2;\n         f();\n         self.indent -= 2;\n         self.wr.write_char('}');\n     }\n-    fn emit_struct(&self, _name: &str, _len: uint, f: fn()) {\n+    fn emit_struct(&self, _name: &str, _len: uint, f: &fn()) {\n         self.emit_rec(f)\n     }\n-    fn emit_field(&self, name: &str, idx: uint, f: fn()) {\n+    fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n         if idx == 0 {\n             self.wr.write_char('\\n');\n         } else {\n@@ -314,10 +314,10 @@ impl serialize::Encoder for PrettyEncoder {\n         self.wr.write_str(\": \");\n         f();\n     }\n-    fn emit_tup(&self, sz: uint, f: fn()) {\n+    fn emit_tup(&self, sz: uint, f: &fn()) {\n         self.emit_borrowed_vec(sz, f);\n     }\n-    fn emit_tup_elt(&self, idx: uint, f: fn()) {\n+    fn emit_tup_elt(&self, idx: uint, f: &fn()) {\n         self.emit_vec_elt(idx, f)\n     }\n }\n@@ -828,23 +828,23 @@ impl serialize::Decoder for Decoder/&self {\n         }\n     }\n \n-    fn read_owned<T>(&self, f: fn() -> T) -> T {\n+    fn read_owned<T>(&self, f: &fn() -> T) -> T {\n         debug!(\"read_owned()\");\n         f()\n     }\n \n-    fn read_managed<T>(&self, f: fn() -> T) -> T {\n+    fn read_managed<T>(&self, f: &fn() -> T) -> T {\n         debug!(\"read_managed()\");\n         f()\n     }\n \n-    fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T {\n+    fn read_enum<T>(&self, name: &str, f: &fn() -> T) -> T {\n         debug!(\"read_enum(%s)\", name);\n         if name != ~\"option\" { fail!(~\"only supports the option enum\") }\n         f()\n     }\n \n-    fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T {\n+    fn read_enum_variant<T>(&self, f: &fn(uint) -> T) -> T {\n         debug!(\"read_enum_variant()\");\n         let idx = match *self.peek() {\n             Null => 0,\n@@ -853,13 +853,13 @@ impl serialize::Decoder for Decoder/&self {\n         f(idx)\n     }\n \n-    fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T {\n+    fn read_enum_variant_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n         debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n         if idx != 0 { fail!(~\"unknown index\") }\n         f()\n     }\n \n-    fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T {\n+    fn read_owned_vec<T>(&self, f: &fn(uint) -> T) -> T {\n         debug!(\"read_owned_vec()\");\n         let len = match *self.peek() {\n             List(ref list) => list.len(),\n@@ -870,7 +870,7 @@ impl serialize::Decoder for Decoder/&self {\n         res\n     }\n \n-    fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T {\n+    fn read_managed_vec<T>(&self, f: &fn(uint) -> T) -> T {\n         debug!(\"read_owned_vec()\");\n         let len = match *self.peek() {\n             List(ref list) => list.len(),\n@@ -881,7 +881,7 @@ impl serialize::Decoder for Decoder/&self {\n         res\n     }\n \n-    fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n+    fn read_vec_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n         debug!(\"read_vec_elt(idx=%u)\", idx);\n         match *self.peek() {\n             List(ref list) => {\n@@ -892,21 +892,21 @@ impl serialize::Decoder for Decoder/&self {\n         }\n     }\n \n-    fn read_rec<T>(&self, f: fn() -> T) -> T {\n+    fn read_rec<T>(&self, f: &fn() -> T) -> T {\n         debug!(\"read_rec()\");\n         let value = f();\n         self.pop();\n         value\n     }\n \n-    fn read_struct<T>(&self, _name: &str, _len: uint, f: fn() -> T) -> T {\n+    fn read_struct<T>(&self, _name: &str, _len: uint, f: &fn() -> T) -> T {\n         debug!(\"read_struct()\");\n         let value = f();\n         self.pop();\n         value\n     }\n \n-    fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T {\n+    fn read_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n         debug!(\"read_rec_field(%s, idx=%u)\", name, idx);\n         let top = self.peek();\n         match *top {\n@@ -929,14 +929,14 @@ impl serialize::Decoder for Decoder/&self {\n         }\n     }\n \n-    fn read_tup<T>(&self, len: uint, f: fn() -> T) -> T {\n+    fn read_tup<T>(&self, len: uint, f: &fn() -> T) -> T {\n         debug!(\"read_tup(len=%u)\", len);\n         let value = f();\n         self.pop();\n         value\n     }\n \n-    fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n+    fn read_tup_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n         debug!(\"read_tup_elt(idx=%u)\", idx);\n         match *self.peek() {\n             List(ref list) => {"}, {"sha": "3a0f299257e096d408890f7a318be6ea8e2bff06", "filename": "src/libstd/list.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -39,7 +39,7 @@ pub pure fn from_vec<T:Copy>(v: &[T]) -> @List<T> {\n  * * z - The initial value\n  * * f - The function to apply\n  */\n-pub fn foldl<T:Copy,U>(z: T, ls: @List<U>, f: fn(&T, &U) -> T) -> T {\n+pub fn foldl<T:Copy,U>(z: T, ls: @List<U>, f: &fn(&T, &U) -> T) -> T {\n     let mut accum: T = z;\n     do iter(ls) |elt| { accum = f(&accum, elt);}\n     accum\n@@ -52,7 +52,7 @@ pub fn foldl<T:Copy,U>(z: T, ls: @List<U>, f: fn(&T, &U) -> T) -> T {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-pub pure fn find<T:Copy>(ls: @List<T>, f: fn(&T) -> bool) -> Option<T> {\n+pub pure fn find<T:Copy>(ls: @List<T>, f: &fn(&T) -> bool) -> Option<T> {\n     let mut ls = ls;\n     loop {\n         ls = match *ls {\n@@ -125,7 +125,7 @@ pure fn push<T:Copy>(ll: &mut @list<T>, vv: T) {\n */\n \n /// Iterate over a list\n-pub pure fn iter<T>(l: @List<T>, f: fn(&T)) {\n+pub pure fn iter<T>(l: @List<T>, f: &fn(&T)) {\n     let mut cur = l;\n     loop {\n         cur = match *cur {\n@@ -139,7 +139,7 @@ pub pure fn iter<T>(l: @List<T>, f: fn(&T)) {\n }\n \n /// Iterate over a list\n-pub pure fn each<T>(l: @List<T>, f: fn(&T) -> bool) {\n+pub pure fn each<T>(l: @List<T>, f: &fn(&T) -> bool) {\n     let mut cur = l;\n     loop {\n         cur = match *cur {"}, {"sha": "df254543512b0833af14c0e3b8e586920749a011", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -105,7 +105,7 @@ pub pure fn md4(msg: &[u8]) -> Quad {\n \n pub pure fn md4_str(msg: &[u8]) -> ~str {\n     let Quad {a, b, c, d} = md4(msg);\n-    pure fn app(a: u32, b: u32, c: u32, d: u32, f: fn(u32)) {\n+    pure fn app(a: u32, b: u32, c: u32, d: u32, f: &fn(u32)) {\n         f(a); f(b); f(c); f(d);\n     }\n     let mut result = ~\"\";"}, {"sha": "18527cfece111499e91d9f77bb64eea449574f11", "filename": "src/libstd/oldmap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -134,7 +134,7 @@ pub mod chained {\n     }\n \n     pub impl<K:Eq + IterBytes + Hash,V> T<K, V> {\n-        pure fn each_entry(&self, blk: fn(@Entry<K,V>) -> bool) {\n+        pure fn each_entry(&self, blk: &fn(@Entry<K,V>) -> bool) {\n             // n.b. we can't use vec::iter() here because self.chains\n             // is stored in a mutable location.\n             let mut i = 0u, n = self.chains.len();\n@@ -236,17 +236,17 @@ pub mod chained {\n             }\n         }\n \n-        pure fn each(&self, blk: fn(key: &K, value: &V) -> bool) {\n+        pure fn each(&self, blk: &fn(key: &K, value: &V) -> bool) {\n             for self.each_entry |entry| {\n                 if !blk(&entry.key, &entry.value) { break; }\n             }\n         }\n \n-        pure fn each_key(&self, blk: fn(key: &K) -> bool) {\n+        pure fn each_key(&self, blk: &fn(key: &K) -> bool) {\n             self.each(|k, _v| blk(k))\n         }\n \n-        pure fn each_value(&self, blk: fn(value: &V) -> bool) {\n+        pure fn each_value(&self, blk: &fn(value: &V) -> bool) {\n             self.each(|_k, v| blk(v))\n         }\n     }\n@@ -260,8 +260,8 @@ pub mod chained {\n             }\n         }\n \n-        fn update_with_key(&self, key: K, newval: V, ff: fn(K, V, V) -> V)\n-                          -> bool {\n+        fn update_with_key(&self, key: K, newval: V, ff: &fn(K, V, V) -> V)\n+                        -> bool {\n /*\n             match self.find(key) {\n                 None            => return self.insert(key, val),\n@@ -312,7 +312,7 @@ pub mod chained {\n             }\n         }\n \n-        fn update(&self, key: K, newval: V, ff: fn(V, V) -> V) -> bool {\n+        fn update(&self, key: K, newval: V, ff: &fn(V, V) -> V) -> bool {\n             return self.update_with_key(key, newval, |_k, v, v1| ff(v,v1));\n         }\n "}, {"sha": "d2d80eb7da80311f8263e380863b5f02a427f23f", "filename": "src/libstd/prettyprint.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Fprettyprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Fprettyprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -98,87 +98,87 @@ impl serialize::Encoder for Serializer {\n         self.wr.write_str(fmt!(\"@%?\", v));\n     }\n \n-    fn emit_borrowed(&self, f: fn()) {\n+    fn emit_borrowed(&self, f: &fn()) {\n         self.wr.write_str(~\"&\");\n         f();\n     }\n \n-    fn emit_owned(&self, f: fn()) {\n+    fn emit_owned(&self, f: &fn()) {\n         self.wr.write_str(~\"~\");\n         f();\n     }\n \n-    fn emit_managed(&self, f: fn()) {\n+    fn emit_managed(&self, f: &fn()) {\n         self.wr.write_str(~\"@\");\n         f();\n     }\n \n-    fn emit_enum(&self, _name: &str, f: fn()) {\n+    fn emit_enum(&self, _name: &str, f: &fn()) {\n         f();\n     }\n \n     fn emit_enum_variant(&self, v_name: &str, _v_id: uint, sz: uint,\n-                         f: fn()) {\n+                         f: &fn()) {\n         self.wr.write_str(v_name);\n         if sz > 0u { self.wr.write_str(~\"(\"); }\n         f();\n         if sz > 0u { self.wr.write_str(~\")\"); }\n     }\n \n-    fn emit_enum_variant_arg(&self, idx: uint, f: fn()) {\n+    fn emit_enum_variant_arg(&self, idx: uint, f: &fn()) {\n         if idx > 0u { self.wr.write_str(~\", \"); }\n         f();\n     }\n \n-    fn emit_borrowed_vec(&self, _len: uint, f: fn()) {\n+    fn emit_borrowed_vec(&self, _len: uint, f: &fn()) {\n         self.wr.write_str(~\"&[\");\n         f();\n         self.wr.write_str(~\"]\");\n     }\n \n-    fn emit_owned_vec(&self, _len: uint, f: fn()) {\n+    fn emit_owned_vec(&self, _len: uint, f: &fn()) {\n         self.wr.write_str(~\"~[\");\n         f();\n         self.wr.write_str(~\"]\");\n     }\n \n-    fn emit_managed_vec(&self, _len: uint, f: fn()) {\n+    fn emit_managed_vec(&self, _len: uint, f: &fn()) {\n         self.wr.write_str(~\"@[\");\n         f();\n         self.wr.write_str(~\"]\");\n     }\n \n-    fn emit_vec_elt(&self, idx: uint, f: fn()) {\n+    fn emit_vec_elt(&self, idx: uint, f: &fn()) {\n         if idx > 0u { self.wr.write_str(~\", \"); }\n         f();\n     }\n \n-    fn emit_rec(&self, f: fn()) {\n+    fn emit_rec(&self, f: &fn()) {\n         self.wr.write_str(~\"{\");\n         f();\n         self.wr.write_str(~\"}\");\n     }\n \n-    fn emit_struct(&self, name: &str, _len: uint, f: fn()) {\n+    fn emit_struct(&self, name: &str, _len: uint, f: &fn()) {\n         self.wr.write_str(fmt!(\"%s {\", name));\n         f();\n         self.wr.write_str(~\"}\");\n     }\n \n-    fn emit_field(&self, name: &str, idx: uint, f: fn()) {\n+    fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n         if idx > 0u { self.wr.write_str(~\", \"); }\n         self.wr.write_str(name);\n         self.wr.write_str(~\": \");\n         f();\n     }\n \n-    fn emit_tup(&self, _len: uint, f: fn()) {\n+    fn emit_tup(&self, _len: uint, f: &fn()) {\n         self.wr.write_str(~\"(\");\n         f();\n         self.wr.write_str(~\")\");\n     }\n \n-    fn emit_tup_elt(&self, idx: uint, f: fn()) {\n+    fn emit_tup_elt(&self, idx: uint, f: &fn()) {\n         if idx > 0u { self.wr.write_str(~\", \"); }\n         f();\n     }"}, {"sha": "31f29ce23f2cda84027826d45ae9b165ade969c5", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -31,7 +31,7 @@ impl<T:Ord> BaseIter<T> for PriorityQueue<T> {\n     /// Visit all values in the underlying vector.\n     ///\n     /// The values are **not** visited in order.\n-    pure fn each(&self, f: fn(&T) -> bool) { self.data.each(f) }\n+    pure fn each(&self, f: &fn(&T) -> bool) { self.data.each(f) }\n     pure fn size_hint(&self) -> Option<uint> { self.data.size_hint() }\n }\n "}, {"sha": "a8b25767ce59563046669b6bc4f424ce0dad4c56", "filename": "src/libstd/rl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frl.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -68,7 +68,7 @@ pub unsafe fn read(prompt: ~str) -> Option<~str> {\n     }\n }\n \n-pub type CompletionCb = @fn(~str, fn(~str));\n+pub type CompletionCb<'self> = @fn(~str, &'self fn(~str));\n \n fn complete_key(_v: @CompletionCb) {}\n "}, {"sha": "dd2f5b58fb96a20a8b07455f6ca5a2179f056dfe", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -393,7 +393,7 @@ Section: Iterating\n  * `true` If execution proceeded correctly, `false` if it was interrupted,\n  * that is if `it` returned `false` at any point.\n  */\n-pub fn loop_chars(rope: Rope, it: fn(c: char) -> bool) -> bool {\n+pub fn loop_chars(rope: Rope, it: &fn(c: char) -> bool) -> bool {\n    match (rope) {\n       node::Empty => return true,\n       node::Content(x) => return node::loop_chars(x, it)\n@@ -407,7 +407,7 @@ pub fn loop_chars(rope: Rope, it: fn(c: char) -> bool) -> bool {\n  * * rope - A rope to traverse. It may be empty\n  * * it - A block to execute with each consecutive character of the rope.\n  */\n-pub fn iter_chars(rope: Rope, it: fn(char)) {\n+pub fn iter_chars(rope: Rope, it: &fn(char)) {\n     do loop_chars(rope) |x| {\n         it(x);\n         true\n@@ -436,7 +436,7 @@ pub fn iter_chars(rope: Rope, it: fn(char)) {\n  * `true` If execution proceeded correctly, `false` if it was interrupted,\n  * that is if `it` returned `false` at any point.\n  */\n-pub fn loop_leaves(rope: Rope, it: fn(node::Leaf) -> bool) -> bool{\n+pub fn loop_leaves(rope: Rope, it: &fn(node::Leaf) -> bool) -> bool{\n    match (rope) {\n       node::Empty => return true,\n       node::Content(x) => return node::loop_leaves(x, it)\n@@ -1078,7 +1078,7 @@ pub mod node {\n         return result;\n     }\n \n-    pub fn loop_chars(node: @Node, it: fn(c: char) -> bool) -> bool {\n+    pub fn loop_chars(node: @Node, it: &fn(c: char) -> bool) -> bool {\n         return loop_leaves(node,|leaf| {\n             str::all_between(*leaf.content,\n                              leaf.byte_offset,\n@@ -1100,7 +1100,7 @@ pub mod node {\n      * `true` If execution proceeded correctly, `false` if it was interrupted,\n      * that is if `it` returned `false` at any point.\n      */\n-    pub fn loop_leaves(node: @Node, it: fn(Leaf) -> bool) -> bool{\n+    pub fn loop_leaves(node: @Node, it: &fn(Leaf) -> bool) -> bool{\n         let mut current = node;\n         loop {\n             match (*current) {"}, {"sha": "7b8a06f1b93afe42bdaf7d3cd0d365d7a62c2902", "filename": "src/libstd/semver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsemver.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -140,7 +140,7 @@ condition! {\n \n fn take_nonempty_prefix(rdr: io::Reader,\n                         ch: char,\n-                        pred: fn(char) -> bool) -> (~str, char) {\n+                        pred: &fn(char) -> bool) -> (~str, char) {\n     let mut buf = ~\"\";\n     let mut ch = ch;\n     while pred(ch) {"}, {"sha": "0288155d29ebd73d83d0f239ff019eeda24f5447", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -43,25 +43,25 @@ pub trait Encoder {\n     fn emit_managed_str(&self, v: &str);\n \n     // Compound types:\n-    fn emit_borrowed(&self, f: fn());\n-    fn emit_owned(&self, f: fn());\n-    fn emit_managed(&self, f: fn());\n+    fn emit_borrowed(&self, f: &fn());\n+    fn emit_owned(&self, f: &fn());\n+    fn emit_managed(&self, f: &fn());\n \n-    fn emit_enum(&self, name: &str, f: fn());\n-    fn emit_enum_variant(&self, v_name: &str, v_id: uint, sz: uint, f: fn());\n-    fn emit_enum_variant_arg(&self, idx: uint, f: fn());\n+    fn emit_enum(&self, name: &str, f: &fn());\n+    fn emit_enum_variant(&self, v_name: &str, v_id: uint, sz: uint, f: &fn());\n+    fn emit_enum_variant_arg(&self, idx: uint, f: &fn());\n \n-    fn emit_borrowed_vec(&self, len: uint, f: fn());\n-    fn emit_owned_vec(&self, len: uint, f: fn());\n-    fn emit_managed_vec(&self, len: uint, f: fn());\n-    fn emit_vec_elt(&self, idx: uint, f: fn());\n+    fn emit_borrowed_vec(&self, len: uint, f: &fn());\n+    fn emit_owned_vec(&self, len: uint, f: &fn());\n+    fn emit_managed_vec(&self, len: uint, f: &fn());\n+    fn emit_vec_elt(&self, idx: uint, f: &fn());\n \n-    fn emit_rec(&self, f: fn());\n-    fn emit_struct(&self, name: &str, _len: uint, f: fn());\n-    fn emit_field(&self, f_name: &str, f_idx: uint, f: fn());\n+    fn emit_rec(&self, f: &fn());\n+    fn emit_struct(&self, name: &str, _len: uint, f: &fn());\n+    fn emit_field(&self, f_name: &str, f_idx: uint, f: &fn());\n \n-    fn emit_tup(&self, len: uint, f: fn());\n-    fn emit_tup_elt(&self, idx: uint, f: fn());\n+    fn emit_tup(&self, len: uint, f: &fn());\n+    fn emit_tup_elt(&self, idx: uint, f: &fn());\n }\n \n pub trait Decoder {\n@@ -86,23 +86,23 @@ pub trait Decoder {\n     fn read_managed_str(&self) -> @str;\n \n     // Compound types:\n-    fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T;\n-    fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T;\n-    fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T;\n+    fn read_enum<T>(&self, name: &str, f: &fn() -> T) -> T;\n+    fn read_enum_variant<T>(&self, f: &fn(uint) -> T) -> T;\n+    fn read_enum_variant_arg<T>(&self, idx: uint, f: &fn() -> T) -> T;\n \n-    fn read_owned<T>(&self, f: fn() -> T) -> T;\n-    fn read_managed<T>(&self, f: fn() -> T) -> T;\n+    fn read_owned<T>(&self, f: &fn() -> T) -> T;\n+    fn read_managed<T>(&self, f: &fn() -> T) -> T;\n \n-    fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T;\n-    fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T;\n-    fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n+    fn read_owned_vec<T>(&self, f: &fn(uint) -> T) -> T;\n+    fn read_managed_vec<T>(&self, f: &fn(uint) -> T) -> T;\n+    fn read_vec_elt<T>(&self, idx: uint, f: &fn() -> T) -> T;\n \n-    fn read_rec<T>(&self, f: fn() -> T) -> T;\n-    fn read_struct<T>(&self, name: &str, _len: uint, f: fn() -> T) -> T;\n-    fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T;\n+    fn read_rec<T>(&self, f: &fn() -> T) -> T;\n+    fn read_struct<T>(&self, name: &str, _len: uint, f: &fn() -> T) -> T;\n+    fn read_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T;\n \n-    fn read_tup<T>(&self, sz: uint, f: fn() -> T) -> T;\n-    fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n+    fn read_tup<T>(&self, sz: uint, f: &fn() -> T) -> T;\n+    fn read_tup_elt<T>(&self, idx: uint, f: &fn() -> T) -> T;\n }\n \n pub trait Encodable<S:Encoder> {\n@@ -547,11 +547,11 @@ impl<\n // In some cases, these should eventually be coded as traits.\n \n pub trait EncoderHelpers {\n-    fn emit_from_vec<T>(&self, v: &[T], f: fn(v: &T));\n+    fn emit_from_vec<T>(&self, v: &[T], f: &fn(v: &T));\n }\n \n impl<S:Encoder> EncoderHelpers for S {\n-    fn emit_from_vec<T>(&self, v: &[T], f: fn(v: &T)) {\n+    fn emit_from_vec<T>(&self, v: &[T], f: &fn(v: &T)) {\n         do self.emit_owned_vec(v.len()) {\n             for v.eachi |i, e| {\n                 do self.emit_vec_elt(i) {\n@@ -563,11 +563,11 @@ impl<S:Encoder> EncoderHelpers for S {\n }\n \n pub trait DecoderHelpers {\n-    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T];\n+    fn read_to_vec<T>(&self, f: &fn() -> T) -> ~[T];\n }\n \n impl<D:Decoder> DecoderHelpers for D {\n-    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T] {\n+    fn read_to_vec<T>(&self, f: &fn() -> T) -> ~[T] {\n         do self.read_owned_vec |len| {\n             do vec::from_fn(len) |i| {\n                 self.read_vec_elt(i, || f())"}, {"sha": "726e7c36abd1b0804e1c2b778911b3ccabcd4b5a", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -24,7 +24,7 @@ pub struct SmallIntMap<T> {\n \n impl<V> BaseIter<(uint, &self/V)> for SmallIntMap<V> {\n     /// Visit all key-value pairs in order\n-    pure fn each(&self, it: fn(&(uint, &self/V)) -> bool) {\n+    pure fn each(&self, it: &fn(&(uint, &self/V)) -> bool) {\n         for uint::range(0, self.v.len()) |i| {\n             match self.v[i] {\n               Some(ref elt) => if !it(&(i, elt)) { break },\n@@ -38,7 +38,7 @@ impl<V> BaseIter<(uint, &self/V)> for SmallIntMap<V> {\n \n impl<V> ReverseIter<(uint, &self/V)> for SmallIntMap<V> {\n     /// Visit all key-value pairs in reverse order\n-    pure fn each_reverse(&self, it: fn(&(uint, &self/V)) -> bool) {\n+    pure fn each_reverse(&self, it: &fn(&(uint, &self/V)) -> bool) {\n         for uint::range_rev(self.v.len(), 0) |i| {\n             match self.v[i - 1] {\n               Some(ref elt) => if !it(&(i - 1, elt)) { break },\n@@ -76,12 +76,12 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n \n     /// Visit all keys in order\n-    pure fn each_key(&self, blk: fn(key: &uint) -> bool) {\n+    pure fn each_key(&self, blk: &fn(key: &uint) -> bool) {\n         self.each(|&(k, _)| blk(&k))\n     }\n \n     /// Visit all values in order\n-    pure fn each_value(&self, blk: fn(value: &V) -> bool) {\n+    pure fn each_value(&self, blk: &fn(value: &V) -> bool) {\n         self.each(|&(_, v)| blk(v))\n     }\n \n@@ -133,15 +133,15 @@ pub impl<V> SmallIntMap<V> {\n \n pub impl<V:Copy> SmallIntMap<V> {\n     fn update_with_key(&mut self, key: uint, val: V,\n-                       ff: fn(uint, V, V) -> V) -> bool {\n+                       ff: &fn(uint, V, V) -> V) -> bool {\n         let new_val = match self.find(&key) {\n             None => val,\n             Some(orig) => ff(key, *orig, val)\n         };\n         self.insert(key, new_val)\n     }\n \n-    fn update(&mut self, key: uint, newval: V, ff: fn(V, V) -> V) -> bool {\n+    fn update(&mut self, key: uint, newval: V, ff: &fn(V, V) -> V) -> bool {\n         self.update_with_key(key, newval, |_k, v, v1| ff(v,v1))\n     }\n }"}, {"sha": "2190475d943b673cf27c2e2743320f2330d4dc50", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -79,8 +79,9 @@ struct SemInner<Q> {\n     // a condition variable attached, others should.\n     blocked:   Q\n }\n+\n #[doc(hidden)]\n-enum Sem<Q> = Exclusive<SemInner<Q>>;\n+struct Sem<Q>(Exclusive<SemInner<Q>>);\n \n #[doc(hidden)]\n fn new_sem<Q:Owned>(count: int, q: Q) -> Sem<Q> {\n@@ -135,7 +136,7 @@ pub impl<Q:Owned> &self/Sem<Q> {\n // FIXME(#3154) move both copies of this into Sem<Q>, and unify the 2 structs\n #[doc(hidden)]\n pub impl &self/Sem<()> {\n-    fn access<U>(&self, blk: fn() -> U) -> U {\n+    fn access<U>(&self, blk: &fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n@@ -148,7 +149,7 @@ pub impl &self/Sem<()> {\n }\n #[doc(hidden)]\n pub impl &self/Sem<~[Waitqueue]> {\n-    fn access<U>(&self, blk: fn() -> U) -> U {\n+    fn access<U>(&self, blk: &fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n@@ -332,7 +333,7 @@ pub impl Condvar/&self {\n #[inline(always)]\n #[doc(hidden)]\n fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n-                        blk: fn() -> U) -> U {\n+                        blk: &fn() -> U) -> U {\n     match out_of_bounds {\n         Some(0) =>\n             fail!(fmt!(\"%s with illegal ID %u - this lock has no condvars!\",\n@@ -347,7 +348,7 @@ fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n #[doc(hidden)]\n pub impl Sem<~[Waitqueue]> {\n     // The only other place that condvars get built is rwlock_write_mode.\n-    fn access_cond<U>(&self, blk: fn(c: &Condvar) -> U) -> U {\n+    fn access_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n         do self.access { blk(&Condvar { sem: self }) }\n     }\n }\n@@ -385,7 +386,7 @@ pub impl Semaphore {\n     fn release(&self) { (&self.sem).release() }\n \n     /// Run a function with ownership of one of the semaphore's resources.\n-    fn access<U>(&self, blk: fn() -> U) -> U { (&self.sem).access(blk) }\n+    fn access<U>(&self, blk: &fn() -> U) -> U { (&self.sem).access(blk) }\n }\n \n /****************************************************************************\n@@ -421,10 +422,10 @@ impl Clone for Mutex {\n \n pub impl Mutex {\n     /// Run a function with ownership of the mutex.\n-    fn lock<U>(&self, blk: fn() -> U) -> U { (&self.sem).access(blk) }\n+    fn lock<U>(&self, blk: &fn() -> U) -> U { (&self.sem).access(blk) }\n \n     /// Run a function with ownership of the mutex and a handle to a condvar.\n-    fn lock_cond<U>(&self, blk: fn(c: &Condvar) -> U) -> U {\n+    fn lock_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n         (&self.sem).access_cond(blk)\n     }\n }\n@@ -480,7 +481,7 @@ pub impl RWlock {\n      * Run a function with the rwlock in read mode. Calls to 'read' from other\n      * tasks may run concurrently with this one.\n      */\n-    fn read<U>(&self, blk: fn() -> U) -> U {\n+    fn read<U>(&self, blk: &fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n@@ -511,7 +512,7 @@ pub impl RWlock {\n      * Run a function with the rwlock in write mode. No calls to 'read' or\n      * 'write' from other tasks will run concurrently with this one.\n      */\n-    fn write<U>(&self, blk: fn() -> U) -> U {\n+    fn write<U>(&self, blk: &fn() -> U) -> U {\n         unsafe {\n             do task::unkillable {\n                 (&self.order_lock).acquire();\n@@ -529,7 +530,7 @@ pub impl RWlock {\n      * the waiting task is signalled. (Note: a writer that waited and then\n      * was signalled might reacquire the lock before other waiting writers.)\n      */\n-    fn write_cond<U>(&self, blk: fn(c: &Condvar) -> U) -> U {\n+    fn write_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n         // NB: You might think I should thread the order_lock into the cond\n         // wait call, so that it gets waited on before access_lock gets\n         // reacquired upon being woken up. However, (a) this would be not\n@@ -564,7 +565,7 @@ pub impl RWlock {\n      * }\n      * ~~~\n      */\n-    fn write_downgrade<U>(&self, blk: fn(v: RWlockWriteMode) -> U) -> U {\n+    fn write_downgrade<U>(&self, blk: &fn(v: RWlockWriteMode) -> U) -> U {\n         // Implementation slightly different from the slicker 'write's above.\n         // The exit path is conditional on whether the caller downgrades.\n         let mut _release = None;\n@@ -692,16 +693,16 @@ impl Drop for RWlockReadMode/&self { fn finalize(&self) {} }\n \n pub impl RWlockWriteMode/&self {\n     /// Access the pre-downgrade rwlock in write mode.\n-    fn write<U>(&self, blk: fn() -> U) -> U { blk() }\n+    fn write<U>(&self, blk: &fn() -> U) -> U { blk() }\n     /// Access the pre-downgrade rwlock in write mode with a condvar.\n-    fn write_cond<U>(&self, blk: fn(c: &Condvar) -> U) -> U {\n+    fn write_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n         blk(&Condvar { sem: &self.lock.access_lock })\n     }\n }\n \n pub impl RWlockReadMode/&self {\n     /// Access the post-downgrade rwlock in read mode.\n-    fn read<U>(&self, blk: fn() -> U) -> U { blk() }\n+    fn read<U>(&self, blk: &fn() -> U) -> U { blk() }\n }\n \n /****************************************************************************\n@@ -1082,7 +1083,7 @@ mod tests {\n     #[cfg(test)]\n     pub enum RWlockMode { Read, Write, Downgrade, DowngradeRead }\n     #[cfg(test)]\n-    pub fn lock_rwlock_in_mode(x: &RWlock, mode: RWlockMode, blk: fn()) {\n+    pub fn lock_rwlock_in_mode(x: &RWlock, mode: RWlockMode, blk: &fn()) {\n         match mode {\n             Read => x.read(blk),\n             Write => x.write(blk),\n@@ -1239,7 +1240,7 @@ mod tests {\n                                              dg1: bool,\n                                              dg2: bool) {\n         // Much like the mutex broadcast test. Downgrade-enabled.\n-        fn lock_cond(x: &RWlock, downgrade: bool, blk: fn(c: &Condvar)) {\n+        fn lock_cond(x: &RWlock, downgrade: bool, blk: &fn(c: &Condvar)) {\n             if downgrade {\n                 do x.write_downgrade |mode| {\n                     (&mode).write_cond(blk)"}, {"sha": "72351aac33975addf8ffa215c49f7c9ddc80d817", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -96,7 +96,7 @@ impl<K: Ord + TotalOrd, V> Ord for TreeMap<K, V> {\n \n impl<'self, K: TotalOrd, V> BaseIter<(&'self K, &'self V)> for TreeMap<K, V> {\n     /// Visit all key-value pairs in order\n-    pure fn each(&self, f: fn(&(&self/K, &self/V)) -> bool) {\n+    pure fn each(&self, f: &fn(&(&self/K, &self/V)) -> bool) {\n         each(&self.root, f)\n     }\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n@@ -107,7 +107,7 @@ impl<'self, K: TotalOrd, V>\n     for TreeMap<K, V>\n {\n     /// Visit all key-value pairs in reverse order\n-    pure fn each_reverse(&self, f: fn(&(&self/K, &self/V)) -> bool) {\n+    pure fn each_reverse(&self, f: &fn(&(&self/K, &self/V)) -> bool) {\n         each_reverse(&self.root, f);\n     }\n }\n@@ -135,10 +135,12 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     }\n \n     /// Visit all keys in order\n-    pure fn each_key(&self, f: fn(&K) -> bool) { self.each(|&(k, _)| f(k)) }\n+    pure fn each_key(&self, f: &fn(&K) -> bool) { self.each(|&(k, _)| f(k)) }\n \n     /// Visit all values in order\n-    pure fn each_value(&self, f: fn(&V) -> bool) { self.each(|&(_, v)| f(v)) }\n+    pure fn each_value(&self, f: &fn(&V) -> bool) {\n+        self.each(|&(_, v)| f(v))\n+    }\n \n     /// Return the value corresponding to the key in the map\n     pure fn find(&self, key: &K) -> Option<&self/V> {\n@@ -180,12 +182,12 @@ pub impl<K: TotalOrd, V> TreeMap<K, V> {\n     static pure fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n     /// Visit all keys in reverse order\n-    pure fn each_key_reverse(&self, f: fn(&K) -> bool) {\n+    pure fn each_key_reverse(&self, f: &fn(&K) -> bool) {\n         self.each_reverse(|&(k, _)| f(k))\n     }\n \n     /// Visit all values in reverse order\n-    pure fn each_value_reverse(&self, f: fn(&V) -> bool) {\n+    pure fn each_value_reverse(&self, f: &fn(&V) -> bool) {\n         self.each_reverse(|&(_, v)| f(v))\n     }\n \n@@ -225,7 +227,7 @@ pub fn map_next<K, V>(iter: &mut TreeMapIterator/&r<K, V>)\n \n /// Advance the iterator through the map\n pub fn map_advance<K, V>(iter: &mut TreeMapIterator/&r<K, V>,\n-                         f: fn((&r/K, &r/V)) -> bool) {\n+                         f: &fn((&r/K, &r/V)) -> bool) {\n     loop {\n         match map_next(iter) {\n           Some(x) => {\n@@ -242,13 +244,13 @@ pub struct TreeSet<T> {\n \n impl<T: TotalOrd> BaseIter<T> for TreeSet<T> {\n     /// Visit all values in order\n-    pure fn each(&self, f: fn(&T) -> bool) { self.map.each_key(f) }\n+    pure fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<T: TotalOrd> ReverseIter<T> for TreeSet<T> {\n     /// Visit all values in reverse order\n-    pure fn each_reverse(&self, f: fn(&T) -> bool) {\n+    pure fn each_reverse(&self, f: &fn(&T) -> bool) {\n         self.map.each_key_reverse(f)\n     }\n }\n@@ -350,7 +352,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the difference\n-    pure fn difference(&self, other: &TreeSet<T>, f: fn(&T) -> bool) {\n+    pure fn difference(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n@@ -383,7 +385,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n \n     /// Visit the values (in-order) representing the symmetric difference\n     pure fn symmetric_difference(&self, other: &TreeSet<T>,\n-                                 f: fn(&T) -> bool) {\n+                                 f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n@@ -422,7 +424,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the intersection\n-    pure fn intersection(&self, other: &TreeSet<T>, f: fn(&T) -> bool) {\n+    pure fn intersection(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n@@ -449,7 +451,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the union\n-    pure fn union(&self, other: &TreeSet<T>, f: fn(&T) -> bool) {\n+    pure fn union(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n@@ -508,7 +510,7 @@ pub fn set_next<T>(iter: &mut TreeSetIterator/&r<T>) -> Option<&r/T> {\n \n /// Advance the iterator through the set\n fn set_advance<T>(iter: &mut TreeSetIterator/&r<T>,\n-                       f: fn(&r/T) -> bool) {\n+                       f: &fn(&r/T) -> bool) {\n     do map_advance(&mut iter.iter) |(k, _)| { f(k) }\n }\n \n@@ -530,15 +532,15 @@ pub impl<K: TotalOrd, V> TreeNode<K, V> {\n }\n \n pure fn each<K: TotalOrd, V>(node: &r/Option<~TreeNode<K, V>>,\n-                        f: fn(&(&r/K, &r/V)) -> bool) {\n+                        f: &fn(&(&r/K, &r/V)) -> bool) {\n     for node.each |x| {\n         each(&x.left, f);\n         if f(&(&x.key, &x.value)) { each(&x.right, f) }\n     }\n }\n \n pure fn each_reverse<K: TotalOrd, V>(node: &r/Option<~TreeNode<K, V>>,\n-                                f: fn(&(&r/K, &r/V)) -> bool) {\n+                                f: &fn(&(&r/K, &r/V)) -> bool) {\n     for node.each |x| {\n         each_reverse(&x.right, f);\n         if f(&(&x.key, &x.value)) { each_reverse(&x.left, f) }"}, {"sha": "68a6f8effaa7710d8de3c4884b2d0b4ca67efab2", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -269,7 +269,7 @@ pub impl Context {\n               Decodable<json::Decoder/&static>>( // FIXME(#5121)\n                   @self,\n                   fn_name:&str,\n-                  blk: fn(@Mut<Prep>)->Work<T>) -> Work<T> {\n+                  blk: &fn(@Mut<Prep>)->Work<T>) -> Work<T> {\n         let p = @Mut(Prep {ctxt: self,\n                            fn_name: fn_name.to_owned(),\n                            declared_inputs: LinearMap::new()});"}, {"sha": "27dba9c2b5ebc23a57ee4b8c88099a60b87d98ae", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -1086,16 +1086,11 @@ pub enum variant_kind {\n #[auto_encode]\n #[auto_decode]\n #[deriving_eq]\n-pub struct enum_def_ {\n+pub struct enum_def {\n     variants: ~[variant],\n     common: Option<@struct_def>,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving_eq]\n-pub enum enum_def = enum_def_;\n-\n #[auto_encode]\n #[auto_decode]\n #[deriving_eq]"}, {"sha": "a7d5c0ce75fa0410ea9f431e8a46e798c94fb7da", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -423,7 +423,7 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n }\n \n pub fn node_item_query<Result>(items: map, id: node_id,\n-                               query: fn(@item) -> Result,\n+                               query: &fn(@item) -> Result,\n                                +error_msg: ~str) -> Result {\n     match items.find(&id) {\n         Some(node_item(it, _)) => query(it),"}, {"sha": "35b188a248fd41e1f8973ab40c6772f85cdcd3f3", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -516,7 +516,7 @@ pub pure fn is_item_impl(item: @ast::item) -> bool {\n     }\n }\n \n-pub fn walk_pat(pat: @pat, it: fn(@pat)) {\n+pub fn walk_pat(pat: @pat, it: &fn(@pat)) {\n     it(pat);\n     match pat.node {\n         pat_ident(_, _, Some(p)) => walk_pat(p, it),"}, {"sha": "0d6ece8ad92f14336c748096b0922a243a44e8f6", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -35,11 +35,11 @@ pub trait Pos {\n }\n \n /// A byte offset\n-pub enum BytePos = uint;\n+pub struct BytePos(uint);\n /// A character offset. Because of multibyte utf8 characters, a byte offset\n /// is not equivalent to a character offset. The CodeMap will convert BytePos\n /// values to CharPos values as necessary.\n-pub enum CharPos = uint;\n+pub struct CharPos(uint);\n \n // XXX: Lots of boilerplate in these impls, but so far my attempts to fix\n // have been unsuccessful"}, {"sha": "4e177fecec9e6bacbafb5975fe153940436e4b00", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -306,7 +306,7 @@ fn print_macro_backtrace(cm: @codemap::CodeMap, sp: span) {\n \n pub fn expect<T:Copy>(diag: span_handler,\n                        opt: Option<T>,\n-                       msg: fn() -> ~str) -> T {\n+                       msg: &fn() -> ~str) -> T {\n     match opt {\n        Some(ref t) => (*t),\n        None => diag.handler().bug(msg())"}, {"sha": "c99d89776431a9968d9f424aad97e89b03fc6d95", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 16, "deletions": 28, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -432,7 +432,7 @@ fn mk_impl(\n     ty_param: ast::TyParam,\n     path: @ast::path,\n     generics: &ast::Generics,\n-    f: fn(@ast::Ty) -> @ast::method\n+    f: &fn(@ast::Ty) -> @ast::method\n ) -> @ast::item {\n     /*!\n      *\n@@ -1256,51 +1256,51 @@ mod test {\n         fn emit_owned_str(&self, +_v: &str) { self.add_unknown_to_log(); }\n         fn emit_managed_str(&self, +_v: &str) { self.add_unknown_to_log(); }\n \n-        fn emit_borrowed(&self, f: fn()) { self.add_unknown_to_log(); f() }\n-        fn emit_owned(&self, f: fn()) { self.add_unknown_to_log(); f() }\n-        fn emit_managed(&self, f: fn()) { self.add_unknown_to_log(); f() }\n+        fn emit_borrowed(&self, f: &fn()) { self.add_unknown_to_log(); f() }\n+        fn emit_owned(&self, f: &fn()) { self.add_unknown_to_log(); f() }\n+        fn emit_managed(&self, f: &fn()) { self.add_unknown_to_log(); f() }\n \n-        fn emit_enum(&self, name: &str, f: fn()) {\n+        fn emit_enum(&self, name: &str, f: &fn()) {\n             self.add_to_log(CallToEmitEnum(name.to_str())); f(); }\n \n         fn emit_enum_variant(&self, name: &str, +id: uint,\n-                             +cnt: uint, f: fn()) {\n+                             +cnt: uint, f: &fn()) {\n             self.add_to_log(CallToEmitEnumVariant (name.to_str(),id,cnt));\n             f();\n         }\n \n-        fn emit_enum_variant_arg(&self, +idx: uint, f: fn()) {\n+        fn emit_enum_variant_arg(&self, +idx: uint, f: &fn()) {\n             self.add_to_log(CallToEmitEnumVariantArg (idx)); f();\n         }\n \n-        fn emit_borrowed_vec(&self, +_len: uint, f: fn()) {\n+        fn emit_borrowed_vec(&self, +_len: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n \n-        fn emit_owned_vec(&self, +_len: uint, f: fn()) {\n+        fn emit_owned_vec(&self, +_len: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n-        fn emit_managed_vec(&self, +_len: uint, f: fn()) {\n+        fn emit_managed_vec(&self, +_len: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n-        fn emit_vec_elt(&self, +_idx: uint, f: fn()) {\n+        fn emit_vec_elt(&self, +_idx: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n \n-        fn emit_rec(&self, f: fn()) {\n+        fn emit_rec(&self, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n-        fn emit_struct(&self, name: &str, +len: uint, f: fn()) {\n+        fn emit_struct(&self, name: &str, +len: uint, f: &fn()) {\n             self.add_to_log(CallToEmitStruct (name.to_str(),len)); f();\n         }\n-        fn emit_field(&self, name: &str, +idx: uint, f: fn()) {\n+        fn emit_field(&self, name: &str, +idx: uint, f: &fn()) {\n             self.add_to_log(CallToEmitField (name.to_str(),idx)); f();\n         }\n \n-        fn emit_tup(&self, +_len: uint, f: fn()) {\n+        fn emit_tup(&self, +_len: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n-        fn emit_tup_elt(&self, +_idx: uint, f: fn()) {\n+        fn emit_tup_elt(&self, +_idx: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }\n     }\n@@ -1327,16 +1327,4 @@ mod test {\n                        CallToEmitEnumVariantArg (1),\n                        CallToEmitUint (44)]);\n         }\n-\n-    pub enum BPos = uint;\n-\n-    #[auto_encode]\n-    pub struct HasPos { pos : BPos }\n-\n-    #[test] fn encode_newtype_test () {\n-        check_equal (to_call_log (HasPos {pos:BPos(48)}),\n-                    ~[CallToEmitStruct(~\"HasPos\",1),\n-                      CallToEmitField(~\"pos\",0),\n-                      CallToEmitUint(48)]);\n-    }\n }"}, {"sha": "fd8b2dbf72f815365b49416555b81a9d333a45b0", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -238,9 +238,7 @@ impl to_type_decls for state {\n             cx.item_enum_poly(\n                 name,\n                 self.span,\n-                ast::enum_def(enum_def_ {\n-                    variants: items_msg,\n-                    common: None }),\n+                ast::enum_def { variants: items_msg, common: None },\n                 cx.strip_bounds(&self.generics)\n             )\n         ]"}, {"sha": "dc9abd536d11fc0d6dce3c628d7c9f1625cf4862", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -104,7 +104,7 @@ pub impl state_ {\n \n     /// Iterate over the states that can be reached in one message\n     /// from this state.\n-    fn reachable(&self, f: fn(state) -> bool) {\n+    fn reachable(&self, f: &fn(state) -> bool) {\n         for self.messages.each |m| {\n             match *m {\n               message(_, _, _, _, Some(next_state { state: ref id, _ })) => {"}, {"sha": "427760c920f6dab1f163050f80c2ddd123b2fbdb", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -254,16 +254,14 @@ pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n         }\n         item_enum(ref enum_definition, ref generics) => {\n             item_enum(\n-                ast::enum_def(\n-                    ast::enum_def_ {\n-                        variants: do enum_definition.variants.map |x| {\n-                            fld.fold_variant(x)\n-                        },\n-                        common: do enum_definition.common.map |x| {\n-                            fold_struct_def(*x, fld)\n-                        }\n+                ast::enum_def {\n+                    variants: do enum_definition.variants.map |x| {\n+                        fld.fold_variant(x)\n+                    },\n+                    common: do enum_definition.common.map |x| {\n+                        fold_struct_def(*x, fld)\n                     }\n-                ),\n+                },\n                 fold_generics(generics, fld))\n         }\n         item_struct(ref struct_def, ref generics) => {\n@@ -684,10 +682,7 @@ fn noop_fold_variant(v: &variant_, fld: @ast_fold) -> variant_ {\n                 fold_struct_def(*x, fld)\n             };\n             kind = enum_variant_kind(\n-                ast::enum_def(ast::enum_def_ {\n-                    variants: variants,\n-                    common: common\n-                })\n+                ast::enum_def { variants: variants, common: common }\n             );\n         }\n     }"}, {"sha": "ba0c7a71b7c17cf07db98f8a3eea6d9783fe934f", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -122,7 +122,7 @@ impl<A:Eq> Eq for OptVec<A> {\n }\n \n impl<A> BaseIter<A> for OptVec<A> {\n-    pure fn each(&self, blk: fn(v: &A) -> bool) {\n+    pure fn each(&self, blk: &fn(v: &A) -> bool) {\n         match *self {\n             Empty => {}\n             Vec(ref v) => v.each(blk)\n@@ -136,31 +136,31 @@ impl<A> BaseIter<A> for OptVec<A> {\n \n impl<A> iter::ExtendedIter<A> for OptVec<A> {\n     #[inline(always)]\n-    pure fn eachi(&self, blk: fn(+v: uint, v: &A) -> bool) {\n+    pure fn eachi(&self, blk: &fn(+v: uint, v: &A) -> bool) {\n         iter::eachi(self, blk)\n     }\n     #[inline(always)]\n-    pure fn all(&self, blk: fn(&A) -> bool) -> bool {\n+    pure fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::all(self, blk)\n     }\n     #[inline(always)]\n-    pure fn any(&self, blk: fn(&A) -> bool) -> bool {\n+    pure fn any(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::any(self, blk)\n     }\n     #[inline(always)]\n-    pure fn foldl<B>(&self, +b0: B, blk: fn(&B, &A) -> B) -> B {\n+    pure fn foldl<B>(&self, +b0: B, blk: &fn(&B, &A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n     #[inline(always)]\n-    pure fn position(&self, f: fn(&A) -> bool) -> Option<uint> {\n+    pure fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n         iter::position(self, f)\n     }\n     #[inline(always)]\n-    pure fn map_to_vec<B>(&self, op: fn(&A) -> B) -> ~[B] {\n+    pure fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n         iter::map_to_vec(self, op)\n     }\n     #[inline(always)]\n-    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: fn(&A) -> IB)\n+    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n         iter::flat_map_to_vec(self, op)\n     }\n@@ -176,13 +176,13 @@ impl<A: Eq> iter::EqIter<A> for OptVec<A> {\n \n impl<A: Copy> iter::CopyableIter<A> for OptVec<A> {\n     #[inline(always)]\n-    pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A] {\n+    pure fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n     #[inline(always)]\n     pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n     #[inline(always)]\n-    pure fn find(&self, f: fn(&A) -> bool) -> Option<A> {\n+    pure fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n         iter::find(self, f)\n     }\n }"}, {"sha": "c7b9a769293d6b32eaa26ee4b1925b0036693b54", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -248,7 +248,7 @@ pub impl Parser {\n     fn parse_seq_to_before_gt<T: Copy>(\n         &self,\n         sep: Option<token::Token>,\n-        f: fn(&Parser) -> T\n+        f: &fn(&Parser) -> T\n     ) -> OptVec<T> {\n         let mut first = true;\n         let mut v = opt_vec::Empty;\n@@ -269,7 +269,7 @@ pub impl Parser {\n     fn parse_seq_to_gt<T: Copy>(\n         &self,\n         sep: Option<token::Token>,\n-        f: fn(&Parser) -> T\n+        f: &fn(&Parser) -> T\n     ) -> OptVec<T> {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n@@ -283,7 +283,7 @@ pub impl Parser {\n         &self,\n         ket: &token::Token,\n         sep: SeqSep,\n-        f: fn(&Parser) -> T\n+        f: &fn(&Parser) -> T\n     ) -> ~[T] {\n         let val = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n@@ -297,7 +297,7 @@ pub impl Parser {\n         &self,\n         ket: &token::Token,\n         sep: SeqSep,\n-        f: fn(&Parser) -> T\n+        f: &fn(&Parser) -> T\n     ) -> ~[T] {\n         let mut first: bool = true;\n         let mut v: ~[T] = ~[];\n@@ -323,7 +323,7 @@ pub impl Parser {\n         bra: &token::Token,\n         ket: &token::Token,\n         sep: SeqSep,\n-        f: fn(&Parser) -> T\n+        f: &fn(&Parser) -> T\n     ) -> ~[T] {\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end(ket, sep, f);\n@@ -338,7 +338,7 @@ pub impl Parser {\n         bra: &token::Token,\n         ket: &token::Token,\n         sep: SeqSep,\n-        f: fn(&Parser) -> T\n+        f: &fn(&Parser) -> T\n     ) -> spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(bra);"}, {"sha": "fd84f8670686b5aafc16c9f25942209dc87ad598", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -173,7 +173,7 @@ pub fn parse_tts_from_source_str(\n }\n \n pub fn parse_from_source_str<T>(\n-    f: fn (Parser) -> T,\n+    f: &fn (Parser) -> T,\n     name: ~str, ss: codemap::FileSubstr,\n     source: @~str,\n     +cfg: ast::crate_cfg,"}, {"sha": "ef858a2d5ebd19c45402b77df9febcb0621547ee", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -53,6 +53,8 @@ pub enum ObsoleteSyntax {\n     ObsoleteRecordPattern,\n     ObsoleteAssertion,\n     ObsoletePostFnTySigil,\n+    ObsoleteBareFnType,\n+    ObsoleteNewtypeEnum,\n }\n \n impl to_bytes::IterBytes for ObsoleteSyntax {\n@@ -166,6 +168,14 @@ pub impl Parser {\n                 \"Rather than `fn@`, `fn~`, or `fn&`, \\\n                  write `@fn`, `~fn`, and `&fn` respectively\"\n             ),\n+            ObsoleteBareFnType => (\n+                \"bare function type\",\n+                \"use `&fn` or `extern fn` instead\"\n+            ),\n+            ObsoleteNewtypeEnum => (\n+                \"newtype enum\",\n+                \"instead of `enum Foo = int`, write `struct Foo(int)`\"\n+            ),\n         };\n \n         self.report(sp, kind, kind_str, desc);"}, {"sha": "99c1c2cb1feec9123acd32eb2c2182618868af2d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -77,6 +77,7 @@ use parse::obsolete::{ObsoleteTraitBoundSeparator, ObsoleteMutOwnedPointer};\n use parse::obsolete::{ObsoleteMutVector, ObsoleteTraitImplVisibility};\n use parse::obsolete::{ObsoleteRecordType, ObsoleteRecordPattern};\n use parse::obsolete::{ObsoleteAssertion, ObsoletePostFnTySigil};\n+use parse::obsolete::{ObsoleteBareFnType, ObsoleteNewtypeEnum};\n use parse::prec::{as_prec, token_to_binop};\n use parse::token::{can_begin_expr, is_ident, is_ident_or_path};\n use parse::token::{is_plain_ident, INTERPOLATED, special_idents};\n@@ -647,8 +648,9 @@ pub impl Parser {\n         } else if self.eat_keyword(&~\"extern\") {\n             self.parse_ty_bare_fn()\n         } else if self.token_is_closure_keyword(&copy *self.token) {\n-            // self.warn(fmt!(\"Old-school closure keyword\"));\n-            self.parse_ty_closure(ast::BorrowedSigil, None)\n+            let result = self.parse_ty_closure(ast::BorrowedSigil, None);\n+            self.obsolete(*self.last_span, ObsoleteBareFnType);\n+            result\n         } else if *self.token == token::MOD_SEP\n             || is_ident_or_path(&*self.token) {\n             let path = self.parse_path_with_tps(colons_before_params);\n@@ -1829,7 +1831,7 @@ pub impl Parser {\n \n     fn parse_sugary_call_expr(&self, keyword: ~str,\n                               sugar: CallSugar,\n-                              ctor: fn(+v: @expr) -> expr_) -> @expr {\n+                              ctor: &fn(+v: @expr) -> expr_) -> @expr {\n         let lo = self.last_span;\n         // Parse the callee `foo` in\n         //    for foo || {\n@@ -2769,7 +2771,7 @@ pub impl Parser {\n         (lifetimes, opt_vec::take_vec(result))\n     }\n \n-    fn parse_fn_decl(&self, parse_arg_fn: fn(&Parser) -> arg_or_capture_item)\n+    fn parse_fn_decl(&self, parse_arg_fn: &fn(&Parser) -> arg_or_capture_item)\n         -> fn_decl\n     {\n         let args_or_capture_items: ~[arg_or_capture_item] =\n@@ -2813,10 +2815,10 @@ pub impl Parser {\n     fn parse_fn_decl_with_self(\n         &self,\n         parse_arg_fn:\n-        fn(&Parser) -> arg_or_capture_item\n+        &fn(&Parser) -> arg_or_capture_item\n     ) -> (self_ty, fn_decl) {\n         fn maybe_parse_self_ty(\n-            cnstr: fn(+v: mutability) -> ast::self_ty_,\n+            cnstr: &fn(+v: mutability) -> ast::self_ty_,\n             p: &Parser\n         ) -> ast::self_ty_ {\n             // We need to make sure it isn't a mode or a type\n@@ -3765,7 +3767,7 @@ pub impl Parser {\n                         enum\");\n         }\n \n-        enum_def(ast::enum_def_ { variants: variants, common: common_fields })\n+        ast::enum_def { variants: variants, common: common_fields }\n     }\n \n     fn parse_item_enum(&self) -> item_info {\n@@ -3788,12 +3790,12 @@ pub impl Parser {\n                 vis: public,\n             });\n \n+            self.obsolete(*self.last_span, ObsoleteNewtypeEnum);\n+\n             return (\n                 id,\n                 item_enum(\n-                    enum_def(\n-                        ast::enum_def_ { variants: ~[variant], common: None }\n-                    ),\n+                    ast::enum_def { variants: ~[variant], common: None },\n                     generics),\n                 None\n             );"}, {"sha": "49899fdeec415e79154d70ae7efe576ffa6d8f05", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 29, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -314,8 +314,8 @@ pub fn commasep<IN>(s: @ps, b: breaks, elts: ~[IN], op: &fn(@ps, IN)) {\n }\n \n \n-pub fn commasep_cmnt<IN>(s: @ps, b: breaks, elts: ~[IN], op: fn(@ps, IN),\n-                         get_span: fn(IN) -> codemap::span) {\n+pub fn commasep_cmnt<IN>(s: @ps, b: breaks, elts: ~[IN], op: &fn(@ps, IN),\n+                         get_span: &fn(IN) -> codemap::span) {\n     box(s, 0u, b);\n     let len = vec::len::<IN>(elts);\n     let mut i = 0u;\n@@ -612,36 +612,11 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n pub fn print_enum_def(s: @ps, enum_definition: ast::enum_def,\n                       generics: &ast::Generics, ident: ast::ident,\n                       span: codemap::span, visibility: ast::visibility) {\n-    let mut newtype =\n-        vec::len(enum_definition.variants) == 1u &&\n-        ident == enum_definition.variants[0].node.name;\n-    if newtype {\n-        match enum_definition.variants[0].node.kind {\n-            ast::tuple_variant_kind(ref args) if args.len() == 1 => {}\n-            _ => newtype = false\n-        }\n-    }\n-    if newtype {\n-        ibox(s, indent_unit);\n-        word_space(s, visibility_qualified(visibility, ~\"enum\"));\n-    } else {\n-        head(s, visibility_qualified(visibility, ~\"enum\"));\n-    }\n-\n+    head(s, visibility_qualified(visibility, ~\"enum\"));\n     print_ident(s, ident);\n     print_generics(s, generics);\n     space(s.s);\n-    if newtype {\n-        word_space(s, ~\"=\");\n-        match /*bad*/ copy enum_definition.variants[0].node.kind {\n-            ast::tuple_variant_kind(args) => print_type(s, args[0].ty),\n-            _ => fail!(~\"newtype syntax with struct?\")\n-        }\n-        word(s.s, ~\";\");\n-        end(s);\n-    } else {\n-        print_variants(s, enum_definition.variants, span);\n-    }\n+    print_variants(s, enum_definition.variants, span);\n }\n \n pub fn print_variants(s: @ps,"}, {"sha": "b7149be00cca92d48730e1920df465b8c447f1d6", "filename": "src/test/auxiliary/cci_impl_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -11,12 +11,12 @@\n #[link(name=\"cci_impl_lib\", vers=\"0.0\")];\n \n trait uint_helpers {\n-    fn to(v: uint, f: fn(uint));\n+    fn to(v: uint, f: &fn(uint));\n }\n \n impl uint_helpers for uint {\n     #[inline]\n-    fn to(v: uint, f: fn(uint)) {\n+    fn to(v: uint, f: &fn(uint)) {\n         let mut i = self;\n         while i < v {\n             f(i);"}, {"sha": "107f0ac32a4bf9cef4173c5dd03494d11c67649c", "filename": "src/test/auxiliary/cci_iter_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -12,7 +12,7 @@\n #[legacy_modes];\n \n #[inline]\n-pub fn iter<T>(v: ~[T], f: fn(T)) {\n+pub fn iter<T>(v: ~[T], f: &fn(T)) {\n     let mut i = 0u;\n     let n = vec::len(v);\n     while i < n {"}, {"sha": "407f62adb0251ef2a0b8c82013d4f00aa6069cb4", "filename": "src/test/auxiliary/cci_no_inline_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -11,7 +11,7 @@\n #[link(name=\"cci_no_inline_lib\", vers=\"0.0\")];\n \n // same as cci_iter_lib, more-or-less, but not marked inline\n-pub fn iter(v: ~[uint], f: fn(uint)) {\n+pub fn iter(v: ~[uint], f: &fn(uint)) {\n     let mut i = 0u;\n     let n = vec::len(v);\n     while i < n {"}, {"sha": "1dd30edcc980bb51d3a9abca0e6945dd19f80830", "filename": "src/test/auxiliary/issue_2472_b.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fauxiliary%2Fissue_2472_b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fauxiliary%2Fissue_2472_b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2472_b.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n \n-enum S = ();\n+pub struct S(());\n \n pub impl S {\n     fn foo() { }\n }\n \n-trait T {\n+pub trait T {\n     fn bar();\n }\n "}, {"sha": "c80457ef1e92c68c9c31407afb5d6f1aa3ee8df2", "filename": "src/test/auxiliary/issue_3136_a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fauxiliary%2Fissue_3136_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fauxiliary%2Fissue_3136_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_3136_a.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -11,7 +11,7 @@\n trait x {\n     fn use_x<T>();\n }\n-enum y = (); \n+struct y(());\n impl x for y { \n     fn use_x<T>() {\n         struct foo { //~ ERROR quux"}, {"sha": "c86d2fe4d9332340783cf4dbec27849724b9f808", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -25,7 +25,7 @@ struct Results {\n }\n \n fn timed(result: &mut float,\n-         op: fn()) {\n+         op: &fn()) {\n     let start = std::time::precise_time_s();\n     op();\n     let end = std::time::precise_time_s();"}, {"sha": "adfde66e57a011755c795a7fe471cba74f96d0d8", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -24,7 +24,7 @@ struct Results {\n     delete_strings: float\n }\n \n-fn timed(result: &mut float, op: fn()) {\n+fn timed(result: &mut float, op: &fn()) {\n     let start = std::time::precise_time_s();\n     op();\n     let end = std::time::precise_time_s();\n@@ -33,7 +33,7 @@ fn timed(result: &mut float, op: fn()) {\n \n pub impl Results {\n     fn bench_int<T:Set<uint>>(&mut self, rng: @rand::Rng, num_keys: uint,\n-                               rand_cap: uint, f: fn() -> T) {\n+                               rand_cap: uint, f: &fn() -> T) {\n         {\n             let mut set = f();\n             do timed(&mut self.sequential_ints) {\n@@ -71,7 +71,7 @@ pub impl Results {\n     }\n \n     fn bench_str<T:Set<~str>>(&mut self, rng: @rand::Rng, num_keys: uint,\n-                               f: fn() -> T) {\n+                               f: &fn() -> T) {\n         {\n             let mut set = f();\n             do timed(&mut self.sequential_strings) {"}, {"sha": "e8fb86fda788988e5731590a7f10934f1d510e60", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -34,7 +34,7 @@ fn main() {\n     bench!(vec_push_all);\n }\n \n-fn maybe_run_test(argv: &[~str], name: ~str, test: fn()) {\n+fn maybe_run_test(argv: &[~str], name: ~str, test: &fn()) {\n     let mut run_test = false;\n \n     if os::getenv(~\"RUST_BENCH\").is_some() { run_test = true }"}, {"sha": "731605e82bd1f3205cf19fbe33bcae21b42ff3ac", "filename": "src/test/bench/pingpong.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -71,7 +71,7 @@ macro_rules! follow (\n )\n \n fn switch<T:Owned,Tb:Owned,U>(+endp: core::pipes::RecvPacketBuffered<T, Tb>,\n-                      f: fn(+v: Option<T>) -> U) -> U {\n+                      f: &fn(+v: Option<T>) -> U) -> U {\n     f(core::pipes::try_recv(endp))\n }\n \n@@ -131,7 +131,7 @@ fn unbounded(count: uint) {\n     }\n }\n \n-fn timeit(f: fn()) -> float {\n+fn timeit(f: &fn()) -> float {\n     let start = precise_time_s();\n     f();\n     let stop = precise_time_s();"}, {"sha": "fc980e3d6db53eb03713e334274cb3f2e939cebd", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -85,7 +85,7 @@ fn update_freq(mm: HashMap<~[u8], uint>, key: &[u8]) {\n // i.e., for \"hello\" and windows of size four,\n // run it(\"hell\") and it(\"ello\"), then return \"llo\"\n fn windows_with_carry(bb: &[u8], nn: uint,\n-                      it: fn(window: &[u8])) -> ~[u8] {\n+                      it: &fn(window: &[u8])) -> ~[u8] {\n    let mut ii = 0u;\n \n    let len = vec::len(bb);"}, {"sha": "f6b9a82ec676ca0aac38ae298eb2b9eeeb4b27f4", "filename": "src/test/compile-fail/access-mode-in-closures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Faccess-mode-in-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Faccess-mode-in-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Faccess-mode-in-closures.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-enum sty = ~[int];\n+struct sty(~[int]);\n \n fn unpack(_unpack: &fn(v: &sty) -> ~[int]) {}\n "}, {"sha": "2efc16de8307fbcd5819e3d8421878f14f014e3b", "filename": "src/test/compile-fail/arg-style-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Farg-style-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Farg-style-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farg-style-mismatch.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -11,5 +11,5 @@\n // error-pattern: mismatched types\n \n fn f(&&_x: int) {}\n-fn g(_a: fn(+v: int)) {}\n+fn g(_a: &fn(+v: int)) {}\n fn main() { g(f); }"}, {"sha": "8835c577fa8fdf8995d267f0992c4a06fe4c2ef0", "filename": "src/test/compile-fail/bad-for-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fbad-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fbad-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-for-loop.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    fn baz(_x: fn(y: int) -> int) {}\n+    fn baz(_x: &fn(y: int) -> int) {}\n     for baz |_e| { } //~ ERROR A `for` loop iterator should expect a closure that returns `bool`\n }"}, {"sha": "95ff995258fad17ec76dc79a8e1e8f1bcf1d3593", "filename": "src/test/compile-fail/block-coerce-no-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no-2.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -15,7 +15,7 @@ fn main() {\n     fn f(f: extern fn(extern fn(extern fn()))) {\n     }\n \n-    fn g(f: extern fn(fn())) {\n+    fn g(f: extern fn(&fn())) {\n     }\n \n     f(g);"}, {"sha": "980dc66b4af5980e8ba3472de019fcdad471c3b7", "filename": "src/test/compile-fail/block-coerce-no.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -11,9 +11,9 @@\n // Make sure that fn-to-block coercion isn't incorrectly lifted over\n // other tycons.\n \n-fn coerce(b: fn()) -> extern fn() {\n-    fn lol(+f: extern fn(+v: fn()) -> extern fn(),\n-           +g: fn()) -> extern fn() { return f(g); }\n+fn coerce(b: &fn()) -> extern fn() {\n+    fn lol(+f: extern fn(+v: &fn()) -> extern fn(),\n+           +g: &fn()) -> extern fn() { return f(g); }\n     fn fn_id(+f: extern fn()) -> extern fn() { return f }\n     return lol(fn_id, b);\n     //~^ ERROR mismatched types"}, {"sha": "25b56abb5ba005a1ff02e46e840b6e600733f8ea", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -22,7 +22,7 @@ fn a() {\n     p[0] = 5; //~ ERROR assigning to mutable vec content prohibited due to outstanding loan\n }\n \n-fn borrow(_x: &[int], _f: fn()) {}\n+fn borrow(_x: &[int], _f: &fn()) {}\n \n fn b() {\n     // here we alias the mutable vector into an imm slice and try to"}, {"sha": "a35d88a76f393c20c2b105e38bd790804545d374", "filename": "src/test/compile-fail/borrowck-assign-to-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-enum.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum foo = int;\n+struct foo(int);\n \n fn main() {\n     let x = foo(3);\n-    *x = 4; //~ ERROR assigning to enum content\n+    *x = 4; //~ ERROR assigning to anonymous field\n }"}, {"sha": "b874eac34b18c2c504ace1d1ce43f6a5e66ea182", "filename": "src/test/compile-fail/borrowck-autoref-3261.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,9 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum X = Either<(uint,uint),extern fn()>;\n+struct X(Either<(uint,uint),extern fn()>);\n+\n pub impl &'self X {\n-    fn with(blk: fn(x: &Either<(uint,uint),extern fn()>)) {\n+    fn with(blk: &fn(x: &Either<(uint,uint),extern fn()>)) {\n         blk(&**self)\n     }\n }"}, {"sha": "788c5397e35d0c236fe555047222ffd3d3a265fd", "filename": "src/test/compile-fail/borrowck-insert-during-each.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -15,7 +15,7 @@ struct Foo {\n }\n \n pub impl Foo {\n-  fn foo(&mut self, fun: fn(&int)) {\n+  fn foo(&mut self, fun: &fn(&int)) {\n     for self.n.each |f| {\n       fun(f);\n     }"}, {"sha": "ed6446a6311b8dbd5b06110fac120fc2851bd25f", "filename": "src/test/compile-fail/borrowck-lend-flow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -94,7 +94,7 @@ fn loop_in_block() {\n }\n \n fn at_most_once_block() {\n-    fn at_most_once(f: fn()) { f() }\n+    fn at_most_once(f: &fn()) { f() }\n \n     // Here, the borrow check has no way of knowing that the block is\n     // executed at most once."}, {"sha": "784fce1300f769cef13b3ed3d0f4aeaa18d85243", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn borrow(v: &int, f: fn(x: &int)) {\n+fn borrow(v: &int, f: &fn(x: &int)) {\n     f(v);\n }\n "}, {"sha": "332ec3fe697d0cbe0be8524192c833bc5cb91ef7", "filename": "src/test/compile-fail/borrowck-loan-blocks-mut-uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn borrow(v: &int, f: fn(x: &int)) {\n+fn borrow(v: &int, f: &fn(x: &int)) {\n     f(v);\n }\n "}, {"sha": "ece9ae7e86199faab96520e76cc406196199e9d1", "filename": "src/test/compile-fail/borrowck-loan-in-overloaded-op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-test #3387\n \n-enum foo = ~uint;\n+struct foo(~uint);\n \n impl Add<foo, foo> for foo {\n     pure fn add(f: &foo) -> foo {"}, {"sha": "85989bf9d21402fc8f3ca2861395d3891d4a83fd", "filename": "src/test/compile-fail/borrowck-loan-rcvr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -12,15 +12,15 @@ struct point { x: int, y: int }\n \n trait methods {\n     fn impurem();\n-    fn blockm(f: fn());\n+    fn blockm(f: &fn());\n     pure fn purem();\n }\n \n impl methods for point {\n     fn impurem() {\n     }\n \n-    fn blockm(f: fn()) { f() }\n+    fn blockm(f: &fn()) { f() }\n \n     pure fn purem() {\n     }"}, {"sha": "d27d690437affb79993a7805f717f26dd6045e16", "filename": "src/test/compile-fail/borrowck-loan-vec-content.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -12,7 +12,7 @@\n // (locally rooted) mutable, unique vector, and that we then prevent\n // modifications to the contents.\n \n-fn takes_imm_elt(_v: &int, f: fn()) {\n+fn takes_imm_elt(_v: &int, f: &fn()) {\n     f();\n }\n \n@@ -29,7 +29,7 @@ fn has_mut_vec_but_tries_to_change_it() {\n     }\n }\n \n-fn takes_const_elt(_v: &const int, f: fn()) {\n+fn takes_const_elt(_v: &const int, f: &fn()) {\n     f();\n }\n "}, {"sha": "540793d4135f26a8417f2579e41a90adb0bf108a", "filename": "src/test/compile-fail/borrowck-mut-deref-comp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-deref-comp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-deref-comp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-deref-comp.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum foo = ~int;\n+struct foo(~int);\n \n fn borrow(x: @mut foo) {\n     let _y = &***x; //~ ERROR illegal borrow unless pure"}, {"sha": "520772f1ceea9e821e448b63c73bfe1e48745f4f", "filename": "src/test/compile-fail/borrowck-unary-move-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move-2.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -24,9 +24,9 @@ fn noncopyable() -> noncopyable {\n     }\n }\n \n-enum wrapper = noncopyable;\n+struct wrapper(noncopyable);\n \n fn main() {\n     let x1 = wrapper(noncopyable());\n-    let _x2 = *x1; //~ ERROR moving out of enum content\n+    let _x2 = *x1; //~ ERROR moving out of anonymous field\n }"}, {"sha": "aad0e8bcbb6dd874fa5ead459190574cdcfeb112", "filename": "src/test/compile-fail/closure-that-fails.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fclosure-that-fails.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fclosure-that-fails.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-that-fails.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -1,4 +1,4 @@\n-fn foo(f: fn() -> !) {}\n+fn foo(f: &fn() -> !) {}\n \n fn main() {\n     // Type inference didn't use to be able to handle this:"}, {"sha": "cccf66ef2d54ead9a8bcd92bad854d224b4de45c", "filename": "src/test/compile-fail/enum-in-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fenum-in-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fenum-in-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-in-scope.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum hello = int;\n+struct hello(int);\n \n fn main() {\n     let hello = 0; //~ERROR declaration of `hello` shadows"}, {"sha": "4daa7f71adf28e3c6a758941ac316286f546bad9", "filename": "src/test/compile-fail/extern-wrong-value-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -13,5 +13,5 @@ extern fn f() {\n \n fn main() {\n     // extern functions are *u8 types\n-    let _x: fn() = f; //~ ERROR mismatched types: expected `&fn()` but found `*u8`\n+    let _x: &fn() = f; //~ ERROR mismatched types: expected `&fn()` but found `*u8`\n }"}, {"sha": "c5c29bd3ecfe70908b8f3bf498f31350c9716915", "filename": "src/test/compile-fail/fn-variance-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Ffn-variance-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Ffn-variance-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-variance-1.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -14,7 +14,7 @@ fn takes_mut(&&x: @mut int) { }\n fn takes_const(&&x: @const int) { }\n fn takes_imm(&&x: @int) { }\n \n-fn apply<T>(t: T, f: fn(T)) {\n+fn apply<T>(t: T, f: &fn(T)) {\n     f(t)\n }\n "}, {"sha": "2084729372d1dea12a1e40ec1e6d90afdd1de28b", "filename": "src/test/compile-fail/immut-function-arguments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fimmut-function-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fimmut-function-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimmut-function-arguments.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -13,7 +13,7 @@ fn f(y: ~int) {\n }\n \n fn g() {\n-    let _frob: fn(~int) = |q| { *q = 2; }; //~ ERROR assigning to dereference of immutable ~ pointer\n+    let _frob: &fn(~int) = |q| { *q = 2; }; //~ ERROR assigning to dereference of immutable ~ pointer\n \n }\n "}, {"sha": "db054d5aba700297c787625daca9f35b922f8097", "filename": "src/test/compile-fail/issue-2063-resource.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fissue-2063-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fissue-2063-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2063-resource.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -16,7 +16,7 @@ struct t { //~ ERROR this type cannot be instantiated\n   to_str: (),\n }\n \n-enum x = @t; //~ ERROR this type cannot be instantiated\n+struct x(@t); //~ ERROR this type cannot be instantiated\n \n fn main() {\n }"}, {"sha": "0ebf0218efe6d1c2788427239462507992cdadc7", "filename": "src/test/compile-fail/issue-2063.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2063.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -1,3 +1,5 @@\n+// xfail-test\n+\n // Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -11,7 +13,7 @@\n // test that autoderef of a type like this does not\n // cause compiler to loop.  Note that no instances\n // of such a type could ever be constructed.\n-enum t = @t; //~ ERROR this type cannot be instantiated\n+struct t(@t); //~ ERROR this type cannot be instantiated\n \n trait to_str_2 {\n     fn to_str() -> ~str;"}, {"sha": "361a20ad45133ce83ce5b00692aac015a2feb5af", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n trait vec_monad<A> {\n-    fn bind<B>(f: fn(A) -> ~[B]);\n+    fn bind<B>(f: &fn(A) -> ~[B]);\n }\n \n impl<A> vec_monad<A> for ~[A] {\n-    fn bind<B>(f: fn(A) -> ~[B]) {\n+    fn bind<B>(f: &fn(A) -> ~[B]) {\n         let mut r = fail!();\n         for self.each |elt| { r += f(*elt); }\n         //~^ WARNING unreachable expression"}, {"sha": "8afaf8995c291f0ace90aa6c2b12d424f2e0d333", "filename": "src/test/compile-fail/issue-2718-a.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fissue-2718-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fissue-2718-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2718-a.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -1,3 +1,5 @@\n+// xfail-test\n+\n // Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -16,7 +18,7 @@ pub struct send_packet<T> {\n mod pingpong {\n     use send_packet;\n     pub type ping = send_packet<pong>;\n-    pub enum pong = send_packet<ping>; //~ ERROR illegal recursive enum type; wrap the inner value in a box to make it representable\n+    pub struct pong(send_packet<ping>); //~ ERROR illegal recursive enum type; wrap the inner value in a box to make it representable\n }\n \n fn main() {}"}, {"sha": "6084552f0ed6da17aa3d28eef8991c677af1afd5", "filename": "src/test/compile-fail/issue-2817-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fissue-2817-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fissue-2817-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2817-2.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn not_bool(f: fn(int) -> ~str) {}\n+fn not_bool(f: &fn(int) -> ~str) {}\n \n fn main() {\n     for uint::range(0, 100000) |_i| { //~ ERROR A for-loop body must return (), but"}, {"sha": "02df25d87d7fb9a7a9ffa485e2a800bfd8f75c87", "filename": "src/test/compile-fail/issue-3080.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fissue-3080.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fissue-3080.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3080.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // xfail-test\n-enum x = ();\n+struct x(());\n pub impl x {\n     unsafe fn with() { } // This should fail\n }"}, {"sha": "df768860cba94817f1f297e5ed4222fd25669276", "filename": "src/test/compile-fail/issue-3344.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum thing = uint;\n+struct thing(uint);\n impl cmp::Ord for thing { //~ ERROR missing method `gt`\n     pure fn lt(&self, other: &thing) -> bool { **self < **other }\n     pure fn le(&self, other: &thing) -> bool { **self < **other }"}, {"sha": "bfc17c589db91ed69af911b7443008507c87263a", "filename": "src/test/compile-fail/issue-3953.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -20,7 +20,7 @@ trait Hahaha: Eq + Eq + Eq + Eq + Eq + //~ ERROR Duplicate supertrait\n               Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq + Eq +\n               Eq {}\n \n-enum Lol = int;\n+struct Lol(int);\n \n impl Hahaha for Lol { }\n "}, {"sha": "b1fc6a870d0867a2618cefaf56b997a4bc3ccdcf", "filename": "src/test/compile-fail/liveness-closure-require-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fliveness-closure-require-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fliveness-closure-require-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-closure-require-ret.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn force(f: fn() -> int) -> int { f() }\n+fn force(f: &fn() -> int) -> int { f() }\n fn main() { log(debug, force(|| {})); } //~ ERROR mismatched types"}, {"sha": "c0de60fa58e3f985afb45f73b5d56fa20bc2973a", "filename": "src/test/compile-fail/liveness-use-after-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -14,7 +14,7 @@ fn send<T:Owned>(ch: _chan<T>, -data: T) {\n     fail!();\n }\n \n-enum _chan<T> = int;\n+struct _chan<T>(int);\n \n // Tests that \"log(debug, message);\" is flagged as using\n // message after the send deinitializes it"}, {"sha": "974f30feb065185be8b11202167fc12df867087d", "filename": "src/test/compile-fail/missing-do.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -10,7 +10,7 @@\n \n // Regression test for issue #2783\n \n-fn foo(f: fn()) { f() }\n+fn foo(f: &fn()) { f() }\n \n fn main() {\n     ~\"\" || 42; //~ ERROR binary operation || cannot be applied to type `~str`"}, {"sha": "d9f6cf8b2d722dcd5666bc2c783cca7e569bdc42", "filename": "src/test/compile-fail/mode-inference-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmode-inference-fail.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -13,8 +13,8 @@\n // In this test, the mode gets inferred to ++ due to the apply_int(),\n // but then we get a failure in the generic apply().\n \n-fn apply<A>(f: fn(A) -> A, a: A) -> A { f(a) }\n-fn apply_int(f: fn(int) -> int, a: int) -> int { f(a) }\n+fn apply<A>(f: &fn(A) -> A, a: A) -> A { f(a) }\n+fn apply_int(f: &fn(int) -> int, a: int) -> int { f(a) }\n \n fn main() {\n     let f = {|i| i};"}, {"sha": "4d89ec14d94b243a0167d1c9889230d7466403db", "filename": "src/test/compile-fail/pat-shadow-in-nested-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fpat-shadow-in-nested-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fpat-shadow-in-nested-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpat-shadow-in-nested-binding.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum foo = uint;\n+struct foo(uint);\n \n fn main() {\n     let (foo, _) = (2, 3); //~ ERROR declaration of `foo` shadows"}, {"sha": "6d262bc04e1e482a77bf8ada93868dffc5e3a07a", "filename": "src/test/compile-fail/pure-higher-order.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -16,21 +16,21 @@ struct S<'self> {\n     f: &'self fn(uint)\n }\n \n-pure fn range(from: uint, to: uint, f: fn(uint)) {\n+pure fn range(from: uint, to: uint, f: &fn(uint)) {\n     let mut i = from;\n     while i < to {\n         f(i); // Note: legal to call argument, even if it is not pure.\n         i += 1u;\n     }\n }\n \n-pure fn range2(from: uint, to: uint, f: fn(uint)) {\n+pure fn range2(from: uint, to: uint, f: &fn(uint)) {\n     do range(from, to) |i| {\n         f(i*2u);\n     }\n }\n \n-pure fn range3(from: uint, to: uint, f: fn(uint)) {\n+pure fn range3(from: uint, to: uint, f: &fn(uint)) {\n     range(from, to, f)\n }\n "}, {"sha": "3e5296530fa35c11772c0cc6966793f3a36e29ba", "filename": "src/test/compile-fail/purity-infer-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fpurity-infer-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fpurity-infer-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpurity-infer-fail.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn something(f: pure fn()) { f(); }\n+fn something(f: &pure fn()) { f(); }\n \n fn main() {\n     let mut x = ~[];"}, {"sha": "eda207f711d68865e3f3a12536929c68e65fb46b", "filename": "src/test/compile-fail/qquote-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -62,7 +62,7 @@ fn main() {\n     check_pp(expr3,  pprust::print_expr, \"2 - 23 + 7\");\n }\n \n-fn check_pp<T>(expr: T, f: fn(pprust::ps, T), expect: str) {\n+fn check_pp<T>(expr: T, f: &fn(pprust::ps, T), expect: str) {\n     fail!();\n }\n "}, {"sha": "c669053400831142b9bcfa24376345ba463338e3", "filename": "src/test/compile-fail/qquote-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -57,7 +57,7 @@ fn main() {\n     check_pp(*stmt,  pprust::print_stmt, \"\");\n }\n \n-fn check_pp<T>(expr: T, f: fn(pprust::ps, T), expect: str) {\n+fn check_pp<T>(expr: T, f: &fn(pprust::ps, T), expect: str) {\n     fail!();\n }\n "}, {"sha": "35bef5a407a5574059ad0fc4fccd66a554588f51", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -12,7 +12,7 @@\n // nominal types (but not on other types) and that they are type\n // checked.\n \n-enum an_enum = &'self int;\n+struct an_enum(&'self int);\n trait a_trait {\n     fn foo() -> &'self int;\n }"}, {"sha": "88f2eefd369052fd72cd1ca940e31f4c576e8817", "filename": "src/test/compile-fail/regions-creating-enums.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -29,7 +29,7 @@ fn compute(x: &ast) -> uint {\n     }\n }\n \n-fn map_nums(x: &ast, f: fn(uint) -> uint) -> &ast {\n+fn map_nums(x: &ast, f: &fn(uint) -> uint) -> &ast {\n     match *x {\n       num(x) => {\n         return &num(f(x)); //~ ERROR illegal borrow"}, {"sha": "9cee55643f89ca620a7cdac69375d8ec94d41db6", "filename": "src/test/compile-fail/regions-escape-bound-fn-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn-2.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn with_int(f: fn(x: &int)) {\n+fn with_int(f: &fn(x: &int)) {\n     let x = 3;\n     f(&x);\n }"}, {"sha": "c81ef77f497db8b7a9d0f0c33684588b02e3a601", "filename": "src/test/compile-fail/regions-escape-bound-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-bound-fn.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn with_int(f: fn(x: &int)) {\n+fn with_int(f: &fn(x: &int)) {\n     let x = 3;\n     f(&x);\n }"}, {"sha": "767d7c9174dfae79a64f0760dd9a51621e5b21cd", "filename": "src/test/compile-fail/regions-escape-via-trait-or-not.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -18,7 +18,7 @@ impl deref for &'self int {\n     }\n }\n \n-fn with<R:deref>(f: fn(x: &int) -> R) -> int {\n+fn with<R:deref>(f: &fn(x: &int) -> R) -> int {\n     f(&3).get()\n }\n "}, {"sha": "50674ac81fecfa15cdbfb01f632a6bc11678a895", "filename": "src/test/compile-fail/regions-fn-subtyping.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -17,41 +17,41 @@ fn test_fn<T>(_x: &x/T, _y: &y/T, _z: &z/T) {\n     // subtype::<T1>(of::<T2>()) will typecheck\n     // iff T1 <: T2.\n \n-    subtype::<fn(&a/T)>(\n-        of::<fn(&a/T)>());\n+    subtype::<&fn(&a/T)>(\n+        of::<&fn(&a/T)>());\n \n-    subtype::<fn(&a/T)>(\n-        of::<fn(&b/T)>());\n+    subtype::<&fn(&a/T)>(\n+        of::<&fn(&b/T)>());\n \n-    subtype::<fn(&b/T)>(\n-        of::<fn(&x/T)>());\n+    subtype::<&fn(&b/T)>(\n+        of::<&fn(&x/T)>());\n \n-    subtype::<fn(&x/T)>(\n-        of::<fn(&b/T)>());  //~ ERROR mismatched types\n+    subtype::<&fn(&x/T)>(\n+        of::<&fn(&b/T)>());  //~ ERROR mismatched types\n \n-    subtype::<fn(&a/T, &b/T)>(\n-        of::<fn(&a/T, &a/T)>());\n+    subtype::<&fn(&a/T, &b/T)>(\n+        of::<&fn(&a/T, &a/T)>());\n \n-    subtype::<fn(&a/T, &a/T)>(\n-        of::<fn(&a/T, &b/T)>()); //~ ERROR mismatched types\n+    subtype::<&fn(&a/T, &a/T)>(\n+        of::<&fn(&a/T, &b/T)>()); //~ ERROR mismatched types\n \n-    subtype::<fn(&a/T, &b/T)>(\n-        of::<fn(&x/T, &y/T)>());\n+    subtype::<&fn(&a/T, &b/T)>(\n+        of::<&fn(&x/T, &y/T)>());\n \n-    subtype::<fn(&x/T, &y/T)>(\n-        of::<fn(&a/T, &b/T)>()); //~ ERROR mismatched types\n+    subtype::<&fn(&x/T, &y/T)>(\n+        of::<&fn(&a/T, &b/T)>()); //~ ERROR mismatched types\n \n-    subtype::<fn(&x/T) -> @fn(&a/T)>(\n-        of::<fn(&x/T) -> @fn(&a/T)>());\n+    subtype::<&fn(&x/T) -> @fn(&a/T)>(\n+        of::<&fn(&x/T) -> @fn(&a/T)>());\n \n-    subtype::<fn(&a/T) -> @fn(&a/T)>(\n-        of::<fn(&a/T) -> @fn(&b/T)>()); //~ ERROR mismatched types\n+    subtype::<&fn(&a/T) -> @fn(&a/T)>(\n+        of::<&fn(&a/T) -> @fn(&b/T)>()); //~ ERROR mismatched types\n \n-    subtype::<fn(&a/T) -> @fn(&a/T)>(\n-        of::<fn(&x/T) -> @fn(&b/T)>()); //~ ERROR mismatched types\n+    subtype::<&fn(&a/T) -> @fn(&a/T)>(\n+        of::<&fn(&x/T) -> @fn(&b/T)>()); //~ ERROR mismatched types\n \n-    subtype::<fn(&a/T) -> @fn(&b/T)>(\n-        of::<fn(&a/T) -> @fn(&a/T)>());\n+    subtype::<&fn(&a/T) -> @fn(&b/T)>(\n+        of::<&fn(&a/T) -> @fn(&a/T)>());\n }\n \n fn main() {}"}, {"sha": "ef8f6748d36af8c571c55746ae00127fbbe6e560", "filename": "src/test/compile-fail/regions-infer-borrow-scope-within-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-borrow-scope-within-loop.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -10,7 +10,7 @@\n \n fn borrow<T>(x: &r/T) -> &r/T {x}\n \n-fn foo(cond: fn() -> bool, box: fn() -> @int) {\n+fn foo(cond: &fn() -> bool, box: &fn() -> @int) {\n     let mut y: &int;\n     loop {\n         let x = box();"}, {"sha": "49d3f6aee65c8825d74ea16383319170d5bb32e3", "filename": "src/test/compile-fail/regions-infer-call-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-infer-call-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-infer-call-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-call-3.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -10,7 +10,7 @@\n \n fn select(x: &r/int, y: &r/int) -> &r/int { x }\n \n-fn with<T>(f: fn(x: &int) -> T) -> T {\n+fn with<T>(f: &fn(x: &int) -> T) -> T {\n     f(&20)\n }\n "}, {"sha": "4c3338d2e1d0c52afc968d4f5cb2e588780279f5", "filename": "src/test/compile-fail/regions-infer-region-in-fn-but-not-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-infer-region-in-fn-but-not-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-infer-region-in-fn-but-not-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-region-in-fn-but-not-type.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -11,7 +11,7 @@\n \n // check that the &int here does not cause us to think that `foo`\n // contains region pointers\n-enum foo = ~fn(x: &int);\n+struct foo(~fn(x: &int));\n \n fn take_foo(x: foo<'static>) {} //~ ERROR no region bound is allowed on `foo`\n "}, {"sha": "ab6a37b58de6fa7c6367814b94bb27c0e69ef652", "filename": "src/test/compile-fail/regions-ret-borrowed-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -12,7 +12,7 @@\n // some point regions-ret-borrowed reported an error but this file did\n // not, due to special hardcoding around the anonymous region.\n \n-fn with<R>(f: fn(x: &a/int) -> R) -> R {\n+fn with<R>(f: &fn(x: &a/int) -> R) -> R {\n     f(&3)\n }\n "}, {"sha": "157b99de9e80685477f06f789f13851d79641030", "filename": "src/test/compile-fail/regions-ret-borrowed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -15,7 +15,7 @@\n // used to successfully compile because we failed to account for the\n // fact that fn(x: &int) rebound the region &.\n \n-fn with<R>(f: fn(x: &int) -> R) -> R {\n+fn with<R>(f: &fn(x: &int) -> R) -> R {\n     f(&3)\n }\n "}, {"sha": "e675d4d455f2c801c84d66f850d9f7eee09bca40", "filename": "src/test/compile-fail/regions-scoping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-scoping.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn with<T>(t: T, f: fn(T)) { f(t) }\n+fn with<T>(t: T, f: &fn(T)) { f(t) }\n \n fn nested<'x>(x: &'x int) {  // (1)\n     do with("}, {"sha": "9e19ecdcb755691ba7b27bed5088082651f5df8f", "filename": "src/test/compile-fail/tps-invariant-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Ftps-invariant-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Ftps-invariant-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftps-invariant-enum.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -12,7 +12,7 @@ struct box<T> {\n     f: T\n }\n \n-enum box_impl<T> = box<T>;\n+struct box_impl<T>(box<T>);\n \n fn set_box_impl<T>(b: box_impl<@const T>, v: @const T) {\n     b.f = v;"}, {"sha": "9569e5f1e8210fe58383f4a5813c7ca048ac80e5", "filename": "src/test/compile-fail/tps-invariant-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Ftps-invariant-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Ftps-invariant-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftps-invariant-trait.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -17,7 +17,7 @@ struct box<T> {\n     f: T\n }\n \n-enum box_impl<T> = box<T>;\n+struct box_impl<T>(box<T>);\n \n impl<T:Copy> box_trait<T> for box_impl<T> {\n     fn get() -> T { return self.f; }"}, {"sha": "07dc677c0476338b7a0a76a795bda0b481d02256", "filename": "src/test/compile-fail/type-arg-out-of-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Ftype-arg-out-of-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Fcompile-fail%2Ftype-arg-out-of-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-arg-out-of-scope.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -10,6 +10,6 @@\n \n // error-pattern:attempt to use a type argument out of scope\n fn foo<T>(x: T) {\n-    fn bar(f: fn(T) -> T) { }\n+    fn bar(f: &fn(T) -> T) { }\n }\n fn main() { foo(1); }"}, {"sha": "1b28d2f6c6d63ee9d9eab7069020c83eb4833b74", "filename": "src/test/run-fail/unwind-iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-fail%2Funwind-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-fail%2Funwind-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-iter.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -10,7 +10,7 @@\n \n // error-pattern:fail\n \n-fn x(it: fn(int)) {\n+fn x(it: &fn(int)) {\n     fail!();\n     it(0);\n }"}, {"sha": "286e5f4976430cf93c178f32790d99d742085762", "filename": "src/test/run-fail/unwind-iter2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-fail%2Funwind-iter2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-fail%2Funwind-iter2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-iter2.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -10,7 +10,7 @@\n \n // error-pattern:fail\n \n-fn x(it: fn(int)) {\n+fn x(it: &fn(int)) {\n     let a = @0;\n     it(1);\n }"}, {"sha": "613480e3a63cdaa604e9b89e8d0b4bc0b2dc11bf", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -75,7 +75,7 @@ fn main() {\n }\n \n fn check_pp<T>(cx: fake_ext_ctxt,\n-               expr: T, f: fn(pprust::ps, T), expect: ~str) {\n+               expr: T, f: &fn(pprust::ps, T), expect: ~str) {\n     let s = do io::with_str_writer |wr| {\n         let pp = pprust::rust_printer(wr, cx.parse_sess().interner);\n         f(pp, expr);"}, {"sha": "22855bce28fca37798b7025ad7be53980525d245", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -12,7 +12,7 @@ struct Pair<A,B> {\n     a: A, b: B\n }\n \n-enum RecEnum<A> = Rec<A>;\n+struct RecEnum<A>(Rec<A>);\n struct Rec<A> {\n     val: A,\n     rec: Option<@mut RecEnum<A>>"}, {"sha": "40d215883500256bd51a97248f07623a365bd67a", "filename": "src/test/run-pass/alt-phi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Falt-phi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Falt-phi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-phi.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -12,7 +12,7 @@\n \n enum thing { a, b, c, }\n \n-fn foo(it: fn(int)) { it(10); }\n+fn foo(it: &fn(int)) { it(10); }\n \n pub fn main() {\n     let mut x = true;"}, {"sha": "ae046babfdf83edd59c8446a16bf5080ee6910b7", "filename": "src/test/run-pass/assignability-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-trait.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -13,19 +13,19 @@\n // it.\n \n trait iterable<A> {\n-    fn iterate(blk: fn(x: &A) -> bool);\n+    fn iterate(blk: &fn(x: &A) -> bool);\n }\n \n impl<A> iterable<A> for &self/[A] {\n-    fn iterate(f: fn(x: &A) -> bool) {\n+    fn iterate(f: &fn(x: &A) -> bool) {\n         for vec::each(self) |e| {\n             if !f(e) { break; }\n         }\n     }\n }\n \n impl<A> iterable<A> for ~[A] {\n-    fn iterate(f: fn(x: &A) -> bool) {\n+    fn iterate(f: &fn(x: &A) -> bool) {\n         for vec::each(self) |e| {\n             if !f(e) { break; }\n         }"}, {"sha": "b6fdb07789c8da639519aac88e985092f4ccc3ea", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -85,13 +85,6 @@ impl cmp::Eq for Expr {\n     pure fn ne(&self, other: &Expr) -> bool { !(*self).eq(other) }\n }\n \n-impl cmp::Eq for AnEnum {\n-    pure fn eq(&self, other: &AnEnum) -> bool {\n-        (*self).v == other.v\n-    }\n-    pure fn ne(&self, other: &AnEnum) -> bool { !(*self).eq(other) }\n-}\n-\n impl cmp::Eq for Point {\n     pure fn eq(&self, other: &Point) -> bool {\n         self.x == other.x && self.y == other.y\n@@ -139,10 +132,6 @@ struct Spanned<T> {\n #[auto_decode]\n struct SomeStruct { v: ~[uint] }\n \n-#[auto_encode]\n-#[auto_decode]\n-enum AnEnum = SomeStruct;\n-\n #[auto_encode]\n #[auto_decode]\n struct Point {x: uint, y: uint}\n@@ -168,10 +157,6 @@ pub fn main() {\n     test_prettyprint(a, &~\"Spanned {lo: 0u, hi: 5u, node: 22u}\");\n     test_ebml(a);\n \n-    let a = &AnEnum(SomeStruct {v: ~[1u, 2u, 3u]});\n-    test_prettyprint(a, &~\"AnEnum(SomeStruct {v: ~[1u, 2u, 3u]})\");\n-    test_ebml(a);\n-\n     let a = &Point {x: 3u, y: 5u};\n     test_prettyprint(a, &~\"Point {x: 3u, y: 5u}\");\n     test_ebml(a);"}, {"sha": "9a84aa6a10e4a814c5fbc741aefa62faf3f61534", "filename": "src/test/run-pass/auto-ref-newtype.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fauto-ref-newtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fauto-ref-newtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-newtype.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -11,7 +11,7 @@\n // Check that we can define inherent methods on newtype enums that use\n // an auto-ref'd receiver.\n \n-enum Foo = uint;\n+struct Foo(uint);\n \n pub impl Foo {\n     fn len(&self) -> uint { **self }"}, {"sha": "44688a8dfce964541cce1277c91dc91180b7019c", "filename": "src/test/run-pass/autobind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fautobind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fautobind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautobind.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -10,10 +10,10 @@\n \n fn f<T:Copy>(x: ~[T]) -> T { return x[0]; }\n \n-fn g(act: fn(~[int]) -> int) -> int { return act(~[1, 2, 3]); }\n+fn g(act: &fn(~[int]) -> int) -> int { return act(~[1, 2, 3]); }\n \n pub fn main() {\n     fail_unless!((g(f) == 1));\n-    let f1: fn(~[~str]) -> ~str = f;\n+    let f1: &fn(~[~str]) -> ~str = f;\n     fail_unless!((f1(~[~\"x\", ~\"y\", ~\"z\"]) == ~\"x\"));\n }"}, {"sha": "732c26694adb5fc5d84925f2a34f93d191f015fb", "filename": "src/test/run-pass/autoderef-method-newtype.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fautoderef-method-newtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fautoderef-method-newtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-newtype.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -16,7 +16,7 @@ impl double for uint {\n     fn double() -> uint { self * 2u }\n }\n \n-enum foo = uint;\n+struct foo(uint);\n \n pub fn main() {\n     let x = foo(3u);"}, {"sha": "b2e1bc515865a6abe751160f56f5e20293416bf3", "filename": "src/test/run-pass/block-arg-can-be-followed-by-block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    fn f(i: fn() -> uint) -> uint { i() }\n+    fn f(i: &fn() -> uint) -> uint { i() }\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n     let z = do do vec::foldl(f, v) |x, _y| { x } { 22u };\n     fail_unless!(z == 22u);"}, {"sha": "ae110a04773742af91b10816b358c4cfbf396a68", "filename": "src/test/run-pass/block-arg-used-as-any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn call_any(f: fn() -> uint) -> uint {\n+fn call_any(f: &fn() -> uint) -> uint {\n     return f();\n }\n "}, {"sha": "b24a655667a6b8727bfeb84703edf127089d8128", "filename": "src/test/run-pass/block-explicit-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-explicit-types.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n pub fn main() {\n-    fn as_buf<T>(s: ~str, f: fn(~str) -> T) -> T { f(s) }\n+    fn as_buf<T>(s: ~str, f: &fn(~str) -> T) -> T { f(s) }\n     as_buf(~\"foo\", |foo: ~str| -> () log(error, foo) );\n }"}, {"sha": "dc8ad25e27606329e01a0df8f3a8edc64842d737", "filename": "src/test/run-pass/block-fn-coerce.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fblock-fn-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fblock-fn-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-fn-coerce.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn force(f: fn() -> int) -> int { return f(); }\n+fn force(f: &fn() -> int) -> int { return f(); }\n pub fn main() {\n     fn f() -> int { return 7; }\n     fail_unless!((force(f) == 7));"}, {"sha": "d0a24f80c0b9074f5c0a399a14b6cb00e0d6d509", "filename": "src/test/run-pass/block-iter-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-fast\n \n-fn iter_vec<T>(v: ~[T], f: fn(&T)) { for v.each |x| { f(x); } }\n+fn iter_vec<T>(v: ~[T], f: &fn(&T)) { for v.each |x| { f(x); } }\n \n pub fn main() {\n     let v = ~[1, 2, 3, 4, 5, 6, 7];"}, {"sha": "acffb6830deded415928a819f5558b2f205e45f1", "filename": "src/test/run-pass/block-iter-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-fast\n \n-fn iter_vec<T>(v: ~[T], f: fn(&T)) { for v.each |x| { f(x); } }\n+fn iter_vec<T>(v: ~[T], f: &fn(&T)) { for v.each |x| { f(x); } }\n \n pub fn main() {\n     let v = ~[1, 2, 3, 4, 5];"}, {"sha": "0422be9d333df34e0aa4c0bfd91a6bbb98c4612e", "filename": "src/test/run-pass/borrowck-borrow-from-expr-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn borrow(x: &int, f: fn(x: &int)) {\n+fn borrow(x: &int, f: &fn(x: &int)) {\n     f(x)\n }\n "}, {"sha": "5f5b9c59d7680cfb53092a753d2d1b3b705db879", "filename": "src/test/run-pass/borrowck-mut-uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -18,7 +18,7 @@ fn add_int(x: &mut Ints, v: int) {\n     x.values <-> values;\n }\n \n-fn iter_ints(x: &Ints, f: fn(x: &int) -> bool) {\n+fn iter_ints(x: &Ints, f: &fn(x: &int) -> bool) {\n     let l = x.values.len();\n     uint::range(0, l, |i| f(&x.values[i]))\n }"}, {"sha": "795b074e37c4fa82e8c76a9c33c887addec29377", "filename": "src/test/run-pass/borrowck-preserve-box-in-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -10,7 +10,7 @@\n \n // exec-env:RUST_POISON_ON_FREE=1\n \n-fn borrow(x: &int, f: fn(x: &int)) {\n+fn borrow(x: &int, f: &fn(x: &int)) {\n     let before = *x;\n     f(x);\n     let after = *x;"}, {"sha": "11ec78b681cbbb422fadedcbd58391cc66399001", "filename": "src/test/run-pass/borrowck-preserve-box-in-uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -10,7 +10,7 @@\n \n // exec-env:RUST_POISON_ON_FREE=1\n \n-fn borrow(x: &int, f: fn(x: &int)) {\n+fn borrow(x: &int, f: &fn(x: &int)) {\n     let before = *x;\n     f(x);\n     let after = *x;"}, {"sha": "8d625476f57dc9c99d7bae76d0a01a6e2e5f5c7f", "filename": "src/test/run-pass/borrowck-preserve-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -10,7 +10,7 @@\n \n // exec-env:RUST_POISON_ON_FREE=1\n \n-fn borrow(x: &int, f: fn(x: &int)) {\n+fn borrow(x: &int, f: &fn(x: &int)) {\n     let before = *x;\n     f(x);\n     let after = *x;"}, {"sha": "fcb84eaaf00aba00f93a7ce1a6df25c194be8e82", "filename": "src/test/run-pass/borrowck-preserve-expl-deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -10,7 +10,7 @@\n \n // exec-env:RUST_POISON_ON_FREE=1\n \n-fn borrow(x: &int, f: fn(x: &int)) {\n+fn borrow(x: &int, f: &fn(x: &int)) {\n     let before = *x;\n     f(x);\n     let after = *x;"}, {"sha": "87573b84dc885dcbd2255486b2164ed2094a0a52", "filename": "src/test/run-pass/class-impl-parameterized-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-trait.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -57,17 +57,17 @@ class cat : map<int, bool> {\n   fn [](&&k:int) -> bool { k <= self.meows }\n   fn find(&&k:int) -> Option<bool> { Some(self.get(k)) }\n   fn remove(&&k:int) -> Option<bool> { self.meows -= k; Some(true) }\n-  fn each(f: fn(&&int, &&bool) -> bool) {\n+  fn each(f: &fn(&&int, &&bool) -> bool) {\n     let mut n = int::abs(self.meows);\n     while n > 0 {\n         if !f(n, true) { break; }\n         n -= 1;\n     }\n   }\n-  fn each_key(&&f: fn(&&int) -> bool) {\n+  fn each_key(&&f: &fn(&&int) -> bool) {\n     for self.each |k, _v| { if !f(k) { break; } again;};\n   }\n-  fn each_value(&&f: fn(&&bool) -> bool) {\n+  fn each_value(&&f: &fn(&&bool) -> bool) {\n     for self.each |_k, v| { if !f(v) { break; } again;};\n   }\n   fn clear() { }"}, {"sha": "6cb0749ddb57fd4d106e45452bb546b497854797", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -50,7 +50,7 @@ pub impl<T> cat<T> {\n }\n \n impl<T> BaseIter<(int, &'self T)> for cat<T> {\n-    pure fn each(&self, f: fn(&(int, &'self T)) -> bool) {\n+    pure fn each(&self, f: &fn(&(int, &'self T)) -> bool) {\n         let mut n = int::abs(self.meows);\n         while n > 0 {\n             if !f(&(n, &self.name)) { break; }\n@@ -73,11 +73,11 @@ impl<T> Mutable for cat<T> {\n impl<T> Map<int, T> for cat<T> {\n     pure fn contains_key(&self, k: &int) -> bool { *k <= self.meows }\n \n-    pure fn each_key(&self, f: fn(v: &int) -> bool) {\n+    pure fn each_key(&self, f: &fn(v: &int) -> bool) {\n         for self.each |&(k, _)| { if !f(&k) { break; } loop;};\n     }\n \n-    pure fn each_value(&self, f: fn(v: &T) -> bool) {\n+    pure fn each_value(&self, f: &fn(v: &T) -> bool) {\n         for self.each |&(_, v)| { if !f(v) { break; } loop;};\n     }\n "}, {"sha": "e525312d6da5b6d7c595727b4e555008967e1895", "filename": "src/test/run-pass/class-trait-bounded-param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fclass-trait-bounded-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fclass-trait-bounded-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-trait-bounded-param.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -22,9 +22,9 @@ class keys<K:Copy,V:Copy,M:Copy + map<K,V>>\n         self.map = map;\n     }\n \n-    fn each(blk: fn(K) -> bool) { self.map.each(|k, _v| blk(k) ) }\n+    fn each(blk: &fn(K) -> bool) { self.map.each(|k, _v| blk(k) ) }\n     fn size_hint() -> Option<uint> { Some(self.map.size()) }\n-    fn eachi(blk: fn(uint, K) -> bool) { iter::eachi(self, blk) }\n+    fn eachi(blk: &fn(uint, K) -> bool) { iter::eachi(self, blk) }\n }\n \n pub fn main() {"}, {"sha": "e61636a323a65a556c5262455debda938579eb32", "filename": "src/test/run-pass/closure-inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fclosure-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fclosure-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-inference.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -12,7 +12,7 @@\n \n fn foo(i: int) -> int { i + 1 }\n \n-fn apply<A>(f: fn(A) -> A, v: A) -> A { f(v) }\n+fn apply<A>(f: &fn(A) -> A, v: A) -> A { f(v) }\n \n pub fn main() {\n     let f = {|i| foo(i)};"}, {"sha": "9921389da6674c069095a5306082da5570148115", "filename": "src/test/run-pass/coherence-copy-bound.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/51cdca0bf0d3efc554c1815df9306ea10e881a14/src%2Ftest%2Frun-pass%2Fcoherence-copy-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51cdca0bf0d3efc554c1815df9306ea10e881a14/src%2Ftest%2Frun-pass%2Fcoherence-copy-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence-copy-bound.rs?ref=51cdca0bf0d3efc554c1815df9306ea10e881a14", "patch": "@@ -1,13 +0,0 @@\n-trait X {}\n-\n-impl<A:Copy> X for A {}\n-\n-struct S {\n-    x: int,\n-    drop {}\n-}\n-\n-impl X for S {}\n-\n-pub fn main(){}\n-"}, {"sha": "5aa9aeafeed2839af81553e58d09f68cd579f8fa", "filename": "src/test/run-pass/const-enum-newtype-align.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/51cdca0bf0d3efc554c1815df9306ea10e881a14/src%2Ftest%2Frun-pass%2Fconst-enum-newtype-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51cdca0bf0d3efc554c1815df9306ea10e881a14/src%2Ftest%2Frun-pass%2Fconst-enum-newtype-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-newtype-align.rs?ref=51cdca0bf0d3efc554c1815df9306ea10e881a14", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-enum E = u32;\n-struct S { a: u8, b: E }\n-const C: S = S { a: 0xA5, b: E(0xDEADBEEF) };\n-\n-pub fn main() {\n-    fail_unless!(C.b == 0xDEADBEEF);\n-}"}, {"sha": "b96b0e957c9907cdd742a60c1338226e51d5aecb", "filename": "src/test/run-pass/const-newtype-enum.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/51cdca0bf0d3efc554c1815df9306ea10e881a14/src%2Ftest%2Frun-pass%2Fconst-newtype-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51cdca0bf0d3efc554c1815df9306ea10e881a14/src%2Ftest%2Frun-pass%2Fconst-newtype-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-newtype-enum.rs?ref=51cdca0bf0d3efc554c1815df9306ea10e881a14", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-enum Foo = u32;\n-\n-const X: Foo = Foo(17);\n-\n-pub fn main() {\n-    fail_unless!((*X == 17));\n-    fail_unless!((*Y == 23));\n-}\n-\n-const Y: Foo = Foo(23);"}, {"sha": "c86c1768111f70776b2da2b7eb34e10177650dab", "filename": "src/test/run-pass/do-for-empty-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fdo-for-empty-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fdo-for-empty-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdo-for-empty-args.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -11,7 +11,7 @@\n // no-reformat\n // Testing various forms of `do` and `for` with empty arg lists\n \n-fn f(f: fn() -> bool) {\n+fn f(f: &fn() -> bool) {\n }\n \n pub fn main() {"}, {"sha": "41686cf5b3736baf5eb32c10cd07ad0653ecf927", "filename": "src/test/run-pass/do-pure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fdo-pure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fdo-pure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdo-pure.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pure fn f(f: fn()) {\n+pure fn f(f: &fn()) {\n }\n \n pure fn g() {"}, {"sha": "9ab6af0ac276e3094e1e08cf046be0bf9d69d172", "filename": "src/test/run-pass/fn-assign-managed-to-bare-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Ffn-assign-managed-to-bare-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Ffn-assign-managed-to-bare-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-assign-managed-to-bare-1.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -15,6 +15,6 @@ fn add(n: int) -> @fn(int) -> int {\n \n pub fn main() {\n       fail_unless!(add(3)(4) == 7);\n-      let add3 : fn(int)->int = add(3);\n+      let add3 : &fn(int)->int = add(3);\n       fail_unless!(add3(4) == 7);\n }"}, {"sha": "db7604d11484d583b7c67d31098363be64af10e1", "filename": "src/test/run-pass/fn-bare-coerce-to-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Ffn-bare-coerce-to-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Ffn-bare-coerce-to-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-bare-coerce-to-block.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -10,7 +10,7 @@\n \n fn bare() {}\n \n-fn likes_block(f: fn()) { f() }\n+fn likes_block(f: &fn()) { f() }\n \n pub fn main() {\n     likes_block(bare);"}, {"sha": "3f5d3818e1c12d57fccefaa65842569c44cef3b9", "filename": "src/test/run-pass/fn-pattern-expected-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Ffn-pattern-expected-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Ffn-pattern-expected-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-pattern-expected-type.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let f: fn((int,int)) = |(x, y)| {\n+    let f: &fn((int,int)) = |(x, y)| {\n         fail_unless!(x == 1);\n         fail_unless!(y == 2);\n     };"}, {"sha": "a94131b36c051db5d23d630c8fb46dcdf91a96b9", "filename": "src/test/run-pass/foreach-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -12,7 +12,7 @@\n \n \n // -*- rust -*-\n-fn two(it: fn(int)) { it(0); it(1); }\n+fn two(it: &fn(int)) { it(0); it(1); }\n \n pub fn main() {\n     let mut a: ~[int] = ~[-1, -1, -1, -1];"}, {"sha": "1a71cf52de25946971b82ee3a762e1982efa480f", "filename": "src/test/run-pass/foreach-put-structured.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -10,7 +10,7 @@\n \n \n \n-fn pairs(it: fn((int, int))) {\n+fn pairs(it: &fn((int, int))) {\n     let mut i: int = 0;\n     let mut j: int = 0;\n     while i < 10 { it((i, j)); i += 1; j += i; }"}, {"sha": "1c0b28982dbe1795389cef784c292eff8c9bd5d7", "filename": "src/test/run-pass/foreach-simple-outer-slot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -20,7 +20,7 @@ pub fn main() {\n     fail_unless!((sum == 45));\n }\n \n-fn first_ten(it: fn(int)) {\n+fn first_ten(it: &fn(int)) {\n     let mut i: int = 0;\n     while i < 10 { debug!(\"first_ten\"); it(i); i = i + 1; }\n }"}, {"sha": "c140a66ffe4d6c460d0f6199f973ca0f6b7a39ec", "filename": "src/test/run-pass/instantiable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Finstantiable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Finstantiable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finstantiable.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -11,7 +11,7 @@\n \n // check that we do not report a type like this as uninstantiable,\n // even though it would be if the nxt field had type @foo:\n-enum foo = X;\n+struct foo(X);\n \n struct X { x: uint, nxt: *foo }\n "}, {"sha": "a6556895dda3362a3680512c47d4617bcd88e186", "filename": "src/test/run-pass/issue-1458.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fissue-1458.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fissue-1458.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1458.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn plus_one(f: fn() -> int) -> int {\n+fn plus_one(f: &fn() -> int) -> int {\n   return f() + 1;\n }\n \n-fn ret_plus_one() -> extern fn(fn() -> int) -> int {\n+fn ret_plus_one() -> extern fn(&fn() -> int) -> int {\n   return plus_one;\n }\n "}, {"sha": "ac680d3d12e417ec3e7f806740f910ede98dc0cb", "filename": "src/test/run-pass/issue-2185.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fissue-2185.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fissue-2185.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2185.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -15,15 +15,15 @@\n // warrant still having a test, so I inlined the old definitions.\n \n trait iterable<A> {\n-    fn iter(blk: fn(A));\n+    fn iter(blk: &fn(A));\n }\n \n impl<A> iterable<A> for @fn(&fn(A)) {\n-    fn iter(blk: fn(A)) { self(blk); }\n+    fn iter(blk: &fn(A)) { self(blk); }\n }\n \n impl iterable<uint> for @fn(&fn(uint)) {\n-    fn iter(blk: fn(&&v: uint)) { self( |i| blk(i) ) }\n+    fn iter(blk: &fn(&&v: uint)) { self( |i| blk(i) ) }\n }\n \n fn filter<A,IA:iterable<A>>(self: IA, prd: @fn(A) -> bool, blk: &fn(A)) {"}, {"sha": "ad6320aed2bb7edf1a1652ec4782cb3ba8df4361", "filename": "src/test/run-pass/issue-2312.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fissue-2312.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fissue-2312.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2312.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -12,7 +12,7 @@\n \n trait clam<A> { }\n \n-enum foo = int;\n+struct foo(int);\n \n pub impl foo {\n     fn bar<B,C:clam<B>>(c: C) -> B { fail!(); }"}, {"sha": "138860ce72d1f6449f96d7ee748e1203733d779f", "filename": "src/test/run-pass/issue-2487-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fissue-2487-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fissue-2487-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2487-a.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -32,7 +32,7 @@ fn socket() -> socket {\n     }\n }\n \n-fn closure(f: fn()) { f() }\n+fn closure(f: &fn()) { f() }\n \n fn setsockopt_bytes(_sock: int) { }\n "}, {"sha": "af3e8e9c7a2b59340d44a89684c637461f61ff63", "filename": "src/test/run-pass/issue-2611.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fissue-2611.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fissue-2611.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2611.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -11,11 +11,11 @@\n use core::iter::BaseIter;\n \n trait FlatMapToVec<A> {\n-  fn flat_map_to_vec<B, IB:BaseIter<B>>(&self, op: fn(&A) -> IB) -> ~[B];\n+  fn flat_map_to_vec<B, IB:BaseIter<B>>(&self, op: &fn(&A) -> IB) -> ~[B];\n }\n \n impl<A:Copy> FlatMapToVec<A> for ~[A] {\n-   fn flat_map_to_vec<B, IB:BaseIter<B>>(&self, op: fn(&A) -> IB) -> ~[B] {\n+   fn flat_map_to_vec<B, IB:BaseIter<B>>(&self, op: &fn(&A) -> IB) -> ~[B] {\n      iter::flat_map_to_vec(self, op)\n    }\n }"}, {"sha": "1376f20571be6615181ee91c5b0ca05f64c5c792", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -225,8 +225,8 @@ pub mod pingpong {\n     use core::cast;\n     use core::ptr;\n \n-    pub enum ping = ::pipes::send_packet<pong>;\n-    pub enum pong = ::pipes::send_packet<ping>;\n+    pub struct ping(::pipes::send_packet<pong>);\n+    pub struct pong(::pipes::send_packet<ping>);\n \n     pub fn liberate_ping(-p: ping) -> ::pipes::send_packet<pong> {\n         unsafe {"}, {"sha": "8d62da9efad427991a4f56e8834821e088ff97a2", "filename": "src/test/run-pass/issue-3874.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fissue-3874.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fissue-3874.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3874.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -11,7 +11,7 @@\n // xfail-test\n enum PureCounter { PureCounter(uint) }\n \n-pure fn each(self: PureCounter, blk: fn(v: &uint)) {\n+pure fn each(self: PureCounter, blk: &fn(v: &uint)) {\n     let PureCounter(ref x) = self;\n     blk(x);\n }"}, {"sha": "16e8fa18c2a0247da7f013a3d608965a04f7c4e9", "filename": "src/test/run-pass/issue-868.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fissue-868.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fissue-868.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-868.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f<T>(g: fn() -> T) -> T { g() }\n+fn f<T>(g: &fn() -> T) -> T { g() }\n \n pub fn main() {\n   let _x = f( | | { 10 });"}, {"sha": "d2c51df2b8fb3e7bbde64436d3d82dc59eea59a7", "filename": "src/test/run-pass/issue-912.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fissue-912.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fissue-912.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-912.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // xfail-test\n-fn find<T>(_f: fn(@T) -> bool, _v: [@T]) {}\n+fn find<T>(_f: &fn(@T) -> bool, _v: [@T]) {}\n \n pub fn main() {\n     let x = 10, arr = [];"}, {"sha": "0ec8eea52365f2e07063e0c5bee054c85905dced", "filename": "src/test/run-pass/iter-range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fiter-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fiter-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-range.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -10,7 +10,7 @@\n \n \n \n-fn range(a: int, b: int, it: fn(int)) {\n+fn range(a: int, b: int, it: &fn(int)) {\n     fail_unless!((a < b));\n     let mut i: int = a;\n     while i < b { it(i); i += 1; }"}, {"sha": "e2dbf7d29db1931aba8850a272009d378ddb4955", "filename": "src/test/run-pass/last-use-in-block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Flast-use-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Flast-use-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flast-use-in-block.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -10,16 +10,16 @@\n \n // Issue #1818\n \n-fn lp<T>(s: ~str, f: fn(~str) -> T) -> T {\n+fn lp<T>(s: ~str, f: &fn(~str) -> T) -> T {\n     while false {\n         let r = f(s);\n         return (r);\n     }\n     fail!();\n }\n \n-fn apply<T>(s: ~str, f: fn(~str) -> T) -> T {\n-    fn g<T>(s: ~str, f: fn(~str) -> T) -> T {f(s)}\n+fn apply<T>(s: ~str, f: &fn(~str) -> T) -> T {\n+    fn g<T>(s: ~str, f: &fn(~str) -> T) -> T {f(s)}\n     g(s, |v| { let r = f(v); r })\n }\n "}, {"sha": "05e50e3e6604784c372c75c5f9f176b37177c849", "filename": "src/test/run-pass/let-destruct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Flet-destruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Flet-destruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flet-destruct.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum xx = int;\n+struct xx(int);\n \n struct X { x: xx, y: int }\n "}, {"sha": "79ad6e8a2506a27ae4e27b69daf0478e80c305f0", "filename": "src/test/run-pass/log-degen-enum.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/51cdca0bf0d3efc554c1815df9306ea10e881a14/src%2Ftest%2Frun-pass%2Flog-degen-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51cdca0bf0d3efc554c1815df9306ea10e881a14/src%2Ftest%2Frun-pass%2Flog-degen-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-degen-enum.rs?ref=51cdca0bf0d3efc554c1815df9306ea10e881a14", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-enum Foo = uint;\n-\n-pub fn main() {\n-    let x = Foo(1);\n-    let y = fmt!(\"%?\", x);\n-    fail_unless!(y == ~\"Foo(1)\");\n-}"}, {"sha": "b21b3b6c7fb26ed69499ee0d00a63f0a9d5ebea2", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -11,23 +11,23 @@\n // xfail-fast\n \n trait vec_monad<A> {\n-    fn bind<B:Copy>(f: fn(&A) -> ~[B]) -> ~[B];\n+    fn bind<B:Copy>(f: &fn(&A) -> ~[B]) -> ~[B];\n }\n \n impl<A> vec_monad<A> for ~[A] {\n-    fn bind<B:Copy>(f: fn(&A) -> ~[B]) -> ~[B] {\n+    fn bind<B:Copy>(f: &fn(&A) -> ~[B]) -> ~[B] {\n         let mut r = ~[];\n         for self.each |elt| { r += f(elt); }\n         r\n     }\n }\n \n trait option_monad<A> {\n-    fn bind<B>(f: fn(&A) -> Option<B>) -> Option<B>;\n+    fn bind<B>(f: &fn(&A) -> Option<B>) -> Option<B>;\n }\n \n impl<A> option_monad<A> for Option<A> {\n-    fn bind<B>(f: fn(&A) -> Option<B>) -> Option<B> {\n+    fn bind<B>(f: &fn(&A) -> Option<B>) -> Option<B> {\n         match self {\n           Some(ref a) => { f(a) }\n           None => { None }"}, {"sha": "f61ffc1bc3e0047c630f34cefd611b9c34f3eb8c", "filename": "src/test/run-pass/mut-function-arguments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fmut-function-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fmut-function-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmut-function-arguments.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -14,7 +14,7 @@ fn f(mut y: ~int) {\n }\n \n fn g() {\n-    let frob: fn(~int) = |mut q| { *q = 2; fail_unless!(*q == 2); };\n+    let frob: &fn(~int) = |mut q| { *q = 2; fail_unless!(*q == 2); };\n     let w = ~37;\n     frob(w);\n "}, {"sha": "076e019bab46d0dd8fe402a5e57a56de19982e6d", "filename": "src/test/run-pass/newlambdas.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fnewlambdas.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fnewlambdas.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewlambdas.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -12,7 +12,7 @@\n \n fn f(i: int, f: &fn(int) -> int) -> int { f(i) }\n \n-fn g(g: fn()) { }\n+fn g(g: &fn()) { }\n \n fn ff() -> @fn(int) -> int {\n     return |x| x + 1;"}, {"sha": "18132d15d57876f011cace4d2616f2e426fe32df", "filename": "src/test/run-pass/newtype-polymorphic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum myvec<X> = ~[X];\n+struct myvec<X>(~[X]);\n \n fn myvec_deref<X:Copy>(mv: myvec<X>) -> ~[X] { return copy *mv; }\n "}, {"sha": "6a82f70d9158aa0a074dca1444ddb403d5dd72a0", "filename": "src/test/run-pass/newtype.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fnewtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fnewtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum mytype = Mytype;\n+struct mytype(Mytype);\n \n struct Mytype {compute: extern fn(mytype) -> int, val: int}\n "}, {"sha": "330a9b9de7b8f72a0074367d456c9ff73386c205", "filename": "src/test/run-pass/non-legacy-modes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fnon-legacy-modes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fnon-legacy-modes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon-legacy-modes.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -12,7 +12,7 @@ struct X {\n     repr: int\n }\n \n-fn apply<T>(x: T, f: fn(T)) {\n+fn apply<T>(x: T, f: &fn(T)) {\n     f(x);\n }\n "}, {"sha": "3d2fd649f156226cf2093dd37fc983b07576f292", "filename": "src/test/run-pass/operator-overloading-explicit-self.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/51cdca0bf0d3efc554c1815df9306ea10e881a14/src%2Ftest%2Frun-pass%2Foperator-overloading-explicit-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51cdca0bf0d3efc554c1815df9306ea10e881a14/src%2Ftest%2Frun-pass%2Foperator-overloading-explicit-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading-explicit-self.rs?ref=51cdca0bf0d3efc554c1815df9306ea10e881a14", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct S {\n-    x: int\n-}\n-\n-pub impl S {\n-    pure fn add(&self, other: &S) -> S {\n-        S { x: self.x + other.x }\n-    }\n-}\n-\n-pub fn main() {\n-    let mut s = S { x: 1 };\n-    s += S { x: 2 };\n-    fail_unless!(s.x == 3);\n-}\n-"}, {"sha": "20daa894bc1288661e69f68c631364d4c8c0039f", "filename": "src/test/run-pass/pipe-bank-proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -49,7 +49,7 @@ macro_rules! move_it (\n )\n \n fn switch<T:Owned,U>(+endp: pipes::RecvPacket<T>,\n-                      f: fn(+v: Option<T>) -> U) -> U {\n+                      f: &fn(+v: Option<T>) -> U) -> U {\n     f(pipes::try_recv(endp))\n }\n "}, {"sha": "f1686080f46618b4f82c1556436ad1ac319200c9", "filename": "src/test/run-pass/pipe-pingpong-bounded.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -43,8 +43,8 @@ mod pingpong {\n             ptr::addr_of(&(data.ping))\n         }\n     }\n-    pub enum ping = server::pong;\n-    pub enum pong = client::ping;\n+    pub struct ping(server::pong);\n+    pub struct pong(client::ping);\n     pub mod client {\n         use core::pipes;\n         use core::pipes::*;"}, {"sha": "d546909de8e1edaa5439dd7ee562210d2d16f435", "filename": "src/test/run-pass/purity-infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fpurity-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fpurity-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpurity-infer.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-fn something(f: pure fn()) { f(); }\n+fn something(f: &pure fn()) { f(); }\n pub fn main() {\n     something(|| log(error, \"hi!\") );\n }"}, {"sha": "0f3f4db3bbfe28aa2f5086ca9fe269d81eb0d853", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -19,7 +19,7 @@ use intrinsic::{TyDesc, get_tydesc, visit_tydesc, TyVisitor};\n \n /// Trait for visitor that wishes to reflect on data.\n trait movable_ptr {\n-    fn move_ptr(adjustment: fn(*c_void) -> *c_void);\n+    fn move_ptr(adjustment: &fn(*c_void) -> *c_void);\n }\n \n /// Helper function for alignment calculation.\n@@ -28,7 +28,7 @@ fn align(size: uint, align: uint) -> uint {\n     ((size + align) - 1u) & !(align - 1u)\n }\n \n-enum ptr_visit_adaptor<V> = Inner<V>;\n+struct ptr_visit_adaptor<V>(Inner<V>);\n \n pub impl<V:TyVisitor + movable_ptr> ptr_visit_adaptor<V> {\n \n@@ -470,7 +470,7 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n     }\n }\n \n-enum my_visitor = @mut Stuff;\n+struct my_visitor(@mut Stuff);\n \n struct Stuff {\n     ptr1: *c_void,\n@@ -479,7 +479,7 @@ struct Stuff {\n }\n \n pub impl my_visitor {\n-    fn get<T>(f: fn(T)) {\n+    fn get<T>(f: &fn(T)) {\n         unsafe {\n             f(*(self.ptr1 as *T));\n         }\n@@ -498,7 +498,7 @@ pub impl my_visitor {\n struct Inner<V> { inner: V }\n \n impl movable_ptr for my_visitor {\n-    fn move_ptr(adjustment: fn(*c_void) -> *c_void) {\n+    fn move_ptr(adjustment: &fn(*c_void) -> *c_void) {\n         self.ptr1 = adjustment(self.ptr1);\n         self.ptr2 = adjustment(self.ptr2);\n     }"}, {"sha": "bc67ece79de50a05030ba4c6e3f9f48adff37087", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-test\n use intrinsic::{TyDesc, get_tydesc, visit_tydesc, TyVisitor};\n-enum my_visitor = @mut { types: ~[str] };\n+struct my_visitor(@mut { types: ~[str] });\n \n impl TyVisitor for my_visitor {\n     fn visit_bot() -> bool {"}, {"sha": "a995b3d96935204528131b14b3039809e3c4106d", "filename": "src/test/run-pass/regions-fn-subtyping-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fregions-fn-subtyping-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fregions-fn-subtyping-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-fn-subtyping-2.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -15,13 +15,13 @@\n // Here, `f` is a function that takes a pointer `x` and a function\n // `g`, where `g` requires its argument `y` to be in the same region\n // that `x` is in.\n-fn has_same_region(f: fn(x: &a.int, g: fn(y: &a.int))) {\n+fn has_same_region(f: &fn(x: &a.int, g: &fn(y: &a.int))) {\n     // `f` should be the type that `wants_same_region` wants, but\n     // right now the compiler complains that it isn't.\n     wants_same_region(f);\n }\n \n-fn wants_same_region(_f: fn(x: &b.int, g: fn(y: &b.int))) { \n+fn wants_same_region(_f: &fn(x: &b.int, g: &fn(y: &b.int))) { \n }\n \n pub fn main() {"}, {"sha": "dc38a7baacd21304f139491e970717786418f5ec", "filename": "src/test/run-pass/regions-infer-call-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fregions-infer-call-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fregions-infer-call-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-call-2.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -10,7 +10,7 @@\n \n fn takes_two(x: &int, y: &int) -> int { *x + *y }\n \n-fn with<T>(f: fn(x: &int) -> T) -> T {\n+fn with<T>(f: &fn(x: &int) -> T) -> T {\n     f(&20)\n }\n "}, {"sha": "b249a4470cb9ea8667818d9d5a88bfa95e5f8f9a", "filename": "src/test/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum arena = ();\n+struct arena(());\n \n struct Bcx {\n     fcx: &'self Fcx<'self>"}, {"sha": "0049653dea9d3ac45f419ffc3ce413604a9b8e15", "filename": "src/test/run-pass/regions-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fregions-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fregions-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-params.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -12,7 +12,7 @@\n \n fn region_identity(x: &r/uint) -> &r/uint { x }\n \n-fn apply<T>(t: T, f: fn(T) -> T) -> T { f(t) }\n+fn apply<T>(t: T, f: &fn(T) -> T) -> T { f(t) }\n \n fn parameterized(x: &uint) -> uint {\n     let z = apply(x, ({|y|"}, {"sha": "058cb4ec77e486da91311c897192faa4edca1a56", "filename": "src/test/run-pass/resource-cycle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fresource-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fresource-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -34,7 +34,7 @@ fn r(v: *int) -> r {\n     }\n }\n \n-enum t = Node;\n+struct t(Node);\n \n struct Node {\n     next: Option<@mut t>,"}, {"sha": "e3b03060893a288e644198106b1f9f5dd75143cb", "filename": "src/test/run-pass/resource-cycle2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fresource-cycle2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fresource-cycle2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle2.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -34,7 +34,7 @@ fn r(v: U) -> r {\n     }\n }\n \n-enum t = Node;\n+struct t(Node);\n \n struct Node {\n     next: Option<@mut t>,"}, {"sha": "c76c1c6aeb9107b6d49823a8fbf06ab992d38f36", "filename": "src/test/run-pass/resource-cycle3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fresource-cycle3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fresource-cycle3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle3.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -43,7 +43,7 @@ fn r(v: U, w: int, _x: *int) -> R {\n     }\n }\n \n-enum t = Node;\n+struct t(Node);\n \n struct Node {\n     next: Option<@mut t>,"}, {"sha": "6fe7575884249d976bfff89d8c992d01b111ce2e", "filename": "src/test/run-pass/ret-break-cont-in-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -12,7 +12,7 @@\n \n use core::cmp::Eq;\n \n-fn iter<T>(v: ~[T], it: fn(&T) -> bool) {\n+fn iter<T>(v: ~[T], it: &fn(&T) -> bool) {\n     let mut i = 0u, l = v.len();\n     while i < l {\n         if !it(&v[i]) { break; }"}, {"sha": "0d9d01f9e700fb1e5de0028950a788347d9c0f46", "filename": "src/test/run-pass/sendfn-is-a-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fsendfn-is-a-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fsendfn-is-a-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-is-a-block.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-fast\n \n-fn test(f: fn(uint) -> uint) -> uint {\n+fn test(f: &fn(uint) -> uint) -> uint {\n     return f(22u);\n }\n "}, {"sha": "2ee6f631ea5211baaa2bdd1545ca45bd4ce4222b", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -26,27 +26,27 @@ mod b {\n \n trait uint_utils {\n     fn str() -> ~str;\n-    fn multi(f: fn(uint));\n+    fn multi(f: &fn(uint));\n }\n \n impl uint_utils for uint {\n     fn str() -> ~str { uint::to_str(self) }\n-    fn multi(f: fn(uint)) {\n+    fn multi(f: &fn(uint)) {\n         let mut c = 0u;\n         while c < self { f(c); c += 1u; }\n     }\n }\n \n trait vec_utils<T> {\n     fn length_() -> uint;\n-    fn iter_(f: fn(&T));\n-    fn map_<U:Copy>(f: fn(&T) -> U) -> ~[U];\n+    fn iter_(f: &fn(&T));\n+    fn map_<U:Copy>(f: &fn(&T) -> U) -> ~[U];\n }\n \n impl<T> vec_utils<T> for ~[T] {\n     fn length_() -> uint { vec::len(self) }\n-    fn iter_(f: fn(&T)) { for self.each |x| { f(x); } }\n-    fn map_<U:Copy>(f: fn(&T) -> U) -> ~[U] {\n+    fn iter_(f: &fn(&T)) { for self.each |x| { f(x); } }\n+    fn map_<U:Copy>(f: &fn(&T) -> U) -> ~[U] {\n         let mut r = ~[];\n         for self.each |elt| { r += ~[f(elt)]; }\n         r"}, {"sha": "0c6359375d306e85ac29492b32dbfc6a7561031c", "filename": "src/test/run-pass/static-method-test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -36,33 +36,33 @@ impl bool_like for int {\n // A trait for sequences that can be constructed imperatively.\n trait buildable<A> {\n      static pure fn build_sized(size: uint,\n-                                builder: fn(push: pure fn(+v: A))) -> Self;\n+                                builder: &fn(push: &pure fn(+v: A))) -> Self;\n }\n \n \n impl<A> buildable<A> for @[A] {\n     #[inline(always)]\n      static pure fn build_sized(size: uint,\n-                                builder: fn(push: pure fn(+v: A))) -> @[A] {\n+                                builder: &fn(push: &pure fn(+v: A))) -> @[A] {\n          at_vec::build_sized(size, builder)\n      }\n }\n impl<A> buildable<A> for ~[A] {\n     #[inline(always)]\n      static pure fn build_sized(size: uint,\n-                                builder: fn(push: pure fn(+v: A))) -> ~[A] {\n+                                builder: &fn(push: &pure fn(+v: A))) -> ~[A] {\n          vec::build_sized(size, builder)\n      }\n }\n \n #[inline(always)]\n-pure fn build<A, B: buildable<A>>(builder: fn(push: pure fn(+v: A))) -> B {\n+pure fn build<A, B: buildable<A>>(builder: &fn(push: &pure fn(+v: A))) -> B {\n     buildable::build_sized(4, builder)\n }\n \n /// Apply a function to each element of an iterable and return the results\n fn map<T, IT: BaseIter<T>, U, BU: buildable<U>>\n-    (v: IT, f: fn(T) -> U) -> BU {\n+    (v: IT, f: &fn(T) -> U) -> BU {\n     do build |push| {\n         for v.each() |elem| {\n             push(f(*elem));"}, {"sha": "39651f86e227bad6ef20ada58d51b06121cd0e01", "filename": "src/test/run-pass/task-killjoin-rsrc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -40,7 +40,7 @@ fn notify(ch: Chan<bool>, v: @mut bool) -> notify {\n }\n \n fn joinable(f: ~fn()) -> Port<bool> {\n-    fn wrapper(c: Chan<bool>, f: fn()) {\n+    fn wrapper(c: Chan<bool>, f: &fn()) {\n         let b = @mut false;\n         error!(\"wrapper: task=%? allocated v=%x\",\n                task::get_task(),"}, {"sha": "4cee3c636c572b9cf653e43d6866e6ce05fb903b", "filename": "src/test/run-pass/trait-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-cast.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -13,7 +13,7 @@\n \n // Test cyclic detector when using trait instances.\n \n-enum Tree = @mut TreeR;\n+struct Tree(@mut TreeR);\n struct TreeR {\n     left: Option<Tree>,\n     right: Option<Tree>,"}, {"sha": "7b8ebe6d34cab21d5a4dab5527ef145d28afd506", "filename": "src/test/run-pass/trait-generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-generic.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -24,10 +24,10 @@ impl to_str for () {\n }\n \n trait map<T> {\n-    fn map<U:Copy>(f: fn(&T) -> U) -> ~[U];\n+    fn map<U:Copy>(f: &fn(&T) -> U) -> ~[U];\n }\n impl<T> map<T> for ~[T] {\n-    fn map<U:Copy>(f: fn(&T) -> U) -> ~[U] {\n+    fn map<U:Copy>(f: &fn(&T) -> U) -> ~[U] {\n         let mut r = ~[];\n         for self.each |x| { r += ~[f(x)]; }\n         r"}, {"sha": "d600ff25f029873571ad984483323439343d385b", "filename": "src/test/run-pass/type-params-in-for-each.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -13,7 +13,7 @@ struct S<T> {\n     b: uint,\n }\n \n-fn range(lo: uint, hi: uint, it: fn(uint)) {\n+fn range(lo: uint, hi: uint, it: &fn(uint)) {\n     let mut lo_ = lo;\n     while lo_ < hi { it(lo_); lo_ += 1u; }\n }"}, {"sha": "649f424ec36bea8afc4447f97ca19dcf11782f78", "filename": "src/test/run-pass/unnamed_argument_mode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Funnamed_argument_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ebb67487c1530822d83d6da6f71fa62cb68f2cd/src%2Ftest%2Frun-pass%2Funnamed_argument_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funnamed_argument_mode.rs?ref=2ebb67487c1530822d83d6da6f71fa62cb68f2cd", "patch": "@@ -3,7 +3,7 @@ fn good(a: &int) {\n \n // unnamed argument &int is now parse x: &int\n \n-fn called(f: fn(&int)) {\n+fn called(f: &fn(&int)) {\n }\n \n pub fn main() {"}]}