{"sha": "9c0bc3028a575eece6d4e8fbc6624cb95b9c9893", "node_id": "C_kwDOAAsO6NoAKDljMGJjMzAyOGE1NzVlZWNlNmQ0ZThmYmM2NjI0Y2I5NWI5Yzk4OTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-01T10:40:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-01T10:40:10Z"}, "message": "Auto merge of #104975 - JakobDegen:custom_mir_let, r=oli-obk\n\n`#![custom_mir]`: Various improvements\n\nThis PR makes a bunch of improvements to `#![custom_mir]`. Ideally this would be 4 PRs, one for each commit, but those would take forever to get merged and be a pain to juggle. Should still be reviewed one commit at a time though.\n\n### Commit 1: Support arbitrary `let`\n\nBefore this change, all locals used in the body need to be declared at the top of the `mir!` invocation, which is rather annoying. We attempt to change that.\n\nUnfortunately, we still have the requirement that the output of the `mir!` macro must resolve, typecheck, etc. Because of that, we can't just accept this in the THIR -> MIR parser because something like\n```rust\n{\n    let x = 0;\n    Goto(other)\n}\nother = {\n    RET = x;\n    Return()\n}\n```\nwill fail to resolve. Instead, the implementation does macro shenanigans to find the let declarations and extract them as part of the `mir!` macro. That *works*, but it is fairly complicated and degrades debuginfo by quite a bit. Specifically, the spans for any statements and declarations that are affected by this are completely wrong. My guess is that this is a net improvement though.\n\nOne way to recover some of the debuginfo would be to not support type annotations in the `let` statements, which would allow us to parse like `let $stmt:stmt`. That seems quite surprising though.\n\n### Commit 2: Parse consts\n\nReuses most of the const parsing from regular Mir building for building custom mir\n\n### Commit 3: Parse statics\n\nStatics are slightly weird because the Mir primitive associated with them is a reference/pointer to them, so this is factored out separately.\n\n### Commit 4: Fix some spans\n\nA bunch of the spans were non-ideal, so we adjust them to be much more helpful.\n\nr? `@oli-obk`", "tree": {"sha": "fcd64011f689d41405fe4dccda56728d0e65a029", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcd64011f689d41405fe4dccda56728d0e65a029"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893", "html_url": "https://github.com/rust-lang/rust/commit/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91", "html_url": "https://github.com/rust-lang/rust/commit/d6c4de0fb22fe8f3cc5a27e94b6b6d88fb504a91"}, {"sha": "5a34dbf193ac8cfb7dbe53b354614f2622f5682c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a34dbf193ac8cfb7dbe53b354614f2622f5682c", "html_url": "https://github.com/rust-lang/rust/commit/5a34dbf193ac8cfb7dbe53b354614f2622f5682c"}], "stats": {"total": 558, "additions": 454, "deletions": 104}, "files": [{"sha": "2412824efeb751c305af719d5fb4dccd3d2729e7", "filename": "compiler/rustc_mir_build/src/build/custom/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs?ref=9c0bc3028a575eece6d4e8fbc6624cb95b9c9893", "patch": "@@ -74,7 +74,7 @@ pub(super) fn build_custom_mir<'tcx>(\n     let mut pctxt = ParseCtxt {\n         tcx,\n         thir,\n-        source_info: SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE },\n+        source_scope: OUTERMOST_SOURCE_SCOPE,\n         body: &mut body,\n         local_map: FxHashMap::default(),\n         block_map: FxHashMap::default(),\n@@ -128,7 +128,7 @@ fn parse_attribute(attr: &Attribute) -> MirPhase {\n struct ParseCtxt<'tcx, 'body> {\n     tcx: TyCtxt<'tcx>,\n     thir: &'body Thir<'tcx>,\n-    source_info: SourceInfo,\n+    source_scope: SourceScope,\n \n     body: &'body mut Body<'tcx>,\n     local_map: FxHashMap<LocalVarId, Local>,"}, {"sha": "d72770e70c7ece67e9f5d43b7251e1625311f227", "filename": "compiler/rustc_mir_build/src/build/custom/parse.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse.rs?ref=9c0bc3028a575eece6d4e8fbc6624cb95b9c9893", "patch": "@@ -23,6 +23,7 @@ macro_rules! parse_by_kind {\n     (\n         $self:ident,\n         $expr_id:expr,\n+        $expr_name:pat,\n         $expected:literal,\n         $(\n             @call($name:literal, $args:ident) => $call_expr:expr,\n@@ -33,6 +34,8 @@ macro_rules! parse_by_kind {\n     ) => {{\n         let expr_id = $self.preparse($expr_id);\n         let expr = &$self.thir[expr_id];\n+        debug!(\"Trying to parse {:?} as {}\", expr.kind, $expected);\n+        let $expr_name = expr;\n         match &expr.kind {\n             $(\n                 ExprKind::Call { ty, fun: _, args: $args, .. } if {\n@@ -137,26 +140,26 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     /// This allows us to easily parse the basic blocks declarations, local declarations, and\n     /// basic block definitions in order.\n     pub fn parse_body(&mut self, expr_id: ExprId) -> PResult<()> {\n-        let body = parse_by_kind!(self, expr_id, \"whole body\",\n+        let body = parse_by_kind!(self, expr_id, _, \"whole body\",\n             ExprKind::Block { block } => self.thir[*block].expr.unwrap(),\n         );\n-        let (block_decls, rest) = parse_by_kind!(self, body, \"body with block decls\",\n+        let (block_decls, rest) = parse_by_kind!(self, body, _, \"body with block decls\",\n             ExprKind::Block { block } => {\n                 let block = &self.thir[*block];\n                 (&block.stmts, block.expr.unwrap())\n             },\n         );\n         self.parse_block_decls(block_decls.iter().copied())?;\n \n-        let (local_decls, rest) = parse_by_kind!(self, rest, \"body with local decls\",\n+        let (local_decls, rest) = parse_by_kind!(self, rest, _, \"body with local decls\",\n             ExprKind::Block { block } => {\n                 let block = &self.thir[*block];\n                 (&block.stmts, block.expr.unwrap())\n             },\n         );\n         self.parse_local_decls(local_decls.iter().copied())?;\n \n-        let block_defs = parse_by_kind!(self, rest, \"body with block defs\",\n+        let block_defs = parse_by_kind!(self, rest, _, \"body with block defs\",\n             ExprKind::Block { block } => &self.thir[*block].stmts,\n         );\n         for (i, block_def) in block_defs.iter().enumerate() {\n@@ -223,22 +226,30 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     }\n \n     fn parse_block_def(&self, expr_id: ExprId) -> PResult<BasicBlockData<'tcx>> {\n-        let block = parse_by_kind!(self, expr_id, \"basic block\",\n+        let block = parse_by_kind!(self, expr_id, _, \"basic block\",\n             ExprKind::Block { block } => &self.thir[*block],\n         );\n \n         let mut data = BasicBlockData::new(None);\n         for stmt_id in &*block.stmts {\n             let stmt = self.statement_as_expr(*stmt_id)?;\n+            let span = self.thir[stmt].span;\n             let statement = self.parse_statement(stmt)?;\n-            data.statements.push(Statement { source_info: self.source_info, kind: statement });\n+            data.statements.push(Statement {\n+                source_info: SourceInfo { span, scope: self.source_scope },\n+                kind: statement,\n+            });\n         }\n \n         let Some(trailing) = block.expr else {\n             return Err(self.expr_error(expr_id, \"terminator\"))\n         };\n+        let span = self.thir[trailing].span;\n         let terminator = self.parse_terminator(trailing)?;\n-        data.terminator = Some(Terminator { source_info: self.source_info, kind: terminator });\n+        data.terminator = Some(Terminator {\n+            source_info: SourceInfo { span, scope: self.source_scope },\n+            kind: terminator,\n+        });\n \n         Ok(data)\n     }"}, {"sha": "03206af33bfb5dc927da6348f64b84f7d4074a08", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=9c0bc3028a575eece6d4e8fbc6624cb95b9c9893", "patch": "@@ -1,10 +1,11 @@\n+use rustc_middle::mir::interpret::{ConstValue, Scalar};\n use rustc_middle::{mir::*, thir::*, ty};\n \n use super::{parse_by_kind, PResult, ParseCtxt};\n \n impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     pub fn parse_statement(&self, expr_id: ExprId) -> PResult<StatementKind<'tcx>> {\n-        parse_by_kind!(self, expr_id, \"statement\",\n+        parse_by_kind!(self, expr_id, _, \"statement\",\n             @call(\"mir_retag\", args) => {\n                 Ok(StatementKind::Retag(RetagKind::Default, Box::new(self.parse_place(args[0])?)))\n             },\n@@ -20,7 +21,7 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     }\n \n     pub fn parse_terminator(&self, expr_id: ExprId) -> PResult<TerminatorKind<'tcx>> {\n-        parse_by_kind!(self, expr_id, \"terminator\",\n+        parse_by_kind!(self, expr_id, _, \"terminator\",\n             @call(\"mir_return\", _args) => {\n                 Ok(TerminatorKind::Return)\n             },\n@@ -31,7 +32,7 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     }\n \n     fn parse_rvalue(&self, expr_id: ExprId) -> PResult<Rvalue<'tcx>> {\n-        parse_by_kind!(self, expr_id, \"rvalue\",\n+        parse_by_kind!(self, expr_id, _, \"rvalue\",\n             ExprKind::Borrow { borrow_kind, arg } => Ok(\n                 Rvalue::Ref(self.tcx.lifetimes.re_erased, *borrow_kind, self.parse_place(*arg)?)\n             ),\n@@ -43,14 +44,26 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     }\n \n     fn parse_operand(&self, expr_id: ExprId) -> PResult<Operand<'tcx>> {\n-        parse_by_kind!(self, expr_id, \"operand\",\n+        parse_by_kind!(self, expr_id, expr, \"operand\",\n             @call(\"mir_move\", args) => self.parse_place(args[0]).map(Operand::Move),\n+            @call(\"mir_static\", args) => self.parse_static(args[0]),\n+            @call(\"mir_static_mut\", args) => self.parse_static(args[0]),\n+            ExprKind::Literal { .. }\n+            | ExprKind::NamedConst { .. }\n+            | ExprKind::NonHirLiteral { .. }\n+            | ExprKind::ZstLiteral { .. }\n+            | ExprKind::ConstParam { .. }\n+            | ExprKind::ConstBlock { .. } => {\n+                Ok(Operand::Constant(Box::new(\n+                    crate::build::expr::as_constant::as_constant_inner(expr, |_| None, self.tcx)\n+                )))\n+            },\n             _ => self.parse_place(expr_id).map(Operand::Copy),\n         )\n     }\n \n     fn parse_place(&self, expr_id: ExprId) -> PResult<Place<'tcx>> {\n-        parse_by_kind!(self, expr_id, \"place\",\n+        parse_by_kind!(self, expr_id, _, \"place\",\n             ExprKind::Deref { arg } => Ok(\n                 self.parse_place(*arg)?.project_deeper(&[PlaceElem::Deref], self.tcx)\n             ),\n@@ -59,14 +72,34 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     }\n \n     fn parse_local(&self, expr_id: ExprId) -> PResult<Local> {\n-        parse_by_kind!(self, expr_id, \"local\",\n+        parse_by_kind!(self, expr_id, _, \"local\",\n             ExprKind::VarRef { id } => Ok(self.local_map[id]),\n         )\n     }\n \n     fn parse_block(&self, expr_id: ExprId) -> PResult<BasicBlock> {\n-        parse_by_kind!(self, expr_id, \"basic block\",\n+        parse_by_kind!(self, expr_id, _, \"basic block\",\n             ExprKind::VarRef { id } => Ok(self.block_map[id]),\n         )\n     }\n+\n+    fn parse_static(&self, expr_id: ExprId) -> PResult<Operand<'tcx>> {\n+        let expr_id = parse_by_kind!(self, expr_id, _, \"static\",\n+            ExprKind::Deref { arg } => *arg,\n+        );\n+\n+        parse_by_kind!(self, expr_id, expr, \"static\",\n+            ExprKind::StaticRef { alloc_id, ty, .. } => {\n+                let const_val =\n+                    ConstValue::Scalar(Scalar::from_pointer((*alloc_id).into(), &self.tcx));\n+                let literal = ConstantKind::Val(const_val, *ty);\n+\n+                Ok(Operand::Constant(Box::new(Constant {\n+                    span: expr.span,\n+                    user_ty: None,\n+                    literal\n+                })))\n+            },\n+        )\n+    }\n }"}, {"sha": "717c62315745b303ca7cef8e1e4d539c24930b4d", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 71, "deletions": 66, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=9c0bc3028a575eece6d4e8fbc6624cb95b9c9893", "patch": "@@ -8,7 +8,9 @@ use rustc_middle::mir::interpret::{\n };\n use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n-use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, TyCtxt};\n+use rustc_middle::ty::{\n+    self, CanonicalUserType, CanonicalUserTypeAnnotation, TyCtxt, UserTypeAnnotationIndex,\n+};\n use rustc_span::DUMMY_SP;\n use rustc_target::abi::Size;\n \n@@ -19,84 +21,87 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let this = self;\n         let tcx = this.tcx;\n         let Expr { ty, temp_lifetime: _, span, ref kind } = *expr;\n-        match *kind {\n+        match kind {\n             ExprKind::Scope { region_scope: _, lint_level: _, value } => {\n-                this.as_constant(&this.thir[value])\n-            }\n-            ExprKind::Literal { lit, neg } => {\n-                let literal =\n-                    match lit_to_mir_constant(tcx, LitToConstInput { lit: &lit.node, ty, neg }) {\n-                        Ok(c) => c,\n-                        Err(LitToConstError::Reported(guar)) => {\n-                            ConstantKind::Ty(tcx.const_error_with_guaranteed(ty, guar))\n-                        }\n-                        Err(LitToConstError::TypeError) => {\n-                            bug!(\"encountered type error in `lit_to_mir_constant\")\n-                        }\n-                    };\n-\n-                Constant { span, user_ty: None, literal }\n+                this.as_constant(&this.thir[*value])\n             }\n-            ExprKind::NonHirLiteral { lit, ref user_ty } => {\n-                let user_ty = user_ty.as_ref().map(|user_ty| {\n-                    this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n+            _ => as_constant_inner(\n+                expr,\n+                |user_ty| {\n+                    Some(this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n                         span,\n                         user_ty: user_ty.clone(),\n                         inferred_ty: ty,\n-                    })\n-                });\n-                let literal = ConstantKind::Val(ConstValue::Scalar(Scalar::Int(lit)), ty);\n+                    }))\n+                },\n+                tcx,\n+            ),\n+        }\n+    }\n+}\n \n-                Constant { span, user_ty: user_ty, literal }\n-            }\n-            ExprKind::ZstLiteral { ref user_ty } => {\n-                let user_ty = user_ty.as_ref().map(|user_ty| {\n-                    this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n-                        span,\n-                        user_ty: user_ty.clone(),\n-                        inferred_ty: ty,\n-                    })\n-                });\n-                let literal = ConstantKind::Val(ConstValue::ZeroSized, ty);\n+pub fn as_constant_inner<'tcx>(\n+    expr: &Expr<'tcx>,\n+    push_cuta: impl FnMut(&Box<CanonicalUserType<'tcx>>) -> Option<UserTypeAnnotationIndex>,\n+    tcx: TyCtxt<'tcx>,\n+) -> Constant<'tcx> {\n+    let Expr { ty, temp_lifetime: _, span, ref kind } = *expr;\n+    match *kind {\n+        ExprKind::Literal { lit, neg } => {\n+            let literal =\n+                match lit_to_mir_constant(tcx, LitToConstInput { lit: &lit.node, ty, neg }) {\n+                    Ok(c) => c,\n+                    Err(LitToConstError::Reported(guar)) => {\n+                        ConstantKind::Ty(tcx.const_error_with_guaranteed(ty, guar))\n+                    }\n+                    Err(LitToConstError::TypeError) => {\n+                        bug!(\"encountered type error in `lit_to_mir_constant\")\n+                    }\n+                };\n \n-                Constant { span, user_ty: user_ty, literal }\n-            }\n-            ExprKind::NamedConst { def_id, substs, ref user_ty } => {\n-                let user_ty = user_ty.as_ref().map(|user_ty| {\n-                    this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n-                        span,\n-                        user_ty: user_ty.clone(),\n-                        inferred_ty: ty,\n-                    })\n-                });\n+            Constant { span, user_ty: None, literal }\n+        }\n+        ExprKind::NonHirLiteral { lit, ref user_ty } => {\n+            let user_ty = user_ty.as_ref().map(push_cuta).flatten();\n \n-                let uneval =\n-                    mir::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n-                let literal = ConstantKind::Unevaluated(uneval, ty);\n+            let literal = ConstantKind::Val(ConstValue::Scalar(Scalar::Int(lit)), ty);\n \n-                Constant { user_ty, span, literal }\n-            }\n-            ExprKind::ConstParam { param, def_id: _ } => {\n-                let const_param = tcx.mk_const(param, expr.ty);\n-                let literal = ConstantKind::Ty(const_param);\n+            Constant { span, user_ty: user_ty, literal }\n+        }\n+        ExprKind::ZstLiteral { ref user_ty } => {\n+            let user_ty = user_ty.as_ref().map(push_cuta).flatten();\n \n-                Constant { user_ty: None, span, literal }\n-            }\n-            ExprKind::ConstBlock { did: def_id, substs } => {\n-                let uneval =\n-                    mir::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n-                let literal = ConstantKind::Unevaluated(uneval, ty);\n+            let literal = ConstantKind::Val(ConstValue::ZeroSized, ty);\n \n-                Constant { user_ty: None, span, literal }\n-            }\n-            ExprKind::StaticRef { alloc_id, ty, .. } => {\n-                let const_val = ConstValue::Scalar(Scalar::from_pointer(alloc_id.into(), &tcx));\n-                let literal = ConstantKind::Val(const_val, ty);\n+            Constant { span, user_ty: user_ty, literal }\n+        }\n+        ExprKind::NamedConst { def_id, substs, ref user_ty } => {\n+            let user_ty = user_ty.as_ref().map(push_cuta).flatten();\n \n-                Constant { span, user_ty: None, literal }\n-            }\n-            _ => span_bug!(span, \"expression is not a valid constant {:?}\", kind),\n+            let uneval = mir::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n+            let literal = ConstantKind::Unevaluated(uneval, ty);\n+\n+            Constant { user_ty, span, literal }\n+        }\n+        ExprKind::ConstParam { param, def_id: _ } => {\n+            let const_param = tcx.mk_const(ty::ConstKind::Param(param), expr.ty);\n+            let literal = ConstantKind::Ty(const_param);\n+\n+            Constant { user_ty: None, span, literal }\n+        }\n+        ExprKind::ConstBlock { did: def_id, substs } => {\n+            let uneval = mir::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n+            let literal = ConstantKind::Unevaluated(uneval, ty);\n+\n+            Constant { user_ty: None, span, literal }\n+        }\n+        ExprKind::StaticRef { alloc_id, ty, .. } => {\n+            let const_val = ConstValue::Scalar(Scalar::from_pointer(alloc_id.into(), &tcx));\n+            let literal = ConstantKind::Val(const_val, ty);\n+\n+            Constant { span, user_ty: None, literal }\n         }\n+        _ => span_bug!(span, \"expression is not a valid constant {:?}\", kind),\n     }\n }\n "}, {"sha": "b456e2aa37a2791fae3f40a8868c9ff70bcea9b7", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=9c0bc3028a575eece6d4e8fbc6624cb95b9c9893", "patch": "@@ -492,7 +492,7 @@ fn construct_fn<'tcx>(\n             arguments,\n             return_ty,\n             return_ty_span,\n-            span,\n+            span_with_body,\n             custom_mir_attr,\n         );\n     }"}, {"sha": "8ba1c122884ca431173cc28a77d33b6282e7169d", "filename": "library/core/src/intrinsics/mir.rs", "status": "modified", "additions": 170, "deletions": 4, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=9c0bc3028a575eece6d4e8fbc6624cb95b9c9893", "patch": "@@ -80,6 +80,8 @@ define!(\"mir_goto\", fn Goto(destination: BasicBlock) -> BasicBlock);\n define!(\"mir_retag\", fn Retag<T>(place: T));\n define!(\"mir_retag_raw\", fn RetagRaw<T>(place: T));\n define!(\"mir_move\", fn Move<T>(place: T) -> T);\n+define!(\"mir_static\", fn Static<T>(s: T) -> &'static T);\n+define!(\"mir_static_mut\", fn StaticMut<T>(s: T) -> *mut T);\n \n /// Convenience macro for generating custom MIR.\n ///\n@@ -90,10 +92,14 @@ pub macro mir {\n     (\n         $(let $local_decl:ident $(: $local_decl_ty:ty)? ;)*\n \n-        $entry_block:block\n+        {\n+            $($entry:tt)*\n+        }\n \n         $(\n-            $block_name:ident = $block:block\n+            $block_name:ident = {\n+                $($block:tt)*\n+            }\n         )*\n     ) => {{\n         // First, we declare all basic blocks.\n@@ -109,15 +115,175 @@ pub macro mir {\n                 let $local_decl $(: $local_decl_ty)? ;\n             )*\n \n+            ::core::intrinsics::mir::__internal_extract_let!($($entry)*);\n+            $(\n+                ::core::intrinsics::mir::__internal_extract_let!($($block)*);\n+            )*\n+\n             {\n                 // Finally, the contents of the basic blocks\n-                $entry_block;\n+                ::core::intrinsics::mir::__internal_remove_let!({\n+                    {}\n+                    { $($entry)* }\n+                });\n                 $(\n-                    $block;\n+                    ::core::intrinsics::mir::__internal_remove_let!({\n+                        {}\n+                        { $($block)* }\n+                    });\n                 )*\n \n                 RET\n             }\n         }\n     }}\n }\n+\n+/// Helper macro that extracts the `let` declarations out of a bunch of statements.\n+///\n+/// This macro is written using the \"statement muncher\" strategy. Each invocation parses the first\n+/// statement out of the input, does the appropriate thing with it, and then recursively calls the\n+/// same macro on the remainder of the input.\n+#[doc(hidden)]\n+pub macro __internal_extract_let {\n+    // If it's a `let` like statement, keep the `let`\n+    (\n+        let $var:ident $(: $ty:ty)? = $expr:expr; $($rest:tt)*\n+    ) => {\n+        let $var $(: $ty)?;\n+        ::core::intrinsics::mir::__internal_extract_let!($($rest)*);\n+    },\n+    // Due to #86730, we have to handle const blocks separately\n+    (\n+        let $var:ident $(: $ty:ty)? = const $block:block; $($rest:tt)*\n+    ) => {\n+        let $var $(: $ty)?;\n+        ::core::intrinsics::mir::__internal_extract_let!($($rest)*);\n+    },\n+    // Otherwise, output nothing\n+    (\n+        $stmt:stmt; $($rest:tt)*\n+    ) => {\n+        ::core::intrinsics::mir::__internal_extract_let!($($rest)*);\n+    },\n+    (\n+        $expr:expr\n+    ) => {}\n+}\n+\n+/// Helper macro that removes the `let` declarations from a bunch of statements.\n+///\n+/// Because expression position macros cannot expand to statements + expressions, we need to be\n+/// slightly creative here. The general strategy is also statement munching as above, but the output\n+/// of the macro is \"stored\" in the subsequent macro invocation. Easiest understood via example:\n+/// ```text\n+/// invoke!(\n+///     {\n+///         {\n+///             x = 5;\n+///         }\n+///         {\n+///             let d = e;\n+///             Call()\n+///         }\n+///     }\n+/// )\n+/// ```\n+/// becomes\n+/// ```text\n+/// invoke!(\n+///     {\n+///         {\n+///             x = 5;\n+///             d = e;\n+///         }\n+///         {\n+///             Call()\n+///         }\n+///     }\n+/// )\n+/// ```\n+#[doc(hidden)]\n+pub macro __internal_remove_let {\n+    // If it's a `let` like statement, remove the `let`\n+    (\n+        {\n+            {\n+                $($already_parsed:tt)*\n+            }\n+            {\n+                let $var:ident $(: $ty:ty)? = $expr:expr;\n+                $($rest:tt)*\n+            }\n+        }\n+    ) => { ::core::intrinsics::mir::__internal_remove_let!(\n+        {\n+            {\n+                $($already_parsed)*\n+                $var = $expr;\n+            }\n+            {\n+                $($rest)*\n+            }\n+        }\n+    )},\n+    // Due to #86730 , we have to handle const blocks separately\n+    (\n+        {\n+            {\n+                $($already_parsed:tt)*\n+            }\n+            {\n+                let $var:ident $(: $ty:ty)? = const $block:block;\n+                $($rest:tt)*\n+            }\n+        }\n+    ) => { ::core::intrinsics::mir::__internal_remove_let!(\n+        {\n+            {\n+                $($already_parsed)*\n+                $var = const $block;\n+            }\n+            {\n+                $($rest)*\n+            }\n+        }\n+    )},\n+    // Otherwise, keep going\n+    (\n+        {\n+            {\n+                $($already_parsed:tt)*\n+            }\n+            {\n+                $stmt:stmt;\n+                $($rest:tt)*\n+            }\n+        }\n+    ) => { ::core::intrinsics::mir::__internal_remove_let!(\n+        {\n+            {\n+                $($already_parsed)*\n+                $stmt;\n+            }\n+            {\n+                $($rest)*\n+            }\n+        }\n+    )},\n+    (\n+        {\n+            {\n+                $($already_parsed:tt)*\n+            }\n+            {\n+                $expr:expr\n+            }\n+        }\n+    ) => {\n+        {\n+            $($already_parsed)*\n+            $expr\n+        }\n+    },\n+}"}, {"sha": "20dd251e7e3087602857da1f41e577d964767eb5", "filename": "src/test/mir-opt/building/custom/arbitrary_let.arbitrary_let.built.after.mir", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Farbitrary_let.arbitrary_let.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Farbitrary_let.arbitrary_let.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Farbitrary_let.arbitrary_let.built.after.mir?ref=9c0bc3028a575eece6d4e8fbc6624cb95b9c9893", "patch": "@@ -0,0 +1,22 @@\n+// MIR for `arbitrary_let` after built\n+\n+fn arbitrary_let(_1: i32) -> i32 {\n+    let mut _0: i32;                     // return place in scope 0 at $DIR/arbitrary_let.rs:+0:29: +0:32\n+    let mut _2: i32;                     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+    let mut _3: i32;                     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+\n+    bb0: {\n+        _2 = _1;                         // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+        goto -> bb2;                     // scope 0 at $DIR/arbitrary_let.rs:+4:13: +4:25\n+    }\n+\n+    bb1: {\n+        _0 = _3;                         // scope 0 at $DIR/arbitrary_let.rs:+7:13: +7:20\n+        return;                          // scope 0 at $DIR/arbitrary_let.rs:+8:13: +8:21\n+    }\n+\n+    bb2: {\n+        _3 = _2;                         // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+        goto -> bb1;                     // scope 0 at $DIR/arbitrary_let.rs:+12:13: +12:24\n+    }\n+}"}, {"sha": "776df3151ffd7817186f8b8cefc0a1dd6747495f", "filename": "src/test/mir-opt/building/custom/arbitrary_let.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Farbitrary_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Farbitrary_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Farbitrary_let.rs?ref=9c0bc3028a575eece6d4e8fbc6624cb95b9c9893", "patch": "@@ -0,0 +1,28 @@\n+#![feature(custom_mir, core_intrinsics)]\n+\n+extern crate core;\n+use core::intrinsics::mir::*;\n+use core::ptr::{addr_of, addr_of_mut};\n+\n+// EMIT_MIR arbitrary_let.arbitrary_let.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+fn arbitrary_let(x: i32) -> i32 {\n+    mir!(\n+        {\n+            let y = x;\n+            Goto(second)\n+        }\n+        third = {\n+            RET = z;\n+            Return()\n+        }\n+        second = {\n+            let z = y;\n+            Goto(third)\n+        }\n+    )\n+}\n+\n+fn main() {\n+    assert_eq!(arbitrary_let(5), 5);\n+}"}, {"sha": "ba753cfc20ca2348096729f34a9eb729ffd27930", "filename": "src/test/mir-opt/building/custom/consts.consts.built.after.mir", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fconsts.consts.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fconsts.consts.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fconsts.consts.built.after.mir?ref=9c0bc3028a575eece6d4e8fbc6624cb95b9c9893", "patch": "@@ -0,0 +1,22 @@\n+// MIR for `consts` after built\n+\n+fn consts() -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/consts.rs:+0:27: +0:27\n+    let mut _1: u8;                      // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+    let mut _2: i8;                      // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+    let mut _3: u32;                     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+    let mut _4: i32;                     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+    let mut _5: fn() {consts::<10>};     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+\n+    bb0: {\n+        _1 = const 5_u8;                 // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+        _2 = const _;                    // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+        _3 = const C;                    // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+        _4 = const _;                    // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+        _5 = consts::<10>;               // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $DIR/consts.rs:16:18: 16:30\n+                                         // + literal: Const { ty: fn() {consts::<10>}, val: Value(<ZST>) }\n+        return;                          // scope 0 at $DIR/consts.rs:+7:9: +7:17\n+    }\n+}"}, {"sha": "ff4fe1a93246ec0406679043402502f1e7d6a9f2", "filename": "src/test/mir-opt/building/custom/consts.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fconsts.rs?ref=9c0bc3028a575eece6d4e8fbc6624cb95b9c9893", "patch": "@@ -0,0 +1,36 @@\n+#![feature(custom_mir, core_intrinsics, inline_const)]\n+\n+extern crate core;\n+use core::intrinsics::mir::*;\n+\n+const D: i32 = 5;\n+\n+// EMIT_MIR consts.consts.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+fn consts<const C: u32>() {\n+    mir!({\n+        let _a = 5_u8;\n+        let _b = const { 5_i8 };\n+        let _c = C;\n+        let _d = D;\n+        let _e = consts::<10>;\n+        Return()\n+    })\n+}\n+\n+static S: i32 = 5;\n+static mut T: i32 = 10;\n+// EMIT_MIR consts.statics.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+fn statics() {\n+    mir!({\n+        let _a: &i32 = Static(S);\n+        let _b: *mut i32 = StaticMut(T);\n+        Return()\n+    })\n+}\n+\n+fn main() {\n+    consts::<5>();\n+    statics();\n+}"}, {"sha": "ee768e263ecdf9d536a824f6600cd04194461847", "filename": "src/test/mir-opt/building/custom/consts.statics.built.after.mir", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fconsts.statics.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fconsts.statics.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fconsts.statics.built.after.mir?ref=9c0bc3028a575eece6d4e8fbc6624cb95b9c9893", "patch": "@@ -0,0 +1,27 @@\n+// MIR for `statics` after built\n+\n+fn statics() -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/consts.rs:+0:14: +0:14\n+    let mut _1: &i32;                    // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+    let mut _2: *mut i32;                // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+\n+    bb0: {\n+        _1 = const {alloc1: &i32};       // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $DIR/consts.rs:27:31: 27:32\n+                                         // + literal: Const { ty: &i32, val: Value(Scalar(alloc1)) }\n+        _2 = const {alloc2: *mut i32};   // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $DIR/consts.rs:28:38: 28:39\n+                                         // + literal: Const { ty: *mut i32, val: Value(Scalar(alloc2)) }\n+        return;                          // scope 0 at $DIR/consts.rs:+4:9: +4:17\n+    }\n+}\n+\n+alloc2 (static: T, size: 4, align: 4) {\n+    0a 00 00 00                                     \u2502 ....\n+}\n+\n+alloc1 (static: S, size: 4, align: 4) {\n+    05 00 00 00                                     \u2502 ....\n+}"}, {"sha": "4d38d45c0f47924eaa45b236916d5ebc21f55957", "filename": "src/test/mir-opt/building/custom/references.immut_ref.built.after.mir", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.immut_ref.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.immut_ref.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.immut_ref.built.after.mir?ref=9c0bc3028a575eece6d4e8fbc6624cb95b9c9893", "patch": "@@ -5,10 +5,10 @@ fn immut_ref(_1: &i32) -> &i32 {\n     let mut _2: *const i32;              // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n \n     bb0: {\n-        _2 = &raw const (*_1);           // scope 0 at $DIR/references.rs:+0:1: +0:34\n-        Retag([raw] _2);                 // scope 0 at $DIR/references.rs:+0:1: +0:34\n-        _0 = &(*_2);                     // scope 0 at $DIR/references.rs:+0:1: +0:34\n-        Retag(_0);                       // scope 0 at $DIR/references.rs:+0:1: +0:34\n-        return;                          // scope 0 at $DIR/references.rs:+0:1: +0:34\n+        _2 = &raw const (*_1);           // scope 0 at $DIR/references.rs:+5:13: +5:29\n+        Retag([raw] _2);                 // scope 0 at $DIR/references.rs:+6:13: +6:24\n+        _0 = &(*_2);                     // scope 0 at $DIR/references.rs:+7:13: +7:23\n+        Retag(_0);                       // scope 0 at $DIR/references.rs:+8:13: +8:23\n+        return;                          // scope 0 at $DIR/references.rs:+9:13: +9:21\n     }\n }"}, {"sha": "01bc8a9cd35802676f6e2c82bbf59462216c1b88", "filename": "src/test/mir-opt/building/custom/references.mut_ref.built.after.mir", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.mut_ref.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.mut_ref.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.mut_ref.built.after.mir?ref=9c0bc3028a575eece6d4e8fbc6624cb95b9c9893", "patch": "@@ -5,10 +5,10 @@ fn mut_ref(_1: &mut i32) -> &mut i32 {\n     let mut _2: *mut i32;                // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n \n     bb0: {\n-        _2 = &raw mut (*_1);             // scope 0 at $DIR/references.rs:+0:1: +0:40\n-        Retag([raw] _2);                 // scope 0 at $DIR/references.rs:+0:1: +0:40\n-        _0 = &mut (*_2);                 // scope 0 at $DIR/references.rs:+0:1: +0:40\n-        Retag(_0);                       // scope 0 at $DIR/references.rs:+0:1: +0:40\n-        return;                          // scope 0 at $DIR/references.rs:+0:1: +0:40\n+        _2 = &raw mut (*_1);             // scope 0 at $DIR/references.rs:+5:13: +5:33\n+        Retag([raw] _2);                 // scope 0 at $DIR/references.rs:+6:13: +6:24\n+        _0 = &mut (*_2);                 // scope 0 at $DIR/references.rs:+7:13: +7:26\n+        Retag(_0);                       // scope 0 at $DIR/references.rs:+8:13: +8:23\n+        return;                          // scope 0 at $DIR/references.rs:+9:13: +9:21\n     }\n }"}, {"sha": "d7560fde69c9500412035d2815c5995e57d659d0", "filename": "src/test/mir-opt/building/custom/simple_assign.simple.built.after.mir", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fsimple_assign.simple.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fsimple_assign.simple.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fsimple_assign.simple.built.after.mir?ref=9c0bc3028a575eece6d4e8fbc6624cb95b9c9893", "patch": "@@ -6,13 +6,13 @@ fn simple(_1: i32) -> i32 {\n     let mut _3: i32;                     // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n \n     bb0: {\n-        _2 = _1;                         // scope 0 at $DIR/simple_assign.rs:+0:1: +0:29\n-        goto -> bb1;                     // scope 0 at $DIR/simple_assign.rs:+0:1: +0:29\n+        _2 = _1;                         // scope 0 at $DIR/simple_assign.rs:+6:13: +6:22\n+        goto -> bb1;                     // scope 0 at $DIR/simple_assign.rs:+7:13: +7:23\n     }\n \n     bb1: {\n-        _3 = move _2;                    // scope 0 at $DIR/simple_assign.rs:+0:1: +0:29\n-        _0 = _3;                         // scope 0 at $DIR/simple_assign.rs:+0:1: +0:29\n-        return;                          // scope 0 at $DIR/simple_assign.rs:+0:1: +0:29\n+        _3 = move _2;                    // scope 0 at $DIR/simple_assign.rs:+11:13: +11:32\n+        _0 = _3;                         // scope 0 at $DIR/simple_assign.rs:+12:13: +12:24\n+        return;                          // scope 0 at $DIR/simple_assign.rs:+13:13: +13:21\n     }\n }"}, {"sha": "2b0e8f1047b53d354cea365ad3afc1dcee6dae6d", "filename": "src/test/mir-opt/building/custom/simple_assign.simple_ref.built.after.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fsimple_assign.simple_ref.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/9c0bc3028a575eece6d4e8fbc6624cb95b9c9893/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fsimple_assign.simple_ref.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fsimple_assign.simple_ref.built.after.mir?ref=9c0bc3028a575eece6d4e8fbc6624cb95b9c9893", "patch": "@@ -4,7 +4,7 @@ fn simple_ref(_1: &mut i32) -> &mut i32 {\n     let mut _0: &mut i32;                // return place in scope 0 at $DIR/simple_assign.rs:+0:35: +0:43\n \n     bb0: {\n-        _0 = move _1;                    // scope 0 at $DIR/simple_assign.rs:+0:1: +0:43\n-        return;                          // scope 0 at $DIR/simple_assign.rs:+0:1: +0:43\n+        _0 = move _1;                    // scope 0 at $DIR/simple_assign.rs:+2:9: +2:22\n+        return;                          // scope 0 at $DIR/simple_assign.rs:+3:9: +3:17\n     }\n }"}]}