{"sha": "d1835ae7cc175b9aff383432e934e7ad13825ebc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxODM1YWU3Y2MxNzViOWFmZjM4MzQzMmU5MzRlN2FkMTM4MjVlYmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-02T18:17:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-02T18:17:48Z"}, "message": "Auto merge of #23931 - steveklabnik:doc_std_fs, r=alexcrichton", "tree": {"sha": "9256a382fcd7ae330d7d7bc89fab19029f48ccd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9256a382fcd7ae330d7d7bc89fab19029f48ccd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1835ae7cc175b9aff383432e934e7ad13825ebc", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1835ae7cc175b9aff383432e934e7ad13825ebc", "html_url": "https://github.com/rust-lang/rust/commit/d1835ae7cc175b9aff383432e934e7ad13825ebc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1835ae7cc175b9aff383432e934e7ad13825ebc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edac3ce6fba1063b01ca0e83841c762909d4df5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/edac3ce6fba1063b01ca0e83841c762909d4df5d", "html_url": "https://github.com/rust-lang/rust/commit/edac3ce6fba1063b01ca0e83841c762909d4df5d"}, {"sha": "187355178b9fe578846a41972e3ae0f3760cf2ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/187355178b9fe578846a41972e3ae0f3760cf2ee", "html_url": "https://github.com/rust-lang/rust/commit/187355178b9fe578846a41972e3ae0f3760cf2ee"}], "stats": {"total": 348, "additions": 306, "deletions": 42}, "files": [{"sha": "4e2dade9a3ca862cdacb7b2eb5e80929f6536fa8", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 306, "deletions": 42, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/d1835ae7cc175b9aff383432e934e7ad13825ebc/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1835ae7cc175b9aff383432e934e7ad13825ebc/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=d1835ae7cc175b9aff383432e934e7ad13825ebc", "patch": "@@ -96,10 +96,41 @@ pub struct WalkDir {\n \n /// Options and flags which can be used to configure how a file is opened.\n ///\n-/// This builder exposes the ability to configure how a `File` is opened and\n-/// what operations are permitted on the open file. The `File::open` and\n-/// `File::create` methods are aliases for commonly used options using this\n-/// builder.\n+/// This builder exposes the ability to configure how a `File` is opened and what operations are\n+/// permitted on the open file. The `File::open` and `File::create` methods are aliases for\n+/// commonly used options using this builder.\n+///\n+/// Generally speaking, when using `OpenOptions`, you'll first call `new()`, then chain calls to\n+/// methods to set each option, then call `open()`, passing the path of the file you're trying to\n+/// open. This will give you a [`io::Result`][result] with a [`File`][file] inside that you can\n+/// further operate on.\n+///\n+/// [result]: ../io/type.Result.html\n+/// [file]: struct.File.html\n+///\n+/// # Examples\n+///\n+/// Opening a file to read:\n+///\n+/// ```no_run\n+/// use std::fs;\n+/// use std::fs::OpenOptions;\n+///\n+/// let file = OpenOptions::new().read(true).open(\"foo.txt\");\n+/// ```\n+///\n+/// Opening a file for both reading and writing, as well as creating it if it doesn't exist:\n+///\n+/// ```\n+/// use std::fs;\n+/// use std::fs::OpenOptions;\n+///\n+/// let file = OpenOptions::new()\n+///             .read(true)\n+///             .write(true)\n+///             .create(true)\n+///             .open(\"foo.txt\");\n+/// ```\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OpenOptions(fs_imp::OpenOptions);\n@@ -317,6 +348,14 @@ impl OpenOptions {\n     /// Creates a blank net set of options ready for configuration.\n     ///\n     /// All options are initially set to `false`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::OpenOptions;\n+    ///\n+    /// let file = OpenOptions::new().open(\"foo.txt\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> OpenOptions {\n         OpenOptions(fs_imp::OpenOptions::new())\n@@ -326,6 +365,14 @@ impl OpenOptions {\n     ///\n     /// This option, when true, will indicate that the file should be\n     /// `read`-able if opened.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::OpenOptions;\n+    ///\n+    /// let file = OpenOptions::new().read(true).open(\"foo.txt\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn read(&mut self, read: bool) -> &mut OpenOptions {\n         self.0.read(read); self\n@@ -335,6 +382,14 @@ impl OpenOptions {\n     ///\n     /// This option, when true, will indicate that the file should be\n     /// `write`-able if opened.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::OpenOptions;\n+    ///\n+    /// let file = OpenOptions::new().write(true).open(\"foo.txt\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write(&mut self, write: bool) -> &mut OpenOptions {\n         self.0.write(write); self\n@@ -344,6 +399,14 @@ impl OpenOptions {\n     ///\n     /// This option, when true, means that writes will append to a file instead\n     /// of overwriting previous contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::OpenOptions;\n+    ///\n+    /// let file = OpenOptions::new().append(true).open(\"foo.txt\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn append(&mut self, append: bool) -> &mut OpenOptions {\n         self.0.append(append); self\n@@ -353,6 +416,14 @@ impl OpenOptions {\n     ///\n     /// If a file is successfully opened with this option set it will truncate\n     /// the file to 0 length if it already exists.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::OpenOptions;\n+    ///\n+    /// let file = OpenOptions::new().truncate(true).open(\"foo.txt\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, truncate: bool) -> &mut OpenOptions {\n         self.0.truncate(truncate); self\n@@ -362,6 +433,14 @@ impl OpenOptions {\n     ///\n     /// This option indicates whether a new file will be created if the file\n     /// does not yet already exist.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::OpenOptions;\n+    ///\n+    /// let file = OpenOptions::new().create(true).open(\"foo.txt\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn create(&mut self, create: bool) -> &mut OpenOptions {\n         self.0.create(create); self\n@@ -378,6 +457,14 @@ impl OpenOptions {\n     /// * Attempting to open a file with access that the user lacks\n     ///   permissions for\n     /// * Filesystem-level errors (full disk, etc)\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::OpenOptions;\n+    ///\n+    /// let file = OpenOptions::new().open(\"foo.txt\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn open<P: AsRef<Path>>(&self, path: P) -> io::Result<File> {\n         let path = path.as_ref();\n@@ -392,18 +479,70 @@ impl AsInnerMut<fs_imp::OpenOptions> for OpenOptions {\n \n impl Metadata {\n     /// Returns whether this metadata is for a directory.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// use std::fs;\n+    ///\n+    /// let metadata = try!(fs::metadata(\"foo.txt\"));\n+    ///\n+    /// assert!(!metadata.is_dir());\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_dir(&self) -> bool { self.0.is_dir() }\n \n     /// Returns whether this metadata is for a regular file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// use std::fs;\n+    ///\n+    /// let metadata = try!(fs::metadata(\"foo.txt\"));\n+    ///\n+    /// assert!(metadata.is_file());\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_file(&self) -> bool { self.0.is_file() }\n \n     /// Returns the size of the file, in bytes, this metadata is for.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// use std::fs;\n+    ///\n+    /// let metadata = try!(fs::metadata(\"foo.txt\"));\n+    ///\n+    /// assert_eq!(0, metadata.len());\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> u64 { self.0.size() }\n \n     /// Returns the permissions of the file this metadata is for.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// use std::fs;\n+    ///\n+    /// let metadata = try!(fs::metadata(\"foo.txt\"));\n+    ///\n+    /// assert!(!metadata.permissions().readonly());\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn permissions(&self) -> Permissions {\n         Permissions(self.0.perm())\n@@ -430,13 +569,48 @@ impl Metadata {\n \n impl Permissions {\n     /// Returns whether these permissions describe a readonly file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut f = try!(File::create(\"foo.txt\"));\n+    /// let metadata = try!(f.metadata());\n+    ///\n+    /// assert_eq!(false, metadata.permissions().readonly());\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn readonly(&self) -> bool { self.0.readonly() }\n \n     /// Modify the readonly flag for this set of permissions.\n     ///\n     /// This operation does **not** modify the filesystem. To modify the\n     /// filesystem use the `fs::set_permissions` function.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut f = try!(File::create(\"foo.txt\"));\n+    /// let metadata = try!(f.metadata());\n+    /// let mut permissions = metadata.permissions();\n+    ///\n+    /// permissions.set_readonly(true);\n+    ///\n+    /// // filesystem doesn't change\n+    /// assert_eq!(false, metadata.permissions().readonly());\n+    ///\n+    /// // just this particular `permissions`.\n+    /// assert_eq!(true, permissions.readonly());\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn set_readonly(&mut self, readonly: bool) {\n         self.0.set_readonly(readonly)\n@@ -468,20 +642,35 @@ impl DirEntry {\n     ///\n     /// The full path is created by joining the original path to `read_dir` or\n     /// `walk_dir` with the filename of this entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs;\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// for entry in try!(fs::read_dir(\".\")) {\n+    ///     let dir = try!(entry);\n+    ///     println!(\"{:?}\", dir.path());\n+    /// }\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n+    ///\n+    /// This prints output like:\n+    ///\n+    /// ```text\n+    /// \"./whatever.txt\"\n+    /// \"./foo.html\"\n+    /// \"./hello_world.rs\"\n+    /// ```\n+    ///\n+    /// The exact text, of course, depends on what files you have in `.`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn path(&self) -> PathBuf { self.0.path() }\n }\n \n /// Remove a file from the underlying filesystem.\n ///\n-/// # Examples\n-///\n-/// ```rust,no_run\n-/// use std::fs;\n-///\n-/// fs::remove_file(\"/some/file/path.txt\");\n-/// ```\n-///\n /// Note that, just because an unlink call was successful, it is not\n /// guaranteed that a file is immediately deleted (e.g. depending on\n /// platform, other open file descriptors may prevent immediate removal).\n@@ -491,6 +680,17 @@ impl DirEntry {\n /// This function will return an error if `path` points to a directory, if the\n /// user lacks permissions to remove the file, or if some other filesystem-level\n /// error occurs.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::fs;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// try!(fs::remove_file(\"a.txt\"));\n+/// # Ok(())\n+/// # }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn remove_file<P: AsRef<Path>>(path: P) -> io::Result<()> {\n     fs_imp::unlink(path.as_ref())\n@@ -504,7 +704,7 @@ pub fn remove_file<P: AsRef<Path>>(path: P) -> io::Result<()> {\n ///\n /// # Examples\n ///\n-/// ```rust,no_run\n+/// ```rust\n /// # fn foo() -> std::io::Result<()> {\n /// use std::fs;\n ///\n@@ -526,20 +726,23 @@ pub fn metadata<P: AsRef<Path>>(path: P) -> io::Result<Metadata> {\n \n /// Rename a file or directory to a new name.\n ///\n-/// # Examples\n-///\n-/// ```rust,no_run\n-/// use std::fs;\n-///\n-/// fs::rename(\"foo\", \"bar\");\n-/// ```\n-///\n /// # Errors\n ///\n /// This function will return an error if the provided `from` doesn't exist, if\n /// the process lacks permissions to view the contents, if `from` and `to`\n /// reside on separate filesystems, or if some other intermittent I/O error\n /// occurs.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::fs;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// try!(fs::rename(\"a.txt\", \"b.txt\"));\n+/// # Ok(())\n+/// # }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn rename<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<()> {\n     fs_imp::rename(from.as_ref(), to.as_ref())\n@@ -553,14 +756,6 @@ pub fn rename<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<()>\n /// Note that if `from` and `to` both point to the same file, then the file\n /// will likely get truncated by this operation.\n ///\n-/// # Examples\n-///\n-/// ```\n-/// use std::fs;\n-///\n-/// fs::copy(\"foo.txt\", \"bar.txt\");\n-/// ```\n-///\n /// # Errors\n ///\n /// This function will return an error in the following situations, but is not\n@@ -570,6 +765,14 @@ pub fn rename<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<()>\n /// * The `from` file does not exist\n /// * The current process does not have the permission rights to access\n ///   `from` or write `to`\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::fs;\n+///\n+/// fs::copy(\"foo.txt\", \"bar.txt\");\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<u64> {\n     let from = from.as_ref();\n@@ -592,6 +795,17 @@ pub fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<u64> {\n ///\n /// The `dst` path will be a link pointing to the `src` path. Note that systems\n /// often require these two paths to both be located on the same filesystem.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::fs;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// try!(fs::hard_link(\"a.txt\", \"b.txt\"));\n+/// # Ok(())\n+/// # }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn hard_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n     fs_imp::link(src.as_ref(), dst.as_ref())\n@@ -600,6 +814,17 @@ pub fn hard_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<(\n /// Creates a new soft link on the filesystem.\n ///\n /// The `dst` path will be a soft link pointing to the `src` path.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::fs;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// try!(fs::soft_link(\"a.txt\", \"b.txt\"));\n+/// # Ok(())\n+/// # }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn soft_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n     fs_imp::symlink(src.as_ref(), dst.as_ref())\n@@ -612,25 +837,39 @@ pub fn soft_link<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<(\n /// This function will return an error on failure. Failure conditions include\n /// reading a file that does not exist or reading a file that is not a soft\n /// link.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::fs;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// let path = try!(fs::read_link(\"a.txt\"));\n+/// # Ok(())\n+/// # }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn read_link<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n     fs_imp::readlink(path.as_ref())\n }\n \n /// Create a new, empty directory at the provided path\n ///\n+/// # Errors\n+///\n+/// This function will return an error if the user lacks permissions to make a\n+/// new directory at the provided `path`, or if the directory already exists.\n+///\n /// # Examples\n ///\n /// ```\n /// use std::fs;\n ///\n-/// fs::create_dir(\"/some/dir\");\n+/// # fn foo() -> std::io::Result<()> {\n+/// try!(fs::create_dir(\"/some/dir\"));\n+/// # Ok(())\n+/// # }\n /// ```\n-///\n-/// # Errors\n-///\n-/// This function will return an error if the user lacks permissions to make a\n-/// new directory at the provided `path`, or if the directory already exists.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn create_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n     fs_imp::mkdir(path.as_ref())\n@@ -645,6 +884,17 @@ pub fn create_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// does not already exist and it could not be created otherwise. The specific\n /// error conditions for when a directory is being created (after it is\n /// determined to not exist) are outlined by `fs::create_dir`.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::fs;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// try!(fs::create_dir_all(\"/some/dir\"));\n+/// # Ok(())\n+/// # }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn create_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n     let path = path.as_ref();\n@@ -655,18 +905,21 @@ pub fn create_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n \n /// Remove an existing, empty directory\n ///\n+/// # Errors\n+///\n+/// This function will return an error if the user lacks permissions to remove\n+/// the directory at the provided `path`, or if the directory isn't empty.\n+///\n /// # Examples\n ///\n /// ```\n /// use std::fs;\n ///\n-/// fs::remove_dir(\"/some/dir\");\n+/// # fn foo() -> std::io::Result<()> {\n+/// try!(fs::remove_dir(\"/some/dir\"));\n+/// # Ok(())\n+/// # }\n /// ```\n-///\n-/// # Errors\n-///\n-/// This function will return an error if the user lacks permissions to remove\n-/// the directory at the provided `path`, or if the directory isn't empty.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn remove_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n     fs_imp::rmdir(path.as_ref())\n@@ -680,7 +933,18 @@ pub fn remove_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n ///\n /// # Errors\n ///\n-/// See `file::remove_file` and `fs::remove_dir`\n+/// See `file::remove_file` and `fs::remove_dir`.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::fs;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// try!(fs::remove_dir_all(\"/some/dir\"));\n+/// # Ok(())\n+/// # }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n     let path = path.as_ref();"}]}