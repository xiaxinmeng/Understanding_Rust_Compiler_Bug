{"sha": "5de57e278d777102c589dbb96331b7013ab597a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkZTU3ZTI3OGQ3NzcxMDJjNTg5ZGJiOTYzMzFiNzAxM2FiNTk3YTI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-08-15T02:40:57Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-08-15T02:40:57Z"}, "message": "Merge branch 'incoming' into reg-snap", "tree": {"sha": "4fbc2f5bdfbac9e228ec685f1f25d3e9eca0826d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fbc2f5bdfbac9e228ec685f1f25d3e9eca0826d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5de57e278d777102c589dbb96331b7013ab597a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5de57e278d777102c589dbb96331b7013ab597a2", "html_url": "https://github.com/rust-lang/rust/commit/5de57e278d777102c589dbb96331b7013ab597a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5de57e278d777102c589dbb96331b7013ab597a2/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "476aae16af195363393cbcab413ae018267f2b97", "url": "https://api.github.com/repos/rust-lang/rust/commits/476aae16af195363393cbcab413ae018267f2b97", "html_url": "https://github.com/rust-lang/rust/commit/476aae16af195363393cbcab413ae018267f2b97"}, {"sha": "11258310e2b67f734d4d520e6f995342892ecc3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/11258310e2b67f734d4d520e6f995342892ecc3a", "html_url": "https://github.com/rust-lang/rust/commit/11258310e2b67f734d4d520e6f995342892ecc3a"}], "stats": {"total": 2452, "additions": 1552, "deletions": 900}, "files": [{"sha": "115ae566c24b64312bad73bb21d59fad6a97c69f", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -8,7 +8,7 @@ import rustc::metadata::filesearch::{get_cargo_root, get_cargo_root_nearest,\n import syntax::diagnostic;\n \n import result::{ok, err};\n-import io::writer_util;\n+import io::WriterUtil;\n import std::{map, json, tempfile, term, sort, getopts};\n import map::hashmap;\n import to_str::to_str;"}, {"sha": "d5cddf0a4e0d918171c6e3c41b753592b3e9bd8c", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,5 +1,5 @@\n import run::spawn_process;\n-import io::writer_util;\n+import io::WriterUtil;\n import libc::{c_int, pid_t};\n \n import pipes::chan;\n@@ -45,8 +45,8 @@ fn run(lib_path: ~str,\n     let pipe_out = os::pipe();\n     let pipe_err = os::pipe();\n     let pid = spawn_process(prog, args,\n-                            some(env + target_env(lib_path, prog)),\n-                            none, pipe_in.in, pipe_out.out, pipe_err.out);\n+                            &some(env + target_env(lib_path, prog)),\n+                            &none, pipe_in.in, pipe_out.out, pipe_err.out);\n \n     os::close(pipe_in.in);\n     os::close(pipe_out.out);"}, {"sha": "a6800053966c73443d61125bac12cf54d53bc1f8", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,4 +1,4 @@\n-import io::writer_util;\n+import io::WriterUtil;\n \n import common::mode_run_pass;\n import common::mode_run_fail;\n@@ -339,7 +339,7 @@ fn compose_and_run_compiler(\n                     config.compile_lib_path, input)\n }\n \n-fn ensure_dir(path: path) {\n+fn ensure_dir(path: Path) {\n     if os::path_is_dir(path) { return; }\n     if !os::make_dir(path, 0x1c0i32) {\n         fail fmt!{\"can't make dir %s\", path};\n@@ -455,7 +455,7 @@ fn dump_output_file(config: config, testfile: ~str,\n                     out: ~str, extension: ~str) {\n     let outfile = make_out_name(config, testfile, extension);\n     let writer = result::get(\n-        io::file_writer(outfile, ~[io::create, io::truncate]));\n+        io::file_writer(outfile, ~[io::Create, io::Truncate]));\n     writer.write_str(out);\n }\n "}, {"sha": "028fc4732e0d926aeb3f74d05bd6f685dfec526f", "filename": "src/etc/combine-tests.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Fetc%2Fcombine-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Fetc%2Fcombine-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcombine-tests.py?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -54,7 +54,7 @@ def scrub(b):\n d.write(\"use std;\\n\")\n d.write(\"use run_pass_stage2;\\n\")\n d.write(\"import run_pass_stage2::*;\\n\")\n-d.write(\"import io::writer_util;\\n\");\n+d.write(\"import io::WriterUtil;\\n\");\n d.write(\"fn main() {\\n\");\n d.write(\"    let out = io::stdout();\\n\");\n i = 0"}, {"sha": "b9f11d881ab25c76610c6165a88d1cfeb7f8f173", "filename": "src/etc/emacs/README.md", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Fetc%2Femacs%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Fetc%2Femacs%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2FREADME.md?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -4,7 +4,10 @@ rust-mode: A major emacs mode for editing Rust source code\n `rust-mode` makes editing [Rust](http://rust-lang.org) code with emacs\n enjoyable.\n \n-To install, check out this repository and add this to your .emacs\n+\n+### Manual Installation\n+\n+To install manually, check out this repository and add this to your .emacs\n file:\n \n     (add-to-list 'load-path \"/path/to/rust-mode/\")\n@@ -25,3 +28,60 @@ it, and pressing `C-j`:\n \n Rust mode will automatically be associated with .rs and .rc files. To\n enable it explicitly, do `M-x rust-mode`.\n+\n+### package.el installation via Marmalade\n+\n+It can be more convenient to use Emacs's package manager to handle\n+installation for you if you use many elisp libraries. If you have\n+package.el but haven't added Marmalade, the community package source,\n+yet, add this to ~/.emacs.d/init.el:\n+\n+```lisp\n+(require 'package)\n+(add-to-list 'package-archives\n+             '(\"marmalade\" . \"http://marmalade-repo.org/packages/\"))\n+(package-initialize)\n+```\n+\n+Then do this to load the package listing:\n+\n+* <kbd>M-x eval-buffer</kbd>\n+* <kbd>M-x package-refresh-contents</kbd>\n+\n+If you use a version of Emacs prior to 24 that doesn't include\n+package.el, you can get it from http://bit.ly/pkg-el23.\n+\n+If you have an older ELPA package.el installed from tromey.com, you\n+should upgrade in order to support installation from multiple sources.\n+The ELPA archive is deprecated and no longer accepting new packages,\n+so the version there (1.7.1) is very outdated.\n+\n+From there you can install rust-mode or any other modes by choosing\n+them from a list:\n+\n+* <kbd>M-x package-list-packages</kbd>\n+\n+Now, to install packages, move your cursor to them and press i. This\n+will mark the packages for installation. When you're done with\n+marking, press x, and ELPA will install the packages for you (under\n+~/.emacs.d/elpa/).\n+\n+* or using <kbd>M-x package-install rust-mode\n+\n+#### Important\n+\n+In order to have cm-mode properly initialized after compilation prior\n+to rust-mode.el compilation you will need to add these `advices` to\n+your init file or if you are a melpa user install the `melpa` package.\n+\n+```lisp\n+(defadvice package-download-tar\n+  (after package-download-tar-initialize activate compile)\n+  \"initialize the package after compilation\"\n+  (package-initialize))\n+\n+(defadvice package-download-single\n+  (after package-download-single-initialize activate compile)\n+  \"initialize the package after compilation\"\n+  (package-initialize))\n+```"}, {"sha": "0303f994172cb617b72410fa7239c8ab1c67b5bb", "filename": "src/etc/emacs/cm-mode.el", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Fetc%2Femacs%2Fcm-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Fetc%2Femacs%2Fcm-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Fcm-mode.el?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,8 +1,8 @@\n ;;; cm-mode.el --- Wrapper for CodeMirror-style Emacs modes\n \n ;; Version: 0.1.0\n+;; Author: Mozilla\n ;; Url: https://github.com/mozilla/rust\n-\n ;; Highlighting is done by running a stateful parser (with first-class\n ;; state object) over the buffer, line by line, using the output to\n ;; add 'face properties, and storing the parser state at the end of"}, {"sha": "6c118da40e0ba3ab99748c225ed93be949cf15d1", "filename": "src/etc/emacs/rust-mode.el", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Fetc%2Femacs%2Frust-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Fetc%2Femacs%2Frust-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode.el?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,6 +1,7 @@\n ;;; rust-mode.el --- A major emacs mode for editing Rust source code\n \n ;; Version: 0.1.0\n+;; Author: Mozilla\n ;; Package-Requires: ((cm-mode \"0.1.0\"))\n ;; Url: https://github.com/mozilla/rust\n "}, {"sha": "352831c86e6203a58ea37207058de7b8c0972a0b", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,4 +1,4 @@\n-import io::writer_util;\n+import io::WriterUtil;\n \n import syntax::{ast, ast_util, fold, visit, codemap};\n import syntax::parse;\n@@ -10,7 +10,7 @@ type context = { mode: test_mode }; // + rng\n \n fn write_file(filename: ~str, content: ~str) {\n     result::get(\n-        io::file_writer(filename, ~[io::create, io::truncate]))\n+        io::file_writer(filename, ~[io::Create, io::Truncate]))\n         .write_str(content);\n }\n \n@@ -216,9 +216,9 @@ fn under(n: uint, it: fn(uint)) {\n     while i < n { it(i); i += 1u; }\n }\n \n-fn devnull() -> io::writer { io::mem_buffer_writer(io::mem_buffer()) }\n+fn devnull() -> io::Writer { io::mem_buffer_writer(io::mem_buffer()) }\n \n-fn as_str(f: fn@(io::writer)) -> ~str {\n+fn as_str(f: fn@(io::Writer)) -> ~str {\n     let buf = io::mem_buffer();\n     f(io::mem_buffer_writer(buf));\n     io::mem_buffer_str(buf)"}, {"sha": "38bdc4075477f59a19cff5f26a4f61f3ae1d6353", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,3 +1,6 @@\n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n /*!\n  * Communication between tasks\n  *\n@@ -162,7 +165,7 @@ fn chan<T: send>(p: port<T>) -> chan<T> {\n  * Sends data over a channel. The sent data is moved into the channel,\n  * whereupon the caller loses access to it.\n  */\n-fn send<T: send>(ch: chan<T>, -data: T) {\n+fn send<T: send>(ch: chan<T>, +data: T) {\n     let chan_t(p) = ch;\n     let data_ptr = ptr::addr_of(data) as *();\n     let res = rustrt::rust_port_id_send(p, data_ptr);"}, {"sha": "f5c9039ad25c97ba0927eaa3ec400042ea8f3ee5", "filename": "src/libcore/core.rc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -54,6 +54,7 @@ export send_map;\n export hash;\n export cmp;\n export num;\n+export path;\n \n // NDM seems to be necessary for resolve to work\n export option_iter;\n@@ -214,11 +215,16 @@ mod pipes;\n \n // Runtime and language-primitive support\n \n+#[warn(non_camel_case_types)]\n mod io;\n mod libc;\n+#[warn(non_camel_case_types)]\n mod os;\n+#[warn(non_camel_case_types)]\n mod path;\n+#[warn(non_camel_case_types)]\n mod rand;\n+#[warn(non_camel_case_types)]\n mod run;\n #[warn(non_camel_case_types)]\n mod sys;"}, {"sha": "f6a721d102ab2889fdd7d6532635aefd1c173276", "filename": "src/libcore/core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -4,7 +4,7 @@\n \n import option::{some, none};\n import option = option::option;\n-import path = path::path;\n+import Path = path::Path;\n import tuple::{TupleOps, ExtendedTupleOps};\n import str::{str_slice, unique_str};\n import vec::{const_vector, copyable_vector, immutable_vector};\n@@ -14,7 +14,7 @@ import num::Num;\n import ptr::ptr;\n import to_str::ToStr;\n \n-export path, option, some, none, unreachable;\n+export Path, option, some, none, unreachable;\n export extensions;\n // The following exports are the extension impls for numeric types\n export Num, times, timesi;"}, {"sha": "2237dad299fedef8d3d429ec80b91a20a6e03529", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,3 +1,7 @@\n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n /*!\n  * Implementation of SipHash 2-4\n  *\n@@ -9,8 +13,8 @@\n  * CPRNG like rand::rng.\n  */\n \n-import io::writer;\n-import io::writer_util;\n+import io::Writer;\n+import io::WriterUtil;\n \n export Streaming, State;\n export default_state;\n@@ -122,7 +126,7 @@ fn SipState(key0: u64, key1: u64) -> SipState {\n }\n \n \n-impl &SipState : io::writer {\n+impl &SipState : io::Writer {\n \n     // Methods for io::writer\n     fn write(msg: &[const u8]) {\n@@ -205,7 +209,7 @@ impl &SipState : io::writer {\n         self.ntail = left;\n     }\n \n-    fn seek(_x: int, _s: io::seek_style) {\n+    fn seek(_x: int, _s: io::SeekStyle) {\n         fail;\n     }\n     fn tell() -> uint {\n@@ -214,8 +218,8 @@ impl &SipState : io::writer {\n     fn flush() -> int {\n         0\n     }\n-    fn get_type() -> io::writer_type {\n-        io::file\n+    fn get_type() -> io::WriterType {\n+        io::File\n     }\n }\n \n@@ -362,9 +366,9 @@ fn test_siphash() {\n     let stream_inc = &State(k0,k1);\n     let stream_full = &State(k0,k1);\n \n-    fn to_hex_str(r:[u8]/8) -> ~str {\n+    fn to_hex_str(r:  &[u8]/8) -> ~str {\n         let mut s = ~\"\";\n-        for vec::each(r) |b| { s += uint::to_str(b as uint, 16u); }\n+        for vec::each(*r) |b| { s += uint::to_str(b as uint, 16u); }\n         return s;\n     }\n \n@@ -379,7 +383,7 @@ fn test_siphash() {\n         stream_full.input(buf);\n         let f = stream_full.result_str();\n         let i = stream_inc.result_str();\n-        let v = to_hex_str(vecs[t]);\n+        let v = to_hex_str(&vecs[t]);\n         debug!{\"%d: (%s) => inc=%s full=%s\", t, v, i, f};\n \n         assert f == i && f == v;"}, {"sha": "c01672b5c738daef1b2cf499742e5f90a33fe573", "filename": "src/libcore/io.rs", "status": "modified", "additions": 114, "deletions": 110, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -11,6 +11,7 @@ import libc::{c_int, c_long, c_uint, c_void, size_t, ssize_t};\n import libc::consts::os::posix88::*;\n import libc::consts::os::extra::*;\n \n+#[allow(non_camel_case_types)] // not sure what to do about this\n type fd_t = c_int;\n \n #[abi = \"cdecl\"]\n@@ -24,25 +25,25 @@ extern mod rustrt {\n \n // FIXME (#2004): This is all buffered. We might need an unbuffered variant\n // as well\n-enum seek_style { seek_set, seek_end, seek_cur, }\n+enum SeekStyle { SeekSet, SeekEnd, SeekCur, }\n \n \n // The raw underlying reader trait. All readers must implement this.\n-trait reader {\n+trait Reader {\n     // FIXME (#2004): Seekable really should be orthogonal.\n \n     // FIXME (#2982): This should probably return an error.\n     fn read(buf: &[mut u8], len: uint) -> uint;\n     fn read_byte() -> int;\n     fn unread_byte(int);\n     fn eof() -> bool;\n-    fn seek(int, seek_style);\n+    fn seek(int, SeekStyle);\n     fn tell() -> uint;\n }\n \n // Generic utility functions defined on readers\n \n-impl reader {\n+impl Reader {\n     fn read_bytes(len: uint) -> ~[u8] {\n         let mut buf = ~[mut];\n         vec::reserve(buf, len);\n@@ -195,15 +196,15 @@ impl reader {\n \n // Reader implementations\n \n-fn convert_whence(whence: seek_style) -> i32 {\n+fn convert_whence(whence: SeekStyle) -> i32 {\n     return match whence {\n-      seek_set => 0i32,\n-      seek_cur => 1i32,\n-      seek_end => 2i32\n+      SeekSet => 0i32,\n+      SeekCur => 1i32,\n+      SeekEnd => 2i32\n     };\n }\n \n-impl *libc::FILE: reader {\n+impl *libc::FILE: Reader {\n     fn read(buf: &[mut u8], len: uint) -> uint {\n         do vec::as_buf(buf) |buf_p, buf_len| {\n             assert buf_len <= len;\n@@ -217,7 +218,7 @@ impl *libc::FILE: reader {\n     fn read_byte() -> int { return libc::fgetc(self) as int; }\n     fn unread_byte(byte: int) { libc::ungetc(byte as c_int, self); }\n     fn eof() -> bool { return libc::feof(self) != 0 as c_int; }\n-    fn seek(offset: int, whence: seek_style) {\n+    fn seek(offset: int, whence: SeekStyle) {\n         assert libc::fseek(self, offset as c_long, convert_whence(whence))\n             == 0 as c_int;\n     }\n@@ -227,36 +228,36 @@ impl *libc::FILE: reader {\n // A forwarding impl of reader that also holds on to a resource for the\n // duration of its lifetime.\n // FIXME there really should be a better way to do this // #2004\n-impl<T: reader, C> {base: T, cleanup: C}: reader {\n+impl<T: Reader, C> {base: T, cleanup: C}: Reader {\n     fn read(buf: &[mut u8], len: uint) -> uint { self.base.read(buf, len) }\n     fn read_byte() -> int { self.base.read_byte() }\n     fn unread_byte(byte: int) { self.base.unread_byte(byte); }\n     fn eof() -> bool { self.base.eof() }\n-    fn seek(off: int, whence: seek_style) { self.base.seek(off, whence) }\n+    fn seek(off: int, whence: SeekStyle) { self.base.seek(off, whence) }\n     fn tell() -> uint { self.base.tell() }\n }\n \n-class FILE_res {\n+class FILERes {\n     let f: *libc::FILE;\n     new(f: *libc::FILE) { self.f = f; }\n     drop { libc::fclose(self.f); }\n }\n \n-fn FILE_reader(f: *libc::FILE, cleanup: bool) -> reader {\n+fn FILE_reader(f: *libc::FILE, cleanup: bool) -> Reader {\n     if cleanup {\n-        {base: f, cleanup: FILE_res(f)} as reader\n+        {base: f, cleanup: FILERes(f)} as Reader\n     } else {\n-        f as reader\n+        f as Reader\n     }\n }\n \n // FIXME (#2004): this should either be an trait-less impl, a set of\n // top-level functions that take a reader, or a set of default methods on\n // reader (which can then be called reader)\n \n-fn stdin() -> reader { rustrt::rust_get_stdin() as reader }\n+fn stdin() -> Reader { rustrt::rust_get_stdin() as Reader }\n \n-fn file_reader(path: ~str) -> result<reader, ~str> {\n+fn file_reader(path: ~str) -> result<Reader, ~str> {\n     let f = os::as_c_charp(path, |pathbuf| {\n         os::as_c_charp(~\"r\", |modebuf|\n             libc::fopen(pathbuf, modebuf)\n@@ -271,9 +272,9 @@ fn file_reader(path: ~str) -> result<reader, ~str> {\n \n // Byte buffer readers\n \n-type byte_buf = {buf: ~[const u8], mut pos: uint, len: uint};\n+type ByteBuf = {buf: ~[const u8], mut pos: uint, len: uint};\n \n-impl byte_buf: reader {\n+impl ByteBuf: Reader {\n     fn read(buf: &[mut u8], len: uint) -> uint {\n         let count = uint::min(len, self.len - self.pos);\n \n@@ -293,65 +294,65 @@ impl byte_buf: reader {\n     // FIXME (#2738): implement this\n     fn unread_byte(_byte: int) { error!{\"Unimplemented: unread_byte\"}; fail; }\n     fn eof() -> bool { self.pos == self.len }\n-    fn seek(offset: int, whence: seek_style) {\n+    fn seek(offset: int, whence: SeekStyle) {\n         let pos = self.pos;\n         self.pos = seek_in_buf(offset, pos, self.len, whence);\n     }\n     fn tell() -> uint { self.pos }\n }\n \n-fn bytes_reader(bytes: ~[u8]) -> reader {\n+fn bytes_reader(bytes: ~[u8]) -> Reader {\n     bytes_reader_between(bytes, 0u, vec::len(bytes))\n }\n \n-fn bytes_reader_between(bytes: ~[u8], start: uint, end: uint) -> reader {\n-    {buf: bytes, mut pos: start, len: end} as reader\n+fn bytes_reader_between(bytes: ~[u8], start: uint, end: uint) -> Reader {\n+    {buf: bytes, mut pos: start, len: end} as Reader\n }\n \n-fn with_bytes_reader<t>(bytes: ~[u8], f: fn(reader) -> t) -> t {\n+fn with_bytes_reader<t>(bytes: ~[u8], f: fn(Reader) -> t) -> t {\n     f(bytes_reader(bytes))\n }\n \n fn with_bytes_reader_between<t>(bytes: ~[u8], start: uint, end: uint,\n-                                f: fn(reader) -> t) -> t {\n+                                f: fn(Reader) -> t) -> t {\n     f(bytes_reader_between(bytes, start, end))\n }\n \n-fn str_reader(s: ~str) -> reader {\n+fn str_reader(s: ~str) -> Reader {\n     bytes_reader(str::bytes(s))\n }\n \n-fn with_str_reader<T>(s: ~str, f: fn(reader) -> T) -> T {\n+fn with_str_reader<T>(s: ~str, f: fn(Reader) -> T) -> T {\n     do str::as_bytes(s) |bytes| {\n         with_bytes_reader_between(bytes, 0u, str::len(s), f)\n     }\n }\n \n // Writing\n-enum fileflag { append, create, truncate, no_flag, }\n+enum FileFlag { Append, Create, Truncate, NoFlag, }\n \n // What type of writer are we?\n-enum writer_type { screen, file }\n+enum WriterType { Screen, File }\n \n // FIXME (#2004): Seekable really should be orthogonal.\n // FIXME (#2004): eventually u64\n-trait writer {\n+trait Writer {\n     fn write(v: &[const u8]);\n-    fn seek(int, seek_style);\n+    fn seek(int, SeekStyle);\n     fn tell() -> uint;\n     fn flush() -> int;\n-    fn get_type() -> writer_type;\n+    fn get_type() -> WriterType;\n }\n \n-impl<T: writer, C> {base: T, cleanup: C}: writer {\n+impl<T: Writer, C> {base: T, cleanup: C}: Writer {\n     fn write(bs: &[const u8]) { self.base.write(bs); }\n-    fn seek(off: int, style: seek_style) { self.base.seek(off, style); }\n+    fn seek(off: int, style: SeekStyle) { self.base.seek(off, style); }\n     fn tell() -> uint { self.base.tell() }\n     fn flush() -> int { self.base.flush() }\n-    fn get_type() -> writer_type { file }\n+    fn get_type() -> WriterType { File }\n }\n \n-impl *libc::FILE: writer {\n+impl *libc::FILE: Writer {\n     fn write(v: &[const u8]) {\n         do vec::as_const_buf(v) |vbuf, len| {\n             let nout = libc::fwrite(vbuf as *c_void, len as size_t,\n@@ -363,28 +364,28 @@ impl *libc::FILE: writer {\n             }\n         }\n     }\n-    fn seek(offset: int, whence: seek_style) {\n+    fn seek(offset: int, whence: SeekStyle) {\n         assert libc::fseek(self, offset as c_long, convert_whence(whence))\n             == 0 as c_int;\n     }\n     fn tell() -> uint { libc::ftell(self) as uint }\n     fn flush() -> int { libc::fflush(self) as int }\n-    fn get_type() -> writer_type {\n+    fn get_type() -> WriterType {\n         let fd = libc::fileno(self);\n-        if libc::isatty(fd) == 0 { file   }\n-        else                     { screen }\n+        if libc::isatty(fd) == 0 { File   }\n+        else                     { Screen }\n     }\n }\n \n-fn FILE_writer(f: *libc::FILE, cleanup: bool) -> writer {\n+fn FILE_writer(f: *libc::FILE, cleanup: bool) -> Writer {\n     if cleanup {\n-        {base: f, cleanup: FILE_res(f)} as writer\n+        {base: f, cleanup: FILERes(f)} as Writer\n     } else {\n-        f as writer\n+        f as Writer\n     }\n }\n \n-impl fd_t: writer {\n+impl fd_t: Writer {\n     fn write(v: &[const u8]) {\n         let mut count = 0u;\n         do vec::as_const_buf(v) |vbuf, len| {\n@@ -400,7 +401,7 @@ impl fd_t: writer {\n             }\n         }\n     }\n-    fn seek(_offset: int, _whence: seek_style) {\n+    fn seek(_offset: int, _whence: SeekStyle) {\n         error!{\"need 64-bit foreign calls for seek, sorry\"};\n         fail;\n     }\n@@ -409,28 +410,28 @@ impl fd_t: writer {\n         fail;\n     }\n     fn flush() -> int { 0 }\n-    fn get_type() -> writer_type {\n-        if libc::isatty(self) == 0 { file } else { screen }\n+    fn get_type() -> WriterType {\n+        if libc::isatty(self) == 0 { File } else { Screen }\n     }\n }\n \n-class fd_res {\n+class FdRes {\n     let fd: fd_t;\n     new(fd: fd_t) { self.fd = fd; }\n     drop { libc::close(self.fd); }\n }\n \n-fn fd_writer(fd: fd_t, cleanup: bool) -> writer {\n+fn fd_writer(fd: fd_t, cleanup: bool) -> Writer {\n     if cleanup {\n-        {base: fd, cleanup: fd_res(fd)} as writer\n+        {base: fd, cleanup: FdRes(fd)} as Writer\n     } else {\n-        fd as writer\n+        fd as Writer\n     }\n }\n \n \n-fn mk_file_writer(path: ~str, flags: ~[fileflag])\n-    -> result<writer, ~str> {\n+fn mk_file_writer(path: ~str, flags: ~[FileFlag])\n+    -> result<Writer, ~str> {\n \n     #[cfg(windows)]\n     fn wb() -> c_int { (O_WRONLY | O_BINARY) as c_int }\n@@ -441,10 +442,10 @@ fn mk_file_writer(path: ~str, flags: ~[fileflag])\n     let mut fflags: c_int = wb();\n     for vec::each(flags) |f| {\n         match f {\n-          append => fflags |= O_APPEND as c_int,\n-          create => fflags |= O_CREAT as c_int,\n-          truncate => fflags |= O_TRUNC as c_int,\n-          no_flag => ()\n+          Append => fflags |= O_APPEND as c_int,\n+          Create => fflags |= O_CREAT as c_int,\n+          Truncate => fflags |= O_TRUNC as c_int,\n+          NoFlag => ()\n         }\n     }\n     let fd = do os::as_c_charp(path) |pathbuf| {\n@@ -535,7 +536,7 @@ fn u64_from_be_bytes(data: ~[u8], start: uint, size: uint) -> u64 {\n \n // FIXME: #3048 combine trait+impl (or just move these to\n // default methods on writer)\n-trait writer_util {\n+trait WriterUtil {\n     fn write_char(ch: char);\n     fn write_str(s: &str);\n     fn write_line(s: &str);\n@@ -560,7 +561,7 @@ trait writer_util {\n     fn write_u8(n: u8);\n }\n \n-impl<T:writer> T : writer_util {\n+impl<T: Writer> T : WriterUtil {\n     fn write_char(ch: char) {\n         if ch as uint < 128u {\n             self.write(&[ch as u8]);\n@@ -631,13 +632,13 @@ impl<T:writer> T : writer_util {\n     fn write_u8(n: u8) { self.write(&[n]) }\n }\n \n-fn file_writer(path: ~str, flags: ~[fileflag]) -> result<writer, ~str> {\n+fn file_writer(path: ~str, flags: ~[FileFlag]) -> result<Writer, ~str> {\n     result::chain(mk_file_writer(path, flags), |w| result::ok(w))\n }\n \n \n // FIXME: fileflags // #2004\n-fn buffered_file_writer(path: ~str) -> result<writer, ~str> {\n+fn buffered_file_writer(path: ~str) -> result<Writer, ~str> {\n     let f = do os::as_c_charp(path) |pathbuf| {\n         do os::as_c_charp(~\"w\") |modebuf| {\n             libc::fopen(pathbuf, modebuf)\n@@ -650,15 +651,15 @@ fn buffered_file_writer(path: ~str) -> result<writer, ~str> {\n // FIXME (#2004) it would be great if this could be a const\n // FIXME (#2004) why are these different from the way stdin() is\n // implemented?\n-fn stdout() -> writer { fd_writer(libc::STDOUT_FILENO as c_int, false) }\n-fn stderr() -> writer { fd_writer(libc::STDERR_FILENO as c_int, false) }\n+fn stdout() -> Writer { fd_writer(libc::STDOUT_FILENO as c_int, false) }\n+fn stderr() -> Writer { fd_writer(libc::STDERR_FILENO as c_int, false) }\n \n fn print(s: &str) { stdout().write_str(s); }\n fn println(s: &str) { stdout().write_line(s); }\n \n-type mem_buffer = @{buf: dvec<u8>, mut pos: uint};\n+type MemBuffer = @{buf: dvec<u8>, mut pos: uint};\n \n-impl mem_buffer: writer {\n+impl MemBuffer: Writer {\n     fn write(v: &[const u8]) {\n         // Fast path.\n         let vlen = vec::len(v);\n@@ -679,48 +680,48 @@ impl mem_buffer: writer {\n         self.buf.push_slice(v, vpos, vlen);\n         self.pos += vlen;\n     }\n-    fn seek(offset: int, whence: seek_style) {\n+    fn seek(offset: int, whence: SeekStyle) {\n         let pos = self.pos;\n         let len = self.buf.len();\n         self.pos = seek_in_buf(offset, pos, len, whence);\n     }\n     fn tell() -> uint { self.pos }\n     fn flush() -> int { 0 }\n-    fn get_type() -> writer_type { file }\n+    fn get_type() -> WriterType { File }\n }\n \n-fn mem_buffer() -> mem_buffer {\n+fn mem_buffer() -> MemBuffer {\n     @{buf: dvec(), mut pos: 0u}\n }\n-fn mem_buffer_writer(b: mem_buffer) -> writer { b as writer }\n-fn mem_buffer_buf(b: mem_buffer) -> ~[u8] { b.buf.get() }\n-fn mem_buffer_str(b: mem_buffer) -> ~str {\n+fn mem_buffer_writer(b: MemBuffer) -> Writer { b as Writer }\n+fn mem_buffer_buf(b: MemBuffer) -> ~[u8] { b.buf.get() }\n+fn mem_buffer_str(b: MemBuffer) -> ~str {\n     str::from_bytes(b.buf.get())\n }\n \n-fn with_str_writer(f: fn(writer)) -> ~str {\n+fn with_str_writer(f: fn(Writer)) -> ~str {\n     let buf = mem_buffer();\n     let wr = mem_buffer_writer(buf);\n     f(wr);\n     io::mem_buffer_str(buf)\n }\n \n-fn with_buf_writer(f: fn(writer)) -> ~[u8] {\n+fn with_buf_writer(f: fn(Writer)) -> ~[u8] {\n     let buf = mem_buffer();\n     let wr = mem_buffer_writer(buf);\n     f(wr);\n     io::mem_buffer_buf(buf)\n }\n \n // Utility functions\n-fn seek_in_buf(offset: int, pos: uint, len: uint, whence: seek_style) ->\n+fn seek_in_buf(offset: int, pos: uint, len: uint, whence: SeekStyle) ->\n    uint {\n     let mut bpos = pos as int;\n     let blen = len as int;\n     match whence {\n-      seek_set => bpos = offset,\n-      seek_cur => bpos += offset,\n-      seek_end => bpos = blen + offset\n+      SeekSet => bpos = offset,\n+      SeekCur => bpos += offset,\n+      SeekEnd => bpos = blen + offset\n     }\n     if bpos < 0 { bpos = 0; } else if bpos > blen { bpos = blen; }\n     return bpos as uint;\n@@ -748,24 +749,24 @@ fn read_whole_file(file: ~str) -> result<~[u8], ~str> {\n \n mod fsync {\n \n-    enum level {\n+    enum Level {\n         // whatever fsync does on that platform\n-        fsync,\n+        FSync,\n \n         // fdatasync on linux, similiar or more on other platforms\n-        fdatasync,\n+        FDataSync,\n \n         // full fsync\n         //\n         // You must additionally sync the parent directory as well!\n-        fullfsync,\n+        FullFSync,\n     }\n \n \n     // Artifacts that need to fsync on destruction\n-    class res<t> {\n-        let arg: arg<t>;\n-        new(-arg: arg<t>) { self.arg <- arg; }\n+    class Res<t> {\n+        let arg: Arg<t>;\n+        new(-arg: Arg<t>) { self.arg <- arg; }\n         drop {\n           match self.arg.opt_level {\n             option::none => (),\n@@ -777,44 +778,47 @@ mod fsync {\n         }\n     }\n \n-    type arg<t> = {\n+    type Arg<t> = {\n         val: t,\n-        opt_level: option<level>,\n-        fsync_fn: fn@(t, level) -> int\n+        opt_level: option<Level>,\n+        fsync_fn: fn@(t, Level) -> int\n     };\n \n     // fsync file after executing blk\n     // FIXME (#2004) find better way to create resources within lifetime of\n     // outer res\n-    fn FILE_res_sync(&&file: FILE_res, opt_level: option<level>,\n-                  blk: fn(&&res<*libc::FILE>)) {\n-        blk(res({\n+    fn FILE_res_sync(&&file: FILERes, opt_level: option<Level>,\n+                  blk: fn(&&Res<*libc::FILE>)) {\n+        blk(Res({\n             val: file.f, opt_level: opt_level,\n-            fsync_fn: fn@(&&file: *libc::FILE, l: level) -> int {\n+            fsync_fn: fn@(&&file: *libc::FILE, l: Level) -> int {\n                 return os::fsync_fd(libc::fileno(file), l) as int;\n             }\n         }));\n     }\n \n     // fsync fd after executing blk\n-    fn fd_res_sync(&&fd: fd_res, opt_level: option<level>,\n-                   blk: fn(&&res<fd_t>)) {\n-        blk(res({\n+    fn fd_res_sync(&&fd: FdRes, opt_level: option<Level>,\n+                   blk: fn(&&Res<fd_t>)) {\n+        blk(Res({\n             val: fd.fd, opt_level: opt_level,\n-            fsync_fn: fn@(&&fd: fd_t, l: level) -> int {\n+            fsync_fn: fn@(&&fd: fd_t, l: Level) -> int {\n                 return os::fsync_fd(fd, l) as int;\n             }\n         }));\n     }\n \n     // Type of objects that may want to fsync\n-    trait t { fn fsync(l: level) -> int; }\n+    trait FSyncable { fn fsync(l: Level) -> int; }\n \n     // Call o.fsync after executing blk\n-    fn obj_sync(&&o: t, opt_level: option<level>, blk: fn(&&res<t>)) {\n-        blk(res({\n+    fn obj_sync(&&o: FSyncable, opt_level: option<Level>,\n+                blk: fn(&&Res<FSyncable>)) {\n+        blk(Res({\n             val: o, opt_level: opt_level,\n-            fsync_fn: fn@(&&o: t, l: level) -> int { return o.fsync(l); }\n+            fsync_fn: fn@(&&o: FSyncable, l: Level) -> int {\n+                return o.fsync(l);\n+            }\n         }));\n     }\n }\n@@ -830,20 +834,20 @@ mod tests {\n             ~\"A hoopy frood who really knows where his towel is.\";\n         log(debug, frood);\n         {\n-            let out: io::writer =\n+            let out: io::Writer =\n                 result::get(\n-                    io::file_writer(tmpfile, ~[io::create, io::truncate]));\n+                    io::file_writer(tmpfile, ~[io::Create, io::Truncate]));\n             out.write_str(frood);\n         }\n-        let inp: io::reader = result::get(io::file_reader(tmpfile));\n+        let inp: io::Reader = result::get(io::file_reader(tmpfile));\n         let frood2: ~str = inp.read_c_str();\n         log(debug, frood2);\n         assert frood == frood2;\n     }\n \n     #[test]\n     fn test_readchars_empty() {\n-        let inp : io::reader = io::str_reader(~\"\");\n+        let inp : io::Reader = io::str_reader(~\"\");\n         let res : ~[char] = inp.read_chars(128u);\n         assert(vec::len(res) == 0u);\n     }\n@@ -858,7 +862,7 @@ mod tests {\n             29983, 38152, 30340, 27748,\n             21273, 20999, 32905, 27748];\n         fn check_read_ln(len : uint, s: ~str, ivals: ~[int]) {\n-            let inp : io::reader = io::str_reader(s);\n+            let inp : io::Reader = io::str_reader(s);\n             let res : ~[char] = inp.read_chars(len);\n             if (len <= vec::len(ivals)) {\n                 assert(vec::len(res) == len);\n@@ -877,14 +881,14 @@ mod tests {\n \n     #[test]\n     fn test_readchar() {\n-        let inp : io::reader = io::str_reader(~\"\u751f\");\n+        let inp : io::Reader = io::str_reader(~\"\u751f\");\n         let res : char = inp.read_char();\n         assert(res as int == 29983);\n     }\n \n     #[test]\n     fn test_readchar_empty() {\n-        let inp : io::reader = io::str_reader(~\"\");\n+        let inp : io::Reader = io::str_reader(~\"\");\n         let res : char = inp.read_char();\n         assert(res as int == -1);\n     }\n@@ -924,12 +928,12 @@ mod tests {\n         let mbuf = mem_buffer();\n         mbuf.write(~[0u8, 1u8, 2u8, 3u8]);\n         assert mem_buffer_buf(mbuf) == ~[0u8, 1u8, 2u8, 3u8];\n-        mbuf.seek(-2, seek_cur);\n+        mbuf.seek(-2, SeekCur);\n         mbuf.write(~[4u8, 5u8, 6u8, 7u8]);\n         assert mem_buffer_buf(mbuf) == ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8];\n-        mbuf.seek(-2, seek_end);\n+        mbuf.seek(-2, SeekEnd);\n         mbuf.write(~[8u8]);\n-        mbuf.seek(1, seek_set);\n+        mbuf.seek(1, SeekSet);\n         mbuf.write(~[9u8]);\n         assert mem_buffer_buf(mbuf) == ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8];\n     }"}, {"sha": "09dd614525edfbf0ec04710db67afe422bf0ce4e", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,3 +1,6 @@\n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n /*!\n  * Bindings for libc.\n  *\n@@ -34,6 +37,8 @@\n  * dissolved.\n  */\n \n+#[allow(non_camel_case_types)];\n+\n // Initial glob-exports mean that all the contents of all the modules\n // wind up exported, if you're interested in writing platform-specific code.\n "}, {"sha": "2f86e1be49570c5b350efae1cefc33073139f449", "filename": "src/libcore/option.rs", "status": "modified", "additions": 51, "deletions": 3, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -46,7 +46,13 @@ pure fn map<T, U>(opt: option<T>, f: fn(T) -> U) -> option<U> {\n     match opt { some(x) => some(f(x)), none => none }\n }\n \n-pure fn map_consume<T, U>(-opt: option<T>, f: fn(-T) -> U) -> option<U> {\n+pure fn map_ref<T, U>(opt: &option<T>, f: fn(x: &T) -> U) -> option<U> {\n+    //! Maps a `some` value by reference from one type to another\n+\n+    match *opt { some(ref x) => some(f(x)), none => none }\n+}\n+\n+pure fn map_consume<T, U>(+opt: option<T>, f: fn(+T) -> U) -> option<U> {\n     /*!\n      * As `map`, but consumes the option and gives `f` ownership to avoid\n      * copying.\n@@ -63,6 +69,16 @@ pure fn chain<T, U>(opt: option<T>, f: fn(T) -> option<U>) -> option<U> {\n     match opt { some(x) => f(x), none => none }\n }\n \n+pure fn chain_ref<T, U>(opt: &option<T>,\n+                        f: fn(x: &T) -> option<U>) -> option<U> {\n+    /*!\n+     * Update an optional value by optionally running its content by reference\n+     * through a function that returns an option.\n+     */\n+\n+    match *opt { some(ref x) => f(x), none => none }\n+}\n+\n #[inline(always)]\n pure fn while_some<T>(+x: option<T>, blk: fn(+T) -> option<T>) {\n     //! Applies a function zero or more times until the result is none.\n@@ -97,14 +113,28 @@ pure fn map_default<T, U>(opt: option<T>, +def: U, f: fn(T) -> U) -> U {\n     match opt { none => def, some(t) => f(t) }\n }\n \n+// This should replace map_default.\n+pure fn map_default_ref<T, U>(opt: &option<T>, +def: U,\n+                              f: fn(x: &T) -> U) -> U {\n+    //! Applies a function to the contained value or returns a default\n+\n+    match *opt { none => def, some(ref t) => f(t) }\n+}\n+\n+// This should change to by-copy mode; use iter_ref below for by reference\n pure fn iter<T>(opt: option<T>, f: fn(T)) {\n     //! Performs an operation on the contained value or does nothing\n \n     match opt { none => (), some(t) => f(t) }\n }\n \n+pure fn iter_ref<T>(opt: &option<T>, f: fn(x: &T)) {\n+    //! Performs an operation on the contained value by reference\n+    match *opt { none => (), some(ref t) => f(t) }\n+}\n+\n #[inline(always)]\n-pure fn unwrap<T>(-opt: option<T>) -> T {\n+pure fn unwrap<T>(+opt: option<T>) -> T {\n     /*!\n      * Moves a value out of an option type and returns it.\n      *\n@@ -130,12 +160,13 @@ fn swap_unwrap<T>(opt: &mut option<T>) -> T {\n     unwrap(util::replace(opt, none))\n }\n \n-pure fn unwrap_expect<T>(-opt: option<T>, reason: &str) -> T {\n+pure fn unwrap_expect<T>(+opt: option<T>, reason: &str) -> T {\n     //! As unwrap, but with a specified failure message.\n     if opt.is_none() { fail reason.to_unique(); }\n     unwrap(opt)\n }\n \n+// Some of these should change to be &option<T>, some should not. See below.\n impl<T> option<T> {\n     /**\n      * Update an optional value by optionally running its content through a\n@@ -155,6 +186,23 @@ impl<T> option<T> {\n     pure fn map<U>(f: fn(T) -> U) -> option<U> { map(self, f) }\n }\n \n+impl<T> &option<T> {\n+    /**\n+     * Update an optional value by optionally running its content by reference\n+     * through a function that returns an option.\n+     */\n+    pure fn chain_ref<U>(f: fn(x: &T) -> option<U>) -> option<U> {\n+        chain_ref(self, f)\n+    }\n+    /// Applies a function to the contained value or returns a default\n+    pure fn map_default_ref<U>(+def: U, f: fn(x: &T) -> U) -> U\n+        { map_default_ref(self, def, f) }\n+    /// Performs an operation on the contained value by reference\n+    pure fn iter_ref(f: fn(x: &T)) { iter_ref(self, f) }\n+    /// Maps a `some` value from one type to another by reference\n+    pure fn map_ref<U>(f: fn(x: &T) -> U) -> option<U> { map_ref(self, f) }\n+}\n+\n impl<T: copy> option<T> {\n     /**\n      * Gets the value out of an option"}, {"sha": "ec4485bb1233409ee8c5316fa88605907295bb7a", "filename": "src/libcore/os.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -134,34 +134,34 @@ mod global_env {\n         fn rust_global_env_chan_ptr() -> *libc::uintptr_t;\n     }\n \n-    enum msg {\n-        msg_getenv(~str, comm::chan<option<~str>>),\n-        msg_setenv(~str, ~str, comm::chan<()>),\n-        msg_env(comm::chan<~[(~str,~str)]>)\n+    enum Msg {\n+        MsgGetEnv(~str, comm::chan<option<~str>>),\n+        MsgSetEnv(~str, ~str, comm::chan<()>),\n+        MsgEnv(comm::chan<~[(~str,~str)]>)\n     }\n \n     fn getenv(n: ~str) -> option<~str> {\n         let env_ch = get_global_env_chan();\n         let po = comm::port();\n-        comm::send(env_ch, msg_getenv(n, comm::chan(po)));\n+        comm::send(env_ch, MsgGetEnv(n, comm::chan(po)));\n         comm::recv(po)\n     }\n \n     fn setenv(n: ~str, v: ~str) {\n         let env_ch = get_global_env_chan();\n         let po = comm::port();\n-        comm::send(env_ch, msg_setenv(n, v, comm::chan(po)));\n+        comm::send(env_ch, MsgSetEnv(n, v, comm::chan(po)));\n         comm::recv(po)\n     }\n \n     fn env() -> ~[(~str,~str)] {\n         let env_ch = get_global_env_chan();\n         let po = comm::port();\n-        comm::send(env_ch, msg_env(comm::chan(po)));\n+        comm::send(env_ch, MsgEnv(comm::chan(po)));\n         comm::recv(po)\n     }\n \n-    fn get_global_env_chan() -> comm::chan<msg> {\n+    fn get_global_env_chan() -> comm::chan<Msg> {\n         let global_ptr = rustrt::rust_global_env_chan_ptr();\n         unsafe {\n             priv::chan_from_global_ptr(global_ptr, || {\n@@ -172,18 +172,18 @@ mod global_env {\n         }\n     }\n \n-    fn global_env_task(msg_po: comm::port<msg>) {\n+    fn global_env_task(msg_po: comm::port<Msg>) {\n         unsafe {\n             do priv::weaken_task |weak_po| {\n                 loop {\n                     match comm::select2(msg_po, weak_po) {\n-                      either::left(msg_getenv(n, resp_ch)) => {\n+                      either::left(MsgGetEnv(n, resp_ch)) => {\n                         comm::send(resp_ch, impl::getenv(n))\n                       }\n-                      either::left(msg_setenv(n, v, resp_ch)) => {\n+                      either::left(MsgSetEnv(n, v, resp_ch)) => {\n                         comm::send(resp_ch, impl::setenv(n, v))\n                       }\n-                      either::left(msg_env(resp_ch)) => {\n+                      either::left(MsgEnv(resp_ch)) => {\n                         comm::send(resp_ch, impl::env())\n                       }\n                       either::right(_) => break\n@@ -272,28 +272,28 @@ fn fdopen(fd: c_int) -> *FILE {\n // fsync related\n \n #[cfg(windows)]\n-fn fsync_fd(fd: c_int, _level: io::fsync::level) -> c_int {\n+fn fsync_fd(fd: c_int, _level: io::fsync::Level) -> c_int {\n     import libc::funcs::extra::msvcrt::*;\n     return commit(fd);\n }\n \n #[cfg(target_os = \"linux\")]\n-fn fsync_fd(fd: c_int, level: io::fsync::level) -> c_int {\n+fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n     import libc::funcs::posix01::unistd::*;\n     match level {\n-      io::fsync::fsync\n-      | io::fsync::fullfsync => return fsync(fd),\n-      io::fsync::fdatasync => return fdatasync(fd)\n+      io::fsync::FSync\n+      | io::fsync::FullFSync => return fsync(fd),\n+      io::fsync::FDataSync => return fdatasync(fd)\n     }\n }\n \n #[cfg(target_os = \"macos\")]\n-fn fsync_fd(fd: c_int, level: io::fsync::level) -> c_int {\n+fn fsync_fd(fd: c_int, level: io::fsync::Level) -> c_int {\n     import libc::consts::os::extra::*;\n     import libc::funcs::posix88::fcntl::*;\n     import libc::funcs::posix01::unistd::*;\n     match level {\n-      io::fsync::fsync => return fsync(fd),\n+      io::fsync::FSync => return fsync(fd),\n       _ => {\n         // According to man fnctl, the ok retval is only specified to be !=-1\n         if (fcntl(F_FULLFSYNC as c_int, fd) == -1 as c_int)\n@@ -305,7 +305,7 @@ fn fsync_fd(fd: c_int, level: io::fsync::level) -> c_int {\n }\n \n #[cfg(target_os = \"freebsd\")]\n-fn fsync_fd(fd: c_int, _l: io::fsync::level) -> c_int {\n+fn fsync_fd(fd: c_int, _l: io::fsync::Level) -> c_int {\n     import libc::funcs::posix01::unistd::*;\n     return fsync(fd);\n }\n@@ -369,10 +369,10 @@ fn dll_filename(base: ~str) -> ~str {\n }\n \n \n-fn self_exe_path() -> option<path> {\n+fn self_exe_path() -> option<Path> {\n \n     #[cfg(target_os = \"freebsd\")]\n-    fn load_self() -> option<path> {\n+    fn load_self() -> option<Path> {\n         unsafe {\n             import libc::funcs::bsd44::*;\n             import libc::consts::os::extra::*;\n@@ -388,7 +388,7 @@ fn self_exe_path() -> option<path> {\n     }\n \n     #[cfg(target_os = \"linux\")]\n-    fn load_self() -> option<path> {\n+    fn load_self() -> option<Path> {\n         import libc::funcs::posix01::unistd::readlink;\n         do fill_charp_buf() |buf, sz| {\n             do as_c_charp(~\"/proc/self/exe\") |proc_self_buf| {\n@@ -398,7 +398,7 @@ fn self_exe_path() -> option<path> {\n     }\n \n     #[cfg(target_os = \"macos\")]\n-    fn load_self() -> option<path> {\n+    fn load_self() -> option<Path> {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::funcs::extra::*;\n         do fill_charp_buf() |buf, sz| {\n@@ -408,7 +408,7 @@ fn self_exe_path() -> option<path> {\n     }\n \n     #[cfg(windows)]\n-    fn load_self() -> option<path> {\n+    fn load_self() -> option<Path> {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::types::os::arch::extra::*;\n         import libc::funcs::extra::kernel32::*;\n@@ -437,7 +437,7 @@ fn self_exe_path() -> option<path> {\n  *\n  * Otherwise, homedir returns option::none.\n  */\n-fn homedir() -> option<path> {\n+fn homedir() -> option<Path> {\n     return match getenv(~\"HOME\") {\n         some(p) => if !str::is_empty(p) {\n           some(p)\n@@ -448,12 +448,12 @@ fn homedir() -> option<path> {\n     };\n \n     #[cfg(unix)]\n-    fn secondary() -> option<path> {\n+    fn secondary() -> option<Path> {\n         none\n     }\n \n     #[cfg(windows)]\n-    fn secondary() -> option<path> {\n+    fn secondary() -> option<Path> {\n         do option::chain(getenv(~\"USERPROFILE\")) |p| {\n             if !str::is_empty(p) {\n                 some(p)\n@@ -465,11 +465,11 @@ fn homedir() -> option<path> {\n }\n \n /// Recursively walk a directory structure\n-fn walk_dir(p: path, f: fn(path) -> bool) {\n+fn walk_dir(p: Path, f: fn(Path) -> bool) {\n \n     walk_dir_(p, f);\n \n-    fn walk_dir_(p: path, f: fn(path) -> bool) -> bool {\n+    fn walk_dir_(p: Path, f: fn(Path) -> bool) -> bool {\n         let mut keepgoing = true;\n         do list_dir(p).each |q| {\n             let path = path::connect(p, q);\n@@ -494,14 +494,14 @@ fn walk_dir(p: path, f: fn(path) -> bool) {\n }\n \n /// Indicates whether a path represents a directory\n-fn path_is_dir(p: path) -> bool {\n+fn path_is_dir(p: Path) -> bool {\n     do str::as_c_str(p) |buf| {\n         rustrt::rust_path_is_dir(buf) != 0 as c_int\n     }\n }\n \n /// Indicates whether a path exists\n-fn path_exists(p: path) -> bool {\n+fn path_exists(p: Path) -> bool {\n     do str::as_c_str(p) |buf| {\n         rustrt::rust_path_exists(buf) != 0 as c_int\n     }\n@@ -519,7 +519,7 @@ fn path_exists(p: path) -> bool {\n // NB: this is here rather than in path because it is a form of environment\n // querying; what it does depends on the process working directory, not just\n // the input paths.\n-fn make_absolute(p: path) -> path {\n+fn make_absolute(p: Path) -> Path {\n     if path::path_is_absolute(p) {\n         p\n     } else {\n@@ -529,11 +529,11 @@ fn make_absolute(p: path) -> path {\n \n \n /// Creates a directory at the specified path\n-fn make_dir(p: path, mode: c_int) -> bool {\n+fn make_dir(p: Path, mode: c_int) -> bool {\n     return mkdir(p, mode);\n \n     #[cfg(windows)]\n-    fn mkdir(p: path, _mode: c_int) -> bool {\n+    fn mkdir(p: Path, _mode: c_int) -> bool {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::types::os::arch::extra::*;\n         import libc::funcs::extra::kernel32::*;\n@@ -546,15 +546,15 @@ fn make_dir(p: path, mode: c_int) -> bool {\n     }\n \n     #[cfg(unix)]\n-    fn mkdir(p: path, mode: c_int) -> bool {\n+    fn mkdir(p: Path, mode: c_int) -> bool {\n         do as_c_charp(p) |c| {\n             libc::mkdir(c, mode as mode_t) == (0 as c_int)\n         }\n     }\n }\n \n /// Lists the contents of a directory\n-fn list_dir(p: path) -> ~[~str] {\n+fn list_dir(p: Path) -> ~[~str] {\n \n     #[cfg(unix)]\n     fn star(p: ~str) -> ~str { p }\n@@ -580,7 +580,7 @@ fn list_dir(p: path) -> ~[~str] {\n  *\n  * This version prepends each entry with the directory.\n  */\n-fn list_dir_path(p: path) -> ~[~str] {\n+fn list_dir_path(p: Path) -> ~[~str] {\n     let mut p = p;\n     let pl = str::len(p);\n     if pl == 0u || (p[pl - 1u] as char != path::consts::path_sep\n@@ -591,11 +591,11 @@ fn list_dir_path(p: path) -> ~[~str] {\n }\n \n /// Removes a directory at the specified path\n-fn remove_dir(p: path) -> bool {\n+fn remove_dir(p: Path) -> bool {\n    return rmdir(p);\n \n     #[cfg(windows)]\n-    fn rmdir(p: path) -> bool {\n+    fn rmdir(p: Path) -> bool {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n@@ -606,18 +606,18 @@ fn remove_dir(p: path) -> bool {\n     }\n \n     #[cfg(unix)]\n-    fn rmdir(p: path) -> bool {\n+    fn rmdir(p: Path) -> bool {\n         return do as_c_charp(p) |buf| {\n             libc::rmdir(buf) == (0 as c_int)\n         };\n     }\n }\n \n-fn change_dir(p: path) -> bool {\n+fn change_dir(p: Path) -> bool {\n     return chdir(p);\n \n     #[cfg(windows)]\n-    fn chdir(p: path) -> bool {\n+    fn chdir(p: Path) -> bool {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n@@ -628,19 +628,19 @@ fn change_dir(p: path) -> bool {\n     }\n \n     #[cfg(unix)]\n-    fn chdir(p: path) -> bool {\n+    fn chdir(p: Path) -> bool {\n         return do as_c_charp(p) |buf| {\n             libc::chdir(buf) == (0 as c_int)\n         };\n     }\n }\n \n /// Copies a file from one location to another\n-fn copy_file(from: path, to: path) -> bool {\n+fn copy_file(from: Path, to: Path) -> bool {\n     return do_copy_file(from, to);\n \n     #[cfg(windows)]\n-    fn do_copy_file(from: path, to: path) -> bool {\n+    fn do_copy_file(from: Path, to: Path) -> bool {\n         // FIXME: remove imports when export globs work properly. #1238\n         import libc::funcs::extra::kernel32::*;\n         import libc::types::os::arch::extra::*;\n@@ -653,7 +653,7 @@ fn copy_file(from: path, to: path) -> bool {\n     }\n \n     #[cfg(unix)]\n-    fn do_copy_file(from: path, to: path) -> bool {\n+    fn do_copy_file(from: Path, to: Path) -> bool {\n         let istream = do as_c_charp(from) |fromp| {\n             do as_c_charp(~\"rb\") |modebuf| {\n                 libc::fopen(fromp, modebuf)\n@@ -699,11 +699,11 @@ fn copy_file(from: path, to: path) -> bool {\n }\n \n /// Deletes an existing file\n-fn remove_file(p: path) -> bool {\n+fn remove_file(p: Path) -> bool {\n     return unlink(p);\n \n     #[cfg(windows)]\n-    fn unlink(p: path) -> bool {\n+    fn unlink(p: Path) -> bool {\n         // FIXME (similar to Issue #2006): remove imports when export globs\n         // work properly.\n         import libc::funcs::extra::kernel32::*;\n@@ -715,7 +715,7 @@ fn remove_file(p: path) -> bool {\n     }\n \n     #[cfg(unix)]\n-    fn unlink(p: path) -> bool {\n+    fn unlink(p: Path) -> bool {\n         return do as_c_charp(p) |buf| {\n             libc::unlink(buf) == (0 as c_int)\n         };\n@@ -792,7 +792,7 @@ mod tests {\n \n     fn make_rand_name() -> ~str {\n         import rand;\n-        let rng: rand::rng = rand::rng();\n+        let rng: rand::Rng = rand::rng();\n         let n = ~\"TEST\" + rng.gen_str(10u);\n         assert option::is_none(getenv(n));\n         n"}, {"sha": "12c5dd90ead2e7149bfefadd1d0aec9463417212", "filename": "src/libcore/path.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,6 +1,6 @@\n //! Path data type and helper functions\n \n-export path;\n+export Path;\n export consts;\n export path_is_absolute;\n export path_sep;\n@@ -14,7 +14,7 @@ export normalize;\n \n // FIXME: This type should probably be constrained (#2624)\n /// A path or fragment of a filesystem path\n-type path = ~str;\n+type Path = ~str;\n \n #[cfg(unix)]\n mod consts {\n@@ -45,7 +45,7 @@ mod consts {\n  * on Windows, begins with a drive letter.\n  */\n #[cfg(unix)]\n-fn path_is_absolute(p: path) -> bool {\n+fn path_is_absolute(p: Path) -> bool {\n     str::char_at(p, 0u) == '/'\n }\n \n@@ -60,7 +60,7 @@ fn path_is_absolute(p: ~str) -> bool {\n /// Get the default path separator for the host platform\n fn path_sep() -> ~str { return str::from_char(consts::path_sep); }\n \n-fn split_dirname_basename (pp: path) -> {dirname: ~str, basename: ~str} {\n+fn split_dirname_basename (pp: Path) -> {dirname: ~str, basename: ~str} {\n     match str::rfind(pp, |ch|\n         ch == consts::path_sep || ch == consts::alt_path_sep\n     ) {\n@@ -81,7 +81,7 @@ fn split_dirname_basename (pp: path) -> {dirname: ~str, basename: ~str} {\n  *\n  * If the path is not prefixed with a directory, then \".\" is returned.\n  */\n-fn dirname(pp: path) -> path {\n+fn dirname(pp: Path) -> Path {\n     return split_dirname_basename(pp).dirname;\n }\n \n@@ -94,7 +94,7 @@ fn dirname(pp: path) -> path {\n  * the provided path. If an empty path is provided or the path ends\n  * with a path separator then an empty path is returned.\n  */\n-fn basename(pp: path) -> path {\n+fn basename(pp: Path) -> Path {\n     return split_dirname_basename(pp).basename;\n }\n \n@@ -105,7 +105,7 @@ fn basename(pp: path) -> path {\n  * and any leading path separator on `post`, and returns the concatenation of\n  * the two with a single path separator between them.\n  */\n-fn connect(pre: path, post: path) -> path {\n+fn connect(pre: Path, post: Path) -> Path {\n     let mut pre_ = pre;\n     let mut post_ = post;\n     let sep = consts::path_sep as u8;\n@@ -127,7 +127,7 @@ fn connect(pre: path, post: path) -> path {\n  *\n  * Inserts path separators as needed.\n  */\n-fn connect_many(paths: ~[path]) -> path {\n+fn connect_many(paths: ~[Path]) -> Path {\n     return if vec::len(paths) == 1u {\n         paths[0]\n     } else {\n@@ -144,7 +144,7 @@ fn connect_many(paths: ~[path]) -> path {\n  * the first element of the returned vector will be the drive letter\n  * followed by a colon.\n  */\n-fn split(p: path) -> ~[path] {\n+fn split(p: Path) -> ~[Path] {\n     str::split_nonempty(p, |c| {\n         c == consts::path_sep || c == consts::alt_path_sep\n     })\n@@ -159,7 +159,7 @@ fn split(p: path) -> ~[path] {\n  * ignored.  If the path includes directory components then they are included\n  * in the filename part of the result pair.\n  */\n-fn splitext(p: path) -> (~str, ~str) {\n+fn splitext(p: Path) -> (~str, ~str) {\n     if str::is_empty(p) { (~\"\", ~\"\") }\n     else {\n         let parts = str::split_char(p, '.');\n@@ -212,7 +212,7 @@ fn splitext(p: path) -> (~str, ~str) {\n  * * 'a/b/../../../' becomes '..'\n  * * '/a/b/c/../d/./../../e/' becomes '/a/e/'\n  */\n-fn normalize(p: path) -> path {\n+fn normalize(p: Path) -> Path {\n     let s = split(p);\n     let s = strip_dots(s);\n     let s = rollup_doubledots(s);\n@@ -233,7 +233,7 @@ fn normalize(p: path) -> path {\n \n     return s;\n \n-    fn strip_dots(s: ~[path]) -> ~[path] {\n+    fn strip_dots(s: ~[Path]) -> ~[Path] {\n         vec::filter_map(s, |elem|\n             if elem == ~\".\" {\n                 option::none\n@@ -242,7 +242,7 @@ fn normalize(p: path) -> path {\n             })\n     }\n \n-    fn rollup_doubledots(s: ~[path]) -> ~[path] {\n+    fn rollup_doubledots(s: ~[Path]) -> ~[Path] {\n         if vec::is_empty(s) {\n             return ~[];\n         }\n@@ -271,7 +271,7 @@ fn normalize(p: path) -> path {\n     }\n \n     #[cfg(unix)]\n-    fn reabsolute(orig: path, n: path) -> path {\n+    fn reabsolute(orig: Path, n: Path) -> Path {\n         if path_is_absolute(orig) {\n             path_sep() + n\n         } else {\n@@ -280,15 +280,15 @@ fn normalize(p: path) -> path {\n     }\n \n     #[cfg(windows)]\n-    fn reabsolute(orig: path, newp: path) -> path {\n+    fn reabsolute(orig: Path, newp: Path) -> Path {\n        if path_is_absolute(orig) && orig[0] == consts::path_sep as u8 {\n            str::from_char(consts::path_sep) + newp\n        } else {\n            newp\n        }\n     }\n \n-    fn reterminate(orig: path, newp: path) -> path {\n+    fn reterminate(orig: Path, newp: Path) -> Path {\n         let last = orig[str::len(orig) - 1u];\n         if last == consts::path_sep as u8\n             || last == consts::path_sep as u8 {"}, {"sha": "01a7936ca26a5bc0fc67d349cf89ae010e79662f", "filename": "src/libcore/priv.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fpriv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fpriv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpriv.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,3 +1,7 @@\n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n #[doc(hidden)];\n \n export chan_from_global_ptr, weaken_task;"}, {"sha": "b7b63af0afbb8d4dad8ec2d2e2a210d8c96e5370", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -152,7 +152,7 @@ fn to_uint<T>(thing: &T) -> uint unsafe {\n \n /// Determine if two borrowed pointers point to the same thing.\n #[inline(always)]\n-fn ref_eq<T>(thing: &T, other: &T) -> bool {\n+fn ref_eq<T>(thing: &a/T, other: &b/T) -> bool {\n     to_uint(thing) == to_uint(other)\n }\n "}, {"sha": "fa197a365c3bdf6ffaaf5e83fc9924970bde0f6f", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,8 +1,9 @@\n //! Random number generation\n \n-export rng, seed, seeded_rng, weighted, extensions;\n+export Rng, rng, seed, seeded_rng, Weighted, extensions;\n export xorshift, seeded_xorshift;\n \n+#[allow(non_camel_case_types)] // runtime type\n enum rctx {}\n \n #[abi = \"cdecl\"]\n@@ -15,16 +16,16 @@ extern mod rustrt {\n }\n \n /// A random number generator\n-trait rng {\n+trait Rng {\n     /// Return the next random integer\n     fn next() -> u32;\n }\n \n /// A value with a particular weight compared to other values\n-type weighted<T> = { weight: uint, item: T };\n+type Weighted<T> = { weight: uint, item: T };\n \n /// Extension methods for random number generators\n-impl rng {\n+impl Rng {\n \n     /// Return a random int\n     fn gen_int() -> int {\n@@ -181,15 +182,15 @@ impl rng {\n      * Choose an item respecting the relative weights, failing if the sum of\n      * the weights is 0\n      */\n-    fn choose_weighted<T: copy>(v : ~[weighted<T>]) -> T {\n+    fn choose_weighted<T: copy>(v : ~[Weighted<T>]) -> T {\n         self.choose_weighted_option(v).get()\n     }\n \n     /**\n      * Choose some(item) respecting the relative weights, returning none if\n      * the sum of the weights is 0\n      */\n-    fn choose_weighted_option<T:copy>(v: ~[weighted<T>]) -> option<T> {\n+    fn choose_weighted_option<T:copy>(v: ~[Weighted<T>]) -> option<T> {\n         let mut total = 0u;\n         for v.each |item| {\n             total += item.weight;\n@@ -212,7 +213,7 @@ impl rng {\n      * Return a vec containing copies of the items, in order, where\n      * the weight of the item determines how many copies there are\n      */\n-    fn weighted_vec<T:copy>(v: ~[weighted<T>]) -> ~[T] {\n+    fn weighted_vec<T:copy>(v: ~[Weighted<T>]) -> ~[T] {\n         let mut r = ~[];\n         for v.each |item| {\n             for uint::range(0u, item.weight) |_i| {\n@@ -242,13 +243,13 @@ impl rng {\n \n }\n \n-class rand_res {\n+class RandRes {\n     let c: *rctx;\n     new(c: *rctx) { self.c = c; }\n     drop { rustrt::rand_free(self.c); }\n }\n \n-impl @rand_res: rng {\n+impl @RandRes: Rng {\n     fn next() -> u32 { return rustrt::rand_next((*self).c); }\n }\n \n@@ -258,8 +259,8 @@ fn seed() -> ~[u8] {\n }\n \n /// Create a random number generator with a system specified seed\n-fn rng() -> rng {\n-    @rand_res(rustrt::rand_new()) as rng\n+fn rng() -> Rng {\n+    @RandRes(rustrt::rand_new()) as Rng\n }\n \n /**\n@@ -268,18 +269,18 @@ fn rng() -> rng {\n  * all other generators constructed with the same seed. The seed may be any\n  * length.\n  */\n-fn seeded_rng(seed: ~[u8]) -> rng {\n-    @rand_res(rustrt::rand_new_seeded(seed)) as rng\n+fn seeded_rng(seed: ~[u8]) -> Rng {\n+    @RandRes(rustrt::rand_new_seeded(seed)) as Rng\n }\n \n-type xorshift_state = {\n+type XorShiftState = {\n     mut x: u32,\n     mut y: u32,\n     mut z: u32,\n     mut w: u32\n };\n \n-impl xorshift_state: rng {\n+impl XorShiftState: Rng {\n     fn next() -> u32 {\n         let x = self.x;\n         let mut t = x ^ (x << 11);\n@@ -292,13 +293,13 @@ impl xorshift_state: rng {\n     }\n }\n \n-fn xorshift() -> rng {\n+fn xorshift() -> Rng {\n     // constants taken from http://en.wikipedia.org/wiki/Xorshift\n     seeded_xorshift(123456789u32, 362436069u32, 521288629u32, 88675123u32)\n }\n \n-fn seeded_xorshift(x: u32, y: u32, z: u32, w: u32) -> rng {\n-    {mut x: x, mut y: y, mut z: z, mut w: w} as rng\n+fn seeded_xorshift(x: u32, y: u32, z: u32, w: u32) -> Rng {\n+    {mut x: x, mut y: y, mut z: z, mut w: w} as Rng\n }\n \n #[cfg(test)]"}, {"sha": "7fd646d6bf85d1a2214d2522dbc2a85e3854c35f", "filename": "src/libcore/rt.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,3 +1,6 @@\n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n //! Runtime calls emitted by the compiler.\n \n import libc::c_char;"}, {"sha": "f754391a50d15204ad79d997d4299ed81c888b57", "filename": "src/libcore/run.rs", "status": "modified", "additions": 55, "deletions": 51, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,8 +1,12 @@\n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n //! Process spawning\n import option::{some, none};\n import libc::{pid_t, c_void, c_int};\n \n-export program;\n+export Program;\n export run_program;\n export start_program;\n export program_output;\n@@ -18,18 +22,18 @@ extern mod rustrt {\n }\n \n /// A value representing a child process\n-trait program {\n+trait Program {\n     /// Returns the process id of the program\n     fn get_id() -> pid_t;\n \n     /// Returns an io::writer that can be used to write to stdin\n-    fn input() -> io::writer;\n+    fn input() -> io::Writer;\n \n     /// Returns an io::reader that can be used to read from stdout\n-    fn output() -> io::reader;\n+    fn output() -> io::Reader;\n \n     /// Returns an io::reader that can be used to read from stderr\n-    fn err() -> io::reader;\n+    fn err() -> io::Reader;\n \n     /// Closes the handle to the child processes standard input\n     fn close_input();\n@@ -62,9 +66,9 @@ trait program {\n  *\n  * The process id of the spawned process\n  */\n-fn spawn_process(prog: ~str, args: ~[~str],\n-                 env: option<~[(~str,~str)]>,\n-                 dir: option<~str>,\n+fn spawn_process(prog: &str, args: &[~str],\n+                 env: &option<~[(~str,~str)]>,\n+                 dir: &option<~str>,\n                  in_fd: c_int, out_fd: c_int, err_fd: c_int)\n    -> pid_t {\n     do with_argv(prog, args) |argv| {\n@@ -77,7 +81,7 @@ fn spawn_process(prog: ~str, args: ~[~str],\n     }\n }\n \n-fn with_argv<T>(prog: ~str, args: ~[~str],\n+fn with_argv<T>(prog: &str, args: &[~str],\n                 cb: fn(**libc::c_char) -> T) -> T {\n     let mut argptrs = str::as_c_str(prog, |b| ~[b]);\n     let mut tmps = ~[];\n@@ -91,11 +95,11 @@ fn with_argv<T>(prog: ~str, args: ~[~str],\n }\n \n #[cfg(unix)]\n-fn with_envp<T>(env: option<~[(~str,~str)]>,\n+fn with_envp<T>(env: &option<~[(~str,~str)]>,\n                 cb: fn(*c_void) -> T) -> T {\n     // On posixy systems we can pass a char** for envp, which is\n     // a null-terminated array of \"k=v\\n\" strings.\n-    match env {\n+    match *env {\n       some(es) if !vec::is_empty(es) => {\n         let mut tmps = ~[];\n         let mut ptrs = ~[];\n@@ -116,13 +120,13 @@ fn with_envp<T>(env: option<~[(~str,~str)]>,\n }\n \n #[cfg(windows)]\n-fn with_envp<T>(env: option<~[(~str,~str)]>,\n+fn with_envp<T>(env: &option<~[(~str,~str)]>,\n                 cb: fn(*c_void) -> T) -> T {\n     // On win32 we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate.\n     unsafe {\n-        match env {\n+        match *env {\n           some(es) if !vec::is_empty(es) => {\n             let mut blk : ~[u8] = ~[];\n             for vec::each(es) |e| {\n@@ -140,9 +144,9 @@ fn with_envp<T>(env: option<~[(~str,~str)]>,\n     }\n }\n \n-fn with_dirp<T>(d: option<~str>,\n+fn with_dirp<T>(d: &option<~str>,\n                 cb: fn(*libc::c_char) -> T) -> T {\n-    match d {\n+    match *d {\n       some(dir) => str::as_c_str(dir, cb),\n       none => cb(ptr::null())\n     }\n@@ -160,8 +164,8 @@ fn with_dirp<T>(d: option<~str>,\n  *\n  * The process id\n  */\n-fn run_program(prog: ~str, args: ~[~str]) -> int {\n-    let pid = spawn_process(prog, args, none, none,\n+fn run_program(prog: &str, args: &[~str]) -> int {\n+    let pid = spawn_process(prog, args, &none, &none,\n                             0i32, 0i32, 0i32);\n     if pid == -1 as pid_t { fail; }\n     return waitpid(pid);\n@@ -183,12 +187,12 @@ fn run_program(prog: ~str, args: ~[~str]) -> int {\n  *\n  * A class with a <program> field\n  */\n-fn start_program(prog: ~str, args: ~[~str]) -> program {\n+fn start_program(prog: &str, args: &[~str]) -> Program {\n     let pipe_input = os::pipe();\n     let pipe_output = os::pipe();\n     let pipe_err = os::pipe();\n     let pid =\n-        spawn_process(prog, args, none, none,\n+        spawn_process(prog, args, &none, &none,\n                       pipe_input.in, pipe_output.out,\n                       pipe_err.out);\n \n@@ -197,54 +201,54 @@ fn start_program(prog: ~str, args: ~[~str]) -> program {\n     libc::close(pipe_output.out);\n     libc::close(pipe_err.out);\n \n-    type prog_repr = {pid: pid_t,\n-                      mut in_fd: c_int,\n-                      out_file: *libc::FILE,\n-                      err_file: *libc::FILE,\n-                      mut finished: bool};\n+    type ProgRepr = {pid: pid_t,\n+                     mut in_fd: c_int,\n+                     out_file: *libc::FILE,\n+                     err_file: *libc::FILE,\n+                     mut finished: bool};\n \n-    fn close_repr_input(r: prog_repr) {\n+    fn close_repr_input(r: &ProgRepr) {\n         let invalid_fd = -1i32;\n         if r.in_fd != invalid_fd {\n             libc::close(r.in_fd);\n             r.in_fd = invalid_fd;\n         }\n     }\n-    fn finish_repr(r: prog_repr) -> int {\n+    fn finish_repr(r: &ProgRepr) -> int {\n         if r.finished { return 0; }\n         r.finished = true;\n         close_repr_input(r);\n         return waitpid(r.pid);\n     }\n-    fn destroy_repr(r: prog_repr) {\n+    fn destroy_repr(r: &ProgRepr) {\n         finish_repr(r);\n        libc::fclose(r.out_file);\n        libc::fclose(r.err_file);\n     }\n-    class prog_res {\n-        let r: prog_repr;\n-        new(-r: prog_repr) { self.r = r; }\n-        drop { destroy_repr(self.r); }\n+    class ProgRes {\n+        let r: ProgRepr;\n+        new(+r: ProgRepr) { self.r = r; }\n+        drop { destroy_repr(&self.r); }\n     }\n \n-    impl prog_res: program {\n+    impl ProgRes: Program {\n         fn get_id() -> pid_t { return self.r.pid; }\n-        fn input() -> io::writer { io::fd_writer(self.r.in_fd, false) }\n-        fn output() -> io::reader { io::FILE_reader(self.r.out_file, false) }\n-        fn err() -> io::reader { io::FILE_reader(self.r.err_file, false) }\n-        fn close_input() { close_repr_input(self.r); }\n-        fn finish() -> int { finish_repr(self.r) }\n-        fn destroy() { destroy_repr(self.r); }\n+        fn input() -> io::Writer { io::fd_writer(self.r.in_fd, false) }\n+        fn output() -> io::Reader { io::FILE_reader(self.r.out_file, false) }\n+        fn err() -> io::Reader { io::FILE_reader(self.r.err_file, false) }\n+        fn close_input() { close_repr_input(&self.r); }\n+        fn finish() -> int { finish_repr(&self.r) }\n+        fn destroy() { destroy_repr(&self.r); }\n     }\n     let repr = {pid: pid,\n                 mut in_fd: pipe_input.out,\n                 out_file: os::fdopen(pipe_output.in),\n                 err_file: os::fdopen(pipe_err.in),\n                 mut finished: false};\n-    return prog_res(repr) as program;\n+    return ProgRes(move repr) as Program;\n }\n \n-fn read_all(rd: io::reader) -> ~str {\n+fn read_all(rd: io::Reader) -> ~str {\n     let mut buf = ~\"\";\n     while !rd.eof() {\n         let bytes = rd.read_bytes(4096u);\n@@ -267,13 +271,13 @@ fn read_all(rd: io::reader) -> ~str {\n  * A record, {status: int, out: str, err: str} containing the exit code,\n  * the contents of stdout and the contents of stderr.\n  */\n-fn program_output(prog: ~str, args: ~[~str]) ->\n+fn program_output(prog: &str, args: &[~str]) ->\n    {status: int, out: ~str, err: ~str} {\n \n     let pipe_in = os::pipe();\n     let pipe_out = os::pipe();\n     let pipe_err = os::pipe();\n-    let pid = spawn_process(prog, args, none, none,\n+    let pid = spawn_process(prog, args, &none, &none,\n                             pipe_in.in, pipe_out.out, pipe_err.out);\n \n     os::close(pipe_in.in);\n@@ -321,8 +325,8 @@ fn program_output(prog: ~str, args: ~[~str]) ->\n     return {status: status, out: outs, err: errs};\n }\n \n-fn writeclose(fd: c_int, s: ~str) {\n-    import io::writer_util;\n+fn writeclose(fd: c_int, s: &str) {\n+    import io::WriterUtil;\n \n     error!{\"writeclose %d, %s\", fd as int, s};\n     let writer = io::fd_writer(fd, false);\n@@ -388,14 +392,14 @@ fn waitpid(pid: pid_t) -> int {\n #[cfg(test)]\n mod tests {\n \n-    import io::writer_util;\n+    import io::WriterUtil;\n \n     // Regression test for memory leaks\n     #[ignore(cfg(windows))] // FIXME (#2626)\n     fn test_leaks() {\n-        run::run_program(~\"echo\", ~[]);\n-        run::start_program(~\"echo\", ~[]);\n-        run::program_output(~\"echo\", ~[]);\n+        run::run_program(\"echo\", []);\n+        run::start_program(\"echo\", []);\n+        run::program_output(\"echo\", []);\n     }\n \n     #[test]\n@@ -406,7 +410,7 @@ mod tests {\n \n         let pid =\n             run::spawn_process(\n-                ~\"cat\", ~[], none, none,\n+                \"cat\", [], &none, &none,\n                 pipe_in.in, pipe_out.out, pipe_err.out);\n         os::close(pipe_in.in);\n         os::close(pipe_out.out);\n@@ -426,8 +430,8 @@ mod tests {\n \n     #[test]\n     fn waitpid() {\n-        let pid = run::spawn_process(~\"false\", ~[],\n-                                     none, none,\n+        let pid = run::spawn_process(\"false\", [],\n+                                     &none, &none,\n                                      0i32, 0i32, 0i32);\n         let status = run::waitpid(pid);\n         assert status == 1;"}, {"sha": "1a130e0e273c4778a5d11f3dae6bbcdbe4d54d0c", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -237,11 +237,11 @@ mod linear {\n     }\n \n     impl<K,V> &const linear_map<K,V> {\n-        fn len() -> uint {\n+        pure fn len() -> uint {\n             self.size\n         }\n \n-        fn is_empty() -> bool {\n+        pure fn is_empty() -> bool {\n             self.len() == 0\n         }\n "}, {"sha": "181c36932d049b0e80c59253fcc12f7c2810f486", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -8,7 +8,7 @@\n  */\n \n import libc::size_t;\n-import io::writer_util;\n+import io::WriterUtil;\n \n export\n    // Creating a string\n@@ -54,6 +54,7 @@ export\n \n    // Comparing strings\n    eq,\n+   eq_slice,\n    le,\n    hash,\n "}, {"sha": "62398a6b8c9f26119c9148703cf206d3798dcea9", "filename": "src/libcore/task.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,3 +1,7 @@\n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n /*!\n  * Task management.\n  *\n@@ -730,8 +734,8 @@ type taskgroup_arc = unsafe::Exclusive<option<taskgroup_data>>;\n type taskgroup_inner = &mut option<taskgroup_data>;\n \n // A taskgroup is 'dead' when nothing can cause it to fail; only members can.\n-fn taskgroup_is_dead(tg: taskgroup_data) -> bool {\n-    (&mut tg.members).is_empty()\n+pure fn taskgroup_is_dead(tg: &taskgroup_data) -> bool {\n+    (&tg.members).is_empty()\n }\n \n // A list-like structure by which taskgroups keep track of all ancestor groups\n@@ -841,8 +845,11 @@ fn each_ancestor(list:        &mut ancestor_list,\n                     do with_parent_tg(&mut nobe.parent_group) |tg_opt| {\n                         // Decide whether this group is dead. Note that the\n                         // group being *dead* is disjoint from it *failing*.\n-                        do tg_opt.iter |tg| {\n-                            nobe_is_dead = taskgroup_is_dead(tg);\n+                        match *tg_opt {\n+                            some(ref tg) => {\n+                                nobe_is_dead = taskgroup_is_dead(tg);\n+                            },\n+                            none => { }\n                         }\n                         // Call iterator block. (If the group is dead, it's\n                         // safe to skip it. This will leave our *rust_task\n@@ -1100,7 +1107,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n     }\n }\n \n-fn spawn_raw(opts: task_opts, +f: fn~()) {\n+fn spawn_raw(+opts: task_opts, +f: fn~()) {\n     let (child_tg, ancestors, is_main) =\n         gen_child_taskgroup(opts.linked, opts.supervised);\n \n@@ -1138,10 +1145,10 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n     // (3a) If any of those fails, it leaves all groups, and does nothing.\n     // (3b) Otherwise it builds a task control structure and puts it in TLS,\n     // (4) ...and runs the provided body function.\n-    fn make_child_wrapper(child: *rust_task, -child_arc: taskgroup_arc,\n-                          -ancestors: ancestor_list, is_main: bool,\n+    fn make_child_wrapper(child: *rust_task, +child_arc: taskgroup_arc,\n+                          +ancestors: ancestor_list, is_main: bool,\n                           notify_chan: option<comm::chan<notification>>,\n-                          -f: fn~()) -> fn~() {\n+                          +f: fn~()) -> fn~() {\n         let child_data = ~mut some((child_arc, ancestors));\n         return fn~() {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)"}, {"sha": "11097b36d4de94fffdd52b8fa25b8ae1605b2cf7", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,3 +1,7 @@\n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n trait ToBytes {\n     fn to_bytes() -> ~[u8];\n }"}, {"sha": "78ea4a5263d7216e59b3463e6efca1527a5bedea", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,3 +1,7 @@\n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n trait ToStr { fn to_str() -> ~str; }\n \n impl int: ToStr {"}, {"sha": "5b5bb6660c3f3e23ce0d30b836b49a461971ab22", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,3 +1,7 @@\n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n //! Operations on tuples\n \n trait TupleOps<T,U> {"}, {"sha": "6f3419aadd416a97b44e56aede93824e0fc231e3", "filename": "src/libcore/unicode.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,3 +1,7 @@\n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n mod general_category {\n     pure fn Cc(c: char) -> bool {\n         return match c {"}, {"sha": "f945cb8ad1d8bfb60ea228d61f19c176cf056802", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,6 +1,7 @@\n //! Unsafe operations\n \n export reinterpret_cast, forget, bump_box_refcount, transmute;\n+export transmute_mut, transmute_immut, transmute_region, transmute_mut_region;\n \n export SharedMutableState, shared_mutable_state, clone_shared_mutable_state;\n export get_shared_mutable_state, get_shared_immutable_state;\n@@ -53,6 +54,17 @@ unsafe fn transmute<L, G>(-thing: L) -> G {\n     return newthing;\n }\n \n+/// Coerce an immutable reference to be mutable.\n+unsafe fn transmute_mut<T>(+ptr: &T) -> &mut T { transmute(ptr) }\n+/// Coerce a mutable reference to be immutable.\n+unsafe fn transmute_immut<T>(+ptr: &mut T) -> &T { transmute(ptr) }\n+/// Coerce a borrowed pointer to have an arbitrary associated region.\n+unsafe fn transmute_region<T>(+ptr: &a/T) -> &b/T { transmute(ptr) }\n+/// Coerce a borrowed mutable pointer to have an arbitrary associated region.\n+unsafe fn transmute_mut_region<T>(+ptr: &a/mut T) -> &b/mut T {\n+    transmute(ptr)\n+}\n+\n /****************************************************************************\n  * Shared state & exclusive ARC\n  ****************************************************************************/"}, {"sha": "3eb9474598cb9db96224ce293b5c91378394acbe", "filename": "src/libcore/util.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,3 +1,7 @@\n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n /**\n  * Miscellaneous helpers for common patterns.\n  */"}, {"sha": "8d6c7ce5d298ed17b207f493ec22ab22fa977e88", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 226, "deletions": 8, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,3 +1,6 @@\n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n /**\n  * Concurrency-enabled mechanisms for sharing mutable and/or immutable state\n  * between tasks.\n@@ -10,7 +13,7 @@ import sync;\n import sync::{mutex, rwlock};\n \n export arc, clone, get;\n-export condvar, mutex_arc, rw_arc;\n+export condvar, mutex_arc, rw_arc, rw_write_mode, rw_read_mode;\n \n /// As sync::condvar, a mechanism for unlock-and-descheduling and signalling.\n struct condvar { is_mutex: bool; failed: &mut bool; cond: &sync::condvar; }\n@@ -136,10 +139,11 @@ impl<T: send> &mutex_arc<T> {\n                 &condvar { is_mutex: true, failed: &mut state.failed,\n                            cond: cond })\n             */\n-            // XXX: Working around two seeming region bugs here\n-            let fref = unsafe { unsafe::reinterpret_cast(&mut state.failed) };\n+            // FIXME(#2282) region variance\n+            let fref =\n+                unsafe { unsafe::transmute_mut_region(&mut state.failed) };\n             let cvar = condvar { is_mutex: true, failed: fref, cond: cond };\n-            blk(&mut state.data, unsafe { unsafe::reinterpret_cast(&cvar) } )\n+            blk(&mut state.data, unsafe { unsafe::transmute_region(&cvar) } )\n         }\n     }\n }\n@@ -227,10 +231,12 @@ impl<T: const send> &rw_arc<T> {\n                 &condvar { is_mutex: false, failed: &mut state.failed,\n                            cond: cond })\n             */\n-            // XXX: Working around two seeming region bugs here\n-            let fref = unsafe { unsafe::reinterpret_cast(&mut state.failed) };\n+            // FIXME(#2282): Need region variance to use the commented-out\n+            // code above instead of this casting mess\n+            let fref =\n+                unsafe { unsafe::transmute_mut_region(&mut state.failed) };\n             let cvar = condvar { is_mutex: false, failed: fref, cond: cond };\n-            blk(&mut state.data, unsafe { unsafe::reinterpret_cast(&cvar) } )\n+            blk(&mut state.data, unsafe { unsafe::transmute_region(&cvar) } )\n         }\n     }\n     /**\n@@ -249,6 +255,52 @@ impl<T: const send> &rw_arc<T> {\n             blk(&state.data)\n         }\n     }\n+\n+    /**\n+     * As write(), but with the ability to atomically 'downgrade' the lock.\n+     * See sync::rwlock.write_downgrade(). The rw_write_mode token must be\n+     * used to obtain the &mut T, and can be transformed into a rw_read_mode\n+     * token by calling downgrade(), after which a &T can be obtained instead.\n+     * ~~~\n+     * do arc.write_downgrade |write_mode| {\n+     *     do (&write_mode).write_cond |state, condvar| {\n+     *         ... exclusive access with mutable state ...\n+     *     }\n+     *     let read_mode = arc.downgrade(write_mode);\n+     *     do (&read_mode).read |state| {\n+     *         ... shared access with immutable state ...\n+     *     }\n+     * }\n+     * ~~~\n+     */\n+    fn write_downgrade<U>(blk: fn(+rw_write_mode<T>) -> U) -> U {\n+        let state = unsafe { get_shared_mutable_state(&self.x) };\n+        do borrow_rwlock(state).write_downgrade |write_mode| {\n+            check_poison(false, state.failed);\n+            // FIXME(#2282) need region variance to avoid having to cast here\n+            let (data,failed) =\n+                unsafe { (unsafe::transmute_mut_region(&mut state.data),\n+                          unsafe::transmute_mut_region(&mut state.failed)) };\n+            blk(rw_write_mode((data, write_mode, poison_on_fail(failed))))\n+        }\n+    }\n+\n+    /// To be called inside of the write_downgrade block.\n+    fn downgrade(+token: rw_write_mode<T>) -> rw_read_mode<T> {\n+        // The rwlock should assert that the token belongs to us for us.\n+        let state = unsafe { get_shared_immutable_state(&self.x) };\n+        let rw_write_mode((data, t, _poison)) = token;\n+        // Let readers in\n+        let new_token = (&state.lock).downgrade(t);\n+        // Whatever region the input reference had, it will be safe to use\n+        // the same region for the output reference. (The only 'unsafe' part\n+        // of this cast is removing the mutability.)\n+        let new_data = unsafe { unsafe::transmute_immut(data) };\n+        // Downgrade ensured the token belonged to us. Just a sanity check.\n+        assert ptr::ref_eq(&state.data, new_data);\n+        // Produce new token\n+        rw_read_mode((new_data, new_token))\n+    }\n }\n \n // Borrowck rightly complains about immutably aliasing the rwlock in order to\n@@ -258,6 +310,58 @@ fn borrow_rwlock<T: const send>(state: &mut rw_arc_inner<T>) -> &rwlock {\n     unsafe { unsafe::reinterpret_cast(&state.lock) }\n }\n \n+// FIXME (#3154) ice with struct/&<T> prevents these from being structs.\n+\n+/// The \"write permission\" token used for rw_arc.write_downgrade().\n+enum rw_write_mode<T: const send> =\n+    (&mut T, sync::rwlock_write_mode, poison_on_fail);\n+/// The \"read permission\" token used for rw_arc.write_downgrade().\n+enum rw_read_mode<T:const send> = (&T, sync::rwlock_read_mode);\n+\n+impl<T: const send> &rw_write_mode<T> {\n+    /// Access the pre-downgrade rw_arc in write mode.\n+    fn write<U>(blk: fn(x: &mut T) -> U) -> U {\n+        match *self {\n+            rw_write_mode((data, ref token, _)) => {\n+                // FIXME(#2282) cast to avoid region invariance\n+                let mode = unsafe { unsafe::transmute_region(token) };\n+                do mode.write {\n+                    blk(data)\n+                }\n+            }\n+        }\n+    }\n+    /// Access the pre-downgrade rw_arc in write mode with a condvar.\n+    fn write_cond<U>(blk: fn(x: &x/mut T, c: &c/condvar) -> U) -> U {\n+        match *self {\n+            rw_write_mode((data, ref token, ref poison)) => {\n+                // FIXME(#2282) cast to avoid region invariance\n+                let mode = unsafe { unsafe::transmute_region(token) };\n+                do mode.write_cond |cond| {\n+                    let cvar = condvar {\n+                        is_mutex: false, failed: poison.failed,\n+                        cond: unsafe { unsafe::reinterpret_cast(cond) } };\n+                    // FIXME(#2282) region variance would avoid having to cast\n+                    blk(data, &cvar)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<T: const send> &rw_read_mode<T> {\n+    /// Access the post-downgrade rwlock in read mode.\n+    fn read<U>(blk: fn(x: &T) -> U) -> U {\n+        match *self {\n+            rw_read_mode((data, ref token)) => {\n+                // FIXME(#2282) cast to avoid region invariance\n+                let mode = unsafe { unsafe::transmute_region(token) };\n+                do mode.read { blk(data) }\n+            }\n+        }\n+    }\n+}\n+\n /****************************************************************************\n  * Tests\n  ****************************************************************************/\n@@ -374,6 +478,23 @@ mod tests {\n             assert *one == 1;\n         }\n     }\n+    #[test] #[should_fail] #[ignore(cfg(windows))]\n+    fn test_rw_arc_poison_dw() {\n+        let arc = ~rw_arc(1);\n+        let arc2 = ~arc.clone();\n+        do task::try {\n+            do arc2.write_downgrade |write_mode| {\n+                // FIXME(#2282)\n+                let mode = unsafe { unsafe::transmute_region(&write_mode) };\n+                do mode.write |one| {\n+                    assert *one == 2;\n+                }\n+            }\n+        };\n+        do arc.write |one| {\n+            assert *one == 1;\n+        }\n+    }\n     #[test] #[ignore(cfg(windows))]\n     fn test_rw_arc_no_poison_rr() {\n         let arc = ~rw_arc(1);\n@@ -400,7 +521,24 @@ mod tests {\n             assert *one == 1;\n         }\n     }\n-\n+    #[test] #[ignore(cfg(windows))]\n+    fn test_rw_arc_no_poison_dr() {\n+        let arc = ~rw_arc(1);\n+        let arc2 = ~arc.clone();\n+        do task::try {\n+            do arc2.write_downgrade |write_mode| {\n+                let read_mode = arc2.downgrade(write_mode);\n+                // FIXME(#2282)\n+                let mode = unsafe { unsafe::transmute_region(&read_mode) };\n+                do mode.read |one| {\n+                    assert *one == 2;\n+                }\n+            }\n+        };\n+        do arc.write |one| {\n+            assert *one == 1;\n+        }\n+    }\n     #[test]\n     fn test_rw_arc() {\n         let arc = ~rw_arc(0);\n@@ -434,4 +572,84 @@ mod tests {\n         p.recv();\n         do arc.read |num| { assert *num == 10; }\n     }\n+    #[test]\n+    fn test_rw_downgrade() {\n+        // (1) A downgrader gets in write mode and does cond.wait.\n+        // (2) A writer gets in write mode, sets state to 42, and does signal.\n+        // (3) Downgrader wakes, sets state to 31337.\n+        // (4) tells writer and all other readers to contend as it downgrades.\n+        // (5) Writer attempts to set state back to 42, while downgraded task\n+        //     and all reader tasks assert that it's 31337.\n+        let arc = ~rw_arc(0);\n+\n+        // Reader tasks\n+        let mut reader_convos = ~[];\n+        for 10.times {\n+            let ((rc1,rp1),(rc2,rp2)) = (pipes::stream(),pipes::stream());\n+            vec::push(reader_convos, (rc1,rp2));\n+            let arcn = ~arc.clone();\n+            do task::spawn {\n+                rp1.recv(); // wait for downgrader to give go-ahead\n+                do arcn.read |state| {\n+                    assert *state == 31337;\n+                    rc2.send(());\n+                }\n+            }\n+        }\n+\n+        // Writer task\n+        let arc2 = ~arc.clone();\n+        let ((wc1,wp1),(wc2,wp2)) = (pipes::stream(),pipes::stream());\n+        do task::spawn {\n+            wp1.recv();\n+            do arc2.write_cond |state, cond| {\n+                assert *state == 0;\n+                *state = 42;\n+                cond.signal();\n+            }\n+            wp1.recv();\n+            do arc2.write |state| {\n+                // This shouldn't happen until after the downgrade read\n+                // section, and all other readers, finish.\n+                assert *state == 31337;\n+                *state = 42;\n+            }\n+            wc2.send(());\n+        }\n+\n+        // Downgrader (us)\n+        do arc.write_downgrade |write_mode| {\n+            // FIXME(#2282)\n+            let mode = unsafe { unsafe::transmute_region(&write_mode) };\n+            do mode.write_cond |state, cond| {\n+                wc1.send(()); // send to another writer who will wake us up\n+                while *state == 0 {\n+                    cond.wait();\n+                }\n+                assert *state == 42;\n+                *state = 31337;\n+                // send to other readers\n+                for vec::each(reader_convos) |x| {\n+                    match x {\n+                        (rc, _) => rc.send(()),\n+                    }\n+                }\n+            }\n+            let read_mode = arc.downgrade(write_mode);\n+            // FIXME(#2282)\n+            let mode = unsafe { unsafe::transmute_region(&read_mode) };\n+            do mode.read |state| {\n+                // complete handshake with other readers\n+                for vec::each(reader_convos) |x| {\n+                    match x {\n+                        (_, rp) => rp.recv(),\n+                    }\n+                }\n+                wc1.send(()); // tell writer to try again\n+                assert *state == 31337;\n+            }\n+        }\n+\n+        wp2.recv(); // complete handshake with writer\n+    }\n }"}, {"sha": "b22fe2b95820b3e579a1bd1a60737e3337c85f41", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,4 +1,4 @@\n-import io::reader;\n+import io::Reader;\n \n trait to_base64 {\n     fn to_base64() -> ~str;"}, {"sha": "5a58775209354e2c94604eec48898aeaa8e7ca6c", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -172,13 +172,13 @@ fn doc_as_i32(d: doc) -> i32 { doc_as_u32(d) as i32 }\n fn doc_as_i64(d: doc) -> i64 { doc_as_u64(d) as i64 }\n \n // ebml writing\n-type writer_ = {writer: io::writer, mut size_positions: ~[uint]};\n+type writer_ = {writer: io::Writer, mut size_positions: ~[uint]};\n \n enum writer {\n     writer_(writer_)\n }\n \n-fn write_sized_vuint(w: io::writer, n: uint, size: uint) {\n+fn write_sized_vuint(w: io::Writer, n: uint, size: uint) {\n     match size {\n       1u => w.write(&[0x80u8 | (n as u8)]),\n       2u => w.write(&[0x40u8 | ((n >> 8_u) as u8), n as u8]),\n@@ -190,15 +190,15 @@ fn write_sized_vuint(w: io::writer, n: uint, size: uint) {\n     };\n }\n \n-fn write_vuint(w: io::writer, n: uint) {\n+fn write_vuint(w: io::Writer, n: uint) {\n     if n < 0x7f_u { write_sized_vuint(w, n, 1u); return; }\n     if n < 0x4000_u { write_sized_vuint(w, n, 2u); return; }\n     if n < 0x200000_u { write_sized_vuint(w, n, 3u); return; }\n     if n < 0x10000000_u { write_sized_vuint(w, n, 4u); return; }\n     fail fmt!{\"vint to write too big: %?\", n};\n }\n \n-fn writer(w: io::writer) -> writer {\n+fn writer(w: io::Writer) -> writer {\n     let size_positions: ~[uint] = ~[];\n     return writer_({writer: w, mut size_positions: size_positions});\n }\n@@ -220,10 +220,10 @@ impl writer {\n     fn end_tag() {\n         let last_size_pos = vec::pop::<uint>(self.size_positions);\n         let cur_pos = self.writer.tell();\n-        self.writer.seek(last_size_pos as int, io::seek_set);\n+        self.writer.seek(last_size_pos as int, io::SeekSet);\n         let size = (cur_pos - last_size_pos - 4u);\n         write_sized_vuint(self.writer, size, 4u);\n-        self.writer.seek(cur_pos as int, io::seek_set);\n+        self.writer.seek(cur_pos as int, io::SeekSet);\n \n         debug!{\"End tag (size = %u)\", size};\n     }"}, {"sha": "715062a06c9eb15f393c85e865d34569e168371f", "filename": "src/libstd/json.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -5,7 +5,7 @@\n \n import result::{result, ok, err};\n import io;\n-import io::writer_util;\n+import io::WriterUtil;\n import map;\n import map::hashmap;\n import map::map;\n@@ -43,7 +43,7 @@ type error = {\n };\n \n /// Serializes a json value into a io::writer\n-fn to_writer(wr: io::writer, j: json) {\n+fn to_writer(wr: io::Writer, j: json) {\n     match j {\n       num(n) => wr.write_str(float::to_str(n, 6u)),\n       string(s) => wr.write_str(escape_str(*s)),\n@@ -109,7 +109,7 @@ fn to_str(j: json) -> ~str {\n }\n \n type parser_ = {\n-    rdr: io::reader,\n+    rdr: io::Reader,\n     mut ch: char,\n     mut line: uint,\n     mut col: uint,\n@@ -458,7 +458,7 @@ impl parser {\n }\n \n /// Deserializes a json value from an io::reader\n-fn from_reader(rdr: io::reader) -> result<json, error> {\n+fn from_reader(rdr: io::Reader) -> result<json, error> {\n     let parser = parser_({\n         rdr: rdr,\n         mut ch: rdr.read_char(),"}, {"sha": "e6f44d76b4ce5da8d98743d218beff3ca308f94b", "filename": "src/libstd/map.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -2,7 +2,7 @@\n \n #[warn(deprecated_mode)];\n \n-import io::writer_util;\n+import io::WriterUtil;\n import to_str::ToStr;\n export hashmap, hashfn, eqfn, set, map, chained, hashmap, str_hash;\n export box_str_hash;\n@@ -328,7 +328,7 @@ mod chained {\n     }\n \n     impl<K: copy ToStr, V: ToStr copy> t<K, V>: ToStr {\n-        fn to_writer(wr: io::writer) {\n+        fn to_writer(wr: io::Writer) {\n             if self.count == 0u {\n                 wr.write_str(~\"{}\");\n                 return;\n@@ -389,6 +389,12 @@ fn hashmap<K: const, V: copy>(+hasher: hashfn<K>, +eqer: eqfn<K>)\n     chained::mk(hasher, eqer)\n }\n \n+/// Construct a hashmap for string-slice keys\n+fn str_slice_hash<V: copy>() -> hashmap<&str, V> {\n+    return hashmap(|s| hash::hash_str(*s) as uint,\n+                   |a,b| str::eq_slice(*a, *b));\n+}\n+\n /// Construct a hashmap for string keys\n fn str_hash<V: copy>() -> hashmap<~str, V> {\n     return hashmap(str::hash, str::eq);"}, {"sha": "b07c2fdfda72e5c9dd0f562fce0ab8b30cfdd5ea", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -8,7 +8,7 @@ import future_spawn = future::spawn;\n // should be able to, but can't atm, replace w/ result::{result, extensions};\n import result::*;\n import libc::size_t;\n-import io::{reader, writer};\n+import io::{Reader, Writer};\n \n // tcp interfaces\n export tcp_socket;\n@@ -752,7 +752,7 @@ impl tcp_socket {\n }\n \n /// Implementation of `io::reader` trait for a buffered `net::tcp::tcp_socket`\n-impl @tcp_socket_buf: io::reader {\n+impl @tcp_socket_buf: io::Reader {\n     fn read(buf: &[mut u8], len: uint) -> uint {\n         // Loop until our buffer has enough data in it for us to read from.\n         while self.data.buf.len() < len {\n@@ -795,7 +795,7 @@ impl @tcp_socket_buf: io::reader {\n     fn eof() -> bool {\n         false // noop\n     }\n-    fn seek(dist: int, seek: io::seek_style) {\n+    fn seek(dist: int, seek: io::SeekStyle) {\n         log(debug, fmt!{\"tcp_socket_buf seek stub %? %?\", dist, seek});\n         // noop\n     }\n@@ -805,7 +805,7 @@ impl @tcp_socket_buf: io::reader {\n }\n \n /// Implementation of `io::reader` trait for a buffered `net::tcp::tcp_socket`\n-impl @tcp_socket_buf: io::writer {\n+impl @tcp_socket_buf: io::Writer {\n     fn write(data: &[const u8]) unsafe {\n         let socket_data_ptr =\n             ptr::addr_of(*((*(self.data)).sock).socket_data);\n@@ -817,7 +817,7 @@ impl @tcp_socket_buf: io::writer {\n                              err_data.err_name, err_data.err_msg});\n         }\n     }\n-    fn seek(dist: int, seek: io::seek_style) {\n+    fn seek(dist: int, seek: io::SeekStyle) {\n       log(debug, fmt!{\"tcp_socket_buf seek stub %? %?\", dist, seek});\n         // noop\n     }\n@@ -827,8 +827,8 @@ impl @tcp_socket_buf: io::writer {\n     fn flush() -> int {\n         0\n     }\n-    fn get_type() -> io::writer_type {\n-        io::file\n+    fn get_type() -> io::WriterType {\n+        io::File\n     }\n }\n \n@@ -1441,11 +1441,11 @@ mod test {\n             assert false;\n         }\n         let sock_buf = @socket_buf(result::unwrap(conn_result));\n-        buf_write(sock_buf as io::writer, expected_req);\n+        buf_write(sock_buf as io::Writer, expected_req);\n \n         // so contrived!\n         let actual_resp = do str::as_bytes(expected_resp) |resp_buf| {\n-            buf_read(sock_buf as io::reader,\n+            buf_read(sock_buf as io::Reader,\n                      vec::len(resp_buf))\n         };\n \n@@ -1458,7 +1458,7 @@ mod test {\n         assert str::contains(actual_resp, expected_resp);\n     }\n \n-    fn buf_write(+w: io::writer, val: ~str) {\n+    fn buf_write(+w: io::Writer, val: ~str) {\n         log(debug, fmt!{\"BUF_WRITE: val len %?\", str::len(val)});\n         do str::byte_slice(val) |b_slice| {\n             log(debug, fmt!{\"BUF_WRITE: b_slice len %?\",\n@@ -1467,7 +1467,7 @@ mod test {\n         }\n     }\n \n-    fn buf_read(+r: io::reader, len: uint) -> ~str {\n+    fn buf_read(+r: io::Reader, len: uint) -> ~str {\n         let new_bytes = r.read_bytes(len);\n         log(debug, fmt!{\"in buf_read.. new_bytes len: %?\",\n                         vec::len(new_bytes)});"}, {"sha": "927fe75b1a93878a5961909a9ecd67e9f5569d50", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -2,7 +2,7 @@\n \n import map;\n import map::{hashmap, str_hash};\n-import io::reader;\n+import io::Reader;\n import dvec::dvec;\n \n export url, userinfo, query;"}, {"sha": "49fe0f4c0bf4bd0cd4cbf0032f9ed28ddcba472f", "filename": "src/libstd/prettyprint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Fprettyprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Fprettyprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,8 +1,8 @@\n-import io::writer;\n-import io::writer_util;\n+import io::Writer;\n+import io::WriterUtil;\n import serialization::serializer;\n \n-impl writer: serializer {\n+impl Writer: serializer {\n     fn emit_nil() {\n         self.write_str(~\"()\")\n     }"}, {"sha": "4233c351cf1ebd077f6fa08519f6e3c89ae74196", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 83, "deletions": 24, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,11 +1,14 @@\n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n /**\n  * The concurrency primitives you know and love.\n  *\n  * Maybe once we have a \"core exports x only to std\" mechanism, these can be\n  * in std.\n  */\n \n-export condvar, semaphore, mutex, rwlock;\n+export condvar, semaphore, mutex, rwlock, rwlock_write_mode, rwlock_read_mode;\n \n // FIXME (#3119) This shouldn't be a thing exported from core.\n import unsafe::{Exclusive, exclusive};\n@@ -387,16 +390,17 @@ impl &rwlock {\n      * the meantime (such as unlocking and then re-locking as a reader would\n      * do). The block takes a \"write mode token\" argument, which can be\n      * transformed into a \"read mode token\" by calling downgrade(). Example:\n-     *\n-     *     do lock.write_downgrade |write_mode| {\n-     *         do (&write_mode).write_cond |condvar| {\n-     *             ... exclusive access ...\n-     *         }\n-     *         let read_mode = lock.downgrade(write_mode);\n-     *         do (&read_mode).read {\n-     *             ... shared access ...\n-     *         }\n+     * ~~~\n+     * do lock.write_downgrade |write_mode| {\n+     *     do (&write_mode).write_cond |condvar| {\n+     *         ... exclusive access ...\n      *     }\n+     *     let read_mode = lock.downgrade(write_mode);\n+     *     do (&read_mode).read {\n+     *         ... shared access ...\n+     *     }\n+     * }\n+     * ~~~\n      */\n     fn write_downgrade<U>(blk: fn(+rwlock_write_mode) -> U) -> U {\n         // Implementation slightly different from the slicker 'write's above.\n@@ -413,6 +417,7 @@ impl &rwlock {\n         blk(rwlock_write_mode { lock: self })\n     }\n \n+    /// To be called inside of the write_downgrade block.\n     fn downgrade(+token: rwlock_write_mode) -> rwlock_read_mode {\n         if !ptr::ref_eq(self, token.lock) {\n             fail ~\"Can't downgrade() with a different rwlock's write_mode!\";\n@@ -498,16 +503,15 @@ struct rwlock_write_mode { lock: &rwlock; drop { } }\n /// The \"read permission\" token used for rwlock.write_downgrade().\n struct rwlock_read_mode  { priv lock: &rwlock; drop { } }\n \n-// FIXME(#3145) XXX Region invariance forbids \"mode.write(blk)\"\n-impl rwlock_write_mode {\n+impl &rwlock_write_mode {\n     /// Access the pre-downgrade rwlock in write mode.\n     fn write<U>(blk: fn() -> U) -> U { blk() }\n     /// Access the pre-downgrade rwlock in write mode with a condvar.\n     fn write_cond<U>(blk: fn(c: &condvar) -> U) -> U {\n         blk(&condvar { sem: &self.lock.access_lock })\n     }\n }\n-impl rwlock_read_mode {\n+impl &rwlock_read_mode {\n     /// Access the post-downgrade rwlock in read mode.\n     fn read<U>(blk: fn() -> U) -> U { blk() }\n }\n@@ -762,9 +766,51 @@ mod tests {\n         assert result.is_err();\n         // child task must have finished by the time try returns\n         do m.lock_cond |cond| {\n-            let _woken = cond.signal();\n-            // FIXME(#3145) this doesn't work\n-            //assert !woken;\n+            let woken = cond.signal();\n+            assert !woken;\n+        }\n+    }\n+    #[test] #[ignore(cfg(windows))]\n+    fn test_mutex_killed_broadcast() {\n+        let m = ~mutex();\n+        let m2 = ~m.clone();\n+        let (c,p) = pipes::stream();\n+\n+        let result: result::result<(),()> = do task::try {\n+            let mut sibling_convos = ~[];\n+            for 2.times {\n+                let (c,p) = pipes::stream();\n+                let c = ~mut some(c);\n+                vec::push(sibling_convos, p);\n+                let mi = ~m2.clone();\n+                // spawn sibling task\n+                do task::spawn { // linked\n+                    do mi.lock_cond |cond| {\n+                        let c = option::swap_unwrap(c);\n+                        c.send(()); // tell sibling to go ahead\n+                        let _z = send_on_failure(c);\n+                        cond.wait(); // block forever\n+                    }\n+                }\n+            }\n+            for vec::each(sibling_convos) |p| {\n+                let _ = p.recv(); // wait for sibling to get in the mutex\n+            }\n+            do m2.lock { }\n+            c.send(sibling_convos); // let parent wait on all children\n+            fail;\n+        };\n+        assert result.is_err();\n+        // child task must have finished by the time try returns\n+        for vec::each(p.recv()) |p| { p.recv(); } // wait on all its siblings\n+        do m.lock_cond |cond| {\n+            let woken = cond.broadcast();\n+            assert woken == 0;\n+        }\n+        struct send_on_failure {\n+            c: pipes::chan<()>;\n+            new(+c: pipes::chan<()>) { self.c = c; }\n+            drop { self.c.send(()); }\n         }\n     }\n     /************************************************************************\n@@ -777,13 +823,23 @@ mod tests {\n         match mode {\n             read => x.read(blk),\n             write => x.write(blk),\n-            downgrade => do x.write_downgrade |mode| { mode.write(blk); },\n+            downgrade =>\n+                do x.write_downgrade |mode| {\n+                    // FIXME(#2282)\n+                    let mode = unsafe { unsafe::transmute_region(&mode) };\n+                    mode.write(blk);\n+                },\n             downgrade_read =>\n-                do x.write_downgrade |mode| { x.downgrade(mode).read(blk); },\n+                do x.write_downgrade |mode| {\n+                    let mode = x.downgrade(mode);\n+                    // FIXME(#2282)\n+                    let mode = unsafe { unsafe::transmute_region(&mode) };\n+                    mode.read(blk);\n+                },\n         }\n     }\n     #[cfg(test)]\n-    fn test_rwlock_exclusion(x: ~rwlock, mode1: rwlock_mode,\n+    fn test_rwlock_exclusion(+x: ~rwlock, mode1: rwlock_mode,\n                              mode2: rwlock_mode) {\n         // Test mutual exclusion between readers and writers. Just like the\n         // mutex mutual exclusion test, a ways above.\n@@ -828,7 +884,7 @@ mod tests {\n         test_rwlock_exclusion(~rwlock(), downgrade, downgrade);\n     }\n     #[cfg(test)]\n-    fn test_rwlock_handshake(x: ~rwlock, mode1: rwlock_mode,\n+    fn test_rwlock_handshake(+x: ~rwlock, mode1: rwlock_mode,\n                              mode2: rwlock_mode, make_mode2_go_first: bool) {\n         // Much like sem_multi_resource.\n         let x2 = ~x.clone();\n@@ -922,7 +978,11 @@ mod tests {\n         // Much like the mutex broadcast test. Downgrade-enabled.\n         fn lock_cond(x: &rwlock, downgrade: bool, blk: fn(c: &condvar)) {\n             if downgrade {\n-                do x.write_downgrade |mode| { mode.write_cond(blk) }\n+                do x.write_downgrade |mode| {\n+                    // FIXME(#2282)\n+                    let mode = unsafe { unsafe::transmute_region(&mode) };\n+                    mode.write_cond(blk)\n+                }\n             } else {\n                 x.write_cond(blk)\n             }\n@@ -1009,9 +1069,8 @@ mod tests {\n         do x.write_downgrade |xwrite| {\n             let mut xopt = some(xwrite);\n             do y.write_downgrade |_ywrite| {\n-                do y.downgrade(option::swap_unwrap(&mut xopt)).read {\n-                    error!(\"oops, y.downgrade(x) should have failed!\");\n-                }\n+                y.downgrade(option::swap_unwrap(&mut xopt));\n+                error!(\"oops, y.downgrade(x) should have failed!\");\n             }\n         }\n     }"}, {"sha": "be18915128787b54947e776fd958ad57aa11b9d6", "filename": "src/libstd/term.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -23,10 +23,10 @@ const color_bright_magenta: u8 = 13u8;\n const color_bright_cyan: u8 = 14u8;\n const color_bright_white: u8 = 15u8;\n \n-fn esc(writer: io::writer) { writer.write(~[0x1bu8, '[' as u8]); }\n+fn esc(writer: io::Writer) { writer.write(~[0x1bu8, '[' as u8]); }\n \n /// Reset the foreground and background colors to default\n-fn reset(writer: io::writer) {\n+fn reset(writer: io::Writer) {\n     esc(writer);\n     writer.write(~['0' as u8, 'm' as u8]);\n }\n@@ -46,7 +46,7 @@ fn color_supported() -> bool {\n         };\n }\n \n-fn set_color(writer: io::writer, first_char: u8, color: u8) {\n+fn set_color(writer: io::Writer, first_char: u8, color: u8) {\n     assert (color < 16u8);\n     esc(writer);\n     let mut color = color;\n@@ -55,12 +55,12 @@ fn set_color(writer: io::writer, first_char: u8, color: u8) {\n }\n \n /// Set the foreground color\n-fn fg(writer: io::writer, color: u8) {\n+fn fg(writer: io::Writer, color: u8) {\n     return set_color(writer, '3' as u8, color);\n }\n \n /// Set the background color\n-fn bg(writer: io::writer, color: u8) {\n+fn bg(writer: io::Writer, color: u8) {\n     return set_color(writer, '4' as u8, color);\n }\n "}, {"sha": "9d33431f0003fbbe85277e2eedbc855aad116b2d", "filename": "src/libstd/test.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -7,7 +7,7 @@\n \n import either::either;\n import result::{ok, err};\n-import io::writer_util;\n+import io::WriterUtil;\n import libc::size_t;\n import task::task_builder;\n \n@@ -91,8 +91,8 @@ fn parse_opts(args: ~[~str]) -> opt_res {\n enum test_result { tr_ok, tr_failed, tr_ignored, }\n \n type console_test_state =\n-    @{out: io::writer,\n-      log_out: option<io::writer>,\n+    @{out: io::Writer,\n+      log_out: option<io::Writer>,\n       use_color: bool,\n       mut total: uint,\n       mut passed: uint,\n@@ -141,7 +141,7 @@ fn run_tests_console(opts: test_opts,\n \n     let log_out = match opts.logfile {\n         some(path) => match io::file_writer(path,\n-                                            ~[io::create, io::truncate]) {\n+                                            ~[io::Create, io::Truncate]) {\n           result::ok(w) => some(w),\n           result::err(s) => {\n               fail(fmt!{\"can't open output file: %s\", s})\n@@ -179,7 +179,7 @@ fn run_tests_console(opts: test_opts,\n \n     return success;\n \n-    fn write_log(out: io::writer, result: test_result, test: test_desc) {\n+    fn write_log(out: io::Writer, result: test_result, test: test_desc) {\n         out.write_line(fmt!{\"%s %s\",\n                     match result {\n                         tr_ok => ~\"ok\",\n@@ -188,19 +188,19 @@ fn run_tests_console(opts: test_opts,\n                     }, test.name});\n     }\n \n-    fn write_ok(out: io::writer, use_color: bool) {\n+    fn write_ok(out: io::Writer, use_color: bool) {\n         write_pretty(out, ~\"ok\", term::color_green, use_color);\n     }\n \n-    fn write_failed(out: io::writer, use_color: bool) {\n+    fn write_failed(out: io::Writer, use_color: bool) {\n         write_pretty(out, ~\"FAILED\", term::color_red, use_color);\n     }\n \n-    fn write_ignored(out: io::writer, use_color: bool) {\n+    fn write_ignored(out: io::Writer, use_color: bool) {\n         write_pretty(out, ~\"ignored\", term::color_yellow, use_color);\n     }\n \n-    fn write_pretty(out: io::writer, word: ~str, color: u8, use_color: bool) {\n+    fn write_pretty(out: io::Writer, word: ~str, color: u8, use_color: bool) {\n         if use_color && term::color_supported() {\n             term::fg(out, color);\n         }"}, {"sha": "47dbff2ccb154031053158353e070ca1b6c4edda", "filename": "src/libstd/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,5 +1,5 @@\n import libc::{c_char, c_int, c_long, size_t, time_t};\n-import io::reader;\n+import io::Reader;\n import result::{result, ok, err};\n \n export"}, {"sha": "39e116990dd238a8c7c233ae03be8325c976a568", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -600,7 +600,7 @@ enum self_ty_ {\n     sty_static,                         // no self: static method\n     sty_by_ref,                         // old by-reference self: ``\n     sty_value,                          // by-value self: `self`\n-    sty_region(@region, mutability),    // by-region self: `&self`\n+    sty_region(mutability),             // by-region self: `&self`\n     sty_box(mutability),                // by-managed-pointer self: `@self`\n     sty_uniq(mutability)                // by-unique-pointer self: `~self`\n }"}, {"sha": "38c8131147cdc86d046ddc64e7ea5234deb9afe9", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,5 +1,5 @@\n import std::term;\n-import io::writer_util;\n+import io::WriterUtil;\n import codemap::span;\n \n export emitter, emit;\n@@ -166,7 +166,7 @@ fn diagnosticcolor(lvl: level) -> u8 {\n \n fn print_diagnostic(topic: ~str, lvl: level, msg: ~str) {\n     let use_color = term::color_supported() &&\n-        io::stderr().get_type() == io::screen;\n+        io::stderr().get_type() == io::Screen;\n     if str::is_not_empty(topic) {\n         io::stderr().write_str(fmt!{\"%s \", topic});\n     }"}, {"sha": "4ab3bb29045d71362f24cd1adb71b9c8bda35318", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,5 +1,5 @@\n import base::*;\n-import io::writer_util;\n+import io::WriterUtil;\n \n fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, tt: ~[ast::token_tree])\n     -> base::mac_result {"}, {"sha": "8664277bcdcba859e3c7371e2f3b0072295cc22d", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -99,7 +99,7 @@ fn expand_include_bin(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n     }\n }\n \n-fn res_rel_file(cx: ext_ctxt, sp: codemap::span, +arg: path) -> path {\n+fn res_rel_file(cx: ext_ctxt, sp: codemap::span, +arg: Path) -> Path {\n     // NB: relative paths are resolved relative to the compilation unit\n     if !path::path_is_absolute(arg) {\n         let cu = codemap::span_to_filename(sp, cx.codemap());"}, {"sha": "381910650749e7d766dd5efb8956c761cf73f768", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -47,7 +47,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n     };\n \n     // Given `lhses` and `rhses`, this is the new macro we create\n-    fn generic_extension(cx: ext_ctxt, sp: span, name: ident,\n+    fn generic_extension(cx: ext_ctxt, sp: span, _name: ident,\n                          arg: ~[ast::token_tree],\n                          lhses: ~[@named_match], rhses: ~[@named_match])\n     -> mac_result {"}, {"sha": "2da34539321ec5125ecc672269bedea6aefd8a8a", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -273,7 +273,7 @@ type lit = {lit: ~str, pos: uint};\n \n fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n                                 path: ~str,\n-                                srdr: io::reader) ->\n+                                srdr: io::Reader) ->\n    {cmnts: ~[cmnt], lits: ~[lit]} {\n     let src = @str::from_bytes(srdr.read_whole_stream());\n     let itr = @interner::mk::<@~str>("}, {"sha": "feb19d6780c3560d43959f01b8ec09bc0ef2c020", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 101, "deletions": 60, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -111,6 +111,12 @@ enum item_or_view_item {\n     iovi_view_item(@view_item)\n }\n \n+enum view_item_parse_mode {\n+    VIEW_ITEMS_AND_ITEMS_ALLOWED,\n+    VIEW_ITEMS_ALLOWED,\n+    IMPORTS_AND_ITEMS_ALLOWED\n+}\n+\n /* The expr situation is not as complex as I thought it would be.\n The important thing is to make sure that lookahead doesn't balk\n at INTERPOLATED tokens */\n@@ -2054,7 +2060,7 @@ class parser {\n \n             let item_attrs = vec::append(first_item_attrs, item_attrs);\n \n-            match self.parse_item_or_view_item(item_attrs) {\n+            match self.parse_item_or_view_item(item_attrs, true) {\n               iovi_item(i) => {\n                 let mut hi = i.span.hi;\n                 let decl = @spanned(lo, hi, decl_item(i));\n@@ -2141,8 +2147,17 @@ class parser {\n                          +first_item_attrs: ~[attribute]) -> blk {\n         let mut stmts = ~[];\n         let mut expr = none;\n-        let {attrs_remaining, view_items} =\n-            self.parse_view(first_item_attrs, true);\n+\n+        let {attrs_remaining, view_items, items: items} =\n+            self.parse_items_and_view_items(first_item_attrs,\n+                                            IMPORTS_AND_ITEMS_ALLOWED);\n+\n+        for items.each |item| {\n+            let decl = @spanned(item.span.lo, item.span.hi, decl_item(item));\n+            push(stmts, @spanned(item.span.lo, item.span.hi,\n+                                 stmt_decl(decl, self.get_id())));\n+        }\n+\n         let mut initial_attrs = attrs_remaining;\n \n         if self.token == token::RBRACE && !vec::is_empty(initial_attrs) {\n@@ -2285,29 +2300,7 @@ class parser {\n                     self.bump();\n                     let mutability = self.parse_mutability();\n                     self.expect_self_ident();\n-\n-                    // Parse an explicit region, if possible.\n-                    let region_name;\n-                    match copy self.token {\n-                        token::BINOP(token::SLASH) => {\n-                            self.bump();\n-                            match copy self.token {\n-                                token::IDENT(sid, false) => {\n-                                    self.bump();\n-                                    region_name = some(self.get_str(sid));\n-                                }\n-                                _ => {\n-                                    region_name = none;\n-                                }\n-                            }\n-                        }\n-                        _ => {\n-                            region_name = none;\n-                        }\n-                    }\n-\n-                    let region = self.region_from_name(region_name);\n-                    self_ty = sty_region(region, mutability);\n+                    self_ty = sty_region(mutability);\n                 } else {\n                     self_ty = sty_by_ref;\n                 }\n@@ -2709,9 +2702,11 @@ class parser {\n     fn parse_mod_items(term: token::token,\n                        +first_item_attrs: ~[attribute]) -> _mod {\n         // Shouldn't be any view items since we've already parsed an item attr\n-        let {attrs_remaining, view_items} =\n-            self.parse_view(first_item_attrs, false);\n-        let mut items: ~[@item] = ~[];\n+        let {attrs_remaining, view_items, items: starting_items} =\n+            self.parse_items_and_view_items(first_item_attrs,\n+                                            VIEW_ITEMS_AND_ITEMS_ALLOWED);\n+        let mut items: ~[@item] = move starting_items;\n+\n         let mut first = true;\n         while self.token != term {\n             let mut attrs = self.parse_outer_attributes();\n@@ -2721,7 +2716,7 @@ class parser {\n             }\n             debug!(\"parse_mod_items: parse_item_or_view_item(attrs=%?)\",\n                    attrs);\n-            match self.parse_item_or_view_item(attrs) {\n+            match self.parse_item_or_view_item(attrs, true) {\n               iovi_item(item) => vec::push(items, item),\n               iovi_view_item(view_item) => {\n                 self.span_fatal(view_item.span, ~\"view items must be \\\n@@ -2797,8 +2792,10 @@ class parser {\n     fn parse_foreign_mod_items(+first_item_attrs: ~[attribute]) ->\n         foreign_mod {\n         // Shouldn't be any view items since we've already parsed an item attr\n-        let {attrs_remaining, view_items} =\n-            self.parse_view(first_item_attrs, false);\n+        let {attrs_remaining, view_items, items: _} =\n+            self.parse_items_and_view_items(first_item_attrs,\n+                                            VIEW_ITEMS_ALLOWED);\n+\n         let mut items: ~[@foreign_item] = ~[];\n         let mut initial_attrs = attrs_remaining;\n         while self.token != token::RBRACE {\n@@ -2813,7 +2810,8 @@ class parser {\n \n     fn parse_item_foreign_mod(lo: uint,\n                               visibility: visibility,\n-                              attrs: ~[attribute])\n+                              attrs: ~[attribute],\n+                              items_allowed: bool)\n                            -> item_or_view_item {\n         if self.is_keyword(~\"mod\") {\n             self.expect_keyword(~\"mod\");\n@@ -2823,7 +2821,7 @@ class parser {\n         let ident = self.parse_ident();\n \n         // extern mod { ... }\n-        if self.eat(token::LBRACE) {\n+        if items_allowed && self.eat(token::LBRACE) {\n             let extra_attrs = self.parse_inner_attrs_and_next();\n             let m = self.parse_foreign_mod_items(extra_attrs.next);\n             self.expect(token::RBRACE);\n@@ -2836,6 +2834,7 @@ class parser {\n \n         // extern mod foo;\n         let metadata = self.parse_optional_meta();\n+        self.expect(token::SEMI);\n         return iovi_view_item(@{\n             node: view_item_use(ident, metadata, self.get_id()),\n             attrs: attrs,\n@@ -3033,7 +3032,8 @@ class parser {\n         }\n     }\n \n-    fn parse_item_or_view_item(+attrs: ~[attribute]) -> item_or_view_item {\n+    fn parse_item_or_view_item(+attrs: ~[attribute], items_allowed: bool)\n+                            -> item_or_view_item {\n         maybe_whole!{iovi self,nt_item};\n         let lo = self.span.lo;\n \n@@ -3046,25 +3046,26 @@ class parser {\n             visibility = inherited;\n         }\n \n-        if self.eat_keyword(~\"const\") {\n+        if items_allowed && self.eat_keyword(~\"const\") {\n             let (ident, item_, extra_attrs) = self.parse_item_const();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.is_keyword(~\"fn\") &&\n+        } else if items_allowed &&\n+            self.is_keyword(~\"fn\") &&\n             !self.fn_expr_lookahead(self.look_ahead(1u)) {\n             self.bump();\n             let (ident, item_, extra_attrs) = self.parse_item_fn(impure_fn);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.eat_keyword(~\"pure\") {\n+        } else if items_allowed && self.eat_keyword(~\"pure\") {\n             self.expect_keyword(~\"fn\");\n             let (ident, item_, extra_attrs) = self.parse_item_fn(pure_fn);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.is_keyword(~\"unsafe\")\n+        } else if items_allowed && self.is_keyword(~\"unsafe\")\n             && self.look_ahead(1u) != token::LBRACE {\n             self.bump();\n             self.expect_keyword(~\"fn\");\n@@ -3073,54 +3074,57 @@ class parser {\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if self.eat_keyword(~\"extern\") {\n-            // XXX: \"extern mod foo;\" syntax as a \"use\" replacement.\n-            if self.eat_keyword(~\"fn\") {\n+            if items_allowed && self.eat_keyword(~\"fn\") {\n                 let (ident, item_, extra_attrs) =\n                     self.parse_item_fn(extern_fn);\n                 return iovi_item(self.mk_item(lo, self.last_span.hi, ident,\n                                               item_, visibility,\n                                               maybe_append(attrs,\n                                                            extra_attrs)));\n             }\n-            return self.parse_item_foreign_mod(lo, visibility, attrs);\n-        } else if self.eat_keyword(~\"mod\") || self.eat_keyword(~\"module\") {\n+            return self.parse_item_foreign_mod(lo, visibility, attrs,\n+                                               items_allowed);\n+        } else if items_allowed && (self.eat_keyword(~\"mod\") ||\n+                                    self.eat_keyword(~\"module\")) {\n             let (ident, item_, extra_attrs) = self.parse_item_mod();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.eat_keyword(~\"type\") {\n+        } else if items_allowed && self.eat_keyword(~\"type\") {\n             let (ident, item_, extra_attrs) = self.parse_item_type();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.eat_keyword(~\"enum\") {\n+        } else if items_allowed && self.eat_keyword(~\"enum\") {\n             let (ident, item_, extra_attrs) = self.parse_item_enum();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.eat_keyword(~\"iface\") {\n+        } else if items_allowed && self.eat_keyword(~\"iface\") {\n             self.warn(~\"`iface` is deprecated; use `trait`\");\n             let (ident, item_, extra_attrs) = self.parse_item_trait();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.eat_keyword(~\"trait\") {\n+        } else if items_allowed && self.eat_keyword(~\"trait\") {\n             let (ident, item_, extra_attrs) = self.parse_item_trait();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.eat_keyword(~\"impl\") {\n+        } else if items_allowed && self.eat_keyword(~\"impl\") {\n             let (ident, item_, extra_attrs) = self.parse_item_impl();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.eat_keyword(~\"class\") || self.eat_keyword(~\"struct\") {\n+        } else if items_allowed &&\n+                (self.eat_keyword(~\"class\") || self.eat_keyword(~\"struct\")) {\n             let (ident, item_, extra_attrs) = self.parse_item_class();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if self.eat_keyword(~\"use\") {\n             let view_item = self.parse_use();\n+            self.expect(token::SEMI);\n             return iovi_view_item(@{\n                 node: view_item,\n                 attrs: attrs,\n@@ -3129,6 +3133,7 @@ class parser {\n             });\n         } else if self.eat_keyword(~\"import\") {\n             let view_paths = self.parse_view_paths();\n+            self.expect(token::SEMI);\n             return iovi_view_item(@{\n                 node: view_item_import(view_paths),\n                 attrs: attrs,\n@@ -3137,15 +3142,16 @@ class parser {\n             });\n         } else if self.eat_keyword(~\"export\") {\n             let view_paths = self.parse_view_paths();\n+            self.expect(token::SEMI);\n             return iovi_view_item(@{\n                 node: view_item_export(view_paths),\n                 attrs: attrs,\n                 vis: visibility,\n                 span: mk_sp(lo, self.last_span.hi)\n             });\n-        } else if !self.is_any_keyword(copy self.token)\n+        } else if items_allowed && (!self.is_any_keyword(copy self.token)\n                 && self.look_ahead(1) == token::NOT\n-                && is_plain_ident(self.look_ahead(2)) {\n+                && is_plain_ident(self.look_ahead(2))) {\n             // item macro.\n             let pth = self.parse_path_without_tps();\n             self.expect(token::NOT);\n@@ -3173,7 +3179,7 @@ class parser {\n     }\n \n     fn parse_item(+attrs: ~[attribute]) -> option<@ast::item> {\n-        match self.parse_item_or_view_item(attrs) {\n+        match self.parse_item_or_view_item(attrs, true) {\n             iovi_none =>\n                 none,\n             iovi_view_item(_) =>\n@@ -3296,18 +3302,53 @@ class parser {\n           vis: vis, span: mk_sp(lo, self.last_span.hi)}\n     }\n \n-    fn parse_view(+first_item_attrs: ~[attribute],\n-                  only_imports: bool) -> {attrs_remaining: ~[attribute],\n-                                          view_items: ~[@view_item]} {\n+    fn parse_items_and_view_items(+first_item_attrs: ~[attribute],\n+                                  mode: view_item_parse_mode)\n+                               -> {attrs_remaining: ~[attribute],\n+                                   view_items: ~[@view_item],\n+                                   items: ~[@item]} {\n         let mut attrs = vec::append(first_item_attrs,\n                                     self.parse_outer_attributes());\n-        let mut items = ~[];\n-        while if only_imports { self.is_keyword(~\"import\") }\n-        else { self.is_view_item() } {\n-            vec::push(items, self.parse_view_item(attrs));\n+\n+        let items_allowed;\n+        match mode {\n+            VIEW_ITEMS_AND_ITEMS_ALLOWED | IMPORTS_AND_ITEMS_ALLOWED =>\n+                items_allowed = true,\n+            VIEW_ITEMS_ALLOWED =>\n+                items_allowed = false\n+        }\n+\n+        let (view_items, items) = (dvec(), dvec());\n+        loop {\n+            match self.parse_item_or_view_item(attrs, items_allowed) {\n+                iovi_none =>\n+                    break,\n+                iovi_view_item(view_item) => {\n+                    match mode {\n+                        VIEW_ITEMS_AND_ITEMS_ALLOWED |\n+                        VIEW_ITEMS_ALLOWED => {}\n+                        IMPORTS_AND_ITEMS_ALLOWED =>\n+                            match view_item.node {\n+                                view_item_import(_) => {}\n+                                view_item_export(_) | view_item_use(*) =>\n+                                    self.fatal(~\"exports and \\\"extern mod\\\" \\\n+                                                 declarations are not \\\n+                                                 allowed here\")\n+                            }\n+                    }\n+                    view_items.push(view_item);\n+                }\n+                iovi_item(item) => {\n+                    assert items_allowed;\n+                    items.push(item)\n+                }\n+            }\n             attrs = self.parse_outer_attributes();\n         }\n-        {attrs_remaining: attrs, view_items: items}\n+\n+        {attrs_remaining: attrs,\n+         view_items: vec::from_mut(dvec::unwrap(view_items)),\n+         items: vec::from_mut(dvec::unwrap(items))}\n     }\n \n     // Parses a source module as a crate"}, {"sha": "0d81d40ca8c6dbb65c2aba02c9dc7f89a785347b", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,4 +1,4 @@\n-import io::writer_util;\n+import io::WriterUtil;\n import dvec::dvec;\n \n /*\n@@ -95,7 +95,7 @@ type print_stack_elt = {offset: int, pbreak: print_stack_break};\n \n const size_infinity: int = 0xffff;\n \n-fn mk_printer(out: io::writer, linewidth: uint) -> printer {\n+fn mk_printer(out: io::Writer, linewidth: uint) -> printer {\n     // Yes 3, it makes the ring buffers big enough to never\n     // fall behind.\n     let n: uint = 3u * linewidth;\n@@ -201,7 +201,7 @@ fn mk_printer(out: io::writer, linewidth: uint) -> printer {\n  * called 'print'.\n  */\n type printer_ = {\n-    out: io::writer,\n+    out: io::Writer,\n     buf_len: uint,\n     mut margin: int, // width of lines we're constrained to\n     mut space: int, // number of spaces left on line"}, {"sha": "05b6ca8c5049f2a60a1d143ee0b746804d509561", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -48,7 +48,7 @@ fn end(s: ps) {\n     pp::end(s.s);\n }\n \n-fn rust_printer(writer: io::writer) -> ps {\n+fn rust_printer(writer: io::Writer) -> ps {\n     return @{s: pp::mk_printer(writer, default_columns),\n              cm: none::<codemap>,\n              intr: @interner::mk::<@~str>(|x| str::hash(*x),\n@@ -61,7 +61,7 @@ fn rust_printer(writer: io::writer) -> ps {\n              ann: no_ann()};\n }\n \n-fn unexpanded_rust_printer(writer: io::writer, intr: ident_interner) -> ps {\n+fn unexpanded_rust_printer(writer: io::Writer, intr: ident_interner) -> ps {\n     return @{s: pp::mk_printer(writer, default_columns),\n              cm: none::<codemap>,\n              intr: intr,\n@@ -83,8 +83,8 @@ const default_columns: uint = 78u;\n // copy forward.\n fn print_crate(cm: codemap, intr: @interner::interner<@~str>,\n                span_diagnostic: diagnostic::span_handler,\n-               crate: @ast::crate, filename: ~str, in: io::reader,\n-               out: io::writer, ann: pp_ann, is_expanded: bool) {\n+               crate: @ast::crate, filename: ~str, in: io::Reader,\n+               out: io::Writer, ann: pp_ann, is_expanded: bool) {\n     let r = comments::gather_comments_and_literals(span_diagnostic,\n                                                    filename, in);\n     let s =\n@@ -838,6 +838,11 @@ fn print_block_unclosed(s: ps, blk: ast::blk) {\n                                  false);\n }\n \n+fn print_block_unclosed_indent(s: ps, blk: ast::blk, indented: uint) {\n+    print_possibly_embedded_block_(s, blk, block_normal, indented, ~[],\n+                                   false);\n+}\n+\n fn print_block_with_attrs(s: ps, blk: ast::blk, attrs: ~[ast::attribute]) {\n     print_possibly_embedded_block_(s, blk, block_normal, indent_unit, attrs,\n                                   true);\n@@ -1178,8 +1183,16 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n             assert arm.body.node.rules == ast::default_blk;\n             match arm.body.node.expr {\n               some(expr) => {\n-                end(s); // close the ibox for the pattern\n-                print_expr(s, expr);\n+                match expr.node {\n+                  ast::expr_block(blk) => {\n+                    // the block will close the pattern's ibox\n+                    print_block_unclosed_indent(s, blk, alt_indent_unit);\n+                  }\n+                  _ => {\n+                    end(s); // close the ibox for the pattern\n+                    print_expr(s, expr);\n+                  }\n+                }\n                 if !expr_is_simple_block(expr)\n                     && i < len - 1 {\n                     word(s.s, ~\",\");"}, {"sha": "8ac75916da0e651a8e63d22c4f9fbf436493196e", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -15,7 +15,7 @@ import lib::llvm::{ModuleRef, mk_pass_manager, mk_target_data, True, False,\n         FileType};\n import metadata::filesearch;\n import syntax::ast_map::{path, path_mod, path_name};\n-import io::{writer, writer_util};\n+import io::{Writer, WriterUtil};\n \n enum output_type {\n     output_type_none,"}, {"sha": "85975897facaf92ca2fa2d91f34444ddfa5a4006", "filename": "src/rustc/back/rpath.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Frpath.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -36,7 +36,7 @@ fn get_rpath_flags(sess: session::session, out_filename: ~str) -> ~[~str] {\n     rpaths_to_flags(rpaths)\n }\n \n-fn get_sysroot_absolute_rt_lib(sess: session::session) -> path::path {\n+fn get_sysroot_absolute_rt_lib(sess: session::session) -> path::Path {\n     let mut path = vec::append(~[sess.filesearch.sysroot()],\n                            filesearch::relative_target_lib_path(\n                                sess.opts.target_triple));\n@@ -48,8 +48,8 @@ fn rpaths_to_flags(rpaths: ~[~str]) -> ~[~str] {\n     vec::map(rpaths, |rpath| fmt!{\"-Wl,-rpath,%s\",rpath} )\n }\n \n-fn get_rpaths(os: session::os, cwd: path::path, sysroot: path::path,\n-              output: path::path, libs: ~[path::path],\n+fn get_rpaths(os: session::os, cwd: path::Path, sysroot: path::Path,\n+              output: path::Path, libs: ~[path::Path],\n               target_triple: ~str) -> ~[~str] {\n     debug!{\"cwd: %s\", cwd};\n     debug!{\"sysroot: %s\", sysroot};\n@@ -93,18 +93,18 @@ fn get_rpaths(os: session::os, cwd: path::path, sysroot: path::path,\n }\n \n fn get_rpaths_relative_to_output(os: session::os,\n-                                 cwd: path::path,\n-                                 output: path::path,\n-                                 libs: ~[path::path]) -> ~[~str] {\n+                                 cwd: path::Path,\n+                                 output: path::Path,\n+                                 libs: ~[path::Path]) -> ~[~str] {\n     vec::map(libs, |a| {\n         get_rpath_relative_to_output(os, cwd, output, a)\n     })\n }\n \n fn get_rpath_relative_to_output(os: session::os,\n-                                cwd: path::path,\n-                                output: path::path,\n-                                &&lib: path::path) -> ~str {\n+                                cwd: path::Path,\n+                                output: path::Path,\n+                                &&lib: path::Path) -> ~str {\n     assert not_win32(os);\n \n     // Mac doesn't appear to support $ORIGIN\n@@ -121,7 +121,7 @@ fn get_rpath_relative_to_output(os: session::os,\n }\n \n // Find the relative path from one file to another\n-fn get_relative_to(abs1: path::path, abs2: path::path) -> path::path {\n+fn get_relative_to(abs1: path::Path, abs2: path::Path) -> path::Path {\n     assert path::path_is_absolute(abs1);\n     assert path::path_is_absolute(abs2);\n     debug!{\"finding relative path from %s to %s\",\n@@ -154,23 +154,23 @@ fn get_relative_to(abs1: path::path, abs2: path::path) -> path::path {\n     }\n }\n \n-fn get_absolute_rpaths(cwd: path::path, libs: ~[path::path]) -> ~[~str] {\n+fn get_absolute_rpaths(cwd: path::Path, libs: ~[path::Path]) -> ~[~str] {\n     vec::map(libs, |a| get_absolute_rpath(cwd, a) )\n }\n \n-fn get_absolute_rpath(cwd: path::path, &&lib: path::path) -> ~str {\n+fn get_absolute_rpath(cwd: path::Path, &&lib: path::Path) -> ~str {\n     path::dirname(get_absolute(cwd, lib))\n }\n \n-fn get_absolute(cwd: path::path, lib: path::path) -> path::path {\n+fn get_absolute(cwd: path::Path, lib: path::Path) -> path::Path {\n     if path::path_is_absolute(lib) {\n         lib\n     } else {\n         path::connect(cwd, lib)\n     }\n }\n \n-fn get_install_prefix_rpath(cwd: path::path, target_triple: ~str) -> ~str {\n+fn get_install_prefix_rpath(cwd: path::Path, target_triple: ~str) -> ~str {\n     let install_prefix = env!{\"CFG_PREFIX\"};\n \n     if install_prefix == ~\"\" {"}, {"sha": "5f21d46adc965a485cf5059c00f90a89ff342849", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -10,7 +10,7 @@ import util::ppaux;\n import back::link;\n import result::{ok, err};\n import std::getopts;\n-import io::writer_util;\n+import io::WriterUtil;\n import getopts::{optopt, optmulti, optflag, optflagopt, opt_present};\n import back::{x86, x86_64};\n import std::map::hashmap;\n@@ -701,7 +701,7 @@ fn early_error(emitter: diagnostic::emitter, msg: ~str) -> ! {\n     fail;\n }\n \n-fn list_metadata(sess: session, path: ~str, out: io::writer) {\n+fn list_metadata(sess: session, path: ~str, out: io::Writer) {\n     metadata::loader::list_file_metadata(\n         session::sess_os_to_meta_os(sess.targ_cfg.os), path, out);\n }"}, {"sha": "d6d9b2701e4c93c8bf7292a8091ad03b32555640", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -3,7 +3,7 @@\n import std::{ebml, map};\n import std::map::{hashmap, str_hash};\n import dvec::dvec;\n-import io::writer_util;\n+import io::WriterUtil;\n import syntax::{ast, ast_util};\n import syntax::attr;\n import middle::ty;\n@@ -598,22 +598,7 @@ fn get_self_ty(item: ebml::doc) -> ast::self_ty_ {\n         'v' => { return ast::sty_value; }\n         '@' => { return ast::sty_box(get_mutability(string[1])); }\n         '~' => { return ast::sty_uniq(get_mutability(string[1])); }\n-        '&' => {\n-            let mutability = get_mutability(string[1]);\n-\n-            let region;\n-            let region_doc =\n-                ebml::get_doc(self_type_doc,\n-                              tag_item_trait_method_self_ty_region);\n-            let region_string = str::from_bytes(ebml::doc_data(region_doc));\n-            if region_string == ~\"\" {\n-                region = ast::re_anon;\n-            } else {\n-                region = ast::re_named(@region_string);\n-            }\n-\n-            return ast::sty_region(@{ id: 0, node: region }, mutability);\n-        }\n+        '&' => { return ast::sty_region(get_mutability(string[1])); }\n         _ => {\n             fail fmt!{\"unknown self type code: `%c`\", self_ty_kind as char};\n         }\n@@ -861,13 +846,13 @@ fn get_attributes(md: ebml::doc) -> ~[ast::attribute] {\n     return attrs;\n }\n \n-fn list_meta_items(meta_items: ebml::doc, out: io::writer) {\n+fn list_meta_items(meta_items: ebml::doc, out: io::Writer) {\n     for get_meta_items(meta_items).each |mi| {\n         out.write_str(fmt!{\"%s\\n\", pprust::meta_item_to_str(*mi)});\n     }\n }\n \n-fn list_crate_attributes(md: ebml::doc, hash: @~str, out: io::writer) {\n+fn list_crate_attributes(md: ebml::doc, hash: @~str, out: io::Writer) {\n     out.write_str(fmt!{\"=Crate Attributes (%s)=\\n\", *hash});\n \n     for get_attributes(md).each |attr| {\n@@ -902,7 +887,7 @@ fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n     return deps;\n }\n \n-fn list_crate_deps(data: @~[u8], out: io::writer) {\n+fn list_crate_deps(data: @~[u8], out: io::Writer) {\n     out.write_str(~\"=External Dependencies=\\n\");\n \n     for get_crate_deps(data).each |dep| {\n@@ -928,7 +913,7 @@ fn get_crate_vers(data: @~[u8]) -> @~str {\n     };\n }\n \n-fn list_crate_items(bytes: @~[u8], md: ebml::doc, out: io::writer) {\n+fn list_crate_items(bytes: @~[u8], md: ebml::doc, out: io::Writer) {\n     out.write_str(~\"=Items=\\n\");\n     let items = ebml::get_doc(md, tag_items);\n     do iter_crate_items(bytes) |tag, path, did| {\n@@ -984,7 +969,7 @@ fn get_crate_module_paths(bytes: @~[u8]) -> ~[(ast::def_id, ~str)] {\n     }\n }\n \n-fn list_crate_metadata(bytes: @~[u8], out: io::writer) {\n+fn list_crate_metadata(bytes: @~[u8], out: io::Writer) {\n     let hash = get_crate_hash(bytes);\n     let md = ebml::doc(bytes);\n     list_crate_attributes(md, hash, out);"}, {"sha": "7d006369359d0d2cd6703450ddb2dc89b80d495a", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -4,7 +4,7 @@ import util::ppaux::ty_to_str;\n \n import std::{ebml, map};\n import std::map::hashmap;\n-import io::writer_util;\n+import io::WriterUtil;\n import ebml::writer;\n import syntax::ast::*;\n import syntax::print::pprust;\n@@ -500,7 +500,7 @@ fn encode_self_type(ebml_w: ebml::writer, self_type: ast::self_ty_) {\n         sty_static =>       { ch = 's' as u8; }\n         sty_by_ref =>       { ch = 'r' as u8; }\n         sty_value =>        { ch = 'v' as u8; }\n-        sty_region(_, _) => { ch = '&' as u8; }\n+        sty_region(_) =>    { ch = '&' as u8; }\n         sty_box(_) =>       { ch = '@' as u8; }\n         sty_uniq(_) =>      { ch = '~' as u8; }\n     }\n@@ -509,27 +509,17 @@ fn encode_self_type(ebml_w: ebml::writer, self_type: ast::self_ty_) {\n     // Encode mutability.\n     match self_type {\n         sty_static | sty_by_ref | sty_value => { /* No-op. */ }\n-        sty_region(_, m_imm) | sty_box(m_imm) | sty_uniq(m_imm) => {\n+        sty_region(m_imm) | sty_box(m_imm) | sty_uniq(m_imm) => {\n             ebml_w.writer.write(&[ 'i' as u8 ]);\n         }\n-        sty_region(_, m_mutbl) | sty_box(m_mutbl) | sty_uniq(m_mutbl) => {\n+        sty_region(m_mutbl) | sty_box(m_mutbl) | sty_uniq(m_mutbl) => {\n             ebml_w.writer.write(&[ 'm' as u8 ]);\n         }\n-        sty_region(_, m_const) | sty_box(m_const) | sty_uniq(m_const) => {\n+        sty_region(m_const) | sty_box(m_const) | sty_uniq(m_const) => {\n             ebml_w.writer.write(&[ 'c' as u8 ]);\n         }\n     }\n \n-    // Encode the region.\n-    match self_type {\n-        sty_region(region, _) => {\n-            encode_region(ebml_w, *region);\n-        }\n-        sty_static | sty_by_ref | sty_value | sty_box(*) | sty_uniq(*) => {\n-            // Nothing to do.\n-        }\n-    }\n-\n     ebml_w.end_tag();\n }\n \n@@ -1015,7 +1005,7 @@ fn create_index<T: copy>(index: ~[entry<T>], hash_fn: fn@(T) -> uint) ->\n }\n \n fn encode_index<T>(ebml_w: ebml::writer, buckets: ~[@~[entry<T>]],\n-                   write_fn: fn(io::writer, T)) {\n+                   write_fn: fn(io::Writer, T)) {\n     let writer = ebml_w.writer;\n     ebml_w.start_tag(tag_index);\n     let mut bucket_locs: ~[uint] = ~[];\n@@ -1042,9 +1032,9 @@ fn encode_index<T>(ebml_w: ebml::writer, buckets: ~[@~[entry<T>]],\n     ebml_w.end_tag();\n }\n \n-fn write_str(writer: io::writer, &&s: ~str) { writer.write_str(s); }\n+fn write_str(writer: io::Writer, &&s: ~str) { writer.write_str(s); }\n \n-fn write_int(writer: io::writer, &&n: int) {\n+fn write_int(writer: io::Writer, &&n: int) {\n     assert n < 0x7fff_ffff;\n     writer.write_be_u32(n as u32);\n }"}, {"sha": "24e6d3267cc02aa736ca53d12fda5790dc304036", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -14,31 +14,31 @@ export get_cargo_root;\n export get_cargo_root_nearest;\n export libdir;\n \n-import path::path;\n+import path::Path;\n \n-type pick<T> = fn(path: path) -> option<T>;\n+type pick<T> = fn(path: Path) -> option<T>;\n \n-fn pick_file(file: path, path: path) -> option<path> {\n+fn pick_file(file: Path, path: Path) -> option<Path> {\n     if path::basename(path) == file { option::some(path) }\n     else { option::none }\n }\n \n trait filesearch {\n-    fn sysroot() -> path;\n-    fn lib_search_paths() -> ~[path];\n-    fn get_target_lib_path() -> path;\n-    fn get_target_lib_file_path(file: path) -> path;\n+    fn sysroot() -> Path;\n+    fn lib_search_paths() -> ~[Path];\n+    fn get_target_lib_path() -> Path;\n+    fn get_target_lib_file_path(file: Path) -> Path;\n }\n \n-fn mk_filesearch(maybe_sysroot: option<path>,\n+fn mk_filesearch(maybe_sysroot: option<Path>,\n                  target_triple: ~str,\n-                 addl_lib_search_paths: ~[path]) -> filesearch {\n-    type filesearch_impl = {sysroot: path,\n-                            addl_lib_search_paths: ~[path],\n+                 addl_lib_search_paths: ~[Path]) -> filesearch {\n+    type filesearch_impl = {sysroot: Path,\n+                            addl_lib_search_paths: ~[Path],\n                             target_triple: ~str};\n     impl filesearch_impl: filesearch {\n-        fn sysroot() -> path { self.sysroot }\n-        fn lib_search_paths() -> ~[path] {\n+        fn sysroot() -> Path { self.sysroot }\n+        fn lib_search_paths() -> ~[Path] {\n             let mut paths = self.addl_lib_search_paths;\n \n             vec::push(paths,\n@@ -53,10 +53,10 @@ fn mk_filesearch(maybe_sysroot: option<path>,\n             }\n             paths\n         }\n-        fn get_target_lib_path() -> path {\n+        fn get_target_lib_path() -> Path {\n             make_target_lib_path(self.sysroot, self.target_triple)\n         }\n-        fn get_target_lib_file_path(file: path) -> path {\n+        fn get_target_lib_file_path(file: Path) -> Path {\n             path::connect(self.get_target_lib_path(), file)\n         }\n     }\n@@ -88,38 +88,38 @@ fn search<T: copy>(filesearch: filesearch, pick: pick<T>) -> option<T> {\n     return rslt;\n }\n \n-fn relative_target_lib_path(target_triple: ~str) -> ~[path] {\n+fn relative_target_lib_path(target_triple: ~str) -> ~[Path] {\n     ~[libdir(), ~\"rustc\", target_triple, libdir()]\n }\n \n-fn make_target_lib_path(sysroot: path,\n-                        target_triple: ~str) -> path {\n+fn make_target_lib_path(sysroot: Path,\n+                        target_triple: ~str) -> Path {\n     let path = vec::append(~[sysroot],\n                            relative_target_lib_path(target_triple));\n     let path = path::connect_many(path);\n     return path;\n }\n \n-fn get_default_sysroot() -> path {\n+fn get_default_sysroot() -> Path {\n     match os::self_exe_path() {\n       option::some(p) => path::normalize(path::connect(p, ~\"..\")),\n       option::none => fail ~\"can't determine value for sysroot\"\n     }\n }\n \n-fn get_sysroot(maybe_sysroot: option<path>) -> path {\n+fn get_sysroot(maybe_sysroot: option<Path>) -> Path {\n     match maybe_sysroot {\n       option::some(sr) => sr,\n       option::none => get_default_sysroot()\n     }\n }\n \n-fn get_cargo_sysroot() -> result<path, ~str> {\n+fn get_cargo_sysroot() -> result<Path, ~str> {\n     let path = ~[get_default_sysroot(), libdir(), ~\"cargo\"];\n     result::ok(path::connect_many(path))\n }\n \n-fn get_cargo_root() -> result<path, ~str> {\n+fn get_cargo_root() -> result<Path, ~str> {\n     match os::getenv(~\"CARGO_ROOT\") {\n         some(_p) => result::ok(_p),\n         none => match os::homedir() {\n@@ -129,7 +129,7 @@ fn get_cargo_root() -> result<path, ~str> {\n     }\n }\n \n-fn get_cargo_root_nearest() -> result<path, ~str> {\n+fn get_cargo_root_nearest() -> result<Path, ~str> {\n     do result::chain(get_cargo_root()) |p| {\n         let cwd = os::getcwd();\n         let mut dirname = path::dirname(cwd);\n@@ -153,13 +153,13 @@ fn get_cargo_root_nearest() -> result<path, ~str> {\n     }\n }\n \n-fn get_cargo_lib_path() -> result<path, ~str> {\n+fn get_cargo_lib_path() -> result<Path, ~str> {\n     do result::chain(get_cargo_root()) |p| {\n         result::ok(path::connect(p, libdir()))\n     }\n }\n \n-fn get_cargo_lib_path_nearest() -> result<path, ~str> {\n+fn get_cargo_lib_path_nearest() -> result<Path, ~str> {\n     do result::chain(get_cargo_root_nearest()) |p| {\n         result::ok(path::connect(p, libdir()))\n     }"}, {"sha": "d1e24642927edc3e94f1e93182b6344e620f841d", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -6,7 +6,7 @@ import syntax::print::pprust;\n import syntax::codemap::span;\n import lib::llvm::{False, llvm, mk_object_file, mk_section_iter};\n import filesearch::filesearch;\n-import io::writer_util;\n+import io::WriterUtil;\n \n export os;\n export os_macos, os_win32, os_linux, os_freebsd;\n@@ -206,7 +206,7 @@ fn meta_section_name(os: os) -> ~str {\n }\n \n // A diagnostic function for dumping crate metadata to an output stream\n-fn list_file_metadata(os: os, path: ~str, out: io::writer) {\n+fn list_file_metadata(os: os, path: ~str, out: io::Writer) {\n     match get_metadata_section(os, path) {\n       option::some(bytes) => decoder::list_crate_metadata(bytes, out),\n       option::none => {"}, {"sha": "f26ccff18069ac7c87e6c9f150d0359191f8f3d5", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,6 +1,6 @@\n // Type encoding\n \n-import io::writer_util;\n+import io::WriterUtil;\n import std::map::hashmap;\n import syntax::ast::*;\n import syntax::diagnostic::span_handler;\n@@ -40,7 +40,7 @@ fn cx_uses_abbrevs(cx: @ctxt) -> bool {\n     }\n }\n \n-fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n+fn enc_ty(w: io::Writer, cx: @ctxt, t: ty::t) {\n     match cx.abbrevs {\n       ac_no_abbrevs => {\n         let result_str = match cx.tcx.short_names_cache.find(t) {\n@@ -95,7 +95,7 @@ fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n       }\n     }\n }\n-fn enc_mt(w: io::writer, cx: @ctxt, mt: ty::mt) {\n+fn enc_mt(w: io::Writer, cx: @ctxt, mt: ty::mt) {\n     match mt.mutbl {\n       m_imm => (),\n       m_mutbl => w.write_char('m'),\n@@ -104,7 +104,7 @@ fn enc_mt(w: io::writer, cx: @ctxt, mt: ty::mt) {\n     enc_ty(w, cx, mt.ty);\n }\n \n-fn enc_opt<T>(w: io::writer, t: option<T>, enc_f: fn(T)) {\n+fn enc_opt<T>(w: io::Writer, t: option<T>, enc_f: fn(T)) {\n     match t {\n       none => w.write_char('n'),\n       some(v) => {\n@@ -114,15 +114,15 @@ fn enc_opt<T>(w: io::writer, t: option<T>, enc_f: fn(T)) {\n     }\n }\n \n-fn enc_substs(w: io::writer, cx: @ctxt, substs: ty::substs) {\n+fn enc_substs(w: io::Writer, cx: @ctxt, substs: ty::substs) {\n     do enc_opt(w, substs.self_r) |r| { enc_region(w, cx, r) }\n     do enc_opt(w, substs.self_ty) |t| { enc_ty(w, cx, t) }\n     w.write_char('[');\n     for substs.tps.each |t| { enc_ty(w, cx, t); }\n     w.write_char(']');\n }\n \n-fn enc_region(w: io::writer, cx: @ctxt, r: ty::region) {\n+fn enc_region(w: io::Writer, cx: @ctxt, r: ty::region) {\n     match r {\n       ty::re_bound(br) => {\n         w.write_char('b');\n@@ -151,7 +151,7 @@ fn enc_region(w: io::writer, cx: @ctxt, r: ty::region) {\n     }\n }\n \n-fn enc_bound_region(w: io::writer, br: ty::bound_region) {\n+fn enc_bound_region(w: io::Writer, br: ty::bound_region) {\n     match br {\n       ty::br_self => w.write_char('s'),\n       ty::br_anon => w.write_char('a'),\n@@ -169,7 +169,7 @@ fn enc_bound_region(w: io::writer, br: ty::bound_region) {\n     }\n }\n \n-fn enc_vstore(w: io::writer, cx: @ctxt, v: ty::vstore) {\n+fn enc_vstore(w: io::Writer, cx: @ctxt, v: ty::vstore) {\n     w.write_char('/');\n     match v {\n       ty::vstore_fixed(u) => {\n@@ -189,7 +189,7 @@ fn enc_vstore(w: io::writer, cx: @ctxt, v: ty::vstore) {\n     }\n }\n \n-fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n+fn enc_sty(w: io::Writer, cx: @ctxt, st: ty::sty) {\n     match st {\n       ty::ty_nil => w.write_char('n'),\n       ty::ty_bot => w.write_char('z'),\n@@ -307,7 +307,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n     }\n }\n \n-fn enc_proto(w: io::writer, cx: @ctxt, proto: ty::fn_proto) {\n+fn enc_proto(w: io::Writer, cx: @ctxt, proto: ty::fn_proto) {\n     w.write_str(&\"f\");\n     match proto {\n         ty::proto_bare => w.write_str(&\"n\"),\n@@ -318,7 +318,7 @@ fn enc_proto(w: io::writer, cx: @ctxt, proto: ty::fn_proto) {\n     }\n }\n \n-fn enc_mode(w: io::writer, cx: @ctxt, m: mode) {\n+fn enc_mode(w: io::Writer, cx: @ctxt, m: mode) {\n     match ty::resolved_mode(cx.tcx, m) {\n       by_mutbl_ref => w.write_char('&'),\n       by_move => w.write_char('-'),\n@@ -328,7 +328,7 @@ fn enc_mode(w: io::writer, cx: @ctxt, m: mode) {\n     }\n }\n \n-fn enc_purity(w: io::writer, p: purity) {\n+fn enc_purity(w: io::Writer, p: purity) {\n     match p {\n       pure_fn => w.write_char('p'),\n       impure_fn => w.write_char('i'),\n@@ -337,7 +337,7 @@ fn enc_purity(w: io::writer, p: purity) {\n     }\n }\n \n-fn enc_ty_fn(w: io::writer, cx: @ctxt, ft: ty::fn_ty) {\n+fn enc_ty_fn(w: io::Writer, cx: @ctxt, ft: ty::fn_ty) {\n     enc_proto(w, cx, ft.proto);\n     enc_purity(w, ft.purity);\n     enc_bounds(w, cx, ft.bounds);\n@@ -353,7 +353,7 @@ fn enc_ty_fn(w: io::writer, cx: @ctxt, ft: ty::fn_ty) {\n     }\n }\n \n-fn enc_bounds(w: io::writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n+fn enc_bounds(w: io::Writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n     for vec::each(*bs) |bound| {\n         match bound {\n           ty::bound_send => w.write_char('S'),"}, {"sha": "ca4a5866a0aa9d9c538c41069beb386754039a6e", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -6,7 +6,7 @@ import syntax::attr;\n import syntax::codemap::span;\n import std::map::{map,hashmap,int_hash,hash_from_strs};\n import std::smallintmap::{map,smallintmap};\n-import io::writer_util;\n+import io::WriterUtil;\n import util::ppaux::{ty_to_str};\n import middle::pat_util::{pat_bindings};\n import syntax::ast_util::{path_to_ident};"}, {"sha": "61feb22f1b4bc9040358c1ef0111c9eb61c82fb5", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -108,7 +108,7 @@ import visit::vt;\n import syntax::codemap::span;\n import syntax::ast::*;\n import driver::session::session;\n-import io::writer_util;\n+import io::WriterUtil;\n import capture::{cap_move, cap_drop, cap_copy, cap_ref};\n \n export check_crate;\n@@ -647,7 +647,7 @@ class liveness {\n         }\n     }\n \n-    fn write_vars(wr: io::writer,\n+    fn write_vars(wr: io::Writer,\n                   ln: live_node,\n                   test: fn(uint) -> live_node) {\n         let node_base_idx = self.idx(ln, variable(0u));"}, {"sha": "eaf1011f181632b4717bf0506371d75e18e87298", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -41,7 +41,7 @@ enum opt_result {\n     range_result(result, result),\n }\n fn trans_opt(bcx: block, o: opt) -> opt_result {\n-    let _icx = bcx.insn_ctxt(~\"alt::trans_opt\");\n+    let _icx = bcx.insn_ctxt(\"alt::trans_opt\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n     match o {\n@@ -303,7 +303,7 @@ fn get_options(ccx: @crate_ctxt, m: match_, col: uint) -> ~[opt] {\n fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n                         vdefs: {enm: def_id, var: def_id}, val: ValueRef) ->\n    {vals: ~[ValueRef], bcx: block} {\n-    let _icx = bcx.insn_ctxt(~\"alt::extract_variant_args\");\n+    let _icx = bcx.insn_ctxt(\"alt::extract_variant_args\");\n     let ccx = bcx.fcx.ccx;\n     let enum_ty_substs = match check ty::get(node_id_type(bcx, pat_id))\n         .struct {\n@@ -449,7 +449,7 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n       For an empty match, a fall-through case must exist\n      */\n     assert(m.len() > 0u || is_some(chk));\n-    let _icx = bcx.insn_ctxt(~\"alt::compile_submatch\");\n+    let _icx = bcx.insn_ctxt(\"alt::compile_submatch\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx(), dm = tcx.def_map;\n     if m.len() == 0u { Br(bcx, option::get(chk)()); return; }\n@@ -735,7 +735,7 @@ fn make_phi_bindings(bcx: block,\n                      map: ~[exit_node],\n                      ids: pat_util::pat_id_map)\n     -> option<phi_bindings_list> {\n-    let _icx = bcx.insn_ctxt(~\"alt::make_phi_bindings\");\n+    let _icx = bcx.insn_ctxt(\"alt::make_phi_bindings\");\n     let our_block = bcx.llbb as uint;\n     let mut phi_bindings = ~[];\n     for ids.each |name, node_id| {\n@@ -815,15 +815,15 @@ fn trans_alt(bcx: block,\n              arms: ~[ast::arm],\n              mode: ast::alt_mode,\n              dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(~\"alt::trans_alt\");\n+    let _icx = bcx.insn_ctxt(\"alt::trans_alt\");\n     do with_scope(bcx, alt_expr.info(), ~\"alt\") |bcx| {\n         trans_alt_inner(bcx, expr, arms, mode, dest)\n     }\n }\n \n fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: ~[ast::arm],\n                    mode: ast::alt_mode, dest: dest) -> block {\n-    let _icx = scope_cx.insn_ctxt(~\"alt::trans_alt_inner\");\n+    let _icx = scope_cx.insn_ctxt(\"alt::trans_alt_inner\");\n     let bcx = scope_cx, tcx = bcx.tcx();\n     let mut bodies = ~[], matches = ~[];\n \n@@ -897,7 +897,7 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: ~[ast::arm],\n // Not alt-related, but similar to the pattern-munging code above\n fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n                         make_copy: bool) -> block {\n-    let _icx = bcx.insn_ctxt(~\"alt::bind_irrefutable_pat\");\n+    let _icx = bcx.insn_ctxt(\"alt::bind_irrefutable_pat\");\n     let ccx = bcx.fcx.ccx;\n     let mut bcx = bcx;\n "}, {"sha": "7b901ae973952760222f25b56f51bdf7a20b99f2", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 128, "deletions": 128, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -94,27 +94,27 @@ class icx_popper {\n }\n \n trait get_insn_ctxt {\n-    fn insn_ctxt(s: ~str) -> icx_popper;\n+    fn insn_ctxt(s: &str) -> icx_popper;\n }\n \n impl @crate_ctxt: get_insn_ctxt {\n-    fn insn_ctxt(s: ~str) -> icx_popper {\n+    fn insn_ctxt(s: &str) -> icx_popper {\n         debug!{\"new insn_ctxt: %s\", s};\n         if self.sess.count_llvm_insns() {\n-            vec::push(*self.stats.llvm_insn_ctxt, s);\n+            vec::push(*self.stats.llvm_insn_ctxt, str::from_slice(s));\n         }\n         icx_popper(self)\n     }\n }\n \n impl block: get_insn_ctxt {\n-    fn insn_ctxt(s: ~str) -> icx_popper {\n+    fn insn_ctxt(s: &str) -> icx_popper {\n         self.ccx().insn_ctxt(s)\n     }\n }\n \n impl fn_ctxt: get_insn_ctxt {\n-    fn insn_ctxt(s: ~str) -> icx_popper {\n+    fn insn_ctxt(s: &str) -> icx_popper {\n         self.ccx.insn_ctxt(s)\n     }\n }\n@@ -219,7 +219,7 @@ fn get_simple_extern_fn(cx: block,\n                         externs: hashmap<~str, ValueRef>,\n                         llmod: ModuleRef,\n                         name: ~str, n_args: int) -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"get_simple_extern_fn\");\n+    let _icx = cx.insn_ctxt(\"get_simple_extern_fn\");\n     let ccx = cx.fcx.ccx;\n     let inputs = vec::from_elem(n_args as uint, ccx.int_type);\n     let output = ccx.int_type;\n@@ -230,7 +230,7 @@ fn get_simple_extern_fn(cx: block,\n fn trans_foreign_call(cx: block, externs: hashmap<~str, ValueRef>,\n                       llmod: ModuleRef, name: ~str, args: ~[ValueRef]) ->\n    ValueRef {\n-    let _icx = cx.insn_ctxt(~\"trans_foreign_call\");\n+    let _icx = cx.insn_ctxt(\"trans_foreign_call\");\n     let n = args.len() as int;\n     let llforeign: ValueRef =\n         get_simple_extern_fn(cx, externs, llmod, name, n);\n@@ -242,24 +242,24 @@ fn trans_foreign_call(cx: block, externs: hashmap<~str, ValueRef>,\n }\n \n fn trans_free(cx: block, v: ValueRef) -> block {\n-    let _icx = cx.insn_ctxt(~\"trans_free\");\n+    let _icx = cx.insn_ctxt(\"trans_free\");\n     trans_rtcall(cx, ~\"free\", ~[PointerCast(cx, v, T_ptr(T_i8()))], ignore)\n }\n \n fn trans_unique_free(cx: block, v: ValueRef) -> block {\n-    let _icx = cx.insn_ctxt(~\"trans_unique_free\");\n+    let _icx = cx.insn_ctxt(\"trans_unique_free\");\n     trans_rtcall(cx, ~\"exchange_free\", ~[PointerCast(cx, v, T_ptr(T_i8()))],\n                  ignore)\n }\n \n fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"umax\");\n+    let _icx = cx.insn_ctxt(\"umax\");\n     let cond = ICmp(cx, lib::llvm::IntULT, a, b);\n     return Select(cx, cond, b, a);\n }\n \n fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"umin\");\n+    let _icx = cx.insn_ctxt(\"umin\");\n     let cond = ICmp(cx, lib::llvm::IntULT, a, b);\n     return Select(cx, cond, a, b);\n }\n@@ -273,7 +273,7 @@ fn alloca_zeroed(cx: block, t: TypeRef) -> ValueRef {\n }\n \n fn alloca_maybe_zeroed(cx: block, t: TypeRef, zero: bool) -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"alloca\");\n+    let _icx = cx.insn_ctxt(\"alloca\");\n     if cx.unreachable { return llvm::LLVMGetUndef(t); }\n     let initcx = raw_block(cx.fcx, false, cx.fcx.llstaticallocas);\n     let p = Alloca(initcx, t);\n@@ -282,7 +282,7 @@ fn alloca_maybe_zeroed(cx: block, t: TypeRef, zero: bool) -> ValueRef {\n }\n \n fn zero_mem(cx: block, llptr: ValueRef, t: ty::t) -> block {\n-    let _icx = cx.insn_ctxt(~\"zero_mem\");\n+    let _icx = cx.insn_ctxt(\"zero_mem\");\n     let bcx = cx;\n     let ccx = cx.ccx();\n     let llty = type_of(ccx, t);\n@@ -291,7 +291,7 @@ fn zero_mem(cx: block, llptr: ValueRef, t: ty::t) -> block {\n }\n \n fn arrayalloca(cx: block, t: TypeRef, v: ValueRef) -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"arrayalloca\");\n+    let _icx = cx.insn_ctxt(\"arrayalloca\");\n     if cx.unreachable { return llvm::LLVMGetUndef(t); }\n     return ArrayAlloca(\n         raw_block(cx.fcx, false, cx.fcx.llstaticallocas), t, v);\n@@ -301,7 +301,7 @@ fn arrayalloca(cx: block, t: TypeRef, v: ValueRef) -> ValueRef {\n // The type of the returned pointer is always i8*.  If you care about the\n // return type, use bump_ptr().\n fn ptr_offs(bcx: block, base: ValueRef, sz: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(~\"ptr_offs\");\n+    let _icx = bcx.insn_ctxt(\"ptr_offs\");\n     let raw = PointerCast(bcx, base, T_ptr(T_i8()));\n     InBoundsGEP(bcx, raw, ~[sz])\n }\n@@ -310,7 +310,7 @@ fn ptr_offs(bcx: block, base: ValueRef, sz: ValueRef) -> ValueRef {\n // to a given type.\n fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n    ValueRef {\n-    let _icx = bcx.insn_ctxt(~\"bump_ptr\");\n+    let _icx = bcx.insn_ctxt(\"bump_ptr\");\n     let ccx = bcx.ccx();\n     let bumped = ptr_offs(bcx, base, sz);\n     let typ = T_ptr(type_of(ccx, t));\n@@ -323,7 +323,7 @@ fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n             variant_id: ast::def_id, ty_substs: ~[ty::t],\n             ix: uint) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(~\"GEP_enum\");\n+    let _icx = bcx.insn_ctxt(\"GEP_enum\");\n     let ccx = bcx.ccx();\n     let variant = ty::enum_variant_with_id(ccx.tcx, enum_id, variant_id);\n     assert ix < variant.args.len();\n@@ -344,7 +344,7 @@ fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n fn opaque_box_body(bcx: block,\n                    body_t: ty::t,\n                    boxptr: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(~\"opaque_box_body\");\n+    let _icx = bcx.insn_ctxt(\"opaque_box_body\");\n     let ccx = bcx.ccx();\n     let boxptr = PointerCast(bcx, boxptr, T_ptr(T_box_header(ccx)));\n     let bodyptr = GEPi(bcx, boxptr, ~[1u]);\n@@ -355,7 +355,7 @@ fn opaque_box_body(bcx: block,\n // potentially dynamic size.\n fn malloc_raw_dyn(bcx: block, t: ty::t, heap: heap,\n                   size: ValueRef) -> result {\n-    let _icx = bcx.insn_ctxt(~\"malloc_raw\");\n+    let _icx = bcx.insn_ctxt(\"malloc_raw\");\n     let ccx = bcx.ccx();\n \n     let (mk_fn, rtcall) = match heap {\n@@ -390,7 +390,7 @@ fn malloc_raw(bcx: block, t: ty::t, heap: heap) -> result {\n // and pulls out the body\n fn malloc_general_dyn(bcx: block, t: ty::t, heap: heap, size: ValueRef)\n     -> {bcx: block, box: ValueRef, body: ValueRef} {\n-    let _icx = bcx.insn_ctxt(~\"malloc_general\");\n+    let _icx = bcx.insn_ctxt(\"malloc_general\");\n     let {bcx: bcx, val: llbox} = malloc_raw_dyn(bcx, t, heap, size);\n     let non_gc_box = non_gc_box_cast(bcx, llbox);\n     let body = GEPi(bcx, non_gc_box, ~[0u, abi::box_field_body]);\n@@ -487,7 +487,7 @@ fn note_unique_llvm_symbol(ccx: @crate_ctxt, sym: ~str) {\n \n // Generates the declaration for (but doesn't emit) a type descriptor.\n fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n-    let _icx = ccx.insn_ctxt(~\"declare_tydesc\");\n+    let _icx = ccx.insn_ctxt(\"declare_tydesc\");\n     let llty = type_of(ccx, t);\n \n     if ccx.sess.count_type_sizes() {\n@@ -524,7 +524,7 @@ type glue_helper = fn@(block, ValueRef, ty::t);\n \n fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n                         name: ~str) -> ValueRef {\n-    let _icx = ccx.insn_ctxt(~\"declare_generic_glue\");\n+    let _icx = ccx.insn_ctxt(\"declare_generic_glue\");\n     let name = name;\n     let mut fn_nm;\n     //XXX this triggers duplicate LLVM symbols\n@@ -541,7 +541,7 @@ fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n \n fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n                            llfn: ValueRef, helper: glue_helper) -> ValueRef {\n-    let _icx = ccx.insn_ctxt(~\"make_generic_glue_inner\");\n+    let _icx = ccx.insn_ctxt(\"make_generic_glue_inner\");\n     let fcx = new_fn_ctxt(ccx, ~[], llfn, none);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     ccx.stats.n_glues_created += 1u;\n@@ -564,7 +564,7 @@ fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n fn make_generic_glue(ccx: @crate_ctxt, t: ty::t, llfn: ValueRef,\n                      helper: glue_helper, name: ~str)\n     -> ValueRef {\n-    let _icx = ccx.insn_ctxt(~\"make_generic_glue\");\n+    let _icx = ccx.insn_ctxt(\"make_generic_glue\");\n     if !ccx.sess.trans_stats() {\n         return make_generic_glue_inner(ccx, t, llfn, helper);\n     }\n@@ -578,7 +578,7 @@ fn make_generic_glue(ccx: @crate_ctxt, t: ty::t, llfn: ValueRef,\n }\n \n fn emit_tydescs(ccx: @crate_ctxt) {\n-    let _icx = ccx.insn_ctxt(~\"emit_tydescs\");\n+    let _icx = ccx.insn_ctxt(\"emit_tydescs\");\n     for ccx.tydescs.each |key, val| {\n         let glue_fn_ty = T_ptr(T_generic_glue_fn(ccx));\n         let ti = val;\n@@ -644,7 +644,7 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n }\n \n fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n-    let _icx = bcx.insn_ctxt(~\"make_take_glue\");\n+    let _icx = bcx.insn_ctxt(\"make_take_glue\");\n     // NB: v is a *pointer* to type t here, not a direct value.\n     let bcx = match ty::get(t).struct {\n       ty::ty_box(_) | ty::ty_opaque_box |\n@@ -686,7 +686,7 @@ fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n }\n \n fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n-    let _icx = cx.insn_ctxt(~\"incr_refcnt_of_boxed\");\n+    let _icx = cx.insn_ctxt(\"incr_refcnt_of_boxed\");\n     let ccx = cx.ccx();\n     maybe_validate_box(cx, box_ptr);\n     let rc_ptr = GEPi(cx, box_ptr, ~[0u, abi::box_field_refcnt]);\n@@ -696,7 +696,7 @@ fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n }\n \n fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n-    let _icx = bcx.insn_ctxt(~\"make_visit_glue\");\n+    let _icx = bcx.insn_ctxt(\"make_visit_glue\");\n     let mut bcx = bcx;\n     assert bcx.ccx().tcx.intrinsic_defs.contains_key(@~\"ty_visitor\");\n     let (trait_id, ty) = bcx.ccx().tcx.intrinsic_defs.get(@~\"ty_visitor\");\n@@ -708,7 +708,7 @@ fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n \n fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n-    let _icx = bcx.insn_ctxt(~\"make_free_glue\");\n+    let _icx = bcx.insn_ctxt(\"make_free_glue\");\n     let ccx = bcx.ccx();\n     let bcx = match ty::get(t).struct {\n       ty::ty_box(body_mt) => {\n@@ -790,7 +790,7 @@ fn trans_class_drop(bcx: block, v0: ValueRef, dtor_did: ast::def_id,\n \n fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n-    let _icx = bcx.insn_ctxt(~\"make_drop_glue\");\n+    let _icx = bcx.insn_ctxt(\"make_drop_glue\");\n     let ccx = bcx.ccx();\n     let bcx = match ty::get(t).struct {\n       ty::ty_box(_) | ty::ty_opaque_box |\n@@ -839,7 +839,7 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id,\n                 parent_id: ast::def_id, substs: ~[ty::t])\n    -> ValueRef {\n-    let _icx = ccx.insn_ctxt(~\"trans_res_dtor\");\n+    let _icx = ccx.insn_ctxt(\"trans_res_dtor\");\n     if (substs.len() > 0u) {\n         let did = if did.crate != ast::local_crate {\n             maybe_instantiate_inline(ccx, did)\n@@ -871,7 +871,7 @@ fn maybe_validate_box(_cx: block, _box_ptr: ValueRef) {\n }\n \n fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t) -> block {\n-    let _icx = bcx.insn_ctxt(~\"decr_refcnt_maybe_free\");\n+    let _icx = bcx.insn_ctxt(\"decr_refcnt_maybe_free\");\n     let ccx = bcx.ccx();\n     maybe_validate_box(bcx, box_ptr);\n \n@@ -923,7 +923,7 @@ fn compare_scalar_types(cx: block, lhs: ValueRef, rhs: ValueRef,\n // A helper function to do the actual comparison of scalar values.\n fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n                          nt: scalar_type, op: ast::binop) -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"compare_scalar_values\");\n+    let _icx = cx.insn_ctxt(\"compare_scalar_values\");\n     fn die_(cx: block) -> ! {\n         cx.tcx().sess.bug(~\"compare_scalar_values: must be a\\\n           comparison operator\");\n@@ -994,13 +994,13 @@ fn store_inbounds(cx: block, v: ValueRef, p: ValueRef,\n // Iterates through the elements of a structural type.\n fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n                       f: val_and_ty_fn) -> block {\n-    let _icx = cx.insn_ctxt(~\"iter_structural_ty\");\n+    let _icx = cx.insn_ctxt(\"iter_structural_ty\");\n \n     fn iter_variant(cx: block, a_tup: ValueRef,\n                     variant: ty::variant_info,\n                     tps: ~[ty::t], tid: ast::def_id,\n                     f: val_and_ty_fn) -> block {\n-        let _icx = cx.insn_ctxt(~\"iter_variant\");\n+        let _icx = cx.insn_ctxt(\"iter_variant\");\n         if variant.args.len() == 0u { return cx; }\n         let fn_ty = variant.ctor_ty;\n         let ccx = cx.ccx();\n@@ -1108,7 +1108,7 @@ fn lazily_emit_all_tydesc_glue(ccx: @crate_ctxt,\n \n fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n                            ti: @tydesc_info) {\n-    let _icx = ccx.insn_ctxt(~\"lazily_emit_tydesc_glue\");\n+    let _icx = ccx.insn_ctxt(\"lazily_emit_tydesc_glue\");\n     let llfnty = type_of_glue_fn(ccx, ti.ty);\n     if field == abi::tydesc_field_take_glue {\n         match ti.take_glue {\n@@ -1168,7 +1168,7 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n // See [Note-arg-mode]\n fn call_tydesc_glue_full(++bcx: block, v: ValueRef, tydesc: ValueRef,\n                          field: uint, static_ti: option<@tydesc_info>) {\n-    let _icx = bcx.insn_ctxt(~\"call_tydesc_glue_full\");\n+    let _icx = bcx.insn_ctxt(\"call_tydesc_glue_full\");\n         if bcx.unreachable { return; }\n     let ccx = bcx.ccx();\n \n@@ -1228,7 +1228,7 @@ fn call_tydesc_glue_full(++bcx: block, v: ValueRef, tydesc: ValueRef,\n // See [Note-arg-mode]\n fn call_tydesc_glue(++cx: block, v: ValueRef, t: ty::t, field: uint)\n     -> block {\n-    let _icx = cx.insn_ctxt(~\"call_tydesc_glue\");\n+    let _icx = cx.insn_ctxt(\"call_tydesc_glue\");\n     let ti = get_tydesc(cx.ccx(), t);\n     call_tydesc_glue_full(cx, v, ti.tydesc, field, some(ti));\n     return cx;\n@@ -1238,7 +1238,7 @@ fn call_cmp_glue(bcx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n                  llop: ValueRef) -> ValueRef {\n     // We can't use call_tydesc_glue_full() and friends here because compare\n     // glue has a special signature.\n-    let _icx = bcx.insn_ctxt(~\"call_cmp_glue\");\n+    let _icx = bcx.insn_ctxt(\"call_cmp_glue\");\n \n     let lllhs = spill_if_immediate(bcx, lhs, t);\n     let llrhs = spill_if_immediate(bcx, rhs, t);\n@@ -1257,7 +1257,7 @@ fn call_cmp_glue(bcx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n \n fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    let _icx = cx.insn_ctxt(~\"take_ty\");\n+    let _icx = cx.insn_ctxt(\"take_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n         return call_tydesc_glue(cx, v, t, abi::tydesc_field_take_glue);\n     }\n@@ -1266,15 +1266,15 @@ fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n \n fn drop_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    let _icx = cx.insn_ctxt(~\"drop_ty\");\n+    let _icx = cx.insn_ctxt(\"drop_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n         return call_tydesc_glue(cx, v, t, abi::tydesc_field_drop_glue);\n     }\n     return cx;\n }\n \n fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n-    let _icx = bcx.insn_ctxt(~\"drop_ty_immediate\");\n+    let _icx = bcx.insn_ctxt(\"drop_ty_immediate\");\n     match ty::get(t).struct {\n       ty::ty_uniq(_) |\n       ty::ty_evec(_, ty::vstore_uniq) |\n@@ -1291,7 +1291,7 @@ fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n }\n \n fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> result {\n-    let _icx = bcx.insn_ctxt(~\"take_ty_immediate\");\n+    let _icx = bcx.insn_ctxt(\"take_ty_immediate\");\n     match ty::get(t).struct {\n       ty::ty_box(_) | ty::ty_opaque_box |\n       ty::ty_evec(_, ty::vstore_box) |\n@@ -1312,15 +1312,15 @@ fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> result {\n \n fn free_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n     // NB: v is an *alias* of type t here, not a direct value.\n-    let _icx = cx.insn_ctxt(~\"free_ty\");\n+    let _icx = cx.insn_ctxt(\"free_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n         return call_tydesc_glue(cx, v, t, abi::tydesc_field_free_glue);\n     }\n     return cx;\n }\n \n fn free_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n-    let _icx = bcx.insn_ctxt(~\"free_ty_immediate\");\n+    let _icx = bcx.insn_ctxt(\"free_ty_immediate\");\n     match ty::get(t).struct {\n       ty::ty_uniq(_) |\n       ty::ty_evec(_, ty::vstore_uniq) |\n@@ -1343,7 +1343,7 @@ fn call_memmove(cx: block, dst: ValueRef, src: ValueRef,\n     // alignment information when the alignment is statically known (it must\n     // be nothing more than a constant int, or LLVM complains -- not even a\n     // constant element of a tydesc works).\n-    let _icx = cx.insn_ctxt(~\"call_memmove\");\n+    let _icx = cx.insn_ctxt(\"call_memmove\");\n     let ccx = cx.ccx();\n     let key = match ccx.sess.targ_cfg.arch {\n       session::arch_x86 | session::arch_arm => ~\"llvm.memmove.p0i8.p0i8.i32\",\n@@ -1359,7 +1359,7 @@ fn call_memmove(cx: block, dst: ValueRef, src: ValueRef,\n }\n \n fn memmove_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) {\n-    let _icx = bcx.insn_ctxt(~\"memmove_ty\");\n+    let _icx = bcx.insn_ctxt(\"memmove_ty\");\n     let ccx = bcx.ccx();\n     if ty::type_is_structural(t) {\n         let llsz = llsize_of(ccx, type_of(ccx, t));\n@@ -1382,7 +1382,7 @@ fn type_is_structural_or_param(t: ty::t) -> bool {\n \n fn copy_val(cx: block, action: copy_action, dst: ValueRef,\n             src: ValueRef, t: ty::t) -> block {\n-    let _icx = cx.insn_ctxt(~\"copy_val\");\n+    let _icx = cx.insn_ctxt(\"copy_val\");\n     if action == DROP_EXISTING &&\n         (type_is_structural_or_param(t) ||\n          ty::type_is_unique(t)) {\n@@ -1399,7 +1399,7 @@ fn copy_val(cx: block, action: copy_action, dst: ValueRef,\n \n fn copy_val_no_check(bcx: block, action: copy_action, dst: ValueRef,\n                      src: ValueRef, t: ty::t) -> block {\n-    let _icx = bcx.insn_ctxt(~\"copy_val_no_check\");\n+    let _icx = bcx.insn_ctxt(\"copy_val_no_check\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n     if ty::type_is_scalar(t) || ty::type_is_region_ptr(t) {\n@@ -1430,7 +1430,7 @@ fn copy_val_no_check(bcx: block, action: copy_action, dst: ValueRef,\n fn move_val(cx: block, action: copy_action, dst: ValueRef,\n             src: lval_result, t: ty::t) -> block {\n \n-    let _icx = cx.insn_ctxt(~\"move_val\");\n+    let _icx = cx.insn_ctxt(\"move_val\");\n     let mut src_val = src.val;\n     let tcx = cx.tcx();\n     let mut cx = cx;\n@@ -1463,7 +1463,7 @@ fn move_val(cx: block, action: copy_action, dst: ValueRef,\n fn store_temp_expr(cx: block, action: copy_action, dst: ValueRef,\n                    src: lval_result, t: ty::t, last_use: bool)\n     -> block {\n-    let _icx = cx.insn_ctxt(~\"trans_temp_expr\");\n+    let _icx = cx.insn_ctxt(\"trans_temp_expr\");\n     // Lvals in memory are not temporaries. Copy them.\n     if src.kind != lv_temporary && !last_use {\n         let v = if src.kind == lv_owned {\n@@ -1477,7 +1477,7 @@ fn store_temp_expr(cx: block, action: copy_action, dst: ValueRef,\n }\n \n fn trans_lit(cx: block, e: @ast::expr, lit: ast::lit, dest: dest) -> block {\n-    let _icx = cx.insn_ctxt(~\"trans_lit\");\n+    let _icx = cx.insn_ctxt(\"trans_lit\");\n     if dest == ignore { return cx; }\n     match lit.node {\n         ast::lit_str(s) => tvec::trans_estr(cx, s, none, dest),\n@@ -1488,7 +1488,7 @@ fn trans_lit(cx: block, e: @ast::expr, lit: ast::lit, dest: dest) -> block {\n fn trans_boxed_expr(bcx: block, contents: @ast::expr,\n                     t: ty::t, heap: heap,\n                     dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_boxed_expr\");\n+    let _icx = bcx.insn_ctxt(\"trans_boxed_expr\");\n     let {bcx, box, body} = malloc_general(bcx, t, heap);\n     add_clean_free(bcx, box, heap);\n     let bcx = trans_expr_save_in(bcx, contents, body);\n@@ -1498,7 +1498,7 @@ fn trans_boxed_expr(bcx: block, contents: @ast::expr,\n \n fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n                un_expr: @ast::expr, dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_unary\");\n+    let _icx = bcx.insn_ctxt(\"trans_unary\");\n     // Check for user-defined method call\n     match bcx.ccx().maps.method_map.find(un_expr.id) {\n       some(mentry) => {\n@@ -1542,7 +1542,7 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n }\n \n fn trans_addr_of(cx: block, e: @ast::expr, dest: dest) -> block {\n-    let _icx = cx.insn_ctxt(~\"trans_addr_of\");\n+    let _icx = cx.insn_ctxt(\"trans_addr_of\");\n     let mut {bcx, val, kind} = trans_temp_lval(cx, e);\n     let ety = expr_ty(cx, e);\n     let is_immediate = ty::type_is_immediate(ety);\n@@ -1554,7 +1554,7 @@ fn trans_addr_of(cx: block, e: @ast::expr, dest: dest) -> block {\n \n fn trans_compare(cx: block, op: ast::binop, lhs: ValueRef,\n                  _lhs_t: ty::t, rhs: ValueRef, rhs_t: ty::t) -> result {\n-    let _icx = cx.insn_ctxt(~\"trans_compare\");\n+    let _icx = cx.insn_ctxt(\"trans_compare\");\n     if ty::type_is_scalar(rhs_t) {\n       let rs = compare_scalar_types(cx, lhs, rhs, rhs_t, op);\n       return rslt(rs.bcx, rs.val);\n@@ -1650,7 +1650,7 @@ fn trans_eager_binop(cx: block, span: span, op: ast::binop, lhs: ValueRef,\n                      lhs_t: ty::t, rhs: ValueRef, rhs_t: ty::t, dest: dest)\n     -> block {\n     let mut cx = cx;\n-    let _icx = cx.insn_ctxt(~\"trans_eager_binop\");\n+    let _icx = cx.insn_ctxt(\"trans_eager_binop\");\n     if dest == ignore { return cx; }\n     let intype = {\n         if ty::type_is_bot(lhs_t) { rhs_t }\n@@ -1721,7 +1721,7 @@ fn trans_eager_binop(cx: block, span: span, op: ast::binop, lhs: ValueRef,\n fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n                    dst: @ast::expr, src: @ast::expr) -> block {\n     debug!{\"%s\", expr_to_str(ex)};\n-    let _icx = bcx.insn_ctxt(~\"trans_assign_op\");\n+    let _icx = bcx.insn_ctxt(\"trans_assign_op\");\n     let t = expr_ty(bcx, src);\n     let lhs_res = trans_lval(bcx, dst);\n     assert (lhs_res.kind == lv_owned);\n@@ -1762,7 +1762,7 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n \n fn root_value(bcx: block, val: ValueRef, ty: ty::t,\n               scope_id: ast::node_id) {\n-    let _icx = bcx.insn_ctxt(~\"root_value\");\n+    let _icx = bcx.insn_ctxt(\"root_value\");\n \n     if bcx.sess().trace() {\n         trans_trace(\n@@ -1780,7 +1780,7 @@ fn root_value(bcx: block, val: ValueRef, ty: ty::t,\n fn autoderef(cx: block, e_id: ast::node_id,\n              v: ValueRef, t: ty::t,\n              max: uint) -> result_t {\n-    let _icx = cx.insn_ctxt(~\"autoderef\");\n+    let _icx = cx.insn_ctxt(\"autoderef\");\n     let mut v1: ValueRef = v;\n     let mut t1: ty::t = t;\n     let ccx = cx.ccx();\n@@ -1845,7 +1845,7 @@ enum lazy_binop_ty { lazy_and, lazy_or }\n \n fn trans_lazy_binop(bcx: block, op: lazy_binop_ty, a: @ast::expr,\n                     b: @ast::expr, dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_lazy_binop\");\n+    let _icx = bcx.insn_ctxt(\"trans_lazy_binop\");\n     let {bcx: past_lhs, val: lhs} = {\n         do with_scope_result(bcx, a.info(), ~\"lhs\") |bcx| {\n             trans_temp_expr(bcx, a)\n@@ -1873,7 +1873,7 @@ fn trans_lazy_binop(bcx: block, op: lazy_binop_ty, a: @ast::expr,\n \n fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n                 rhs: @ast::expr, dest: dest, ex: @ast::expr) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_binary\");\n+    let _icx = bcx.insn_ctxt(\"trans_binary\");\n     // User-defined operators\n     match bcx.ccx().maps.method_map.find(ex.id) {\n       some(origin) => {\n@@ -1912,7 +1912,7 @@ fn trans_binary(bcx: block, op: ast::binop, lhs: @ast::expr,\n fn trans_if(cx: block, cond: @ast::expr, thn: ast::blk,\n             els: option<@ast::expr>, dest: dest)\n     -> block {\n-    let _icx = cx.insn_ctxt(~\"trans_if\");\n+    let _icx = cx.insn_ctxt(\"trans_if\");\n     let {bcx, val: cond_val} = trans_temp_expr(cx, cond);\n \n     let then_dest = dup_for_join(dest);\n@@ -1949,7 +1949,7 @@ fn trans_if(cx: block, cond: @ast::expr, thn: ast::blk,\n \n fn trans_while(cx: block, cond: @ast::expr, body: ast::blk)\n     -> block {\n-    let _icx = cx.insn_ctxt(~\"trans_while\");\n+    let _icx = cx.insn_ctxt(\"trans_while\");\n     let next_cx = sub_block(cx, ~\"while next\");\n     let loop_cx = loop_scope_block(cx, next_cx, ~\"`while`\", body.info());\n     let cond_cx = scope_block(loop_cx, cond.info(), ~\"while loop cond\");\n@@ -1965,7 +1965,7 @@ fn trans_while(cx: block, cond: @ast::expr, body: ast::blk)\n }\n \n fn trans_loop(cx:block, body: ast::blk) -> block {\n-    let _icx = cx.insn_ctxt(~\"trans_loop\");\n+    let _icx = cx.insn_ctxt(\"trans_loop\");\n     let next_cx = sub_block(cx, ~\"next\");\n     let body_cx = loop_scope_block(cx, next_cx, ~\"`loop`\", body.info());\n     let body_end = trans_block(body_cx, body, ignore);\n@@ -2111,7 +2111,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n                   vtables: option<typeck::vtable_res>,\n                   ref_id: option<ast::node_id>)\n     -> {val: ValueRef, must_cast: bool} {\n-    let _icx = ccx.insn_ctxt(~\"monomorphic_fn\");\n+    let _icx = ccx.insn_ctxt(\"monomorphic_fn\");\n     let mut must_cast = false;\n     let substs = vec::map(real_substs, |t| {\n         match normalize_for_monomorphization(ccx.tcx, t) {\n@@ -2295,7 +2295,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n \n fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n     -> ast::def_id {\n-    let _icx = ccx.insn_ctxt(~\"maybe_instantiate_inline\");\n+    let _icx = ccx.insn_ctxt(\"maybe_instantiate_inline\");\n     match ccx.external.find(fn_id) {\n       some(some(node_id)) => {\n         // Already inline\n@@ -2373,7 +2373,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n \n fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id)\n     -> lval_maybe_callee {\n-    let _icx = bcx.insn_ctxt(~\"lval_static_fn\");\n+    let _icx = bcx.insn_ctxt(\"lval_static_fn\");\n     let vts = option::map(bcx.ccx().maps.vtable_map.find(id), |vts| {\n         impl::resolve_vtables_in_fn_ctxt(bcx.fcx, vts)\n     });\n@@ -2383,7 +2383,7 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id)\n fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n                         tys: ~[ty::t], vtables: option<typeck::vtable_res>)\n     -> lval_maybe_callee {\n-    let _icx = bcx.insn_ctxt(~\"lval_static_fn_inner\");\n+    let _icx = bcx.insn_ctxt(\"lval_static_fn_inner\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n     let tpt = ty::lookup_item_type(tcx, fn_id);\n \n@@ -2433,7 +2433,7 @@ fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n }\n \n fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n-    let _icx = ccx.insn_ctxt(~\"lookup_discriminant\");\n+    let _icx = ccx.insn_ctxt(\"lookup_discriminant\");\n     match ccx.discrims.find(vid) {\n       none => {\n         // It's an external discriminant that we haven't seen yet.\n@@ -2456,7 +2456,7 @@ fn cast_self(cx: block, slf: val_self_pair) -> ValueRef {\n }\n \n fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n-    let _icx = cx.insn_ctxt(~\"trans_local_var\");\n+    let _icx = cx.insn_ctxt(\"trans_local_var\");\n     fn take_local(table: hashmap<ast::node_id, local_val>,\n                   id: ast::node_id) -> local_var_result {\n         match table.find(id) {\n@@ -2495,7 +2495,7 @@ fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n \n fn trans_path(cx: block, id: ast::node_id)\n     -> lval_maybe_callee {\n-    let _icx = cx.insn_ctxt(~\"trans_path\");\n+    let _icx = cx.insn_ctxt(\"trans_path\");\n     match cx.tcx().def_map.find(id) {\n       none => cx.sess().bug(~\"trans_path: unbound node ID\"),\n       some(df) => {\n@@ -2505,7 +2505,7 @@ fn trans_path(cx: block, id: ast::node_id)\n }\n \n fn trans_var(cx: block, def: ast::def, id: ast::node_id)-> lval_maybe_callee {\n-    let _icx = cx.insn_ctxt(~\"trans_var\");\n+    let _icx = cx.insn_ctxt(\"trans_var\");\n     let ccx = cx.ccx();\n     match def {\n       ast::def_fn(did, _) => {\n@@ -2548,7 +2548,7 @@ fn trans_var(cx: block, def: ast::def, id: ast::node_id)-> lval_maybe_callee {\n \n fn trans_rec_field(bcx: block, base: @ast::expr,\n                    field: ast::ident) -> lval_result {\n-    let _icx = bcx.insn_ctxt(~\"trans_rec_field\");\n+    let _icx = bcx.insn_ctxt(\"trans_rec_field\");\n     let {bcx, val} = trans_temp_expr(bcx, base);\n     let {bcx, val, ty} =\n         autoderef(bcx, base.id, val, expr_ty(bcx, base),\n@@ -2593,7 +2593,7 @@ fn trans_rec_field_inner(bcx: block, val: ValueRef, ty: ty::t,\n \n fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n                idx: @ast::expr) -> lval_result {\n-    let _icx = cx.insn_ctxt(~\"trans_index\");\n+    let _icx = cx.insn_ctxt(\"trans_index\");\n     let base_ty = expr_ty(cx, base);\n     let exp = trans_temp_expr(cx, base);\n     let lv = autoderef(exp.bcx, base.id, exp.val, base_ty, uint::max_value);\n@@ -2650,7 +2650,7 @@ fn expr_is_lval(bcx: block, e: @ast::expr) -> bool {\n }\n \n fn trans_callee(bcx: block, e: @ast::expr) -> lval_maybe_callee {\n-    let _icx = bcx.insn_ctxt(~\"trans_callee\");\n+    let _icx = bcx.insn_ctxt(\"trans_callee\");\n     match e.node {\n       ast::expr_path(path) => return trans_path(bcx, e.id),\n       ast::expr_field(base, _, _) => {\n@@ -2691,7 +2691,7 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n                                  scope_id});\n         }\n \n-        let _icx = lv.bcx.insn_ctxt(~\"root_value_lval\");\n+        let _icx = lv.bcx.insn_ctxt(\"root_value_lval\");\n         let ty = expr_ty(lv.bcx, e);\n         let root_loc = alloca_zeroed(lv.bcx, type_of(cx.ccx(), ty));\n         let bcx = store_temp_expr(lv.bcx, INIT, root_loc, lv, ty, false);\n@@ -2701,7 +2701,7 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n     };\n \n     fn unrooted(cx: block, e: @ast::expr) -> lval_result {\n-        let _icx = cx.insn_ctxt(~\"trans_lval\");\n+        let _icx = cx.insn_ctxt(\"trans_lval\");\n         match e.node {\n           ast::expr_path(_) => {\n             let v = trans_path(cx, e.id);\n@@ -2773,7 +2773,7 @@ fn lval_maybe_callee_to_lval(c: lval_maybe_callee, sp: span) -> lval_result {\n \n fn int_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n             llsrc: ValueRef, signed: bool) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(~\"int_cast\");\n+    let _icx = bcx.insn_ctxt(\"int_cast\");\n     let srcsz = llvm::LLVMGetIntTypeWidth(llsrctype);\n     let dstsz = llvm::LLVMGetIntTypeWidth(lldsttype);\n     return if dstsz == srcsz {\n@@ -2787,7 +2787,7 @@ fn int_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n \n fn float_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n               llsrc: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(~\"float_cast\");\n+    let _icx = bcx.insn_ctxt(\"float_cast\");\n     let srcsz = lib::llvm::float_width(llsrctype);\n     let dstsz = lib::llvm::float_width(lldsttype);\n     return if dstsz > srcsz {\n@@ -2815,7 +2815,7 @@ fn cast_type_kind(t: ty::t) -> cast_kind {\n \n fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n               dest: dest) -> block {\n-    let _icx = cx.insn_ctxt(~\"trans_cast\");\n+    let _icx = cx.insn_ctxt(\"trans_cast\");\n     let ccx = cx.ccx();\n     let t_out = node_id_type(cx, id);\n     match ty::get(t_out).struct {\n@@ -2903,7 +2903,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n                   derefs: uint)\n     -> result {\n     debug!{\"+++ trans_arg_expr on %s\", expr_to_str(e)};\n-    let _icx = cx.insn_ctxt(~\"trans_arg_expr\");\n+    let _icx = cx.insn_ctxt(\"trans_arg_expr\");\n     let ccx = cx.ccx();\n     let e_ty = expr_ty(cx, e);\n     let is_bot = ty::type_is_bot(e_ty);\n@@ -3077,7 +3077,7 @@ enum call_args {\n fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n               dest: dest, ret_flag: option<ValueRef>)\n     -> {bcx: block, args: ~[ValueRef], retslot: ValueRef} {\n-    let _icx = cx.insn_ctxt(~\"trans_args\");\n+    let _icx = cx.insn_ctxt(\"trans_args\");\n     let mut temp_cleanups = ~[];\n     let arg_tys = ty::ty_fn_args(fn_ty);\n     let mut llargs: ~[ValueRef] = ~[];\n@@ -3139,7 +3139,7 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n fn trans_call(in_cx: block, call_ex: @ast::expr, f: @ast::expr,\n               args: call_args, id: ast::node_id, dest: dest)\n     -> block {\n-    let _icx = in_cx.insn_ctxt(~\"trans_call\");\n+    let _icx = in_cx.insn_ctxt(\"trans_call\");\n     trans_call_inner(\n         in_cx, call_ex.info(), expr_ty(in_cx, f), node_id_type(in_cx, id),\n         |cx| trans_callee(cx, f), args, dest)\n@@ -3257,7 +3257,7 @@ fn trans_call_inner(\n }\n \n fn invoke(bcx: block, llfn: ValueRef, llargs: ~[ValueRef]) -> block {\n-    let _icx = bcx.insn_ctxt(~\"invoke_\");\n+    let _icx = bcx.insn_ctxt(\"invoke_\");\n     if bcx.unreachable { return bcx; }\n     if need_invoke(bcx) {\n         log(debug, ~\"invoking\");\n@@ -3336,7 +3336,7 @@ fn in_lpad_scope_cx(bcx: block, f: fn(scope_info)) {\n }\n \n fn get_landing_pad(bcx: block) -> BasicBlockRef {\n-    let _icx = bcx.insn_ctxt(~\"get_landing_pad\");\n+    let _icx = bcx.insn_ctxt(\"get_landing_pad\");\n \n     let mut cached = none, pad_bcx = bcx; // Guaranteed to be set below\n     do in_lpad_scope_cx(bcx) |inf| {\n@@ -3386,7 +3386,7 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n }\n \n fn trans_tup(bcx: block, elts: ~[@ast::expr], dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_tup\");\n+    let _icx = bcx.insn_ctxt(\"trans_tup\");\n     let mut bcx = bcx;\n     let addr = match dest {\n       ignore => {\n@@ -3411,7 +3411,7 @@ fn trans_tup(bcx: block, elts: ~[@ast::expr], dest: dest) -> block {\n fn trans_rec(bcx: block, fields: ~[ast::field],\n              base: option<@ast::expr>, id: ast::node_id,\n              dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_rec\");\n+    let _icx = bcx.insn_ctxt(\"trans_rec\");\n     let t = node_id_type(bcx, id);\n     let mut bcx = bcx;\n     let addr = match check dest {\n@@ -3475,7 +3475,7 @@ fn trans_struct(block_context: block, span: span, fields: ~[ast::field],\n                 base: option<@ast::expr>, id: ast::node_id, dest: dest)\n              -> block {\n \n-    let _instruction_context = block_context.insn_ctxt(~\"trans_struct\");\n+    let _instruction_context = block_context.insn_ctxt(\"trans_struct\");\n     let mut block_context = block_context;\n     let type_context = block_context.ccx().tcx;\n \n@@ -3615,7 +3615,7 @@ fn trans_expr_save_in(bcx: block, e: @ast::expr, dest: ValueRef)\n // trans_expr_save_in. For intermediates where you don't care about lval-ness,\n // use trans_temp_expr.\n fn trans_temp_lval(bcx: block, e: @ast::expr) -> lval_result {\n-    let _icx = bcx.insn_ctxt(~\"trans_temp_lval\");\n+    let _icx = bcx.insn_ctxt(\"trans_temp_lval\");\n     let mut bcx = bcx;\n     if expr_is_lval(bcx, e) {\n         return trans_lval(bcx, e);\n@@ -3641,7 +3641,7 @@ fn trans_temp_lval(bcx: block, e: @ast::expr) -> lval_result {\n // Use only for intermediate values. See trans_expr and trans_expr_save_in for\n // expressions that must 'end up somewhere' (or get ignored).\n fn trans_temp_expr(bcx: block, e: @ast::expr) -> result {\n-    let _icx = bcx.insn_ctxt(~\"trans_temp_expr\");\n+    let _icx = bcx.insn_ctxt(\"trans_temp_expr\");\n     lval_result_to_result(trans_temp_lval(bcx, e), expr_ty(bcx, e))\n }\n \n@@ -3702,7 +3702,7 @@ fn add_root_cleanup(bcx: block, scope_id: ast::node_id,\n // - exprs returning nil or bot always get dest=ignore\n // - exprs with non-immediate type never get dest=by_val\n fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_expr\");\n+    let _icx = bcx.insn_ctxt(\"trans_expr\");\n     debuginfo::update_source_pos(bcx, e.span);\n \n     if expr_is_lval(bcx, e) {\n@@ -3724,7 +3724,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n                                   scope_id});\n         }\n \n-        let _icx = bcx.insn_ctxt(~\"root_value_expr\");\n+        let _icx = bcx.insn_ctxt(\"root_value_expr\");\n         add_root_cleanup(bcx, scope_id, root_loc, ty);\n         let lv = {bcx: bcx, val: root_loc, kind: lv_owned};\n         lval_result_to_dps(lv, ty, false, dest)\n@@ -3982,20 +3982,20 @@ fn do_spill_noroot(++cx: block, v: ValueRef) -> ValueRef {\n }\n \n fn spill_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"spill_if_immediate\");\n+    let _icx = cx.insn_ctxt(\"spill_if_immediate\");\n     if ty::type_is_immediate(t) { return do_spill(cx, v, t); }\n     return v;\n }\n \n fn load_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"load_if_immediate\");\n+    let _icx = cx.insn_ctxt(\"load_if_immediate\");\n     if ty::type_is_immediate(t) { return Load(cx, v); }\n     return v;\n }\n \n fn trans_log(log_ex: @ast::expr, lvl: @ast::expr,\n              bcx: block, e: @ast::expr) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_log\");\n+    let _icx = bcx.insn_ctxt(\"trans_log\");\n     let ccx = bcx.ccx();\n     if ty::type_is_bot(expr_ty(bcx, lvl)) {\n        return trans_expr(bcx, lvl, ignore);\n@@ -4046,7 +4046,7 @@ fn trans_log(log_ex: @ast::expr, lvl: @ast::expr,\n \n fn trans_check_expr(bcx: block, chk_expr: @ast::expr,\n                     pred_expr: @ast::expr, s: ~str) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_check_expr\");\n+    let _icx = bcx.insn_ctxt(\"trans_check_expr\");\n     let expr_str = s + ~\" \" + expr_to_str(pred_expr) + ~\" failed\";\n     let {bcx, val} = {\n         do with_scope_result(bcx, chk_expr.info(), ~\"check\") |bcx| {\n@@ -4060,7 +4060,7 @@ fn trans_check_expr(bcx: block, chk_expr: @ast::expr,\n \n fn trans_fail_expr(bcx: block, sp_opt: option<span>,\n                    fail_expr: option<@ast::expr>) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_fail_expr\");\n+    let _icx = bcx.insn_ctxt(\"trans_fail_expr\");\n     let mut bcx = bcx;\n     match fail_expr {\n       some(expr) => {\n@@ -4087,7 +4087,7 @@ fn trans_fail_expr(bcx: block, sp_opt: option<span>,\n \n fn trans_trace(bcx: block, sp_opt: option<span>, trace_str: ~str) {\n     if !bcx.sess().trace() { return; }\n-    let _icx = bcx.insn_ctxt(~\"trans_trace\");\n+    let _icx = bcx.insn_ctxt(\"trans_trace\");\n     add_comment(bcx, trace_str);\n     let V_trace_str = C_cstr(bcx.ccx(), trace_str);\n     let {V_filename, V_line} = match sp_opt {\n@@ -4111,14 +4111,14 @@ fn trans_trace(bcx: block, sp_opt: option<span>, trace_str: ~str) {\n \n fn trans_fail(bcx: block, sp_opt: option<span>, fail_str: ~str) ->\n     block {\n-    let _icx = bcx.insn_ctxt(~\"trans_fail\");\n+    let _icx = bcx.insn_ctxt(\"trans_fail\");\n     let V_fail_str = C_cstr(bcx.ccx(), fail_str);\n     return trans_fail_value(bcx, sp_opt, V_fail_str);\n }\n \n fn trans_fail_value(bcx: block, sp_opt: option<span>,\n                     V_fail_str: ValueRef) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_fail_value\");\n+    let _icx = bcx.insn_ctxt(\"trans_fail_value\");\n     let ccx = bcx.ccx();\n     let {V_filename, V_line} = match sp_opt {\n       some(sp) => {\n@@ -4157,7 +4157,7 @@ fn trans_rtcall(bcx: block, name: ~str, args: ~[ValueRef], dest: dest)\n \n fn trans_break_cont(bcx: block, to_end: bool)\n     -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_break_cont\");\n+    let _icx = bcx.insn_ctxt(\"trans_break_cont\");\n     // Locate closest loop block, outputting cleanup as we go.\n     let mut unwind = bcx;\n     let mut target;\n@@ -4198,7 +4198,7 @@ fn trans_cont(cx: block) -> block {\n }\n \n fn trans_ret(bcx: block, e: option<@ast::expr>) -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_ret\");\n+    let _icx = bcx.insn_ctxt(\"trans_ret\");\n     let mut bcx = bcx;\n     let retptr = match copy bcx.fcx.loop_ret {\n       some({flagptr, retptr}) => {\n@@ -4227,7 +4227,7 @@ fn trans_ret(bcx: block, e: option<@ast::expr>) -> block {\n }\n \n fn build_return(bcx: block) {\n-    let _icx = bcx.insn_ctxt(~\"build_return\");\n+    let _icx = bcx.insn_ctxt(\"build_return\");\n     Br(bcx, bcx.fcx.llreturn);\n }\n \n@@ -4238,7 +4238,7 @@ fn ignore_lhs(_bcx: block, local: @ast::local) -> bool {\n }\n \n fn init_local(bcx: block, local: @ast::local) -> block {\n-    let _icx = bcx.insn_ctxt(~\"init_local\");\n+    let _icx = bcx.insn_ctxt(\"init_local\");\n     let ty = node_id_type(bcx, local.node.id);\n \n     if ignore_lhs(bcx, local) {\n@@ -4277,7 +4277,7 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n }\n \n fn trans_stmt(cx: block, s: ast::stmt) -> block {\n-    let _icx = cx.insn_ctxt(~\"trans_stmt\");\n+    let _icx = cx.insn_ctxt(\"trans_stmt\");\n     debug!{\"trans_stmt(%s)\", stmt_to_str(s)};\n \n     if !cx.sess().no_asm_comments() {\n@@ -4384,7 +4384,7 @@ fn trans_block_cleanups(bcx: block, cleanup_cx: block) -> block {\n \n fn trans_block_cleanups_(bcx: block, cleanup_cx: block, is_lpad: bool) ->\n    block {\n-    let _icx = bcx.insn_ctxt(~\"trans_block_cleanups\");\n+    let _icx = bcx.insn_ctxt(\"trans_block_cleanups\");\n     if bcx.unreachable { return bcx; }\n     let mut bcx = bcx;\n     match check cleanup_cx.kind {\n@@ -4411,7 +4411,7 @@ fn trans_block_cleanups_(bcx: block, cleanup_cx: block, is_lpad: bool) ->\n // instruction.\n fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n                      leave: option<BasicBlockRef>) {\n-    let _icx = bcx.insn_ctxt(~\"cleanup_and_leave\");\n+    let _icx = bcx.insn_ctxt(\"cleanup_and_leave\");\n     let mut cur = bcx, bcx = bcx;\n     let is_lpad = leave == none;\n     loop {\n@@ -4454,12 +4454,12 @@ fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n \n fn cleanup_and_Br(bcx: block, upto: block,\n                   target: BasicBlockRef) {\n-    let _icx = bcx.insn_ctxt(~\"cleanup_and_Br\");\n+    let _icx = bcx.insn_ctxt(\"cleanup_and_Br\");\n     cleanup_and_leave(bcx, some(upto.llbb), some(target));\n }\n \n fn leave_block(bcx: block, out_of: block) -> block {\n-    let _icx = bcx.insn_ctxt(~\"leave_block\");\n+    let _icx = bcx.insn_ctxt(\"leave_block\");\n     let next_cx = sub_block(block_parent(out_of), ~\"next\");\n     if bcx.unreachable { Unreachable(next_cx); }\n     cleanup_and_Br(bcx, out_of, next_cx.llbb);\n@@ -4468,7 +4468,7 @@ fn leave_block(bcx: block, out_of: block) -> block {\n \n fn with_scope(bcx: block, opt_node_info: option<node_info>,\n               name: ~str, f: fn(block) -> block) -> block {\n-    let _icx = bcx.insn_ctxt(~\"with_scope\");\n+    let _icx = bcx.insn_ctxt(\"with_scope\");\n     let scope_cx = scope_block(bcx, opt_node_info, name);\n     Br(bcx, scope_cx.llbb);\n     leave_block(f(scope_cx), scope_cx)\n@@ -4477,15 +4477,15 @@ fn with_scope(bcx: block, opt_node_info: option<node_info>,\n fn with_scope_result(bcx: block, opt_node_info: option<node_info>,\n                      name: ~str, f: fn(block) -> result)\n     -> result {\n-    let _icx = bcx.insn_ctxt(~\"with_scope_result\");\n+    let _icx = bcx.insn_ctxt(\"with_scope_result\");\n     let scope_cx = scope_block(bcx, opt_node_info, name);\n     Br(bcx, scope_cx.llbb);\n     let {bcx, val} = f(scope_cx);\n     {bcx: leave_block(bcx, scope_cx), val: val}\n }\n \n fn with_cond(bcx: block, val: ValueRef, f: fn(block) -> block) -> block {\n-    let _icx = bcx.insn_ctxt(~\"with_cond\");\n+    let _icx = bcx.insn_ctxt(\"with_cond\");\n     let next_cx = sub_block(bcx, ~\"next\"), cond_cx = sub_block(bcx, ~\"cond\");\n     CondBr(bcx, val, cond_cx.llbb, next_cx.llbb);\n     let after_cx = f(cond_cx);\n@@ -4510,7 +4510,7 @@ fn block_locals(b: ast::blk, it: fn(@ast::local)) {\n }\n \n fn alloc_ty(bcx: block, t: ty::t) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(~\"alloc_ty\");\n+    let _icx = bcx.insn_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let llty = type_of(ccx, t);\n     if ty::type_has_params(t) { log(error, ppaux::ty_to_str(ccx.tcx, t)); }\n@@ -4520,7 +4520,7 @@ fn alloc_ty(bcx: block, t: ty::t) -> ValueRef {\n }\n \n fn alloc_local(cx: block, local: @ast::local) -> block {\n-    let _icx = cx.insn_ctxt(~\"alloc_local\");\n+    let _icx = cx.insn_ctxt(\"alloc_local\");\n     let t = node_id_type(cx, local.node.id);\n     let simple_name = match local.node.pat.node {\n       ast::pat_ident(_, pth, none) => some(path_to_ident(pth)),\n@@ -4540,7 +4540,7 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n \n fn trans_block(bcx: block, b: ast::blk, dest: dest)\n     -> block {\n-    let _icx = bcx.insn_ctxt(~\"trans_block\");\n+    let _icx = bcx.insn_ctxt(\"trans_block\");\n     let mut bcx = bcx;\n     do block_locals(b) |local| { bcx = alloc_local(bcx, local); };\n     for vec::each(b.node.stmts) |s| {\n@@ -4622,7 +4622,7 @@ fn new_fn_ctxt(ccx: @crate_ctxt, path: path, llfndecl: ValueRef,\n fn create_llargs_for_fn_args(cx: fn_ctxt,\n                              ty_self: self_arg,\n                              args: ~[ast::arg]) {\n-    let _icx = cx.insn_ctxt(~\"create_llargs_for_fn_args\");\n+    let _icx = cx.insn_ctxt(\"create_llargs_for_fn_args\");\n     // Skip the implicit arguments 0, and 1.\n     let mut arg_n = first_real_arg;\n     match ty_self {\n@@ -4647,7 +4647,7 @@ fn create_llargs_for_fn_args(cx: fn_ctxt,\n \n fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: ~[ast::arg],\n                         arg_tys: ~[ty::arg]) -> block {\n-    let _icx = fcx.insn_ctxt(~\"copy_args_to_allocas\");\n+    let _icx = fcx.insn_ctxt(\"copy_args_to_allocas\");\n     let tcx = bcx.tcx();\n     let mut arg_n: uint = 0u, bcx = bcx;\n     let epic_fail = fn@() -> ! {\n@@ -4685,14 +4685,14 @@ fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: ~[ast::arg],\n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n fn finish_fn(fcx: fn_ctxt, lltop: BasicBlockRef) {\n-    let _icx = fcx.insn_ctxt(~\"finish_fn\");\n+    let _icx = fcx.insn_ctxt(\"finish_fn\");\n     tie_up_header_blocks(fcx, lltop);\n     let ret_cx = raw_block(fcx, false, fcx.llreturn);\n     RetVoid(ret_cx);\n }\n \n fn tie_up_header_blocks(fcx: fn_ctxt, lltop: BasicBlockRef) {\n-    let _icx = fcx.insn_ctxt(~\"tie_up_header_blocks\");\n+    let _icx = fcx.insn_ctxt(\"tie_up_header_blocks\");\n     Br(raw_block(fcx, false, fcx.llstaticallocas), fcx.llloadenv);\n     Br(raw_block(fcx, false, fcx.llloadenv), lltop);\n }\n@@ -4709,7 +4709,7 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n                  id: ast::node_id,\n                  maybe_load_env: fn(fn_ctxt),\n                  finish: fn(block)) {\n-    let _icx = ccx.insn_ctxt(~\"trans_closure\");\n+    let _icx = ccx.insn_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);\n \n     // Set up arguments to the function.\n@@ -4765,7 +4765,7 @@ fn trans_fn(ccx: @crate_ctxt,\n     let do_time = ccx.sess.trans_stats();\n     let start = if do_time { time::get_time() }\n                 else { {sec: 0i64, nsec: 0i32} };\n-    let _icx = ccx.insn_ctxt(~\"trans_fn\");\n+    let _icx = ccx.insn_ctxt(\"trans_fn\");\n     trans_closure(ccx, path, decl, body, llfndecl, ty_self,\n                   param_substs, id,\n                   |fcx| {\n@@ -4787,7 +4787,7 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n                       disr: int, is_degen: bool,\n                       param_substs: option<param_substs>,\n                       llfndecl: ValueRef) {\n-    let _icx = ccx.insn_ctxt(~\"trans_enum_variant\");\n+    let _icx = ccx.insn_ctxt(\"trans_enum_variant\");\n     // Translate variant arguments to function arguments.\n     let fn_args = vec::map(args, |varg|\n         {mode: ast::expl(ast::by_copy),\n@@ -4968,7 +4968,7 @@ fn trans_enum_def(ccx: @crate_ctxt, enum_definition: ast::enum_def,\n }\n \n fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n-    let _icx = ccx.insn_ctxt(~\"trans_item\");\n+    let _icx = ccx.insn_ctxt(\"trans_item\");\n     let path = match check ccx.tcx.items.get(item.id) {\n       ast_map::node_item(_, p) => p\n     };\n@@ -5068,7 +5068,7 @@ fn trans_trait(ccx: @crate_ctxt, tps: ~[ast::ty_param],\n // only as a convenience for humans working with the code, to organize names\n // and control visibility.\n fn trans_mod(ccx: @crate_ctxt, m: ast::_mod) {\n-    let _icx = ccx.insn_ctxt(~\"trans_mod\");\n+    let _icx = ccx.insn_ctxt(\"trans_mod\");\n     for vec::each(m.items) |item| { trans_item(ccx, *item); }\n }\n \n@@ -5375,7 +5375,7 @@ fn trans_method(ccx: @crate_ctxt, id: ast::node_id, pth: @ast_map::path,\n \n // The constant translation pass.\n fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n-    let _icx = ccx.insn_ctxt(~\"trans_constant\");\n+    let _icx = ccx.insn_ctxt(\"trans_constant\");\n     match it.node {\n       ast::item_enum(enum_definition, _) => {\n         let vi = ty::enum_variants(ccx.tcx, {crate: ast::local_crate,\n@@ -5814,12 +5814,12 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n     gather_rtcalls(ccx, crate);\n \n     {\n-        let _icx = ccx.insn_ctxt(~\"data\");\n+        let _icx = ccx.insn_ctxt(\"data\");\n         trans_constants(ccx, crate);\n     }\n \n     {\n-        let _icx = ccx.insn_ctxt(~\"text\");\n+        let _icx = ccx.insn_ctxt(\"text\");\n         trans_mod(ccx, crate.node.module);\n     }\n "}, {"sha": "915be95c6cafb9c295b49118cab013c2a1c2dfe6", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 93, "deletions": 93, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -15,7 +15,7 @@ fn B(cx: block) -> BuilderRef {\n     return b;\n }\n \n-fn count_insn(cx: block, category: ~str) {\n+fn count_insn(cx: block, category: &str) {\n     if cx.ccx().sess.count_llvm_insns() {\n \n         let h = cx.ccx().stats.llvm_insns;\n@@ -70,15 +70,15 @@ fn RetVoid(cx: block) {\n     if cx.unreachable { return; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    count_insn(cx, ~\"retvoid\");\n+    count_insn(cx, \"retvoid\");\n     llvm::LLVMBuildRetVoid(B(cx));\n }\n \n fn Ret(cx: block, V: ValueRef) {\n     if cx.unreachable { return; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    count_insn(cx, ~\"ret\");\n+    count_insn(cx, \"ret\");\n     llvm::LLVMBuildRet(B(cx), V);\n }\n \n@@ -96,7 +96,7 @@ fn Br(cx: block, Dest: BasicBlockRef) {\n     if cx.unreachable { return; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    count_insn(cx, ~\"br\");\n+    count_insn(cx, \"br\");\n     llvm::LLVMBuildBr(B(cx), Dest);\n }\n \n@@ -105,7 +105,7 @@ fn CondBr(cx: block, If: ValueRef, Then: BasicBlockRef,\n     if cx.unreachable { return; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    count_insn(cx, ~\"condbr\");\n+    count_insn(cx, \"condbr\");\n     llvm::LLVMBuildCondBr(B(cx), If, Then, Else);\n }\n \n@@ -126,7 +126,7 @@ fn IndirectBr(cx: block, Addr: ValueRef, NumDests: uint) {\n     if cx.unreachable { return; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    count_insn(cx, ~\"indirectbr\");\n+    count_insn(cx, \"indirectbr\");\n     llvm::LLVMBuildIndirectBr(B(cx), Addr, NumDests as c_uint);\n }\n \n@@ -147,7 +147,7 @@ fn Invoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n            str::connect(vec::map(Args, |a| val_str(cx.ccx().tn, a)),\n                         ~\", \")};\n     unsafe {\n-        count_insn(cx, ~\"invoke\");\n+        count_insn(cx, \"invoke\");\n         llvm::LLVMBuildInvoke(B(cx), Fn, vec::unsafe::to_ptr(Args),\n                               Args.len() as c_uint, Then, Catch,\n                               noname());\n@@ -160,7 +160,7 @@ fn FastInvoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n     assert (!cx.terminated);\n     cx.terminated = true;\n     unsafe {\n-        count_insn(cx, ~\"fastinvoke\");\n+        count_insn(cx, \"fastinvoke\");\n         let v = llvm::LLVMBuildInvoke(B(cx), Fn, vec::unsafe::to_ptr(Args),\n                                       Args.len() as c_uint,\n                                       Then, Catch, noname());\n@@ -172,7 +172,7 @@ fn Unreachable(cx: block) {\n     if cx.unreachable { return; }\n     cx.unreachable = true;\n     if !cx.terminated {\n-        count_insn(cx, ~\"unreachable\");\n+        count_insn(cx, \"unreachable\");\n         llvm::LLVMBuildUnreachable(B(cx));\n     }\n }\n@@ -184,218 +184,218 @@ fn _Undef(val: ValueRef) -> ValueRef {\n /* Arithmetic */\n fn Add(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"add\");\n+    count_insn(cx, \"add\");\n     return llvm::LLVMBuildAdd(B(cx), LHS, RHS, noname());\n }\n \n fn NSWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"nswadd\");\n+    count_insn(cx, \"nswadd\");\n     return llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, noname());\n }\n \n fn NUWAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"nuwadd\");\n+    count_insn(cx, \"nuwadd\");\n     return llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, noname());\n }\n \n fn FAdd(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"fadd\");\n+    count_insn(cx, \"fadd\");\n     return llvm::LLVMBuildFAdd(B(cx), LHS, RHS, noname());\n }\n \n fn Sub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"sub\");\n+    count_insn(cx, \"sub\");\n     return llvm::LLVMBuildSub(B(cx), LHS, RHS, noname());\n }\n \n fn NSWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"nwsub\");\n+    count_insn(cx, \"nwsub\");\n     return llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, noname());\n }\n \n fn NUWSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"nuwsub\");\n+    count_insn(cx, \"nuwsub\");\n     return llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, noname());\n }\n \n fn FSub(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"sub\");\n+    count_insn(cx, \"sub\");\n     return llvm::LLVMBuildFSub(B(cx), LHS, RHS, noname());\n }\n \n fn Mul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"mul\");\n+    count_insn(cx, \"mul\");\n     return llvm::LLVMBuildMul(B(cx), LHS, RHS, noname());\n }\n \n fn NSWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"nswmul\");\n+    count_insn(cx, \"nswmul\");\n     return llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, noname());\n }\n \n fn NUWMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"nuwmul\");\n+    count_insn(cx, \"nuwmul\");\n     return llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, noname());\n }\n \n fn FMul(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"fmul\");\n+    count_insn(cx, \"fmul\");\n     return llvm::LLVMBuildFMul(B(cx), LHS, RHS, noname());\n }\n \n fn UDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"udiv\");\n+    count_insn(cx, \"udiv\");\n     return llvm::LLVMBuildUDiv(B(cx), LHS, RHS, noname());\n }\n \n fn SDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"sdiv\");\n+    count_insn(cx, \"sdiv\");\n     return llvm::LLVMBuildSDiv(B(cx), LHS, RHS, noname());\n }\n \n fn ExactSDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"extractsdiv\");\n+    count_insn(cx, \"extractsdiv\");\n     return llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, noname());\n }\n \n fn FDiv(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"fdiv\");\n+    count_insn(cx, \"fdiv\");\n     return llvm::LLVMBuildFDiv(B(cx), LHS, RHS, noname());\n }\n \n fn URem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"urem\");\n+    count_insn(cx, \"urem\");\n     return llvm::LLVMBuildURem(B(cx), LHS, RHS, noname());\n }\n \n fn SRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"srem\");\n+    count_insn(cx, \"srem\");\n     return llvm::LLVMBuildSRem(B(cx), LHS, RHS, noname());\n }\n \n fn FRem(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"frem\");\n+    count_insn(cx, \"frem\");\n     return llvm::LLVMBuildFRem(B(cx), LHS, RHS, noname());\n }\n \n fn Shl(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"shl\");\n+    count_insn(cx, \"shl\");\n     return llvm::LLVMBuildShl(B(cx), LHS, RHS, noname());\n }\n \n fn LShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"lshr\");\n+    count_insn(cx, \"lshr\");\n     return llvm::LLVMBuildLShr(B(cx), LHS, RHS, noname());\n }\n \n fn AShr(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"ashr\");\n+    count_insn(cx, \"ashr\");\n     return llvm::LLVMBuildAShr(B(cx), LHS, RHS, noname());\n }\n \n fn And(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"and\");\n+    count_insn(cx, \"and\");\n     return llvm::LLVMBuildAnd(B(cx), LHS, RHS, noname());\n }\n \n fn Or(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"or\");\n+    count_insn(cx, \"or\");\n     return llvm::LLVMBuildOr(B(cx), LHS, RHS, noname());\n }\n \n fn Xor(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"xor\");\n+    count_insn(cx, \"xor\");\n     return llvm::LLVMBuildXor(B(cx), LHS, RHS, noname());\n }\n \n fn BinOp(cx: block, Op: Opcode, LHS: ValueRef, RHS: ValueRef) ->\n    ValueRef {\n     if cx.unreachable { return _Undef(LHS); }\n-    count_insn(cx, ~\"binop\");\n+    count_insn(cx, \"binop\");\n     return llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, noname());\n }\n \n fn Neg(cx: block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n-    count_insn(cx, ~\"neg\");\n+    count_insn(cx, \"neg\");\n     return llvm::LLVMBuildNeg(B(cx), V, noname());\n }\n \n fn NSWNeg(cx: block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n-    count_insn(cx, ~\"nswneg\");\n+    count_insn(cx, \"nswneg\");\n     return llvm::LLVMBuildNSWNeg(B(cx), V, noname());\n }\n \n fn NUWNeg(cx: block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n-    count_insn(cx, ~\"nuwneg\");\n+    count_insn(cx, \"nuwneg\");\n     return llvm::LLVMBuildNUWNeg(B(cx), V, noname());\n }\n fn FNeg(cx: block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n-    count_insn(cx, ~\"fneg\");\n+    count_insn(cx, \"fneg\");\n     return llvm::LLVMBuildFNeg(B(cx), V, noname());\n }\n \n fn Not(cx: block, V: ValueRef) -> ValueRef {\n     if cx.unreachable { return _Undef(V); }\n-    count_insn(cx, ~\"not\");\n+    count_insn(cx, \"not\");\n     return llvm::LLVMBuildNot(B(cx), V, noname());\n }\n \n /* Memory */\n fn Malloc(cx: block, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    count_insn(cx, ~\"malloc\");\n+    count_insn(cx, \"malloc\");\n     return llvm::LLVMBuildMalloc(B(cx), Ty, noname());\n }\n \n fn ArrayMalloc(cx: block, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    count_insn(cx, ~\"arraymalloc\");\n+    count_insn(cx, \"arraymalloc\");\n     return llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, noname());\n }\n \n fn Alloca(cx: block, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(Ty)); }\n-    count_insn(cx, ~\"alloca\");\n+    count_insn(cx, \"alloca\");\n     return llvm::LLVMBuildAlloca(B(cx), Ty, noname());\n }\n \n fn ArrayAlloca(cx: block, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(Ty)); }\n-    count_insn(cx, ~\"arrayalloca\");\n+    count_insn(cx, \"arrayalloca\");\n     return llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, noname());\n }\n \n fn Free(cx: block, PointerVal: ValueRef) {\n     if cx.unreachable { return; }\n-    count_insn(cx, ~\"free\");\n+    count_insn(cx, \"free\");\n     llvm::LLVMBuildFree(B(cx), PointerVal);\n }\n \n@@ -407,7 +407,7 @@ fn Load(cx: block, PointerVal: ValueRef) -> ValueRef {\n             llvm::LLVMGetElementType(ty) } else { ccx.int_type };\n         return llvm::LLVMGetUndef(eltty);\n     }\n-    count_insn(cx, ~\"load\");\n+    count_insn(cx, \"load\");\n     return llvm::LLVMBuildLoad(B(cx), PointerVal, noname());\n }\n \n@@ -416,14 +416,14 @@ fn Store(cx: block, Val: ValueRef, Ptr: ValueRef) {\n     debug!{\"Store %s -> %s\",\n            val_str(cx.ccx().tn, Val),\n            val_str(cx.ccx().tn, Ptr)};\n-    count_insn(cx, ~\"store\");\n+    count_insn(cx, \"store\");\n     llvm::LLVMBuildStore(B(cx), Val, Ptr);\n }\n \n fn GEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n-    count_insn(cx, ~\"gep\");\n+    count_insn(cx, \"gep\");\n     return llvm::LLVMBuildGEP(B(cx), Pointer, vec::unsafe::to_ptr(Indices),\n                                Indices.len() as c_uint, noname());\n     }\n@@ -434,15 +434,15 @@ fn GEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) -> ValueRef {\n fn GEPi(cx: block, base: ValueRef, ixs: ~[uint]) -> ValueRef {\n     let mut v: ~[ValueRef] = ~[];\n     for vec::each(ixs) |i| { vec::push(v, C_i32(i as i32)); }\n-    count_insn(cx, ~\"gepi\");\n+    count_insn(cx, \"gepi\");\n     return InBoundsGEP(cx, base, v);\n }\n \n fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) ->\n    ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n-        count_insn(cx, ~\"inboundsgep\");\n+        count_insn(cx, \"inboundsgep\");\n     return llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n                                        vec::unsafe::to_ptr(Indices),\n                                        Indices.len() as c_uint,\n@@ -452,138 +452,138 @@ fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) ->\n \n fn StructGEP(cx: block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n-    count_insn(cx, ~\"structgep\");\n+    count_insn(cx, \"structgep\");\n     return llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx as c_uint, noname());\n }\n \n fn GlobalString(cx: block, _Str: *libc::c_char) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    count_insn(cx, ~\"globalstring\");\n+    count_insn(cx, \"globalstring\");\n     return llvm::LLVMBuildGlobalString(B(cx), _Str, noname());\n }\n \n fn GlobalStringPtr(cx: block, _Str: *libc::c_char) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    count_insn(cx, ~\"globalstringptr\");\n+    count_insn(cx, \"globalstringptr\");\n     return llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, noname());\n }\n \n /* Casts */\n fn Trunc(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"trunc\");\n+    count_insn(cx, \"trunc\");\n     return llvm::LLVMBuildTrunc(B(cx), Val, DestTy, noname());\n }\n \n fn ZExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"zext\");\n+    count_insn(cx, \"zext\");\n     return llvm::LLVMBuildZExt(B(cx), Val, DestTy, noname());\n }\n \n fn SExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"sext\");\n+    count_insn(cx, \"sext\");\n     return llvm::LLVMBuildSExt(B(cx), Val, DestTy, noname());\n }\n \n fn FPToUI(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"fptoui\");\n+    count_insn(cx, \"fptoui\");\n     return llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, noname());\n }\n \n fn FPToSI(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"fptosi\");\n+    count_insn(cx, \"fptosi\");\n     return llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, noname());\n }\n \n fn UIToFP(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"uitofp\");\n+    count_insn(cx, \"uitofp\");\n     return llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, noname());\n }\n \n fn SIToFP(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"sitofp\");\n+    count_insn(cx, \"sitofp\");\n     return llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, noname());\n }\n \n fn FPTrunc(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"fptrunc\");\n+    count_insn(cx, \"fptrunc\");\n     return llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, noname());\n }\n \n fn FPExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"fpext\");\n+    count_insn(cx, \"fpext\");\n     return llvm::LLVMBuildFPExt(B(cx), Val, DestTy, noname());\n }\n \n fn PtrToInt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"ptrtoint\");\n+    count_insn(cx, \"ptrtoint\");\n     return llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, noname());\n }\n \n fn IntToPtr(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"inttoptr\");\n+    count_insn(cx, \"inttoptr\");\n     return llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, noname());\n }\n \n fn BitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"bitcast\");\n+    count_insn(cx, \"bitcast\");\n     return llvm::LLVMBuildBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn ZExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"zextorbitcast\");\n+    count_insn(cx, \"zextorbitcast\");\n     return llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn SExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"sextorbitcast\");\n+    count_insn(cx, \"sextorbitcast\");\n     return llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn TruncOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"truncorbitcast\");\n+    count_insn(cx, \"truncorbitcast\");\n     return llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, noname());\n }\n \n fn Cast(cx: block, Op: Opcode, Val: ValueRef, DestTy: TypeRef,\n         _Name: *u8) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"cast\");\n+    count_insn(cx, \"cast\");\n     return llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, noname());\n }\n \n fn PointerCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"pointercast\");\n+    count_insn(cx, \"pointercast\");\n     return llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, noname());\n }\n \n fn IntCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"intcast\");\n+    count_insn(cx, \"intcast\");\n     return llvm::LLVMBuildIntCast(B(cx), Val, DestTy, noname());\n }\n \n fn FPCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n-    count_insn(cx, ~\"fpcast\");\n+    count_insn(cx, \"fpcast\");\n     return llvm::LLVMBuildFPCast(B(cx), Val, DestTy, noname());\n }\n \n@@ -592,21 +592,21 @@ fn FPCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n fn ICmp(cx: block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n     -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n-    count_insn(cx, ~\"icmp\");\n+    count_insn(cx, \"icmp\");\n     return llvm::LLVMBuildICmp(B(cx), Op as c_uint, LHS, RHS, noname());\n }\n \n fn FCmp(cx: block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n     -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n-    count_insn(cx, ~\"fcmp\");\n+    count_insn(cx, \"fcmp\");\n     return llvm::LLVMBuildFCmp(B(cx), Op as c_uint, LHS, RHS, noname());\n }\n \n /* Miscellaneous instructions */\n fn EmptyPhi(cx: block, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n-    count_insn(cx, ~\"emptyphi\");\n+    count_insn(cx, \"emptyphi\");\n     return llvm::LLVMBuildPhi(B(cx), Ty, noname());\n }\n \n@@ -616,7 +616,7 @@ fn Phi(cx: block, Ty: TypeRef, vals: ~[ValueRef], bbs: ~[BasicBlockRef])\n     assert vals.len() == bbs.len();\n     let phi = EmptyPhi(cx, Ty);\n     unsafe {\n-        count_insn(cx, ~\"addincoming\");\n+        count_insn(cx, \"addincoming\");\n         llvm::LLVMAddIncoming(phi, vec::unsafe::to_ptr(vals),\n                               vec::unsafe::to_ptr(bbs),\n                               vals.len() as c_uint);\n@@ -671,7 +671,7 @@ fn add_comment(bcx: block, text: ~str) {\n fn Call(cx: block, Fn: ValueRef, Args: ~[ValueRef]) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n     unsafe {\n-        count_insn(cx, ~\"call\");\n+        count_insn(cx, \"call\");\n \n         debug!{\"Call(Fn=%s, Args=%?)\",\n                val_str(cx.ccx().tn, Fn),\n@@ -685,7 +685,7 @@ fn Call(cx: block, Fn: ValueRef, Args: ~[ValueRef]) -> ValueRef {\n fn FastCall(cx: block, Fn: ValueRef, Args: ~[ValueRef]) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n     unsafe {\n-        count_insn(cx, ~\"fastcall\");\n+        count_insn(cx, \"fastcall\");\n         let v = llvm::LLVMBuildCall(B(cx), Fn, vec::unsafe::to_ptr(Args),\n                                     Args.len() as c_uint, noname());\n         lib::llvm::SetInstructionCallConv(v, lib::llvm::FastCallConv);\n@@ -697,7 +697,7 @@ fn CallWithConv(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n                 Conv: CallConv) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n     unsafe {\n-        count_insn(cx, ~\"callwithconv\");\n+        count_insn(cx, \"callwithconv\");\n         let v = llvm::LLVMBuildCall(B(cx), Fn, vec::unsafe::to_ptr(Args),\n                                     Args.len() as c_uint, noname());\n         lib::llvm::SetInstructionCallConv(v, Conv);\n@@ -708,68 +708,68 @@ fn CallWithConv(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n fn Select(cx: block, If: ValueRef, Then: ValueRef, Else: ValueRef) ->\n    ValueRef {\n     if cx.unreachable { return _Undef(Then); }\n-    count_insn(cx, ~\"select\");\n+    count_insn(cx, \"select\");\n     return llvm::LLVMBuildSelect(B(cx), If, Then, Else, noname());\n }\n \n fn VAArg(cx: block, list: ValueRef, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n-    count_insn(cx, ~\"vaarg\");\n+    count_insn(cx, \"vaarg\");\n     return llvm::LLVMBuildVAArg(B(cx), list, Ty, noname());\n }\n \n fn ExtractElement(cx: block, VecVal: ValueRef, Index: ValueRef) ->\n    ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n-    count_insn(cx, ~\"extractelement\");\n+    count_insn(cx, \"extractelement\");\n     return llvm::LLVMBuildExtractElement(B(cx), VecVal, Index, noname());\n }\n \n fn InsertElement(cx: block, VecVal: ValueRef, EltVal: ValueRef,\n                  Index: ValueRef) {\n     if cx.unreachable { return; }\n-    count_insn(cx, ~\"insertelement\");\n+    count_insn(cx, \"insertelement\");\n     llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index, noname());\n }\n \n fn ShuffleVector(cx: block, V1: ValueRef, V2: ValueRef,\n                  Mask: ValueRef) {\n     if cx.unreachable { return; }\n-    count_insn(cx, ~\"shufflevector\");\n+    count_insn(cx, \"shufflevector\");\n     llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, noname());\n }\n \n fn ExtractValue(cx: block, AggVal: ValueRef, Index: uint) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n-    count_insn(cx, ~\"extractvalue\");\n+    count_insn(cx, \"extractvalue\");\n     return llvm::LLVMBuildExtractValue(\n         B(cx), AggVal, Index as c_uint, noname());\n }\n \n fn InsertValue(cx: block, AggVal: ValueRef, EltVal: ValueRef,\n                Index: uint) {\n     if cx.unreachable { return; }\n-    count_insn(cx, ~\"insertvalue\");\n+    count_insn(cx, \"insertvalue\");\n     llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal, Index as c_uint,\n                                noname());\n }\n \n fn IsNull(cx: block, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n-    count_insn(cx, ~\"isnull\");\n+    count_insn(cx, \"isnull\");\n     return llvm::LLVMBuildIsNull(B(cx), Val, noname());\n }\n \n fn IsNotNull(cx: block, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n-    count_insn(cx, ~\"isnotnull\");\n+    count_insn(cx, \"isnotnull\");\n     return llvm::LLVMBuildIsNotNull(B(cx), Val, noname());\n }\n \n fn PtrDiff(cx: block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let ccx = cx.fcx.ccx;\n     if cx.unreachable { return llvm::LLVMGetUndef(ccx.int_type); }\n-    count_insn(cx, ~\"ptrdiff\");\n+    count_insn(cx, \"ptrdiff\");\n     return llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, noname());\n }\n \n@@ -785,7 +785,7 @@ fn Trap(cx: block) {\n     assert (T as int != 0);\n     let Args: ~[ValueRef] = ~[];\n     unsafe {\n-        count_insn(cx, ~\"trap\");\n+        count_insn(cx, \"trap\");\n         llvm::LLVMBuildCall(b, T, vec::unsafe::to_ptr(Args),\n                             Args.len() as c_uint, noname());\n     }\n@@ -794,20 +794,20 @@ fn Trap(cx: block) {\n fn LandingPad(cx: block, Ty: TypeRef, PersFn: ValueRef,\n               NumClauses: uint) -> ValueRef {\n     assert !cx.terminated && !cx.unreachable;\n-    count_insn(cx, ~\"landingpad\");\n+    count_insn(cx, \"landingpad\");\n     return llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn,\n                                   NumClauses as c_uint, noname());\n }\n \n fn SetCleanup(cx: block, LandingPad: ValueRef) {\n-    count_insn(cx, ~\"setcleanup\");\n+    count_insn(cx, \"setcleanup\");\n     llvm::LLVMSetCleanup(LandingPad, lib::llvm::True);\n }\n \n fn Resume(cx: block, Exn: ValueRef) -> ValueRef {\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    count_insn(cx, ~\"resume\");\n+    count_insn(cx, \"resume\");\n     return llvm::LLVMBuildResume(B(cx), Exn);\n }\n "}, {"sha": "9e5bdc1964c3f023b03086224569c5ac2ce8b20a", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -137,11 +137,11 @@ fn allocate_cbox(bcx: block,\n                  ck: ty::closure_kind,\n                  cdata_ty: ty::t)\n     -> result {\n-    let _icx = bcx.insn_ctxt(~\"closure::allocate_cbox\");\n+    let _icx = bcx.insn_ctxt(\"closure::allocate_cbox\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n     fn nuke_ref_count(bcx: block, llbox: ValueRef) {\n-        let _icx = bcx.insn_ctxt(~\"closure::nuke_ref_count\");\n+        let _icx = bcx.insn_ctxt(\"closure::nuke_ref_count\");\n         // Initialize ref count to arbitrary value for debugging:\n         let ccx = bcx.ccx();\n         let llbox = PointerCast(bcx, llbox, T_opaque_box_ptr(ccx));\n@@ -178,7 +178,7 @@ type closure_result = {\n fn store_environment(bcx: block,\n                      bound_values: ~[environment_value],\n                      ck: ty::closure_kind) -> closure_result {\n-    let _icx = bcx.insn_ctxt(~\"closure::store_environment\");\n+    let _icx = bcx.insn_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n     // compute the shape of the closure\n@@ -251,7 +251,7 @@ fn build_closure(bcx0: block,\n                  ck: ty::closure_kind,\n                  id: ast::node_id,\n                  include_ret_handle: option<ValueRef>) -> closure_result {\n-    let _icx = bcx0.insn_ctxt(~\"closure::build_closure\");\n+    let _icx = bcx0.insn_ctxt(\"closure::build_closure\");\n     // If we need to, package up the iterator body to call\n     let mut env_vals = ~[];\n     let mut bcx = bcx0;\n@@ -312,7 +312,7 @@ fn load_environment(fcx: fn_ctxt,\n                     cap_vars: ~[capture::capture_var],\n                     load_ret_handle: bool,\n                     ck: ty::closure_kind) {\n-    let _icx = fcx.insn_ctxt(~\"closure::load_environment\");\n+    let _icx = fcx.insn_ctxt(\"closure::load_environment\");\n     let bcx = raw_block(fcx, false, fcx.llloadenv);\n \n     // Load a pointer to the closure data, skipping over the box header:\n@@ -354,7 +354,7 @@ fn trans_expr_fn(bcx: block,\n                  cap_clause: ast::capture_clause,\n                  is_loop_body: option<option<ValueRef>>,\n                  dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(~\"closure::trans_expr_fn\");\n+    let _icx = bcx.insn_ctxt(\"closure::trans_expr_fn\");\n     if dest == ignore { return bcx; }\n     let ccx = bcx.ccx();\n     let fty = node_id_type(bcx, id);\n@@ -407,7 +407,7 @@ fn make_fn_glue(\n     t: ty::t,\n     glue_fn: fn@(block, v: ValueRef, t: ty::t) -> block)\n     -> block {\n-    let _icx = cx.insn_ctxt(~\"closure::make_fn_glue\");\n+    let _icx = cx.insn_ctxt(\"closure::make_fn_glue\");\n     let bcx = cx;\n     let tcx = cx.tcx();\n \n@@ -439,7 +439,7 @@ fn make_opaque_cbox_take_glue(\n     cboxptr: ValueRef)     // ptr to ptr to the opaque closure\n     -> block {\n     // Easy cases:\n-    let _icx = bcx.insn_ctxt(~\"closure::make_opaque_cbox_take_glue\");\n+    let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_take_glue\");\n     match ck {\n       ty::ck_block => return bcx,\n       ty::ck_box => {\n@@ -491,7 +491,7 @@ fn make_opaque_cbox_drop_glue(\n     ck: ty::closure_kind,\n     cboxptr: ValueRef)     // ptr to the opaque closure\n     -> block {\n-    let _icx = bcx.insn_ctxt(~\"closure::make_opaque_cbox_drop_glue\");\n+    let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_drop_glue\");\n     match ck {\n       ty::ck_block => bcx,\n       ty::ck_box => {\n@@ -510,7 +510,7 @@ fn make_opaque_cbox_free_glue(\n     ck: ty::closure_kind,\n     cbox: ValueRef)     // ptr to ptr to the opaque closure\n     -> block {\n-    let _icx = bcx.insn_ctxt(~\"closure::make_opaque_cbox_free_glue\");\n+    let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_free_glue\");\n     match ck {\n       ty::ck_block => return bcx,\n       ty::ck_box | ty::ck_uniq => { /* hard cases: */ }"}, {"sha": "51b16fd19c826457f9a6b06ef22b7b26fe955273", "filename": "src/rustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -4,7 +4,7 @@ import base::get_insn_ctxt;\n \n fn const_lit(cx: @crate_ctxt, e: @ast::expr, lit: ast::lit)\n     -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"trans_lit\");\n+    let _icx = cx.insn_ctxt(\"trans_lit\");\n     match lit.node {\n       ast::lit_int(i, t) => C_integral(T_int_ty(cx, t), i as u64, True),\n       ast::lit_uint(u, t) => C_integral(T_uint_ty(cx, t), u, False),\n@@ -82,7 +82,7 @@ fn const_autoderef(cx: @crate_ctxt, ty: ty::t, v: ValueRef)\n \n \n fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n-    let _icx = cx.insn_ctxt(~\"const_expr\");\n+    let _icx = cx.insn_ctxt(\"const_expr\");\n     match e.node {\n       ast::expr_lit(lit) => consts::const_lit(cx, e, *lit),\n       ast::expr_binary(b, e1, e2) => {\n@@ -366,7 +366,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n }\n \n fn trans_const(ccx: @crate_ctxt, e: @ast::expr, id: ast::node_id) {\n-    let _icx = ccx.insn_ctxt(~\"trans_const\");\n+    let _icx = ccx.insn_ctxt(\"trans_const\");\n     let v = const_expr(ccx, e);\n \n     // The scalars come back as 1st class LLVM vals"}, {"sha": "6df5a00f21d804a35731d8fd2aa6522f778e71b4", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -511,7 +511,7 @@ fn build_wrap_fn_(ccx: @crate_ctxt,\n                   arg_builder: wrap_arg_builder,\n                   ret_builder: wrap_ret_builder) {\n \n-    let _icx = ccx.insn_ctxt(~\"foreign::build_wrap_fn_\");\n+    let _icx = ccx.insn_ctxt(\"foreign::build_wrap_fn_\");\n     let fcx = new_fn_ctxt(ccx, ~[], llwrapfn, none);\n     let bcx = top_scope_block(fcx, none);\n     let lltop = bcx.llbb;\n@@ -571,18 +571,18 @@ fn build_wrap_fn_(ccx: @crate_ctxt,\n fn trans_foreign_mod(ccx: @crate_ctxt,\n                     foreign_mod: ast::foreign_mod, abi: ast::foreign_abi) {\n \n-    let _icx = ccx.insn_ctxt(~\"foreign::trans_foreign_mod\");\n+    let _icx = ccx.insn_ctxt(\"foreign::trans_foreign_mod\");\n \n     fn build_shim_fn(ccx: @crate_ctxt,\n                      foreign_item: @ast::foreign_item,\n                      tys: @c_stack_tys,\n                      cc: lib::llvm::CallConv) -> ValueRef {\n \n-        let _icx = ccx.insn_ctxt(~\"foreign::build_shim_fn\");\n+        let _icx = ccx.insn_ctxt(\"foreign::build_shim_fn\");\n \n         fn build_args(bcx: block, tys: @c_stack_tys,\n                       llargbundle: ValueRef) -> ~[ValueRef] {\n-            let _icx = bcx.insn_ctxt(~\"foreign::shim::build_args\");\n+            let _icx = bcx.insn_ctxt(\"foreign::shim::build_args\");\n             let mut llargvals = ~[];\n             let mut i = 0u;\n             let n = vec::len(tys.arg_tys);\n@@ -628,7 +628,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n \n         fn build_ret(bcx: block, tys: @c_stack_tys,\n                      llargbundle: ValueRef, llretval: ValueRef)  {\n-            let _icx = bcx.insn_ctxt(~\"foreign::shim::build_ret\");\n+            let _icx = bcx.insn_ctxt(\"foreign::shim::build_ret\");\n             match tys.x86_64_tys {\n                 some(x86_64) => {\n                   do vec::iteri(x86_64.attrs) |i, a| {\n@@ -719,11 +719,11 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n                      llshimfn: ValueRef,\n                      llwrapfn: ValueRef) {\n \n-        let _icx = ccx.insn_ctxt(~\"foreign::build_wrap_fn\");\n+        let _icx = ccx.insn_ctxt(\"foreign::build_wrap_fn\");\n \n         fn build_args(bcx: block, tys: @c_stack_tys,\n                       llwrapfn: ValueRef, llargbundle: ValueRef) {\n-            let _icx = bcx.insn_ctxt(~\"foreign::wrap::build_args\");\n+            let _icx = bcx.insn_ctxt(\"foreign::wrap::build_args\");\n             let mut i = 0u;\n             let n = vec::len(tys.arg_tys);\n             let implicit_args = first_real_arg; // return + env\n@@ -738,7 +738,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n \n         fn build_ret(bcx: block, _tys: @c_stack_tys,\n                      _llargbundle: ValueRef) {\n-            let _icx = bcx.insn_ctxt(~\"foreign::wrap::build_ret\");\n+            let _icx = bcx.insn_ctxt(\"foreign::wrap::build_ret\");\n             RetVoid(bcx);\n         }\n \n@@ -987,12 +987,12 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                   body: ast::blk, llwrapfn: ValueRef, id: ast::node_id) {\n \n-    let _icx = ccx.insn_ctxt(~\"foreign::build_foreign_fn\");\n+    let _icx = ccx.insn_ctxt(\"foreign::build_foreign_fn\");\n \n     fn build_rust_fn(ccx: @crate_ctxt, path: ast_map::path,\n                      decl: ast::fn_decl, body: ast::blk,\n                      id: ast::node_id) -> ValueRef {\n-        let _icx = ccx.insn_ctxt(~\"foreign::foreign::build_rust_fn\");\n+        let _icx = ccx.insn_ctxt(\"foreign::foreign::build_rust_fn\");\n         let t = ty::node_id_to_type(ccx.tcx, id);\n         let ps = link::mangle_internal_name_by_path(\n             ccx, vec::append_one(path, ast_map::path_name(@~\"__rust_abi\")));\n@@ -1005,11 +1005,11 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n     fn build_shim_fn(ccx: @crate_ctxt, path: ast_map::path,\n                      llrustfn: ValueRef, tys: @c_stack_tys) -> ValueRef {\n \n-        let _icx = ccx.insn_ctxt(~\"foreign::foreign::build_shim_fn\");\n+        let _icx = ccx.insn_ctxt(\"foreign::foreign::build_shim_fn\");\n \n         fn build_args(bcx: block, tys: @c_stack_tys,\n                       llargbundle: ValueRef) -> ~[ValueRef] {\n-            let _icx = bcx.insn_ctxt(~\"foreign::extern::shim::build_args\");\n+            let _icx = bcx.insn_ctxt(\"foreign::extern::shim::build_args\");\n             let mut llargvals = ~[];\n             let mut i = 0u;\n             let n = vec::len(tys.arg_tys);\n@@ -1042,11 +1042,11 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n     fn build_wrap_fn(ccx: @crate_ctxt, llshimfn: ValueRef,\n                      llwrapfn: ValueRef, tys: @c_stack_tys) {\n \n-        let _icx = ccx.insn_ctxt(~\"foreign::foreign::build_wrap_fn\");\n+        let _icx = ccx.insn_ctxt(\"foreign::foreign::build_wrap_fn\");\n \n         fn build_args(bcx: block, tys: @c_stack_tys,\n                       llwrapfn: ValueRef, llargbundle: ValueRef) {\n-            let _icx = bcx.insn_ctxt(~\"foreign::foreign::wrap::build_args\");\n+            let _icx = bcx.insn_ctxt(\"foreign::foreign::wrap::build_args\");\n             match tys.x86_64_tys {\n                 option::some(x86_64) => {\n                     let mut atys = x86_64.arg_tys;\n@@ -1100,7 +1100,7 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n \n         fn build_ret(bcx: block, tys: @c_stack_tys,\n                      llargbundle: ValueRef) {\n-            let _icx = bcx.insn_ctxt(~\"foreign::foreign::wrap::build_ret\");\n+            let _icx = bcx.insn_ctxt(\"foreign::foreign::wrap::build_ret\");\n             match tys.x86_64_tys {\n                 option::some(x86_64) => {\n                     if x86_64.sret || !tys.ret_def {\n@@ -1144,7 +1144,7 @@ fn trans_foreign_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n fn register_foreign_fn(ccx: @crate_ctxt, sp: span,\n                      path: ast_map::path, node_id: ast::node_id)\n     -> ValueRef {\n-    let _icx = ccx.insn_ctxt(~\"foreign::register_foreign_fn\");\n+    let _icx = ccx.insn_ctxt(\"foreign::register_foreign_fn\");\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n     let (llargtys, llretty, ret_ty) = c_arg_and_ret_lltys(ccx, node_id);\n     return if ccx.sess.targ_cfg.arch == arch_x86_64 {"}, {"sha": "20e005d7c54f97a46c063c9cfd61419ad3270bd4", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -20,15 +20,29 @@ import syntax::print::pprust::expr_to_str;\n \n fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n               methods: ~[@ast::method], tps: ~[ast::ty_param]) {\n-    let _icx = ccx.insn_ctxt(~\"impl::trans_impl\");\n+    let _icx = ccx.insn_ctxt(\"impl::trans_impl\");\n     if tps.len() > 0u { return; }\n     let sub_path = vec::append_one(path, path_name(name));\n     for vec::each(methods) |m| {\n         if m.tps.len() == 0u {\n             let llfn = get_item_val(ccx, m.id);\n+            let self_ty = ty::node_id_to_type(ccx.tcx, m.self_id);\n             let self_arg = match m.self_ty.node {\n               ast::sty_static => { no_self }\n-              _ => { impl_self(ty::node_id_to_type(ccx.tcx, m.self_id)) }\n+              ast::sty_box(_) => {\n+                impl_self(ty::mk_imm_box(ccx.tcx, self_ty))\n+              }\n+              ast::sty_uniq(_) => {\n+                impl_self(ty::mk_imm_uniq(ccx.tcx, self_ty))\n+              }\n+              // XXX: Is this right at all?\n+              ast::sty_region(*) => {\n+                impl_self(ty::mk_imm_ptr(ccx.tcx, self_ty))\n+              }\n+              ast::sty_value => {\n+                ccx.sess.unimpl(~\"by value self type not implemented\");\n+              }\n+              ast::sty_by_ref => { impl_self(self_ty) }\n             };\n \n             trans_fn(ccx,\n@@ -41,7 +55,7 @@ fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n }\n \n fn trans_self_arg(bcx: block, base: @ast::expr, derefs: uint) -> result {\n-    let _icx = bcx.insn_ctxt(~\"impl::trans_self_arg\");\n+    let _icx = bcx.insn_ctxt(\"impl::trans_self_arg\");\n     let basety = expr_ty(bcx, base);\n     let m_by_ref = ast::expl(ast::by_ref);\n     let mut temp_cleanups = ~[];\n@@ -59,7 +73,7 @@ fn trans_self_arg(bcx: block, base: @ast::expr, derefs: uint) -> result {\n fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n                        self: @ast::expr, mentry: typeck::method_map_entry)\n     -> lval_maybe_callee {\n-    let _icx = bcx.insn_ctxt(~\"impl::trans_method_callee\");\n+    let _icx = bcx.insn_ctxt(\"impl::trans_method_callee\");\n     match mentry.origin {\n       typeck::method_static(did) => {\n         let {bcx, val} = trans_self_arg(bcx, self, mentry.derefs);\n@@ -89,7 +103,7 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n \n fn trans_static_method_callee(bcx: block, method_id: ast::def_id,\n                               callee_id: ast::node_id) -> lval_maybe_callee {\n-    let _icx = bcx.insn_ctxt(~\"impl::trans_static_method_callee\");\n+    let _icx = bcx.insn_ctxt(\"impl::trans_static_method_callee\");\n     let ccx = bcx.ccx();\n \n     let mname = if method_id.crate == ast::local_crate {\n@@ -175,7 +189,7 @@ fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n                               trait_id: ast::def_id, n_method: uint,\n                               vtbl: typeck::vtable_origin)\n     -> lval_maybe_callee {\n-    let _icx = bcx.insn_ctxt(~\"impl::trans_monomorphized_callee\");\n+    let _icx = bcx.insn_ctxt(\"impl::trans_monomorphized_callee\");\n     match vtbl {\n       typeck::vtable_static(impl_did, impl_substs, sub_origins) => {\n         let ccx = bcx.ccx();\n@@ -210,7 +224,7 @@ fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n fn trans_trait_callee(bcx: block, val: ValueRef,\n                       callee_ty: ty::t, n_method: uint)\n     -> lval_maybe_callee {\n-    let _icx = bcx.insn_ctxt(~\"impl::trans_trait_callee\");\n+    let _icx = bcx.insn_ctxt(\"impl::trans_trait_callee\");\n     let ccx = bcx.ccx();\n     let vtable = Load(bcx, PointerCast(bcx, GEPi(bcx, val, ~[0u, 0u]),\n                                        T_ptr(T_ptr(T_vtable()))));\n@@ -299,7 +313,7 @@ fn get_vtable(ccx: @crate_ctxt, origin: typeck::vtable_origin)\n }\n \n fn make_vtable(ccx: @crate_ctxt, ptrs: ~[ValueRef]) -> ValueRef {\n-    let _icx = ccx.insn_ctxt(~\"impl::make_vtable\");\n+    let _icx = ccx.insn_ctxt(\"impl::make_vtable\");\n     let tbl = C_struct(ptrs);\n     let vt_gvar = str::as_c_str(ccx.names(~\"vtable\"), |buf| {\n         llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl), buf)\n@@ -312,7 +326,7 @@ fn make_vtable(ccx: @crate_ctxt, ptrs: ~[ValueRef]) -> ValueRef {\n \n fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: ~[ty::t],\n                     vtables: typeck::vtable_res) -> ValueRef {\n-    let _icx = ccx.insn_ctxt(~\"impl::make_impl_vtable\");\n+    let _icx = ccx.insn_ctxt(\"impl::make_impl_vtable\");\n     let tcx = ccx.tcx;\n \n     // XXX: This should support multiple traits.\n@@ -345,7 +359,7 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: ~[ty::t],\n \n fn trans_cast(bcx: block, val: @ast::expr, id: ast::node_id, dest: dest)\n     -> block {\n-    let _icx = bcx.insn_ctxt(~\"impl::trans_cast\");\n+    let _icx = bcx.insn_ctxt(\"impl::trans_cast\");\n     if dest == ignore { return trans_expr(bcx, val, ignore); }\n     let ccx = bcx.ccx();\n     let v_ty = expr_ty(bcx, val);"}, {"sha": "9633284758810ac95d5f2cfb5b769893866caec6", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -32,7 +32,7 @@ fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n }\n \n fn get_fill(bcx: block, vptr: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(~\"tvec::get_fill\");\n+    let _icx = bcx.insn_ctxt(\"tvec::get_fill\");\n     Load(bcx, GEPi(bcx, vptr, ~[0u, abi::vec_elt_fill]))\n }\n fn set_fill(bcx: block, vptr: ValueRef, fill: ValueRef) {\n@@ -48,20 +48,20 @@ fn get_bodyptr(bcx: block, vptr: ValueRef) -> ValueRef {\n \n fn get_dataptr(bcx: block, vptr: ValueRef)\n     -> ValueRef {\n-    let _icx = bcx.insn_ctxt(~\"tvec::get_dataptr\");\n+    let _icx = bcx.insn_ctxt(\"tvec::get_dataptr\");\n     GEPi(bcx, vptr, ~[0u, abi::vec_elt_elems, 0u])\n }\n \n fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(~\"tvec::pointer_add\");\n+    let _icx = bcx.insn_ctxt(\"tvec::pointer_add\");\n     let old_ty = val_ty(ptr);\n     let bptr = PointerCast(bcx, ptr, T_ptr(T_i8()));\n     return PointerCast(bcx, InBoundsGEP(bcx, bptr, ~[bytes]), old_ty);\n }\n \n fn alloc_raw(bcx: block, unit_ty: ty::t,\n               fill: ValueRef, alloc: ValueRef, heap: heap) -> result {\n-    let _icx = bcx.insn_ctxt(~\"tvec::alloc_uniq\");\n+    let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n \n     let vecbodyty = ty::mk_mut_unboxed_vec(bcx.tcx(), unit_ty);\n@@ -79,7 +79,7 @@ fn alloc_uniq_raw(bcx: block, unit_ty: ty::t,\n }\n \n fn alloc_vec(bcx: block, unit_ty: ty::t, elts: uint, heap: heap) -> result {\n-    let _icx = bcx.insn_ctxt(~\"tvec::alloc_uniq\");\n+    let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n     let llunitty = type_of::type_of(ccx, unit_ty);\n     let unit_sz = llsize_of(ccx, llunitty);\n@@ -92,7 +92,7 @@ fn alloc_vec(bcx: block, unit_ty: ty::t, elts: uint, heap: heap) -> result {\n }\n \n fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n-    let _icx = bcx.insn_ctxt(~\"tvec::duplicate_uniq\");\n+    let _icx = bcx.insn_ctxt(\"tvec::duplicate_uniq\");\n \n     let fill = get_fill(bcx, get_bodyptr(bcx, vptr));\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n@@ -110,7 +110,7 @@ fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n \n fn make_drop_glue_unboxed(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n    block {\n-    let _icx = bcx.insn_ctxt(~\"tvec::make_drop_glue_unboxed\");\n+    let _icx = bcx.insn_ctxt(\"tvec::make_drop_glue_unboxed\");\n     let tcx = bcx.tcx(), unit_ty = ty::sequence_element_type(tcx, vec_ty);\n     if ty::type_needs_drop(tcx, unit_ty) {\n         iter_vec_unboxed(bcx, vptr, vec_ty, base::drop_ty)\n@@ -124,7 +124,7 @@ enum evec_elements {\n \n fn trans_evec(bcx: block, elements: evec_elements,\n               vst: ast::vstore, id: ast::node_id, dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(~\"tvec::trans_evec\");\n+    let _icx = bcx.insn_ctxt(\"tvec::trans_evec\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n \n@@ -318,7 +318,7 @@ fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n \n fn trans_estr(bcx: block, s: @~str, vstore: option<ast::vstore>,\n               dest: dest) -> block {\n-    let _icx = bcx.insn_ctxt(~\"tvec::trans_estr\");\n+    let _icx = bcx.insn_ctxt(\"tvec::trans_estr\");\n     if dest == base::ignore { return bcx; }\n     let ccx = bcx.ccx();\n \n@@ -362,7 +362,7 @@ type iter_vec_block = fn(block, ValueRef, ty::t) -> block;\n \n fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n                 fill: ValueRef, f: iter_vec_block) -> block {\n-    let _icx = bcx.insn_ctxt(~\"tvec::iter_vec_raw\");\n+    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_raw\");\n \n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n \n@@ -393,14 +393,14 @@ fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n \n fn iter_vec_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n                  fill: ValueRef, f: iter_vec_block) -> block {\n-    let _icx = bcx.insn_ctxt(~\"tvec::iter_vec_uniq\");\n+    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_uniq\");\n     let data_ptr = get_dataptr(bcx, get_bodyptr(bcx, vptr));\n     iter_vec_raw(bcx, data_ptr, vec_ty, fill, f)\n }\n \n fn iter_vec_unboxed(bcx: block, body_ptr: ValueRef, vec_ty: ty::t,\n                     f: iter_vec_block) -> block {\n-    let _icx = bcx.insn_ctxt(~\"tvec::iter_vec_unboxed\");\n+    let _icx = bcx.insn_ctxt(\"tvec::iter_vec_unboxed\");\n     let fill = get_fill(bcx, body_ptr);\n     let dataptr = get_dataptr(bcx, body_ptr);\n     return iter_vec_raw(bcx, dataptr, vec_ty, fill, f);"}, {"sha": "f9b4a76bced04c646a68f8d6b8aa56789b6a1e5a", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -9,7 +9,7 @@ export make_free_glue, autoderef, duplicate;\n \n fn make_free_glue(bcx: block, vptrptr: ValueRef, t: ty::t)\n     -> block {\n-    let _icx = bcx.insn_ctxt(~\"uniq::make_free_glue\");\n+    let _icx = bcx.insn_ctxt(\"uniq::make_free_glue\");\n     let vptr = Load(bcx, vptrptr);\n     do with_cond(bcx, IsNotNull(bcx, vptr)) |bcx| {\n         let content_ty = content_ty(t);\n@@ -33,7 +33,7 @@ fn autoderef(bcx: block, v: ValueRef, t: ty::t) -> {v: ValueRef, t: ty::t} {\n }\n \n fn duplicate(bcx: block, v: ValueRef, t: ty::t) -> result {\n-    let _icx = bcx.insn_ctxt(~\"uniq::duplicate\");\n+    let _icx = bcx.insn_ctxt(\"uniq::duplicate\");\n     let content_ty = content_ty(t);\n     let {bcx: bcx, box: dst_box, body: dst_body} =\n         malloc_unique(bcx, content_ty);"}, {"sha": "5cb886a36f06d34d8ad0ee9989a922cf73613e1a", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -80,6 +80,7 @@ import std::map::str_hash;\n type self_info = {\n     self_ty: ty::t,\n     node_id: ast::node_id,\n+    explicit_self: ast::self_ty_\n };\n \n type fn_ctxt_ =\n@@ -367,14 +368,20 @@ fn check_fn(ccx: @crate_ctxt,\n \n fn check_method(ccx: @crate_ctxt, method: @ast::method,\n                 self_info: self_info) {\n+\n     check_bare_fn(ccx, method.decl, method.body, method.id, some(self_info));\n }\n \n-fn check_class_member(ccx: @crate_ctxt, class_t: self_info,\n+fn check_class_member(ccx: @crate_ctxt, self_ty: ty::t,\n+                      node_id: ast::node_id,\n                       cm: @ast::class_member) {\n     match cm.node {\n       ast::instance_var(_,t,_,_,_) => (),\n-      ast::class_method(m) => check_method(ccx, m, class_t)\n+      ast::class_method(m) => {\n+        let class_t = {self_ty: self_ty, node_id: node_id,\n+                       explicit_self: m.self_ty.node};\n+        check_method(ccx, m, class_t)\n+      }\n     }\n }\n \n@@ -404,9 +411,11 @@ fn check_no_duplicate_fields(tcx: ty::ctxt, fields:\n fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n                 id: ast::node_id, span: span) {\n     let tcx = ccx.tcx;\n-    let class_t = {self_ty: ty::node_id_to_type(tcx, id), node_id: id};\n+    let self_ty = ty::node_id_to_type(tcx, id);\n \n     do option::iter(struct_def.ctor) |ctor| {\n+        let class_t = {self_ty: self_ty, node_id: id,\n+                       explicit_self: ast::sty_by_ref};\n         // typecheck the ctor\n         check_bare_fn(ccx, ctor.node.dec,\n                       ctor.node.body, ctor.node.id,\n@@ -416,6 +425,8 @@ fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n     }\n \n     do option::iter(struct_def.dtor) |dtor| {\n+        let class_t = {self_ty: self_ty, node_id: id,\n+                       explicit_self: ast::sty_by_ref};\n         // typecheck the dtor\n         check_bare_fn(ccx, ast_util::dtor_dec(),\n                       dtor.node.body, dtor.node.id,\n@@ -426,7 +437,7 @@ fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n \n     // typecheck the members\n     for struct_def.members.each |m| {\n-        check_class_member(ccx, class_t, m);\n+        check_class_member(ccx, self_ty, id, m);\n     }\n     // Check that there's at least one field\n     let (fields,_) = split_class_items(struct_def.members);\n@@ -450,9 +461,12 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         let rp = ccx.tcx.region_paramd_items.contains_key(it.id);\n         debug!{\"item_impl %s with id %d rp %b\",\n                *it.ident, it.id, rp};\n-        let self_info = {self_ty: ccx.to_ty(rscope::type_rscope(rp), ty),\n-                         node_id: it.id };\n-        for ms.each |m| { check_method(ccx, m, self_info);}\n+        let self_ty = ccx.to_ty(rscope::type_rscope(rp), ty);\n+        for ms.each |m| {\n+            let self_info = {self_ty: self_ty, node_id: it.id,\n+                             explicit_self: m.self_ty.node };\n+            check_method(ccx, m, self_info)\n+        }\n       }\n       ast::item_trait(_, _, trait_methods) => {\n         for trait_methods.each |trait_method| {\n@@ -463,7 +477,8 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n               }\n               provided(m) => {\n                 let self_info = {self_ty: ty::mk_self(ccx.tcx),\n-                                 node_id: it.id};\n+                                 node_id: it.id,\n+                                 explicit_self: m.self_ty.node};\n                 check_method(ccx, m, self_info);\n               }\n             }\n@@ -742,7 +757,8 @@ fn check_expr(fcx: @fn_ctxt, expr: @ast::expr,\n // declared on the impl declaration e.g., `impl<A,B> for ~[(A,B)]`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n-fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n+fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id, require_rp: bool)\n+                                        -> ty_param_substs_and_ty {\n     let tcx = fcx.ccx.tcx;\n \n     let {n_tps, rp, raw_ty} = if did.crate == ast::local_crate {\n@@ -778,6 +794,7 @@ fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n          raw_ty: ity.ty}\n     };\n \n+    let rp = rp || require_rp;\n     let self_r = if rp {some(fcx.infcx.next_region_var_nb())} else {none};\n     let tps = fcx.infcx.next_ty_vars(n_tps);\n \n@@ -2216,7 +2233,10 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n       ast::def_self(_) => {\n         match fcx.self_info {\n           some(self_info) => {\n-            return no_params(self_info.self_ty);\n+            let self_region = fcx.in_scope_regions.find(ty::br_self);\n+            return no_params(method::transform_self_type_for_method(\n+                fcx.tcx(), self_region,\n+                self_info.self_ty, self_info.explicit_self));\n           }\n           none => {\n               fcx.ccx.tcx.sess.span_bug(sp, ~\"def_self with no self_info\");"}, {"sha": "c5d3dd765abd4dd09fd77ec5bbd7180325124b09", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -20,28 +20,30 @@ type candidate = {\n     entry: method_map_entry\n };\n \n-fn transform_self_type_for_method(fcx: @fn_ctxt,\n-                                  impl_ty: ty::t,\n-                                  method_info: MethodInfo)\n+fn transform_self_type_for_method\n+    (tcx: ty::ctxt,\n+     self_region: option<ty::region>,\n+     impl_ty: ty::t,\n+     self_type: ast::self_ty_)\n                                -> ty::t {\n-    match method_info.self_type {\n+    match self_type {\n       sty_static => {\n-        fcx.tcx().sess.bug(~\"calling transform_self_type_for_method on \\\n-                             static method\");\n+        tcx.sess.bug(~\"calling transform_self_type_for_method on \\\n+                       static method\");\n       }\n       sty_by_ref | sty_value => {\n         impl_ty\n       }\n-      sty_region(r, mutability) => {\n-        // XXX: dummy_sp is unfortunate here.\n-        let region = ast_region_to_region(fcx, fcx, dummy_sp(), r);\n-        mk_rptr(fcx.ccx.tcx, region, { ty: impl_ty, mutbl: mutability })\n+      sty_region(mutability) => {\n+        mk_rptr(tcx,\n+                self_region.expect(~\"self region missing for &self param\"),\n+                { ty: impl_ty, mutbl: mutability })\n       }\n       sty_box(mutability) => {\n-        mk_box(fcx.ccx.tcx, { ty: impl_ty, mutbl: mutability })\n+        mk_box(tcx, { ty: impl_ty, mutbl: mutability })\n       }\n       sty_uniq(mutability) => {\n-        mk_uniq(fcx.ccx.tcx, { ty: impl_ty, mutbl: mutability })\n+        mk_uniq(tcx, { ty: impl_ty, mutbl: mutability })\n       }\n     }\n }\n@@ -368,14 +370,17 @@ class lookup {\n         // Check whether this impl has a method with the right name.\n         for im.methods.find(|m| m.ident == self.m_name).each |m| {\n \n+            let need_rp = match m.self_type { ast::sty_region(_) => true,\n+                                              _ => false };\n+\n             // determine the `self` of the impl with fresh\n             // variables for each parameter:\n             let {substs: impl_substs, ty: impl_ty} =\n-                impl_self_ty(self.fcx, im.did);\n+                impl_self_ty(self.fcx, im.did, need_rp);\n \n-            let impl_ty = transform_self_type_for_method(self.fcx,\n-                                                         impl_ty,\n-                                                         *m);\n+            let impl_ty = transform_self_type_for_method(\n+                self.tcx(), impl_substs.self_r,\n+                impl_ty, m.self_type);\n \n             // Depending on our argument, we find potential\n             // matches either by checking subtypability or"}, {"sha": "75f5ca3cbd8034412d1c5a4c7b94ea3edab19c83", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -22,6 +22,17 @@ fn replace_bound_regions_in_fn_ty(\n \n     let mut all_tys = ty::tys_in_fn_ty(fn_ty);\n \n+    match self_info {\n+      some({explicit_self: ast::sty_region(m), _}) => {\n+        let region = ty::re_bound(ty::br_self);\n+        let ty = ty::mk_rptr(tcx, region,\n+                             { ty: ty::mk_self(tcx), mutbl: m });\n+        vec::push(all_tys, ty);\n+      }\n+      _ => {}\n+    }\n+\n+\n     for self_ty.each |t| { vec::push(all_tys, t) }\n \n     debug!{\"replace_bound_regions_in_fn_ty(self_info.self_ty=%?, fn_ty=%s, \\\n@@ -50,7 +61,7 @@ fn replace_bound_regions_in_fn_ty(\n     // Glue updated self_ty back together with its original node_id.\n     let new_self_info = match self_info {\n         some(s) => match check t_self {\n-          some(t) => some({self_ty: t, node_id: s.node_id})\n+          some(t) => some({self_ty: t with s})\n           // this 'none' case shouldn't happen\n         },\n         none => none"}, {"sha": "d509b26b8417ae8e1765347e7022d9220d1a95ef", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -146,7 +146,7 @@ fn lookup_vtable(fcx: @fn_ctxt, sp: span, ty: ty::t, trait_ty: ty::t,\n                         // check whether the type unifies with the type\n                         // that the impl is for, and continue if not\n                         let {substs: substs, ty: for_ty} =\n-                            impl_self_ty(fcx, im.did);\n+                            impl_self_ty(fcx, im.did, false);\n                         let im_bs = ty::lookup_item_type(tcx, im.did).bounds;\n                         match fcx.mk_subty(ty, for_ty) {\n                           result::err(_) => again,"}, {"sha": "7631e3b82f2631a74432e84c99da94c793310cc6", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -77,10 +77,10 @@ fn default_config(input_crate: ~str) -> config {\n     }\n }\n \n-type program_output = fn~(~str, ~[~str]) ->\n+type program_output = fn~((&str), (&[~str])) ->\n     {status: int, out: ~str, err: ~str};\n \n-fn mock_program_output(_prog: ~str, _args: ~[~str]) -> {\n+fn mock_program_output(_prog: &str, _args: &[~str]) -> {\n     status: int, out: ~str, err: ~str\n } {\n     {\n@@ -231,7 +231,7 @@ fn should_find_pandoc() {\n         output_format: pandoc_html\n         with default_config(~\"test\")\n     };\n-    let mock_program_output = fn~(_prog: ~str, _args: ~[~str]) -> {\n+    let mock_program_output = fn~(_prog: &str, _args: &[~str]) -> {\n         status: int, out: ~str, err: ~str\n     } {\n         {\n@@ -248,7 +248,7 @@ fn should_error_with_no_pandoc() {\n         output_format: pandoc_html\n         with default_config(~\"test\")\n     };\n-    let mock_program_output = fn~(_prog: ~str, _args: ~[~str]) -> {\n+    let mock_program_output = fn~(_prog: &str, _args: &[~str]) -> {\n         status: int, out: ~str, err: ~str\n     } {\n         {"}, {"sha": "2757bd8fbf10ee92d5864b44702dbc9c8d0c18e5", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -83,7 +83,9 @@ fn write_markdown(\n     doc: doc::doc,\n     +writer_factory: writer_factory\n ) {\n-    do par::map(doc.pages) |page| {\n+    // FIXME #2484: There is easy parallelism to be had here but\n+    // we don't want to spawn too many pandoc processes\n+    do doc.pages.map |page| {\n         let ctxt = {\n             w: writer_factory(page)\n         };"}, {"sha": "8265bbe17d884d2610fb76628376e4ea9bb31052", "filename": "src/rustdoc/markdown_writer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Frustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_writer.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -88,7 +88,7 @@ fn pandoc_writer(\n     ];\n \n     do generic_writer |markdown| {\n-        import io::writer_util;\n+        import io::WriterUtil;\n \n         debug!{\"pandoc cmd: %s\", pandoc_cmd};\n         debug!{\"pandoc args: %s\", str::connect(pandoc_args, ~\" \")};\n@@ -97,7 +97,7 @@ fn pandoc_writer(\n         let pipe_out = os::pipe();\n         let pipe_err = os::pipe();\n         let pid = run::spawn_process(\n-            pandoc_cmd, pandoc_args, none, none,\n+            pandoc_cmd, pandoc_args, &none, &none,\n             pipe_in.in, pipe_out.out, pipe_err.out);\n \n         let writer = io::fd_writer(pipe_in.out, false);\n@@ -254,9 +254,9 @@ mod test {\n }\n \n fn write_file(path: ~str, s: ~str) {\n-    import io::writer_util;\n+    import io::WriterUtil;\n \n-    match io::file_writer(path, ~[io::create, io::truncate]) {\n+    match io::file_writer(path, ~[io::Create, io::Truncate]) {\n       result::ok(writer) => {\n         writer.write_str(s);\n       }"}, {"sha": "d58cd1ef4cf0549002264c7716bffedaf92e7206", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -6,7 +6,7 @@ import std::time::precise_time_s;\n import std::map;\n import std::map::{map, hashmap};\n \n-import io::reader;\n+import io::Reader;\n \n fn main(argv: ~[~str]) {\n     #macro["}, {"sha": "b480d92a0d849fde2d325299b21b89a2f87acb14", "filename": "src/test/bench/core-vec-append.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-vec-append.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -2,7 +2,7 @@\n \n use std;\n import dvec::dvec;\n-import io::writer_util;\n+import io::WriterUtil;\n \n fn collect_raw(num: uint) -> ~[uint] {\n     let mut result = ~[];"}, {"sha": "35ff2e648c9a6af36f83a3e20150dccdc965a101", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -13,7 +13,7 @@ import std::map::hashmap;\n import std::deque;\n import std::deque::t;\n import std::par;\n-import io::writer_util;\n+import io::WriterUtil;\n import comm::*;\n import int::abs;\n \n@@ -24,7 +24,7 @@ type bfs_result = ~[node_id];\n fn make_edges(scale: uint, edgefactor: uint) -> ~[(node_id, node_id)] {\n     let r = rand::xorshift();\n \n-    fn choose_edge(i: node_id, j: node_id, scale: uint, r: rand::rng)\n+    fn choose_edge(i: node_id, j: node_id, scale: uint, r: rand::Rng)\n         -> (node_id, node_id) {\n \n         let A = 0.57;"}, {"sha": "8b0eeb15cb3fa539a7b81cf04fa7205d84ce9988", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -11,8 +11,8 @@\n // xfail-pretty\n \n use std;\n-import io::writer;\n-import io::writer_util;\n+import io::Writer;\n+import io::WriterUtil;\n \n import pipes::{port, chan, shared_chan};\n "}, {"sha": "06b4213970b0825edd02c0a3947b5e0f650c8d5d", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -7,8 +7,8 @@\n // xfail-pretty\n \n use std;\n-import io::writer;\n-import io::writer_util;\n+import io::Writer;\n+import io::WriterUtil;\n \n import pipes::{port, port_set, chan};\n "}, {"sha": "abcf9f4ed54877223c433b0b59bba2433526d16a", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -5,8 +5,8 @@\n // I *think* it's the same, more or less.\n \n use std;\n-import io::writer;\n-import io::writer_util;\n+import io::Writer;\n+import io::WriterUtil;\n \n enum request {\n     get_count,"}, {"sha": "4b83b14c98fd21b332e0b687d59041d36f652b6b", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -10,7 +10,7 @@ import vec;\n import uint;\n import int;\n import str;\n-import io::writer_util;\n+import io::WriterUtil;\n \n fn LINE_LENGTH() -> uint { return 60u; }\n \n@@ -43,7 +43,7 @@ fn select_random(r: u32, genelist: ~[aminoacids]) -> char {\n     return bisect(genelist, 0u, vec::len::<aminoacids>(genelist) - 1u, r);\n }\n \n-fn make_random_fasta(wr: io::writer, id: ~str, desc: ~str, genelist: ~[aminoacids], n: int) {\n+fn make_random_fasta(wr: io::Writer, id: ~str, desc: ~str, genelist: ~[aminoacids], n: int) {\n     wr.write_line(~\">\" + id + ~\" \" + desc);\n     let rng = @{mut last: rand::rng().next()};\n     let mut op: ~str = ~\"\";\n@@ -58,7 +58,7 @@ fn make_random_fasta(wr: io::writer, id: ~str, desc: ~str, genelist: ~[aminoacid\n     if str::len(op) > 0u { wr.write_line(op); }\n }\n \n-fn make_repeat_fasta(wr: io::writer, id: ~str, desc: ~str, s: ~str, n: int) unsafe {\n+fn make_repeat_fasta(wr: io::Writer, id: ~str, desc: ~str, s: ~str, n: int) unsafe {\n     wr.write_line(~\">\" + id + ~\" \" + desc);\n     let mut op: ~str = ~\"\";\n     let sl: uint = str::len(s);\n@@ -85,7 +85,7 @@ fn main(args: ~[~str]) {\n     };\n \n     let writer = if os::getenv(~\"RUST_BENCH\").is_some() {\n-        result::get(io::file_writer(~\"./shootout-fasta.data\", ~[io::truncate, io::create]))\n+        result::get(io::file_writer(~\"./shootout-fasta.data\", ~[io::Truncate, io::Create]))\n     } else {\n         io::stdout()\n     };"}, {"sha": "fcbd2e6fed015ffd53fe7d6b8552fefce1d794b9", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -13,7 +13,7 @@\n //  writes pbm image to output path\n \n use std;\n-import io::writer_util;\n+import io::WriterUtil;\n import std::map::hashmap;\n \n struct cmplx {\n@@ -90,30 +90,30 @@ fn chanmb(i: uint, size: uint, ch: comm::chan<line>) -> ()\n \n type devnull = {dn: int};\n \n-impl devnull: io::writer {\n+impl devnull: io::Writer {\n     fn write(_b: &[const u8]) {}\n-    fn seek(_i: int, _s: io::seek_style) {}\n+    fn seek(_i: int, _s: io::SeekStyle) {}\n     fn tell() -> uint {0_u}\n     fn flush() -> int {0}\n-    fn get_type() -> io::writer_type { io::file }\n+    fn get_type() -> io::WriterType { io::File }\n }\n \n fn writer(path: ~str, writech: comm::chan<comm::chan<line>>, size: uint)\n {\n     let p: comm::port<line> = comm::port();\n     let ch = comm::chan(p);\n     comm::send(writech, ch);\n-    let cout: io::writer = match path {\n+    let cout: io::Writer = match path {\n         ~\"\" => {\n-            {dn: 0} as io::writer\n+            {dn: 0} as io::Writer\n         }\n         ~\"-\" => {\n             io::stdout()\n         }\n         _ => {\n             result::get(\n                 io::file_writer(path,\n-                ~[io::create, io::truncate]))\n+                ~[io::Create, io::Truncate]))\n         }\n     };\n     cout.write_line(~\"P4\");"}, {"sha": "7942392f2b80fa02ceb621694412e22f47c68610", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -13,7 +13,7 @@\n use std;\n \n import std::{time, getopts};\n-import io::writer_util;\n+import io::WriterUtil;\n import int::range;\n import pipes::port;\n import pipes::chan;"}, {"sha": "a9cab862e2e9ef0ed324c7d862f6474fc8b2c083", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -3,7 +3,7 @@\n use std;\n import std::smallintmap;\n import std::smallintmap::smallintmap;\n-import io::writer_util;\n+import io::WriterUtil;\n \n fn append_sequential(min: uint, max: uint, map: smallintmap<uint>) {\n     for uint::range(min, max) |i| {"}, {"sha": "7c72244213306d911cba642b38d8fd33c2e2136a", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,7 +1,7 @@\n use std;\n \n import std::bitv;\n-import io::writer_util;\n+import io::WriterUtil;\n \n // Computes a single solution to a given 9x9 sudoku\n //\n@@ -28,7 +28,7 @@ type grid = ~[~[mut u8]];\n enum grid_t { grid_ctor(grid), }\n \n // read a sudoku problem from file f\n-fn read_grid(f: io::reader) -> grid_t {\n+fn read_grid(f: io::Reader) -> grid_t {\n     assert f.read_line() == ~\"9,9\"; /* assert first line is exactly \"9,9\" */\n \n     let g = vec::from_fn(10u, {|_i|\n@@ -116,7 +116,7 @@ fn solve_grid(g: grid_t) {\n     }\n }\n \n-fn write_grid(f: io::writer, g: grid_t) {\n+fn write_grid(f: io::Writer, g: grid_t) {\n     for u8::range(0u8, 9u8) |row| {\n         f.write_str(fmt!{\"%u\", (*g)[row][0] as uint});\n         for u8::range(1u8, 9u8) |col| {"}, {"sha": "f48b05d0f1715d86f9b5f30b67cdb34f72840209", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -20,7 +20,7 @@ import std::map;\n import std::map::hashmap;\n import vec;\n import io;\n-import io::writer_util;\n+import io::WriterUtil;\n \n import std::time;\n import u64;\n@@ -73,7 +73,7 @@ fn join(t: joinable_task) {\n     t.recv()\n }\n \n-impl io::reader: word_reader {\n+impl io::Reader: word_reader {\n     fn read_word() -> option<~str> { read_word(self) }\n }\n \n@@ -331,7 +331,7 @@ fn main(argv: ~[~str]) {\n              + u64::str(elapsed) + ~\"ms\");\n }\n \n-fn read_word(r: io::reader) -> option<~str> {\n+fn read_word(r: io::Reader) -> option<~str> {\n     let mut w = ~\"\";\n \n     while !r.eof() {\n@@ -350,7 +350,7 @@ fn is_word_char(c: char) -> bool {\n \n class random_word_reader: word_reader {\n     let mut remaining: uint;\n-    let rng: rand::rng;\n+    let rng: rand::Rng;\n     new(count: uint) {\n         self.remaining = count;\n         self.rng = rand::rng();"}, {"sha": "d8b3fd3e8b02578ef60a6d233eb54a921219926c", "filename": "src/test/compile-fail/arc-rw-cond-shouldnt-escape.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -0,0 +1,11 @@\n+// error-pattern: reference is not valid outside of its lifetime\n+use std;\n+import std::arc;\n+fn main() {\n+    let x = ~arc::rw_arc(1);\n+    let mut y = none;\n+    do x.write_cond |_one, cond| {\n+        y = some(cond);\n+    }\n+    option::unwrap(y).wait();\n+}"}, {"sha": "8ba84bf85dc435f92dd54f5334befb4d2f5d1141", "filename": "src/test/compile-fail/arc-rw-read-mode-shouldnt-escape.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -0,0 +1,12 @@\n+// error-pattern: reference is not valid outside of its lifetime\n+use std;\n+import std::arc;\n+fn main() {\n+    let x = ~arc::rw_arc(1);\n+    let mut y = none;\n+    do x.write_downgrade |write_mode| {\n+        y = some(x.downgrade(write_mode));\n+    }\n+    // Adding this line causes a method unification failure instead\n+    // do (&option::unwrap(y)).read |state| { assert *state == 1; }\n+}"}, {"sha": "3584512c28e4d17285bcdae95fc5651528f46bb9", "filename": "src/test/compile-fail/arc-rw-write-mode-cond-shouldnt-escape.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -0,0 +1,13 @@\n+// error-pattern: reference is not valid outside of its lifetime\n+use std;\n+import std::arc;\n+fn main() {\n+    let x = ~arc::rw_arc(1);\n+    let mut y = none;\n+    do x.write_downgrade |write_mode| {\n+        do (&write_mode).write_cond |_one, cond| {\n+            y = some(cond);\n+        }\n+    }\n+    option::unwrap(y).wait();\n+}"}, {"sha": "e4ecef47476adaf59b403946451c7c5de2c1e09f", "filename": "src/test/compile-fail/arc-rw-write-mode-shouldnt-escape.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -0,0 +1,12 @@\n+// error-pattern: reference is not valid outside of its lifetime\n+use std;\n+import std::arc;\n+fn main() {\n+    let x = ~arc::rw_arc(1);\n+    let mut y = none;\n+    do x.write_downgrade |write_mode| {\n+        y = some(write_mode);\n+    }\n+    // Adding this line causes a method unification failure instead\n+    // do (&option::unwrap(y)).write |state| { assert *state == 1; }\n+}"}, {"sha": "f4a7816c1617c73f618fc9b765e902bc6d900596", "filename": "src/test/compile-fail/kindck-implicit-close-over-mut-var.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fcompile-fail%2Fkindck-implicit-close-over-mut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fcompile-fail%2Fkindck-implicit-close-over-mut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-implicit-close-over-mut-var.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,10 +1,10 @@\n-fn use(_i: int) {}\n+fn user(_i: int) {}\n \n fn foo() {\n     // Here, i is *moved* into the closure: Not actually OK\n     let mut i = 0;\n     do task::spawn {\n-        use(i); //~ ERROR mutable variables cannot be implicitly captured\n+        user(i); //~ ERROR mutable variables cannot be implicitly captured\n     }\n }\n \n@@ -14,7 +14,7 @@ fn bar() {\n     let mut i = 0;\n     while i < 10 {\n         do task::spawn {\n-            use(i); //~ ERROR mutable variables cannot be implicitly captured\n+            user(i); //~ ERROR mutable variables cannot be implicitly captured\n         }\n         i += 1;\n     }\n@@ -25,7 +25,7 @@ fn car() {\n     let mut i = 0;\n     while i < 10 {\n         do task::spawn |copy i| {\n-            use(i);\n+            user(i);\n         }\n         i += 1;\n     }"}, {"sha": "2b76279a4abf8d34bc1a274348e10372a76492e6", "filename": "src/test/compile-fail/sync-rwlock-cond-shouldnt-escape.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -0,0 +1,11 @@\n+// error-pattern: reference is not valid outside of its lifetime\n+use std;\n+import std::sync;\n+fn main() {\n+    let x = ~sync::rwlock();\n+    let mut y = none;\n+    do x.write_cond |cond| {\n+        y = some(cond);\n+    }\n+    option::unwrap(y).wait();\n+}"}, {"sha": "ac04671ee372ae6a259f5b42a9a2c3ef84d66f3b", "filename": "src/test/compile-fail/sync-rwlock-read-mode-shouldnt-escape.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -0,0 +1,12 @@\n+// error-pattern: reference is not valid outside of its lifetime\n+use std;\n+import std::sync;\n+fn main() {\n+    let x = ~sync::rwlock();\n+    let mut y = none;\n+    do x.write_downgrade |write_mode| {\n+        y = some(x.downgrade(write_mode));\n+    }\n+    // Adding this line causes a method unification failure instead\n+    // do (&option::unwrap(y)).read { }\n+}"}, {"sha": "7f60342b9994cfdd6cf373024f9500fd7dae16b3", "filename": "src/test/compile-fail/sync-rwlock-write-mode-cond-shouldnt-escape.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -0,0 +1,13 @@\n+// error-pattern: reference is not valid outside of its lifetime\n+use std;\n+import std::sync;\n+fn main() {\n+    let x = ~sync::rwlock();\n+    let mut y = none;\n+    do x.write_downgrade |write_mode| {\n+        do (&write_mode).write_cond |cond| {\n+            y = some(cond);\n+        }\n+    }\n+    option::unwrap(y).wait();\n+}"}, {"sha": "f7571d11ac8ad0f884f1778cb2f25a0e244ab7ad", "filename": "src/test/compile-fail/sync-rwlock-write-mode-shouldnt-escape.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -0,0 +1,12 @@\n+// error-pattern: reference is not valid outside of its lifetime\n+use std;\n+import std::sync;\n+fn main() {\n+    let x = ~sync::rwlock();\n+    let mut y = none;\n+    do x.write_downgrade |write_mode| {\n+        y = some(write_mode);\n+    }\n+    // Adding this line causes a method unification failure instead\n+    // do (&option::unwrap(y)).write { }\n+}"}, {"sha": "e22c71af2674945e6ac796815761b91472b3eb44", "filename": "src/test/compile-fail/view-items-at-top.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fcompile-fail%2Fview-items-at-top.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Fcompile-fail%2Fview-items-at-top.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fview-items-at-top.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,9 +1,11 @@\n+// xfail-test\n+\n use std;\n \n fn f() {\n }\n \n-import std::io::println;    //~ ERROR view items must be declared at the top\n+import std::net;    //~ ERROR view items must be declared at the top\n \n fn main() {\n }"}, {"sha": "8084558ab6952e06dbcab99a3c76995f635d879b", "filename": "src/test/run-fail/issue-2156.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Frun-fail%2Fissue-2156.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Frun-fail%2Fissue-2156.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-2156.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,7 +1,7 @@\n // error-pattern:explicit failure\n // Don't double free the string\n use std;\n-import io::reader;\n+import io::Reader;\n \n fn main() {\n     do io::with_str_reader(~\"\") |rdr| {"}, {"sha": "4a36e7a1c46cb184b44b6555c3baf38bf9698c67", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -85,7 +85,7 @@ fn main() {\n \n fn check_pp<T>(expr: T, f: fn(pprust::ps, T), expect: ~str) {\n     let buf = mem_buffer();\n-    let pp = pprust::rust_printer(buf as io::writer);\n+    let pp = pprust::rust_printer(buf as io::Writer);\n     f(pp, expr);\n     pp::eof(pp.s);\n     let str = mem_buffer_str(buf);"}, {"sha": "cd7abd4b40049195775a2c85aad75c18c363519c", "filename": "src/test/run-pass/auto_serialize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -4,14 +4,14 @@ use std;\n // the common code.\n \n import std::ebml;\n-import io::writer;\n+import io::Writer;\n import std::serialization::{serialize_uint, deserialize_uint};\n \n fn test_ser_and_deser<A>(a1: A,\n                          expected: ~str,\n                          ebml_ser_fn: fn(ebml::writer, A),\n                          ebml_deser_fn: fn(ebml::ebml_deserializer) -> A,\n-                         io_ser_fn: fn(io::writer, A)) {\n+                         io_ser_fn: fn(io::Writer, A)) {\n \n     // check the pretty printer:\n     io_ser_fn(io::stdout(), a1);\n@@ -21,7 +21,7 @@ fn test_ser_and_deser<A>(a1: A,\n \n     // check the EBML serializer:\n     let buf = io::mem_buffer();\n-    let w = ebml::writer(buf as io::writer);\n+    let w = ebml::writer(buf as io::Writer);\n     ebml_ser_fn(w, a1);\n     let d = ebml::doc(@io::mem_buffer_buf(buf));\n     let a2 = ebml_deser_fn(ebml::ebml_deserializer(d));"}, {"sha": "719cda244b5c032c9bda7bb7d9da00aabb26ebbe", "filename": "src/test/run-pass/extern-mod-syntax.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Frun-pass%2Fextern-mod-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Frun-pass%2Fextern-mod-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-mod-syntax.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -0,0 +1,7 @@\n+extern mod std;\n+use std::map::hashmap;\n+\n+fn main() {\n+    io::println(\"Hello world!\");\n+}\n+"}, {"sha": "e245fba4f66d2eb25cb876a50b817650f211ccab", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -1,6 +1,6 @@\n use std;\n import io;\n-import io::writer_util;\n+import io::WriterUtil;\n import std::map::hashmap;\n \n enum object"}, {"sha": "c75880e146a2f9096b51dff8f2198db7dd418559", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de57e278d777102c589dbb96331b7013ab597a2/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=5de57e278d777102c589dbb96331b7013ab597a2", "patch": "@@ -45,8 +45,8 @@ fn square_from_char(c: char) -> square {\n     }\n }\n \n-fn read_board_grid<rdr: owned io::reader>(+in: rdr) -> ~[~[square]] {\n-    let in = in as io::reader;\n+fn read_board_grid<rdr: owned io::Reader>(+in: rdr) -> ~[~[square]] {\n+    let in = in as io::Reader;\n     let mut grid = ~[];\n     for in.each_line |line| {\n         let mut row = ~[];"}]}