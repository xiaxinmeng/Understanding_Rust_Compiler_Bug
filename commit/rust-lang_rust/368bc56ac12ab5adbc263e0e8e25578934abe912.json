{"sha": "368bc56ac12ab5adbc263e0e8e25578934abe912", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2OGJjNTZhYzEyYWI1YWRiYzI2M2UwZThlMjU1Nzg5MzRhYmU5MTI=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-21T14:36:08Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-21T14:36:08Z"}, "message": "Merge #873\n\n873: add API guide to ra_syntax r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "4e8ad24c1ca68b7cda79c9103a687c57a07b8fde", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e8ad24c1ca68b7cda79c9103a687c57a07b8fde"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/368bc56ac12ab5adbc263e0e8e25578934abe912", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/368bc56ac12ab5adbc263e0e8e25578934abe912", "html_url": "https://github.com/rust-lang/rust/commit/368bc56ac12ab5adbc263e0e8e25578934abe912", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/368bc56ac12ab5adbc263e0e8e25578934abe912/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "5cacdfcb3c666161dc41f59228eaaca5cfe8fc27", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27", "html_url": "https://github.com/rust-lang/rust/commit/5cacdfcb3c666161dc41f59228eaaca5cfe8fc27"}, {"sha": "4fe07a2b617f4dd3ed6053b5be5d856f45f8db35", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fe07a2b617f4dd3ed6053b5be5d856f45f8db35", "html_url": "https://github.com/rust-lang/rust/commit/4fe07a2b617f4dd3ed6053b5be5d856f45f8db35"}], "stats": {"total": 173, "additions": 173, "deletions": 0}, "files": [{"sha": "e7d402446cf1a90d15e03b0a9d89d9433a5539a1", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/368bc56ac12ab5adbc263e0e8e25578934abe912/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/368bc56ac12ab5adbc263e0e8e25578934abe912/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=368bc56ac12ab5adbc263e0e8e25578934abe912", "patch": "@@ -14,6 +14,8 @@\n //! CST). The actual parser live in a separate `ra_parser` crate, thought the\n //! lexer lives in this crate.\n //!\n+//! See `api_walkthrough` test in this file for a quick API tour!\n+//!\n //! [RFC]: <https://github.com/rust-lang/rfcs/pull/2256>\n //! [Swift]: <https://github.com/apple/swift/blob/13d593df6f359d0cb2fc81cfaac273297c539455/lib/Syntax/README.md>\n \n@@ -87,3 +89,174 @@ pub fn check_fuzz_invariants(text: &str) {\n     validation::validate_block_structure(root);\n     let _ = file.errors();\n }\n+\n+/// This test does not assert anything and instead just shows off the crate's\n+/// API.\n+#[test]\n+fn api_walkthrough() {\n+    use ast::{ModuleItemOwner, NameOwner};\n+\n+    let source_code = \"\n+        fn foo() {\n+            1 + 1\n+        }\n+    \";\n+    // `SourceFile` is the main entry point.\n+    //\n+    // Note how `parse` does not return a `Result`: even completely invalid\n+    // source code might be parsed.\n+    let file = SourceFile::parse(source_code);\n+\n+    // Due to the way ownership is set up, owned syntax Nodes always live behind\n+    // a `TreeArc` smart pointer. `TreeArc` is roughly an `std::sync::Arc` which\n+    // points to the whole file instead of an individual node.\n+    let file: TreeArc<SourceFile> = file;\n+\n+    // `SourceFile` is the root of the syntax tree. We can iterate file's items:\n+    let mut func = None;\n+    for item in file.items() {\n+        match item.kind() {\n+            ast::ModuleItemKind::FnDef(f) => func = Some(f),\n+            _ => unreachable!(),\n+        }\n+    }\n+    // The returned items are always references.\n+    let func: &ast::FnDef = func.unwrap();\n+\n+    // All nodes implement `ToOwned` trait, with `Owned = TreeArc<Self>`.\n+    // `to_owned` is a cheap operation: atomic increment.\n+    let _owned_func: TreeArc<ast::FnDef> = func.to_owned();\n+\n+    // Each AST node has a bunch of getters for children. All getters return\n+    // `Option`s though, to account for incomplete code. Some getters are common\n+    // for several kinds of node. In this case, a trait like `ast::NameOwner`\n+    // usually exists. By convention, all ast types should be used with `ast::`\n+    // qualifier.\n+    let name: Option<&ast::Name> = func.name();\n+    let name = name.unwrap();\n+    assert_eq!(name.text(), \"foo\");\n+\n+    // Let's get the `1 + 1` expression!\n+    let block: &ast::Block = func.body().unwrap();\n+    let expr: &ast::Expr = block.expr().unwrap();\n+\n+    // \"Enum\"-like nodes are represented using the \"kind\" pattern. It allows us\n+    // to match exhaustively against all flavors of nodes, while maintaining\n+    // internal representation flexibility. The drawback is that one can't write\n+    // nested matches as one pattern.\n+    let bin_expr: &ast::BinExpr = match expr.kind() {\n+        ast::ExprKind::BinExpr(e) => e,\n+        _ => unreachable!(),\n+    };\n+\n+    // Besides the \"typed\" AST API, there's an untyped CST one as well.\n+    // To switch from AST to CST, call `.syntax()` method:\n+    let expr_syntax: &SyntaxNode = expr.syntax();\n+\n+    // Note how `expr` and `bin_expr` are in fact the same node underneath:\n+    assert!(std::ptr::eq(expr_syntax, bin_expr.syntax()));\n+\n+    // To go from CST to AST, `AstNode::cast` function is used:\n+    let expr = match ast::Expr::cast(expr_syntax) {\n+        Some(e) => e,\n+        None => unreachable!(),\n+    };\n+\n+    // Note how expr is also a reference!\n+    let expr: &ast::Expr = expr;\n+\n+    // This is possible because the underlying representation is the same:\n+    assert_eq!(\n+        expr as *const ast::Expr as *const u8,\n+        expr_syntax as *const SyntaxNode as *const u8\n+    );\n+\n+    // The two properties each syntax node has is a `SyntaxKind`:\n+    assert_eq!(expr_syntax.kind(), SyntaxKind::BIN_EXPR);\n+\n+    // And text range:\n+    assert_eq!(expr_syntax.range(), TextRange::from_to(32.into(), 37.into()));\n+\n+    // You can get node's text as a `SyntaxText` object, which will traverse the\n+    // tree collecting token's text:\n+    let text: SyntaxText<'_> = expr_syntax.text();\n+    assert_eq!(text.to_string(), \"1 + 1\");\n+\n+    // There's a bunch of traversal methods on `SyntaxNode`:\n+    assert_eq!(expr_syntax.parent(), Some(block.syntax()));\n+    assert_eq!(block.syntax().first_child().map(|it| it.kind()), Some(SyntaxKind::L_CURLY));\n+    assert_eq!(expr_syntax.next_sibling().map(|it| it.kind()), Some(SyntaxKind::WHITESPACE));\n+\n+    // As well as some iterator helpers:\n+    let f = expr_syntax.ancestors().find_map(ast::FnDef::cast);\n+    assert_eq!(f, Some(&*func));\n+    assert!(expr_syntax.siblings(Direction::Next).any(|it| it.kind() == SyntaxKind::R_CURLY));\n+    assert_eq!(\n+        expr_syntax.descendants().count(),\n+        8, // 5 tokens `1`, ` `, `+`, ` `, `!`\n+           // 2 child literal expressions: `1`, `1`\n+           // 1 the node itself: `1 + 1`\n+    );\n+\n+    // There's also a `preorder` method with a more fine-grained iteration control:\n+    let mut buf = String::new();\n+    let mut indent = 0;\n+    for event in expr_syntax.preorder() {\n+        match event {\n+            WalkEvent::Enter(node) => {\n+                buf += &format!(\n+                    \"{:indent$}{:?} {:?}\\n\",\n+                    \" \",\n+                    node.text(),\n+                    node.kind(),\n+                    indent = indent\n+                );\n+                indent += 2;\n+            }\n+            WalkEvent::Leave(_) => indent -= 2,\n+        }\n+    }\n+    assert_eq!(indent, 0);\n+    assert_eq!(\n+        buf.trim(),\n+        r#\"\n+\"1 + 1\" BIN_EXPR\n+  \"1\" LITERAL\n+    \"1\" INT_NUMBER\n+  \" \" WHITESPACE\n+  \"+\" PLUS\n+  \" \" WHITESPACE\n+  \"1\" LITERAL\n+    \"1\" INT_NUMBER\n+\"#\n+        .trim()\n+    );\n+\n+    // To recursively process the tree, there are three approaches:\n+    // 1. explicitly call getter methods on AST nodes.\n+    // 2. use descendants and `AstNode::cast`.\n+    // 3. use descendants and the visitor.\n+    //\n+    // Here's how the first one looks like:\n+    let exprs_cast: Vec<String> = file\n+        .syntax()\n+        .descendants()\n+        .filter_map(ast::Expr::cast)\n+        .map(|expr| expr.syntax().text().to_string())\n+        .collect();\n+\n+    // An alternative is to use a visitor. The visitor does not do traversal\n+    // automatically (so it's more akin to a generic lambda) and is constructed\n+    // from closures. This seems more flexible than a single generated visitor\n+    // trait.\n+    use algo::visit::{visitor, Visitor};\n+    let mut exprs_visit = Vec::new();\n+    for node in file.syntax().descendants() {\n+        if let Some(result) =\n+            visitor().visit::<ast::Expr, _>(|expr| expr.syntax().text().to_string()).accept(node)\n+        {\n+            exprs_visit.push(result);\n+        }\n+    }\n+    assert_eq!(exprs_cast, exprs_visit);\n+}"}]}