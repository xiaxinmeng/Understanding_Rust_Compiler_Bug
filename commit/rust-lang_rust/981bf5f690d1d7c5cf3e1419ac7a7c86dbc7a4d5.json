{"sha": "981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4MWJmNWY2OTBkMWQ3YzVjZjNlMTQxOWFjN2E3Yzg2ZGJjN2E0ZDU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-11T22:24:14Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-13T17:00:28Z"}, "message": "Fallout of std::old_io deprecation", "tree": {"sha": "d586caea71713f14132ed0d78ec21077be97b91e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d586caea71713f14132ed0d78ec21077be97b91e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "html_url": "https://github.com/rust-lang/rust/commit/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d54bd9f29af67748b7ddf80a5cf285145949ddc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d54bd9f29af67748b7ddf80a5cf285145949ddc2", "html_url": "https://github.com/rust-lang/rust/commit/d54bd9f29af67748b7ddf80a5cf285145949ddc2"}], "stats": {"total": 1401, "additions": 608, "deletions": 793}, "files": [{"sha": "50e74a13ee2b76c9378c2f05076429e1633151ef", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -20,7 +20,6 @@\n #![feature(std_misc)]\n #![feature(test)]\n #![feature(core)]\n-#![feature(io)]\n #![feature(net)]\n #![feature(path_ext)]\n \n@@ -34,7 +33,6 @@ extern crate log;\n \n use std::env;\n use std::fs;\n-use std::old_io;\n use std::path::{Path, PathBuf};\n use std::thunk::Thunk;\n use getopts::{optopt, optflag, reqopt};\n@@ -246,7 +244,11 @@ pub fn run_tests(config: &Config) {\n     // sadly osx needs some file descriptor limits raised for running tests in\n     // parallel (especially when we have lots and lots of child processes).\n     // For context, see #8904\n-    old_io::test::raise_fd_limit();\n+    #[allow(deprecated)]\n+    fn raise_fd_limit() {\n+        std::old_io::test::raise_fd_limit();\n+    }\n+    raise_fd_limit();\n     // Prevent issue #21352 UAC blocking .exe containing 'patch' etc. on Windows\n     // If #11207 is resolved (adding manifest to .exe) this becomes unnecessary\n     env::set_var(\"__COMPAT_LAYER\", \"RunAsInvoker\");"}, {"sha": "475c0410135004278a83dc4400325c95d9325d54", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -26,7 +26,6 @@ use std::io::BufReader;\n use std::io::prelude::*;\n use std::iter::repeat;\n use std::net::TcpStream;\n-use std::old_io::timer;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Output, ExitStatus};\n use std::str;\n@@ -452,7 +451,11 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                 .expect(&format!(\"failed to exec `{:?}`\", config.adb_path));\n             loop {\n                 //waiting 1 second for gdbserver start\n-                timer::sleep(Duration::milliseconds(1000));\n+                #[allow(deprecated)]\n+                fn sleep() {\n+                    ::std::old_io::timer::sleep(Duration::milliseconds(1000));\n+                }\n+                sleep();\n                 if TcpStream::connect(\"127.0.0.1:5039\").is_ok() {\n                     break\n                 }"}, {"sha": "0e0804593443d5d733bb4e16b51fa1939b31d937", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 35, "deletions": 28, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -48,13 +48,14 @@\n //!\n //! ```rust\n //! use std::borrow::IntoCow;\n+//! use std::io::Write;\n //! use graphviz as dot;\n //!\n //! type Nd = int;\n //! type Ed = (int,int);\n //! struct Edges(Vec<Ed>);\n //!\n-//! pub fn render_to<W:Writer>(output: &mut W) {\n+//! pub fn render_to<W: Write>(output: &mut W) {\n //!     let edges = Edges(vec!((0,1), (0,2), (1,3), (2,3), (3,4), (4,4)));\n //!     dot::render(&edges, output).unwrap()\n //! }\n@@ -94,10 +95,10 @@\n //! ```\n //!\n //! ```no_run\n-//! # pub fn render_to<W:Writer>(output: &mut W) { unimplemented!() }\n+//! # pub fn render_to<W:std::io::Write>(output: &mut W) { unimplemented!() }\n //! pub fn main() {\n-//!     use std::old_io::File;\n-//!     let mut f = File::create(&Path::new(\"example1.dot\"));\n+//!     use std::fs::File;\n+//!     let mut f = File::create(\"example1.dot\").unwrap();\n //!     render_to(&mut f)\n //! }\n //! ```\n@@ -148,13 +149,14 @@\n //!\n //! ```rust\n //! use std::borrow::IntoCow;\n+//! use std::io::Write;\n //! use graphviz as dot;\n //!\n //! type Nd = uint;\n //! type Ed<'a> = &'a (uint, uint);\n //! struct Graph { nodes: Vec<&'static str>, edges: Vec<(uint,uint)> }\n //!\n-//! pub fn render_to<W:Writer>(output: &mut W) {\n+//! pub fn render_to<W: Write>(output: &mut W) {\n //!     let nodes = vec!(\"{x,y}\",\"{x}\",\"{y}\",\"{}\");\n //!     let edges = vec!((0,1), (0,2), (1,3), (2,3));\n //!     let graph = Graph { nodes: nodes, edges: edges };\n@@ -186,10 +188,10 @@\n //! ```\n //!\n //! ```no_run\n-//! # pub fn render_to<W:Writer>(output: &mut W) { unimplemented!() }\n+//! # pub fn render_to<W:std::io::Write>(output: &mut W) { unimplemented!() }\n //! pub fn main() {\n-//!     use std::old_io::File;\n-//!     let mut f = File::create(&Path::new(\"example2.dot\"));\n+//!     use std::fs::File;\n+//!     let mut f = File::create(\"example2.dot\").unwrap();\n //!     render_to(&mut f)\n //! }\n //! ```\n@@ -204,13 +206,14 @@\n //!\n //! ```rust\n //! use std::borrow::IntoCow;\n+//! use std::io::Write;\n //! use graphviz as dot;\n //!\n //! type Nd<'a> = (uint, &'a str);\n //! type Ed<'a> = (Nd<'a>, Nd<'a>);\n //! struct Graph { nodes: Vec<&'static str>, edges: Vec<(uint,uint)> }\n //!\n-//! pub fn render_to<W:Writer>(output: &mut W) {\n+//! pub fn render_to<W: Write>(output: &mut W) {\n //!     let nodes = vec!(\"{x,y}\",\"{x}\",\"{y}\",\"{}\");\n //!     let edges = vec!((0,1), (0,2), (1,3), (2,3));\n //!     let graph = Graph { nodes: nodes, edges: edges };\n@@ -250,10 +253,10 @@\n //! ```\n //!\n //! ```no_run\n-//! # pub fn render_to<W:Writer>(output: &mut W) { unimplemented!() }\n+//! # pub fn render_to<W:std::io::Write>(output: &mut W) { unimplemented!() }\n //! pub fn main() {\n-//!     use std::old_io::File;\n-//!     let mut f = File::create(&Path::new(\"example3.dot\"));\n+//!     use std::fs::File;\n+//!     let mut f = File::create(\"example3.dot\").unwrap();\n //!     render_to(&mut f)\n //! }\n //! ```\n@@ -277,12 +280,12 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n #![feature(int_uint)]\n #![feature(collections)]\n-#![feature(old_io)]\n \n use self::LabelText::*;\n \n use std::borrow::{IntoCow, Cow};\n-use std::old_io;\n+use std::io::prelude::*;\n+use std::io;\n \n /// The text for a graphviz label on a node or edge.\n pub enum LabelText<'a> {\n@@ -529,26 +532,26 @@ pub fn default_options() -> Vec<RenderOption> { vec![] }\n \n /// Renders directed graph `g` into the writer `w` in DOT syntax.\n /// (Simple wrapper around `render_opts` that passes a default set of options.)\n-pub fn render<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N,E>, W:Writer>(\n+pub fn render<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N,E>, W:Write>(\n               g: &'a G,\n-              w: &mut W) -> old_io::IoResult<()> {\n+              w: &mut W) -> io::Result<()> {\n     render_opts(g, w, &[])\n }\n \n /// Renders directed graph `g` into the writer `w` in DOT syntax.\n /// (Main entry point for the library.)\n-pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N,E>, W:Writer>(\n+pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N,E>, W:Write>(\n               g: &'a G,\n               w: &mut W,\n-              options: &[RenderOption]) -> old_io::IoResult<()>\n+              options: &[RenderOption]) -> io::Result<()>\n {\n-    fn writeln<W:Writer>(w: &mut W, arg: &[&str]) -> old_io::IoResult<()> {\n-        for &s in arg { try!(w.write_str(s)); }\n-        w.write_char('\\n')\n+    fn writeln<W:Write>(w: &mut W, arg: &[&str]) -> io::Result<()> {\n+        for &s in arg { try!(w.write_all(s.as_bytes())); }\n+        write!(w, \"\\n\")\n     }\n \n-    fn indent<W:Writer>(w: &mut W) -> old_io::IoResult<()> {\n-        w.write_str(\"    \")\n+    fn indent<W:Write>(w: &mut W) -> io::Result<()> {\n+        w.write_all(b\"    \")\n     }\n \n     try!(writeln(w, &[\"digraph \", g.graph_id().as_slice(), \" {\"]));\n@@ -589,7 +592,8 @@ mod tests {\n     use self::NodeLabels::*;\n     use super::{Id, Labeller, Nodes, Edges, GraphWalk, render};\n     use super::LabelText::{self, LabelStr, EscStr};\n-    use std::old_io::IoResult;\n+    use std::io;\n+    use std::io::prelude::*;\n     use std::borrow::IntoCow;\n     use std::iter::repeat;\n \n@@ -738,10 +742,12 @@ mod tests {\n         }\n     }\n \n-    fn test_input(g: LabelledGraph) -> IoResult<String> {\n+    fn test_input(g: LabelledGraph) -> io::Result<String> {\n         let mut writer = Vec::new();\n         render(&g, &mut writer).unwrap();\n-        (&mut &*writer).read_to_string()\n+        let mut s = String::new();\n+        try!(Read::read_to_string(&mut &*writer, &mut s));\n+        Ok(s)\n     }\n \n     // All of the tests use raw-strings as the format for the expected outputs,\n@@ -853,9 +859,10 @@ r#\"digraph hasse_diagram {\n                  edge(1, 3, \";\"),    edge(2, 3, \";\"   )));\n \n         render(&g, &mut writer).unwrap();\n-        let r = (&mut &*writer).read_to_string();\n+        let mut r = String::new();\n+        Read::read_to_string(&mut &*writer, &mut r).unwrap();\n \n-        assert_eq!(r.unwrap(),\n+        assert_eq!(r,\n r#\"digraph syntax_tree {\n     N0[label=\"if test {\\l    branch1\\l} else {\\l    branch2\\l}\\lafterward\\l\"];\n     N1[label=\"branch1\"];"}, {"sha": "b03d77db4ec9c29e57f3abcc8c73547d1e88472c", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -174,14 +174,14 @@\n #![feature(box_syntax)]\n #![feature(int_uint)]\n #![feature(core)]\n-#![feature(old_io)]\n #![feature(std_misc)]\n+#![feature(io)]\n \n use std::boxed;\n use std::cell::RefCell;\n use std::fmt;\n-use std::old_io::LineBufferedWriter;\n-use std::old_io;\n+use std::io::{self, Stderr};\n+use std::io::prelude::*;\n use std::mem;\n use std::env;\n use std::ptr;\n@@ -237,9 +237,7 @@ pub trait Logger {\n     fn log(&mut self, record: &LogRecord);\n }\n \n-struct DefaultLogger {\n-    handle: LineBufferedWriter<old_io::stdio::StdWriter>,\n-}\n+struct DefaultLogger { handle: Stderr }\n \n /// Wraps the log level with fmt implementations.\n #[derive(Copy, PartialEq, PartialOrd, Debug)]\n@@ -300,7 +298,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     let mut logger = LOCAL_LOGGER.with(|s| {\n         s.borrow_mut().take()\n     }).unwrap_or_else(|| {\n-        box DefaultLogger { handle: old_io::stderr() } as Box<Logger + Send>\n+        box DefaultLogger { handle: io::stderr() } as Box<Logger + Send>\n     });\n     logger.log(&LogRecord {\n         level: LogLevel(level),"}, {"sha": "bf4b5ee2c0e7498bad4c98656b101370984d9a6e", "filename": "src/librbml/io.rs", "status": "removed", "additions": 0, "deletions": 241, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/d54bd9f29af67748b7ddf80a5cf285145949ddc2/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d54bd9f29af67748b7ddf80a5cf285145949ddc2/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=d54bd9f29af67748b7ddf80a5cf285145949ddc2", "patch": "@@ -1,241 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::old_io::{IoError, IoResult, SeekStyle};\n-use std::old_io;\n-use std::slice;\n-use std::iter::repeat;\n-\n-const BUF_CAPACITY: uint = 128;\n-\n-fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> {\n-    // compute offset as signed and clamp to prevent overflow\n-    let pos = match seek {\n-        old_io::SeekSet => 0,\n-        old_io::SeekEnd => end,\n-        old_io::SeekCur => cur,\n-    } as i64;\n-\n-    if offset + pos < 0 {\n-        Err(IoError {\n-            kind: old_io::InvalidInput,\n-            desc: \"invalid seek to a negative offset\",\n-            detail: None\n-        })\n-    } else {\n-        Ok((offset + pos) as u64)\n-    }\n-}\n-\n-/// Writes to an owned, growable byte vector that supports seeking.\n-///\n-/// # Examples\n-///\n-/// ```rust\n-/// # #![allow(unused_must_use)]\n-/// use rbml::io::SeekableMemWriter;\n-///\n-/// let mut w = SeekableMemWriter::new();\n-/// w.write(&[0, 1, 2]);\n-///\n-/// assert_eq!(w.unwrap(), [0, 1, 2]);\n-/// ```\n-pub struct SeekableMemWriter {\n-    buf: Vec<u8>,\n-    pos: uint,\n-}\n-\n-impl SeekableMemWriter {\n-    /// Create a new `SeekableMemWriter`.\n-    #[inline]\n-    pub fn new() -> SeekableMemWriter {\n-        SeekableMemWriter::with_capacity(BUF_CAPACITY)\n-    }\n-    /// Create a new `SeekableMemWriter`, allocating at least `n` bytes for\n-    /// the internal buffer.\n-    #[inline]\n-    pub fn with_capacity(n: uint) -> SeekableMemWriter {\n-        SeekableMemWriter { buf: Vec::with_capacity(n), pos: 0 }\n-    }\n-\n-    /// Acquires an immutable reference to the underlying buffer of this\n-    /// `SeekableMemWriter`.\n-    ///\n-    /// No method is exposed for acquiring a mutable reference to the buffer\n-    /// because it could corrupt the state of this `MemWriter`.\n-    #[inline]\n-    pub fn get_ref<'a>(&'a self) -> &'a [u8] { &self.buf }\n-\n-    /// Unwraps this `SeekableMemWriter`, returning the underlying buffer\n-    #[inline]\n-    pub fn unwrap(self) -> Vec<u8> { self.buf }\n-}\n-\n-impl Writer for SeekableMemWriter {\n-    #[inline]\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        if self.pos == self.buf.len() {\n-            self.buf.push_all(buf)\n-        } else {\n-            // Make sure the internal buffer is as least as big as where we\n-            // currently are\n-            let difference = self.pos as i64 - self.buf.len() as i64;\n-            if difference > 0 {\n-                self.buf.extend(repeat(0).take(difference as uint));\n-            }\n-\n-            // Figure out what bytes will be used to overwrite what's currently\n-            // there (left), and what will be appended on the end (right)\n-            let cap = self.buf.len() - self.pos;\n-            let (left, right) = if cap <= buf.len() {\n-                (&buf[..cap], &buf[cap..])\n-            } else {\n-                let result: (_, &[_]) = (buf, &[]);\n-                result\n-            };\n-\n-            // Do the necessary writes\n-            if left.len() > 0 {\n-                slice::bytes::copy_memory(&mut self.buf[self.pos..], left);\n-            }\n-            if right.len() > 0 {\n-                self.buf.push_all(right);\n-            }\n-        }\n-\n-        // Bump us forward\n-        self.pos += buf.len();\n-        Ok(())\n-    }\n-}\n-\n-impl Seek for SeekableMemWriter {\n-    #[inline]\n-    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n-\n-    #[inline]\n-    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        let new = try!(combine(style, self.pos, self.buf.len(), pos));\n-        self.pos = new as uint;\n-        Ok(())\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    extern crate test;\n-    use super::SeekableMemWriter;\n-    use std::old_io;\n-    use std::iter::repeat;\n-    use test::Bencher;\n-\n-    #[test]\n-    fn test_seekable_mem_writer() {\n-        let mut writer = SeekableMemWriter::new();\n-        assert_eq!(writer.tell(), Ok(0));\n-        writer.write_all(&[0]).unwrap();\n-        assert_eq!(writer.tell(), Ok(1));\n-        writer.write_all(&[1, 2, 3]).unwrap();\n-        writer.write_all(&[4, 5, 6, 7]).unwrap();\n-        assert_eq!(writer.tell(), Ok(8));\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n-        assert_eq!(writer.get_ref(), b);\n-\n-        writer.seek(0, old_io::SeekSet).unwrap();\n-        assert_eq!(writer.tell(), Ok(0));\n-        writer.write_all(&[3, 4]).unwrap();\n-        let b: &[_] = &[3, 4, 2, 3, 4, 5, 6, 7];\n-        assert_eq!(writer.get_ref(), b);\n-\n-        writer.seek(1, old_io::SeekCur).unwrap();\n-        writer.write_all(&[0, 1]).unwrap();\n-        let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 7];\n-        assert_eq!(writer.get_ref(), b);\n-\n-        writer.seek(-1, old_io::SeekEnd).unwrap();\n-        writer.write_all(&[1, 2]).unwrap();\n-        let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2];\n-        assert_eq!(writer.get_ref(), b);\n-\n-        writer.seek(1, old_io::SeekEnd).unwrap();\n-        writer.write_all(&[1]).unwrap();\n-        let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1];\n-        assert_eq!(writer.get_ref(), b);\n-    }\n-\n-    #[test]\n-    fn seek_past_end() {\n-        let mut r = SeekableMemWriter::new();\n-        r.seek(10, old_io::SeekSet).unwrap();\n-        assert!(r.write_all(&[3]).is_ok());\n-    }\n-\n-    #[test]\n-    fn seek_before_0() {\n-        let mut r = SeekableMemWriter::new();\n-        assert!(r.seek(-1, old_io::SeekSet).is_err());\n-    }\n-\n-    fn do_bench_seekable_mem_writer(b: &mut Bencher, times: uint, len: uint) {\n-        let src: Vec<u8> = repeat(5).take(len).collect();\n-\n-        b.bytes = (times * len) as u64;\n-        b.iter(|| {\n-            let mut wr = SeekableMemWriter::new();\n-            for _ in 0..times {\n-                wr.write_all(&src).unwrap();\n-            }\n-\n-            let v = wr.unwrap();\n-            assert_eq!(v.len(), times * len);\n-            assert!(v.iter().all(|x| *x == 5));\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_seekable_mem_writer_001_0000(b: &mut Bencher) {\n-        do_bench_seekable_mem_writer(b, 1, 0)\n-    }\n-\n-    #[bench]\n-    fn bench_seekable_mem_writer_001_0010(b: &mut Bencher) {\n-        do_bench_seekable_mem_writer(b, 1, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_seekable_mem_writer_001_0100(b: &mut Bencher) {\n-        do_bench_seekable_mem_writer(b, 1, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_seekable_mem_writer_001_1000(b: &mut Bencher) {\n-        do_bench_seekable_mem_writer(b, 1, 1000)\n-    }\n-\n-    #[bench]\n-    fn bench_seekable_mem_writer_100_0000(b: &mut Bencher) {\n-        do_bench_seekable_mem_writer(b, 100, 0)\n-    }\n-\n-    #[bench]\n-    fn bench_seekable_mem_writer_100_0010(b: &mut Bencher) {\n-        do_bench_seekable_mem_writer(b, 100, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_seekable_mem_writer_100_0100(b: &mut Bencher) {\n-        do_bench_seekable_mem_writer(b, 100, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_seekable_mem_writer_100_1000(b: &mut Bencher) {\n-        do_bench_seekable_mem_writer(b, 100, 1000)\n-    }\n-}"}, {"sha": "5d1fbc32f14b75e37977ca6ff3dfb85e1eba59c8", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 32, "deletions": 47, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -123,10 +123,9 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![feature(collections)]\n+#![feature(io)]\n #![feature(core)]\n #![feature(int_uint)]\n-#![feature(old_io)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n \n@@ -143,8 +142,6 @@ pub use self::Error::*;\n use std::str;\n use std::fmt;\n \n-pub mod io;\n-\n /// Common data structures\n #[derive(Clone, Copy)]\n pub struct Doc<'a> {\n@@ -228,7 +225,7 @@ pub enum Error {\n     IntTooBig(uint),\n     InvalidTag(uint),\n     Expected(String),\n-    IoError(std::old_io::IoError),\n+    IoError(std::io::Error),\n     ApplicationError(String)\n }\n \n@@ -840,73 +837,63 @@ pub mod reader {\n pub mod writer {\n     use std::mem;\n     use std::num::Int;\n-    use std::old_io::{Writer, Seek};\n-    use std::old_io;\n+    use std::io::prelude::*;\n+    use std::io::{self, SeekFrom, Cursor};\n     use std::slice::bytes;\n     use std::num::ToPrimitive;\n \n     use super::{ EsVec, EsMap, EsEnum, EsSub8, EsSub32, EsVecElt, EsMapKey,\n         EsU64, EsU32, EsU16, EsU8, EsI64, EsI32, EsI16, EsI8,\n         EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal,\n         EsOpaque, NUM_IMPLICIT_TAGS, NUM_TAGS };\n-    use super::io::SeekableMemWriter;\n \n     use serialize;\n \n \n-    pub type EncodeResult = old_io::IoResult<()>;\n+    pub type EncodeResult = io::Result<()>;\n \n     // rbml writing\n     pub struct Encoder<'a> {\n-        pub writer: &'a mut SeekableMemWriter,\n-        size_positions: Vec<uint>,\n+        pub writer: &'a mut Cursor<Vec<u8>>,\n+        size_positions: Vec<u64>,\n         relax_limit: u64, // do not move encoded bytes before this position\n     }\n \n-    fn write_tag<W: Writer>(w: &mut W, n: uint) -> EncodeResult {\n+    fn write_tag<W: Write>(w: &mut W, n: uint) -> EncodeResult {\n         if n < 0xf0 {\n             w.write_all(&[n as u8])\n         } else if 0x100 <= n && n < NUM_TAGS {\n             w.write_all(&[0xf0 | (n >> 8) as u8, n as u8])\n         } else {\n-            Err(old_io::IoError {\n-                kind: old_io::OtherIoError,\n-                desc: \"invalid tag\",\n-                detail: Some(format!(\"{}\", n))\n-            })\n+            Err(io::Error::new(io::ErrorKind::Other, \"invalid tag\",\n+                               Some(n.to_string())))\n         }\n     }\n \n-    fn write_sized_vuint<W: Writer>(w: &mut W, n: uint, size: uint) -> EncodeResult {\n+    fn write_sized_vuint<W: Write>(w: &mut W, n: uint, size: uint) -> EncodeResult {\n         match size {\n             1 => w.write_all(&[0x80 | (n as u8)]),\n             2 => w.write_all(&[0x40 | ((n >> 8) as u8), n as u8]),\n             3 => w.write_all(&[0x20 | ((n >> 16) as u8), (n >> 8) as u8,\n                             n as u8]),\n             4 => w.write_all(&[0x10 | ((n >> 24) as u8), (n >> 16) as u8,\n                             (n >> 8) as u8, n as u8]),\n-            _ => Err(old_io::IoError {\n-                kind: old_io::OtherIoError,\n-                desc: \"int too big\",\n-                detail: Some(format!(\"{}\", n))\n-            })\n+            _ => Err(io::Error::new(io::ErrorKind::Other,\n+                                    \"int too big\", Some(n.to_string())))\n         }\n     }\n \n-    fn write_vuint<W: Writer>(w: &mut W, n: uint) -> EncodeResult {\n+    fn write_vuint<W: Write>(w: &mut W, n: uint) -> EncodeResult {\n         if n < 0x7f { return write_sized_vuint(w, n, 1); }\n         if n < 0x4000 { return write_sized_vuint(w, n, 2); }\n         if n < 0x200000 { return write_sized_vuint(w, n, 3); }\n         if n < 0x10000000 { return write_sized_vuint(w, n, 4); }\n-        Err(old_io::IoError {\n-            kind: old_io::OtherIoError,\n-            desc: \"int too big\",\n-            detail: Some(format!(\"{}\", n))\n-        })\n+        Err(io::Error::new(io::ErrorKind::Other, \"int too big\",\n+                           Some(n.to_string())))\n     }\n \n     impl<'a> Encoder<'a> {\n-        pub fn new(w: &'a mut SeekableMemWriter) -> Encoder<'a> {\n+        pub fn new(w: &'a mut Cursor<Vec<u8>>) -> Encoder<'a> {\n             Encoder {\n                 writer: w,\n                 size_positions: vec!(),\n@@ -931,24 +918,26 @@ pub mod writer {\n             try!(write_tag(self.writer, tag_id));\n \n             // Write a placeholder four-byte size.\n-            self.size_positions.push(try!(self.writer.tell()) as uint);\n+            let cur_pos = try!(self.writer.seek(SeekFrom::Current(0)));\n+            self.size_positions.push(cur_pos);\n             let zeroes: &[u8] = &[0, 0, 0, 0];\n             self.writer.write_all(zeroes)\n         }\n \n         pub fn end_tag(&mut self) -> EncodeResult {\n             let last_size_pos = self.size_positions.pop().unwrap();\n-            let cur_pos = try!(self.writer.tell());\n-            try!(self.writer.seek(last_size_pos as i64, old_io::SeekSet));\n-            let size = cur_pos as uint - last_size_pos - 4;\n+            let cur_pos = try!(self.writer.seek(SeekFrom::Current(0)));\n+            try!(self.writer.seek(SeekFrom::Start(last_size_pos)));\n+            let size = (cur_pos - last_size_pos - 4) as usize;\n \n             // relax the size encoding for small tags (bigger tags are costly to move).\n             // we should never try to move the stable positions, however.\n             const RELAX_MAX_SIZE: uint = 0x100;\n-            if size <= RELAX_MAX_SIZE && last_size_pos >= self.relax_limit as uint {\n+            if size <= RELAX_MAX_SIZE && last_size_pos >= self.relax_limit {\n                 // we can't alter the buffer in place, so have a temporary buffer\n                 let mut buf = [0u8; RELAX_MAX_SIZE];\n                 {\n+                    let last_size_pos = last_size_pos as usize;\n                     let data = &self.writer.get_ref()[last_size_pos+4..cur_pos as uint];\n                     bytes::copy_memory(&mut buf, data);\n                 }\n@@ -959,7 +948,7 @@ pub mod writer {\n             } else {\n                 // overwrite the size with an overlong encoding and skip past the data\n                 try!(write_sized_vuint(self.writer, size, 4));\n-                try!(self.writer.seek(cur_pos as i64, old_io::SeekSet));\n+                try!(self.writer.seek(SeekFrom::Start(cur_pos)));\n             }\n \n             debug!(\"End tag (size = {:?})\", size);\n@@ -1074,7 +1063,7 @@ pub mod writer {\n         /// Returns the current position while marking it stable, i.e.\n         /// generated bytes so far woundn't be affected by relaxation.\n         pub fn mark_stable_position(&mut self) -> u64 {\n-            let pos = self.writer.tell().unwrap();\n+            let pos = self.writer.seek(SeekFrom::Current(0)).unwrap();\n             if self.relax_limit < pos {\n                 self.relax_limit = pos;\n             }\n@@ -1090,11 +1079,9 @@ pub mod writer {\n             } else if let Some(v) = v.to_u32() {\n                 self.wr_tagged_raw_u32(EsSub32 as uint, v)\n             } else {\n-                Err(old_io::IoError {\n-                    kind: old_io::OtherIoError,\n-                    desc: \"length or variant id too big\",\n-                    detail: Some(format!(\"{}\", v))\n-                })\n+                Err(io::Error::new(io::ErrorKind::Other,\n+                                   \"length or variant id too big\",\n+                                   Some(v.to_string())))\n             }\n         }\n \n@@ -1108,7 +1095,7 @@ pub mod writer {\n     }\n \n     impl<'a> serialize::Encoder for Encoder<'a> {\n-        type Error = old_io::IoError;\n+        type Error = io::Error;\n \n         fn emit_nil(&mut self) -> EncodeResult {\n             Ok(())\n@@ -1339,12 +1326,10 @@ pub mod writer {\n #[cfg(test)]\n mod tests {\n     use super::{Doc, reader, writer};\n-    use super::io::SeekableMemWriter;\n \n     use serialize::{Encodable, Decodable};\n \n-    use std::option::Option;\n-    use std::option::Option::{None, Some};\n+    use std::io::Cursor;\n \n     #[test]\n     fn test_vuint_at() {\n@@ -1398,7 +1383,7 @@ mod tests {\n     fn test_option_int() {\n         fn test_v(v: Option<int>) {\n             debug!(\"v == {:?}\", v);\n-            let mut wr = SeekableMemWriter::new();\n+            let mut wr = Cursor::new(Vec::new());\n             {\n                 let mut rbml_w = writer::Encoder::new(&mut wr);\n                 let _ = v.encode(&mut rbml_w);"}, {"sha": "60102040bcad8d0e9b71afdd18702fb0cc77488b", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -31,7 +31,6 @@\n #![feature(core)]\n #![feature(hash)]\n #![feature(int_uint)]\n-#![feature(old_io)]\n #![feature(libc)]\n #![feature(old_path)]\n #![feature(quote)]"}, {"sha": "10461e3d2aedfc38b2f51f9a0bd78f6fe97e5bde", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 48, "deletions": 38, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -30,6 +30,8 @@ use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n use serialize::Encodable;\n use std::cell::RefCell;\n use std::hash::{Hash, Hasher, SipHasher};\n+use std::io::prelude::*;\n+use std::io::{Cursor, SeekFrom};\n use syntax::abi;\n use syntax::ast::{self, DefId, NodeId};\n use syntax::ast_map::{PathElem, PathElems};\n@@ -47,7 +49,6 @@ use syntax::visit::Visitor;\n use syntax::visit;\n use syntax;\n use rbml::writer::Encoder;\n-use rbml::io::SeekableMemWriter;\n \n /// A borrowed version of `ast::InlinedItem`.\n pub enum InlinedItemRef<'a> {\n@@ -1530,7 +1531,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n // Path and definition ID indexing\n \n fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn: F) where\n-    F: FnMut(&mut SeekableMemWriter, &T),\n+    F: FnMut(&mut Cursor<Vec<u8>>, &T),\n     T: Hash,\n {\n     let mut buckets: Vec<Vec<entry<T>>> = (0..256u16).map(|_| Vec::new()).collect();\n@@ -1551,8 +1552,8 @@ fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn:\n             rbml_w.start_tag(tag_index_buckets_bucket_elt);\n             assert!(elt.pos < 0xffff_ffff);\n             {\n-                let wr: &mut SeekableMemWriter = rbml_w.writer;\n-                wr.write_be_u32(elt.pos as u32);\n+                let wr: &mut Cursor<Vec<u8>> = rbml_w.writer;\n+                write_be_u32(wr, elt.pos as u32);\n             }\n             write_fn(rbml_w.writer, &elt.val);\n             rbml_w.end_tag();\n@@ -1563,17 +1564,26 @@ fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn:\n     rbml_w.start_tag(tag_index_table);\n     for pos in &bucket_locs {\n         assert!(*pos < 0xffff_ffff);\n-        let wr: &mut SeekableMemWriter = rbml_w.writer;\n-        wr.write_be_u32(*pos as u32);\n+        let wr: &mut Cursor<Vec<u8>> = rbml_w.writer;\n+        write_be_u32(wr, *pos as u32);\n     }\n     rbml_w.end_tag();\n     rbml_w.end_tag();\n }\n \n-fn write_i64(writer: &mut SeekableMemWriter, &n: &i64) {\n-    let wr: &mut SeekableMemWriter = writer;\n+fn write_i64(writer: &mut Cursor<Vec<u8>>, &n: &i64) {\n+    let wr: &mut Cursor<Vec<u8>> = writer;\n     assert!(n < 0x7fff_ffff);\n-    wr.write_be_u32(n as u32);\n+    write_be_u32(wr, n as u32);\n+}\n+\n+fn write_be_u32(w: &mut Write, u: u32) {\n+    w.write_all(&[\n+        (u >> 24) as u8,\n+        (u >> 16) as u8,\n+        (u >>  8) as u8,\n+        (u >>  0) as u8,\n+    ]);\n }\n \n fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n@@ -1929,13 +1939,13 @@ fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n pub const metadata_encoding_version : &'static [u8] = &[b'r', b'u', b's', b't', 0, 0, 0, 2 ];\n \n pub fn encode_metadata(parms: EncodeParams, krate: &ast::Crate) -> Vec<u8> {\n-    let mut wr = SeekableMemWriter::new();\n+    let mut wr = Cursor::new(Vec::new());\n     encode_metadata_inner(&mut wr, parms, krate);\n \n     // RBML compacts the encoded bytes whenever appropriate,\n     // so there are some garbages left after the end of the data.\n-    let metalen = wr.tell().unwrap() as uint;\n-    let mut v = wr.unwrap();\n+    let metalen = wr.seek(SeekFrom::Current(0)).unwrap() as uint;\n+    let mut v = wr.into_inner();\n     v.truncate(metalen);\n     assert_eq!(v.len(), metalen);\n \n@@ -1965,7 +1975,7 @@ pub fn encode_metadata(parms: EncodeParams, krate: &ast::Crate) -> Vec<u8> {\n     return v;\n }\n \n-fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n+fn encode_metadata_inner(wr: &mut Cursor<Vec<u8>>,\n                          parms: EncodeParams,\n                          krate: &ast::Crate) {\n     struct Stats {\n@@ -2032,64 +2042,64 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n     encode_hash(&mut rbml_w, &ecx.link_meta.crate_hash);\n     encode_dylib_dependency_formats(&mut rbml_w, &ecx);\n \n-    let mut i = rbml_w.writer.tell().unwrap();\n+    let mut i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n     encode_attributes(&mut rbml_w, &krate.attrs);\n-    stats.attr_bytes = rbml_w.writer.tell().unwrap() - i;\n+    stats.attr_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n-    i = rbml_w.writer.tell().unwrap();\n+    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n     encode_crate_deps(&mut rbml_w, ecx.cstore);\n-    stats.dep_bytes = rbml_w.writer.tell().unwrap() - i;\n+    stats.dep_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode the language items.\n-    i = rbml_w.writer.tell().unwrap();\n+    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n     encode_lang_items(&ecx, &mut rbml_w);\n-    stats.lang_item_bytes = rbml_w.writer.tell().unwrap() - i;\n+    stats.lang_item_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode the native libraries used\n-    i = rbml_w.writer.tell().unwrap();\n+    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n     encode_native_libraries(&ecx, &mut rbml_w);\n-    stats.native_lib_bytes = rbml_w.writer.tell().unwrap() - i;\n+    stats.native_lib_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode the plugin registrar function\n-    i = rbml_w.writer.tell().unwrap();\n+    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n     encode_plugin_registrar_fn(&ecx, &mut rbml_w);\n-    stats.plugin_registrar_fn_bytes = rbml_w.writer.tell().unwrap() - i;\n+    stats.plugin_registrar_fn_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode codemap\n-    i = rbml_w.writer.tell().unwrap();\n+    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n     encode_codemap(&ecx, &mut rbml_w);\n-    stats.codemap_bytes = rbml_w.writer.tell().unwrap() - i;\n+    stats.codemap_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode macro definitions\n-    i = rbml_w.writer.tell().unwrap();\n+    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n     encode_macro_defs(&mut rbml_w, krate);\n-    stats.macro_defs_bytes = rbml_w.writer.tell().unwrap() - i;\n+    stats.macro_defs_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode the def IDs of impls, for coherence checking.\n-    i = rbml_w.writer.tell().unwrap();\n+    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n     encode_impls(&ecx, krate, &mut rbml_w);\n-    stats.impl_bytes = rbml_w.writer.tell().unwrap() - i;\n+    stats.impl_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode miscellaneous info.\n-    i = rbml_w.writer.tell().unwrap();\n+    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n     encode_misc_info(&ecx, krate, &mut rbml_w);\n     encode_reachable_extern_fns(&ecx, &mut rbml_w);\n-    stats.misc_bytes = rbml_w.writer.tell().unwrap() - i;\n+    stats.misc_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n     // Encode and index the items.\n     rbml_w.start_tag(tag_items);\n-    i = rbml_w.writer.tell().unwrap();\n+    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n     let items_index = encode_info_for_items(&ecx, &mut rbml_w, krate);\n-    stats.item_bytes = rbml_w.writer.tell().unwrap() - i;\n+    stats.item_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n-    i = rbml_w.writer.tell().unwrap();\n+    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n     encode_index(&mut rbml_w, items_index, write_i64);\n-    stats.index_bytes = rbml_w.writer.tell().unwrap() - i;\n+    stats.index_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n     rbml_w.end_tag();\n \n     encode_struct_field_attrs(&mut rbml_w, krate);\n \n-    stats.total_bytes = rbml_w.writer.tell().unwrap();\n+    stats.total_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n \n     if tcx.sess.meta_stats() {\n         for e in rbml_w.writer.get_ref() {\n@@ -2117,12 +2127,12 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n \n // Get the encoded string for a type\n pub fn encoded_ty<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> String {\n-    let mut wr = SeekableMemWriter::new();\n+    let mut wr = Cursor::new(Vec::new());\n     tyencode::enc_ty(&mut Encoder::new(&mut wr), &tyencode::ctxt {\n         diag: tcx.sess.diagnostic(),\n         ds: def_to_string,\n         tcx: tcx,\n         abbrevs: &RefCell::new(FnvHashMap())\n     }, t);\n-    String::from_utf8(wr.unwrap()).unwrap()\n+    String::from_utf8(wr.into_inner()).unwrap()\n }"}, {"sha": "b0fa0e757fe05b1f0a644e230653574cf9d8da8b", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -14,6 +14,7 @@\n #![allow(non_camel_case_types)]\n \n use std::cell::RefCell;\n+use std::io::prelude::*;\n \n use middle::region;\n use middle::subst;"}, {"sha": "ed1d876d83619040457d081243ee4777ab6601a0", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -38,10 +38,11 @@ use syntax::parse::token;\n use syntax::ptr::P;\n use syntax;\n \n-use std::old_io::Seek;\n+use std::cell::Cell;\n+use std::io::SeekFrom;\n+use std::io::prelude::*;\n use std::num::FromPrimitive;\n use std::rc::Rc;\n-use std::cell::Cell;\n \n use rbml::reader;\n use rbml::writer::Encoder;\n@@ -50,7 +51,7 @@ use serialize;\n use serialize::{Decodable, Decoder, DecoderHelpers, Encodable};\n use serialize::{EncoderHelpers};\n \n-#[cfg(test)] use rbml::io::SeekableMemWriter;\n+#[cfg(test)] use std::io::Cursor;\n #[cfg(test)] use syntax::parse;\n #[cfg(test)] use syntax::print::pprust;\n \n@@ -85,7 +86,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n     };\n     debug!(\"> Encoding inlined item: {} ({:?})\",\n            ecx.tcx.map.path_to_string(id),\n-           rbml_w.writer.tell());\n+           rbml_w.writer.seek(SeekFrom::Current(0)));\n \n     // Folding could be avoided with a smarter encoder.\n     let ii = simplify_ast(ii);\n@@ -99,7 +100,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n \n     debug!(\"< Encoded inlined fn: {} ({:?})\",\n            ecx.tcx.map.path_to_string(id),\n-           rbml_w.writer.tell());\n+           rbml_w.writer.seek(SeekFrom::Current(0)));\n }\n \n impl<'a, 'b, 'c, 'tcx> ast_map::FoldOps for &'a DecodeContext<'b, 'c, 'tcx> {\n@@ -1974,7 +1975,7 @@ fn mk_ctxt() -> parse::ParseSess {\n #[cfg(test)]\n fn roundtrip(in_item: Option<P<ast::Item>>) {\n     let in_item = in_item.unwrap();\n-    let mut wr = SeekableMemWriter::new();\n+    let mut wr = Cursor::new(Vec::new());\n     encode_item_ast(&mut Encoder::new(&mut wr), &*in_item);\n     let rbml_doc = rbml::Doc::new(wr.get_ref());\n     let out_item = decode_item_ast(rbml_doc);"}, {"sha": "932c9c61ef1fbb53ef4006201de88feea96f0f31", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -118,9 +118,11 @@ use middle::ty::ClosureTyper;\n use lint;\n use util::nodemap::NodeMap;\n \n-use std::{fmt, old_io, usize};\n-use std::rc::Rc;\n+use std::{fmt, usize};\n+use std::io::prelude::*;\n+use std::io;\n use std::iter::repeat;\n+use std::rc::Rc;\n use syntax::ast::{self, NodeId, Expr};\n use syntax::codemap::{BytePos, original_sp, Span};\n use syntax::parse::token::{self, special_idents};\n@@ -680,10 +682,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn write_vars<F>(&self,\n-                     wr: &mut old_io::Writer,\n+                     wr: &mut Write,\n                      ln: LiveNode,\n                      mut test: F)\n-                     -> old_io::IoResult<()> where\n+                     -> io::Result<()> where\n         F: FnMut(usize) -> LiveNode,\n     {\n         let node_base_idx = self.idx(ln, Variable(0));\n@@ -727,7 +729,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn ln_str(&self, ln: LiveNode) -> String {\n         let mut wr = Vec::new();\n         {\n-            let wr = &mut wr as &mut old_io::Writer;\n+            let wr = &mut wr as &mut Write;\n             write!(wr, \"[ln({:?}) of kind {:?} reads\", ln.get(), self.ir.lnk(ln));\n             self.write_vars(wr, ln, |idx| self.users[idx].reader);\n             write!(wr, \"  writes\");"}, {"sha": "6a6502800f683e17bec25099fd490f4683f36ca6", "filename": "src/librustc_back/fs.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -9,11 +9,8 @@\n // except according to those terms.\n \n use std::io;\n-use std::old_io::fs;\n-use std::old_io;\n-#[allow(deprecated)]\n-use std::old_path;\n-use std::os;\n+#[allow(deprecated)] use std::old_path;\n+#[allow(deprecated)] use std::old_io;\n use std::path::{Path, PathBuf};\n \n /// Returns an absolute path in the filesystem that `path` points to. The\n@@ -31,6 +28,8 @@ pub fn realpath(original: &Path) -> io::Result<PathBuf> {\n \n #[allow(deprecated)]\n fn old_realpath(original: &old_path::Path) -> old_io::IoResult<old_path::Path> {\n+    use std::old_io::fs;\n+    use std::os;\n     const MAX_LINKS_FOLLOWED: usize = 256;\n     let original = try!(os::getcwd()).join(original);\n "}, {"sha": "e0261606ef12fb21e944bea7851c19d701b74493", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -29,7 +29,6 @@\n #![feature(collections)]\n #![feature(core)]\n #![feature(int_uint)]\n-#![feature(old_io)]\n #![feature(libc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n@@ -38,6 +37,7 @@\n #![feature(staged_api)]\n #![feature(exit_status)]\n #![feature(io)]\n+#![feature(set_panic)]\n \n extern crate arena;\n extern crate flate;\n@@ -74,10 +74,11 @@ use rustc::util::common::time;\n \n use std::cmp::Ordering::Equal;\n use std::env;\n+use std::io::{self, Read, Write};\n use std::iter::repeat;\n-use std::old_io::{self, stdio};\n use std::path::PathBuf;\n-use std::sync::mpsc::channel;\n+use std::str;\n+use std::sync::{Arc, Mutex};\n use std::thread;\n \n use rustc::session::early_error;\n@@ -171,8 +172,8 @@ fn make_input(free_matches: &[String]) -> Option<(Input, Option<PathBuf>)> {\n     if free_matches.len() == 1 {\n         let ifile = &free_matches[0][..];\n         if ifile == \"-\" {\n-            let contents = old_io::stdin().read_to_end().unwrap();\n-            let src = String::from_utf8(contents).unwrap();\n+            let mut src = String::new();\n+            io::stdin().read_to_string(&mut src).unwrap();\n             Some((Input::Str(src), None))\n         } else {\n             Some((Input::File(PathBuf::new(ifile)), Some(PathBuf::new(ifile))))\n@@ -794,9 +795,16 @@ fn parse_crate_attrs(sess: &Session, input: &Input) ->\n pub fn monitor<F:FnOnce()+Send+'static>(f: F) {\n     const STACK_SIZE: uint = 8 * 1024 * 1024; // 8MB\n \n-    let (tx, rx) = channel();\n-    let w = old_io::ChanWriter::new(tx);\n-    let mut r = old_io::ChanReader::new(rx);\n+    struct Sink(Arc<Mutex<Vec<u8>>>);\n+    impl Write for Sink {\n+        fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+            Write::write(&mut *self.0.lock().unwrap(), data)\n+        }\n+        fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+    }\n+\n+    let data = Arc::new(Mutex::new(Vec::new()));\n+    let err = Sink(data.clone());\n \n     let mut cfg = thread::Builder::new().name(\"rustc\".to_string());\n \n@@ -806,7 +814,7 @@ pub fn monitor<F:FnOnce()+Send+'static>(f: F) {\n         cfg = cfg.stack_size(STACK_SIZE);\n     }\n \n-    match cfg.spawn(move || { stdio::set_stderr(box w); f() }).unwrap().join() {\n+    match cfg.spawn(move || { io::set_panic(box err); f() }).unwrap().join() {\n         Ok(()) => { /* fallthrough */ }\n         Err(value) => {\n             // Thread panicked without emitting a fatal diagnostic\n@@ -833,22 +841,13 @@ pub fn monitor<F:FnOnce()+Send+'static>(f: F) {\n                     emitter.emit(None, &note[..], None, diagnostic::Note)\n                 }\n \n-                match r.read_to_string() {\n-                    Ok(s) => println!(\"{}\", s),\n-                    Err(e) => {\n-                        emitter.emit(None,\n-                                     &format!(\"failed to read internal \\\n-                                              stderr: {}\", e),\n-                                     None,\n-                                     diagnostic::Error)\n-                    }\n-                }\n+                println!(\"{}\", str::from_utf8(&data.lock().unwrap()).unwrap());\n             }\n \n             // Panic so the process returns a failure code, but don't pollute the\n             // output with some unnecessary panic messages, we've already\n             // printed everything that we needed to.\n-            old_io::stdio::set_stderr(box old_io::util::NullWriter);\n+            io::set_panic(box io::sink());\n             panic!();\n         }\n     }"}, {"sha": "9e693a64ef0a2bf5710e77d22c5b513da98a806d", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -40,7 +40,6 @@ use graphviz as dot;\n \n use std::fs::File;\n use std::io::{self, Write};\n-use std::old_io;\n use std::option;\n use std::path::PathBuf;\n use std::str::FromStr;\n@@ -615,7 +614,7 @@ pub fn pretty_print_input(sess: Session,\n             });\n \n             let code = blocks::Code::from_node(node);\n-            let out: &mut Writer = &mut out;\n+            let out: &mut Write = &mut out;\n             match code {\n                 Some(code) => {\n                     let variants = gather_flowgraph_variants(&sess);\n@@ -654,11 +653,11 @@ pub fn pretty_print_input(sess: Session,\n     }\n }\n \n-fn print_flowgraph<W:old_io::Writer>(variants: Vec<borrowck_dot::Variant>,\n-                                 analysis: ty::CrateAnalysis,\n-                                 code: blocks::Code,\n-                                 mode: PpFlowGraphMode,\n-                                 mut out: W) -> io::Result<()> {\n+fn print_flowgraph<W: Write>(variants: Vec<borrowck_dot::Variant>,\n+                             analysis: ty::CrateAnalysis,\n+                             code: blocks::Code,\n+                             mode: PpFlowGraphMode,\n+                             mut out: W) -> io::Result<()> {\n     let ty_cx = &analysis.ty_cx;\n     let cfg = match code {\n         blocks::BlockCode(block) => cfg::CFG::new(ty_cx, &*block),\n@@ -698,7 +697,7 @@ fn print_flowgraph<W:old_io::Writer>(variants: Vec<borrowck_dot::Variant>,\n         }\n     }\n \n-    fn expand_err_details(r: old_io::IoResult<()>) -> io::Result<()> {\n+    fn expand_err_details(r: io::Result<()>) -> io::Result<()> {\n         r.map_err(|ioerr| {\n             io::Error::new(io::ErrorKind::Other, \"graphviz::render failed\",\n                            Some(ioerr.to_string()))"}, {"sha": "efc81da560b6e262e0cc9ed52f9eaa50fe4781ad", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -38,7 +38,6 @@\n #![feature(unsafe_destructor)]\n #![feature(staged_api)]\n #![feature(unicode)]\n-#![feature(io)]\n #![feature(path_ext)]\n #![feature(fs)]\n #![feature(hash)]"}, {"sha": "c2b6c940caea29291b36fa179c28d706e05b315c", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -11,7 +11,6 @@\n use std::fs::File;\n use std::io::prelude::*;\n use std::io;\n-use std::old_io;\n use std::path::{PathBuf, Path};\n use std::str;\n \n@@ -51,12 +50,12 @@ macro_rules! load_or_return {\n             let input = PathBuf::new($input);\n             match ::externalfiles::load_string(&input) {\n                 Err(e) => {\n-                    let _ = writeln!(&mut old_io::stderr(),\n+                    let _ = writeln!(&mut io::stderr(),\n                                      \"error reading `{}`: {}\", input.display(), e);\n                     return $cant_read;\n                 }\n                 Ok(None) => {\n-                    let _ = writeln!(&mut old_io::stderr(),\n+                    let _ = writeln!(&mut io::stderr(),\n                                      \"error reading `{}`: not UTF-8\", input.display());\n                     return $not_utf8;\n                 }"}, {"sha": "8c85eaff23ce5610646d337a94d837d878859b1c", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -23,8 +23,8 @@ mod imp {\n     use std::ffi::{AsOsStr, CString};\n     use std::os::unix::prelude::*;\n     use std::path::Path;\n+    use std::io;\n     use libc;\n-    use std::os as stdos;\n \n     #[cfg(target_os = \"linux\")]\n     mod os {\n@@ -121,8 +121,8 @@ mod imp {\n                 libc::open(buf.as_ptr(), libc::O_RDWR | libc::O_CREAT,\n                            libc::S_IRWXU)\n             };\n-            assert!(fd > 0, \"failed to open lockfile: [{}] {}\",\n-                    stdos::errno(), stdos::last_os_error());\n+            assert!(fd > 0, \"failed to open lockfile: {}\",\n+                    io::Error::last_os_error());\n             let flock = os::flock {\n                 l_start: 0,\n                 l_len: 0,\n@@ -135,10 +135,9 @@ mod imp {\n                 libc::fcntl(fd, os::F_SETLKW, &flock)\n             };\n             if ret == -1 {\n-                let errno = stdos::errno();\n+                let err = io::Error::last_os_error();\n                 unsafe { libc::close(fd); }\n-                panic!(\"could not lock `{}`: [{}] {}\", p.display(),\n-                       errno, stdos::error_string(errno))\n+                panic!(\"could not lock `{}`: {}\", p.display(), err);\n             }\n             Lock { fd: fd }\n         }\n@@ -166,9 +165,9 @@ mod imp {\n mod imp {\n     use libc;\n     use std::ffi::AsOsStr;\n+    use std::io;\n     use std::mem;\n     use std::os::windows::prelude::*;\n-    use std::os;\n     use std::path::Path;\n     use std::ptr;\n \n@@ -210,19 +209,17 @@ mod imp {\n                                   ptr::null_mut())\n             };\n             if handle == libc::INVALID_HANDLE_VALUE {\n-                panic!(\"create file error: [{}] {}\",\n-                       os::errno(), os::last_os_error());\n+                panic!(\"create file error: {}\", io::Error::last_os_error());\n             }\n             let mut overlapped: libc::OVERLAPPED = unsafe { mem::zeroed() };\n             let ret = unsafe {\n                 LockFileEx(handle, LOCKFILE_EXCLUSIVE_LOCK, 0, 100, 0,\n                            &mut overlapped)\n             };\n             if ret == 0 {\n-                let errno = os::errno();\n+                let err = io::Error::last_os_error();\n                 unsafe { libc::CloseHandle(handle); }\n-                panic!(\"could not lock `{}`: [{}] {}\", p.display(),\n-                       errno, os::error_string(errno));\n+                panic!(\"could not lock `{}`: {}\", p.display(), err);\n             }\n             Lock { handle: handle }\n         }"}, {"sha": "d19ccabed478efdb392b7830ad67def89cbf81f3", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -15,7 +15,8 @@\n \n use html::escape::Escape;\n \n-use std::old_io;\n+use std::io;\n+use std::io::prelude::*;\n use syntax::parse::lexer;\n use syntax::parse::token;\n use syntax::parse;\n@@ -46,7 +47,7 @@ pub fn highlight(src: &str, class: Option<&str>, id: Option<&str>) -> String {\n /// source.\n fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n         class: Option<&str>, id: Option<&str>,\n-        out: &mut Writer) -> old_io::IoResult<()> {\n+        out: &mut Write) -> io::Result<()> {\n     use syntax::parse::lexer::Reader;\n \n     try!(write!(out, \"<pre \"));"}, {"sha": "152b6f5c80a628ea3f9cac4562fcdf259748c887", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -26,9 +26,8 @@\n #![feature(core)]\n #![feature(exit_status)]\n #![feature(int_uint)]\n-#![feature(old_io)]\n+#![feature(set_panic)]\n #![feature(libc)]\n-#![feature(os)]\n #![feature(old_path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n@@ -465,7 +464,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n fn json_input(input: &str) -> Result<Output, String> {\n     let mut bytes = Vec::new();\n     match File::open(input).and_then(|mut f| f.read_to_end(&mut bytes)) {\n-        Ok(()) => {}\n+        Ok(_) => {}\n         Err(e) => return Err(format!(\"couldn't open {}: {}\", input, e)),\n     };\n     match json::from_reader(&mut &bytes[..]) {"}, {"sha": "09b4915222b3902ec3c6d49ea904a1be381fb2ca", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n use std::fs::File;\n-use std::io::Write;\n-use std::old_io;\n+use std::io;\n+use std::io::prelude::*;\n use std::path::{PathBuf, Path};\n \n use core;\n@@ -64,7 +64,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n \n     let mut out = match File::create(&output) {\n         Err(e) => {\n-            let _ = writeln!(&mut old_io::stderr(),\n+            let _ = writeln!(&mut io::stderr(),\n                              \"error opening `{}` for writing: {}\",\n                              output.display(), e);\n             return 4;\n@@ -74,7 +74,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n \n     let (metadata, text) = extract_leading_metadata(&input_str);\n     if metadata.len() == 0 {\n-        let _ = writeln!(&mut old_io::stderr(),\n+        let _ = writeln!(&mut io::stderr(),\n                          \"invalid markdown file: expecting initial line with `% ...TITLE...`\");\n         return 5;\n     }\n@@ -129,7 +129,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n \n     match err {\n         Err(e) => {\n-            let _ = writeln!(&mut old_io::stderr(),\n+            let _ = writeln!(&mut io::stderr(),\n                              \"error writing to `{}`: {}\",\n                              output.display(), e);\n             6"}, {"sha": "e2f8a6f82c6442df51e271223ddc4e82b91fa95b", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -13,13 +13,12 @@ use std::collections::{HashSet, HashMap};\n use std::dynamic_lib::DynamicLibrary;\n use std::env;\n use std::ffi::OsString;\n-use std::old_io;\n+use std::io::prelude::*;\n use std::io;\n use std::path::PathBuf;\n use std::process::Command;\n use std::str;\n-use std::sync::mpsc::channel;\n-use std::thread;\n+use std::sync::{Arc, Mutex};\n use std::thunk::Thunk;\n \n use testing;\n@@ -140,30 +139,29 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     // an explicit handle into rustc to collect output messages, but we also\n     // want to catch the error message that rustc prints when it fails.\n     //\n-    // We take our task-local stderr (likely set by the test runner), and move\n-    // it into another task. This helper task then acts as a sink for both the\n-    // stderr of this task and stderr of rustc itself, copying all the info onto\n-    // the stderr channel we originally started with.\n+    // We take our task-local stderr (likely set by the test runner) and replace\n+    // it with a sink that is also passed to rustc itself. When this function\n+    // returns the output of the sink is copied onto the output of our own task.\n     //\n     // The basic idea is to not use a default_handler() for rustc, and then also\n     // not print things by default to the actual stderr.\n-    let (tx, rx) = channel();\n-    let w1 = old_io::ChanWriter::new(tx);\n-    let w2 = w1.clone();\n-    let old = old_io::stdio::set_stderr(box w1);\n-    thread::spawn(move || {\n-        let mut p = old_io::ChanReader::new(rx);\n-        let mut err = match old {\n-            Some(old) => {\n-                // Chop off the `Send` bound.\n-                let old: Box<Writer> = old;\n-                old\n-            }\n-            None => box old_io::stderr() as Box<Writer>,\n-        };\n-        old_io::util::copy(&mut p, &mut err).unwrap();\n-    });\n-    let emitter = diagnostic::EmitterWriter::new(box w2, None);\n+    struct Sink(Arc<Mutex<Vec<u8>>>);\n+    impl Write for Sink {\n+        fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+            Write::write(&mut *self.0.lock().unwrap(), data)\n+        }\n+        fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+    }\n+    struct Bomb(Arc<Mutex<Vec<u8>>>, Box<Write+Send>);\n+    impl Drop for Bomb {\n+        fn drop(&mut self) {\n+            let _ = self.1.write_all(&self.0.lock().unwrap());\n+        }\n+    }\n+    let data = Arc::new(Mutex::new(Vec::new()));\n+    let emitter = diagnostic::EmitterWriter::new(box Sink(data.clone()), None);\n+    let old = io::set_panic(box Sink(data.clone()));\n+    let _bomb = Bomb(data, old.unwrap_or(box io::stdout()));\n \n     // Compile the code\n     let codemap = CodeMap::new();"}, {"sha": "d0ef89e811bd46563d596aa8602d8b6da069d208", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -199,15 +199,17 @@ use self::DecoderError::*;\n use self::ParserState::*;\n use self::InternalStackElement::*;\n \n-use std;\n use std::collections::{HashMap, BTreeMap};\n-use std::{char, f64, fmt, old_io, num, str};\n+use std::io::prelude::*;\n+use std::io;\n use std::mem::{swap};\n-use std::num::{Float, Int};\n use std::num::FpCategory as Fp;\n+use std::num::{Float, Int};\n+use std::ops::Index;\n use std::str::FromStr;\n use std::string;\n-use std::ops::Index;\n+use std::{char, f64, fmt, num, str};\n+use std;\n use unicode::str as unicode_str;\n use unicode::str::Utf16Item;\n \n@@ -256,11 +258,11 @@ pub enum ErrorCode {\n     NotUtf8,\n }\n \n-#[derive(Clone, Copy, PartialEq, Debug)]\n+#[derive(Clone, PartialEq, Debug)]\n pub enum ParserError {\n     /// msg, line, col\n     SyntaxError(ErrorCode, uint, uint),\n-    IoError(old_io::IoErrorKind, &'static str),\n+    IoError(io::ErrorKind, String),\n }\n \n // Builder and Parser have the same errors.\n@@ -331,8 +333,8 @@ impl fmt::Display for ErrorCode {\n     }\n }\n \n-fn io_error_to_error(io: old_io::IoError) -> ParserError {\n-    IoError(io.kind, io.desc)\n+fn io_error_to_error(io: io::Error) -> ParserError {\n+    IoError(io.kind(), io.to_string())\n }\n \n impl fmt::Display for ParserError {\n@@ -1982,7 +1984,7 @@ impl<T: Iterator<Item=char>> Builder<T> {\n         self.bump();\n         match self.token {\n             None => {}\n-            Some(Error(e)) => { return Err(e); }\n+            Some(Error(ref e)) => { return Err(e.clone()); }\n             ref tok => { panic!(\"unexpected token {:?}\", tok.clone()); }\n         }\n         result\n@@ -2004,7 +2006,7 @@ impl<T: Iterator<Item=char>> Builder<T> {\n                 swap(s, &mut temp);\n                 Ok(Json::String(temp))\n             }\n-            Some(Error(e)) => Err(e),\n+            Some(Error(ref e)) => Err(e.clone()),\n             Some(ArrayStart) => self.build_array(),\n             Some(ObjectStart) => self.build_object(),\n             Some(ObjectEnd) => self.parser.error(InvalidSyntax),\n@@ -2037,7 +2039,7 @@ impl<T: Iterator<Item=char>> Builder<T> {\n         loop {\n             match self.token {\n                 Some(ObjectEnd) => { return Ok(Json::Object(values)); }\n-                Some(Error(e)) => { return Err(e); }\n+                Some(Error(ref e)) => { return Err(e.clone()); }\n                 None => { break; }\n                 _ => {}\n             }\n@@ -2056,8 +2058,9 @@ impl<T: Iterator<Item=char>> Builder<T> {\n }\n \n /// Decodes a json value from an `&mut old_io::Reader`\n-pub fn from_reader(rdr: &mut old_io::Reader) -> Result<Json, BuilderError> {\n-    let contents = match rdr.read_to_end() {\n+pub fn from_reader(rdr: &mut Read) -> Result<Json, BuilderError> {\n+    let mut contents = Vec::new();\n+    match rdr.read_to_end(&mut contents) {\n         Ok(c)  => c,\n         Err(e) => return Err(io_error_to_error(e))\n     };"}, {"sha": "49e44a6d45563e4080f23c7f8f3b59cbf80e9dd0", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -31,7 +31,7 @@ Core encoding and decoding interfaces.\n #![feature(collections)]\n #![feature(core)]\n #![feature(int_uint)]\n-#![feature(old_io)]\n+#![feature(io)]\n #![feature(old_path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "677894ba6e4c450cf8711639cdf24b91fc54529a", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -17,6 +17,7 @@ use io;\n use iter::IteratorExt;\n use libc;\n use mem;\n+#[allow(deprecated)]\n use old_io;\n use ops::Deref;\n use option::Option::{self, Some, None};\n@@ -298,6 +299,7 @@ impl FromError<NulError> for io::Error {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n impl FromError<NulError> for old_io::IoError {\n     fn from_error(_: NulError) -> old_io::IoError {\n         old_io::IoError {"}, {"sha": "03416eb86a0eb92427ec54b12d53c0e2ecd6af8e", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -159,6 +159,7 @@ impl<W: Write> BufWriter<W> {\n                     break;\n                 }\n                 Ok(n) => written += n,\n+                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n                 Err(e) => { ret = Err(e); break }\n \n             }"}, {"sha": "3fddaaad807911b532c0e4eef1f56845a898883b", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -39,6 +39,8 @@ pub use self::error::{Result, Error, ErrorKind};\n pub use self::util::{copy, sink, Sink, empty, Empty, repeat, Repeat};\n pub use self::stdio::{stdin, stdout, stderr, Stdin, Stdout, Stderr};\n pub use self::stdio::{StdoutLock, StderrLock, StdinLock};\n+#[doc(no_inline, hidden)]\n+pub use self::stdio::set_panic;\n \n #[macro_use] mod lazy;\n \n@@ -930,18 +932,18 @@ mod tests {\n     fn read_until() {\n         let mut buf = Cursor::new(b\"12\");\n         let mut v = Vec::new();\n-        assert_eq!(buf.read_until(b'3', &mut v), Ok(()));\n+        assert_eq!(buf.read_until(b'3', &mut v), Ok(2));\n         assert_eq!(v, b\"12\");\n \n         let mut buf = Cursor::new(b\"1233\");\n         let mut v = Vec::new();\n-        assert_eq!(buf.read_until(b'3', &mut v), Ok(()));\n+        assert_eq!(buf.read_until(b'3', &mut v), Ok(3));\n         assert_eq!(v, b\"123\");\n         v.truncate(0);\n-        assert_eq!(buf.read_until(b'3', &mut v), Ok(()));\n+        assert_eq!(buf.read_until(b'3', &mut v), Ok(1));\n         assert_eq!(v, b\"3\");\n         v.truncate(0);\n-        assert_eq!(buf.read_until(b'3', &mut v), Ok(()));\n+        assert_eq!(buf.read_until(b'3', &mut v), Ok(0));\n         assert_eq!(v, []);\n     }\n \n@@ -963,18 +965,18 @@ mod tests {\n     fn read_line() {\n         let mut buf = Cursor::new(b\"12\");\n         let mut v = String::new();\n-        assert_eq!(buf.read_line(&mut v), Ok(()));\n+        assert_eq!(buf.read_line(&mut v), Ok(2));\n         assert_eq!(v, \"12\");\n \n         let mut buf = Cursor::new(b\"12\\n\\n\");\n         let mut v = String::new();\n-        assert_eq!(buf.read_line(&mut v), Ok(()));\n+        assert_eq!(buf.read_line(&mut v), Ok(3));\n         assert_eq!(v, \"12\\n\");\n         v.truncate(0);\n-        assert_eq!(buf.read_line(&mut v), Ok(()));\n+        assert_eq!(buf.read_line(&mut v), Ok(1));\n         assert_eq!(v, \"\\n\");\n         v.truncate(0);\n-        assert_eq!(buf.read_line(&mut v), Ok(()));\n+        assert_eq!(buf.read_line(&mut v), Ok(0));\n         assert_eq!(v, \"\");\n     }\n \n@@ -996,25 +998,25 @@ mod tests {\n     fn read_to_end() {\n         let mut c = Cursor::new(b\"\");\n         let mut v = Vec::new();\n-        assert_eq!(c.read_to_end(&mut v), Ok(()));\n+        assert_eq!(c.read_to_end(&mut v), Ok(0));\n         assert_eq!(v, []);\n \n         let mut c = Cursor::new(b\"1\");\n         let mut v = Vec::new();\n-        assert_eq!(c.read_to_end(&mut v), Ok(()));\n+        assert_eq!(c.read_to_end(&mut v), Ok(1));\n         assert_eq!(v, b\"1\");\n     }\n \n     #[test]\n     fn read_to_string() {\n         let mut c = Cursor::new(b\"\");\n         let mut v = String::new();\n-        assert_eq!(c.read_to_string(&mut v), Ok(()));\n+        assert_eq!(c.read_to_string(&mut v), Ok(0));\n         assert_eq!(v, \"\");\n \n         let mut c = Cursor::new(b\"1\");\n         let mut v = String::new();\n-        assert_eq!(c.read_to_string(&mut v), Ok(()));\n+        assert_eq!(c.read_to_string(&mut v), Ok(1));\n         assert_eq!(v, \"1\");\n \n         let mut c = Cursor::new(b\"\\xff\");"}, {"sha": "3b4e396953d0821672e286372c45f7e8079f1364", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -346,3 +346,26 @@ impl<'a> Write for StderrLock<'a> {\n     }\n     fn flush(&mut self) -> io::Result<()> { self.inner.flush() }\n }\n+\n+/// Resets the task-local stdout handle to the specified writer\n+///\n+/// This will replace the current task's stdout handle, returning the old\n+/// handle. All future calls to `print` and friends will emit their output to\n+/// this specified handle.\n+///\n+/// Note that this does not need to be called for all new tasks; the default\n+/// output handle is to the process's stdout stream.\n+#[unstable(feature = \"set_panic\",\n+           reason = \"this function may disappear completely or be replaced \\\n+                     with a more general mechanism\")]\n+#[doc(hidden)]\n+pub fn set_panic(sink: Box<Write + Send>) -> Option<Box<Write + Send>> {\n+    use panicking::LOCAL_STDERR;\n+    use mem;\n+    LOCAL_STDERR.with(move |slot| {\n+        mem::replace(&mut *slot.borrow_mut(), Some(sink))\n+    }).and_then(|mut s| {\n+        let _ = s.flush();\n+        Some(s)\n+    })\n+}"}, {"sha": "81e2113cfdfc1b5a7d9262473ddf39ffbab438c3", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -298,6 +298,7 @@ mod std {\n     pub use sync; // used for select!()\n     pub use error; // used for try!()\n     pub use fmt; // used for any formatting strings\n+    #[allow(deprecated)]\n     pub use old_io; // used for println!()\n     pub use option; // used for bitflags!{}\n     pub use rt; // used for panic!()"}, {"sha": "34b4ec94a4484ccd1a872180bc424771347162f7", "filename": "src/libstd/old_io/stdio.rs", "status": "modified", "additions": 5, "deletions": 25, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -31,10 +31,9 @@ use boxed;\n use boxed::Box;\n use cell::RefCell;\n use clone::Clone;\n-use panicking::LOCAL_STDERR;\n use fmt;\n use old_io::{Reader, Writer, IoResult, IoError, OtherIoError, Buffer,\n-         standard_error, EndOfFile, LineBufferedWriter, BufferedReader};\n+             standard_error, EndOfFile, LineBufferedWriter, BufferedReader};\n use marker::{Sync, Send};\n use libc;\n use mem;\n@@ -319,14 +318,10 @@ pub fn set_stdout(stdout: Box<Writer + Send>) -> Option<Box<Writer + Send>> {\n ///\n /// Note that this does not need to be called for all new tasks; the default\n /// output handle is to the process's stderr stream.\n-pub fn set_stderr(stderr: Box<Writer + Send>) -> Option<Box<Writer + Send>> {\n-    let mut new = Some(stderr);\n-    LOCAL_STDERR.with(|slot| {\n-        mem::replace(&mut *slot.borrow_mut(), new.take())\n-    }).and_then(|mut s| {\n-        let _ = s.flush();\n-        Some(s)\n-    })\n+#[unstable(feature = \"old_io\")]\n+#[deprecated(since = \"1.0.0\", reason = \"replaced with std::io::set_panic\")]\n+pub fn set_stderr(_stderr: Box<Writer + Send>) -> Option<Box<Writer + Send>> {\n+    None\n }\n \n // Helper to access the local task's stdout handle\n@@ -554,19 +549,4 @@ mod tests {\n         });\n         assert_eq!(r.read_to_string().unwrap(), \"hello!\\n\");\n     }\n-\n-    #[test]\n-    fn capture_stderr() {\n-        use old_io::{ChanReader, ChanWriter, Reader};\n-\n-        let (tx, rx) = channel();\n-        let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n-        // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-        let _t = thread::spawn(move || -> () {\n-            set_stderr(Box::new(w));\n-            panic!(\"my special message\");\n-        });\n-        let s = r.read_to_string().unwrap();\n-        assert!(s.contains(\"my special message\"));\n-    }\n }"}, {"sha": "866f7caffe86de07689988e79c636cf44e23224a", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -25,6 +25,7 @@\n //! OS-ignorant code by default.\n \n #![unstable(feature = \"os\")]\n+#![deprecated(since = \"1.0.0\", reason = \"replaced with std::env APIs\")]\n \n #![allow(missing_docs)]\n #![allow(non_snake_case)]"}, {"sha": "3e0584d9ab4f538a0016bb267825dec440b2ace3", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -11,37 +11,30 @@\n #![unstable(feature = \"std_misc\")]\n \n use prelude::v1::*;\n+use io::prelude::*;\n \n use any::Any;\n use cell::RefCell;\n-use old_io::IoResult;\n use rt::{backtrace, unwind};\n-use rt::util::{Stderr, Stdio};\n+use sys::stdio::Stderr;\n use thread;\n \n // Defined in this module instead of old_io::stdio so that the unwinding\n thread_local! {\n-    pub static LOCAL_STDERR: RefCell<Option<Box<Writer + Send>>> = {\n+    pub static LOCAL_STDERR: RefCell<Option<Box<Write + Send>>> = {\n         RefCell::new(None)\n     }\n }\n \n-impl Writer for Stdio {\n-    fn write_all(&mut self, bytes: &[u8]) -> IoResult<()> {\n-        let _ = self.write_bytes(bytes);\n-        Ok(())\n-    }\n-}\n-\n-pub fn on_panic(obj: &(Any+Send), file: &'static str, line: uint) {\n+pub fn on_panic(obj: &(Any+Send), file: &'static str, line: usize) {\n     let msg = match obj.downcast_ref::<&'static str>() {\n         Some(s) => *s,\n         None => match obj.downcast_ref::<String>() {\n             Some(s) => &s[..],\n             None => \"Box<Any>\",\n         }\n     };\n-    let mut err = Stderr;\n+    let mut err = Stderr::new();\n     let thread = thread::current();\n     let name = thread.name().unwrap_or(\"<unnamed>\");\n     let prev = LOCAL_STDERR.with(|s| s.borrow_mut().take());"}, {"sha": "e72fd7b33202dab64a063d2acb39ac67462e25b6", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 7, "deletions": 66, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -11,16 +11,14 @@\n // ignore-lexer-test FIXME #15677\n \n use prelude::v1::*;\n+use io::prelude::*;\n \n-use cmp;\n use env;\n use fmt;\n use intrinsics;\n-use libc::{self, uintptr_t};\n-use os;\n-use slice;\n-use str;\n+use libc::uintptr_t;\n use sync::atomic::{self, Ordering};\n+use sys::stdio::Stderr;\n \n /// Dynamically inquire about whether we're running under V.\n /// You should usually not use this unless your test definitely\n@@ -62,7 +60,9 @@ pub fn min_stack() -> uint {\n \n /// Get's the number of scheduler threads requested by the environment\n /// either `RUST_THREADS` or `num_cpus`.\n+#[allow(deprecated)]\n pub fn default_sched_threads() -> uint {\n+    use os;\n     match env::var(\"RUST_THREADS\") {\n         Ok(nstr) => {\n             let opt_n: Option<uint> = nstr.parse().ok();\n@@ -88,76 +88,17 @@ pub fn default_sched_threads() -> uint {\n pub const ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) ||\n                                   cfg!(rtassert);\n \n-pub struct Stdio(libc::c_int);\n-\n-#[allow(non_upper_case_globals)]\n-pub const Stdout: Stdio = Stdio(libc::STDOUT_FILENO);\n-#[allow(non_upper_case_globals)]\n-pub const Stderr: Stdio = Stdio(libc::STDERR_FILENO);\n-\n-impl Stdio {\n-    pub fn write_bytes(&mut self, data: &[u8]) {\n-        #[cfg(unix)]\n-        type WriteLen = libc::size_t;\n-        #[cfg(windows)]\n-        type WriteLen = libc::c_uint;\n-        unsafe {\n-            let Stdio(fd) = *self;\n-            libc::write(fd,\n-                        data.as_ptr() as *const libc::c_void,\n-                        data.len() as WriteLen);\n-        }\n-    }\n-}\n-\n-impl fmt::Write for Stdio {\n-    fn write_str(&mut self, data: &str) -> fmt::Result {\n-        self.write_bytes(data.as_bytes());\n-        Ok(()) // yes, we're lying\n-    }\n-}\n-\n pub fn dumb_print(args: fmt::Arguments) {\n-    let _ = Stderr.write_fmt(args);\n+    let _ = write!(&mut Stderr::new(), \"{}\", args);\n }\n \n pub fn abort(args: fmt::Arguments) -> ! {\n-    use fmt::Write;\n-\n-    struct BufWriter<'a> {\n-        buf: &'a mut [u8],\n-        pos: uint,\n-    }\n-    impl<'a> fmt::Write for BufWriter<'a> {\n-        fn write_str(&mut self, bytes: &str) -> fmt::Result {\n-            let left = &mut self.buf[self.pos..];\n-            let to_write = &bytes.as_bytes()[..cmp::min(bytes.len(), left.len())];\n-            slice::bytes::copy_memory(left, to_write);\n-            self.pos += to_write.len();\n-            Ok(())\n-        }\n-    }\n-\n-    // Convert the arguments into a stack-allocated string\n-    let mut msg = [0; 512];\n-    let mut w = BufWriter { buf: &mut msg, pos: 0 };\n-    let _ = write!(&mut w, \"{}\", args);\n-    let msg = str::from_utf8(&w.buf[..w.pos]).unwrap_or(\"aborted\");\n-    let msg = if msg.is_empty() {\"aborted\"} else {msg};\n-    rterrln!(\"fatal runtime error: {}\", msg);\n+    rterrln!(\"fatal runtime error: {}\", args);\n     unsafe { intrinsics::abort(); }\n }\n \n pub unsafe fn report_overflow() {\n     use thread;\n-\n-    // See the message below for why this is not emitted to the\n-    // ^ Where did the message below go?\n-    // task's logger. This has the additional conundrum of the\n-    // logger may not be initialized just yet, meaning that an FFI\n-    // call would happen to initialized it (calling out to libuv),\n-    // and the FFI call needs 2MB of stack when we just ran out.\n-\n     rterrln!(\"\\nthread '{}' has overflowed its stack\",\n              thread::current().name().unwrap_or(\"<unknown>\"));\n }"}, {"sha": "c42a755b444d8605e3f8dc79a34e5199befc7f77", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -9,8 +9,9 @@\n // except according to those terms.\n \n use prelude::v1::*;\n+use io::prelude::*;\n \n-use old_io::IoResult;\n+use io;\n \n #[cfg(target_pointer_width = \"64\")]\n pub const HEX_WIDTH: uint = 18;\n@@ -35,7 +36,7 @@ pub const HEX_WIDTH: uint = 10;\n // Note that this demangler isn't quite as fancy as it could be. We have lots\n // of other information in our symbols like hashes, version, type information,\n // etc. Additionally, this doesn't handle glue symbols at all.\n-pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n+pub fn demangle(writer: &mut Write, s: &str) -> io::Result<()> {\n     // First validate the symbol. If it doesn't look like anything we're\n     // expecting, we just print it literally. Note that we must handle non-rust\n     // symbols because we could have any function in the backtrace.\n@@ -72,12 +73,12 @@ pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n \n     // Alright, let's do this.\n     if !valid {\n-        try!(writer.write_str(s));\n+        try!(writer.write_all(s.as_bytes()));\n     } else {\n         let mut first = true;\n         while inner.len() > 0 {\n             if !first {\n-                try!(writer.write_str(\"::\"));\n+                try!(writer.write_all(b\"::\"));\n             } else {\n                 first = false;\n             }\n@@ -93,11 +94,11 @@ pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n                     macro_rules! demangle {\n                         ($($pat:expr, => $demangled:expr),*) => ({\n                             $(if rest.starts_with($pat) {\n-                                try!(writer.write_str($demangled));\n+                                try!(writer.write_all($demangled));\n                                 rest = &rest[$pat.len()..];\n                               } else)*\n                             {\n-                                try!(writer.write_str(rest));\n+                                try!(writer.write_all(rest.as_bytes()));\n                                 break;\n                             }\n \n@@ -106,29 +107,29 @@ pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n \n                     // see src/librustc/back/link.rs for these mappings\n                     demangle! (\n-                        \"$SP$\", => \"@\",\n-                        \"$BP$\", => \"*\",\n-                        \"$RF$\", => \"&\",\n-                        \"$LT$\", => \"<\",\n-                        \"$GT$\", => \">\",\n-                        \"$LP$\", => \"(\",\n-                        \"$RP$\", => \")\",\n-                        \"$C$\", => \",\",\n+                        \"$SP$\", => b\"@\",\n+                        \"$BP$\", => b\"*\",\n+                        \"$RF$\", => b\"&\",\n+                        \"$LT$\", => b\"<\",\n+                        \"$GT$\", => b\">\",\n+                        \"$LP$\", => b\"(\",\n+                        \"$RP$\", => b\")\",\n+                        \"$C$\", => b\",\",\n \n                         // in theory we can demangle any Unicode code point, but\n                         // for simplicity we just catch the common ones.\n-                        \"$u7e$\", => \"~\",\n-                        \"$u20$\", => \" \",\n-                        \"$u27$\", => \"'\",\n-                        \"$u5b$\", => \"[\",\n-                        \"$u5d$\", => \"]\"\n+                        \"$u7e$\", => b\"~\",\n+                        \"$u20$\", => b\" \",\n+                        \"$u27$\", => b\"'\",\n+                        \"$u5b$\", => b\"[\",\n+                        \"$u5d$\", => b\"]\"\n                     )\n                 } else {\n                     let idx = match rest.find('$') {\n                         None => rest.len(),\n                         Some(i) => i,\n                     };\n-                    try!(writer.write_str(&rest[..idx]));\n+                    try!(writer.write_all(rest[..idx].as_bytes()));\n                     rest = &rest[idx..];\n                 }\n             }"}, {"sha": "29c05b1e0d883c50be44e7db9c2830f3bb9b2d0f", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -37,6 +37,7 @@ pub mod wtf8;\n \n // common error constructors\n \n+#[allow(deprecated)]\n pub fn eof() -> IoError {\n     IoError {\n         kind: old_io::EndOfFile,\n@@ -45,6 +46,7 @@ pub fn eof() -> IoError {\n     }\n }\n \n+#[allow(deprecated)]\n pub fn timeout(desc: &'static str) -> IoError {\n     IoError {\n         kind: old_io::TimedOut,\n@@ -53,6 +55,7 @@ pub fn timeout(desc: &'static str) -> IoError {\n     }\n }\n \n+#[allow(deprecated)]\n pub fn short_write(n: uint, desc: &'static str) -> IoError {\n     IoError {\n         kind: if n == 0 { old_io::TimedOut } else { old_io::ShortWrite(n) },\n@@ -61,6 +64,7 @@ pub fn short_write(n: uint, desc: &'static str) -> IoError {\n     }\n }\n \n+#[allow(deprecated)]\n pub fn unimpl() -> IoError {\n     IoError {\n         kind: old_io::IoUnavailable,\n@@ -70,6 +74,7 @@ pub fn unimpl() -> IoError {\n }\n \n // unix has nonzero values as errors\n+#[allow(deprecated)]\n pub fn mkerr_libc<T: Int>(ret: T) -> IoResult<()> {\n     if ret != Int::zero() {\n         Err(last_error())"}, {"sha": "3fa9f5d07aa20239d14f902fbc9cd2b40e6e93a1", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -84,9 +84,10 @@\n /// all unix platforms we support right now, so it at least gets the job done.\n \n use prelude::v1::*;\n+use io::prelude::*;\n \n use ffi::CStr;\n-use old_io::IoResult;\n+use io;\n use libc;\n use mem;\n use str;\n@@ -105,7 +106,7 @@ use sys_common::backtrace::*;\n /// only viable option.\n #[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n #[inline(never)]\n-pub fn write(w: &mut Writer) -> IoResult<()> {\n+pub fn write(w: &mut Write) -> io::Result<()> {\n     use result;\n \n     extern {\n@@ -135,13 +136,11 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n #[inline(never)] // if we know this is a function call, we can skip it when\n                  // tracing\n-pub fn write(w: &mut Writer) -> IoResult<()> {\n-    use old_io::IoError;\n-\n+pub fn write(w: &mut Write) -> io::Result<()> {\n     struct Context<'a> {\n         idx: int,\n-        writer: &'a mut (Writer+'a),\n-        last_error: Option<IoError>,\n+        writer: &'a mut (Write+'a),\n+        last_error: Option<io::Error>,\n     }\n \n     // When using libbacktrace, we use some necessary global state, so we\n@@ -223,8 +222,8 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void,\n-         _symaddr: *mut libc::c_void) -> IoResult<()> {\n+fn print(w: &mut Write, idx: int, addr: *mut libc::c_void,\n+         _symaddr: *mut libc::c_void) -> io::Result<()> {\n     use intrinsics;\n     #[repr(C)]\n     struct Dl_info {\n@@ -249,8 +248,8 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void,\n }\n \n #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n-fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void,\n-         symaddr: *mut libc::c_void) -> IoResult<()> {\n+fn print(w: &mut Write, idx: int, addr: *mut libc::c_void,\n+         symaddr: *mut libc::c_void) -> io::Result<()> {\n     use env;\n     use ffi::AsOsStr;\n     use os::unix::prelude::*;\n@@ -442,8 +441,8 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void,\n }\n \n // Finally, after all that work above, we can emit a symbol.\n-fn output(w: &mut Writer, idx: int, addr: *mut libc::c_void,\n-          s: Option<&[u8]>) -> IoResult<()> {\n+fn output(w: &mut Write, idx: int, addr: *mut libc::c_void,\n+          s: Option<&[u8]>) -> io::Result<()> {\n     try!(write!(w, \"  {:2}: {:2$?} - \", idx, addr, HEX_WIDTH));\n     match s.and_then(|s| str::from_utf8(s).ok()) {\n         Some(string) => try!(demangle(w, string)),\n@@ -453,8 +452,8 @@ fn output(w: &mut Writer, idx: int, addr: *mut libc::c_void,\n }\n \n #[allow(dead_code)]\n-fn output_fileline(w: &mut Writer, file: &[u8], line: libc::c_int,\n-                   more: bool) -> IoResult<()> {\n+fn output_fileline(w: &mut Write, file: &[u8], line: libc::c_int,\n+                   more: bool) -> io::Result<()> {\n     let file = str::from_utf8(file).ok().unwrap_or(\"<unknown>\");\n     // prior line: \"  ##: {:2$} - func\"\n     try!(write!(w, \"      {:3$}at {}:{}\", \"\", file, line, HEX_WIDTH));"}, {"sha": "3dd05319194b14c6336a2ecc4c30f0b8ca6b2645", "filename": "src/libstd/sys/unix/ext.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -43,7 +43,7 @@ use sys::os_str::Buf;\n use sys_common::{AsInner, AsInnerMut, IntoInner, FromInner};\n use libc::{self, gid_t, uid_t};\n \n-use old_io;\n+#[allow(deprecated)] use old_io;\n \n /// Raw file descriptors.\n pub type Fd = libc::c_int;\n@@ -67,6 +67,7 @@ impl AsRawFd for fs::File {\n     }\n }\n \n+#[allow(deprecated)]\n impl AsRawFd for old_io::pipe::PipeStream {\n     fn as_raw_fd(&self) -> Fd {\n         self.as_inner().fd()"}, {"sha": "c839ce65298721cea9d8d678f02aff6629d2f153", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n //! Blocking posix-based file I/O\n+#![allow(deprecated)]\n \n #![allow(deprecated)] // this module itself is essentially deprecated\n "}, {"sha": "ff29dea254fc42031c0169a1e029de1bfbd3f590", "filename": "src/libstd/sys/unix/helper_signal.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Funix%2Fhelper_signal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Funix%2Fhelper_signal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fhelper_signal.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(deprecated)]\n+\n use libc;\n use os;\n "}, {"sha": "a8cee74828d3496c433f07bcf73b202a32f9d03c", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -60,10 +60,12 @@ pub type wrlen = libc::size_t;\n pub type msglen_t = libc::size_t;\n pub unsafe fn close_sock(sock: sock_t) { let _ = libc::close(sock); }\n \n+#[allow(deprecated)]\n pub fn last_error() -> IoError {\n     decode_error_detailed(os::errno() as i32)\n }\n \n+#[allow(deprecated)]\n pub fn last_net_error() -> IoError {\n     last_error()\n }\n@@ -72,6 +74,7 @@ extern \"system\" {\n     fn gai_strerror(errcode: libc::c_int) -> *const libc::c_char;\n }\n \n+#[allow(deprecated)]\n pub fn last_gai_error(s: libc::c_int) -> IoError {\n \n     let mut err = decode_error(s);\n@@ -83,6 +86,7 @@ pub fn last_gai_error(s: libc::c_int) -> IoError {\n }\n \n /// Convert an `errno` value into a high-level error variant and description.\n+#[allow(deprecated)]\n pub fn decode_error(errno: i32) -> IoError {\n     // FIXME: this should probably be a bit more descriptive...\n     let (kind, desc) = match errno {\n@@ -119,12 +123,14 @@ pub fn decode_error(errno: i32) -> IoError {\n     IoError { kind: kind, desc: desc, detail: None }\n }\n \n+#[allow(deprecated)]\n pub fn decode_error_detailed(errno: i32) -> IoError {\n     let mut err = decode_error(errno);\n     err.detail = Some(os::error_string(errno));\n     err\n }\n \n+#[allow(deprecated)]\n pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     match errno as libc::c_int {\n         libc::ECONNREFUSED => ErrorKind::ConnectionRefused,\n@@ -155,6 +161,7 @@ pub fn decode_error_kind(errno: i32) -> ErrorKind {\n }\n \n #[inline]\n+#[allow(deprecated)]\n pub fn retry<T, F> (mut f: F) -> T where\n     T: SignedInt,\n     F: FnMut() -> T,\n@@ -194,11 +201,13 @@ pub fn ms_to_timeval(ms: u64) -> libc::timeval {\n     }\n }\n \n+#[allow(deprecated)]\n pub fn wouldblock() -> bool {\n     let err = os::errno();\n     err == libc::EWOULDBLOCK as i32 || err == libc::EAGAIN as i32\n }\n \n+#[allow(deprecated)]\n pub fn set_nonblocking(fd: sock_t, nb: bool) {\n     let set = nb as libc::c_int;\n     mkerr_libc(retry(|| unsafe { c::ioctl(fd, c::FIONBIO, &set) })).unwrap();"}, {"sha": "d332556d188a7120a6912005198404c246bb9093", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -22,7 +22,7 @@ use io;\n use iter;\n use libc::{self, c_int, c_char, c_void};\n use mem;\n-use old_io::{IoError, IoResult};\n+#[allow(deprecated)] use old_io::{IoError, IoResult};\n use ptr;\n use path::{self, PathBuf};\n use slice;\n@@ -398,7 +398,7 @@ pub fn env() -> Env {\n         let mut environ = *environ();\n         if environ as usize == 0 {\n             panic!(\"os::env() failure getting env string from OS: {}\",\n-                   IoError::last_error());\n+                   io::Error::last_os_error());\n         }\n         let mut result = Vec::new();\n         while *environ != ptr::null() {\n@@ -434,7 +434,7 @@ pub fn setenv(k: &OsStr, v: &OsStr) {\n         let k = k.to_cstring().unwrap();\n         let v = v.to_cstring().unwrap();\n         if libc::funcs::posix01::unistd::setenv(k.as_ptr(), v.as_ptr(), 1) != 0 {\n-            panic!(\"failed setenv: {}\", IoError::last_error());\n+            panic!(\"failed setenv: {}\", io::Error::last_os_error());\n         }\n     }\n }\n@@ -443,11 +443,12 @@ pub fn unsetenv(n: &OsStr) {\n     unsafe {\n         let nbuf = n.to_cstring().unwrap();\n         if libc::funcs::posix01::unistd::unsetenv(nbuf.as_ptr()) != 0 {\n-            panic!(\"failed unsetenv: {}\", IoError::last_error());\n+            panic!(\"failed unsetenv: {}\", io::Error::last_os_error());\n         }\n     }\n }\n \n+#[allow(deprecated)]\n pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n     let mut fds = [0; 2];\n     if libc::pipe(fds.as_mut_ptr()) == 0 {"}, {"sha": "daa981720f6da45faf6913446e253909c6af49b5", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(deprecated)]\n+\n use prelude::v1::*;\n \n use ffi::CString;"}, {"sha": "5f5101e96d7c485ec61ac0bdbc2f44d5a139a45a", "filename": "src/libstd/sys/unix/stdio.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -50,3 +50,13 @@ impl Stderr {\n         return ret;\n     }\n }\n+\n+// FIXME: right now this raw stderr handle is used in a few places because\n+//        std::io::stderr_raw isn't exposed, but once that's exposed this impl\n+//        should go away\n+impl io::Write for Stderr {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        Stderr::write(self, data)\n+    }\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+}"}, {"sha": "ef0274fdda92dc223d4e0ae42993a259bd06e82f", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -46,6 +46,8 @@\n //!\n //! Note that all time units in this file are in *milliseconds*.\n \n+#![allow(deprecated)]\n+\n use prelude::v1::*;\n use self::Req::*;\n "}, {"sha": "f607f7c6a2f5ac76bf4465bd7e2f366f96ceba2a", "filename": "src/libstd/sys/unix/tty.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftty.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(deprecated)]\n+\n use prelude::v1::*;\n \n use sys::fs::FileDesc;"}, {"sha": "8638099ca695a721b1e5ba59434b04e173ed140a", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -28,9 +28,10 @@\n use prelude::v1::*;\n \n use dynamic_lib::DynamicLibrary;\n+use io;\n+use io::prelude::*;\n use ffi::CStr;\n use intrinsics;\n-use old_io::IoResult;\n use libc;\n use mem;\n use ptr;\n@@ -292,7 +293,7 @@ impl Drop for Cleanup {\n     fn drop(&mut self) { (self.SymCleanup)(self.handle); }\n }\n \n-pub fn write(w: &mut Writer) -> IoResult<()> {\n+pub fn write(w: &mut Write) -> io::Result<()> {\n     // According to windows documentation, all dbghelp functions are\n     // single-threaded.\n     static LOCK: StaticMutex = MUTEX_INIT;"}, {"sha": "67552255fdbeb50e0c5a294059606ccfbd31722a", "filename": "src/libstd/sys/windows/condvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -12,7 +12,7 @@ use prelude::v1::*;\n \n use cell::UnsafeCell;\n use libc::{self, DWORD};\n-use os;\n+use sys::os;\n use sys::mutex::{self, Mutex};\n use sys::sync as ffi;\n use time::Duration;\n@@ -46,7 +46,7 @@ impl Condvar {\n                                                0);\n         if r == 0 {\n             const ERROR_TIMEOUT: DWORD = 0x5B4;\n-            debug_assert_eq!(os::errno() as uint, ERROR_TIMEOUT as uint);\n+            debug_assert_eq!(os::errno() as usize, ERROR_TIMEOUT as usize);\n             false\n         } else {\n             true"}, {"sha": "dc820a4ce45d903db48343ce22668b4841b458f1", "filename": "src/libstd/sys/windows/ext.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -25,6 +25,7 @@ use net;\n use sys::os_str::Buf;\n use sys_common::{AsInner, FromInner, AsInnerMut};\n \n+#[allow(deprecated)]\n use old_io;\n \n /// Raw HANDLEs.\n@@ -52,6 +53,7 @@ impl AsRawHandle for fs::File {\n     }\n }\n \n+#[allow(deprecated)]\n impl AsRawHandle for old_io::pipe::PipeStream {\n     fn as_raw_handle(&self) -> Handle {\n         self.as_inner().handle()"}, {"sha": "6b0f6a78c85e10711da04ec03520dc02752ad044", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -64,6 +64,7 @@ pub type msglen_t = libc::c_int;\n pub unsafe fn close_sock(sock: sock_t) { let _ = libc::closesocket(sock); }\n \n // windows has zero values as errors\n+#[allow(deprecated)]\n fn mkerr_winbool(ret: libc::c_int) -> IoResult<()> {\n     if ret == 0 {\n         Err(last_error())\n@@ -72,25 +73,29 @@ fn mkerr_winbool(ret: libc::c_int) -> IoResult<()> {\n     }\n }\n \n+#[allow(deprecated)]\n pub fn last_error() -> IoError {\n     let errno = os::errno() as i32;\n     let mut err = decode_error(errno);\n     err.detail = Some(os::error_string(errno));\n     err\n }\n \n+#[allow(deprecated)]\n pub fn last_net_error() -> IoError {\n     let errno = unsafe { c::WSAGetLastError() as i32 };\n     let mut err = decode_error(errno);\n     err.detail = Some(os::error_string(errno));\n     err\n }\n \n+#[allow(deprecated)]\n pub fn last_gai_error(_errno: i32) -> IoError {\n     last_net_error()\n }\n \n /// Convert an `errno` value into a high-level error variant and description.\n+#[allow(deprecated)]\n pub fn decode_error(errno: i32) -> IoError {\n     let (kind, desc) = match errno {\n         libc::EOF => (old_io::EndOfFile, \"end of file\"),\n@@ -134,6 +139,7 @@ pub fn decode_error(errno: i32) -> IoError {\n     IoError { kind: kind, desc: desc, detail: None }\n }\n \n+#[allow(deprecated)]\n pub fn decode_error_detailed(errno: i32) -> IoError {\n     let mut err = decode_error(errno);\n     err.detail = Some(os::error_string(errno));\n@@ -178,11 +184,13 @@ pub fn ms_to_timeval(ms: u64) -> libc::timeval {\n     }\n }\n \n+#[allow(deprecated)]\n pub fn wouldblock() -> bool {\n     let err = os::errno();\n     err == libc::WSAEWOULDBLOCK as i32\n }\n \n+#[allow(deprecated)]\n pub fn set_nonblocking(fd: sock_t, nb: bool) {\n     let mut set = nb as libc::c_ulong;\n     if unsafe { c::ioctlsocket(fd, c::FIONBIO, &mut set) } != 0 {\n@@ -205,6 +213,7 @@ pub fn init_net() {\n     }\n }\n \n+#[allow(deprecated)]\n pub fn to_utf16(s: Option<&str>) -> IoResult<Vec<u16>> {\n     match s {\n         Some(s) => Ok(to_utf16_os(OsStr::from_str(s))),\n@@ -283,6 +292,7 @@ fn fill_utf16_buf_base<F1, F2, T>(mut f1: F1, f2: F2) -> Result<T, ()>\n     }\n }\n \n+#[allow(deprecated)]\n fn fill_utf16_buf<F1, F2, T>(f1: F1, f2: F2) -> IoResult<T>\n     where F1: FnMut(*mut u16, libc::DWORD) -> libc::DWORD,\n           F2: FnOnce(&[u16]) -> T"}, {"sha": "ecd538abfb4817ba88dd327c0b3675cb871060b0", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -22,6 +22,7 @@ use io;\n use libc::types::os::arch::extra::LPWCH;\n use libc::{self, c_int, c_void};\n use mem;\n+#[allow(deprecated)]\n use old_io::{IoError, IoResult};\n use ops::Range;\n use path::{self, PathBuf};\n@@ -134,7 +135,7 @@ pub fn env() -> Env {\n         let ch = GetEnvironmentStringsW();\n         if ch as usize == 0 {\n             panic!(\"failure getting env string from OS: {}\",\n-                   IoError::last_error());\n+                   io::Error::last_os_error());\n         }\n         Env { base: ch, cur: ch }\n     }\n@@ -269,7 +270,7 @@ pub fn setenv(k: &OsStr, v: &OsStr) {\n \n     unsafe {\n         if libc::SetEnvironmentVariableW(k.as_ptr(), v.as_ptr()) == 0 {\n-            panic!(\"failed to set env: {}\", IoError::last_error());\n+            panic!(\"failed to set env: {}\", io::Error::last_os_error());\n         }\n     }\n }\n@@ -278,7 +279,7 @@ pub fn unsetenv(n: &OsStr) {\n     let v = super::to_utf16_os(n);\n     unsafe {\n         if libc::SetEnvironmentVariableW(v.as_ptr(), ptr::null()) == 0 {\n-            panic!(\"failed to unset env: {}\", IoError::last_error());\n+            panic!(\"failed to unset env: {}\", io::Error::last_os_error());\n         }\n     }\n }\n@@ -333,6 +334,7 @@ pub fn page_size() -> usize {\n     }\n }\n \n+#[allow(deprecated)]\n pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n     // Windows pipes work subtly differently than unix pipes, and their\n     // inheritance has to be handled in a different way that I do not"}, {"sha": "2b03e9e743172a80f9898473d3844a78936c9ae5", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -84,6 +84,8 @@\n //! the test suite passing (the suite is in libstd), and that's good enough for\n //! me!\n \n+#![allow(deprecated)]\n+\n use prelude::v1::*;\n \n use libc;"}, {"sha": "d1bff0e135dd697aa2c7f2eb1139200ffd7b903c", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -135,6 +135,16 @@ impl Stderr {\n     }\n }\n \n+// FIXME: right now this raw stderr handle is used in a few places because\n+//        std::io::stderr_raw isn't exposed, but once that's exposed this impl\n+//        should go away\n+impl io::Write for Stderr {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        Stderr::write(self, data)\n+    }\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+}\n+\n impl NoClose {\n     fn new(handle: libc::HANDLE) -> NoClose {\n         NoClose(Some(Handle::new(handle)))"}, {"sha": "91a7f694181f1e2ef5d34345057f489aa519a7f1", "filename": "src/libstd/sys/windows/timer.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -20,6 +20,8 @@\n //! Other than that, the implementation is pretty straightforward in terms of\n //! the other two implementations of timers with nothing *that* new showing up.\n \n+#![allow(deprecated)]\n+\n use prelude::v1::*;\n use self::Req::*;\n "}, {"sha": "f542cb2323ebc4839f7747aabd8c0418c6c9da10", "filename": "src/libstd/sys/windows/tty.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -25,6 +25,8 @@\n //! wrapper that performs encoding/decoding, this implementation should switch\n //! to working in raw UTF-16, with such a wrapper around it.\n \n+#![allow(deprecated)]\n+\n use prelude::v1::*;\n \n use old_io::{self, IoError, IoResult, MemReader};"}, {"sha": "adc3b77407a6121a48952d3321388ffe45473555", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -904,20 +904,6 @@ mod test {\n         }\n     }\n \n-    #[test]\n-    fn test_stdout() {\n-        let (tx, rx) = channel();\n-        let mut reader = ChanReader::new(rx);\n-        let stdout = ChanWriter::new(tx);\n-\n-        Builder::new().stdout(box stdout as Box<Writer + Send>).scoped(move|| {\n-            print!(\"Hello, world!\");\n-        }).unwrap().join();\n-\n-        let output = reader.read_to_string().unwrap();\n-        assert_eq!(output, \"Hello, world!\".to_string());\n-    }\n-\n     #[test]\n     fn test_park_timeout_unpark_before() {\n         for _ in 0..10 {"}, {"sha": "32857769acf4a34ab2a08989981bba8167fd9ed1", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 48, "deletions": 24, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -19,10 +19,11 @@ use diagnostics;\n \n use std::cell::{RefCell, Cell};\n use std::fmt;\n-use std::old_io;\n-use std::string::String;\n+use std::io::prelude::*;\n+use std::io;\n use term::WriterWrapper;\n use term;\n+use libc;\n \n /// maximum number of lines we will print for each error; arbitrary.\n const MAX_LINES: usize = 6;\n@@ -271,7 +272,7 @@ impl Level {\n \n fn print_maybe_styled(w: &mut EmitterWriter,\n                       msg: &str,\n-                      color: term::attr::Attr) -> old_io::IoResult<()> {\n+                      color: term::attr::Attr) -> io::Result<()> {\n     match w.dst {\n         Terminal(ref mut t) => {\n             try!(t.attr(color));\n@@ -289,23 +290,21 @@ fn print_maybe_styled(w: &mut EmitterWriter,\n             // to be miscolored. We assume this is rare enough that we don't\n             // have to worry about it.\n             if msg.ends_with(\"\\n\") {\n-                try!(t.write_str(&msg[..msg.len()-1]));\n+                try!(t.write_all(msg[..msg.len()-1].as_bytes()));\n                 try!(t.reset());\n-                try!(t.write_str(\"\\n\"));\n+                try!(t.write_all(b\"\\n\"));\n             } else {\n-                try!(t.write_str(msg));\n+                try!(t.write_all(msg.as_bytes()));\n                 try!(t.reset());\n             }\n             Ok(())\n         }\n-        Raw(ref mut w) => {\n-            w.write_str(msg)\n-        }\n+        Raw(ref mut w) => w.write_all(msg.as_bytes()),\n     }\n }\n \n fn print_diagnostic(dst: &mut EmitterWriter, topic: &str, lvl: Level,\n-                    msg: &str, code: Option<&str>) -> old_io::IoResult<()> {\n+                    msg: &str, code: Option<&str>) -> io::Result<()> {\n     if !topic.is_empty() {\n         try!(write!(&mut dst.dst, \"{} \", topic));\n     }\n@@ -324,7 +323,7 @@ fn print_diagnostic(dst: &mut EmitterWriter, topic: &str, lvl: Level,\n         }\n         None => ()\n     }\n-    try!(dst.dst.write_char('\\n'));\n+    try!(write!(&mut dst.dst, \"\\n\"));\n     Ok(())\n }\n \n@@ -335,18 +334,18 @@ pub struct EmitterWriter {\n \n enum Destination {\n     Terminal(Box<term::Terminal<WriterWrapper> + Send>),\n-    Raw(Box<Writer + Send>),\n+    Raw(Box<Write + Send>),\n }\n \n impl EmitterWriter {\n     pub fn stderr(color_config: ColorConfig,\n                   registry: Option<diagnostics::registry::Registry>) -> EmitterWriter {\n-        let stderr = old_io::stderr();\n+        let stderr = io::stderr();\n \n         let use_color = match color_config {\n             Always => true,\n             Never  => false,\n-            Auto   => stderr.get_ref().isatty()\n+            Auto   => stderr_isatty(),\n         };\n \n         if use_color {\n@@ -360,17 +359,42 @@ impl EmitterWriter {\n         }\n     }\n \n-    pub fn new(dst: Box<Writer + Send>,\n+    pub fn new(dst: Box<Write + Send>,\n                registry: Option<diagnostics::registry::Registry>) -> EmitterWriter {\n         EmitterWriter { dst: Raw(dst), registry: registry }\n     }\n }\n \n-impl Writer for Destination {\n-    fn write_all(&mut self, bytes: &[u8]) -> old_io::IoResult<()> {\n+#[cfg(unix)]\n+fn stderr_isatty() -> bool {\n+    unsafe { libc::isatty(libc::STDERR_FILENO) != 0 }\n+}\n+#[cfg(windows)]\n+fn stderr_isatty() -> bool {\n+    const STD_ERROR_HANDLE: libc::DWORD = -12;\n+    extern \"system\" {\n+        fn GetStdHandle(which: libc::DWORD) -> libc::HANDLE;\n+        fn GetConsoleMode(hConsoleHandle: libc::HANDLE,\n+                          lpMode: libc::LPDWORD) -> libc::BOOL;\n+    }\n+    unsafe {\n+        let handle = GetStdHandle(STD_ERROR_HANDLE);\n+        let mut out = 0;\n+        GetConsoleMode(handle, &mut out) != 0\n+    }\n+}\n+\n+impl Write for Destination {\n+    fn write(&mut self, bytes: &[u8]) -> io::Result<usize> {\n+        match *self {\n+            Terminal(ref mut t) => t.write(bytes),\n+            Raw(ref mut w) => w.write(bytes),\n+        }\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n         match *self {\n-            Terminal(ref mut t) => t.write_all(bytes),\n-            Raw(ref mut w) => w.write_all(bytes),\n+            Terminal(ref mut t) => t.flush(),\n+            Raw(ref mut w) => w.flush(),\n         }\n     }\n }\n@@ -403,7 +427,7 @@ impl Emitter for EmitterWriter {\n }\n \n fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n-        msg: &str, code: Option<&str>, lvl: Level, custom: bool) -> old_io::IoResult<()> {\n+        msg: &str, code: Option<&str>, lvl: Level, custom: bool) -> io::Result<()> {\n     let sp = rsp.span();\n \n     // We cannot check equality directly with COMMAND_LINE_SP\n@@ -451,7 +475,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n                    cm: &codemap::CodeMap,\n                    sp: Span,\n                    lvl: Level,\n-                   lines: codemap::FileLines) -> old_io::IoResult<()> {\n+                   lines: codemap::FileLines) -> io::Result<()> {\n     let fm = &*lines.file;\n \n     let mut elided = false;\n@@ -560,7 +584,7 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n                           sp: Span,\n                           lvl: Level,\n                           lines: codemap::FileLines)\n-                          -> old_io::IoResult<()> {\n+                          -> io::Result<()> {\n     let fm = &*lines.file;\n \n     let lines = &lines.lines[..];\n@@ -617,8 +641,8 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n fn print_macro_backtrace(w: &mut EmitterWriter,\n                          cm: &codemap::CodeMap,\n                          sp: Span)\n-                         -> old_io::IoResult<()> {\n-    let cs = try!(cm.with_expn_info(sp.expn_id, |expn_info| -> old_io::IoResult<_> {\n+                         -> io::Result<()> {\n+    let cs = try!(cm.with_expn_info(sp.expn_id, |expn_info| -> io::Result<_> {\n         match expn_info {\n             Some(ei) => {\n                 let ss = ei.callee.span.map_or(String::new(),"}, {"sha": "f60ac8f3f33b2f4976589555830e46bd9503f925", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -30,7 +30,6 @@\n #![feature(collections)]\n #![feature(core)]\n #![feature(int_uint)]\n-#![feature(old_io)]\n #![feature(libc)]\n #![feature(old_path)]\n #![feature(quote, unsafe_destructor)]"}, {"sha": "d9887c28e5c4d01ca482199c5dd939199f3163ab", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -1470,11 +1470,11 @@ mod test {\n     use diagnostic;\n     use parse::token;\n     use parse::token::{str_to_ident};\n-    use std::old_io::util;\n+    use std::io;\n \n     fn mk_sh() -> diagnostic::SpanHandler {\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-        let emitter = diagnostic::EmitterWriter::new(Box::new(util::NullWriter), None);\n+        let emitter = diagnostic::EmitterWriter::new(Box::new(io::sink()), None);\n         let handler = diagnostic::mk_handler(true, Box::new(emitter));\n         diagnostic::mk_span_handler(handler, CodeMap::new())\n     }"}, {"sha": "36225fad2211e4d7b81171b2fcb82d415e03cd8d", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -21,6 +21,8 @@\n //! ```no_run\n //! extern crate term;\n //!\n+//! use std::io::prelude::*;\n+//!\n //! fn main() {\n //!     let mut t = term::stdout().unwrap();\n //!\n@@ -56,7 +58,6 @@\n #![feature(collections)]\n #![feature(int_uint)]\n #![feature(io)]\n-#![feature(old_io)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n@@ -69,27 +70,28 @@ pub use terminfo::TerminfoTerminal;\n #[cfg(windows)]\n pub use win::WinConsole;\n \n-use std::old_io::IoResult;\n+use std::io::prelude::*;\n+use std::io;\n \n pub mod terminfo;\n \n #[cfg(windows)]\n mod win;\n \n-/// A hack to work around the fact that `Box<Writer + Send>` does not\n-/// currently implement `Writer`.\n+/// A hack to work around the fact that `Box<Write + Send>` does not\n+/// currently implement `Write`.\n pub struct WriterWrapper {\n-    wrapped: Box<Writer + Send>,\n+    wrapped: Box<Write + Send>,\n }\n \n-impl Writer for WriterWrapper {\n+impl Write for WriterWrapper {\n     #[inline]\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.wrapped.write_all(buf)\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.wrapped.write(buf)\n     }\n \n     #[inline]\n-    fn flush(&mut self) -> IoResult<()> {\n+    fn flush(&mut self) -> io::Result<()> {\n         self.wrapped.flush()\n     }\n }\n@@ -99,7 +101,7 @@ impl Writer for WriterWrapper {\n /// opened.\n pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n     TerminfoTerminal::new(WriterWrapper {\n-        wrapped: box std::old_io::stdout() as Box<Writer + Send>,\n+        wrapped: box std::io::stdout() as Box<Write + Send>,\n     })\n }\n \n@@ -108,14 +110,14 @@ pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n /// opened.\n pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n     let ti = TerminfoTerminal::new(WriterWrapper {\n-        wrapped: box std::old_io::stdout() as Box<Writer + Send>,\n+        wrapped: box std::io::stdout() as Box<Write + Send>,\n     });\n \n     match ti {\n         Some(t) => Some(t),\n         None => {\n             WinConsole::new(WriterWrapper {\n-                wrapped: box std::old_io::stdout() as Box<Writer + Send>,\n+                wrapped: box std::io::stdout() as Box<Write + Send>,\n             })\n         }\n     }\n@@ -126,7 +128,7 @@ pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n /// opened.\n pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n     TerminfoTerminal::new(WriterWrapper {\n-        wrapped: box std::old_io::stderr() as Box<Writer + Send>,\n+        wrapped: box std::io::stderr() as Box<Write + Send>,\n     })\n }\n \n@@ -135,14 +137,14 @@ pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n /// opened.\n pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n     let ti = TerminfoTerminal::new(WriterWrapper {\n-        wrapped: box std::old_io::stderr() as Box<Writer + Send>,\n+        wrapped: box std::io::stderr() as Box<Write + Send>,\n     });\n \n     match ti {\n         Some(t) => Some(t),\n         None => {\n             WinConsole::new(WriterWrapper {\n-                wrapped: box std::old_io::stderr() as Box<Writer + Send>,\n+                wrapped: box std::io::stderr() as Box<Write + Send>,\n             })\n         }\n     }\n@@ -209,15 +211,15 @@ pub mod attr {\n \n /// A terminal with similar capabilities to an ANSI Terminal\n /// (foreground/background colors etc).\n-pub trait Terminal<T: Writer>: Writer {\n+pub trait Terminal<T: Write>: Write {\n     /// Sets the foreground color to the given color.\n     ///\n     /// If the color is a bright color, but the terminal only supports 8 colors,\n     /// the corresponding normal color will be used instead.\n     ///\n     /// Returns `Ok(true)` if the color was set, `Ok(false)` otherwise, and `Err(e)`\n     /// if there was an I/O error.\n-    fn fg(&mut self, color: color::Color) -> IoResult<bool>;\n+    fn fg(&mut self, color: color::Color) -> io::Result<bool>;\n \n     /// Sets the background color to the given color.\n     ///\n@@ -226,19 +228,19 @@ pub trait Terminal<T: Writer>: Writer {\n     ///\n     /// Returns `Ok(true)` if the color was set, `Ok(false)` otherwise, and `Err(e)`\n     /// if there was an I/O error.\n-    fn bg(&mut self, color: color::Color) -> IoResult<bool>;\n+    fn bg(&mut self, color: color::Color) -> io::Result<bool>;\n \n     /// Sets the given terminal attribute, if supported.  Returns `Ok(true)`\n     /// if the attribute was supported, `Ok(false)` otherwise, and `Err(e)` if\n     /// there was an I/O error.\n-    fn attr(&mut self, attr: attr::Attr) -> IoResult<bool>;\n+    fn attr(&mut self, attr: attr::Attr) -> io::Result<bool>;\n \n     /// Returns whether the given terminal attribute is supported.\n     fn supports_attr(&self, attr: attr::Attr) -> bool;\n \n     /// Resets all terminal attributes and color to the default.\n     /// Returns `Ok()`.\n-    fn reset(&mut self) -> IoResult<()>;\n+    fn reset(&mut self) -> io::Result<()>;\n \n     /// Gets an immutable reference to the stream inside\n     fn get_ref<'a>(&'a self) -> &'a T;\n@@ -248,7 +250,7 @@ pub trait Terminal<T: Writer>: Writer {\n }\n \n /// A terminal which can be unwrapped.\n-pub trait UnwrappableTerminal<T: Writer>: Terminal<T> {\n+pub trait UnwrappableTerminal<T: Write>: Terminal<T> {\n     /// Returns the contained stream, destroying the `Terminal`\n     fn unwrap(self) -> T;\n }"}, {"sha": "3c269cc485dad908aec4fda4bb09a50625460ad1", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -11,8 +11,9 @@\n //! Terminfo database interface.\n \n use std::collections::HashMap;\n-use std::old_io::IoResult;\n use std::env;\n+use std::io::prelude::*;\n+use std::io;\n \n use attr;\n use color;\n@@ -72,8 +73,8 @@ pub struct TerminfoTerminal<T> {\n     ti: Box<TermInfo>\n }\n \n-impl<T: Writer+Send+'static> Terminal<T> for TerminfoTerminal<T> {\n-    fn fg(&mut self, color: color::Color) -> IoResult<bool> {\n+impl<T: Write+Send+'static> Terminal<T> for TerminfoTerminal<T> {\n+    fn fg(&mut self, color: color::Color) -> io::Result<bool> {\n         let color = self.dim_if_necessary(color);\n         if self.num_colors > color {\n             let s = expand(self.ti\n@@ -90,7 +91,7 @@ impl<T: Writer+Send+'static> Terminal<T> for TerminfoTerminal<T> {\n         Ok(false)\n     }\n \n-    fn bg(&mut self, color: color::Color) -> IoResult<bool> {\n+    fn bg(&mut self, color: color::Color) -> io::Result<bool> {\n         let color = self.dim_if_necessary(color);\n         if self.num_colors > color {\n             let s = expand(self.ti\n@@ -107,7 +108,7 @@ impl<T: Writer+Send+'static> Terminal<T> for TerminfoTerminal<T> {\n         Ok(false)\n     }\n \n-    fn attr(&mut self, attr: attr::Attr) -> IoResult<bool> {\n+    fn attr(&mut self, attr: attr::Attr) -> io::Result<bool> {\n         match attr {\n             attr::ForegroundColor(c) => self.fg(c),\n             attr::BackgroundColor(c) => self.bg(c),\n@@ -140,7 +141,7 @@ impl<T: Writer+Send+'static> Terminal<T> for TerminfoTerminal<T> {\n         }\n     }\n \n-    fn reset(&mut self) -> IoResult<()> {\n+    fn reset(&mut self) -> io::Result<()> {\n         let mut cap = self.ti.strings.get(\"sgr0\");\n         if cap.is_none() {\n             // are there any terminals that have color/attrs and not sgr0?\n@@ -164,11 +165,11 @@ impl<T: Writer+Send+'static> Terminal<T> for TerminfoTerminal<T> {\n     fn get_mut<'a>(&'a mut self) -> &'a mut T { &mut self.out }\n }\n \n-impl<T: Writer+Send+'static> UnwrappableTerminal<T> for TerminfoTerminal<T> {\n+impl<T: Write+Send+'static> UnwrappableTerminal<T> for TerminfoTerminal<T> {\n     fn unwrap(self) -> T { self.out }\n }\n \n-impl<T: Writer+Send+'static> TerminfoTerminal<T> {\n+impl<T: Write+Send+'static> TerminfoTerminal<T> {\n     /// Returns `None` whenever the terminal cannot be created for some\n     /// reason.\n     pub fn new(out: T) -> Option<Box<Terminal<T>+Send+'static>> {\n@@ -220,12 +221,12 @@ impl<T: Writer+Send+'static> TerminfoTerminal<T> {\n }\n \n \n-impl<T: Writer> Writer for TerminfoTerminal<T> {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.out.write_all(buf)\n+impl<T: Write> Write for TerminfoTerminal<T> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.out.write(buf)\n     }\n \n-    fn flush(&mut self) -> IoResult<()> {\n+    fn flush(&mut self) -> io::Result<()> {\n         self.out.flush()\n     }\n }"}, {"sha": "e29e0e27394db93a3103fc149c9baf424cbf930f", "filename": "src/libterm/win.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fwin.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -14,7 +14,8 @@\n \n extern crate libc;\n \n-use std::old_io::IoResult;\n+use std::io;\n+use std::io::prelude::*;\n \n use attr;\n use color;\n@@ -86,7 +87,7 @@ fn bits_to_color(bits: u16) -> color::Color {\n     color | (bits & 0x8) // copy the hi-intensity bit\n }\n \n-impl<T: Writer+Send+'static> WinConsole<T> {\n+impl<T: Write+Send+'static> WinConsole<T> {\n     fn apply(&mut self) {\n         let _unused = self.buf.flush();\n         let mut accum: libc::WORD = 0;\n@@ -129,32 +130,32 @@ impl<T: Writer+Send+'static> WinConsole<T> {\n     }\n }\n \n-impl<T: Writer> Writer for WinConsole<T> {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.buf.write_all(buf)\n+impl<T: Write> Write for WinConsole<T> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.buf.write(buf)\n     }\n \n-    fn flush(&mut self) -> IoResult<()> {\n+    fn flush(&mut self) -> io::Result<()> {\n         self.buf.flush()\n     }\n }\n \n-impl<T: Writer+Send+'static> Terminal<T> for WinConsole<T> {\n-    fn fg(&mut self, color: color::Color) -> IoResult<bool> {\n+impl<T: Write+Send+'static> Terminal<T> for WinConsole<T> {\n+    fn fg(&mut self, color: color::Color) -> io::Result<bool> {\n         self.foreground = color;\n         self.apply();\n \n         Ok(true)\n     }\n \n-    fn bg(&mut self, color: color::Color) -> IoResult<bool> {\n+    fn bg(&mut self, color: color::Color) -> io::Result<bool> {\n         self.background = color;\n         self.apply();\n \n         Ok(true)\n     }\n \n-    fn attr(&mut self, attr: attr::Attr) -> IoResult<bool> {\n+    fn attr(&mut self, attr: attr::Attr) -> io::Result<bool> {\n         match attr {\n             attr::ForegroundColor(f) => {\n                 self.foreground = f;\n@@ -179,7 +180,7 @@ impl<T: Writer+Send+'static> Terminal<T> for WinConsole<T> {\n         }\n     }\n \n-    fn reset(&mut self) -> IoResult<()> {\n+    fn reset(&mut self) -> io::Result<()> {\n         self.foreground = self.def_foreground;\n         self.background = self.def_background;\n         self.apply();\n@@ -192,6 +193,6 @@ impl<T: Writer+Send+'static> Terminal<T> for WinConsole<T> {\n     fn get_mut<'a>(&'a mut self) -> &'a mut T { &mut self.buf }\n }\n \n-impl<T: Writer+Send+'static> UnwrappableTerminal<T> for WinConsole<T> {\n+impl<T: Write+Send+'static> UnwrappableTerminal<T> for WinConsole<T> {\n     fn unwrap(self) -> T { self.buf }\n }"}, {"sha": "3de24b1383f8fef4f9f61ec9a42a927f3d0086f5", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 74, "deletions": 49, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -44,11 +44,14 @@\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(io)]\n+#![feature(libc)]\n+#![feature(set_panic)]\n \n extern crate getopts;\n extern crate serialize;\n extern crate \"serialize\" as rustc_serialize;\n extern crate term;\n+extern crate libc;\n \n pub use self::TestFn::*;\n pub use self::ColorConfig::*;\n@@ -70,14 +73,13 @@ use std::collections::BTreeMap;\n use std::env;\n use std::fmt;\n use std::fs::File;\n-use std::io::{self, Write};\n+use std::io::prelude::*;\n+use std::io;\n use std::iter::repeat;\n use std::num::{Float, Int};\n-use std::old_io::stdio::StdWriter;\n-use std::old_io::{ChanReader, ChanWriter};\n-use std::old_io;\n use std::path::{PathBuf};\n use std::sync::mpsc::{channel, Sender};\n+use std::sync::{Arc, Mutex};\n use std::thread;\n use std::thunk::{Thunk, Invoke};\n use std::time::Duration;\n@@ -451,23 +453,15 @@ struct ConsoleTestState<T> {\n     max_name_len: uint, // number of columns to fill when aligning names\n }\n \n-fn new2old(new: io::Error) -> old_io::IoError {\n-    old_io::IoError {\n-        kind: old_io::OtherIoError,\n-        desc: \"other error\",\n-        detail: Some(new.to_string()),\n-    }\n-}\n-\n-impl<T: Writer> ConsoleTestState<T> {\n+impl<T: Write> ConsoleTestState<T> {\n     pub fn new(opts: &TestOpts,\n-               _: Option<T>) -> old_io::IoResult<ConsoleTestState<StdWriter>> {\n+               _: Option<T>) -> io::Result<ConsoleTestState<io::Stdout>> {\n         let log_out = match opts.logfile {\n-            Some(ref path) => Some(try!(File::create(path).map_err(new2old))),\n+            Some(ref path) => Some(try!(File::create(path))),\n             None => None\n         };\n         let out = match term::stdout() {\n-            None => Raw(old_io::stdio::stdout_raw()),\n+            None => Raw(io::stdout()),\n             Some(t) => Pretty(t)\n         };\n \n@@ -486,29 +480,29 @@ impl<T: Writer> ConsoleTestState<T> {\n         })\n     }\n \n-    pub fn write_ok(&mut self) -> old_io::IoResult<()> {\n+    pub fn write_ok(&mut self) -> io::Result<()> {\n         self.write_pretty(\"ok\", term::color::GREEN)\n     }\n \n-    pub fn write_failed(&mut self) -> old_io::IoResult<()> {\n+    pub fn write_failed(&mut self) -> io::Result<()> {\n         self.write_pretty(\"FAILED\", term::color::RED)\n     }\n \n-    pub fn write_ignored(&mut self) -> old_io::IoResult<()> {\n+    pub fn write_ignored(&mut self) -> io::Result<()> {\n         self.write_pretty(\"ignored\", term::color::YELLOW)\n     }\n \n-    pub fn write_metric(&mut self) -> old_io::IoResult<()> {\n+    pub fn write_metric(&mut self) -> io::Result<()> {\n         self.write_pretty(\"metric\", term::color::CYAN)\n     }\n \n-    pub fn write_bench(&mut self) -> old_io::IoResult<()> {\n+    pub fn write_bench(&mut self) -> io::Result<()> {\n         self.write_pretty(\"bench\", term::color::CYAN)\n     }\n \n     pub fn write_pretty(&mut self,\n                         word: &str,\n-                        color: term::color::Color) -> old_io::IoResult<()> {\n+                        color: term::color::Color) -> io::Result<()> {\n         match self.out {\n             Pretty(ref mut term) => {\n                 if self.use_color {\n@@ -527,7 +521,7 @@ impl<T: Writer> ConsoleTestState<T> {\n         }\n     }\n \n-    pub fn write_plain(&mut self, s: &str) -> old_io::IoResult<()> {\n+    pub fn write_plain(&mut self, s: &str) -> io::Result<()> {\n         match self.out {\n             Pretty(ref mut term) => {\n                 try!(term.write_all(s.as_bytes()));\n@@ -540,19 +534,19 @@ impl<T: Writer> ConsoleTestState<T> {\n         }\n     }\n \n-    pub fn write_run_start(&mut self, len: uint) -> old_io::IoResult<()> {\n+    pub fn write_run_start(&mut self, len: uint) -> io::Result<()> {\n         self.total = len;\n         let noun = if len != 1 { \"tests\" } else { \"test\" };\n         self.write_plain(&format!(\"\\nrunning {} {}\\n\", len, noun))\n     }\n \n     pub fn write_test_start(&mut self, test: &TestDesc,\n-                            align: NamePadding) -> old_io::IoResult<()> {\n+                            align: NamePadding) -> io::Result<()> {\n         let name = test.padded_name(self.max_name_len, align);\n         self.write_plain(&format!(\"test {} ... \", name))\n     }\n \n-    pub fn write_result(&mut self, result: &TestResult) -> old_io::IoResult<()> {\n+    pub fn write_result(&mut self, result: &TestResult) -> io::Result<()> {\n         try!(match *result {\n             TrOk => self.write_ok(),\n             TrFailed => self.write_failed(),\n@@ -589,7 +583,7 @@ impl<T: Writer> ConsoleTestState<T> {\n         }\n     }\n \n-    pub fn write_failures(&mut self) -> old_io::IoResult<()> {\n+    pub fn write_failures(&mut self) -> io::Result<()> {\n         try!(self.write_plain(\"\\nfailures:\\n\"));\n         let mut failures = Vec::new();\n         let mut fail_out = String::new();\n@@ -615,7 +609,7 @@ impl<T: Writer> ConsoleTestState<T> {\n         Ok(())\n     }\n \n-    pub fn write_run_finish(&mut self) -> old_io::IoResult<bool> {\n+    pub fn write_run_finish(&mut self) -> io::Result<bool> {\n         assert!(self.passed + self.failed + self.ignored + self.measured == self.total);\n \n         let success = self.failed == 0;\n@@ -651,15 +645,15 @@ pub fn fmt_bench_samples(bs: &BenchSamples) -> String {\n }\n \n // A simple console test runner\n-pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> old_io::IoResult<bool> {\n+pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> io::Result<bool> {\n \n-    fn callback<T: Writer>(event: &TestEvent,\n-                           st: &mut ConsoleTestState<T>) -> old_io::IoResult<()> {\n+    fn callback<T: Write>(event: &TestEvent,\n+                          st: &mut ConsoleTestState<T>) -> io::Result<()> {\n         match (*event).clone() {\n             TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n             TeWait(ref test, padding) => st.write_test_start(test, padding),\n             TeResult(test, result, stdout) => {\n-                try!(st.write_log(&test, &result).map_err(new2old));\n+                try!(st.write_log(&test, &result));\n                 try!(st.write_result(&result));\n                 match result {\n                     TrOk => st.passed += 1,\n@@ -693,7 +687,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> old_io:\n         }\n     }\n \n-    let mut st = try!(ConsoleTestState::new(opts, None::<StdWriter>));\n+    let mut st = try!(ConsoleTestState::new(opts, None::<io::Stdout>));\n     fn len_if_padded(t: &TestDescAndFn) -> uint {\n         match t.testfn.padding() {\n             PadNone => 0,\n@@ -752,12 +746,31 @@ fn should_sort_failures_before_printing_them() {\n \n fn use_color(opts: &TestOpts) -> bool {\n     match opts.color {\n-        AutoColor => get_concurrency() == 1 && old_io::stdout().get_ref().isatty(),\n+        AutoColor => get_concurrency() == 1 && stdout_isatty(),\n         AlwaysColor => true,\n         NeverColor => false,\n     }\n }\n \n+#[cfg(unix)]\n+fn stdout_isatty() -> bool {\n+    unsafe { libc::isatty(libc::STDOUT_FILENO) != 0 }\n+}\n+#[cfg(windows)]\n+fn stdout_isatty() -> bool {\n+    const STD_OUTPUT_HANDLE: libc::DWORD = -11;\n+    extern \"system\" {\n+        fn GetStdHandle(which: libc::DWORD) -> libc::HANDLE;\n+        fn GetConsoleMode(hConsoleHandle: libc::HANDLE,\n+                          lpMode: libc::LPDWORD) -> libc::BOOL;\n+    }\n+    unsafe {\n+        let handle = GetStdHandle(STD_OUTPUT_HANDLE);\n+        let mut out = 0;\n+        GetConsoleMode(handle, &mut out) != 0\n+    }\n+}\n+\n #[derive(Clone)]\n enum TestEvent {\n     TeFiltered(Vec<TestDesc> ),\n@@ -770,8 +783,8 @@ pub type MonitorMsg = (TestDesc, TestResult, Vec<u8> );\n \n fn run_tests<F>(opts: &TestOpts,\n                 tests: Vec<TestDescAndFn> ,\n-                mut callback: F) -> old_io::IoResult<()> where\n-    F: FnMut(TestEvent) -> old_io::IoResult<()>,\n+                mut callback: F) -> io::Result<()> where\n+    F: FnMut(TestEvent) -> io::Result<()>,\n {\n     let filtered_tests = filter_tests(opts, tests);\n     let filtered_descs = filtered_tests.iter()\n@@ -895,29 +908,41 @@ pub fn run_test(opts: &TestOpts,\n         return;\n     }\n \n+    #[allow(deprecated)] // set_stdout\n     fn run_test_inner(desc: TestDesc,\n                       monitor_ch: Sender<MonitorMsg>,\n                       nocapture: bool,\n                       testfn: Thunk<'static>) {\n+        struct Sink(Arc<Mutex<Vec<u8>>>);\n+        impl Write for Sink {\n+            fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+                Write::write(&mut *self.0.lock().unwrap(), data)\n+            }\n+            fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+        }\n+        impl Writer for Sink {\n+            fn write_all(&mut self, data: &[u8]) -> std::old_io::IoResult<()> {\n+                Writer::write_all(&mut *self.0.lock().unwrap(), data)\n+            }\n+        }\n+\n         thread::spawn(move || {\n-            let (tx, rx) = channel();\n-            let mut reader = ChanReader::new(rx);\n-            let stdout = ChanWriter::new(tx.clone());\n-            let stderr = ChanWriter::new(tx);\n-            let mut cfg = thread::Builder::new().name(match desc.name {\n+            let data = Arc::new(Mutex::new(Vec::new()));\n+            let data2 = data.clone();\n+            let cfg = thread::Builder::new().name(match desc.name {\n                 DynTestName(ref name) => name.clone().to_string(),\n                 StaticTestName(name) => name.to_string(),\n             });\n-            if nocapture {\n-                drop((stdout, stderr));\n-            } else {\n-                cfg = cfg.stdout(box stdout as Box<Writer + Send>);\n-                cfg = cfg.stderr(box stderr as Box<Writer + Send>);\n-            }\n \n-            let result_guard = cfg.spawn(move || { testfn.invoke(()) }).unwrap();\n-            let stdout = reader.read_to_end().unwrap().into_iter().collect();\n+            let result_guard = cfg.spawn(move || {\n+                if !nocapture {\n+                    std::old_io::stdio::set_stdout(box Sink(data2.clone()));\n+                    io::set_panic(box Sink(data2));\n+                }\n+                testfn.invoke(())\n+            }).unwrap();\n             let test_result = calc_result(&desc, result_guard.join());\n+            let stdout = data.lock().unwrap().to_vec();\n             monitor_ch.send((desc.clone(), test_result, stdout)).unwrap();\n         });\n     }"}, {"sha": "84d510294efe4906354ca1b6799333d53baf7c67", "filename": "src/rustbook/main.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -12,8 +12,6 @@\n \n #![feature(core)]\n #![feature(exit_status)]\n-#![feature(io)]\n-#![feature(old_io)]\n #![feature(rustdoc)]\n #![feature(rustc_private)]\n "}, {"sha": "060297beb758bc37da200710b716e19036b6ac9a", "filename": "src/rustbook/term.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Frustbook%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Frustbook%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fterm.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -12,22 +12,23 @@\n //! verbosity support. For now, just a wrapper around stdout/stderr.\n \n use std::env;\n-use std::old_io::stdio;\n+use std::io;\n+use std::io::prelude::*;\n \n pub struct Term {\n-    err: Box<Writer + 'static>\n+    err: Box<Write + 'static>\n }\n \n impl Term {\n     pub fn new() -> Term {\n         Term {\n-            err: Box::new(stdio::stderr())\n+            err: Box::new(io::stderr())\n         }\n     }\n \n     pub fn err(&mut self, msg: &str) {\n         // swallow any errors\n-        let _ = self.err.write_line(msg);\n+        let _ = writeln!(&mut self.err, \"{}\", msg);\n         env::set_exit_status(101);\n     }\n }"}, {"sha": "bc907787c7cc014314e051d2418ea10917fb55b9", "filename": "src/test/run-pass/issue-11881.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11881.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -13,16 +13,15 @@\n extern crate rbml;\n extern crate serialize;\n \n-use std::old_io;\n+use std::io::Cursor;\n+use std::io::prelude::*;\n use std::fmt;\n-use std::old_io::{IoResult, SeekStyle};\n use std::slice;\n \n use serialize::{Encodable, Encoder};\n use serialize::json;\n \n use rbml::writer;\n-use rbml::io::SeekableMemWriter;\n \n #[derive(Encodable)]\n struct Foo {\n@@ -40,17 +39,17 @@ enum WireProtocol {\n     // ...\n }\n \n-fn encode_json<T: Encodable>(val: &T, wr: &mut SeekableMemWriter) {\n+fn encode_json<T: Encodable>(val: &T, wr: &mut Cursor<Vec<u8>>) {\n     write!(wr, \"{}\", json::as_json(val));\n }\n-fn encode_rbml<T: Encodable>(val: &T, wr: &mut SeekableMemWriter) {\n+fn encode_rbml<T: Encodable>(val: &T, wr: &mut Cursor<Vec<u8>>) {\n     let mut encoder = writer::Encoder::new(wr);\n     val.encode(&mut encoder);\n }\n \n pub fn main() {\n     let target = Foo{baz: false,};\n-    let mut wr = SeekableMemWriter::new();\n+    let mut wr = Cursor::new(Vec::new());\n     let proto = WireProtocol::JSON;\n     match proto {\n         WireProtocol::JSON => encode_json(&target, &mut wr),"}, {"sha": "3131cda1dbc3aa7a89b72b067191c524c9c58863", "filename": "src/test/run-pass/task-stderr.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-stderr.rs?ref=981bf5f690d1d7c5cf3e1419ac7a7c86dbc7a4d5", "patch": "@@ -11,21 +11,30 @@\n #![allow(unknown_features)]\n #![feature(box_syntax)]\n \n-use std::sync::mpsc::channel;\n-use std::old_io::{ChanReader, ChanWriter};\n+use std::io::prelude::*;\n+use std::io;\n+use std::str;\n+use std::sync::{Arc, Mutex};\n use std::thread;\n \n-fn main() {\n-    let (tx, rx) = channel();\n-    let mut reader = ChanReader::new(rx);\n-    let stderr = ChanWriter::new(tx);\n+struct Sink(Arc<Mutex<Vec<u8>>>);\n+impl Write for Sink {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        Write::write(&mut *self.0.lock().unwrap(), data)\n+    }\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+}\n \n-    let res = thread::Builder::new().stderr(box stderr as Box<Writer + Send>)\n-                                    .spawn(move|| -> () {\n+fn main() {\n+    let data = Arc::new(Mutex::new(Vec::new()));\n+    let sink = Sink(data.clone());\n+    let res = thread::Builder::new().spawn(move|| -> () {\n+        io::set_panic(Box::new(sink));\n         panic!(\"Hello, world!\")\n     }).unwrap().join();\n     assert!(res.is_err());\n \n-    let output = reader.read_to_string().unwrap();\n+    let output = data.lock().unwrap();\n+    let output = str::from_utf8(&output).unwrap();\n     assert!(output.contains(\"Hello, world!\"));\n }"}]}