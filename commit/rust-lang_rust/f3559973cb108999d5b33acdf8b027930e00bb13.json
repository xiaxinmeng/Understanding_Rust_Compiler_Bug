{"sha": "f3559973cb108999d5b33acdf8b027930e00bb13", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNTU5OTczY2IxMDg5OTlkNWIzM2FjZGY4YjAyNzkzMGUwMGJiMTM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-04-02T12:27:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-02T12:27:55Z"}, "message": "Rollup merge of #70615 - Lezzz:rename-tables, r=oli-obk\n\nRenamed `PerDefTables` to `Tables`\n\nOriginally suggested by @eddyb", "tree": {"sha": "8862ccbd54eff56116c47b7df6f129a8b072425b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8862ccbd54eff56116c47b7df6f129a8b072425b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3559973cb108999d5b33acdf8b027930e00bb13", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJehdpLCRBK7hj4Ov3rIwAAdHIIAG4vjzU5phVfSRLs1Uvq7z2U\no14JimwpIxZU1IUF+hHZX2oh3rVxYMaIh8zjwCjSfWYt33VsMPyCEIg3AYZ4ZEy0\n4dfJP/UghmLEEvh5SV2xPm9aZz4aZdO0ey+LMYVwCgGhWyJm84kee8J5tjAS7c53\nQxVvdcyoGTlpVFWCZIIOwcBkXHHPOddooqJQO+TWB0valytKGFER8NYEQWhKWiEC\nWLiFzr4NE84T/dcppyUnyjSYM36/c7b5H6ajEFuKMj3dsM5Pfh4fnRSoY7fXpwkO\nvoGOIwR7D5BFsOd78L3zv3pw4jR0TP/a4JMK7BfQEYMqw4HIVhE3YTADJRrCfok=\n=I4yl\n-----END PGP SIGNATURE-----\n", "payload": "tree 8862ccbd54eff56116c47b7df6f129a8b072425b\nparent 03591e8a7842896975985614221a152b28238bb8\nparent dca3782c18067001bee992523016d55e08b07057\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1585830475 +0200\ncommitter GitHub <noreply@github.com> 1585830475 +0200\n\nRollup merge of #70615 - Lezzz:rename-tables, r=oli-obk\n\nRenamed `PerDefTables` to `Tables`\n\nOriginally suggested by @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3559973cb108999d5b33acdf8b027930e00bb13", "html_url": "https://github.com/rust-lang/rust/commit/f3559973cb108999d5b33acdf8b027930e00bb13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3559973cb108999d5b33acdf8b027930e00bb13/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03591e8a7842896975985614221a152b28238bb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/03591e8a7842896975985614221a152b28238bb8", "html_url": "https://github.com/rust-lang/rust/commit/03591e8a7842896975985614221a152b28238bb8"}, {"sha": "dca3782c18067001bee992523016d55e08b07057", "url": "https://api.github.com/repos/rust-lang/rust/commits/dca3782c18067001bee992523016d55e08b07057", "html_url": "https://github.com/rust-lang/rust/commit/dca3782c18067001bee992523016d55e08b07057"}], "stats": {"total": 234, "additions": 117, "deletions": 117}, "files": [{"sha": "04aa8187e1fe93da883529673675f0bf33573246", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f3559973cb108999d5b33acdf8b027930e00bb13/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3559973cb108999d5b33acdf8b027930e00bb13/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=f3559973cb108999d5b33acdf8b027930e00bb13", "patch": "@@ -633,7 +633,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn maybe_kind(&self, item_id: DefIndex) -> Option<EntryKind> {\n-        self.root.per_def.kind.get(self, item_id).map(|k| k.decode(self))\n+        self.root.tables.kind.get(self, item_id).map(|k| k.decode(self))\n     }\n \n     fn kind(&self, item_id: DefIndex) -> EntryKind {\n@@ -665,7 +665,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .expect(\"no name in item_ident\");\n             let span = self\n                 .root\n-                .per_def\n+                .tables\n                 .ident_span\n                 .get(self, item_index)\n                 .map(|data| data.decode((self, sess)))\n@@ -688,7 +688,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_span(&self, index: DefIndex, sess: &Session) -> Span {\n-        self.root.per_def.span.get(self, index).unwrap().decode((self, sess))\n+        self.root.tables.span.get(self, index).unwrap().decode((self, sess))\n     }\n \n     fn load_proc_macro(&self, id: DefIndex, sess: &Session) -> SyntaxExtension {\n@@ -781,7 +781,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             ctor_did,\n             data.discr,\n             self.root\n-                .per_def\n+                .tables\n                 .children\n                 .get(self, index)\n                 .unwrap_or(Lazy::empty())\n@@ -812,7 +812,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n         let variants = if let ty::AdtKind::Enum = adt_kind {\n             self.root\n-                .per_def\n+                .tables\n                 .children\n                 .get(self, item_id)\n                 .unwrap_or(Lazy::empty())\n@@ -831,7 +831,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n-        self.root.per_def.explicit_predicates.get(self, item_id).unwrap().decode((self, tcx))\n+        self.root.tables.explicit_predicates.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n     fn get_inferred_outlives(\n@@ -840,7 +840,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n         self.root\n-            .per_def\n+            .tables\n             .inferred_outlives\n             .get(self, item_id)\n             .map(|predicates| predicates.decode((self, tcx)))\n@@ -852,31 +852,31 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n-        self.root.per_def.super_predicates.get(self, item_id).unwrap().decode((self, tcx))\n+        self.root.tables.super_predicates.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n     fn get_generics(&self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n-        self.root.per_def.generics.get(self, item_id).unwrap().decode((self, sess))\n+        self.root.tables.generics.get(self, item_id).unwrap().decode((self, sess))\n     }\n \n     fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n-        self.root.per_def.ty.get(self, id).unwrap().decode((self, tcx))\n+        self.root.tables.ty.get(self, id).unwrap().decode((self, tcx))\n     }\n \n     fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n         match self.is_proc_macro(id) {\n             true => self.root.proc_macro_stability,\n-            false => self.root.per_def.stability.get(self, id).map(|stab| stab.decode(self)),\n+            false => self.root.tables.stability.get(self, id).map(|stab| stab.decode(self)),\n         }\n     }\n \n     fn get_const_stability(&self, id: DefIndex) -> Option<attr::ConstStability> {\n-        self.root.per_def.const_stability.get(self, id).map(|stab| stab.decode(self))\n+        self.root.tables.const_stability.get(self, id).map(|stab| stab.decode(self))\n     }\n \n     fn get_deprecation(&self, id: DefIndex) -> Option<attr::Deprecation> {\n         self.root\n-            .per_def\n+            .tables\n             .deprecation\n             .get(self, id)\n             .filter(|_| !self.is_proc_macro(id))\n@@ -886,7 +886,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     fn get_visibility(&self, id: DefIndex) -> ty::Visibility {\n         match self.is_proc_macro(id) {\n             true => ty::Visibility::Public,\n-            false => self.root.per_def.visibility.get(self, id).unwrap().decode(self),\n+            false => self.root.tables.visibility.get(self, id).unwrap().decode(self),\n         }\n     }\n \n@@ -914,7 +914,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_impl_trait(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n-        self.root.per_def.impl_trait_ref.get(self, id).map(|tr| tr.decode((self, tcx)))\n+        self.root.tables.impl_trait_ref.get(self, id).map(|tr| tr.decode((self, tcx)))\n     }\n \n     /// Iterates over all the stability attributes in the given crate.\n@@ -984,7 +984,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n         // Iterate over all children.\n         let macros_only = self.dep_kind.lock().macros_only();\n-        let children = self.root.per_def.children.get(self, id).unwrap_or(Lazy::empty());\n+        let children = self.root.tables.children.get(self, id).unwrap_or(Lazy::empty());\n         for child_index in children.decode((self, sess)) {\n             if macros_only {\n                 continue;\n@@ -1004,7 +1004,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                     EntryKind::ForeignMod => {\n                         let child_children = self\n                             .root\n-                            .per_def\n+                            .tables\n                             .children\n                             .get(self, child_index)\n                             .unwrap_or(Lazy::empty());\n@@ -1016,7 +1016,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                                     vis: self.get_visibility(child_index),\n                                     span: self\n                                         .root\n-                                        .per_def\n+                                        .tables\n                                         .span\n                                         .get(self, child_index)\n                                         .unwrap()\n@@ -1096,13 +1096,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn is_item_mir_available(&self, id: DefIndex) -> bool {\n-        !self.is_proc_macro(id) && self.root.per_def.mir.get(self, id).is_some()\n+        !self.is_proc_macro(id) && self.root.tables.mir.get(self, id).is_some()\n     }\n \n     fn get_optimized_mir(&self, tcx: TyCtxt<'tcx>, id: DefIndex) -> BodyAndCache<'tcx> {\n         let mut cache = self\n             .root\n-            .per_def\n+            .tables\n             .mir\n             .get(self, id)\n             .filter(|_| !self.is_proc_macro(id))\n@@ -1121,7 +1121,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     ) -> IndexVec<Promoted, BodyAndCache<'tcx>> {\n         let mut cache = self\n             .root\n-            .per_def\n+            .tables\n             .promoted_mir\n             .get(self, id)\n             .filter(|_| !self.is_proc_macro(id))\n@@ -1172,7 +1172,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {\n-        self.root.per_def.variances.get(self, id).unwrap_or(Lazy::empty()).decode(self).collect()\n+        self.root.tables.variances.get(self, id).unwrap_or(Lazy::empty()).decode(self).collect()\n     }\n \n     fn get_ctor_kind(&self, node_id: DefIndex) -> CtorKind {\n@@ -1209,7 +1209,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n         Lrc::from(\n             self.root\n-                .per_def\n+                .tables\n                 .attributes\n                 .get(self, item_id)\n                 .unwrap_or(Lazy::empty())\n@@ -1220,7 +1220,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n     fn get_struct_field_names(&self, id: DefIndex, sess: &Session) -> Vec<Spanned<ast::Name>> {\n         self.root\n-            .per_def\n+            .tables\n             .children\n             .get(self, id)\n             .unwrap_or(Lazy::empty())\n@@ -1236,7 +1236,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     ) -> &'tcx [DefId] {\n         tcx.arena.alloc_from_iter(\n             self.root\n-                .per_def\n+                .tables\n                 .inherent_impls\n                 .get(self, id)\n                 .unwrap_or(Lazy::empty())\n@@ -1416,7 +1416,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n-        self.root.per_def.fn_sig.get(self, id).unwrap().decode((self, tcx))\n+        self.root.tables.fn_sig.get(self, id).unwrap().decode((self, tcx))\n     }\n \n     #[inline]"}, {"sha": "3cc5fb1a991e18c12032eee3594963f58fd5374d", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/f3559973cb108999d5b33acdf8b027930e00bb13/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3559973cb108999d5b33acdf8b027930e00bb13/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=f3559973cb108999d5b33acdf8b027930e00bb13", "patch": "@@ -45,7 +45,7 @@ struct EncodeContext<'tcx> {\n     opaque: opaque::Encoder,\n     tcx: TyCtxt<'tcx>,\n \n-    per_def: PerDefTableBuilders<'tcx>,\n+    tables: TableBuilders<'tcx>,\n \n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n@@ -497,8 +497,8 @@ impl<'tcx> EncodeContext<'tcx> {\n         };\n \n         i = self.position();\n-        let per_def = self.per_def.encode(&mut self.opaque);\n-        let per_def_bytes = self.position() - i;\n+        let tables = self.tables.encode(&mut self.opaque);\n+        let tables_bytes = self.position() - i;\n \n         // Encode the proc macro data\n         i = self.position();\n@@ -560,7 +560,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             impls,\n             exported_symbols,\n             interpret_alloc_index,\n-            per_def,\n+            tables,\n         });\n \n         let total_bytes = self.position();\n@@ -585,7 +585,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             println!(\"  def-path table bytes: {}\", def_path_table_bytes);\n             println!(\" proc-macro-data-bytes: {}\", proc_macro_data_bytes);\n             println!(\"            item bytes: {}\", item_bytes);\n-            println!(\"   per-def table bytes: {}\", per_def_bytes);\n+            println!(\"           table bytes: {}\", tables_bytes);\n             println!(\"            zero bytes: {}\", zero_bytes);\n             println!(\"           total bytes: {}\", total_bytes);\n         }\n@@ -597,12 +597,12 @@ impl<'tcx> EncodeContext<'tcx> {\n impl EncodeContext<'tcx> {\n     fn encode_variances_of(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_variances_of({:?})\", def_id);\n-        record!(self.per_def.variances[def_id] <- &self.tcx.variances_of(def_id)[..]);\n+        record!(self.tables.variances[def_id] <- &self.tcx.variances_of(def_id)[..]);\n     }\n \n     fn encode_item_type(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_item_type({:?})\", def_id);\n-        record!(self.per_def.ty[def_id] <- self.tcx.type_of(def_id));\n+        record!(self.tables.ty[def_id] <- self.tcx.type_of(def_id));\n     }\n \n     fn encode_enum_variant_info(&mut self, enum_did: DefId, index: VariantIdx) {\n@@ -621,12 +621,12 @@ impl EncodeContext<'tcx> {\n         let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n         let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n \n-        record!(self.per_def.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n-        record!(self.per_def.visibility[def_id] <-\n+        record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n+        record!(self.tables.visibility[def_id] <-\n             ty::Visibility::from_hir(enum_vis, enum_id, self.tcx));\n-        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n-        record!(self.per_def.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n-        record!(self.per_def.children[def_id] <- variant.fields.iter().map(|f| {\n+        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.tables.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n+        record!(self.tables.children[def_id] <- variant.fields.iter().map(|f| {\n             assert!(f.did.is_local());\n             f.did.index\n         }));\n@@ -637,7 +637,7 @@ impl EncodeContext<'tcx> {\n         if variant.ctor_kind == CtorKind::Fn {\n             // FIXME(eddyb) encode signature only in `encode_enum_variant_ctor`.\n             if let Some(ctor_def_id) = variant.ctor_def_id {\n-                record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(ctor_def_id));\n+                record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(ctor_def_id));\n             }\n             // FIXME(eddyb) is this ever used?\n             self.encode_variances_of(def_id);\n@@ -672,14 +672,14 @@ impl EncodeContext<'tcx> {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }\n \n-        record!(self.per_def.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n-        record!(self.per_def.visibility[def_id] <- ctor_vis);\n-        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n+        record!(self.tables.visibility[def_id] <- ctor_vis);\n+        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n-            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n+            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -707,11 +707,11 @@ impl EncodeContext<'tcx> {\n             },\n         };\n \n-        record!(self.per_def.kind[def_id] <- EntryKind::Mod(self.lazy(data)));\n-        record!(self.per_def.visibility[def_id] <- ty::Visibility::from_hir(vis, id, self.tcx));\n-        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n-        record!(self.per_def.attributes[def_id] <- attrs);\n-        record!(self.per_def.children[def_id] <- md.item_ids.iter().map(|item_id| {\n+        record!(self.tables.kind[def_id] <- EntryKind::Mod(self.lazy(data)));\n+        record!(self.tables.visibility[def_id] <- ty::Visibility::from_hir(vis, id, self.tcx));\n+        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.tables.attributes[def_id] <- attrs);\n+        record!(self.tables.children[def_id] <- md.item_ids.iter().map(|item_id| {\n             tcx.hir().local_def_id(item_id.id).index\n         }));\n         self.encode_stability(def_id);\n@@ -729,10 +729,10 @@ impl EncodeContext<'tcx> {\n         let variant_id = tcx.hir().as_local_hir_id(variant.def_id).unwrap();\n         let variant_data = tcx.hir().expect_variant_data(variant_id);\n \n-        record!(self.per_def.kind[def_id] <- EntryKind::Field);\n-        record!(self.per_def.visibility[def_id] <- field.vis);\n-        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n-        record!(self.per_def.attributes[def_id] <- variant_data.fields()[field_index].attrs);\n+        record!(self.tables.kind[def_id] <- EntryKind::Field);\n+        record!(self.tables.visibility[def_id] <- field.vis);\n+        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.tables.attributes[def_id] <- variant_data.fields()[field_index].attrs);\n         self.encode_ident_span(def_id, field.ident);\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n@@ -771,14 +771,14 @@ impl EncodeContext<'tcx> {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }\n \n-        record!(self.per_def.kind[def_id] <- EntryKind::Struct(self.lazy(data), adt_def.repr));\n-        record!(self.per_def.visibility[def_id] <- ctor_vis);\n-        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.tables.kind[def_id] <- EntryKind::Struct(self.lazy(data), adt_def.repr));\n+        record!(self.tables.visibility[def_id] <- ctor_vis);\n+        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n-            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n+            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -790,26 +790,26 @@ impl EncodeContext<'tcx> {\n \n     fn encode_generics(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_generics({:?})\", def_id);\n-        record!(self.per_def.generics[def_id] <- self.tcx.generics_of(def_id));\n+        record!(self.tables.generics[def_id] <- self.tcx.generics_of(def_id));\n     }\n \n     fn encode_explicit_predicates(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_explicit_predicates({:?})\", def_id);\n-        record!(self.per_def.explicit_predicates[def_id] <-\n+        record!(self.tables.explicit_predicates[def_id] <-\n             self.tcx.explicit_predicates_of(def_id));\n     }\n \n     fn encode_inferred_outlives(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_inferred_outlives({:?})\", def_id);\n         let inferred_outlives = self.tcx.inferred_outlives_of(def_id);\n         if !inferred_outlives.is_empty() {\n-            record!(self.per_def.inferred_outlives[def_id] <- inferred_outlives);\n+            record!(self.tables.inferred_outlives[def_id] <- inferred_outlives);\n         }\n     }\n \n     fn encode_super_predicates(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_super_predicates({:?})\", def_id);\n-        record!(self.per_def.super_predicates[def_id] <- self.tcx.super_predicates_of(def_id));\n+        record!(self.tables.super_predicates[def_id] <- self.tcx.super_predicates_of(def_id));\n     }\n \n     fn encode_info_for_trait_item(&mut self, def_id: DefId) {\n@@ -826,7 +826,7 @@ impl EncodeContext<'tcx> {\n             hir::Defaultness::Final => span_bug!(ast_item.span, \"traits cannot have final items\"),\n         };\n \n-        record!(self.per_def.kind[def_id] <- match trait_item.kind {\n+        record!(self.tables.kind[def_id] <- match trait_item.kind {\n             ty::AssocKind::Const => {\n                 let rendered = rustc_hir_pretty::to_string(\n                     &(&self.tcx.hir() as &dyn intravisit::Map<'_>),\n@@ -867,9 +867,9 @@ impl EncodeContext<'tcx> {\n             ty::AssocKind::Type => EntryKind::AssocType(container),\n             ty::AssocKind::OpaqueTy => span_bug!(ast_item.span, \"opaque type in trait\"),\n         });\n-        record!(self.per_def.visibility[def_id] <- trait_item.vis);\n-        record!(self.per_def.span[def_id] <- ast_item.span);\n-        record!(self.per_def.attributes[def_id] <- ast_item.attrs);\n+        record!(self.tables.visibility[def_id] <- trait_item.vis);\n+        record!(self.tables.span[def_id] <- ast_item.span);\n+        record!(self.tables.attributes[def_id] <- ast_item.attrs);\n         self.encode_ident_span(def_id, ast_item.ident);\n         self.encode_stability(def_id);\n         self.encode_const_stability(def_id);\n@@ -886,7 +886,7 @@ impl EncodeContext<'tcx> {\n             ty::AssocKind::OpaqueTy => unreachable!(),\n         }\n         if trait_item.kind == ty::AssocKind::Method {\n-            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n+            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -919,7 +919,7 @@ impl EncodeContext<'tcx> {\n             }\n         };\n \n-        record!(self.per_def.kind[def_id] <- match impl_item.kind {\n+        record!(self.tables.kind[def_id] <- match impl_item.kind {\n             ty::AssocKind::Const => {\n                 if let hir::ImplItemKind::Const(_, body_id) = ast_item.kind {\n                     let qualifs = self.tcx.at(ast_item.span).mir_const_qualif(def_id);\n@@ -951,16 +951,16 @@ impl EncodeContext<'tcx> {\n             ty::AssocKind::OpaqueTy => EntryKind::AssocOpaqueTy(container),\n             ty::AssocKind::Type => EntryKind::AssocType(container)\n         });\n-        record!(self.per_def.visibility[def_id] <- impl_item.vis);\n-        record!(self.per_def.span[def_id] <- ast_item.span);\n-        record!(self.per_def.attributes[def_id] <- ast_item.attrs);\n+        record!(self.tables.visibility[def_id] <- impl_item.vis);\n+        record!(self.tables.span[def_id] <- ast_item.span);\n+        record!(self.tables.attributes[def_id] <- ast_item.attrs);\n         self.encode_ident_span(def_id, impl_item.ident);\n         self.encode_stability(def_id);\n         self.encode_const_stability(def_id);\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if impl_item.kind == ty::AssocKind::Method {\n-            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n+            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -1005,14 +1005,14 @@ impl EncodeContext<'tcx> {\n     fn encode_optimized_mir(&mut self, def_id: DefId) {\n         debug!(\"EntryBuilder::encode_mir({:?})\", def_id);\n         if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id) {\n-            record!(self.per_def.mir[def_id] <- self.tcx.optimized_mir(def_id));\n+            record!(self.tables.mir[def_id] <- self.tcx.optimized_mir(def_id));\n         }\n     }\n \n     fn encode_promoted_mir(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_promoted_mir({:?})\", def_id);\n         if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id) {\n-            record!(self.per_def.promoted_mir[def_id] <- self.tcx.promoted_mir(def_id));\n+            record!(self.tables.promoted_mir[def_id] <- self.tcx.promoted_mir(def_id));\n         }\n     }\n \n@@ -1021,7 +1021,7 @@ impl EncodeContext<'tcx> {\n         debug!(\"EncodeContext::encode_inherent_implementations({:?})\", def_id);\n         let implementations = self.tcx.inherent_impls(def_id);\n         if !implementations.is_empty() {\n-            record!(self.per_def.inherent_impls[def_id] <- implementations.iter().map(|&def_id| {\n+            record!(self.tables.inherent_impls[def_id] <- implementations.iter().map(|&def_id| {\n                 assert!(def_id.is_local());\n                 def_id.index\n             }));\n@@ -1031,21 +1031,21 @@ impl EncodeContext<'tcx> {\n     fn encode_stability(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_stability({:?})\", def_id);\n         if let Some(stab) = self.tcx.lookup_stability(def_id) {\n-            record!(self.per_def.stability[def_id] <- stab)\n+            record!(self.tables.stability[def_id] <- stab)\n         }\n     }\n \n     fn encode_const_stability(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_const_stability({:?})\", def_id);\n         if let Some(stab) = self.tcx.lookup_const_stability(def_id) {\n-            record!(self.per_def.const_stability[def_id] <- stab)\n+            record!(self.tables.const_stability[def_id] <- stab)\n         }\n     }\n \n     fn encode_deprecation(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_deprecation({:?})\", def_id);\n         if let Some(depr) = self.tcx.lookup_deprecation(def_id) {\n-            record!(self.per_def.deprecation[def_id] <- depr);\n+            record!(self.tables.deprecation[def_id] <- depr);\n         }\n     }\n \n@@ -1066,7 +1066,7 @@ impl EncodeContext<'tcx> {\n \n         self.encode_ident_span(def_id, item.ident);\n \n-        record!(self.per_def.kind[def_id] <- match item.kind {\n+        record!(self.tables.kind[def_id] <- match item.kind {\n             hir::ItemKind::Static(_, hir::Mutability::Mut, _) => EntryKind::MutStatic,\n             hir::ItemKind::Static(_, hir::Mutability::Not, _) => EntryKind::ImmStatic,\n             hir::ItemKind::Const(_, body_id) => {\n@@ -1172,26 +1172,26 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n         });\n-        record!(self.per_def.visibility[def_id] <-\n+        record!(self.tables.visibility[def_id] <-\n             ty::Visibility::from_hir(&item.vis, item.hir_id, tcx));\n-        record!(self.per_def.span[def_id] <- item.span);\n-        record!(self.per_def.attributes[def_id] <- item.attrs);\n+        record!(self.tables.span[def_id] <- item.span);\n+        record!(self.tables.attributes[def_id] <- item.attrs);\n         // FIXME(eddyb) there should be a nicer way to do this.\n         match item.kind {\n-            hir::ItemKind::ForeignMod(ref fm) => record!(self.per_def.children[def_id] <-\n+            hir::ItemKind::ForeignMod(ref fm) => record!(self.tables.children[def_id] <-\n                 fm.items\n                     .iter()\n                     .map(|foreign_item| tcx.hir().local_def_id(\n                         foreign_item.hir_id).index)\n             ),\n-            hir::ItemKind::Enum(..) => record!(self.per_def.children[def_id] <-\n+            hir::ItemKind::Enum(..) => record!(self.tables.children[def_id] <-\n                 self.tcx.adt_def(def_id).variants.iter().map(|v| {\n                     assert!(v.def_id.is_local());\n                     v.def_id.index\n                 })\n             ),\n             hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n-                record!(self.per_def.children[def_id] <-\n+                record!(self.tables.children[def_id] <-\n                     self.tcx.adt_def(def_id).non_enum_variant().fields.iter().map(|f| {\n                         assert!(f.did.is_local());\n                         f.did.index\n@@ -1200,7 +1200,7 @@ impl EncodeContext<'tcx> {\n             }\n             hir::ItemKind::Impl { .. } | hir::ItemKind::Trait(..) => {\n                 let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n-                record!(self.per_def.children[def_id] <-\n+                record!(self.tables.children[def_id] <-\n                     associated_item_def_ids.iter().map(|&def_id| {\n                         assert!(def_id.is_local());\n                         def_id.index\n@@ -1225,11 +1225,11 @@ impl EncodeContext<'tcx> {\n             _ => {}\n         }\n         if let hir::ItemKind::Fn(..) = item.kind {\n-            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n+            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n         }\n         if let hir::ItemKind::Impl { .. } = item.kind {\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(def_id) {\n-                record!(self.per_def.impl_trait_ref[def_id] <- trait_ref);\n+                record!(self.tables.impl_trait_ref[def_id] <- trait_ref);\n             }\n         }\n         self.encode_inherent_implementations(def_id);\n@@ -1288,19 +1288,19 @@ impl EncodeContext<'tcx> {\n     /// Serialize the text of exported macros\n     fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef<'_>) {\n         let def_id = self.tcx.hir().local_def_id(macro_def.hir_id);\n-        record!(self.per_def.kind[def_id] <- EntryKind::MacroDef(self.lazy(macro_def.ast.clone())));\n-        record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n-        record!(self.per_def.span[def_id] <- macro_def.span);\n-        record!(self.per_def.attributes[def_id] <- macro_def.attrs);\n+        record!(self.tables.kind[def_id] <- EntryKind::MacroDef(self.lazy(macro_def.ast.clone())));\n+        record!(self.tables.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.tables.span[def_id] <- macro_def.span);\n+        record!(self.tables.attributes[def_id] <- macro_def.attrs);\n         self.encode_ident_span(def_id, macro_def.ident);\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n     }\n \n     fn encode_info_for_generic_param(&mut self, def_id: DefId, kind: EntryKind, encode_type: bool) {\n-        record!(self.per_def.kind[def_id] <- kind);\n-        record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n-        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.tables.kind[def_id] <- kind);\n+        record!(self.tables.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         if encode_type {\n             self.encode_item_type(def_id);\n         }\n@@ -1314,7 +1314,7 @@ impl EncodeContext<'tcx> {\n         let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n         let ty = self.tcx.typeck_tables_of(def_id).node_type(hir_id);\n \n-        record!(self.per_def.kind[def_id] <- match ty.kind {\n+        record!(self.tables.kind[def_id] <- match ty.kind {\n             ty::Generator(..) => {\n                 let data = self.tcx.generator_kind(def_id).unwrap();\n                 EntryKind::Generator(data)\n@@ -1324,12 +1324,12 @@ impl EncodeContext<'tcx> {\n \n             _ => bug!(\"closure that is neither generator nor closure\"),\n         });\n-        record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n-        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n-        record!(self.per_def.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n+        record!(self.tables.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.tables.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n         self.encode_item_type(def_id);\n         if let ty::Closure(def_id, substs) = ty.kind {\n-            record!(self.per_def.fn_sig[def_id] <- substs.as_closure().sig());\n+            record!(self.tables.fn_sig[def_id] <- substs.as_closure().sig());\n         }\n         self.encode_generics(def_id);\n         self.encode_optimized_mir(def_id);\n@@ -1343,9 +1343,9 @@ impl EncodeContext<'tcx> {\n         let const_data = self.encode_rendered_const_for_body(body_id);\n         let qualifs = self.tcx.mir_const_qualif(def_id);\n \n-        record!(self.per_def.kind[def_id] <- EntryKind::Const(qualifs, const_data));\n-        record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n-        record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n+        record!(self.tables.kind[def_id] <- EntryKind::Const(qualifs, const_data));\n+        record!(self.tables.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         self.encode_item_type(def_id);\n         self.encode_generics(def_id);\n         self.encode_explicit_predicates(def_id);\n@@ -1516,7 +1516,7 @@ impl EncodeContext<'tcx> {\n \n         debug!(\"EncodeContext::encode_info_for_foreign_item({:?})\", def_id);\n \n-        record!(self.per_def.kind[def_id] <- match nitem.kind {\n+        record!(self.tables.kind[def_id] <- match nitem.kind {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n                 let data = FnData {\n                     asyncness: hir::IsAsync::NotAsync,\n@@ -1533,17 +1533,17 @@ impl EncodeContext<'tcx> {\n             hir::ForeignItemKind::Static(_, hir::Mutability::Not) => EntryKind::ForeignImmStatic,\n             hir::ForeignItemKind::Type => EntryKind::ForeignType,\n         });\n-        record!(self.per_def.visibility[def_id] <-\n+        record!(self.tables.visibility[def_id] <-\n             ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, self.tcx));\n-        record!(self.per_def.span[def_id] <- nitem.span);\n-        record!(self.per_def.attributes[def_id] <- nitem.attrs);\n+        record!(self.tables.span[def_id] <- nitem.span);\n+        record!(self.tables.attributes[def_id] <- nitem.attrs);\n         self.encode_ident_span(def_id, nitem.ident);\n         self.encode_stability(def_id);\n         self.encode_const_stability(def_id);\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if let hir::ForeignItemKind::Fn(..) = nitem.kind {\n-            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n+            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -1630,7 +1630,7 @@ impl EncodeContext<'tcx> {\n     }\n \n     fn encode_ident_span(&mut self, def_id: DefId, ident: Ident) {\n-        record!(self.per_def.ident_span[def_id] <- ident.span);\n+        record!(self.tables.ident_span[def_id] <- ident.span);\n     }\n \n     /// In some cases, along with the item itself, we also\n@@ -1846,7 +1846,7 @@ fn encode_metadata_impl(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     let mut ecx = EncodeContext {\n         opaque: encoder,\n         tcx,\n-        per_def: Default::default(),\n+        tables: Default::default(),\n         lazy_state: LazyState::NoNode,\n         type_shorthands: Default::default(),\n         predicate_shorthands: Default::default(),"}, {"sha": "8aa70293aab018c5b7a3c5e2fef28776c9109310", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f3559973cb108999d5b33acdf8b027930e00bb13/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3559973cb108999d5b33acdf8b027930e00bb13/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=f3559973cb108999d5b33acdf8b027930e00bb13", "patch": "@@ -197,7 +197,7 @@ crate struct CrateRoot<'tcx> {\n     impls: Lazy<[TraitImpls]>,\n     interpret_alloc_index: Lazy<[u32]>,\n \n-    per_def: LazyPerDefTables<'tcx>,\n+    tables: LazyTables<'tcx>,\n \n     /// The DefIndex's of any proc macros declared by this crate.\n     proc_macro_data: Option<Lazy<[DefIndex]>>,\n@@ -228,30 +228,30 @@ crate struct TraitImpls {\n     impls: Lazy<[DefIndex]>,\n }\n \n-/// Define `LazyPerDefTables` and `PerDefTableBuilders` at the same time.\n-macro_rules! define_per_def_tables {\n+/// Define `LazyTables` and `TableBuilders` at the same time.\n+macro_rules! define_tables {\n     ($($name:ident: Table<DefIndex, $T:ty>),+ $(,)?) => {\n         #[derive(RustcEncodable, RustcDecodable)]\n-        crate struct LazyPerDefTables<'tcx> {\n+        crate struct LazyTables<'tcx> {\n             $($name: Lazy!(Table<DefIndex, $T>)),+\n         }\n \n         #[derive(Default)]\n-        struct PerDefTableBuilders<'tcx> {\n+        struct TableBuilders<'tcx> {\n             $($name: TableBuilder<DefIndex, $T>),+\n         }\n \n-        impl PerDefTableBuilders<'tcx> {\n-            fn encode(&self, buf: &mut Encoder) -> LazyPerDefTables<'tcx> {\n-                LazyPerDefTables {\n+        impl TableBuilders<'tcx> {\n+            fn encode(&self, buf: &mut Encoder) -> LazyTables<'tcx> {\n+                LazyTables {\n                     $($name: self.$name.encode(buf)),+\n                 }\n             }\n         }\n     }\n }\n \n-define_per_def_tables! {\n+define_tables! {\n     kind: Table<DefIndex, Lazy<EntryKind>>,\n     visibility: Table<DefIndex, Lazy<ty::Visibility>>,\n     span: Table<DefIndex, Lazy<Span>>,"}]}