{"sha": "e5fb13897d947e13a1322a055b71632e30357eff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1ZmIxMzg5N2Q5NDdlMTNhMTMyMmEwNTViNzE2MzJlMzAzNTdlZmY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-03-09T23:02:39Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-03-17T19:12:21Z"}, "message": "AST: Keep distinction between `path` and `::path` in imports and visibilities\n\nAdd the root segment for name resolution purposes only", "tree": {"sha": "a9368805b050be3852c321648bcba5eea6b86087", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9368805b050be3852c321648bcba5eea6b86087"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5fb13897d947e13a1322a055b71632e30357eff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5fb13897d947e13a1322a055b71632e30357eff", "html_url": "https://github.com/rust-lang/rust/commit/e5fb13897d947e13a1322a055b71632e30357eff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5fb13897d947e13a1322a055b71632e30357eff/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b057c554ab9c7615ebdb3c920010a164ec5bf3ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/b057c554ab9c7615ebdb3c920010a164ec5bf3ed", "html_url": "https://github.com/rust-lang/rust/commit/b057c554ab9c7615ebdb3c920010a164ec5bf3ed"}], "stats": {"total": 143, "additions": 66, "deletions": 77}, "files": [{"sha": "dd3b9350d91610c40937efc8707059e19a8af1db", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb13897d947e13a1322a055b71632e30357eff/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb13897d947e13a1322a055b71632e30357eff/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e5fb13897d947e13a1322a055b71632e30357eff", "patch": "@@ -1355,17 +1355,11 @@ impl<'a> LoweringContext<'a> {\n                         id: NodeId,\n                         p: &Path,\n                         name: Option<Name>,\n-                        param_mode: ParamMode,\n-                        defaults_to_global: bool)\n+                        param_mode: ParamMode)\n                         -> hir::Path {\n-        let mut segments = p.segments.iter();\n-        if defaults_to_global && p.is_global() {\n-            segments.next();\n-        }\n-\n         hir::Path {\n             def: self.expect_full_def(id),\n-            segments: segments.map(|segment| {\n+            segments: p.segments.iter().map(|segment| {\n                 self.lower_path_segment(p.span, segment, param_mode, 0,\n                                         ParenthesizedGenericArgs::Err,\n                                         ImplTraitContext::Disallowed)\n@@ -1378,10 +1372,9 @@ impl<'a> LoweringContext<'a> {\n     fn lower_path(&mut self,\n                   id: NodeId,\n                   p: &Path,\n-                  param_mode: ParamMode,\n-                  defaults_to_global: bool)\n+                  param_mode: ParamMode)\n                   -> hir::Path {\n-        self.lower_path_extra(id, p, None, param_mode, defaults_to_global)\n+        self.lower_path_extra(id, p, None, param_mode)\n     }\n \n     fn lower_path_segment(&mut self,\n@@ -2069,7 +2062,7 @@ impl<'a> LoweringContext<'a> {\n                     }\n                 }\n \n-                let path = P(self.lower_path(id, &path, ParamMode::Explicit, true));\n+                let path = P(self.lower_path(id, &path, ParamMode::Explicit));\n                 hir::ItemUse(path, hir::UseKind::Single)\n             }\n             UseTreeKind::Glob => {\n@@ -2080,7 +2073,7 @@ impl<'a> LoweringContext<'a> {\n                         .cloned()\n                         .collect(),\n                     span: path.span,\n-                }, ParamMode::Explicit, true));\n+                }, ParamMode::Explicit));\n                 hir::ItemUse(path, hir::UseKind::Glob)\n             }\n             UseTreeKind::Nested(ref trees) => {\n@@ -2136,7 +2129,7 @@ impl<'a> LoweringContext<'a> {\n                 // Privatize the degenerate import base, used only to check\n                 // the stability of `use a::{};`, to avoid it showing up as\n                 // a re-export by accident when `pub`, e.g. in documentation.\n-                let path = P(self.lower_path(id, &prefix, ParamMode::Explicit, true));\n+                let path = P(self.lower_path(id, &prefix, ParamMode::Explicit));\n                 *vis = hir::Inherited;\n                 hir::ItemUse(path, hir::UseKind::ListStem)\n             }\n@@ -3379,7 +3372,7 @@ impl<'a> LoweringContext<'a> {\n             VisibilityKind::Crate(..) => hir::Visibility::Crate,\n             VisibilityKind::Restricted { ref path, id, .. } => {\n                 hir::Visibility::Restricted {\n-                    path: P(self.lower_path(id, path, ParamMode::Explicit, true)),\n+                    path: P(self.lower_path(id, path, ParamMode::Explicit)),\n                     id: if let Some(owner) = explicit_owner {\n                         self.lower_node_id_with_owner(id, owner).node_id\n                     } else {"}, {"sha": "c192f349c2019723f6eb2bba0679db27a4c43220", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb13897d947e13a1322a055b71632e30357eff/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb13897d947e13a1322a055b71632e30357eff/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=e5fb13897d947e13a1322a055b71632e30357eff", "patch": "@@ -245,9 +245,9 @@ impl<'a> Resolver<'a> {\n \n         match item.node {\n             ItemKind::Use(ref use_tree) => {\n-                // Just an empty prefix to start out\n+                // Imports are resolved as global by default, add starting root segment.\n                 let prefix = ast::Path {\n-                    segments: vec![],\n+                    segments: use_tree.prefix.make_root().into_iter().collect(),\n                     span: use_tree.span,\n                 };\n "}, {"sha": "23ad27ec2c3d6ba677c617d26cd564313820e158", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb13897d947e13a1322a055b71632e30357eff/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb13897d947e13a1322a055b71632e30357eff/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e5fb13897d947e13a1322a055b71632e30357eff", "patch": "@@ -2164,8 +2164,9 @@ impl<'a> Resolver<'a> {\n             }\n \n             ItemKind::Use(ref use_tree) => {\n+                // Imports are resolved as global by default, add starting root segment.\n                 let path = Path {\n-                    segments: vec![],\n+                    segments: use_tree.prefix.make_root().into_iter().collect(),\n                     span: use_tree.span,\n                 };\n                 self.resolve_use_tree(item.id, use_tree, &path);\n@@ -2300,7 +2301,6 @@ impl<'a> Resolver<'a> {\n                 None,\n                 &path,\n                 trait_ref.path.span,\n-                trait_ref.path.segments.last().unwrap().span,\n                 PathSource::Trait(AliasPossibility::No)\n             ).base_def();\n             if def != Def::Err {\n@@ -2731,18 +2731,17 @@ impl<'a> Resolver<'a> {\n         let segments = &path.segments.iter()\n             .map(|seg| respan(seg.span, seg.identifier))\n             .collect::<Vec<_>>();\n-        let ident_span = path.segments.last().map_or(path.span, |seg| seg.span);\n-        self.smart_resolve_path_fragment(id, qself, segments, path.span, ident_span, source)\n+        self.smart_resolve_path_fragment(id, qself, segments, path.span, source)\n     }\n \n     fn smart_resolve_path_fragment(&mut self,\n                                    id: NodeId,\n                                    qself: Option<&QSelf>,\n                                    path: &[SpannedIdent],\n                                    span: Span,\n-                                   ident_span: Span,\n                                    source: PathSource)\n                                    -> PathResolution {\n+        let ident_span = path.last().map_or(span, |ident| ident.span);\n         let ns = source.namespace();\n         let is_expected = &|def| source.is_expected(def);\n         let is_enum_variant = &|def| if let Def::Variant(..) = def { true } else { false };\n@@ -3090,7 +3089,7 @@ impl<'a> Resolver<'a> {\n             // Make sure `A::B` in `<T as A>::B::C` is a trait item.\n             let ns = if qself.position + 1 == path.len() { ns } else { TypeNS };\n             let res = self.smart_resolve_path_fragment(id, None, &path[..qself.position + 1],\n-                                                       span, span, PathSource::TraitItem(ns));\n+                                                       span, PathSource::TraitItem(ns));\n             return Some(PathResolution::with_unresolved_segments(\n                 res.base_def(), res.unresolved_segments() + path.len() - qself.position - 1\n             ));\n@@ -3941,8 +3940,12 @@ impl<'a> Resolver<'a> {\n                 ty::Visibility::Restricted(self.current_module.normal_ancestor_id)\n             }\n             ast::VisibilityKind::Restricted { ref path, id, .. } => {\n-                let def = self.smart_resolve_path(id, None, path,\n-                                                  PathSource::Visibility).base_def();\n+                // Visibilities are resolved as global by default, add starting root segment.\n+                let segments = path.make_root().iter().chain(path.segments.iter())\n+                    .map(|seg| respan(seg.span, seg.identifier))\n+                    .collect::<Vec<_>>();\n+                let def = self.smart_resolve_path_fragment(id, None, &segments, path.span,\n+                                                           PathSource::Visibility).base_def();\n                 if def == Def::Err {\n                     ty::Visibility::Public\n                 } else {"}, {"sha": "4cbebdc3c1c39f9458fb732e4e0da80bf471d2f7", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb13897d947e13a1322a055b71632e30357eff/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb13897d947e13a1322a055b71632e30357eff/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=e5fb13897d947e13a1322a055b71632e30357eff", "patch": "@@ -667,11 +667,10 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             }\n             PathResult::Failed(span, msg, true) => {\n                 let (mut self_path, mut self_result) = (module_path.clone(), None);\n-                if !self_path.is_empty() &&\n-                    !token::Ident(self_path[0].node).is_path_segment_keyword() &&\n-                    !(self_path.len() > 1 &&\n-                      token::Ident(self_path[1].node).is_path_segment_keyword())\n-                {\n+                let is_special = |ident| token::Ident(ident).is_path_segment_keyword() &&\n+                                         ident.name != keywords::CrateRoot.name();\n+                if !self_path.is_empty() && !is_special(self_path[0].node) &&\n+                   !(self_path.len() > 1 && is_special(self_path[1].node)) {\n                     self_path[0].node.name = keywords::SelfValue.name();\n                     self_result = Some(self.resolve_path(&self_path, None, false, span));\n                 }"}, {"sha": "4ce6c53d3383bacfd11eb62384ae98885ee63c8d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb13897d947e13a1322a055b71632e30357eff/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb13897d947e13a1322a055b71632e30357eff/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e5fb13897d947e13a1322a055b71632e30357eff", "patch": "@@ -108,17 +108,16 @@ impl Path {\n         }\n     }\n \n-    // Add starting \"crate root\" segment to all paths except those that\n-    // already have it or start with `self`, `super`, `Self` or `$crate`.\n-    pub fn default_to_global(mut self) -> Path {\n-        if !self.is_global() {\n-            let ident = self.segments[0].identifier;\n-            if !::parse::token::Ident(ident).is_path_segment_keyword() ||\n-               ident.name == keywords::Crate.name() {\n-                self.segments.insert(0, PathSegment::crate_root(self.span));\n+    // Make a \"crate root\" segment for this path unless it already has it\n+    // or starts with something like `self`/`super`/`$crate`/etc.\n+    pub fn make_root(&self) -> Option<PathSegment> {\n+        if let Some(ident) = self.segments.get(0).map(|seg| seg.identifier) {\n+            if ::parse::token::Ident(ident).is_path_segment_keyword() &&\n+               ident.name != keywords::Crate.name() {\n+                return None;\n             }\n         }\n-        self\n+        Some(PathSegment::crate_root(self.span.with_hi(self.span.lo())))\n     }\n \n     pub fn is_global(&self) -> bool {"}, {"sha": "ee646dc91743b8c09838b9a197c6ba4f16286b2f", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb13897d947e13a1322a055b71632e30357eff/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb13897d947e13a1322a055b71632e30357eff/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=e5fb13897d947e13a1322a055b71632e30357eff", "patch": "@@ -329,9 +329,13 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             None\n         };\n         segments.push(ast::PathSegment { identifier: last_identifier, span, parameters });\n-        let path = ast::Path { span, segments };\n-\n-        if global { path.default_to_global() } else { path }\n+        let mut path = ast::Path { span, segments };\n+        if global {\n+            if let Some(seg) = path.make_root() {\n+                path.segments.insert(0, seg);\n+            }\n+        }\n+        path\n     }\n \n     /// Constructs a qualified path."}, {"sha": "ca879765b4efcc5780baa8727aa31888fa9a1e02", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb13897d947e13a1322a055b71632e30357eff/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb13897d947e13a1322a055b71632e30357eff/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e5fb13897d947e13a1322a055b71632e30357eff", "patch": "@@ -5869,7 +5869,7 @@ impl<'a> Parser<'a> {\n                 // `pub(in path)`\n                 self.bump(); // `(`\n                 self.bump(); // `in`\n-                let path = self.parse_path(PathStyle::Mod)?.default_to_global(); // `path`\n+                let path = self.parse_path(PathStyle::Mod)?; // `path`\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n                 let vis = respan(lo.to(self.prev_span), VisibilityKind::Restricted {\n                     path: P(path),\n@@ -5882,7 +5882,7 @@ impl<'a> Parser<'a> {\n             {\n                 // `pub(self)` or `pub(super)`\n                 self.bump(); // `(`\n-                let path = self.parse_path(PathStyle::Mod)?.default_to_global(); // `super`/`self`\n+                let path = self.parse_path(PathStyle::Mod)?; // `super`/`self`\n                 self.expect(&token::CloseDelim(token::Paren))?; // `)`\n                 let vis = respan(lo.to(self.prev_span), VisibilityKind::Restricted {\n                     path: P(path),\n@@ -6480,7 +6480,7 @@ impl<'a> Parser<'a> {\n \n         if self.eat_keyword(keywords::Use) {\n             // USE ITEM\n-            let item_ = ItemKind::Use(P(self.parse_use_tree(false)?));\n+            let item_ = ItemKind::Use(P(self.parse_use_tree()?));\n             self.expect(&token::Semi)?;\n \n             let prev_span = self.prev_span;\n@@ -6984,7 +6984,7 @@ impl<'a> Parser<'a> {\n     ///            PATH `::` `*` |\n     ///            PATH `::` `{` USE_TREE_LIST `}` |\n     ///            PATH [`as` IDENT]\n-    fn parse_use_tree(&mut self, nested: bool) -> PResult<'a, UseTree> {\n+    fn parse_use_tree(&mut self) -> PResult<'a, UseTree> {\n         let lo = self.span;\n \n         let mut prefix = ast::Path {\n@@ -6998,8 +6998,6 @@ impl<'a> Parser<'a> {\n             // Remove the first `::`\n             if self.eat(&token::ModSep) {\n                 prefix.segments.push(PathSegment::crate_root(self.prev_span));\n-            } else if !nested {\n-                prefix.segments.push(PathSegment::crate_root(self.span));\n             }\n \n             if self.eat(&token::BinOp(token::Star)) {\n@@ -7014,9 +7012,6 @@ impl<'a> Parser<'a> {\n         } else {\n             // `use path::...;`\n             let mut parsed = self.parse_path(PathStyle::Mod)?;\n-            if !nested {\n-                parsed = parsed.default_to_global();\n-            }\n \n             prefix.segments.append(&mut parsed.segments);\n             prefix.span = prefix.span.to(parsed.span);\n@@ -7051,7 +7046,7 @@ impl<'a> Parser<'a> {\n         self.parse_unspanned_seq(&token::OpenDelim(token::Brace),\n                                  &token::CloseDelim(token::Brace),\n                                  SeqSep::trailing_allowed(token::Comma), |this| {\n-            Ok((this.parse_use_tree(true)?, ast::DUMMY_NODE_ID))\n+            Ok((this.parse_use_tree()?, ast::DUMMY_NODE_ID))\n         })\n     }\n "}, {"sha": "3c602f1d1a800c07b476ebb4c43d67c6577cccbf", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb13897d947e13a1322a055b71632e30357eff/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb13897d947e13a1322a055b71632e30357eff/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=e5fb13897d947e13a1322a055b71632e30357eff", "patch": "@@ -362,6 +362,7 @@ impl Token {\n                         id.name == keywords::SelfType.name() ||\n                         id.name == keywords::Extern.name() ||\n                         id.name == keywords::Crate.name() ||\n+                        id.name == keywords::CrateRoot.name() ||\n                         id.name == keywords::DollarCrate.name(),\n             None => false,\n         }"}, {"sha": "319a9a3bbaebccfea550f90ccd076fa1a560d714", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb13897d947e13a1322a055b71632e30357eff/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb13897d947e13a1322a055b71632e30357eff/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e5fb13897d947e13a1322a055b71632e30357eff", "patch": "@@ -353,7 +353,7 @@ pub fn fn_block_to_string(p: &ast::FnDecl) -> String {\n }\n \n pub fn path_to_string(p: &ast::Path) -> String {\n-    to_string(|s| s.print_path(p, false, 0, false))\n+    to_string(|s| s.print_path(p, false, 0))\n }\n \n pub fn path_segment_to_string(p: &ast::PathSegment) -> String {\n@@ -1051,7 +1051,7 @@ impl<'a> State<'a> {\n                                  &f.generic_params)?;\n             }\n             ast::TyKind::Path(None, ref path) => {\n-                self.print_path(path, false, 0, false)?;\n+                self.print_path(path, false, 0)?;\n             }\n             ast::TyKind::Path(Some(ref qself), ref path) => {\n                 self.print_qpath(path, qself, false)?\n@@ -1378,7 +1378,7 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n             }\n             ast::ItemKind::Mac(codemap::Spanned { ref node, .. }) => {\n-                self.print_path(&node.path, false, 0, false)?;\n+                self.print_path(&node.path, false, 0)?;\n                 self.s.word(\"! \")?;\n                 self.print_ident(item.ident)?;\n                 self.cbox(INDENT_UNIT)?;\n@@ -1403,7 +1403,7 @@ impl<'a> State<'a> {\n     }\n \n     fn print_trait_ref(&mut self, t: &ast::TraitRef) -> io::Result<()> {\n-        self.print_path(&t.path, false, 0, false)\n+        self.print_path(&t.path, false, 0)\n     }\n \n     fn print_formal_generic_params(\n@@ -1460,7 +1460,7 @@ impl<'a> State<'a> {\n                 ast::CrateSugar::JustCrate => self.word_nbsp(\"crate\")\n             }\n             ast::VisibilityKind::Restricted { ref path, .. } => {\n-                let path = to_string(|s| s.print_path(path, false, 0, true));\n+                let path = to_string(|s| s.print_path(path, false, 0));\n                 if path == \"self\" || path == \"super\" {\n                     self.word_nbsp(&format!(\"pub({})\", path))\n                 } else {\n@@ -1594,7 +1594,7 @@ impl<'a> State<'a> {\n             }\n             ast::TraitItemKind::Macro(codemap::Spanned { ref node, .. }) => {\n                 // code copied from ItemKind::Mac:\n-                self.print_path(&node.path, false, 0, false)?;\n+                self.print_path(&node.path, false, 0)?;\n                 self.s.word(\"! \")?;\n                 self.cbox(INDENT_UNIT)?;\n                 self.popen()?;\n@@ -1628,7 +1628,7 @@ impl<'a> State<'a> {\n             }\n             ast::ImplItemKind::Macro(codemap::Spanned { ref node, .. }) => {\n                 // code copied from ItemKind::Mac:\n-                self.print_path(&node.path, false, 0, false)?;\n+                self.print_path(&node.path, false, 0)?;\n                 self.s.word(\"! \")?;\n                 self.cbox(INDENT_UNIT)?;\n                 self.popen()?;\n@@ -1814,7 +1814,7 @@ impl<'a> State<'a> {\n \n     pub fn print_mac(&mut self, m: &ast::Mac, delim: token::DelimToken)\n                      -> io::Result<()> {\n-        self.print_path(&m.node.path, false, 0, false)?;\n+        self.print_path(&m.node.path, false, 0)?;\n         self.s.word(\"!\")?;\n         match delim {\n             token::Paren => self.popen()?,\n@@ -1915,7 +1915,7 @@ impl<'a> State<'a> {\n                          fields: &[ast::Field],\n                          wth: &Option<P<ast::Expr>>,\n                          attrs: &[Attribute]) -> io::Result<()> {\n-        self.print_path(path, true, 0, false)?;\n+        self.print_path(path, true, 0)?;\n         self.s.word(\"{\")?;\n         self.print_inner_attributes_inline(attrs)?;\n         self.commasep_cmnt(\n@@ -2236,7 +2236,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::ExprKind::Path(None, ref path) => {\n-                self.print_path(path, true, 0, false)?\n+                self.print_path(path, true, 0)?\n             }\n             ast::ExprKind::Path(Some(ref qself), ref path) => {\n                 self.print_qpath(path, qself, true)?\n@@ -2396,17 +2396,12 @@ impl<'a> State<'a> {\n     fn print_path(&mut self,\n                   path: &ast::Path,\n                   colons_before_params: bool,\n-                  depth: usize,\n-                  defaults_to_global: bool)\n+                  depth: usize)\n                   -> io::Result<()>\n     {\n         self.maybe_print_comment(path.span.lo())?;\n \n-        let mut segments = path.segments[..path.segments.len()-depth].iter();\n-        if defaults_to_global && path.is_global() {\n-            segments.next();\n-        }\n-        for (i, segment) in segments.enumerate() {\n+        for (i, segment) in path.segments[..path.segments.len() - depth].iter().enumerate() {\n             if i > 0 {\n                 self.s.word(\"::\")?\n             }\n@@ -2445,7 +2440,7 @@ impl<'a> State<'a> {\n             self.s.space()?;\n             self.word_space(\"as\")?;\n             let depth = path.segments.len() - qself.position;\n-            self.print_path(path, false, depth, false)?;\n+            self.print_path(path, false, depth)?;\n         }\n         self.s.word(\">\")?;\n         self.s.word(\"::\")?;\n@@ -2548,7 +2543,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             PatKind::TupleStruct(ref path, ref elts, ddpos) => {\n-                self.print_path(path, true, 0, false)?;\n+                self.print_path(path, true, 0)?;\n                 self.popen()?;\n                 if let Some(ddpos) = ddpos {\n                     self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(p))?;\n@@ -2566,13 +2561,13 @@ impl<'a> State<'a> {\n                 self.pclose()?;\n             }\n             PatKind::Path(None, ref path) => {\n-                self.print_path(path, true, 0, false)?;\n+                self.print_path(path, true, 0)?;\n             }\n             PatKind::Path(Some(ref qself), ref path) => {\n                 self.print_qpath(path, qself, false)?;\n             }\n             PatKind::Struct(ref path, ref fields, etc) => {\n-                self.print_path(path, true, 0, false)?;\n+                self.print_path(path, true, 0)?;\n                 self.nbsp()?;\n                 self.word_space(\"{\")?;\n                 self.commasep_cmnt(\n@@ -2950,7 +2945,7 @@ impl<'a> State<'a> {\n     pub fn print_use_tree(&mut self, tree: &ast::UseTree) -> io::Result<()> {\n         match tree.kind {\n             ast::UseTreeKind::Simple(rename) => {\n-                self.print_path(&tree.prefix, false, 0, true)?;\n+                self.print_path(&tree.prefix, false, 0)?;\n                 if let Some(rename) = rename {\n                     self.s.space()?;\n                     self.word_space(\"as\")?;\n@@ -2959,7 +2954,7 @@ impl<'a> State<'a> {\n             }\n             ast::UseTreeKind::Glob => {\n                 if !tree.prefix.segments.is_empty() {\n-                    self.print_path(&tree.prefix, false, 0, true)?;\n+                    self.print_path(&tree.prefix, false, 0)?;\n                     self.s.word(\"::\")?;\n                 }\n                 self.s.word(\"*\")?;\n@@ -2968,7 +2963,7 @@ impl<'a> State<'a> {\n                 if tree.prefix.segments.is_empty() {\n                     self.s.word(\"{\")?;\n                 } else {\n-                    self.print_path(&tree.prefix, false, 0, true)?;\n+                    self.print_path(&tree.prefix, false, 0)?;\n                     self.s.word(\"::{\")?;\n                 }\n                 self.commasep(Inconsistent, &items[..], |this, &(ref tree, _)| {"}, {"sha": "401183e7c7d5e17d14db4b3d7b61b3412636d2e2", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5fb13897d947e13a1322a055b71632e30357eff/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5fb13897d947e13a1322a055b71632e30357eff/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=e5fb13897d947e13a1322a055b71632e30357eff", "patch": "@@ -79,7 +79,7 @@ pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<&str>\n         vis: respan(span.empty(), ast::VisibilityKind::Inherited),\n         node: ast::ItemKind::Use(P(ast::UseTree {\n             prefix: ast::Path {\n-                segments: [\"{{root}}\", name, \"prelude\", \"v1\"].into_iter().map(|name| {\n+                segments: [name, \"prelude\", \"v1\"].into_iter().map(|name| {\n                     ast::PathSegment::from_ident(ast::Ident::from_str(name), DUMMY_SP)\n                 }).collect(),\n                 span,"}]}