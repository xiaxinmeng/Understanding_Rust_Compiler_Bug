{"sha": "18061e85b79915deb9f04c78aac7b63b837432dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MDYxZTg1Yjc5OTE1ZGViOWYwNGM3OGFhYzdiNjNiODM3NDMyZGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-19T21:11:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-19T21:11:37Z"}, "message": "auto merge of #11642 : erickt/rust/path, r=huonw\n\nThis pull request exposes a platform independent way to get the path separator. This is useful when building complicated paths by hand.", "tree": {"sha": "b12afd62219730e9b529bdb6ed86250acc52ef4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b12afd62219730e9b529bdb6ed86250acc52ef4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18061e85b79915deb9f04c78aac7b63b837432dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18061e85b79915deb9f04c78aac7b63b837432dd", "html_url": "https://github.com/rust-lang/rust/commit/18061e85b79915deb9f04c78aac7b63b837432dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18061e85b79915deb9f04c78aac7b63b837432dd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5512fb49a038ca3827e33d8ddf41f6901f11c2f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5512fb49a038ca3827e33d8ddf41f6901f11c2f5", "html_url": "https://github.com/rust-lang/rust/commit/5512fb49a038ca3827e33d8ddf41f6901f11c2f5"}, {"sha": "f13086f4571e13f712b9606fddbee47f40c40842", "url": "https://api.github.com/repos/rust-lang/rust/commits/f13086f4571e13f712b9606fddbee47f40c40842", "html_url": "https://github.com/rust-lang/rust/commit/f13086f4571e13f712b9606fddbee47f40c40842"}], "stats": {"total": 103, "additions": 62, "deletions": 41}, "files": [{"sha": "253d99c11ebac4e3274266c0c7293008aae45e43", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/18061e85b79915deb9f04c78aac7b63b837432dd/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18061e85b79915deb9f04c78aac7b63b837432dd/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=18061e85b79915deb9f04c78aac7b63b837432dd", "patch": "@@ -117,6 +117,20 @@ pub use StrComponents = self::windows::StrComponents;\n #[cfg(windows)]\n pub use RevStrComponents = self::windows::RevStrComponents;\n \n+/// Alias for the platform-native separator character.\n+#[cfg(unix)]\n+pub use SEP = self::posix::SEP;\n+/// Alias for the platform-native separator byte.\n+#[cfg(windows)]\n+pub use SEP = self::windows::SEP;\n+\n+/// Alias for the platform-native separator character.\n+#[cfg(unix)]\n+pub use SEP_BYTE = self::posix::SEP_BYTE;\n+/// Alias for the platform-native separator byte.\n+#[cfg(windows)]\n+pub use SEP_BYTE = self::windows::SEP_BYTE;\n+\n /// Typedef for the platform-native separator char func\n #[cfg(unix)]\n pub use is_sep = self::posix::is_sep;"}, {"sha": "b228dc7f1ffbd372ced3f015b908eb8b58d5d9a5", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/18061e85b79915deb9f04c78aac7b63b837432dd/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18061e85b79915deb9f04c78aac7b63b837432dd/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=18061e85b79915deb9f04c78aac7b63b837432dd", "patch": "@@ -45,19 +45,21 @@ pub struct Path {\n }\n \n /// The standard path separator character\n-pub static sep: char = '/';\n-static sep_byte: u8 = sep as u8;\n+pub static SEP: char = '/';\n+\n+/// The standard path separator byte\n+pub static SEP_BYTE: u8 = SEP as u8;\n \n /// Returns whether the given byte is a path separator\n #[inline]\n pub fn is_sep_byte(u: &u8) -> bool {\n-    *u as char == sep\n+    *u as char == SEP\n }\n \n /// Returns whether the given char is a path separator\n #[inline]\n pub fn is_sep(c: char) -> bool {\n-    c == sep\n+    c == SEP\n }\n \n impl Eq for Path {\n@@ -115,7 +117,7 @@ impl GenericPathUnsafe for Path {\n     unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Path {\n         let path = Path::normalize(path.container_as_bytes());\n         assert!(!path.is_empty());\n-        let idx = path.rposition_elem(&sep_byte);\n+        let idx = path.rposition_elem(&SEP_BYTE);\n         Path{ repr: path, sepidx: idx }\n     }\n \n@@ -125,7 +127,7 @@ impl GenericPathUnsafe for Path {\n             None if bytes!(\"..\") == self.repr => {\n                 let mut v = vec::with_capacity(3 + filename.len());\n                 v.push_all(dot_dot_static);\n-                v.push(sep_byte);\n+                v.push(SEP_BYTE);\n                 v.push_all(filename);\n                 self.repr = Path::normalize(v);\n             }\n@@ -135,7 +137,7 @@ impl GenericPathUnsafe for Path {\n             Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => {\n                 let mut v = vec::with_capacity(self.repr.len() + 1 + filename.len());\n                 v.push_all(self.repr);\n-                v.push(sep_byte);\n+                v.push(SEP_BYTE);\n                 v.push_all(filename);\n                 self.repr = Path::normalize(v);\n             }\n@@ -146,22 +148,22 @@ impl GenericPathUnsafe for Path {\n                 self.repr = Path::normalize(v);\n             }\n         }\n-        self.sepidx = self.repr.rposition_elem(&sep_byte);\n+        self.sepidx = self.repr.rposition_elem(&SEP_BYTE);\n     }\n \n     unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T) {\n         let path = path.container_as_bytes();\n         if !path.is_empty() {\n-            if path[0] == sep_byte {\n+            if path[0] == SEP_BYTE {\n                 self.repr = Path::normalize(path);\n             }  else {\n                 let mut v = vec::with_capacity(self.repr.len() + path.len() + 1);\n                 v.push_all(self.repr);\n-                v.push(sep_byte);\n+                v.push(SEP_BYTE);\n                 v.push_all(path);\n                 self.repr = Path::normalize(v);\n             }\n-            self.sepidx = self.repr.rposition_elem(&sep_byte);\n+            self.sepidx = self.repr.rposition_elem(&SEP_BYTE);\n         }\n     }\n }\n@@ -211,7 +213,7 @@ impl GenericPath for Path {\n                 } else {\n                     self.repr.truncate(idx);\n                 }\n-                self.sepidx = self.repr.rposition_elem(&sep_byte);\n+                self.sepidx = self.repr.rposition_elem(&SEP_BYTE);\n                 true\n             }\n         }\n@@ -227,7 +229,7 @@ impl GenericPath for Path {\n \n     #[inline]\n     fn is_absolute(&self) -> bool {\n-        self.repr[0] == sep_byte\n+        self.repr[0] == SEP_BYTE\n     }\n \n     fn is_ancestor_of(&self, other: &Path) -> bool {\n@@ -291,7 +293,7 @@ impl GenericPath for Path {\n                     }\n                 }\n             }\n-            Some(Path::new(comps.connect_vec(&sep_byte)))\n+            Some(Path::new(comps.connect_vec(&SEP_BYTE)))\n         }\n     }\n \n@@ -333,14 +335,14 @@ impl Path {\n     fn normalize<V: Vector<u8>+CopyableVector<u8>>(v: V) -> ~[u8] {\n         // borrowck is being very picky\n         let val = {\n-            let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == sep_byte;\n+            let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == SEP_BYTE;\n             let v_ = if is_abs { v.as_slice().slice_from(1) } else { v.as_slice() };\n             let comps = normalize_helper(v_, is_abs);\n             match comps {\n                 None => None,\n                 Some(comps) => {\n                     if is_abs && comps.is_empty() {\n-                        Some(~[sep_byte])\n+                        Some(~[SEP_BYTE])\n                     } else {\n                         let n = if is_abs { comps.len() } else { comps.len() - 1} +\n                                 comps.iter().map(|v| v.len()).sum();\n@@ -353,7 +355,7 @@ impl Path {\n                             }\n                         }\n                         for comp in it {\n-                            v.push(sep_byte);\n+                            v.push(SEP_BYTE);\n                             v.push_all(comp);\n                         }\n                         Some(v)\n@@ -372,7 +374,7 @@ impl Path {\n     /// /a/b/c and a/b/c yield the same set of components.\n     /// A path of \"/\" yields no components. A path of \".\" yields one component.\n     pub fn components<'a>(&'a self) -> Components<'a> {\n-        let v = if self.repr[0] == sep_byte {\n+        let v = if self.repr[0] == SEP_BYTE {\n             self.repr.slice_from(1)\n         } else { self.repr.as_slice() };\n         let mut ret = v.split(is_sep_byte);\n@@ -386,7 +388,7 @@ impl Path {\n     /// Returns an iterator that yields each component of the path in reverse.\n     /// See components() for details.\n     pub fn rev_components<'a>(&'a self) -> RevComponents<'a> {\n-        let v = if self.repr[0] == sep_byte {\n+        let v = if self.repr[0] == SEP_BYTE {\n             self.repr.slice_from(1)\n         } else { self.repr.as_slice() };\n         let mut ret = v.rsplit(is_sep_byte);"}, {"sha": "86a9d2235d05fa0bc7cda8d14e8871e8760838f7", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/18061e85b79915deb9f04c78aac7b63b837432dd/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18061e85b79915deb9f04c78aac7b63b837432dd/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=18061e85b79915deb9f04c78aac7b63b837432dd", "patch": "@@ -183,7 +183,7 @@ impl GenericPathUnsafe for Path {\n             None if \"..\" == self.repr => {\n                 let mut s = str::with_capacity(3 + filename.len());\n                 s.push_str(\"..\");\n-                s.push_char(sep);\n+                s.push_char(SEP);\n                 s.push_str(filename);\n                 self.update_normalized(s);\n             }\n@@ -193,7 +193,7 @@ impl GenericPathUnsafe for Path {\n             Some((_,idxa,end)) if self.repr.slice(idxa,end) == \"..\" => {\n                 let mut s = str::with_capacity(end + 1 + filename.len());\n                 s.push_str(self.repr.slice_to(end));\n-                s.push_char(sep);\n+                s.push_char(SEP);\n                 s.push_str(filename);\n                 self.update_normalized(s);\n             }\n@@ -206,7 +206,7 @@ impl GenericPathUnsafe for Path {\n             Some((idxb,_,_)) => {\n                 let mut s = str::with_capacity(idxb + 1 + filename.len());\n                 s.push_str(self.repr.slice_to(idxb));\n-                s.push_char(sep);\n+                s.push_char(SEP);\n                 s.push_str(filename);\n                 self.update_normalized(s);\n             }\n@@ -264,8 +264,8 @@ impl GenericPathUnsafe for Path {\n             // if me is \"C:\" we don't want to add a path separator\n             match me.prefix {\n                 Some(DiskPrefix) if me.repr.len() == plen => (),\n-                _ if !(me.repr.len() > plen && me.repr[me.repr.len()-1] == sep as u8) => {\n-                    s.push_char(sep);\n+                _ if !(me.repr.len() > plen && me.repr[me.repr.len()-1] == SEP_BYTE) => {\n+                    s.push_char(SEP);\n                 }\n                 _ => ()\n             }\n@@ -460,7 +460,7 @@ impl GenericPath for Path {\n         match self.prefix {\n             Some(DiskPrefix) => {\n                 let rest = self.repr.slice_from(self.prefix_len());\n-                rest.len() > 0 && rest[0] == sep as u8\n+                rest.len() > 0 && rest[0] == SEP_BYTE\n             }\n             Some(_) => true,\n             None => false\n@@ -501,7 +501,7 @@ impl GenericPath for Path {\n \n     fn path_relative_from(&self, base: &Path) -> Option<Path> {\n         fn comp_requires_verbatim(s: &str) -> bool {\n-            s == \".\" || s == \"..\" || s.contains_char(sep2)\n+            s == \".\" || s == \"..\" || s.contains_char(SEP2)\n         }\n \n         if !self.equiv_prefix(base) {\n@@ -619,14 +619,14 @@ impl Path {\n         let s = match self.prefix {\n             Some(_) => {\n                 let plen = self.prefix_len();\n-                if self.repr.len() > plen && self.repr[plen] == sep as u8 {\n+                if self.repr.len() > plen && self.repr[plen] == SEP_BYTE {\n                     self.repr.slice_from(plen+1)\n                 } else { self.repr.slice_from(plen) }\n             }\n-            None if self.repr[0] == sep as u8 => self.repr.slice_from(1),\n+            None if self.repr[0] == SEP_BYTE => self.repr.slice_from(1),\n             None => self.repr.as_slice()\n         };\n-        let ret = s.split_terminator(sep).map(Some);\n+        let ret = s.split_terminator(SEP).map(Some);\n         ret\n     }\n \n@@ -703,7 +703,7 @@ impl Path {\n                 Some(VerbatimUNCPrefix(x, 0)) if s.len() == 8 + x => {\n                     // the server component has no trailing '\\'\n                     let mut s = s.into_owned();\n-                    s.push_char(sep);\n+                    s.push_char(SEP);\n                     Some(s)\n                 }\n                 _ => None\n@@ -739,7 +739,7 @@ impl Path {\n                                 if is_abs {\n                                     // normalize C:/ to C:\\\n                                     unsafe {\n-                                        str::raw::as_owned_vec(&mut s)[2] = sep as u8;\n+                                        str::raw::as_owned_vec(&mut s)[2] = SEP_BYTE;\n                                     }\n                                 }\n                                 Some(s)\n@@ -761,7 +761,7 @@ impl Path {\n                             }\n                         }\n                     } else if is_abs && comps.is_empty() {\n-                        Some(str::from_char(sep))\n+                        Some(str::from_char(SEP))\n                     } else {\n                         let prefix_ = s.slice_to(prefix_len(prefix));\n                         let n = prefix_.len() +\n@@ -781,7 +781,7 @@ impl Path {\n                             Some(UNCPrefix(a,b)) => {\n                                 s.push_str(\"\\\\\\\\\");\n                                 s.push_str(prefix_.slice(2, a+2));\n-                                s.push_char(sep);\n+                                s.push_char(SEP);\n                                 s.push_str(prefix_.slice(3+a, 3+a+b));\n                             }\n                             Some(_) => s.push_str(prefix_),\n@@ -795,7 +795,7 @@ impl Path {\n                             }\n                         }\n                         for comp in it {\n-                            s.push_char(sep);\n+                            s.push_char(SEP);\n                             s.push_str(comp);\n                         }\n                         Some(s)\n@@ -837,7 +837,7 @@ impl Path {\n \n     fn has_nonsemantic_trailing_slash(&self) -> bool {\n         is_verbatim(self) && self.repr.len() > self.prefix_len()+1 &&\n-            self.repr[self.repr.len()-1] == sep as u8\n+            self.repr[self.repr.len()-1] == SEP_BYTE\n     }\n \n     fn update_normalized<S: Str>(&mut self, s: S) {\n@@ -877,36 +877,41 @@ pub fn is_verbatim(path: &Path) -> bool {\n }\n \n /// The standard path separator character\n-pub static sep: char = '\\\\';\n+pub static SEP: char = '\\\\';\n+/// The standard path separator byte\n+pub static SEP_BYTE: u8 = SEP as u8;\n+\n+/// The alternative path separator character\n+pub static SEP2: char = '/';\n /// The alternative path separator character\n-pub static sep2: char = '/';\n+pub static SEP2_BYTE: u8 = SEP2 as u8;\n \n /// Returns whether the given char is a path separator.\n /// Allows both the primary separator '\\' and the alternative separator '/'.\n #[inline]\n pub fn is_sep(c: char) -> bool {\n-    c == sep || c == sep2\n+    c == SEP || c == SEP2\n }\n \n /// Returns whether the given char is a path separator.\n /// Only allows the primary separator '\\'; use is_sep to allow '/'.\n #[inline]\n pub fn is_sep_verbatim(c: char) -> bool {\n-    c == sep\n+    c == SEP\n }\n \n /// Returns whether the given byte is a path separator.\n /// Allows both the primary separator '\\' and the alternative separator '/'.\n #[inline]\n pub fn is_sep_byte(u: &u8) -> bool {\n-    *u as char == sep || *u as char == sep2\n+    *u == SEP_BYTE || *u == SEP2_BYTE\n }\n \n /// Returns whether the given byte is a path separator.\n /// Only allows the primary separator '\\'; use is_sep_byte to allow '/'.\n #[inline]\n pub fn is_sep_byte_verbatim(u: &u8) -> bool {\n-    *u as char == sep\n+    *u == SEP_BYTE\n }\n \n /// Prefix types for Path"}]}