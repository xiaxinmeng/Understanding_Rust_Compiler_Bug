{"sha": "b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "node_id": "C_kwDOAAsO6NoAKGI3YjlhZTU5YTA4MWYwZWNiZDExZDY2ZTIwNTMwNzMyOGNkNWNmYmU", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-08T17:28:52Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-17T09:38:35Z"}, "message": "desugar `? operator`", "tree": {"sha": "6adf3619a2404d822d68621f0a6b03134d611dfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6adf3619a2404d822d68621f0a6b03134d611dfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "html_url": "https://github.com/rust-lang/rust/commit/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "924d277f32b53219fcaa03226c17b485a081ed16", "url": "https://api.github.com/repos/rust-lang/rust/commits/924d277f32b53219fcaa03226c17b485a081ed16", "html_url": "https://github.com/rust-lang/rust/commit/924d277f32b53219fcaa03226c17b485a081ed16"}], "stats": {"total": 708, "additions": 517, "deletions": 191}, "files": [{"sha": "7f9b9476dcd9110dcaac418f99653b2e617e8f8a", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -391,7 +391,7 @@ impl Body {\n             }\n         };\n         let expander = Expander::new(db, file_id, module);\n-        let (mut body, source_map) = Body::new(db, expander, params, body);\n+        let (mut body, source_map) = Body::new(db, expander, params, body, module.krate);\n         body.shrink_to_fit();\n \n         (Arc::new(body), Arc::new(source_map))\n@@ -420,8 +420,9 @@ impl Body {\n         expander: Expander,\n         params: Option<(ast::ParamList, impl Iterator<Item = bool>)>,\n         body: Option<ast::Expr>,\n+        krate: CrateId,\n     ) -> (Body, BodySourceMap) {\n-        lower::lower(db, expander, params, body)\n+        lower::lower(db, expander, params, body, krate)\n     }\n \n     fn shrink_to_fit(&mut self) {"}, {"sha": "348b7589ff4f402d695fff79443fa46e48f39ab3", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 87, "deletions": 6, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -3,6 +3,7 @@\n \n use std::{mem, sync::Arc};\n \n+use base_db::CrateId;\n use either::Either;\n use hir_expand::{\n     ast_id_map::AstIdMap,\n@@ -36,6 +37,7 @@ use crate::{\n         RecordFieldPat, RecordLitField, Statement,\n     },\n     item_scope::BuiltinShadowMode,\n+    lang_item::LangItem,\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n     AdtId, BlockId, BlockLoc, ModuleDefId, UnresolvedMacro,\n@@ -80,9 +82,11 @@ pub(super) fn lower(\n     expander: Expander,\n     params: Option<(ast::ParamList, impl Iterator<Item = bool>)>,\n     body: Option<ast::Expr>,\n+    krate: CrateId,\n ) -> (Body, BodySourceMap) {\n     ExprCollector {\n         db,\n+        krate,\n         source_map: BodySourceMap::default(),\n         ast_id_map: db.ast_id_map(expander.current_file_id),\n         body: Body {\n@@ -107,6 +111,7 @@ struct ExprCollector<'a> {\n     expander: Expander,\n     ast_id_map: Arc<AstIdMap>,\n     body: Body,\n+    krate: CrateId,\n     source_map: BodySourceMap,\n     is_lowering_assignee_expr: bool,\n     is_lowering_generator: bool,\n@@ -176,8 +181,7 @@ impl ExprCollector<'_> {\n         self.source_map.expr_map.insert(src, id);\n         id\n     }\n-    // desugared exprs don't have ptr, that's wrong and should be fixed\n-    // somehow.\n+    // FIXME: desugared exprs don't have ptr, that's wrong and should be fixed somehow.\n     fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {\n         self.body.exprs.alloc(expr)\n     }\n@@ -199,6 +203,10 @@ impl ExprCollector<'_> {\n         self.source_map.pat_map.insert(src, id);\n         id\n     }\n+    // FIXME: desugared pats don't have ptr, that's wrong and should be fixed somehow.\n+    fn alloc_pat_desugared(&mut self, pat: Pat) -> PatId {\n+        self.body.pats.alloc(pat)\n+    }\n     fn missing_pat(&mut self) -> PatId {\n         self.body.pats.alloc(Pat::Missing)\n     }\n@@ -437,10 +445,7 @@ impl ExprCollector<'_> {\n                 let expr = self.collect_expr_opt(e.expr());\n                 self.alloc_expr(Expr::Await { expr }, syntax_ptr)\n             }\n-            ast::Expr::TryExpr(e) => {\n-                let expr = self.collect_expr_opt(e.expr());\n-                self.alloc_expr(Expr::Try { expr }, syntax_ptr)\n-            }\n+            ast::Expr::TryExpr(e) => self.collect_try_operator(syntax_ptr, e),\n             ast::Expr::CastExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let type_ref = Interned::new(TypeRef::from_ast_opt(&self.ctx(), e.ty()));\n@@ -601,6 +606,82 @@ impl ExprCollector<'_> {\n         })\n     }\n \n+    fn collect_try_operator(&mut self, syntax_ptr: AstPtr<ast::Expr>, e: ast::TryExpr) -> ExprId {\n+        let (try_branch, cf_continue, cf_break, try_from_residual) = 'if_chain: {\n+            if let Some(try_branch) = LangItem::TryTraitBranch.path(self.db, self.krate) {\n+                if let Some(cf_continue) =\n+                    LangItem::ControlFlowContinue.path(self.db, self.krate)\n+                {\n+                    if let Some(cf_break) =\n+                        LangItem::ControlFlowBreak.path(self.db, self.krate)\n+                    {\n+                        if let Some(try_from_residual) =\n+                            LangItem::TryTraitFromResidual.path(self.db, self.krate)\n+                        {\n+                            break 'if_chain (\n+                                try_branch,\n+                                cf_continue,\n+                                cf_break,\n+                                try_from_residual,\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+            // Some of the needed lang items are missing, so we can't desugar\n+            return self.alloc_expr(Expr::Missing, syntax_ptr);\n+        };\n+        let operand = self.collect_expr_opt(e.expr());\n+        let try_branch = self.alloc_expr(Expr::Path(try_branch), syntax_ptr.clone());\n+        let expr = self.alloc_expr(\n+            Expr::Call {\n+                callee: try_branch,\n+                args: Box::new([operand]),\n+                is_assignee_expr: false,\n+            },\n+            syntax_ptr.clone(),\n+        );\n+        let continue_binding =\n+            self.alloc_binding(name![v1], BindingAnnotation::Unannotated);\n+        let continue_bpat =\n+            self.alloc_pat_desugared(Pat::Bind { id: continue_binding, subpat: None });\n+        self.add_definition_to_binding(continue_binding, continue_bpat);\n+        let continue_arm = MatchArm {\n+            pat: self.alloc_pat_desugared(Pat::TupleStruct {\n+                path: Some(Box::new(cf_continue)),\n+                args: Box::new([continue_bpat]),\n+                ellipsis: None,\n+            }),\n+            guard: None,\n+            expr: self.alloc_expr(Expr::Path(Path::from(name![v1])), syntax_ptr.clone()),\n+        };\n+        let break_binding = self.alloc_binding(name![v1], BindingAnnotation::Unannotated);\n+        let break_bpat =\n+            self.alloc_pat_desugared(Pat::Bind { id: break_binding, subpat: None });\n+        self.add_definition_to_binding(break_binding, break_bpat);\n+        let break_arm = MatchArm {\n+            pat: self.alloc_pat_desugared(Pat::TupleStruct {\n+                path: Some(Box::new(cf_break)),\n+                args: Box::new([break_bpat]),\n+                ellipsis: None,\n+            }),\n+            guard: None,\n+            expr: {\n+                let x =\n+                    self.alloc_expr(Expr::Path(Path::from(name![v1])), syntax_ptr.clone());\n+                let callee =\n+                    self.alloc_expr(Expr::Path(try_from_residual), syntax_ptr.clone());\n+                let result = self.alloc_expr(\n+                    Expr::Call { callee, args: Box::new([x]), is_assignee_expr: false },\n+                    syntax_ptr.clone(),\n+                );\n+                self.alloc_expr(Expr::Return { expr: Some(result) }, syntax_ptr.clone())\n+            },\n+        };\n+        let arms = Box::new([continue_arm, break_arm]);\n+        self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)\n+    }\n+\n     fn collect_macro_call<F, T, U>(\n         &mut self,\n         mcall: ast::MacroCall,"}, {"sha": "c091ad0d150f60f4b8132c2ed08a1029cb6faee6", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -288,10 +288,6 @@ impl<'a> Printer<'a> {\n                 self.print_expr(*expr);\n                 w!(self, \".await\");\n             }\n-            Expr::Try { expr } => {\n-                self.print_expr(*expr);\n-                w!(self, \"?\");\n-            }\n             Expr::Cast { expr, type_ref } => {\n                 self.print_expr(*expr);\n                 w!(self, \" as \");"}, {"sha": "5b8758224371b358799f689b8cfa63d7a2e1e316", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -192,9 +192,6 @@ pub enum Expr {\n     Await {\n         expr: ExprId,\n     },\n-    Try {\n-        expr: ExprId,\n-    },\n     Cast {\n         expr: ExprId,\n         type_ref: Interned<TypeRef>,\n@@ -383,7 +380,6 @@ impl Expr {\n             }\n             Expr::Field { expr, .. }\n             | Expr::Await { expr }\n-            | Expr::Try { expr }\n             | Expr::Cast { expr, .. }\n             | Expr::Ref { expr, .. }\n             | Expr::UnaryOp { expr, .. }"}, {"sha": "818054188bea32828e05f0fef2e910313820c381", "filename": "crates/hir-def/src/lang_item.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-def%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-def%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flang_item.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -8,8 +8,8 @@ use rustc_hash::FxHashMap;\n use syntax::SmolStr;\n \n use crate::{\n-    db::DefDatabase, AdtId, AssocItemId, AttrDefId, CrateId, EnumId, EnumVariantId, FunctionId,\n-    ImplId, ModuleDefId, StaticId, StructId, TraitId, TypeAliasId, UnionId,\n+    db::DefDatabase, path::Path, AdtId, AssocItemId, AttrDefId, CrateId, EnumId, EnumVariantId,\n+    FunctionId, ImplId, ModuleDefId, StaticId, StructId, TraitId, TypeAliasId, UnionId,\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -220,11 +220,6 @@ macro_rules! language_item_table {\n                 }\n             }\n \n-            /// Opposite of [`LangItem::name`]\n-            pub fn from_name(name: &hir_expand::name::Name) -> Option<Self> {\n-                Self::from_str(name.as_str()?)\n-            }\n-\n             /// Opposite of [`LangItem::name`]\n             pub fn from_str(name: &str) -> Option<Self> {\n                 match name {\n@@ -236,6 +231,18 @@ macro_rules! language_item_table {\n     }\n }\n \n+impl LangItem {\n+    /// Opposite of [`LangItem::name`]\n+    pub fn from_name(name: &hir_expand::name::Name) -> Option<Self> {\n+        Self::from_str(name.as_str()?)\n+    }\n+\n+    pub fn path(&self, db: &dyn DefDatabase, start_crate: CrateId) -> Option<Path> {\n+        let t = db.lang_item(start_crate, *self)?;\n+        Some(Path::LangItem(t))\n+    }\n+}\n+\n language_item_table! {\n //  Variant name,            Name,                     Getter method name,         Target                  Generic requirements;\n     Sized,                   sized,               sized_trait,                Target::Trait,          GenericRequirement::Exact(0);"}, {"sha": "c67c29818f5b14c6eeb04a6297b2368d5159c960", "filename": "crates/hir-def/src/path.rs", "status": "modified", "additions": 58, "deletions": 25, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpath.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -8,6 +8,7 @@ use std::{\n \n use crate::{\n     body::LowerCtx,\n+    lang_item::LangItemTarget,\n     type_ref::{ConstRefOrPath, LifetimeRef},\n };\n use hir_expand::name::Name;\n@@ -36,13 +37,19 @@ impl Display for ImportAlias {\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Path {\n-    /// Type based path like `<T>::foo`.\n-    /// Note that paths like `<Type as Trait>::foo` are desugared to `Trait::<Self=Type>::foo`.\n-    type_anchor: Option<Interned<TypeRef>>,\n-    mod_path: Interned<ModPath>,\n-    /// Invariant: the same len as `self.mod_path.segments` or `None` if all segments are `None`.\n-    generic_args: Option<Box<[Option<Interned<GenericArgs>>]>>,\n+pub enum Path {\n+    /// A normal path\n+    Normal {\n+        /// Type based path like `<T>::foo`.\n+        /// Note that paths like `<Type as Trait>::foo` are desugared to `Trait::<Self=Type>::foo`.\n+        type_anchor: Option<Interned<TypeRef>>,\n+        mod_path: Interned<ModPath>,\n+        /// Invariant: the same len as `self.mod_path.segments` or `None` if all segments are `None`.\n+        generic_args: Option<Box<[Option<Interned<GenericArgs>>]>>,\n+    },\n+    /// A link to a lang item. It is used in desugaring of things like `x?`. We can show these\n+    /// links via a normal path since they might be private and not accessible in the usage place.\n+    LangItem(LangItemTarget),\n }\n \n /// Generic arguments to a path segment (e.g. the `i32` in `Option<i32>`). This\n@@ -102,51 +109,77 @@ impl Path {\n     ) -> Path {\n         let generic_args = generic_args.into();\n         assert_eq!(path.len(), generic_args.len());\n-        Path { type_anchor: None, mod_path: Interned::new(path), generic_args: Some(generic_args) }\n+        Path::Normal {\n+            type_anchor: None,\n+            mod_path: Interned::new(path),\n+            generic_args: Some(generic_args),\n+        }\n+    }\n+\n+    /// Converts a known mod path to `Path`.\n+    pub fn from_known_path_with_no_generic(path: ModPath) -> Path {\n+        Path::Normal { type_anchor: None, mod_path: Interned::new(path), generic_args: None }\n     }\n \n     pub fn kind(&self) -> &PathKind {\n-        &self.mod_path.kind\n+        match self {\n+            Path::Normal { mod_path, .. } => &mod_path.kind,\n+            Path::LangItem(_) => &PathKind::Abs,\n+        }\n     }\n \n     pub fn type_anchor(&self) -> Option<&TypeRef> {\n-        self.type_anchor.as_deref()\n+        match self {\n+            Path::Normal { type_anchor, .. } => type_anchor.as_deref(),\n+            Path::LangItem(_) => None,\n+        }\n     }\n \n     pub fn segments(&self) -> PathSegments<'_> {\n-        let s = PathSegments {\n-            segments: self.mod_path.segments(),\n-            generic_args: self.generic_args.as_deref(),\n+        let Path::Normal { mod_path, generic_args, .. } = self else {\n+            return PathSegments {\n+                segments: &[],\n+                generic_args: None,\n+            };\n         };\n+        let s =\n+            PathSegments { segments: mod_path.segments(), generic_args: generic_args.as_deref() };\n         if let Some(generic_args) = s.generic_args {\n             assert_eq!(s.segments.len(), generic_args.len());\n         }\n         s\n     }\n \n-    pub fn mod_path(&self) -> &ModPath {\n-        &self.mod_path\n+    pub fn mod_path(&self) -> Option<&ModPath> {\n+        match self {\n+            Path::Normal { mod_path, .. } => Some(&mod_path),\n+            Path::LangItem(_) => None,\n+        }\n     }\n \n     pub fn qualifier(&self) -> Option<Path> {\n-        if self.mod_path.is_ident() {\n+        let Path::Normal { mod_path, generic_args, type_anchor } = self else {\n+            return None;\n+        };\n+        if mod_path.is_ident() {\n             return None;\n         }\n-        let res = Path {\n-            type_anchor: self.type_anchor.clone(),\n+        let res = Path::Normal {\n+            type_anchor: type_anchor.clone(),\n             mod_path: Interned::new(ModPath::from_segments(\n-                self.mod_path.kind,\n-                self.mod_path.segments()[..self.mod_path.segments().len() - 1].iter().cloned(),\n+                mod_path.kind,\n+                mod_path.segments()[..mod_path.segments().len() - 1].iter().cloned(),\n             )),\n-            generic_args: self.generic_args.as_ref().map(|it| it[..it.len() - 1].to_vec().into()),\n+            generic_args: generic_args.as_ref().map(|it| it[..it.len() - 1].to_vec().into()),\n         };\n         Some(res)\n     }\n \n     pub fn is_self_type(&self) -> bool {\n-        self.type_anchor.is_none()\n-            && self.generic_args.as_deref().is_none()\n-            && self.mod_path.is_Self()\n+        let Path::Normal { mod_path, generic_args, type_anchor } = self else {\n+            return false;\n+        };\n+        type_anchor.is_none() && generic_args.as_deref().is_none() && mod_path.is_Self()\n     }\n }\n \n@@ -222,7 +255,7 @@ impl GenericArgs {\n \n impl From<Name> for Path {\n     fn from(name: Name) -> Path {\n-        Path {\n+        Path::Normal {\n             type_anchor: None,\n             mod_path: Interned::new(ModPath::from_segments(PathKind::Plain, iter::once(name))),\n             generic_args: None,"}, {"sha": "407f38daad4f5e67e1cd11656ef4d81954c73859", "filename": "crates/hir-def/src/path/lower.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -75,8 +75,11 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n                     }\n                     // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n                     Some(trait_ref) => {\n-                        let Path { mod_path, generic_args: path_generic_args, .. } =\n-                            Path::from_src(trait_ref.path()?, ctx)?;\n+                        let Path::Normal { mod_path, generic_args: path_generic_args, .. } =\n+                            Path::from_src(trait_ref.path()?, ctx)? else\n+                        {\n+                            return None;\n+                        };\n                         let num_segments = mod_path.segments().len();\n                         kind = mod_path.kind;\n \n@@ -157,7 +160,7 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n     }\n \n     let mod_path = Interned::new(ModPath::from_segments(kind, segments));\n-    return Some(Path {\n+    return Some(Path::Normal {\n         type_anchor,\n         mod_path,\n         generic_args: if generic_args.is_empty() { None } else { Some(generic_args.into()) },"}, {"sha": "958882d43e309d4b4c098db2bf4de0aefb7647c6", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -15,8 +15,9 @@ use crate::{\n     expr::{BindingId, ExprId, LabelId},\n     generics::{GenericParams, TypeOrConstParamData},\n     item_scope::{BuiltinShadowMode, BUILTIN_SCOPE},\n+    lang_item::LangItemTarget,\n     nameres::DefMap,\n-    path::{ModPath, PathKind},\n+    path::{ModPath, Path, PathKind},\n     per_ns::PerNs,\n     visibility::{RawVisibility, Visibility},\n     AdtId, AssocItemId, ConstId, ConstParamId, DefWithBodyId, EnumId, EnumVariantId, ExternBlockId,\n@@ -176,8 +177,27 @@ impl Resolver {\n     pub fn resolve_path_in_type_ns(\n         &self,\n         db: &dyn DefDatabase,\n-        path: &ModPath,\n+        path: &Path,\n     ) -> Option<(TypeNs, Option<usize>)> {\n+        let path = match path {\n+            Path::Normal { mod_path, .. } => mod_path,\n+            Path::LangItem(l) => {\n+                return Some((\n+                    match *l {\n+                        LangItemTarget::Union(x) => TypeNs::AdtId(x.into()),\n+                        LangItemTarget::TypeAlias(x) => TypeNs::TypeAliasId(x),\n+                        LangItemTarget::Struct(x) => TypeNs::AdtId(x.into()),\n+                        LangItemTarget::EnumVariant(x) => TypeNs::EnumVariantId(x),\n+                        LangItemTarget::EnumId(x) => TypeNs::AdtId(x.into()),\n+                        LangItemTarget::Trait(x) => TypeNs::TraitId(x),\n+                        LangItemTarget::Function(_)\n+                        | LangItemTarget::ImplDef(_)\n+                        | LangItemTarget::Static(_) => return None,\n+                    },\n+                    None,\n+                ))\n+            }\n+        };\n         let first_name = path.segments().first()?;\n         let skip_to_mod = path.kind != PathKind::Plain;\n         if skip_to_mod {\n@@ -217,7 +237,7 @@ impl Resolver {\n     pub fn resolve_path_in_type_ns_fully(\n         &self,\n         db: &dyn DefDatabase,\n-        path: &ModPath,\n+        path: &Path,\n     ) -> Option<TypeNs> {\n         let (res, unresolved) = self.resolve_path_in_type_ns(db, path)?;\n         if unresolved.is_some() {\n@@ -245,8 +265,24 @@ impl Resolver {\n     pub fn resolve_path_in_value_ns(\n         &self,\n         db: &dyn DefDatabase,\n-        path: &ModPath,\n+        path: &Path,\n     ) -> Option<ResolveValueResult> {\n+        let path = match path {\n+            Path::Normal { mod_path, .. } => mod_path,\n+            Path::LangItem(l) => {\n+                return Some(ResolveValueResult::ValueNs(match *l {\n+                    LangItemTarget::Function(x) => ValueNs::FunctionId(x),\n+                    LangItemTarget::Static(x) => ValueNs::StaticId(x),\n+                    LangItemTarget::Struct(x) => ValueNs::StructId(x),\n+                    LangItemTarget::EnumVariant(x) => ValueNs::EnumVariantId(x),\n+                    LangItemTarget::Union(_)\n+                    | LangItemTarget::ImplDef(_)\n+                    | LangItemTarget::TypeAlias(_)\n+                    | LangItemTarget::Trait(_)\n+                    | LangItemTarget::EnumId(_) => return None,\n+                }))\n+            }\n+        };\n         let n_segments = path.segments().len();\n         let tmp = name![self];\n         let first_name = if path.is_self() { &tmp } else { path.segments().first()? };\n@@ -340,7 +376,7 @@ impl Resolver {\n     pub fn resolve_path_in_value_ns_fully(\n         &self,\n         db: &dyn DefDatabase,\n-        path: &ModPath,\n+        path: &Path,\n     ) -> Option<ValueNs> {\n         match self.resolve_path_in_value_ns(db, path)? {\n             ResolveValueResult::ValueNs(it) => Some(it),\n@@ -441,7 +477,7 @@ impl Resolver {\n                 &Scope::ImplDefScope(impl_) => {\n                     if let Some(target_trait) = &db.impl_data(impl_).target_trait {\n                         if let Some(TypeNs::TraitId(trait_)) =\n-                            self.resolve_path_in_type_ns_fully(db, target_trait.path.mod_path())\n+                            self.resolve_path_in_type_ns_fully(db, &target_trait.path)\n                         {\n                             traits.insert(trait_);\n                         }"}, {"sha": "fcb3445a54270e183775ce2f7f37fc48b6d2b268", "filename": "crates/hir-ty/src/consteval.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -4,7 +4,7 @@ use base_db::CrateId;\n use chalk_ir::{BoundVar, DebruijnIndex, GenericArgData};\n use hir_def::{\n     expr::Expr,\n-    path::ModPath,\n+    path::Path,\n     resolver::{Resolver, ValueNs},\n     type_ref::ConstRef,\n     ConstId, EnumVariantId,\n@@ -72,7 +72,7 @@ impl From<MirEvalError> for ConstEvalError {\n pub(crate) fn path_to_const(\n     db: &dyn HirDatabase,\n     resolver: &Resolver,\n-    path: &ModPath,\n+    path: &Path,\n     mode: ParamLoweringMode,\n     args_lazy: impl FnOnce() -> Generics,\n     debruijn: DebruijnIndex,\n@@ -89,7 +89,7 @@ pub(crate) fn path_to_const(\n                     Some(x) => ConstValue::BoundVar(BoundVar::new(debruijn, x)),\n                     None => {\n                         never!(\n-                            \"Generic list doesn't contain this param: {:?}, {}, {:?}\",\n+                            \"Generic list doesn't contain this param: {:?}, {:?}, {:?}\",\n                             args,\n                             path,\n                             p\n@@ -228,7 +228,7 @@ pub(crate) fn eval_to_const(\n     let db = ctx.db;\n     if let Expr::Path(p) = &ctx.body.exprs[expr] {\n         let resolver = &ctx.resolver;\n-        if let Some(c) = path_to_const(db, resolver, p.mod_path(), mode, args, debruijn) {\n+        if let Some(c) = path_to_const(db, resolver, p, mode, args, debruijn) {\n             return c;\n         }\n     }"}, {"sha": "3bec2ee88bfa385a119a2f1ac88f49b5ace77fa4", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -801,6 +801,73 @@ fn options() {\n     );\n }\n \n+#[test]\n+fn from_trait() {\n+    check_number(\n+        r#\"\n+    //- minicore: from\n+    struct E1(i32);\n+    struct E2(i32);\n+\n+    impl From<E1> for E2 {\n+        fn from(E1(x): E1) -> Self {\n+            E2(1000 * x)\n+        }\n+    }\n+    const GOAL: i32 = {\n+        let x: E2 = E1(2).into();\n+        x.0\n+    };\n+    \"#,\n+        2000,\n+    );\n+}\n+\n+#[test]\n+fn try_operator() {\n+    check_number(\n+        r#\"\n+    //- minicore: option, try\n+    const fn f(x: Option<i32>, y: Option<i32>) -> Option<i32> {\n+        Some(x? * y?)\n+    }\n+    const fn g(x: Option<i32>, y: Option<i32>) -> i32 {\n+        match f(x, y) {\n+            Some(k) => k,\n+            None => 5,\n+        }\n+    }\n+    const GOAL: i32 = g(Some(10), Some(20)) + g(Some(30), None) + g(None, Some(40)) + g(None, None);\n+        \"#,\n+        215,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: result, try, from\n+    struct E1(i32);\n+    struct E2(i32);\n+\n+    impl From<E1> for E2 {\n+        fn from(E1(x): E1) -> Self {\n+            E2(1000 * x)\n+        }\n+    }\n+\n+    const fn f(x: Result<i32, E1>) -> Result<i32, E2> {\n+        Ok(x? * 10)\n+    }\n+    const fn g(x: Result<i32, E1>) -> i32 {\n+        match f(x) {\n+            Ok(k) => 7 * k,\n+            Err(E2(k)) => 5 * k,\n+        }\n+    }\n+    const GOAL: i32 = g(Ok(2)) + g(Err(E1(3)));\n+        \"#,\n+        15140,\n+    );\n+}\n+\n #[test]\n fn or_pattern() {\n     check_number("}, {"sha": "8f1af4c2f8e2dca114c69db0be4724082b7ed3ec", "filename": "crates/hir-ty/src/db.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -97,6 +97,10 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(crate::lower::generic_predicates_query)]\n     fn generic_predicates(&self, def: GenericDefId) -> Arc<[Binders<QuantifiedWhereClause>]>;\n \n+    #[salsa::invoke(crate::lower::trait_environment_for_body_query)]\n+    #[salsa::transparent]\n+    fn trait_environment_for_body(&self, def: DefWithBodyId) -> Arc<crate::TraitEnvironment>;\n+\n     #[salsa::invoke(crate::lower::trait_environment_query)]\n     fn trait_environment(&self, def: GenericDefId) -> Arc<crate::TraitEnvironment>;\n "}, {"sha": "664822ee6fb4d75e27154d5ec37c59653f7e4602", "filename": "crates/hir-ty/src/diagnostics/unsafe_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -73,7 +73,7 @@ fn walk_unsafe(\n         }\n         Expr::Path(path) => {\n             let resolver = resolver_for_expr(db.upcast(), def, current);\n-            let value_or_partial = resolver.resolve_path_in_value_ns(db.upcast(), path.mod_path());\n+            let value_or_partial = resolver.resolve_path_in_value_ns(db.upcast(), path);\n             if let Some(ResolveValueResult::ValueNs(ValueNs::StaticId(id))) = value_or_partial {\n                 if db.static_data(id).mutable {\n                     unsafe_expr_cb(UnsafeExpr { expr: current, inside_unsafe_block });"}, {"sha": "00b5f7948ac4c473b39637f9abfb56b342b2d2a7", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -25,16 +25,16 @@ use hir_def::{\n     expr::{BindingAnnotation, BindingId, ExprId, ExprOrPatId, PatId},\n     lang_item::{LangItem, LangItemTarget},\n     layout::Integer,\n-    path::Path,\n+    path::{ModPath, Path},\n     resolver::{HasResolver, ResolveValueResult, Resolver, TypeNs, ValueNs},\n     type_ref::TypeRef,\n-    AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, HasModule,\n-    ItemContainerId, Lookup, TraitId, TypeAliasId, VariantId,\n+    AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, ItemContainerId, Lookup,\n+    TraitId, TypeAliasId, VariantId,\n };\n use hir_expand::name::{name, Name};\n use la_arena::ArenaMap;\n use rustc_hash::{FxHashMap, FxHashSet};\n-use stdx::always;\n+use stdx::{always, never};\n \n use crate::{\n     db::HirDatabase, fold_tys, fold_tys_and_consts, infer::coerce::CoerceMany,\n@@ -110,10 +110,7 @@ pub(crate) fn normalize(db: &dyn HirDatabase, owner: DefWithBodyId, ty: Ty) -> T\n     if !ty.data(Interner).flags.intersects(TypeFlags::HAS_PROJECTION) {\n         return ty;\n     }\n-    let krate = owner.module(db.upcast()).krate();\n-    let trait_env = owner\n-        .as_generic_def_id()\n-        .map_or_else(|| Arc::new(TraitEnvironment::empty(krate)), |d| db.trait_environment(d));\n+    let trait_env = db.trait_environment_for_body(owner);\n     let mut table = unify::InferenceTable::new(db, trait_env);\n \n     let ty_with_vars = table.normalize_associated_types_in(ty);\n@@ -506,10 +503,7 @@ impl<'a> InferenceContext<'a> {\n         body: &'a Body,\n         resolver: Resolver,\n     ) -> Self {\n-        let krate = owner.module(db.upcast()).krate();\n-        let trait_env = owner\n-            .as_generic_def_id()\n-            .map_or_else(|| Arc::new(TraitEnvironment::empty(krate)), |d| db.trait_environment(d));\n+        let trait_env = db.trait_environment_for_body(owner);\n         InferenceContext {\n             result: InferenceResult::default(),\n             table: unify::InferenceTable::new(db, trait_env.clone()),\n@@ -851,7 +845,7 @@ impl<'a> InferenceContext<'a> {\n         // FIXME: this should resolve assoc items as well, see this example:\n         // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n         let (resolution, unresolved) = if value_ns {\n-            match self.resolver.resolve_path_in_value_ns(self.db.upcast(), path.mod_path()) {\n+            match self.resolver.resolve_path_in_value_ns(self.db.upcast(), path) {\n                 Some(ResolveValueResult::ValueNs(value)) => match value {\n                     ValueNs::EnumVariantId(var) => {\n                         let substs = ctx.substs_from_path(path, var.into(), true);\n@@ -872,11 +866,15 @@ impl<'a> InferenceContext<'a> {\n                 None => return (self.err_ty(), None),\n             }\n         } else {\n-            match self.resolver.resolve_path_in_type_ns(self.db.upcast(), path.mod_path()) {\n+            match self.resolver.resolve_path_in_type_ns(self.db.upcast(), path) {\n                 Some(it) => it,\n                 None => return (self.err_ty(), None),\n             }\n         };\n+        let Some(mod_path) = path.mod_path() else {\n+            never!(\"resolver should always resolve lang item paths\");\n+            return (self.err_ty(), None);\n+        };\n         return match resolution {\n             TypeNs::AdtId(AdtId::StructId(strukt)) => {\n                 let substs = ctx.substs_from_path(path, strukt.into(), true);\n@@ -900,7 +898,7 @@ impl<'a> InferenceContext<'a> {\n                 let generics = crate::utils::generics(self.db.upcast(), impl_id.into());\n                 let substs = generics.placeholder_subst(self.db);\n                 let ty = self.db.impl_self_ty(impl_id).substitute(Interner, &substs);\n-                self.resolve_variant_on_alias(ty, unresolved, path)\n+                self.resolve_variant_on_alias(ty, unresolved, mod_path)\n             }\n             TypeNs::TypeAliasId(it) => {\n                 let container = it.lookup(self.db.upcast()).container;\n@@ -917,7 +915,7 @@ impl<'a> InferenceContext<'a> {\n                 let ty = TyBuilder::def_ty(self.db, it.into(), parent_subst)\n                     .fill_with_inference_vars(&mut self.table)\n                     .build();\n-                self.resolve_variant_on_alias(ty, unresolved, path)\n+                self.resolve_variant_on_alias(ty, unresolved, mod_path)\n             }\n             TypeNs::AdtSelfType(_) => {\n                 // FIXME this could happen in array size expressions, once we're checking them\n@@ -953,9 +951,9 @@ impl<'a> InferenceContext<'a> {\n         &mut self,\n         ty: Ty,\n         unresolved: Option<usize>,\n-        path: &Path,\n+        path: &ModPath,\n     ) -> (Ty, Option<VariantId>) {\n-        let remaining = unresolved.map(|x| path.segments().skip(x).len()).filter(|x| x > &0);\n+        let remaining = unresolved.map(|x| path.segments()[x..].len()).filter(|x| x > &0);\n         match remaining {\n             None => {\n                 let variant = ty.as_adt().and_then(|(adt_id, _)| match adt_id {\n@@ -969,7 +967,7 @@ impl<'a> InferenceContext<'a> {\n                 (ty, variant)\n             }\n             Some(1) => {\n-                let segment = path.mod_path().segments().last().unwrap();\n+                let segment = path.segments().last().unwrap();\n                 // this could be an enum variant or associated type\n                 if let Some((AdtId::EnumId(enum_id), _)) = ty.as_adt() {\n                     let enum_data = self.db.enum_data(enum_id);"}, {"sha": "7bf227a27f28b9515020780f8c8c770c443c63db", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -601,21 +601,21 @@ impl<'a> InferenceContext<'a> {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 self.resolve_associated_type(inner_ty, self.resolve_future_future_output())\n             }\n-            Expr::Try { expr } => {\n-                let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n-                if let Some(trait_) = self.resolve_lang_trait(LangItem::Try) {\n-                    if let Some(func) = self.db.trait_data(trait_).method_by_name(&name!(branch)) {\n-                        let subst = TyBuilder::subst_for_def(self.db, trait_, None)\n-                            .push(inner_ty.clone())\n-                            .build();\n-                        self.write_method_resolution(tgt_expr, func, subst.clone());\n-                    }\n-                    let try_output = self.resolve_output_on(trait_);\n-                    self.resolve_associated_type(inner_ty, try_output)\n-                } else {\n-                    self.err_ty()\n-                }\n-            }\n+            // Expr::Try { expr } => {\n+            //     let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n+            //     if let Some(trait_) = self.resolve_lang_trait(LangItem::Try) {\n+            //         if let Some(func) = self.db.trait_data(trait_).method_by_name(&name!(branch)) {\n+            //             let subst = TyBuilder::subst_for_def(self.db, trait_, None)\n+            //                 .push(inner_ty.clone())\n+            //                 .build();\n+            //             self.write_method_resolution(tgt_expr, func, subst.clone());\n+            //         }\n+            //         let try_output = self.resolve_output_on(trait_);\n+            //         self.resolve_associated_type(inner_ty, try_output)\n+            //     } else {\n+            //         self.err_ty()\n+            //     }\n+            // }\n             Expr::Cast { expr, type_ref } => {\n                 let cast_ty = self.make_ty(type_ref);\n                 // FIXME: propagate the \"castable to\" expectation"}, {"sha": "266e410187581bc6889ef077497a7a7292f34a10", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -39,7 +39,7 @@ impl<'a> InferenceContext<'a> {\n         } else {\n             // FIXME: report error, unresolved first path segment\n             let value_or_partial =\n-                self.resolver.resolve_path_in_value_ns(self.db.upcast(), path.mod_path())?;\n+                self.resolver.resolve_path_in_value_ns(self.db.upcast(), path)?;\n \n             match value_or_partial {\n                 ResolveValueResult::ValueNs(it) => (it, None),"}, {"sha": "e7490087e762b4402ce17c542a0a456b4a7fba8e", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 62, "deletions": 26, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -25,12 +25,12 @@ use hir_def::{\n         TypeOrConstParamData, TypeParamProvenance, WherePredicate, WherePredicateTypeTarget,\n     },\n     lang_item::{lang_attr, LangItem},\n-    path::{GenericArg, ModPath, Path, PathKind, PathSegment, PathSegments},\n+    path::{GenericArg, GenericArgs, ModPath, Path, PathKind, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{ConstRefOrPath, TraitBoundModifier, TraitRef as HirTraitRef, TypeBound, TypeRef},\n-    AdtId, AssocItemId, ConstId, ConstParamId, EnumId, EnumVariantId, FunctionId, GenericDefId,\n-    HasModule, ImplId, ItemContainerId, LocalFieldId, Lookup, ModuleDefId, StaticId, StructId,\n-    TraitId, TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId, VariantId,\n+    AdtId, AssocItemId, ConstId, ConstParamId, DefWithBodyId, EnumId, EnumVariantId, FunctionId,\n+    GenericDefId, HasModule, ImplId, ItemContainerId, LocalFieldId, Lookup, ModuleDefId, StaticId,\n+    StructId, TraitId, TypeAliasId, TypeOrConstParamId, TypeParamId, UnionId, VariantId,\n };\n use hir_expand::{name::Name, ExpandResult};\n use intern::Interned;\n@@ -425,11 +425,10 @@ impl<'a> TyLoweringContext<'a> {\n         if path.segments().len() > 1 {\n             return None;\n         }\n-        let resolution =\n-            match self.resolver.resolve_path_in_type_ns(self.db.upcast(), path.mod_path()) {\n-                Some((it, None)) => it,\n-                _ => return None,\n-            };\n+        let resolution = match self.resolver.resolve_path_in_type_ns(self.db.upcast(), path) {\n+            Some((it, None)) => it,\n+            _ => return None,\n+        };\n         match resolution {\n             TypeNs::GenericParam(param_id) => Some(param_id.into()),\n             _ => None,\n@@ -608,7 +607,7 @@ impl<'a> TyLoweringContext<'a> {\n         }\n \n         let (resolution, remaining_index) =\n-            match self.resolver.resolve_path_in_type_ns(self.db.upcast(), path.mod_path()) {\n+            match self.resolver.resolve_path_in_type_ns(self.db.upcast(), path) {\n                 Some(it) => it,\n                 None => return (TyKind::Error.intern(Interner), None),\n             };\n@@ -716,7 +715,7 @@ impl<'a> TyLoweringContext<'a> {\n         resolved: ValueTyDefId,\n         infer_args: bool,\n     ) -> Substitution {\n-        let last = path.segments().last().expect(\"path should have at least one segment\");\n+        let last = path.segments().last();\n         let (segment, generic_def) = match resolved {\n             ValueTyDefId::FunctionId(it) => (last, Some(it.into())),\n             ValueTyDefId::StructId(it) => (last, Some(it.into())),\n@@ -732,13 +731,20 @@ impl<'a> TyLoweringContext<'a> {\n                 let len = path.segments().len();\n                 let penultimate = len.checked_sub(2).and_then(|idx| path.segments().get(idx));\n                 let segment = match penultimate {\n-                    Some(segment) if segment.args_and_bindings.is_some() => segment,\n+                    Some(segment) if segment.args_and_bindings.is_some() => Some(segment),\n                     _ => last,\n                 };\n                 (segment, Some(var.parent.into()))\n             }\n         };\n-        self.substs_from_path_segment(segment, generic_def, infer_args, None)\n+        if let Some(segment) = segment {\n+            self.substs_from_path_segment(segment, generic_def, infer_args, None)\n+        } else if let Some(generic_def) = generic_def {\n+            // lang item\n+            self.substs_from_args_and_bindings(None, Some(generic_def), infer_args, None)\n+        } else {\n+            Substitution::empty(Interner)\n+        }\n     }\n \n     fn substs_from_path_segment(\n@@ -747,6 +753,21 @@ impl<'a> TyLoweringContext<'a> {\n         def: Option<GenericDefId>,\n         infer_args: bool,\n         explicit_self_ty: Option<Ty>,\n+    ) -> Substitution {\n+        self.substs_from_args_and_bindings(\n+            segment.args_and_bindings,\n+            def,\n+            infer_args,\n+            explicit_self_ty,\n+        )\n+    }\n+\n+    fn substs_from_args_and_bindings(\n+        &self,\n+        args_and_bindings: Option<&GenericArgs>,\n+        def: Option<GenericDefId>,\n+        infer_args: bool,\n+        explicit_self_ty: Option<Ty>,\n     ) -> Substitution {\n         // Remember that the item's own generic args come before its parent's.\n         let mut substs = Vec::new();\n@@ -780,7 +801,7 @@ impl<'a> TyLoweringContext<'a> {\n         };\n         let mut had_explicit_args = false;\n \n-        if let Some(generic_args) = &segment.args_and_bindings {\n+        if let Some(generic_args) = &args_and_bindings {\n             if !generic_args.has_self_type {\n                 fill_self_params();\n             }\n@@ -879,12 +900,11 @@ impl<'a> TyLoweringContext<'a> {\n         path: &Path,\n         explicit_self_ty: Option<Ty>,\n     ) -> Option<TraitRef> {\n-        let resolved =\n-            match self.resolver.resolve_path_in_type_ns_fully(self.db.upcast(), path.mod_path())? {\n-                // FIXME(trait_alias): We need to handle trait alias here.\n-                TypeNs::TraitId(tr) => tr,\n-                _ => return None,\n-            };\n+        let resolved = match self.resolver.resolve_path_in_type_ns_fully(self.db.upcast(), path)? {\n+            // FIXME(trait_alias): We need to handle trait alias here.\n+            TypeNs::TraitId(tr) => tr,\n+            _ => return None,\n+        };\n         let segment = path.segments().last().expect(\"path should have at least one segment\");\n         Some(self.lower_trait_ref_from_resolved_path(resolved, segment, explicit_self_ty))\n     }\n@@ -1381,9 +1401,7 @@ pub(crate) fn generic_predicates_for_param_query(\n                             Some(it) => it,\n                             None => return true,\n                         };\n-                        let tr = match resolver\n-                            .resolve_path_in_type_ns_fully(db.upcast(), path.mod_path())\n-                        {\n+                        let tr = match resolver.resolve_path_in_type_ns_fully(db.upcast(), path) {\n                             Some(TypeNs::TraitId(tr)) => tr,\n                             _ => return false,\n                         };\n@@ -1423,6 +1441,17 @@ pub(crate) fn generic_predicates_for_param_recover(\n     Arc::new([])\n }\n \n+pub(crate) fn trait_environment_for_body_query(\n+    db: &dyn HirDatabase,\n+    def: DefWithBodyId,\n+) -> Arc<TraitEnvironment> {\n+    let Some(def) = def.as_generic_def_id() else {\n+        let krate = def.module(db.upcast()).krate();\n+        return Arc::new(TraitEnvironment::empty(krate));\n+    };\n+    db.trait_environment(def)\n+}\n+\n pub(crate) fn trait_environment_query(\n     db: &dyn HirDatabase,\n     def: GenericDefId,\n@@ -1948,7 +1977,7 @@ pub(crate) fn generic_arg_to_chalk<'a, T>(\n             // as types. Maybe here is not the best place to do it, but\n             // it works.\n             if let TypeRef::Path(p) = t {\n-                let p = p.mod_path();\n+                let p = p.mod_path()?;\n                 if p.kind == PathKind::Plain {\n                     if let [n] = p.segments() {\n                         let c = ConstRefOrPath::Path(n.clone());\n@@ -1977,8 +2006,15 @@ pub(crate) fn const_or_path_to_chalk(\n         ConstRefOrPath::Scalar(s) => intern_const_ref(db, s, expected_ty, resolver.krate()),\n         ConstRefOrPath::Path(n) => {\n             let path = ModPath::from_segments(PathKind::Plain, Some(n.clone()));\n-            path_to_const(db, resolver, &path, mode, args, debruijn)\n-                .unwrap_or_else(|| unknown_const(expected_ty))\n+            path_to_const(\n+                db,\n+                resolver,\n+                &Path::from_known_path_with_no_generic(path),\n+                mode,\n+                args,\n+                debruijn,\n+            )\n+            .unwrap_or_else(|| unknown_const(expected_ty))\n         }\n     }\n }"}, {"sha": "1ff6e106021f2cdecd8ef97da6631af60e8496d9", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -1,6 +1,6 @@\n //! This module provides a MIR interpreter, which is used in const eval.\n \n-use std::{borrow::Cow, collections::HashMap, iter};\n+use std::{borrow::Cow, collections::HashMap, iter, sync::Arc};\n \n use base_db::CrateId;\n use chalk_ir::{\n@@ -24,7 +24,8 @@ use crate::{\n     layout::layout_of_ty,\n     mapping::from_chalk,\n     method_resolution::lookup_impl_method,\n-    CallableDefId, Const, ConstScalar, Interner, MemoryMap, Substitution, Ty, TyBuilder, TyExt,\n+    CallableDefId, Const, ConstScalar, Interner, MemoryMap, Substitution, TraitEnvironment, Ty,\n+    TyBuilder, TyExt,\n };\n \n use super::{\n@@ -34,6 +35,7 @@ use super::{\n \n pub struct Evaluator<'a> {\n     db: &'a dyn HirDatabase,\n+    trait_env: Arc<TraitEnvironment>,\n     stack: Vec<u8>,\n     heap: Vec<u8>,\n     crate_id: CrateId,\n@@ -217,8 +219,7 @@ pub fn interpret_mir(\n     assert_placeholder_ty_is_unused: bool,\n ) -> Result<Const> {\n     let ty = body.locals[return_slot()].ty.clone();\n-    let mut evaluator =\n-        Evaluator::new(db, body.owner.module(db.upcast()).krate(), assert_placeholder_ty_is_unused);\n+    let mut evaluator = Evaluator::new(db, body, assert_placeholder_ty_is_unused);\n     let bytes = evaluator.interpret_mir_with_no_arg(&body)?;\n     let memory_map = evaluator.create_memory_map(\n         &bytes,\n@@ -231,13 +232,16 @@ pub fn interpret_mir(\n impl Evaluator<'_> {\n     pub fn new<'a>(\n         db: &'a dyn HirDatabase,\n-        crate_id: CrateId,\n+        body: &MirBody,\n         assert_placeholder_ty_is_unused: bool,\n     ) -> Evaluator<'a> {\n+        let crate_id = body.owner.module(db.upcast()).krate();\n+        let trait_env = db.trait_environment_for_body(body.owner);\n         Evaluator {\n             stack: vec![0],\n             heap: vec![0],\n             db,\n+            trait_env,\n             crate_id,\n             assert_placeholder_ty_is_unused,\n             stack_depth_limit: 100,\n@@ -500,15 +504,9 @@ impl Evaluator<'_> {\n                                     } else if let Some(x) = self.detect_lang_function(def) {\n                                         self.exec_lang_item(x, arg_bytes)?\n                                     } else {\n-                                        let trait_env = {\n-                                            let Some(d) = body.owner.as_generic_def_id() else {\n-                                                not_supported!(\"trait resolving in non generic def id\");\n-                                            };\n-                                            self.db.trait_environment(d)\n-                                        };\n                                         let (imp, generic_args) = lookup_impl_method(\n                                             self.db,\n-                                            trait_env,\n+                                            self.trait_env.clone(),\n                                             def,\n                                             generic_args.clone(),\n                                         );\n@@ -584,7 +582,7 @@ impl Evaluator<'_> {\n                         .to_owned());\n                 }\n                 Terminator::Unreachable => {\n-                    return Err(MirEvalError::UndefinedBehavior(\"unreachable executed\"))\n+                    return Err(MirEvalError::UndefinedBehavior(\"unreachable executed\"));\n                 }\n                 _ => not_supported!(\"unknown terminator\"),\n             }\n@@ -710,8 +708,24 @@ impl Evaluator<'_> {\n                 let ty = self.place_ty(p, locals)?;\n                 let bytes = self.eval_place(p, locals)?.get(&self)?;\n                 let layout = self.layout(&ty)?;\n+                let enum_id = 'b: {\n+                    match ty.kind(Interner) {\n+                        TyKind::Adt(e, _) => match e.0 {\n+                            AdtId::EnumId(e) => break 'b e,\n+                            _ => (),\n+                        },\n+                        _ => (),\n+                    }\n+                    return Ok(Owned(0u128.to_le_bytes().to_vec()));\n+                };\n                 match layout.variants {\n-                    Variants::Single { .. } => Owned(0u128.to_le_bytes().to_vec()),\n+                    Variants::Single { index } => {\n+                        let r = self.db.const_eval_discriminant(EnumVariantId {\n+                            parent: enum_id,\n+                            local_id: index.0,\n+                        })?;\n+                        Owned(r.to_le_bytes().to_vec())\n+                    }\n                     Variants::Multiple { tag, tag_encoding, .. } => {\n                         let Some(target_data_layout) = self.db.target_data_layout(self.crate_id) else {\n                             not_supported!(\"missing target data layout\");\n@@ -727,13 +741,6 @@ impl Evaluator<'_> {\n                                 let tag = &bytes[offset..offset + size];\n                                 let candidate_discriminant = i128::from_le_bytes(pad16(tag, false))\n                                     .wrapping_sub(niche_start as i128);\n-                                let enum_id = match ty.kind(Interner) {\n-                                    TyKind::Adt(e, _) => match e.0 {\n-                                        AdtId::EnumId(e) => e,\n-                                        _ => not_supported!(\"Non enum with multi variant layout\"),\n-                                    },\n-                                    _ => not_supported!(\"Non adt with multi variant layout\"),\n-                                };\n                                 let enum_data = self.db.enum_data(enum_id);\n                                 let result = 'b: {\n                                     for (local_id, _) in enum_data.variants.iter() {\n@@ -790,8 +797,8 @@ impl Evaluator<'_> {\n                     Owned(result)\n                 }\n                 AggregateKind::Adt(x, subst) => {\n-                    let (size, variant_layout, tag) =\n-                        self.layout_of_variant(*x, subst.clone(), locals)?;\n+                    let subst = self.subst_filler(subst, locals);\n+                    let (size, variant_layout, tag) = self.layout_of_variant(*x, subst, locals)?;\n                     Owned(self.make_by_layout(size, &variant_layout, tag, values, locals)?)\n                 }\n             },\n@@ -1124,12 +1131,13 @@ impl Evaluator<'_> {\n     }\n \n     fn detect_lang_function(&self, def: FunctionId) -> Option<LangItem> {\n+        use LangItem::*;\n         let candidate = lang_attr(self.db.upcast(), def)?;\n-        // filter normal lang functions out\n-        if [LangItem::IntoIterIntoIter, LangItem::IteratorNext].contains(&candidate) {\n-            return None;\n+        // We want to execute these functions with special logic\n+        if [PanicFmt, BeginPanic, SliceLen].contains(&candidate) {\n+            return Some(candidate);\n         }\n-        Some(candidate)\n+        None\n     }\n \n     fn create_memory_map(&self, bytes: &[u8], ty: &Ty, locals: &Locals<'_>) -> Result<MemoryMap> {"}, {"sha": "3b9a31c772a5bbb61452e40aabf20fbf190f003d", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -13,7 +13,7 @@ use hir_def::{\n     layout::LayoutError,\n     path::Path,\n     resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n-    DefWithBodyId, EnumVariantId, HasModule,\n+    DefWithBodyId, EnumVariantId, HasModule, ItemContainerId, TraitId,\n };\n use hir_expand::name::Name;\n use la_arena::ArenaMap;\n@@ -50,6 +50,8 @@ pub enum MirLowerError {\n     ConstEvalError(Box<ConstEvalError>),\n     LayoutError(LayoutError),\n     IncompleteExpr,\n+    /// Trying to lower a trait function, instead of an implementation\n+    TraitFunctionDefinition(TraitId, Name),\n     UnresolvedName(String),\n     RecordLiteralWithoutPath,\n     UnresolvedMethod,\n@@ -200,12 +202,21 @@ impl MirLowerCtx<'_> {\n         mut current: BasicBlockId,\n     ) -> Result<Option<BasicBlockId>> {\n         match &self.body.exprs[expr_id] {\n-            Expr::Missing => Err(MirLowerError::IncompleteExpr),\n+            Expr::Missing => {\n+                if let DefWithBodyId::FunctionId(f) = self.owner {\n+                    let assoc = self.db.lookup_intern_function(f);\n+                    if let ItemContainerId::TraitId(t) = assoc.container {\n+                        let name = &self.db.function_data(f).name;\n+                        return Err(MirLowerError::TraitFunctionDefinition(t, name.clone()));\n+                    }\n+                }\n+                Err(MirLowerError::IncompleteExpr)\n+            },\n             Expr::Path(p) => {\n                 let unresolved_name = || MirLowerError::unresolved_path(self.db, p);\n                 let resolver = resolver_for_expr(self.db.upcast(), self.owner, expr_id);\n                 let pr = resolver\n-                    .resolve_path_in_value_ns(self.db.upcast(), p.mod_path())\n+                    .resolve_path_in_value_ns(self.db.upcast(), p)\n                     .ok_or_else(unresolved_name)?;\n                 let pr = match pr {\n                     ResolveValueResult::ValueNs(v) => v,\n@@ -608,7 +619,6 @@ impl MirLowerCtx<'_> {\n                 }\n             }\n             Expr::Await { .. } => not_supported!(\"await\"),\n-            Expr::Try { .. } => not_supported!(\"? operator\"),\n             Expr::Yeet { .. } => not_supported!(\"yeet\"),\n             Expr::TryBlock { .. } => not_supported!(\"try block\"),\n             Expr::Async { .. } => not_supported!(\"async block\"),"}, {"sha": "b683dd7f90d62ced1a0e840c37a6b049ce4301b7", "filename": "crates/hir-ty/src/mir/lower/as_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -125,7 +125,7 @@ impl MirLowerCtx<'_> {\n         match &self.body.exprs[expr_id] {\n             Expr::Path(p) => {\n                 let resolver = resolver_for_expr(self.db.upcast(), self.owner, expr_id);\n-                let Some(pr) = resolver.resolve_path_in_value_ns(self.db.upcast(), p.mod_path()) else {\n+                let Some(pr) = resolver.resolve_path_in_value_ns(self.db.upcast(), p) else {\n                     return Err(MirLowerError::unresolved_path(self.db, p));\n                 };\n                 let pr = match pr {"}, {"sha": "70364d0882314c0467742610217b24d54845db63", "filename": "crates/hir-ty/src/mir/pretty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -77,6 +77,7 @@ impl Display for LocalName {\n \n impl<'a> MirPrettyCtx<'a> {\n     fn for_body(&mut self) {\n+        wln!(self, \"// {:?}\", self.body.owner);\n         self.with_block(|this| {\n             this.locals();\n             wln!(this);"}, {"sha": "a6967414aa8559f2f6b05e734a6cf469ffc12600", "filename": "crates/hir-ty/src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Futils.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -130,7 +130,7 @@ fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId, cb: impl FnMut(Tra\n             WherePredicate::Lifetime { .. } => None,\n         })\n         .filter(|(_, bound_modifier)| matches!(bound_modifier, TraitBoundModifier::None))\n-        .filter_map(|(path, _)| match resolver.resolve_path_in_type_ns_fully(db, path.mod_path()) {\n+        .filter_map(|(path, _)| match resolver.resolve_path_in_type_ns_fully(db, path) {\n             Some(TypeNs::TraitId(t)) => Some(t),\n             _ => None,\n         })"}, {"sha": "9709970db1eecec2ff308f044e43088fbd9cd682", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -1076,10 +1076,7 @@ impl<'db> SemanticsImpl<'db> {\n         let hygiene = hir_expand::hygiene::Hygiene::new(self.db.upcast(), analyze.file_id);\n         let ctx = body::LowerCtx::with_hygiene(self.db.upcast(), &hygiene);\n         let hir_path = Path::from_src(path.clone(), &ctx)?;\n-        match analyze\n-            .resolver\n-            .resolve_path_in_type_ns_fully(self.db.upcast(), hir_path.mod_path())?\n-        {\n+        match analyze.resolver.resolve_path_in_type_ns_fully(self.db.upcast(), &hir_path)? {\n             TypeNs::TraitId(id) => Some(Trait { id }),\n             _ => None,\n         }"}, {"sha": "5b18e445727f3fac47cfb33bf9e1789aae23aa78", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -420,7 +420,10 @@ impl SourceAnalyzer {\n             None\n         } else {\n             // Shorthand syntax, resolve to the local\n-            let path = ModPath::from_segments(PathKind::Plain, once(local_name.clone()));\n+            let path = Path::from_known_path_with_no_generic(ModPath::from_segments(\n+                PathKind::Plain,\n+                once(local_name.clone()),\n+            ));\n             match self.resolver.resolve_path_in_value_ns_fully(db.upcast(), &path) {\n                 Some(ValueNs::LocalBinding(binding_id)) => {\n                     Some(Local { binding_id, parent: self.resolver.body_owner()? })\n@@ -461,7 +464,7 @@ impl SourceAnalyzer {\n     ) -> Option<Macro> {\n         let ctx = body::LowerCtx::new(db.upcast(), macro_call.file_id);\n         let path = macro_call.value.path().and_then(|ast| Path::from_src(ast, &ctx))?;\n-        self.resolver.resolve_path_as_macro(db.upcast(), path.mod_path()).map(|it| it.into())\n+        self.resolver.resolve_path_as_macro(db.upcast(), path.mod_path()?).map(|it| it.into())\n     }\n \n     pub(crate) fn resolve_bind_pat_to_const(\n@@ -801,15 +804,11 @@ impl SourceAnalyzer {\n         func: FunctionId,\n         substs: Substitution,\n     ) -> FunctionId {\n-        let krate = self.resolver.krate();\n         let owner = match self.resolver.body_owner() {\n             Some(it) => it,\n             None => return func,\n         };\n-        let env = owner.as_generic_def_id().map_or_else(\n-            || Arc::new(hir_ty::TraitEnvironment::empty(krate)),\n-            |d| db.trait_environment(d),\n-        );\n+        let env = db.trait_environment_for_body(owner);\n         method_resolution::lookup_impl_method(db, env, func, substs).0\n     }\n \n@@ -819,15 +818,11 @@ impl SourceAnalyzer {\n         const_id: ConstId,\n         subs: Substitution,\n     ) -> ConstId {\n-        let krate = self.resolver.krate();\n         let owner = match self.resolver.body_owner() {\n             Some(it) => it,\n             None => return const_id,\n         };\n-        let env = owner.as_generic_def_id().map_or_else(\n-            || Arc::new(hir_ty::TraitEnvironment::empty(krate)),\n-            |d| db.trait_environment(d),\n-        );\n+        let env = db.trait_environment_for_body(owner);\n         method_resolution::lookup_impl_const(db, env, const_id, subs).0\n     }\n \n@@ -946,7 +941,7 @@ pub(crate) fn resolve_hir_path_as_macro(\n     resolver: &Resolver,\n     path: &Path,\n ) -> Option<Macro> {\n-    resolver.resolve_path_as_macro(db.upcast(), path.mod_path()).map(Into::into)\n+    resolver.resolve_path_as_macro(db.upcast(), path.mod_path()?).map(Into::into)\n }\n \n fn resolve_hir_path_(\n@@ -962,8 +957,7 @@ fn resolve_hir_path_(\n                 res.map(|ty_ns| (ty_ns, path.segments().first()))\n             }\n             None => {\n-                let (ty, remaining_idx) =\n-                    resolver.resolve_path_in_type_ns(db.upcast(), path.mod_path())?;\n+                let (ty, remaining_idx) = resolver.resolve_path_in_type_ns(db.upcast(), path)?;\n                 match remaining_idx {\n                     Some(remaining_idx) => {\n                         if remaining_idx + 1 == path.segments().len() {\n@@ -1019,7 +1013,7 @@ fn resolve_hir_path_(\n \n     let body_owner = resolver.body_owner();\n     let values = || {\n-        resolver.resolve_path_in_value_ns_fully(db.upcast(), path.mod_path()).and_then(|val| {\n+        resolver.resolve_path_in_value_ns_fully(db.upcast(), path).and_then(|val| {\n             let res = match val {\n                 ValueNs::LocalBinding(binding_id) => {\n                     let var = Local { parent: body_owner?, binding_id };\n@@ -1039,14 +1033,14 @@ fn resolve_hir_path_(\n \n     let items = || {\n         resolver\n-            .resolve_module_path_in_items(db.upcast(), path.mod_path())\n+            .resolve_module_path_in_items(db.upcast(), path.mod_path()?)\n             .take_types()\n             .map(|it| PathResolution::Def(it.into()))\n     };\n \n     let macros = || {\n         resolver\n-            .resolve_path_as_macro(db.upcast(), path.mod_path())\n+            .resolve_path_as_macro(db.upcast(), path.mod_path()?)\n             .map(|def| PathResolution::Def(ModuleDef::Macro(def.into())))\n     };\n \n@@ -1074,7 +1068,7 @@ fn resolve_hir_path_qualifier(\n     path: &Path,\n ) -> Option<PathResolution> {\n     resolver\n-        .resolve_path_in_type_ns_fully(db.upcast(), path.mod_path())\n+        .resolve_path_in_type_ns_fully(db.upcast(), &path)\n         .map(|ty| match ty {\n             TypeNs::SelfType(it) => PathResolution::SelfType(it.into()),\n             TypeNs::GenericParam(id) => PathResolution::TypeParam(id.into()),\n@@ -1089,7 +1083,7 @@ fn resolve_hir_path_qualifier(\n         })\n         .or_else(|| {\n             resolver\n-                .resolve_module_path_in_items(db.upcast(), path.mod_path())\n+                .resolve_module_path_in_items(db.upcast(), path.mod_path()?)\n                 .take_types()\n                 .map(|it| PathResolution::Def(it.into()))\n         })"}, {"sha": "2e26f59d030ff6d3da36343f2fe48449fc9ce3b6", "filename": "crates/ide-assists/src/handlers/replace_try_expr_with_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_try_expr_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_try_expr_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_try_expr_with_match.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -20,7 +20,7 @@ use crate::assist_context::{AssistContext, Assists};\n // Replaces a `try` expression with a `match` expression.\n //\n // ```\n-// # //- minicore:option\n+// # //- minicore: try, option\n // fn handle() {\n //     let pat = Some(true)$0?;\n // }\n@@ -111,7 +111,7 @@ mod tests {\n         check_assist(\n             replace_try_expr_with_match,\n             r#\"\n-//- minicore:option\n+//- minicore: try, option\n fn test() {\n     let pat = Some(true)$0?;\n }\n@@ -132,7 +132,7 @@ fn test() {\n         check_assist(\n             replace_try_expr_with_match,\n             r#\"\n-//- minicore:result\n+//- minicore: try, from, result\n fn test() {\n     let pat = Ok(true)$0?;\n }"}, {"sha": "aff11367de9a6f96b2829ba4187895ed1a54c646", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -2352,7 +2352,7 @@ fn doctest_replace_try_expr_with_match() {\n     check_doc_test(\n         \"replace_try_expr_with_match\",\n         r#####\"\n-//- minicore:option\n+//- minicore: try, option\n fn handle() {\n     let pat = Some(true)$0?;\n }"}, {"sha": "70ec915e96745ba35295d86b98436a435df12141", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -5009,7 +5009,7 @@ fn foo() {\n fn hover_try_expr_res() {\n     check_hover_range(\n         r#\"\n-//- minicore:result\n+//- minicore: try, from, result\n struct FooError;\n \n fn foo() -> Result<(), FooError> {\n@@ -5023,7 +5023,7 @@ fn foo() -> Result<(), FooError> {\n     );\n     check_hover_range(\n         r#\"\n-//- minicore:result\n+//- minicore: try, from, result\n struct FooError;\n struct BarError;\n \n@@ -5044,6 +5044,7 @@ fn foo() -> Result<(), FooError> {\n fn hover_try_expr() {\n     check_hover_range(\n         r#\"\n+//- minicore: try\n struct NotResult<T, U>(T, U);\n struct Short;\n struct Looooong;\n@@ -5061,6 +5062,7 @@ fn foo() -> NotResult<(), Looooong> {\n     );\n     check_hover_range(\n         r#\"\n+//- minicore: try\n struct NotResult<T, U>(T, U);\n struct Short;\n struct Looooong;\n@@ -5092,7 +5094,7 @@ fn foo() -> Option<()> {\n \"#,\n         expect![[r#\"\n                 ```rust\n-                <Option<i32> as Try>::Output\n+                i32\n                 ```\"#]],\n     );\n }"}, {"sha": "8dd9f306c8a627f5efcc3c53a2999f8ae09fb607", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b9ae59a081f0ecbd11d66e205307328cd5cfbe/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=b7b9ae59a081f0ecbd11d66e205307328cd5cfbe", "patch": "@@ -181,7 +181,7 @@ pub mod convert {\n     }\n     // endregion:as_ref\n     // region:infallible\n-    pub enum Infallibe {}\n+    pub enum Infallible {}\n     // endregion:infallible\n }\n \n@@ -380,11 +380,15 @@ pub mod ops {\n     // endregion:fn\n     // region:try\n     mod try_ {\n+        use super::super::convert::Infallible;\n+\n         pub enum ControlFlow<B, C = ()> {\n+            #[lang = \"Continue\"]\n             Continue(C),\n+            #[lang = \"Break\"]\n             Break(B),\n         }\n-        pub trait FromResidual<R = Self::Residual> {\n+        pub trait FromResidual<R = <Self as Try>::Residual> {\n             #[lang = \"from_residual\"]\n             fn from_residual(residual: R) -> Self;\n         }\n@@ -400,14 +404,66 @@ pub mod ops {\n \n         impl<B, C> Try for ControlFlow<B, C> {\n             type Output = C;\n-            type Residual = ControlFlow<B, convert::Infallible>;\n+            type Residual = ControlFlow<B, Infallible>;\n             fn from_output(output: Self::Output) -> Self {}\n             fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {}\n         }\n \n         impl<B, C> FromResidual for ControlFlow<B, C> {\n-            fn from_residual(residual: ControlFlow<B, convert::Infallible>) -> Self {}\n+            fn from_residual(residual: ControlFlow<B, Infallible>) -> Self {}\n+        }\n+        // region:option\n+        impl<T> Try for Option<T> {\n+            type Output = T;\n+            type Residual = Option<Infallible>;\n+            fn from_output(output: Self::Output) -> Self {\n+                Some(output)\n+            }\n+            fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n+                match self {\n+                    Some(x) => ControlFlow::Continue(x),\n+                    None => ControlFlow::Break(None),\n+                }\n+            }\n+        }\n+\n+        impl<T> FromResidual for Option<T> {\n+            fn from_residual(x: Option<Infallible>) -> Self {\n+                match x {\n+                    None => None,\n+                }\n+            }\n+        }\n+        // endregion:option\n+        // region:result\n+        // region:from\n+        use super::super::convert::From;\n+\n+        impl<T, E> Try for Result<T, E> {\n+            type Output = T;\n+            type Residual = Result<Infallible, E>;\n+\n+            fn from_output(output: Self::Output) -> Self {\n+                Ok(output)\n+            }\n+\n+            fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n+                match self {\n+                    Ok(v) => ControlFlow::Continue(v),\n+                    Err(e) => ControlFlow::Break(Err(e)),\n+                }\n+            }\n+        }\n+\n+        impl<T, E, F: From<E>> FromResidual<Result<Infallible, E>> for Result<T, F> {\n+            fn from_residual(residual: Result<Infallible, E>) -> Self {\n+                match residual {\n+                    Err(e) => Err(From::from(e)),\n+                }\n+            }\n         }\n+        // endregion:from\n+        // endregion:result\n     }\n     pub use self::try_::{ControlFlow, FromResidual, Try};\n     // endregion:try"}]}