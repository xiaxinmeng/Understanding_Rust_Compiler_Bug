{"sha": "3bb3278e53f44e413101501043d86764037a8ca2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiYjMyNzhlNTNmNDRlNDEzMTAxNTAxMDQzZDg2NzY0MDM3YThjYTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-11-22T21:05:13Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-12-20T10:37:15Z"}, "message": "revert a lot of the changes to method probe internals", "tree": {"sha": "e4f2e1046eb80acab65b97e249d95cb4f9ca6b7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4f2e1046eb80acab65b97e249d95cb4f9ca6b7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bb3278e53f44e413101501043d86764037a8ca2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bb3278e53f44e413101501043d86764037a8ca2", "html_url": "https://github.com/rust-lang/rust/commit/3bb3278e53f44e413101501043d86764037a8ca2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bb3278e53f44e413101501043d86764037a8ca2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec5847a698bc3d64bd419a872d3c60e100999406", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec5847a698bc3d64bd419a872d3c60e100999406", "html_url": "https://github.com/rust-lang/rust/commit/ec5847a698bc3d64bd419a872d3c60e100999406"}], "stats": {"total": 136, "additions": 47, "deletions": 89}, "files": [{"sha": "80437dcdbfe00cdccd6f0dfc942cbd07eb1d8ec9", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3bb3278e53f44e413101501043d86764037a8ca2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bb3278e53f44e413101501043d86764037a8ca2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=3bb3278e53f44e413101501043d86764037a8ca2", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let mode = probe::Mode::MethodCall;\n         let self_ty = self.resolve_type_vars_if_possible(&self_ty);\n-        let pick = self.probe_for_name(span, mode, method_name, self_ty, call_expr.id)?.remove(0);\n+        let pick = self.probe_for_name(span, mode, method_name, self_ty, call_expr.id)?;\n \n         if let Some(import_id) = pick.import_id {\n             self.tcx.used_trait_imports.borrow_mut().insert(import_id);\n@@ -328,8 +328,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         expr_id: ast::NodeId)\n                         -> Result<Def, MethodError<'tcx>> {\n         let mode = probe::Mode::Path;\n-        let picks = self.probe_for_name(span, mode, method_name, self_ty, expr_id)?;\n-        let pick = &picks[0];\n+        let pick = self.probe_for_name(span, mode, method_name, self_ty, expr_id)?;\n \n         if let Some(import_id) = pick.import_id {\n             self.tcx.used_trait_imports.borrow_mut().insert(import_id);"}, {"sha": "a1393aa882ea568373375ff937dad80602c123e4", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 45, "deletions": 86, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/3bb3278e53f44e413101501043d86764037a8ca2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bb3278e53f44e413101501043d86764037a8ca2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=3bb3278e53f44e413101501043d86764037a8ca2", "patch": "@@ -135,7 +135,7 @@ pub enum PickKind<'tcx> {\n                     ty::PolyTraitRef<'tcx>),\n }\n \n-pub type PickResult<'tcx> = Result<Vec<Pick<'tcx>>, MethodError<'tcx>>;\n+pub type PickResult<'tcx> = Result<Pick<'tcx>, MethodError<'tcx>>;\n \n #[derive(PartialEq, Eq, Copy, Clone, Debug)]\n pub enum Mode {\n@@ -175,8 +175,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             .iter()\n             .flat_map(|&method_name| {\n                 match self.probe_for_name(span, mode, method_name, self_ty, scope_expr_id) {\n-                    Ok(picks) => picks.into_iter().map(move |pick| pick.item).collect(),\n-                    Err(_) => vec![],\n+                    Ok(pick) => Some(pick.item),\n+                    Err(_) => None,\n                 }\n             })\n             .collect()\n@@ -219,7 +219,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // think cause spurious errors. Really though this part should\n         // take place in the `self.probe` below.\n         let steps = if mode == Mode::MethodCall {\n-            match self.create_steps(span, self_ty, &looking_for) {\n+            match self.create_steps(span, self_ty) {\n                 Some(steps) => steps,\n                 None => {\n                     return Err(MethodError::NoMatch(NoMatchData::new(Vec::new(),\n@@ -272,8 +272,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn create_steps(&self,\n                     span: Span,\n-                    self_ty: Ty<'tcx>,\n-                    looking_for: &LookingFor<'tcx>)\n+                    self_ty: Ty<'tcx>)\n                     -> Option<Vec<CandidateStep<'tcx>>> {\n         // FIXME: we don't need to create the entire steps in one pass\n \n@@ -288,12 +287,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             })\n             .collect();\n \n-        let final_ty = match looking_for {\n-            &LookingFor::MethodName(_) => autoderef.unambiguous_final_ty(),\n-            // Since ReturnType case tries to coerce the returned type to the\n-            // expected one, we need all the information!\n-            &LookingFor::ReturnType(_) => self_ty,\n-        };\n+        let final_ty = autoderef.unambiguous_final_ty();\n         match final_ty.sty {\n             ty::TyArray(elem_ty, _) => {\n                 let dereferences = steps.len() - 1;\n@@ -935,8 +929,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             LookingFor::ReturnType(_) => false,\n         });\n \n-        if let Some(ret) = self.pick_core() {\n-            return ret;\n+        if let Some(r) = self.pick_core() {\n+            return r;\n         }\n \n         let static_candidates = mem::replace(&mut self.static_candidates, vec![]);\n@@ -956,21 +950,21 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             //Some(Ok(p)) => p.iter().map(|p| p.item.container().id()).collect(),\n             Some(Err(MethodError::Ambiguity(v))) => {\n                 v.into_iter()\n-                .map(|source| {\n-                    match source {\n-                        TraitSource(id) => id,\n-                        ImplSource(impl_id) => {\n-                            match tcx.trait_id_of_impl(impl_id) {\n-                                Some(id) => id,\n-                                None => {\n-                                    span_bug!(span,\n-                                              \"found inherent method when looking at traits\")\n+                    .map(|source| {\n+                        match source {\n+                            TraitSource(id) => id,\n+                            ImplSource(impl_id) => {\n+                                match tcx.trait_id_of_impl(impl_id) {\n+                                    Some(id) => id,\n+                                    None => {\n+                                        span_bug!(span,\n+                                                  \"found inherent method when looking at traits\")\n+                                    }\n                                 }\n                             }\n                         }\n-                    }\n-                })\n-                .collect()\n+                    })\n+                    .collect()\n             }\n             Some(Err(MethodError::NoMatch(NoMatchData { out_of_scope_traits: others, .. }))) => {\n                 assert!(others.is_empty());\n@@ -997,9 +991,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         let steps = self.steps.clone();\n \n         // find the first step that works\n-        steps.iter()\n-             .filter_map(|step| self.pick_step(step))\n-             .next()\n+        steps.iter().filter_map(|step| self.pick_step(step)).next()\n     }\n \n     fn pick_step(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> {\n@@ -1030,18 +1022,16 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         }\n \n         self.pick_method(step.self_ty).map(|r| {\n-            r.map(|mut picks| {\n-                for pick in picks.iter_mut() {\n-                    pick.autoderefs = step.autoderefs;\n-\n-                    // Insert a `&*` or `&mut *` if this is a reference type:\n-                    if let ty::TyRef(_, mt) = step.self_ty.sty {\n-                        pick.autoderefs += 1;\n-                        pick.autoref = Some(mt.mutbl);\n-                    }\n+            r.map(|mut pick| {\n+                pick.autoderefs = step.autoderefs;\n+\n+                // Insert a `&*` or `&mut *` if this is a reference type:\n+                if let ty::TyRef(_, mt) = step.self_ty.sty {\n+                    pick.autoderefs += 1;\n+                    pick.autoref = Some(mt.mutbl);\n                 }\n \n-                picks\n+                pick\n             })\n         })\n     }\n@@ -1054,44 +1044,28 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         let region = tcx.mk_region(ty::ReErased);\n \n         // Search through mutabilities in order to find one where pick works:\n-        let mut elements = [hir::MutImmutable, hir::MutMutable];\n-        let mut it = elements\n-            .iter_mut()\n-            .filter_map(|&mut m| {\n+        [hir::MutImmutable, hir::MutMutable]\n+            .iter()\n+            .filter_map(|&m| {\n                 let autoref_ty = tcx.mk_ref(region,\n                                             ty::TypeAndMut {\n                                                 ty: step.self_ty,\n                                                 mutbl: m,\n                                             });\n                 self.pick_method(autoref_ty).map(|r| {\n-                    r.map(|mut picks| {\n-                        for pick in picks.iter_mut() {\n-                            pick.autoderefs = step.autoderefs;\n-                            pick.autoref = Some(m);\n-                            pick.unsize = if step.unsize {\n-                                Some(step.self_ty)\n-                            } else {\n-                                None\n-                            };\n-                        }\n-                        picks\n+                    r.map(|mut pick| {\n+                        pick.autoderefs = step.autoderefs;\n+                        pick.autoref = Some(m);\n+                        pick.unsize = if step.unsize {\n+                            Some(step.self_ty)\n+                        } else {\n+                            None\n+                        };\n+                        pick\n                     })\n                 })\n-            });\n-        match self.looking_for {\n-            LookingFor::MethodName(_) => it.nth(0),\n-            LookingFor::ReturnType(_) => {\n-                let ret = it.filter_map(|entry| entry.ok())\n-                            .flat_map(|v| v)\n-                            .collect::<Vec<_>>();\n-\n-                if ret.len() < 1 {\n-                    None\n-                } else {\n-                    Some(Ok(ret))\n-                }\n-            }\n-        }\n+            })\n+            .nth(0)\n     }\n \n     fn pick_method(&mut self, self_ty: Ty<'tcx>) -> Option<PickResult<'tcx>> {\n@@ -1130,7 +1104,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         if applicable_candidates.len() > 1 {\n             match self.collapse_candidates_to_trait_pick(&applicable_candidates[..]) {\n                 Some(pick) => {\n-                    return Some(Ok(vec![pick]));\n+                    return Some(Ok(pick));\n                 }\n                 None => {}\n             }\n@@ -1141,22 +1115,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             return Some(Err(MethodError::Ambiguity(sources)));\n         }\n \n-        match self.looking_for {\n-            LookingFor::MethodName(_) => applicable_candidates\n-                .pop()\n-                .map(|probe| Ok(vec![probe.to_unadjusted_pick()])),\n-            LookingFor::ReturnType(_) => {\n-                let ret: Vec<_> = applicable_candidates.iter()\n-                                                       .map(|probe| probe.to_unadjusted_pick())\n-                                                       .collect();\n-\n-                if ret.len() < 1 {\n-                    None\n-                } else {\n-                    Some(Ok(ret))\n-                }\n-            }\n-        }\n+        applicable_candidates.pop().map(|probe| Ok(probe.to_unadjusted_pick()))\n     }\n \n     fn consider_probe(&self,"}]}