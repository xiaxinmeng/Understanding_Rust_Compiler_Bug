{"sha": "07adeee6e942a639af81f7cd4c035e066433cef0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3YWRlZWU2ZTk0MmE2MzlhZjgxZjdjZDRjMDM1ZTA2NjQzM2NlZjA=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-05-04T05:17:15Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-05-04T05:20:34Z"}, "message": "Added check for zero bitmask and uncommon directions, wrong comment in needless_bool corrected, added new lint vec_ptr_arg + test", "tree": {"sha": "197e0bf0d482508a735ffea5c59ca4f704c3201c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/197e0bf0d482508a735ffea5c59ca4f704c3201c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07adeee6e942a639af81f7cd4c035e066433cef0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07adeee6e942a639af81f7cd4c035e066433cef0", "html_url": "https://github.com/rust-lang/rust/commit/07adeee6e942a639af81f7cd4c035e066433cef0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07adeee6e942a639af81f7cd4c035e066433cef0/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53fa76dff968787fc39e7a6b96059f151bab6b2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/53fa76dff968787fc39e7a6b96059f151bab6b2e", "html_url": "https://github.com/rust-lang/rust/commit/53fa76dff968787fc39e7a6b96059f151bab6b2e"}], "stats": {"total": 134, "additions": 130, "deletions": 4}, "files": [{"sha": "d4cdc9526613ccdb13e2d8aacb02a8820263b0b6", "filename": "src/bit_mask.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/07adeee6e942a639af81f7cd4c035e066433cef0/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07adeee6e942a639af81f7cd4c035e066433cef0/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=07adeee6e942a639af81f7cd4c035e066433cef0", "patch": "@@ -43,12 +43,31 @@ impl LintPass for BitMask {\n     fn check_expr(&mut self, cx: &Context, e: &Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n \t\t\tif is_comparison_binop(cmp.node) {\n-\t\t\t\tfetch_int_literal(cx, right).map(|cmp_value| check_compare(cx, left, cmp.node, cmp_value, &e.span));\n+\t\t\t\tlet cmp_opt = fetch_int_literal(cx, right);\n+\t\t\t\tif cmp_opt.is_some() {\n+\t\t\t\t\tcheck_compare(cx, left, cmp.node, cmp_opt.unwrap(), &e.span);\n+\t\t\t\t} else {\n+\t\t\t\t\tfetch_int_literal(cx, left).map(|cmp_val| \n+\t\t\t\t\t\tcheck_compare(cx, right, invert_cmp(cmp.node), cmp_val, &e.span));\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n     }\n }\n \n+fn invert_cmp(cmp : BinOp_) -> BinOp_ {\n+\tmatch cmp {\n+\t\tBiEq => BiEq,\n+\t\tBiNe => BiNe,\n+\t\tBiLt => BiGt,\n+\t\tBiGt => BiLt,\n+\t\tBiLe => BiGe,\n+\t\tBiGe => BiLe,\n+\t\t_ => BiOr // Dummy\n+\t}\n+}\n+\n+\n fn check_compare(cx: &Context, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u64, span: &Span) {\n \tmatch &bit_op.node {\n \t\t&ExprParen(ref subexp) => check_compare(cx, subexp, cmp_op, cmp_value, span),\n@@ -70,6 +89,10 @@ fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_, mask_value: u64,\n \t\t\tBiBitAnd => if mask_value & cmp_value != mask_value {\n \t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, &format!(\"incompatible bit mask: _ & {} can never be equal to {}\", mask_value,\n \t\t\t\t\tcmp_value));\n+\t\t\t} else { \n+\t\t\t\tif mask_value == 0 {\n+\t\t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, &format!(\"&-masking with zero\"));\n+\t\t\t\t}\n \t\t\t},\n \t\t\tBiBitOr => if mask_value | cmp_value != cmp_value {\n \t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, &format!(\"incompatible bit mask: _ | {} can never be equal to {}\", mask_value,\n@@ -81,6 +104,10 @@ fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_, mask_value: u64,\n \t\t\tBiBitAnd => if mask_value < cmp_value {\n \t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, &format!(\"incompatible bit mask: _ & {} will always be lower than {}\", mask_value,\n \t\t\t\t\tcmp_value));\n+\t\t\t} else { \n+\t\t\t\tif mask_value == 0 {\n+\t\t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, &format!(\"&-masking with zero\"));\n+\t\t\t\t}\n \t\t\t},\n \t\t\tBiBitOr => if mask_value >= cmp_value {\n \t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, &format!(\"incompatible bit mask: _ | {} will never be lower than {}\", mask_value,\n@@ -92,6 +119,10 @@ fn check_bit_mask(cx: &Context, bit_op: BinOp_, cmp_op: BinOp_, mask_value: u64,\n \t\t\tBiBitAnd => if mask_value <= cmp_value {\n \t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, &format!(\"incompatible bit mask: _ & {} will never be higher than {}\", mask_value,\n \t\t\t\t\tcmp_value));\n+\t\t\t} else { \n+\t\t\t\tif mask_value == 0 {\n+\t\t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, &format!(\"&-masking with zero\"));\n+\t\t\t\t}\n \t\t\t},\n \t\t\tBiBitOr => if mask_value > cmp_value {\n \t\t\t\tcx.span_lint(BAD_BIT_MASK, *span, &format!(\"incompatible bit mask: _ | {} will always be higher than {}\", mask_value,"}, {"sha": "a9faf199863b5d4c961d27eebcd96d2e3e30b4fc", "filename": "src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/07adeee6e942a639af81f7cd4c035e066433cef0/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07adeee6e942a639af81f7cd4c035e066433cef0/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=07adeee6e942a639af81f7cd4c035e066433cef0", "patch": "@@ -19,6 +19,7 @@ pub mod misc;\n pub mod eq_op;\n pub mod bit_mask;\n pub mod needless_bool;\n+pub mod vec_ptr_arg;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n@@ -29,9 +30,13 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_lint_pass(box eq_op::EqOp as LintPassObject);\n     reg.register_lint_pass(box bit_mask::BitMask as LintPassObject);\n     reg.register_lint_pass(box needless_bool::NeedlessBool as LintPassObject);\n+    reg.register_lint_pass(box vec_ptr_arg::VecPtrArg as LintPassObject);\n+    \n     reg.register_lint_group(\"clippy\", vec![types::BOX_VEC, types::LINKEDLIST,\n                                            misc::SINGLE_MATCH, misc::STR_TO_STRING,\n                                            misc::TOPLEVEL_REF_ARG, eq_op::EQ_OP,\n                                            bit_mask::BAD_BIT_MASK, \n-                                           needless_bool::NEEDLESS_BOOL]);\n+                                           needless_bool::NEEDLESS_BOOL,\n+                                           vec_ptr_arg::VEC_PTR_ARG\n+                                           ]);\n }"}, {"sha": "fe35e6ee3bd460414d8ef2243a343eaf48fbd590", "filename": "src/needless_bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07adeee6e942a639af81f7cd4c035e066433cef0/src%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07adeee6e942a639af81f7cd4c035e066433cef0/src%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_bool.rs?ref=07adeee6e942a639af81f7cd4c035e066433cef0", "patch": "@@ -1,6 +1,6 @@\n //! Checks for needless boolean results of if-else expressions\n //!\n-//! This lint is **deny** by default\n+//! This lint is **warn** by default\n \n use rustc::plugin::Registry;\n use rustc::lint::*;"}, {"sha": "88fdc5cf0653258a50f14c6bda5e99d62ab23869", "filename": "src/vec_ptr_arg.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/07adeee6e942a639af81f7cd4c035e066433cef0/src%2Fvec_ptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07adeee6e942a639af81f7cd4c035e066433cef0/src%2Fvec_ptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvec_ptr_arg.rs?ref=07adeee6e942a639af81f7cd4c035e066433cef0", "patch": "@@ -0,0 +1,65 @@\n+//! Checks for usage of &Vec[_] and &String\n+//!\n+//! This lint is **warn** by default\n+\n+use rustc::plugin::Registry;\n+use rustc::lint::*;\n+use rustc::middle::const_eval::lookup_const_by_id;\n+use rustc::middle::def::*;\n+use syntax::ast::*;\n+use syntax::ast_util::{is_comparison_binop, binop_to_string};\n+use syntax::ptr::P;\n+use syntax::codemap::Span;\n+use types::match_ty_unwrap;\n+\n+declare_lint! {\n+    pub VEC_PTR_ARG,\n+    Allow,\n+    \"Warn on declaration of a &Vec-typed method argument\"\n+}\n+\n+\n+#[derive(Copy,Clone)]\n+pub struct VecPtrArg;\n+\n+impl LintPass for VecPtrArg {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(VEC_PTR_ARG)\n+    }\n+    \n+    fn check_item(&mut self, cx: &Context, item: &Item) {\n+\t\tif let &ItemFn(ref decl, _, _, _, _) = &item.node {\n+\t\t\tcheck_fn(cx, decl);\n+\t\t}\n+\t}\n+    \n+    fn check_impl_item(&mut self, cx: &Context, item: &ImplItem) { \n+\t\tif let &MethodImplItem(ref sig, _) = &item.node {\n+\t\t\tcheck_fn(cx, &sig.decl);\n+\t\t}\n+\t}\n+        \n+\tfn check_trait_item(&mut self, cx: &Context, item: &TraitItem) {\n+\t\tif let &MethodTraitItem(ref sig, _) = &item.node {\n+\t\t\tcheck_fn(cx, &sig.decl);\n+\t\t}\n+\t}\n+}\n+\n+fn check_fn(cx: &Context, decl: &FnDecl) {\n+\tfor arg in &decl.inputs {\n+\t\tlet ty = &arg.ty;\n+\t\tmatch ty.node {\n+\t\t\tTyPtr(ref pty) => check_ptr_subtype(cx, ty.span, &pty.ty),\n+\t\t\tTyRptr(_, ref rpty) => check_ptr_subtype(cx, ty.span, &rpty.ty),\n+\t\t\t_ => ()\n+\t\t}\n+\t}\n+}\n+\n+fn check_ptr_subtype(cx: &Context, span: Span, ty: &Ty) {\n+\tif match_ty_unwrap(ty, &[\"Vec\"]).is_some() { \n+\t\tcx.span_lint(VEC_PTR_ARG, span, \n+\t\t\t\"Writing '&Vec<_>' instead of '&[_]' involves one more reference and cannot be used with non-vec-based slices. Consider changing the type to &[...]\");\n+\t}\n+}"}, {"sha": "b575dbc4e2563993efdf88fe794afc001bde2310", "filename": "tests/compile-fail/bit_masks.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/07adeee6e942a639af81f7cd4c035e066433cef0/tests%2Fcompile-fail%2Fbit_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07adeee6e942a639af81f7cd4c035e066433cef0/tests%2Fcompile-fail%2Fbit_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbit_masks.rs?ref=07adeee6e942a639af81f7cd4c035e066433cef0", "patch": "@@ -7,12 +7,15 @@ const EVEN_MORE_REDIRECTION : i64 = THREE_BITS;\n #[deny(bad_bit_mask)]\n fn main() {\n \tlet x = 5;\n+\t\n+\tx & 0 == 0; //~ERROR &-masking with zero\n \tx & 1 == 1; //ok, distinguishes bit 0\n \tx & 2 == 1; //~ERROR\n+\tx | 0 == 0; //ok, equals x == 0 (maybe warn?)\n \tx | 1 == 3; //ok, equals x == 2 || x == 3\n \tx | 3 == 3; //ok, equals x <= 3\n \tx | 3 == 2; //~ERROR\n-\t\n+\n \tx & 1 > 1; //~ERROR\n \tx & 2 > 1; // ok, distinguishes x & 2 == 2 from x & 2 == 0\n \tx & 2 < 1; // ok, distinguishes x & 2 == 2 from x & 2 == 0\n@@ -23,4 +26,12 @@ fn main() {\n \t// this also now works with constants\n \tx & THREE_BITS == 8; //~ERROR\n \tx | EVEN_MORE_REDIRECTION < 7; //~ERROR\n+\t\n+\t0 & x == 0; //~ERROR\n+\t1 | x > 1;\n+\t\n+\t// and should now also match uncommon usage\n+\t1 < 2 | x; //~ERROR\n+\t2 == 3 | x; //~ERROR\n+\t1 == x & 2; //~ERROR\n }"}, {"sha": "5c4338e356ffc136bc7c7d358823d6a83835fe0f", "filename": "tests/compile-fail/vec_ptr_arg.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/07adeee6e942a639af81f7cd4c035e066433cef0/tests%2Fcompile-fail%2Fvec_ptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07adeee6e942a639af81f7cd4c035e066433cef0/tests%2Fcompile-fail%2Fvec_ptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvec_ptr_arg.rs?ref=07adeee6e942a639af81f7cd4c035e066433cef0", "patch": "@@ -0,0 +1,14 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#[deny(vec_ptr_arg)]\n+#[allow(unused)]\n+fn go(x: &Vec<i64>) { //~ERROR: Writing '&Vec<_>' instead of '&[_]'\n+\t//Nothing here\n+}\n+\n+\n+fn main() {\n+\tlet x = vec![1i64, 2, 3];\n+\tgo(&x);\n+}"}]}