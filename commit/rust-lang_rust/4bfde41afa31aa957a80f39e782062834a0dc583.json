{"sha": "4bfde41afa31aa957a80f39e782062834a0dc583", "node_id": "C_kwDOAAsO6NoAKDRiZmRlNDFhZmEzMWFhOTU3YTgwZjM5ZTc4MjA2MjgzNGEwZGM1ODM", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-03-21T08:24:57Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-03-21T08:24:57Z"}, "message": "Merge from rustc", "tree": {"sha": "e560ed4646bc001322d9bfa3f1ad38f16e39fa2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e560ed4646bc001322d9bfa3f1ad38f16e39fa2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bfde41afa31aa957a80f39e782062834a0dc583", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bfde41afa31aa957a80f39e782062834a0dc583", "html_url": "https://github.com/rust-lang/rust/commit/4bfde41afa31aa957a80f39e782062834a0dc583", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bfde41afa31aa957a80f39e782062834a0dc583/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2be2568a54540a8ddf2c9c77a20ec73b018b45cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/2be2568a54540a8ddf2c9c77a20ec73b018b45cc", "html_url": "https://github.com/rust-lang/rust/commit/2be2568a54540a8ddf2c9c77a20ec73b018b45cc"}, {"sha": "204807d8a93041f9ef69cc2a69646fe1020f4c9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/204807d8a93041f9ef69cc2a69646fe1020f4c9c", "html_url": "https://github.com/rust-lang/rust/commit/204807d8a93041f9ef69cc2a69646fe1020f4c9c"}], "stats": {"total": 6665, "additions": 4892, "deletions": 1773}, "files": [{"sha": "b45246eb4ead81fde9f90d6857f73617d7395b97", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -48,19 +48,19 @@ jobs:\n         include:\n           - name: mingw-check\n             tidy: false\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: mingw-check-tidy\n             tidy: true\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: x86_64-gnu-llvm-14\n             tidy: false\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: x86_64-gnu-tools\n             tidy: false\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n     timeout-minutes: 600\n     runs-on: \"${{ matrix.os }}\"\n@@ -181,136 +181,136 @@ jobs:\n               - ARM64\n               - linux\n           - name: arm-android\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: armhf-gnu\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-aarch64-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-android\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-arm-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-armhf-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-armv7-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-i586-gnu-i586-i686-musl\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-i686-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-mips-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-mips64-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-mips64el-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-mipsel-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-powerpc-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-powerpc64-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-powerpc64le-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-riscv64-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-s390x-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-various-1\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-various-2\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-x86_64-freebsd\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-x86_64-illumos\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-x86_64-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-x86_64-linux-alt\n             env:\n               IMAGE: dist-x86_64-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n           - name: dist-x86_64-musl\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-x86_64-netbsd\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: i686-gnu\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: i686-gnu-nopt\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: mingw-check\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: test-various\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: wasm32\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: x86_64-gnu\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: x86_64-gnu-stable\n             env:\n               IMAGE: x86_64-gnu\n               RUST_CI_OVERRIDE_RELEASE_CHANNEL: stable\n               CI_ONLY_WHEN_CHANNEL: nightly\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n           - name: x86_64-gnu-aux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: x86_64-gnu-debug\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: x86_64-gnu-distcheck\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: x86_64-gnu-llvm-15\n             env:\n               RUST_BACKTRACE: 1\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n           - name: x86_64-gnu-llvm-14\n             env:\n               RUST_BACKTRACE: 1\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n           - name: x86_64-gnu-llvm-14-stage1\n             env:\n               RUST_BACKTRACE: 1\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n           - name: x86_64-gnu-nopt\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: x86_64-gnu-tools\n             env:\n               DEPLOY_TOOLSTATES_JSON: toolstates-linux.json\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n           - name: dist-x86_64-apple\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths --host=x86_64-apple-darwin --target=x86_64-apple-darwin\"\n@@ -386,101 +386,101 @@ jobs:\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-profiler\"\n               SCRIPT: make ci-subset-1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: x86_64-msvc-2\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-profiler\"\n               SCRIPT: make ci-subset-2\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: i686-msvc-1\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-msvc\"\n               SCRIPT: make ci-subset-1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: i686-msvc-2\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-msvc\"\n               SCRIPT: make ci-subset-2\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: x86_64-msvc-cargo\n             env:\n               SCRIPT: python x.py --stage 2 test src/tools/cargotest src/tools/cargo\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-lld\"\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: x86_64-msvc-tools\n             env:\n               SCRIPT: src/ci/docker/host-x86_64/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstate/toolstates.json windows\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstate/toolstates.json\"\n               DEPLOY_TOOLSTATES_JSON: toolstates-windows.json\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: i686-mingw-1\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu\"\n               SCRIPT: make ci-mingw-subset-1\n               NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: i686-mingw-2\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu\"\n               SCRIPT: make ci-mingw-subset-2\n               NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: x86_64-mingw-1\n             env:\n               SCRIPT: make ci-mingw-subset-1\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-profiler\"\n               NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: x86_64-mingw-2\n             env:\n               SCRIPT: make ci-mingw-subset-2\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-profiler\"\n               NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: dist-x86_64-msvc\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=x86_64-pc-windows-msvc --target=x86_64-pc-windows-msvc --enable-full-tools --enable-profiler\"\n               SCRIPT: PGO_HOST=x86_64-pc-windows-msvc python src/ci/stage-build.py python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: dist-i686-msvc\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-msvc --host=i686-pc-windows-msvc --target=i686-pc-windows-msvc,i586-pc-windows-msvc --enable-full-tools --enable-profiler\"\n               SCRIPT: python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: dist-aarch64-msvc\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=aarch64-pc-windows-msvc --enable-full-tools --enable-profiler\"\n               SCRIPT: python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n               WINDOWS_SDK_20348_HACK: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: dist-i686-mingw\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu --enable-full-tools --enable-profiler\"\n               NO_DOWNLOAD_CI_LLVM: 1\n               SCRIPT: python x.py dist bootstrap --include-default-paths\n               CUSTOM_MINGW: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: dist-x86_64-mingw\n             env:\n               SCRIPT: python x.py dist bootstrap --include-default-paths\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-full-tools --enable-profiler\"\n               NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: dist-x86_64-msvc-alt\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\"\n               SCRIPT: python x.py dist bootstrap --include-default-paths\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n     timeout-minutes: 600\n     runs-on: \"${{ matrix.os }}\"\n     steps:\n@@ -595,7 +595,7 @@ jobs:\n       matrix:\n         include:\n           - name: dist-x86_64-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n     timeout-minutes: 600\n     runs-on: \"${{ matrix.os }}\""}, {"sha": "485968d9c56ff5a3a37c74b331704914da82011c", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -21,6 +21,7 @@ Session.vim\n .project\n .favorites.json\n .settings/\n+.vs/\n \n ## Tool\n .valgrindrc"}, {"sha": "61f2cfb9e22c42b9d77e3f2b7ebf4dac38ee3cd1", "filename": "Cargo.lock", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -898,7 +898,7 @@ dependencies = [\n  \"tracing-subscriber\",\n  \"unified-diff\",\n  \"walkdir\",\n- \"winapi\",\n+ \"windows 0.46.0\",\n ]\n \n [[package]]\n@@ -2273,7 +2273,7 @@ dependencies = [\n  \"dirs\",\n  \"gix-path\",\n  \"libc\",\n- \"windows\",\n+ \"windows 0.43.0\",\n ]\n \n [[package]]\n@@ -3103,9 +3103,9 @@ dependencies = [\n \n [[package]]\n name = \"mdbook\"\n-version = \"0.4.25\"\n+version = \"0.4.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d1ed28d5903dde77bd5182645078a37ee57014cac6ccb2d54e1d6496386648e4\"\n+checksum = \"764dcbfc2e5f868bc1b566eb179dff1a06458fd0cff846aae2579392dd3f01a0\"\n dependencies = [\n  \"ammonia\",\n  \"anyhow\",\n@@ -4529,7 +4529,7 @@ dependencies = [\n  \"tempfile\",\n  \"thin-vec\",\n  \"tracing\",\n- \"winapi\",\n+ \"windows 0.46.0\",\n ]\n \n [[package]]\n@@ -4588,7 +4588,7 @@ dependencies = [\n  \"rustc_ty_utils\",\n  \"serde_json\",\n  \"tracing\",\n- \"winapi\",\n+ \"windows 0.46.0\",\n ]\n \n [[package]]\n@@ -4636,7 +4636,7 @@ dependencies = [\n  \"termize\",\n  \"tracing\",\n  \"unicode-width\",\n- \"winapi\",\n+ \"windows 0.46.0\",\n ]\n \n [[package]]\n@@ -5277,7 +5277,7 @@ dependencies = [\n  \"smallvec\",\n  \"termize\",\n  \"tracing\",\n- \"winapi\",\n+ \"windows 0.46.0\",\n ]\n \n [[package]]\n@@ -6908,6 +6908,15 @@ dependencies = [\n  \"windows_x86_64_msvc\",\n ]\n \n+[[package]]\n+name = \"windows\"\n+version = \"0.46.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cdacb41e6a96a052c6cb63a144f24900236121c6f63f4f8219fef5977ecb0c25\"\n+dependencies = [\n+ \"windows-targets\",\n+]\n+\n [[package]]\n name = \"windows-sys\"\n version = \"0.42.0\"\n@@ -6934,9 +6943,9 @@ dependencies = [\n \n [[package]]\n name = \"windows-targets\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8e2522491fbfcd58cc84d47aeb2958948c4b8982e9a2d8a2a35bbaed431390e7\"\n+checksum = \"8e5180c00cd44c9b1c88adb3693291f1cd93605ded80c250a75d472756b4d071\"\n dependencies = [\n  \"windows_aarch64_gnullvm\",\n  \"windows_aarch64_msvc\",\n@@ -6949,45 +6958,45 @@ dependencies = [\n \n [[package]]\n name = \"windows_aarch64_gnullvm\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8c9864e83243fdec7fc9c5444389dcbbfd258f745e7853198f365e3c4968a608\"\n+checksum = \"597a5118570b68bc08d8d59125332c54f1ba9d9adeedeef5b99b02ba2b0698f8\"\n \n [[package]]\n name = \"windows_aarch64_msvc\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c8b1b673ffc16c47a9ff48570a9d85e25d265735c503681332589af6253c6c7\"\n+checksum = \"e08e8864a60f06ef0d0ff4ba04124db8b0fb3be5776a5cd47641e942e58c4d43\"\n \n [[package]]\n name = \"windows_i686_gnu\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"de3887528ad530ba7bdbb1faa8275ec7a1155a45ffa57c37993960277145d640\"\n+checksum = \"c61d927d8da41da96a81f029489353e68739737d3beca43145c8afec9a31a84f\"\n \n [[package]]\n name = \"windows_i686_msvc\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bf4d1122317eddd6ff351aa852118a2418ad4214e6613a50e0191f7004372605\"\n+checksum = \"44d840b6ec649f480a41c8d80f9c65108b92d89345dd94027bfe06ac444d1060\"\n \n [[package]]\n name = \"windows_x86_64_gnu\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c1040f221285e17ebccbc2591ffdc2d44ee1f9186324dd3e84e99ac68d699c45\"\n+checksum = \"8de912b8b8feb55c064867cf047dda097f92d51efad5b491dfb98f6bbb70cb36\"\n \n [[package]]\n name = \"windows_x86_64_gnullvm\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"628bfdf232daa22b0d64fdb62b09fcc36bb01f05a3939e20ab73aaf9470d0463\"\n+checksum = \"26d41b46a36d453748aedef1486d5c7a85db22e56aff34643984ea85514e94a3\"\n \n [[package]]\n name = \"windows_x86_64_msvc\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"447660ad36a13288b1db4d4248e857b510e8c3a225c822ba4fb748c0aafecffd\"\n+checksum = \"9aec5da331524158c6d1a4ac0ab1541149c0b9505fde06423b02f5ef0106b9f0\"\n \n [[package]]\n name = \"writeable\""}, {"sha": "151afd2d458b0484e36ea3fb4ac410c2f3e42ba9", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -8,7 +8,7 @@ use rustc_errors::Applicability;\n use rustc_expand::base::*;\n use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident, Symbol};\n-use rustc_span::Span;\n+use rustc_span::{FileNameDisplayPreference, Span};\n use std::iter;\n use thin_vec::{thin_vec, ThinVec};\n \n@@ -33,7 +33,23 @@ pub fn expand_test_case(\n     }\n \n     let sp = ecx.with_def_site_ctxt(attr_sp);\n-    let mut item = anno_item.expect_item();\n+    let (mut item, is_stmt) = match anno_item {\n+        Annotatable::Item(item) => (item, false),\n+        Annotatable::Stmt(stmt) if let ast::StmtKind::Item(_) = stmt.kind => if let ast::StmtKind::Item(i) = stmt.into_inner().kind {\n+            (i, true)\n+        } else {\n+            unreachable!()\n+        },\n+        _ => {\n+            ecx.struct_span_err(\n+                anno_item.span(),\n+                \"`#[test_case]` attribute is only allowed on items\",\n+            )\n+            .emit();\n+\n+            return vec![];\n+        }\n+    };\n     item = item.map(|mut item| {\n         let test_path_symbol = Symbol::intern(&item_path(\n             // skip the name of the root module\n@@ -50,7 +66,13 @@ pub fn expand_test_case(\n         item\n     });\n \n-    return vec![Annotatable::Item(item)];\n+    let ret = if is_stmt {\n+        Annotatable::Stmt(P(ecx.stmt_item(item.span, item)))\n+    } else {\n+        Annotatable::Item(item)\n+    };\n+\n+    vec![ret]\n }\n \n pub fn expand_test(\n@@ -231,6 +253,8 @@ pub fn expand_test_or_bench(\n         &item.ident,\n     ));\n \n+    let location_info = get_location_info(cx, &item);\n+\n     let mut test_const = cx.item(\n         sp,\n         Ident::new(item.ident.name, sp),\n@@ -280,6 +304,16 @@ pub fn expand_test_or_bench(\n                                             cx.expr_none(sp)\n                                         },\n                                     ),\n+                                    // source_file: <relative_path_of_source_file>\n+                                    field(\"source_file\", cx.expr_str(sp, location_info.0)),\n+                                    // start_line: start line of the test fn identifier.\n+                                    field(\"start_line\", cx.expr_usize(sp, location_info.1)),\n+                                    // start_col: start column of the test fn identifier.\n+                                    field(\"start_col\", cx.expr_usize(sp, location_info.2)),\n+                                    // end_line: end line of the test fn identifier.\n+                                    field(\"end_line\", cx.expr_usize(sp, location_info.3)),\n+                                    // end_col: end column of the test fn identifier.\n+                                    field(\"end_col\", cx.expr_usize(sp, location_info.4)),\n                                     // compile_fail: true | false\n                                     field(\"compile_fail\", cx.expr_bool(sp, false)),\n                                     // no_run: true | false\n@@ -364,6 +398,19 @@ pub fn expand_test_or_bench(\n     }\n }\n \n+fn get_location_info(cx: &ExtCtxt<'_>, item: &ast::Item) -> (Symbol, usize, usize, usize, usize) {\n+    let span = item.ident.span;\n+    let (source_file, lo_line, lo_col, hi_line, hi_col) =\n+        cx.sess.source_map().span_to_location_info(span);\n+\n+    let file_name = match source_file {\n+        Some(sf) => sf.name.display(FileNameDisplayPreference::Remapped).to_string(),\n+        None => \"no-location\".to_string(),\n+    };\n+\n+    (Symbol::intern(&file_name), lo_line, lo_col, hi_line, hi_col)\n+}\n+\n fn item_path(mod_path: &[Ident], item_ident: &Ident) -> String {\n     mod_path\n         .iter()"}, {"sha": "6a0d0ca55c255e39e47643fe42c88d3087064c19", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -358,9 +358,9 @@ fn link_rlib<'a>(\n             let (data, _) = create_wrapper_file(sess, b\".bundled_lib\".to_vec(), &src);\n             let wrapper_file = emit_wrapper_file(sess, &data, tmpdir, filename.as_str());\n             packed_bundled_libs.push(wrapper_file);\n-        } else if let Some(name) = lib.name {\n+        } else {\n             let path =\n-                find_native_static_library(name.as_str(), lib.verbatim, &lib_search_paths, sess);\n+                find_native_static_library(lib.name.as_str(), lib.verbatim, &lib_search_paths, sess);\n             ab.add_archive(&path, Box::new(|_| false)).unwrap_or_else(|error| {\n                 sess.emit_fatal(errors::AddNativeLibrary { library_path: path, error })});\n         }\n@@ -436,7 +436,7 @@ fn collate_raw_dylibs<'a, 'b>(\n     for lib in used_libraries {\n         if lib.kind == NativeLibKind::RawDylib {\n             let ext = if lib.verbatim { \"\" } else { \".dll\" };\n-            let name = format!(\"{}{}\", lib.name.expect(\"unnamed raw-dylib library\"), ext);\n+            let name = format!(\"{}{}\", lib.name, ext);\n             let imports = dylib_table.entry(name.clone()).or_default();\n             for import in &lib.dll_imports {\n                 if let Some(old_import) = imports.insert(import.name, import) {\n@@ -1296,7 +1296,7 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n         .iter()\n         .filter(|l| relevant_lib(sess, l))\n         .filter_map(|lib| {\n-            let name = lib.name?;\n+            let name = lib.name;\n             match lib.kind {\n                 NativeLibKind::Static { bundle: Some(false), .. }\n                 | NativeLibKind::Dylib { .. }\n@@ -1317,6 +1317,7 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n                 // These are included, no need to print them\n                 NativeLibKind::Static { bundle: None | Some(true), .. }\n                 | NativeLibKind::LinkArg\n+                | NativeLibKind::WasmImportModule\n                 | NativeLibKind::RawDylib => None,\n             }\n         })\n@@ -2275,21 +2276,18 @@ fn add_native_libs_from_crate(\n \n     let mut last = (None, NativeLibKind::Unspecified, false);\n     for lib in native_libs {\n-        let Some(name) = lib.name else {\n-            continue;\n-        };\n         if !relevant_lib(sess, lib) {\n             continue;\n         }\n \n         // Skip if this library is the same as the last.\n-        last = if (lib.name, lib.kind, lib.verbatim) == last {\n+        last = if (Some(lib.name), lib.kind, lib.verbatim) == last {\n             continue;\n         } else {\n-            (lib.name, lib.kind, lib.verbatim)\n+            (Some(lib.name), lib.kind, lib.verbatim)\n         };\n \n-        let name = name.as_str();\n+        let name = lib.name.as_str();\n         let verbatim = lib.verbatim;\n         match lib.kind {\n             NativeLibKind::Static { bundle, whole_archive } => {\n@@ -2346,6 +2344,7 @@ fn add_native_libs_from_crate(\n             NativeLibKind::RawDylib => {\n                 // Handled separately in `linker_with_args`.\n             }\n+            NativeLibKind::WasmImportModule => {}\n             NativeLibKind::LinkArg => {\n                 if link_static {\n                     cmd.arg(name);"}, {"sha": "18d17b1a0137c1e027c2dcc4029b3712a5c6b1e6", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -595,7 +595,7 @@ fn wasm_import_module_map(tcx: TyCtxt<'_>, cnum: CrateNum) -> FxHashMap<DefId, S\n \n     let mut ret = FxHashMap::default();\n     for (def_id, lib) in tcx.foreign_modules(cnum).iter() {\n-        let module = def_id_to_native_lib.get(&def_id).and_then(|s| s.wasm_import_module);\n+        let module = def_id_to_native_lib.get(&def_id).and_then(|s| s.wasm_import_module());\n         let Some(module) = module else { continue };\n         ret.extend(lib.foreign_items.iter().map(|id| {\n             assert_eq!(id.krate, cnum);"}, {"sha": "81227b04e8a7efe0690b6a98db20af8883d593a3", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -118,7 +118,7 @@ bitflags::bitflags! {\n #[derive(Clone, Debug, Encodable, Decodable, HashStable)]\n pub struct NativeLib {\n     pub kind: NativeLibKind,\n-    pub name: Option<Symbol>,\n+    pub name: Symbol,\n     pub filename: Option<Symbol>,\n     pub cfg: Option<ast::MetaItem>,\n     pub verbatim: bool,"}, {"sha": "bdfc0aa1c30c7b9b2c3f07b4d759223dafd7102f", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1475,7 +1475,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> OperandRef<'tcx, Bx::Value> {\n         let tcx = bx.tcx();\n \n-        let mut span_to_caller_location = |span: Span| {\n+        let mut span_to_caller_location = |mut span: Span| {\n+            // Remove `Inlined` marks as they pollute `expansion_cause`.\n+            while span.is_inlined() {\n+                span.remove_mark();\n+            }\n             let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n             let caller = tcx.sess.source_map().lookup_char_pos(topmost.lo());\n             let const_loc = tcx.const_caller_location(("}, {"sha": "76c8d0a975ac0b882812f5345e2fff60d2ce9ae9", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -111,7 +111,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         location\n     }\n \n-    pub(crate) fn location_triple_for_span(&self, span: Span) -> (Symbol, u32, u32) {\n+    pub(crate) fn location_triple_for_span(&self, mut span: Span) -> (Symbol, u32, u32) {\n+        // Remove `Inlined` marks as they pollute `expansion_cause`.\n+        while span.is_inlined() {\n+            span.remove_mark();\n+        }\n         let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n         let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n         ("}, {"sha": "24cf9812a25a1ba226a6e279414b50fc52fb8f70", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -36,8 +36,15 @@ elsa = \"1.8\"\n [dependencies.parking_lot]\n version = \"0.11\"\n \n-[target.'cfg(windows)'.dependencies]\n-winapi = { version = \"0.3\", features = [\"fileapi\", \"psapi\", \"winerror\"] }\n+[target.'cfg(windows)'.dependencies.windows]\n+version = \"0.46.0\"\n+features = [\n+    \"Win32_Foundation\",\n+    \"Win32_Storage_FileSystem\",\n+    \"Win32_System_IO\",\n+    \"Win32_System_ProcessStatus\",\n+    \"Win32_System_Threading\",\n+]\n \n [target.'cfg(not(target_arch = \"wasm32\"))'.dependencies]\n memmap2 = \"0.2.1\""}, {"sha": "efdb44248d1d7ef98657be0b6c3cfd7448c5281b", "filename": "compiler/rustc_data_structures/src/flock.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_data_structures%2Fsrc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_data_structures%2Fsrc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflock.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -4,9 +4,6 @@\n //! green/native threading. This is just a bare-bones enough solution for\n //! librustdoc, it is not production quality at all.\n \n-#![allow(non_camel_case_types)]\n-#![allow(nonstandard_style)]\n-\n cfg_if! {\n     if #[cfg(target_os = \"linux\")] {\n         mod linux;\n@@ -16,7 +13,7 @@ cfg_if! {\n         use unix as imp;\n     } else if #[cfg(windows)] {\n         mod windows;\n-        use windows as imp;\n+        use self::windows as imp;\n     } else {\n         mod unsupported;\n         use unsupported as imp;"}, {"sha": "da128f464a607b59447316d8c404fe2bdd7b9548", "filename": "compiler/rustc_data_structures/src/flock/windows.rs", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Fwindows.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,13 +1,16 @@\n use std::fs::{File, OpenOptions};\n use std::io;\n-use std::mem;\n use std::os::windows::prelude::*;\n use std::path::Path;\n \n-use winapi::shared::winerror::ERROR_INVALID_FUNCTION;\n-use winapi::um::fileapi::LockFileEx;\n-use winapi::um::minwinbase::{LOCKFILE_EXCLUSIVE_LOCK, LOCKFILE_FAIL_IMMEDIATELY, OVERLAPPED};\n-use winapi::um::winnt::{FILE_SHARE_DELETE, FILE_SHARE_READ, FILE_SHARE_WRITE};\n+use windows::{\n+    Win32::Foundation::{ERROR_INVALID_FUNCTION, HANDLE},\n+    Win32::Storage::FileSystem::{\n+        LockFileEx, FILE_SHARE_DELETE, FILE_SHARE_READ, FILE_SHARE_WRITE, LOCKFILE_EXCLUSIVE_LOCK,\n+        LOCKFILE_FAIL_IMMEDIATELY, LOCK_FILE_FLAGS,\n+    },\n+    Win32::System::IO::OVERLAPPED,\n+};\n \n #[derive(Debug)]\n pub struct Lock {\n@@ -25,7 +28,7 @@ impl Lock {\n         let share_mode = FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE;\n \n         let mut open_options = OpenOptions::new();\n-        open_options.read(true).share_mode(share_mode);\n+        open_options.read(true).share_mode(share_mode.0);\n \n         if create {\n             open_options.create(true).write(true);\n@@ -43,33 +46,42 @@ impl Lock {\n             }\n         };\n \n-        let ret = unsafe {\n-            let mut overlapped: OVERLAPPED = mem::zeroed();\n+        let mut flags = LOCK_FILE_FLAGS::default();\n+        if !wait {\n+            flags |= LOCKFILE_FAIL_IMMEDIATELY;\n+        }\n \n-            let mut dwFlags = 0;\n-            if !wait {\n-                dwFlags |= LOCKFILE_FAIL_IMMEDIATELY;\n-            }\n+        if exclusive {\n+            flags |= LOCKFILE_EXCLUSIVE_LOCK;\n+        }\n \n-            if exclusive {\n-                dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;\n-            }\n+        let mut overlapped = OVERLAPPED::default();\n \n-            debug!(\"attempting to acquire lock on lock file `{}`\", p.display());\n-            LockFileEx(file.as_raw_handle(), dwFlags, 0, 0xFFFF_FFFF, 0xFFFF_FFFF, &mut overlapped)\n-        };\n-        if ret == 0 {\n-            let err = io::Error::last_os_error();\n-            debug!(\"failed acquiring file lock: {}\", err);\n-            Err(err)\n-        } else {\n-            debug!(\"successfully acquired lock\");\n-            Ok(Lock { _file: file })\n+        debug!(\"attempting to acquire lock on lock file `{}`\", p.display());\n+\n+        unsafe {\n+            LockFileEx(\n+                HANDLE(file.as_raw_handle() as isize),\n+                flags,\n+                0,\n+                u32::MAX,\n+                u32::MAX,\n+                &mut overlapped,\n+            )\n         }\n+        .ok()\n+        .map_err(|e| {\n+            let err = io::Error::from_raw_os_error(e.code().0);\n+            debug!(\"failed acquiring file lock: {}\", err);\n+            err\n+        })?;\n+\n+        debug!(\"successfully acquired lock\");\n+        Ok(Lock { _file: file })\n     }\n \n     pub fn error_unsupported(err: &io::Error) -> bool {\n-        err.raw_os_error() == Some(ERROR_INVALID_FUNCTION as i32)\n+        err.raw_os_error() == Some(ERROR_INVALID_FUNCTION.0 as i32)\n     }\n }\n "}, {"sha": "3d9c7f6eae276405b60ea82409165ce1bbaccda8", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -796,21 +796,26 @@ fn get_thread_id() -> u32 {\n cfg_if! {\n     if #[cfg(windows)] {\n         pub fn get_resident_set_size() -> Option<usize> {\n-            use std::mem::{self, MaybeUninit};\n-            use winapi::shared::minwindef::DWORD;\n-            use winapi::um::processthreadsapi::GetCurrentProcess;\n-            use winapi::um::psapi::{GetProcessMemoryInfo, PROCESS_MEMORY_COUNTERS};\n-\n-            let mut pmc = MaybeUninit::<PROCESS_MEMORY_COUNTERS>::uninit();\n-            match unsafe {\n-                GetProcessMemoryInfo(GetCurrentProcess(), pmc.as_mut_ptr(), mem::size_of_val(&pmc) as DWORD)\n-            } {\n-                0 => None,\n-                _ => {\n-                    let pmc = unsafe { pmc.assume_init() };\n-                    Some(pmc.WorkingSetSize as usize)\n-                }\n+            use std::mem;\n+\n+            use windows::{\n+                Win32::System::ProcessStatus::{K32GetProcessMemoryInfo, PROCESS_MEMORY_COUNTERS},\n+                Win32::System::Threading::GetCurrentProcess,\n+            };\n+\n+            let mut pmc = PROCESS_MEMORY_COUNTERS::default();\n+            let pmc_size = mem::size_of_val(&pmc);\n+            unsafe {\n+                K32GetProcessMemoryInfo(\n+                    GetCurrentProcess(),\n+                    &mut pmc,\n+                    pmc_size as u32,\n+                )\n             }\n+            .ok()\n+            .ok()?;\n+\n+            Some(pmc.WorkingSetSize)\n         }\n     } else if #[cfg(target_os = \"macos\")] {\n         pub fn get_resident_set_size() -> Option<usize> {"}, {"sha": "73a1f79a020f1da162ee5f2b6a6a5faeb9318906", "filename": "compiler/rustc_driver_impl/Cargo.toml", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_driver_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_driver_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2FCargo.toml?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -54,8 +54,11 @@ rustc_hir_analysis = { path = \"../rustc_hir_analysis\" }\n [target.'cfg(unix)'.dependencies]\n libc = \"0.2\"\n \n-[target.'cfg(windows)'.dependencies]\n-winapi = { version = \"0.3\", features = [\"consoleapi\", \"debugapi\", \"processenv\"] }\n+[target.'cfg(windows)'.dependencies.windows]\n+version = \"0.46.0\"\n+features = [\n+    \"Win32_System_Diagnostics_Debug\",\n+]\n \n [features]\n llvm = ['rustc_interface/llvm']"}, {"sha": "8634c64417654e115190895ce5f0a806d3e3b446", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1246,11 +1246,9 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     interface::try_print_query_stack(&handler, num_frames);\n \n     #[cfg(windows)]\n-    unsafe {\n-        if env::var(\"RUSTC_BREAK_ON_ICE\").is_ok() {\n-            // Trigger a debugger if we crashed during bootstrap\n-            winapi::um::debugapi::DebugBreak();\n-        }\n+    if env::var(\"RUSTC_BREAK_ON_ICE\").is_ok() {\n+        // Trigger a debugger if we crashed during bootstrap\n+        unsafe { windows::Win32::System::Diagnostics::Debug::DebugBreak() };\n     }\n }\n "}, {"sha": "e1ead08ea66bdf9dd4ad4919010627cb855e49d5", "filename": "compiler/rustc_errors/Cargo.toml", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2FCargo.toml?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -25,8 +25,14 @@ termize = \"0.1.1\"\n serde = { version = \"1.0.125\", features = [ \"derive\" ] }\n serde_json = \"1.0.59\"\n \n-[target.'cfg(windows)'.dependencies]\n-winapi = { version = \"0.3\", features = [ \"handleapi\", \"synchapi\", \"winbase\" ] }\n+[target.'cfg(windows)'.dependencies.windows]\n+version = \"0.46.0\"\n+features = [\n+    \"Win32_Foundation\",\n+    \"Win32_Security\",\n+    \"Win32_System_Threading\",\n+    \"Win32_System_WindowsProgramming\",\n+]\n \n [features]\n rustc_use_parallel_compiler = ['rustc_error_messages/rustc_use_parallel_compiler']"}, {"sha": "7db262abfde267ebb46dc85d49a19a3140446b9a", "filename": "compiler/rustc_errors/src/lock.rs", "status": "modified", "additions": 36, "deletions": 45, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_errors%2Fsrc%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_errors%2Fsrc%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flock.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -16,10 +16,12 @@ pub fn acquire_global_lock(name: &str) -> Box<dyn Any> {\n     use std::ffi::CString;\n     use std::io;\n \n-    use winapi::shared::ntdef::HANDLE;\n-    use winapi::um::handleapi::CloseHandle;\n-    use winapi::um::synchapi::{CreateMutexA, ReleaseMutex, WaitForSingleObject};\n-    use winapi::um::winbase::{INFINITE, WAIT_ABANDONED, WAIT_OBJECT_0};\n+    use windows::{\n+        core::PCSTR,\n+        Win32::Foundation::{CloseHandle, HANDLE, WAIT_ABANDONED, WAIT_OBJECT_0},\n+        Win32::System::Threading::{CreateMutexA, ReleaseMutex, WaitForSingleObject},\n+        Win32::System::WindowsProgramming::INFINITE,\n+    };\n \n     struct Handle(HANDLE);\n \n@@ -42,49 +44,38 @@ pub fn acquire_global_lock(name: &str) -> Box<dyn Any> {\n     }\n \n     let cname = CString::new(name).unwrap();\n-    unsafe {\n-        // Create a named mutex, with no security attributes and also not\n-        // acquired when we create it.\n-        //\n-        // This will silently create one if it doesn't already exist, or it'll\n-        // open up a handle to one if it already exists.\n-        let mutex = CreateMutexA(std::ptr::null_mut(), 0, cname.as_ptr());\n-        if mutex.is_null() {\n-            panic!(\n-                \"failed to create global mutex named `{}`: {}\",\n-                name,\n-                io::Error::last_os_error()\n-            );\n-        }\n-        let mutex = Handle(mutex);\n+    // Create a named mutex, with no security attributes and also not\n+    // acquired when we create it.\n+    //\n+    // This will silently create one if it doesn't already exist, or it'll\n+    // open up a handle to one if it already exists.\n+    let mutex = unsafe { CreateMutexA(None, false, PCSTR::from_raw(cname.as_ptr().cast())) }\n+        .unwrap_or_else(|_| panic!(\"failed to create global mutex named `{}`\", name));\n+    let mutex = Handle(mutex);\n \n-        // Acquire the lock through `WaitForSingleObject`.\n-        //\n-        // A return value of `WAIT_OBJECT_0` means we successfully acquired it.\n-        //\n-        // A return value of `WAIT_ABANDONED` means that the previous holder of\n-        // the thread exited without calling `ReleaseMutex`. This can happen,\n-        // for example, when the compiler crashes or is interrupted via ctrl-c\n-        // or the like. In this case, however, we are still transferred\n-        // ownership of the lock so we continue.\n-        //\n-        // If an error happens.. well... that's surprising!\n-        match WaitForSingleObject(mutex.0, INFINITE) {\n-            WAIT_OBJECT_0 | WAIT_ABANDONED => {}\n-            code => {\n-                panic!(\n-                    \"WaitForSingleObject failed on global mutex named \\\n-                        `{}`: {} (ret={:x})\",\n-                    name,\n-                    io::Error::last_os_error(),\n-                    code\n-                );\n-            }\n-        }\n-\n-        // Return a guard which will call `ReleaseMutex` when dropped.\n-        Box::new(Guard(mutex))\n+    // Acquire the lock through `WaitForSingleObject`.\n+    //\n+    // A return value of `WAIT_OBJECT_0` means we successfully acquired it.\n+    //\n+    // A return value of `WAIT_ABANDONED` means that the previous holder of\n+    // the thread exited without calling `ReleaseMutex`. This can happen,\n+    // for example, when the compiler crashes or is interrupted via ctrl-c\n+    // or the like. In this case, however, we are still transferred\n+    // ownership of the lock so we continue.\n+    //\n+    // If an error happens.. well... that's surprising!\n+    match unsafe { WaitForSingleObject(mutex.0, INFINITE) } {\n+        WAIT_OBJECT_0 | WAIT_ABANDONED => (),\n+        err => panic!(\n+            \"WaitForSingleObject failed on global mutex named `{}`: {} (ret={:x})\",\n+            name,\n+            io::Error::last_os_error(),\n+            err.0\n+        ),\n     }\n+\n+    // Return a guard which will call `ReleaseMutex` when dropped.\n+    Box::new(Guard(mutex))\n }\n \n #[cfg(not(windows))]"}, {"sha": "6a27383121d2ddd72f6b3ec8ea313fd01e20e657", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -3068,7 +3068,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         // generate the def_id of an associated type for the trait and return as\n                         // type a projection.\n                         let def_id = if in_trait && tcx.lower_impl_trait_in_trait_to_assoc_ty() {\n-                            tcx.associated_item_for_impl_trait_in_trait(local_def_id).to_def_id()\n+                            tcx.associated_type_for_impl_trait_in_trait(local_def_id).to_def_id()\n                         } else {\n                             local_def_id.to_def_id()\n                         };\n@@ -3152,8 +3152,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         debug!(\"impl_trait_ty_to_ty: generics={:?}\", generics);\n         let substs = InternalSubsts::for_item(tcx, def_id, |param, _| {\n-            if let Some(i) = (param.index as usize).checked_sub(generics.parent_count) {\n-                // Our own parameters are the resolved lifetimes.\n+            // We use `generics.count() - lifetimes.len()` here instead of `generics.parent_count`\n+            // since return-position impl trait in trait squashes all of the generics from its source fn\n+            // into its own generics, so the opaque's \"own\" params isn't always just lifetimes.\n+            if let Some(i) = (param.index as usize).checked_sub(generics.count() - lifetimes.len())\n+            {\n+                // Resolve our own lifetime parameters.\n                 let GenericParamDefKind::Lifetime { .. } = param.kind else { bug!() };\n                 let hir::GenericArg::Lifetime(lifetime) = &lifetimes[i] else { bug!() };\n                 self.ast_region_to_region(lifetime, None).into()"}, {"sha": "4bbea87890429237bec62a80acd1499de5125b08", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -278,8 +278,11 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n             }\n             TraitItemKind::Const(ty, body_id) => body_id\n                 .and_then(|body_id| {\n-                    is_suggestable_infer_ty(ty)\n-                        .then(|| infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident, \"constant\",))\n+                    is_suggestable_infer_ty(ty).then(|| {\n+                        infer_placeholder_type(\n+                            tcx, def_id, body_id, ty.span, item.ident, \"constant\",\n+                        )\n+                    })\n                 })\n                 .unwrap_or_else(|| icx.to_ty(ty)),\n             TraitItemKind::Type(_, Some(ty)) => icx.to_ty(ty),\n@@ -335,14 +338,15 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n                     }\n                 }\n                 ItemKind::TyAlias(self_ty, _) => icx.to_ty(self_ty),\n-                ItemKind::Impl(hir::Impl { self_ty, .. }) => {\n-                    match self_ty.find_self_aliases() {\n-                        spans if spans.len() > 0 => {\n-                            let guar = tcx.sess.emit_err(crate::errors::SelfInImplSelf { span: spans.into(), note: () });\n-                            tcx.ty_error(guar)\n-                        },\n-                        _ => icx.to_ty(*self_ty),\n+                ItemKind::Impl(hir::Impl { self_ty, .. }) => match self_ty.find_self_aliases() {\n+                    spans if spans.len() > 0 => {\n+                        let guar = tcx.sess.emit_err(crate::errors::SelfInImplSelf {\n+                            span: spans.into(),\n+                            note: (),\n+                        });\n+                        tcx.ty_error(guar)\n                     }\n+                    _ => icx.to_ty(*self_ty),\n                 },\n                 ItemKind::Fn(..) => {\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n@@ -364,7 +368,10 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n                     ..\n                 }) => {\n                     if in_trait && !tcx.impl_defaultness(owner).has_value() {\n-                        span_bug!(tcx.def_span(def_id), \"tried to get type of this RPITIT with no definition\");\n+                        span_bug!(\n+                            tcx.def_span(def_id),\n+                            \"tried to get type of this RPITIT with no definition\"\n+                        );\n                     }\n                     find_opaque_ty_constraints_for_rpit(tcx, def_id, owner)\n                 }\n@@ -453,15 +460,12 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n                     tcx.adt_def(tcx.hir().get_parent_item(hir_id)).repr().discr_type().to_ty(tcx)\n                 }\n \n-                Node::TypeBinding(\n-                    TypeBinding {\n-                        hir_id: binding_id,\n-                        kind: TypeBindingKind::Equality { term: Term::Const(e) },\n-                        ident,\n-                        ..\n-                    },\n-                ) if let Node::TraitRef(trait_ref) =\n-                    tcx.hir().get_parent(*binding_id)\n+                Node::TypeBinding(TypeBinding {\n+                    hir_id: binding_id,\n+                    kind: TypeBindingKind::Equality { term: Term::Const(e) },\n+                    ident,\n+                    ..\n+                }) if let Node::TraitRef(trait_ref) = tcx.hir().get_parent(*binding_id)\n                     && e.hir_id == hir_id =>\n                 {\n                     let Some(trait_def_id) = trait_ref.trait_def_id() else {\n@@ -475,7 +479,9 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n                         def_id.to_def_id(),\n                     );\n                     if let Some(assoc_item) = assoc_item {\n-                        tcx.type_of(assoc_item.def_id).subst_identity()\n+                        tcx.type_of(assoc_item.def_id)\n+                            .no_bound_vars()\n+                            .expect(\"const parameter types cannot be generic\")\n                     } else {\n                         // FIXME(associated_const_equality): add a useful error message here.\n                         tcx.ty_error_with_message(\n@@ -485,10 +491,13 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n                     }\n                 }\n \n-                Node::TypeBinding(\n-                    TypeBinding { hir_id: binding_id, gen_args, kind, ident, .. },\n-                ) if let Node::TraitRef(trait_ref) =\n-                    tcx.hir().get_parent(*binding_id)\n+                Node::TypeBinding(TypeBinding {\n+                    hir_id: binding_id,\n+                    gen_args,\n+                    kind,\n+                    ident,\n+                    ..\n+                }) if let Node::TraitRef(trait_ref) = tcx.hir().get_parent(*binding_id)\n                     && let Some((idx, _)) =\n                         gen_args.args.iter().enumerate().find(|(_, arg)| {\n                             if let GenericArg::Const(ct) = arg {\n@@ -517,15 +526,18 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n                         },\n                         def_id.to_def_id(),\n                     );\n-                    if let Some(param)\n-                        = assoc_item.map(|item| &tcx.generics_of(item.def_id).params[idx]).filter(|param| param.kind.is_ty_or_const())\n+                    if let Some(assoc_item) = assoc_item\n+                        && let param = &tcx.generics_of(assoc_item.def_id).params[idx]\n+                        && matches!(param.kind, ty::GenericParamDefKind::Const { .. })\n                     {\n-                        tcx.type_of(param.def_id).subst_identity()\n+                        tcx.type_of(param.def_id)\n+                            .no_bound_vars()\n+                            .expect(\"const parameter types cannot be generic\")\n                     } else {\n                         // FIXME(associated_const_equality): add a useful error message here.\n                         tcx.ty_error_with_message(\n                             DUMMY_SP,\n-                            \"Could not find associated const on trait\",\n+                            \"Could not find const param on associated item\",\n                         )\n                     }\n                 }"}, {"sha": "b6d39341fe7cc5ecbc04fec2ef3f63b393fa1ba6", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1028,6 +1028,15 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     true\n                 }\n             })\n+            // ensure that we don't suggest unstable methods\n+            .filter(|candidate| {\n+                // note that `DUMMY_SP` is ok here because it is only used for\n+                // suggestions and macro stuff which isn't applicable here.\n+                !matches!(\n+                    self.tcx.eval_stability(candidate.item.def_id, None, DUMMY_SP, None),\n+                    stability::EvalResult::Deny { .. }\n+                )\n+            })\n             .map(|candidate| candidate.item.ident(self.tcx))\n             .filter(|&name| set.insert(name))\n             .collect();"}, {"sha": "fd16363a1db0102b5f37a5df6cfbde53c42b5eec", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -615,9 +615,10 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         }\n \n         let report_path_match = |err: &mut Diagnostic, did1: DefId, did2: DefId| {\n-            // Only external crates, if either is from a local\n-            // module we could have false positives\n-            if !(did1.is_local() || did2.is_local()) && did1.krate != did2.krate {\n+            // Only report definitions from different crates. If both definitions\n+            // are from a local module we could have false positives, e.g.\n+            // let _ = [{struct Foo; Foo}, {struct Foo; Foo}];\n+            if did1.krate != did2.krate {\n                 let abs_path =\n                     |def_id| AbsolutePathPrinter { tcx: self.tcx }.print_def_path(def_id, &[]);\n \n@@ -629,10 +630,16 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 };\n                 if same_path().unwrap_or(false) {\n                     let crate_name = self.tcx.crate_name(did1.krate);\n-                    err.note(&format!(\n-                        \"perhaps two different versions of crate `{}` are being used?\",\n-                        crate_name\n-                    ));\n+                    let msg = if did1.is_local() || did2.is_local() {\n+                        format!(\n+                            \"the crate `{crate_name}` is compiled multiple times, possibly with different configurations\"\n+                        )\n+                    } else {\n+                        format!(\n+                            \"perhaps two different versions of crate `{crate_name}` are being used?\"\n+                        )\n+                    };\n+                    err.note(msg);\n                 }\n             }\n         };"}, {"sha": "c822237413c7039c132dac232b30a3bc7ecd34cb", "filename": "compiler/rustc_lint/messages.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_lint%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_lint%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fmessages.ftl?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -508,3 +508,6 @@ lint_opaque_hidden_inferred_bound = opaque type `{$ty}` does not satisfy its ass\n     .specifically = this associated type bound is unsatisfied for `{$proj_ty}`\n \n lint_opaque_hidden_inferred_bound_sugg = add this bound\n+\n+lint_useless_anonymous_reexport = useless anonymous re-export\n+    .note = only anonymous re-exports of traits are useful, this is {$article} `{$desc}`"}, {"sha": "b1ff76865abda729882fc497c557e1a6778eb894", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -2781,8 +2781,7 @@ impl ClashingExternDeclarations {\n \n             // Given a transparent newtype, reach through and grab the inner\n             // type unless the newtype makes the type non-null.\n-            let non_transparent_ty = |ty: Ty<'tcx>| -> Ty<'tcx> {\n-                let mut ty = ty;\n+            let non_transparent_ty = |mut ty: Ty<'tcx>| -> Ty<'tcx> {\n                 loop {\n                     if let ty::Adt(def, substs) = *ty.kind() {\n                         let is_transparent = def.repr().transparent();\n@@ -2792,14 +2791,14 @@ impl ClashingExternDeclarations {\n                             ty, is_transparent, is_non_null\n                         );\n                         if is_transparent && !is_non_null {\n-                            debug_assert!(def.variants().len() == 1);\n+                            debug_assert_eq!(def.variants().len(), 1);\n                             let v = &def.variant(VariantIdx::new(0));\n-                            ty = transparent_newtype_field(tcx, v)\n-                                .expect(\n-                                    \"single-variant transparent structure with zero-sized field\",\n-                                )\n-                                .ty(tcx, substs);\n-                            continue;\n+                            // continue with `ty`'s non-ZST field,\n+                            // otherwise `ty` is a ZST and we can return\n+                            if let Some(field) = transparent_newtype_field(tcx, v) {\n+                                ty = field.ty(tcx, substs);\n+                                continue;\n+                            }\n                         }\n                     }\n                     debug!(\"non_transparent_ty -> {:?}\", ty);\n@@ -2813,10 +2812,8 @@ impl ClashingExternDeclarations {\n             if !seen_types.insert((a, b)) {\n                 // We've encountered a cycle. There's no point going any further -- the types are\n                 // structurally the same.\n-                return true;\n-            }\n-            let tcx = cx.tcx;\n-            if a == b {\n+                true\n+            } else if a == b {\n                 // All nominally-same types are structurally same, too.\n                 true\n             } else {"}, {"sha": "c2cc2fcdf551a580d4fe094c53b5f2807c7b0ae6", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -74,6 +74,7 @@ mod opaque_hidden_inferred_bound;\n mod pass_by_value;\n mod passes;\n mod redundant_semicolon;\n+mod reexports;\n mod traits;\n mod types;\n mod unused;\n@@ -111,6 +112,7 @@ use noop_method_call::*;\n use opaque_hidden_inferred_bound::*;\n use pass_by_value::*;\n use redundant_semicolon::*;\n+use reexports::*;\n use traits::*;\n use types::*;\n use unused::*;\n@@ -242,6 +244,7 @@ late_lint_methods!(\n             OpaqueHiddenInferredBound: OpaqueHiddenInferredBound,\n             MultipleSupertraitUpcastable: MultipleSupertraitUpcastable,\n             MapUnitFn: MapUnitFn,\n+            UselessAnonymousReexport: UselessAnonymousReexport,\n         ]\n     ]\n );"}, {"sha": "46a025f41e04aec056cb2e84115b6fb2c27c670c", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1528,3 +1528,11 @@ pub struct UnusedAllocationDiag;\n #[derive(LintDiagnostic)]\n #[diag(lint_unused_allocation_mut)]\n pub struct UnusedAllocationMutDiag;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_useless_anonymous_reexport)]\n+#[note]\n+pub struct UselessAnonymousReexportDiag {\n+    pub article: &'static str,\n+    pub desc: &'static str,\n+}"}, {"sha": "8737a57ea0264cddb1476d51411acbed456d027f", "filename": "compiler/rustc_lint/src/reexports.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_lint%2Fsrc%2Freexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_lint%2Fsrc%2Freexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Freexports.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,82 @@\n+use crate::lints::UselessAnonymousReexportDiag;\n+use crate::{LateContext, LateLintPass, LintContext};\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{Item, ItemKind, UseKind};\n+use rustc_middle::ty::Visibility;\n+use rustc_span::symbol::kw;\n+use rustc_span::Span;\n+\n+declare_lint! {\n+    /// The `useless_anonymous_reexport` lint checks if anonymous re-exports\n+    /// are re-exports of traits.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(useless_anonymous_reexport)]\n+    ///\n+    /// mod sub {\n+    ///     pub struct Bar;\n+    /// }\n+    ///\n+    /// pub use self::sub::Bar as _;\n+    /// # fn main() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Anonymous re-exports are only useful if it's a re-export of a trait\n+    /// in case you want to give access to it. If you re-export any other kind,\n+    /// you won't be able to use it since its name won't be accessible.\n+    pub USELESS_ANONYMOUS_REEXPORT,\n+    Warn,\n+    \"useless anonymous re-export\"\n+}\n+\n+declare_lint_pass!(UselessAnonymousReexport => [USELESS_ANONYMOUS_REEXPORT]);\n+\n+fn emit_err(cx: &LateContext<'_>, span: Span, def_id: DefId) {\n+    let article = cx.tcx.def_descr_article(def_id);\n+    let desc = cx.tcx.def_descr(def_id);\n+    cx.emit_spanned_lint(\n+        USELESS_ANONYMOUS_REEXPORT,\n+        span,\n+        UselessAnonymousReexportDiag { article, desc },\n+    );\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for UselessAnonymousReexport {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n+        if let ItemKind::Use(path, kind) = item.kind &&\n+            !matches!(kind, UseKind::Glob) &&\n+            item.ident.name == kw::Underscore &&\n+            // We only want re-exports. If it's just a `use X;`, then we ignore it.\n+            match cx.tcx.local_visibility(item.owner_id.def_id) {\n+                Visibility::Public => true,\n+                Visibility::Restricted(level) => {\n+                    level != cx.tcx.parent_module_from_def_id(item.owner_id.def_id)\n+                }\n+            }\n+        {\n+            for def_id in path.res.iter().filter_map(|r| r.opt_def_id()) {\n+                match cx.tcx.def_kind(def_id) {\n+                    DefKind::Trait | DefKind::TraitAlias => {}\n+                    DefKind::TyAlias => {\n+                        let ty = cx.tcx.type_of(def_id);\n+                        if !ty.0.is_trait() {\n+                            emit_err(cx, item.span, def_id);\n+                            break;\n+                        }\n+                    }\n+                    _ => {\n+                        emit_err(cx, item.span, def_id);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "b855c8e433266470195b6033923ddb784f459185", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 35, "deletions": 41, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -46,7 +46,7 @@ pub fn find_native_static_library(\n }\n \n fn find_bundled_library(\n-    name: Option<Symbol>,\n+    name: Symbol,\n     verbatim: Option<bool>,\n     kind: NativeLibKind,\n     has_cfg: bool,\n@@ -58,7 +58,7 @@ fn find_bundled_library(\n     {\n         let verbatim = verbatim.unwrap_or(false);\n         let search_paths = &sess.target_filesearch(PathKind::Native).search_path_dirs();\n-        return find_native_static_library(name.unwrap().as_str(), verbatim, search_paths, sess)\n+        return find_native_static_library(name.as_str(), verbatim, search_paths, sess)\n             .file_name()\n             .and_then(|s| s.to_str())\n             .map(Symbol::intern);\n@@ -336,10 +336,16 @@ impl<'tcx> Collector<'tcx> {\n                 if name.is_some() || kind.is_some() || modifiers.is_some() || cfg.is_some() {\n                     sess.emit_err(errors::IncompatibleWasmLink { span });\n                 }\n-            } else if name.is_none() {\n-                sess.emit_err(errors::LinkRequiresName { span: m.span });\n             }\n \n+            if wasm_import_module.is_some() {\n+                (name, kind) = (wasm_import_module, Some(NativeLibKind::WasmImportModule));\n+            }\n+            let Some((name, name_span)) = name else {\n+                sess.emit_err(errors::LinkRequiresName { span: m.span });\n+                continue;\n+            };\n+\n             // Do this outside of the loop so that `import_name_type` can be specified before `kind`.\n             if let Some((_, span)) = import_name_type {\n                 if kind != Some(NativeLibKind::RawDylib) {\n@@ -349,8 +355,8 @@ impl<'tcx> Collector<'tcx> {\n \n             let dll_imports = match kind {\n                 Some(NativeLibKind::RawDylib) => {\n-                    if let Some((name, span)) = name && name.as_str().contains('\\0') {\n-                        sess.emit_err(errors::RawDylibNoNul { span });\n+                    if name.as_str().contains('\\0') {\n+                        sess.emit_err(errors::RawDylibNoNul { span: name_span });\n                     }\n                     foreign_mod_items\n                         .iter()\n@@ -389,7 +395,6 @@ impl<'tcx> Collector<'tcx> {\n                 }\n             };\n \n-            let name = name.map(|(name, _)| name);\n             let kind = kind.unwrap_or(NativeLibKind::Unspecified);\n             let filename = find_bundled_library(name, verbatim, kind, cfg.is_some(), sess);\n             self.libs.push(NativeLib {\n@@ -398,7 +403,6 @@ impl<'tcx> Collector<'tcx> {\n                 kind,\n                 cfg,\n                 foreign_module: Some(it.owner_id.to_def_id()),\n-                wasm_import_module: wasm_import_module.map(|(name, _)| name),\n                 verbatim,\n                 dll_imports,\n             });\n@@ -415,11 +419,7 @@ impl<'tcx> Collector<'tcx> {\n                 self.tcx.sess.emit_err(errors::LibFrameworkApple);\n             }\n             if let Some(ref new_name) = lib.new_name {\n-                let any_duplicate = self\n-                    .libs\n-                    .iter()\n-                    .filter_map(|lib| lib.name.as_ref())\n-                    .any(|n| n.as_str() == lib.name);\n+                let any_duplicate = self.libs.iter().any(|n| n.name.as_str() == lib.name);\n                 if new_name.is_empty() {\n                     self.tcx.sess.emit_err(errors::EmptyRenamingTarget { lib_name: &lib.name });\n                 } else if !any_duplicate {\n@@ -444,41 +444,36 @@ impl<'tcx> Collector<'tcx> {\n             let mut existing = self\n                 .libs\n                 .drain_filter(|lib| {\n-                    if let Some(lib_name) = lib.name {\n-                        if lib_name.as_str() == passed_lib.name {\n-                            // FIXME: This whole logic is questionable, whether modifiers are\n-                            // involved or not, library reordering and kind overriding without\n-                            // explicit `:rename` in particular.\n-                            if lib.has_modifiers() || passed_lib.has_modifiers() {\n-                                match lib.foreign_module {\n-                                    Some(def_id) => {\n-                                        self.tcx.sess.emit_err(errors::NoLinkModOverride {\n-                                            span: Some(self.tcx.def_span(def_id)),\n-                                        })\n-                                    }\n-                                    None => self\n-                                        .tcx\n-                                        .sess\n-                                        .emit_err(errors::NoLinkModOverride { span: None }),\n-                                };\n-                            }\n-                            if passed_lib.kind != NativeLibKind::Unspecified {\n-                                lib.kind = passed_lib.kind;\n-                            }\n-                            if let Some(new_name) = &passed_lib.new_name {\n-                                lib.name = Some(Symbol::intern(new_name));\n-                            }\n-                            lib.verbatim = passed_lib.verbatim;\n-                            return true;\n+                    if lib.name.as_str() == passed_lib.name {\n+                        // FIXME: This whole logic is questionable, whether modifiers are\n+                        // involved or not, library reordering and kind overriding without\n+                        // explicit `:rename` in particular.\n+                        if lib.has_modifiers() || passed_lib.has_modifiers() {\n+                            match lib.foreign_module {\n+                                Some(def_id) => self.tcx.sess.emit_err(errors::NoLinkModOverride {\n+                                    span: Some(self.tcx.def_span(def_id)),\n+                                }),\n+                                None => {\n+                                    self.tcx.sess.emit_err(errors::NoLinkModOverride { span: None })\n+                                }\n+                            };\n+                        }\n+                        if passed_lib.kind != NativeLibKind::Unspecified {\n+                            lib.kind = passed_lib.kind;\n+                        }\n+                        if let Some(new_name) = &passed_lib.new_name {\n+                            lib.name = Symbol::intern(new_name);\n                         }\n+                        lib.verbatim = passed_lib.verbatim;\n+                        return true;\n                     }\n                     false\n                 })\n                 .collect::<Vec<_>>();\n             if existing.is_empty() {\n                 // Add if not found\n                 let new_name: Option<&str> = passed_lib.new_name.as_deref();\n-                let name = Some(Symbol::intern(new_name.unwrap_or(&passed_lib.name)));\n+                let name = Symbol::intern(new_name.unwrap_or(&passed_lib.name));\n                 let sess = self.tcx.sess;\n                 let filename =\n                     find_bundled_library(name, passed_lib.verbatim, passed_lib.kind, false, sess);\n@@ -488,7 +483,6 @@ impl<'tcx> Collector<'tcx> {\n                     kind: passed_lib.kind,\n                     cfg: None,\n                     foreign_module: None,\n-                    wasm_import_module: None,\n                     verbatim: passed_lib.verbatim,\n                     dll_imports: Vec::new(),\n                 });"}, {"sha": "561e770d90cec6ed2eec63696eace7f49c691af0", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -226,15 +226,7 @@ provide! { tcx, def_id, other, cdata,\n     lookup_default_body_stability => { table }\n     lookup_deprecation_entry => { table }\n     params_in_repr => { table }\n-    // FIXME: Could be defaulted, but `LazyValue<UnusedGenericParams>` is not `FixedSizeEncoding`..\n-    unused_generic_params => {\n-        cdata\n-            .root\n-            .tables\n-            .unused_generic_params\n-            .get(cdata, def_id.index)\n-            .map_or_else(|| ty::UnusedGenericParams::new_all_used(), |lazy| lazy.decode((cdata, tcx)))\n-    }\n+    unused_generic_params => { cdata.root.tables.unused_generic_params.get(cdata, def_id.index) }\n     opt_def_kind => { table_direct }\n     impl_parent => { table }\n     impl_polarity => { table_direct }\n@@ -262,7 +254,7 @@ provide! { tcx, def_id, other, cdata,\n             .process_decoded(tcx, || panic!(\"{def_id:?} does not have trait_impl_trait_tys\")))\n      }\n \n-    associated_items_for_impl_trait_in_trait => { table_defaulted_array }\n+    associated_types_for_impl_traits_in_associated_fn => { table_defaulted_array }\n \n     visibility => { cdata.get_visibility(def_id.index) }\n     adt_def => { cdata.get_adt_def(def_id.index, tcx) }"}, {"sha": "46fd0cace09a1cc928fef6d274283102b7b1796f", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -609,10 +609,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         _ = stat!(\"mir\", || self.encode_mir());\n \n-        _ = stat!(\"items\", || {\n-            self.encode_def_ids();\n-            self.encode_info_for_items();\n-        });\n+        _ = stat!(\"def-ids\", || self.encode_def_ids());\n+\n+        _ = stat!(\"items\", || self.encode_info_for_items());\n \n         let interpret_alloc_index = stat!(\"interpret-alloc-index\", || {\n             let mut interpret_alloc_index = Vec::new();\n@@ -1198,8 +1197,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.trait_impl_trait_tys[def_id] <- table);\n             }\n             if should_encode_fn_impl_trait_in_trait(tcx, def_id) {\n-                let table = tcx.associated_items_for_impl_trait_in_trait(def_id);\n-                record_defaulted_array!(self.tables.associated_items_for_impl_trait_in_trait[def_id] <- table);\n+                let table = tcx.associated_types_for_impl_traits_in_associated_fn(def_id);\n+                record_defaulted_array!(self.tables.associated_types_for_impl_traits_in_associated_fn[def_id] <- table);\n             }\n         }\n \n@@ -1440,9 +1439,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let instance =\n                 ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id.to_def_id()));\n             let unused = tcx.unused_generic_params(instance);\n-            if !unused.all_used() {\n-                record!(self.tables.unused_generic_params[def_id.to_def_id()] <- unused);\n-            }\n+            self.tables.unused_generic_params.set(def_id.local_def_index, unused);\n         }\n \n         // Encode all the deduced parameter attributes for everything that has MIR, even for items"}, {"sha": "6dc6041b284ea3898f6517eb755becde21265fe0", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -354,8 +354,9 @@ define_tables! {\n     explicit_item_bounds: Table<DefIndex, LazyArray<(ty::Predicate<'static>, Span)>>,\n     inferred_outlives_of: Table<DefIndex, LazyArray<(ty::Clause<'static>, Span)>>,\n     inherent_impls: Table<DefIndex, LazyArray<DefIndex>>,\n-    associated_items_for_impl_trait_in_trait: Table<DefIndex, LazyArray<DefId>>,\n+    associated_types_for_impl_traits_in_associated_fn: Table<DefIndex, LazyArray<DefId>>,\n     opt_rpitit_info: Table<DefIndex, Option<LazyValue<ty::ImplTraitInTraitData>>>,\n+    unused_generic_params: Table<DefIndex, UnusedGenericParams>,\n \n - optional:\n     attributes: Table<DefIndex, LazyArray<ast::Attribute>>,\n@@ -398,7 +399,6 @@ define_tables! {\n     trait_def: Table<DefIndex, LazyValue<ty::TraitDef>>,\n     trait_item_def_id: Table<DefIndex, RawDefId>,\n     expn_that_defined: Table<DefIndex, LazyValue<ExpnId>>,\n-    unused_generic_params: Table<DefIndex, LazyValue<UnusedGenericParams>>,\n     params_in_repr: Table<DefIndex, LazyValue<BitSet<u32>>>,\n     repr_options: Table<DefIndex, LazyValue<ReprOptions>>,\n     // `def_keys` and `def_path_hashes` represent a lazy version of a"}, {"sha": "364fa74ab7b459bd31796bef39482ccc2f23c653", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -3,7 +3,7 @@ use crate::rmeta::*;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_hir::def::{CtorKind, CtorOf};\n use rustc_index::vec::Idx;\n-use rustc_middle::ty::ParameterizedOverTcx;\n+use rustc_middle::ty::{ParameterizedOverTcx, UnusedGenericParams};\n use rustc_serialize::opaque::FileEncoder;\n use rustc_serialize::Encoder as _;\n use rustc_span::hygiene::MacroKind;\n@@ -50,6 +50,16 @@ impl IsDefault for DefPathHash {\n     }\n }\n \n+impl IsDefault for UnusedGenericParams {\n+    fn is_default(&self) -> bool {\n+        // UnusedGenericParams encodes the *un*usedness as a bitset.\n+        // This means that 0 corresponds to all bits used, which is indeed the default.\n+        let is_default = self.bits() == 0;\n+        debug_assert_eq!(is_default, self.all_used());\n+        is_default\n+    }\n+}\n+\n /// Helper trait, for encoding to, and decoding from, a fixed number of bytes.\n /// Used mainly for Lazy positions and lengths.\n /// Unchecked invariant: `Self::default()` should encode as `[0; BYTE_LEN]`,\n@@ -271,6 +281,21 @@ impl FixedSizeEncoding for bool {\n     }\n }\n \n+impl FixedSizeEncoding for UnusedGenericParams {\n+    type ByteArray = [u8; 4];\n+\n+    #[inline]\n+    fn from_bytes(b: &[u8; 4]) -> Self {\n+        let x: u32 = u32::from_bytes(b);\n+        UnusedGenericParams::from_bits(x)\n+    }\n+\n+    #[inline]\n+    fn write_to_bytes(self, b: &mut [u8; 4]) {\n+        self.bits().write_to_bytes(b);\n+    }\n+}\n+\n // NOTE(eddyb) there could be an impl for `usize`, which would enable a more\n // generic `LazyValue<T>` impl, but in the general case we might not need / want\n // to fit every `usize` in `u32`."}, {"sha": "4bf81c97d06adba414bae577be37afbc61472294", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -785,15 +785,15 @@ rustc_queries! {\n     /// if `fn_def_id` is the def id of a function defined inside an impl that implements a trait, then it\n     /// creates and returns the associated items that correspond to each impl trait in return position\n     /// of the implemented trait.\n-    query associated_items_for_impl_trait_in_trait(fn_def_id: DefId) -> &'tcx [DefId] {\n+    query associated_types_for_impl_traits_in_associated_fn(fn_def_id: DefId) -> &'tcx [DefId] {\n         desc { |tcx| \"creating associated items for impl trait in trait returned by `{}`\", tcx.def_path_str(fn_def_id) }\n         cache_on_disk_if { fn_def_id.is_local() }\n         separate_provide_extern\n     }\n \n     /// Given an impl trait in trait `opaque_ty_def_id`, create and return the corresponding\n     /// associated item.\n-    query associated_item_for_impl_trait_in_trait(opaque_ty_def_id: LocalDefId) -> LocalDefId {\n+    query associated_type_for_impl_trait_in_trait(opaque_ty_def_id: LocalDefId) -> LocalDefId {\n         desc { |tcx| \"creates the associated item corresponding to the opaque type `{}`\", tcx.def_path_str(opaque_ty_def_id.to_def_id()) }\n         cache_on_disk_if { true }\n         separate_provide_extern"}, {"sha": "5fc98f01a5470ee213ba3eec3a2463bad7e67c95", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -781,6 +781,12 @@ fn needs_fn_once_adapter_shim(\n #[derive(Debug, Copy, Clone, Eq, PartialEq, Decodable, Encodable, HashStable)]\n pub struct UnusedGenericParams(FiniteBitSet<u32>);\n \n+impl Default for UnusedGenericParams {\n+    fn default() -> Self {\n+        UnusedGenericParams::new_all_used()\n+    }\n+}\n+\n impl UnusedGenericParams {\n     pub fn new_all_unused(amount: u32) -> Self {\n         let mut bitset = FiniteBitSet::new_empty();\n@@ -807,4 +813,12 @@ impl UnusedGenericParams {\n     pub fn all_used(&self) -> bool {\n         self.0.is_empty()\n     }\n+\n+    pub fn bits(&self) -> u32 {\n+        self.0.0\n+    }\n+\n+    pub fn from_bits(bits: u32) -> UnusedGenericParams {\n+        UnusedGenericParams(FiniteBitSet(bits))\n+    }\n }"}, {"sha": "298b2c3073cd399a1fa0bbf7293058b227e024d1", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -2579,7 +2579,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         let Some(trait_item_def_id) = item.trait_item_def_id else { return false; };\n \n         if self.lower_impl_trait_in_trait_to_assoc_ty() {\n-            return !self.associated_items_for_impl_trait_in_trait(trait_item_def_id).is_empty();\n+            return !self\n+                .associated_types_for_impl_traits_in_associated_fn(trait_item_def_id)\n+                .is_empty();\n         }\n \n         // FIXME(RPITIT): This does a somewhat manual walk through the signature"}, {"sha": "3dbcc4d2e8aabc40d90e14dc8297f82157c23aef", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -6,7 +6,6 @@ use rustc_data_structures::sharded::{self, Sharded};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, Lrc, Ordering};\n-use rustc_data_structures::OnDrop;\n use rustc_index::vec::IndexVec;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use smallvec::{smallvec, SmallVec};\n@@ -54,6 +53,11 @@ impl From<DepNodeIndex> for QueryInvocationId {\n     }\n }\n \n+pub struct MarkFrame<'a> {\n+    index: SerializedDepNodeIndex,\n+    parent: Option<&'a MarkFrame<'a>>,\n+}\n+\n #[derive(PartialEq)]\n pub enum DepNodeColor {\n     Red,\n@@ -710,32 +714,26 @@ impl<K: DepKind> DepGraphData<K> {\n         let prev_index = self.previous.node_to_index_opt(dep_node)?;\n \n         match self.colors.get(prev_index) {\n-            Some(DepNodeColor::Green(dep_node_index)) => return Some((prev_index, dep_node_index)),\n-            Some(DepNodeColor::Red) => return None,\n-            None => {}\n+            Some(DepNodeColor::Green(dep_node_index)) => Some((prev_index, dep_node_index)),\n+            Some(DepNodeColor::Red) => None,\n+            None => {\n+                // This DepNode and the corresponding query invocation existed\n+                // in the previous compilation session too, so we can try to\n+                // mark it as green by recursively marking all of its\n+                // dependencies green.\n+                self.try_mark_previous_green(qcx, prev_index, &dep_node, None)\n+                    .map(|dep_node_index| (prev_index, dep_node_index))\n+            }\n         }\n-\n-        let backtrace = backtrace_printer(qcx.dep_context().sess(), self, prev_index);\n-\n-        // This DepNode and the corresponding query invocation existed\n-        // in the previous compilation session too, so we can try to\n-        // mark it as green by recursively marking all of its\n-        // dependencies green.\n-        let ret = self\n-            .try_mark_previous_green(qcx, prev_index, &dep_node)\n-            .map(|dep_node_index| (prev_index, dep_node_index));\n-\n-        // We succeeded, no backtrace.\n-        backtrace.disable();\n-        return ret;\n     }\n \n-    #[instrument(skip(self, qcx, parent_dep_node_index), level = \"debug\")]\n+    #[instrument(skip(self, qcx, parent_dep_node_index, frame), level = \"debug\")]\n     fn try_mark_parent_green<Qcx: QueryContext<DepKind = K>>(\n         &self,\n         qcx: Qcx,\n         parent_dep_node_index: SerializedDepNodeIndex,\n         dep_node: &DepNode<K>,\n+        frame: Option<&MarkFrame<'_>>,\n     ) -> Option<()> {\n         let dep_dep_node_color = self.colors.get(parent_dep_node_index);\n         let dep_dep_node = &self.previous.index_to_node(parent_dep_node_index);\n@@ -767,7 +765,8 @@ impl<K: DepKind> DepGraphData<K> {\n                 dep_dep_node, dep_dep_node.hash,\n             );\n \n-            let node_index = self.try_mark_previous_green(qcx, parent_dep_node_index, dep_dep_node);\n+            let node_index =\n+                self.try_mark_previous_green(qcx, parent_dep_node_index, dep_dep_node, frame);\n \n             if node_index.is_some() {\n                 debug!(\"managed to MARK dependency {dep_dep_node:?} as green\",);\n@@ -777,7 +776,7 @@ impl<K: DepKind> DepGraphData<K> {\n \n         // We failed to mark it green, so we try to force the query.\n         debug!(\"trying to force dependency {dep_dep_node:?}\");\n-        if !qcx.dep_context().try_force_from_dep_node(*dep_dep_node) {\n+        if !qcx.dep_context().try_force_from_dep_node(*dep_dep_node, frame) {\n             // The DepNode could not be forced.\n             debug!(\"dependency {dep_dep_node:?} could not be forced\");\n             return None;\n@@ -816,13 +815,16 @@ impl<K: DepKind> DepGraphData<K> {\n     }\n \n     /// Try to mark a dep-node which existed in the previous compilation session as green.\n-    #[instrument(skip(self, qcx, prev_dep_node_index), level = \"debug\")]\n+    #[instrument(skip(self, qcx, prev_dep_node_index, frame), level = \"debug\")]\n     fn try_mark_previous_green<Qcx: QueryContext<DepKind = K>>(\n         &self,\n         qcx: Qcx,\n         prev_dep_node_index: SerializedDepNodeIndex,\n         dep_node: &DepNode<K>,\n+        frame: Option<&MarkFrame<'_>>,\n     ) -> Option<DepNodeIndex> {\n+        let frame = MarkFrame { index: prev_dep_node_index, parent: frame };\n+\n         #[cfg(not(parallel_compiler))]\n         {\n             debug_assert!(!self.dep_node_exists(dep_node));\n@@ -837,10 +839,7 @@ impl<K: DepKind> DepGraphData<K> {\n         let prev_deps = self.previous.edge_targets_from(prev_dep_node_index);\n \n         for &dep_dep_node_index in prev_deps {\n-            let backtrace = backtrace_printer(qcx.dep_context().sess(), self, dep_dep_node_index);\n-            let success = self.try_mark_parent_green(qcx, dep_dep_node_index, dep_node);\n-            backtrace.disable();\n-            success?;\n+            self.try_mark_parent_green(qcx, dep_dep_node_index, dep_node, Some(&frame))?;\n         }\n \n         // If we got here without hitting a `return` that means that all\n@@ -970,6 +969,7 @@ impl<K: DepKind> DepGraph<K> {\n     }\n \n     pub(crate) fn next_virtual_depnode_index(&self) -> DepNodeIndex {\n+        debug_assert!(self.data.is_none());\n         let index = self.virtual_dep_node_index.fetch_add(1, Relaxed);\n         DepNodeIndex::from_u32(index)\n     }\n@@ -1414,25 +1414,25 @@ impl DepNodeColorMap {\n     }\n }\n \n-fn backtrace_printer<'a, K: DepKind>(\n-    sess: &'a rustc_session::Session,\n-    graph: &'a DepGraphData<K>,\n-    node: SerializedDepNodeIndex,\n-) -> OnDrop<impl Fn() + 'a> {\n-    OnDrop(\n-        #[inline(never)]\n-        #[cold]\n-        move || {\n-            let node = graph.previous.index_to_node(node);\n-            // Do not try to rely on DepNode's Debug implementation, since it may panic.\n-            let diag = rustc_errors::Diagnostic::new(\n-                rustc_errors::Level::FailureNote,\n-                &format!(\n-                    \"encountered while trying to mark dependency green: {:?}({})\",\n-                    node.kind, node.hash\n-                ),\n-            );\n-            sess.diagnostic().force_print_diagnostic(diag);\n-        },\n-    )\n+#[inline(never)]\n+#[cold]\n+pub(crate) fn print_markframe_trace<K: DepKind>(\n+    graph: &DepGraph<K>,\n+    frame: Option<&MarkFrame<'_>>,\n+) {\n+    let data = graph.data.as_ref().unwrap();\n+\n+    eprintln!(\"there was a panic while trying to force a dep node\");\n+    eprintln!(\"try_mark_green dep node stack:\");\n+\n+    let mut i = 0;\n+    let mut current = frame;\n+    while let Some(frame) = current {\n+        let node = data.previous.index_to_node(frame.index);\n+        eprintln!(\"#{i} {:?}\", node);\n+        current = frame.parent;\n+        i += 1;\n+    }\n+\n+    eprintln!(\"end of try_mark_green dep node stack\");\n }"}, {"sha": "40e7131987fabf44fc226b3d37d372f81e9cd376", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -17,8 +17,10 @@ use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_serialize::{opaque::FileEncoder, Encodable};\n use rustc_session::Session;\n \n-use std::fmt;\n use std::hash::Hash;\n+use std::{fmt, panic};\n+\n+use self::graph::{print_markframe_trace, MarkFrame};\n \n pub trait DepContext: Copy {\n     type DepKind: self::DepKind;\n@@ -53,11 +55,23 @@ pub trait DepContext: Copy {\n     }\n \n     /// Try to force a dep node to execute and see if it's green.\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn try_force_from_dep_node(self, dep_node: DepNode<Self::DepKind>) -> bool {\n+    #[inline]\n+    #[instrument(skip(self, frame), level = \"debug\")]\n+    fn try_force_from_dep_node(\n+        self,\n+        dep_node: DepNode<Self::DepKind>,\n+        frame: Option<&MarkFrame<'_>>,\n+    ) -> bool {\n         let cb = self.dep_kind_info(dep_node.kind);\n         if let Some(f) = cb.force_from_dep_node {\n-            f(self, dep_node);\n+            if let Err(value) = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n+                f(self, dep_node);\n+            })) {\n+                if !value.is::<rustc_errors::FatalErrorMarker>() {\n+                    print_markframe_trace(self.dep_graph(), frame);\n+                }\n+                panic::resume_unwind(value)\n+            }\n             true\n         } else {\n             false"}, {"sha": "ba2f859ff0f8e0f6800bc553444cce2bd61ea17f", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -379,7 +379,11 @@ where\n \n     match JobOwner::<'_, Q::Key, Qcx::DepKind>::try_start(&qcx, state, state_lock, span, key) {\n         TryGetJob::NotYetStarted(job) => {\n-            let (result, dep_node_index) = execute_job(query, qcx, key.clone(), dep_node, job.id);\n+            let (result, dep_node_index) = match qcx.dep_context().dep_graph().data() {\n+                None => execute_job_non_incr(query, qcx, key, job.id),\n+                Some(data) => execute_job_incr(query, qcx, data, key, dep_node, job.id),\n+            };\n+\n             let cache = query.query_cache(qcx);\n             if query.feedable() {\n                 // We should not compute queries that also got a value via feeding.\n@@ -413,48 +417,55 @@ where\n     }\n }\n \n+// Fast path for when incr. comp. is off.\n #[inline(always)]\n-fn execute_job<Q, Qcx>(\n+fn execute_job_non_incr<Q, Qcx>(\n     query: Q,\n     qcx: Qcx,\n     key: Q::Key,\n-    mut dep_node_opt: Option<DepNode<Qcx::DepKind>>,\n     job_id: QueryJobId,\n ) -> (Q::Value, DepNodeIndex)\n where\n     Q: QueryConfig<Qcx>,\n     Qcx: QueryContext,\n {\n-    let dep_graph = qcx.dep_context().dep_graph();\n-    let dep_graph_data = match dep_graph.data() {\n-        // Fast path for when incr. comp. is off.\n-        None => {\n-            // Fingerprint the key, just to assert that it doesn't\n-            // have anything we don't consider hashable\n-            if cfg!(debug_assertions) {\n-                let _ = key.to_fingerprint(*qcx.dep_context());\n-            }\n+    debug_assert!(!qcx.dep_context().dep_graph().is_fully_enabled());\n \n-            let prof_timer = qcx.dep_context().profiler().query_provider();\n-            let result =\n-                qcx.start_query(job_id, query.depth_limit(), None, || query.compute(qcx, key));\n-            let dep_node_index = dep_graph.next_virtual_depnode_index();\n-            prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n-\n-            // Similarly, fingerprint the result to assert that\n-            // it doesn't have anything not considered hashable.\n-            if cfg!(debug_assertions) && let Some(hash_result) = query.hash_result()\n-            {\n-                qcx.dep_context().with_stable_hashing_context(|mut hcx| {\n-                    hash_result(&mut hcx, &result);\n-                });\n-            }\n+    // Fingerprint the key, just to assert that it doesn't\n+    // have anything we don't consider hashable\n+    if cfg!(debug_assertions) {\n+        let _ = key.to_fingerprint(*qcx.dep_context());\n+    }\n \n-            return (result, dep_node_index);\n-        }\n-        Some(data) => data,\n-    };\n+    let prof_timer = qcx.dep_context().profiler().query_provider();\n+    let result = qcx.start_query(job_id, query.depth_limit(), None, || query.compute(qcx, key));\n+    let dep_node_index = qcx.dep_context().dep_graph().next_virtual_depnode_index();\n+    prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n+\n+    // Similarly, fingerprint the result to assert that\n+    // it doesn't have anything not considered hashable.\n+    if cfg!(debug_assertions) && let Some(hash_result) = query.hash_result() {\n+        qcx.dep_context().with_stable_hashing_context(|mut hcx| {\n+            hash_result(&mut hcx, &result);\n+        });\n+    }\n \n+    (result, dep_node_index)\n+}\n+\n+#[inline(always)]\n+fn execute_job_incr<Q, Qcx>(\n+    query: Q,\n+    qcx: Qcx,\n+    dep_graph_data: &DepGraphData<Qcx::DepKind>,\n+    key: Q::Key,\n+    mut dep_node_opt: Option<DepNode<Qcx::DepKind>>,\n+    job_id: QueryJobId,\n+) -> (Q::Value, DepNodeIndex)\n+where\n+    Q: QueryConfig<Qcx>,\n+    Qcx: QueryContext,\n+{\n     if !query.anon() && !query.eval_always() {\n         // `to_dep_node` is expensive for some `DepKind`s.\n         let dep_node ="}, {"sha": "6af9dc89e5694c71a076c9383721a675c8d5109f", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -590,7 +590,6 @@ struct LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n     parent_scope: ParentScope<'a>,\n \n     /// The current set of local scopes for types and values.\n-    /// FIXME #4948: Reuse ribs to avoid allocation.\n     ribs: PerNS<Vec<Rib<'a>>>,\n \n     /// Previous poped `rib`, only used for diagnostic."}, {"sha": "9e337dde99531bafa754854f5734a955a11f61f8", "filename": "compiler/rustc_session/Cargo.toml", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_session%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_session%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2FCargo.toml?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -24,5 +24,9 @@ termize = \"0.1.1\"\n [target.'cfg(unix)'.dependencies]\n libc = \"0.2\"\n \n-[target.'cfg(windows)'.dependencies]\n-winapi = { version = \"0.3\", features = [\"libloaderapi\"] }\n+[target.'cfg(windows)'.dependencies.windows]\n+version = \"0.46.0\"\n+features = [\n+    \"Win32_Foundation\",\n+    \"Win32_System_LibraryLoader\",\n+]"}, {"sha": "a262c06d91f039b6b47bd68a093557db315f9bd9", "filename": "compiler/rustc_session/src/cstore.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcstore.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -67,12 +67,11 @@ pub enum LinkagePreference {\n #[derive(Debug, Encodable, Decodable, HashStable_Generic)]\n pub struct NativeLib {\n     pub kind: NativeLibKind,\n-    pub name: Option<Symbol>,\n+    pub name: Symbol,\n     /// If packed_bundled_libs enabled, actual filename of library is stored.\n     pub filename: Option<Symbol>,\n     pub cfg: Option<ast::MetaItem>,\n     pub foreign_module: Option<DefId>,\n-    pub wasm_import_module: Option<Symbol>,\n     pub verbatim: Option<bool>,\n     pub dll_imports: Vec<DllImport>,\n }\n@@ -81,6 +80,10 @@ impl NativeLib {\n     pub fn has_modifiers(&self) -> bool {\n         self.verbatim.is_some() || self.kind.has_modifiers()\n     }\n+\n+    pub fn wasm_import_module(&self) -> Option<Symbol> {\n+        if self.kind == NativeLibKind::WasmImportModule { Some(self.name) } else { None }\n+    }\n }\n \n /// Different ways that the PE Format can decorate a symbol name."}, {"sha": "e734599cbfc18590651cc56e0403ca12136a4bbd", "filename": "compiler/rustc_session/src/filesearch.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -87,35 +87,38 @@ fn current_dll_path() -> Result<PathBuf, String> {\n     use std::ffi::OsString;\n     use std::io;\n     use std::os::windows::prelude::*;\n-    use std::ptr;\n \n-    use winapi::um::libloaderapi::{\n-        GetModuleFileNameW, GetModuleHandleExW, GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n+    use windows::{\n+        core::PCWSTR,\n+        Win32::Foundation::HINSTANCE,\n+        Win32::System::LibraryLoader::{\n+            GetModuleFileNameW, GetModuleHandleExW, GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n+        },\n     };\n \n+    let mut module = HINSTANCE::default();\n     unsafe {\n-        let mut module = ptr::null_mut();\n-        let r = GetModuleHandleExW(\n+        GetModuleHandleExW(\n             GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n-            current_dll_path as usize as *mut _,\n+            PCWSTR(current_dll_path as *mut u16),\n             &mut module,\n-        );\n-        if r == 0 {\n-            return Err(format!(\"GetModuleHandleExW failed: {}\", io::Error::last_os_error()));\n-        }\n-        let mut space = Vec::with_capacity(1024);\n-        let r = GetModuleFileNameW(module, space.as_mut_ptr(), space.capacity() as u32);\n-        if r == 0 {\n-            return Err(format!(\"GetModuleFileNameW failed: {}\", io::Error::last_os_error()));\n-        }\n-        let r = r as usize;\n-        if r >= space.capacity() {\n-            return Err(format!(\"our buffer was too small? {}\", io::Error::last_os_error()));\n-        }\n-        space.set_len(r);\n-        let os = OsString::from_wide(&space);\n-        Ok(PathBuf::from(os))\n+        )\n     }\n+    .ok()\n+    .map_err(|e| e.to_string())?;\n+\n+    let mut filename = vec![0; 1024];\n+    let n = unsafe { GetModuleFileNameW(module, &mut filename) } as usize;\n+    if n == 0 {\n+        return Err(format!(\"GetModuleFileNameW failed: {}\", io::Error::last_os_error()));\n+    }\n+    if n >= filename.capacity() {\n+        return Err(format!(\"our buffer was too small? {}\", io::Error::last_os_error()));\n+    }\n+\n+    filename.truncate(n);\n+\n+    Ok(OsString::from_wide(&filename).into())\n }\n \n pub fn sysroot_candidates() -> SmallVec<[PathBuf; 2]> {"}, {"sha": "3b3d4ca5d6b21e3c15cf8b70ec8244683eee70e0", "filename": "compiler/rustc_session/src/utils.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_session%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_session%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Futils.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -37,6 +37,10 @@ pub enum NativeLibKind {\n     /// Argument which is passed to linker, relative order with libraries and other arguments\n     /// is preserved\n     LinkArg,\n+\n+    /// Module imported from WebAssembly\n+    WasmImportModule,\n+\n     /// The library kind wasn't specified, `Dylib` is currently used as a default.\n     Unspecified,\n }\n@@ -50,7 +54,10 @@ impl NativeLibKind {\n             NativeLibKind::Dylib { as_needed } | NativeLibKind::Framework { as_needed } => {\n                 as_needed.is_some()\n             }\n-            NativeLibKind::RawDylib | NativeLibKind::Unspecified | NativeLibKind::LinkArg => false,\n+            NativeLibKind::RawDylib\n+            | NativeLibKind::Unspecified\n+            | NativeLibKind::LinkArg\n+            | NativeLibKind::WasmImportModule => false,\n         }\n     }\n "}, {"sha": "d727aba6de5f91fb4cf65a49a54debd006e4f8e7", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -880,7 +880,7 @@ impl Span {\n     pub fn fresh_expansion(self, expn_id: LocalExpnId) -> Span {\n         HygieneData::with(|data| {\n             self.with_ctxt(data.apply_mark(\n-                SyntaxContext::root(),\n+                self.ctxt(),\n                 expn_id.to_expn_id(),\n                 Transparency::Transparent,\n             ))"}, {"sha": "ee895f53eba9bf046faa4fc5eaaf45548771349b", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -448,25 +448,36 @@ impl SourceMap {\n         sp: Span,\n         filename_display_pref: FileNameDisplayPreference,\n     ) -> String {\n-        if self.files.borrow().source_files.is_empty() || sp.is_dummy() {\n-            return \"no-location\".to_string();\n-        }\n+        let (source_file, lo_line, lo_col, hi_line, hi_col) = self.span_to_location_info(sp);\n+\n+        let file_name = match source_file {\n+            Some(sf) => sf.name.display(filename_display_pref).to_string(),\n+            None => return \"no-location\".to_string(),\n+        };\n \n-        let lo = self.lookup_char_pos(sp.lo());\n-        let hi = self.lookup_char_pos(sp.hi());\n         format!(\n-            \"{}:{}:{}{}\",\n-            lo.file.name.display(filename_display_pref),\n-            lo.line,\n-            lo.col.to_usize() + 1,\n+            \"{file_name}:{lo_line}:{lo_col}{}\",\n             if let FileNameDisplayPreference::Short = filename_display_pref {\n                 String::new()\n             } else {\n-                format!(\": {}:{}\", hi.line, hi.col.to_usize() + 1)\n+                format!(\": {hi_line}:{hi_col}\")\n             }\n         )\n     }\n \n+    pub fn span_to_location_info(\n+        &self,\n+        sp: Span,\n+    ) -> (Option<Lrc<SourceFile>>, usize, usize, usize, usize) {\n+        if self.files.borrow().source_files.is_empty() || sp.is_dummy() {\n+            return (None, 0, 0, 0, 0);\n+        }\n+\n+        let lo = self.lookup_char_pos(sp.lo());\n+        let hi = self.lookup_char_pos(sp.hi());\n+        (Some(lo.file), lo.line, lo.col.to_usize() + 1, hi.line, hi.col.to_usize() + 1)\n+    }\n+\n     /// Format the span location suitable for embedding in build artifacts\n     pub fn span_to_embeddable_string(&self, sp: Span) -> String {\n         self.span_to_string(sp, FileNameDisplayPreference::Remapped)"}, {"sha": "87fdaa14f6be0e54bc028d102af9e0d08d1e4598", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 40, "deletions": 31, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -11,8 +11,8 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         associated_item,\n         associated_item_def_ids,\n         associated_items,\n-        associated_items_for_impl_trait_in_trait,\n-        associated_item_for_impl_trait_in_trait,\n+        associated_types_for_impl_traits_in_associated_fn,\n+        associated_type_for_impl_trait_in_trait,\n         impl_item_implementor_ids,\n         ..*providers\n     };\n@@ -24,7 +24,7 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n             if tcx.lower_impl_trait_in_trait_to_assoc_ty() {\n                 // We collect RPITITs for each trait method's return type and create a\n-                // corresponding associated item using associated_items_for_impl_trait_in_trait\n+                // corresponding associated item using associated_types_for_impl_traits_in_associated_fn\n                 // query.\n                 tcx.arena.alloc_from_iter(\n                     trait_item_refs\n@@ -39,7 +39,9 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n                                 .flat_map(|trait_item_ref| {\n                                     let trait_fn_def_id =\n                                         trait_item_ref.id.owner_id.def_id.to_def_id();\n-                                    tcx.associated_items_for_impl_trait_in_trait(trait_fn_def_id)\n+                                    tcx.associated_types_for_impl_traits_in_associated_fn(\n+                                        trait_fn_def_id,\n+                                    )\n                                 })\n                                 .map(|def_id| *def_id),\n                         ),\n@@ -56,7 +58,7 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n             if tcx.lower_impl_trait_in_trait_to_assoc_ty() {\n                 // We collect RPITITs for each trait method's return type, on the impl side too and\n                 // create a corresponding associated item using\n-                // associated_items_for_impl_trait_in_trait query.\n+                // associated_types_for_impl_traits_in_associated_fn query.\n                 tcx.arena.alloc_from_iter(\n                     impl_\n                         .items\n@@ -72,7 +74,9 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n                                 .flat_map(|impl_item_ref| {\n                                     let impl_fn_def_id =\n                                         impl_item_ref.id.owner_id.def_id.to_def_id();\n-                                    tcx.associated_items_for_impl_trait_in_trait(impl_fn_def_id)\n+                                    tcx.associated_types_for_impl_traits_in_associated_fn(\n+                                        impl_fn_def_id,\n+                                    )\n                                 })\n                                 .map(|def_id| *def_id)\n                         })),\n@@ -176,13 +180,19 @@ fn associated_item_from_impl_item_ref(impl_item_ref: &hir::ImplItemRef) -> ty::A\n     }\n }\n \n-/// Given an `fn_def_id` of a trait or of an impl that implements a given trait:\n-/// if `fn_def_id` is the def id of a function defined inside a trait, then it creates and returns\n-/// the associated items that correspond to each impl trait in return position for that trait.\n-/// if `fn_def_id` is the def id of a function defined inside an impl that implements a trait, then it\n-/// creates and returns the associated items that correspond to each impl trait in return position\n-/// of the implemented trait.\n-fn associated_items_for_impl_trait_in_trait(tcx: TyCtxt<'_>, fn_def_id: DefId) -> &'_ [DefId] {\n+/// Given an `fn_def_id` of a trait or a trait implementation:\n+///\n+/// if `fn_def_id` is a function defined inside a trait, then it synthesizes\n+/// a new def id corresponding to a new associated type for each return-\n+/// position `impl Trait` in the signature.\n+///\n+/// if `fn_def_id` is a function inside of an impl, then for each synthetic\n+/// associated type generated for the corresponding trait function described\n+/// above, synthesize a corresponding associated type in the impl.\n+fn associated_types_for_impl_traits_in_associated_fn(\n+    tcx: TyCtxt<'_>,\n+    fn_def_id: DefId,\n+) -> &'_ [DefId] {\n     let parent_def_id = tcx.parent(fn_def_id);\n \n     match tcx.def_kind(parent_def_id) {\n@@ -206,7 +216,7 @@ fn associated_items_for_impl_trait_in_trait(tcx: TyCtxt<'_>, fn_def_id: DefId) -\n                 visitor.visit_fn_ret_ty(output);\n \n                 tcx.arena.alloc_from_iter(visitor.rpits.iter().map(|opaque_ty_def_id| {\n-                    tcx.associated_item_for_impl_trait_in_trait(opaque_ty_def_id).to_def_id()\n+                    tcx.associated_type_for_impl_trait_in_trait(opaque_ty_def_id).to_def_id()\n                 }))\n             } else {\n                 &[]\n@@ -217,9 +227,9 @@ fn associated_items_for_impl_trait_in_trait(tcx: TyCtxt<'_>, fn_def_id: DefId) -\n             let Some(trait_fn_def_id) = tcx.associated_item(fn_def_id).trait_item_def_id else { return &[] };\n \n             tcx.arena.alloc_from_iter(\n-                tcx.associated_items_for_impl_trait_in_trait(trait_fn_def_id).iter().map(\n+                tcx.associated_types_for_impl_traits_in_associated_fn(trait_fn_def_id).iter().map(\n                     move |trait_assoc_def_id| {\n-                        impl_associated_item_for_impl_trait_in_trait(\n+                        associated_type_for_impl_trait_in_impl(\n                             tcx,\n                             trait_assoc_def_id.expect_local(),\n                             fn_def_id.expect_local(),\n@@ -231,16 +241,17 @@ fn associated_items_for_impl_trait_in_trait(tcx: TyCtxt<'_>, fn_def_id: DefId) -\n         }\n \n         def_kind => bug!(\n-            \"associated_items_for_impl_trait_in_trait: {:?} should be Trait or Impl but is {:?}\",\n+            \"associated_types_for_impl_traits_in_associated_fn: {:?} should be Trait or Impl but is {:?}\",\n             parent_def_id,\n             def_kind\n         ),\n     }\n }\n \n-/// Given an `opaque_ty_def_id` corresponding to an impl trait in trait, create and return the\n-/// corresponding associated item.\n-fn associated_item_for_impl_trait_in_trait(\n+/// Given an `opaque_ty_def_id` corresponding to an `impl Trait` in an associated\n+/// function from a trait, synthesize an associated type for that `impl Trait`\n+/// that inherits properties that we infer from the method and the opaque type.\n+fn associated_type_for_impl_trait_in_trait(\n     tcx: TyCtxt<'_>,\n     opaque_ty_def_id: LocalDefId,\n ) -> LocalDefId {\n@@ -335,10 +346,12 @@ fn associated_item_for_impl_trait_in_trait(\n     local_def_id\n }\n \n-/// Given an `trait_assoc_def_id` that corresponds to a previously synthesized impl trait in trait\n-/// into an associated type and an `impl_def_id` corresponding to an impl block, create and return\n-/// the corresponding associated item inside the impl block.\n-fn impl_associated_item_for_impl_trait_in_trait(\n+/// Given an `trait_assoc_def_id` corresponding to an associated item synthesized\n+/// from an `impl Trait` in an associated function from a trait, and an\n+/// `impl_fn_def_id` that represents an implementation of the associated function\n+/// that the `impl Trait` comes from, synthesize an associated type for that `impl Trait`\n+/// that inherits properties that we infer from the method and the associated type.\n+fn associated_type_for_impl_trait_in_impl(\n     tcx: TyCtxt<'_>,\n     trait_assoc_def_id: LocalDefId,\n     impl_fn_def_id: LocalDefId,\n@@ -383,6 +396,8 @@ fn impl_associated_item_for_impl_trait_in_trait(\n     impl_assoc_ty.impl_defaultness(tcx.impl_defaultness(impl_fn_def_id));\n \n     // Copy generics_of the trait's associated item but the impl as the parent.\n+    // FIXME(-Zlower-impl-trait-in-trait-to-assoc-ty) resolves to the trait instead of the impl\n+    // generics.\n     impl_assoc_ty.generics_of({\n         let trait_assoc_generics = tcx.generics_of(trait_assoc_def_id);\n         let trait_assoc_parent_count = trait_assoc_generics.parent_count;\n@@ -391,16 +406,10 @@ fn impl_associated_item_for_impl_trait_in_trait(\n         let parent_generics = tcx.generics_of(impl_def_id);\n         let parent_count = parent_generics.parent_count + parent_generics.params.len();\n \n-        let mut impl_fn_params = tcx.generics_of(impl_fn_def_id).params.clone();\n-\n         for param in &mut params {\n-            param.index = param.index + parent_count as u32 + impl_fn_params.len() as u32\n-                - trait_assoc_parent_count as u32;\n+            param.index = param.index + parent_count as u32 - trait_assoc_parent_count as u32;\n         }\n \n-        impl_fn_params.extend(params);\n-        params = impl_fn_params;\n-\n         let param_def_id_to_index =\n             params.iter().map(|param| (param.def_id, param.index)).collect();\n "}, {"sha": "64fc1c0c2774171f976bd595c224bcf5e96c6da1", "filename": "library/core/src/intrinsics/mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -8,7 +8,7 @@\n //!\n //! The documentation for this module describes how to use this feature. If you are interested in\n //! hacking on the implementation, most of that documentation lives at\n-//! `rustc_mir_building/src/build/custom/mod.rs`.\n+//! `rustc_mir_build/src/build/custom/mod.rs`.\n //!\n //! Typical usage will look like this:\n //!"}, {"sha": "f19636fba5d95fdde9209b61da38ca554b347a78", "filename": "library/core/src/iter/range.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Frange.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,4 +1,5 @@\n use crate::convert::TryFrom;\n+use crate::marker::Destruct;\n use crate::mem;\n use crate::ops::{self, Try};\n \n@@ -20,7 +21,8 @@ unsafe_impl_trusted_step![char i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usi\n /// The *successor* operation moves towards values that compare greater.\n /// The *predecessor* operation moves towards values that compare lesser.\n #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n-pub trait Step: Clone + PartialOrd + Sized {\n+#[const_trait]\n+pub trait Step: ~const Clone + ~const PartialOrd + Sized {\n     /// Returns the number of *successor* steps required to get from `start` to `end`.\n     ///\n     /// Returns `None` if the number of steps would overflow `usize`\n@@ -234,7 +236,8 @@ macro_rules! step_integer_impls {\n         $(\n             #[allow(unreachable_patterns)]\n             #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n-            impl Step for $u_narrower {\n+            #[rustc_const_unstable(feature = \"const_iter\", issue = \"92476\")]\n+            impl const Step for $u_narrower {\n                 step_identical_methods!();\n \n                 #[inline]\n@@ -266,7 +269,8 @@ macro_rules! step_integer_impls {\n \n             #[allow(unreachable_patterns)]\n             #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n-            impl Step for $i_narrower {\n+            #[rustc_const_unstable(feature = \"const_iter\", issue = \"92476\")]\n+            impl const Step for $i_narrower {\n                 step_identical_methods!();\n \n                 #[inline]\n@@ -330,7 +334,8 @@ macro_rules! step_integer_impls {\n         $(\n             #[allow(unreachable_patterns)]\n             #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n-            impl Step for $u_wider {\n+            #[rustc_const_unstable(feature = \"const_iter\", issue = \"92476\")]\n+            impl const Step for $u_wider {\n                 step_identical_methods!();\n \n                 #[inline]\n@@ -355,7 +360,8 @@ macro_rules! step_integer_impls {\n \n             #[allow(unreachable_patterns)]\n             #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n-            impl Step for $i_wider {\n+            #[rustc_const_unstable(feature = \"const_iter\", issue = \"92476\")]\n+            impl const Step for $i_wider {\n                 step_identical_methods!();\n \n                 #[inline]\n@@ -405,7 +411,8 @@ step_integer_impls! {\n }\n \n #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n-impl Step for char {\n+#[rustc_const_unstable(feature = \"const_iter\", issue = \"92476\")]\n+impl const Step for char {\n     #[inline]\n     fn steps_between(&start: &char, &end: &char) -> Option<usize> {\n         let start = start as u32;\n@@ -423,6 +430,7 @@ impl Step for char {\n     }\n \n     #[inline]\n+    #[rustc_allow_const_fn_unstable(const_try)]\n     fn forward_checked(start: char, count: usize) -> Option<char> {\n         let start = start as u32;\n         let mut res = Step::forward_checked(start, count)?;\n@@ -439,6 +447,7 @@ impl Step for char {\n     }\n \n     #[inline]\n+    #[rustc_allow_const_fn_unstable(const_try)]\n     fn backward_checked(start: char, count: usize) -> Option<char> {\n         let start = start as u32;\n         let mut res = Step::backward_checked(start, count)?;\n@@ -514,6 +523,7 @@ macro_rules! range_incl_exact_iter_impl {\n }\n \n /// Specialization implementations for `Range`.\n+#[const_trait]\n trait RangeIteratorImpl {\n     type Item;\n \n@@ -528,7 +538,7 @@ trait RangeIteratorImpl {\n     fn spec_advance_back_by(&mut self, n: usize) -> Result<(), usize>;\n }\n \n-impl<A: Step> RangeIteratorImpl for ops::Range<A> {\n+impl<A: ~const Step + ~const Destruct> const RangeIteratorImpl for ops::Range<A> {\n     type Item = A;\n \n     #[inline]\n@@ -614,7 +624,7 @@ impl<A: Step> RangeIteratorImpl for ops::Range<A> {\n     }\n }\n \n-impl<T: TrustedStep> RangeIteratorImpl for ops::Range<T> {\n+impl<T: ~const TrustedStep + ~const Destruct> const RangeIteratorImpl for ops::Range<T> {\n     #[inline]\n     fn spec_next(&mut self) -> Option<T> {\n         if self.start < self.end {\n@@ -702,7 +712,8 @@ impl<T: TrustedStep> RangeIteratorImpl for ops::Range<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Step> Iterator for ops::Range<A> {\n+#[rustc_const_unstable(feature = \"const_iter\", issue = \"92476\")]\n+impl<A: ~const Step + ~const Destruct> const Iterator for ops::Range<A> {\n     type Item = A;\n \n     #[inline]\n@@ -812,7 +823,8 @@ range_incl_exact_iter_impl! {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n+#[rustc_const_unstable(feature = \"const_iter\", issue = \"92476\")]\n+impl<A: ~const Step + ~const Destruct> const DoubleEndedIterator for ops::Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         self.spec_next_back()"}, {"sha": "7a10dea500a969a7e344d79b97cf3f6c590535b0", "filename": "library/core/src/iter/traits/double_ended.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,3 +1,4 @@\n+use crate::marker::Destruct;\n use crate::ops::{ControlFlow, Try};\n \n /// An iterator able to yield elements from both ends.\n@@ -37,6 +38,7 @@ use crate::ops::{ControlFlow, Try};\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"DoubleEndedIterator\")]\n+#[const_trait]\n pub trait DoubleEndedIterator: Iterator {\n     /// Removes and returns an element from the end of the iterator.\n     ///\n@@ -131,7 +133,10 @@ pub trait DoubleEndedIterator: Iterator {\n     /// [`Err(k)`]: Err\n     #[inline]\n     #[unstable(feature = \"iter_advance_by\", reason = \"recently added\", issue = \"77404\")]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize>\n+    where\n+        Self::Item: ~const Destruct,\n+    {\n         for i in 0..n {\n             self.next_back().ok_or(i)?;\n         }\n@@ -181,6 +186,7 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_nth_back\", since = \"1.37.0\")]\n+    #[rustc_do_not_const_check]\n     fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n         self.advance_back_by(n).ok()?;\n         self.next_back()\n@@ -218,6 +224,7 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n+    #[rustc_do_not_const_check]\n     fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n     where\n         Self: Sized,\n@@ -289,6 +296,7 @@ pub trait DoubleEndedIterator: Iterator {\n     #[doc(alias = \"foldr\")]\n     #[inline]\n     #[stable(feature = \"iter_rfold\", since = \"1.27.0\")]\n+    #[rustc_do_not_const_check]\n     fn rfold<B, F>(mut self, init: B, mut f: F) -> B\n     where\n         Self: Sized,\n@@ -344,6 +352,7 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_rfind\", since = \"1.27.0\")]\n+    #[rustc_do_not_const_check]\n     fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         Self: Sized,"}, {"sha": "6c3030336c6b893d0cf526a784e5956107905bc1", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,5 +1,6 @@\n use crate::array;\n use crate::cmp::{self, Ordering};\n+use crate::marker::Destruct;\n use crate::ops::{ChangeOutputType, ControlFlow, FromResidual, Residual, Try};\n \n use super::super::try_process;\n@@ -336,8 +337,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"iter_advance_by\", reason = \"recently added\", issue = \"77404\")]\n-    #[rustc_do_not_const_check]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize>\n+    where\n+        Self::Item: ~const Destruct,\n+    {\n         for i in 0..n {\n             self.next().ok_or(i)?;\n         }\n@@ -385,8 +388,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_do_not_const_check]\n-    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+    fn nth(&mut self, n: usize) -> Option<Self::Item>\n+    where\n+        Self::Item: ~const Destruct,\n+    {\n         self.advance_by(n).ok()?;\n         self.next()\n     }\n@@ -1998,7 +2003,7 @@ pub trait Iterator {\n     /// a.iter().map(|&x| x * 2).collect_into(&mut vec);\n     /// a.iter().map(|&x| x * 10).collect_into(&mut vec);\n     ///\n-    /// assert_eq!(vec![0, 1, 2, 4, 6, 10, 20, 30], vec);\n+    /// assert_eq!(vec, vec![0, 1, 2, 4, 6, 10, 20, 30]);\n     /// ```\n     ///\n     /// `Vec` can have a manual set capacity to avoid reallocating it:\n@@ -2013,7 +2018,7 @@ pub trait Iterator {\n     /// a.iter().map(|&x| x * 10).collect_into(&mut vec);\n     ///\n     /// assert_eq!(6, vec.capacity());\n-    /// println!(\"{:?}\", vec);\n+    /// assert_eq!(vec, vec![2, 4, 6, 10, 20, 30]);\n     /// ```\n     ///\n     /// The returned mutable reference can be used to continue the call chain:\n@@ -2027,12 +2032,12 @@ pub trait Iterator {\n     /// let count = a.iter().collect_into(&mut vec).iter().count();\n     ///\n     /// assert_eq!(count, vec.len());\n-    /// println!(\"Vec len is {}\", count);\n+    /// assert_eq!(vec, vec![1, 2, 3]);\n     ///\n     /// let count = a.iter().collect_into(&mut vec).iter().count();\n     ///\n     /// assert_eq!(count, vec.len());\n-    /// println!(\"Vec len now is {}\", count);\n+    /// assert_eq!(vec, vec![1, 2, 3, 1, 2, 3]);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"iter_collect_into\", reason = \"new API\", issue = \"94780\")]"}, {"sha": "c8f60defff771f7ca4a2064bd18e19e133f163f5", "filename": "library/core/src/iter/traits/marker.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -86,4 +86,5 @@ pub unsafe trait InPlaceIterable: Iterator {}\n /// for details. Consumers are free to rely on the invariants in unsafe code.\n #[unstable(feature = \"trusted_step\", issue = \"85731\")]\n #[rustc_specialization_trait]\n-pub unsafe trait TrustedStep: Step {}\n+#[const_trait]\n+pub unsafe trait TrustedStep: ~const Step {}"}, {"sha": "1076d357070ef5ee265cc807b75de0698f80021d", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -123,9 +123,11 @@\n #![feature(const_index_range_slice_index)]\n #![feature(const_inherent_unchecked_arith)]\n #![feature(const_int_unchecked_arith)]\n+#![feature(const_intoiterator_identity)]\n #![feature(const_intrinsic_forget)]\n #![feature(const_ipv4)]\n #![feature(const_ipv6)]\n+#![feature(const_iter)]\n #![feature(const_likely)]\n #![feature(const_maybe_uninit_uninit_array)]\n #![feature(const_maybe_uninit_as_mut_ptr)]"}, {"sha": "529f62f4d6cd7db5c2a53adc45f3b5b8ab3279d8", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -340,9 +340,9 @@ pub macro debug_assert_matches($($arg:tt)*) {\n #[stable(feature = \"matches_macro\", since = \"1.42.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"matches_macro\")]\n macro_rules! matches {\n-    ($expression:expr, $(|)? $( $pattern:pat_param )|+ $( if $guard: expr )? $(,)?) => {\n+    ($expression:expr, $pattern:pat $(if $guard:expr)? $(,)?) => {\n         match $expression {\n-            $( $pattern )|+ $( if $guard )? => true,\n+            $pattern $(if $guard)? => true,\n             _ => false\n         }\n     };"}, {"sha": "3e8d75df37868bb960e43c188e7aeb13a02dd497", "filename": "library/core/src/num/dec2flt/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fcommon.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -192,6 +192,7 @@ pub struct BiasedFp {\n }\n \n impl BiasedFp {\n+    #[inline]\n     pub const fn zero_pow2(e: i32) -> Self {\n         Self { f: 0, e }\n     }"}, {"sha": "1c9d68999d6f81957935a1e8f9cfcac15dcf3128", "filename": "library/core/src/num/dec2flt/float.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Ffloat.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -118,11 +118,13 @@ impl RawFloat for f32 {\n     const SMALLEST_POWER_OF_TEN: i32 = -65;\n     const LARGEST_POWER_OF_TEN: i32 = 38;\n \n+    #[inline]\n     fn from_u64(v: u64) -> Self {\n         debug_assert!(v <= Self::MAX_MANTISSA_FAST_PATH);\n         v as _\n     }\n \n+    #[inline]\n     fn from_u64_bits(v: u64) -> Self {\n         f32::from_bits((v & 0xFFFFFFFF) as u32)\n     }\n@@ -169,11 +171,13 @@ impl RawFloat for f64 {\n     const SMALLEST_POWER_OF_TEN: i32 = -342;\n     const LARGEST_POWER_OF_TEN: i32 = 308;\n \n+    #[inline]\n     fn from_u64(v: u64) -> Self {\n         debug_assert!(v <= Self::MAX_MANTISSA_FAST_PATH);\n         v as _\n     }\n \n+    #[inline]\n     fn from_u64_bits(v: u64) -> Self {\n         f64::from_bits(v)\n     }"}, {"sha": "3bc052df7a6c180eb71a8cafba0c8a5ab34d2b9f", "filename": "library/core/src/num/dec2flt/lemire.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Flemire.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Flemire.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Flemire.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -118,10 +118,12 @@ pub fn compute_float<F: RawFloat>(q: i64, mut w: u64) -> BiasedFp {\n /// This uses a pre-computed integer approximation for\n /// log2(10), where 217706 / 2^16 is accurate for the\n /// entire range of non-finite decimal exponents.\n+#[inline]\n fn power(q: i32) -> i32 {\n     (q.wrapping_mul(152_170 + 65536) >> 16) + 63\n }\n \n+#[inline]\n fn full_multiplication(a: u64, b: u64) -> (u64, u64) {\n     let r = (a as u128) * (b as u128);\n     (r as u64, (r >> 64) as u64)"}, {"sha": "58ffb950ad86b9c0d4c2ea497ff84b67a1ee26ee", "filename": "library/core/src/num/dec2flt/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -147,7 +147,13 @@ macro_rules! from_str_float_impl {\n             /// representable floating-point number to the number represented\n             /// by `src` (following the same rules for rounding as for the\n             /// results of primitive operations).\n-            #[inline]\n+            // We add the `#[inline(never)]` attribute, since its content will\n+            // be filled with that of `dec2flt`, which has #[inline(always)].\n+            // Since `dec2flt` is generic, a normal inline attribute on this function\n+            // with `dec2flt` having no attributes results in heavily repeated\n+            // generation of `dec2flt`, despite the fact only a maximum of 2\n+            // possible instances can ever exist. Adding #[inline(never)] avoids this.\n+            #[inline(never)]\n             fn from_str(src: &str) -> Result<Self, ParseFloatError> {\n                 dec2flt(src)\n             }\n@@ -202,12 +208,14 @@ impl fmt::Display for ParseFloatError {\n     }\n }\n \n+#[inline]\n pub(super) fn pfe_empty() -> ParseFloatError {\n     ParseFloatError { kind: FloatErrorKind::Empty }\n }\n \n // Used in unit tests, keep public.\n // This is much better than making FloatErrorKind and ParseFloatError::kind public.\n+#[inline]\n pub fn pfe_invalid() -> ParseFloatError {\n     ParseFloatError { kind: FloatErrorKind::Invalid }\n }\n@@ -220,6 +228,7 @@ fn biased_fp_to_float<T: RawFloat>(x: BiasedFp) -> T {\n }\n \n /// Converts a decimal string into a floating point number.\n+#[inline(always)] // Will be inlined into a function with `#[inline(never)]`, see above\n pub fn dec2flt<F: RawFloat>(s: &str) -> Result<F, ParseFloatError> {\n     let mut s = s.as_bytes();\n     let c = if let Some(&c) = s.first() {"}, {"sha": "8589e2bbd4fac2a58e4fb8d60e161c508a26e677", "filename": "library/core/src/num/dec2flt/number.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fnumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fnumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fnumber.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -33,6 +33,7 @@ pub struct Number {\n \n impl Number {\n     /// Detect if the float can be accurately reconstructed from native floats.\n+    #[inline]\n     fn is_fast_path<F: RawFloat>(&self) -> bool {\n         F::MIN_EXPONENT_FAST_PATH <= self.exponent\n             && self.exponent <= F::MAX_EXPONENT_DISGUISED_FAST_PATH"}, {"sha": "c4b89a6301965b6a6c8efbc0cbb5fe8173da189f", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1003,22 +1003,25 @@ impl<P, U> CoerceUnsized<Pin<U>> for Pin<P> where P: CoerceUnsized<U> {}\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<P, U> DispatchFromDyn<Pin<U>> for Pin<P> where P: DispatchFromDyn<U> {}\n \n-/// Constructs a <code>[Pin]<[&mut] T></code>, by pinning[^1] a `value: T` _locally_[^2].\n+/// Constructs a <code>[Pin]<[&mut] T></code>, by pinning a `value: T` locally.\n ///\n-/// Unlike [`Box::pin`], this does not involve a heap allocation.\n+/// Unlike [`Box::pin`], this does not create a new heap allocation. As explained\n+/// below, the element might still end up on the heap however.\n ///\n-/// [^1]: If the (type `T` of the) given value does not implement [`Unpin`], then this\n-/// effectively pins the `value` in memory, where it will be unable to be moved.\n-/// Otherwise, <code>[Pin]<[&mut] T></code> behaves like <code>[&mut] T</code>, and operations such\n-/// as [`mem::replace()`][crate::mem::replace] will allow extracting that value, and therefore,\n-/// moving it.\n-/// See [the `Unpin` section of the `pin` module][self#unpin] for more info.\n+/// The local pinning performed by this macro is usually dubbed \"stack\"-pinning.\n+/// Outside of `async` contexts locals do indeed get stored on the stack. In\n+/// `async` functions or blocks however, any locals crossing an `.await` point\n+/// are part of the state captured by the `Future`, and will use the storage of\n+/// those. That storage can either be on the heap or on the stack. Therefore,\n+/// local pinning is a more accurate term.\n ///\n-/// [^2]: This is usually dubbed \"stack\"-pinning. And whilst local values are almost always located\n-/// in the stack (_e.g._, when within the body of a non-`async` function), the truth is that inside\n-/// the body of an `async fn` or block \u2014more generally, the body of a generator\u2014 any locals crossing\n-/// an `.await` point \u2014a `yield` point\u2014 end up being part of the state captured by the `Future` \u2014by\n-/// the `Generator`\u2014, and thus will be stored wherever that one is.\n+/// If the type of the given value does not implement [`Unpin`], then this macro\n+/// pins the value in memory in a way that prevents moves. On the other hand,\n+/// if the type does implement [`Unpin`], <code>[Pin]<[&mut] T></code> behaves\n+/// like <code>[&mut] T</code>, and operations such as\n+/// [`mem::replace()`][crate::mem::replace] or [`mem::take()`](crate::mem::take)\n+/// will allow moves of the value.\n+/// See [the `Unpin` section of the `pin` module][self#unpin] for details.\n ///\n /// ## Examples\n ///\n@@ -1158,9 +1161,9 @@ impl<P, U> DispatchFromDyn<Pin<U>> for Pin<P> where P: DispatchFromDyn<U> {}\n ///\n /// If you really need to return a pinned value, consider using [`Box::pin`] instead.\n ///\n-/// On the other hand, pinning to the stack[<sup>2</sup>](#fn2) using [`pin!`] is likely to be\n-/// cheaper than pinning into a fresh heap allocation using [`Box::pin`]. Moreover, by virtue of not\n-/// even needing an allocator, [`pin!`] is the main non-`unsafe` `#![no_std]`-compatible [`Pin`]\n+/// On the other hand, local pinning using [`pin!`] is likely to be cheaper than\n+/// pinning into a fresh heap allocation using [`Box::pin`]. Moreover, by virtue of not\n+/// requiring an allocator, [`pin!`] is the main non-`unsafe` `#![no_std]`-compatible [`Pin`]\n /// constructor.\n ///\n /// [`Box::pin`]: ../../std/boxed/struct.Box.html#method.pin"}, {"sha": "88b84bd1352cc8c7baccd8730c353fac1dae81cc", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -132,9 +132,7 @@ iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, {\n         Self: Sized,\n         F: FnMut(&Self::Item, &Self::Item) -> Option<Ordering>,\n     {\n-        self.as_slice().windows(2).all(|w| {\n-            compare(&&w[0], &&w[1]).map(|o| o != Ordering::Greater).unwrap_or(false)\n-        })\n+        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n     }\n }}\n "}, {"sha": "57b6e0ce4bb238b215efefe9e93bc85d3fadb926", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -3822,7 +3822,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&'a T, &'a T) -> Option<Ordering>,\n     {\n-        self.iter().is_sorted_by(|a, b| compare(*a, *b))\n+        self.array_windows().all(|[a, b]| compare(a, b).map_or(false, Ordering::is_le))\n     }\n \n     /// Checks if the elements of this slice are sorted using the given key extraction function."}, {"sha": "d56687e48c96a0d15a3e56477c52219fedda8253", "filename": "library/core/tests/iter/consts.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Ftests%2Fiter%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Ftests%2Fiter%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fconsts.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,36 @@\n+#[test]\n+fn const_manual_iter() {\n+    struct S(bool);\n+\n+    impl const Iterator for S {\n+        type Item = ();\n+\n+        fn next(&mut self) -> Option<Self::Item> {\n+            if self.0 == false {\n+                self.0 = true;\n+                Some(())\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+    const {\n+        let mut val = S(false);\n+        assert!(val.next().is_some());\n+        assert!(val.next().is_none());\n+        assert!(val.next().is_none());\n+    }\n+}\n+\n+#[test]\n+fn const_range() {\n+    const {\n+        let mut arr = [0; 3];\n+        for i in 0..arr.len() {\n+            arr[i] = i;\n+        }\n+        assert!(arr[0] == 0);\n+        assert!(arr[1] == 1);\n+        assert!(arr[2] == 2);\n+    }\n+}"}, {"sha": "cbb18e79e2d430de00d042d5759e565f4415a249", "filename": "library/core/tests/iter/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Ftests%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Ftests%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fmod.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -20,6 +20,8 @@ mod range;\n mod sources;\n mod traits;\n \n+mod consts;\n+\n use core::cell::Cell;\n use core::convert::TryFrom;\n use core::iter::*;"}, {"sha": "637cc6e9f629bfffc8625047e58bc1bea247d399", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -12,8 +12,11 @@\n #![feature(const_caller_location)]\n #![feature(const_cell_into_inner)]\n #![feature(const_convert)]\n+#![feature(const_for)]\n #![feature(const_hash)]\n #![feature(const_heap)]\n+#![feature(const_intoiterator_identity)]\n+#![feature(const_iter)]\n #![feature(const_maybe_uninit_as_mut_ptr)]\n #![feature(const_maybe_uninit_assume_init_read)]\n #![feature(const_nonnull_new)]"}, {"sha": "4b31c552eedd2c06d84a593963a2209d8569995c", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -823,8 +823,22 @@ pub trait Read {\n \n     /// Read the exact number of bytes required to fill `cursor`.\n     ///\n-    /// This is equivalent to the [`read_exact`](Read::read_exact) method, except that it is passed a [`BorrowedCursor`] rather than `[u8]` to\n-    /// allow use with uninitialized buffers.\n+    /// This is similar to the [`read_exact`](Read::read_exact) method, except\n+    /// that it is passed a [`BorrowedCursor`] rather than `[u8]` to allow use\n+    /// with uninitialized buffers.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If this function encounters an error of the kind [`ErrorKind::Interrupted`]\n+    /// then the error is ignored and the operation will continue.\n+    ///\n+    /// If this function encounters an \"end of file\" before completely filling\n+    /// the buffer, it returns an error of the kind [`ErrorKind::UnexpectedEof`].\n+    ///\n+    /// If any other read error is encountered then this function immediately\n+    /// returns.\n+    ///\n+    /// If this function returns an error, all bytes read will be appended to `cursor`.\n     #[unstable(feature = \"read_buf\", issue = \"78485\")]\n     fn read_buf_exact(&mut self, mut cursor: BorrowedCursor<'_>) -> Result<()> {\n         while cursor.capacity() > 0 {"}, {"sha": "345d72ef8678e87ccf395e1d81ec09db0ce98abe", "filename": "library/std/src/panic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fstd%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fstd%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanic.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -308,8 +308,7 @@ pub fn get_backtrace_style() -> Option<BacktraceStyle> {\n                 BacktraceStyle::Short\n             }\n         })\n-        .unwrap_or(if cfg!(target_os = \"fuchsia\") {\n-            // Fuchsia components default to full backtrace.\n+        .unwrap_or(if crate::sys::FULL_BACKTRACE_DEFAULT {\n             BacktraceStyle::Full\n         } else {\n             BacktraceStyle::Off"}, {"sha": "e767b2866cb9bc1a3445b57c92b6c25e3d3e1b0e", "filename": "library/std/src/sys/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -76,3 +76,12 @@ cfg_if::cfg_if! {\n         pub mod c;\n     }\n }\n+\n+cfg_if::cfg_if! {\n+    // Fuchsia components default to full backtrace.\n+    if #[cfg(target_os = \"fuchsia\")] {\n+        pub const FULL_BACKTRACE_DEFAULT: bool = true;\n+    } else {\n+        pub const FULL_BACKTRACE_DEFAULT: bool = false;\n+    }\n+}"}, {"sha": "1f4092ad73847c0977f22cccf4e0a00d9005a8ee", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 40, "deletions": 47, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -296,7 +296,6 @@ pub const STATUS_INVALID_PARAMETER: NTSTATUS = 0xc000000d_u32 as _;\n \n pub const STATUS_PENDING: NTSTATUS = 0x103 as _;\n pub const STATUS_END_OF_FILE: NTSTATUS = 0xC0000011_u32 as _;\n-pub const STATUS_NOT_IMPLEMENTED: NTSTATUS = 0xC0000002_u32 as _;\n \n // Equivalent to the `NT_SUCCESS` C preprocessor macro.\n // See: https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/using-ntstatus-values\n@@ -1282,6 +1281,46 @@ extern \"system\" {\n     ) -> NTSTATUS;\n }\n \n+#[link(name = \"ntdll\")]\n+extern \"system\" {\n+    pub fn NtCreateFile(\n+        FileHandle: *mut HANDLE,\n+        DesiredAccess: ACCESS_MASK,\n+        ObjectAttributes: *const OBJECT_ATTRIBUTES,\n+        IoStatusBlock: *mut IO_STATUS_BLOCK,\n+        AllocationSize: *mut i64,\n+        FileAttributes: ULONG,\n+        ShareAccess: ULONG,\n+        CreateDisposition: ULONG,\n+        CreateOptions: ULONG,\n+        EaBuffer: *mut c_void,\n+        EaLength: ULONG,\n+    ) -> NTSTATUS;\n+    pub fn NtReadFile(\n+        FileHandle: BorrowedHandle<'_>,\n+        Event: HANDLE,\n+        ApcRoutine: Option<IO_APC_ROUTINE>,\n+        ApcContext: *mut c_void,\n+        IoStatusBlock: &mut IO_STATUS_BLOCK,\n+        Buffer: *mut crate::mem::MaybeUninit<u8>,\n+        Length: ULONG,\n+        ByteOffset: Option<&LARGE_INTEGER>,\n+        Key: Option<&ULONG>,\n+    ) -> NTSTATUS;\n+    pub fn NtWriteFile(\n+        FileHandle: BorrowedHandle<'_>,\n+        Event: HANDLE,\n+        ApcRoutine: Option<IO_APC_ROUTINE>,\n+        ApcContext: *mut c_void,\n+        IoStatusBlock: &mut IO_STATUS_BLOCK,\n+        Buffer: *const u8,\n+        Length: ULONG,\n+        ByteOffset: Option<&LARGE_INTEGER>,\n+        Key: Option<&ULONG>,\n+    ) -> NTSTATUS;\n+    pub fn RtlNtStatusToDosError(Status: NTSTATUS) -> ULONG;\n+}\n+\n // Functions that aren't available on every version of Windows that we support,\n // but we still use them and just provide some form of a fallback implementation.\n compat_fn_with_fallback! {\n@@ -1322,52 +1361,6 @@ compat_fn_optional! {\n compat_fn_with_fallback! {\n     pub static NTDLL: &CStr = ansi_str!(\"ntdll\");\n \n-    pub fn NtCreateFile(\n-        FileHandle: *mut HANDLE,\n-        DesiredAccess: ACCESS_MASK,\n-        ObjectAttributes: *const OBJECT_ATTRIBUTES,\n-        IoStatusBlock: *mut IO_STATUS_BLOCK,\n-        AllocationSize: *mut i64,\n-        FileAttributes: ULONG,\n-        ShareAccess: ULONG,\n-        CreateDisposition: ULONG,\n-        CreateOptions: ULONG,\n-        EaBuffer: *mut c_void,\n-        EaLength: ULONG\n-    ) -> NTSTATUS {\n-        STATUS_NOT_IMPLEMENTED\n-    }\n-    pub fn NtReadFile(\n-        FileHandle: BorrowedHandle<'_>,\n-        Event: HANDLE,\n-        ApcRoutine: Option<IO_APC_ROUTINE>,\n-        ApcContext: *mut c_void,\n-        IoStatusBlock: &mut IO_STATUS_BLOCK,\n-        Buffer: *mut crate::mem::MaybeUninit<u8>,\n-        Length: ULONG,\n-        ByteOffset: Option<&LARGE_INTEGER>,\n-        Key: Option<&ULONG>\n-    ) -> NTSTATUS {\n-        STATUS_NOT_IMPLEMENTED\n-    }\n-    pub fn NtWriteFile(\n-        FileHandle: BorrowedHandle<'_>,\n-        Event: HANDLE,\n-        ApcRoutine: Option<IO_APC_ROUTINE>,\n-        ApcContext: *mut c_void,\n-        IoStatusBlock: &mut IO_STATUS_BLOCK,\n-        Buffer: *const u8,\n-        Length: ULONG,\n-        ByteOffset: Option<&LARGE_INTEGER>,\n-        Key: Option<&ULONG>\n-    ) -> NTSTATUS {\n-        STATUS_NOT_IMPLEMENTED\n-    }\n-    pub fn RtlNtStatusToDosError(\n-        Status: NTSTATUS\n-    ) -> ULONG {\n-        Status as ULONG\n-    }\n     pub fn NtCreateKeyedEvent(\n         KeyedEventHandle: LPHANDLE,\n         DesiredAccess: ACCESS_MASK,"}, {"sha": "7eee4ca236190ba7c25465dd7ed508eac4611e1c", "filename": "library/test/src/console.rs", "status": "modified", "additions": 57, "deletions": 26, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Ftest%2Fsrc%2Fconsole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Ftest%2Fsrc%2Fconsole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fconsole.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -41,6 +41,46 @@ impl<T: Write> Write for OutputLocation<T> {\n     }\n }\n \n+pub struct ConsoleTestDiscoveryState {\n+    pub log_out: Option<File>,\n+    pub tests: usize,\n+    pub benchmarks: usize,\n+    pub ignored: usize,\n+    pub options: Options,\n+}\n+\n+impl ConsoleTestDiscoveryState {\n+    pub fn new(opts: &TestOpts) -> io::Result<ConsoleTestDiscoveryState> {\n+        let log_out = match opts.logfile {\n+            Some(ref path) => Some(File::create(path)?),\n+            None => None,\n+        };\n+\n+        Ok(ConsoleTestDiscoveryState {\n+            log_out,\n+            tests: 0,\n+            benchmarks: 0,\n+            ignored: 0,\n+            options: opts.options,\n+        })\n+    }\n+\n+    pub fn write_log<F, S>(&mut self, msg: F) -> io::Result<()>\n+    where\n+        S: AsRef<str>,\n+        F: FnOnce() -> S,\n+    {\n+        match self.log_out {\n+            None => Ok(()),\n+            Some(ref mut o) => {\n+                let msg = msg();\n+                let msg = msg.as_ref();\n+                o.write_all(msg.as_bytes())\n+            }\n+        }\n+    }\n+}\n+\n pub struct ConsoleTestState {\n     pub log_out: Option<File>,\n     pub total: usize,\n@@ -138,53 +178,44 @@ impl ConsoleTestState {\n \n // List the tests to console, and optionally to logfile. Filters are honored.\n pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<()> {\n-    let mut output = match term::stdout() {\n+    let output = match term::stdout() {\n         None => OutputLocation::Raw(io::stdout().lock()),\n         Some(t) => OutputLocation::Pretty(t),\n     };\n \n-    let quiet = opts.format == OutputFormat::Terse;\n-    let mut st = ConsoleTestState::new(opts)?;\n-\n-    let mut ntest = 0;\n-    let mut nbench = 0;\n+    let mut out: Box<dyn OutputFormatter> = match opts.format {\n+        OutputFormat::Pretty | OutputFormat::Junit => {\n+            Box::new(PrettyFormatter::new(output, false, 0, false, None))\n+        }\n+        OutputFormat::Terse => Box::new(TerseFormatter::new(output, false, 0, false)),\n+        OutputFormat::Json => Box::new(JsonFormatter::new(output)),\n+    };\n+    let mut st = ConsoleTestDiscoveryState::new(opts)?;\n \n+    out.write_discovery_start()?;\n     for test in filter_tests(opts, tests).into_iter() {\n         use crate::TestFn::*;\n \n-        let TestDescAndFn { desc: TestDesc { name, .. }, testfn } = test;\n+        let TestDescAndFn { desc, testfn } = test;\n \n         let fntype = match testfn {\n             StaticTestFn(..) | DynTestFn(..) => {\n-                ntest += 1;\n+                st.tests += 1;\n                 \"test\"\n             }\n             StaticBenchFn(..) | DynBenchFn(..) => {\n-                nbench += 1;\n+                st.benchmarks += 1;\n                 \"benchmark\"\n             }\n         };\n \n-        writeln!(output, \"{name}: {fntype}\")?;\n-        st.write_log(|| format!(\"{fntype} {name}\\n\"))?;\n-    }\n+        st.ignored += if desc.ignore { 1 } else { 0 };\n \n-    fn plural(count: u32, s: &str) -> String {\n-        match count {\n-            1 => format!(\"1 {s}\"),\n-            n => format!(\"{n} {s}s\"),\n-        }\n+        out.write_test_discovered(&desc, fntype)?;\n+        st.write_log(|| format!(\"{fntype} {}\\n\", desc.name))?;\n     }\n \n-    if !quiet {\n-        if ntest != 0 || nbench != 0 {\n-            writeln!(output)?;\n-        }\n-\n-        writeln!(output, \"{}, {}\", plural(ntest, \"test\"), plural(nbench, \"benchmark\"))?;\n-    }\n-\n-    Ok(())\n+    out.write_discovery_finish(&st)\n }\n \n // Updates `ConsoleTestState` depending on result of the test execution."}, {"sha": "40976ec5e1c8b037660e3319b7a7fa587f383948", "filename": "library/test/src/formatters/json.rs", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Ftest%2Fsrc%2Fformatters%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Ftest%2Fsrc%2Fformatters%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fformatters%2Fjson.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -2,7 +2,7 @@ use std::{borrow::Cow, io, io::prelude::Write};\n \n use super::OutputFormatter;\n use crate::{\n-    console::{ConsoleTestState, OutputLocation},\n+    console::{ConsoleTestDiscoveryState, ConsoleTestState, OutputLocation},\n     test_result::TestResult,\n     time,\n     types::TestDesc,\n@@ -60,6 +60,56 @@ impl<T: Write> JsonFormatter<T> {\n }\n \n impl<T: Write> OutputFormatter for JsonFormatter<T> {\n+    fn write_discovery_start(&mut self) -> io::Result<()> {\n+        self.writeln_message(&format!(r#\"{{ \"type\": \"suite\", \"event\": \"discovery\" }}\"#))\n+    }\n+\n+    fn write_test_discovered(&mut self, desc: &TestDesc, test_type: &str) -> io::Result<()> {\n+        let TestDesc {\n+            name,\n+            ignore,\n+            ignore_message,\n+            #[cfg(not(bootstrap))]\n+            source_file,\n+            #[cfg(not(bootstrap))]\n+            start_line,\n+            #[cfg(not(bootstrap))]\n+            start_col,\n+            #[cfg(not(bootstrap))]\n+            end_line,\n+            #[cfg(not(bootstrap))]\n+            end_col,\n+            ..\n+        } = desc;\n+\n+        #[cfg(bootstrap)]\n+        let source_file = \"\";\n+        #[cfg(bootstrap)]\n+        let start_line = 0;\n+        #[cfg(bootstrap)]\n+        let start_col = 0;\n+        #[cfg(bootstrap)]\n+        let end_line = 0;\n+        #[cfg(bootstrap)]\n+        let end_col = 0;\n+\n+        self.writeln_message(&format!(\n+            r#\"{{ \"type\": \"{test_type}\", \"event\": \"discovered\", \"name\": \"{}\", \"ignore\": {ignore}, \"ignore_message\": \"{}\", \"source_path\": \"{}\", \"start_line\": {start_line}, \"start_col\": {start_col}, \"end_line\": {end_line}, \"end_col\": {end_col} }}\"#,\n+            EscapedString(name.as_slice()),\n+            ignore_message.unwrap_or(\"\"),\n+            EscapedString(source_file),\n+        ))\n+    }\n+\n+    fn write_discovery_finish(&mut self, state: &ConsoleTestDiscoveryState) -> io::Result<()> {\n+        let ConsoleTestDiscoveryState { tests, benchmarks, ignored, .. } = state;\n+\n+        let total = tests + benchmarks;\n+        self.writeln_message(&format!(\n+            r#\"{{ \"type\": \"suite\", \"event\": \"completed\", \"tests\": {tests}, \"benchmarks\": {benchmarks}, \"total\": {total}, \"ignored\": {ignored} }}\"#\n+        ))\n+    }\n+\n     fn write_run_start(&mut self, test_count: usize, shuffle_seed: Option<u64>) -> io::Result<()> {\n         let shuffle_seed_json = if let Some(shuffle_seed) = shuffle_seed {\n             format!(r#\", \"shuffle_seed\": {shuffle_seed}\"#)"}, {"sha": "2e07ce3c09923fc569dd62160af46110a91f7f09", "filename": "library/test/src/formatters/junit.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Ftest%2Fsrc%2Fformatters%2Fjunit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Ftest%2Fsrc%2Fformatters%2Fjunit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fformatters%2Fjunit.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -3,7 +3,7 @@ use std::time::Duration;\n \n use super::OutputFormatter;\n use crate::{\n-    console::{ConsoleTestState, OutputLocation},\n+    console::{ConsoleTestDiscoveryState, ConsoleTestState, OutputLocation},\n     test_result::TestResult,\n     time,\n     types::{TestDesc, TestType},\n@@ -27,6 +27,18 @@ impl<T: Write> JunitFormatter<T> {\n }\n \n impl<T: Write> OutputFormatter for JunitFormatter<T> {\n+    fn write_discovery_start(&mut self) -> io::Result<()> {\n+        Err(io::Error::new(io::ErrorKind::NotFound, \"Not yet implemented!\"))\n+    }\n+\n+    fn write_test_discovered(&mut self, _desc: &TestDesc, _test_type: &str) -> io::Result<()> {\n+        Err(io::Error::new(io::ErrorKind::NotFound, \"Not yet implemented!\"))\n+    }\n+\n+    fn write_discovery_finish(&mut self, _state: &ConsoleTestDiscoveryState) -> io::Result<()> {\n+        Err(io::Error::new(io::ErrorKind::NotFound, \"Not yet implemented!\"))\n+    }\n+\n     fn write_run_start(\n         &mut self,\n         _test_count: usize,"}, {"sha": "bc6ffebc1d3b2f85295c6e668042a2cebe2e3468", "filename": "library/test/src/formatters/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Ftest%2Fsrc%2Fformatters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Ftest%2Fsrc%2Fformatters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fformatters%2Fmod.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,7 +1,7 @@\n use std::{io, io::prelude::Write};\n \n use crate::{\n-    console::ConsoleTestState,\n+    console::{ConsoleTestDiscoveryState, ConsoleTestState},\n     test_result::TestResult,\n     time,\n     types::{TestDesc, TestName},\n@@ -18,6 +18,10 @@ pub(crate) use self::pretty::PrettyFormatter;\n pub(crate) use self::terse::TerseFormatter;\n \n pub(crate) trait OutputFormatter {\n+    fn write_discovery_start(&mut self) -> io::Result<()>;\n+    fn write_test_discovered(&mut self, desc: &TestDesc, test_type: &str) -> io::Result<()>;\n+    fn write_discovery_finish(&mut self, state: &ConsoleTestDiscoveryState) -> io::Result<()>;\n+\n     fn write_run_start(&mut self, test_count: usize, shuffle_seed: Option<u64>) -> io::Result<()>;\n     fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()>;\n     fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()>;"}, {"sha": "22654a3400b44f8fd0458df456b060b3d7f69f5c", "filename": "library/test/src/formatters/pretty.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Ftest%2Fsrc%2Fformatters%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Ftest%2Fsrc%2Fformatters%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fformatters%2Fpretty.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -3,7 +3,7 @@ use std::{io, io::prelude::Write};\n use super::OutputFormatter;\n use crate::{\n     bench::fmt_bench_samples,\n-    console::{ConsoleTestState, OutputLocation},\n+    console::{ConsoleTestDiscoveryState, ConsoleTestState, OutputLocation},\n     term,\n     test_result::TestResult,\n     time,\n@@ -181,6 +181,33 @@ impl<T: Write> PrettyFormatter<T> {\n }\n \n impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n+    fn write_discovery_start(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+\n+    fn write_test_discovered(&mut self, desc: &TestDesc, test_type: &str) -> io::Result<()> {\n+        self.write_plain(format!(\"{}: {test_type}\\n\", desc.name))\n+    }\n+\n+    fn write_discovery_finish(&mut self, state: &ConsoleTestDiscoveryState) -> io::Result<()> {\n+        fn plural(count: usize, s: &str) -> String {\n+            match count {\n+                1 => format!(\"1 {s}\"),\n+                n => format!(\"{n} {s}s\"),\n+            }\n+        }\n+\n+        if state.tests != 0 || state.benchmarks != 0 {\n+            self.write_plain(\"\\n\")?;\n+        }\n+\n+        self.write_plain(format!(\n+            \"{}, {}\\n\",\n+            plural(state.tests, \"test\"),\n+            plural(state.benchmarks, \"benchmark\")\n+        ))\n+    }\n+\n     fn write_run_start(&mut self, test_count: usize, shuffle_seed: Option<u64>) -> io::Result<()> {\n         let noun = if test_count != 1 { \"tests\" } else { \"test\" };\n         let shuffle_seed_msg = if let Some(shuffle_seed) = shuffle_seed {"}, {"sha": "2931ca6ead0ac59877e2dc5afa5cff277aa1359e", "filename": "library/test/src/formatters/terse.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Ftest%2Fsrc%2Fformatters%2Fterse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Ftest%2Fsrc%2Fformatters%2Fterse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fformatters%2Fterse.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -3,7 +3,7 @@ use std::{io, io::prelude::Write};\n use super::OutputFormatter;\n use crate::{\n     bench::fmt_bench_samples,\n-    console::{ConsoleTestState, OutputLocation},\n+    console::{ConsoleTestDiscoveryState, ConsoleTestState, OutputLocation},\n     term,\n     test_result::TestResult,\n     time,\n@@ -167,6 +167,18 @@ impl<T: Write> TerseFormatter<T> {\n }\n \n impl<T: Write> OutputFormatter for TerseFormatter<T> {\n+    fn write_discovery_start(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+\n+    fn write_test_discovered(&mut self, desc: &TestDesc, test_type: &str) -> io::Result<()> {\n+        self.write_plain(format!(\"{}: {test_type}\\n\", desc.name))\n+    }\n+\n+    fn write_discovery_finish(&mut self, _state: &ConsoleTestDiscoveryState) -> io::Result<()> {\n+        Ok(())\n+    }\n+\n     fn write_run_start(&mut self, test_count: usize, shuffle_seed: Option<u64>) -> io::Result<()> {\n         self.total_test_count = test_count;\n         let noun = if test_count != 1 { \"tests\" } else { \"test\" };"}, {"sha": "5ffdbf73fbf93368d45fa7cabdac9798667ae2e2", "filename": "library/test/src/tests.rs", "status": "modified", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Ftest%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Ftest%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Ftests.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -63,6 +63,16 @@ fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n                 name: StaticTestName(\"1\"),\n                 ignore: true,\n                 ignore_message: None,\n+                #[cfg(not(bootstrap))]\n+                source_file: \"\",\n+                #[cfg(not(bootstrap))]\n+                start_line: 0,\n+                #[cfg(not(bootstrap))]\n+                start_col: 0,\n+                #[cfg(not(bootstrap))]\n+                end_line: 0,\n+                #[cfg(not(bootstrap))]\n+                end_col: 0,\n                 should_panic: ShouldPanic::No,\n                 compile_fail: false,\n                 no_run: false,\n@@ -75,6 +85,16 @@ fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n                 name: StaticTestName(\"2\"),\n                 ignore: false,\n                 ignore_message: None,\n+                #[cfg(not(bootstrap))]\n+                source_file: \"\",\n+                #[cfg(not(bootstrap))]\n+                start_line: 0,\n+                #[cfg(not(bootstrap))]\n+                start_col: 0,\n+                #[cfg(not(bootstrap))]\n+                end_line: 0,\n+                #[cfg(not(bootstrap))]\n+                end_col: 0,\n                 should_panic: ShouldPanic::No,\n                 compile_fail: false,\n                 no_run: false,\n@@ -95,6 +115,16 @@ pub fn do_not_run_ignored_tests() {\n             name: StaticTestName(\"whatever\"),\n             ignore: true,\n             ignore_message: None,\n+            #[cfg(not(bootstrap))]\n+            source_file: \"\",\n+            #[cfg(not(bootstrap))]\n+            start_line: 0,\n+            #[cfg(not(bootstrap))]\n+            start_col: 0,\n+            #[cfg(not(bootstrap))]\n+            end_line: 0,\n+            #[cfg(not(bootstrap))]\n+            end_col: 0,\n             should_panic: ShouldPanic::No,\n             compile_fail: false,\n             no_run: false,\n@@ -118,6 +148,16 @@ pub fn ignored_tests_result_in_ignored() {\n             name: StaticTestName(\"whatever\"),\n             ignore: true,\n             ignore_message: None,\n+            #[cfg(not(bootstrap))]\n+            source_file: \"\",\n+            #[cfg(not(bootstrap))]\n+            start_line: 0,\n+            #[cfg(not(bootstrap))]\n+            start_col: 0,\n+            #[cfg(not(bootstrap))]\n+            end_line: 0,\n+            #[cfg(not(bootstrap))]\n+            end_col: 0,\n             should_panic: ShouldPanic::No,\n             compile_fail: false,\n             no_run: false,\n@@ -143,6 +183,16 @@ fn test_should_panic() {\n             name: StaticTestName(\"whatever\"),\n             ignore: false,\n             ignore_message: None,\n+            #[cfg(not(bootstrap))]\n+            source_file: \"\",\n+            #[cfg(not(bootstrap))]\n+            start_line: 0,\n+            #[cfg(not(bootstrap))]\n+            start_col: 0,\n+            #[cfg(not(bootstrap))]\n+            end_line: 0,\n+            #[cfg(not(bootstrap))]\n+            end_col: 0,\n             should_panic: ShouldPanic::Yes,\n             compile_fail: false,\n             no_run: false,\n@@ -168,6 +218,16 @@ fn test_should_panic_good_message() {\n             name: StaticTestName(\"whatever\"),\n             ignore: false,\n             ignore_message: None,\n+            #[cfg(not(bootstrap))]\n+            source_file: \"\",\n+            #[cfg(not(bootstrap))]\n+            start_line: 0,\n+            #[cfg(not(bootstrap))]\n+            start_col: 0,\n+            #[cfg(not(bootstrap))]\n+            end_line: 0,\n+            #[cfg(not(bootstrap))]\n+            end_col: 0,\n             should_panic: ShouldPanic::YesWithMessage(\"error message\"),\n             compile_fail: false,\n             no_run: false,\n@@ -198,6 +258,16 @@ fn test_should_panic_bad_message() {\n             name: StaticTestName(\"whatever\"),\n             ignore: false,\n             ignore_message: None,\n+            #[cfg(not(bootstrap))]\n+            source_file: \"\",\n+            #[cfg(not(bootstrap))]\n+            start_line: 0,\n+            #[cfg(not(bootstrap))]\n+            start_col: 0,\n+            #[cfg(not(bootstrap))]\n+            end_line: 0,\n+            #[cfg(not(bootstrap))]\n+            end_col: 0,\n             should_panic: ShouldPanic::YesWithMessage(expected),\n             compile_fail: false,\n             no_run: false,\n@@ -232,6 +302,16 @@ fn test_should_panic_non_string_message_type() {\n             name: StaticTestName(\"whatever\"),\n             ignore: false,\n             ignore_message: None,\n+            #[cfg(not(bootstrap))]\n+            source_file: \"\",\n+            #[cfg(not(bootstrap))]\n+            start_line: 0,\n+            #[cfg(not(bootstrap))]\n+            start_col: 0,\n+            #[cfg(not(bootstrap))]\n+            end_line: 0,\n+            #[cfg(not(bootstrap))]\n+            end_col: 0,\n             should_panic: ShouldPanic::YesWithMessage(expected),\n             compile_fail: false,\n             no_run: false,\n@@ -260,6 +340,16 @@ fn test_should_panic_but_succeeds() {\n                 name: StaticTestName(\"whatever\"),\n                 ignore: false,\n                 ignore_message: None,\n+                #[cfg(not(bootstrap))]\n+                source_file: \"\",\n+                #[cfg(not(bootstrap))]\n+                start_line: 0,\n+                #[cfg(not(bootstrap))]\n+                start_col: 0,\n+                #[cfg(not(bootstrap))]\n+                end_line: 0,\n+                #[cfg(not(bootstrap))]\n+                end_col: 0,\n                 should_panic,\n                 compile_fail: false,\n                 no_run: false,\n@@ -288,6 +378,16 @@ fn report_time_test_template(report_time: bool) -> Option<TestExecTime> {\n             name: StaticTestName(\"whatever\"),\n             ignore: false,\n             ignore_message: None,\n+            #[cfg(not(bootstrap))]\n+            source_file: \"\",\n+            #[cfg(not(bootstrap))]\n+            start_line: 0,\n+            #[cfg(not(bootstrap))]\n+            start_col: 0,\n+            #[cfg(not(bootstrap))]\n+            end_line: 0,\n+            #[cfg(not(bootstrap))]\n+            end_col: 0,\n             should_panic: ShouldPanic::No,\n             compile_fail: false,\n             no_run: false,\n@@ -325,6 +425,16 @@ fn time_test_failure_template(test_type: TestType) -> TestResult {\n             name: StaticTestName(\"whatever\"),\n             ignore: false,\n             ignore_message: None,\n+            #[cfg(not(bootstrap))]\n+            source_file: \"\",\n+            #[cfg(not(bootstrap))]\n+            start_line: 0,\n+            #[cfg(not(bootstrap))]\n+            start_col: 0,\n+            #[cfg(not(bootstrap))]\n+            end_line: 0,\n+            #[cfg(not(bootstrap))]\n+            end_col: 0,\n             should_panic: ShouldPanic::No,\n             compile_fail: false,\n             no_run: false,\n@@ -364,6 +474,16 @@ fn typed_test_desc(test_type: TestType) -> TestDesc {\n         name: StaticTestName(\"whatever\"),\n         ignore: false,\n         ignore_message: None,\n+        #[cfg(not(bootstrap))]\n+        source_file: \"\",\n+        #[cfg(not(bootstrap))]\n+        start_line: 0,\n+        #[cfg(not(bootstrap))]\n+        start_col: 0,\n+        #[cfg(not(bootstrap))]\n+        end_line: 0,\n+        #[cfg(not(bootstrap))]\n+        end_col: 0,\n         should_panic: ShouldPanic::No,\n         compile_fail: false,\n         no_run: false,\n@@ -476,6 +596,16 @@ pub fn exclude_should_panic_option() {\n             name: StaticTestName(\"3\"),\n             ignore: false,\n             ignore_message: None,\n+            #[cfg(not(bootstrap))]\n+            source_file: \"\",\n+            #[cfg(not(bootstrap))]\n+            start_line: 0,\n+            #[cfg(not(bootstrap))]\n+            start_col: 0,\n+            #[cfg(not(bootstrap))]\n+            end_line: 0,\n+            #[cfg(not(bootstrap))]\n+            end_col: 0,\n             should_panic: ShouldPanic::Yes,\n             compile_fail: false,\n             no_run: false,\n@@ -500,6 +630,16 @@ pub fn exact_filter_match() {\n                     name: StaticTestName(name),\n                     ignore: false,\n                     ignore_message: None,\n+                    #[cfg(not(bootstrap))]\n+                    source_file: \"\",\n+                    #[cfg(not(bootstrap))]\n+                    start_line: 0,\n+                    #[cfg(not(bootstrap))]\n+                    start_col: 0,\n+                    #[cfg(not(bootstrap))]\n+                    end_line: 0,\n+                    #[cfg(not(bootstrap))]\n+                    end_col: 0,\n                     should_panic: ShouldPanic::No,\n                     compile_fail: false,\n                     no_run: false,\n@@ -591,6 +731,16 @@ fn sample_tests() -> Vec<TestDescAndFn> {\n                 name: DynTestName((*name).clone()),\n                 ignore: false,\n                 ignore_message: None,\n+                #[cfg(not(bootstrap))]\n+                source_file: \"\",\n+                #[cfg(not(bootstrap))]\n+                start_line: 0,\n+                #[cfg(not(bootstrap))]\n+                start_col: 0,\n+                #[cfg(not(bootstrap))]\n+                end_line: 0,\n+                #[cfg(not(bootstrap))]\n+                end_col: 0,\n                 should_panic: ShouldPanic::No,\n                 compile_fail: false,\n                 no_run: false,\n@@ -720,6 +870,16 @@ pub fn test_bench_no_iter() {\n         name: StaticTestName(\"f\"),\n         ignore: false,\n         ignore_message: None,\n+        #[cfg(not(bootstrap))]\n+        source_file: \"\",\n+        #[cfg(not(bootstrap))]\n+        start_line: 0,\n+        #[cfg(not(bootstrap))]\n+        start_col: 0,\n+        #[cfg(not(bootstrap))]\n+        end_line: 0,\n+        #[cfg(not(bootstrap))]\n+        end_col: 0,\n         should_panic: ShouldPanic::No,\n         compile_fail: false,\n         no_run: false,\n@@ -743,6 +903,16 @@ pub fn test_bench_iter() {\n         name: StaticTestName(\"f\"),\n         ignore: false,\n         ignore_message: None,\n+        #[cfg(not(bootstrap))]\n+        source_file: \"\",\n+        #[cfg(not(bootstrap))]\n+        start_line: 0,\n+        #[cfg(not(bootstrap))]\n+        start_col: 0,\n+        #[cfg(not(bootstrap))]\n+        end_line: 0,\n+        #[cfg(not(bootstrap))]\n+        end_col: 0,\n         should_panic: ShouldPanic::No,\n         compile_fail: false,\n         no_run: false,\n@@ -759,6 +929,16 @@ fn should_sort_failures_before_printing_them() {\n         name: StaticTestName(\"a\"),\n         ignore: false,\n         ignore_message: None,\n+        #[cfg(not(bootstrap))]\n+        source_file: \"\",\n+        #[cfg(not(bootstrap))]\n+        start_line: 0,\n+        #[cfg(not(bootstrap))]\n+        start_col: 0,\n+        #[cfg(not(bootstrap))]\n+        end_line: 0,\n+        #[cfg(not(bootstrap))]\n+        end_col: 0,\n         should_panic: ShouldPanic::No,\n         compile_fail: false,\n         no_run: false,\n@@ -769,6 +949,16 @@ fn should_sort_failures_before_printing_them() {\n         name: StaticTestName(\"b\"),\n         ignore: false,\n         ignore_message: None,\n+        #[cfg(not(bootstrap))]\n+        source_file: \"\",\n+        #[cfg(not(bootstrap))]\n+        start_line: 0,\n+        #[cfg(not(bootstrap))]\n+        start_col: 0,\n+        #[cfg(not(bootstrap))]\n+        end_line: 0,\n+        #[cfg(not(bootstrap))]\n+        end_col: 0,\n         should_panic: ShouldPanic::No,\n         compile_fail: false,\n         no_run: false,\n@@ -816,6 +1006,16 @@ fn test_dyn_bench_returning_err_fails_when_run_as_test() {\n             name: StaticTestName(\"whatever\"),\n             ignore: false,\n             ignore_message: None,\n+            #[cfg(not(bootstrap))]\n+            source_file: \"\",\n+            #[cfg(not(bootstrap))]\n+            start_line: 0,\n+            #[cfg(not(bootstrap))]\n+            start_col: 0,\n+            #[cfg(not(bootstrap))]\n+            end_line: 0,\n+            #[cfg(not(bootstrap))]\n+            end_col: 0,\n             should_panic: ShouldPanic::No,\n             compile_fail: false,\n             no_run: false,"}, {"sha": "8d4e204c8ac1253f94360d221e73b9d1c80e5b15", "filename": "library/test/src/types.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Ftest%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/library%2Ftest%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Ftypes.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -119,6 +119,16 @@ pub struct TestDesc {\n     pub name: TestName,\n     pub ignore: bool,\n     pub ignore_message: Option<&'static str>,\n+    #[cfg(not(bootstrap))]\n+    pub source_file: &'static str,\n+    #[cfg(not(bootstrap))]\n+    pub start_line: usize,\n+    #[cfg(not(bootstrap))]\n+    pub start_col: usize,\n+    #[cfg(not(bootstrap))]\n+    pub end_line: usize,\n+    #[cfg(not(bootstrap))]\n+    pub end_col: usize,\n     pub should_panic: options::ShouldPanic,\n     pub compile_fail: bool,\n     pub no_run: bool,"}, {"sha": "833e155ed87926743d0a6c66ba6a61bfa3f432e5", "filename": "src/bootstrap/Cargo.lock", "status": "modified", "additions": 39, "deletions": 15, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -57,7 +57,7 @@ dependencies = [\n  \"tar\",\n  \"toml\",\n  \"walkdir\",\n- \"winapi\",\n+ \"windows\",\n  \"xz2\",\n ]\n \n@@ -720,6 +720,15 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n \n+[[package]]\n+name = \"windows\"\n+version = \"0.46.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cdacb41e6a96a052c6cb63a144f24900236121c6f63f4f8219fef5977ecb0c25\"\n+dependencies = [\n+ \"windows-targets\",\n+]\n+\n [[package]]\n name = \"windows-sys\"\n version = \"0.42.0\"\n@@ -735,47 +744,62 @@ dependencies = [\n  \"windows_x86_64_msvc\",\n ]\n \n+[[package]]\n+name = \"windows-targets\"\n+version = \"0.42.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8e5180c00cd44c9b1c88adb3693291f1cd93605ded80c250a75d472756b4d071\"\n+dependencies = [\n+ \"windows_aarch64_gnullvm\",\n+ \"windows_aarch64_msvc\",\n+ \"windows_i686_gnu\",\n+ \"windows_i686_msvc\",\n+ \"windows_x86_64_gnu\",\n+ \"windows_x86_64_gnullvm\",\n+ \"windows_x86_64_msvc\",\n+]\n+\n [[package]]\n name = \"windows_aarch64_gnullvm\"\n-version = \"0.42.0\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"41d2aa71f6f0cbe00ae5167d90ef3cfe66527d6f613ca78ac8024c3ccab9a19e\"\n+checksum = \"597a5118570b68bc08d8d59125332c54f1ba9d9adeedeef5b99b02ba2b0698f8\"\n \n [[package]]\n name = \"windows_aarch64_msvc\"\n-version = \"0.42.0\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dd0f252f5a35cac83d6311b2e795981f5ee6e67eb1f9a7f64eb4500fbc4dcdb4\"\n+checksum = \"e08e8864a60f06ef0d0ff4ba04124db8b0fb3be5776a5cd47641e942e58c4d43\"\n \n [[package]]\n name = \"windows_i686_gnu\"\n-version = \"0.42.0\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fbeae19f6716841636c28d695375df17562ca208b2b7d0dc47635a50ae6c5de7\"\n+checksum = \"c61d927d8da41da96a81f029489353e68739737d3beca43145c8afec9a31a84f\"\n \n [[package]]\n name = \"windows_i686_msvc\"\n-version = \"0.42.0\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"84c12f65daa39dd2babe6e442988fc329d6243fdce47d7d2d155b8d874862246\"\n+checksum = \"44d840b6ec649f480a41c8d80f9c65108b92d89345dd94027bfe06ac444d1060\"\n \n [[package]]\n name = \"windows_x86_64_gnu\"\n-version = \"0.42.0\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bf7b1b21b5362cbc318f686150e5bcea75ecedc74dd157d874d754a2ca44b0ed\"\n+checksum = \"8de912b8b8feb55c064867cf047dda097f92d51efad5b491dfb98f6bbb70cb36\"\n \n [[package]]\n name = \"windows_x86_64_gnullvm\"\n-version = \"0.42.0\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"09d525d2ba30eeb3297665bd434a54297e4170c7f1a44cad4ef58095b4cd2028\"\n+checksum = \"26d41b46a36d453748aedef1486d5c7a85db22e56aff34643984ea85514e94a3\"\n \n [[package]]\n name = \"windows_x86_64_msvc\"\n-version = \"0.42.0\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f40009d85759725a34da6d89a94e63d7bdc50a862acf0dbc7c8e488f1edcb6f5\"\n+checksum = \"9aec5da331524158c6d1a4ac0ab1541149c0b9505fde06423b02f5ef0106b9f0\"\n \n [[package]]\n name = \"xattr\""}, {"sha": "13ebd8af15b2e2e55750e030a9ab37d79f163a5f", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -59,18 +59,20 @@ sysinfo = { version = \"0.26.0\", optional = true }\n [target.'cfg(not(target_os = \"solaris\"))'.dependencies]\n fd-lock = \"3.0.8\"\n \n-[target.'cfg(windows)'.dependencies.winapi]\n-version = \"0.3\"\n+[target.'cfg(windows)'.dependencies.windows]\n+version = \"0.46.0\"\n features = [\n-    \"fileapi\",\n-    \"ioapiset\",\n-    \"jobapi2\",\n-    \"handleapi\",\n-    \"winioctl\",\n-    \"psapi\",\n-    \"impl-default\",\n-    \"timezoneapi\",\n-    \"winbase\",\n+    \"Win32_Foundation\",\n+    \"Win32_Security\",\n+    \"Win32_Storage_FileSystem\",\n+    \"Win32_System_Diagnostics_Debug\",\n+    \"Win32_System_IO\",\n+    \"Win32_System_Ioctl\",\n+    \"Win32_System_JobObjects\",\n+    \"Win32_System_ProcessStatus\",\n+    \"Win32_System_SystemServices\",\n+    \"Win32_System_Threading\",\n+    \"Win32_System_Time\",\n ]\n \n [dev-dependencies]"}, {"sha": "040fec3615b6e260569544b0a75eaf650a8ad9dc", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -281,41 +281,49 @@ fn format_rusage_data(_child: Child) -> Option<String> {\n #[cfg(windows)]\n fn format_rusage_data(child: Child) -> Option<String> {\n     use std::os::windows::io::AsRawHandle;\n-    use winapi::um::{processthreadsapi, psapi, timezoneapi};\n-    let handle = child.as_raw_handle();\n-    macro_rules! try_bool {\n-        ($e:expr) => {\n-            if $e != 1 {\n-                return None;\n-            }\n-        };\n-    }\n+\n+    use windows::{\n+        Win32::Foundation::HANDLE,\n+        Win32::System::ProcessStatus::{\n+            K32GetProcessMemoryInfo, PROCESS_MEMORY_COUNTERS, PROCESS_MEMORY_COUNTERS_EX,\n+        },\n+        Win32::System::Threading::GetProcessTimes,\n+        Win32::System::Time::FileTimeToSystemTime,\n+    };\n+\n+    let handle = HANDLE(child.as_raw_handle() as isize);\n \n     let mut user_filetime = Default::default();\n     let mut user_time = Default::default();\n     let mut kernel_filetime = Default::default();\n     let mut kernel_time = Default::default();\n-    let mut memory_counters = psapi::PROCESS_MEMORY_COUNTERS::default();\n+    let mut memory_counters = PROCESS_MEMORY_COUNTERS::default();\n \n     unsafe {\n-        try_bool!(processthreadsapi::GetProcessTimes(\n+        GetProcessTimes(\n             handle,\n             &mut Default::default(),\n             &mut Default::default(),\n             &mut kernel_filetime,\n             &mut user_filetime,\n-        ));\n-        try_bool!(timezoneapi::FileTimeToSystemTime(&user_filetime, &mut user_time));\n-        try_bool!(timezoneapi::FileTimeToSystemTime(&kernel_filetime, &mut kernel_time));\n-\n-        // Unlike on Linux with RUSAGE_CHILDREN, this will only return memory information for the process\n-        // with the given handle and none of that process's children.\n-        try_bool!(psapi::GetProcessMemoryInfo(\n-            handle as _,\n-            &mut memory_counters as *mut _ as _,\n-            std::mem::size_of::<psapi::PROCESS_MEMORY_COUNTERS_EX>() as u32,\n-        ));\n+        )\n+    }\n+    .ok()\n+    .ok()?;\n+    unsafe { FileTimeToSystemTime(&user_filetime, &mut user_time) }.ok().ok()?;\n+    unsafe { FileTimeToSystemTime(&kernel_filetime, &mut kernel_time) }.ok().ok()?;\n+\n+    // Unlike on Linux with RUSAGE_CHILDREN, this will only return memory information for the process\n+    // with the given handle and none of that process's children.\n+    unsafe {\n+        K32GetProcessMemoryInfo(\n+            handle,\n+            &mut memory_counters,\n+            std::mem::size_of::<PROCESS_MEMORY_COUNTERS_EX>() as u32,\n+        )\n     }\n+    .ok()\n+    .ok()?;\n \n     // Guide on interpreting these numbers:\n     // https://docs.microsoft.com/en-us/windows/win32/psapi/process-memory-usage-information"}, {"sha": "20bd71f06e918e1dfe1d1f8cb0e8839ba9d79161", "filename": "src/bootstrap/bootstrap_test.py", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2Fbootstrap_test.py", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2Fbootstrap_test.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap_test.py?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -11,6 +11,7 @@\n from shutil import rmtree\n \n import bootstrap\n+import configure\n \n \n class VerifyTestCase(unittest.TestCase):\n@@ -74,12 +75,50 @@ def test_same_dates(self):\n         self.assertFalse(self.build.program_out_of_date(self.rustc_stamp_path, self.key))\n \n \n+class GenerateAndParseConfig(unittest.TestCase):\n+    \"\"\"Test that we can serialize and deserialize a config.toml file\"\"\"\n+    def serialize_and_parse(self, args):\n+        from io import StringIO\n+\n+        section_order, sections, targets = configure.parse_args(args)\n+        buffer = StringIO()\n+        configure.write_config_toml(buffer, section_order, targets, sections)\n+        build = bootstrap.RustBuild()\n+        build.config_toml = buffer.getvalue()\n+\n+        try:\n+            import tomllib\n+            # Verify this is actually valid TOML.\n+            tomllib.loads(build.config_toml)\n+        except ImportError:\n+            print(\"warning: skipping TOML validation, need at least python 3.11\", file=sys.stderr)\n+        return build\n+\n+    def test_no_args(self):\n+        build = self.serialize_and_parse([])\n+        self.assertEqual(build.get_toml(\"changelog-seen\"), '2')\n+        self.assertIsNone(build.get_toml(\"llvm.download-ci-llvm\"))\n+\n+    def test_set_section(self):\n+        build = self.serialize_and_parse([\"--set\", \"llvm.download-ci-llvm\"])\n+        self.assertEqual(build.get_toml(\"download-ci-llvm\", section=\"llvm\"), 'true')\n+\n+    def test_set_target(self):\n+        build = self.serialize_and_parse([\"--set\", \"target.x86_64-unknown-linux-gnu.cc=gcc\"])\n+        self.assertEqual(build.get_toml(\"cc\", section=\"target.x86_64-unknown-linux-gnu\"), 'gcc')\n+\n+    # Uncomment when #108928 is fixed.\n+    # def test_set_top_level(self):\n+    #     build = self.serialize_and_parse([\"--set\", \"profile=compiler\"])\n+    #     self.assertEqual(build.get_toml(\"profile\"), 'compiler')\n+\n if __name__ == '__main__':\n     SUITE = unittest.TestSuite()\n     TEST_LOADER = unittest.TestLoader()\n     SUITE.addTest(doctest.DocTestSuite(bootstrap))\n     SUITE.addTests([\n         TEST_LOADER.loadTestsFromTestCase(VerifyTestCase),\n+        TEST_LOADER.loadTestsFromTestCase(GenerateAndParseConfig),\n         TEST_LOADER.loadTestsFromTestCase(ProgramOutOfDate)])\n \n     RUNNER = unittest.TextTestRunner(stream=sys.stdout, verbosity=2)"}, {"sha": "cbf0f1c37a2cf66f27732911aaa865ff955d2a30", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1303,6 +1303,14 @@ impl<'a> Builder<'a> {\n             }\n         };\n \n+        // By default, windows-rs depends on a native library that doesn't get copied into the\n+        // sysroot. Passing this cfg enables raw-dylib support instead, which makes the native\n+        // library unnecessary. This can be removed when windows-rs enables raw-dylib\n+        // unconditionally.\n+        if let Mode::Rustc | Mode::ToolRustc = mode {\n+            rustflags.arg(\"--cfg=windows_raw_dylib\");\n+        }\n+\n         if use_new_symbol_mangling {\n             rustflags.arg(\"-Csymbol-mangling-version=v0\");\n         } else {"}, {"sha": "abd28b4005d0be6faa8a796f935496e15012b489", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 219, "deletions": 198, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -205,77 +205,78 @@ def err(msg):\n \n # Parse all command line arguments into one of these three lists, handling\n # boolean and value-based options separately\n-unknown_args = []\n-need_value_args = []\n-known_args = {}\n-\n-p(\"processing command line\")\n-i = 1\n-while i < len(sys.argv):\n-    arg = sys.argv[i]\n-    i += 1\n-    if not arg.startswith('--'):\n-        unknown_args.append(arg)\n-        continue\n-\n-    found = False\n-    for option in options:\n-        value = None\n-        if option.value:\n-            keyval = arg[2:].split('=', 1)\n-            key = keyval[0]\n-            if option.name != key:\n-                continue\n+def parse_args(args):\n+    unknown_args = []\n+    need_value_args = []\n+    known_args = {}\n+\n+    i = 0\n+    while i < len(args):\n+        arg = args[i]\n+        i += 1\n+        if not arg.startswith('--'):\n+            unknown_args.append(arg)\n+            continue\n \n-            if len(keyval) > 1:\n-                value = keyval[1]\n-            elif i < len(sys.argv):\n-                value = sys.argv[i]\n-                i += 1\n-            else:\n-                need_value_args.append(arg)\n-                continue\n-        else:\n-            if arg[2:] == 'enable-' + option.name:\n-                value = True\n-            elif arg[2:] == 'disable-' + option.name:\n-                value = False\n+        found = False\n+        for option in options:\n+            value = None\n+            if option.value:\n+                keyval = arg[2:].split('=', 1)\n+                key = keyval[0]\n+                if option.name != key:\n+                    continue\n+\n+                if len(keyval) > 1:\n+                    value = keyval[1]\n+                elif i < len(args):\n+                    value = args[i]\n+                    i += 1\n+                else:\n+                    need_value_args.append(arg)\n+                    continue\n             else:\n-                continue\n+                if arg[2:] == 'enable-' + option.name:\n+                    value = True\n+                elif arg[2:] == 'disable-' + option.name:\n+                    value = False\n+                else:\n+                    continue\n+\n+            found = True\n+            if option.name not in known_args:\n+                known_args[option.name] = []\n+            known_args[option.name].append((option, value))\n+            break\n+\n+        if not found:\n+            unknown_args.append(arg)\n+\n+    # Note: here and a few other places, we use [-1] to apply the *last* value\n+    # passed.  But if option-checking is enabled, then the known_args loop will\n+    # also assert that options are only passed once.\n+    option_checking = ('option-checking' not in known_args\n+                    or known_args['option-checking'][-1][1])\n+    if option_checking:\n+        if len(unknown_args) > 0:\n+            err(\"Option '\" + unknown_args[0] + \"' is not recognized\")\n+        if len(need_value_args) > 0:\n+            err(\"Option '{0}' needs a value ({0}=val)\".format(need_value_args[0]))\n+\n+    config = {}\n+\n+    set('build.configure-args', sys.argv[1:], config)\n+    apply_args(known_args, option_checking, config)\n+    return parse_example_config(known_args, config)\n \n-        found = True\n-        if option.name not in known_args:\n-            known_args[option.name] = []\n-        known_args[option.name].append((option, value))\n-        break\n-\n-    if not found:\n-        unknown_args.append(arg)\n-p(\"\")\n-\n-# Note: here and a few other places, we use [-1] to apply the *last* value\n-# passed.  But if option-checking is enabled, then the known_args loop will\n-# also assert that options are only passed once.\n-option_checking = ('option-checking' not in known_args\n-                   or known_args['option-checking'][-1][1])\n-if option_checking:\n-    if len(unknown_args) > 0:\n-        err(\"Option '\" + unknown_args[0] + \"' is not recognized\")\n-    if len(need_value_args) > 0:\n-        err(\"Option '{0}' needs a value ({0}=val)\".format(need_value_args[0]))\n-\n-# Parse all known arguments into a configuration structure that reflects the\n-# TOML we're going to write out\n-config = {}\n-\n-\n-def build():\n+\n+def build(known_args):\n     if 'build' in known_args:\n         return known_args['build'][-1][1]\n     return bootstrap.default_build_triple(verbose=False)\n \n \n-def set(key, value):\n+def set(key, value, config):\n     if isinstance(value, list):\n         # Remove empty values, which value.split(',') tends to generate.\n         value = [v for v in value if v]\n@@ -297,122 +298,127 @@ def set(key, value):\n             arr = arr[part]\n \n \n-for key in known_args:\n-    # The `set` option is special and can be passed a bunch of times\n-    if key == 'set':\n-        for option, value in known_args[key]:\n-            keyval = value.split('=', 1)\n-            if len(keyval) == 1 or keyval[1] == \"true\":\n-                value = True\n-            elif keyval[1] == \"false\":\n-                value = False\n-            else:\n-                value = keyval[1]\n-            set(keyval[0], value)\n-        continue\n-\n-    # Ensure each option is only passed once\n-    arr = known_args[key]\n-    if option_checking and len(arr) > 1:\n-        err(\"Option '{}' provided more than once\".format(key))\n-    option, value = arr[-1]\n-\n-    # If we have a clear avenue to set our value in rustbuild, do so\n-    if option.rustbuild is not None:\n-        set(option.rustbuild, value)\n-        continue\n-\n-    # Otherwise we're a \"special\" option and need some extra handling, so do\n-    # that here.\n-    if option.name == 'sccache':\n-        set('llvm.ccache', 'sccache')\n-    elif option.name == 'local-rust':\n-        for path in os.environ['PATH'].split(os.pathsep):\n-            if os.path.exists(path + '/rustc'):\n-                set('build.rustc', path + '/rustc')\n-                break\n-        for path in os.environ['PATH'].split(os.pathsep):\n-            if os.path.exists(path + '/cargo'):\n-                set('build.cargo', path + '/cargo')\n-                break\n-    elif option.name == 'local-rust-root':\n-        set('build.rustc', value + '/bin/rustc')\n-        set('build.cargo', value + '/bin/cargo')\n-    elif option.name == 'llvm-root':\n-        set('target.{}.llvm-config'.format(build()), value + '/bin/llvm-config')\n-    elif option.name == 'llvm-config':\n-        set('target.{}.llvm-config'.format(build()), value)\n-    elif option.name == 'llvm-filecheck':\n-        set('target.{}.llvm-filecheck'.format(build()), value)\n-    elif option.name == 'tools':\n-        set('build.tools', value.split(','))\n-    elif option.name == 'codegen-backends':\n-        set('rust.codegen-backends', value.split(','))\n-    elif option.name == 'host':\n-        set('build.host', value.split(','))\n-    elif option.name == 'target':\n-        set('build.target', value.split(','))\n-    elif option.name == 'full-tools':\n-        set('rust.codegen-backends', ['llvm'])\n-        set('rust.lld', True)\n-        set('rust.llvm-tools', True)\n-        set('build.extended', True)\n-    elif option.name == 'option-checking':\n-        # this was handled above\n-        pass\n-    elif option.name == 'dist-compression-formats':\n-        set('dist.compression-formats', value.split(','))\n-    else:\n-        raise RuntimeError(\"unhandled option {}\".format(option.name))\n+def apply_args(known_args, option_checking, config):\n+    for key in known_args:\n+        # The `set` option is special and can be passed a bunch of times\n+        if key == 'set':\n+            for option, value in known_args[key]:\n+                keyval = value.split('=', 1)\n+                if len(keyval) == 1 or keyval[1] == \"true\":\n+                    value = True\n+                elif keyval[1] == \"false\":\n+                    value = False\n+                else:\n+                    value = keyval[1]\n+                set(keyval[0], value, config)\n+            continue\n \n-set('build.configure-args', sys.argv[1:])\n+        # Ensure each option is only passed once\n+        arr = known_args[key]\n+        if option_checking and len(arr) > 1:\n+            err(\"Option '{}' provided more than once\".format(key))\n+        option, value = arr[-1]\n+\n+        # If we have a clear avenue to set our value in rustbuild, do so\n+        if option.rustbuild is not None:\n+            set(option.rustbuild, value, config)\n+            continue\n+\n+        # Otherwise we're a \"special\" option and need some extra handling, so do\n+        # that here.\n+        build_triple = build(known_args)\n+\n+        if option.name == 'sccache':\n+            set('llvm.ccache', 'sccache', config)\n+        elif option.name == 'local-rust':\n+            for path in os.environ['PATH'].split(os.pathsep):\n+                if os.path.exists(path + '/rustc'):\n+                    set('build.rustc', path + '/rustc', config)\n+                    break\n+            for path in os.environ['PATH'].split(os.pathsep):\n+                if os.path.exists(path + '/cargo'):\n+                    set('build.cargo', path + '/cargo', config)\n+                    break\n+        elif option.name == 'local-rust-root':\n+            set('build.rustc', value + '/bin/rustc', config)\n+            set('build.cargo', value + '/bin/cargo', config)\n+        elif option.name == 'llvm-root':\n+            set('target.{}.llvm-config'.format(build_triple), value + '/bin/llvm-config', config)\n+        elif option.name == 'llvm-config':\n+            set('target.{}.llvm-config'.format(build_triple), value, config)\n+        elif option.name == 'llvm-filecheck':\n+            set('target.{}.llvm-filecheck'.format(build_triple), value, config)\n+        elif option.name == 'tools':\n+            set('build.tools', value.split(','), config)\n+        elif option.name == 'codegen-backends':\n+            set('rust.codegen-backends', value.split(','), config)\n+        elif option.name == 'host':\n+            set('build.host', value.split(','), config)\n+        elif option.name == 'target':\n+            set('build.target', value.split(','), config)\n+        elif option.name == 'full-tools':\n+            set('rust.codegen-backends', ['llvm'], config)\n+            set('rust.lld', True, config)\n+            set('rust.llvm-tools', True, config)\n+            set('build.extended', True, config)\n+        elif option.name == 'option-checking':\n+            # this was handled above\n+            pass\n+        elif option.name == 'dist-compression-formats':\n+            set('dist.compression-formats', value.split(','), config)\n+        else:\n+            raise RuntimeError(\"unhandled option {}\".format(option.name))\n \n # \"Parse\" the `config.example.toml` file into the various sections, and we'll\n # use this as a template of a `config.toml` to write out which preserves\n # all the various comments and whatnot.\n #\n # Note that the `target` section is handled separately as we'll duplicate it\n # per configured target, so there's a bit of special handling for that here.\n-sections = {}\n-cur_section = None\n-sections[None] = []\n-section_order = [None]\n-targets = {}\n-top_level_keys = []\n-\n-for line in open(rust_dir + '/config.example.toml').read().split(\"\\n\"):\n-    if cur_section == None:\n-        if line.count('=') == 1:\n-            top_level_key = line.split('=')[0]\n-            top_level_key = top_level_key.strip(' #')\n-            top_level_keys.append(top_level_key)\n-    if line.startswith('['):\n-        cur_section = line[1:-1]\n-        if cur_section.startswith('target'):\n-            cur_section = 'target'\n-        elif '.' in cur_section:\n-            raise RuntimeError(\"don't know how to deal with section: {}\".format(cur_section))\n-        sections[cur_section] = [line]\n-        section_order.append(cur_section)\n-    else:\n-        sections[cur_section].append(line)\n-\n-# Fill out the `targets` array by giving all configured targets a copy of the\n-# `target` section we just loaded from the example config\n-configured_targets = [build()]\n-if 'build' in config:\n-    if 'host' in config['build']:\n-        configured_targets += config['build']['host']\n-    if 'target' in config['build']:\n-        configured_targets += config['build']['target']\n-if 'target' in config:\n-    for target in config['target']:\n-        configured_targets.append(target)\n-for target in configured_targets:\n-    targets[target] = sections['target'][:]\n-    # For `.` to be valid TOML, it needs to be quoted. But `bootstrap.py` doesn't use a proper TOML parser and fails to parse the target.\n-    # Avoid using quotes unless it's necessary.\n-    targets[target][0] = targets[target][0].replace(\"x86_64-unknown-linux-gnu\", \"'{}'\".format(target) if \".\" in target else target)\n+def parse_example_config(known_args, config):\n+    sections = {}\n+    cur_section = None\n+    sections[None] = []\n+    section_order = [None]\n+    targets = {}\n+    top_level_keys = []\n+\n+    for line in open(rust_dir + '/config.example.toml').read().split(\"\\n\"):\n+        if cur_section == None:\n+            if line.count('=') == 1:\n+                top_level_key = line.split('=')[0]\n+                top_level_key = top_level_key.strip(' #')\n+                top_level_keys.append(top_level_key)\n+        if line.startswith('['):\n+            cur_section = line[1:-1]\n+            if cur_section.startswith('target'):\n+                cur_section = 'target'\n+            elif '.' in cur_section:\n+                raise RuntimeError(\"don't know how to deal with section: {}\".format(cur_section))\n+            sections[cur_section] = [line]\n+            section_order.append(cur_section)\n+        else:\n+            sections[cur_section].append(line)\n+\n+    # Fill out the `targets` array by giving all configured targets a copy of the\n+    # `target` section we just loaded from the example config\n+    configured_targets = [build(known_args)]\n+    if 'build' in config:\n+        if 'host' in config['build']:\n+            configured_targets += config['build']['host']\n+        if 'target' in config['build']:\n+            configured_targets += config['build']['target']\n+    if 'target' in config:\n+        for target in config['target']:\n+            configured_targets.append(target)\n+    for target in configured_targets:\n+        targets[target] = sections['target'][:]\n+        # For `.` to be valid TOML, it needs to be quoted. But `bootstrap.py` doesn't use a proper TOML parser and fails to parse the target.\n+        # Avoid using quotes unless it's necessary.\n+        targets[target][0] = targets[target][0].replace(\"x86_64-unknown-linux-gnu\", \"'{}'\".format(target) if \".\" in target else target)\n+\n+    configure_file(sections, top_level_keys, targets, config)\n+    return section_order, sections, targets\n \n \n def is_number(value):\n@@ -475,17 +481,20 @@ def configure_top_level_key(lines, top_level_key, value):\n     raise RuntimeError(\"failed to find config line for {}\".format(top_level_key))\n \n \n-for section_key, section_config in config.items():\n-    if section_key not in sections and section_key not in top_level_keys:\n-        raise RuntimeError(\"config key {} not in sections or top_level_keys\".format(section_key))\n-    if section_key in top_level_keys:\n-        configure_top_level_key(sections[None], section_key, section_config)\n+# Modify `sections` to reflect the parsed arguments and example configs.\n+def configure_file(sections, top_level_keys, targets, config):\n+    for section_key, section_config in config.items():\n+        if section_key not in sections and section_key not in top_level_keys:\n+            raise RuntimeError(\"config key {} not in sections or top_level_keys\".format(section_key))\n+        if section_key in top_level_keys:\n+            configure_top_level_key(sections[None], section_key, section_config)\n+\n+        elif  section_key == 'target':\n+            for target in section_config:\n+                configure_section(targets[target], section_config[target])\n+        else:\n+            configure_section(sections[section_key], section_config)\n \n-    elif  section_key == 'target':\n-        for target in section_config:\n-            configure_section(targets[target], section_config[target])\n-    else:\n-        configure_section(sections[section_key], section_config)\n \n def write_uncommented(target, f):\n     block = []\n@@ -503,24 +512,36 @@ def write_uncommented(target, f):\n         is_comment = is_comment and line.startswith('#')\n     return f\n \n-# Now that we've built up our `config.toml`, write it all out in the same\n-# order that we read it in.\n-p(\"\")\n-p(\"writing `config.toml` in current directory\")\n-with bootstrap.output('config.toml') as f:\n+\n+def write_config_toml(writer, section_order, targets, sections):\n     for section in section_order:\n         if section == 'target':\n             for target in targets:\n-                f = write_uncommented(targets[target], f)\n+                writer = write_uncommented(targets[target], writer)\n         else:\n-            f = write_uncommented(sections[section], f)\n-\n-with bootstrap.output('Makefile') as f:\n-    contents = os.path.join(rust_dir, 'src', 'bootstrap', 'mk', 'Makefile.in')\n-    contents = open(contents).read()\n-    contents = contents.replace(\"$(CFG_SRC_DIR)\", rust_dir + '/')\n-    contents = contents.replace(\"$(CFG_PYTHON)\", sys.executable)\n-    f.write(contents)\n-\n-p(\"\")\n-p(\"run `python {}/x.py --help`\".format(rust_dir))\n+            writer = write_uncommented(sections[section], writer)\n+\n+\n+if __name__ == \"__main__\":\n+    p(\"processing command line\")\n+    # Parse all known arguments into a configuration structure that reflects the\n+    # TOML we're going to write out\n+    p(\"\")\n+    section_order, sections, targets = parse_args(sys.argv[1:])\n+\n+    # Now that we've built up our `config.toml`, write it all out in the same\n+    # order that we read it in.\n+    p(\"\")\n+    p(\"writing `config.toml` in current directory\")\n+    with bootstrap.output('config.toml') as f:\n+        write_config_toml(f, section_order, targets, sections)\n+\n+    with bootstrap.output('Makefile') as f:\n+        contents = os.path.join(rust_dir, 'src', 'bootstrap', 'mk', 'Makefile.in')\n+        contents = open(contents).read()\n+        contents = contents.replace(\"$(CFG_SRC_DIR)\", rust_dir + '/')\n+        contents = contents.replace(\"$(CFG_PYTHON)\", sys.executable)\n+        f.write(contents)\n+\n+    p(\"\")\n+    p(\"run `python {}/x.py --help`\".format(rust_dir))"}, {"sha": "dceb4bd1b893c9711dcc683315470d2a1e887cf9", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -210,6 +210,8 @@ fn make_win_dist(\n         rustc_dlls.push(\"libgcc_s_seh-1.dll\");\n     }\n \n+    // Libraries necessary to link the windows-gnu toolchains.\n+    // System libraries will be preferred if they are available (see #67429).\n     let target_libs = [\n         //MinGW libs\n         \"libgcc.a\",\n@@ -223,6 +225,7 @@ fn make_win_dist(\n         \"libmoldname.a\",\n         \"libpthread.a\",\n         //Windows import libs\n+        //This should contain only the set of libraries necessary to link the standard library.\n         \"libadvapi32.a\",\n         \"libbcrypt.a\",\n         \"libcomctl32.a\",\n@@ -236,6 +239,7 @@ fn make_win_dist(\n         \"libkernel32.a\",\n         \"libmsimg32.a\",\n         \"libmsvcrt.a\",\n+        \"libntdll.a\",\n         \"libodbc32.a\",\n         \"libole32.a\",\n         \"liboleaut32.a\","}, {"sha": "4fb00f65dc19d9ae2e49b685edff37b90230abe4", "filename": "src/bootstrap/job.rs", "status": "modified", "additions": 44, "deletions": 41, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fjob.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -27,52 +27,54 @@\n //! Note that this module has a #[cfg(windows)] above it as none of this logic\n //! is required on Unix.\n \n-#![allow(nonstandard_style, dead_code)]\n-\n use crate::Build;\n use std::env;\n+use std::ffi::c_void;\n use std::io;\n use std::mem;\n-use std::ptr;\n \n-use winapi::shared::minwindef::{DWORD, FALSE, LPVOID};\n-use winapi::um::errhandlingapi::SetErrorMode;\n-use winapi::um::handleapi::{CloseHandle, DuplicateHandle};\n-use winapi::um::jobapi2::{AssignProcessToJobObject, CreateJobObjectW, SetInformationJobObject};\n-use winapi::um::processthreadsapi::{GetCurrentProcess, OpenProcess};\n-use winapi::um::winbase::{BELOW_NORMAL_PRIORITY_CLASS, SEM_NOGPFAULTERRORBOX};\n-use winapi::um::winnt::{\n-    JobObjectExtendedLimitInformation, DUPLICATE_SAME_ACCESS, JOBOBJECT_EXTENDED_LIMIT_INFORMATION,\n-    JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE, JOB_OBJECT_LIMIT_PRIORITY_CLASS, PROCESS_DUP_HANDLE,\n+use windows::{\n+    core::PCWSTR,\n+    Win32::Foundation::{CloseHandle, DuplicateHandle, DUPLICATE_SAME_ACCESS, HANDLE},\n+    Win32::System::Diagnostics::Debug::{SetErrorMode, SEM_NOGPFAULTERRORBOX, THREAD_ERROR_MODE},\n+    Win32::System::JobObjects::{\n+        AssignProcessToJobObject, CreateJobObjectW, JobObjectExtendedLimitInformation,\n+        SetInformationJobObject, JOBOBJECT_EXTENDED_LIMIT_INFORMATION,\n+        JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE, JOB_OBJECT_LIMIT_PRIORITY_CLASS,\n+    },\n+    Win32::System::Threading::{\n+        GetCurrentProcess, OpenProcess, BELOW_NORMAL_PRIORITY_CLASS, PROCESS_DUP_HANDLE,\n+    },\n };\n \n pub unsafe fn setup(build: &mut Build) {\n     // Enable the Windows Error Reporting dialog which msys disables,\n     // so we can JIT debug rustc\n-    let mode = SetErrorMode(0);\n+    let mode = SetErrorMode(THREAD_ERROR_MODE::default());\n+    let mode = THREAD_ERROR_MODE(mode);\n     SetErrorMode(mode & !SEM_NOGPFAULTERRORBOX);\n \n     // Create a new job object for us to use\n-    let job = CreateJobObjectW(ptr::null_mut(), ptr::null());\n-    assert!(!job.is_null(), \"{}\", io::Error::last_os_error());\n+    let job = CreateJobObjectW(None, PCWSTR::null()).unwrap();\n \n     // Indicate that when all handles to the job object are gone that all\n     // process in the object should be killed. Note that this includes our\n     // entire process tree by default because we've added ourselves and our\n     // children will reside in the job by default.\n-    let mut info = mem::zeroed::<JOBOBJECT_EXTENDED_LIMIT_INFORMATION>();\n+    let mut info = JOBOBJECT_EXTENDED_LIMIT_INFORMATION::default();\n     info.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;\n     if build.config.low_priority {\n         info.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_PRIORITY_CLASS;\n-        info.BasicLimitInformation.PriorityClass = BELOW_NORMAL_PRIORITY_CLASS;\n+        info.BasicLimitInformation.PriorityClass = BELOW_NORMAL_PRIORITY_CLASS.0;\n     }\n     let r = SetInformationJobObject(\n         job,\n         JobObjectExtendedLimitInformation,\n-        &mut info as *mut _ as LPVOID,\n-        mem::size_of_val(&info) as DWORD,\n-    );\n-    assert!(r != 0, \"{}\", io::Error::last_os_error());\n+        &info as *const _ as *const c_void,\n+        mem::size_of_val(&info) as u32,\n+    )\n+    .ok();\n+    assert!(r.is_ok(), \"{}\", io::Error::last_os_error());\n \n     // Assign our process to this job object. Note that if this fails, one very\n     // likely reason is that we are ourselves already in a job object! This can\n@@ -83,8 +85,8 @@ pub unsafe fn setup(build: &mut Build) {\n     // Also note that nested jobs (why this might fail) are supported in recent\n     // versions of Windows, but the version of Windows that our bots are running\n     // at least don't support nested job objects.\n-    let r = AssignProcessToJobObject(job, GetCurrentProcess());\n-    if r == 0 {\n+    let r = AssignProcessToJobObject(job, GetCurrentProcess()).ok();\n+    if r.is_err() {\n         CloseHandle(job);\n         return;\n     }\n@@ -102,39 +104,40 @@ pub unsafe fn setup(build: &mut Build) {\n         Err(..) => return,\n     };\n \n-    let parent = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pid.parse().unwrap());\n-\n-    // If we get a null parent pointer here, it is possible that either\n-    // we have got an invalid pid or the parent process has been closed.\n-    // Since the first case rarely happens\n-    // (only when wrongly setting the environmental variable),\n-    // so it might be better to improve the experience of the second case\n-    // when users have interrupted the parent process and we don't finish\n-    // duplicating the handle yet.\n-    // We just need close the job object if that occurs.\n-    if parent.is_null() {\n-        CloseHandle(job);\n-        return;\n-    }\n+    let parent = match OpenProcess(PROCESS_DUP_HANDLE, false, pid.parse().unwrap()).ok() {\n+        Some(parent) => parent,\n+        _ => {\n+            // If we get a null parent pointer here, it is possible that either\n+            // we have an invalid pid or the parent process has been closed.\n+            // Since the first case rarely happens\n+            // (only when wrongly setting the environmental variable),\n+            // it might be better to improve the experience of the second case\n+            // when users have interrupted the parent process and we haven't finish\n+            // duplicating the handle yet. We just need close the job object if that occurs.\n+            CloseHandle(job);\n+            return;\n+        }\n+    };\n \n-    let mut parent_handle = ptr::null_mut();\n+    let mut parent_handle = HANDLE::default();\n     let r = DuplicateHandle(\n         GetCurrentProcess(),\n         job,\n         parent,\n         &mut parent_handle,\n         0,\n-        FALSE,\n+        false,\n         DUPLICATE_SAME_ACCESS,\n-    );\n+    )\n+    .ok();\n \n     // If this failed, well at least we tried! An example of DuplicateHandle\n     // failing in the past has been when the wrong python2 package spawned this\n     // build system (e.g., the `python2` package in MSYS instead of\n     // `mingw-w64-x86_64-python2`. Not sure why it failed, but the \"failure\n     // mode\" here is that we only clean everything up when the build system\n     // dies, not when the python parent does, so not too bad.\n-    if r != 0 {\n+    if r.is_err() {\n         CloseHandle(job);\n     }\n }"}, {"sha": "d23c262aad2f4584465adb89f2fb1fdb8e7f00f2", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -144,6 +144,9 @@ const EXTRA_CHECK_CFGS: &[(Option<Mode>, &'static str, Option<&[&'static str]>)]\n     // FIXME: Used by filetime, but we should not be triggering on external dependencies.\n     (Some(Mode::Rustc), \"emulate_second_only_system\", None),\n     (Some(Mode::ToolRustc), \"emulate_second_only_system\", None),\n+    // Needed to avoid the need to copy windows.lib into the sysroot.\n+    (Some(Mode::Rustc), \"windows_raw_dylib\", None),\n+    (Some(Mode::ToolRustc), \"windows_raw_dylib\", None),\n ];\n \n /// A structure representing a Rust compiler."}, {"sha": "dff46b500e3ad2653ac0edd7a012e3e0305d2e3b", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -567,6 +567,8 @@ fn configure_cmake(\n             cfg.define(\"CMAKE_SYSTEM_NAME\", \"Haiku\");\n         } else if target.contains(\"solaris\") || target.contains(\"illumos\") {\n             cfg.define(\"CMAKE_SYSTEM_NAME\", \"SunOS\");\n+        } else if target.contains(\"linux\") {\n+            cfg.define(\"CMAKE_SYSTEM_NAME\", \"Linux\");\n         }\n         // When cross-compiling we should also set CMAKE_SYSTEM_VERSION, but in\n         // that case like CMake we cannot easily determine system version either."}, {"sha": "9a6aaffe22b2412cedd3ec3293146d7c0f4ac942", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 46, "deletions": 40, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -155,29 +155,30 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n     fn symlink_dir_inner(target: &Path, junction: &Path) -> io::Result<()> {\n         use std::ffi::OsStr;\n         use std::os::windows::ffi::OsStrExt;\n-        use std::ptr;\n-\n-        use winapi::shared::minwindef::{DWORD, WORD};\n-        use winapi::um::fileapi::{CreateFileW, OPEN_EXISTING};\n-        use winapi::um::handleapi::CloseHandle;\n-        use winapi::um::ioapiset::DeviceIoControl;\n-        use winapi::um::winbase::{FILE_FLAG_BACKUP_SEMANTICS, FILE_FLAG_OPEN_REPARSE_POINT};\n-        use winapi::um::winioctl::FSCTL_SET_REPARSE_POINT;\n-        use winapi::um::winnt::{\n-            FILE_SHARE_DELETE, FILE_SHARE_READ, FILE_SHARE_WRITE, GENERIC_WRITE,\n-            IO_REPARSE_TAG_MOUNT_POINT, MAXIMUM_REPARSE_DATA_BUFFER_SIZE, WCHAR,\n+\n+        use windows::{\n+            core::PCWSTR,\n+            Win32::Foundation::{CloseHandle, HANDLE},\n+            Win32::Storage::FileSystem::{\n+                CreateFileW, FILE_ACCESS_FLAGS, FILE_FLAG_BACKUP_SEMANTICS,\n+                FILE_FLAG_OPEN_REPARSE_POINT, FILE_SHARE_DELETE, FILE_SHARE_READ, FILE_SHARE_WRITE,\n+                MAXIMUM_REPARSE_DATA_BUFFER_SIZE, OPEN_EXISTING,\n+            },\n+            Win32::System::Ioctl::FSCTL_SET_REPARSE_POINT,\n+            Win32::System::SystemServices::{GENERIC_WRITE, IO_REPARSE_TAG_MOUNT_POINT},\n+            Win32::System::IO::DeviceIoControl,\n         };\n \n         #[allow(non_snake_case)]\n         #[repr(C)]\n         struct REPARSE_MOUNTPOINT_DATA_BUFFER {\n-            ReparseTag: DWORD,\n-            ReparseDataLength: DWORD,\n-            Reserved: WORD,\n-            ReparseTargetLength: WORD,\n-            ReparseTargetMaximumLength: WORD,\n-            Reserved1: WORD,\n-            ReparseTarget: WCHAR,\n+            ReparseTag: u32,\n+            ReparseDataLength: u32,\n+            Reserved: u16,\n+            ReparseTargetLength: u16,\n+            ReparseTargetMaximumLength: u16,\n+            Reserved1: u16,\n+            ReparseTarget: u16,\n         }\n \n         fn to_u16s<S: AsRef<OsStr>>(s: S) -> io::Result<Vec<u16>> {\n@@ -193,17 +194,20 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n \n         let path = to_u16s(junction)?;\n \n-        unsafe {\n-            let h = CreateFileW(\n-                path.as_ptr(),\n-                GENERIC_WRITE,\n+        let h = unsafe {\n+            CreateFileW(\n+                PCWSTR(path.as_ptr()),\n+                FILE_ACCESS_FLAGS(GENERIC_WRITE),\n                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n-                ptr::null_mut(),\n+                None,\n                 OPEN_EXISTING,\n                 FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,\n-                ptr::null_mut(),\n-            );\n+                HANDLE::default(),\n+            )\n+        }\n+        .map_err(|_| io::Error::last_os_error())?;\n \n+        unsafe {\n             #[repr(C, align(8))]\n             struct Align8<T>(T);\n             let mut data = Align8([0u8; MAXIMUM_REPARSE_DATA_BUFFER_SIZE as usize]);\n@@ -219,27 +223,29 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n             }\n             *buf.offset(i) = 0;\n             i += 1;\n+\n             (*db).ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;\n-            (*db).ReparseTargetMaximumLength = (i * 2) as WORD;\n-            (*db).ReparseTargetLength = ((i - 1) * 2) as WORD;\n-            (*db).ReparseDataLength = (*db).ReparseTargetLength as DWORD + 12;\n+            (*db).ReparseTargetMaximumLength = (i * 2) as u16;\n+            (*db).ReparseTargetLength = ((i - 1) * 2) as u16;\n+            (*db).ReparseDataLength = ((*db).ReparseTargetLength + 12) as u32;\n \n-            let mut ret = 0;\n-            let res = DeviceIoControl(\n-                h as *mut _,\n+            let mut ret = 0u32;\n+            DeviceIoControl(\n+                h,\n                 FSCTL_SET_REPARSE_POINT,\n-                db.cast(),\n+                Some(db.cast()),\n                 (*db).ReparseDataLength + 8,\n-                ptr::null_mut(),\n+                None,\n                 0,\n-                &mut ret,\n-                ptr::null_mut(),\n-            );\n-\n-            let out = if res == 0 { Err(io::Error::last_os_error()) } else { Ok(()) };\n-            CloseHandle(h);\n-            out\n+                Some(&mut ret),\n+                None,\n+            )\n+            .ok()\n+            .map_err(|_| io::Error::last_os_error())?;\n         }\n+\n+        unsafe { CloseHandle(h) };\n+        Ok(())\n     }\n }\n "}, {"sha": "b5715024a8484533d8ecf55736e39f0b061084df", "filename": "src/ci/docker/host-x86_64/mingw-check-tidy/Dockerfile", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check-tidy%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check-tidy%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check-tidy%2FDockerfile?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,13 +1,16 @@\n FROM ubuntu:22.04\n \n ARG DEBIAN_FRONTEND=noninteractive\n+# NOTE: intentionally uses python2 for x.py so we can test it still works.\n+# validate-toolstate only runs in our CI, so it's ok for it to only support python3.\n RUN apt-get update && apt-get install -y --no-install-recommends \\\n   g++ \\\n   make \\\n   ninja-build \\\n   file \\\n   curl \\\n   ca-certificates \\\n+  python2.7 \\\n   python3 \\\n   python3-pip \\\n   python3-pkg-resources \\\n@@ -30,4 +33,4 @@ RUN pip3 install --no-deps --no-cache-dir --require-hashes -r /tmp/reuse-require\n COPY host-x86_64/mingw-check/validate-toolstate.sh /scripts/\n COPY host-x86_64/mingw-check/validate-error-codes.sh /scripts/\n \n-ENV SCRIPT python3 ../x.py test --stage 0 src/tools/tidy tidyselftest\n+ENV SCRIPT python2.7 ../x.py test --stage 0 src/tools/tidy tidyselftest"}, {"sha": "dc8a4aac76873e3fcb3feb1ea412f9ba70acdf4f", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-14/Dockerfile", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-14%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-14%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-14%2FDockerfile?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -2,7 +2,6 @@ FROM ubuntu:22.04\n \n ARG DEBIAN_FRONTEND=noninteractive\n \n-# NOTE: intentionally installs both python2 and python3 so we can test support for both.\n RUN apt-get update && apt-get install -y --no-install-recommends \\\n   g++ \\\n   gcc-multilib \\\n@@ -11,8 +10,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n-  python3 \\\n+  python3.11 \\\n   git \\\n   cmake \\\n   sudo \\"}, {"sha": "c594288dcf81d59d963f3c5bb893bd2038e07bf3", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -74,15 +74,15 @@ x--expand-yaml-anchors--remove:\n     env: {}\n \n   - &job-linux-xl\n-    os: ubuntu-20.04-xl\n+    os: ubuntu-20.04-16core-64gb\n     <<: *base-job\n \n   - &job-macos-xl\n     os: macos-12-xl\n     <<: *base-job\n \n   - &job-windows-xl\n-    os: windows-latest-xl\n+    os: windows-2019-8core-32gb\n     <<: *base-job\n \n   - &job-aarch64-linux"}, {"sha": "e3e5454ef5443072d7ed3998a559430f69e533b4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -39,6 +39,7 @@ use std::hash::Hash;\n use std::mem;\n use thin_vec::ThinVec;\n \n+use crate::clean::inline::merge_attrs;\n use crate::core::{self, DocContext, ImplTraitParam};\n use crate::formats::item_type::ItemType;\n use crate::visit_ast::Module as DocModule;\n@@ -2373,21 +2374,22 @@ fn clean_maybe_renamed_item<'tcx>(\n             _ => unreachable!(\"not yet converted\"),\n         };\n \n-        let mut extra_attrs = Vec::new();\n+        let mut import_attrs = Vec::new();\n+        let mut target_attrs = Vec::new();\n         if let Some(import_id) = import_id &&\n             let Some(hir::Node::Item(use_node)) = cx.tcx.hir().find_by_def_id(import_id)\n         {\n             let is_inline = inline::load_attrs(cx, import_id.to_def_id()).lists(sym::doc).get_word_attr(sym::inline).is_some();\n             // Then we get all the various imports' attributes.\n-            get_all_import_attributes(use_node, cx.tcx, item.owner_id.def_id, &mut extra_attrs, is_inline);\n-            add_without_unwanted_attributes(&mut extra_attrs, inline::load_attrs(cx, def_id), is_inline);\n+            get_all_import_attributes(use_node, cx.tcx, item.owner_id.def_id, &mut import_attrs, is_inline);\n+            add_without_unwanted_attributes(&mut target_attrs, inline::load_attrs(cx, def_id), is_inline);\n         } else {\n             // We only keep the item's attributes.\n-            extra_attrs.extend_from_slice(inline::load_attrs(cx, def_id));\n+            target_attrs.extend_from_slice(inline::load_attrs(cx, def_id));\n         }\n \n-        let attrs = Attributes::from_ast(&extra_attrs);\n-        let cfg = extra_attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n+        let import_parent = import_id.map(|import_id| cx.tcx.local_parent(import_id).to_def_id());\n+        let (attrs, cfg) =  merge_attrs(cx, import_parent, &target_attrs, Some(&import_attrs));\n \n         let mut item =\n             Item::from_def_id_and_attrs_and_parts(def_id, Some(name), kind, Box::new(attrs), cfg);"}, {"sha": "aaa83ecce4817ecb549e913829fed31730046963", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1057,6 +1057,16 @@ impl Tester for Collector {\n                     Ignore::Some(ref ignores) => ignores.iter().any(|s| target_str.contains(s)),\n                 },\n                 ignore_message: None,\n+                #[cfg(not(bootstrap))]\n+                source_file: \"\",\n+                #[cfg(not(bootstrap))]\n+                start_line: 0,\n+                #[cfg(not(bootstrap))]\n+                start_col: 0,\n+                #[cfg(not(bootstrap))]\n+                end_line: 0,\n+                #[cfg(not(bootstrap))]\n+                end_col: 0,\n                 // compiler failures are test failures\n                 should_panic: test::ShouldPanic::No,\n                 compile_fail: config.compile_fail,"}, {"sha": "f2b9c0bcf3ee7785f53e166f668360dd2c845c85", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1480,7 +1480,7 @@ pub(crate) fn visibility_print_with_space<'a, 'tcx: 'a>(\n                 debug!(\"path={:?}\", path);\n                 // modified from `resolved_path()` to work with `DefPathData`\n                 let last_name = path.data.last().unwrap().data.get_opt_name().unwrap();\n-                let anchor = anchor(vis_did, last_name, cx).to_string();\n+                let anchor = anchor(vis_did, last_name, cx);\n \n                 let mut s = \"pub(in \".to_owned();\n                 for seg in &path.data[..path.data.len() - 1] {"}, {"sha": "fd81a21f5a99453bf4268509cb22d59cf6ff341f", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -556,7 +556,15 @@ fn check_if_allowed_tag(t: &Tag<'_>) -> bool {\n }\n \n fn is_forbidden_tag(t: &Tag<'_>) -> bool {\n-    matches!(t, Tag::CodeBlock(_) | Tag::Table(_) | Tag::TableHead | Tag::TableRow | Tag::TableCell)\n+    matches!(\n+        t,\n+        Tag::CodeBlock(_)\n+            | Tag::Table(_)\n+            | Tag::TableHead\n+            | Tag::TableRow\n+            | Tag::TableCell\n+            | Tag::FootnoteDefinition(_)\n+    )\n }\n \n impl<'a, I: Iterator<Item = Event<'a>>> Iterator for SummaryLine<'a, I> {\n@@ -589,6 +597,10 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for SummaryLine<'a, I> {\n                     is_start = false;\n                     check_if_allowed_tag(c)\n                 }\n+                Event::FootnoteReference(_) => {\n+                    self.skipped_tags += 1;\n+                    false\n+                }\n                 _ => true,\n             };\n             if !is_allowed_tag {"}, {"sha": "ac5054ce1b6b520bc01f2c031265d5d542d11df5", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -352,7 +352,7 @@ impl<'tcx> Context<'tcx> {\n                 },\n             );\n \n-            path = href.into_inner().to_string_lossy().to_string();\n+            path = href.into_inner().to_string_lossy().into_owned();\n \n             if let Some(c) = path.as_bytes().last() && *c != b'/' {\n                 path.push('/');"}, {"sha": "7eb9c0b7cf52af0f8ff782d6f26e15ab05ddabd0", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 56, "deletions": 35, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,5 +1,6 @@\n use clean::AttributesExt;\n \n+use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n@@ -28,8 +29,8 @@ use crate::formats::item_type::ItemType;\n use crate::formats::{AssocItemRender, Impl, RenderMode};\n use crate::html::escape::Escape;\n use crate::html::format::{\n-    join_with_double_colon, print_abi_with_space, print_constness_with_space, print_where_clause,\n-    visibility_print_with_space, Buffer, Ending, PrintWithSpace,\n+    display_fn, join_with_double_colon, print_abi_with_space, print_constness_with_space,\n+    print_where_clause, visibility_print_with_space, Buffer, Ending, PrintWithSpace,\n };\n use crate::html::layout::Page;\n use crate::html::markdown::{HeadingOffset, MarkdownSummaryLine};\n@@ -367,7 +368,7 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                         ..myitem.clone()\n                     };\n \n-                    let stab_tags = Some(extra_info_tags(&import_item, item, cx.tcx()));\n+                    let stab_tags = Some(extra_info_tags(&import_item, item, cx.tcx()).to_string());\n                     stab_tags\n                 } else {\n                     None\n@@ -461,42 +462,62 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n \n /// Render the stability, deprecation and portability tags that are displayed in the item's summary\n /// at the module level.\n-fn extra_info_tags(item: &clean::Item, parent: &clean::Item, tcx: TyCtxt<'_>) -> String {\n-    let mut tags = String::new();\n-\n-    fn tag_html(class: &str, title: &str, contents: &str) -> String {\n-        format!(r#\"<span class=\"stab {}\" title=\"{}\">{}</span>\"#, class, Escape(title), contents)\n-    }\n-\n-    // The trailing space after each tag is to space it properly against the rest of the docs.\n-    if let Some(depr) = &item.deprecation(tcx) {\n-        let message = if stability::deprecation_in_effect(depr) {\n-            \"Deprecated\"\n-        } else {\n-            \"Deprecation planned\"\n-        };\n-        tags += &tag_html(\"deprecated\", \"\", message);\n-    }\n+fn extra_info_tags<'a, 'tcx: 'a>(\n+    item: &'a clean::Item,\n+    parent: &'a clean::Item,\n+    tcx: TyCtxt<'tcx>,\n+) -> impl fmt::Display + 'a + Captures<'tcx> {\n+    display_fn(move |f| {\n+        fn tag_html<'a>(\n+            class: &'a str,\n+            title: &'a str,\n+            contents: &'a str,\n+        ) -> impl fmt::Display + 'a {\n+            display_fn(move |f| {\n+                write!(\n+                    f,\n+                    r#\"<span class=\"stab {}\" title=\"{}\">{}</span>\"#,\n+                    class,\n+                    Escape(title),\n+                    contents\n+                )\n+            })\n+        }\n \n-    // The \"rustc_private\" crates are permanently unstable so it makes no sense\n-    // to render \"unstable\" everywhere.\n-    if item.stability(tcx).as_ref().map(|s| s.is_unstable() && s.feature != sym::rustc_private)\n-        == Some(true)\n-    {\n-        tags += &tag_html(\"unstable\", \"\", \"Experimental\");\n-    }\n+        // The trailing space after each tag is to space it properly against the rest of the docs.\n+        if let Some(depr) = &item.deprecation(tcx) {\n+            let message = if stability::deprecation_in_effect(depr) {\n+                \"Deprecated\"\n+            } else {\n+                \"Deprecation planned\"\n+            };\n+            write!(f, \"{}\", tag_html(\"deprecated\", \"\", message))?;\n+        }\n \n-    let cfg = match (&item.cfg, parent.cfg.as_ref()) {\n-        (Some(cfg), Some(parent_cfg)) => cfg.simplify_with(parent_cfg),\n-        (cfg, _) => cfg.as_deref().cloned(),\n-    };\n+        // The \"rustc_private\" crates are permanently unstable so it makes no sense\n+        // to render \"unstable\" everywhere.\n+        if item.stability(tcx).as_ref().map(|s| s.is_unstable() && s.feature != sym::rustc_private)\n+            == Some(true)\n+        {\n+            write!(f, \"{}\", tag_html(\"unstable\", \"\", \"Experimental\"))?;\n+        }\n \n-    debug!(\"Portability name={:?} {:?} - {:?} = {:?}\", item.name, item.cfg, parent.cfg, cfg);\n-    if let Some(ref cfg) = cfg {\n-        tags += &tag_html(\"portability\", &cfg.render_long_plain(), &cfg.render_short_html());\n-    }\n+        let cfg = match (&item.cfg, parent.cfg.as_ref()) {\n+            (Some(cfg), Some(parent_cfg)) => cfg.simplify_with(parent_cfg),\n+            (cfg, _) => cfg.as_deref().cloned(),\n+        };\n \n-    tags\n+        debug!(\"Portability name={:?} {:?} - {:?} = {:?}\", item.name, item.cfg, parent.cfg, cfg);\n+        if let Some(ref cfg) = cfg {\n+            write!(\n+                f,\n+                \"{}\",\n+                tag_html(\"portability\", &cfg.render_long_plain(), &cfg.render_short_html())\n+            )\n+        } else {\n+            Ok(())\n+        }\n+    })\n }\n \n fn item_function(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, f: &clean::Function) {"}, {"sha": "be9d1c408eca6173aec745c0cabef427524c6804", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -85,7 +85,7 @@ impl LocalSourcesCollector<'_, '_> {\n             },\n         );\n \n-        let mut href = href.into_inner().to_string_lossy().to_string();\n+        let mut href = href.into_inner().to_string_lossy().into_owned();\n         if let Some(c) = href.as_bytes().last() && *c != b'/' {\n             href.push('/');\n         }"}, {"sha": "36ff20e299e1ef5a628ace561b3e3788151695a9", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 70, "deletions": 26, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1202,28 +1202,42 @@ function initSearch(rawSearchIndex) {\n          * @param {Row} row\n          * @param {QueryElement} elem    - The element from the parsed query.\n          * @param {integer} typeFilter\n+         * @param {Array<integer>} skipPositions - Do not return one of these positions.\n          *\n-         * @return {integer} - Returns an edit distance to the best match. If there is no\n-         *                      match, returns `maxEditDistance + 1`.\n+         * @return {dist: integer, position: integer} - Returns an edit distance to the best match.\n+         *                                              If there is no match, returns\n+         *                                              `maxEditDistance + 1` and position: -1.\n          */\n-        function findArg(row, elem, typeFilter, maxEditDistance) {\n+        function findArg(row, elem, typeFilter, maxEditDistance, skipPositions) {\n             let dist = maxEditDistance + 1;\n+            let position = -1;\n \n             if (row && row.type && row.type.inputs && row.type.inputs.length > 0) {\n+                let i = 0;\n                 for (const input of row.type.inputs) {\n-                    if (!typePassesFilter(typeFilter, input.ty)) {\n+                    if (!typePassesFilter(typeFilter, input.ty) ||\n+                        skipPositions.indexOf(i) !== -1) {\n+                        i += 1;\n                         continue;\n                     }\n-                    dist = Math.min(\n-                        dist,\n-                        checkType(input, elem, parsedQuery.literalSearch, maxEditDistance)\n+                    const typeDist = checkType(\n+                        input,\n+                        elem,\n+                        parsedQuery.literalSearch,\n+                        maxEditDistance\n                     );\n-                    if (dist === 0) {\n-                        return 0;\n+                    if (typeDist === 0) {\n+                        return {dist: 0, position: i};\n+                    }\n+                    if (typeDist < dist) {\n+                        dist = typeDist;\n+                        position = i;\n                     }\n+                    i += 1;\n                 }\n             }\n-            return parsedQuery.literalSearch ? maxEditDistance + 1 : dist;\n+            dist = parsedQuery.literalSearch ? maxEditDistance + 1 : dist;\n+            return {dist, position};\n         }\n \n         /**\n@@ -1232,29 +1246,43 @@ function initSearch(rawSearchIndex) {\n          * @param {Row} row\n          * @param {QueryElement} elem   - The element from the parsed query.\n          * @param {integer} typeFilter\n+         * @param {Array<integer>} skipPositions - Do not return one of these positions.\n          *\n-         * @return {integer} - Returns an edit distance to the best match. If there is no\n-         *                      match, returns `maxEditDistance + 1`.\n+         * @return {dist: integer, position: integer} - Returns an edit distance to the best match.\n+         *                                              If there is no match, returns\n+         *                                              `maxEditDistance + 1` and position: -1.\n          */\n-        function checkReturned(row, elem, typeFilter, maxEditDistance) {\n+        function checkReturned(row, elem, typeFilter, maxEditDistance, skipPositions) {\n             let dist = maxEditDistance + 1;\n+            let position = -1;\n \n             if (row && row.type && row.type.output.length > 0) {\n                 const ret = row.type.output;\n+                let i = 0;\n                 for (const ret_ty of ret) {\n-                    if (!typePassesFilter(typeFilter, ret_ty.ty)) {\n+                    if (!typePassesFilter(typeFilter, ret_ty.ty) ||\n+                        skipPositions.indexOf(i) !== -1) {\n+                        i += 1;\n                         continue;\n                     }\n-                    dist = Math.min(\n-                        dist,\n-                        checkType(ret_ty, elem, parsedQuery.literalSearch, maxEditDistance)\n+                    const typeDist = checkType(\n+                        ret_ty,\n+                        elem,\n+                        parsedQuery.literalSearch,\n+                        maxEditDistance\n                     );\n-                    if (dist === 0) {\n-                        return 0;\n+                    if (typeDist === 0) {\n+                        return {dist: 0, position: i};\n                     }\n+                    if (typeDist < dist) {\n+                        dist = typeDist;\n+                        position = i;\n+                    }\n+                    i += 1;\n                 }\n             }\n-            return parsedQuery.literalSearch ? maxEditDistance + 1 : dist;\n+            dist = parsedQuery.literalSearch ? maxEditDistance + 1 : dist;\n+            return {dist, position};\n         }\n \n         function checkPath(contains, ty, maxEditDistance) {\n@@ -1455,13 +1483,13 @@ function initSearch(rawSearchIndex) {\n             const fullId = row.id;\n             const searchWord = searchWords[pos];\n \n-            const in_args = findArg(row, elem, parsedQuery.typeFilter, maxEditDistance);\n-            const returned = checkReturned(row, elem, parsedQuery.typeFilter, maxEditDistance);\n+            const in_args = findArg(row, elem, parsedQuery.typeFilter, maxEditDistance, []);\n+            const returned = checkReturned(row, elem, parsedQuery.typeFilter, maxEditDistance, []);\n \n             // path_dist is 0 because no parent path information is currently stored\n             // in the search index\n-            addIntoResults(results_in_args, fullId, pos, -1, in_args, 0, maxEditDistance);\n-            addIntoResults(results_returned, fullId, pos, -1, returned, 0, maxEditDistance);\n+            addIntoResults(results_in_args, fullId, pos, -1, in_args.dist, 0, maxEditDistance);\n+            addIntoResults(results_returned, fullId, pos, -1, returned.dist, 0, maxEditDistance);\n \n             if (!typePassesFilter(parsedQuery.typeFilter, row.ty)) {\n                 return;\n@@ -1534,12 +1562,20 @@ function initSearch(rawSearchIndex) {\n \n             // If the result is too \"bad\", we return false and it ends this search.\n             function checkArgs(elems, callback) {\n+                const skipPositions = [];\n                 for (const elem of elems) {\n                     // There is more than one parameter to the query so all checks should be \"exact\"\n-                    const dist = callback(row, elem, NO_TYPE_FILTER, maxEditDistance);\n+                    const { dist, position } = callback(\n+                        row,\n+                        elem,\n+                        NO_TYPE_FILTER,\n+                        maxEditDistance,\n+                        skipPositions\n+                    );\n                     if (dist <= 1) {\n                         nbDist += 1;\n                         totalDist += dist;\n+                        skipPositions.push(position);\n                     } else {\n                         return false;\n                     }\n@@ -1597,9 +1633,17 @@ function initSearch(rawSearchIndex) {\n                             row,\n                             elem,\n                             parsedQuery.typeFilter,\n+                            maxEditDistance,\n+                            []\n+                        );\n+                        addIntoResults(\n+                            results_others,\n+                            row.id,\n+                            i,\n+                            -1,\n+                            in_returned.dist,\n                             maxEditDistance\n                         );\n-                        addIntoResults(results_others, row.id, i, -1, in_returned, maxEditDistance);\n                     }\n                 }\n             } else if (parsedQuery.foundElems > 0) {"}, {"sha": "75d155e91c203b027327ee52f325e44baf5249e3", "filename": "src/librustdoc/html/templates/short_item_info.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fshort_item_info.html", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fshort_item_info.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fshort_item_info.html?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -2,7 +2,7 @@\n     {% when Self::Deprecation with { message } %}\n         <div class=\"stab deprecated\"> {# #}\n             <span class=\"emoji\">\ud83d\udc4e</span> {# #}\n-            <span>{{message}}</span> {# #}\n+            <span>{{message|safe}}</span> {# #}\n         </div> {# #}\n     {% when Self::Unstable with { feature, tracking } %}\n         <div class=\"stab unstable\"> {# #}"}, {"sha": "6ed7b98999977664d54327fb3d91a99834a37d10", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -286,7 +286,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             split.next().map(|f|  Symbol::intern(f)).ok_or_else(no_res)?;\n         let path = split\n             .next()\n-            .map(|f| f.to_owned())\n             // If there's no third component, we saw `[a::b]` before and it failed to resolve.\n             // So there's no partial res.\n             .ok_or_else(no_res)?;\n@@ -429,7 +428,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         let item_name = Symbol::intern(item_str);\n         let path_root = split\n             .next()\n-            .map(|f| f.to_owned())\n             // If there's no `::`, it's not an associated item.\n             // So we can be sure that `rustc_resolve` was accurate when it said it wasn't resolved.\n             .ok_or_else(|| {"}, {"sha": "060062db0027aa5cd809501e7d6db85d11a169ff", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -265,10 +265,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false;\n         }\n \n-        if !self.view_item_stack.insert(res_did) {\n-            return false;\n-        }\n-\n         if !please_inline &&\n             let mut visitor = OneLevelVisitor::new(self.cx.tcx.hir(), res_did) &&\n             let Some(item) = visitor.find_target(self.cx.tcx, def_id.to_def_id(), path) &&\n@@ -285,6 +281,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false;\n         }\n \n+        if !self.view_item_stack.insert(res_did) {\n+            return false;\n+        }\n+\n         let ret = match tcx.hir().get_by_def_id(res_did) {\n             Node::Item(&hir::Item { kind: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);"}, {"sha": "85fd6523c82b190128d11bcfb714449ed9ddaaa9", "filename": "src/tools/compiletest/Cargo.toml", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Fcompiletest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Fcompiletest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2FCargo.toml?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -26,4 +26,10 @@ libc = \"0.2\"\n \n [target.'cfg(windows)'.dependencies]\n miow = \"0.5\"\n-winapi = { version = \"0.3\", features = [\"winerror\"] }\n+\n+[target.'cfg(windows)'.dependencies.windows]\n+version = \"0.46.0\"\n+features = [\n+    \"Win32_Foundation\",\n+    \"Win32_System_Diagnostics_Debug\",\n+]"}, {"sha": "22a0b1d13be160359808c09a741ea4a0b005f4f8", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1047,6 +1047,16 @@ pub fn make_test_description<R: Read>(\n         name,\n         ignore,\n         ignore_message,\n+        #[cfg(not(bootstrap))]\n+        source_file: \"\",\n+        #[cfg(not(bootstrap))]\n+        start_line: 0,\n+        #[cfg(not(bootstrap))]\n+        start_col: 0,\n+        #[cfg(not(bootstrap))]\n+        end_line: 0,\n+        #[cfg(not(bootstrap))]\n+        end_col: 0,\n         should_panic,\n         compile_fail: false,\n         no_run: false,"}, {"sha": "725f7a1515c626449c7a8115cdac5318e0af2f59", "filename": "src/tools/compiletest/src/read2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -232,7 +232,7 @@ mod imp {\n     use miow::iocp::{CompletionPort, CompletionStatus};\n     use miow::pipe::NamedPipe;\n     use miow::Overlapped;\n-    use winapi::shared::winerror::ERROR_BROKEN_PIPE;\n+    use windows::Win32::Foundation::ERROR_BROKEN_PIPE;\n \n     struct Pipe<'a> {\n         dst: &'a mut Vec<u8>,\n@@ -295,7 +295,7 @@ mod imp {\n             match self.pipe.read_overlapped(dst, self.overlapped.raw()) {\n                 Ok(_) => Ok(()),\n                 Err(e) => {\n-                    if e.raw_os_error() == Some(ERROR_BROKEN_PIPE as i32) {\n+                    if e.raw_os_error() == Some(ERROR_BROKEN_PIPE.0 as i32) {\n                         self.done = true;\n                         Ok(())\n                     } else {"}, {"sha": "a40030723105272df2a266187a7977eb92503b72", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 40, "deletions": 17, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -49,8 +49,10 @@ const FAKE_SRC_BASE: &str = \"fake-test-src-base\";\n #[cfg(windows)]\n fn disable_error_reporting<F: FnOnce() -> R, R>(f: F) -> R {\n     use std::sync::Mutex;\n-    use winapi::um::errhandlingapi::SetErrorMode;\n-    use winapi::um::winbase::SEM_NOGPFAULTERRORBOX;\n+\n+    use windows::Win32::System::Diagnostics::Debug::{\n+        SetErrorMode, SEM_NOGPFAULTERRORBOX, THREAD_ERROR_MODE,\n+    };\n \n     static LOCK: Mutex<()> = Mutex::new(());\n \n@@ -62,6 +64,7 @@ fn disable_error_reporting<F: FnOnce() -> R, R>(f: F) -> R {\n     // termination by design. This mode is inherited by all child processes.\n     unsafe {\n         let old_mode = SetErrorMode(SEM_NOGPFAULTERRORBOX); // read inherited flags\n+        let old_mode = THREAD_ERROR_MODE(old_mode);\n         SetErrorMode(old_mode | SEM_NOGPFAULTERRORBOX);\n         let r = f();\n         SetErrorMode(old_mode);\n@@ -278,13 +281,15 @@ impl<'test> TestCx<'test> {\n             Incremental => {\n                 let revision =\n                     self.revision.expect(\"incremental tests require a list of revisions\");\n-                if revision.starts_with(\"rpass\") || revision.starts_with(\"rfail\") {\n+                if revision.starts_with(\"cpass\")\n+                    || revision.starts_with(\"rpass\")\n+                    || revision.starts_with(\"rfail\")\n+                {\n                     true\n                 } else if revision.starts_with(\"cfail\") {\n-                    // FIXME: would be nice if incremental revs could start with \"cpass\"\n                     pm.is_some()\n                 } else {\n-                    panic!(\"revision name must begin with rpass, rfail, or cfail\");\n+                    panic!(\"revision name must begin with cpass, rpass, rfail, or cfail\");\n                 }\n             }\n             mode => panic!(\"unimplemented for mode {:?}\", mode),\n@@ -384,6 +389,20 @@ impl<'test> TestCx<'test> {\n         }\n     }\n \n+    fn run_cpass_test(&self) {\n+        let emit_metadata = self.should_emit_metadata(self.pass_mode());\n+        let proc_res = self.compile_test(WillExecute::No, emit_metadata);\n+\n+        if !proc_res.status.success() {\n+            self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n+        }\n+\n+        // FIXME(#41968): Move this check to tidy?\n+        if !errors::load_errors(&self.testpaths.file, self.revision).is_empty() {\n+            self.fatal(\"compile-pass tests with expected warnings should be moved to ui/\");\n+        }\n+    }\n+\n     fn run_rpass_test(&self) {\n         let emit_metadata = self.should_emit_metadata(self.pass_mode());\n         let should_run = self.run_if_enabled();\n@@ -393,17 +412,15 @@ impl<'test> TestCx<'test> {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n         }\n \n+        // FIXME(#41968): Move this check to tidy?\n+        if !errors::load_errors(&self.testpaths.file, self.revision).is_empty() {\n+            self.fatal(\"run-pass tests with expected warnings should be moved to ui/\");\n+        }\n+\n         if let WillExecute::Disabled = should_run {\n             return;\n         }\n \n-        // FIXME(#41968): Move this check to tidy?\n-        let expected_errors = errors::load_errors(&self.testpaths.file, self.revision);\n-        assert!(\n-            expected_errors.is_empty(),\n-            \"run-pass tests with expected warnings should be moved to ui/\"\n-        );\n-\n         let proc_res = self.exec_compiled_test();\n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"test run failed!\", &proc_res);\n@@ -2913,10 +2930,11 @@ impl<'test> TestCx<'test> {\n     fn run_incremental_test(&self) {\n         // Basic plan for a test incremental/foo/bar.rs:\n         // - load list of revisions rpass1, cfail2, rpass3\n-        //   - each should begin with `rpass`, `cfail`, or `rfail`\n-        //   - if `rpass`, expect compile and execution to succeed\n+        //   - each should begin with `cpass`, `rpass`, `cfail`, or `rfail`\n+        //   - if `cpass`, expect compilation to succeed, don't execute\n+        //   - if `rpass`, expect compilation and execution to succeed\n         //   - if `cfail`, expect compilation to fail\n-        //   - if `rfail`, expect execution to fail\n+        //   - if `rfail`, expect compilation to succeed and execution to fail\n         // - create a directory build/foo/bar.incremental\n         // - compile foo/bar.rs with -C incremental=.../foo/bar.incremental and -C rpass1\n         //   - because name of revision starts with \"rpass\", expect success\n@@ -2940,7 +2958,12 @@ impl<'test> TestCx<'test> {\n             print!(\"revision={:?} props={:#?}\", revision, self.props);\n         }\n \n-        if revision.starts_with(\"rpass\") {\n+        if revision.starts_with(\"cpass\") {\n+            if self.props.should_ice {\n+                self.fatal(\"can only use should-ice in cfail tests\");\n+            }\n+            self.run_cpass_test();\n+        } else if revision.starts_with(\"rpass\") {\n             if self.props.should_ice {\n                 self.fatal(\"can only use should-ice in cfail tests\");\n             }\n@@ -2953,7 +2976,7 @@ impl<'test> TestCx<'test> {\n         } else if revision.starts_with(\"cfail\") {\n             self.run_cfail_test();\n         } else {\n-            self.fatal(\"revision name must begin with rpass, rfail, or cfail\");\n+            self.fatal(\"revision name must begin with cpass, rpass, rfail, or cfail\");\n         }\n     }\n "}, {"sha": "7e2051fc98a0ee8ed2f5c65d5874dd4aa88d16aa", "filename": "src/tools/miri/src/shims/windows/dlsym.rs", "status": "modified", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fdlsym.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,5 +1,4 @@\n use rustc_middle::mir;\n-use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n \n use log::trace;\n@@ -11,7 +10,6 @@ use crate::*;\n \n #[derive(Debug, Copy, Clone)]\n pub enum Dlsym {\n-    NtWriteFile,\n     SetThreadDescription,\n     WaitOnAddress,\n     WakeByAddressSingle,\n@@ -23,7 +21,6 @@ impl Dlsym {\n     pub fn from_str<'tcx>(name: &str) -> InterpResult<'tcx, Option<Dlsym>> {\n         Ok(match name {\n             \"GetSystemTimePreciseAsFileTime\" => None,\n-            \"NtWriteFile\" => Some(Dlsym::NtWriteFile),\n             \"SetThreadDescription\" => Some(Dlsym::SetThreadDescription),\n             \"WaitOnAddress\" => Some(Dlsym::WaitOnAddress),\n             \"WakeByAddressSingle\" => Some(Dlsym::WakeByAddressSingle),\n@@ -49,72 +46,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.check_abi(abi, Abi::System { unwind: false })?;\n \n         match dlsym {\n-            Dlsym::NtWriteFile => {\n-                if !this.frame_in_std() {\n-                    throw_unsup_format!(\n-                        \"`NtWriteFile` support is crude and just enough for stdout to work\"\n-                    );\n-                }\n-\n-                let [\n-                    handle,\n-                    _event,\n-                    _apc_routine,\n-                    _apc_context,\n-                    io_status_block,\n-                    buf,\n-                    n,\n-                    byte_offset,\n-                    _key,\n-                ] = check_arg_count(args)?;\n-                let handle = this.read_target_isize(handle)?;\n-                let buf = this.read_pointer(buf)?;\n-                let n = this.read_scalar(n)?.to_u32()?;\n-                let byte_offset = this.read_target_usize(byte_offset)?; // is actually a pointer\n-                let io_status_block = this.deref_operand(io_status_block)?;\n-\n-                if byte_offset != 0 {\n-                    throw_unsup_format!(\n-                        \"`NtWriteFile` `ByteOffset` paremeter is non-null, which is unsupported\"\n-                    );\n-                }\n-\n-                let written = if handle == -11 || handle == -12 {\n-                    // stdout/stderr\n-                    use std::io::{self, Write};\n-\n-                    let buf_cont =\n-                        this.read_bytes_ptr_strip_provenance(buf, Size::from_bytes(u64::from(n)))?;\n-                    let res = if this.machine.mute_stdout_stderr {\n-                        Ok(buf_cont.len())\n-                    } else if handle == -11 {\n-                        io::stdout().write(buf_cont)\n-                    } else {\n-                        io::stderr().write(buf_cont)\n-                    };\n-                    // We write at most `n` bytes, which is a `u32`, so we cannot have written more than that.\n-                    res.ok().map(|n| u32::try_from(n).unwrap())\n-                } else {\n-                    throw_unsup_format!(\n-                        \"on Windows, writing to anything except stdout/stderr is not supported\"\n-                    )\n-                };\n-                // We have to put the result into io_status_block.\n-                if let Some(n) = written {\n-                    let io_status_information =\n-                        this.mplace_field_named(&io_status_block, \"Information\")?;\n-                    this.write_scalar(\n-                        Scalar::from_target_usize(n.into(), this),\n-                        &io_status_information.into(),\n-                    )?;\n-                }\n-                // Return whether this was a success. >= 0 is success.\n-                // For the error code we arbitrarily pick 0xC0000185, STATUS_IO_DEVICE_ERROR.\n-                this.write_scalar(\n-                    Scalar::from_u32(if written.is_some() { 0 } else { 0xC0000185u32 }),\n-                    dest,\n-                )?;\n-            }\n             Dlsym::SetThreadDescription => {\n                 let [handle, name] = check_arg_count(args)?;\n "}, {"sha": "665c7ed438f3d1bf777f250398dfa7971481cff6", "filename": "src/tools/miri/src/shims/windows/foreign_items.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -69,6 +69,74 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 this.write_scalar(result, dest)?;\n             }\n \n+            // File related shims\n+            \"NtWriteFile\" => {\n+                if !this.frame_in_std() {\n+                    throw_unsup_format!(\n+                        \"`NtWriteFile` support is crude and just enough for stdout to work\"\n+                    );\n+                }\n+\n+                let [\n+                    handle,\n+                    _event,\n+                    _apc_routine,\n+                    _apc_context,\n+                    io_status_block,\n+                    buf,\n+                    n,\n+                    byte_offset,\n+                    _key,\n+                ] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let handle = this.read_target_isize(handle)?;\n+                let buf = this.read_pointer(buf)?;\n+                let n = this.read_scalar(n)?.to_u32()?;\n+                let byte_offset = this.read_target_usize(byte_offset)?; // is actually a pointer\n+                let io_status_block = this.deref_operand(io_status_block)?;\n+\n+                if byte_offset != 0 {\n+                    throw_unsup_format!(\n+                        \"`NtWriteFile` `ByteOffset` paremeter is non-null, which is unsupported\"\n+                    );\n+                }\n+\n+                let written = if handle == -11 || handle == -12 {\n+                    // stdout/stderr\n+                    use std::io::{self, Write};\n+\n+                    let buf_cont =\n+                        this.read_bytes_ptr_strip_provenance(buf, Size::from_bytes(u64::from(n)))?;\n+                    let res = if this.machine.mute_stdout_stderr {\n+                        Ok(buf_cont.len())\n+                    } else if handle == -11 {\n+                        io::stdout().write(buf_cont)\n+                    } else {\n+                        io::stderr().write(buf_cont)\n+                    };\n+                    // We write at most `n` bytes, which is a `u32`, so we cannot have written more than that.\n+                    res.ok().map(|n| u32::try_from(n).unwrap())\n+                } else {\n+                    throw_unsup_format!(\n+                        \"on Windows, writing to anything except stdout/stderr is not supported\"\n+                    )\n+                };\n+                // We have to put the result into io_status_block.\n+                if let Some(n) = written {\n+                    let io_status_information =\n+                        this.mplace_field_named(&io_status_block, \"Information\")?;\n+                    this.write_scalar(\n+                        Scalar::from_target_usize(n.into(), this),\n+                        &io_status_information.into(),\n+                    )?;\n+                }\n+                // Return whether this was a success. >= 0 is success.\n+                // For the error code we arbitrarily pick 0xC0000185, STATUS_IO_DEVICE_ERROR.\n+                this.write_scalar(\n+                    Scalar::from_u32(if written.is_some() { 0 } else { 0xC0000185u32 }),\n+                    dest,\n+                )?;\n+            }\n+\n             // Allocation\n             \"HeapAlloc\" => {\n                 let [handle, flags, size] ="}, {"sha": "25242c6028a476fbbc51560e1cbe486d7f489642", "filename": "src/tools/rust-analyzer/Cargo.lock", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.lock?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -169,9 +169,9 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.88.0\"\n+version = \"0.89.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4df80a3fbc1f0e59f560eeeebca94bf655566a8ad3023c210a109deb6056455a\"\n+checksum = \"ea176c50987dc4765961aa165001e8eb5a722a26308c5797a47303ea91686aab\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -181,9 +181,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.88.0\"\n+version = \"0.89.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f39e5272016916956298cceea5147006f897972c274a768ed4d6e074efe5d3fb\"\n+checksum = \"473b480241695428c14e8f84f1c9a47ef232450a50faf3a4041e5c9dc11e0a3b\"\n dependencies = [\n  \"bitflags\",\n  \"chalk-derive\",\n@@ -192,9 +192,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-recursive\"\n-version = \"0.88.0\"\n+version = \"0.89.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d9d60b42ad7478d3e027e2f9ea4e99fbbb8fdee0c8c3cf068be269f57e603618\"\n+checksum = \"6764b4fe67cac3a3758185084efbfbd39bf0352795824ba849ddd2b64cd4bb28\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -205,9 +205,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.88.0\"\n+version = \"0.89.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab30620ea5b36819525eaab2204f4b8e1842fc7ee36826424a28bef59ae7fecf\"\n+checksum = \"55a7e6160966eceb6e7dcc2f479a2af4c477aaf5bccbc640d82515995ab1a6cc\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\","}, {"sha": "7610a3ae1e3cb5237504e9697a8064a1fac96b46", "filename": "src/tools/rust-analyzer/bench_data/numerous_macro_rules", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fbench_data%2Fnumerous_macro_rules", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fbench_data%2Fnumerous_macro_rules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fbench_data%2Fnumerous_macro_rules?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -341,8 +341,8 @@ macro_rules! __ra_macro_fixture339 {($name :  ident )=>{ impl  Clone  for $name\n macro_rules! __ra_macro_fixture340 {([$($stack :  tt )*])=>{$($stack )* }; ([$($stack :  tt )*]{$($tail :  tt )* })=>{$($stack )* { remove_sections_inner ! ([]$($tail )*); }}; ([$($stack :  tt )*]$t :  tt $($tail :  tt )*)=>{ remove_sections ! ([$($stack )* $t ]$($tail )*); }; }\n macro_rules! __ra_macro_fixture341 {($t :  ty ,$z :  expr )=>{ impl  Zero  for $t { fn  zero ()->  Self {$z  as $t } fn  is_zero (&  self )->  bool { self == &  Self ::  zero ()}}}; }\n macro_rules! __ra_macro_fixture342 {($($ident :  ident ),* $(,)?)=>{$(# [ allow ( bad_style )] pub  const $ident :  super ::  Name =  super ::  Name ::  new_inline ( stringify ! ($ident )); )* }; }\n-macro_rules! __ra_macro_fixture343 {($($trait :  ident =>$expand :  ident ),* )=>{# [ derive ( Debug ,  Clone ,  Copy ,  PartialEq ,  Eq ,  Hash )] pub  enum  BuiltinDeriveExpander {$($trait ),* } impl  BuiltinDeriveExpander { pub  fn  expand (&  self ,  db : &  dyn  AstDatabase ,  id :  LazyMacroId ,  tt : &  tt ::  Subtree , )->  Result <  tt ::  Subtree ,  mbe ::  ExpandError > { let  expander =  match *  self {$(BuiltinDeriveExpander ::$trait =>$expand , )* };  expander ( db ,  id ,  tt )} fn  find_by_name ( name : &  name ::  Name )->  Option <  Self > { match  name {$(id  if  id == &  name ::  name ! [$trait ]=> Some ( BuiltinDeriveExpander ::$trait ), )* _ => None , }}}}; }\n-macro_rules! __ra_macro_fixture344 {( LAZY : $(($name :  ident , $kind :  ident )=>$expand :  ident ),* ,  EAGER : $(($e_name :  ident , $e_kind :  ident )=>$e_expand :  ident ),* )=>{# [ derive ( Debug ,  Clone ,  Copy ,  PartialEq ,  Eq ,  Hash )] pub  enum  BuiltinFnLikeExpander {$($kind ),* }# [ derive ( Debug ,  Clone ,  Copy ,  PartialEq ,  Eq ,  Hash )] pub  enum  EagerExpander {$($e_kind ),* } impl  BuiltinFnLikeExpander { pub  fn  expand (&  self ,  db : &  dyn  AstDatabase ,  id :  LazyMacroId ,  tt : &  tt ::  Subtree , )->  ExpandResult <  tt ::  Subtree > { let  expander =  match *  self {$(BuiltinFnLikeExpander ::$kind =>$expand , )* };  expander ( db ,  id ,  tt )}} impl  EagerExpander { pub  fn  expand (&  self ,  db : &  dyn  AstDatabase ,  arg_id :  EagerMacroId ,  tt : &  tt ::  Subtree , )->  ExpandResult <  Option < ( tt ::  Subtree ,  FragmentKind )>> { let  expander =  match *  self {$(EagerExpander ::$e_kind =>$e_expand , )* };  expander ( db ,  arg_id ,  tt )}} fn  find_by_name ( ident : &  name ::  Name )->  Option <  Either <  BuiltinFnLikeExpander ,  EagerExpander >> { match  ident {$(id  if  id == &  name ::  name ! [$name ]=> Some ( Either ::  Left ( BuiltinFnLikeExpander ::$kind )), )* $(id  if  id == &  name ::  name ! [$e_name ]=> Some ( Either ::  Right ( EagerExpander ::$e_kind )), )* _ => return  None , }}}; }\n+macro_rules! __ra_macro_fixture343 {($($trait :  ident =>$expand :  ident ),* )=>{# [ derive ( Debug ,  Clone ,  Copy ,  PartialEq ,  Eq ,  Hash )] pub  enum  BuiltinDeriveExpander {$($trait ),* } impl  BuiltinDeriveExpander { pub  fn  expand (&  self ,  db : &  dyn  ExpandDatabase ,  id :  LazyMacroId ,  tt : &  tt ::  Subtree , )->  Result <  tt ::  Subtree ,  mbe ::  ExpandError > { let  expander =  match *  self {$(BuiltinDeriveExpander ::$trait =>$expand , )* };  expander ( db ,  id ,  tt )} fn  find_by_name ( name : &  name ::  Name )->  Option <  Self > { match  name {$(id  if  id == &  name ::  name ! [$trait ]=> Some ( BuiltinDeriveExpander ::$trait ), )* _ => None , }}}}; }\n+macro_rules! __ra_macro_fixture344 {( LAZY : $(($name :  ident , $kind :  ident )=>$expand :  ident ),* ,  EAGER : $(($e_name :  ident , $e_kind :  ident )=>$e_expand :  ident ),* )=>{# [ derive ( Debug ,  Clone ,  Copy ,  PartialEq ,  Eq ,  Hash )] pub  enum  BuiltinFnLikeExpander {$($kind ),* }# [ derive ( Debug ,  Clone ,  Copy ,  PartialEq ,  Eq ,  Hash )] pub  enum  EagerExpander {$($e_kind ),* } impl  BuiltinFnLikeExpander { pub  fn  expand (&  self ,  db : &  dyn  ExpandDatabase ,  id :  LazyMacroId ,  tt : &  tt ::  Subtree , )->  ExpandResult <  tt ::  Subtree > { let  expander =  match *  self {$(BuiltinFnLikeExpander ::$kind =>$expand , )* };  expander ( db ,  id ,  tt )}} impl  EagerExpander { pub  fn  expand (&  self ,  db : &  dyn  ExpandDatabase ,  arg_id :  EagerMacroId ,  tt : &  tt ::  Subtree , )->  ExpandResult <  Option < ( tt ::  Subtree ,  FragmentKind )>> { let  expander =  match *  self {$(EagerExpander ::$e_kind =>$e_expand , )* };  expander ( db ,  arg_id ,  tt )}} fn  find_by_name ( ident : &  name ::  Name )->  Option <  Either <  BuiltinFnLikeExpander ,  EagerExpander >> { match  ident {$(id  if  id == &  name ::  name ! [$name ]=> Some ( Either ::  Left ( BuiltinFnLikeExpander ::$kind )), )* $(id  if  id == &  name ::  name ! [$e_name ]=> Some ( Either ::  Right ( EagerExpander ::$e_kind )), )* _ => return  None , }}}; }\n macro_rules! __ra_macro_fixture345 {($($ty :  ty =>$this :  ident $im :  block );*)=>{$(impl  ToTokenTree  for $ty { fn  to_token ($this )->  tt ::  TokenTree { let  leaf :  tt ::  Leaf = $im .  into ();  leaf .  into ()}} impl  ToTokenTree  for &$ty { fn  to_token ($this )->  tt ::  TokenTree { let  leaf :  tt ::  Leaf = $im .  clone ().  into ();  leaf .  into ()}})* }}\n macro_rules! __ra_macro_fixture346 {($name :  ident )=>{ impl $crate ::  salsa ::  InternKey  for $name { fn  from_intern_id ( v : $crate ::  salsa ::  InternId )->  Self {$name ( v )} fn  as_intern_id (&  self )-> $crate ::  salsa ::  InternId { self .  0 }}}; }\n macro_rules! __ra_macro_fixture347 {($($var :  ident ($t :  ty )),+ )=>{$(impl  From <$t >  for  AttrOwner { fn  from ( t : $t )->  AttrOwner { AttrOwner ::$var ( t )}})+ }; }"}, {"sha": "b336f59ffee312f08c1128e71fcbd6f5e8ce1dde", "filename": "src/tools/rust-analyzer/crates/hir-def/src/adt.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fadt.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -40,6 +40,7 @@ pub struct StructData {\n     pub repr: Option<ReprOptions>,\n     pub visibility: RawVisibility,\n     pub rustc_has_incoherent_inherent_impls: bool,\n+    pub fundamental: bool,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -173,10 +174,10 @@ impl StructData {\n         let item_tree = loc.id.item_tree(db);\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n-        let rustc_has_incoherent_inherent_impls = item_tree\n-            .attrs(db, loc.container.krate, ModItem::from(loc.id.value).into())\n-            .by_key(\"rustc_has_incoherent_inherent_impls\")\n-            .exists();\n+        let attrs = item_tree.attrs(db, loc.container.krate, ModItem::from(loc.id.value).into());\n+        let rustc_has_incoherent_inherent_impls =\n+            attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists();\n+        let fundamental = attrs.by_key(\"fundamental\").exists();\n \n         let strukt = &item_tree[loc.id.value];\n         let (variant_data, diagnostics) = lower_fields(\n@@ -196,6 +197,7 @@ impl StructData {\n                 repr,\n                 visibility: item_tree[strukt.visibility].clone(),\n                 rustc_has_incoherent_inherent_impls,\n+                fundamental,\n             }),\n             diagnostics.into(),\n         )\n@@ -215,10 +217,10 @@ impl StructData {\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n \n-        let rustc_has_incoherent_inherent_impls = item_tree\n-            .attrs(db, loc.container.krate, ModItem::from(loc.id.value).into())\n-            .by_key(\"rustc_has_incoherent_inherent_impls\")\n-            .exists();\n+        let attrs = item_tree.attrs(db, loc.container.krate, ModItem::from(loc.id.value).into());\n+        let rustc_has_incoherent_inherent_impls =\n+            attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists();\n+        let fundamental = attrs.by_key(\"fundamental\").exists();\n \n         let union = &item_tree[loc.id.value];\n         let (variant_data, diagnostics) = lower_fields(\n@@ -238,6 +240,7 @@ impl StructData {\n                 repr,\n                 visibility: item_tree[union.visibility].clone(),\n                 rustc_has_incoherent_inherent_impls,\n+                fundamental,\n             }),\n             diagnostics.into(),\n         )"}, {"sha": "b70e658efd79cd6a64df12a14f37dcbe8f4f0b1f", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -24,7 +24,9 @@ use syntax::{ast, AstPtr, SyntaxNode, SyntaxNodePtr};\n use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n-    expr::{dummy_expr_id, Binding, BindingId, Expr, ExprId, Label, LabelId, Pat, PatId},\n+    expr::{\n+        dummy_expr_id, Binding, BindingId, Expr, ExprId, Label, LabelId, Pat, PatId, RecordFieldPat,\n+    },\n     item_scope::BuiltinShadowMode,\n     macro_id_to_def_id,\n     nameres::DefMap,\n@@ -432,6 +434,44 @@ impl Body {\n         pats.shrink_to_fit();\n         bindings.shrink_to_fit();\n     }\n+\n+    pub fn walk_bindings_in_pat(&self, pat_id: PatId, mut f: impl FnMut(BindingId)) {\n+        self.walk_pats(pat_id, &mut |pat| {\n+            if let Pat::Bind { id, .. } = pat {\n+                f(*id);\n+            }\n+        });\n+    }\n+\n+    pub fn walk_pats(&self, pat_id: PatId, f: &mut impl FnMut(&Pat)) {\n+        let pat = &self[pat_id];\n+        f(pat);\n+        match pat {\n+            Pat::Range { .. }\n+            | Pat::Lit(..)\n+            | Pat::Path(..)\n+            | Pat::ConstBlock(..)\n+            | Pat::Wild\n+            | Pat::Missing => {}\n+            &Pat::Bind { subpat, .. } => {\n+                if let Some(subpat) = subpat {\n+                    self.walk_pats(subpat, f);\n+                }\n+            }\n+            Pat::Or(args) | Pat::Tuple { args, .. } | Pat::TupleStruct { args, .. } => {\n+                args.iter().copied().for_each(|p| self.walk_pats(p, f));\n+            }\n+            Pat::Ref { pat, .. } => self.walk_pats(*pat, f),\n+            Pat::Slice { prefix, slice, suffix } => {\n+                let total_iter = prefix.iter().chain(slice.iter()).chain(suffix.iter());\n+                total_iter.copied().for_each(|p| self.walk_pats(p, f));\n+            }\n+            Pat::Record { args, .. } => {\n+                args.iter().for_each(|RecordFieldPat { pat, .. }| self.walk_pats(*pat, f));\n+            }\n+            Pat::Box { inner } => self.walk_pats(*inner, f),\n+        }\n+    }\n }\n \n impl Default for Body {"}, {"sha": "fedaf39559858099094328286961bf44b7842bf2", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -499,6 +499,8 @@ impl ExprCollector<'_> {\n                         Movability::Movable\n                     };\n                     ClosureKind::Generator(movability)\n+                } else if e.async_token().is_some() {\n+                    ClosureKind::Async\n                 } else {\n                     ClosureKind::Closure\n                 };"}, {"sha": "5a9b825a2530bd5c7bf7bd8d15f5fd444b4f84b5", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -360,8 +360,14 @@ impl<'a> Printer<'a> {\n                 w!(self, \"]\");\n             }\n             Expr::Closure { args, arg_types, ret_type, body, closure_kind } => {\n-                if let ClosureKind::Generator(Movability::Static) = closure_kind {\n-                    w!(self, \"static \");\n+                match closure_kind {\n+                    ClosureKind::Generator(Movability::Static) => {\n+                        w!(self, \"static \");\n+                    }\n+                    ClosureKind::Async => {\n+                        w!(self, \"async \");\n+                    }\n+                    _ => (),\n                 }\n                 w!(self, \"|\");\n                 for (i, (pat, ty)) in args.iter().zip(arg_types.iter()).enumerate() {"}, {"sha": "1633a33bedde87d1d7a0cf6c63df9e17dec1b5b3", "filename": "src/tools/rust-analyzer/crates/hir-def/src/data.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -35,6 +35,7 @@ pub struct FunctionData {\n     pub visibility: RawVisibility,\n     pub abi: Option<Interned<str>>,\n     pub legacy_const_generics_indices: Box<[u32]>,\n+    pub rustc_allow_incoherent_impl: bool,\n     flags: FnFlags,\n }\n \n@@ -84,13 +85,14 @@ impl FunctionData {\n             }\n         }\n \n-        let legacy_const_generics_indices = item_tree\n-            .attrs(db, krate, ModItem::from(loc.id.value).into())\n+        let attrs = item_tree.attrs(db, krate, ModItem::from(loc.id.value).into());\n+        let legacy_const_generics_indices = attrs\n             .by_key(\"rustc_legacy_const_generics\")\n             .tt_values()\n             .next()\n             .map(parse_rustc_legacy_const_generics)\n             .unwrap_or_default();\n+        let rustc_allow_incoherent_impl = attrs.by_key(\"rustc_allow_incoherent_impl\").exists();\n \n         Arc::new(FunctionData {\n             name: func.name.clone(),\n@@ -108,6 +110,7 @@ impl FunctionData {\n             abi: func.abi.clone(),\n             legacy_const_generics_indices,\n             flags,\n+            rustc_allow_incoherent_impl,\n         })\n     }\n \n@@ -171,6 +174,7 @@ pub struct TypeAliasData {\n     pub visibility: RawVisibility,\n     pub is_extern: bool,\n     pub rustc_has_incoherent_inherent_impls: bool,\n+    pub rustc_allow_incoherent_impl: bool,\n     /// Bounds restricting the type alias itself (eg. `type Ty: Bound;` in a trait or impl).\n     pub bounds: Vec<Interned<TypeBound>>,\n }\n@@ -189,17 +193,22 @@ impl TypeAliasData {\n             item_tree[typ.visibility].clone()\n         };\n \n-        let rustc_has_incoherent_inherent_impls = item_tree\n-            .attrs(db, loc.container.module(db).krate(), ModItem::from(loc.id.value).into())\n-            .by_key(\"rustc_has_incoherent_inherent_impls\")\n-            .exists();\n+        let attrs = item_tree.attrs(\n+            db,\n+            loc.container.module(db).krate(),\n+            ModItem::from(loc.id.value).into(),\n+        );\n+        let rustc_has_incoherent_inherent_impls =\n+            attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists();\n+        let rustc_allow_incoherent_impl = attrs.by_key(\"rustc_allow_incoherent_impl\").exists();\n \n         Arc::new(TypeAliasData {\n             name: typ.name.clone(),\n             type_ref: typ.type_ref.clone(),\n             visibility,\n             is_extern: matches!(loc.container, ItemContainerId::ExternBlockId(_)),\n             rustc_has_incoherent_inherent_impls,\n+            rustc_allow_incoherent_impl,\n             bounds: typ.bounds.to_vec(),\n         })\n     }\n@@ -212,11 +221,12 @@ pub struct TraitData {\n     pub is_auto: bool,\n     pub is_unsafe: bool,\n     pub rustc_has_incoherent_inherent_impls: bool,\n+    pub skip_array_during_method_dispatch: bool,\n+    pub fundamental: bool,\n     pub visibility: RawVisibility,\n     /// Whether the trait has `#[rust_skip_array_during_method_dispatch]`. `hir_ty` will ignore\n     /// method calls to this trait's methods when the receiver is an array and the crate edition is\n     /// 2015 or 2018.\n-    pub skip_array_during_method_dispatch: bool,\n     // box it as the vec is usually empty anyways\n     pub attribute_calls: Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>>,\n }\n@@ -245,6 +255,7 @@ impl TraitData {\n             attrs.by_key(\"rustc_skip_array_during_method_dispatch\").exists();\n         let rustc_has_incoherent_inherent_impls =\n             attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists();\n+        let fundamental = attrs.by_key(\"fundamental\").exists();\n         let mut collector =\n             AssocItemCollector::new(db, module_id, tree_id.file_id(), ItemContainerId::TraitId(tr));\n         collector.collect(&item_tree, tree_id.tree_id(), &tr_def.items);\n@@ -260,6 +271,7 @@ impl TraitData {\n                 visibility,\n                 skip_array_during_method_dispatch,\n                 rustc_has_incoherent_inherent_impls,\n+                fundamental,\n             }),\n             diagnostics.into(),\n         )\n@@ -450,6 +462,7 @@ pub struct ConstData {\n     pub name: Option<Name>,\n     pub type_ref: Interned<TypeRef>,\n     pub visibility: RawVisibility,\n+    pub rustc_allow_incoherent_impl: bool,\n }\n \n impl ConstData {\n@@ -463,10 +476,16 @@ impl ConstData {\n             item_tree[konst.visibility].clone()\n         };\n \n+        let rustc_allow_incoherent_impl = item_tree\n+            .attrs(db, loc.container.module(db).krate(), ModItem::from(loc.id.value).into())\n+            .by_key(\"rustc_allow_incoherent_impl\")\n+            .exists();\n+\n         Arc::new(ConstData {\n             name: konst.name.clone(),\n             type_ref: konst.type_ref.clone(),\n             visibility,\n+            rustc_allow_incoherent_impl,\n         })\n     }\n }"}, {"sha": "9371fc14dd8a0d3bd27e355c69cf69dd2a66066f", "filename": "src/tools/rust-analyzer/crates/hir-def/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdb.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -3,7 +3,7 @@ use std::sync::Arc;\n \n use base_db::{salsa, CrateId, SourceDatabase, Upcast};\n use either::Either;\n-use hir_expand::{db::AstDatabase, HirFileId};\n+use hir_expand::{db::ExpandDatabase, HirFileId};\n use intern::Interned;\n use la_arena::ArenaMap;\n use syntax::{ast, AstPtr};\n@@ -64,7 +64,7 @@ pub trait InternDatabase: SourceDatabase {\n }\n \n #[salsa::query_group(DefDatabaseStorage)]\n-pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n+pub trait DefDatabase: InternDatabase + ExpandDatabase + Upcast<dyn ExpandDatabase> {\n     #[salsa::input]\n     fn enable_proc_attr_macros(&self) -> bool;\n "}, {"sha": "19fa6b25419e112cc92987a85d9a1308112b0bfd", "filename": "src/tools/rust-analyzer/crates/hir-def/src/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -245,6 +245,7 @@ pub enum Expr {\n pub enum ClosureKind {\n     Closure,\n     Generator(Movability),\n+    Async,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]"}, {"sha": "314bf22b95ee76428066b412da9574ee5f09a6e4", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -20,7 +20,7 @@ use ::mbe::TokenMap;\n use base_db::{fixture::WithFixture, ProcMacro, SourceDatabase};\n use expect_test::Expect;\n use hir_expand::{\n-    db::{AstDatabase, TokenExpander},\n+    db::{ExpandDatabase, TokenExpander},\n     AstId, InFile, MacroDefId, MacroDefKind, MacroFile,\n };\n use stdx::format_to;"}, {"sha": "4efe8c58a69e3b8f74b81672a6fce169cd699349", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -120,6 +120,8 @@ pub struct DefMap {\n     registered_tools: Vec<SmolStr>,\n     /// Unstable features of Rust enabled with `#![feature(A, B)]`.\n     unstable_features: FxHashSet<SmolStr>,\n+    /// #[rustc_coherence_is_core]\n+    rustc_coherence_is_core: bool,\n \n     edition: Edition,\n     recursion_limit: Option<u32>,\n@@ -215,7 +217,7 @@ pub struct ModuleData {\n     pub origin: ModuleOrigin,\n     /// Declared visibility of this module.\n     pub visibility: Visibility,\n-\n+    /// Always [`None`] for block modules\n     pub parent: Option<LocalModuleId>,\n     pub children: FxHashMap<Name, LocalModuleId>,\n     pub scope: ItemScope,\n@@ -292,6 +294,7 @@ impl DefMap {\n             registered_tools: Vec::new(),\n             unstable_features: FxHashSet::default(),\n             diagnostics: Vec::new(),\n+            rustc_coherence_is_core: false,\n         }\n     }\n \n@@ -325,6 +328,10 @@ impl DefMap {\n         self.unstable_features.contains(feature)\n     }\n \n+    pub fn is_rustc_coherence_is_core(&self) -> bool {\n+        self.rustc_coherence_is_core\n+    }\n+\n     pub fn root(&self) -> LocalModuleId {\n         self.root\n     }\n@@ -337,7 +344,7 @@ impl DefMap {\n         self.proc_macro_loading_error.as_deref()\n     }\n \n-    pub(crate) fn krate(&self) -> CrateId {\n+    pub fn krate(&self) -> CrateId {\n         self.krate\n     }\n \n@@ -425,7 +432,7 @@ impl DefMap {\n         Some(self.block?.parent)\n     }\n \n-    /// Returns the module containing `local_mod`, either the parent `mod`, or the module containing\n+    /// Returns the module containing `local_mod`, either the parent `mod`, or the module (or block) containing\n     /// the block, if `self` corresponds to a block expression.\n     pub fn containing_module(&self, local_mod: LocalModuleId) -> Option<ModuleId> {\n         match self[local_mod].parent {\n@@ -498,6 +505,7 @@ impl DefMap {\n             krate: _,\n             prelude: _,\n             root: _,\n+            rustc_coherence_is_core: _,\n         } = self;\n \n         extern_prelude.shrink_to_fit();"}, {"sha": "ddcee77ec4ccfa3327c4d56cf024243878df7b41", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -87,10 +87,7 @@ pub(super) fn collect_defs(db: &dyn DefDatabase, mut def_map: DefMap, tree_id: T\n                     // FIXME: a hacky way to create a Name from string.\n                     let name =\n                         tt::Ident { text: it.name.clone(), span: tt::TokenId::unspecified() };\n-                    (\n-                        name.as_name(),\n-                        ProcMacroExpander::new(def_map.krate, base_db::ProcMacroId(idx as u32)),\n-                    )\n+                    (name.as_name(), ProcMacroExpander::new(base_db::ProcMacroId(idx as u32)))\n                 })\n                 .collect()\n         }\n@@ -299,6 +296,11 @@ impl DefCollector<'_> {\n                     continue;\n                 }\n \n+                if attr_name.as_text().as_deref() == Some(\"rustc_coherence_is_core\") {\n+                    self.def_map.rustc_coherence_is_core = true;\n+                    continue;\n+                }\n+\n                 if *attr_name == hir_expand::name![feature] {\n                     let features =\n                         attr.parse_path_comma_token_tree().into_iter().flatten().filter_map(\n@@ -581,7 +583,7 @@ impl DefCollector<'_> {\n         let kind = def.kind.to_basedb_kind();\n         let (expander, kind) = match self.proc_macros.iter().find(|(n, _)| n == &def.name) {\n             Some(&(_, expander)) => (expander, kind),\n-            None => (ProcMacroExpander::dummy(self.def_map.krate), kind),\n+            None => (ProcMacroExpander::dummy(), kind),\n         };\n \n         let proc_macro_id ="}, {"sha": "ee143b19ae5b38e7bbd32712a79590ac5e775205", "filename": "src/tools/rust-analyzer/crates/hir-def/src/test_db.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftest_db.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -9,7 +9,7 @@ use base_db::{\n     salsa, AnchoredPath, CrateId, FileId, FileLoader, FileLoaderDelegate, FilePosition,\n     SourceDatabase, Upcast,\n };\n-use hir_expand::{db::AstDatabase, InFile};\n+use hir_expand::{db::ExpandDatabase, InFile};\n use stdx::hash::NoHashHashSet;\n use syntax::{algo, ast, AstNode};\n \n@@ -23,7 +23,7 @@ use crate::{\n #[salsa::database(\n     base_db::SourceDatabaseExtStorage,\n     base_db::SourceDatabaseStorage,\n-    hir_expand::db::AstDatabaseStorage,\n+    hir_expand::db::ExpandDatabaseStorage,\n     crate::db::InternDatabaseStorage,\n     crate::db::DefDatabaseStorage\n )]\n@@ -40,8 +40,8 @@ impl Default for TestDB {\n     }\n }\n \n-impl Upcast<dyn AstDatabase> for TestDB {\n-    fn upcast(&self) -> &(dyn AstDatabase + 'static) {\n+impl Upcast<dyn ExpandDatabase> for TestDB {\n+    fn upcast(&self) -> &(dyn ExpandDatabase + 'static) {\n         &*self\n     }\n }"}, {"sha": "ab76ed43d3a0e558a86e3eea66e4d5f83231ca0a", "filename": "src/tools/rust-analyzer/crates/hir-def/src/visibility.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fvisibility.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -131,21 +131,23 @@ impl Visibility {\n         // visibility as the containing module (even though no items are directly nameable from\n         // there, getting this right is important for method resolution).\n         // In that case, we adjust the visibility of `to_module` to point to the containing module.\n+\n         // Additional complication: `to_module` might be in `from_module`'s `DefMap`, which we're\n         // currently computing, so we must not call the `def_map` query for it.\n-        let arc;\n-        let to_module_def_map =\n-            if to_module.krate == def_map.krate() && to_module.block == def_map.block_id() {\n-                cov_mark::hit!(is_visible_from_same_block_def_map);\n-                def_map\n-            } else {\n-                arc = to_module.def_map(db);\n-                &arc\n-            };\n-        let is_block_root =\n-            to_module.block.is_some() && to_module_def_map[to_module.local_id].parent.is_none();\n-        if is_block_root {\n-            to_module = to_module_def_map.containing_module(to_module.local_id).unwrap();\n+        let mut arc;\n+        loop {\n+            let to_module_def_map =\n+                if to_module.krate == def_map.krate() && to_module.block == def_map.block_id() {\n+                    cov_mark::hit!(is_visible_from_same_block_def_map);\n+                    def_map\n+                } else {\n+                    arc = to_module.def_map(db);\n+                    &arc\n+                };\n+            match to_module_def_map.parent() {\n+                Some(parent) => to_module = parent,\n+                None => break,\n+            }\n         }\n \n         // from_module needs to be a descendant of to_module"}, {"sha": "8d1e88725ecbf2509abb9b12ffc54f3982da35a0", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/attrs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fattrs.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -10,7 +10,7 @@ use smallvec::{smallvec, SmallVec};\n use syntax::{ast, match_ast, AstNode, SmolStr, SyntaxNode};\n \n use crate::{\n-    db::AstDatabase,\n+    db::ExpandDatabase,\n     hygiene::Hygiene,\n     mod_path::{ModPath, PathKind},\n     name::AsName,\n@@ -38,7 +38,7 @@ impl ops::Deref for RawAttrs {\n impl RawAttrs {\n     pub const EMPTY: Self = Self { entries: None };\n \n-    pub fn new(db: &dyn AstDatabase, owner: &dyn ast::HasAttrs, hygiene: &Hygiene) -> Self {\n+    pub fn new(db: &dyn ExpandDatabase, owner: &dyn ast::HasAttrs, hygiene: &Hygiene) -> Self {\n         let entries = collect_attrs(owner)\n             .filter_map(|(id, attr)| match attr {\n                 Either::Left(attr) => {\n@@ -55,7 +55,7 @@ impl RawAttrs {\n         Self { entries: if entries.is_empty() { None } else { Some(entries) } }\n     }\n \n-    pub fn from_attrs_owner(db: &dyn AstDatabase, owner: InFile<&dyn ast::HasAttrs>) -> Self {\n+    pub fn from_attrs_owner(db: &dyn ExpandDatabase, owner: InFile<&dyn ast::HasAttrs>) -> Self {\n         let hygiene = Hygiene::new(db, owner.file_id);\n         Self::new(db, owner.value, &hygiene)\n     }\n@@ -87,7 +87,7 @@ impl RawAttrs {\n \n     /// Processes `cfg_attr`s, returning the resulting semantic `Attrs`.\n     // FIXME: This should return a different type\n-    pub fn filter(self, db: &dyn AstDatabase, krate: CrateId) -> RawAttrs {\n+    pub fn filter(self, db: &dyn ExpandDatabase, krate: CrateId) -> RawAttrs {\n         let has_cfg_attrs = self\n             .iter()\n             .any(|attr| attr.path.as_ident().map_or(false, |name| *name == crate::name![cfg_attr]));\n@@ -199,7 +199,7 @@ impl fmt::Display for AttrInput {\n \n impl Attr {\n     fn from_src(\n-        db: &dyn AstDatabase,\n+        db: &dyn ExpandDatabase,\n         ast: ast::Meta,\n         hygiene: &Hygiene,\n         id: AttrId,\n@@ -221,7 +221,7 @@ impl Attr {\n     }\n \n     fn from_tt(\n-        db: &dyn AstDatabase,\n+        db: &dyn ExpandDatabase,\n         tt: &tt::Subtree,\n         hygiene: &Hygiene,\n         id: AttrId,"}, {"sha": "277ecd93994225ba4ffa3ed5e26cf718ca0cd334", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_attr_macro.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,6 +1,6 @@\n //! Builtin attributes.\n \n-use crate::{db::AstDatabase, name, tt, ExpandResult, MacroCallId, MacroCallKind};\n+use crate::{db::ExpandDatabase, name, tt, ExpandResult, MacroCallId, MacroCallKind};\n \n macro_rules! register_builtin {\n     ( $(($name:ident, $variant:ident) => $expand:ident),* ) => {\n@@ -12,7 +12,7 @@ macro_rules! register_builtin {\n         impl BuiltinAttrExpander {\n             pub fn expand(\n                 &self,\n-                db: &dyn AstDatabase,\n+                db: &dyn ExpandDatabase,\n                 id: MacroCallId,\n                 tt: &tt::Subtree,\n             ) -> ExpandResult<tt::Subtree> {\n@@ -60,7 +60,7 @@ pub fn find_builtin_attr(ident: &name::Name) -> Option<BuiltinAttrExpander> {\n }\n \n fn dummy_attr_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -90,7 +90,7 @@ fn dummy_attr_expand(\n /// So this hacky approach is a lot more friendly for us, though it does require a bit of support in\n /// [`hir::Semantics`] to make this work.\n fn derive_attr_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {"}, {"sha": "5c1a75132ee94f19bd42e4c144003969d8fbb10e", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_derive_macro.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -9,7 +9,7 @@ use syntax::{\n     match_ast,\n };\n \n-use crate::{db::AstDatabase, name, quote, ExpandError, ExpandResult, MacroCallId};\n+use crate::{db::ExpandDatabase, name, quote, ExpandError, ExpandResult, MacroCallId};\n \n macro_rules! register_builtin {\n     ( $($trait:ident => $expand:ident),* ) => {\n@@ -21,7 +21,7 @@ macro_rules! register_builtin {\n         impl BuiltinDeriveExpander {\n             pub fn expand(\n                 &self,\n-                db: &dyn AstDatabase,\n+                db: &dyn ExpandDatabase,\n                 id: MacroCallId,\n                 tt: &tt::Subtree,\n             ) -> ExpandResult<tt::Subtree> {\n@@ -141,7 +141,7 @@ fn expand_simple_derive(tt: &tt::Subtree, trait_path: tt::Subtree) -> ExpandResu\n     ExpandResult::ok(expanded)\n }\n \n-fn find_builtin_crate(db: &dyn AstDatabase, id: MacroCallId) -> tt::TokenTree {\n+fn find_builtin_crate(db: &dyn ExpandDatabase, id: MacroCallId) -> tt::TokenTree {\n     // FIXME: make hygiene works for builtin derive macro\n     // such that $crate can be used here.\n     let cg = db.crate_graph();\n@@ -158,7 +158,7 @@ fn find_builtin_crate(db: &dyn AstDatabase, id: MacroCallId) -> tt::TokenTree {\n }\n \n fn copy_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -167,7 +167,7 @@ fn copy_expand(\n }\n \n fn clone_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -176,7 +176,7 @@ fn clone_expand(\n }\n \n fn default_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -185,7 +185,7 @@ fn default_expand(\n }\n \n fn debug_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -194,21 +194,25 @@ fn debug_expand(\n }\n \n fn hash_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     let krate = find_builtin_crate(db, id);\n     expand_simple_derive(tt, quote! { #krate::hash::Hash })\n }\n \n-fn eq_expand(db: &dyn AstDatabase, id: MacroCallId, tt: &tt::Subtree) -> ExpandResult<tt::Subtree> {\n+fn eq_expand(\n+    db: &dyn ExpandDatabase,\n+    id: MacroCallId,\n+    tt: &tt::Subtree,\n+) -> ExpandResult<tt::Subtree> {\n     let krate = find_builtin_crate(db, id);\n     expand_simple_derive(tt, quote! { #krate::cmp::Eq })\n }\n \n fn partial_eq_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -217,7 +221,7 @@ fn partial_eq_expand(\n }\n \n fn ord_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -226,7 +230,7 @@ fn ord_expand(\n }\n \n fn partial_ord_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {"}, {"sha": "44510f2b7ff680c765d73055d2ecf470b9deefb4", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_fn_macro.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -10,7 +10,7 @@ use syntax::{\n };\n \n use crate::{\n-    db::AstDatabase, name, quote, tt, ExpandError, ExpandResult, MacroCallId, MacroCallLoc,\n+    db::ExpandDatabase, name, quote, tt, ExpandError, ExpandResult, MacroCallId, MacroCallLoc,\n };\n \n macro_rules! register_builtin {\n@@ -28,7 +28,7 @@ macro_rules! register_builtin {\n         impl BuiltinFnLikeExpander {\n             pub fn expand(\n                 &self,\n-                db: &dyn AstDatabase,\n+                db: &dyn ExpandDatabase,\n                 id: MacroCallId,\n                 tt: &tt::Subtree,\n             ) -> ExpandResult<tt::Subtree> {\n@@ -42,7 +42,7 @@ macro_rules! register_builtin {\n         impl EagerExpander {\n             pub fn expand(\n                 &self,\n-                db: &dyn AstDatabase,\n+                db: &dyn ExpandDatabase,\n                 arg_id: MacroCallId,\n                 tt: &tt::Subtree,\n             ) -> ExpandResult<ExpandedEager> {\n@@ -121,7 +121,7 @@ const DOLLAR_CRATE: tt::Ident =\n     tt::Ident { text: SmolStr::new_inline(\"$crate\"), span: tt::TokenId::unspecified() };\n \n fn module_path_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -130,7 +130,7 @@ fn module_path_expand(\n }\n \n fn line_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -144,23 +144,23 @@ fn line_expand(\n }\n \n fn log_syntax_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     ExpandResult::ok(quote! {})\n }\n \n fn trace_macros_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n     ExpandResult::ok(quote! {})\n }\n \n fn stringify_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -174,7 +174,7 @@ fn stringify_expand(\n }\n \n fn column_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -188,7 +188,7 @@ fn column_expand(\n }\n \n fn assert_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -218,7 +218,7 @@ fn assert_expand(\n }\n \n fn file_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -234,7 +234,7 @@ fn file_expand(\n }\n \n fn format_args_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -276,7 +276,7 @@ fn format_args_expand(\n }\n \n fn asm_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -304,7 +304,7 @@ fn asm_expand(\n }\n \n fn global_asm_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     _tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -313,7 +313,7 @@ fn global_asm_expand(\n }\n \n fn cfg_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -325,7 +325,7 @@ fn cfg_expand(\n }\n \n fn panic_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -343,7 +343,7 @@ fn panic_expand(\n }\n \n fn unreachable_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n@@ -379,7 +379,7 @@ fn unquote_byte_string(lit: &tt::Literal) -> Option<Vec<u8>> {\n }\n \n fn compile_error_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {\n@@ -395,7 +395,7 @@ fn compile_error_expand(\n }\n \n fn concat_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {\n@@ -441,7 +441,7 @@ fn concat_expand(\n }\n \n fn concat_bytes_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {\n@@ -507,7 +507,7 @@ fn concat_bytes_expand_subtree(\n }\n \n fn concat_idents_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {\n@@ -529,7 +529,7 @@ fn concat_idents_expand(\n }\n \n fn relative_file(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     call_id: MacroCallId,\n     path_str: &str,\n     allow_recursion: bool,\n@@ -558,7 +558,7 @@ fn parse_string(tt: &tt::Subtree) -> Result<String, ExpandError> {\n }\n \n fn include_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {\n@@ -583,7 +583,7 @@ fn include_expand(\n }\n \n fn include_bytes_expand(\n-    _db: &dyn AstDatabase,\n+    _db: &dyn ExpandDatabase,\n     _arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {\n@@ -606,7 +606,7 @@ fn include_bytes_expand(\n }\n \n fn include_str_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {\n@@ -637,13 +637,13 @@ fn include_str_expand(\n     ExpandResult::ok(ExpandedEager::new(quote!(#text)))\n }\n \n-fn get_env_inner(db: &dyn AstDatabase, arg_id: MacroCallId, key: &str) -> Option<String> {\n+fn get_env_inner(db: &dyn ExpandDatabase, arg_id: MacroCallId, key: &str) -> Option<String> {\n     let krate = db.lookup_intern_macro_call(arg_id).krate;\n     db.crate_graph()[krate].env.get(key)\n }\n \n fn env_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {\n@@ -679,7 +679,7 @@ fn env_expand(\n }\n \n fn option_env_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     arg_id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<ExpandedEager> {"}, {"sha": "45572499e84264cdf8ed44c4431e1c655ec0db43", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/db.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fdb.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -44,7 +44,7 @@ pub enum TokenExpander {\n impl TokenExpander {\n     fn expand(\n         &self,\n-        db: &dyn AstDatabase,\n+        db: &dyn ExpandDatabase,\n         id: MacroCallId,\n         tt: &tt::Subtree,\n     ) -> ExpandResult<tt::Subtree> {\n@@ -83,9 +83,8 @@ impl TokenExpander {\n     }\n }\n \n-// FIXME: rename to ExpandDatabase\n-#[salsa::query_group(AstDatabaseStorage)]\n-pub trait AstDatabase: SourceDatabase {\n+#[salsa::query_group(ExpandDatabaseStorage)]\n+pub trait ExpandDatabase: SourceDatabase {\n     fn ast_id_map(&self, file_id: HirFileId) -> Arc<AstIdMap>;\n \n     /// Main public API -- parses a hir file, not caring whether it's a real\n@@ -138,7 +137,7 @@ pub trait AstDatabase: SourceDatabase {\n /// token. The `token_to_map` mapped down into the expansion, with the mapped\n /// token returned.\n pub fn expand_speculative(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     actual_macro_call: MacroCallId,\n     speculative_args: &SyntaxNode,\n     token_to_map: SyntaxToken,\n@@ -211,7 +210,7 @@ pub fn expand_speculative(\n     let mut speculative_expansion = match loc.def.kind {\n         MacroDefKind::ProcMacro(expander, ..) => {\n             tt.delimiter = tt::Delimiter::unspecified();\n-            expander.expand(db, loc.krate, &tt, attr_arg.as_ref())\n+            expander.expand(db, loc.def.krate, loc.krate, &tt, attr_arg.as_ref())\n         }\n         MacroDefKind::BuiltInAttr(BuiltinAttrExpander::Derive, _) => {\n             pseudo_derive_attr_expansion(&tt, attr_arg.as_ref()?)\n@@ -236,12 +235,12 @@ pub fn expand_speculative(\n     Some((node.syntax_node(), token))\n }\n \n-fn ast_id_map(db: &dyn AstDatabase, file_id: HirFileId) -> Arc<AstIdMap> {\n+fn ast_id_map(db: &dyn ExpandDatabase, file_id: HirFileId) -> Arc<AstIdMap> {\n     let map = db.parse_or_expand(file_id).map(|it| AstIdMap::from_source(&it)).unwrap_or_default();\n     Arc::new(map)\n }\n \n-fn parse_or_expand(db: &dyn AstDatabase, file_id: HirFileId) -> Option<SyntaxNode> {\n+fn parse_or_expand(db: &dyn ExpandDatabase, file_id: HirFileId) -> Option<SyntaxNode> {\n     match file_id.repr() {\n         HirFileIdRepr::FileId(file_id) => Some(db.parse(file_id).tree().syntax().clone()),\n         HirFileIdRepr::MacroFile(macro_file) => {\n@@ -253,13 +252,13 @@ fn parse_or_expand(db: &dyn AstDatabase, file_id: HirFileId) -> Option<SyntaxNod\n }\n \n fn parse_macro_expansion(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     macro_file: MacroFile,\n ) -> ExpandResult<Option<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)>> {\n     let _p = profile::span(\"parse_macro_expansion\");\n-    let result = db.macro_expand(macro_file.macro_call_id);\n+    let mbe::ValueResult { value, err } = db.macro_expand(macro_file.macro_call_id);\n \n-    if let Some(err) = &result.err {\n+    if let Some(err) = &err {\n         // Note:\n         // The final goal we would like to make all parse_macro success,\n         // such that the following log will not call anyway.\n@@ -280,9 +279,9 @@ fn parse_macro_expansion(\n             parents\n         );\n     }\n-    let tt = match result.value {\n+    let tt = match value {\n         Some(tt) => tt,\n-        None => return ExpandResult { value: None, err: result.err },\n+        None => return ExpandResult { value: None, err },\n     };\n \n     let expand_to = macro_expand_to(db, macro_file.macro_call_id);\n@@ -292,11 +291,11 @@ fn parse_macro_expansion(\n \n     let (parse, rev_token_map) = token_tree_to_syntax_node(&tt, expand_to);\n \n-    ExpandResult { value: Some((parse, Arc::new(rev_token_map))), err: result.err }\n+    ExpandResult { value: Some((parse, Arc::new(rev_token_map))), err }\n }\n \n fn macro_arg(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     id: MacroCallId,\n ) -> Option<Arc<(tt::Subtree, mbe::TokenMap, fixup::SyntaxFixupUndoInfo)>> {\n     let arg = db.macro_arg_text(id)?;\n@@ -357,7 +356,7 @@ fn censor_for_macro_input(loc: &MacroCallLoc, node: &SyntaxNode) -> FxHashSet<Sy\n     .unwrap_or_default()\n }\n \n-fn macro_arg_text(db: &dyn AstDatabase, id: MacroCallId) -> Option<GreenNode> {\n+fn macro_arg_text(db: &dyn ExpandDatabase, id: MacroCallId) -> Option<GreenNode> {\n     let loc = db.lookup_intern_macro_call(id);\n     let arg = loc.kind.arg(db)?;\n     if matches!(loc.kind, MacroCallKind::FnLike { .. }) {\n@@ -380,7 +379,10 @@ fn macro_arg_text(db: &dyn AstDatabase, id: MacroCallId) -> Option<GreenNode> {\n     Some(arg.green().into())\n }\n \n-fn macro_def(db: &dyn AstDatabase, id: MacroDefId) -> Result<Arc<TokenExpander>, mbe::ParseError> {\n+fn macro_def(\n+    db: &dyn ExpandDatabase,\n+    id: MacroDefId,\n+) -> Result<Arc<TokenExpander>, mbe::ParseError> {\n     match id.kind {\n         MacroDefKind::Declarative(ast_id) => {\n             let (mac, def_site_token_map) = match ast_id.to_node(db) {\n@@ -419,7 +421,10 @@ fn macro_def(db: &dyn AstDatabase, id: MacroDefId) -> Result<Arc<TokenExpander>,\n     }\n }\n \n-fn macro_expand(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<Option<Arc<tt::Subtree>>> {\n+fn macro_expand(\n+    db: &dyn ExpandDatabase,\n+    id: MacroCallId,\n+) -> ExpandResult<Option<Arc<tt::Subtree>>> {\n     let _p = profile::span(\"macro_expand\");\n     let loc: MacroCallLoc = db.lookup_intern_macro_call(id);\n     if let Some(eager) = &loc.eager {\n@@ -469,11 +474,11 @@ fn macro_expand(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<Option<Ar\n     ExpandResult { value: Some(Arc::new(tt)), err }\n }\n \n-fn macro_expand_error(db: &dyn AstDatabase, macro_call: MacroCallId) -> Option<ExpandError> {\n+fn macro_expand_error(db: &dyn ExpandDatabase, macro_call: MacroCallId) -> Option<ExpandError> {\n     db.macro_expand(macro_call).err\n }\n \n-fn expand_proc_macro(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<tt::Subtree> {\n+fn expand_proc_macro(db: &dyn ExpandDatabase, id: MacroCallId) -> ExpandResult<tt::Subtree> {\n     let loc: MacroCallLoc = db.lookup_intern_macro_call(id);\n     let macro_arg = match db.macro_arg(id) {\n         Some(it) => it,\n@@ -499,14 +504,14 @@ fn expand_proc_macro(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<tt::\n         _ => None,\n     };\n \n-    expander.expand(db, loc.krate, &macro_arg.0, attr_arg.as_ref())\n+    expander.expand(db, loc.def.krate, loc.krate, &macro_arg.0, attr_arg.as_ref())\n }\n \n-fn hygiene_frame(db: &dyn AstDatabase, file_id: HirFileId) -> Arc<HygieneFrame> {\n+fn hygiene_frame(db: &dyn ExpandDatabase, file_id: HirFileId) -> Arc<HygieneFrame> {\n     Arc::new(HygieneFrame::new(db, file_id))\n }\n \n-fn macro_expand_to(db: &dyn AstDatabase, id: MacroCallId) -> ExpandTo {\n+fn macro_expand_to(db: &dyn ExpandDatabase, id: MacroCallId) -> ExpandTo {\n     let loc: MacroCallLoc = db.lookup_intern_macro_call(id);\n     loc.kind.expand_to()\n }"}, {"sha": "aca41b11f926eb3e6152ad95a1edf4bb36d2a779", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/eager.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Feager.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -25,7 +25,7 @@ use syntax::{ted, SyntaxNode};\n \n use crate::{\n     ast::{self, AstNode},\n-    db::AstDatabase,\n+    db::ExpandDatabase,\n     hygiene::Hygiene,\n     mod_path::ModPath,\n     EagerCallInfo, ExpandError, ExpandResult, ExpandTo, InFile, MacroCallId, MacroCallKind,\n@@ -96,7 +96,7 @@ impl ErrorSink for &'_ mut dyn FnMut(ExpandError) {\n }\n \n pub fn expand_eager_macro(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     krate: CrateId,\n     macro_call: InFile<ast::MacroCall>,\n     def: MacroDefId,\n@@ -172,7 +172,7 @@ fn to_subtree(node: &SyntaxNode) -> crate::tt::Subtree {\n }\n \n fn lazy_expand(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     def: &MacroDefId,\n     macro_call: InFile<ast::MacroCall>,\n     krate: CrateId,\n@@ -193,7 +193,7 @@ fn lazy_expand(\n }\n \n fn eager_macro_recur(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     hygiene: &Hygiene,\n     curr: InFile<SyntaxNode>,\n     krate: CrateId,"}, {"sha": "b273f21768c686772c70d11ba6b67c43cb1bd67a", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/fixup.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -636,9 +636,8 @@ fn foo() {\n     if {}\n }\n \"#,\n-            // the {} gets parsed as the condition, I think?\n             expect![[r#\"\n-fn foo () {if {} {}}\n+fn foo () {if __ra_fixup {} {}}\n \"#]],\n         )\n     }"}, {"sha": "2eb56fc9e8b266124fc4b244faa91fe492597ffb", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/hygiene.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fhygiene.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -14,7 +14,7 @@ use syntax::{\n };\n \n use crate::{\n-    db::{self, AstDatabase},\n+    db::{self, ExpandDatabase},\n     fixup,\n     name::{AsName, Name},\n     HirFileId, InFile, MacroCallKind, MacroCallLoc, MacroDefKind, MacroFile,\n@@ -26,7 +26,7 @@ pub struct Hygiene {\n }\n \n impl Hygiene {\n-    pub fn new(db: &dyn AstDatabase, file_id: HirFileId) -> Hygiene {\n+    pub fn new(db: &dyn ExpandDatabase, file_id: HirFileId) -> Hygiene {\n         Hygiene { frames: Some(HygieneFrames::new(db, file_id)) }\n     }\n \n@@ -37,7 +37,7 @@ impl Hygiene {\n     // FIXME: this should just return name\n     pub fn name_ref_to_name(\n         &self,\n-        db: &dyn AstDatabase,\n+        db: &dyn ExpandDatabase,\n         name_ref: ast::NameRef,\n     ) -> Either<Name, CrateId> {\n         if let Some(frames) = &self.frames {\n@@ -51,7 +51,7 @@ impl Hygiene {\n         Either::Left(name_ref.as_name())\n     }\n \n-    pub fn local_inner_macros(&self, db: &dyn AstDatabase, path: ast::Path) -> Option<CrateId> {\n+    pub fn local_inner_macros(&self, db: &dyn ExpandDatabase, path: ast::Path) -> Option<CrateId> {\n         let mut token = path.syntax().first_token()?.text_range();\n         let frames = self.frames.as_ref()?;\n         let mut current = &frames.0;\n@@ -87,13 +87,13 @@ pub struct HygieneFrame {\n }\n \n impl HygieneFrames {\n-    fn new(db: &dyn AstDatabase, file_id: HirFileId) -> Self {\n+    fn new(db: &dyn ExpandDatabase, file_id: HirFileId) -> Self {\n         // Note that this intentionally avoids the `hygiene_frame` query to avoid blowing up memory\n         // usage. The query is only helpful for nested `HygieneFrame`s as it avoids redundant work.\n         HygieneFrames(Arc::new(HygieneFrame::new(db, file_id)))\n     }\n \n-    fn root_crate(&self, db: &dyn AstDatabase, node: &SyntaxNode) -> Option<CrateId> {\n+    fn root_crate(&self, db: &dyn ExpandDatabase, node: &SyntaxNode) -> Option<CrateId> {\n         let mut token = node.first_token()?.text_range();\n         let mut result = self.0.krate;\n         let mut current = self.0.clone();\n@@ -136,7 +136,7 @@ struct HygieneInfo {\n impl HygieneInfo {\n     fn map_ident_up(\n         &self,\n-        db: &dyn AstDatabase,\n+        db: &dyn ExpandDatabase,\n         token: TextRange,\n     ) -> Option<(InFile<TextRange>, Origin)> {\n         let token_id = self.exp_map.token_by_range(token)?;\n@@ -175,7 +175,7 @@ impl HygieneInfo {\n }\n \n fn make_hygiene_info(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     macro_file: MacroFile,\n     loc: &MacroCallLoc,\n ) -> Option<HygieneInfo> {\n@@ -215,7 +215,7 @@ fn make_hygiene_info(\n }\n \n impl HygieneFrame {\n-    pub(crate) fn new(db: &dyn AstDatabase, file_id: HirFileId) -> HygieneFrame {\n+    pub(crate) fn new(db: &dyn ExpandDatabase, file_id: HirFileId) -> HygieneFrame {\n         let (info, krate, local_inner) = match file_id.macro_file() {\n             None => (None, None, false),\n             Some(macro_file) => {"}, {"sha": "5e99eacc1b619696d59aa11ecb7f356338cae4a5", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/lib.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -198,7 +198,7 @@ impl HirFileId {\n \n     /// For macro-expansion files, returns the file original source file the\n     /// expansion originated from.\n-    pub fn original_file(self, db: &dyn db::AstDatabase) -> FileId {\n+    pub fn original_file(self, db: &dyn db::ExpandDatabase) -> FileId {\n         let mut file_id = self;\n         loop {\n             match file_id.repr() {\n@@ -214,7 +214,7 @@ impl HirFileId {\n         }\n     }\n \n-    pub fn expansion_level(self, db: &dyn db::AstDatabase) -> u32 {\n+    pub fn expansion_level(self, db: &dyn db::ExpandDatabase) -> u32 {\n         let mut level = 0;\n         let mut curr = self;\n         while let Some(macro_file) = curr.macro_file() {\n@@ -227,14 +227,14 @@ impl HirFileId {\n     }\n \n     /// If this is a macro call, returns the syntax node of the call.\n-    pub fn call_node(self, db: &dyn db::AstDatabase) -> Option<InFile<SyntaxNode>> {\n+    pub fn call_node(self, db: &dyn db::ExpandDatabase) -> Option<InFile<SyntaxNode>> {\n         let macro_file = self.macro_file()?;\n         let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n         Some(loc.kind.to_node(db))\n     }\n \n     /// If this is a macro call, returns the syntax node of the very first macro call this file resides in.\n-    pub fn original_call_node(self, db: &dyn db::AstDatabase) -> Option<(FileId, SyntaxNode)> {\n+    pub fn original_call_node(self, db: &dyn db::ExpandDatabase) -> Option<(FileId, SyntaxNode)> {\n         let mut call =\n             db.lookup_intern_macro_call(self.macro_file()?.macro_call_id).kind.to_node(db);\n         loop {\n@@ -248,7 +248,7 @@ impl HirFileId {\n     }\n \n     /// Return expansion information if it is a macro-expansion file\n-    pub fn expansion_info(self, db: &dyn db::AstDatabase) -> Option<ExpansionInfo> {\n+    pub fn expansion_info(self, db: &dyn db::ExpandDatabase) -> Option<ExpansionInfo> {\n         let macro_file = self.macro_file()?;\n         let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n \n@@ -294,7 +294,7 @@ impl HirFileId {\n     }\n \n     /// Indicate it is macro file generated for builtin derive\n-    pub fn is_builtin_derive(&self, db: &dyn db::AstDatabase) -> Option<InFile<ast::Attr>> {\n+    pub fn is_builtin_derive(&self, db: &dyn db::ExpandDatabase) -> Option<InFile<ast::Attr>> {\n         let macro_file = self.macro_file()?;\n         let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n         let attr = match loc.def.kind {\n@@ -304,7 +304,7 @@ impl HirFileId {\n         Some(attr.with_value(ast::Attr::cast(attr.value.clone())?))\n     }\n \n-    pub fn is_custom_derive(&self, db: &dyn db::AstDatabase) -> bool {\n+    pub fn is_custom_derive(&self, db: &dyn db::ExpandDatabase) -> bool {\n         match self.macro_file() {\n             Some(macro_file) => {\n                 let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n@@ -315,7 +315,7 @@ impl HirFileId {\n     }\n \n     /// Return whether this file is an include macro\n-    pub fn is_include_macro(&self, db: &dyn db::AstDatabase) -> bool {\n+    pub fn is_include_macro(&self, db: &dyn db::ExpandDatabase) -> bool {\n         match self.macro_file() {\n             Some(macro_file) => {\n                 let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n@@ -326,7 +326,7 @@ impl HirFileId {\n     }\n \n     /// Return whether this file is an attr macro\n-    pub fn is_attr_macro(&self, db: &dyn db::AstDatabase) -> bool {\n+    pub fn is_attr_macro(&self, db: &dyn db::ExpandDatabase) -> bool {\n         match self.macro_file() {\n             Some(macro_file) => {\n                 let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n@@ -338,7 +338,7 @@ impl HirFileId {\n \n     /// Return whether this file is the pseudo expansion of the derive attribute.\n     /// See [`crate::builtin_attr_macro::derive_attr_expand`].\n-    pub fn is_derive_attr_pseudo_expansion(&self, db: &dyn db::AstDatabase) -> bool {\n+    pub fn is_derive_attr_pseudo_expansion(&self, db: &dyn db::ExpandDatabase) -> bool {\n         match self.macro_file() {\n             Some(macro_file) => {\n                 let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n@@ -384,7 +384,7 @@ impl HirFileId {\n impl MacroDefId {\n     pub fn as_lazy_macro(\n         self,\n-        db: &dyn db::AstDatabase,\n+        db: &dyn db::ExpandDatabase,\n         krate: CrateId,\n         kind: MacroCallKind,\n     ) -> MacroCallId {\n@@ -427,7 +427,7 @@ impl MacroCallKind {\n         }\n     }\n \n-    pub fn to_node(&self, db: &dyn db::AstDatabase) -> InFile<SyntaxNode> {\n+    pub fn to_node(&self, db: &dyn db::ExpandDatabase) -> InFile<SyntaxNode> {\n         match self {\n             MacroCallKind::FnLike { ast_id, .. } => {\n                 ast_id.with_value(ast_id.to_node(db).syntax().clone())\n@@ -465,7 +465,7 @@ impl MacroCallKind {\n     /// Returns the original file range that best describes the location of this macro call.\n     ///\n     /// Unlike `MacroCallKind::original_call_range`, this also spans the item of attributes and derives.\n-    pub fn original_call_range_with_body(self, db: &dyn db::AstDatabase) -> FileRange {\n+    pub fn original_call_range_with_body(self, db: &dyn db::ExpandDatabase) -> FileRange {\n         let mut kind = self;\n         let file_id = loop {\n             match kind.file_id().repr() {\n@@ -490,7 +490,7 @@ impl MacroCallKind {\n     /// Here we try to roughly match what rustc does to improve diagnostics: fn-like macros\n     /// get the whole `ast::MacroCall`, attribute macros get the attribute's range, and derives\n     /// get only the specific derive that is being referred to.\n-    pub fn original_call_range(self, db: &dyn db::AstDatabase) -> FileRange {\n+    pub fn original_call_range(self, db: &dyn db::ExpandDatabase) -> FileRange {\n         let mut kind = self;\n         let file_id = loop {\n             match kind.file_id().repr() {\n@@ -529,7 +529,7 @@ impl MacroCallKind {\n         FileRange { range, file_id }\n     }\n \n-    fn arg(&self, db: &dyn db::AstDatabase) -> Option<SyntaxNode> {\n+    fn arg(&self, db: &dyn db::ExpandDatabase) -> Option<SyntaxNode> {\n         match self {\n             MacroCallKind::FnLike { ast_id, .. } => {\n                 Some(ast_id.to_node(db).token_tree()?.syntax().clone())\n@@ -597,7 +597,7 @@ impl ExpansionInfo {\n     ///     Both of these only have one simple call site input so no special handling is required here.\n     pub fn map_token_down(\n         &self,\n-        db: &dyn db::AstDatabase,\n+        db: &dyn db::ExpandDatabase,\n         item: Option<ast::Item>,\n         token: InFile<&SyntaxToken>,\n     ) -> Option<impl Iterator<Item = InFile<SyntaxToken>> + '_> {\n@@ -666,7 +666,7 @@ impl ExpansionInfo {\n     /// Map a token up out of the expansion it resides in into the arguments of the macro call of the expansion.\n     pub fn map_token_up(\n         &self,\n-        db: &dyn db::AstDatabase,\n+        db: &dyn db::ExpandDatabase,\n         token: InFile<&SyntaxToken>,\n     ) -> Option<(InFile<SyntaxToken>, Origin)> {\n         // Fetch the id through its text range,\n@@ -717,7 +717,7 @@ impl ExpansionInfo {\n pub type AstId<N> = InFile<FileAstId<N>>;\n \n impl<N: AstNode> AstId<N> {\n-    pub fn to_node(&self, db: &dyn db::AstDatabase) -> N {\n+    pub fn to_node(&self, db: &dyn db::ExpandDatabase) -> N {\n         let root = db.parse_or_expand(self.file_id).unwrap();\n         db.ast_id_map(self.file_id).get(self.value).to_node(&root)\n     }\n@@ -753,7 +753,7 @@ impl<T> InFile<T> {\n         self.with_value(&self.value)\n     }\n \n-    pub fn file_syntax(&self, db: &dyn db::AstDatabase) -> SyntaxNode {\n+    pub fn file_syntax(&self, db: &dyn db::ExpandDatabase) -> SyntaxNode {\n         db.parse_or_expand(self.file_id).expect(\"source created from invalid file\")\n     }\n }\n@@ -783,7 +783,7 @@ impl<L, R> InFile<Either<L, R>> {\n impl<'a> InFile<&'a SyntaxNode> {\n     pub fn ancestors_with_macros(\n         self,\n-        db: &dyn db::AstDatabase,\n+        db: &dyn db::ExpandDatabase,\n     ) -> impl Iterator<Item = InFile<SyntaxNode>> + Clone + '_ {\n         iter::successors(Some(self.cloned()), move |node| match node.value.parent() {\n             Some(parent) => Some(node.with_value(parent)),\n@@ -794,7 +794,7 @@ impl<'a> InFile<&'a SyntaxNode> {\n     /// Skips the attributed item that caused the macro invocation we are climbing up\n     pub fn ancestors_with_macros_skip_attr_item(\n         self,\n-        db: &dyn db::AstDatabase,\n+        db: &dyn db::ExpandDatabase,\n     ) -> impl Iterator<Item = InFile<SyntaxNode>> + '_ {\n         let succ = move |node: &InFile<SyntaxNode>| match node.value.parent() {\n             Some(parent) => Some(node.with_value(parent)),\n@@ -816,7 +816,7 @@ impl<'a> InFile<&'a SyntaxNode> {\n     ///\n     /// For attributes and derives, this will point back to the attribute only.\n     /// For the entire item use [`InFile::original_file_range_full`].\n-    pub fn original_file_range(self, db: &dyn db::AstDatabase) -> FileRange {\n+    pub fn original_file_range(self, db: &dyn db::ExpandDatabase) -> FileRange {\n         match self.file_id.repr() {\n             HirFileIdRepr::FileId(file_id) => FileRange { file_id, range: self.value.text_range() },\n             HirFileIdRepr::MacroFile(mac_file) => {\n@@ -831,7 +831,7 @@ impl<'a> InFile<&'a SyntaxNode> {\n     }\n \n     /// Falls back to the macro call range if the node cannot be mapped up fully.\n-    pub fn original_file_range_full(self, db: &dyn db::AstDatabase) -> FileRange {\n+    pub fn original_file_range_full(self, db: &dyn db::ExpandDatabase) -> FileRange {\n         match self.file_id.repr() {\n             HirFileIdRepr::FileId(file_id) => FileRange { file_id, range: self.value.text_range() },\n             HirFileIdRepr::MacroFile(mac_file) => {\n@@ -846,7 +846,7 @@ impl<'a> InFile<&'a SyntaxNode> {\n     }\n \n     /// Attempts to map the syntax node back up its macro calls.\n-    pub fn original_file_range_opt(self, db: &dyn db::AstDatabase) -> Option<FileRange> {\n+    pub fn original_file_range_opt(self, db: &dyn db::ExpandDatabase) -> Option<FileRange> {\n         match ascend_node_border_tokens(db, self) {\n             Some(InFile { file_id, value: (first, last) }) => {\n                 let original_file = file_id.original_file(db);\n@@ -865,7 +865,7 @@ impl<'a> InFile<&'a SyntaxNode> {\n         }\n     }\n \n-    pub fn original_syntax_node(self, db: &dyn db::AstDatabase) -> Option<InFile<SyntaxNode>> {\n+    pub fn original_syntax_node(self, db: &dyn db::ExpandDatabase) -> Option<InFile<SyntaxNode>> {\n         // This kind of upmapping can only be achieved in attribute expanded files,\n         // as we don't have node inputs otherwise and therefore can't find an `N` node in the input\n         if !self.file_id.is_macro() {\n@@ -892,13 +892,13 @@ impl<'a> InFile<&'a SyntaxNode> {\n }\n \n impl InFile<SyntaxToken> {\n-    pub fn upmap(self, db: &dyn db::AstDatabase) -> Option<InFile<SyntaxToken>> {\n+    pub fn upmap(self, db: &dyn db::ExpandDatabase) -> Option<InFile<SyntaxToken>> {\n         let expansion = self.file_id.expansion_info(db)?;\n         expansion.map_token_up(db, self.as_ref()).map(|(it, _)| it)\n     }\n \n     /// Falls back to the macro call range if the node cannot be mapped up fully.\n-    pub fn original_file_range(self, db: &dyn db::AstDatabase) -> FileRange {\n+    pub fn original_file_range(self, db: &dyn db::ExpandDatabase) -> FileRange {\n         match self.file_id.repr() {\n             HirFileIdRepr::FileId(file_id) => FileRange { file_id, range: self.value.text_range() },\n             HirFileIdRepr::MacroFile(mac_file) => {\n@@ -913,7 +913,7 @@ impl InFile<SyntaxToken> {\n     }\n \n     /// Attempts to map the syntax node back up its macro calls.\n-    pub fn original_file_range_opt(self, db: &dyn db::AstDatabase) -> Option<FileRange> {\n+    pub fn original_file_range_opt(self, db: &dyn db::ExpandDatabase) -> Option<FileRange> {\n         match self.file_id.repr() {\n             HirFileIdRepr::FileId(file_id) => {\n                 Some(FileRange { file_id, range: self.value.text_range() })\n@@ -932,7 +932,7 @@ impl InFile<SyntaxToken> {\n \n     pub fn ancestors_with_macros(\n         self,\n-        db: &dyn db::AstDatabase,\n+        db: &dyn db::ExpandDatabase,\n     ) -> impl Iterator<Item = InFile<SyntaxNode>> + '_ {\n         self.value.parent().into_iter().flat_map({\n             let file_id = self.file_id;\n@@ -942,7 +942,7 @@ impl InFile<SyntaxToken> {\n }\n \n fn ascend_node_border_tokens(\n-    db: &dyn db::AstDatabase,\n+    db: &dyn db::ExpandDatabase,\n     InFile { file_id, value: node }: InFile<&SyntaxNode>,\n ) -> Option<InFile<(SyntaxToken, SyntaxToken)>> {\n     let expansion = file_id.expansion_info(db)?;\n@@ -958,7 +958,7 @@ fn ascend_node_border_tokens(\n }\n \n fn ascend_call_token(\n-    db: &dyn db::AstDatabase,\n+    db: &dyn db::ExpandDatabase,\n     expansion: &ExpansionInfo,\n     token: InFile<SyntaxToken>,\n ) -> Option<InFile<SyntaxToken>> {\n@@ -977,7 +977,7 @@ impl<N: AstNode> InFile<N> {\n         self.value.syntax().descendants().filter_map(T::cast).map(move |n| self.with_value(n))\n     }\n \n-    pub fn original_ast_node(self, db: &dyn db::AstDatabase) -> Option<InFile<N>> {\n+    pub fn original_ast_node(self, db: &dyn db::ExpandDatabase) -> Option<InFile<N>> {\n         // This kind of upmapping can only be achieved in attribute expanded files,\n         // as we don't have node inputs otherwise and therefore can't find an `N` node in the input\n         if !self.file_id.is_macro() {"}, {"sha": "e9393cc89aedf021ad3a6533fd79d0be6537fc7e", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/mod_path.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fmod_path.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -6,7 +6,7 @@ use std::{\n };\n \n use crate::{\n-    db::AstDatabase,\n+    db::ExpandDatabase,\n     hygiene::Hygiene,\n     name::{known, Name},\n };\n@@ -37,7 +37,11 @@ pub enum PathKind {\n }\n \n impl ModPath {\n-    pub fn from_src(db: &dyn AstDatabase, path: ast::Path, hygiene: &Hygiene) -> Option<ModPath> {\n+    pub fn from_src(\n+        db: &dyn ExpandDatabase,\n+        path: ast::Path,\n+        hygiene: &Hygiene,\n+    ) -> Option<ModPath> {\n         convert_path(db, None, path, hygiene)\n     }\n \n@@ -162,7 +166,7 @@ impl From<Name> for ModPath {\n }\n \n fn convert_path(\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     prefix: Option<ModPath>,\n     path: ast::Path,\n     hygiene: &Hygiene,"}, {"sha": "d758e9302cd87d90a8d20b048353fcd5af723499", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/proc_macro.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fproc_macro.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -3,22 +3,20 @@\n use base_db::{CrateId, ProcMacroExpansionError, ProcMacroId, ProcMacroKind};\n use stdx::never;\n \n-use crate::{db::AstDatabase, tt, ExpandError, ExpandResult};\n+use crate::{db::ExpandDatabase, tt, ExpandError, ExpandResult};\n \n #[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]\n pub struct ProcMacroExpander {\n-    krate: CrateId,\n     proc_macro_id: Option<ProcMacroId>,\n }\n \n impl ProcMacroExpander {\n-    pub fn new(krate: CrateId, proc_macro_id: ProcMacroId) -> Self {\n-        Self { krate, proc_macro_id: Some(proc_macro_id) }\n+    pub fn new(proc_macro_id: ProcMacroId) -> Self {\n+        Self { proc_macro_id: Some(proc_macro_id) }\n     }\n \n-    pub fn dummy(krate: CrateId) -> Self {\n-        // FIXME: Should store the name for better errors\n-        Self { krate, proc_macro_id: None }\n+    pub fn dummy() -> Self {\n+        Self { proc_macro_id: None }\n     }\n \n     pub fn is_dummy(&self) -> bool {\n@@ -27,15 +25,16 @@ impl ProcMacroExpander {\n \n     pub fn expand(\n         self,\n-        db: &dyn AstDatabase,\n+        db: &dyn ExpandDatabase,\n+        def_crate: CrateId,\n         calling_crate: CrateId,\n         tt: &tt::Subtree,\n         attr_arg: Option<&tt::Subtree>,\n     ) -> ExpandResult<tt::Subtree> {\n         match self.proc_macro_id {\n             Some(id) => {\n                 let krate_graph = db.crate_graph();\n-                let proc_macros = match &krate_graph[self.krate].proc_macro {\n+                let proc_macros = match &krate_graph[def_crate].proc_macro {\n                     Ok(proc_macros) => proc_macros,\n                     Err(_) => {\n                         never!(\"Non-dummy expander even though there are no proc macros\");\n@@ -84,7 +83,7 @@ impl ProcMacroExpander {\n             }\n             None => ExpandResult::with_err(\n                 tt::Subtree::empty(),\n-                ExpandError::UnresolvedProcMacro(self.krate),\n+                ExpandError::UnresolvedProcMacro(def_crate),\n             ),\n         }\n     }"}, {"sha": "9b3296df2508a4ba684afb05291ceb82e07f2b1c", "filename": "src/tools/rust-analyzer/crates/hir-ty/Cargo.toml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -22,10 +22,10 @@ either = \"1.7.0\"\n tracing = \"0.1.35\"\n rustc-hash = \"1.1.0\"\n scoped-tls = \"1.0.0\"\n-chalk-solve = { version = \"0.88.0\", default-features = false }\n-chalk-ir = \"0.88.0\"\n-chalk-recursive = { version = \"0.88.0\", default-features = false }\n-chalk-derive = \"0.88.0\"\n+chalk-solve = { version = \"0.89.0\", default-features = false }\n+chalk-ir = \"0.89.0\"\n+chalk-recursive = { version = \"0.89.0\", default-features = false }\n+chalk-derive = \"0.89.0\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n once_cell = \"1.17.0\"\n typed-arena = \"2.0.1\""}, {"sha": "2141894922f7b78c1a07f386148cdbeb5579f999", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -12,7 +12,7 @@ use hir_def::{\n use crate::{\n     db::HirDatabase, from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id,\n     from_placeholder_idx, to_chalk_trait_id, utils::generics, AdtId, AliasEq, AliasTy, Binders,\n-    CallableDefId, CallableSig, FnPointer, ImplTraitId, Interner, Lifetime, ProjectionTy,\n+    CallableDefId, CallableSig, DynTy, FnPointer, ImplTraitId, Interner, Lifetime, ProjectionTy,\n     QuantifiedWhereClause, Substitution, TraitRef, Ty, TyBuilder, TyKind, TypeFlags, WhereClause,\n };\n \n@@ -378,6 +378,19 @@ impl ProjectionTyExt for ProjectionTy {\n     }\n }\n \n+pub trait DynTyExt {\n+    fn principal(&self) -> Option<&TraitRef>;\n+}\n+\n+impl DynTyExt for DynTy {\n+    fn principal(&self) -> Option<&TraitRef> {\n+        self.bounds.skip_binders().interned().get(0).and_then(|b| match b.skip_binders() {\n+            crate::WhereClause::Implemented(trait_ref) => Some(trait_ref),\n+            _ => None,\n+        })\n+    }\n+}\n+\n pub trait TraitRefExt {\n     fn hir_trait_id(&self) -> TraitId;\n }"}, {"sha": "4b147b99707c15ad6c71a171307b605cec108fe6", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -11,3 +11,9 @@ pub use crate::diagnostics::{\n     },\n     unsafe_check::{missing_unsafe, unsafe_expressions, UnsafeExpr},\n };\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct IncoherentImpl {\n+    pub file_id: hir_expand::HirFileId,\n+    pub impl_: syntax::AstPtr<syntax::ast::Impl>,\n+}"}, {"sha": "ee186673ee130ab8d13daca76e82319c47aac6c0", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 47, "deletions": 26, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -275,7 +275,23 @@ impl<'a> InferenceContext<'a> {\n                     Some(type_ref) => self.make_ty(type_ref),\n                     None => self.table.new_type_var(),\n                 };\n-                sig_tys.push(ret_ty.clone());\n+                if let ClosureKind::Async = closure_kind {\n+                    // Use the first type parameter as the output type of future.\n+                    // existential type AsyncBlockImplTrait<InnerType>: Future<Output = InnerType>\n+                    let impl_trait_id =\n+                        crate::ImplTraitId::AsyncBlockTypeImplTrait(self.owner, *body);\n+                    let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n+                    sig_tys.push(\n+                        TyKind::OpaqueType(\n+                            opaque_ty_id,\n+                            Substitution::from1(Interner, ret_ty.clone()),\n+                        )\n+                        .intern(Interner),\n+                    );\n+                } else {\n+                    sig_tys.push(ret_ty.clone());\n+                }\n+\n                 let sig_ty = TyKind::Function(FnPointer {\n                     num_binders: 0,\n                     sig: FnSig { abi: (), safety: chalk_ir::Safety::Safe, variadic: false },\n@@ -286,33 +302,38 @@ impl<'a> InferenceContext<'a> {\n                 })\n                 .intern(Interner);\n \n-                let (ty, resume_yield_tys) = if matches!(closure_kind, ClosureKind::Generator(_)) {\n-                    // FIXME: report error when there are more than 1 parameter.\n-                    let resume_ty = match sig_tys.first() {\n-                        // When `sig_tys.len() == 1` the first type is the return type, not the\n-                        // first parameter type.\n-                        Some(ty) if sig_tys.len() > 1 => ty.clone(),\n-                        _ => self.result.standard_types.unit.clone(),\n-                    };\n-                    let yield_ty = self.table.new_type_var();\n-\n-                    let subst = TyBuilder::subst_for_generator(self.db, self.owner)\n-                        .push(resume_ty.clone())\n-                        .push(yield_ty.clone())\n-                        .push(ret_ty.clone())\n-                        .build();\n+                let (ty, resume_yield_tys) = match closure_kind {\n+                    ClosureKind::Generator(_) => {\n+                        // FIXME: report error when there are more than 1 parameter.\n+                        let resume_ty = match sig_tys.first() {\n+                            // When `sig_tys.len() == 1` the first type is the return type, not the\n+                            // first parameter type.\n+                            Some(ty) if sig_tys.len() > 1 => ty.clone(),\n+                            _ => self.result.standard_types.unit.clone(),\n+                        };\n+                        let yield_ty = self.table.new_type_var();\n+\n+                        let subst = TyBuilder::subst_for_generator(self.db, self.owner)\n+                            .push(resume_ty.clone())\n+                            .push(yield_ty.clone())\n+                            .push(ret_ty.clone())\n+                            .build();\n \n-                    let generator_id = self.db.intern_generator((self.owner, tgt_expr)).into();\n-                    let generator_ty = TyKind::Generator(generator_id, subst).intern(Interner);\n+                        let generator_id = self.db.intern_generator((self.owner, tgt_expr)).into();\n+                        let generator_ty = TyKind::Generator(generator_id, subst).intern(Interner);\n \n-                    (generator_ty, Some((resume_ty, yield_ty)))\n-                } else {\n-                    let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n-                    let closure_ty =\n-                        TyKind::Closure(closure_id, Substitution::from1(Interner, sig_ty.clone()))\n-                            .intern(Interner);\n+                        (generator_ty, Some((resume_ty, yield_ty)))\n+                    }\n+                    ClosureKind::Closure | ClosureKind::Async => {\n+                        let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n+                        let closure_ty = TyKind::Closure(\n+                            closure_id,\n+                            Substitution::from1(Interner, sig_ty.clone()),\n+                        )\n+                        .intern(Interner);\n \n-                    (closure_ty, None)\n+                        (closure_ty, None)\n+                    }\n                 };\n \n                 // Eagerly try to relate the closure type with the expected\n@@ -321,7 +342,7 @@ impl<'a> InferenceContext<'a> {\n                 self.deduce_closure_type_from_expectations(tgt_expr, &ty, &sig_ty, expected);\n \n                 // Now go through the argument patterns\n-                for (arg_pat, arg_ty) in args.iter().zip(sig_tys) {\n+                for (arg_pat, arg_ty) in args.iter().zip(&sig_tys) {\n                     self.infer_top_pat(*arg_pat, &arg_ty);\n                 }\n "}, {"sha": "5f839fc307aabf79191f9b27c81d513f0f77d696", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -5,10 +5,7 @@ use std::iter::repeat_with;\n use chalk_ir::Mutability;\n use hir_def::{\n     body::Body,\n-    expr::{\n-        Binding, BindingAnnotation, BindingId, Expr, ExprId, ExprOrPatId, Literal, Pat, PatId,\n-        RecordFieldPat,\n-    },\n+    expr::{Binding, BindingAnnotation, BindingId, Expr, ExprId, ExprOrPatId, Literal, Pat, PatId},\n     path::Path,\n };\n use hir_expand::name::Name;\n@@ -439,38 +436,8 @@ fn is_non_ref_pat(body: &hir_def::body::Body, pat: PatId) -> bool {\n \n pub(super) fn contains_explicit_ref_binding(body: &Body, pat_id: PatId) -> bool {\n     let mut res = false;\n-    walk_pats(body, pat_id, &mut |pat| {\n+    body.walk_pats(pat_id, &mut |pat| {\n         res |= matches!(pat, Pat::Bind { id, .. } if body.bindings[*id].mode == BindingAnnotation::Ref);\n     });\n     res\n }\n-\n-fn walk_pats(body: &Body, pat_id: PatId, f: &mut impl FnMut(&Pat)) {\n-    let pat = &body[pat_id];\n-    f(pat);\n-    match pat {\n-        Pat::Range { .. }\n-        | Pat::Lit(..)\n-        | Pat::Path(..)\n-        | Pat::ConstBlock(..)\n-        | Pat::Wild\n-        | Pat::Missing => {}\n-        &Pat::Bind { subpat, .. } => {\n-            if let Some(subpat) = subpat {\n-                walk_pats(body, subpat, f);\n-            }\n-        }\n-        Pat::Or(args) | Pat::Tuple { args, .. } | Pat::TupleStruct { args, .. } => {\n-            args.iter().copied().for_each(|p| walk_pats(body, p, f));\n-        }\n-        Pat::Ref { pat, .. } => walk_pats(body, *pat, f),\n-        Pat::Slice { prefix, slice, suffix } => {\n-            let total_iter = prefix.iter().chain(slice.iter()).chain(suffix.iter());\n-            total_iter.copied().for_each(|p| walk_pats(body, p, f));\n-        }\n-        Pat::Record { args, .. } => {\n-            args.iter().for_each(|RecordFieldPat { pat, .. }| walk_pats(body, *pat, f));\n-        }\n-        Pat::Box { inner } => walk_pats(body, *inner, f),\n-    }\n-}"}, {"sha": "f3a27632bf545f9c578bb1a8bcd9673fb9186e75", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 83, "deletions": 9, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -19,13 +19,13 @@ use stdx::never;\n use crate::{\n     autoderef::{self, AutoderefKind},\n     db::HirDatabase,\n-    from_foreign_def_id,\n+    from_chalk_trait_id, from_foreign_def_id,\n     infer::{unify::InferenceTable, Adjust, Adjustment, AutoBorrow, OverloadedDeref, PointerCast},\n     primitive::{FloatTy, IntTy, UintTy},\n     static_lifetime, to_chalk_trait_id,\n     utils::all_super_traits,\n-    AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, ForeignDefId, InEnvironment, Interner,\n-    Scalar, Substitution, TraitEnvironment, TraitRef, TraitRefExt, Ty, TyBuilder, TyExt,\n+    AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, DynTyExt, ForeignDefId, InEnvironment,\n+    Interner, Scalar, Substitution, TraitEnvironment, TraitRef, TraitRefExt, Ty, TyBuilder, TyExt,\n };\n \n /// This is used as a key for indexing impls.\n@@ -266,11 +266,12 @@ impl TraitImpls {\n #[derive(Debug, Eq, PartialEq)]\n pub struct InherentImpls {\n     map: FxHashMap<TyFingerprint, Vec<ImplId>>,\n+    invalid_impls: Vec<ImplId>,\n }\n \n impl InherentImpls {\n     pub(crate) fn inherent_impls_in_crate_query(db: &dyn HirDatabase, krate: CrateId) -> Arc<Self> {\n-        let mut impls = Self { map: FxHashMap::default() };\n+        let mut impls = Self { map: FxHashMap::default(), invalid_impls: Vec::default() };\n \n         let crate_def_map = db.crate_def_map(krate);\n         impls.collect_def_map(db, &crate_def_map);\n@@ -283,7 +284,7 @@ impl InherentImpls {\n         db: &dyn HirDatabase,\n         block: BlockId,\n     ) -> Option<Arc<Self>> {\n-        let mut impls = Self { map: FxHashMap::default() };\n+        let mut impls = Self { map: FxHashMap::default(), invalid_impls: Vec::default() };\n         if let Some(block_def_map) = db.block_def_map(block) {\n             impls.collect_def_map(db, &block_def_map);\n             impls.shrink_to_fit();\n@@ -306,11 +307,17 @@ impl InherentImpls {\n                 }\n \n                 let self_ty = db.impl_self_ty(impl_id);\n-                let fp = TyFingerprint::for_inherent_impl(self_ty.skip_binders());\n-                if let Some(fp) = fp {\n-                    self.map.entry(fp).or_default().push(impl_id);\n+                let self_ty = self_ty.skip_binders();\n+\n+                match is_inherent_impl_coherent(db, def_map, &data, self_ty) {\n+                    true => {\n+                        // `fp` should only be `None` in error cases (either erroneous code or incomplete name resolution)\n+                        if let Some(fp) = TyFingerprint::for_inherent_impl(self_ty) {\n+                            self.map.entry(fp).or_default().push(impl_id);\n+                        }\n+                    }\n+                    false => self.invalid_impls.push(impl_id),\n                 }\n-                // `fp` should only be `None` in error cases (either erroneous code or incomplete name resolution)\n             }\n \n             // To better support custom derives, collect impls in all unnamed const items.\n@@ -334,6 +341,10 @@ impl InherentImpls {\n     pub fn all_impls(&self) -> impl Iterator<Item = ImplId> + '_ {\n         self.map.values().flat_map(|v| v.iter().copied())\n     }\n+\n+    pub fn invalid_impls(&self) -> &[ImplId] {\n+        &self.invalid_impls\n+    }\n }\n \n pub(crate) fn incoherent_inherent_impl_crates(\n@@ -775,6 +786,69 @@ fn find_matching_impl(\n     }\n }\n \n+fn is_inherent_impl_coherent(\n+    db: &dyn HirDatabase,\n+    def_map: &DefMap,\n+    impl_data: &ImplData,\n+    self_ty: &Ty,\n+) -> bool {\n+    let self_ty = self_ty.kind(Interner);\n+    let impl_allowed = match self_ty {\n+        TyKind::Tuple(_, _)\n+        | TyKind::FnDef(_, _)\n+        | TyKind::Array(_, _)\n+        | TyKind::Never\n+        | TyKind::Raw(_, _)\n+        | TyKind::Ref(_, _, _)\n+        | TyKind::Slice(_)\n+        | TyKind::Str\n+        | TyKind::Scalar(_) => def_map.is_rustc_coherence_is_core(),\n+\n+        &TyKind::Adt(AdtId(adt), _) => adt.module(db.upcast()).krate() == def_map.krate(),\n+        TyKind::Dyn(it) => it.principal().map_or(false, |trait_ref| {\n+            from_chalk_trait_id(trait_ref.trait_id).module(db.upcast()).krate() == def_map.krate()\n+        }),\n+\n+        _ => true,\n+    };\n+    impl_allowed || {\n+        let rustc_has_incoherent_inherent_impls = match self_ty {\n+            TyKind::Tuple(_, _)\n+            | TyKind::FnDef(_, _)\n+            | TyKind::Array(_, _)\n+            | TyKind::Never\n+            | TyKind::Raw(_, _)\n+            | TyKind::Ref(_, _, _)\n+            | TyKind::Slice(_)\n+            | TyKind::Str\n+            | TyKind::Scalar(_) => true,\n+\n+            &TyKind::Adt(AdtId(adt), _) => match adt {\n+                hir_def::AdtId::StructId(it) => {\n+                    db.struct_data(it).rustc_has_incoherent_inherent_impls\n+                }\n+                hir_def::AdtId::UnionId(it) => {\n+                    db.union_data(it).rustc_has_incoherent_inherent_impls\n+                }\n+                hir_def::AdtId::EnumId(it) => db.enum_data(it).rustc_has_incoherent_inherent_impls,\n+            },\n+            TyKind::Dyn(it) => it.principal().map_or(false, |trait_ref| {\n+                db.trait_data(from_chalk_trait_id(trait_ref.trait_id))\n+                    .rustc_has_incoherent_inherent_impls\n+            }),\n+\n+            _ => false,\n+        };\n+        rustc_has_incoherent_inherent_impls\n+            && !impl_data.items.is_empty()\n+            && impl_data.items.iter().copied().all(|assoc| match assoc {\n+                AssocItemId::FunctionId(it) => db.function_data(it).rustc_allow_incoherent_impl,\n+                AssocItemId::ConstId(it) => db.const_data(it).rustc_allow_incoherent_impl,\n+                AssocItemId::TypeAliasId(it) => db.type_alias_data(it).rustc_allow_incoherent_impl,\n+            })\n+    }\n+}\n+\n pub fn iterate_path_candidates(\n     ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,"}, {"sha": "c4dd7c0ace46c150663cb5641c72d21d630a6dcf", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1113,7 +1113,7 @@ impl MirLowerCtx<'_> {\n                 if matches!(mode, BindingAnnotation::Ref | BindingAnnotation::RefMut) {\n                     binding_mode = mode;\n                 }\n-                self.push_storage_live(*id, current)?;\n+                self.push_storage_live(*id, current);\n                 self.push_assignment(\n                     current,\n                     target_place.into(),\n@@ -1327,8 +1327,9 @@ impl MirLowerCtx<'_> {\n         is_ty_uninhabited_from(&self.infer[expr_id], self.owner.module(self.db.upcast()), self.db)\n     }\n \n-    /// This function push `StorageLive` statements for each binding in the pattern.\n-    fn push_storage_live(&mut self, b: BindingId, current: BasicBlockId) -> Result<()> {\n+    /// This function push `StorageLive` statement for the binding, and applies changes to add `StorageDead` in\n+    /// the appropriated places.\n+    fn push_storage_live(&mut self, b: BindingId, current: BasicBlockId) {\n         // Current implementation is wrong. It adds no `StorageDead` at the end of scope, and before each break\n         // and continue. It just add a `StorageDead` before the `StorageLive`, which is not wrong, but unneeeded in\n         // the proper implementation. Due this limitation, implementing a borrow checker on top of this mir will falsely\n@@ -1356,7 +1357,6 @@ impl MirLowerCtx<'_> {\n         let l = self.result.binding_locals[b];\n         self.push_statement(current, StatementKind::StorageDead(l).with_span(span));\n         self.push_statement(current, StatementKind::StorageLive(l).with_span(span));\n-        Ok(())\n     }\n \n     fn resolve_lang_item(&self, item: LangItem) -> Result<LangItemTarget> {\n@@ -1381,10 +1381,10 @@ impl MirLowerCtx<'_> {\n                     if let Some(expr_id) = initializer {\n                         let else_block;\n                         let Some((init_place, c)) =\n-                        self.lower_expr_as_place(current, *expr_id, true)?\n-                    else {\n-                        return Ok(None);\n-                    };\n+                            self.lower_expr_as_place(current, *expr_id, true)?\n+                        else {\n+                            return Ok(None);\n+                        };\n                         current = c;\n                         (current, else_block) = self.pattern_match(\n                             current,\n@@ -1407,6 +1407,10 @@ impl MirLowerCtx<'_> {\n                                 }\n                             }\n                         }\n+                    } else {\n+                        self.body.walk_bindings_in_pat(*pat, |b| {\n+                            self.push_storage_live(b, current);\n+                        });\n                     }\n                 }\n                 hir_def::expr::Statement::Expr { expr, has_semi: _ } => {"}, {"sha": "8c48331b94b53769721fe7688813545aecd0a8b3", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/test_db.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftest_db.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -9,15 +9,15 @@ use base_db::{\n     salsa, AnchoredPath, CrateId, FileId, FileLoader, FileLoaderDelegate, SourceDatabase, Upcast,\n };\n use hir_def::{db::DefDatabase, ModuleId};\n-use hir_expand::db::AstDatabase;\n+use hir_expand::db::ExpandDatabase;\n use stdx::hash::{NoHashHashMap, NoHashHashSet};\n use syntax::TextRange;\n use test_utils::extract_annotations;\n \n #[salsa::database(\n     base_db::SourceDatabaseExtStorage,\n     base_db::SourceDatabaseStorage,\n-    hir_expand::db::AstDatabaseStorage,\n+    hir_expand::db::ExpandDatabaseStorage,\n     hir_def::db::InternDatabaseStorage,\n     hir_def::db::DefDatabaseStorage,\n     crate::db::HirDatabaseStorage\n@@ -41,8 +41,8 @@ impl fmt::Debug for TestDB {\n     }\n }\n \n-impl Upcast<dyn AstDatabase> for TestDB {\n-    fn upcast(&self) -> &(dyn AstDatabase + 'static) {\n+impl Upcast<dyn ExpandDatabase> for TestDB {\n+    fn upcast(&self) -> &(dyn ExpandDatabase + 'static) {\n         &*self\n     }\n }"}, {"sha": "83d31f002a1dcae6b336cac179ac8e97eddf16cf", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -23,7 +23,7 @@ use hir_def::{\n     src::HasSource,\n     AssocItemId, DefWithBodyId, HasModule, LocalModuleId, Lookup, ModuleDefId,\n };\n-use hir_expand::{db::AstDatabase, InFile};\n+use hir_expand::{db::ExpandDatabase, InFile};\n use once_cell::race::OnceBool;\n use stdx::format_to;\n use syntax::{"}, {"sha": "378d478336102f0c2399e7d2b2aedfd7531a0503", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -9,6 +9,7 @@ fn infer_slice_method() {\n     check_types(\n         r#\"\n impl<T> [T] {\n+    #[rustc_allow_incoherent_impl]\n     fn foo(&self) -> T {\n         loop {}\n     }\n@@ -35,6 +36,7 @@ fn test() {\n //- /lib.rs crate:other_crate\n mod foo {\n     impl f32 {\n+        #[rustc_allow_incoherent_impl]\n         pub fn foo(self) -> f32 { 0. }\n     }\n }\n@@ -47,6 +49,7 @@ fn infer_array_inherent_impl() {\n     check_types(\n         r#\"\n impl<T, const N: usize> [T; N] {\n+    #[rustc_allow_incoherent_impl]\n     fn foo(&self) -> T {\n         loop {}\n     }\n@@ -1437,6 +1440,7 @@ fn resolve_const_generic_array_methods() {\n         r#\"\n #[lang = \"array\"]\n impl<T, const N: usize> [T; N] {\n+    #[rustc_allow_incoherent_impl]\n     pub fn map<F, U>(self, f: F) -> [U; N]\n     where\n         F: FnMut(T) -> U,\n@@ -1445,6 +1449,7 @@ impl<T, const N: usize> [T; N] {\n \n #[lang = \"slice\"]\n impl<T> [T] {\n+    #[rustc_allow_incoherent_impl]\n     pub fn map<F, U>(self, f: F) -> &[U]\n     where\n         F: FnMut(T) -> U,\n@@ -1468,6 +1473,7 @@ struct Const<const N: usize>;\n \n #[lang = \"array\"]\n impl<T, const N: usize> [T; N] {\n+    #[rustc_allow_incoherent_impl]\n     pub fn my_map<F, U, const X: usize>(self, f: F, c: Const<X>) -> [U; X]\n     where\n         F: FnMut(T) -> U,\n@@ -1476,6 +1482,7 @@ impl<T, const N: usize> [T; N] {\n \n #[lang = \"slice\"]\n impl<T> [T] {\n+    #[rustc_allow_incoherent_impl]\n     pub fn my_map<F, const X: usize, U>(self, f: F, c: Const<X>) -> &[U]\n     where\n         F: FnMut(T) -> U,\n@@ -1874,14 +1881,14 @@ fn incoherent_impls() {\n pub struct Box<T>(T);\n use core::error::Error;\n \n-#[rustc_allow_incoherent_impl]\n impl dyn Error {\n+    #[rustc_allow_incoherent_impl]\n     pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error>> {\n         loop {}\n     }\n }\n-#[rustc_allow_incoherent_impl]\n impl dyn Error + Send {\n+    #[rustc_allow_incoherent_impl]\n     /// Attempts to downcast the box to a concrete type.\n     pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error + Send>> {\n         let err: Box<dyn Error> = self;"}, {"sha": "689f0da44f68036178bf666b6ef8b6ac76a2fe13", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1756,3 +1756,35 @@ const C: usize = 2 + 2;\n \"#,\n     );\n }\n+\n+#[test]\n+fn regression_14164() {\n+    check_types(\n+        r#\"\n+trait Rec {\n+    type K;\n+    type Rebind<Tok>: Rec<K = Tok>;\n+}\n+\n+trait Expr<K> {\n+    type Part: Rec<K = K>;\n+    fn foo(_: <Self::Part as Rec>::Rebind<i32>) {}\n+}\n+\n+struct Head<K>(K);\n+impl<K> Rec for Head<K> {\n+    type K = K;\n+    type Rebind<Tok> = Head<Tok>;\n+}\n+\n+fn test<E>()\n+where\n+    E: Expr<usize, Part = Head<usize>>,\n+{\n+    let head;\n+      //^^^^ Head<i32>\n+    E::foo(head);\n+}\n+\"#,\n+    );\n+}"}, {"sha": "13cc3fea52d16281c33419c4788ab94f27f38222", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1116,21 +1116,22 @@ fn infer_inherent_method() {\n fn infer_inherent_method_str() {\n     check_infer(\n         r#\"\n-        #[lang = \"str\"]\n-        impl str {\n-            fn foo(&self) -> i32 {}\n-        }\n+#![rustc_coherence_is_core]\n+#[lang = \"str\"]\n+impl str {\n+    fn foo(&self) -> i32 {}\n+}\n \n-        fn test() {\n-            \"foo\".foo();\n-        }\n-        \"#,\n+fn test() {\n+    \"foo\".foo();\n+}\n+\"#,\n         expect![[r#\"\n-            39..43 'self': &str\n-            52..54 '{}': i32\n-            68..88 '{     ...o(); }': ()\n-            74..79 '\"foo\"': &str\n-            74..85 '\"foo\".foo()': i32\n+            67..71 'self': &str\n+            80..82 '{}': i32\n+            96..116 '{     ...o(); }': ()\n+            102..107 '\"foo\"': &str\n+            102..113 '\"foo\".foo()': i32\n         \"#]],\n     );\n }\n@@ -2640,6 +2641,7 @@ impl<T> [T] {}\n \n #[lang = \"slice_alloc\"]\n impl<T> [T] {\n+    #[rustc_allow_incoherent_impl]\n     pub fn into_vec<A: Allocator>(self: Box<Self, A>) -> Vec<T, A> {\n         unimplemented!()\n     }\n@@ -2655,22 +2657,22 @@ struct Astruct;\n impl B for Astruct {}\n \"#,\n         expect![[r#\"\n-            569..573 'self': Box<[T], A>\n-            602..634 '{     ...     }': Vec<T, A>\n-            648..761 '{     ...t]); }': ()\n-            658..661 'vec': Vec<i32, Global>\n-            664..679 '<[_]>::into_vec': fn into_vec<i32, Global>(Box<[i32], Global>) -> Vec<i32, Global>\n-            664..691 '<[_]>:...1i32])': Vec<i32, Global>\n-            680..690 'box [1i32]': Box<[i32; 1], Global>\n-            684..690 '[1i32]': [i32; 1]\n-            685..689 '1i32': i32\n-            701..702 'v': Vec<Box<dyn B, Global>, Global>\n-            722..739 '<[_]> ...to_vec': fn into_vec<Box<dyn B, Global>, Global>(Box<[Box<dyn B, Global>], Global>) -> Vec<Box<dyn B, Global>, Global>\n-            722..758 '<[_]> ...ruct])': Vec<Box<dyn B, Global>, Global>\n-            740..757 'box [b...truct]': Box<[Box<dyn B, Global>; 1], Global>\n-            744..757 '[box Astruct]': [Box<dyn B, Global>; 1]\n-            745..756 'box Astruct': Box<Astruct, Global>\n-            749..756 'Astruct': Astruct\n+            604..608 'self': Box<[T], A>\n+            637..669 '{     ...     }': Vec<T, A>\n+            683..796 '{     ...t]); }': ()\n+            693..696 'vec': Vec<i32, Global>\n+            699..714 '<[_]>::into_vec': fn into_vec<i32, Global>(Box<[i32], Global>) -> Vec<i32, Global>\n+            699..726 '<[_]>:...1i32])': Vec<i32, Global>\n+            715..725 'box [1i32]': Box<[i32; 1], Global>\n+            719..725 '[1i32]': [i32; 1]\n+            720..724 '1i32': i32\n+            736..737 'v': Vec<Box<dyn B, Global>, Global>\n+            757..774 '<[_]> ...to_vec': fn into_vec<Box<dyn B, Global>, Global>(Box<[Box<dyn B, Global>], Global>) -> Vec<Box<dyn B, Global>, Global>\n+            757..793 '<[_]> ...ruct])': Vec<Box<dyn B, Global>, Global>\n+            775..792 'box [b...truct]': Box<[Box<dyn B, Global>; 1], Global>\n+            779..792 '[box Astruct]': [Box<dyn B, Global>; 1]\n+            780..791 'box Astruct': Box<Astruct, Global>\n+            784..791 'Astruct': Astruct\n         \"#]],\n     )\n }"}, {"sha": "da76d7fd83f76a0987f0d27284dbe49e8a409acc", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 56, "deletions": 15, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -82,6 +82,46 @@ async fn test() {\n     );\n }\n \n+#[test]\n+fn infer_async_closure() {\n+    check_types(\n+        r#\"\n+//- minicore: future, option\n+async fn test() {\n+    let f = async move |x: i32| x + 42;\n+    f;\n+//  ^ |i32| -> impl Future<Output = i32>\n+    let a = f(4);\n+    a;\n+//  ^ impl Future<Output = i32>\n+    let x = a.await;\n+    x;\n+//  ^ i32\n+    let f = async move || 42;\n+    f;\n+//  ^ || -> impl Future<Output = i32>\n+    let a = f();\n+    a;\n+//  ^ impl Future<Output = i32>\n+    let x = a.await;\n+    x;\n+//  ^ i32\n+    let b = ((async move || {})()).await;\n+    b;\n+//  ^ ()\n+    let c = async move || {\n+        let y = None;\n+        y\n+    //  ^ Option<u64>\n+    };\n+    let _: Option<u64> = c().await;\n+    c;\n+//  ^ || -> impl Future<Output = Option<u64>>\n+}\n+\"#,\n+    );\n+}\n+\n #[test]\n fn auto_sized_async_block() {\n     check_no_mismatches(\n@@ -493,29 +533,30 @@ fn tuple_struct_with_fn() {\n         r#\"\n struct S(fn(u32) -> u64);\n fn test() -> u64 {\n-    let a = S(|i| 2*i);\n+    let a = S(|i| 2*i as u64);\n     let b = a.0(4);\n     a.0(2)\n }\"#,\n         expect![[r#\"\n-            43..101 '{     ...0(2) }': u64\n+            43..108 '{     ...0(2) }': u64\n             53..54 'a': S\n             57..58 'S': S(fn(u32) -> u64) -> S\n-            57..67 'S(|i| 2*i)': S\n-            59..66 '|i| 2*i': |u32| -> u64\n+            57..74 'S(|i| ...s u64)': S\n+            59..73 '|i| 2*i as u64': |u32| -> u64\n             60..61 'i': u32\n-            63..64 '2': u32\n-            63..66 '2*i': u32\n+            63..64 '2': u64\n+            63..73 '2*i as u64': u64\n             65..66 'i': u32\n-            77..78 'b': u64\n-            81..82 'a': S\n-            81..84 'a.0': fn(u32) -> u64\n-            81..87 'a.0(4)': u64\n-            85..86 '4': u32\n-            93..94 'a': S\n-            93..96 'a.0': fn(u32) -> u64\n-            93..99 'a.0(2)': u64\n-            97..98 '2': u32\n+            65..73 'i as u64': u64\n+            84..85 'b': u64\n+            88..89 'a': S\n+            88..91 'a.0': fn(u32) -> u64\n+            88..94 'a.0(4)': u64\n+            92..93 '4': u32\n+            100..101 'a': S\n+            100..103 'a.0': fn(u32) -> u64\n+            100..106 'a.0(2)': u64\n+            104..105 '2': u32\n         \"#]],\n     );\n }"}, {"sha": "0935b5ea51945de6557d07af7a7aff41e1974151", "filename": "src/tools/rust-analyzer/crates/hir/src/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdb.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -5,7 +5,7 @@\n //! But we need this for at least LRU caching at the query level.\n pub use hir_def::db::*;\n pub use hir_expand::db::{\n-    AstDatabase, AstDatabaseStorage, AstIdMapQuery, ExpandProcMacroQuery, HygieneFrameQuery,\n+    AstIdMapQuery, ExpandDatabase, ExpandDatabaseStorage, ExpandProcMacroQuery, HygieneFrameQuery,\n     InternMacroCallQuery, MacroArgTextQuery, MacroDefQuery, MacroExpandErrorQuery,\n     MacroExpandQuery, ParseMacroExpansionQuery,\n };"}, {"sha": "253d62dafc60b20ec3845e7cd7c189112d6a8e48", "filename": "src/tools/rust-analyzer/crates/hir/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -3,6 +3,8 @@\n //!\n //! This probably isn't the best way to do this -- ideally, diagnostics should\n //! be expressed in terms of hir types themselves.\n+pub use hir_ty::diagnostics::{IncoherentImpl, IncorrectCase};\n+\n use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n@@ -35,6 +37,7 @@ diagnostics![\n     InactiveCode,\n     IncorrectCase,\n     InvalidDeriveTarget,\n+    IncoherentImpl,\n     MacroError,\n     MalformedDerive,\n     MismatchedArgCount,\n@@ -220,5 +223,3 @@ pub struct NeedMut {\n pub struct UnusedMut {\n     pub local: Local,\n }\n-\n-pub use hir_ty::diagnostics::IncorrectCase;"}, {"sha": "35424feec8b29b294220be299c6ecaab1e1594cf", "filename": "src/tools/rust-analyzer/crates/hir/src/lib.rs", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -85,10 +85,10 @@ use crate::db::{DefDatabase, HirDatabase};\n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n     diagnostics::{\n-        AnyDiagnostic, BreakOutsideOfLoop, ExpectedFunction, InactiveCode, IncorrectCase,\n-        InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount, MissingFields,\n-        MissingMatchArms, MissingUnsafe, NeedMut, NoSuchField, PrivateAssocItem, PrivateField,\n-        ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n+        AnyDiagnostic, BreakOutsideOfLoop, ExpectedFunction, InactiveCode, IncoherentImpl,\n+        IncorrectCase, InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount,\n+        MissingFields, MissingMatchArms, MissingUnsafe, NeedMut, NoSuchField, PrivateAssocItem,\n+        PrivateField, ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n         UnresolvedExternCrate, UnresolvedField, UnresolvedImport, UnresolvedMacroCall,\n         UnresolvedMethodCall, UnresolvedModule, UnresolvedProcMacro, UnusedMut,\n     },\n@@ -604,11 +604,23 @@ impl Module {\n             }\n         }\n \n+        let inherent_impls = db.inherent_impls_in_crate(self.id.krate());\n+\n         for impl_def in self.impl_defs(db) {\n             for diag in db.impl_data_with_diagnostics(impl_def.id).1.iter() {\n                 emit_def_diagnostic(db, acc, diag);\n             }\n \n+            if inherent_impls.invalid_impls().contains(&impl_def.id) {\n+                let loc = impl_def.id.lookup(db.upcast());\n+                let tree = loc.id.item_tree(db.upcast());\n+                let node = &tree[loc.id.value];\n+                let file_id = loc.id.file_id();\n+                let ast_id_map = db.ast_id_map(file_id);\n+\n+                acc.push(IncoherentImpl { impl_: ast_id_map.get(node.ast_id()), file_id }.into())\n+            }\n+\n             for item in impl_def.items(db) {\n                 let def: DefWithBody = match item {\n                     AssocItem::Function(it) => it.into(),\n@@ -3210,6 +3222,14 @@ impl Type {\n         matches!(self.ty.kind(Interner), TyKind::Scalar(Scalar::Uint(UintTy::Usize)))\n     }\n \n+    pub fn is_float(&self) -> bool {\n+        matches!(self.ty.kind(Interner), TyKind::Scalar(Scalar::Float(_)))\n+    }\n+\n+    pub fn is_char(&self) -> bool {\n+        matches!(self.ty.kind(Interner), TyKind::Scalar(Scalar::Char))\n+    }\n+\n     pub fn is_int_or_uint(&self) -> bool {\n         match self.ty.kind(Interner) {\n             TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_)) => true,\n@@ -3224,6 +3244,13 @@ impl Type {\n         }\n     }\n \n+    pub fn as_slice(&self) -> Option<Type> {\n+        match &self.ty.kind(Interner) {\n+            TyKind::Slice(ty) => Some(self.derived(ty.clone())),\n+            _ => None,\n+        }\n+    }\n+\n     pub fn strip_references(&self) -> Type {\n         self.derived(self.ty.strip_references().clone())\n     }"}, {"sha": "407ba6f65844e7b426450a81c4e001985b9ffa8e", "filename": "src/tools/rust-analyzer/crates/hir/src/semantics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -15,7 +15,7 @@ use hir_def::{\n     AsMacroCall, DefWithBodyId, FieldId, FunctionId, MacroId, TraitId, VariantId,\n };\n use hir_expand::{\n-    db::AstDatabase,\n+    db::ExpandDatabase,\n     name::{known, AsName},\n     ExpansionInfo, MacroCallId,\n };\n@@ -411,7 +411,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_record_field(field)\n     }\n \n-    pub fn resolve_record_pat_field(&self, field: &ast::RecordPatField) -> Option<Field> {\n+    pub fn resolve_record_pat_field(&self, field: &ast::RecordPatField) -> Option<(Field, Type)> {\n         self.imp.resolve_record_pat_field(field)\n     }\n \n@@ -1201,7 +1201,7 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(field.syntax())?.resolve_record_field(self.db, field)\n     }\n \n-    fn resolve_record_pat_field(&self, field: &ast::RecordPatField) -> Option<Field> {\n+    fn resolve_record_pat_field(&self, field: &ast::RecordPatField) -> Option<(Field, Type)> {\n         self.analyze(field.syntax())?.resolve_record_pat_field(self.db, field)\n     }\n \n@@ -1536,7 +1536,7 @@ impl<'db> SemanticsImpl<'db> {\n \n fn macro_call_to_macro_id(\n     ctx: &mut SourceToDefCtx<'_, '_>,\n-    db: &dyn AstDatabase,\n+    db: &dyn ExpandDatabase,\n     macro_call_id: MacroCallId,\n ) -> Option<MacroId> {\n     let loc = db.lookup_intern_macro_call(macro_call_id);"}, {"sha": "c24d196e1b6247857764f9898fd17c623069bdc0", "filename": "src/tools/rust-analyzer/crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -441,14 +441,17 @@ impl SourceAnalyzer {\n         &self,\n         db: &dyn HirDatabase,\n         field: &ast::RecordPatField,\n-    ) -> Option<Field> {\n+    ) -> Option<(Field, Type)> {\n         let field_name = field.field_name()?.as_name();\n         let record_pat = ast::RecordPat::cast(field.syntax().parent().and_then(|p| p.parent())?)?;\n         let pat_id = self.pat_id(&record_pat.into())?;\n         let variant = self.infer.as_ref()?.variant_resolution_for_pat(pat_id)?;\n         let variant_data = variant.variant_data(db.upcast());\n         let field = FieldId { parent: variant, local_id: variant_data.field(&field_name)? };\n-        Some(field.into())\n+        let (_, subst) = self.infer.as_ref()?.type_of_pat.get(pat_id)?.as_adt()?;\n+        let field_ty =\n+            db.field_types(variant).get(field.local_id)?.clone().substitute(Interner, subst);\n+        Some((field.into(), Type::new_with_resolver(db, &self.resolver, field_ty)))\n     }\n \n     pub(crate) fn resolve_macro_call("}, {"sha": "0768389281ca303826e574c430cf1d5a9e584158", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_function.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1027,7 +1027,7 @@ fn next_space_for_fn_after_call_site(expr: ast::CallableExpr) -> Option<Generate\n }\n \n fn next_space_for_fn_in_module(\n-    db: &dyn hir::db::AstDatabase,\n+    db: &dyn hir::db::ExpandDatabase,\n     module_source: &hir::InFile<hir::ModuleSource>,\n ) -> Option<(FileId, GeneratedFunctionTarget)> {\n     let file = module_source.file_id.original_file(db);"}, {"sha": "28d815e81b49d88d07fa3e19cac12c4f6a88b2dc", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/inline_call.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -363,10 +363,10 @@ fn inline(\n         .collect();\n \n     if function.self_param(sema.db).is_some() {\n-        let this = || make::name_ref(\"this\").syntax().clone_for_update();\n+        let this = || make::name_ref(\"this\").syntax().clone_for_update().first_token().unwrap();\n         if let Some(self_local) = params[0].2.as_local(sema.db) {\n             usages_for_locals(self_local)\n-                .flat_map(|FileReference { name, range, .. }| match name {\n+                .filter_map(|FileReference { name, range, .. }| match name {\n                     ast::NameLike::NameRef(_) => Some(body.syntax().covering_element(range)),\n                     _ => None,\n                 })\n@@ -680,6 +680,42 @@ impl Foo {\n     }\n }\n \n+fn main() {\n+    let x = {\n+        let ref this = Foo(3);\n+        Foo(this.0 + 2)\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn generic_method_by_ref() {\n+        check_assist(\n+            inline_call,\n+            r#\"\n+struct Foo(u32);\n+\n+impl Foo {\n+    fn add<T>(&self, a: u32) -> Self {\n+        Foo(self.0 + a)\n+    }\n+}\n+\n+fn main() {\n+    let x = Foo(3).add$0::<usize>(2);\n+}\n+\"#,\n+            r#\"\n+struct Foo(u32);\n+\n+impl Foo {\n+    fn add<T>(&self, a: u32) -> Self {\n+        Foo(self.0 + a)\n+    }\n+}\n+\n fn main() {\n     let x = {\n         let ref this = Foo(3);"}, {"sha": "a403d5bc672d2b9ca40e81a9fc2853e8d3a25207", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/remove_dbg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -46,7 +46,7 @@ pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<(\n     acc.add(\n         AssistId(\"remove_dbg\", AssistKind::Refactor),\n         \"Remove dbg!()\",\n-        ctx.selection_trimmed(),\n+        replacements.iter().map(|&(range, _)| range).reduce(|acc, range| acc.cover(range)).unwrap(),\n         |builder| {\n             for (range, expr) in replacements {\n                 if let Some(expr) = expr {"}, {"sha": "8b07e29a5879fba4621b53e3dd105de51b271d9f", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -265,7 +265,6 @@ mod handlers {\n             inline_local_variable::inline_local_variable,\n             inline_type_alias::inline_type_alias,\n             inline_type_alias::inline_type_alias_uses,\n-            inline_macro::inline_macro,\n             introduce_named_generic::introduce_named_generic,\n             introduce_named_lifetime::introduce_named_lifetime,\n             invert_if::invert_if,\n@@ -286,7 +285,6 @@ mod handlers {\n             raw_string::add_hash,\n             raw_string::make_usual_string,\n             raw_string::remove_hash,\n-            remove_dbg::remove_dbg,\n             remove_mut::remove_mut,\n             remove_unused_param::remove_unused_param,\n             remove_parentheses::remove_parentheses,\n@@ -335,6 +333,9 @@ mod handlers {\n             generate_setter::generate_setter,\n             generate_delegate_methods::generate_delegate_methods,\n             generate_deref::generate_deref,\n+            //\n+            remove_dbg::remove_dbg,\n+            inline_macro::inline_macro,\n             // Are you sure you want to add new assist here, and not to the\n             // sorted list above?\n         ]"}, {"sha": "c3136f6df4b391a1f6951f17491ccab6e29d9819", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -23,7 +23,7 @@ pub(crate) mod env_vars;\n \n use std::iter;\n \n-use hir::{known, ScopeDef};\n+use hir::{known, ScopeDef, Variant};\n use ide_db::{imports::import_assets::LocatedImport, SymbolKind};\n use syntax::ast;\n \n@@ -537,17 +537,20 @@ fn enum_variants_with_paths(\n     impl_: &Option<ast::Impl>,\n     cb: impl Fn(&mut Completions, &CompletionContext<'_>, hir::Variant, hir::ModPath),\n ) {\n+    let mut process_variant = |variant: Variant| {\n+        let self_path = hir::ModPath::from_segments(\n+            hir::PathKind::Plain,\n+            iter::once(known::SELF_TYPE).chain(iter::once(variant.name(ctx.db))),\n+        );\n+\n+        cb(acc, ctx, variant, self_path);\n+    };\n+\n     let variants = enum_.variants(ctx.db);\n \n     if let Some(impl_) = impl_.as_ref().and_then(|impl_| ctx.sema.to_def(impl_)) {\n         if impl_.self_ty(ctx.db).as_adt() == Some(hir::Adt::Enum(enum_)) {\n-            for &variant in &variants {\n-                let self_path = hir::ModPath::from_segments(\n-                    hir::PathKind::Plain,\n-                    iter::once(known::SELF_TYPE).chain(iter::once(variant.name(ctx.db))),\n-                );\n-                cb(acc, ctx, variant, self_path);\n-            }\n+            variants.iter().for_each(|variant| process_variant(*variant));\n         }\n     }\n "}, {"sha": "77246379e7bd98a436dbae9f598260369318f275", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/dot.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -415,7 +415,6 @@ fn foo(a: lib::A) { a.$0 }\n     fn test_local_impls() {\n         check(\n             r#\"\n-//- /lib.rs crate:lib\n pub struct A {}\n mod m {\n     impl super::A {\n@@ -427,9 +426,8 @@ mod m {\n         }\n     }\n }\n-//- /main.rs crate:main deps:lib\n-fn foo(a: lib::A) {\n-    impl lib::A {\n+fn foo(a: A) {\n+    impl A {\n         fn local_method(&self) {}\n     }\n     a.$0"}, {"sha": "8cbf89e9c301954e83b32ba23cc88179ff31e07e", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -220,6 +220,8 @@ pub(super) struct PatternContext {\n     /// The record pattern this name or ref is a field of\n     pub(super) record_pat: Option<ast::RecordPat>,\n     pub(super) impl_: Option<ast::Impl>,\n+    /// List of missing variants in a match expr\n+    pub(super) missing_variants: Vec<hir::Variant>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]"}, {"sha": "a94c404586b11b4923762ca5f5a7a0659caa7d45", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 55, "deletions": 7, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,7 +1,7 @@\n //! Module responsible for analyzing the code surrounding the cursor for completion.\n use std::iter;\n \n-use hir::{Semantics, Type, TypeInfo};\n+use hir::{Semantics, Type, TypeInfo, Variant};\n use ide_db::{active_parameter::ActiveParameter, RootDatabase};\n use syntax::{\n     algo::{find_node_at_offset, non_trivia_sibling},\n@@ -353,7 +353,7 @@ fn expected_type_and_name(\n         _ => ty,\n     };\n \n-    loop {\n+    let (ty, name) = loop {\n         break match_ast! {\n             match node {\n                 ast::LetStmt(it) => {\n@@ -385,9 +385,7 @@ fn expected_type_and_name(\n                        token.clone(),\n                     ).map(|ap| {\n                         let name = ap.ident().map(NameOrNameRef::Name);\n-\n-                        let ty = strip_refs(ap.ty);\n-                        (Some(ty), name)\n+                        (Some(ap.ty), name)\n                     })\n                     .unwrap_or((None, None))\n                 },\n@@ -489,7 +487,8 @@ fn expected_type_and_name(\n                 },\n             }\n         };\n-    }\n+    };\n+    (ty.map(strip_refs), name)\n }\n \n fn classify_lifetime(\n@@ -1133,6 +1132,9 @@ fn pattern_context_for(\n     pat: ast::Pat,\n ) -> PatternContext {\n     let mut param_ctx = None;\n+\n+    let mut missing_variants = vec![];\n+\n     let (refutability, has_type_ascription) =\n     pat\n         .syntax()\n@@ -1162,7 +1164,52 @@ fn pattern_context_for(\n                         })();\n                         return (PatternRefutability::Irrefutable, has_type_ascription)\n                     },\n-                    ast::MatchArm(_) => PatternRefutability::Refutable,\n+                    ast::MatchArm(match_arm) => {\n+                       let missing_variants_opt = match_arm\n+                            .syntax()\n+                            .parent()\n+                            .and_then(ast::MatchArmList::cast)\n+                            .and_then(|match_arm_list| {\n+                                match_arm_list\n+                                .syntax()\n+                                .parent()\n+                                .and_then(ast::MatchExpr::cast)\n+                                .and_then(|match_expr| {\n+                                    let expr_opt = find_opt_node_in_file(&original_file, match_expr.expr());\n+\n+                                    expr_opt.and_then(|expr| {\n+                                        sema.type_of_expr(&expr)?\n+                                        .adjusted()\n+                                        .autoderef(sema.db)\n+                                        .find_map(|ty| match ty.as_adt() {\n+                                            Some(hir::Adt::Enum(e)) => Some(e),\n+                                            _ => None,\n+                                        }).and_then(|enum_| {\n+                                            Some(enum_.variants(sema.db))\n+                                        })\n+                                    })\n+                                }).and_then(|variants| {\n+                                   Some(variants.iter().filter_map(|variant| {\n+                                        let variant_name = variant.name(sema.db).to_string();\n+\n+                                        let variant_already_present = match_arm_list.arms().any(|arm| {\n+                                            arm.pat().and_then(|pat| {\n+                                                let pat_already_present = pat.syntax().to_string().contains(&variant_name);\n+                                                pat_already_present.then(|| pat_already_present)\n+                                            }).is_some()\n+                                        });\n+\n+                                        (!variant_already_present).then_some(variant.clone())\n+                                    }).collect::<Vec<Variant>>())\n+                                })\n+                        });\n+\n+                        if let Some(missing_variants_) = missing_variants_opt {\n+                            missing_variants = missing_variants_;\n+                        };\n+\n+                        PatternRefutability::Refutable\n+                    },\n                     ast::LetExpr(_) => PatternRefutability::Refutable,\n                     ast::ForExpr(_) => PatternRefutability::Irrefutable,\n                     _ => PatternRefutability::Irrefutable,\n@@ -1184,6 +1231,7 @@ fn pattern_context_for(\n         ref_token,\n         record_pat: None,\n         impl_: fetch_immediate_impl(sema, original_file, pat.syntax()),\n+        missing_variants,\n     }\n }\n "}, {"sha": "82a1c10c5314f2a6661d8ee56b96677b85ed586e", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context/tests.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -411,3 +411,15 @@ fn main() {\n         expect![\"ty: i32, name: ?\"],\n     );\n }\n+\n+#[test]\n+fn expected_type_ref_return_pos() {\n+    check_expected_type_and_name(\n+        r#\"\n+fn f(thing: u32) -> &u32 {\n+    &thin$0\n+}\n+\"#,\n+        expect![\"ty: u32, name: ?\"],\n+    );\n+}"}, {"sha": "9225c91bebf51897c871798075457def5d4c780d", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/pattern.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -37,7 +37,9 @@ pub(crate) fn render_struct_pat(\n     let lookup = format_literal_lookup(name.as_str(), kind);\n     let pat = render_pat(&ctx, pattern_ctx, &escaped_name, kind, &visible_fields, fields_omitted)?;\n \n-    Some(build_completion(ctx, label, lookup, pat, strukt))\n+    let db = ctx.db();\n+\n+    Some(build_completion(ctx, label, lookup, pat, strukt, strukt.ty(db), false))\n }\n \n pub(crate) fn render_variant_pat(\n@@ -52,6 +54,7 @@ pub(crate) fn render_variant_pat(\n \n     let fields = variant.fields(ctx.db());\n     let (visible_fields, fields_omitted) = visible_fields(ctx.completion, &fields, variant)?;\n+    let enum_ty = variant.parent_enum(ctx.db()).ty(ctx.db());\n \n     let (name, escaped_name) = match path {\n         Some(path) => (path.unescaped().to_string().into(), path.to_string().into()),\n@@ -81,7 +84,15 @@ pub(crate) fn render_variant_pat(\n         }\n     };\n \n-    Some(build_completion(ctx, label, lookup, pat, variant))\n+    Some(build_completion(\n+        ctx,\n+        label,\n+        lookup,\n+        pat,\n+        variant,\n+        enum_ty,\n+        pattern_ctx.missing_variants.contains(&variant),\n+    ))\n }\n \n fn build_completion(\n@@ -90,13 +101,22 @@ fn build_completion(\n     lookup: SmolStr,\n     pat: String,\n     def: impl HasAttrs + Copy,\n+    adt_ty: hir::Type,\n+    // Missing in context of match statement completions\n+    is_variant_missing: bool,\n ) -> CompletionItem {\n+    let mut relevance = ctx.completion_relevance();\n+\n+    if is_variant_missing {\n+        relevance.type_match = super::compute_type_match(ctx.completion, &adt_ty);\n+    }\n+\n     let mut item = CompletionItem::new(CompletionItemKind::Binding, ctx.source_range(), label);\n     item.set_documentation(ctx.docs(def))\n         .set_deprecated(ctx.is_deprecated(def))\n         .detail(&pat)\n         .lookup_by(lookup)\n-        .set_relevance(ctx.completion_relevance());\n+        .set_relevance(relevance);\n     match ctx.snippet_cap() {\n         Some(snippet_cap) => item.insert_snippet(snippet_cap, pat),\n         None => item.insert_text(pat),"}, {"sha": "c0e485c36fdd11c13aaabc2e92b4d13e4abfb8bf", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/pattern.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -614,6 +614,7 @@ fn f(u: U) {\n \n     check_empty(\n         r#\"\n+#![rustc_coherence_is_core]\n #[lang = \"u32\"]\n impl u32 {\n     pub const MIN: Self = 0;"}, {"sha": "65cefdb0856d214106fba77f20b26118bfb42fe7", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/record.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Frecord.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -46,6 +46,66 @@ fn foo(s: Struct) {\n     );\n }\n \n+#[test]\n+fn record_pattern_field_enum() {\n+    check(\n+        r#\"\n+//- minicore:result\n+enum Baz { Foo, Bar }\n+\n+fn foo(baz: Baz) {\n+    match baz {\n+        Baz::Foo => (),\n+        $0\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            en Baz\n+            en Result\n+            md core\n+            ev Err\n+            ev Ok\n+            bn Baz::Bar Baz::Bar$0\n+            bn Baz::Foo Baz::Foo$0\n+            bn Err(\u2026)   Err($1)$0\n+            bn Ok(\u2026)    Ok($1)$0\n+            kw mut\n+            kw ref\n+        \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+//- minicore:result\n+enum Baz { Foo, Bar }\n+\n+fn foo(baz: Baz) {\n+    use Baz::*;\n+    match baz {\n+        Foo => (),\n+        $0\n+    }\n+}\n+ \"#,\n+        expect![[r#\"\n+         en Baz\n+         en Result\n+         md core\n+         ev Bar\n+         ev Err\n+         ev Foo\n+         ev Ok\n+         bn Bar    Bar$0\n+         bn Err(\u2026) Err($1)$0\n+         bn Foo    Foo$0\n+         bn Ok(\u2026)  Ok($1)$0\n+         kw mut\n+         kw ref\n+         \"#]],\n+    );\n+}\n+\n #[test]\n fn pattern_enum_variant() {\n     check("}, {"sha": "f8a6f6cd3ed065824f3943ca13aaefbf8c92ced8", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/special.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -608,6 +608,7 @@ fn f() {\n }\n \n //- /core.rs crate:core\n+#![rustc_coherence_is_core]\n #[lang = \"u8\"]\n impl u8 {\n     pub const MAX: Self = 255;"}, {"sha": "ea1d9cc4919d37648b94df09f628eadc08dacc48", "filename": "src/tools/rust-analyzer/crates/ide-db/src/apply_change.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fapply_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fapply_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fapply_change.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -71,7 +71,7 @@ impl RootDatabase {\n             base_db::SourceRootQuery\n             base_db::SourceRootCratesQuery\n \n-            // AstDatabase\n+            // ExpandDatabase\n             hir::db::AstIdMapQuery\n             hir::db::ParseMacroExpansionQuery\n             hir::db::InternMacroCallQuery"}, {"sha": "4071c490b7fc39546812ad04375c17b292305f54", "filename": "src/tools/rust-analyzer/crates/ide-db/src/defs.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fdefs.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -327,7 +327,7 @@ impl NameClass {\n             let pat_parent = ident_pat.syntax().parent();\n             if let Some(record_pat_field) = pat_parent.and_then(ast::RecordPatField::cast) {\n                 if record_pat_field.name_ref().is_none() {\n-                    if let Some(field) = sema.resolve_record_pat_field(&record_pat_field) {\n+                    if let Some((field, _)) = sema.resolve_record_pat_field(&record_pat_field) {\n                         return Some(NameClass::PatFieldShorthand {\n                             local_def: local,\n                             field_ref: field,\n@@ -483,6 +483,13 @@ impl NameRefClass {\n                 },\n                 ast::RecordPatField(record_pat_field) => {\n                     sema.resolve_record_pat_field(&record_pat_field)\n+                        .map(|(field, ..)|field)\n+                        .map(Definition::Field)\n+                        .map(NameRefClass::Definition)\n+                },\n+                ast::RecordExprField(record_expr_field) => {\n+                    sema.resolve_record_field(&record_expr_field)\n+                        .map(|(field, ..)|field)\n                         .map(Definition::Field)\n                         .map(NameRefClass::Definition)\n                 },"}, {"sha": "b1df11bf911722433036e1aa9e5c71f831337228", "filename": "src/tools/rust-analyzer/crates/ide-db/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Flib.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -50,7 +50,7 @@ use base_db::{\n     AnchoredPath, CrateId, FileId, FileLoader, FileLoaderDelegate, SourceDatabase, Upcast,\n };\n use hir::{\n-    db::{AstDatabase, DefDatabase, HirDatabase},\n+    db::{DefDatabase, ExpandDatabase, HirDatabase},\n     symbols::FileSymbolKind,\n };\n use stdx::hash::NoHashHashSet;\n@@ -68,7 +68,7 @@ pub type FxIndexMap<K, V> =\n #[salsa::database(\n     base_db::SourceDatabaseExtStorage,\n     base_db::SourceDatabaseStorage,\n-    hir::db::AstDatabaseStorage,\n+    hir::db::ExpandDatabaseStorage,\n     hir::db::DefDatabaseStorage,\n     hir::db::HirDatabaseStorage,\n     hir::db::InternDatabaseStorage,\n@@ -95,8 +95,8 @@ impl fmt::Debug for RootDatabase {\n     }\n }\n \n-impl Upcast<dyn AstDatabase> for RootDatabase {\n-    fn upcast(&self) -> &(dyn AstDatabase + 'static) {\n+impl Upcast<dyn ExpandDatabase> for RootDatabase {\n+    fn upcast(&self) -> &(dyn ExpandDatabase + 'static) {\n         &*self\n     }\n }"}, {"sha": "72af9ebfcbb62e48a6c110bfaa5bbcca21b2b2cc", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/incoherent_impl.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincoherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincoherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincoherent_impl.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,77 @@\n+use hir::InFile;\n+\n+use crate::{Diagnostic, DiagnosticsContext, Severity};\n+\n+// Diagnostic: incoherent-impl\n+//\n+// This diagnostic is triggered if the targe type of an impl is from a foreign crate.\n+pub(crate) fn incoherent_impl(ctx: &DiagnosticsContext<'_>, d: &hir::IncoherentImpl) -> Diagnostic {\n+    Diagnostic::new(\n+        \"incoherent-impl\",\n+        format!(\"cannot define inherent `impl` for foreign type\"),\n+        ctx.sema.diagnostics_display_range(InFile::new(d.file_id, d.impl_.clone().into())).range,\n+    )\n+    .severity(Severity::Error)\n+}\n+\n+#[cfg(test)]\n+mod change_case {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn primitive() {\n+        check_diagnostics(\n+            r#\"\n+  impl bool {}\n+//^^^^^^^^^^^^ error: cannot define inherent `impl` for foreign type\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn primitive_rustc_allow_incoherent_impl() {\n+        check_diagnostics(\n+            r#\"\n+impl bool {\n+    #[rustc_allow_incoherent_impl]\n+    fn falsch(self) -> Self { false }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn rustc_allow_incoherent_impl() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo\n+#[rustc_has_incoherent_inherent_impls]\n+pub struct S;\n+//- /main.rs crate:main deps:foo\n+impl foo::S {\n+    #[rustc_allow_incoherent_impl]\n+    fn func(self) {}\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo\n+pub struct S;\n+//- /main.rs crate:main deps:foo\n+  impl foo::S { #[rustc_allow_incoherent_impl] fn func(self) {} }\n+//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ error: cannot define inherent `impl` for foreign type\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo\n+#[rustc_has_incoherent_inherent_impls]\n+pub struct S;\n+//- /main.rs crate:main deps:foo\n+  impl foo::S { fn func(self) {} }\n+//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ error: cannot define inherent `impl` for foreign type\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "db88bf7b9313dad008a423c3f7c134b24b6dde4e", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/incorrect_case.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincorrect_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincorrect_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincorrect_case.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,4 +1,4 @@\n-use hir::{db::AstDatabase, InFile};\n+use hir::{db::ExpandDatabase, InFile};\n use ide_db::{assists::Assist, defs::NameClass};\n use syntax::AstNode;\n "}, {"sha": "5c4327ff93413b17af3ac26c7191c82218f0e8b3", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/missing_fields.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,6 +1,6 @@\n use either::Either;\n use hir::{\n-    db::{AstDatabase, HirDatabase},\n+    db::{ExpandDatabase, HirDatabase},\n     known, AssocItem, HirDisplay, InFile, Type,\n };\n use ide_db::{"}, {"sha": "eb32db250656c1dac5deb0563d3c7146b9f85d18", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/missing_unsafe.rs", "status": "modified", "additions": 374, "deletions": 7, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,4 +1,10 @@\n-use crate::{Diagnostic, DiagnosticsContext};\n+use hir::db::ExpandDatabase;\n+use ide_db::{assists::Assist, source_change::SourceChange};\n+use syntax::{ast, SyntaxNode};\n+use syntax::{match_ast, AstNode};\n+use text_edit::TextEdit;\n+\n+use crate::{fix, Diagnostic, DiagnosticsContext};\n \n // Diagnostic: missing-unsafe\n //\n@@ -9,11 +15,83 @@ pub(crate) fn missing_unsafe(ctx: &DiagnosticsContext<'_>, d: &hir::MissingUnsaf\n         \"this operation is unsafe and requires an unsafe function or block\",\n         ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n     )\n+    .with_fixes(fixes(ctx, d))\n+}\n+\n+fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingUnsafe) -> Option<Vec<Assist>> {\n+    // The fixit will not work correctly for macro expansions, so we don't offer it in that case.\n+    if d.expr.file_id.is_macro() {\n+        return None;\n+    }\n+\n+    let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n+    let expr = d.expr.value.to_node(&root);\n+\n+    let node_to_add_unsafe_block = pick_best_node_to_add_unsafe_block(&expr)?;\n+\n+    let replacement = format!(\"unsafe {{ {} }}\", node_to_add_unsafe_block.text());\n+    let edit = TextEdit::replace(node_to_add_unsafe_block.text_range(), replacement);\n+    let source_change =\n+        SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), edit);\n+    Some(vec![fix(\"add_unsafe\", \"Add unsafe block\", source_change, expr.syntax().text_range())])\n+}\n+\n+// Pick the first ancestor expression of the unsafe `expr` that is not a\n+// receiver of a method call, a field access, the left-hand side of an\n+// assignment, or a reference. As all of those cases would incur a forced move\n+// if wrapped which might not be wanted. That is:\n+// - `unsafe_expr.foo` -> `unsafe { unsafe_expr.foo }`\n+// - `unsafe_expr.foo.bar` -> `unsafe { unsafe_expr.foo.bar }`\n+// - `unsafe_expr.foo()` -> `unsafe { unsafe_expr.foo() }`\n+// - `unsafe_expr.foo.bar()` -> `unsafe { unsafe_expr.foo.bar() }`\n+// - `unsafe_expr += 1` -> `unsafe { unsafe_expr += 1 }`\n+// - `&unsafe_expr` -> `unsafe { &unsafe_expr }`\n+// - `&&unsafe_expr` -> `unsafe { &&unsafe_expr }`\n+fn pick_best_node_to_add_unsafe_block(unsafe_expr: &ast::Expr) -> Option<SyntaxNode> {\n+    // The `unsafe_expr` might be:\n+    // - `ast::CallExpr`: call an unsafe function\n+    // - `ast::MethodCallExpr`: call an unsafe method\n+    // - `ast::PrefixExpr`: dereference a raw pointer\n+    // - `ast::PathExpr`: access a static mut variable\n+    for (node, parent) in\n+        unsafe_expr.syntax().ancestors().zip(unsafe_expr.syntax().ancestors().skip(1))\n+    {\n+        match_ast! {\n+            match parent {\n+                // If the `parent` is a `MethodCallExpr`, that means the `node`\n+                // is the receiver of the method call, because only the receiver\n+                // can be a direct child of a method call. The method name\n+                // itself is not an expression but a `NameRef`, and an argument\n+                // is a direct child of an `ArgList`.\n+                ast::MethodCallExpr(_) => continue,\n+                ast::FieldExpr(_) => continue,\n+                ast::RefExpr(_) => continue,\n+                ast::BinExpr(it) => {\n+                    // Check if the `node` is the left-hand side of an\n+                    // assignment, if so, we don't want to wrap it in an unsafe\n+                    // block, e.g. `unsafe_expr += 1`\n+                    let is_left_hand_side_of_assignment = {\n+                        if let Some(ast::BinaryOp::Assignment { .. }) = it.op_kind() {\n+                            it.lhs().map(|lhs| lhs.syntax().text_range().contains_range(node.text_range())).unwrap_or(false)\n+                        } else {\n+                            false\n+                        }\n+                    };\n+                    if !is_left_hand_side_of_assignment {\n+                        return Some(node);\n+                    }\n+                },\n+                _ => { return Some(node); }\n+\n+            }\n+        }\n+    }\n+    None\n }\n \n #[cfg(test)]\n mod tests {\n-    use crate::tests::check_diagnostics;\n+    use crate::tests::{check_diagnostics, check_fix, check_no_fix};\n \n     #[test]\n     fn missing_unsafe_diagnostic_with_raw_ptr() {\n@@ -23,7 +101,7 @@ fn main() {\n     let x = &5 as *const usize;\n     unsafe { let y = *x; }\n     let z = *x;\n-}         //^^ error: this operation is unsafe and requires an unsafe function or block\n+}         //^^\ud83d\udca1 error: this operation is unsafe and requires an unsafe function or block\n \"#,\n         )\n     }\n@@ -48,9 +126,9 @@ unsafe fn unsafe_fn() {\n \n fn main() {\n     unsafe_fn();\n-  //^^^^^^^^^^^ error: this operation is unsafe and requires an unsafe function or block\n+  //^^^^^^^^^^^\ud83d\udca1 error: this operation is unsafe and requires an unsafe function or block\n     HasUnsafe.unsafe_fn();\n-  //^^^^^^^^^^^^^^^^^^^^^ error: this operation is unsafe and requires an unsafe function or block\n+  //^^^^^^^^^^^^^^^^^^^^^\ud83d\udca1 error: this operation is unsafe and requires an unsafe function or block\n     unsafe {\n         unsafe_fn();\n         HasUnsafe.unsafe_fn();\n@@ -72,7 +150,7 @@ static mut STATIC_MUT: Ty = Ty { a: 0 };\n \n fn main() {\n     let x = STATIC_MUT.a;\n-          //^^^^^^^^^^ error: this operation is unsafe and requires an unsafe function or block\n+          //^^^^^^^^^^\ud83d\udca1 error: this operation is unsafe and requires an unsafe function or block\n     unsafe {\n         let x = STATIC_MUT.a;\n     }\n@@ -94,9 +172,298 @@ extern \"rust-intrinsic\" {\n fn main() {\n     let _ = bitreverse(12);\n     let _ = floorf32(12.0);\n-          //^^^^^^^^^^^^^^ error: this operation is unsafe and requires an unsafe function or block\n+          //^^^^^^^^^^^^^^\ud83d\udca1 error: this operation is unsafe and requires an unsafe function or block\n }\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn add_unsafe_block_when_dereferencing_a_raw_pointer() {\n+        check_fix(\n+            r#\"\n+fn main() {\n+    let x = &5 as *const usize;\n+    let z = *x$0;\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    let x = &5 as *const usize;\n+    let z = unsafe { *x };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_unsafe_block_when_calling_unsafe_function() {\n+        check_fix(\n+            r#\"\n+unsafe fn func() {\n+    let x = &5 as *const usize;\n+    let z = *x;\n+}\n+fn main() {\n+    func$0();\n+}\n+\"#,\n+            r#\"\n+unsafe fn func() {\n+    let x = &5 as *const usize;\n+    let z = *x;\n+}\n+fn main() {\n+    unsafe { func() };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_unsafe_block_when_calling_unsafe_method() {\n+        check_fix(\n+            r#\"\n+struct S(usize);\n+impl S {\n+    unsafe fn func(&self) {\n+        let x = &self.0 as *const usize;\n+        let z = *x;\n+    }\n+}\n+fn main() {\n+    let s = S(5);\n+    s.func$0();\n+}\n+\"#,\n+            r#\"\n+struct S(usize);\n+impl S {\n+    unsafe fn func(&self) {\n+        let x = &self.0 as *const usize;\n+        let z = *x;\n+    }\n+}\n+fn main() {\n+    let s = S(5);\n+    unsafe { s.func() };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_unsafe_block_when_accessing_mutable_static() {\n+        check_fix(\n+            r#\"\n+struct Ty {\n+    a: u8,\n+}\n+\n+static mut STATIC_MUT: Ty = Ty { a: 0 };\n+\n+fn main() {\n+    let x = STATIC_MUT$0.a;\n+}\n+\"#,\n+            r#\"\n+struct Ty {\n+    a: u8,\n+}\n+\n+static mut STATIC_MUT: Ty = Ty { a: 0 };\n+\n+fn main() {\n+    let x = unsafe { STATIC_MUT.a };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_unsafe_block_when_calling_unsafe_intrinsic() {\n+        check_fix(\n+            r#\"\n+extern \"rust-intrinsic\" {\n+    pub fn floorf32(x: f32) -> f32;\n+}\n+\n+fn main() {\n+    let _ = floorf32$0(12.0);\n+}\n+\"#,\n+            r#\"\n+extern \"rust-intrinsic\" {\n+    pub fn floorf32(x: f32) -> f32;\n+}\n+\n+fn main() {\n+    let _ = unsafe { floorf32(12.0) };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_as_a_receiver_of_a_method_call() {\n+        check_fix(\n+            r#\"\n+unsafe fn foo() -> String {\n+    \"string\".to_string()\n+}\n+\n+fn main() {\n+    foo$0().len();\n+}\n+\"#,\n+            r#\"\n+unsafe fn foo() -> String {\n+    \"string\".to_string()\n+}\n+\n+fn main() {\n+    unsafe { foo().len() };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_as_an_argument_of_a_method_call() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let mut v = vec![];\n+    v.push(STATIC_MUT$0);\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let mut v = vec![];\n+    v.push(unsafe { STATIC_MUT });\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_as_left_hand_side_of_assignment() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    STATIC_MUT$0 = 1;\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    unsafe { STATIC_MUT = 1 };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_as_right_hand_side_of_assignment() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x;\n+    x = STATIC_MUT$0;\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x;\n+    x = unsafe { STATIC_MUT };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_in_binary_plus() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = STATIC_MUT$0 + 1;\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = unsafe { STATIC_MUT } + 1;\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn ref_to_unsafe_expr() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = &STATIC_MUT$0;\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = unsafe { &STATIC_MUT };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn ref_ref_to_unsafe_expr() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = &&STATIC_MUT$0;\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = unsafe { &&STATIC_MUT };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_in_macro_call() {\n+        check_no_fix(\n+            r#\"\n+unsafe fn foo() -> u8 {\n+    0\n+}\n+\n+fn main() {\n+    let x = format!(\"foo: {}\", foo$0());\n+}\n+            \"#,\n+        )\n+    }\n }"}, {"sha": "96470265d11d1f67644f8782b0060474308c5d7f", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -505,6 +505,30 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn initialization_is_not_mutation_in_loop() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let a;\n+    loop {\n+        let c @ (\n+            mut b,\n+          //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+            mut d\n+          //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+        );\n+        a = 1;\n+      //^^^^^ \ud83d\udca1 error: cannot mutate immutable variable `a`\n+        b = 1;\n+        c = (2, 3);\n+        d = 3;\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn function_arguments_are_initialized() {\n         check_diagnostics("}, {"sha": "24c521ed1a8a41827b23726b90046e90a9de39a9", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/no_such_field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,4 +1,4 @@\n-use hir::{db::AstDatabase, HasSource, HirDisplay, Semantics};\n+use hir::{db::ExpandDatabase, HasSource, HirDisplay, Semantics};\n use ide_db::{base_db::FileId, source_change::SourceChange, RootDatabase};\n use syntax::{\n     ast::{self, edit::IndentLevel, make},"}, {"sha": "be83ad6aaadaaef139df7b08fb593a8ca8f83167", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/private_field.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_field.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -62,6 +62,26 @@ mod module {\n fn main(s: module::Struct) {\n     s.field;\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn block_module_madness() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    let strukt = {\n+        use crate as ForceParentBlockDefMap;\n+        {\n+            pub struct Struct {\n+                field: (),\n+            }\n+            Struct { field: () }\n+        }\n+    };\n+    strukt.field;\n+}\n \"#,\n         );\n     }"}, {"sha": "9b1c65983e615fd18b55d6380dfb090a16484231", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/replace_filter_map_next_with_find_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,4 +1,4 @@\n-use hir::{db::AstDatabase, InFile};\n+use hir::{db::ExpandDatabase, InFile};\n use ide_db::source_change::SourceChange;\n use syntax::{\n     ast::{self, HasArgList},"}, {"sha": "4abc25a28fbc040f4130899ae0bcf7f9d8af17da", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/type_mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,5 +1,5 @@\n use either::Either;\n-use hir::{db::AstDatabase, HirDisplay, InFile, Type};\n+use hir::{db::ExpandDatabase, HirDisplay, InFile, Type};\n use ide_db::{famous_defs::FamousDefs, source_change::SourceChange};\n use syntax::{\n     ast::{self, BlockExpr, ExprStmt},"}, {"sha": "cefa74e523e8f13a37d206e18700ff779f9fab8d", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/unresolved_field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_field.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,4 +1,4 @@\n-use hir::{db::AstDatabase, HirDisplay, InFile};\n+use hir::{db::ExpandDatabase, HirDisplay, InFile};\n use ide_db::{\n     assists::{Assist, AssistId, AssistKind},\n     base_db::FileRange,"}, {"sha": "f3ec6efa75215c9c132d4935420047057226ed70", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/unresolved_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_method.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,4 +1,4 @@\n-use hir::{db::AstDatabase, HirDisplay};\n+use hir::{db::ExpandDatabase, HirDisplay};\n use ide_db::{\n     assists::{Assist, AssistId, AssistKind},\n     base_db::FileRange,"}, {"sha": "94614f11c33497d65733dbf306be3d65f5918ebd", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/unresolved_module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_module.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,4 +1,4 @@\n-use hir::db::AstDatabase;\n+use hir::db::ExpandDatabase;\n use ide_db::{assists::Assist, base_db::AnchoredPathBuf, source_change::FileSystemEdit};\n use itertools::Itertools;\n use syntax::AstNode;"}, {"sha": "71f136b8c9030c0e85f9de909eb11b18368496e7", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -29,6 +29,7 @@ mod handlers {\n     pub(crate) mod break_outside_of_loop;\n     pub(crate) mod expected_function;\n     pub(crate) mod inactive_code;\n+    pub(crate) mod incoherent_impl;\n     pub(crate) mod incorrect_case;\n     pub(crate) mod invalid_derive_target;\n     pub(crate) mod macro_error;\n@@ -254,6 +255,7 @@ pub fn diagnostics(\n             AnyDiagnostic::BreakOutsideOfLoop(d) => handlers::break_outside_of_loop::break_outside_of_loop(&ctx, &d),\n             AnyDiagnostic::ExpectedFunction(d) => handlers::expected_function::expected_function(&ctx, &d),\n             AnyDiagnostic::IncorrectCase(d) => handlers::incorrect_case::incorrect_case(&ctx, &d),\n+            AnyDiagnostic::IncoherentImpl(d) => handlers::incoherent_impl::incoherent_impl(&ctx, &d),\n             AnyDiagnostic::MacroError(d) => handlers::macro_error::macro_error(&ctx, &d),\n             AnyDiagnostic::MalformedDerive(d) => handlers::malformed_derive::malformed_derive(&ctx, &d),\n             AnyDiagnostic::MismatchedArgCount(d) => handlers::mismatched_arg_count::mismatched_arg_count(&ctx, &d),"}, {"sha": "a1a119629a94e43b814b95efb59ff7a0160bc123", "filename": "src/tools/rust-analyzer/crates/ide/src/goto_implementation.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_implementation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_implementation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_implementation.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -297,6 +297,7 @@ impl Foo<str> {}\n //- /lib.rs crate:main deps:core\n fn foo(_: bool$0) {{}}\n //- /libcore.rs crate:core\n+#![rustc_coherence_is_core]\n #[lang = \"bool\"]\n impl bool {}\n    //^^^^"}, {"sha": "6d2d0bd635165b2bba55a7ff4fccd6b74fbe03d4", "filename": "src/tools/rust-analyzer/crates/ide/src/goto_type_definition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_type_definition.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -55,7 +55,7 @@ pub(crate) fn goto_type_definition(\n                                 ty\n                             } else {\n                                 let record_field = ast::RecordPatField::for_field_name_ref(&it)?;\n-                                sema.resolve_record_pat_field(&record_field)?.ty(db)\n+                                sema.resolve_record_pat_field(&record_field)?.1\n                             }\n                         },\n                         _ => return None,"}, {"sha": "46505b30441090bff30d9bbd36865209c482a1f5", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/adjustment.rs", "status": "modified", "additions": 36, "deletions": 10, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -31,19 +31,31 @@ pub(super) fn hints(\n         return None;\n     }\n \n-    // These inherit from the inner expression which would result in duplicate hints\n-    if let ast::Expr::ParenExpr(_)\n-    | ast::Expr::IfExpr(_)\n-    | ast::Expr::BlockExpr(_)\n-    | ast::Expr::MatchExpr(_) = expr\n-    {\n+    // ParenExpr resolve to their contained expressions HIR so they will dupe these hints\n+    if let ast::Expr::ParenExpr(_) = expr {\n         return None;\n     }\n+    if let ast::Expr::BlockExpr(b) = expr {\n+        if !b.is_standalone() {\n+            return None;\n+        }\n+    }\n \n     let descended = sema.descend_node_into_attributes(expr.clone()).pop();\n     let desc_expr = descended.as_ref().unwrap_or(expr);\n     let adjustments = sema.expr_adjustments(desc_expr).filter(|it| !it.is_empty())?;\n \n+    if let ast::Expr::BlockExpr(_) | ast::Expr::IfExpr(_) | ast::Expr::MatchExpr(_) = desc_expr {\n+        if let [Adjustment { kind: Adjust::Deref(_), source, .. }, Adjustment { kind: Adjust::Borrow(_), source: _, target }] =\n+            &*adjustments\n+        {\n+            // Don't show unnecessary reborrows for these, they will just repeat the inner ones again\n+            if source == target {\n+                return None;\n+            }\n+        }\n+    }\n+\n     let (postfix, needs_outer_parens, needs_inner_parens) =\n         mode_and_needs_parens_for_adjustment_hints(expr, config.adjustment_hints_mode);\n \n@@ -67,6 +79,7 @@ pub(super) fn hints(\n \n     for Adjustment { source, target, kind } in iter {\n         if source == target {\n+            cov_mark::hit!(same_type_adjustment);\n             continue;\n         }\n \n@@ -251,7 +264,7 @@ mod tests {\n         check_with_config(\n             InlayHintsConfig { adjustment_hints: AdjustmentHints::Always, ..DISABLED_CONFIG },\n             r#\"\n-//- minicore: coerce_unsized, fn\n+//- minicore: coerce_unsized, fn, eq\n fn main() {\n     let _: u32         = loop {};\n                        //^^^^^^^<never-to-any>\n@@ -332,7 +345,7 @@ fn main() {\n         loop {}\n       //^^^^^^^<never-to-any>\n     };\n-    let _: &mut [u32] = match () { () => &mut [] }\n+    let _: &mut [u32] = match () { () => &mut [] };\n                                        //^^^^^^^<unsize>\n                                        //^^^^^^^&mut $\n                                        //^^^^^^^*\n@@ -341,6 +354,12 @@ fn main() {\n                          //^^^^^^^^^^<unsize>\n                          //^^^^^^^^^^&mut $\n                          //^^^^^^^^^^*\n+    () == ();\n+ // ^^&\n+       // ^^&\n+    (()) == {()};\n+  // ^^&\n+         // ^^^^&\n }\n \n #[derive(Copy, Clone)]\n@@ -363,7 +382,7 @@ impl Struct {\n                 ..DISABLED_CONFIG\n             },\n             r#\"\n-//- minicore: coerce_unsized, fn\n+//- minicore: coerce_unsized, fn, eq\n fn main() {\n \n     Struct.consume();\n@@ -419,7 +438,7 @@ fn main() {\n         loop {}\n       //^^^^^^^.<never-to-any>\n     };\n-    let _: &mut [u32] = match () { () => &mut [] }\n+    let _: &mut [u32] = match () { () => &mut [] };\n                                        //^^^^^^^(\n                                        //^^^^^^^)\n                                        //^^^^^^^.*\n@@ -432,6 +451,12 @@ fn main() {\n                          //^^^^^^^^^^.*\n                          //^^^^^^^^^^.&mut\n                          //^^^^^^^^^^.<unsize>\n+    () == ();\n+ // ^^.&\n+       // ^^.&\n+    (()) == {()};\n+  // ^^.&\n+         // ^^^^.&\n }\n \n #[derive(Copy, Clone)]\n@@ -499,6 +524,7 @@ fn main() {\n \n     #[test]\n     fn never_to_never_is_never_shown() {\n+        cov_mark::check!(same_type_adjustment);\n         check_with_config(\n             InlayHintsConfig { adjustment_hints: AdjustmentHints::Always, ..DISABLED_CONFIG },\n             r#\""}, {"sha": "1e1771259b1ba624101e1b911886ce3b5e2c7518", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/chaining.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -435,7 +435,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3386..3394,\n+                                        range: 3415..3423,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -448,7 +448,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3418..3422,\n+                                        range: 3447..3451,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -468,7 +468,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3386..3394,\n+                                        range: 3415..3423,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -481,7 +481,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3418..3422,\n+                                        range: 3447..3451,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -501,7 +501,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3386..3394,\n+                                        range: 3415..3423,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -514,7 +514,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3418..3422,\n+                                        range: 3447..3451,\n                                     },\n                                 ),\n                                 tooltip: \"\","}, {"sha": "4b2c139f6f455b3f8fa5ad462c6343d5d9faaeed", "filename": "src/tools/rust-analyzer/crates/ide/src/signature_help.rs", "status": "modified", "additions": 257, "deletions": 6, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -16,7 +16,7 @@ use stdx::format_to;\n use syntax::{\n     algo,\n     ast::{self, HasArgList},\n-    match_ast, AstNode, Direction, SyntaxToken, TextRange, TextSize,\n+    match_ast, AstNode, Direction, SyntaxElementChildren, SyntaxToken, TextRange, TextSize,\n };\n \n use crate::RootDatabase;\n@@ -102,6 +102,20 @@ pub(crate) fn signature_help(db: &RootDatabase, position: FilePosition) -> Optio\n                     }\n                     return signature_help_for_record_lit(&sema, record, token);\n                 },\n+                ast::RecordPat(record) => {\n+                    let cursor_outside = record.record_pat_field_list().and_then(|list| list.r_curly_token()).as_ref() == Some(&token);\n+                    if cursor_outside {\n+                        continue;\n+                    }\n+                    return signature_help_for_record_pat(&sema, record, token);\n+                },\n+                ast::TupleStructPat(tuple_pat) => {\n+                    let cursor_outside = tuple_pat.r_paren_token().as_ref() == Some(&token);\n+                    if cursor_outside {\n+                        continue;\n+                    }\n+                    return signature_help_for_tuple_struct_pat(&sema, tuple_pat, token);\n+                },\n                 _ => (),\n             }\n         }\n@@ -346,10 +360,111 @@ fn signature_help_for_record_lit(\n     record: ast::RecordExpr,\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n-    let active_parameter = record\n-        .record_expr_field_list()?\n+    signature_help_for_record_(\n+        sema,\n+        record.record_expr_field_list()?.syntax().children_with_tokens(),\n+        &record.path()?,\n+        record\n+            .record_expr_field_list()?\n+            .fields()\n+            .filter_map(|field| sema.resolve_record_field(&field))\n+            .map(|(field, _, ty)| (field, ty)),\n+        token,\n+    )\n+}\n+\n+fn signature_help_for_record_pat(\n+    sema: &Semantics<'_, RootDatabase>,\n+    record: ast::RecordPat,\n+    token: SyntaxToken,\n+) -> Option<SignatureHelp> {\n+    signature_help_for_record_(\n+        sema,\n+        record.record_pat_field_list()?.syntax().children_with_tokens(),\n+        &record.path()?,\n+        record\n+            .record_pat_field_list()?\n+            .fields()\n+            .filter_map(|field| sema.resolve_record_pat_field(&field)),\n+        token,\n+    )\n+}\n+\n+fn signature_help_for_tuple_struct_pat(\n+    sema: &Semantics<'_, RootDatabase>,\n+    pat: ast::TupleStructPat,\n+    token: SyntaxToken,\n+) -> Option<SignatureHelp> {\n+    let rest_pat = pat.fields().find(|it| matches!(it, ast::Pat::RestPat(_)));\n+    let is_left_of_rest_pat =\n+        rest_pat.map_or(true, |it| token.text_range().start() < it.syntax().text_range().end());\n+\n+    let mut res = SignatureHelp {\n+        doc: None,\n+        signature: String::new(),\n+        parameters: vec![],\n+        active_parameter: None,\n+    };\n+\n+    let db = sema.db;\n+    let path_res = sema.resolve_path(&pat.path()?)?;\n+    let fields: Vec<_> = if let PathResolution::Def(ModuleDef::Variant(variant)) = path_res {\n+        let en = variant.parent_enum(db);\n+\n+        res.doc = en.docs(db).map(|it| it.into());\n+        format_to!(res.signature, \"enum {}::{} (\", en.name(db), variant.name(db));\n+        variant.fields(db)\n+    } else {\n+        let adt = match path_res {\n+            PathResolution::SelfType(imp) => imp.self_ty(db).as_adt()?,\n+            PathResolution::Def(ModuleDef::Adt(adt)) => adt,\n+            _ => return None,\n+        };\n+\n+        match adt {\n+            hir::Adt::Struct(it) => {\n+                res.doc = it.docs(db).map(|it| it.into());\n+                format_to!(res.signature, \"struct {} (\", it.name(db));\n+                it.fields(db)\n+            }\n+            _ => return None,\n+        }\n+    };\n+    let commas = pat\n         .syntax()\n         .children_with_tokens()\n+        .filter_map(syntax::NodeOrToken::into_token)\n+        .filter(|t| t.kind() == syntax::T![,]);\n+    res.active_parameter = Some(if is_left_of_rest_pat {\n+        commas.take_while(|t| t.text_range().start() <= token.text_range().start()).count()\n+    } else {\n+        let n_commas = commas\n+            .collect::<Vec<_>>()\n+            .into_iter()\n+            .rev()\n+            .take_while(|t| t.text_range().start() > token.text_range().start())\n+            .count();\n+        fields.len().saturating_sub(1).saturating_sub(n_commas)\n+    });\n+\n+    let mut buf = String::new();\n+    for ty in fields.into_iter().map(|it| it.ty(db)) {\n+        format_to!(buf, \"{}\", ty.display_truncated(db, Some(20)));\n+        res.push_call_param(&buf);\n+        buf.clear();\n+    }\n+    res.signature.push_str(\")\");\n+    Some(res)\n+}\n+\n+fn signature_help_for_record_(\n+    sema: &Semantics<'_, RootDatabase>,\n+    field_list_children: SyntaxElementChildren,\n+    path: &ast::Path,\n+    fields2: impl Iterator<Item = (hir::Field, hir::Type)>,\n+    token: SyntaxToken,\n+) -> Option<SignatureHelp> {\n+    let active_parameter = field_list_children\n         .filter_map(syntax::NodeOrToken::into_token)\n         .filter(|t| t.kind() == syntax::T![,])\n         .take_while(|t| t.text_range().start() <= token.text_range().start())\n@@ -365,7 +480,7 @@ fn signature_help_for_record_lit(\n     let fields;\n \n     let db = sema.db;\n-    let path_res = sema.resolve_path(&record.path()?)?;\n+    let path_res = sema.resolve_path(path)?;\n     if let PathResolution::Def(ModuleDef::Variant(variant)) = path_res {\n         fields = variant.fields(db);\n         let en = variant.parent_enum(db);\n@@ -397,8 +512,7 @@ fn signature_help_for_record_lit(\n     let mut fields =\n         fields.into_iter().map(|field| (field.name(db), Some(field))).collect::<FxIndexMap<_, _>>();\n     let mut buf = String::new();\n-    for field in record.record_expr_field_list()?.fields() {\n-        let Some((field, _, ty)) = sema.resolve_record_field(&field) else { continue };\n+    for (field, ty) in fields2 {\n         let name = field.name(db);\n         format_to!(buf, \"{name}: {}\", ty.display_truncated(db, Some(20)));\n         res.push_record_field(&buf);\n@@ -439,6 +553,7 @@ mod tests {\n         (database, FilePosition { file_id, offset })\n     }\n \n+    #[track_caller]\n     fn check(ra_fixture: &str, expect: Expect) {\n         let fixture = format!(\n             r#\"\n@@ -890,6 +1005,119 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn tuple_struct_pat() {\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32);\n+fn main() {\n+    let S(0, $0);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32)\n+                          ---  ^^^\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_struct_pat_rest() {\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16);\n+fn main() {\n+    let S(0, .., $0);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16)\n+                          ---  ---  ---  ^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16, u8);\n+fn main() {\n+    let S(0, .., $0, 0);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16, u8)\n+                          ---  ---  ---  ^^^  --\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16);\n+fn main() {\n+    let S($0, .., 1);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16)\n+                          ^^^  ---  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16, u8);\n+fn main() {\n+    let S(1, .., 1, $0, 2);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16, u8)\n+                          ---  ---  ---  ^^^  --\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16);\n+fn main() {\n+    let S(1, $0.., 1);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16)\n+                          ---  ^^^  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+/// A cool tuple struct\n+struct S(u32, i32, f32, u16);\n+fn main() {\n+    let S(1, ..$0, 1);\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct S (u32, i32, f32, u16)\n+                          ---  ^^^  ---  ---\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn generic_struct() {\n         check(\n@@ -1550,6 +1778,29 @@ impl S {\n         );\n     }\n \n+    #[test]\n+    fn record_pat() {\n+        check(\n+            r#\"\n+struct Strukt<T, U = ()> {\n+    t: T,\n+    u: U,\n+    unit: (),\n+}\n+fn f() {\n+    let Strukt {\n+        u: 0,\n+        $0\n+    }\n+}\n+\"#,\n+            expect![[r#\"\n+                struct Strukt { u: i32, t: T, unit: () }\n+                                ------  ^^^^  --------\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn test_enum_in_nested_method_in_lambda() {\n         check("}, {"sha": "5f4977886f6ebe076fde8f190af25ac50af95d0c", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/patterns.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -431,14 +431,15 @@ fn slice_pat(p: &mut Parser<'_>) -> CompletedMarker {\n \n fn pat_list(p: &mut Parser<'_>, ket: SyntaxKind) {\n     while !p.at(EOF) && !p.at(ket) {\n-        if !p.at_ts(PAT_TOP_FIRST) {\n-            p.error(\"expected a pattern\");\n-            break;\n-        }\n-\n         pattern_top(p);\n-        if !p.at(ket) {\n-            p.expect(T![,]);\n+        if !p.at(T![,]) {\n+            if p.at_ts(PAT_TOP_FIRST) {\n+                p.error(format!(\"expected {:?}, got {:?}\", T![,], p.current()));\n+            } else {\n+                break;\n+            }\n+        } else {\n+            p.bump(T![,]);\n         }\n     }\n }"}, {"sha": "4e5d640f175e461c8971ce023d99641da8dab02b", "filename": "src/tools/rust-analyzer/crates/project-model/src/build_scripts.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -429,8 +429,9 @@ impl WorkspaceBuildScripts {\n             for p in rustc.packages() {\n                 let package = &rustc[p];\n                 if package.targets.iter().any(|&it| rustc[it].is_proc_macro) {\n-                    if let Some((_, path)) =\n-                        proc_macro_dylibs.iter().find(|(name, _)| *name == package.name)\n+                    if let Some((_, path)) = proc_macro_dylibs\n+                        .iter()\n+                        .find(|(name, _)| *name.trim_start_matches(\"lib\") == package.name)\n                     {\n                         bs.outputs[p].proc_macro_dylib_path = Some(path.clone());\n                     }"}, {"sha": "01162b1a8ba0cd8bed2c641cfbe6ce25fc7aa881", "filename": "src/tools/rust-analyzer/crates/project-model/src/cargo_workspace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -50,7 +50,7 @@ impl ops::Index<Target> for CargoWorkspace {\n \n /// Describes how to set the rustc source directory.\n #[derive(Clone, Debug, PartialEq, Eq)]\n-pub enum RustcSource {\n+pub enum RustLibSource {\n     /// Explicit path for the rustc source directory.\n     Path(AbsPathBuf),\n     /// Try to automatically detect where the rustc source directory is.\n@@ -95,10 +95,10 @@ pub struct CargoConfig {\n     /// rustc target\n     pub target: Option<String>,\n     /// Sysroot loading behavior\n-    pub sysroot: Option<RustcSource>,\n+    pub sysroot: Option<RustLibSource>,\n     pub sysroot_src: Option<AbsPathBuf>,\n     /// rustc private crate source\n-    pub rustc_source: Option<RustcSource>,\n+    pub rustc_source: Option<RustLibSource>,\n     /// crates to disable `#[cfg(test)]` on\n     pub unset_test_crates: UnsetTestCrates,\n     /// Invoke `cargo check` through the RUSTC_WRAPPER."}, {"sha": "70cb71ae3bde8438478f21b14b3c2cfb5922f02d", "filename": "src/tools/rust-analyzer/crates/project-model/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Flib.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -44,7 +44,7 @@ pub use crate::{\n     build_scripts::WorkspaceBuildScripts,\n     cargo_workspace::{\n         CargoConfig, CargoFeatures, CargoWorkspace, Package, PackageData, PackageDependency,\n-        RustcSource, Target, TargetData, TargetKind, UnsetTestCrates,\n+        RustLibSource, Target, TargetData, TargetKind, UnsetTestCrates,\n     },\n     manifest_path::ManifestPath,\n     project_json::{ProjectJson, ProjectJsonData},"}, {"sha": "3754accbb03d8ad591f106bbfb953dca28ff19fa", "filename": "src/tools/rust-analyzer/crates/project-model/src/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Ftests.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -24,8 +24,8 @@ fn load_cargo_with_overrides(file: &str, cfg_overrides: CfgOverrides) -> CrateGr\n     let project_workspace = ProjectWorkspace::Cargo {\n         cargo: cargo_workspace,\n         build_scripts: WorkspaceBuildScripts::default(),\n-        sysroot: None,\n-        rustc: None,\n+        sysroot: Err(None),\n+        rustc: Err(None),\n         rustc_cfg: Vec::new(),\n         cfg_overrides,\n         toolchain: None,\n@@ -37,7 +37,7 @@ fn load_cargo_with_overrides(file: &str, cfg_overrides: CfgOverrides) -> CrateGr\n fn load_rust_project(file: &str) -> CrateGraph {\n     let data = get_test_json_file(file);\n     let project = rooted_project_json(data);\n-    let sysroot = Some(get_fake_sysroot());\n+    let sysroot = Ok(get_fake_sysroot());\n     let project_workspace = ProjectWorkspace::Json { project, sysroot, rustc_cfg: Vec::new() };\n     to_crate_graph(project_workspace)\n }"}, {"sha": "d1e53e12eebb5691cce40bd4e0cf87b078ba1bde", "filename": "src/tools/rust-analyzer/crates/project-model/src/workspace.rs", "status": "modified", "additions": 110, "deletions": 114, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -17,7 +17,7 @@ use stdx::{always, hash::NoHashHashMap};\n \n use crate::{\n     build_scripts::BuildScriptOutput,\n-    cargo_workspace::{DepKind, PackageData, RustcSource},\n+    cargo_workspace::{DepKind, PackageData, RustLibSource},\n     cfg_flag::CfgFlag,\n     rustc_cfg,\n     sysroot::SysrootCrate,\n@@ -69,8 +69,8 @@ pub enum ProjectWorkspace {\n     Cargo {\n         cargo: CargoWorkspace,\n         build_scripts: WorkspaceBuildScripts,\n-        sysroot: Option<Sysroot>,\n-        rustc: Option<(CargoWorkspace, WorkspaceBuildScripts)>,\n+        sysroot: Result<Sysroot, Option<String>>,\n+        rustc: Result<(CargoWorkspace, WorkspaceBuildScripts), Option<String>>,\n         /// Holds cfg flags for the current target. We get those by running\n         /// `rustc --print cfg`.\n         ///\n@@ -82,7 +82,7 @@ pub enum ProjectWorkspace {\n         target_layout: Result<String, String>,\n     },\n     /// Project workspace was manually specified using a `rust-project.json` file.\n-    Json { project: ProjectJson, sysroot: Option<Sysroot>, rustc_cfg: Vec<CfgFlag> },\n+    Json { project: ProjectJson, sysroot: Result<Sysroot, Option<String>>, rustc_cfg: Vec<CfgFlag> },\n     // FIXME: The primary limitation of this approach is that the set of detached files needs to be fixed at the beginning.\n     // That's not the end user experience we should strive for.\n     // Ideally, you should be able to just open a random detached file in existing cargo projects, and get the basic features working.\n@@ -93,7 +93,11 @@ pub enum ProjectWorkspace {\n     // //\n     /// Project with a set of disjoint files, not belonging to any particular workspace.\n     /// Backed by basic sysroot crates for basic completion and highlighting.\n-    DetachedFiles { files: Vec<AbsPathBuf>, sysroot: Option<Sysroot>, rustc_cfg: Vec<CfgFlag> },\n+    DetachedFiles {\n+        files: Vec<AbsPathBuf>,\n+        sysroot: Result<Sysroot, Option<String>>,\n+        rustc_cfg: Vec<CfgFlag>,\n+    },\n }\n \n impl fmt::Debug for ProjectWorkspace {\n@@ -113,7 +117,7 @@ impl fmt::Debug for ProjectWorkspace {\n                 .debug_struct(\"Cargo\")\n                 .field(\"root\", &cargo.workspace_root().file_name())\n                 .field(\"n_packages\", &cargo.packages().len())\n-                .field(\"sysroot\", &sysroot.is_some())\n+                .field(\"sysroot\", &sysroot.is_ok())\n                 .field(\n                     \"n_rustc_compiler_crates\",\n                     &rustc.as_ref().map_or(0, |(rc, _)| rc.packages().len()),\n@@ -126,7 +130,7 @@ impl fmt::Debug for ProjectWorkspace {\n             ProjectWorkspace::Json { project, sysroot, rustc_cfg } => {\n                 let mut debug_struct = f.debug_struct(\"Json\");\n                 debug_struct.field(\"n_crates\", &project.n_crates());\n-                if let Some(sysroot) = sysroot {\n+                if let Ok(sysroot) = sysroot {\n                     debug_struct.field(\"n_sysroot_crates\", &sysroot.crates().len());\n                 }\n                 debug_struct.field(\"n_rustc_cfg\", &rustc_cfg.len());\n@@ -135,7 +139,7 @@ impl fmt::Debug for ProjectWorkspace {\n             ProjectWorkspace::DetachedFiles { files, sysroot, rustc_cfg } => f\n                 .debug_struct(\"DetachedFiles\")\n                 .field(\"n_files\", &files.len())\n-                .field(\"sysroot\", &sysroot.is_some())\n+                .field(\"sysroot\", &sysroot.is_ok())\n                 .field(\"n_rustc_cfg\", &rustc_cfg.len())\n                 .finish(),\n         }\n@@ -191,93 +195,81 @@ impl ProjectWorkspace {\n                 let cargo = CargoWorkspace::new(meta);\n \n                 let sysroot = match (&config.sysroot, &config.sysroot_src) {\n-                    (Some(RustcSource::Path(path)), None) => {\n-                        match Sysroot::with_sysroot_dir(path.clone()) {\n-                            Ok(it) => Some(it),\n-                            Err(e) => {\n-                                tracing::error!(%e, \"Failed to find sysroot at {}.\", path.display());\n-                                None\n-                            }\n-                        }\n+                    (Some(RustLibSource::Path(path)), None) => {\n+                        Sysroot::with_sysroot_dir(path.clone()).map_err(|e| {\n+                          Some(format!(\"Failed to find sysroot at {}:{e}\", path.display()))\n+                        })\n                     }\n-                    (Some(RustcSource::Discover), None) => {\n-                        match Sysroot::discover(cargo_toml.parent(), &config.extra_env) {\n-                            Ok(it) => Some(it),\n-                            Err(e) => {\n-                                tracing::error!(\n-                                    %e,\n-                                    \"Failed to find sysroot for Cargo.toml file {}. Is rust-src installed?\",\n-                                    cargo_toml.display()\n-                                );\n-                                None\n-                            }\n-                        }\n+                    (Some(RustLibSource::Discover), None) => {\n+                        Sysroot::discover(cargo_toml.parent(), &config.extra_env).map_err(|e| {\n+                            Some(format!(\"Failed to find sysroot for Cargo.toml file {}. Is rust-src installed? {e}\", cargo_toml.display()))\n+                        })\n                     }\n-                    (Some(RustcSource::Path(sysroot)), Some(sysroot_src)) => {\n-                        Some(Sysroot::load(sysroot.clone(), sysroot_src.clone()))\n+                    (Some(RustLibSource::Path(sysroot)), Some(sysroot_src)) => {\n+                        Ok(Sysroot::load(sysroot.clone(), sysroot_src.clone()))\n                     }\n-                    (Some(RustcSource::Discover), Some(sysroot_src)) => {\n-                        match Sysroot::discover_with_src_override(\n+                    (Some(RustLibSource::Discover), Some(sysroot_src)) => {\n+                        Sysroot::discover_with_src_override(\n                             cargo_toml.parent(),\n                             &config.extra_env,\n                             sysroot_src.clone(),\n-                        ) {\n-                            Ok(it) => Some(it),\n-                            Err(e) => {\n-                                tracing::error!(\n-                                    %e,\n-                                    \"Failed to find sysroot for Cargo.toml file {}. Is rust-src installed?\",\n-                                    cargo_toml.display()\n-                                );\n-                                None\n-                            }\n-                        }\n+                        ).map_err(|e| {\n+                            Some(format!(\"Failed to find sysroot for Cargo.toml file {}. Is rust-src installed? {e}\", cargo_toml.display()))\n+                        })\n                     }\n-                    (None, _) => None,\n+                    (None, _) => Err(None),\n                 };\n \n-                if let Some(sysroot) = &sysroot {\n+                if let Ok(sysroot) = &sysroot {\n                     tracing::info!(workspace = %cargo_toml.display(), src_root = %sysroot.src_root().display(), root = %sysroot.root().display(), \"Using sysroot\");\n                 }\n \n                 let rustc_dir = match &config.rustc_source {\n-                    Some(RustcSource::Path(path)) => ManifestPath::try_from(path.clone()).ok(),\n-                    Some(RustcSource::Discover) => {\n-                        sysroot.as_ref().and_then(Sysroot::discover_rustc)\n+                    Some(RustLibSource::Path(path)) => ManifestPath::try_from(path.clone())\n+                        .map_err(|p| {\n+                            Some(format!(\"rustc source path is not absolute: {}\", p.display()))\n+                        }),\n+                    Some(RustLibSource::Discover) => {\n+                        sysroot.as_ref().ok().and_then(Sysroot::discover_rustc).ok_or_else(|| {\n+                            Some(format!(\"Failed to discover rustc source for sysroot.\"))\n+                        })\n                     }\n-                    None => None,\n+                    None => Err(None),\n                 };\n \n-                let rustc = match rustc_dir {\n-                    Some(rustc_dir) => {\n-                        tracing::info!(workspace = %cargo_toml.display(), rustc_dir = %rustc_dir.display(), \"Using rustc source\");\n-                        match CargoWorkspace::fetch_metadata(\n-                            &rustc_dir,\n-                            cargo_toml.parent(),\n-                            config,\n-                            progress,\n-                        ) {\n-                            Ok(meta) => {\n-                                let workspace = CargoWorkspace::new(meta);\n-                                let buildscripts = WorkspaceBuildScripts::rustc_crates(\n-                                    &workspace,\n-                                    cargo_toml.parent(),\n-                                    &config.extra_env,\n-                                );\n-                                Some((workspace, buildscripts))\n-                            }\n-                            Err(e) => {\n-                                tracing::error!(\n-                                    %e,\n-                                    \"Failed to read Cargo metadata from rustc source at {}\",\n-                                    rustc_dir.display()\n-                                );\n-                                None\n-                            }\n+                let rustc =  rustc_dir.and_then(|rustc_dir| {\n+                    tracing::info!(workspace = %cargo_toml.display(), rustc_dir = %rustc_dir.display(), \"Using rustc source\");\n+                    match CargoWorkspace::fetch_metadata(\n+                        &rustc_dir,\n+                        cargo_toml.parent(),\n+                        &CargoConfig {\n+                            features: crate::CargoFeatures::default(),\n+                            ..config.clone()\n+                        },\n+                        progress,\n+                    ) {\n+                        Ok(meta) => {\n+                            let workspace = CargoWorkspace::new(meta);\n+                            let buildscripts = WorkspaceBuildScripts::rustc_crates(\n+                                &workspace,\n+                                cargo_toml.parent(),\n+                                &config.extra_env,\n+                            );\n+                            Ok((workspace, buildscripts))\n+                        }\n+                        Err(e) => {\n+                            tracing::error!(\n+                                %e,\n+                                \"Failed to read Cargo metadata from rustc source at {}\",\n+                                rustc_dir.display()\n+                            );\n+                            Err(Some(format!(\n+                                \"Failed to read Cargo metadata from rustc source at {}: {e}\",\n+                                rustc_dir.display())\n+                            ))\n                         }\n                     }\n-                    None => None,\n-                };\n+                });\n \n                 let rustc_cfg =\n                     rustc_cfg::get(Some(&cargo_toml), config.target.as_deref(), &config.extra_env);\n@@ -313,24 +305,24 @@ impl ProjectWorkspace {\n         extra_env: &FxHashMap<String, String>,\n     ) -> ProjectWorkspace {\n         let sysroot = match (project_json.sysroot.clone(), project_json.sysroot_src.clone()) {\n-            (Some(sysroot), Some(sysroot_src)) => Some(Sysroot::load(sysroot, sysroot_src)),\n+            (Some(sysroot), Some(sysroot_src)) => Ok(Sysroot::load(sysroot, sysroot_src)),\n             (Some(sysroot), None) => {\n                 // assume sysroot is structured like rustup's and guess `sysroot_src`\n                 let sysroot_src =\n                     sysroot.join(\"lib\").join(\"rustlib\").join(\"src\").join(\"rust\").join(\"library\");\n-                Some(Sysroot::load(sysroot, sysroot_src))\n+                Ok(Sysroot::load(sysroot, sysroot_src))\n             }\n             (None, Some(sysroot_src)) => {\n                 // assume sysroot is structured like rustup's and guess `sysroot`\n                 let mut sysroot = sysroot_src.clone();\n                 for _ in 0..5 {\n                     sysroot.pop();\n                 }\n-                Some(Sysroot::load(sysroot, sysroot_src))\n+                Ok(Sysroot::load(sysroot, sysroot_src))\n             }\n-            (None, None) => None,\n+            (None, None) => Err(None),\n         };\n-        if let Some(sysroot) = &sysroot {\n+        if let Ok(sysroot) = &sysroot {\n             tracing::info!(src_root = %sysroot.src_root().display(), root = %sysroot.root().display(), \"Using sysroot\");\n         }\n \n@@ -343,33 +335,23 @@ impl ProjectWorkspace {\n         config: &CargoConfig,\n     ) -> Result<ProjectWorkspace> {\n         let sysroot = match &config.sysroot {\n-            Some(RustcSource::Path(path)) => match Sysroot::with_sysroot_dir(path.clone()) {\n-                Ok(it) => Some(it),\n-                Err(e) => {\n-                    tracing::error!(%e, \"Failed to find sysroot at {}.\", path.display());\n-                    None\n-                }\n-            },\n-            Some(RustcSource::Discover) => {\n+            Some(RustLibSource::Path(path)) => Sysroot::with_sysroot_dir(path.clone())\n+                .map_err(|e| Some(format!(\"Failed to find sysroot at {}:{e}\", path.display()))),\n+            Some(RustLibSource::Discover) => {\n                 let dir = &detached_files\n                     .first()\n                     .and_then(|it| it.parent())\n                     .ok_or_else(|| format_err!(\"No detached files to load\"))?;\n-                match Sysroot::discover(dir, &config.extra_env) {\n-                    Ok(it) => Some(it),\n-                    Err(e) => {\n-                        tracing::error!(\n-                            %e,\n-                            \"Failed to find sysroot for {}. Is rust-src installed?\",\n-                            dir.display()\n-                        );\n-                        None\n-                    }\n-                }\n+                Sysroot::discover(dir, &config.extra_env).map_err(|e| {\n+                    Some(format!(\n+                        \"Failed to find sysroot for {}. Is rust-src installed? {e}\",\n+                        dir.display()\n+                    ))\n+                })\n             }\n-            None => None,\n+            None => Err(None),\n         };\n-        if let Some(sysroot) = &sysroot {\n+        if let Ok(sysroot) = &sysroot {\n             tracing::info!(src_root = %sysroot.src_root().display(), root = %sysroot.root().display(), \"Using sysroot\");\n         }\n         let rustc_cfg = rustc_cfg::get(None, None, &Default::default());\n@@ -450,10 +432,18 @@ impl ProjectWorkspace {\n         }\n     }\n \n+    pub fn workspace_definition_path(&self) -> Option<&AbsPath> {\n+        match self {\n+            ProjectWorkspace::Cargo { cargo, .. } => Some(cargo.workspace_root()),\n+            ProjectWorkspace::Json { project, .. } => Some(project.path()),\n+            ProjectWorkspace::DetachedFiles { .. } => None,\n+        }\n+    }\n+\n     pub fn find_sysroot_proc_macro_srv(&self) -> Option<AbsPathBuf> {\n         match self {\n-            ProjectWorkspace::Cargo { sysroot: Some(sysroot), .. }\n-            | ProjectWorkspace::Json { sysroot: Some(sysroot), .. } => {\n+            ProjectWorkspace::Cargo { sysroot: Ok(sysroot), .. }\n+            | ProjectWorkspace::Json { sysroot: Ok(sysroot), .. } => {\n                 let standalone_server_name =\n                     format!(\"rust-analyzer-proc-macro-srv{}\", std::env::consts::EXE_SUFFIX);\n                 [\"libexec\", \"lib\"]\n@@ -469,7 +459,7 @@ impl ProjectWorkspace {\n     /// The return type contains the path and whether or not\n     /// the root is a member of the current workspace\n     pub fn to_roots(&self) -> Vec<PackageRoot> {\n-        let mk_sysroot = |sysroot: Option<&Sysroot>, project_root: Option<&AbsPath>| {\n+        let mk_sysroot = |sysroot: Result<&Sysroot, _>, project_root: Option<&AbsPath>| {\n             sysroot.map(|sysroot| PackageRoot {\n                 // mark the sysroot as mutable if it is located inside of the project\n                 is_local: project_root\n@@ -592,7 +582,7 @@ impl ProjectWorkspace {\n                 load_proc_macro,\n                 load,\n                 project,\n-                sysroot.as_ref(),\n+                sysroot.as_ref().ok(),\n                 extra_env,\n                 Err(\"rust-project.json projects have no target layout set\".into()),\n             ),\n@@ -608,9 +598,9 @@ impl ProjectWorkspace {\n             } => cargo_to_crate_graph(\n                 load_proc_macro,\n                 load,\n-                rustc,\n+                rustc.as_ref().ok(),\n                 cargo,\n-                sysroot.as_ref(),\n+                sysroot.as_ref().ok(),\n                 rustc_cfg.clone(),\n                 cfg_overrides,\n                 build_scripts,\n@@ -624,7 +614,7 @@ impl ProjectWorkspace {\n                     rustc_cfg.clone(),\n                     load,\n                     files,\n-                    sysroot,\n+                    sysroot.as_ref().ok(),\n                     Err(\"detached file projects have no target layout set\".into()),\n                 )\n             }\n@@ -786,7 +776,7 @@ fn project_json_to_crate_graph(\n fn cargo_to_crate_graph(\n     load_proc_macro: &mut dyn FnMut(&str, &AbsPath) -> ProcMacroLoadResult,\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n-    rustc: &Option<(CargoWorkspace, WorkspaceBuildScripts)>,\n+    rustc: Option<&(CargoWorkspace, WorkspaceBuildScripts)>,\n     cargo: &CargoWorkspace,\n     sysroot: Option<&Sysroot>,\n     rustc_cfg: Vec<CfgFlag>,\n@@ -932,7 +922,7 @@ fn cargo_to_crate_graph(\n     if has_private {\n         // If the user provided a path to rustc sources, we add all the rustc_private crates\n         // and create dependencies on them for the crates which opt-in to that\n-        if let Some((rustc_workspace, build_scripts)) = rustc {\n+        if let Some((rustc_workspace, rustc_build_scripts)) = rustc {\n             handle_rustc_crates(\n                 &mut crate_graph,\n                 &mut pkg_to_lib_crate,\n@@ -945,7 +935,13 @@ fn cargo_to_crate_graph(\n                 &pkg_crates,\n                 &cfg_options,\n                 override_cfg,\n-                build_scripts,\n+                if rustc_workspace.workspace_root() == cargo.workspace_root() {\n+                    // the rustc workspace does not use the installed toolchain's proc-macro server\n+                    // so we need to make sure we don't use the pre compiled proc-macros there either\n+                    build_scripts\n+                } else {\n+                    rustc_build_scripts\n+                },\n                 target_layout,\n             );\n         }\n@@ -957,7 +953,7 @@ fn detached_files_to_crate_graph(\n     rustc_cfg: Vec<CfgFlag>,\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n     detached_files: &[AbsPathBuf],\n-    sysroot: &Option<Sysroot>,\n+    sysroot: Option<&Sysroot>,\n     target_layout: TargetLayoutLoadResult,\n ) -> CrateGraph {\n     let _p = profile::span(\"detached_files_to_crate_graph\");"}, {"sha": "6ce1de5d32bcac068df2e40d3f9a98ae323e30c7", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -7,7 +7,7 @@ use std::{\n };\n \n use hir::{\n-    db::{AstDatabase, DefDatabase, HirDatabase},\n+    db::{DefDatabase, ExpandDatabase, HirDatabase},\n     AssocItem, Crate, Function, HasSource, HirDisplay, ModuleDef,\n };\n use hir_def::{\n@@ -24,7 +24,7 @@ use ide_db::base_db::{\n use itertools::Itertools;\n use oorandom::Rand32;\n use profile::{Bytes, StopWatch};\n-use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace, RustcSource};\n+use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace, RustLibSource};\n use rayon::prelude::*;\n use rustc_hash::FxHashSet;\n use stdx::format_to;\n@@ -57,7 +57,7 @@ impl flags::AnalysisStats {\n         let mut cargo_config = CargoConfig::default();\n         cargo_config.sysroot = match self.no_sysroot {\n             true => None,\n-            false => Some(RustcSource::Discover),\n+            false => Some(RustLibSource::Discover),\n         };\n         let no_progress = &|_| ();\n "}, {"sha": "4006d023def52be059fa3310a4091fa65a6229b7", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,7 +1,7 @@\n //! Analyze all modules in a project for diagnostics. Exits with a non-zero\n //! status code if any errors are found.\n \n-use project_model::{CargoConfig, RustcSource};\n+use project_model::{CargoConfig, RustLibSource};\n use rustc_hash::FxHashSet;\n \n use hir::{db::HirDatabase, Crate, Module};\n@@ -16,7 +16,7 @@ use crate::cli::{\n impl flags::Diagnostics {\n     pub fn run(self) -> anyhow::Result<()> {\n         let mut cargo_config = CargoConfig::default();\n-        cargo_config.sysroot = Some(RustcSource::Discover);\n+        cargo_config.sysroot = Some(RustLibSource::Discover);\n         let load_cargo_config = LoadCargoConfig {\n             load_out_dirs_from_check: !self.disable_build_scripts,\n             with_proc_macro_server: ProcMacroServerChoice::Sysroot,"}, {"sha": "7f5d084496714d08d51d6a17fb82806ff08e8366", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/lsif.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -13,7 +13,7 @@ use ide_db::LineIndexDatabase;\n use ide_db::base_db::salsa::{self, ParallelDatabase};\n use ide_db::line_index::WideEncoding;\n use lsp_types::{self, lsif};\n-use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace, RustcSource};\n+use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace, RustLibSource};\n use vfs::{AbsPathBuf, Vfs};\n \n use crate::cli::load_cargo::ProcMacroServerChoice;\n@@ -290,7 +290,7 @@ impl flags::Lsif {\n         eprintln!(\"Generating LSIF started...\");\n         let now = Instant::now();\n         let mut cargo_config = CargoConfig::default();\n-        cargo_config.sysroot = Some(RustcSource::Discover);\n+        cargo_config.sysroot = Some(RustLibSource::Discover);\n         let no_progress = &|_| ();\n         let load_cargo_config = LoadCargoConfig {\n             load_out_dirs_from_check: true,"}, {"sha": "3e5e40750e9cac931a7ce391e2ef52a8bfbed57b", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/scip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -15,7 +15,7 @@ use ide::{\n     TokenStaticData,\n };\n use ide_db::LineIndexDatabase;\n-use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace, RustcSource};\n+use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace, RustLibSource};\n use scip::types as scip_types;\n use std::env;\n \n@@ -30,7 +30,7 @@ impl flags::Scip {\n         eprintln!(\"Generating SCIP start...\");\n         let now = Instant::now();\n         let mut cargo_config = CargoConfig::default();\n-        cargo_config.sysroot = Some(RustcSource::Discover);\n+        cargo_config.sysroot = Some(RustLibSource::Discover);\n \n         let no_progress = &|s| (eprintln!(\"rust-analyzer: Loading {s}\"));\n         let load_cargo_config = LoadCargoConfig {"}, {"sha": "82a769347df04fe356ce95702c1b30a6e5c8c5e4", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/ssr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,7 +1,7 @@\n //! Applies structured search replace rules from the command line.\n \n use ide_ssr::MatchFinder;\n-use project_model::{CargoConfig, RustcSource};\n+use project_model::{CargoConfig, RustLibSource};\n \n use crate::cli::{\n     flags,\n@@ -13,7 +13,7 @@ impl flags::Ssr {\n     pub fn run(self) -> Result<()> {\n         use ide_db::base_db::SourceDatabaseExt;\n         let mut cargo_config = CargoConfig::default();\n-        cargo_config.sysroot = Some(RustcSource::Discover);\n+        cargo_config.sysroot = Some(RustLibSource::Discover);\n         let load_cargo_config = LoadCargoConfig {\n             load_out_dirs_from_check: true,\n             with_proc_macro_server: ProcMacroServerChoice::Sysroot,"}, {"sha": "c35cce103fab60ce138e643dcbf318a19a990a39", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -22,7 +22,7 @@ use ide_db::{\n use itertools::Itertools;\n use lsp_types::{ClientCapabilities, MarkupKind};\n use project_model::{\n-    CargoConfig, CargoFeatures, ProjectJson, ProjectJsonData, ProjectManifest, RustcSource,\n+    CargoConfig, CargoFeatures, ProjectJson, ProjectJsonData, ProjectManifest, RustLibSource,\n     UnsetTestCrates,\n };\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -272,7 +272,6 @@ config_data! {\n         /// The warnings will be indicated by a blue squiggly underline in code\n         /// and a blue icon in the `Problems Panel`.\n         diagnostics_warningsAsInfo: Vec<String> = \"[]\",\n-\n         /// These directories will be ignored by rust-analyzer. They are\n         /// relative to the workspace root, and globs are not supported. You may\n         /// also need to add the folders to Code's `files.watcherExclude`.\n@@ -895,6 +894,15 @@ impl Config {\n         }\n     }\n \n+    pub fn add_linked_projects(&mut self, linked_projects: Vec<ProjectJsonData>) {\n+        let mut linked_projects = linked_projects\n+            .into_iter()\n+            .map(ManifestOrProjectJson::ProjectJson)\n+            .collect::<Vec<ManifestOrProjectJson>>();\n+\n+        self.data.linkedProjects.append(&mut linked_projects);\n+    }\n+\n     pub fn did_save_text_document_dynamic_registration(&self) -> bool {\n         let caps = try_or_def!(self.caps.text_document.as_ref()?.synchronization.clone()?);\n         caps.did_save == Some(true) && caps.dynamic_registration == Some(true)\n@@ -1129,16 +1137,16 @@ impl Config {\n     pub fn cargo(&self) -> CargoConfig {\n         let rustc_source = self.data.rustc_source.as_ref().map(|rustc_src| {\n             if rustc_src == \"discover\" {\n-                RustcSource::Discover\n+                RustLibSource::Discover\n             } else {\n-                RustcSource::Path(self.root_path.join(rustc_src))\n+                RustLibSource::Path(self.root_path.join(rustc_src))\n             }\n         });\n         let sysroot = self.data.cargo_sysroot.as_ref().map(|sysroot| {\n             if sysroot == \"discover\" {\n-                RustcSource::Discover\n+                RustLibSource::Discover\n             } else {\n-                RustcSource::Path(self.root_path.join(sysroot))\n+                RustLibSource::Path(self.root_path.join(sysroot))\n             }\n         });\n         let sysroot_src ="}, {"sha": "313bb2ec8dffa8dfa3583331a2c76db8bfc60f3a", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/dispatch.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdispatch.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -87,6 +87,42 @@ impl<'a> RequestDispatcher<'a> {\n         self\n     }\n \n+    /// Dispatches the request onto thread pool\n+    pub(crate) fn on_no_retry<R>(\n+        &mut self,\n+        f: fn(GlobalStateSnapshot, R::Params) -> Result<R::Result>,\n+    ) -> &mut Self\n+    where\n+        R: lsp_types::request::Request + 'static,\n+        R::Params: DeserializeOwned + panic::UnwindSafe + Send + fmt::Debug,\n+        R::Result: Serialize,\n+    {\n+        let (req, params, panic_context) = match self.parse::<R>() {\n+            Some(it) => it,\n+            None => return self,\n+        };\n+\n+        self.global_state.task_pool.handle.spawn({\n+            let world = self.global_state.snapshot();\n+            move || {\n+                let result = panic::catch_unwind(move || {\n+                    let _pctx = stdx::panic_context::enter(panic_context);\n+                    f(world, params)\n+                });\n+                match thread_result_to_response::<R>(req.id.clone(), result) {\n+                    Ok(response) => Task::Response(response),\n+                    Err(_) => Task::Response(lsp_server::Response::new_err(\n+                        req.id,\n+                        lsp_server::ErrorCode::ContentModified as i32,\n+                        \"content modified\".to_string(),\n+                    )),\n+                }\n+            }\n+        });\n+\n+        self\n+    }\n+\n     /// Dispatches the request onto thread pool\n     pub(crate) fn on<R>(\n         &mut self,"}, {"sha": "2fca2ab851d416ec75998236fa45ef323a0aa286", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -29,7 +29,7 @@ use project_model::{ManifestPath, ProjectWorkspace, TargetKind};\n use serde_json::json;\n use stdx::{format_to, never};\n use syntax::{algo, ast, AstNode, TextRange, TextSize};\n-use vfs::AbsPathBuf;\n+use vfs::{AbsPath, AbsPathBuf};\n \n use crate::{\n     cargo_target_spec::CargoTargetSpec,\n@@ -46,6 +46,7 @@ use crate::{\n pub(crate) fn handle_workspace_reload(state: &mut GlobalState, _: ()) -> Result<()> {\n     state.proc_macro_clients.clear();\n     state.proc_macro_changed = false;\n+\n     state.fetch_workspaces_queue.request_op(\"reload workspace request\".to_string());\n     state.fetch_build_data_queue.request_op(\"reload workspace request\".to_string());\n     Ok(())\n@@ -84,6 +85,15 @@ pub(crate) fn handle_analyzer_status(\n             snap.workspaces.len(),\n             if snap.workspaces.len() == 1 { \"\" } else { \"s\" }\n         );\n+\n+        format_to!(\n+            buf,\n+            \"Workspace root folders: {:?}\",\n+            snap.workspaces\n+                .iter()\n+                .flat_map(|ws| ws.workspace_definition_path())\n+                .collect::<Vec<&AbsPath>>()\n+        );\n     }\n     buf.push_str(\"\\nAnalysis:\\n\");\n     buf.push_str("}, {"sha": "12e5caf2cc9e43f0b0830cfaae8d3b28401dcd4a", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -36,11 +36,41 @@ impl Progress {\n }\n \n impl GlobalState {\n-    pub(crate) fn show_message(&mut self, typ: lsp_types::MessageType, message: String) {\n-        let message = message;\n-        self.send_notification::<lsp_types::notification::ShowMessage>(\n-            lsp_types::ShowMessageParams { typ, message },\n-        )\n+    pub(crate) fn show_message(\n+        &mut self,\n+        typ: lsp_types::MessageType,\n+        message: String,\n+        show_open_log_button: bool,\n+    ) {\n+        match self.config.open_server_logs() && show_open_log_button  {\n+            true => self.send_request::<lsp_types::request::ShowMessageRequest>(\n+                lsp_types::ShowMessageRequestParams {\n+                    typ,\n+                    message,\n+                    actions: Some(vec![lsp_types::MessageActionItem {\n+                        title: \"Open server logs\".to_owned(),\n+                        properties: Default::default(),\n+                    }]),\n+                },\n+                |this, resp| {\n+                    let lsp_server::Response { error: None, result: Some(result), .. } = resp\n+                    else { return };\n+                    if let Ok(Some(_item)) = crate::from_json::<\n+                        <lsp_types::request::ShowMessageRequest as lsp_types::request::Request>::Result,\n+                    >(\n+                        lsp_types::request::ShowMessageRequest::METHOD, &result\n+                    ) {\n+                        this.send_notification::<lsp_ext::OpenServerLogs>(());\n+                    }\n+                },\n+            ),\n+            false => self.send_notification::<lsp_types::notification::ShowMessage>(\n+                lsp_types::ShowMessageParams {\n+                    typ,\n+                    message,\n+                },\n+            ),\n+        }\n     }\n \n     /// Sends a notification to the client containing the error `message`."}, {"sha": "67a54cde68c6f9aa586aeb1b1ea09e7939eb4022", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -406,9 +406,19 @@ impl GlobalState {\n \n             if self.config.server_status_notification() {\n                 self.send_notification::<lsp_ext::ServerStatusNotification>(status);\n-            } else if let (lsp_ext::Health::Error, Some(message)) = (status.health, &status.message)\n-            {\n-                self.show_and_log_error(message.clone(), None);\n+            } else if let (health, Some(message)) = (status.health, &status.message) {\n+                let open_log_button = tracing::enabled!(tracing::Level::ERROR)\n+                    && (self.fetch_build_data_error().is_err()\n+                        || self.fetch_workspace_error().is_err());\n+                self.show_message(\n+                    match health {\n+                        lsp_ext::Health::Ok => lsp_types::MessageType::INFO,\n+                        lsp_ext::Health::Warning => lsp_types::MessageType::WARNING,\n+                        lsp_ext::Health::Error => lsp_types::MessageType::ERROR,\n+                    },\n+                    message.clone(),\n+                    open_log_button,\n+                );\n             }\n         }\n     }\n@@ -653,7 +663,7 @@ impl GlobalState {\n             .on::<lsp_types::request::GotoDeclaration>(handlers::handle_goto_declaration)\n             .on::<lsp_types::request::GotoImplementation>(handlers::handle_goto_implementation)\n             .on::<lsp_types::request::GotoTypeDefinition>(handlers::handle_goto_type_definition)\n-            .on::<lsp_types::request::InlayHintRequest>(handlers::handle_inlay_hints)\n+            .on_no_retry::<lsp_types::request::InlayHintRequest>(handlers::handle_inlay_hints)\n             .on::<lsp_types::request::InlayHintResolveRequest>(handlers::handle_inlay_hints_resolve)\n             .on::<lsp_types::request::Completion>(handlers::handle_completion)\n             .on::<lsp_types::request::ResolveCompletionItem>(handlers::handle_completion_resolve)\n@@ -919,6 +929,7 @@ impl GlobalState {\n                                         this.show_message(\n                                             lsp_types::MessageType::WARNING,\n                                             error.to_string(),\n+                                            false,\n                                         );\n                                     }\n                                     this.update_configuration(config);"}, {"sha": "1a6e1af2eb7edd86fe66fbed80d267daa3c9d4b5", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -90,38 +90,55 @@ impl GlobalState {\n             quiescent: self.is_quiescent(),\n             message: None,\n         };\n+        let mut message = String::new();\n \n         if self.proc_macro_changed {\n             status.health = lsp_ext::Health::Warning;\n-            status.message =\n-                Some(\"Reload required due to source changes of a procedural macro.\".into())\n+            message.push_str(\"Reload required due to source changes of a procedural macro.\\n\\n\");\n         }\n         if let Err(_) = self.fetch_build_data_error() {\n             status.health = lsp_ext::Health::Warning;\n-            status.message =\n-                Some(\"Failed to run build scripts of some packages, check the logs.\".to_string());\n+            message.push_str(\"Failed to run build scripts of some packages.\\n\\n\");\n         }\n         if !self.config.cargo_autoreload()\n             && self.is_quiescent()\n             && self.fetch_workspaces_queue.op_requested()\n         {\n             status.health = lsp_ext::Health::Warning;\n-            status.message = Some(\"Workspace reload required\".to_string())\n+            message.push_str(\"Auto-reloading is disabled and the workspace has changed, a manual workspace reload is required.\\n\\n\");\n         }\n-\n-        if let Err(_) = self.fetch_workspace_error() {\n-            status.health = lsp_ext::Health::Error;\n-            status.message = Some(\"Failed to load workspaces\".to_string())\n-        }\n-\n         if self.config.linked_projects().is_empty()\n             && self.config.detached_files().is_empty()\n             && self.config.notifications().cargo_toml_not_found\n         {\n             status.health = lsp_ext::Health::Warning;\n-            status.message = Some(\"Failed to discover workspace\".to_string())\n+            message.push_str(\"Failed to discover workspace.\\n\\n\");\n+        }\n+\n+        for ws in self.workspaces.iter() {\n+            let (ProjectWorkspace::Cargo { sysroot, .. }\n+            | ProjectWorkspace::Json { sysroot, .. }\n+            | ProjectWorkspace::DetachedFiles { sysroot, .. }) = ws;\n+            if let Err(Some(e)) = sysroot {\n+                status.health = lsp_ext::Health::Warning;\n+                message.push_str(e);\n+                message.push_str(\"\\n\\n\");\n+            }\n+            if let ProjectWorkspace::Cargo { rustc: Err(Some(e)), .. } = ws {\n+                status.health = lsp_ext::Health::Warning;\n+                message.push_str(e);\n+                message.push_str(\"\\n\\n\");\n+            }\n         }\n \n+        if let Err(_) = self.fetch_workspace_error() {\n+            status.health = lsp_ext::Health::Error;\n+            message.push_str(\"Failed to load workspaces.\\n\\n\");\n+        }\n+\n+        if !message.is_empty() {\n+            status.message = Some(message.trim_end().to_owned());\n+        }\n         status\n     }\n "}, {"sha": "c43d0830b9e24864ff3148879cab369d6dadc968", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/expr_ext.rs", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -48,23 +48,30 @@ impl From<ast::IfExpr> for ElseBranch {\n }\n \n impl ast::IfExpr {\n-    pub fn then_branch(&self) -> Option<ast::BlockExpr> {\n-        self.children_after_condition().next()\n+    pub fn condition(&self) -> Option<ast::Expr> {\n+        // If the condition is a BlockExpr, check if the then body is missing.\n+        // If it is assume the condition is the expression that is missing instead.\n+        let mut exprs = support::children(self.syntax());\n+        let first = exprs.next();\n+        match first {\n+            Some(ast::Expr::BlockExpr(_)) => exprs.next().and(first),\n+            first => first,\n+        }\n     }\n \n-    pub fn else_branch(&self) -> Option<ElseBranch> {\n-        let res = match self.children_after_condition().nth(1) {\n-            Some(block) => ElseBranch::Block(block),\n-            None => {\n-                let elif = self.children_after_condition().next()?;\n-                ElseBranch::IfExpr(elif)\n-            }\n-        };\n-        Some(res)\n+    pub fn then_branch(&self) -> Option<ast::BlockExpr> {\n+        match support::children(self.syntax()).nth(1)? {\n+            ast::Expr::BlockExpr(block) => Some(block),\n+            _ => None,\n+        }\n     }\n \n-    fn children_after_condition<N: AstNode>(&self) -> impl Iterator<Item = N> {\n-        self.syntax().children().skip(1).filter_map(N::cast)\n+    pub fn else_branch(&self) -> Option<ElseBranch> {\n+        match support::children(self.syntax()).nth(2)? {\n+            ast::Expr::BlockExpr(block) => Some(ElseBranch::Block(block)),\n+            ast::Expr::IfExpr(elif) => Some(ElseBranch::IfExpr(elif)),\n+            _ => None,\n+        }\n     }\n }\n \n@@ -356,7 +363,15 @@ impl ast::BlockExpr {\n             Some(it) => it,\n             None => return true,\n         };\n-        !matches!(parent.kind(), FN | IF_EXPR | WHILE_EXPR | LOOP_EXPR)\n+        match parent.kind() {\n+            FOR_EXPR | IF_EXPR => parent\n+                .children()\n+                .filter(|it| ast::Expr::can_cast(it.kind()))\n+                .next()\n+                .map_or(true, |it| it == *self.syntax()),\n+            LET_ELSE | FN | WHILE_EXPR | LOOP_EXPR | CONST_BLOCK_PAT => false,\n+            _ => true,\n+        }\n     }\n }\n "}, {"sha": "3308077da5b12457a7f129cac2b5ad56d73d675e", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -937,12 +937,6 @@ impl From<ast::Adt> for ast::Item {\n     }\n }\n \n-impl ast::IfExpr {\n-    pub fn condition(&self) -> Option<ast::Expr> {\n-        support::child(&self.syntax)\n-    }\n-}\n-\n impl ast::MatchGuard {\n     pub fn condition(&self) -> Option<ast::Expr> {\n         support::child(&self.syntax)"}, {"sha": "ca6de4061a4b8d24c8ced00e423c72e9e9d511f2", "filename": "src/tools/rust-analyzer/crates/test-utils/src/minicore.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -44,6 +44,8 @@\n //!     try: infallible\n //!     unsize: sized\n \n+#![rustc_coherence_is_core]\n+\n pub mod marker {\n     // region:sized\n     #[lang = \"sized\"]"}, {"sha": "c5eb08748bfab5176592a9f4c4bfccf1c60ddbc6", "filename": "src/tools/rust-analyzer/editors/code/package.json", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -199,6 +199,11 @@\n                 \"title\": \"Reload workspace\",\n                 \"category\": \"rust-analyzer\"\n             },\n+            {\n+                \"command\": \"rust-analyzer.addProject\",\n+                \"title\": \"Add current file's crate to workspace\",\n+                \"category\": \"rust-analyzer\"\n+            },\n             {\n                 \"command\": \"rust-analyzer.reload\",\n                 \"title\": \"Restart server\",\n@@ -428,6 +433,17 @@\n                     \"default\": false,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.discoverProjectCommand\": {\n+                    \"markdownDescription\": \"Sets the command that rust-analyzer uses to generate `rust-project.json` files. This command should only be used\\n if a build system like Buck or Bazel is also in use. The command must accept files as arguments and return \\n a rust-project.json over stdout.\",\n+                    \"default\": null,\n+                    \"type\": [\n+                        \"null\",\n+                        \"array\"\n+                    ],\n+                    \"items\": {\n+                        \"type\": \"string\"\n+                    }\n+                },\n                 \"$generated-start\": {},\n                 \"rust-analyzer.assist.emitMustUse\": {\n                     \"markdownDescription\": \"Whether to insert #[must_use] when generating `as_` methods\\nfor enum variants.\","}, {"sha": "565cb9c6432f426aca5c7319e227001b141bda52", "filename": "src/tools/rust-analyzer/editors/code/src/client.ts", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fclient.ts?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -6,7 +6,7 @@ import * as Is from \"vscode-languageclient/lib/common/utils/is\";\n import { assert } from \"./util\";\n import * as diagnostics from \"./diagnostics\";\n import { WorkspaceEdit } from \"vscode\";\n-import { Config, substituteVSCodeVariables } from \"./config\";\n+import { Config, prepareVSCodeConfig } from \"./config\";\n import { randomUUID } from \"crypto\";\n \n export interface Env {\n@@ -95,7 +95,16 @@ export async function createClient(\n                     const resp = await next(params, token);\n                     if (resp && Array.isArray(resp)) {\n                         return resp.map((val) => {\n-                            return substituteVSCodeVariables(val);\n+                            return prepareVSCodeConfig(val, (key, cfg) => {\n+                                // we only want to set discovered workspaces on the right key\n+                                // and if a workspace has been discovered.\n+                                if (\n+                                    key === \"linkedProjects\" &&\n+                                    config.discoveredWorkspaces.length > 0\n+                                ) {\n+                                    cfg[key] = config.discoveredWorkspaces;\n+                                }\n+                            });\n                         });\n                     } else {\n                         return resp;"}, {"sha": "8a953577e99d368d8ead2bf5f03714a3447d6f93", "filename": "src/tools/rust-analyzer/editors/code/src/commands.ts", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -3,7 +3,7 @@ import * as lc from \"vscode-languageclient\";\n import * as ra from \"./lsp_ext\";\n import * as path from \"path\";\n \n-import { Ctx, Cmd, CtxInit } from \"./ctx\";\n+import { Ctx, Cmd, CtxInit, discoverWorkspace } from \"./ctx\";\n import { applySnippetWorkspaceEdit, applySnippetTextEdits } from \"./snippets\";\n import { spawnSync } from \"child_process\";\n import { RunnableQuickPick, selectRunnable, createTask, createArgs } from \"./run\";\n@@ -749,6 +749,33 @@ export function reloadWorkspace(ctx: CtxInit): Cmd {\n     return async () => ctx.client.sendRequest(ra.reloadWorkspace);\n }\n \n+export function addProject(ctx: CtxInit): Cmd {\n+    return async () => {\n+        const discoverProjectCommand = ctx.config.discoverProjectCommand;\n+        if (!discoverProjectCommand) {\n+            return;\n+        }\n+\n+        const workspaces: JsonProject[] = await Promise.all(\n+            vscode.workspace.workspaceFolders!.map(async (folder): Promise<JsonProject> => {\n+                const rustDocuments = vscode.workspace.textDocuments.filter(isRustDocument);\n+                return discoverWorkspace(rustDocuments, discoverProjectCommand, {\n+                    cwd: folder.uri.fsPath,\n+                });\n+            })\n+        );\n+\n+        ctx.addToDiscoveredWorkspaces(workspaces);\n+\n+        // this is a workaround to avoid needing writing the `rust-project.json` into\n+        // a workspace-level VS Code-specific settings folder. We'd like to keep the\n+        // `rust-project.json` entirely in-memory.\n+        await ctx.client?.sendNotification(lc.DidChangeConfigurationNotification.type, {\n+            settings: \"\",\n+        });\n+    };\n+}\n+\n async function showReferencesImpl(\n     client: LanguageClient | undefined,\n     uri: string,"}, {"sha": "da7c74c28bae901a8a3dcb3cb0924da57a53ec5b", "filename": "src/tools/rust-analyzer/editors/code/src/config.ts", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -34,6 +34,7 @@ export class Config {\n \n     constructor(ctx: vscode.ExtensionContext) {\n         this.globalStorageUri = ctx.globalStorageUri;\n+        this.discoveredWorkspaces = [];\n         vscode.workspace.onDidChangeConfiguration(\n             this.onDidChangeConfiguration,\n             this,\n@@ -55,6 +56,8 @@ export class Config {\n         log.info(\"Using configuration\", Object.fromEntries(cfg));\n     }\n \n+    public discoveredWorkspaces: JsonProject[];\n+\n     private async onDidChangeConfiguration(event: vscode.ConfigurationChangeEvent) {\n         this.refreshLogging();\n \n@@ -191,7 +194,7 @@ export class Config {\n      * So this getter handles this quirk by not requiring the caller to use postfix `!`\n      */\n     private get<T>(path: string): T | undefined {\n-        return substituteVSCodeVariables(this.cfg.get<T>(path));\n+        return prepareVSCodeConfig(this.cfg.get<T>(path));\n     }\n \n     get serverPath() {\n@@ -214,6 +217,10 @@ export class Config {\n         return this.get<boolean>(\"trace.extension\");\n     }\n \n+    get discoverProjectCommand() {\n+        return this.get<string[] | undefined>(\"discoverProjectCommand\");\n+    }\n+\n     get cargoRunner() {\n         return this.get<string | undefined>(\"cargoRunner\");\n     }\n@@ -280,18 +287,32 @@ export class Config {\n     }\n }\n \n-export function substituteVSCodeVariables<T>(resp: T): T {\n+// the optional `cb?` parameter is meant to be used to add additional\n+// key/value pairs to the VS Code configuration. This needed for, e.g.,\n+// including a `rust-project.json` into the `linkedProjects` key as part\n+// of the configuration/InitializationParams _without_ causing VS Code\n+// configuration to be written out to workspace-level settings. This is\n+// undesirable behavior because rust-project.json files can be tens of\n+// thousands of lines of JSON, most of which is not meant for humans\n+// to interact with.\n+export function prepareVSCodeConfig<T>(\n+    resp: T,\n+    cb?: (key: Extract<keyof T, string>, res: { [key: string]: any }) => void\n+): T {\n     if (Is.string(resp)) {\n         return substituteVSCodeVariableInString(resp) as T;\n     } else if (resp && Is.array<any>(resp)) {\n         return resp.map((val) => {\n-            return substituteVSCodeVariables(val);\n+            return prepareVSCodeConfig(val);\n         }) as T;\n     } else if (resp && typeof resp === \"object\") {\n         const res: { [key: string]: any } = {};\n         for (const key in resp) {\n             const val = resp[key];\n-            res[key] = substituteVSCodeVariables(val);\n+            res[key] = prepareVSCodeConfig(val);\n+            if (cb) {\n+                cb(key, res);\n+            }\n         }\n         return res as T;\n     }"}, {"sha": "c2dca733df8f53aeb2d457cfaf15b9973b9990ab", "filename": "src/tools/rust-analyzer/editors/code/src/ctx.ts", "status": "modified", "additions": 63, "deletions": 6, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fctx.ts", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fctx.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fctx.ts?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -2,12 +2,20 @@ import * as vscode from \"vscode\";\n import * as lc from \"vscode-languageclient/node\";\n import * as ra from \"./lsp_ext\";\n \n-import { Config, substituteVSCodeVariables } from \"./config\";\n+import { Config, prepareVSCodeConfig } from \"./config\";\n import { createClient } from \"./client\";\n-import { isRustDocument, isRustEditor, LazyOutputChannel, log, RustEditor } from \"./util\";\n+import {\n+    executeDiscoverProject,\n+    isRustDocument,\n+    isRustEditor,\n+    LazyOutputChannel,\n+    log,\n+    RustEditor,\n+} from \"./util\";\n import { ServerStatusParams } from \"./lsp_ext\";\n import { PersistentState } from \"./persistent_state\";\n import { bootstrap } from \"./bootstrap\";\n+import { ExecOptions } from \"child_process\";\n \n // We only support local folders, not eg. Live Share (`vlsl:` scheme), so don't activate if\n // only those are in use. We use \"Empty\" to represent these scenarios\n@@ -41,6 +49,17 @@ export function fetchWorkspace(): Workspace {\n         : { kind: \"Workspace Folder\" };\n }\n \n+export async function discoverWorkspace(\n+    files: readonly vscode.TextDocument[],\n+    command: string[],\n+    options: ExecOptions\n+): Promise<JsonProject> {\n+    const paths = files.map((f) => `\"${f.uri.fsPath}\"`).join(\" \");\n+    const joinedCommand = command.join(\" \");\n+    const data = await executeDiscoverProject(`${joinedCommand} ${paths}`, options);\n+    return JSON.parse(data) as JsonProject;\n+}\n+\n export type CommandFactory = {\n     enabled: (ctx: CtxInit) => Cmd;\n     disabled?: (ctx: Ctx) => Cmd;\n@@ -52,7 +71,7 @@ export type CtxInit = Ctx & {\n \n export class Ctx {\n     readonly statusBar: vscode.StatusBarItem;\n-    readonly config: Config;\n+    config: Config;\n     readonly workspace: Workspace;\n \n     private _client: lc.LanguageClient | undefined;\n@@ -169,7 +188,30 @@ export class Ctx {\n                 };\n             }\n \n-            const initializationOptions = substituteVSCodeVariables(rawInitializationOptions);\n+            const discoverProjectCommand = this.config.discoverProjectCommand;\n+            if (discoverProjectCommand) {\n+                const workspaces: JsonProject[] = await Promise.all(\n+                    vscode.workspace.workspaceFolders!.map(async (folder): Promise<JsonProject> => {\n+                        const rustDocuments = vscode.workspace.textDocuments.filter(isRustDocument);\n+                        return discoverWorkspace(rustDocuments, discoverProjectCommand, {\n+                            cwd: folder.uri.fsPath,\n+                        });\n+                    })\n+                );\n+\n+                this.addToDiscoveredWorkspaces(workspaces);\n+            }\n+\n+            const initializationOptions = prepareVSCodeConfig(\n+                rawInitializationOptions,\n+                (key, obj) => {\n+                    // we only want to set discovered workspaces on the right key\n+                    // and if a workspace has been discovered.\n+                    if (key === \"linkedProjects\" && this.config.discoveredWorkspaces.length > 0) {\n+                        obj[\"linkedProjects\"] = this.config.discoveredWorkspaces;\n+                    }\n+                }\n+            );\n \n             this._client = await createClient(\n                 this.traceOutputChannel,\n@@ -251,6 +293,17 @@ export class Ctx {\n         return this._serverPath;\n     }\n \n+    addToDiscoveredWorkspaces(workspaces: JsonProject[]) {\n+        for (const workspace of workspaces) {\n+            const index = this.config.discoveredWorkspaces.indexOf(workspace);\n+            if (~index) {\n+                this.config.discoveredWorkspaces[index] = workspace;\n+            } else {\n+                this.config.discoveredWorkspaces.push(workspace);\n+            }\n+        }\n+    }\n+\n     private updateCommands(forceDisable?: \"disable\") {\n         this.commandDisposables.forEach((disposable) => disposable.dispose());\n         this.commandDisposables = [];\n@@ -289,6 +342,7 @@ export class Ctx {\n                 statusBar.tooltip.appendText(status.message ?? \"Ready\");\n                 statusBar.color = undefined;\n                 statusBar.backgroundColor = undefined;\n+                statusBar.command = \"rust-analyzer.stopServer\";\n                 break;\n             case \"warning\":\n                 if (status.message) {\n@@ -298,6 +352,7 @@ export class Ctx {\n                 statusBar.backgroundColor = new vscode.ThemeColor(\n                     \"statusBarItem.warningBackground\"\n                 );\n+                statusBar.command = \"rust-analyzer.openLogs\";\n                 icon = \"$(warning) \";\n                 break;\n             case \"error\":\n@@ -306,6 +361,7 @@ export class Ctx {\n                 }\n                 statusBar.color = new vscode.ThemeColor(\"statusBarItem.errorForeground\");\n                 statusBar.backgroundColor = new vscode.ThemeColor(\"statusBarItem.errorBackground\");\n+                statusBar.command = \"rust-analyzer.openLogs\";\n                 icon = \"$(error) \";\n                 break;\n             case \"stopped\":\n@@ -315,18 +371,19 @@ export class Ctx {\n                 );\n                 statusBar.color = undefined;\n                 statusBar.backgroundColor = undefined;\n+                statusBar.command = \"rust-analyzer.startServer\";\n                 statusBar.text = `$(stop-circle) rust-analyzer`;\n                 return;\n         }\n         if (statusBar.tooltip.value) {\n             statusBar.tooltip.appendText(\"\\n\\n\");\n         }\n-        statusBar.tooltip.appendMarkdown(\"[Stop server](command:rust-analyzer.stopServer)\");\n         statusBar.tooltip.appendMarkdown(\n             \"\\n\\n[Reload Workspace](command:rust-analyzer.reloadWorkspace)\"\n         );\n-        statusBar.tooltip.appendMarkdown(\"\\n\\n[Restart server](command:rust-analyzer.startServer)\");\n         statusBar.tooltip.appendMarkdown(\"\\n\\n[Open logs](command:rust-analyzer.openLogs)\");\n+        statusBar.tooltip.appendMarkdown(\"\\n\\n[Restart server](command:rust-analyzer.startServer)\");\n+        statusBar.tooltip.appendMarkdown(\"[Stop server](command:rust-analyzer.stopServer)\");\n         if (!status.quiescent) icon = \"$(sync~spin) \";\n         statusBar.text = `${icon}rust-analyzer`;\n     }"}, {"sha": "872d7199b838a9926ee529a329f650d6938ba6f0", "filename": "src/tools/rust-analyzer/editors/code/src/lsp_ext.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Flsp_ext.ts", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Flsp_ext.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Flsp_ext.ts?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -43,6 +43,7 @@ export const relatedTests = new lc.RequestType<lc.TextDocumentPositionParams, Te\n     \"rust-analyzer/relatedTests\"\n );\n export const reloadWorkspace = new lc.RequestType0<null, void>(\"rust-analyzer/reloadWorkspace\");\n+\n export const runFlycheck = new lc.NotificationType<{\n     textDocument: lc.TextDocumentIdentifier | null;\n }>(\"rust-analyzer/runFlycheck\");"}, {"sha": "d5de00561b1235f4e8c9071a15e33d53a763a017", "filename": "src/tools/rust-analyzer/editors/code/src/main.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -153,6 +153,7 @@ function createCommands(): Record<string, CommandFactory> {\n         memoryUsage: { enabled: commands.memoryUsage },\n         shuffleCrateGraph: { enabled: commands.shuffleCrateGraph },\n         reloadWorkspace: { enabled: commands.reloadWorkspace },\n+        addProject: { enabled: commands.addProject },\n         matchingBrace: { enabled: commands.matchingBrace },\n         joinLines: { enabled: commands.joinLines },\n         parentModule: { enabled: commands.parentModule },"}, {"sha": "187a1a96c10c5c39874b0be3bc6bdf74b48d2d8d", "filename": "src/tools/rust-analyzer/editors/code/src/rust_project.ts", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Frust_project.ts", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Frust_project.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Frust_project.ts?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,91 @@\n+interface JsonProject {\n+    /// Path to the directory with *source code* of\n+    /// sysroot crates.\n+    ///\n+    /// It should point to the directory where std,\n+    /// core, and friends can be found:\n+    ///\n+    /// https://github.com/rust-lang/rust/tree/master/library.\n+    ///\n+    /// If provided, rust-analyzer automatically adds\n+    /// dependencies on sysroot crates. Conversely,\n+    /// if you omit this path, you can specify sysroot\n+    /// dependencies yourself and, for example, have\n+    /// several different \"sysroots\" in one graph of\n+    /// crates.\n+    sysroot_src?: string;\n+    /// The set of crates comprising the current\n+    /// project. Must include all transitive\n+    /// dependencies as well as sysroot crate (libstd,\n+    /// libcore and such).\n+    crates: Crate[];\n+}\n+\n+interface Crate {\n+    /// Optional crate name used for display purposes,\n+    /// without affecting semantics. See the `deps`\n+    /// key for semantically-significant crate names.\n+    display_name?: string;\n+    /// Path to the root module of the crate.\n+    root_module: string;\n+    /// Edition of the crate.\n+    edition: \"2015\" | \"2018\" | \"2021\";\n+    /// Dependencies\n+    deps: Dep[];\n+    /// Should this crate be treated as a member of\n+    /// current \"workspace\".\n+    ///\n+    /// By default, inferred from the `root_module`\n+    /// (members are the crates which reside inside\n+    /// the directory opened in the editor).\n+    ///\n+    /// Set this to `false` for things like standard\n+    /// library and 3rd party crates to enable\n+    /// performance optimizations (rust-analyzer\n+    /// assumes that non-member crates don't change).\n+    is_workspace_member?: boolean;\n+    /// Optionally specify the (super)set of `.rs`\n+    /// files comprising this crate.\n+    ///\n+    /// By default, rust-analyzer assumes that only\n+    /// files under `root_module.parent` can belong\n+    /// to a crate. `include_dirs` are included\n+    /// recursively, unless a subdirectory is in\n+    /// `exclude_dirs`.\n+    ///\n+    /// Different crates can share the same `source`.\n+    ///\n+    /// If two crates share an `.rs` file in common,\n+    /// they *must* have the same `source`.\n+    /// rust-analyzer assumes that files from one\n+    /// source can't refer to files in another source.\n+    source?: {\n+        include_dirs: string[];\n+        exclude_dirs: string[];\n+    };\n+    /// The set of cfgs activated for a given crate, like\n+    /// `[\"unix\", \"feature=\\\"foo\\\"\", \"feature=\\\"bar\\\"\"]`.\n+    cfg: string[];\n+    /// Target triple for this Crate.\n+    ///\n+    /// Used when running `rustc --print cfg`\n+    /// to get target-specific cfgs.\n+    target?: string;\n+    /// Environment variables, used for\n+    /// the `env!` macro\n+    env: { [key: string]: string };\n+\n+    /// Whether the crate is a proc-macro crate.\n+    is_proc_macro: boolean;\n+    /// For proc-macro crates, path to compiled\n+    /// proc-macro (.so file).\n+    proc_macro_dylib_path?: string;\n+}\n+\n+interface Dep {\n+    /// Index of a crate in the `crates` array.\n+    crate: number;\n+    /// Name as should appear in the (implicit)\n+    /// `extern crate name` declaration.\n+    name: string;\n+}"}, {"sha": "922fbcbcf35a5037ca624c9c72f34cf59de238e0", "filename": "src/tools/rust-analyzer/editors/code/src/util.ts", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Futil.ts", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Futil.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Futil.ts?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -150,9 +150,11 @@ export function memoizeAsync<Ret, TThis, Param extends string>(\n \n /** Awaitable wrapper around `child_process.exec` */\n export function execute(command: string, options: ExecOptions): Promise<string> {\n+    log.info(`running command: ${command}`);\n     return new Promise((resolve, reject) => {\n         exec(command, options, (err, stdout, stderr) => {\n             if (err) {\n+                log.error(err);\n                 reject(err);\n                 return;\n             }\n@@ -167,6 +169,21 @@ export function execute(command: string, options: ExecOptions): Promise<string>\n     });\n }\n \n+export function executeDiscoverProject(command: string, options: ExecOptions): Promise<string> {\n+    log.info(`running command: ${command}`);\n+    return new Promise((resolve, reject) => {\n+        exec(command, options, (err, stdout, _) => {\n+            if (err) {\n+                log.error(err);\n+                reject(err);\n+                return;\n+            }\n+\n+            resolve(stdout.trimEnd());\n+        });\n+    });\n+}\n+\n export class LazyOutputChannel implements vscode.OutputChannel {\n     constructor(name: string) {\n         this.name = name;"}, {"sha": "8286bd506bca7838ca24d99eb0944b461d00cd7b", "filename": "src/tools/rustbook/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frustbook%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Frustbook%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2FCargo.toml?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -9,6 +9,6 @@ clap = \"4.0.32\"\n env_logger = \"0.7.1\"\n \n [dependencies.mdbook]\n-version = \"0.4.25\"\n+version = \"0.4.28\"\n default-features = false\n features = [\"search\"]"}, {"sha": "a9eb6c8d03f72bbbf14ccd236740486df25c9e7e", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -260,6 +260,7 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"valuable\",\n     \"version_check\",\n     \"wasi\",\n+    \"windows\",\n     \"winapi\",\n     \"winapi-i686-pc-windows-gnu\",\n     \"winapi-util\","}, {"sha": "b316e9e9009fcad18fee617ac01f0cc158227eb5", "filename": "src/tools/tidy/src/mir_opt_tests.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Ftidy%2Fsrc%2Fmir_opt_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Ftidy%2Fsrc%2Fmir_opt_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmir_opt_tests.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -3,19 +3,24 @@\n use std::collections::HashSet;\n use std::path::{Path, PathBuf};\n \n+use crate::walk::walk_no_read;\n+\n fn check_unused_files(path: &Path, bless: bool, bad: &mut bool) {\n     let mut rs_files = Vec::<PathBuf>::new();\n     let mut output_files = HashSet::<PathBuf>::new();\n-    let files = walkdir::WalkDir::new(&path.join(\"mir-opt\")).into_iter();\n \n-    for file in files.filter_map(Result::ok).filter(|e| e.file_type().is_file()) {\n-        let filepath = file.path();\n-        if filepath.extension() == Some(\"rs\".as_ref()) {\n-            rs_files.push(filepath.to_owned());\n-        } else {\n-            output_files.insert(filepath.to_owned());\n-        }\n-    }\n+    walk_no_read(\n+        &[&path.join(\"mir-opt\")],\n+        |path| path.file_name() == Some(\"README.md\".as_ref()),\n+        &mut |file| {\n+            let filepath = file.path();\n+            if filepath.extension() == Some(\"rs\".as_ref()) {\n+                rs_files.push(filepath.to_owned());\n+            } else {\n+                output_files.insert(filepath.to_owned());\n+            }\n+        },\n+    );\n \n     for file in rs_files {\n         for bw in [32, 64] {\n@@ -26,16 +31,14 @@ fn check_unused_files(path: &Path, bless: bool, bad: &mut bool) {\n     }\n \n     for extra in output_files {\n-        if extra.file_name() != Some(\"README.md\".as_ref()) {\n-            if !bless {\n-                tidy_error!(\n-                    bad,\n-                    \"the following output file is not associated with any mir-opt test, you can remove it: {}\",\n-                    extra.display()\n-                );\n-            } else {\n-                let _ = std::fs::remove_file(extra);\n-            }\n+        if !bless {\n+            tidy_error!(\n+                bad,\n+                \"the following output file is not associated with any mir-opt test, you can remove it: {}\",\n+                extra.display()\n+            );\n+        } else {\n+            let _ = std::fs::remove_file(extra);\n         }\n     }\n }"}, {"sha": "6b7b27fd526c3caf88a2e0b3b5ce05b9a686eab9", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -59,7 +59,6 @@ const EXCEPTION_PATHS: &[&str] = &[\n     \"library/std/src/path.rs\",\n     \"library/std/src/sys_common\", // Should only contain abstractions over platforms\n     \"library/std/src/net/test.rs\", // Utility helpers for tests\n-    \"library/std/src/panic.rs\",   // fuchsia-specific panic backtrace handling\n     \"library/std/src/personality.rs\",\n     \"library/std/src/personality/\",\n ];"}, {"sha": "0e74eb1b2f2631b561ce698b9c352c687ffba803", "filename": "tests/incremental/auxiliary/circular-dependencies-aux.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fincremental%2Fauxiliary%2Fcircular-dependencies-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fincremental%2Fauxiliary%2Fcircular-dependencies-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fincremental%2Fauxiliary%2Fcircular-dependencies-aux.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,10 @@\n+// edition: 2021\n+// compile-flags: --crate-type lib --extern circular_dependencies={{build-base}}/circular-dependencies/libcircular_dependencies.rmeta --emit dep-info,metadata\n+\n+use circular_dependencies::Foo;\n+\n+pub fn consume_foo(_: Foo) {}\n+\n+pub fn produce_foo() -> Foo {\n+    Foo\n+}"}, {"sha": "10673066a9df09b2e1f9f29dc8eb836b57b3875a", "filename": "tests/incremental/circular-dependencies.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fincremental%2Fcircular-dependencies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fincremental%2Fcircular-dependencies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fincremental%2Fcircular-dependencies.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,37 @@\n+// ignore-tidy-linelength\n+// revisions: cpass1 cfail2\n+// edition: 2021\n+// [cpass1] compile-flags: --crate-type lib --emit dep-info,metadata\n+// [cfail2] aux-build: circular-dependencies-aux.rs\n+// [cfail2] compile-flags: --test --extern aux={{build-base}}/circular-dependencies/auxiliary/libcircular_dependencies_aux.rmeta -L dependency={{build-base}}/circular-dependencies\n+\n+pub struct Foo;\n+//[cfail2]~^ NOTE `Foo` is defined in the current crate\n+//[cfail2]~| NOTE `Foo` is defined in the current crate\n+//[cfail2]~| NOTE `circular_dependencies::Foo` is defined in crate `circular_dependencies`\n+//[cfail2]~| NOTE `circular_dependencies::Foo` is defined in crate `circular_dependencies`\n+\n+pub fn consume_foo(_: Foo) {}\n+//[cfail2]~^ NOTE function defined here\n+\n+pub fn produce_foo() -> Foo {\n+    Foo\n+}\n+\n+#[test]\n+fn test() {\n+    aux::consume_foo(produce_foo());\n+    //[cfail2]~^ ERROR mismatched types [E0308]\n+    //[cfail2]~| NOTE expected `circular_dependencies::Foo`, found `Foo`\n+    //[cfail2]~| NOTE arguments to this function are incorrect\n+    //[cfail2]~| NOTE `Foo` and `circular_dependencies::Foo` have similar names, but are actually distinct types\n+    //[cfail2]~| NOTE the crate `circular_dependencies` is compiled multiple times, possibly with different configurations\n+    //[cfail2]~| NOTE function defined here\n+\n+    consume_foo(aux::produce_foo());\n+    //[cfail2]~^ ERROR mismatched types [E0308]\n+    //[cfail2]~| NOTE expected `Foo`, found `circular_dependencies::Foo`\n+    //[cfail2]~| NOTE arguments to this function are incorrect\n+    //[cfail2]~| NOTE `circular_dependencies::Foo` and `Foo` have similar names, but are actually distinct types\n+    //[cfail2]~| NOTE the crate `circular_dependencies` is compiled multiple times, possibly with different configurations\n+}"}, {"sha": "58f746f2e0ef87eb24440ee458d1209c04e64f2d", "filename": "tests/pretty/tests-are-sorted.pp", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fpretty%2Ftests-are-sorted.pp", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fpretty%2Ftests-are-sorted.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpretty%2Ftests-are-sorted.pp?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -4,7 +4,7 @@\n use ::std::prelude::rust_2015::*;\n #[macro_use]\n extern crate std;\n-// compile-flags: --crate-type=lib --test\n+// compile-flags: --crate-type=lib --test --remap-path-prefix={{src-base}}/=/the/src/ --remap-path-prefix={{src-base}}\\=/the/src/\n // pretty-compare-only\n // pretty-mode:expanded\n // pp-exact:tests-are-sorted.pp\n@@ -18,6 +18,11 @@\n             name: test::StaticTestName(\"m_test\"),\n             ignore: false,\n             ignore_message: ::core::option::Option::None,\n+            source_file: \"/the/src/tests-are-sorted.rs\",\n+            start_line: 7usize,\n+            start_col: 4usize,\n+            end_line: 7usize,\n+            end_col: 10usize,\n             compile_fail: false,\n             no_run: false,\n             should_panic: test::ShouldPanic::No,\n@@ -34,15 +39,21 @@\n     test::TestDescAndFn {\n         desc: test::TestDesc {\n             name: test::StaticTestName(\"z_test\"),\n-            ignore: false,\n-            ignore_message: ::core::option::Option::None,\n+            ignore: true,\n+            ignore_message: ::core::option::Option::Some(\"not yet implemented\"),\n+            source_file: \"/the/src/tests-are-sorted.rs\",\n+            start_line: 11usize,\n+            start_col: 4usize,\n+            end_line: 11usize,\n+            end_col: 10usize,\n             compile_fail: false,\n             no_run: false,\n             should_panic: test::ShouldPanic::No,\n             test_type: test::TestType::Unknown,\n         },\n         testfn: test::StaticTestFn(|| test::assert_test_result(z_test())),\n     };\n+#[ignore = \"not yet implemented\"]\n fn z_test() {}\n \n extern crate test;\n@@ -54,6 +65,11 @@\n             name: test::StaticTestName(\"a_test\"),\n             ignore: false,\n             ignore_message: ::core::option::Option::None,\n+            source_file: \"/the/src/tests-are-sorted.rs\",\n+            start_line: 14usize,\n+            start_col: 4usize,\n+            end_line: 14usize,\n+            end_col: 10usize,\n             compile_fail: false,\n             no_run: false,\n             should_panic: test::ShouldPanic::No,"}, {"sha": "39e0922250b8d0c02e36d4b8278a376fbea060e5", "filename": "tests/pretty/tests-are-sorted.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fpretty%2Ftests-are-sorted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fpretty%2Ftests-are-sorted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpretty%2Ftests-are-sorted.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: --crate-type=lib --test\n+// compile-flags: --crate-type=lib --test --remap-path-prefix={{src-base}}/=/the/src/ --remap-path-prefix={{src-base}}\\=/the/src/\n // pretty-compare-only\n // pretty-mode:expanded\n // pp-exact:tests-are-sorted.pp\n@@ -7,6 +7,7 @@\n fn m_test() {}\n \n #[test]\n+#[ignore = \"not yet implemented\"]\n fn z_test() {}\n \n #[test]"}, {"sha": "ea06b620c4cff7b24b41adb586fa0a038caf6ebf", "filename": "tests/run-make-fulldeps/tools.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Frun-make-fulldeps%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Frun-make-fulldeps%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make-fulldeps%2Ftools.mk?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -112,9 +112,9 @@ endif\n # Extra flags needed to compile a working executable with the standard library\n ifdef IS_WINDOWS\n ifdef IS_MSVC\n-\tEXTRACFLAGS := ws2_32.lib userenv.lib advapi32.lib bcrypt.lib\n+\tEXTRACFLAGS := ws2_32.lib userenv.lib advapi32.lib bcrypt.lib ntdll.lib\n else\n-\tEXTRACFLAGS := -lws2_32 -luserenv -lbcrypt\n+\tEXTRACFLAGS := -lws2_32 -luserenv -lbcrypt -lntdll\n \tEXTRACXXFLAGS := -lstdc++\n \t# So this is a bit hacky: we can't use the DLL version of libstdc++ because\n \t# it pulls in the DLL version of libgcc, which means that we end up with 2"}, {"sha": "c56a3df5f904c06312aca4393a77304bc08abb0b", "filename": "tests/rustdoc-js/search-bag-semantics.js", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Frustdoc-js%2Fsearch-bag-semantics.js", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Frustdoc-js%2Fsearch-bag-semantics.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fsearch-bag-semantics.js?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,20 @@\n+// exact-check\n+\n+const QUERY = [\n+    'P',\n+    'P, P',\n+];\n+\n+const EXPECTED = [\n+    {\n+        'in_args': [\n+            { 'path': 'search_bag_semantics', 'name': 'alacazam' },\n+            { 'path': 'search_bag_semantics', 'name': 'abracadabra' },\n+        ],\n+    },\n+    {\n+        'others': [\n+            { 'path': 'search_bag_semantics', 'name': 'abracadabra' },\n+        ],\n+    },\n+];"}, {"sha": "546572dc4ef06660797ea48145cfaf8877fbc574", "filename": "tests/rustdoc-js/search-bag-semantics.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Frustdoc-js%2Fsearch-bag-semantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Frustdoc-js%2Fsearch-bag-semantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fsearch-bag-semantics.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,4 @@\n+pub struct P;\n+\n+pub fn abracadabra(a: P, b: P) {}\n+pub fn alacazam(a: P) {}"}, {"sha": "33bebbab5e0080810a6056db224d45c4eaf34446", "filename": "tests/rustdoc-json/fns/extern_c_variadic.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Frustdoc-json%2Ffns%2Fextern_c_variadic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Frustdoc-json%2Ffns%2Fextern_c_variadic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-json%2Ffns%2Fextern_c_variadic.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,9 @@\n+#![feature(no_core)]\n+#![no_core]\n+\n+extern \"C\" {\n+    // @is \"$.index[*][?(@.name == 'not_variadic')].inner.decl.c_variadic\" false\n+    pub fn not_variadic(_: i32);\n+    // @is \"$.index[*][?(@.name == 'variadic')].inner.decl.c_variadic\" true\n+    pub fn variadic(_: i32, ...);\n+}"}, {"sha": "31fef032b0fc959cfca692666144c9a22e36fcd3", "filename": "tests/rustdoc-ui/intra-doc/import-inline-merge.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Frustdoc-ui%2Fintra-doc%2Fimport-inline-merge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Frustdoc-ui%2Fintra-doc%2Fimport-inline-merge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fimport-inline-merge.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,16 @@\n+// Import for `A` is inlined and doc comments on the import and `A` itself are merged.\n+// After the merge they still have correct parent scopes to resolve both `[A]` and `[B]`.\n+\n+// check-pass\n+\n+#![allow(rustdoc::private_intra_doc_links)]\n+\n+mod m {\n+    /// [B]\n+    pub struct A {}\n+\n+    pub struct B {}\n+}\n+\n+/// [A]\n+pub use m::A;"}, {"sha": "9c9c0945b8fd94500f180193514b0bbe452f3d6e", "filename": "tests/rustdoc/deprecated.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Frustdoc%2Fdeprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Frustdoc%2Fdeprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fdeprecated.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -28,6 +28,6 @@ pub struct V;\n pub struct W;\n \n // @matches deprecated/struct.X.html '//*[@class=\"stab deprecated\"]' \\\n-//      'Deprecated: shorthand reason$'\n-#[deprecated = \"shorthand reason\"]\n+//      'Deprecated: shorthand reason: code$'\n+#[deprecated = \"shorthand reason: `code`\"]\n pub struct X;"}, {"sha": "e6ff5a7fd51dcb901366c10a33381c3ed282bf60", "filename": "tests/rustdoc/footnote-in-summary.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Frustdoc%2Ffootnote-in-summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Frustdoc%2Ffootnote-in-summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Ffootnote-in-summary.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,17 @@\n+// This test ensures that no footnote reference is generated inside\n+// summary doc.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/index.html'\n+// @has - '//*[@class=\"desc docblock-short\"]' 'hello bla'\n+// @!has - '//*[@class=\"desc docblock-short\"]/sup' '1'\n+\n+// @has 'foo/struct.S.html'\n+// @has - '//*[@class=\"docblock\"]//sup' '1'\n+// @has - '//*[@class=\"docblock\"]' 'hello 1 bla'\n+\n+/// hello [^foot] bla\n+///\n+/// [^foot]: blabla\n+pub struct S;"}, {"sha": "96f606368b27db0c435d51221b10356d903c88d3", "filename": "tests/rustdoc/issue-109258-missing-private-inlining.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Frustdoc%2Fissue-109258-missing-private-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Frustdoc%2Fissue-109258-missing-private-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-109258-missing-private-inlining.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,27 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/109258>.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/index.html'\n+// We should only have a \"Re-exports\" and a \"Modules\" headers.\n+// @count - '//*[@id=\"main-content\"]/h2[@class=\"small-section-header\"]' 2\n+// @has - '//*[@id=\"main-content\"]/h2[@class=\"small-section-header\"]' 'Re-exports'\n+// @has - '//*[@id=\"main-content\"]/h2[@class=\"small-section-header\"]' 'Modules'\n+\n+// @has - '//*[@id=\"reexport.Foo\"]' 'pub use crate::issue_109258::Foo;'\n+// @has - '//*[@id=\"reexport.Foo\"]//a[@href=\"issue_109258/struct.Foo.html\"]' 'Foo'\n+// @!has 'foo/struct.Foo.html'\n+pub use crate::issue_109258::Foo;\n+\n+// @has 'foo/issue_109258/index.html'\n+// We should only have a \"Structs\" header.\n+// @count - '//*[@id=\"main-content\"]/h2[@class=\"small-section-header\"]' 1\n+// @has - '//*[@id=\"main-content\"]/h2[@class=\"small-section-header\"]' 'Structs'\n+// @has - '//*[@id=\"main-content\"]//a[@href=\"struct.Foo.html\"]' 'Foo'\n+// @has 'foo/issue_109258/struct.Foo.html'\n+pub mod issue_109258 {\n+    mod priv_mod {\n+        pub struct Foo;\n+    }\n+    pub use self::priv_mod::Foo;\n+}"}, {"sha": "8e5dbd08eb98bb9302596514849b95f78822cfe9", "filename": "tests/ui/async-await/in-trait/issue-102310.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fasync-await%2Fin-trait%2Fissue-102310.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fasync-await%2Fin-trait%2Fissue-102310.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fissue-102310.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,5 +1,7 @@\n // check-pass\n // edition:2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "0e9477544a4a6febde94fbb27295f994278be3fb", "filename": "tests/ui/async-await/in-trait/lifetime-mismatch.current.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.current.stderr?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,5 +1,5 @@\n warning: the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/lifetime-mismatch.rs:3:12\n+  --> $DIR/lifetime-mismatch.rs:5:12\n    |\n LL | #![feature(async_fn_in_trait)]\n    |            ^^^^^^^^^^^^^^^^^\n@@ -8,7 +8,7 @@ LL | #![feature(async_fn_in_trait)]\n    = note: `#[warn(incomplete_features)]` on by default\n \n error[E0195]: lifetime parameters or bounds on method `foo` do not match the trait declaration\n-  --> $DIR/lifetime-mismatch.rs:12:17\n+  --> $DIR/lifetime-mismatch.rs:14:17\n    |\n LL |     async fn foo<'a>(&self);\n    |                 ---- lifetimes in impl do not match this method in trait", "previous_filename": "tests/ui/async-await/in-trait/lifetime-mismatch.stderr"}, {"sha": "0e9477544a4a6febde94fbb27295f994278be3fb", "filename": "tests/ui/async-await/in-trait/lifetime-mismatch.next.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.next.stderr?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,21 @@\n+warning: the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/lifetime-mismatch.rs:5:12\n+   |\n+LL | #![feature(async_fn_in_trait)]\n+   |            ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0195]: lifetime parameters or bounds on method `foo` do not match the trait declaration\n+  --> $DIR/lifetime-mismatch.rs:14:17\n+   |\n+LL |     async fn foo<'a>(&self);\n+   |                 ---- lifetimes in impl do not match this method in trait\n+...\n+LL |     async fn foo(&self) {}\n+   |                 ^ lifetimes do not match method in trait\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0195`."}, {"sha": "5ff5a01a1ee0356a3c63d4c069bc72705c69e548", "filename": "tests/ui/async-await/in-trait/lifetime-mismatch.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,4 +1,6 @@\n // edition:2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n //~^ WARN the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes"}, {"sha": "734a37862940f05badaae18ecfb6232f24b8258d", "filename": "tests/ui/const-generics/generic_const_exprs/mismatched-gat-subst-kind.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fmismatched-gat-subst-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fmismatched-gat-subst-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fmismatched-gat-subst-kind.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,11 @@\n+#![feature(generic_const_exprs)]\n+//~^ WARN the feature `generic_const_exprs` is incomplete\n+\n+trait B {\n+    type U<T>;\n+}\n+\n+fn f<T: B<U<1i32> = ()>>() {}\n+//~^ ERROR constant provided when a type was expected\n+\n+fn main() {}"}, {"sha": "8b6eb5b75940f052edd9252e2d6758d590800a9b", "filename": "tests/ui/const-generics/generic_const_exprs/mismatched-gat-subst-kind.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fmismatched-gat-subst-kind.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fmismatched-gat-subst-kind.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fmismatched-gat-subst-kind.stderr?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,18 @@\n+warning: the feature `generic_const_exprs` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/mismatched-gat-subst-kind.rs:1:12\n+   |\n+LL | #![feature(generic_const_exprs)]\n+   |            ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #76560 <https://github.com/rust-lang/rust/issues/76560> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0747]: constant provided when a type was expected\n+  --> $DIR/mismatched-gat-subst-kind.rs:8:13\n+   |\n+LL | fn f<T: B<U<1i32> = ()>>() {}\n+   |             ^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0747`."}, {"sha": "831033a588061cc0efc2cefacfd8818b27e8f07e", "filename": "tests/ui/impl-trait/in-trait/early.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fearly.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,5 +1,7 @@\n // check-pass\n // edition:2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait, return_position_impl_trait_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "1329ca29d06aa99fcebd360cfc22662a6e244420", "filename": "tests/ui/impl-trait/in-trait/issue-102301.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fissue-102301.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fissue-102301.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fissue-102301.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,4 +1,6 @@\n // check-pass\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(return_position_impl_trait_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "f48d9fa26c003ce40d4af5d812b48f61b8c7820d", "filename": "tests/ui/impl-trait/in-trait/opaque-in-impl.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fopaque-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fopaque-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fopaque-in-impl.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,4 +1,6 @@\n // check-pass\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(return_position_impl_trait_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "64c942705cf8e5ab86f7147101ee3d94c3f06740", "filename": "tests/ui/impl-trait/in-trait/trait-more-generics-than-impl.current.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.current.stderr?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,5 +1,5 @@\n error[E0049]: method `bar` has 0 type parameters but its trait declaration has 1 type parameter\n-  --> $DIR/trait-more-generics-than-impl.rs:11:11\n+  --> $DIR/trait-more-generics-than-impl.rs:14:11\n    |\n LL |     fn bar<T>() -> impl Sized;\n    |            - expected 1 type parameter", "previous_filename": "tests/ui/impl-trait/in-trait/trait-more-generics-than-impl.stderr"}, {"sha": "64c942705cf8e5ab86f7147101ee3d94c3f06740", "filename": "tests/ui/impl-trait/in-trait/trait-more-generics-than-impl.next.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.next.stderr?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,12 @@\n+error[E0049]: method `bar` has 0 type parameters but its trait declaration has 1 type parameter\n+  --> $DIR/trait-more-generics-than-impl.rs:14:11\n+   |\n+LL |     fn bar<T>() -> impl Sized;\n+   |            - expected 1 type parameter\n+...\n+LL |     fn bar() -> impl Sized {}\n+   |           ^ found 0 type parameters\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0049`."}, {"sha": "c2e394a1f664518a7eb58f1fa468da59d1b3daa1", "filename": "tests/ui/impl-trait/in-trait/trait-more-generics-than-impl.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,3 +1,6 @@\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n+\n #![feature(return_position_impl_trait_in_trait)]\n #![allow(incomplete_features)]\n "}, {"sha": "88d86e2b541929fc5dc0672cd923c87a9feee633", "filename": "tests/ui/impl-trait/in-trait/where-clause.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwhere-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwhere-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwhere-clause.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,5 +1,7 @@\n // check-pass\n // edition: 2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(return_position_impl_trait_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "0f688fa282356dca1372cd3380c296941a38180a", "filename": "tests/ui/imports/issue-99695-b.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimports%2Fissue-99695-b.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimports%2Fissue-99695-b.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Fissue-99695-b.fixed?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(unused, nonstandard_style)]\n+#![allow(unused, nonstandard_style, useless_anonymous_reexport)]\n mod m {\n \n     mod p {"}, {"sha": "b433997e53f6a7b8a7c77ad7c003e3e105e840db", "filename": "tests/ui/imports/issue-99695-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimports%2Fissue-99695-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimports%2Fissue-99695-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Fissue-99695-b.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(unused, nonstandard_style)]\n+#![allow(unused, nonstandard_style, useless_anonymous_reexport)]\n mod m {\n \n     mod p {"}, {"sha": "17ff409324e3401ce8acba9f80707a9c5dcdf40d", "filename": "tests/ui/imports/issue-99695.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimports%2Fissue-99695.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimports%2Fissue-99695.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Fissue-99695.fixed?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(unused, nonstandard_style)]\n+#![allow(unused, nonstandard_style, useless_anonymous_reexport)]\n mod m {\n     #[macro_export]\n     macro_rules! nu {"}, {"sha": "b8979bcb7345ca81c9177980271489ffae244565", "filename": "tests/ui/imports/issue-99695.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimports%2Fissue-99695.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fimports%2Fissue-99695.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Fissue-99695.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(unused, nonstandard_style)]\n+#![allow(unused, nonstandard_style, useless_anonymous_reexport)]\n mod m {\n     #[macro_export]\n     macro_rules! nu {"}, {"sha": "2f740e55389730bf0550a9124ea68583b223e0b7", "filename": "tests/ui/linkage-attr/issue-109144.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Flinkage-attr%2Fissue-109144.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Flinkage-attr%2Fissue-109144.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flinkage-attr%2Fissue-109144.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,4 @@\n+#![crate_type = \"lib\"]\n+#[link(kind = \"static\", modifiers = \"+whole-archive,+bundle\")]\n+//~^ ERROR `#[link]` attribute requires a `name = \"string\"` argument\n+extern  {}"}, {"sha": "33187cfdbb63674aa8235a72f6c82ff50dc991c3", "filename": "tests/ui/linkage-attr/issue-109144.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Flinkage-attr%2Fissue-109144.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Flinkage-attr%2Fissue-109144.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flinkage-attr%2Fissue-109144.stderr?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,9 @@\n+error[E0459]: `#[link]` attribute requires a `name = \"string\"` argument\n+  --> $DIR/issue-109144.rs:2:1\n+   |\n+LL | #[link(kind = \"static\", modifiers = \"+whole-archive,+bundle\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `name` argument\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0459`."}, {"sha": "5d56ae6f969b551107c4c1466e640565128961b3", "filename": "tests/ui/lint/anonymous-reexport.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Flint%2Fanonymous-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Flint%2Fanonymous-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fanonymous-reexport.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,21 @@\n+#![deny(useless_anonymous_reexport)]\n+#![crate_type = \"rlib\"]\n+\n+mod my_mod {\n+    pub trait Foo {}\n+    pub type TyFoo = dyn Foo;\n+    pub struct Bar;\n+    pub type TyBar = Bar;\n+}\n+\n+pub use self::my_mod::Foo as _;\n+pub use self::my_mod::TyFoo as _;\n+pub use self::my_mod::Bar as _; //~ ERROR\n+pub use self::my_mod::TyBar as _; //~ ERROR\n+pub use self::my_mod::{Bar as _}; //~ ERROR\n+pub use self::my_mod::{Bar as _, Foo as _}; //~ ERROR\n+pub use self::my_mod::{Bar as _, TyBar as _};\n+//~^ ERROR\n+//~| ERROR\n+#[allow(unused_imports)]\n+use self::my_mod::TyBar as _;"}, {"sha": "f4f8b41c417a438192381ae6be7717597946ab6f", "filename": "tests/ui/lint/anonymous-reexport.stderr", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Flint%2Fanonymous-reexport.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Flint%2Fanonymous-reexport.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fanonymous-reexport.stderr?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,55 @@\n+error: useless anonymous re-export\n+  --> $DIR/anonymous-reexport.rs:13:1\n+   |\n+LL | pub use self::my_mod::Bar as _;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only anonymous re-exports of traits are useful, this is a `struct`\n+note: the lint level is defined here\n+  --> $DIR/anonymous-reexport.rs:1:9\n+   |\n+LL | #![deny(useless_anonymous_reexport)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: useless anonymous re-export\n+  --> $DIR/anonymous-reexport.rs:14:1\n+   |\n+LL | pub use self::my_mod::TyBar as _;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only anonymous re-exports of traits are useful, this is a `type alias`\n+\n+error: useless anonymous re-export\n+  --> $DIR/anonymous-reexport.rs:15:24\n+   |\n+LL | pub use self::my_mod::{Bar as _};\n+   |                        ^^^^^^^^\n+   |\n+   = note: only anonymous re-exports of traits are useful, this is a `struct`\n+\n+error: useless anonymous re-export\n+  --> $DIR/anonymous-reexport.rs:16:24\n+   |\n+LL | pub use self::my_mod::{Bar as _, Foo as _};\n+   |                        ^^^^^^^^\n+   |\n+   = note: only anonymous re-exports of traits are useful, this is a `struct`\n+\n+error: useless anonymous re-export\n+  --> $DIR/anonymous-reexport.rs:17:24\n+   |\n+LL | pub use self::my_mod::{Bar as _, TyBar as _};\n+   |                        ^^^^^^^^\n+   |\n+   = note: only anonymous re-exports of traits are useful, this is a `struct`\n+\n+error: useless anonymous re-export\n+  --> $DIR/anonymous-reexport.rs:17:34\n+   |\n+LL | pub use self::my_mod::{Bar as _, TyBar as _};\n+   |                                  ^^^^^^^^^^\n+   |\n+   = note: only anonymous re-exports of traits are useful, this is a `type alias`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "09fda33dbec5c1c51aee99c2dd1bca45494d78ed", "filename": "tests/ui/lint/clashing-extern-fn.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Flint%2Fclashing-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Flint%2Fclashing-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fclashing-extern-fn.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -122,8 +122,8 @@ mod banana {\n             weight: u32,\n             length: u16,\n         } // note: distinct type\n-          // This should not trigger the lint because two::Banana is structurally equivalent to\n-          // one::Banana.\n+        // This should not trigger the lint because two::Banana is structurally equivalent to\n+        // one::Banana.\n         extern \"C\" {\n             fn weigh_banana(count: *const Banana) -> u64;\n         }\n@@ -223,6 +223,27 @@ mod transparent {\n     }\n }\n \n+#[allow(improper_ctypes)]\n+mod zst {\n+    mod transparent {\n+        #[repr(transparent)]\n+        struct TransparentZst(());\n+        extern \"C\" {\n+            fn zst() -> ();\n+            fn transparent_zst() -> TransparentZst;\n+        }\n+    }\n+\n+    mod not_transparent {\n+        struct NotTransparentZst(());\n+        extern \"C\" {\n+            // These shouldn't warn since all return types are zero sized\n+            fn zst() -> NotTransparentZst;\n+            fn transparent_zst() -> NotTransparentZst;\n+        }\n+    }\n+}\n+\n mod missing_return_type {\n     mod a {\n         extern \"C\" {\n@@ -397,10 +418,14 @@ mod hidden_niche {\n         use std::num::NonZeroUsize;\n \n         #[repr(transparent)]\n-        struct Transparent { x: NonZeroUsize }\n+        struct Transparent {\n+            x: NonZeroUsize,\n+        }\n \n         #[repr(transparent)]\n-        struct TransparentNoNiche { y: UnsafeCell<NonZeroUsize> }\n+        struct TransparentNoNiche {\n+            y: UnsafeCell<NonZeroUsize>,\n+        }\n \n         extern \"C\" {\n             fn hidden_niche_transparent() -> Option<Transparent>;"}, {"sha": "5d457ba0ec7637401eab9505b7ce690fb2e9c494", "filename": "tests/ui/lint/clashing-extern-fn.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Flint%2Fclashing-extern-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Flint%2Fclashing-extern-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fclashing-extern-fn.stderr?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -130,7 +130,7 @@ LL |             fn transparent_incorrect() -> isize;\n               found `unsafe extern \"C\" fn() -> isize`\n \n warning: `missing_return_type` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:238:13\n+  --> $DIR/clashing-extern-fn.rs:259:13\n    |\n LL |             fn missing_return_type() -> usize;\n    |             ---------------------------------- `missing_return_type` previously declared here\n@@ -142,7 +142,7 @@ LL |             fn missing_return_type();\n               found `unsafe extern \"C\" fn()`\n \n warning: `non_zero_usize` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:256:13\n+  --> $DIR/clashing-extern-fn.rs:277:13\n    |\n LL |             fn non_zero_usize() -> core::num::NonZeroUsize;\n    |             ----------------------------------------------- `non_zero_usize` previously declared here\n@@ -154,7 +154,7 @@ LL |             fn non_zero_usize() -> usize;\n               found `unsafe extern \"C\" fn() -> usize`\n \n warning: `non_null_ptr` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:258:13\n+  --> $DIR/clashing-extern-fn.rs:279:13\n    |\n LL |             fn non_null_ptr() -> core::ptr::NonNull<usize>;\n    |             ----------------------------------------------- `non_null_ptr` previously declared here\n@@ -166,7 +166,7 @@ LL |             fn non_null_ptr() -> *const usize;\n               found `unsafe extern \"C\" fn() -> *const usize`\n \n warning: `option_non_zero_usize_incorrect` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:356:13\n+  --> $DIR/clashing-extern-fn.rs:377:13\n    |\n LL |             fn option_non_zero_usize_incorrect() -> usize;\n    |             ---------------------------------------------- `option_non_zero_usize_incorrect` previously declared here\n@@ -178,7 +178,7 @@ LL |             fn option_non_zero_usize_incorrect() -> isize;\n               found `unsafe extern \"C\" fn() -> isize`\n \n warning: `option_non_null_ptr_incorrect` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:358:13\n+  --> $DIR/clashing-extern-fn.rs:379:13\n    |\n LL |             fn option_non_null_ptr_incorrect() -> *const usize;\n    |             --------------------------------------------------- `option_non_null_ptr_incorrect` previously declared here\n@@ -190,7 +190,7 @@ LL |             fn option_non_null_ptr_incorrect() -> *const isize;\n               found `unsafe extern \"C\" fn() -> *const isize`\n \n warning: `hidden_niche_transparent_no_niche` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:408:13\n+  --> $DIR/clashing-extern-fn.rs:433:13\n    |\n LL |             fn hidden_niche_transparent_no_niche() -> usize;\n    |             ------------------------------------------------ `hidden_niche_transparent_no_niche` previously declared here\n@@ -202,7 +202,7 @@ LL |             fn hidden_niche_transparent_no_niche() -> Option<TransparentNoN\n               found `unsafe extern \"C\" fn() -> Option<TransparentNoNiche>`\n \n warning: `hidden_niche_unsafe_cell` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:412:13\n+  --> $DIR/clashing-extern-fn.rs:437:13\n    |\n LL |             fn hidden_niche_unsafe_cell() -> usize;\n    |             --------------------------------------- `hidden_niche_unsafe_cell` previously declared here\n@@ -214,7 +214,7 @@ LL |             fn hidden_niche_unsafe_cell() -> Option<UnsafeCell<NonZeroUsize\n               found `unsafe extern \"C\" fn() -> Option<UnsafeCell<NonZeroUsize>>`\n \n warning: `extern` block uses type `Option<TransparentNoNiche>`, which is not FFI-safe\n-  --> $DIR/clashing-extern-fn.rs:408:55\n+  --> $DIR/clashing-extern-fn.rs:433:55\n    |\n LL |             fn hidden_niche_transparent_no_niche() -> Option<TransparentNoNiche>;\n    |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ not FFI-safe\n@@ -224,7 +224,7 @@ LL |             fn hidden_niche_transparent_no_niche() -> Option<TransparentNoN\n    = note: `#[warn(improper_ctypes)]` on by default\n \n warning: `extern` block uses type `Option<UnsafeCell<NonZeroUsize>>`, which is not FFI-safe\n-  --> $DIR/clashing-extern-fn.rs:412:46\n+  --> $DIR/clashing-extern-fn.rs:437:46\n    |\n LL |             fn hidden_niche_unsafe_cell() -> Option<UnsafeCell<NonZeroUsize>>;\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not FFI-safe"}, {"sha": "23d2a4b0a99c642103b2587668bbad5fca5e858d", "filename": "tests/ui/rfc-2091-track-caller/intrinsic-wrapper.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Frfc-2091-track-caller%2Fintrinsic-wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Frfc-2091-track-caller%2Fintrinsic-wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2091-track-caller%2Fintrinsic-wrapper.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -1,5 +1,6 @@\n // run-pass\n // revisions: default mir-opt\n+//[default] compile-flags: -Zinline-mir=no\n //[mir-opt] compile-flags: -Zmir-opt-level=4\n \n macro_rules! caller_location_from_macro {\n@@ -9,13 +10,13 @@ macro_rules! caller_location_from_macro {\n fn main() {\n     let loc = core::panic::Location::caller();\n     assert_eq!(loc.file(), file!());\n-    assert_eq!(loc.line(), 10);\n+    assert_eq!(loc.line(), 11);\n     assert_eq!(loc.column(), 15);\n \n     // `Location::caller()` in a macro should behave similarly to `file!` and `line!`,\n     // i.e. point to where the macro was invoked, instead of the macro itself.\n     let loc2 = caller_location_from_macro!();\n     assert_eq!(loc2.file(), file!());\n-    assert_eq!(loc2.line(), 17);\n+    assert_eq!(loc2.line(), 18);\n     assert_eq!(loc2.column(), 16);\n }"}, {"sha": "a2e8eb27edeacbf58e967b8fc3efa0cd649ffd1b", "filename": "tests/ui/rfc-2091-track-caller/mir-inlined-macro.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Frfc-2091-track-caller%2Fmir-inlined-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Frfc-2091-track-caller%2Fmir-inlined-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2091-track-caller%2Fmir-inlined-macro.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,23 @@\n+// run-pass\n+// revisions: default mir-opt\n+//[default] compile-flags: -Zinline-mir=no\n+//[mir-opt] compile-flags: -Zmir-opt-level=4\n+\n+use std::panic::Location;\n+\n+macro_rules! f {\n+    () => {\n+        Location::caller()\n+    };\n+}\n+\n+#[inline(always)]\n+fn g() -> &'static Location<'static> {\n+    f!()\n+}\n+\n+fn main() {\n+    let loc = g();\n+    assert_eq!(loc.line(), 16);\n+    assert_eq!(loc.column(), 5);\n+}"}, {"sha": "8804186ee1a6b915777f028ae86925e044c5b78b", "filename": "tests/ui/stability-attribute/auxiliary/similar-unstable-method.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fstability-attribute%2Fauxiliary%2Fsimilar-unstable-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fstability-attribute%2Fauxiliary%2Fsimilar-unstable-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstability-attribute%2Fauxiliary%2Fsimilar-unstable-method.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,13 @@\n+#![feature(staged_api)]\n+#![stable(feature = \"libfoo\", since = \"1.0.0\")]\n+\n+#[unstable(feature = \"foo\", reason = \"...\", issue = \"none\")]\n+pub fn foo() {}\n+\n+#[stable(feature = \"libfoo\", since = \"1.0.0\")]\n+pub struct Foo;\n+\n+impl Foo {\n+    #[unstable(feature = \"foo\", reason = \"...\", issue = \"none\")]\n+    pub fn foo(&self) {}\n+}"}, {"sha": "6d052779c6d363339ac4943b468045308ca629af", "filename": "tests/ui/stability-attribute/issue-109177.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fstability-attribute%2Fissue-109177.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fstability-attribute%2Fissue-109177.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstability-attribute%2Fissue-109177.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,13 @@\n+// aux-build: similar-unstable-method.rs\n+\n+extern crate similar_unstable_method;\n+\n+fn main() {\n+    // FIXME: this function should not suggest the `foo` function.\n+    similar_unstable_method::foo1();\n+    //~^ ERROR cannot find function `foo1` in crate `similar_unstable_method` [E0425]\n+\n+    let foo = similar_unstable_method::Foo;\n+    foo.foo1();\n+    //~^ ERROR no method named `foo1` found for struct `Foo` in the current scope [E0599]\n+}"}, {"sha": "9c2ac591ace05374c6259c3965ffa317e448d210", "filename": "tests/ui/stability-attribute/issue-109177.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fstability-attribute%2Fissue-109177.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Fstability-attribute%2Fissue-109177.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstability-attribute%2Fissue-109177.stderr?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,21 @@\n+error[E0425]: cannot find function `foo1` in crate `similar_unstable_method`\n+  --> $DIR/issue-109177.rs:7:30\n+   |\n+LL |     similar_unstable_method::foo1();\n+   |                              ^^^^ help: a function with a similar name exists: `foo`\n+   |\n+  ::: $DIR/auxiliary/similar-unstable-method.rs:5:1\n+   |\n+LL | pub fn foo() {}\n+   | ------------ similarly named function `foo` defined here\n+\n+error[E0599]: no method named `foo1` found for struct `Foo` in the current scope\n+  --> $DIR/issue-109177.rs:11:9\n+   |\n+LL |     foo.foo1();\n+   |         ^^^^ method not found in `Foo`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0425, E0599.\n+For more information about an error, try `rustc --explain E0425`."}, {"sha": "2bb133e8bfd42667fec4f3b3f695b395dbb4ef39", "filename": "tests/ui/test-attrs/custom-test-frameworks/issue-107454.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftest-attrs%2Fcustom-test-frameworks%2Fissue-107454.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftest-attrs%2Fcustom-test-frameworks%2Fissue-107454.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftest-attrs%2Fcustom-test-frameworks%2Fissue-107454.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags: --test\n+\n+#![feature(custom_test_frameworks)]\n+#![deny(unnameable_test_items)]\n+\n+fn foo() {\n+    #[test_case]\n+    //~^ ERROR cannot test inner items [unnameable_test_items]\n+    fn test2() {}\n+}"}, {"sha": "bd604afb79f8e5a4a3a69288c8f172609d15fe00", "filename": "tests/ui/test-attrs/custom-test-frameworks/issue-107454.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftest-attrs%2Fcustom-test-frameworks%2Fissue-107454.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftest-attrs%2Fcustom-test-frameworks%2Fissue-107454.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftest-attrs%2Fcustom-test-frameworks%2Fissue-107454.stderr?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,15 @@\n+error: cannot test inner items\n+  --> $DIR/issue-107454.rs:7:5\n+   |\n+LL |     #[test_case]\n+   |     ^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-107454.rs:4:9\n+   |\n+LL | #![deny(unnameable_test_items)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in the attribute macro `test_case` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}, {"sha": "d5df4b57b05913cdfdd865566b9fd4e661958827", "filename": "tests/ui/test-attrs/tests-listing-format-default.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-default.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,18 @@\n+// no-prefer-dynamic\n+// compile-flags: --test\n+// run-flags: --list\n+// run-pass\n+// check-run-results\n+\n+// Checks the listing of tests with no --format arguments.\n+\n+#![cfg(test)]\n+#[test]\n+fn m_test() {}\n+\n+#[test]\n+#[ignore = \"not yet implemented\"]\n+fn z_test() {}\n+\n+#[test]\n+fn a_test() {}"}, {"sha": "72337daf02cdfb43ef278bfb1c83afba3a15ce09", "filename": "tests/ui/test-attrs/tests-listing-format-default.run.stdout", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-default.run.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-default.run.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-default.run.stdout?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,5 @@\n+a_test: test\n+m_test: test\n+z_test: test\n+\n+3 tests, 0 benchmarks"}, {"sha": "5247f1f8f1746bfb14f49de180f1f7e345cb7aac", "filename": "tests/ui/test-attrs/tests-listing-format-json-without-unstableopts.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-json-without-unstableopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-json-without-unstableopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-json-without-unstableopts.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,18 @@\n+// no-prefer-dynamic\n+// compile-flags: --test\n+// run-flags: --list --format json\n+// run-fail\n+// check-run-results\n+\n+// Checks that --format json does not work without -Zunstable-options.\n+\n+#![cfg(test)]\n+#[test]\n+fn m_test() {}\n+\n+#[test]\n+#[ignore = \"not yet implemented\"]\n+fn z_test() {}\n+\n+#[test]\n+fn a_test() {}"}, {"sha": "9f6276300a0bde79983fc46972add4011cb3f060", "filename": "tests/ui/test-attrs/tests-listing-format-json-without-unstableopts.run.stderr", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-json-without-unstableopts.run.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-json-without-unstableopts.run.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-json-without-unstableopts.run.stderr?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1 @@\n+error: The \"json\" format is only accepted on the nightly compiler"}, {"sha": "18f1521eeeb1c8e55fe2a085b4a4f2105549df62", "filename": "tests/ui/test-attrs/tests-listing-format-json.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-json.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-json.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-json.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,20 @@\n+// no-prefer-dynamic\n+// compile-flags: --test\n+// run-flags: --list --format json -Zunstable-options\n+// run-pass\n+// check-run-results\n+// normalize-stdout-test: \"fake-test-src-base/test-attrs/\" -> \"$$DIR/\"\n+// normalize-stdout-test: \"fake-test-src-base\\\\test-attrs\\\\\" -> \"$$DIR/\"\n+\n+// Checks the listing of tests with --format json.\n+\n+#![cfg(test)]\n+#[test]\n+fn m_test() {}\n+\n+#[test]\n+#[ignore = \"not yet implemented\"]\n+fn z_test() {}\n+\n+#[test]\n+fn a_test() {}"}, {"sha": "b4131e97c34bc4c60bb7833a399d439ba9c8578a", "filename": "tests/ui/test-attrs/tests-listing-format-json.run.stdout", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-json.run.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-json.run.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-json.run.stdout?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,5 @@\n+{ \"type\": \"suite\", \"event\": \"discovery\" }\n+{ \"type\": \"test\", \"event\": \"discovered\", \"name\": \"a_test\", \"ignore\": false, \"ignore_message\": \"\", \"source_path\": \"$DIR/tests-listing-format-json.rs\", \"start_line\": 20, \"start_col\": 4, \"end_line\": 20, \"end_col\": 10 }\n+{ \"type\": \"test\", \"event\": \"discovered\", \"name\": \"m_test\", \"ignore\": false, \"ignore_message\": \"\", \"source_path\": \"$DIR/tests-listing-format-json.rs\", \"start_line\": 13, \"start_col\": 4, \"end_line\": 13, \"end_col\": 10 }\n+{ \"type\": \"test\", \"event\": \"discovered\", \"name\": \"z_test\", \"ignore\": true, \"ignore_message\": \"not yet implemented\", \"source_path\": \"$DIR/tests-listing-format-json.rs\", \"start_line\": 17, \"start_col\": 4, \"end_line\": 17, \"end_col\": 10 }\n+{ \"type\": \"suite\", \"event\": \"completed\", \"tests\": 3, \"benchmarks\": 0, \"total\": 3, \"ignored\": 1 }"}, {"sha": "7835f71759cb41ec9f8c49f242dd3b794654a1f7", "filename": "tests/ui/test-attrs/tests-listing-format-terse.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-terse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-terse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-terse.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,18 @@\n+// no-prefer-dynamic\n+// compile-flags: --test\n+// run-flags: --list --format terse\n+// run-pass\n+// check-run-results\n+\n+// Checks the listing of tests with --format terse.\n+\n+#![cfg(test)]\n+#[test]\n+fn m_test() {}\n+\n+#[test]\n+#[ignore = \"not yet implemented\"]\n+fn z_test() {}\n+\n+#[test]\n+fn a_test() {}"}, {"sha": "22afe104bfb1d921ed50c460be7f2ccbbcebce9d", "filename": "tests/ui/test-attrs/tests-listing-format-terse.run.stdout", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-terse.run.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-terse.run.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-terse.run.stdout?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -0,0 +1,3 @@\n+a_test: test\n+m_test: test\n+z_test: test"}, {"sha": "e6f7dc410b6147512fcbd31fd377202cff4bf9ce", "filename": "tests/ui/typeck/typeck_type_placeholder_item.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -228,5 +228,4 @@ fn evens_squared(n: usize) -> _ {\n \n const _: _ = (1..10).filter(|x| x % 2 == 0).map(|x| x * x);\n //~^ ERROR the trait bound\n-//~| ERROR the trait bound\n //~| ERROR the placeholder"}, {"sha": "9144ab9e3a6bd39daea117d723c949abeaa5b094", "filename": "tests/ui/typeck/typeck_type_placeholder_item.stderr", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bfde41afa31aa957a80f39e782062834a0dc583/tests%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr?ref=4bfde41afa31aa957a80f39e782062834a0dc583", "patch": "@@ -437,19 +437,6 @@ LL | fn evens_squared(n: usize) -> _ {\n    |                               not allowed in type signatures\n    |                               help: replace with an appropriate return type: `impl Iterator<Item = usize>`\n \n-error[E0277]: the trait bound `std::ops::Range<{integer}>: Iterator` is not satisfied\n-  --> $DIR/typeck_type_placeholder_item.rs:229:22\n-   |\n-LL | const _: _ = (1..10).filter(|x| x % 2 == 0).map(|x| x * x);\n-   |                      ^^^^^^ `std::ops::Range<{integer}>` is not an iterator\n-   |\n-   = help: the trait `~const Iterator` is not implemented for `std::ops::Range<{integer}>`\n-note: the trait `Iterator` is implemented for `std::ops::Range<{integer}>`, but that implementation is not `const`\n-  --> $DIR/typeck_type_placeholder_item.rs:229:14\n-   |\n-LL | const _: _ = (1..10).filter(|x| x % 2 == 0).map(|x| x * x);\n-   |              ^^^^^^^\n-\n error[E0277]: the trait bound `Filter<std::ops::Range<{integer}>, [closure@$DIR/typeck_type_placeholder_item.rs:229:29: 229:32]>: Iterator` is not satisfied\n   --> $DIR/typeck_type_placeholder_item.rs:229:45\n    |\n@@ -677,7 +664,7 @@ LL |     const D: _ = 42;\n    |              not allowed in type signatures\n    |              help: replace with the correct type: `i32`\n \n-error: aborting due to 73 previous errors\n+error: aborting due to 72 previous errors\n \n Some errors have detailed explanations: E0121, E0277, E0282, E0403.\n For more information about an error, try `rustc --explain E0121`."}]}