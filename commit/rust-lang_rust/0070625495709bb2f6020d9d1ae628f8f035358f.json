{"sha": "0070625495709bb2f6020d9d1ae628f8f035358f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNzA2MjU0OTU3MDliYjJmNjAyMGQ5ZDFhZTYyOGY4ZjAzNTM1OGY=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-21T17:17:43Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-21T17:17:43Z"}, "message": "small edits for recently written book chapters", "tree": {"sha": "d4735113701dcd1391b2eecf02a4c0c78fea959b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4735113701dcd1391b2eecf02a4c0c78fea959b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0070625495709bb2f6020d9d1ae628f8f035358f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0070625495709bb2f6020d9d1ae628f8f035358f", "html_url": "https://github.com/rust-lang/rust/commit/0070625495709bb2f6020d9d1ae628f8f035358f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0070625495709bb2f6020d9d1ae628f8f035358f/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3860240b0e124f38483ea4bd070b61d362871ece", "url": "https://api.github.com/repos/rust-lang/rust/commits/3860240b0e124f38483ea4bd070b61d362871ece", "html_url": "https://github.com/rust-lang/rust/commit/3860240b0e124f38483ea4bd070b61d362871ece"}], "stats": {"total": 290, "additions": 145, "deletions": 145}, "files": [{"sha": "55e2787cc2591032f349e564f06f9bd84e88779f", "filename": "src/doc/trpl/associated-types.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0070625495709bb2f6020d9d1ae628f8f035358f/src%2Fdoc%2Ftrpl%2Fassociated-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/0070625495709bb2f6020d9d1ae628f8f035358f/src%2Fdoc%2Ftrpl%2Fassociated-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fassociated-types.md?ref=0070625495709bb2f6020d9d1ae628f8f035358f", "patch": "@@ -1,8 +1,8 @@\n % Associated Types\n \n-Associated types are a powerful part of Rust's type system. They're related to\n-the idea of a 'type family', in other words, grouping multiple types together. That\n-description is a bit abstract, so let's dive right into an example. If you want\n+Associated types are a powerful part of Rust\u2019s type system. They\u2019re related to\n+the idea of a \u2018type family\u2019, in other words, grouping multiple types together. That\n+description is a bit abstract, so let\u2019s dive right into an example. If you want\n to write a `Graph` trait, you have two types to be generic over: the node type\n and the edge type. So you might write a trait, `Graph<N, E>`, that looks like\n this:\n@@ -48,11 +48,11 @@ fn distance<G: Graph>(graph: &G, start: &G::N, end: &G::N) -> uint { ... }\n \n No need to deal with the `E`dge type here!\n \n-Let's go over all this in more detail.\n+Let\u2019s go over all this in more detail.\n \n ## Defining associated types\n \n-Let's build that `Graph` trait. Here's the definition:\n+Let\u2019s build that `Graph` trait. Here\u2019s the definition:\n \n ```rust\n trait Graph {\n@@ -86,7 +86,7 @@ trait Graph {\n ## Implementing associated types\n \n Just like any trait, traits that use associated types use the `impl` keyword to\n-provide implementations. Here's a simple implementation of Graph:\n+provide implementations. Here\u2019s a simple implementation of Graph:\n \n ```rust\n # trait Graph {\n@@ -118,13 +118,13 @@ impl Graph for MyGraph {\n This silly implementation always returns `true` and an empty `Vec<Edge>`, but it\n gives you an idea of how to implement this kind of thing. We first need three\n `struct`s, one for the graph, one for the node, and one for the edge. If it made\n-more sense to use a different type, that would work as well, we're just going to\n+more sense to use a different type, that would work as well, we\u2019re just going to\n use `struct`s for all three here.\n \n Next is the `impl` line, which is just like implementing any other trait.\n \n From here, we use `=` to define our associated types. The name the trait uses\n-goes on the left of the `=`, and the concrete type we're `impl`ementing this\n+goes on the left of the `=`, and the concrete type we\u2019re `impl`ementing this\n for goes on the right. Finally, we use the concrete types in our function\n declarations.\n "}, {"sha": "604dcb739df63812f18e56600fd1978bddc991b8", "filename": "src/doc/trpl/closures.md", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0070625495709bb2f6020d9d1ae628f8f035358f/src%2Fdoc%2Ftrpl%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/0070625495709bb2f6020d9d1ae628f8f035358f/src%2Fdoc%2Ftrpl%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fclosures.md?ref=0070625495709bb2f6020d9d1ae628f8f035358f", "patch": "@@ -1,9 +1,9 @@\n % Closures\n \n Rust not only has named functions, but anonymous functions as well. Anonymous\n-functions that have an associated environment are called 'closures', because they\n+functions that have an associated environment are called \u2018closures\u2019, because they\n close over an environment. Rust has a really great implementation of them, as\n-we'll see.\n+we\u2019ll see.\n \n # Syntax\n \n@@ -15,7 +15,7 @@ let plus_one = |x: i32| x + 1;\n assert_eq!(2, plus_one(1));\n ```\n \n-We create a binding, `plus_one`, and assign it to a closure. The closure's\n+We create a binding, `plus_one`, and assign it to a closure. The closure\u2019s\n arguments go between the pipes (`|`), and the body is an expression, in this\n case, `x + 1`. Remember that `{ }` is an expression, so we can have multi-line\n closures too:\n@@ -33,7 +33,7 @@ let plus_two = |x| {\n assert_eq!(4, plus_two(2));\n ```\n \n-You'll notice a few things about closures that are a bit different than regular\n+You\u2019ll notice a few things about closures that are a bit different than regular\n functions defined with `fn`. The first of which is that we did not need to\n annotate the types of arguments the closure takes or the values it returns. We\n can:\n@@ -44,13 +44,13 @@ let plus_one = |x: i32| -> i32 { x + 1 };\n assert_eq!(2, plus_one(1));\n ```\n \n-But we don't have to. Why is this? Basically, it was chosen for ergonomic reasons.\n+But we don\u2019t have to. Why is this? Basically, it was chosen for ergonomic reasons.\n While specifying the full type for named functions is helpful with things like\n documentation and type inference, the types of closures are rarely documented\n since they\u2019re anonymous, and they don\u2019t cause the kinds of error-at-a-distance\n that inferring named function types can.\n \n-The second is that the syntax is similar, but a bit different. I've added spaces\n+The second is that the syntax is similar, but a bit different. I\u2019ve added spaces\n here to make them look a little closer:\n \n ```rust\n@@ -59,11 +59,11 @@ let plus_one_v2 = |x: i32 | -> i32 { x + 1 };\n let plus_one_v3 = |x: i32 |          x + 1  ;\n ```\n \n-Small differences, but they're similar in ways.\n+Small differences, but they\u2019re similar in ways.\n \n # Closures and their environment\n \n-Closures are called such because they 'close over their environment.' It\n+Closures are called such because they \u2018close over their environment\u2019. It\n looks like this:\n \n ```rust\n@@ -105,7 +105,7 @@ fn main() {\n ^\n ```\n \n-A verbose yet helpful error message! As it says, we can't take a mutable borrow\n+A verbose yet helpful error message! As it says, we can\u2019t take a mutable borrow\n on `num` because the closure is already borrowing it. If we let the closure go\n out of scope, we can:\n \n@@ -140,7 +140,7 @@ let takes_nums = || nums;\n ```\n \n `Vec<T>` has ownership over its contents, and therefore, when we refer to it\n-in our closure, we have to take ownership of `nums`. It's the same as if we'd\n+in our closure, we have to take ownership of `nums`. It\u2019s the same as if we\u2019d\n passed `nums` to a function that took ownership of it.\n \n ## `move` closures\n@@ -156,7 +156,7 @@ let owns_num = move |x: i32| x + num;\n \n Now, even though the keyword is `move`, the variables follow normal move semantics.\n In this case, `5` implements `Copy`, and so `owns_num` takes ownership of a copy\n-of `num`. So what's the difference?\n+of `num`. So what\u2019s the difference?\n \n ```rust\n let mut num = 5;\n@@ -171,11 +171,11 @@ assert_eq!(10, num);\n ```\n \n So in this case, our closure took a mutable reference to `num`, and then when\n-we called `add_num`, it mutated the underlying value, as we'd expect. We also\n+we called `add_num`, it mutated the underlying value, as we\u2019d expect. We also\n needed to declare `add_num` as `mut` too, because we\u2019re mutating its\n environment.\n \n-If we change to a `move` closure, it's different:\n+If we change to a `move` closure, it\u2019s different:\n \n ```rust\n let mut num = 5;\n@@ -203,8 +203,8 @@ you tons of control over what your code does, and closures are no different.\n \n # Closure implementation\n \n-Rust's implementation of closures is a bit different than other languages. They\n-are effectively syntax sugar for traits. You'll want to make sure to have read\n+Rust\u2019s implementation of closures is a bit different than other languages. They\n+are effectively syntax sugar for traits. You\u2019ll want to make sure to have read\n the [traits chapter][traits] before this one, as well as the chapter on [trait\n objects][trait-objects].\n \n@@ -237,9 +237,9 @@ pub trait FnOnce<Args> {\n # }\n ```\n \n-You'll notice a few differences between these traits, but a big one is `self`:\n+You\u2019ll notice a few differences between these traits, but a big one is `self`:\n `Fn` takes `&self`, `FnMut` takes `&mut self`, and `FnOnce` takes `self`. This\n-covers all three kinds of `self` via the usual method call syntax. But we've\n+covers all three kinds of `self` via the usual method call syntax. But we\u2019ve\n split them up into three traits, rather than having a single one. This gives us\n a large amount of control over what kind of closures we can take.\n \n@@ -253,7 +253,7 @@ Now that we know that closures are traits, we already know how to accept and\n return closures: just like any other trait!\n \n This also means that we can choose static vs dynamic dispatch as well. First,\n-let's write a function which takes something callable, calls it, and returns\n+let\u2019s write a function which takes something callable, calls it, and returns\n the result:\n \n ```rust\n@@ -271,7 +271,7 @@ assert_eq!(3, answer);\n We pass our closure, `|x| x + 2`, to `call_with_one`. It just does what it\n suggests: it calls the closure, giving it `1` as an argument.\n \n-Let's examine the signature of `call_with_one` in more depth:\n+Let\u2019s examine the signature of `call_with_one` in more depth:\n \n ```rust\n fn call_with_one<F>(some_closure: F) -> i32\n@@ -280,7 +280,7 @@ fn call_with_one<F>(some_closure: F) -> i32\n ```\n \n We take one parameter, and it has the type `F`. We also return a `i32`. This part\n-isn't interesting. The next part is:\n+isn\u2019t interesting. The next part is:\n \n ```rust\n # fn call_with_one<F>(some_closure: F) -> i32\n@@ -292,9 +292,9 @@ Because `Fn` is a trait, we can bound our generic with it. In this case, our clo\n takes a `i32` as an argument and returns an `i32`, and so the generic bound we use\n is `Fn(i32) -> i32`.\n \n-There's one other key point here: because we're bounding a generic with a\n-trait, this will get monomorphized, and therefore, we'll be doing static\n-dispatch into the closure. That's pretty neat. In many langauges, closures are\n+There\u2019s one other key point here: because we\u2019re bounding a generic with a\n+trait, this will get monomorphized, and therefore, we\u2019ll be doing static\n+dispatch into the closure. That\u2019s pretty neat. In many langauges, closures are\n inherently heap allocated, and will always involve dynamic dispatch. In Rust,\n we can stack allocate our closure environment, and statically dispatch the\n call. This happens quite often with iterators and their adapters, which often\n@@ -320,7 +320,7 @@ to our closure when we pass it to `call_with_one`, so we use `&||`.\n \n It\u2019s very common for functional-style code to return closures in various\n situations. If you try to return a closure, you may run into an error. At\n-first, it may seem strange, but we'll figure it out. Here's how you'd probably\n+first, it may seem strange, but we\u2019ll figure it out. Here\u2019s how you\u2019d probably\n try to return a closure from a function:\n \n ```rust,ignore\n@@ -361,7 +361,7 @@ In order to return something from a function, Rust needs to know what\n size the return type is. But since `Fn` is a trait, it could be various\n things of various sizes: many different types can implement `Fn`. An easy\n way to give something a size is to take a reference to it, as references\n-have a known size. So we'd write this:\n+have a known size. So we\u2019d write this:\n \n ```rust,ignore\n fn factory() -> &(Fn(i32) -> Vec<i32>) {\n@@ -385,7 +385,7 @@ fn factory() -> &(Fn(i32) -> i32) {\n ```\n \n Right. Because we have a reference, we need to give it a lifetime. But\n-our `factory()` function takes no arguments, so elision doesn't kick in\n+our `factory()` function takes no arguments, so elision doesn\u2019t kick in\n here. What lifetime can we choose? `'static`:\n \n ```rust,ignore\n@@ -414,15 +414,15 @@ error: mismatched types:\n \n ```\n \n-This error is letting us know that we don't have a `&'static Fn(i32) -> i32`,\n+This error is letting us know that we don\u2019t have a `&'static Fn(i32) -> i32`,\n we have a `[closure <anon>:7:9: 7:20]`. Wait, what?\n \n Because each closure generates its own environment `struct` and implementation\n of `Fn` and friends, these types are anonymous. They exist just solely for\n this closure. So Rust shows them as `closure <anon>`, rather than some\n autogenerated name.\n \n-But why doesn't our closure implement `&'static Fn`? Well, as we discussed before,\n+But why doesn\u2019t our closure implement `&'static Fn`? Well, as we discussed before,\n closures borrow their environment. And in this case, our environment is based\n on a stack-allocated `5`, the `num` variable binding. So the borrow has a lifetime\n of the stack frame. So if we returned this closure, the function call would be\n@@ -445,7 +445,7 @@ assert_eq!(6, answer);\n # }\n ```\n \n-We use a trait object, by `Box`ing up the `Fn`. There's just one last problem:\n+We use a trait object, by `Box`ing up the `Fn`. There\u2019s just one last problem:\n \n ```text\n error: `num` does not live long enough\n@@ -471,5 +471,5 @@ assert_eq!(6, answer);\n ```\n \n By making the inner closure a `move Fn`, we create a new stack frame for our\n-closure. By `Box`ing it up, we've given it a known size, and allowing it to\n+closure. By `Box`ing it up, we\u2019ve given it a known size, and allowing it to\n escape our stack frame."}, {"sha": "3ab3401e61264d046ddb81a3b8449d796a43e8da", "filename": "src/doc/trpl/crates-and-modules.md", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/0070625495709bb2f6020d9d1ae628f8f035358f/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/0070625495709bb2f6020d9d1ae628f8f035358f/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md?ref=0070625495709bb2f6020d9d1ae628f8f035358f", "patch": "@@ -1,27 +1,27 @@\n % Crates and Modules\n \n-When a project starts getting large, it's considered good software\n+When a project starts getting large, it\u2019s considered good software\n engineering practice to split it up into a bunch of smaller pieces, and then\n-fit them together. It's also important to have a well-defined interface, so\n+fit them together. It\u2019s also important to have a well-defined interface, so\n that some of your functionality is private, and some is public. To facilitate\n these kinds of things, Rust has a module system.\n \n # Basic terminology: Crates and Modules\n \n-Rust has two distinct terms that relate to the module system: *crate* and\n-*module*. A crate is synonymous with a *library* or *package* in other\n-languages. Hence \"Cargo\" as the name of Rust's package management tool: you\n+Rust has two distinct terms that relate to the module system: \u2018crate\u2019 and\n+\u2018module\u2019. A crate is synonymous with a \u2018library\u2019 or \u2018package\u2019 in other\n+languages. Hence \u201cCargo\u201d as the name of Rust\u2019s package management tool: you\n ship your crates to others with Cargo. Crates can produce an executable or a\n library, depending on the project.\n \n Each crate has an implicit *root module* that contains the code for that crate.\n You can then define a tree of sub-modules under that root module. Modules allow\n you to partition your code within the crate itself.\n \n-As an example, let's make a *phrases* crate, which will give us various phrases\n-in different languages. To keep things simple, we'll stick to \"greetings\" and\n-\"farewells\" as two kinds of phrases, and use English and Japanese (\u65e5\u672c\u8a9e) as\n-two languages for those phrases to be in. We'll use this module layout:\n+As an example, let\u2019s make a *phrases* crate, which will give us various phrases\n+in different languages. To keep things simple, we\u2019ll stick to \u2018greetings\u2019 and\n+\u2018farewells\u2019 as two kinds of phrases, and use English and Japanese (\u65e5\u672c\u8a9e) as\n+two languages for those phrases to be in. We\u2019ll use this module layout:\n \n ```text\n                                     +-----------+\n@@ -47,7 +47,7 @@ In this example, `phrases` is the name of our crate. All of the rest are\n modules.  You can see that they form a tree, branching out from the crate\n *root*, which is the root of the tree: `phrases` itself.\n \n-Now that we have a plan, let's define these modules in code. To start,\n+Now that we have a plan, let\u2019s define these modules in code. To start,\n generate a new crate with Cargo:\n \n ```bash\n@@ -72,7 +72,7 @@ above.\n \n # Defining Modules\n \n-To define each of our modules, we use the `mod` keyword. Let's make our\n+To define each of our modules, we use the `mod` keyword. Let\u2019s make our\n `src/lib.rs` look like this:\n \n ```\n@@ -101,7 +101,7 @@ Within a given `mod`, you can declare sub-`mod`s. We can refer to sub-modules\n with double-colon (`::`) notation: our four nested modules are\n `english::greetings`, `english::farewells`, `japanese::greetings`, and\n `japanese::farewells`. Because these sub-modules are namespaced under their\n-parent module, the names don't conflict: `english::greetings` and\n+parent module, the names don\u2019t conflict: `english::greetings` and\n `japanese::greetings` are distinct, even though their names are both\n `greetings`.\n \n@@ -116,11 +116,11 @@ build  deps  examples  libphrases-a7448e02a0468eaa.rlib  native\n ```\n \n `libphrase-hash.rlib` is the compiled crate. Before we see how to use this\n-crate from another crate, let's break it up into multiple files.\n+crate from another crate, let\u2019s break it up into multiple files.\n \n # Multiple file crates\n \n-If each crate were just one file, these files would get very large. It's often\n+If each crate were just one file, these files would get very large. It\u2019s often\n easier to split up crates into multiple files, and Rust supports this in two\n ways.\n \n@@ -141,7 +141,7 @@ mod english;\n If we do that, Rust will expect to find either a `english.rs` file, or a\n `english/mod.rs` file with the contents of our module.\n \n-Note that in these files, you don't need to re-declare the module: that's\n+Note that in these files, you don\u2019t need to re-declare the module: that\u2019s\n already been done with the initial `mod` declaration.\n \n Using these two techniques, we can break up our crate into two directories and\n@@ -180,7 +180,7 @@ mod japanese;\n \n These two declarations tell Rust to look for either `src/english.rs` and\n `src/japanese.rs`, or `src/english/mod.rs` and `src/japanese/mod.rs`, depending\n-on our preference. In this case, because our modules have sub-modules, we've\n+on our preference. In this case, because our modules have sub-modules, we\u2019ve\n chosen the second. Both `src/english/mod.rs` and `src/japanese/mod.rs` look\n like this:\n \n@@ -192,11 +192,11 @@ mod farewells;\n Again, these declarations tell Rust to look for either\n `src/english/greetings.rs` and `src/japanese/greetings.rs` or\n `src/english/farewells/mod.rs` and `src/japanese/farewells/mod.rs`. Because\n-these sub-modules don't have their own sub-modules, we've chosen to make them\n+these sub-modules don\u2019t have their own sub-modules, we\u2019ve chosen to make them\n `src/english/greetings.rs` and `src/japanese/farewells.rs`. Whew!\n \n The contents of `src/english/greetings.rs` and `src/japanese/farewells.rs` are\n-both empty at the moment. Let's add some functions.\n+both empty at the moment. Let\u2019s add some functions.\n \n Put this in `src/english/greetings.rs`:\n \n@@ -223,7 +223,7 @@ fn hello() -> String {\n ```\n \n Of course, you can copy and paste this from this web page, or just type\n-something else. It's not important that you actually put \"konnichiwa\" to learn\n+something else. It\u2019s not important that you actually put \u2018konnichiwa\u2019 to learn\n about the module system.\n \n Put this in `src/japanese/farewells.rs`:\n@@ -234,17 +234,17 @@ fn goodbye() -> String {\n }\n ```\n \n-(This is \"Say\u014dnara\", if you're curious.)\n+(This is \u2018Say\u014dnara\u2019, if you\u2019re curious.)\n \n-Now that we have some functionality in our crate, let's try to use it from\n+Now that we have some functionality in our crate, let\u2019s try to use it from\n another crate.\n \n # Importing External Crates\n \n-We have a library crate. Let's make an executable crate that imports and uses\n+We have a library crate. Let\u2019s make an executable crate that imports and uses\n our library.\n \n-Make a `src/main.rs` and put this in it (it won't quite compile yet):\n+Make a `src/main.rs` and put this in it (it won\u2019t quite compile yet):\n \n ```rust,ignore\n extern crate phrases;\n@@ -259,18 +259,18 @@ fn main() {\n ```\n \n The `extern crate` declaration tells Rust that we need to compile and link to\n-the `phrases` crate. We can then use `phrases`' modules in this one. As we\n+the `phrases` crate. We can then use `phrases`\u2019 modules in this one. As we\n mentioned earlier, you can use double colons to refer to sub-modules and the\n functions inside of them.\n \n Also, Cargo assumes that `src/main.rs` is the crate root of a binary crate,\n rather than a library crate. Our package now has two crates: `src/lib.rs` and\n `src/main.rs`. This pattern is quite common for executable crates: most\n functionality is in a library crate, and the executable crate uses that\n-library. This way, other programs can also use the library crate, and it's also\n+library. This way, other programs can also use the library crate, and it\u2019s also\n a nice separation of concerns.\n \n-This doesn't quite work yet, though. We get four errors that look similar to\n+This doesn\u2019t quite work yet, though. We get four errors that look similar to\n this:\n \n ```bash\n@@ -287,14 +287,14 @@ note: in expansion of format_args!\n phrases/src/main.rs:4:5: 4:76 note: expansion site\n ```\n \n-By default, everything is private in Rust. Let's talk about this in some more\n+By default, everything is private in Rust. Let\u2019s talk about this in some more\n depth.\n \n # Exporting a Public Interface\n \n Rust allows you to precisely control which aspects of your interface are\n public, and so private is the default. To make things public, you use the `pub`\n-keyword. Let's focus on the `english` module first, so let's reduce our `src/main.rs`\n+keyword. Let\u2019s focus on the `english` module first, so let\u2019s reduce our `src/main.rs`\n to just this:\n \n ```{rust,ignore}\n@@ -306,21 +306,21 @@ fn main() {\n }\n ```\n \n-In our `src/lib.rs`, let's add `pub` to the `english` module declaration:\n+In our `src/lib.rs`, let\u2019s add `pub` to the `english` module declaration:\n \n ```{rust,ignore}\n pub mod english;\n mod japanese;\n ```\n \n-And in our `src/english/mod.rs`, let's make both `pub`:\n+And in our `src/english/mod.rs`, let\u2019s make both `pub`:\n \n ```{rust,ignore}\n pub mod greetings;\n pub mod farewells;\n ```\n \n-In our `src/english/greetings.rs`, let's add `pub` to our `fn` declaration:\n+In our `src/english/greetings.rs`, let\u2019s add `pub` to our `fn` declaration:\n \n ```{rust,ignore}\n pub fn hello() -> String {\n@@ -358,12 +358,12 @@ Goodbye in English: Goodbye.\n Now that our functions are public, we can use them. Great! However, typing out\n `phrases::english::greetings::hello()` is very long and repetitive. Rust has\n another keyword for importing names into the current scope, so that you can\n-refer to them with shorter names. Let's talk about `use`.\n+refer to them with shorter names. Let\u2019s talk about `use`.\n \n # Importing Modules with `use`\n \n Rust has a `use` keyword, which allows us to import names into our local scope.\n-Let's change our `src/main.rs` to look like this:\n+Let\u2019s change our `src/main.rs` to look like this:\n \n ```{rust,ignore}\n extern crate phrases;\n@@ -378,7 +378,7 @@ fn main() {\n ```\n \n The two `use` lines import each module into the local scope, so we can refer to\n-the functions by a much shorter name. By convention, when importing functions, it's\n+the functions by a much shorter name. By convention, when importing functions, it\u2019s\n considered best practice to import the module, rather than the function directly. In\n other words, you _can_ do this:\n \n@@ -395,7 +395,7 @@ fn main() {\n ```\n \n But it is not idiomatic. This is significantly more likely to introduce a\n-naming conflict. In our short program, it's not a big deal, but as it grows, it\n+naming conflict. In our short program, it\u2019s not a big deal, but as it grows, it\n becomes a problem. If we have conflicting names, Rust will give a compilation\n error. For example, if we made the `japanese` functions public, and tried to do\n this:\n@@ -423,7 +423,7 @@ error: aborting due to previous error\n Could not compile `phrases`.\n ```\n \n-If we're importing multiple names from the same module, we don't have to type it out\n+If we\u2019re importing multiple names from the same module, we don\u2019t have to type it out\n twice. Instead of this:\n \n ```{rust,ignore}\n@@ -439,11 +439,11 @@ use phrases::english::{greetings, farewells};\n \n ## Re-exporting with `pub use`\n \n-You don't just use `use` to shorten identifiers. You can also use it inside of your crate\n+You don\u2019t just use `use` to shorten identifiers. You can also use it inside of your crate\n to re-export a function inside another module. This allows you to present an external\n interface that may not directly map to your internal code organization.\n \n-Let's look at an example. Modify your `src/main.rs` to read like this:\n+Let\u2019s look at an example. Modify your `src/main.rs` to read like this:\n \n ```{rust,ignore}\n extern crate phrases;\n@@ -494,11 +494,11 @@ mod farewells;\n ```\n \n The `pub use` declaration brings the function into scope at this part of our\n-module hierarchy. Because we've `pub use`d this inside of our `japanese`\n+module hierarchy. Because we\u2019ve `pub use`d this inside of our `japanese`\n module, we now have a `phrases::japanese::hello()` function and a\n `phrases::japanese::goodbye()` function, even though the code for them lives in\n `phrases::japanese::greetings::hello()` and\n-`phrases::japanese::farewells::goodbye()`. Our internal organization doesn't\n+`phrases::japanese::farewells::goodbye()`. Our internal organization doesn\u2019t\n define our external interface.\n \n Here we have a `pub use` for each function we want to bring into the\n@@ -507,13 +507,13 @@ everything from `greetings` into the current scope: `pub use self::greetings::*`\n \n What about the `self`? Well, by default, `use` declarations are absolute paths,\n starting from your crate root. `self` makes that path relative to your current\n-place in the hierarchy instead. There's one more special form of `use`: you can\n+place in the hierarchy instead. There\u2019s one more special form of `use`: you can\n `use super::` to reach one level up the tree from your current location. Some\n-people like to think of `self` as `.` and `super` as `..`, from many shells'\n+people like to think of `self` as `.` and `super` as `..`, from many shells\u2019\n display for the current directory and the parent directory.\n \n Outside of `use`, paths are relative: `foo::bar()` refers to a function inside\n-of `foo` relative to where we are. If that's prefixed with `::`, as in\n+of `foo` relative to where we are. If that\u2019s prefixed with `::`, as in\n `::foo::bar()`, it refers to a different `foo`, an absolute path from your\n crate root.\n "}, {"sha": "9fa870ab1ac7cf27796ffc56f77121e5cd3e15bf", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0070625495709bb2f6020d9d1ae628f8f035358f/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/0070625495709bb2f6020d9d1ae628f8f035358f/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=0070625495709bb2f6020d9d1ae628f8f035358f", "patch": "@@ -1,20 +1,20 @@\n % Macros\n \n-By now you've learned about many of the tools Rust provides for abstracting and\n+By now you\u2019ve learned about many of the tools Rust provides for abstracting and\n reusing code. These units of code reuse have a rich semantic structure. For\n example, functions have a type signature, type parameters have trait bounds,\n and overloaded functions must belong to a particular trait.\n \n-This structure means that Rust's core abstractions have powerful compile-time\n+This structure means that Rust\u2019s core abstractions have powerful compile-time\n correctness checking. But this comes at the price of reduced flexibility. If\n-you visually identify a pattern of repeated code, you may find it's difficult\n+you visually identify a pattern of repeated code, you may find it\u2019s difficult\n or cumbersome to express that pattern as a generic function, a trait, or\n-anything else within Rust's semantics.\n+anything else within Rust\u2019s semantics.\n \n-Macros allow us to abstract at a *syntactic* level. A macro invocation is\n+Macros allow us to abstract at a syntactic level. A macro invocation is\n shorthand for an \"expanded\" syntactic form. This expansion happens early in\n compilation, before any static checking. As a result, macros can capture many\n-patterns of code reuse that Rust's core abstractions cannot.\n+patterns of code reuse that Rust\u2019s core abstractions cannot.\n \n The drawback is that macro-based code can be harder to understand, because\n fewer of the built-in rules apply. Like an ordinary function, a well-behaved\n@@ -23,8 +23,8 @@ difficult to design a well-behaved macro!  Additionally, compiler errors in\n macro code are harder to interpret, because they describe problems in the\n expanded code, not the source-level form that developers use.\n \n-These drawbacks make macros something of a \"feature of last resort\". That's not\n-to say that macros are bad; they are part of Rust because sometimes they're\n+These drawbacks make macros something of a \"feature of last resort\". That\u2019s not\n+to say that macros are bad; they are part of Rust because sometimes they\u2019re\n needed for truly concise, well-abstracted code. Just keep this tradeoff in\n mind.\n \n@@ -40,7 +40,7 @@ let x: Vec<u32> = vec![1, 2, 3];\n # assert_eq!(x, [1, 2, 3]);\n ```\n \n-This can't be an ordinary function, because it takes any number of arguments.\n+This can\u2019t be an ordinary function, because it takes any number of arguments.\n But we can imagine it as syntactic shorthand for\n \n ```rust\n@@ -77,20 +77,20 @@ macro_rules! vec {\n # }\n ```\n \n-Whoa, that's a lot of new syntax! Let's break it down.\n+Whoa, that\u2019s a lot of new syntax! Let\u2019s break it down.\n \n ```ignore\n macro_rules! vec { ... }\n ```\n \n-This says we're defining a macro named `vec`, much as `fn vec` would define a\n-function named `vec`. In prose, we informally write a macro's name with an\n+This says we\u2019re defining a macro named `vec`, much as `fn vec` would define a\n+function named `vec`. In prose, we informally write a macro\u2019s name with an\n exclamation point, e.g. `vec!`. The exclamation point is part of the invocation\n syntax and serves to distinguish a macro from an ordinary function.\n \n ## Matching\n \n-The macro is defined through a series of *rules*, which are pattern-matching\n+The macro is defined through a series of rules, which are pattern-matching\n cases. Above, we had\n \n ```ignore\n@@ -99,13 +99,13 @@ cases. Above, we had\n \n This is like a `match` expression arm, but the matching happens on Rust syntax\n trees, at compile time. The semicolon is optional on the last (here, only)\n-case. The \"pattern\" on the left-hand side of `=>` is known as a *matcher*.\n+case. The \"pattern\" on the left-hand side of `=>` is known as a \u2018matcher\u2019.\n These have [their own little grammar] within the language.\n \n [their own little grammar]: ../reference.html#macros\n \n The matcher `$x:expr` will match any Rust expression, binding that syntax tree\n-to the *metavariable* `$x`. The identifier `expr` is a *fragment specifier*;\n+to the \u2018metavariable\u2019 `$x`. The identifier `expr` is a \u2018fragment specifier\u2019;\n the full possibilities are enumerated in the [advanced macros chapter][].\n Surrounding the matcher with `$(...),*` will match zero or more expressions,\n separated by commas.\n@@ -158,8 +158,8 @@ Each matched expression `$x` will produce a single `push` statement in the\n macro expansion. The repetition in the expansion proceeds in \"lockstep\" with\n repetition in the matcher (more on this in a moment).\n \n-Because `$x` was already declared as matching an expression, we don't repeat\n-`:expr` on the right-hand side. Also, we don't include a separating comma as\n+Because `$x` was already declared as matching an expression, we don\u2019t repeat\n+`:expr` on the right-hand side. Also, we don\u2019t include a separating comma as\n part of the repetition operator. Instead, we have a terminating semicolon\n within the repeated block.\n \n@@ -180,7 +180,7 @@ The outer braces are part of the syntax of `macro_rules!`. In fact, you can use\n The inner braces are part of the expanded syntax. Remember, the `vec!` macro is\n used in an expression context. To write an expression with multiple statements,\n including `let`-bindings, we use a block. If your macro expands to a single\n-expression, you don't need this extra layer of braces.\n+expression, you don\u2019t need this extra layer of braces.\n \n Note that we never *declared* that the macro produces an expression. In fact,\n this is not determined until we use the macro as an expression. With care, you\n@@ -194,7 +194,7 @@ The repetition operator follows two principal rules:\n 1. `$(...)*` walks through one \"layer\" of repetitions, for all of the `$name`s\n    it contains, in lockstep, and\n 2. each `$name` must be under at least as many `$(...)*`s as it was matched\n-   against. If it is under more, it'll be duplicated, as appropriate.\n+   against. If it is under more, it\u2019ll be duplicated, as appropriate.\n \n This baroque macro illustrates the duplication of variables from outer\n repetition levels.\n@@ -219,7 +219,7 @@ fn main() {\n }\n ```\n \n-That's most of the matcher syntax. These examples use `$(...)*`, which is a\n+That\u2019s most of the matcher syntax. These examples use `$(...)*`, which is a\n \"zero or more\" match. Alternatively you can write `$(...)+` for a \"one or\n more\" match. Both forms optionally include a separator, which can be any token\n except `+` or `*`.\n@@ -244,9 +244,9 @@ int main() {\n ```\n \n After expansion we have `5 * 2 + 3`, and multiplication has greater precedence\n-than addition. If you've used C macros a lot, you probably know the standard\n+than addition. If you\u2019ve used C macros a lot, you probably know the standard\n idioms for avoiding this problem, as well as five or six others. In Rust, we\n-don't have to worry about it.\n+don\u2019t have to worry about it.\n \n ```rust\n macro_rules! five_times {\n@@ -261,8 +261,8 @@ fn main() {\n The metavariable `$x` is parsed as a single expression node, and keeps its\n place in the syntax tree even after substitution.\n \n-Another common problem in macro systems is *variable capture*. Here's a C\n-macro, using [a GNU C extension] to emulate Rust's expression blocks.\n+Another common problem in macro systems is \u2018variable capture\u2019. Here\u2019s a C\n+macro, using [a GNU C extension] to emulate Rust\u2019s expression blocks.\n \n [a GNU C extension]: https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html\n \n@@ -275,7 +275,7 @@ macro, using [a GNU C extension] to emulate Rust's expression blocks.\n })\n ```\n \n-Here's a simple use case that goes terribly wrong:\n+Here\u2019s a simple use case that goes terribly wrong:\n \n ```text\n const char *state = \"reticulating splines\";\n@@ -315,10 +315,10 @@ fn main() {\n ```\n \n This works because Rust has a [hygienic macro system][]. Each macro expansion\n-happens in a distinct *syntax context*, and each variable is tagged with the\n-syntax context where it was introduced. It's as though the variable `state`\n+happens in a distinct \u2018syntax context\u2019, and each variable is tagged with the\n+syntax context where it was introduced. It\u2019s as though the variable `state`\n inside `main` is painted a different \"color\" from the variable `state` inside\n-the macro, and therefore they don't conflict.\n+the macro, and therefore they don\u2019t conflict.\n \n [hygienic macro system]: http://en.wikipedia.org/wiki/Hygienic_macro\n \n@@ -336,7 +336,7 @@ fn main() {\n }\n ```\n \n-Instead you need to pass the variable name into the invocation, so it's tagged\n+Instead you need to pass the variable name into the invocation, so it\u2019s tagged\n with the right syntax context.\n \n ```rust\n@@ -368,7 +368,7 @@ fn main() {\n \n # Recursive macros\n \n-A macro's expansion can include more macro invocations, including invocations\n+A macro\u2019s expansion can include more macro invocations, including invocations\n of the very same macro being expanded.  These recursive macros are useful for\n processing tree-structured input, as illustrated by this (simplistic) HTML\n shorthand:\n@@ -429,7 +429,7 @@ they are unstable and require feature gates.\n Even when Rust code contains un-expanded macros, it can be parsed as a full\n [syntax tree][ast]. This property can be very useful for editors and other\n tools that process code. It also has a few consequences for the design of\n-Rust's macro system.\n+Rust\u2019s macro system.\n \n [ast]: glossary.html#abstract-syntax-tree\n \n@@ -454,13 +454,13 @@ consist of valid Rust tokens. Furthermore, parentheses, brackets, and braces\n must be balanced within a macro invocation. For example, `foo!([)` is\n forbidden. This allows Rust to know where the macro invocation ends.\n \n-More formally, the macro invocation body must be a sequence of *token trees*.\n+More formally, the macro invocation body must be a sequence of \u2018token trees\u2019.\n A token tree is defined recursively as either\n \n * a sequence of token trees surrounded by matching `()`, `[]`, or `{}`, or\n * any other single token.\n \n-Within a matcher, each metavariable has a *fragment specifier*, identifying\n+Within a matcher, each metavariable has a \u2018fragment specifier\u2019, identifying\n which syntactic form it matches.\n \n * `ident`: an identifier. Examples: `x`; `foo`.\n@@ -482,7 +482,7 @@ There are additional rules regarding the next token after a metavariable:\n * `pat` variables must be followed by one of: `=> , =`\n * Other variables may be followed by any token.\n \n-These rules provide some flexibility for Rust's syntax to evolve without\n+These rules provide some flexibility for Rust\u2019s syntax to evolve without\n breaking existing macros.\n \n The macro system does not deal with parse ambiguity at all. For example, the\n@@ -500,16 +500,16 @@ One downside is that scoping works differently for macros, compared to other\n constructs in the language.\n \n Definition and expansion of macros both happen in a single depth-first,\n-lexical-order traversal of a crate's source. So a macro defined at module scope\n+lexical-order traversal of a crate\u2019s source. So a macro defined at module scope\n is visible to any subsequent code in the same module, which includes the body\n of any subsequent child `mod` items.\n \n A macro defined within the body of a single `fn`, or anywhere else not at\n module scope, is visible only within that item.\n \n If a module has the `macro_use` attribute, its macros are also visible in its\n-parent module after the child's `mod` item. If the parent also has `macro_use`\n-then the macros will be visible in the grandparent after the parent's `mod`\n+parent module after the child\u2019s `mod` item. If the parent also has `macro_use`\n+then the macros will be visible in the grandparent after the parent\u2019s `mod`\n item, and so forth.\n \n The `macro_use` attribute can also appear on `extern crate`. In this context\n@@ -524,7 +524,7 @@ If the attribute is given simply as `#[macro_use]`, all macros are loaded. If\n there is no `#[macro_use]` attribute then no macros are loaded. Only macros\n defined with the `#[macro_export]` attribute may be loaded.\n \n-To load a crate's macros *without* linking it into the output, use `#[no_link]`\n+To load a crate\u2019s macros without linking it into the output, use `#[no_link]`\n as well.\n \n An example:\n@@ -619,12 +619,12 @@ only appear at the root of your crate, not inside `mod`. This ensures that\n \n The introductory chapter mentioned recursive macros, but it did not give the\n full story. Recursive macros are useful for another reason: Each recursive\n-invocation gives you another opportunity to pattern-match the macro's\n+invocation gives you another opportunity to pattern-match the macro\u2019s\n arguments.\n \n As an extreme example, it is possible, though hardly advisable, to implement\n the [Bitwise Cyclic Tag](http://esolangs.org/wiki/Bitwise_Cyclic_Tag) automaton\n-within Rust's macro system.\n+within Rust\u2019s macro system.\n \n ```rust\n macro_rules! bct {\n@@ -765,9 +765,9 @@ as `unimplemented!` until you\u2019re ready to write them.\n \n # Procedural macros\n \n-If Rust's macro system can't do what you need, you may want to write a\n+If Rust\u2019s macro system can\u2019t do what you need, you may want to write a\n [compiler plugin](plugins.html) instead. Compared to `macro_rules!`\n macros, this is significantly more work, the interfaces are much less stable,\n and bugs can be much harder to track down. In exchange you get the\n flexibility of running arbitrary Rust code within the compiler. Syntax\n-extension plugins are sometimes called *procedural macros* for this reason.\n+extension plugins are sometimes called \u2018procedural macros\u2019 for this reason."}, {"sha": "52f8cb335a93a0c8eb92953a2432a836320c2755", "filename": "src/doc/trpl/trait-objects.md", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0070625495709bb2f6020d9d1ae628f8f035358f/src%2Fdoc%2Ftrpl%2Ftrait-objects.md", "raw_url": "https://github.com/rust-lang/rust/raw/0070625495709bb2f6020d9d1ae628f8f035358f/src%2Fdoc%2Ftrpl%2Ftrait-objects.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftrait-objects.md?ref=0070625495709bb2f6020d9d1ae628f8f035358f", "patch": "@@ -1,15 +1,15 @@\n % Trait Objects\n \n When code involves polymorphism, there needs to be a mechanism to determine\n-which specific version is actually run. This is called 'dispatch.' There are\n+which specific version is actually run. This is called \u2018dispatch\u2019. There are\n two major forms of dispatch: static dispatch and dynamic dispatch. While Rust\n favors static dispatch, it also supports dynamic dispatch through a mechanism\n-called 'trait objects.'\n+called \u2018trait objects\u2019.\n \n ## Background\n \n-For the rest of this chapter, we'll need a trait and some implementations.\n-Let's make a simple one, `Foo`. It has one method that is expected to return a\n+For the rest of this chapter, we\u2019ll need a trait and some implementations.\n+Let\u2019s make a simple one, `Foo`. It has one method that is expected to return a\n `String`.\n \n ```rust\n@@ -18,7 +18,7 @@ trait Foo {\n }\n ```\n \n-We'll also implement this trait for `u8` and `String`:\n+We\u2019ll also implement this trait for `u8` and `String`:\n \n ```rust\n # trait Foo { fn method(&self) -> String; }\n@@ -53,7 +53,7 @@ fn main() {\n }\n ```\n \n-Rust uses 'monomorphization' to perform static dispatch here. This means that\n+Rust uses \u2018monomorphization\u2019 to perform static dispatch here. This means that\n Rust will create a special version of `do_something()` for both `u8` and\n `String`, and then replace the call sites with calls to these specialized\n functions. In other words, Rust generates something like this:\n@@ -82,7 +82,7 @@ fn main() {\n This has a great upside: static dispatch allows function calls to be\n inlined because the callee is known at compile time, and inlining is\n the key to good optimization. Static dispatch is fast, but it comes at\n-a tradeoff: 'code bloat', due to many copies of the same function\n+a tradeoff: \u2018code bloat\u2019, due to many copies of the same function\n existing in the binary, one for each type.\n \n Furthermore, compilers aren\u2019t perfect and may \u201coptimize\u201d code to become slower.\n@@ -99,7 +99,7 @@ reason.\n \n ## Dynamic dispatch\n \n-Rust provides dynamic dispatch through a feature called 'trait objects.' Trait\n+Rust provides dynamic dispatch through a feature called \u2018trait objects\u2019. Trait\n objects, like `&Foo` or `Box<Foo>`, are normal values that store a value of\n *any* type that implements the given trait, where the precise type can only be\n known at runtime.\n@@ -109,12 +109,12 @@ implements the trait by *casting* it (e.g. `&x as &Foo`) or *coercing* it\n (e.g. using `&x` as an argument to a function that takes `&Foo`).\n \n These trait object coercions and casts also work for pointers like `&mut T` to\n-`&mut Foo` and `Box<T>` to `Box<Foo>`, but that's all at the moment. Coercions\n+`&mut Foo` and `Box<T>` to `Box<Foo>`, but that\u2019s all at the moment. Coercions\n and casts are identical.\n \n-This operation can be seen as \"erasing\" the compiler's knowledge about the\n+This operation can be seen as \u2018erasing\u2019 the compiler\u2019s knowledge about the\n specific type of the pointer, and hence trait objects are sometimes referred to\n-as \"type erasure\".\n+as \u2018type erasure\u2019.\n \n Coming back to the example above, we can use the same trait to perform dynamic\n dispatch with trait objects by casting:\n@@ -167,7 +167,7 @@ on the heap to store it.\n \n For `Foo`, we would need to have a value that could be at least either a\n `String` (24 bytes) or a `u8` (1 byte), as well as any other type for which\n-dependent crates may implement `Foo` (any number of bytes at all). There's no\n+dependent crates may implement `Foo` (any number of bytes at all). There\u2019s no\n way to guarantee that this last point can work if the values are stored without\n a pointer, because those other types can be arbitrarily large.\n \n@@ -177,14 +177,14 @@ when we are tossing a trait object around, only the size of the pointer itself.\n ### Representation\n \n The methods of the trait can be called on a trait object via a special record\n-of function pointers traditionally called a 'vtable' (created and managed by\n+of function pointers traditionally called a \u2018vtable\u2019 (created and managed by\n the compiler).\n \n Trait objects are both simple and complicated: their core representation and\n layout is quite straight-forward, but there are some curly error messages and\n surprising behaviors to discover.\n \n-Let's start simple, with the runtime representation of a trait object. The\n+Let\u2019s start simple, with the runtime representation of a trait object. The\n `std::raw` module contains structs with layouts that are the same as the\n complicated built-in types, [including trait objects][stdraw]:\n \n@@ -199,20 +199,20 @@ pub struct TraitObject {\n \n [stdraw]: ../std/raw/struct.TraitObject.html\n \n-That is, a trait object like `&Foo` consists of a \"data\" pointer and a \"vtable\"\n+That is, a trait object like `&Foo` consists of a \u2018data\u2019 pointer and a \u2018vtable\u2019\n pointer.\n \n The data pointer addresses the data (of some unknown type `T`) that the trait\n-object is storing, and the vtable pointer points to the vtable (\"virtual method\n-table\") corresponding to the implementation of `Foo` for `T`.\n+object is storing, and the vtable pointer points to the vtable (\u2018virtual method\n+table\u2019) corresponding to the implementation of `Foo` for `T`.\n \n \n A vtable is essentially a struct of function pointers, pointing to the concrete\n piece of machine code for each method in the implementation. A method call like\n `trait_object.method()` will retrieve the correct pointer out of the vtable and\n then do a dynamic call of it. For example:\n \n-```{rust,ignore}\n+```rust,ignore\n struct FooVtable {\n     destructor: fn(*mut ()),\n     size: usize,\n@@ -261,7 +261,7 @@ static Foo_for_String_vtable: FooVtable = FooVtable {\n ```\n \n The `destructor` field in each vtable points to a function that will clean up\n-any resources of the vtable's type, for `u8` it is trivial, but for `String` it\n+any resources of the vtable\u2019s type, for `u8` it is trivial, but for `String` it\n will free the memory. This is necessary for owning trait objects like\n `Box<Foo>`, which need to clean-up both the `Box` allocation as well as the\n internal type when they go out of scope. The `size` and `align` fields store\n@@ -270,11 +270,11 @@ essentially unused at the moment since the information is embedded in the\n destructor, but will be used in the future, as trait objects are progressively\n made more flexible.\n \n-Suppose we've got some values that implement `Foo`, then the explicit form of\n+Suppose we\u2019ve got some values that implement `Foo`, then the explicit form of\n construction and use of `Foo` trait objects might look a bit like (ignoring the\n-type mismatches: they're all just pointers anyway):\n+type mismatches: they\u2019re all just pointers anyway):\n \n-```{rust,ignore}\n+```rust,ignore\n let a: String = \"foo\".to_string();\n let x: u8 = 1;\n "}]}