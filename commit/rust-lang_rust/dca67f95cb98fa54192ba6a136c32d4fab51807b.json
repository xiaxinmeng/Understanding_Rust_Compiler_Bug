{"sha": "dca67f95cb98fa54192ba6a136c32d4fab51807b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjYTY3Zjk1Y2I5OGZhNTQxOTJiYTZhMTM2YzMyZDRmYWI1MTgwN2I=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-25T14:23:32Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-25T14:46:08Z"}, "message": "Make the lexer slightly less stateful", "tree": {"sha": "6bba0f8131a885d1b0fd2f46baa283d6ee1a5831", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bba0f8131a885d1b0fd2f46baa283d6ee1a5831"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dca67f95cb98fa54192ba6a136c32d4fab51807b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dca67f95cb98fa54192ba6a136c32d4fab51807b", "html_url": "https://github.com/rust-lang/rust/commit/dca67f95cb98fa54192ba6a136c32d4fab51807b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dca67f95cb98fa54192ba6a136c32d4fab51807b/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e949aab10ae69d671fe1fc315c12f04b2674d969", "url": "https://api.github.com/repos/rust-lang/rust/commits/e949aab10ae69d671fe1fc315c12f04b2674d969", "html_url": "https://github.com/rust-lang/rust/commit/e949aab10ae69d671fe1fc315c12f04b2674d969"}], "stats": {"total": 54, "additions": 25, "deletions": 29}, "files": [{"sha": "799050bb083276e90026eb27254ce968382c7c00", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/dca67f95cb98fa54192ba6a136c32d4fab51807b/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca67f95cb98fa54192ba6a136c32d4fab51807b/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=dca67f95cb98fa54192ba6a136c32d4fab51807b", "patch": "@@ -19,9 +19,7 @@ type reader =\n         fn next() -> char ;\n         fn init() ;\n         fn bump() ;\n-        fn mark() ;\n-        fn get_mark_chpos() -> uint ;\n-        fn get_mark_str() -> str ;\n+        fn get_str_from(uint) -> str ;\n         fn get_interner() -> @interner::interner[str] ;\n         fn get_chpos() -> uint ;\n         fn get_byte_pos() -> uint ;\n@@ -38,21 +36,16 @@ fn new_reader(&codemap::codemap cm, str src, codemap::filemap filemap,\n                mutable uint col,\n                mutable uint pos,\n                mutable char ch,\n-               mutable uint mark_pos,\n-               mutable uint mark_chpos,\n                mutable uint chpos,\n                mutable str[] strs,\n                codemap::filemap fm,\n                @interner::interner[str] itr) {\n         fn is_eof() -> bool { ret ch == -1 as char; }\n-        fn mark() { mark_pos = pos; mark_chpos = chpos; }\n-        fn get_mark_str() -> str {\n+        fn get_str_from(uint start) -> str {\n             // I'm pretty skeptical about this subtraction. What if there's a\n             // multi-byte character before the mark?\n-            ret str::slice(src, mark_pos - 1u,\n-                           pos - 1u);\n+            ret str::slice(src, start - 1u, pos - 1u);\n         }\n-        fn get_mark_chpos() -> uint { ret mark_chpos; }\n         fn get_chpos() -> uint { ret chpos; }\n         fn get_byte_pos() -> uint { ret pos; }\n         fn curr() -> char { ret ch; }\n@@ -90,9 +83,8 @@ fn new_reader(&codemap::codemap cm, str src, codemap::filemap filemap,\n     }\n     let str[] strs = ~[];\n     auto rd =\n-        reader(cm, src, str::byte_len(src), 0u, 0u, -1 as char, 0u,\n-               filemap.start_pos.ch, filemap.start_pos.ch, strs, filemap,\n-               itr);\n+        reader(cm, src, str::byte_len(src), 0u, 0u, -1 as char,\n+               filemap.start_pos.ch, strs, filemap, itr);\n     rd.init();\n     ret rd;\n }\n@@ -346,11 +338,17 @@ fn scan_numeric_escape(&reader rdr, uint n_hex_digits) -> char {\n     ret accum_int as char;\n }\n \n-fn next_token(&reader rdr) -> token::token {\n-    auto accum_str = \"\";\n+fn next_token(&reader rdr) -> tup(token::token, uint, uint) {\n     consume_whitespace_and_comments(rdr);\n-    if (rdr.is_eof()) { ret token::EOF; }\n-    rdr.mark();\n+    auto start_chpos = rdr.get_chpos();\n+    auto start_bpos = rdr.get_byte_pos();\n+    auto tok = if rdr.is_eof() { token::EOF }\n+               else { next_token_inner(rdr) };\n+    ret tup(tok, start_chpos, start_bpos);\n+}\n+\n+fn next_token_inner(&reader rdr) -> token::token {\n+    auto accum_str = \"\";\n     auto c = rdr.curr();\n     if (is_alpha(c) || c == '_') {\n         while (is_alnum(c) || c == '_') {\n@@ -762,11 +760,10 @@ fn gather_comments_and_literals(&codemap::codemap cm, str path)\n             break;\n         }\n         auto tok = next_token(rdr);\n-        if (is_lit(tok)) {\n-            literals += ~[rec(lit=rdr.get_mark_str(),\n-                              pos=rdr.get_mark_chpos())];\n+        if (is_lit(tok._0)) {\n+            literals += ~[rec(lit=rdr.get_str_from(tok._2), pos=tok._1)];\n         }\n-        log \"tok: \" + token::to_str(rdr, tok);\n+        log \"tok: \" + token::to_str(rdr, tok._0);\n         first_read = false;\n     }\n     ret rec(cmnts=comments, lits=literals);"}, {"sha": "5e2e89a3dce6513f003d7538326164c5918ed444", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dca67f95cb98fa54192ba6a136c32d4fab51807b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca67f95cb98fa54192ba6a136c32d4fab51807b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=dca67f95cb98fa54192ba6a136c32d4fab51807b", "patch": "@@ -90,8 +90,9 @@ fn new_parser(parse_sess sess, ast::crate_cfg cfg, lexer::reader rdr,\n             //   + \":\" + common::istr(lo.line as int);\n \n             last_lo = lo;\n-            tok = lexer::next_token(rdr);\n-            lo = rdr.get_mark_chpos();\n+            auto next = lexer::next_token(rdr);\n+            tok = next._0;\n+            lo = next._1;\n             hi = rdr.get_chpos();\n         }\n         fn fatal(str m) -> ! {\n@@ -122,11 +123,9 @@ fn new_parser(parse_sess sess, ast::crate_cfg cfg, lexer::reader rdr,\n         fn get_sess() -> parse_sess { ret sess; }\n     }\n \n-    // Make sure npos points at first actual token:\n-    lexer::consume_whitespace_and_comments(rdr);\n-    auto npos = rdr.get_chpos();\n-    ret stdio_parser(sess, cfg, ftype, lexer::next_token(rdr),\n-                     npos, npos, npos, UNRESTRICTED, rdr,\n+    auto tok0 = lexer::next_token(rdr);\n+    ret stdio_parser(sess, cfg, ftype, tok0._0,\n+                     tok0._1, tok0._1, tok0._1, UNRESTRICTED, rdr,\n                      prec_table(), bad_expr_word_table());\n }\n \n@@ -693,13 +692,13 @@ fn parse_path(&parser p) -> ast::path {\n             case (token::IDENT(?i, _)) {\n                 hi = p.get_hi_pos();\n                 ids += ~[p.get_str(i)];\n+                hi = p.get_hi_pos();\n                 p.bump();\n                 if (p.peek() == token::MOD_SEP) { p.bump(); } else { break; }\n             }\n             case (_) { break; }\n         }\n     }\n-    hi = p.get_hi_pos();\n     ret spanned(lo, hi, rec(global=global, idents=ids, types=~[]));\n }\n "}]}