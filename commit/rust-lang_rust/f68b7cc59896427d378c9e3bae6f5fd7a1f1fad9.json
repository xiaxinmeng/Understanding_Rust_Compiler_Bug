{"sha": "f68b7cc59896427d378c9e3bae6f5fd7a1f1fad9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2OGI3Y2M1OTg5NjQyN2QzNzhjOWUzYmFlNmY1ZmQ3YTFmMWZhZDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-05T00:37:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-05T00:37:03Z"}, "message": "Auto merge of #53027 - matklad:once_is_completed, r=alexcrichton\n\nAllow to check if sync::Once is already initialized\n\nHi!\n\nI propose to expose a way to check if a `Once` instance is initialized.\n\nI need it in `once_cell`. `OnceCell` is effetively a pair of `(Once, UnsafeCell<Option<T>>)`, which can set the `T` only once. Because I can't check if `Once` is initialized, I am forced to add an indirection and check the value of ptr instead:\n\nhttps://github.com/matklad/once_cell/blob/8127a81976c3f2f4c0860562c3f14647ebc025c0/src/lib.rs#L423-L429\n\nhttps://github.com/matklad/once_cell/blob/8127a81976c3f2f4c0860562c3f14647ebc025c0/src/lib.rs#L457-L461\n\nThe `parking_lot`'s version of `Once` exposes the state as an enum: https://docs.rs/parking_lot/0.6.3/parking_lot/struct.Once.html#method.state.\n\nI suggest, for now, just to add a simple `bool` function: this fits my use-case perfectly, exposes less implementation details, and is forward-compatible with more fine-grained state checking.", "tree": {"sha": "e7c43bb48abe1a3fe6c8a8d7fa2de19f5b644958", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7c43bb48abe1a3fe6c8a8d7fa2de19f5b644958"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f68b7cc59896427d378c9e3bae6f5fd7a1f1fad9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f68b7cc59896427d378c9e3bae6f5fd7a1f1fad9", "html_url": "https://github.com/rust-lang/rust/commit/f68b7cc59896427d378c9e3bae6f5fd7a1f1fad9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f68b7cc59896427d378c9e3bae6f5fd7a1f1fad9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c2e17f4e3a2070a7f703f51e29c1c388ef703b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c2e17f4e3a2070a7f703f51e29c1c388ef703b6", "html_url": "https://github.com/rust-lang/rust/commit/1c2e17f4e3a2070a7f703f51e29c1c388ef703b6"}, {"sha": "e1bd0e7b4e9009ada545580b2698a11631f1f597", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1bd0e7b4e9009ada545580b2698a11631f1f597", "html_url": "https://github.com/rust-lang/rust/commit/e1bd0e7b4e9009ada545580b2698a11631f1f597"}], "stats": {"total": 73, "additions": 59, "deletions": 14}, "files": [{"sha": "ce54726baee2a43f0bb60e623b22d2fcbd5509cd", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 59, "deletions": 14, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f68b7cc59896427d378c9e3bae6f5fd7a1f1fad9/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f68b7cc59896427d378c9e3bae6f5fd7a1f1fad9/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=f68b7cc59896427d378c9e3bae6f5fd7a1f1fad9", "patch": "@@ -221,13 +221,9 @@ impl Once {\n     /// [poison]: struct.Mutex.html#poisoning\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn call_once<F>(&self, f: F) where F: FnOnce() {\n-        // Fast path, just see if we've completed initialization.\n-        // An `Acquire` load is enough because that makes all the initialization\n-        // operations visible to us. The cold path uses SeqCst consistently\n-        // because the performance difference really does not matter there,\n-        // and SeqCst minimizes the chances of something going wrong.\n-        if self.state.load(Ordering::Acquire) == COMPLETE {\n-            return\n+        // Fast path check\n+        if self.is_completed() {\n+            return;\n         }\n \n         let mut f = Some(f);\n@@ -282,13 +278,9 @@ impl Once {\n     /// ```\n     #[unstable(feature = \"once_poison\", issue = \"33577\")]\n     pub fn call_once_force<F>(&self, f: F) where F: FnOnce(&OnceState) {\n-        // same as above, just with a different parameter to `call_inner`.\n-        // An `Acquire` load is enough because that makes all the initialization\n-        // operations visible to us. The cold path uses SeqCst consistently\n-        // because the performance difference really does not matter there,\n-        // and SeqCst minimizes the chances of something going wrong.\n-        if self.state.load(Ordering::Acquire) == COMPLETE {\n-            return\n+        // Fast path check\n+        if self.is_completed() {\n+            return;\n         }\n \n         let mut f = Some(f);\n@@ -297,6 +289,55 @@ impl Once {\n         });\n     }\n \n+    /// Returns true if some `call_once` call has completed\n+    /// successfuly. Specifically, `is_completed` will return false in\n+    /// the following situtations:\n+    ///   * `call_once` was not called at all,\n+    ///   * `call_once` was called, but has not yet completed,\n+    ///   * the `Once` instance is poisoned\n+    ///\n+    /// It is also possible that immediately after `is_completed`\n+    /// returns false, some other thread finishes executing\n+    /// `call_once`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_is_completed)]\n+    /// use std::sync::Once;\n+    ///\n+    /// static INIT: Once = Once::new();\n+    ///\n+    /// assert_eq!(INIT.is_completed(), false);\n+    /// INIT.call_once(|| {\n+    ///     assert_eq!(INIT.is_completed(), false);\n+    /// });\n+    /// assert_eq!(INIT.is_completed(), true);\n+    /// ```\n+    ///\n+    /// ```\n+    /// #![feature(once_is_completed)]\n+    /// use std::sync::Once;\n+    /// use std::thread;\n+    ///\n+    /// static INIT: Once = Once::new();\n+    ///\n+    /// assert_eq!(INIT.is_completed(), false);\n+    /// let handle = thread::spawn(|| {\n+    ///     INIT.call_once(|| panic!());\n+    /// });\n+    /// assert!(handle.join().is_err());\n+    /// assert_eq!(INIT.is_completed(), false);\n+    /// ```\n+    #[unstable(feature = \"once_is_completed\", issue = \"42\")]\n+    pub fn is_completed(&self) -> bool {\n+        // An `Acquire` load is enough because that makes all the initialization\n+        // operations visible to us, and, this being a fast path, weaker\n+        // ordering helps with performance. This `Acquire` synchronizes with\n+        // `SeqCst` operations on the slow path.\n+        self.state.load(Ordering::Acquire) == COMPLETE\n+    }\n+\n     // This is a non-generic function to reduce the monomorphization cost of\n     // using `call_once` (this isn't exactly a trivial or small implementation).\n     //\n@@ -312,6 +353,10 @@ impl Once {\n     fn call_inner(&self,\n                   ignore_poisoning: bool,\n                   init: &mut dyn FnMut(bool)) {\n+\n+        // This cold path uses SeqCst consistently because the\n+        // performance difference really does not matter there, and\n+        // SeqCst minimizes the chances of something going wrong.\n         let mut state = self.state.load(Ordering::SeqCst);\n \n         'outer: loop {"}]}