{"sha": "a7f376fbd3f30b58ec2bde5538b446eb4c2d615e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3ZjM3NmZiZDNmMzBiNThlYzJiZGU1NTM4YjQ0NmViNGMyZDYxNWU=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-07-17T17:52:03Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-08-16T13:34:58Z"}, "message": "Add lint `manual_split_once`", "tree": {"sha": "611a8ff2ff5d995c69e3698397426e23e7171aa7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/611a8ff2ff5d995c69e3698397426e23e7171aa7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmEaaYUACgkQ2lnoZDo37QZK9AD+MiFZDuWmRyDTkDgSnQ5oD3ei\niZ4OPRhSKXSPl8ADLjcBAMrblJhoJiqmpdVrKqy1Wggvvg3ATtuA03q9dJiy8UUE\n=fxrO\n-----END PGP SIGNATURE-----", "payload": "tree 611a8ff2ff5d995c69e3698397426e23e7171aa7\nparent 8cf6dae0ca66525fcdf519b588896e6cb5576c71\nauthor Jason Newcomb <jsnewcomb@pm.me> 1626544323 -0400\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1629120898 -0400\n\nAdd lint `manual_split_once`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e", "html_url": "https://github.com/rust-lang/rust/commit/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cf6dae0ca66525fcdf519b588896e6cb5576c71", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cf6dae0ca66525fcdf519b588896e6cb5576c71", "html_url": "https://github.com/rust-lang/rust/commit/8cf6dae0ca66525fcdf519b588896e6cb5576c71"}], "stats": {"total": 485, "additions": 459, "deletions": 26}, "files": [{"sha": "b9e67d361c0c34cc265eb98307209e64053e1f42", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=a7f376fbd3f30b58ec2bde5538b446eb4c2d615e", "patch": "@@ -2754,6 +2754,7 @@ Released 2018-09-13\n [`manual_ok_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_ok_or\n [`manual_range_contains`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_range_contains\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n+[`manual_split_once`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_split_once\n [`manual_str_repeat`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_str_repeat\n [`manual_strip`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip\n [`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap"}, {"sha": "1fadaf4770a811cb6803e4a66de21e41c7262361", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=a7f376fbd3f30b58ec2bde5538b446eb4c2d615e", "patch": "@@ -773,6 +773,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         methods::MANUAL_FILTER_MAP,\n         methods::MANUAL_FIND_MAP,\n         methods::MANUAL_SATURATING_ARITHMETIC,\n+        methods::MANUAL_SPLIT_ONCE,\n         methods::MANUAL_STR_REPEAT,\n         methods::MAP_COLLECT_RESULT_UNIT,\n         methods::MAP_FLATTEN,\n@@ -1319,6 +1320,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::MANUAL_FILTER_MAP),\n         LintId::of(methods::MANUAL_FIND_MAP),\n         LintId::of(methods::MANUAL_SATURATING_ARITHMETIC),\n+        LintId::of(methods::MANUAL_SPLIT_ONCE),\n         LintId::of(methods::MANUAL_STR_REPEAT),\n         LintId::of(methods::MAP_COLLECT_RESULT_UNIT),\n         LintId::of(methods::MAP_IDENTITY),\n@@ -1617,6 +1619,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::ITER_COUNT),\n         LintId::of(methods::MANUAL_FILTER_MAP),\n         LintId::of(methods::MANUAL_FIND_MAP),\n+        LintId::of(methods::MANUAL_SPLIT_ONCE),\n         LintId::of(methods::MAP_IDENTITY),\n         LintId::of(methods::OPTION_AS_REF_DEREF),\n         LintId::of(methods::OPTION_FILTER_MAP),"}, {"sha": "e273186d0519022d5a7c1a9219cf1aa9625fd4a7", "filename": "clippy_lints/src/methods/manual_split_once.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/clippy_lints%2Fsrc%2Fmethods%2Fmanual_split_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/clippy_lints%2Fsrc%2Fmethods%2Fmanual_split_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_split_once.rs?ref=a7f376fbd3f30b58ec2bde5538b446eb4c2d615e", "patch": "@@ -0,0 +1,213 @@\n+use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_context;\n+use clippy_utils::{is_diag_item_method, match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, HirId, LangItem, Node, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, adjustment::Adjust};\n+use rustc_span::{symbol::sym, Span, SyntaxContext};\n+\n+use super::MANUAL_SPLIT_ONCE;\n+\n+pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, self_arg: &Expr<'_>, pat_arg: &Expr<'_>) {\n+    if !cx.typeck_results().expr_ty_adjusted(self_arg).peel_refs().is_str() {\n+        return;\n+    }\n+\n+    let ctxt = expr.span.ctxt();\n+    let usage = match parse_iter_usage(cx, ctxt, cx.tcx.hir().parent_iter(expr.hir_id)) {\n+        Some(x) => x,\n+        None => return,\n+    };\n+    let (method_name, msg) = if method_name == \"splitn\" {\n+        (\"split_once\", \"manual implementation of `split_once`\")\n+    } else {\n+        (\"rsplit_once\", \"manual implementation of `rsplit_once`\")\n+    };\n+\n+    let mut app = Applicability::MachineApplicable;\n+    let self_snip = snippet_with_context(cx, self_arg.span, ctxt, \"..\", &mut app).0;\n+    let pat_snip = snippet_with_context(cx, pat_arg.span, ctxt, \"..\", &mut app).0;\n+\n+    match usage.kind {\n+        IterUsageKind::NextTuple => {\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_SPLIT_ONCE,\n+                usage.span,\n+                msg,\n+                \"try this\",\n+                format!(\"{}.{}({})\", self_snip, method_name, pat_snip),\n+                app,\n+            );\n+        },\n+        IterUsageKind::Next => {\n+            let self_deref = {\n+                let adjust = cx.typeck_results().expr_adjustments(self_arg);\n+                if adjust.is_empty() {\n+                    String::new()\n+                } else if cx.typeck_results().expr_ty(self_arg).is_box()\n+                    || adjust\n+                        .iter()\n+                        .any(|a| matches!(a.kind, Adjust::Deref(Some(_))) || a.target.is_box())\n+                {\n+                    format!(\"&{}\", \"*\".repeat(adjust.len() - 1))\n+                } else {\n+                    \"*\".repeat(adjust.len() - 2)\n+                }\n+            };\n+            let sugg = if usage.unwrap_kind.is_some() {\n+                format!(\n+                    \"{}.{}({}).map_or({}{}, |x| x.0)\",\n+                    &self_snip, method_name, pat_snip, self_deref, &self_snip\n+                )\n+            } else {\n+                format!(\n+                    \"Some({}.{}({}).map_or({}{}, |x| x.0))\",\n+                    &self_snip, method_name, pat_snip, self_deref, &self_snip\n+                )\n+            };\n+\n+            span_lint_and_sugg(cx, MANUAL_SPLIT_ONCE, usage.span, msg, \"try this\", sugg, app);\n+        },\n+        IterUsageKind::Second => {\n+            let access_str = match usage.unwrap_kind {\n+                Some(UnwrapKind::Unwrap) => \".unwrap().1\",\n+                Some(UnwrapKind::QuestionMark) => \"?.1\",\n+                None => \".map(|x| x.1)\",\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_SPLIT_ONCE,\n+                usage.span,\n+                msg,\n+                \"try this\",\n+                format!(\"{}.{}({}){}\", self_snip, method_name, pat_snip, access_str),\n+                app,\n+            );\n+        },\n+    }\n+}\n+\n+enum IterUsageKind {\n+    Next,\n+    Second,\n+    NextTuple,\n+}\n+\n+enum UnwrapKind {\n+    Unwrap,\n+    QuestionMark,\n+}\n+\n+struct IterUsage {\n+    kind: IterUsageKind,\n+    unwrap_kind: Option<UnwrapKind>,\n+    span: Span,\n+}\n+\n+fn parse_iter_usage(\n+    cx: &LateContext<'tcx>,\n+    ctxt: SyntaxContext,\n+    mut iter: impl Iterator<Item = (HirId, Node<'tcx>)>,\n+) -> Option<IterUsage> {\n+    let (kind, span) = match iter.next() {\n+        Some((_, Node::Expr(e))) if e.span.ctxt() == ctxt => {\n+            let (name, args) = if let ExprKind::MethodCall(name, _, [_, args @ ..], _) = e.kind {\n+                (name, args)\n+            } else {\n+                return None;\n+            };\n+            let did = cx.typeck_results().type_dependent_def_id(e.hir_id)?;\n+            let iter_id = cx.tcx.get_diagnostic_item(sym::Iterator)?;\n+\n+            match (&*name.ident.as_str(), args) {\n+                (\"next\", []) if cx.tcx.trait_of_item(did) == Some(iter_id) => (IterUsageKind::Next, e.span),\n+                (\"next_tuple\", []) => {\n+                    if_chain! {\n+                        if match_def_path(cx, did, &paths::ITERTOOLS_NEXT_TUPLE);\n+                        if let ty::Adt(adt_def, subs) = cx.typeck_results().expr_ty(e).kind();\n+                        if cx.tcx.is_diagnostic_item(sym::option_type, adt_def.did);\n+                        if let ty::Tuple(subs) = subs.type_at(0).kind();\n+                        if subs.len() == 2;\n+                        then {\n+                            return Some(IterUsage { kind: IterUsageKind::NextTuple, span: e.span, unwrap_kind: None });\n+                        } else {\n+                            return None;\n+                        }\n+                    }\n+                },\n+                (\"nth\" | \"skip\", [idx_expr]) if cx.tcx.trait_of_item(did) == Some(iter_id) => {\n+                    if let Some((Constant::Int(idx), _)) = constant(cx, cx.typeck_results(), idx_expr) {\n+                        let span = if name.ident.as_str() == \"nth\" {\n+                            e.span\n+                        } else {\n+                            if_chain! {\n+                                if let Some((_, Node::Expr(next_expr))) = iter.next();\n+                                if let ExprKind::MethodCall(next_name, _, [_], _) = next_expr.kind;\n+                                if next_name.ident.name == sym::next;\n+                                if next_expr.span.ctxt() == ctxt;\n+                                if let Some(next_id) = cx.typeck_results().type_dependent_def_id(next_expr.hir_id);\n+                                if cx.tcx.trait_of_item(next_id) == Some(iter_id);\n+                                then {\n+                                    next_expr.span\n+                                } else {\n+                                    return None;\n+                                }\n+                            }\n+                        };\n+                        match idx {\n+                            0 => (IterUsageKind::Next, span),\n+                            1 => (IterUsageKind::Second, span),\n+                            _ => return None,\n+                        }\n+                    } else {\n+                        return None;\n+                    }\n+                },\n+                _ => return None,\n+            }\n+        },\n+        _ => return None,\n+    };\n+\n+    let (unwrap_kind, span) = if let Some((_, Node::Expr(e))) = iter.next() {\n+        match e.kind {\n+            ExprKind::Call(\n+                Expr {\n+                    kind: ExprKind::Path(QPath::LangItem(LangItem::TryTraitBranch, _)),\n+                    ..\n+                },\n+                _,\n+            ) => {\n+                let parent_span = e.span.parent().unwrap();\n+                if parent_span.ctxt() == ctxt {\n+                    (Some(UnwrapKind::QuestionMark), parent_span)\n+                } else {\n+                    (None, span)\n+                }\n+            },\n+            _ if e.span.ctxt() != ctxt => (None, span),\n+            ExprKind::MethodCall(name, _, [_], _)\n+                if name.ident.name == sym::unwrap\n+                    && cx\n+                        .typeck_results()\n+                        .type_dependent_def_id(e.hir_id)\n+                        .map_or(false, |id| is_diag_item_method(cx, id, sym::option_type)) =>\n+            {\n+                (Some(UnwrapKind::Unwrap), e.span)\n+            },\n+            _ => (None, span),\n+        }\n+    } else {\n+        (None, span)\n+    };\n+\n+    Some(IterUsage {\n+        kind,\n+        unwrap_kind,\n+        span,\n+    })\n+}"}, {"sha": "15ad0325006eb62dcc31de8151b091c71cd8bcf8", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=a7f376fbd3f30b58ec2bde5538b446eb4c2d615e", "patch": "@@ -33,6 +33,7 @@ mod iter_nth_zero;\n mod iter_skip_next;\n mod iterator_step_by_zero;\n mod manual_saturating_arithmetic;\n+mod manual_split_once;\n mod manual_str_repeat;\n mod map_collect_result_unit;\n mod map_flatten;\n@@ -64,6 +65,7 @@ mod wrong_self_convention;\n mod zst_offset;\n \n use bind_instead_of_map::BindInsteadOfMap;\n+use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::ty::{contains_adt_constructor, contains_ty, implements_trait, is_copy, is_type_diagnostic_item};\n use clippy_utils::{contains_return, get_trait_def_id, in_macro, iter_input_pats, meets_msrv, msrvs, paths, return_ty};\n@@ -1771,6 +1773,31 @@ declare_clippy_lint! {\n     \"manual implementation of `str::repeat`\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usages of `splitn(2, _)`\n+    ///\n+    /// **Why is this bad?** `split_once` is clearer.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// let some_str = \"name=value\";\n+    /// let mut iter = some_str.splitn(2, '=');\n+    /// let name = iter.next().unwrap();\n+    /// let value = iter.next().unwrap_or(\"\");\n+    ///\n+    /// // Good\n+    /// let some_str = \"name=value\";\n+    /// let (name, value) = some_str.split_once('=').unwrap_or((some_str, \"\"));\n+    /// ```\n+    pub MANUAL_SPLIT_ONCE,\n+    complexity,\n+    \"replace `.splitn(2, pat)` with `.split_once(pat)`\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n@@ -1848,7 +1875,8 @@ impl_lint_pass!(Methods => [\n     IMPLICIT_CLONE,\n     SUSPICIOUS_SPLITN,\n     MANUAL_STR_REPEAT,\n-    EXTEND_WITH_DRAIN\n+    EXTEND_WITH_DRAIN,\n+    MANUAL_SPLIT_ONCE\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -2176,8 +2204,18 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                     unnecessary_lazy_eval::check(cx, expr, recv, arg, \"or\");\n                 }\n             },\n-            (\"splitn\" | \"splitn_mut\" | \"rsplitn\" | \"rsplitn_mut\", [count_arg, _]) => {\n-                suspicious_splitn::check(cx, name, expr, recv, count_arg);\n+            (\"splitn\" | \"rsplitn\", [count_arg, pat_arg]) => {\n+                if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n+                    suspicious_splitn::check(cx, name, expr, recv, count);\n+                    if count == 2 && meets_msrv(msrv, &msrvs::STR_SPLIT_ONCE) {\n+                        manual_split_once::check(cx, name, expr, recv, pat_arg);\n+                    }\n+                }\n+            },\n+            (\"splitn_mut\" | \"rsplitn_mut\", [count_arg, _]) => {\n+                if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n+                    suspicious_splitn::check(cx, name, expr, recv, count);\n+                }\n             },\n             (\"step_by\", [arg]) => iterator_step_by_zero::check(cx, expr, arg),\n             (\"to_os_string\" | \"to_owned\" | \"to_path_buf\" | \"to_vec\", []) => {"}, {"sha": "1c546a15bf62b331a5993e378aee11e7c832dc72", "filename": "clippy_lints/src/methods/suspicious_splitn.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs?ref=a7f376fbd3f30b58ec2bde5538b446eb4c2d615e", "patch": "@@ -1,4 +1,3 @@\n-use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_note;\n use if_chain::if_chain;\n use rustc_ast::LitKind;\n@@ -8,25 +7,18 @@ use rustc_span::source_map::Spanned;\n \n use super::SUSPICIOUS_SPLITN;\n \n-pub(super) fn check(\n-    cx: &LateContext<'_>,\n-    method_name: &str,\n-    expr: &Expr<'_>,\n-    self_arg: &Expr<'_>,\n-    count_arg: &Expr<'_>,\n-) {\n+pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, self_arg: &Expr<'_>, count: u128) {\n     if_chain! {\n-        if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg);\n         if count <= 1;\n         if let Some(call_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if let Some(impl_id) = cx.tcx.impl_of_method(call_id);\n         let lang_items = cx.tcx.lang_items();\n         if lang_items.slice_impl() == Some(impl_id) || lang_items.str_impl() == Some(impl_id);\n         then {\n             // Ignore empty slice and string literals when used with a literal count.\n-            if (matches!(self_arg.kind, ExprKind::Array([]))\n+            if matches!(self_arg.kind, ExprKind::Array([]))\n                 || matches!(self_arg.kind, ExprKind::Lit(Spanned { node: LitKind::Str(s, _), .. }) if s.is_empty())\n-            ) && matches!(count_arg.kind, ExprKind::Lit(_))\n+\n             {\n                 return;\n             }"}, {"sha": "211ffdeca2000e53d749507206e8e960464f9cef", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=a7f376fbd3f30b58ec2bde5538b446eb4c2d615e", "patch": "@@ -136,7 +136,7 @@ define_Conf! {\n     ///\n     /// Suppress lints whenever the suggested change would cause breakage for other crates.\n     (avoid_breaking_exported_api: bool = true),\n-    /// Lint: MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE.\n+    /// Lint: MANUAL_SPLIT_ONCE, MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE.\n     ///\n     /// The minimum rust version that the project supports\n     (msrv: Option<String> = None),"}, {"sha": "9302e5c21faa4f7606d485726bcbf256aba1cfb8", "filename": "clippy_utils/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/clippy_utils%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/clippy_utils%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fdiagnostics.rs?ref=a7f376fbd3f30b58ec2bde5538b446eb4c2d615e", "patch": "@@ -21,7 +21,7 @@ fn docs_link(diag: &mut DiagnosticBuilder<'_>, lint: &'static Lint) {\n                 \"for further information visit https://rust-lang.github.io/rust-clippy/{}/index.html#{}\",\n                 &option_env!(\"RUST_RELEASE_NUM\").map_or(\"master\".to_string(), |n| {\n                     // extract just major + minor version and ignore patch versions\n-                    format!(\"rust-{}\", n.rsplitn(2, '.').nth(1).unwrap())\n+                    format!(\"rust-{}\", n.rsplit_once('.').unwrap().1)\n                 }),\n                 lint\n             ));"}, {"sha": "14234d9c9cbf0d6ce4384f7ae8b97a9294afc387", "filename": "clippy_utils/src/msrvs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/clippy_utils%2Fsrc%2Fmsrvs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/clippy_utils%2Fsrc%2Fmsrvs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmsrvs.rs?ref=a7f376fbd3f30b58ec2bde5538b446eb4c2d615e", "patch": "@@ -13,6 +13,7 @@ macro_rules! msrv_aliases {\n // names may refer to stabilized feature flags or library items\n msrv_aliases! {\n     1,53,0 { OR_PATTERNS }\n+    1,52,0 { STR_SPLIT_ONCE }\n     1,50,0 { BOOL_THEN }\n     1,46,0 { CONST_IF_MATCH }\n     1,45,0 { STR_STRIP_PREFIX }"}, {"sha": "d7e46c2d3eb9d2826966f19fc3d8f98b058a150d", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=a7f376fbd3f30b58ec2bde5538b446eb4c2d615e", "patch": "@@ -68,6 +68,7 @@ pub const IO_WRITE: [&str; 3] = [\"std\", \"io\", \"Write\"];\n pub const IPADDR_V4: [&str; 5] = [\"std\", \"net\", \"ip\", \"IpAddr\", \"V4\"];\n pub const IPADDR_V6: [&str; 5] = [\"std\", \"net\", \"ip\", \"IpAddr\", \"V6\"];\n pub const ITER_REPEAT: [&str; 5] = [\"core\", \"iter\", \"sources\", \"repeat\", \"repeat\"];\n+pub const ITERTOOLS_NEXT_TUPLE: [&str; 3] = [\"itertools\", \"Itertools\", \"next_tuple\"];\n #[cfg(feature = \"internal-lints\")]\n pub const KW_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"kw\"];\n #[cfg(feature = \"internal-lints\")]"}, {"sha": "503effbdad5725069eb4ddc268a08c80ae7b9014", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=a7f376fbd3f30b58ec2bde5538b446eb4c2d615e", "patch": "@@ -147,22 +147,23 @@ macro_rules! visitable_ref {\n             }\n         }\n     };\n-    ([$t:ident], $f:ident) => {\n-        impl Visitable<'tcx> for &'tcx [$t<'tcx>] {\n-            fn visit<V: Visitor<'tcx>>(self, visitor: &mut V) {\n-                for x in self {\n-                    visitor.$f(x);\n-                }\n-            }\n-        }\n-    };\n }\n visitable_ref!(Arm, visit_arm);\n visitable_ref!(Block, visit_block);\n visitable_ref!(Body, visit_body);\n visitable_ref!(Expr, visit_expr);\n visitable_ref!(Stmt, visit_stmt);\n-visitable_ref!([Stmt], visit_stmt);\n+\n+// impl<'tcx, I: IntoIterator> Visitable<'tcx> for I\n+// where\n+//     I::Item: Visitable<'tcx>,\n+// {\n+//     fn visit<V: Visitor<'tcx>>(self, visitor: &mut V) {\n+//         for x in self {\n+//             x.visit(visitor);\n+//         }\n+//     }\n+// }\n \n /// Calls the given function for each break expression.\n pub fn visit_break_exprs<'tcx>("}, {"sha": "6116acffe07f4a4db75c12de2600a2f7547e8587", "filename": "tests/compile-test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=a7f376fbd3f30b58ec2bde5538b446eb4c2d615e", "patch": "@@ -39,6 +39,7 @@ fn third_party_crates() -> String {\n         \"clippy_lints\",\n         \"clippy_utils\",\n         \"if_chain\",\n+        \"itertools\",\n         \"quote\",\n         \"regex\",\n         \"serde\","}, {"sha": "3a0332939d409a8237572e97d489bce948b44817", "filename": "tests/ui/manual_split_once.fixed", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/tests%2Fui%2Fmanual_split_once.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/tests%2Fui%2Fmanual_split_once.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.fixed?ref=a7f376fbd3f30b58ec2bde5538b446eb4c2d615e", "patch": "@@ -0,0 +1,50 @@\n+// run-rustfix\n+\n+#![feature(custom_inner_attributes)]\n+#![warn(clippy::manual_split_once)]\n+#![allow(clippy::iter_skip_next, clippy::iter_nth_zero)]\n+\n+extern crate itertools;\n+\n+#[allow(unused_imports)]\n+use itertools::Itertools;\n+\n+fn main() {\n+    let _ = Some(\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0));\n+    let _ = \"key=value\".splitn(2, '=').nth(2);\n+    let _ = \"key=value\".split_once('=').map_or(\"key=value\", |x| x.0);\n+    let _ = \"key=value\".split_once('=').map_or(\"key=value\", |x| x.0);\n+    let _ = \"key=value\".split_once('=').unwrap().1;\n+    let _ = \"key=value\".split_once('=').unwrap().1;\n+    let (_, _) = \"key=value\".split_once('=').unwrap();\n+\n+    let s = String::from(\"key=value\");\n+    let _ = s.split_once('=').map_or(&*s, |x| x.0);\n+\n+    let s = Box::<str>::from(\"key=value\");\n+    let _ = s.split_once('=').map_or(&*s, |x| x.0);\n+\n+    let s = &\"key=value\";\n+    let _ = s.split_once('=').map_or(*s, |x| x.0);\n+\n+    fn _f(s: &str) -> Option<&str> {\n+        let _ = s.split_once(\"key=value\").map_or(s, |x| x.0);\n+        let _ = s.split_once(\"key=value\")?.1;\n+        let _ = s.split_once(\"key=value\")?.1;\n+        None\n+    }\n+\n+    // Don't lint, slices don't have `split_once`\n+    let _ = [0, 1, 2].splitn(2, |&x| x == 1).nth(1).unwrap();\n+}\n+\n+fn _msrv_1_51() {\n+    #![clippy::msrv = \"1.51\"]\n+    // `str::split_once` was stabilized in 1.16. Do not lint this\n+    let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+}\n+\n+fn _msrv_1_52() {\n+    #![clippy::msrv = \"1.52\"]\n+    let _ = \"key=value\".split_once('=').unwrap().1;\n+}"}, {"sha": "e6093b63fe8d428e348760d6a496a3ae4d433090", "filename": "tests/ui/manual_split_once.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/tests%2Fui%2Fmanual_split_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/tests%2Fui%2Fmanual_split_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.rs?ref=a7f376fbd3f30b58ec2bde5538b446eb4c2d615e", "patch": "@@ -0,0 +1,50 @@\n+// run-rustfix\n+\n+#![feature(custom_inner_attributes)]\n+#![warn(clippy::manual_split_once)]\n+#![allow(clippy::iter_skip_next, clippy::iter_nth_zero)]\n+\n+extern crate itertools;\n+\n+#[allow(unused_imports)]\n+use itertools::Itertools;\n+\n+fn main() {\n+    let _ = \"key=value\".splitn(2, '=').next();\n+    let _ = \"key=value\".splitn(2, '=').nth(2);\n+    let _ = \"key=value\".splitn(2, '=').next().unwrap();\n+    let _ = \"key=value\".splitn(2, '=').nth(0).unwrap();\n+    let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+    let _ = \"key=value\".splitn(2, '=').skip(1).next().unwrap();\n+    let (_, _) = \"key=value\".splitn(2, '=').next_tuple().unwrap();\n+\n+    let s = String::from(\"key=value\");\n+    let _ = s.splitn(2, '=').next().unwrap();\n+\n+    let s = Box::<str>::from(\"key=value\");\n+    let _ = s.splitn(2, '=').nth(0).unwrap();\n+\n+    let s = &\"key=value\";\n+    let _ = s.splitn(2, '=').skip(0).next().unwrap();\n+\n+    fn _f(s: &str) -> Option<&str> {\n+        let _ = s.splitn(2, \"key=value\").next()?;\n+        let _ = s.splitn(2, \"key=value\").nth(1)?;\n+        let _ = s.splitn(2, \"key=value\").skip(1).next()?;\n+        None\n+    }\n+\n+    // Don't lint, slices don't have `split_once`\n+    let _ = [0, 1, 2].splitn(2, |&x| x == 1).nth(1).unwrap();\n+}\n+\n+fn _msrv_1_51() {\n+    #![clippy::msrv = \"1.51\"]\n+    // `str::split_once` was stabilized in 1.16. Do not lint this\n+    let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+}\n+\n+fn _msrv_1_52() {\n+    #![clippy::msrv = \"1.52\"]\n+    let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+}"}, {"sha": "4f15196b469e1f73d713f527edca2c57b22af889", "filename": "tests/ui/manual_split_once.stderr", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/tests%2Fui%2Fmanual_split_once.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a7f376fbd3f30b58ec2bde5538b446eb4c2d615e/tests%2Fui%2Fmanual_split_once.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.stderr?ref=a7f376fbd3f30b58ec2bde5538b446eb4c2d615e", "patch": "@@ -0,0 +1,82 @@\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:13:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').next();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `Some(\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0))`\n+   |\n+   = note: `-D clippy::manual-split-once` implied by `-D warnings`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:15:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').next().unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:16:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').nth(0).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:17:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:18:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').skip(1).next().unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:19:18\n+   |\n+LL |     let (_, _) = \"key=value\".splitn(2, '=').next_tuple().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=')`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:22:13\n+   |\n+LL |     let _ = s.splitn(2, '=').next().unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').map_or(&*s, |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:25:13\n+   |\n+LL |     let _ = s.splitn(2, '=').nth(0).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').map_or(&*s, |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:28:13\n+   |\n+LL |     let _ = s.splitn(2, '=').skip(0).next().unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').map_or(*s, |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:31:17\n+   |\n+LL |         let _ = s.splitn(2, \"key=value\").next()?;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once(\"key=value\").map_or(s, |x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:32:17\n+   |\n+LL |         let _ = s.splitn(2, \"key=value\").nth(1)?;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once(\"key=value\")?.1`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:33:17\n+   |\n+LL |         let _ = s.splitn(2, \"key=value\").skip(1).next()?;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once(\"key=value\")?.1`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:49:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n+\n+error: aborting due to 13 previous errors\n+"}]}