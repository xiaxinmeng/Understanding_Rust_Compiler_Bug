{"sha": "2a50d127ddc8a40c526d3409159a328517a6ff84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhNTBkMTI3ZGRjOGE0MGM1MjZkMzQwOTE1OWEzMjg1MTdhNmZmODQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-09-22T11:03:15Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-09-23T17:47:37Z"}, "message": "incr.comp.: Remove support for loading metadata fingerprints.", "tree": {"sha": "a6754404610a0d2b9a7abdef73f2fd3da5eb71e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6754404610a0d2b9a7abdef73f2fd3da5eb71e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a50d127ddc8a40c526d3409159a328517a6ff84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a50d127ddc8a40c526d3409159a328517a6ff84", "html_url": "https://github.com/rust-lang/rust/commit/2a50d127ddc8a40c526d3409159a328517a6ff84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a50d127ddc8a40c526d3409159a328517a6ff84/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5974ec745e97af456e50a04473e468db9007bd07", "url": "https://api.github.com/repos/rust-lang/rust/commits/5974ec745e97af456e50a04473e468db9007bd07", "html_url": "https://github.com/rust-lang/rust/commit/5974ec745e97af456e50a04473e468db9007bd07"}], "stats": {"total": 413, "additions": 105, "deletions": 308}, "files": [{"sha": "b492caf10bb0df97217dd0e33de39aedee33df00", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=2a50d127ddc8a40c526d3409159a328517a6ff84", "patch": "@@ -60,7 +60,7 @@\n //! user of the `DepNode` API of having to know how to compute the expected\n //! fingerprint for a given set of node parameters.\n \n-use hir::def_id::{CrateNum, DefId, DefIndex};\n+use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n use hir::map::DefPathHash;\n use hir::{HirId, ItemLocalId};\n \n@@ -420,7 +420,7 @@ define_dep_nodes!( <'tcx>\n     [input] Hir(DefId),\n \n     // Represents metadata from an extern crate.\n-    [input] MetaData(DefId),\n+    [input] CrateMetadata(CrateNum),\n \n     // Represents some artifact that we save to disk. Note that these\n     // do not have a def-id as part of their identifier.\n@@ -678,6 +678,22 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefIndex,\n     }\n }\n \n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (CrateNum,) {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n+\n+    fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n+        let def_id = DefId {\n+            krate: self.0,\n+            index: CRATE_DEF_INDEX,\n+        };\n+        tcx.def_path_hash(def_id).0\n+    }\n+\n+    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+        tcx.crate_name(self.0).as_str().to_string()\n+    }\n+}\n+\n impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId, DefId) {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n "}, {"sha": "a97bfa0536987398acae30741c2738ccb3ccbb3d", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=2a50d127ddc8a40c526d3409159a328517a6ff84", "patch": "@@ -267,6 +267,8 @@ pub trait CrateStore {\n     fn export_macros_untracked(&self, cnum: CrateNum);\n     fn dep_kind_untracked(&self, cnum: CrateNum) -> DepKind;\n     fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol;\n+    fn crate_disambiguator_untracked(&self, cnum: CrateNum) -> Symbol;\n+    fn crate_hash_untracked(&self, cnum: CrateNum) -> Svh;\n     fn struct_field_names_untracked(&self, def: DefId) -> Vec<ast::Name>;\n     fn item_children_untracked(&self, did: DefId, sess: &Session) -> Vec<def::Export>;\n     fn load_macro_untracked(&self, did: DefId, sess: &Session) -> LoadedMacro;\n@@ -336,6 +338,10 @@ impl CrateStore for DummyCrateStore {\n     fn dep_kind_untracked(&self, cnum: CrateNum) -> DepKind { bug!(\"is_explicitly_linked\") }\n     fn export_macros_untracked(&self, cnum: CrateNum) { bug!(\"export_macros\") }\n     fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol { bug!(\"crate_name\") }\n+    fn crate_disambiguator_untracked(&self, cnum: CrateNum) -> Symbol {\n+        bug!(\"crate_disambiguator\")\n+    }\n+    fn crate_hash_untracked(&self, cnum: CrateNum) -> Svh { bug!(\"crate_hash\") }\n \n     // resolve\n     fn def_key(&self, def: DefId) -> DefKey { bug!(\"def_key\") }"}, {"sha": "d3256357941f35912a729e08329c919556bbab8b", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=2a50d127ddc8a40c526d3409159a328517a6ff84", "patch": "@@ -1021,7 +1021,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"attempt to recover from parse errors (experimental)\"),\n     incremental: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"enable incremental compilation (experimental)\"),\n-    incremental_cc: bool = (true, parse_bool, [UNTRACKED],\n+    incremental_cc: bool = (false, parse_bool, [UNTRACKED],\n           \"enable cross-crate incremental compilation (even more experimental)\"),\n     incremental_info: bool = (false, parse_bool, [UNTRACKED],\n         \"print high-level information about incremental reuse (or the lack thereof)\"),"}, {"sha": "054c5e122df7a6c00f5629a0f7b1bc4aac6b6894", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=2a50d127ddc8a40c526d3409159a328517a6ff84", "patch": "@@ -11,6 +11,7 @@\n //! type context book-keeping\n \n use dep_graph::DepGraph;\n+use dep_graph::{DepNode, DepConstructor};\n use errors::DiagnosticBuilder;\n use session::Session;\n use session::config::OutputFilenames;\n@@ -1237,6 +1238,25 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                   self.cstore)\n     }\n \n+    // This method makes sure that we have a DepNode and a Fingerprint for\n+    // every upstream crate. It needs to be called once right after the tcx is\n+    // created.\n+    // With full-fledged red/green, the method will probably become unnecessary\n+    // as this will be done on-demand.\n+    pub fn allocate_metadata_dep_nodes(self) {\n+        // We cannot use the query versions of crates() and crate_hash(), since\n+        // those would need the DepNodes that we are allocating here.\n+        for cnum in self.cstore.crates_untracked() {\n+            let dep_node = DepNode::new(self, DepConstructor::CrateMetadata(cnum));\n+            let crate_hash = self.cstore.crate_hash_untracked(cnum);\n+            self.dep_graph.with_task(dep_node,\n+                                     self,\n+                                     crate_hash,\n+                                     |_, x| x // No transformation needed\n+            );\n+        }\n+    }\n+\n     // This method exercises the `in_scope_traits_map` query for all possible\n     // values so that we have their fingerprints available in the DepGraph.\n     // This is only required as long as we still use the old dependency tracking"}, {"sha": "8d729e5e05279c9e340f1095b5057d5d997c9dbf", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=2a50d127ddc8a40c526d3409159a328517a6ff84", "patch": "@@ -114,15 +114,12 @@\n //! unsupported file system and emit a warning in that case. This is not yet\n //! implemented.\n \n-use rustc::hir::def_id::CrateNum;\n use rustc::hir::svh::Svh;\n use rustc::session::Session;\n-use rustc::ty::TyCtxt;\n use rustc::util::fs as fs_util;\n use rustc_data_structures::{flock, base_n};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n-use std::ffi::OsString;\n use std::fs as std_fs;\n use std::io;\n use std::mem;\n@@ -158,10 +155,6 @@ pub fn metadata_hash_export_path(sess: &Session) -> PathBuf {\n     in_incr_comp_dir_sess(sess, METADATA_HASHES_FILENAME)\n }\n \n-pub fn metadata_hash_import_path(import_session_dir: &Path) -> PathBuf {\n-    import_session_dir.join(METADATA_HASHES_FILENAME)\n-}\n-\n pub fn lock_file_path(session_dir: &Path) -> PathBuf {\n     let crate_dir = session_dir.parent().unwrap();\n \n@@ -621,70 +614,6 @@ fn string_to_timestamp(s: &str) -> Result<SystemTime, ()> {\n     Ok(UNIX_EPOCH + duration)\n }\n \n-fn crate_path_tcx(tcx: TyCtxt, cnum: CrateNum) -> PathBuf {\n-    crate_path(tcx.sess, &tcx.crate_name(cnum).as_str(), &tcx.crate_disambiguator(cnum).as_str())\n-}\n-\n-/// Finds the session directory containing the correct metadata hashes file for\n-/// the given crate. In order to do that it has to compute the crate directory\n-/// of the given crate, and in there, look for the session directory with the\n-/// correct SVH in it.\n-/// Note that we have to match on the exact SVH here, not just the\n-/// crate's (name, disambiguator) pair. The metadata hashes are only valid for\n-/// the exact version of the binary we are reading from now (i.e. the hashes\n-/// are part of the dependency graph of a specific compilation session).\n-pub fn find_metadata_hashes_for(tcx: TyCtxt, cnum: CrateNum) -> Option<PathBuf> {\n-    let crate_directory = crate_path_tcx(tcx, cnum);\n-\n-    if !crate_directory.exists() {\n-        return None\n-    }\n-\n-    let dir_entries = match crate_directory.read_dir() {\n-        Ok(dir_entries) => dir_entries,\n-        Err(e) => {\n-            tcx.sess\n-               .err(&format!(\"incremental compilation: Could not read crate directory `{}`: {}\",\n-                             crate_directory.display(), e));\n-            return None\n-        }\n-    };\n-\n-    let target_svh = tcx.crate_hash(cnum);\n-    let target_svh = base_n::encode(target_svh.as_u64(), INT_ENCODE_BASE);\n-\n-    let sub_dir = find_metadata_hashes_iter(&target_svh, dir_entries.filter_map(|e| {\n-        e.ok().map(|e| e.file_name().to_string_lossy().into_owned())\n-    }));\n-\n-    sub_dir.map(|sub_dir_name| crate_directory.join(&sub_dir_name))\n-}\n-\n-fn find_metadata_hashes_iter<'a, I>(target_svh: &str, iter: I) -> Option<OsString>\n-    where I: Iterator<Item=String>\n-{\n-    for sub_dir_name in iter {\n-        if !is_session_directory(&sub_dir_name) || !is_finalized(&sub_dir_name) {\n-            // This is not a usable session directory\n-            continue\n-        }\n-\n-        let is_match = if let Some(last_dash_pos) = sub_dir_name.rfind(\"-\") {\n-            let candidate_svh = &sub_dir_name[last_dash_pos + 1 .. ];\n-            target_svh == candidate_svh\n-        } else {\n-            // some kind of invalid directory name\n-            continue\n-        };\n-\n-        if is_match {\n-            return Some(OsString::from(sub_dir_name))\n-        }\n-    }\n-\n-    None\n-}\n-\n fn crate_path(sess: &Session,\n               crate_name: &str,\n               crate_disambiguator: &str)"}, {"sha": "f7ea0a07f3df25321ad0b8159642f05ee197d19f", "filename": "src/librustc_incremental/persist/hash.rs", "status": "removed", "additions": 0, "deletions": 202, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5974ec745e97af456e50a04473e468db9007bd07/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=5974ec745e97af456e50a04473e468db9007bd07", "patch": "@@ -1,202 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::dep_graph::{DepNode, DepKind};\n-use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use rustc::hir::svh::Svh;\n-use rustc::ich::Fingerprint;\n-use rustc::ty::TyCtxt;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::flock;\n-use rustc_serialize::Decodable;\n-use rustc_serialize::opaque::Decoder;\n-\n-use super::data::*;\n-use super::fs::*;\n-use super::file_format;\n-\n-use std::hash::Hash;\n-use std::fmt::Debug;\n-\n-pub struct HashContext<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    metadata_hashes: FxHashMap<DefId, Fingerprint>,\n-    crate_hashes: FxHashMap<CrateNum, Svh>,\n-}\n-\n-impl<'a, 'tcx> HashContext<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n-        HashContext {\n-            tcx,\n-            metadata_hashes: FxHashMap(),\n-            crate_hashes: FxHashMap(),\n-        }\n-    }\n-\n-    pub fn hash(&mut self, dep_node: &DepNode) -> Option<Fingerprint> {\n-        match dep_node.kind {\n-            // HIR nodes (which always come from our crate) are an input:\n-            DepKind::Krate |\n-            DepKind::InScopeTraits |\n-            DepKind::Hir |\n-            DepKind::HirBody => {\n-                Some(self.tcx.dep_graph.fingerprint_of(dep_node).unwrap())\n-            }\n-\n-            // MetaData from other crates is an *input* to us.\n-            // MetaData nodes from *our* crates are an *output*; we\n-            // don't hash them, but we do compute a hash for them and\n-            // save it for others to use.\n-            DepKind::MetaData => {\n-                let def_id = dep_node.extract_def_id(self.tcx).unwrap();\n-                assert!(!def_id.is_local());\n-\n-                Some(self.metadata_hash(def_id,\n-                                        def_id.krate,\n-                                        |this| &mut this.metadata_hashes))\n-            }\n-\n-            _ => {\n-                // Other kinds of nodes represent computed by-products\n-                // that we don't hash directly; instead, they should\n-                // have some transitive dependency on a Hir or\n-                // MetaData node, so we'll just hash that\n-                None\n-            }\n-        }\n-    }\n-\n-    fn metadata_hash<K, C>(&mut self,\n-                           key: K,\n-                           cnum: CrateNum,\n-                           cache: C)\n-                           -> Fingerprint\n-        where K: Hash + Eq + Debug,\n-              C: Fn(&mut Self) -> &mut FxHashMap<K, Fingerprint>,\n-    {\n-        debug!(\"metadata_hash(key={:?})\", key);\n-\n-        debug_assert!(cnum != LOCAL_CRATE);\n-        loop {\n-            // check whether we have a result cached for this def-id\n-            if let Some(&hash) = cache(self).get(&key) {\n-                return hash;\n-            }\n-\n-            // check whether we did not find detailed metadata for this\n-            // krate; in that case, we just use the krate's overall hash\n-            if let Some(&svh) = self.crate_hashes.get(&cnum) {\n-                // micro-\"optimization\": avoid a cache miss if we ask\n-                // for metadata from this particular def-id again.\n-                let fingerprint = svh_to_fingerprint(svh);\n-                cache(self).insert(key, fingerprint);\n-\n-                return fingerprint;\n-            }\n-\n-            // otherwise, load the data and repeat.\n-            self.load_data(cnum);\n-            assert!(self.crate_hashes.contains_key(&cnum));\n-        }\n-    }\n-\n-    fn load_data(&mut self, cnum: CrateNum) {\n-        debug!(\"load_data(cnum={})\", cnum);\n-\n-        let svh = self.tcx.crate_hash(cnum);\n-        let old = self.crate_hashes.insert(cnum, svh);\n-        debug!(\"load_data: svh={}\", svh);\n-        assert!(old.is_none(), \"loaded data for crate {:?} twice\", cnum);\n-\n-        if let Some(session_dir) = find_metadata_hashes_for(self.tcx, cnum) {\n-            debug!(\"load_data: session_dir={:?}\", session_dir);\n-\n-            // Lock the directory we'll be reading  the hashes from.\n-            let lock_file_path = lock_file_path(&session_dir);\n-            let _lock = match flock::Lock::new(&lock_file_path,\n-                                               false,   // don't wait\n-                                               false,   // don't create the lock-file\n-                                               false) { // shared lock\n-                Ok(lock) => lock,\n-                Err(err) => {\n-                    debug!(\"Could not acquire lock on `{}` while trying to \\\n-                            load metadata hashes: {}\",\n-                            lock_file_path.display(),\n-                            err);\n-\n-                    // Could not acquire the lock. The directory is probably in\n-                    // in the process of being deleted. It's OK to just exit\n-                    // here. It's the same scenario as if the file had not\n-                    // existed in the first place.\n-                    return\n-                }\n-            };\n-\n-            let hashes_file_path = metadata_hash_import_path(&session_dir);\n-\n-            match file_format::read_file(self.tcx.sess, &hashes_file_path)\n-            {\n-                Ok(Some(data)) => {\n-                    match self.load_from_data(cnum, &data, svh) {\n-                        Ok(()) => { }\n-                        Err(err) => {\n-                            bug!(\"decoding error in dep-graph from `{}`: {}\",\n-                                 &hashes_file_path.display(), err);\n-                        }\n-                    }\n-                }\n-                Ok(None) => {\n-                    // If the file is not found, that's ok.\n-                }\n-                Err(err) => {\n-                    self.tcx.sess.err(\n-                        &format!(\"could not load dep information from `{}`: {}\",\n-                                 hashes_file_path.display(), err));\n-                }\n-            }\n-        }\n-    }\n-\n-    fn load_from_data(&mut self,\n-                      cnum: CrateNum,\n-                      data: &[u8],\n-                      expected_svh: Svh) -> Result<(), String> {\n-        debug!(\"load_from_data(cnum={})\", cnum);\n-\n-        // Load up the hashes for the def-ids from this crate.\n-        let mut decoder = Decoder::new(data, 0);\n-        let svh_in_hashes_file = Svh::decode(&mut decoder)?;\n-\n-        if svh_in_hashes_file != expected_svh {\n-            // We should not be able to get here. If we do, then\n-            // `fs::find_metadata_hashes_for()` has messed up.\n-            bug!(\"mismatch between SVH in crate and SVH in incr. comp. hashes\")\n-        }\n-\n-        let serialized_hashes = SerializedMetadataHashes::decode(&mut decoder)?;\n-        for serialized_hash in serialized_hashes.entry_hashes {\n-            // the hashes are stored with just a def-index, which is\n-            // always relative to the old crate; convert that to use\n-            // our internal crate number\n-            let def_id = DefId { krate: cnum, index: serialized_hash.def_index };\n-\n-            // record the hash for this dep-node\n-            let old = self.metadata_hashes.insert(def_id, serialized_hash.hash);\n-            debug!(\"load_from_data: def_id={:?} hash={}\", def_id, serialized_hash.hash);\n-            assert!(old.is_none(), \"already have hash for {:?}\", def_id);\n-        }\n-\n-        Ok(())\n-    }\n-}\n-\n-fn svh_to_fingerprint(svh: Svh) -> Fingerprint {\n-    Fingerprint::from_smaller_hash(svh.as_u64())\n-}"}, {"sha": "28d05a897c8c944a7aa820b6714a298f4b0a11d7", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=2a50d127ddc8a40c526d3409159a328517a6ff84", "patch": "@@ -10,7 +10,7 @@\n \n //! Code to save/load the dep-graph from files.\n \n-use rustc::dep_graph::{DepNode, WorkProductId, DepKind};\n+use rustc::dep_graph::{DepNode, WorkProductId, DepKind, PreviousDepGraph};\n use rustc::hir::svh::Svh;\n use rustc::ich::Fingerprint;\n use rustc::session::Session;\n@@ -24,7 +24,6 @@ use std::path::{Path};\n \n use super::data::*;\n use super::dirty_clean;\n-use super::hash::*;\n use super::fs::*;\n use super::file_format;\n use super::work_product;\n@@ -40,6 +39,7 @@ pub type DirtyNodes = FxHashMap<DepNodeIndex, DepNodeIndex>;\n /// actually it doesn't matter all that much.) See `README.md` for\n /// more general overview.\n pub fn load_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    tcx.allocate_metadata_dep_nodes();\n     tcx.precompute_in_scope_traits_hashes();\n     if tcx.sess.incr_session_load_dep_graph() {\n         let _ignore = tcx.dep_graph.in_ignore();\n@@ -103,7 +103,7 @@ fn does_still_exist(tcx: TyCtxt, dep_node: &DepNode) -> bool {\n         DepKind::Hir |\n         DepKind::HirBody |\n         DepKind::InScopeTraits |\n-        DepKind::MetaData => {\n+        DepKind::CrateMetadata => {\n             dep_node.extract_def_id(tcx).is_some()\n         }\n         _ => {\n@@ -198,15 +198,12 @@ fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  nodes: &IndexVec<DepNodeIndex, DepNode>,\n                                  serialized_hashes: &[(DepNodeIndex, Fingerprint)])\n                                  -> DirtyNodes {\n-    let mut hcx = HashContext::new(tcx);\n     let mut dirty_nodes = FxHashMap();\n \n     for &(dep_node_index, prev_hash) in serialized_hashes {\n         let dep_node = nodes[dep_node_index];\n         if does_still_exist(tcx, &dep_node) {\n-            let current_hash = hcx.hash(&dep_node).unwrap_or_else(|| {\n-                bug!(\"Cannot find current ICH for input that still exists?\")\n-            });\n+            let current_hash = tcx.dep_graph.fingerprint_of(&dep_node);\n \n             if current_hash == prev_hash {\n                 debug!(\"initial_dirty_nodes: {:?} is clean (hash={:?})\",\n@@ -416,7 +413,7 @@ fn process_edge<'a, 'tcx, 'edges>(\n     // clean target because removing the input would have dirtied the input\n     // node and transitively dirtied the target.\n     debug_assert!(match nodes[source].kind {\n-        DepKind::Hir | DepKind::HirBody | DepKind::MetaData => {\n+        DepKind::Hir | DepKind::HirBody | DepKind::CrateMetadata => {\n             does_still_exist(tcx, &nodes[source])\n         }\n         _ => true,"}, {"sha": "688d8add57e3fd49f38dc67ebe317f3433ccd2f1", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=2a50d127ddc8a40c526d3409159a328517a6ff84", "patch": "@@ -15,7 +15,6 @@\n mod data;\n mod dirty_clean;\n mod fs;\n-mod hash;\n mod load;\n mod preds;\n mod save;"}, {"sha": "a552a27c62af0f9eec9356a9a3e1ed88393d4fbf", "filename": "src/librustc_incremental/persist/preds/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs?ref=2a50d127ddc8a40c526d3409159a328517a6ff84", "patch": "@@ -10,10 +10,10 @@\n \n use rustc::dep_graph::{DepGraphQuery, DepNode, DepKind};\n use rustc::ich::Fingerprint;\n+use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph::{Graph, NodeIndex};\n \n-use super::hash::*;\n \n mod compress;\n \n@@ -40,15 +40,13 @@ pub struct Predecessors<'query> {\n }\n \n impl<'q> Predecessors<'q> {\n-    pub fn new(query: &'q DepGraphQuery, hcx: &mut HashContext) -> Self {\n-        let tcx = hcx.tcx;\n-\n+    pub fn new(tcx: TyCtxt, query: &'q DepGraphQuery) -> Self {\n         // Find the set of \"start nodes\". These are nodes that we will\n         // possibly query later.\n         let is_output = |node: &DepNode| -> bool {\n             match node.kind {\n                 DepKind::WorkProduct => true,\n-                DepKind::MetaData => {\n+                DepKind::CrateMetadata => {\n                     // We do *not* create dep-nodes for the current crate's\n                     // metadata anymore, just for metadata that we import/read\n                     // from other crates.\n@@ -74,7 +72,7 @@ impl<'q> Predecessors<'q> {\n             let input = *graph.node_data(input_index);\n             debug!(\"computing hash for input node `{:?}`\", input);\n             hashes.entry(input)\n-                  .or_insert_with(|| hcx.hash(input).unwrap());\n+                  .or_insert_with(|| tcx.dep_graph.fingerprint_of(&input));\n         }\n \n         if tcx.sess.opts.debugging_opts.query_dep_graph {\n@@ -89,7 +87,7 @@ impl<'q> Predecessors<'q> {\n \n             for node in hir_nodes {\n                 hashes.entry(node)\n-                      .or_insert_with(|| hcx.hash(node).unwrap());\n+                      .or_insert_with(|| tcx.dep_graph.fingerprint_of(&node));\n             }\n         }\n "}, {"sha": "c9efd97d47b38f3370488540b29f6c05c456f1ed", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=2a50d127ddc8a40c526d3409159a328517a6ff84", "patch": "@@ -15,6 +15,7 @@ use rustc::ich::Fingerprint;\n use rustc::middle::cstore::EncodedMetadataHashes;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n+use rustc::util::common::time;\n use rustc::util::nodemap::DefIdMap;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph;\n@@ -26,7 +27,6 @@ use std::fs::{self, File};\n use std::path::PathBuf;\n \n use super::data::*;\n-use super::hash::*;\n use super::preds::*;\n use super::fs::*;\n use super::dirty_clean;\n@@ -45,13 +45,6 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return;\n     }\n \n-    let query = tcx.dep_graph.query();\n-\n-    if tcx.sess.opts.debugging_opts.incremental_info {\n-        eprintln!(\"incremental: {} nodes in dep-graph\", query.graph.len_nodes());\n-        eprintln!(\"incremental: {} edges in dep-graph\", query.graph.len_edges());\n-    }\n-\n     // We load the previous metadata hashes now before overwriting the file\n     // (if we need them for testing).\n     let prev_metadata_hashes = if tcx.sess.opts.debugging_opts.query_dep_graph {\n@@ -60,8 +53,6 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         DefIdMap()\n     };\n \n-    let mut hcx = HashContext::new(tcx);\n-    let preds = Predecessors::new(&query, &mut hcx);\n     let mut current_metadata_hashes = FxHashMap();\n \n     // IMPORTANT: We are saving the metadata hashes *before* the dep-graph,\n@@ -78,9 +69,25 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            e));\n     }\n \n-    save_in(sess,\n-            dep_graph_path(sess),\n-            |e| encode_dep_graph(tcx, &preds, e));\n+    time(sess.time_passes(), \"persist dep-graph (old)\", || {\n+        let query = tcx.dep_graph.query();\n+\n+        if tcx.sess.opts.debugging_opts.incremental_info {\n+            eprintln!(\"incremental: {} nodes in dep-graph\", query.graph.len_nodes());\n+            eprintln!(\"incremental: {} edges in dep-graph\", query.graph.len_edges());\n+        }\n+\n+        let preds = Predecessors::new(tcx, &query);\n+        save_in(sess,\n+                dep_graph_path(sess),\n+                |e| encode_dep_graph(tcx, &preds, e));\n+    });\n+\n+    time(sess.time_passes(), \"persist dep-graph (new)\", || {\n+        save_in(sess,\n+                dep_graph_path_new(sess),\n+                |e| encode_dep_graph_new(tcx, e));\n+    });\n \n     dirty_clean::check_dirty_clean_metadata(tcx,\n                                             &prev_metadata_hashes,"}, {"sha": "8eacc21ab003b59e96b6d303ea9671230a4a8edf", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=2a50d127ddc8a40c526d3409159a328517a6ff84", "patch": "@@ -55,9 +55,14 @@ macro_rules! provide {\n                 let ($def_id, $other) = def_id_arg.into_args();\n                 assert!(!$def_id.is_local());\n \n-                let def_path_hash = $tcx.def_path_hash($def_id);\n-                let dep_node = def_path_hash.to_dep_node(::rustc::dep_graph::DepKind::MetaData);\n-\n+                let def_path_hash = $tcx.def_path_hash(DefId {\n+                    krate: $def_id.krate,\n+                    index: CRATE_DEF_INDEX\n+                });\n+                let dep_node = def_path_hash\n+                    .to_dep_node(::rustc::dep_graph::DepKind::CrateMetadata);\n+                // The DepNodeIndex of the DepNode::CrateMetadata should be\n+                // cached somewhere, so that we can use read_index().\n                 $tcx.dep_graph.read(dep_node);\n \n                 let $cdata = $tcx.crate_data_as_rc_any($def_id.krate);\n@@ -379,6 +384,16 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(cnum).name\n     }\n \n+    fn crate_disambiguator_untracked(&self, cnum: CrateNum) -> Symbol\n+    {\n+        self.get_crate_data(cnum).disambiguator()\n+    }\n+\n+    fn crate_hash_untracked(&self, cnum: CrateNum) -> hir::svh::Svh\n+    {\n+        self.get_crate_data(cnum).hash()\n+    }\n+\n     /// Returns the `DefKey` for a given `DefId`. This indicates the\n     /// parent `DefId` as well as some idea of what kind of data the\n     /// `DefId` refers to."}, {"sha": "355983e9ca1b9e53f3a8795d64087732ba458b41", "filename": "src/test/incremental/callee_caller_cross_crate/b.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs?ref=2a50d127ddc8a40c526d3409159a328517a6ff84", "patch": "@@ -12,6 +12,8 @@\n // revisions:rpass1 rpass2\n // compile-flags:-Z query-dep-graph\n \n+// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n+\n #![feature(rustc_attrs)]\n \n extern crate a;"}, {"sha": "d58a9bacdb53ca4c7ed10f500ea7b65257cc8815", "filename": "src/test/incremental/change_private_fn_cc/struct_point.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fstruct_point.rs?ref=2a50d127ddc8a40c526d3409159a328517a6ff84", "patch": "@@ -15,6 +15,8 @@\n // compile-flags: -Z query-dep-graph\n // aux-build:point.rs\n \n+// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n+\n #![feature(rustc_attrs)]\n #![feature(stmt_expr_attributes)]\n #![allow(dead_code)]"}, {"sha": "3f665f5c82052da07458916a2a5231583c5bec64", "filename": "src/test/incremental/change_private_impl_method_cc/struct_point.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs?ref=2a50d127ddc8a40c526d3409159a328517a6ff84", "patch": "@@ -15,6 +15,8 @@\n // compile-flags: -Z query-dep-graph\n // aux-build:point.rs\n \n+// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n+\n #![feature(rustc_attrs)]\n #![feature(stmt_expr_attributes)]\n #![allow(dead_code)]"}, {"sha": "39065d9671ace089b3736c11403e75b6835faf48", "filename": "src/test/incremental/rlib_cross_crate/b.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs?ref=2a50d127ddc8a40c526d3409159a328517a6ff84", "patch": "@@ -18,6 +18,8 @@\n // no-prefer-dynamic\n // compile-flags: -Z query-dep-graph\n \n+// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n+\n #![feature(rustc_attrs)]\n \n extern crate a;"}, {"sha": "e5ec9784847f0b4c5882a04441f0974aed7dda62", "filename": "src/test/incremental/struct_change_field_type_cross_crate/b.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs?ref=2a50d127ddc8a40c526d3409159a328517a6ff84", "patch": "@@ -12,6 +12,8 @@\n // revisions:rpass1 rpass2\n // compile-flags: -Z query-dep-graph\n \n+// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n+\n #![feature(rustc_attrs)]\n \n extern crate a;"}, {"sha": "63e1437f0687be4398da2d6805e111ed77afac69", "filename": "src/test/incremental/type_alias_cross_crate/b.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a50d127ddc8a40c526d3409159a328517a6ff84/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs?ref=2a50d127ddc8a40c526d3409159a328517a6ff84", "patch": "@@ -12,6 +12,8 @@\n // revisions:rpass1 rpass2 rpass3\n // compile-flags: -Z query-dep-graph\n \n+// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n+\n #![feature(rustc_attrs)]\n \n extern crate a;"}]}