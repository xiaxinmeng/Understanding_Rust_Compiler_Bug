{"sha": "37c6f2881c634fe72dc98b846037dc1237270659", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3YzZmMjg4MWM2MzRmZTcyZGM5OGI4NDYwMzdkYzEyMzcyNzA2NTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-22T23:13:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-22T23:13:08Z"}, "message": "Auto merge of #31715 - mitaa:rdoc-index-crate, r=alexcrichton\n\nThis allows to search for crates in documentation and simplifies the json serialization of the search-index.\n\nfixes #14077", "tree": {"sha": "d8235df3712c742cc8d17f345c94f338c92cd4f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8235df3712c742cc8d17f345c94f338c92cd4f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37c6f2881c634fe72dc98b846037dc1237270659", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37c6f2881c634fe72dc98b846037dc1237270659", "html_url": "https://github.com/rust-lang/rust/commit/37c6f2881c634fe72dc98b846037dc1237270659", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37c6f2881c634fe72dc98b846037dc1237270659/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8fc4817dcbf50690aba1fc8bd4db336aff2dbc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8fc4817dcbf50690aba1fc8bd4db336aff2dbc6", "html_url": "https://github.com/rust-lang/rust/commit/c8fc4817dcbf50690aba1fc8bd4db336aff2dbc6"}, {"sha": "81f673d3bc6828acefd548df3f4733f330259c4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/81f673d3bc6828acefd548df3f4733f330259c4c", "html_url": "https://github.com/rust-lang/rust/commit/81f673d3bc6828acefd548df3f4733f330259c4c"}], "stats": {"total": 223, "additions": 112, "deletions": 111}, "files": [{"sha": "692d230446cda7b356b028021237f610c28bb141", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 98, "deletions": 110, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/37c6f2881c634fe72dc98b846037dc1237270659/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37c6f2881c634fe72dc98b846037dc1237270659/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=37c6f2881c634fe72dc98b846037dc1237270659", "patch": "@@ -52,7 +52,7 @@ use std::sync::Arc;\n \n use externalfiles::ExternalHtml;\n \n-use serialize::json::{self, ToJson};\n+use serialize::json::{ToJson, Json, as_json};\n use syntax::{abi, ast};\n use syntax::feature_gate::UnstableFeatures;\n use rustc::middle::cstore::LOCAL_CRATE;\n@@ -290,22 +290,40 @@ struct IndexItem {\n     path: String,\n     desc: String,\n     parent: Option<DefId>,\n+    parent_idx: Option<usize>,\n     search_type: Option<IndexItemFunctionType>,\n }\n \n+impl ToJson for IndexItem {\n+    fn to_json(&self) -> Json {\n+        assert_eq!(self.parent.is_some(), self.parent_idx.is_some());\n+\n+        let mut data = Vec::with_capacity(6);\n+        data.push((self.ty as usize).to_json());\n+        data.push(self.name.to_json());\n+        data.push(self.path.to_json());\n+        data.push(self.desc.to_json());\n+        data.push(self.parent_idx.to_json());\n+        data.push(self.search_type.to_json());\n+\n+        Json::Array(data)\n+    }\n+}\n+\n /// A type used for the search index.\n struct Type {\n     name: Option<String>,\n }\n \n-impl fmt::Display for Type {\n-    /// Formats type as {name: $name}.\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // Wrapping struct fmt should never call us when self.name is None,\n-        // but just to be safe we write `null` in that case.\n+impl ToJson for Type {\n+    fn to_json(&self) -> Json {\n         match self.name {\n-            Some(ref n) => write!(f, \"{{\\\"name\\\":\\\"{}\\\"}}\", n),\n-            None => write!(f, \"null\")\n+            Some(ref name) => {\n+                let mut data = BTreeMap::new();\n+                data.insert(\"name\".to_owned(), name.to_json());\n+                Json::Object(data)\n+            },\n+            None => Json::Null\n         }\n     }\n }\n@@ -316,26 +334,17 @@ struct IndexItemFunctionType {\n     output: Option<Type>\n }\n \n-impl fmt::Display for IndexItemFunctionType {\n-    /// Formats a full fn type as a JSON {inputs: [Type], outputs: Type/null}.\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl ToJson for IndexItemFunctionType {\n+    fn to_json(&self) -> Json {\n         // If we couldn't figure out a type, just write `null`.\n-        if self.inputs.iter().any(|ref i| i.name.is_none()) ||\n-           (self.output.is_some() && self.output.as_ref().unwrap().name.is_none()) {\n-            return write!(f, \"null\")\n+        if self.inputs.iter().chain(self.output.iter()).any(|ref i| i.name.is_none()) {\n+            Json::Null\n+        } else {\n+            let mut data = BTreeMap::new();\n+            data.insert(\"inputs\".to_owned(), self.inputs.to_json());\n+            data.insert(\"output\".to_owned(), self.output.to_json());\n+            Json::Object(data)\n         }\n-\n-        let inputs: Vec<String> = self.inputs.iter().map(|ref t| {\n-            format!(\"{}\", t)\n-        }).collect();\n-        try!(write!(f, \"{{\\\"inputs\\\":[{}],\\\"output\\\":\", inputs.join(\",\")));\n-\n-        match self.output {\n-            Some(ref t) => try!(write!(f, \"{}\", t)),\n-            None => try!(write!(f, \"null\"))\n-        };\n-\n-        Ok(try!(write!(f, \"}}\")))\n     }\n }\n \n@@ -534,101 +543,79 @@ pub fn run(mut krate: clean::Crate,\n     cx.krate(krate)\n }\n \n+/// Build the search index from the collected metadata\n fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n-    // Build the search index from the collected metadata\n     let mut nodeid_to_pathid = HashMap::new();\n-    let mut pathid_to_nodeid = Vec::new();\n-    {\n-        let Cache { ref mut search_index,\n-                    ref orphan_methods,\n-                    ref mut paths, .. } = *cache;\n-\n-        // Attach all orphan methods to the type's definition if the type\n-        // has since been learned.\n-        for &(did, ref item) in orphan_methods {\n-            match paths.get(&did) {\n-                Some(&(ref fqp, _)) => {\n-                    // Needed to determine `self` type.\n-                    let parent_basename = Some(fqp[fqp.len() - 1].clone());\n-                    search_index.push(IndexItem {\n-                        ty: shortty(item),\n-                        name: item.name.clone().unwrap(),\n-                        path: fqp[..fqp.len() - 1].join(\"::\"),\n-                        desc: Escape(&shorter(item.doc_value())).to_string(),\n-                        parent: Some(did),\n-                        search_type: get_index_search_type(&item, parent_basename),\n-                    });\n-                },\n-                None => {}\n-            }\n-        }\n-\n-        // Reduce `NodeId` in paths into smaller sequential numbers,\n-        // and prune the paths that do not appear in the index.\n-        for item in search_index.iter() {\n-            match item.parent {\n-                Some(nodeid) => {\n-                    if !nodeid_to_pathid.contains_key(&nodeid) {\n-                        let pathid = pathid_to_nodeid.len();\n-                        nodeid_to_pathid.insert(nodeid, pathid);\n-                        pathid_to_nodeid.push(nodeid);\n-                    }\n-                }\n-                None => {}\n-            }\n+    let mut crate_items = Vec::with_capacity(cache.search_index.len());\n+    let mut crate_paths = Vec::<Json>::new();\n+\n+    let Cache { ref mut search_index,\n+                ref orphan_methods,\n+                ref mut paths, .. } = *cache;\n+\n+    // Attach all orphan methods to the type's definition if the type\n+    // has since been learned.\n+    for &(did, ref item) in orphan_methods {\n+        match paths.get(&did) {\n+            Some(&(ref fqp, _)) => {\n+                // Needed to determine `self` type.\n+                let parent_basename = Some(fqp[fqp.len() - 1].clone());\n+                search_index.push(IndexItem {\n+                    ty: shortty(item),\n+                    name: item.name.clone().unwrap(),\n+                    path: fqp[..fqp.len() - 1].join(\"::\"),\n+                    desc: Escape(&shorter(item.doc_value())).to_string(),\n+                    parent: Some(did),\n+                    parent_idx: None,\n+                    search_type: get_index_search_type(&item, parent_basename),\n+                });\n+            },\n+            None => {}\n         }\n-        assert_eq!(nodeid_to_pathid.len(), pathid_to_nodeid.len());\n     }\n \n-    // Collect the index into a string\n-    let mut w = io::Cursor::new(Vec::new());\n-    write!(&mut w, r#\"searchIndex['{}'] = {{\"items\":[\"#, krate.name).unwrap();\n+    // Reduce `NodeId` in paths into smaller sequential numbers,\n+    // and prune the paths that do not appear in the index.\n+    let mut lastpath = String::new();\n+    let mut lastpathid = 0usize;\n \n-    let mut lastpath = \"\".to_string();\n-    for (i, item) in cache.search_index.iter().enumerate() {\n-        // Omit the path if it is same to that of the prior item.\n-        let path;\n-        if lastpath == item.path {\n-            path = \"\";\n-        } else {\n-            lastpath = item.path.to_string();\n-            path = &item.path;\n-        };\n+    for item in search_index {\n+        item.parent_idx = item.parent.map(|nodeid| {\n+            if nodeid_to_pathid.contains_key(&nodeid) {\n+                *nodeid_to_pathid.get(&nodeid).unwrap()\n+            } else {\n+                let pathid = lastpathid;\n+                nodeid_to_pathid.insert(nodeid, pathid);\n+                lastpathid += 1;\n \n-        if i > 0 {\n-            write!(&mut w, \",\").unwrap();\n-        }\n-        write!(&mut w, r#\"[{},\"{}\",\"{}\",{}\"#,\n-               item.ty as usize, item.name, path,\n-               item.desc.to_json().to_string()).unwrap();\n-        match item.parent {\n-            Some(nodeid) => {\n-                let pathid = *nodeid_to_pathid.get(&nodeid).unwrap();\n-                write!(&mut w, \",{}\", pathid).unwrap();\n+                let &(ref fqp, short) = paths.get(&nodeid).unwrap();\n+                crate_paths.push(((short as usize), fqp.last().unwrap().clone()).to_json());\n+                pathid\n             }\n-            None => write!(&mut w, \",null\").unwrap()\n-        }\n-        match item.search_type {\n-            Some(ref t) => write!(&mut w, \",{}\", t).unwrap(),\n-            None => write!(&mut w, \",null\").unwrap()\n-        }\n-        write!(&mut w, \"]\").unwrap();\n-    }\n-\n-    write!(&mut w, r#\"],\"paths\":[\"#).unwrap();\n+        });\n \n-    for (i, &did) in pathid_to_nodeid.iter().enumerate() {\n-        let &(ref fqp, short) = cache.paths.get(&did).unwrap();\n-        if i > 0 {\n-            write!(&mut w, \",\").unwrap();\n+        // Omit the parent path if it is same to that of the prior item.\n+        if lastpath == item.path {\n+            item.path.clear();\n+        } else {\n+            lastpath = item.path.clone();\n         }\n-        write!(&mut w, r#\"[{},\"{}\"]\"#,\n-               short as usize, *fqp.last().unwrap()).unwrap();\n+        crate_items.push(item.to_json());\n     }\n \n-    write!(&mut w, \"]}};\").unwrap();\n+    let crate_doc = krate.module.as_ref().map(|module| {\n+        Escape(&shorter(module.doc_value())).to_string()\n+    }).unwrap_or(String::new());\n \n-    String::from_utf8(w.into_inner()).unwrap()\n+    let mut crate_data = BTreeMap::new();\n+    crate_data.insert(\"doc\".to_owned(), Json::String(crate_doc));\n+    crate_data.insert(\"items\".to_owned(), Json::Array(crate_items));\n+    crate_data.insert(\"paths\".to_owned(), Json::Array(crate_paths));\n+\n+    // Collect the index into a string\n+    format!(\"searchIndex[{}] = {};\",\n+            as_json(&krate.name),\n+            Json::Object(crate_data))\n }\n \n fn write_shared(cx: &Context,\n@@ -693,7 +680,7 @@ fn write_shared(cx: &Context,\n                 if !line.starts_with(key) {\n                     continue\n                 }\n-                if line.starts_with(&format!(\"{}['{}']\", key, krate)) {\n+                if line.starts_with(&format!(r#\"{}[\"{}\"]\"#, key, krate)) {\n                     continue\n                 }\n                 ret.push(line.to_string());\n@@ -1067,6 +1054,7 @@ impl DocFolder for Cache {\n                             path: path.join(\"::\").to_string(),\n                             desc: Escape(&shorter(item.doc_value())).to_string(),\n                             parent: parent,\n+                            parent_idx: None,\n                             search_type: get_index_search_type(&item, parent_basename),\n                         });\n                     }\n@@ -1387,7 +1375,7 @@ impl Context {\n                         let js_dst = this.dst.join(\"sidebar-items.js\");\n                         let mut js_out = BufWriter::new(try_err!(File::create(&js_dst), &js_dst));\n                         try_err!(write!(&mut js_out, \"initSidebarItems({});\",\n-                                    json::as_json(&items)), &js_dst);\n+                                    as_json(&items)), &js_dst);\n                     }\n \n                     for item in m.items {"}, {"sha": "f3efbcb1db3080f107e3fe7ca3250a810bf71b14", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/37c6f2881c634fe72dc98b846037dc1237270659/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/37c6f2881c634fe72dc98b846037dc1237270659/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=37c6f2881c634fe72dc98b846037dc1237270659", "patch": "@@ -580,6 +580,9 @@\n                         displayPath = \"\";\n                         href = rootPath + item.path.replace(/::/g, '/') +\n                                '/' + type + '.' + name + '.html';\n+                    } else if (type === \"externcrate\") {\n+                        displayPath = \"\";\n+                        href = rootPath + name + '/index.html';\n                     } else if (item.parent !== undefined) {\n                         var myparent = item.parent;\n                         var anchor = '#' + type + '.' + name;\n@@ -678,6 +681,16 @@\n             for (var crate in rawSearchIndex) {\n                 if (!rawSearchIndex.hasOwnProperty(crate)) { continue; }\n \n+                searchWords.push(crate);\n+                searchIndex.push({\n+                    crate: crate,\n+                    ty: 1, // == ExternCrate\n+                    name: crate,\n+                    path: \"\",\n+                    desc: rawSearchIndex[crate].doc,\n+                    type: null,\n+                });\n+\n                 // an array of [(Number) item type,\n                 //              (String) name,\n                 //              (String) full path or empty string for previous path,"}, {"sha": "5c073860f08ca78c5b6a3958e68fffe72ec5a3c1", "filename": "src/librustdoc/html/static/styles/main.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37c6f2881c634fe72dc98b846037dc1237270659/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/37c6f2881c634fe72dc98b846037dc1237270659/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css?ref=37c6f2881c634fe72dc98b846037dc1237270659", "patch": "@@ -82,7 +82,7 @@ pre {\n }\n \n .content a.primitive { color: #39a7bf; }\n-.content span.mod, .content a.mod, block a.current.mod { color: #4d76ae; }\n+.content span.externcrate, span.mod, .content a.mod, block a.current.mod { color: #4d76ae; }\n .content span.fn, .content a.fn, .block a.current.fn,\n .content span.method, .content a.method, .block a.current.method,\n .content span.tymethod, .content a.tymethod, .block a.current.tymethod,"}]}