{"sha": "4414071074759dee637e0ce968805de63e60da7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0MTQwNzEwNzQ3NTlkZWU2MzdlMGNlOTY4ODA1ZGU2M2U2MGRhN2I=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-06T12:50:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-06T12:50:25Z"}, "message": "Merge #8355\n\n8355: internal: do not drop errors from cargo metadata/check r=matklad a=matklad\n\nWork towards #3155\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "90ee633afbfdb4c23573bc20e2f0a907609a366d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90ee633afbfdb4c23573bc20e2f0a907609a366d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4414071074759dee637e0ce968805de63e60da7b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgbFkRCRBK7hj4Ov3rIwAAdHIIAJWSCSq/iMuQAdeHdgvOj8yw\nXp17CB7INnkHhei/DlchbZwmaAku7++2Lneh+r0elinFqWhZrGtXKZLhB9GsFCwH\njjB5n3LyHeGdcVHasGin/HXRslEqFKHI5ctjx8jBjBhLm5XgkePQiBtUQFmlsd9k\nOLjOP2TirgSPsJOUZdPxH/SO61phNCdWZiMla+b2xvS610CQlP85kEZ+49bXK8sX\nV037yCI+OsX1pmElJsoK00ZKxMrYBiGdO+MzRgUAb+zLT5waaj1akJzjuskHZDCV\nyPGmX7em9R/UCE2X8ikYvRerSTg5OV12wnZaFWetWS8pTifjrF72ayp5eWLRrpc=\n=aoyi\n-----END PGP SIGNATURE-----\n", "payload": "tree 90ee633afbfdb4c23573bc20e2f0a907609a366d\nparent 002e72a28de3df818992442ad49bb60d3d0b1d0b\nparent ad02bfe58fd52293d9ae4a049f98f475df9d3abb\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1617713425 +0000\ncommitter GitHub <noreply@github.com> 1617713425 +0000\n\nMerge #8355\n\n8355: internal: do not drop errors from cargo metadata/check r=matklad a=matklad\n\nWork towards #3155\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4414071074759dee637e0ce968805de63e60da7b", "html_url": "https://github.com/rust-lang/rust/commit/4414071074759dee637e0ce968805de63e60da7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4414071074759dee637e0ce968805de63e60da7b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "002e72a28de3df818992442ad49bb60d3d0b1d0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/002e72a28de3df818992442ad49bb60d3d0b1d0b", "html_url": "https://github.com/rust-lang/rust/commit/002e72a28de3df818992442ad49bb60d3d0b1d0b"}, {"sha": "ad02bfe58fd52293d9ae4a049f98f475df9d3abb", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad02bfe58fd52293d9ae4a049f98f475df9d3abb", "html_url": "https://github.com/rust-lang/rust/commit/ad02bfe58fd52293d9ae4a049f98f475df9d3abb"}], "stats": {"total": 508, "additions": 272, "deletions": 236}, "files": [{"sha": "c2c87b207b1e42553614e84f5b3b3f01645ce4f8", "filename": "crates/project_model/src/build_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4414071074759dee637e0ce968805de63e60da7b/crates%2Fproject_model%2Fsrc%2Fbuild_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4414071074759dee637e0ce968805de63e60da7b/crates%2Fproject_model%2Fsrc%2Fbuild_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fbuild_data.rs?ref=4414071074759dee637e0ce968805de63e60da7b", "patch": "@@ -52,7 +52,7 @@ pub struct BuildDataCollector {\n     configs: FxHashMap<AbsPathBuf, BuildDataConfig>,\n }\n \n-#[derive(Debug, Default, PartialEq, Eq)]\n+#[derive(Debug, Default, PartialEq, Eq, Clone)]\n pub struct BuildDataResult {\n     data: FxHashMap<AbsPathBuf, BuildDataMap>,\n }"}, {"sha": "e012b4452fa4ca157c21f4b1b8d9ce1f62536e7b", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4414071074759dee637e0ce968805de63e60da7b/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4414071074759dee637e0ce968805de63e60da7b/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=4414071074759dee637e0ce968805de63e60da7b", "patch": "@@ -445,8 +445,8 @@ impl Config {\n     pub fn hover_actions(&self) -> bool {\n         self.experimental(\"hoverActions\")\n     }\n-    pub fn status_notification(&self) -> bool {\n-        self.experimental(\"statusNotification\")\n+    pub fn server_status_notification(&self) -> bool {\n+        self.experimental(\"serverStatusNotification\")\n     }\n \n     pub fn publish_diagnostics(&self) -> bool {"}, {"sha": "adeb7a97e85ab96c985ec9f32f434f59aaad41ac", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/4414071074759dee637e0ce968805de63e60da7b/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4414071074759dee637e0ce968805de63e60da7b/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=4414071074759dee637e0ce968805de63e60da7b", "patch": "@@ -23,6 +23,7 @@ use crate::{\n     document::DocumentData,\n     from_proto,\n     line_index::{LineEndings, LineIndex},\n+    lsp_ext,\n     main_loop::Task,\n     op_queue::OpQueue,\n     reload::SourceRootConfig,\n@@ -32,20 +33,6 @@ use crate::{\n     Result,\n };\n \n-#[derive(Eq, PartialEq, Copy, Clone)]\n-pub(crate) enum Status {\n-    Loading,\n-    Ready { partial: bool },\n-    Invalid,\n-    NeedsReload,\n-}\n-\n-impl Default for Status {\n-    fn default() -> Self {\n-        Status::Loading\n-    }\n-}\n-\n // Enforces drop order\n pub(crate) struct Handle<H, C> {\n     pub(crate) handle: H,\n@@ -67,26 +54,36 @@ pub(crate) struct GlobalState {\n     req_queue: ReqQueue,\n     pub(crate) task_pool: Handle<TaskPool<Task>, Receiver<Task>>,\n     pub(crate) loader: Handle<Box<dyn vfs::loader::Handle>, Receiver<vfs::loader::Message>>,\n-    pub(crate) vfs_config_version: u32,\n-    pub(crate) flycheck: Vec<FlycheckHandle>,\n-    pub(crate) flycheck_sender: Sender<flycheck::Message>,\n-    pub(crate) flycheck_receiver: Receiver<flycheck::Message>,\n     pub(crate) config: Arc<Config>,\n     pub(crate) analysis_host: AnalysisHost,\n     pub(crate) diagnostics: DiagnosticCollection,\n     pub(crate) mem_docs: FxHashMap<VfsPath, DocumentData>,\n     pub(crate) semantic_tokens_cache: Arc<Mutex<FxHashMap<Url, SemanticTokens>>>,\n-    pub(crate) vfs: Arc<RwLock<(vfs::Vfs, FxHashMap<FileId, LineEndings>)>>,\n     pub(crate) shutdown_requested: bool,\n-    pub(crate) status: Status,\n+    pub(crate) last_reported_status: Option<lsp_ext::ServerStatusParams>,\n     pub(crate) source_root_config: SourceRootConfig,\n     pub(crate) proc_macro_client: Option<ProcMacroClient>,\n \n-    pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n-    pub(crate) fetch_workspaces_queue: OpQueue<(), ()>,\n+    pub(crate) flycheck: Vec<FlycheckHandle>,\n+    pub(crate) flycheck_sender: Sender<flycheck::Message>,\n+    pub(crate) flycheck_receiver: Receiver<flycheck::Message>,\n \n+    pub(crate) vfs: Arc<RwLock<(vfs::Vfs, FxHashMap<FileId, LineEndings>)>>,\n+    pub(crate) vfs_config_version: u32,\n+    pub(crate) vfs_progress_config_version: u32,\n+    pub(crate) vfs_progress_n_total: usize,\n+    pub(crate) vfs_progress_n_done: usize,\n+\n+    /// For both `workspaces` and `workspace_build_data`, the field stores the\n+    /// data we actually use, while the `OpQueue` stores the result of the last\n+    /// fetch.\n+    ///\n+    /// If the fetch (partially) fails, we do not update the values.\n+    pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n+    pub(crate) fetch_workspaces_queue: OpQueue<(), Vec<anyhow::Result<ProjectWorkspace>>>,\n     pub(crate) workspace_build_data: Option<BuildDataResult>,\n-    pub(crate) fetch_build_data_queue: OpQueue<BuildDataCollector, ()>,\n+    pub(crate) fetch_build_data_queue:\n+        OpQueue<BuildDataCollector, Option<anyhow::Result<BuildDataResult>>>,\n \n     latest_requests: Arc<RwLock<LatestRequests>>,\n }\n@@ -124,25 +121,32 @@ impl GlobalState {\n         GlobalState {\n             sender,\n             req_queue: ReqQueue::default(),\n-            vfs_config_version: 0,\n             task_pool,\n             loader,\n-            flycheck: Vec::new(),\n-            flycheck_sender,\n-            flycheck_receiver,\n             config: Arc::new(config),\n             analysis_host,\n             diagnostics: Default::default(),\n             mem_docs: FxHashMap::default(),\n             semantic_tokens_cache: Arc::new(Default::default()),\n-            vfs: Arc::new(RwLock::new((vfs::Vfs::default(), FxHashMap::default()))),\n             shutdown_requested: false,\n-            status: Status::default(),\n+            last_reported_status: None,\n             source_root_config: SourceRootConfig::default(),\n             proc_macro_client: None,\n+\n+            flycheck: Vec::new(),\n+            flycheck_sender,\n+            flycheck_receiver,\n+\n+            vfs: Arc::new(RwLock::new((vfs::Vfs::default(), FxHashMap::default()))),\n+            vfs_config_version: 0,\n+            vfs_progress_config_version: 0,\n+            vfs_progress_n_total: 0,\n+            vfs_progress_n_done: 0,\n+\n             workspaces: Arc::new(Vec::new()),\n             fetch_workspaces_queue: OpQueue::default(),\n             workspace_build_data: None,\n+\n             fetch_build_data_queue: OpQueue::default(),\n             latest_requests: Default::default(),\n         }"}, {"sha": "81a6f22f16c1c79d1f3f5f6f7247fe2dd26b8978", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4414071074759dee637e0ce968805de63e60da7b/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4414071074759dee637e0ce968805de63e60da7b/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=4414071074759dee637e0ce968805de63e60da7b", "patch": "@@ -241,26 +241,26 @@ pub struct SsrParams {\n     pub selections: Vec<lsp_types::Range>,\n }\n \n-pub enum StatusNotification {}\n+pub enum ServerStatusNotification {}\n \n-#[derive(Serialize, Deserialize)]\n-#[serde(rename_all = \"camelCase\")]\n-pub enum Status {\n-    Loading,\n-    ReadyPartial,\n-    Ready,\n-    NeedsReload,\n-    Invalid,\n+impl Notification for ServerStatusNotification {\n+    type Params = ServerStatusParams;\n+    const METHOD: &'static str = \"experimental/serverStatus\";\n }\n \n-#[derive(Deserialize, Serialize)]\n-pub struct StatusParams {\n-    pub status: Status,\n+#[derive(Deserialize, Serialize, PartialEq, Eq, Clone)]\n+pub struct ServerStatusParams {\n+    pub health: Health,\n+    pub quiescent: bool,\n+    pub message: Option<String>,\n }\n \n-impl Notification for StatusNotification {\n-    type Params = StatusParams;\n-    const METHOD: &'static str = \"rust-analyzer/status\";\n+#[derive(Serialize, Deserialize, Clone, Copy, PartialEq, Eq)]\n+#[serde(rename_all = \"camelCase\")]\n+pub enum Health {\n+    Ok,\n+    Warning,\n+    Error,\n }\n \n pub enum CodeActionRequest {}"}, {"sha": "a5655116b49ae18d44cfbc2f9c7512d33a5b0237", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 59, "deletions": 42, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/4414071074759dee637e0ce968805de63e60da7b/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4414071074759dee637e0ce968805de63e60da7b/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=4414071074759dee637e0ce968805de63e60da7b", "patch": "@@ -2,6 +2,7 @@\n //! requests/replies and notifications back to the client.\n use std::{\n     env, fmt,\n+    sync::Arc,\n     time::{Duration, Instant},\n };\n \n@@ -12,14 +13,15 @@ use ide::{Canceled, FileId};\n use ide_db::base_db::VfsPath;\n use lsp_server::{Connection, Notification, Request, Response};\n use lsp_types::notification::Notification as _;\n+use project_model::BuildDataCollector;\n use vfs::ChangeKind;\n \n use crate::{\n     config::Config,\n     dispatch::{NotificationDispatcher, RequestDispatcher},\n     document::DocumentData,\n     from_proto,\n-    global_state::{file_id_to_url, url_to_file_id, GlobalState, Status},\n+    global_state::{file_id_to_url, url_to_file_id, GlobalState},\n     handlers, lsp_ext,\n     lsp_utils::{apply_document_changes, is_canceled, notification_is, Progress},\n     reload::{BuildDataProgress, ProjectWorkspaceProgress},\n@@ -187,7 +189,7 @@ impl GlobalState {\n             log::info!(\"task queue len: {}\", task_queue_len);\n         }\n \n-        let mut new_status = self.status;\n+        let was_quiescent = self.is_quiescent();\n         match event {\n             Event::Lsp(msg) => match msg {\n                 lsp_server::Message::Request(req) => self.on_request(loop_start, req)?,\n@@ -227,11 +229,24 @@ impl GlobalState {\n                                     (Progress::Report, Some(msg))\n                                 }\n                                 ProjectWorkspaceProgress::End(workspaces) => {\n-                                    self.fetch_workspaces_completed();\n-                                    self.switch_workspaces(workspaces, None);\n+                                    self.fetch_workspaces_completed(workspaces);\n+\n+                                    let old = Arc::clone(&self.workspaces);\n+                                    self.switch_workspaces();\n+                                    let workspaces_updated = !Arc::ptr_eq(&old, &self.workspaces);\n+\n+                                    if self.config.run_build_scripts() && workspaces_updated {\n+                                        let mut collector = BuildDataCollector::default();\n+                                        for ws in self.workspaces.iter() {\n+                                            ws.collect_build_data_configs(&mut collector);\n+                                        }\n+                                        self.fetch_build_data_request(collector)\n+                                    }\n+\n                                     (Progress::End, None)\n                                 }\n                             };\n+\n                             self.report_progress(\"fetching\", state, msg, None);\n                         }\n                         Task::FetchBuildData(progress) => {\n@@ -240,19 +255,21 @@ impl GlobalState {\n                                 BuildDataProgress::Report(msg) => {\n                                     (Some(Progress::Report), Some(msg))\n                                 }\n-                                BuildDataProgress::End(collector) => {\n-                                    self.fetch_build_data_completed();\n-                                    let workspaces =\n-                                        (*self.workspaces).clone().into_iter().map(Ok).collect();\n-                                    self.switch_workspaces(workspaces, Some(collector));\n+                                BuildDataProgress::End(build_data_result) => {\n+                                    self.fetch_build_data_completed(build_data_result);\n+\n+                                    self.switch_workspaces();\n+\n                                     (Some(Progress::End), None)\n                                 }\n                             };\n+\n                             if let Some(state) = state {\n                                 self.report_progress(\"loading\", state, msg, None);\n                             }\n                         }\n                     }\n+\n                     // Coalesce multiple task events into one loop turn\n                     task = match self.task_pool.receiver.try_recv() {\n                         Ok(task) => task,\n@@ -298,30 +315,25 @@ impl GlobalState {\n                         }\n                         vfs::loader::Message::Progress { n_total, n_done, config_version } => {\n                             always!(config_version <= self.vfs_config_version);\n-                            if n_total == 0 {\n-                                new_status = Status::Invalid;\n+\n+                            self.vfs_progress_config_version = config_version;\n+                            self.vfs_progress_n_total = n_total;\n+                            self.vfs_progress_n_done = n_done;\n+\n+                            let state = if n_done == 0 {\n+                                Progress::Begin\n+                            } else if n_done < n_total {\n+                                Progress::Report\n                             } else {\n-                                let state = if n_done == 0 {\n-                                    new_status = Status::Loading;\n-                                    Progress::Begin\n-                                } else if n_done < n_total {\n-                                    Progress::Report\n-                                } else {\n-                                    assert_eq!(n_done, n_total);\n-                                    new_status = Status::Ready {\n-                                        partial: self.config.run_build_scripts()\n-                                            && self.workspace_build_data.is_none()\n-                                            || config_version < self.vfs_config_version,\n-                                    };\n-                                    Progress::End\n-                                };\n-                                self.report_progress(\n-                                    \"roots scanned\",\n-                                    state,\n-                                    Some(format!(\"{}/{}\", n_done, n_total)),\n-                                    Some(Progress::fraction(n_done, n_total)),\n-                                )\n-                            }\n+                                assert_eq!(n_done, n_total);\n+                                Progress::End\n+                            };\n+                            self.report_progress(\n+                                \"roots scanned\",\n+                                state,\n+                                Some(format!(\"{}/{}\", n_done, n_total)),\n+                                Some(Progress::fraction(n_done, n_total)),\n+                            )\n                         }\n                     }\n                     // Coalesce many VFS event into a single loop turn\n@@ -397,18 +409,14 @@ impl GlobalState {\n         }\n \n         let state_changed = self.process_changes();\n-        let prev_status = self.status;\n-        if prev_status != new_status {\n-            self.transition(new_status);\n-        }\n-        let is_ready = matches!(self.status, Status::Ready { .. });\n-        if prev_status == Status::Loading && is_ready {\n+\n+        if self.is_quiescent() && !was_quiescent {\n             for flycheck in &self.flycheck {\n                 flycheck.update();\n             }\n         }\n \n-        if is_ready && (state_changed || prev_status == Status::Loading) {\n+        if self.is_quiescent() && (!was_quiescent || state_changed) {\n             self.update_file_notifications_on_threadpool();\n \n             // Refresh semantic tokens if the client supports it.\n@@ -437,9 +445,13 @@ impl GlobalState {\n             }\n         }\n \n-        self.fetch_workspaces_if_needed();\n+        if self.config.cargo_autoreload() {\n+            self.fetch_workspaces_if_needed();\n+        }\n         self.fetch_build_data_if_needed();\n \n+        self.report_new_status_if_needed();\n+\n         let loop_duration = loop_start.elapsed();\n         if loop_duration > Duration::from_millis(100) {\n             log::warn!(\"overly long loop turn: {:?}\", loop_duration);\n@@ -466,7 +478,8 @@ impl GlobalState {\n             return Ok(());\n         }\n \n-        if self.status == Status::Loading && req.method != \"shutdown\" {\n+        // Avoid flashing a bunch of unresolved references during initial load.\n+        if self.workspaces.is_empty() && !self.is_quiescent() {\n             self.respond(lsp_server::Response::new_err(\n                 req.id,\n                 // FIXME: i32 should impl From<ErrorCode> (from() guarantees lossless conversion)\n@@ -477,7 +490,11 @@ impl GlobalState {\n         }\n \n         RequestDispatcher { req: Some(req), global_state: self }\n-            .on_sync::<lsp_ext::ReloadWorkspace>(|s, ()| Ok(s.fetch_workspaces_request()))?\n+            .on_sync::<lsp_ext::ReloadWorkspace>(|s, ()| {\n+                s.fetch_workspaces_request();\n+                s.fetch_workspaces_if_needed();\n+                Ok(())\n+            })?\n             .on_sync::<lsp_ext::JoinLines>(|s, p| handlers::handle_join_lines(s.snapshot(), p))?\n             .on_sync::<lsp_ext::OnEnter>(|s, p| handlers::handle_on_enter(s.snapshot(), p))?\n             .on_sync::<lsp_types::request::Shutdown>(|s, ()| {"}, {"sha": "1d612a9337642eef9ec231fbc703e4ae3d08d007", "filename": "crates/rust-analyzer/src/op_queue.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4414071074759dee637e0ce968805de63e60da7b/crates%2Frust-analyzer%2Fsrc%2Fop_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4414071074759dee637e0ce968805de63e60da7b/crates%2Frust-analyzer%2Fsrc%2Fop_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fop_queue.rs?ref=4414071074759dee637e0ce968805de63e60da7b", "patch": "@@ -2,27 +2,27 @@\n //! at a time.\n \n pub(crate) struct OpQueue<Args, Output> {\n-    op_scheduled: Option<Args>,\n+    op_requested: Option<Args>,\n     op_in_progress: bool,\n     last_op_result: Output,\n }\n \n impl<Args, Output: Default> Default for OpQueue<Args, Output> {\n     fn default() -> Self {\n-        Self { op_scheduled: None, op_in_progress: false, last_op_result: Default::default() }\n+        Self { op_requested: None, op_in_progress: false, last_op_result: Default::default() }\n     }\n }\n \n impl<Args, Output> OpQueue<Args, Output> {\n     pub(crate) fn request_op(&mut self, data: Args) {\n-        self.op_scheduled = Some(data);\n+        self.op_requested = Some(data);\n     }\n     pub(crate) fn should_start_op(&mut self) -> Option<Args> {\n         if self.op_in_progress {\n             return None;\n         }\n-        self.op_in_progress = self.op_scheduled.is_some();\n-        self.op_scheduled.take()\n+        self.op_in_progress = self.op_requested.is_some();\n+        self.op_requested.take()\n     }\n     pub(crate) fn op_completed(&mut self, result: Output) {\n         assert!(self.op_in_progress);\n@@ -34,4 +34,10 @@ impl<Args, Output> OpQueue<Args, Output> {\n     pub(crate) fn last_op_result(&self) -> &Output {\n         &self.last_op_result\n     }\n+    pub(crate) fn op_in_progress(&self) -> bool {\n+        self.op_in_progress\n+    }\n+    pub(crate) fn op_requested(&self) -> bool {\n+        self.op_requested.is_some()\n+    }\n }"}, {"sha": "301c7003b99dafa325467925aa29c2a49746203d", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 100, "deletions": 94, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/4414071074759dee637e0ce968805de63e60da7b/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4414071074759dee637e0ce968805de63e60da7b/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=4414071074759dee637e0ce968805de63e60da7b", "patch": "@@ -9,11 +9,10 @@ use vfs::{file_set::FileSetConfig, AbsPath, AbsPathBuf, ChangeKind};\n \n use crate::{\n     config::{Config, FilesWatcher, LinkedProject},\n-    global_state::{GlobalState, Status},\n+    global_state::GlobalState,\n     lsp_ext,\n     main_loop::Task,\n };\n-use lsp_ext::StatusParams;\n \n #[derive(Debug)]\n pub(crate) enum ProjectWorkspaceProgress {\n@@ -30,6 +29,13 @@ pub(crate) enum BuildDataProgress {\n }\n \n impl GlobalState {\n+    pub(crate) fn is_quiescent(&self) -> bool {\n+        !(self.fetch_workspaces_queue.op_in_progress()\n+            || self.fetch_build_data_queue.op_in_progress()\n+            || self.vfs_progress_config_version < self.vfs_config_version\n+            || self.vfs_progress_n_done < self.vfs_progress_n_total)\n+    }\n+\n     pub(crate) fn update_configuration(&mut self, config: Config) {\n         let _p = profile::span(\"GlobalState::update_configuration\");\n         let old_config = mem::replace(&mut self.config, Arc::new(config));\n@@ -46,25 +52,17 @@ impl GlobalState {\n         if !changes.iter().any(|(path, kind)| is_interesting(path, *kind)) {\n             return;\n         }\n-        match self.status {\n-            Status::Loading | Status::NeedsReload => return,\n-            Status::Ready { .. } | Status::Invalid => (),\n-        }\n         log::info!(\n-            \"Reloading workspace because of the following changes: {}\",\n+            \"Requesting workspace reload because of the following changes: {}\",\n             itertools::join(\n                 changes\n                     .iter()\n                     .filter(|(path, kind)| is_interesting(path, *kind))\n-                    .map(|(path, kind)| format!(\"{}/{:?}\", path.display(), kind)),\n+                    .map(|(path, kind)| format!(\"{}: {:?}\", path.display(), kind)),\n                 \", \"\n             )\n         );\n-        if self.config.cargo_autoreload() {\n-            self.fetch_workspaces_request();\n-        } else {\n-            self.transition(Status::NeedsReload);\n-        }\n+        self.fetch_workspaces_request();\n \n         fn is_interesting(path: &AbsPath, change_kind: ChangeKind) -> bool {\n             const IMPLICIT_TARGET_FILES: &[&str] = &[\"build.rs\", \"src/main.rs\", \"src/lib.rs\"];\n@@ -101,46 +99,32 @@ impl GlobalState {\n             false\n         }\n     }\n-    pub(crate) fn transition(&mut self, new_status: Status) {\n-        self.status = new_status;\n-        if self.config.status_notification() {\n-            let lsp_status = match new_status {\n-                Status::Loading => lsp_ext::Status::Loading,\n-                Status::Ready { partial: true } => lsp_ext::Status::ReadyPartial,\n-                Status::Ready { partial: false } => lsp_ext::Status::Ready,\n-                Status::Invalid => lsp_ext::Status::Invalid,\n-                Status::NeedsReload => lsp_ext::Status::NeedsReload,\n-            };\n-            self.send_notification::<lsp_ext::StatusNotification>(StatusParams {\n-                status: lsp_status,\n-            });\n+    pub(crate) fn report_new_status_if_needed(&mut self) {\n+        if !self.config.server_status_notification() {\n+            return;\n         }\n-    }\n-\n-    pub(crate) fn fetch_build_data_request(&mut self, build_data_collector: BuildDataCollector) {\n-        self.fetch_build_data_queue.request_op(build_data_collector);\n-    }\n \n-    pub(crate) fn fetch_build_data_if_needed(&mut self) {\n-        let mut build_data_collector = match self.fetch_build_data_queue.should_start_op() {\n-            Some(it) => it,\n-            None => return,\n+        let mut status = lsp_ext::ServerStatusParams {\n+            health: lsp_ext::Health::Ok,\n+            quiescent: self.is_quiescent(),\n+            message: None,\n         };\n-        self.task_pool.handle.spawn_with_sender(move |sender| {\n-            sender.send(Task::FetchBuildData(BuildDataProgress::Begin)).unwrap();\n+        if !self.config.cargo_autoreload()\n+            && self.is_quiescent()\n+            && self.fetch_workspaces_queue.op_requested()\n+        {\n+            status.health = lsp_ext::Health::Warning;\n+            status.message = Some(\"Workspace reload required\".to_string())\n+        }\n+        if let Some(error) = self.loading_error() {\n+            status.health = lsp_ext::Health::Error;\n+            status.message = Some(format!(\"Workspace reload failed: {}\", error))\n+        }\n \n-            let progress = {\n-                let sender = sender.clone();\n-                move |msg| {\n-                    sender.send(Task::FetchBuildData(BuildDataProgress::Report(msg))).unwrap()\n-                }\n-            };\n-            let res = build_data_collector.collect(&progress);\n-            sender.send(Task::FetchBuildData(BuildDataProgress::End(res))).unwrap();\n-        });\n-    }\n-    pub(crate) fn fetch_build_data_completed(&mut self) {\n-        self.fetch_build_data_queue.op_completed(())\n+        if self.last_reported_status.as_ref() != Some(&status) {\n+            self.last_reported_status = Some(status.clone());\n+            self.send_notification::<lsp_ext::ServerStatusNotification>(status);\n+        }\n     }\n \n     pub(crate) fn fetch_workspaces_request(&mut self) {\n@@ -194,57 +178,69 @@ impl GlobalState {\n             }\n         });\n     }\n-    pub(crate) fn fetch_workspaces_completed(&mut self) {\n-        self.fetch_workspaces_queue.op_completed(())\n+    pub(crate) fn fetch_workspaces_completed(\n+        &mut self,\n+        workspaces: Vec<anyhow::Result<ProjectWorkspace>>,\n+    ) {\n+        self.fetch_workspaces_queue.op_completed(workspaces)\n     }\n \n-    pub(crate) fn switch_workspaces(\n+    pub(crate) fn fetch_build_data_request(&mut self, build_data_collector: BuildDataCollector) {\n+        self.fetch_build_data_queue.request_op(build_data_collector);\n+    }\n+    pub(crate) fn fetch_build_data_if_needed(&mut self) {\n+        let mut build_data_collector = match self.fetch_build_data_queue.should_start_op() {\n+            Some(it) => it,\n+            None => return,\n+        };\n+        self.task_pool.handle.spawn_with_sender(move |sender| {\n+            sender.send(Task::FetchBuildData(BuildDataProgress::Begin)).unwrap();\n+\n+            let progress = {\n+                let sender = sender.clone();\n+                move |msg| {\n+                    sender.send(Task::FetchBuildData(BuildDataProgress::Report(msg))).unwrap()\n+                }\n+            };\n+            let res = build_data_collector.collect(&progress);\n+            sender.send(Task::FetchBuildData(BuildDataProgress::End(res))).unwrap();\n+        });\n+    }\n+    pub(crate) fn fetch_build_data_completed(\n         &mut self,\n-        workspaces: Vec<anyhow::Result<ProjectWorkspace>>,\n-        workspace_build_data: Option<anyhow::Result<BuildDataResult>>,\n+        build_data: anyhow::Result<BuildDataResult>,\n     ) {\n-        let _p = profile::span(\"GlobalState::switch_workspaces\");\n-        log::info!(\"will switch workspaces: {:?}\", workspaces);\n+        self.fetch_build_data_queue.op_completed(Some(build_data))\n+    }\n \n-        let mut has_errors = false;\n-        let workspaces = workspaces\n-            .into_iter()\n-            .filter_map(|res| {\n-                res.map_err(|err| {\n-                    has_errors = true;\n-                    log::error!(\"failed to load workspace: {:#}\", err);\n-                    if self.workspaces.is_empty() {\n-                        self.show_message(\n-                            lsp_types::MessageType::Error,\n-                            format!(\"rust-analyzer failed to load workspace: {:#}\", err),\n-                        );\n-                    }\n-                })\n-                .ok()\n-            })\n-            .collect::<Vec<_>>();\n+    pub(crate) fn switch_workspaces(&mut self) {\n+        let _p = profile::span(\"GlobalState::switch_workspaces\");\n+        log::info!(\"will switch workspaces\");\n \n-        let workspace_build_data = match workspace_build_data {\n-            Some(Ok(it)) => Some(it),\n-            Some(Err(err)) => {\n-                log::error!(\"failed to fetch build data: {:#}\", err);\n-                self.show_message(\n-                    lsp_types::MessageType::Error,\n-                    format!(\"rust-analyzer failed to fetch build data: {:#}\", err),\n-                );\n+        if let Some(error_message) = self.loading_error() {\n+            log::error!(\"failed to switch workspaces: {}\", error_message);\n+            self.show_message(lsp_types::MessageType::Error, error_message);\n+            if !self.workspaces.is_empty() {\n                 return;\n             }\n-            None => None,\n+        }\n+\n+        let workspaces = self\n+            .fetch_workspaces_queue\n+            .last_op_result()\n+            .iter()\n+            .filter_map(|res| res.as_ref().ok().cloned())\n+            .collect::<Vec<_>>();\n+\n+        let workspace_build_data = match self.fetch_build_data_queue.last_op_result() {\n+            Some(Ok(it)) => Some(it.clone()),\n+            None | Some(Err(_)) => None,\n         };\n \n         if *self.workspaces == workspaces && self.workspace_build_data == workspace_build_data {\n             return;\n         }\n \n-        if !self.workspaces.is_empty() && has_errors {\n-            return;\n-        }\n-\n         if let FilesWatcher::Client = self.config.files().watcher {\n             if self.config.did_change_watched_files_dynamic_registration() {\n                 let registration_options = lsp_types::DidChangeWatchedFilesRegistrationOptions {\n@@ -337,14 +333,6 @@ impl GlobalState {\n         };\n         change.set_crate_graph(crate_graph);\n \n-        if self.config.run_build_scripts() && workspace_build_data.is_none() {\n-            let mut collector = BuildDataCollector::default();\n-            for ws in &workspaces {\n-                ws.collect_build_data_configs(&mut collector);\n-            }\n-            self.fetch_build_data_request(collector)\n-        }\n-\n         self.source_root_config = project_folders.source_root_config;\n         self.workspaces = Arc::new(workspaces);\n         self.workspace_build_data = workspace_build_data;\n@@ -355,6 +343,24 @@ impl GlobalState {\n         log::info!(\"did switch workspaces\");\n     }\n \n+    fn loading_error(&self) -> Option<String> {\n+        let mut message = None;\n+\n+        for ws in self.fetch_workspaces_queue.last_op_result() {\n+            if let Err(err) = ws {\n+                let message = message.get_or_insert_with(String::new);\n+                stdx::format_to!(message, \"rust-analyzer failed to load workspace: {:#}\\n\", err);\n+            }\n+        }\n+\n+        if let Some(Err(err)) = self.fetch_build_data_queue.last_op_result() {\n+            let message = message.get_or_insert_with(String::new);\n+            stdx::format_to!(message, \"rust-analyzer failed to fetch build data: {:#}\\n\", err);\n+        }\n+\n+        message\n+    }\n+\n     fn reload_flycheck(&mut self) {\n         let _p = profile::span(\"GlobalState::reload_flycheck\");\n         let config = match self.config.flycheck() {"}, {"sha": "8d68f1b7d53af1c8900abce15f862353affd037e", "filename": "crates/rust-analyzer/tests/rust-analyzer/support.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4414071074759dee637e0ce968805de63e60da7b/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4414071074759dee637e0ce968805de63e60da7b/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fsupport.rs?ref=4414071074759dee637e0ce968805de63e60da7b", "patch": "@@ -103,7 +103,7 @@ impl<'a> Project<'a> {\n                     ..Default::default()\n                 }),\n                 experimental: Some(json!({\n-                    \"statusNotification\": true,\n+                    \"serverStatusNotification\": true,\n                 })),\n                 ..Default::default()\n             },\n@@ -213,13 +213,12 @@ impl Server {\n     }\n     pub(crate) fn wait_until_workspace_is_loaded(self) -> Server {\n         self.wait_for_message_cond(1, &|msg: &Message| match msg {\n-            Message::Notification(n) if n.method == \"rust-analyzer/status\" => {\n+            Message::Notification(n) if n.method == \"experimental/serverStatus\" => {\n                 let status = n\n                     .clone()\n-                    .extract::<lsp_ext::StatusParams>(\"rust-analyzer/status\")\n-                    .unwrap()\n-                    .status;\n-                matches!(status, lsp_ext::Status::Ready)\n+                    .extract::<lsp_ext::ServerStatusParams>(\"experimental/serverStatus\")\n+                    .unwrap();\n+                status.quiescent\n             }\n             _ => false,\n         })"}, {"sha": "989771ac6fff8c5f8a4098e8718780e5b2fe54ad", "filename": "docs/dev/lsp-extensions.md", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4414071074759dee637e0ce968805de63e60da7b/docs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/4414071074759dee637e0ce968805de63e60da7b/docs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Flsp-extensions.md?ref=4414071074759dee637e0ce968805de63e60da7b", "patch": "@@ -1,5 +1,5 @@\n <!---\n-lsp_ext.rs hash: e8a7502bd2b2c2f5\n+lsp_ext.rs hash: faae991334a151d0\n \n If you need to change the above hash to make the test pass, please check if you\n need to adjust this doc as well and ping this  issue:\n@@ -419,23 +419,37 @@ Returns internal status message, mostly for debugging purposes.\n \n Reloads project information (that is, re-executes `cargo metadata`).\n \n-## Status Notification\n+## Server Status\n \n-**Experimental Client Capability:** `{ \"statusNotification\": boolean }`\n+**Experimental Client Capability:** `{ \"serverStatus\": boolean }`\n \n-**Method:** `rust-analyzer/status`\n+**Method:** `experimental/serverStatus`\n \n **Notification:**\n \n ```typescript\n-interface StatusParams {\n-    status: \"loading\" | \"readyPartial\" | \"ready\" | \"invalid\" | \"needsReload\",\n+interface ServerStatusParams {\n+    /// `ok` means that the server is completely functional.\n+    ///\n+    /// `warning` means that the server is partially functional.\n+    /// It can server requests, but some results might be wrong due to,\n+    /// for example, some missing dependencies.\n+    ///\n+    /// `error` means that the server is not functional. For example,\n+    /// there's a fatal build configuration problem.\n+    health: \"ok\" | \"warning\" | \"error\",\n+    /// Is there any pending background work which might change the status?\n+    /// For example, are dependencies being downloaded?\n+    quiescent: bool,\n+    /// Explanatory message to show on hover.\n+    message?: string,\n }\n ```\n \n This notification is sent from server to client.\n-The client can use it to display persistent status to the user (in modline).\n-For `needsReload` state, the client can provide a context-menu action to run `rust-analyzer/reloadWorkspace` request.\n+The client can use it to display *persistent* status to the user (in modline).\n+It is similar to the `showMessage`, but is intended for stares rather than point-in-time events.\n+\n \n ## Syntax Tree\n "}, {"sha": "116f41df6e9c1a8e48c31bd678a6b236a1dcf026", "filename": "editors/code/src/client.ts", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4414071074759dee637e0ce968805de63e60da7b/editors%2Fcode%2Fsrc%2Fclient.ts", "raw_url": "https://github.com/rust-lang/rust/raw/4414071074759dee637e0ce968805de63e60da7b/editors%2Fcode%2Fsrc%2Fclient.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fclient.ts?ref=4414071074759dee637e0ce968805de63e60da7b", "patch": "@@ -159,7 +159,7 @@ class ExperimentalFeatures implements lc.StaticFeature {\n         caps.snippetTextEdit = true;\n         caps.codeActionGroup = true;\n         caps.hoverActions = true;\n-        caps.statusNotification = true;\n+        caps.serverStatusNotification = true;\n         capabilities.experimental = caps;\n     }\n     initialize(_capabilities: lc.ServerCapabilities<any>, _documentSelector: lc.DocumentSelector | undefined): void {"}, {"sha": "bd023f803e79f3dd2bd8fa87408930b38cbf450e", "filename": "editors/code/src/ctx.ts", "status": "modified", "additions": 18, "deletions": 29, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4414071074759dee637e0ce968805de63e60da7b/editors%2Fcode%2Fsrc%2Fctx.ts", "raw_url": "https://github.com/rust-lang/rust/raw/4414071074759dee637e0ce968805de63e60da7b/editors%2Fcode%2Fsrc%2Fctx.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fctx.ts?ref=4414071074759dee637e0ce968805de63e60da7b", "patch": "@@ -5,7 +5,7 @@ import * as ra from './lsp_ext';\n import { Config } from './config';\n import { createClient } from './client';\n import { isRustEditor, RustEditor } from './util';\n-import { Status } from './lsp_ext';\n+import { ServerStatusParams } from './lsp_ext';\n \n export class Ctx {\n     private constructor(\n@@ -36,7 +36,7 @@ export class Ctx {\n \n         res.pushCleanup(client.start());\n         await client.onReady();\n-        client.onNotification(ra.status, (params) => res.setStatus(params.status));\n+        client.onNotification(ra.serverStatus, (params) => res.setServerStatus(params));\n         return res;\n     }\n \n@@ -66,39 +66,28 @@ export class Ctx {\n         return this.extCtx.subscriptions;\n     }\n \n-    setStatus(status: Status) {\n-        switch (status) {\n-            case \"loading\":\n-                this.statusBar.text = \"$(sync~spin) rust-analyzer\";\n-                this.statusBar.tooltip = \"Loading the project\";\n-                this.statusBar.command = undefined;\n+    setServerStatus(status: ServerStatusParams) {\n+        this.statusBar.tooltip = status.message ?? \"Ready\";\n+        let icon = \"\";\n+        switch (status.health) {\n+            case \"ok\":\n                 this.statusBar.color = undefined;\n                 break;\n-            case \"readyPartial\":\n-                this.statusBar.text = \"rust-analyzer\";\n-                this.statusBar.tooltip = \"Ready (Partial)\";\n-                this.statusBar.command = undefined;\n-                this.statusBar.color = undefined;\n-                break;\n-            case \"ready\":\n-                this.statusBar.text = \"rust-analyzer\";\n-                this.statusBar.tooltip = \"Ready\";\n-                this.statusBar.command = undefined;\n-                this.statusBar.color = undefined;\n-                break;\n-            case \"invalid\":\n-                this.statusBar.text = \"$(error) rust-analyzer\";\n-                this.statusBar.tooltip = \"Failed to load the project\";\n-                this.statusBar.command = undefined;\n-                this.statusBar.color = new vscode.ThemeColor(\"notificationsErrorIcon.foreground\");\n-                break;\n-            case \"needsReload\":\n-                this.statusBar.text = \"$(warning) rust-analyzer\";\n-                this.statusBar.tooltip = \"Click to reload\";\n+            case \"warning\":\n+                this.statusBar.tooltip += \"\\nClick to reload.\";\n                 this.statusBar.command = \"rust-analyzer.reloadWorkspace\";\n                 this.statusBar.color = new vscode.ThemeColor(\"notificationsWarningIcon.foreground\");\n+                icon = \"$(warning) \";\n+                break;\n+            case \"error\":\n+                this.statusBar.tooltip += \"\\nClick to reload.\";\n+                this.statusBar.command = \"rust-analyzer.reloadWorkspace\";\n+                this.statusBar.color = new vscode.ThemeColor(\"notificationsErrorIcon.foreground\");\n+                icon = \"$(error) \";\n                 break;\n         }\n+        if (!status.quiescent) icon = \"$(sync~spin) \";\n+        this.statusBar.text = `${icon} rust-analyzer`;\n     }\n \n     pushCleanup(d: Disposable) {"}, {"sha": "e453bb9e0bcf3b7a946abf3c400a4eef01788466", "filename": "editors/code/src/lsp_ext.ts", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4414071074759dee637e0ce968805de63e60da7b/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "raw_url": "https://github.com/rust-lang/rust/raw/4414071074759dee637e0ce968805de63e60da7b/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Flsp_ext.ts?ref=4414071074759dee637e0ce968805de63e60da7b", "patch": "@@ -10,11 +10,12 @@ export interface AnalyzerStatusParams {\n export const analyzerStatus = new lc.RequestType<AnalyzerStatusParams, string, void>(\"rust-analyzer/analyzerStatus\");\n export const memoryUsage = new lc.RequestType0<string, void>(\"rust-analyzer/memoryUsage\");\n \n-export type Status = \"loading\" | \"ready\" | \"readyPartial\" | \"invalid\" | \"needsReload\";\n-export interface StatusParams {\n-    status: Status;\n+export interface ServerStatusParams {\n+    health: \"ok\" | \"warning\" | \"error\";\n+    quiescent: boolean;\n+    message?: string;\n }\n-export const status = new lc.NotificationType<StatusParams>(\"rust-analyzer/status\");\n+export const serverStatus = new lc.NotificationType<ServerStatusParams>(\"experimental/serverStatus\");\n \n export const reloadWorkspace = new lc.RequestType0<null, void>(\"rust-analyzer/reloadWorkspace\");\n "}]}