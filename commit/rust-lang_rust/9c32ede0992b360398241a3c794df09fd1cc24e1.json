{"sha": "9c32ede0992b360398241a3c794df09fd1cc24e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljMzJlZGUwOTkyYjM2MDM5ODI0MWEzYzc5NGRmMDlmZDFjYzI0ZTE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-23T16:00:07Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-23T16:03:57Z"}, "message": "comment tweaks, better validation errors, update UI tests", "tree": {"sha": "a08442f262f8f59d42c08dcd496dedb5c27a9922", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a08442f262f8f59d42c08dcd496dedb5c27a9922"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c32ede0992b360398241a3c794df09fd1cc24e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c32ede0992b360398241a3c794df09fd1cc24e1", "html_url": "https://github.com/rust-lang/rust/commit/9c32ede0992b360398241a3c794df09fd1cc24e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c32ede0992b360398241a3c794df09fd1cc24e1/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42", "url": "https://api.github.com/repos/rust-lang/rust/commits/c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42", "html_url": "https://github.com/rust-lang/rust/commit/c12c8a78eaa0e2fccadbffde971fa9a39f7e7b42"}], "stats": {"total": 62, "additions": 36, "deletions": 26}, "files": [{"sha": "f9ab661ea87f92c39054150ed257c6cdda5b48cb", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9c32ede0992b360398241a3c794df09fd1cc24e1/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c32ede0992b360398241a3c794df09fd1cc24e1/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=9c32ede0992b360398241a3c794df09fd1cc24e1", "patch": "@@ -20,7 +20,6 @@ use super::{\n     Pointer, AllocId, Allocation, GlobalId, AllocationExtra,\n     InterpResult, Scalar, InterpError, GlobalAlloc, PointerArithmetic,\n     Machine, AllocMap, MayLeak, ErrorHandled, CheckInAllocMsg,\n-    InterpError::ValidationFailure,\n };\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n@@ -260,13 +259,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n \n     /// Check if the given scalar is allowed to do a memory access of given `size`\n-    /// and `align`.  On success, returns `None` for zero-sized accesses (where\n+    /// and `align`. On success, returns `None` for zero-sized accesses (where\n     /// nothing else is left to do) and a `Pointer` to use for the actual access otherwise.\n     /// Crucially, if the input is a `Pointer`, we will test it for liveness\n     /// *even of* the size is 0.\n     ///\n     /// Everyone accessing memory based on a `Scalar` should use this method to get the\n-    /// `Pointer` they need.  And even if you already have a `Pointer`, call this method\n+    /// `Pointer` they need. And even if you already have a `Pointer`, call this method\n     /// to make sure it is sufficiently aligned and not dangling.  Not doing that may\n     /// cause ICEs.\n     pub fn check_ptr_access(\n@@ -292,9 +291,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     return err!(InvalidNullPointerUsage);\n                 }\n                 if bits % align.bytes() != 0 {\n-                    let bits_pow1 = 1 << bits.trailing_zeros();\n+                    // The biggest power of two through which `bits` is divisible.\n+                    let bits_pow2 = 1 << bits.trailing_zeros();\n                     return err!(AlignmentCheckFailed {\n-                        has: Align::from_bytes(bits_pow1).unwrap(),\n+                        has: Align::from_bytes(bits_pow2).unwrap(),\n                         required: align,\n                     });\n                 }\n@@ -308,7 +308,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 // checks for overflow.\n                 let end_ptr = ptr.offset(size, self)?;\n                 end_ptr.check_in_alloc(allocation_size, CheckInAllocMsg::MemoryAccessTest)?;\n-                // Test align.  Check this last; if both bounds and alignment are violated\n+                // Test align. Check this last; if both bounds and alignment are violated\n                 // we want the error to be about the bounds.\n                 if alloc_align.bytes() < align.bytes() {\n                     // The allocation itself is not aligned enough.\n@@ -323,10 +323,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 }\n                 let offset = ptr.offset.bytes();\n                 if offset % align.bytes() != 0 {\n-                    // The offset os not aligned enough.\n-                    let has = offset % align.bytes();\n+                    // The biggest power of two through which `offset` is divisible.\n+                    let bits_pow2 = 1 << offset.trailing_zeros();\n                     return err!(AlignmentCheckFailed {\n-                        has: Align::from_bytes(has).unwrap(),\n+                        has: Align::from_bytes(bits_pow2).unwrap(),\n                         required: align,\n                     })\n                 }\n@@ -520,15 +520,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             }\n             _ => {\n                 if let Ok(alloc) = self.get(id) {\n-                    return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n+                    Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align))\n                 }\n-                if let AllocCheck::MaybeDead = liveness {\n+                else if let AllocCheck::MaybeDead = liveness {\n                     // Deallocated pointers are allowed, we should be able to find\n                     // them in the map.\n-                    self.dead_alloc_map.get(&id).copied().ok_or_else(||\n-                        ValidationFailure(\"allocation missing in dead_alloc_map\".to_string())\n-                            .into()\n-                    )\n+                    Ok(*self.dead_alloc_map.get(&id)\n+                        .expect(\"deallocated pointers should all be recorded in `dead_alloc_map`\"))\n                 } else {\n                     err!(DanglingPointerDeref)\n                 }"}, {"sha": "c72078fa89cd27e07bf0ec8c6a2bf265696b1138", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c32ede0992b360398241a3c794df09fd1cc24e1/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c32ede0992b360398241a3c794df09fd1cc24e1/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=9c32ede0992b360398241a3c794df09fd1cc24e1", "patch": "@@ -228,10 +228,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n \n         let ptr = match self.memory.check_ptr_access(ptr, mplace.layout.size, ptr_align)? {\n             Some(ptr) => ptr,\n-            None => return Ok(Some(ImmTy {\n+            None => return Ok(Some(ImmTy { // zero-sized type\n                 imm: Immediate::Scalar(Scalar::zst().into()),\n                 layout: mplace.layout,\n-            })), // zero-sized access\n+            })),\n         };\n \n         match mplace.layout.abi {"}, {"sha": "b2a159fef59c616341ca6a7e850edd638237664f", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9c32ede0992b360398241a3c794df09fd1cc24e1/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c32ede0992b360398241a3c794df09fd1cc24e1/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=9c32ede0992b360398241a3c794df09fd1cc24e1", "patch": "@@ -366,11 +366,15 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     match tail.sty {\n                         ty::Dynamic(..) => {\n                             let vtable = meta.unwrap();\n-                            try_validation!(self.ecx.memory.check_ptr_access(\n-                                vtable,\n-                                3*self.ecx.tcx.data_layout.pointer_size, // drop, size, align\n-                                self.ecx.tcx.data_layout.pointer_align.abi,\n-                            ), \"dangling or unaligned vtable pointer\", self.path);\n+                            try_validation!(\n+                                self.ecx.memory.check_ptr_access(\n+                                    vtable,\n+                                    3*self.ecx.tcx.data_layout.pointer_size, // drop, size, align\n+                                    self.ecx.tcx.data_layout.pointer_align.abi,\n+                                ),\n+                                \"dangling or unaligned vtable pointer or too small vtable\",\n+                                self.path\n+                            );\n                             try_validation!(self.ecx.read_drop_type_from_vtable(vtable),\n                                 \"invalid drop fn in vtable\", self.path);\n                             try_validation!(self.ecx.read_size_and_align_from_vtable(vtable),\n@@ -397,14 +401,22 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 let ptr: Option<_> = match self.ecx.memory.check_ptr_access(ptr, size, align) {\n                     Ok(ptr) => ptr,\n                     Err(err) => {\n-                        info!(\"{:?} is not aligned to {:?}\", ptr, align);\n+                        info!(\n+                            \"{:?} did not pass access check for size {:?}, align {:?}\",\n+                            ptr, size, align\n+                        );\n                         match err.kind {\n                             InterpError::InvalidNullPointerUsage =>\n                                 return validation_failure!(\"NULL reference\", self.path),\n                             InterpError::AlignmentCheckFailed { required, has } =>\n                                 return validation_failure!(format!(\"unaligned reference \\\n                                     (required {} byte alignment but found {})\",\n                                     required.bytes(), has.bytes()), self.path),\n+                            InterpError::ReadBytesAsPointer =>\n+                                return validation_failure!(\n+                                    \"integer pointer in non-ZST reference\",\n+                                    self.path\n+                                ),\n                             _ =>\n                                 return validation_failure!(\n                                     \"dangling (not entirely in bounds) reference\","}, {"sha": "19db90c1cb53e2ff0bd47e3f1b67b049be0cda16", "filename": "src/test/ui/consts/const-eval/union-ub-fat-ptr.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c32ede0992b360398241a3c794df09fd1cc24e1/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c32ede0992b360398241a3c794df09fd1cc24e1/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub-fat-ptr.stderr?ref=9c32ede0992b360398241a3c794df09fd1cc24e1", "patch": "@@ -42,23 +42,23 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/union-ub-fat-ptr.rs:97:1\n    |\n LL | const D: &dyn Trait = unsafe { DynTransmute { repr: DynRepr { ptr: &92, vtable: &3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop fn in vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/union-ub-fat-ptr.rs:100:1\n    |\n LL | const E: &dyn Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid drop fn in vtable\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/union-ub-fat-ptr.rs:103:1\n    |\n LL | const F: &dyn Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-pointer vtable in fat pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}]}