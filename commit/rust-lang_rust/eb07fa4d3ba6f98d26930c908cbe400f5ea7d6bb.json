{"sha": "eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViMDdmYTRkM2JhNmY5OGQyNjkzMGM5MDhjYmU0MDBmNWVhN2Q2YmI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-13T08:32:05Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-13T10:51:17Z"}, "message": "Remove all remaining uses of objs from the compiler", "tree": {"sha": "55932215575f8a632742603ac5e606a1dbe861f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55932215575f8a632742603ac5e606a1dbe861f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb", "html_url": "https://github.com/rust-lang/rust/commit/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f6294455963334fec69fc799442ae74ef65b35e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f6294455963334fec69fc799442ae74ef65b35e", "html_url": "https://github.com/rust-lang/rust/commit/7f6294455963334fec69fc799442ae74ef65b35e"}], "stats": {"total": 543, "additions": 271, "deletions": 272}, "files": [{"sha": "e16223178e7769eb62b560d8a609abccffc49796", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb", "patch": "@@ -545,15 +545,15 @@ fn mangle_internal_name_by_type_only(ccx: @crate_ctxt, t: ty::t, name: str) ->\n \n fn mangle_internal_name_by_path_and_seq(ccx: @crate_ctxt, path: [str],\n                                         flav: str) -> str {\n-    ret mangle(path + [ccx.names.next(flav)]);\n+    ret mangle(path + [ccx.names(flav)]);\n }\n \n fn mangle_internal_name_by_path(_ccx: @crate_ctxt, path: [str]) -> str {\n     ret mangle(path);\n }\n \n fn mangle_internal_name_by_seq(ccx: @crate_ctxt, flav: str) -> str {\n-    ret ccx.names.next(flav);\n+    ret ccx.names(flav);\n }\n \n // If the user wants an exe generated we need to invoke"}, {"sha": "e3d36e4ed5cc0fd3af0562f5b1f1642b93edd9ca", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb", "patch": "@@ -898,37 +898,27 @@ native mod llvm {\n \n /* Memory-managed object interface to type handles. */\n \n-obj type_names(type_names: std::map::hashmap<TypeRef, str>,\n-               named_types: std::map::hashmap<str, TypeRef>) {\n-\n-    fn associate(s: str, t: TypeRef) {\n-        assert (!named_types.contains_key(s));\n-        assert (!type_names.contains_key(t));\n-        type_names.insert(t, s);\n-        named_types.insert(s, t);\n-    }\n-\n-    fn type_has_name(t: TypeRef) -> bool { ret type_names.contains_key(t); }\n+type type_names = @{type_names: std::map::hashmap<TypeRef, str>,\n+                    named_types: std::map::hashmap<str, TypeRef>};\n \n-    fn get_name(t: TypeRef) -> str { ret type_names.get(t); }\n+fn associate_type(tn: type_names, s: str, t: TypeRef) {\n+    assert tn.type_names.insert(t, s);\n+    assert tn.named_types.insert(s, t);\n+}\n \n-    fn name_has_type(s: str) -> bool { ret named_types.contains_key(s); }\n+fn type_has_name(tn: type_names, t: TypeRef) -> option::t<str> {\n+    ret tn.type_names.find(t);\n+}\n \n-    fn get_type(s: str) -> TypeRef { ret named_types.get(s); }\n+fn name_has_type(tn: type_names, s: str) -> option::t<TypeRef> {\n+    ret tn.named_types.find(s);\n }\n \n fn mk_type_names() -> type_names {\n-    let nt = std::map::new_str_hash::<TypeRef>();\n-\n     fn hash(&&t: TypeRef) -> uint { ret t as uint; }\n-\n     fn eq(&&a: TypeRef, &&b: TypeRef) -> bool { ret a as uint == b as uint; }\n-\n-    let hasher: std::map::hashfn<TypeRef> = hash;\n-    let eqer: std::map::eqfn<TypeRef> = eq;\n-    let tn = std::map::mk_hashmap::<TypeRef, str>(hasher, eqer);\n-\n-    ret type_names(tn, nt);\n+    @{type_names: std::map::mk_hashmap(hash, eq),\n+      named_types: std::map::new_str_hash()}\n }\n \n fn type_to_str(names: type_names, ty: TypeRef) -> str {\n@@ -937,8 +927,10 @@ fn type_to_str(names: type_names, ty: TypeRef) -> str {\n \n fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n    str {\n-\n-    if names.type_has_name(ty) { ret names.get_name(ty); }\n+    alt type_has_name(names, ty) {\n+      option::some(n) { ret n; }\n+      _ {}\n+    }\n \n     let outer = outer0 + [ty];\n "}, {"sha": "fab7f625b0f8fb5356958e59b8c663f92a4d0264", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb", "patch": "@@ -394,7 +394,7 @@ fn create_record(cx: @crate_ctxt, t: ty::t, fields: [ast::ty_field],\n     let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname);\n     let scx = create_structure(file_node,\n-                               option::get(cx.dbg_cx).names.next(\"rec\"),\n+                               option::get(cx.dbg_cx).names(\"rec\"),\n                                line_from_span(cx.sess.codemap,\n                                               span) as int);\n     for field in fields {\n@@ -738,10 +738,10 @@ fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n       ast_map::node_expr(expr) {\n         alt expr.node {\n           ast::expr_fn(_, decl, _, _) {\n-            (dbg_cx.names.next(\"fn\"), decl.output, expr.id)\n+            (dbg_cx.names(\"fn\"), decl.output, expr.id)\n           }\n           ast::expr_fn_block(decl, _) {\n-            (dbg_cx.names.next(\"fn\"), decl.output, expr.id)\n+            (dbg_cx.names(\"fn\"), decl.output, expr.id)\n           }\n         }\n       }"}, {"sha": "38f9ec7813aff3bffc65f83a34ff0b2dfcdf9c08", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb", "patch": "@@ -4119,7 +4119,7 @@ fn new_block_ctxt(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n     let s = \"\";\n     if cx.lcx.ccx.sess.opts.save_temps ||\n            cx.lcx.ccx.sess.opts.debuginfo {\n-        s = cx.lcx.ccx.names.next(name);\n+        s = cx.lcx.ccx.names(name);\n     }\n     let llbb: BasicBlockRef =\n         str::as_buf(s, {|buf| llvm::LLVMAppendBasicBlock(cx.llfn, buf) });\n@@ -5665,13 +5665,13 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n     let float_type = T_float(targ_cfg);\n     let task_type = T_task(targ_cfg);\n     let taskptr_type = T_ptr(task_type);\n-    tn.associate(\"taskptr\", taskptr_type);\n+    lib::llvm::associate_type(tn, \"taskptr\", taskptr_type);\n     let tydesc_type = T_tydesc(targ_cfg);\n-    tn.associate(\"tydesc\", tydesc_type);\n+    lib::llvm::associate_type(tn, \"tydesc\", tydesc_type);\n     let crate_map = decl_crate_map(sess, link_meta.name, llmod);\n     let dbg_cx = if sess.opts.debuginfo {\n         option::some(@{llmetadata: map::new_int_hash(),\n-                       names: namegen(0)})\n+                       names: new_namegen()})\n     } else {\n         option::none\n     };\n@@ -5696,7 +5696,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           dicts: map::mk_hashmap(hash_dict_id, {|a, b| a == b}),\n           module_data: new_str_hash::<ValueRef>(),\n           lltypes: ty::new_ty_hash(),\n-          names: namegen(0),\n+          names: new_namegen(),\n           sha: sha,\n           type_sha1s: ty::new_ty_hash(),\n           type_short_names: ty::new_ty_hash(),"}, {"sha": "d4221ea2d2542914fbfd2226de8085ab876f2c80", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb", "patch": "@@ -507,7 +507,7 @@ fn trans_expr_fn(bcx: @block_ctxt,\n     let ccx = bcx_ccx(bcx), bcx = bcx;\n     let fty = node_id_type(ccx, id);\n     let llfnty = type_of_fn_from_ty(ccx, sp, fty, []);\n-    let sub_cx = extend_path(bcx.fcx.lcx, ccx.names.next(\"anon\"));\n+    let sub_cx = extend_path(bcx.fcx.lcx, ccx.names(\"anon\"));\n     let s = mangle_internal_name_by_path(ccx, sub_cx.path);\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n     register_fn(ccx, sp, sub_cx.path, \"anon fn\", [], id);"}, {"sha": "1073234923a372f3433c9157530d4bc731c27fcb", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb", "patch": "@@ -14,16 +14,19 @@ import middle::{resolve, ty};\n import back::{link, abi, upcall};\n import util::common::*;\n import syntax::codemap::span;\n-import lib::llvm::{llvm, target_data, type_names};\n+import lib::llvm::{llvm, target_data, type_names, associate_type,\n+                   name_has_type};\n import lib::llvm::llvm::{ModuleRef, ValueRef, TypeRef, BasicBlockRef};\n import lib::llvm::{True, False, Bool};\n import metadata::{csearch};\n \n // FIXME: These should probably be pulled in here too.\n import trans::{type_of_fn, drop_ty};\n \n-obj namegen(mutable i: int) {\n-    fn next(prefix: str) -> str { i += 1; ret prefix + int::str(i); }\n+type namegen = fn@(str) -> str;\n+fn new_namegen() -> namegen {\n+    let i = @mutable 0;\n+    ret fn@(prefix: str) -> str { *i += 1; prefix + int::str(*i) };\n }\n \n type derived_tydesc_info = {lltydesc: ValueRef, escapes: bool};\n@@ -616,17 +619,17 @@ fn T_tydesc_field(cx: @crate_ctxt, field: int) -> TypeRef unsafe {\n \n fn T_glue_fn(cx: @crate_ctxt) -> TypeRef {\n     let s = \"glue_fn\";\n-    if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n+    alt name_has_type(cx.tn, s) { some(t) { ret t; } _ {} }\n     let t = T_tydesc_field(cx, abi::tydesc_field_drop_glue);\n-    cx.tn.associate(s, t);\n+    associate_type(cx.tn, s, t);\n     ret t;\n }\n \n fn T_cmp_glue_fn(cx: @crate_ctxt) -> TypeRef {\n     let s = \"cmp_glue_fn\";\n-    if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n+    alt name_has_type(cx.tn, s) { some(t) { ret t; } _ {} }\n     let t = T_tydesc_field(cx, abi::tydesc_field_cmp_glue);\n-    cx.tn.associate(s, t);\n+    associate_type(cx.tn, s, t);\n     ret t;\n }\n \n@@ -691,23 +694,23 @@ fn T_taskptr(cx: @crate_ctxt) -> TypeRef { ret T_ptr(cx.task_type); }\n // This type must never be used directly; it must always be cast away.\n fn T_typaram(tn: type_names) -> TypeRef {\n     let s = \"typaram\";\n-    if tn.name_has_type(s) { ret tn.get_type(s); }\n+    alt name_has_type(tn, s) { some(t) { ret t; } _ {} }\n     let t = T_i8();\n-    tn.associate(s, t);\n+    associate_type(tn, s, t);\n     ret t;\n }\n \n fn T_typaram_ptr(tn: type_names) -> TypeRef { ret T_ptr(T_typaram(tn)); }\n \n fn T_opaque_cbox_ptr(cx: @crate_ctxt) -> TypeRef {\n     let s = \"*cbox\";\n-    if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n+    alt name_has_type(cx.tn, s) { some(t) { ret t; } _ {} }\n     let t = T_ptr(T_struct([cx.int_type,\n                             T_ptr(cx.tydesc_type),\n                             T_i8() /* represents closed over tydescs\n                             and data go here; see trans_closure.rs*/\n                            ]));\n-    cx.tn.associate(s, t);\n+    associate_type(cx.tn, s, t);\n     ret t;\n }\n \n@@ -717,20 +720,20 @@ fn T_tag_variant(cx: @crate_ctxt) -> TypeRef {\n \n fn T_tag(cx: @crate_ctxt, size: uint) -> TypeRef {\n     let s = \"tag_\" + uint::to_str(size, 10u);\n-    if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n+    alt name_has_type(cx.tn, s) { some(t) { ret t; } _ {} }\n     let t =\n         if size == 0u {\n             T_struct([T_tag_variant(cx)])\n         } else { T_struct([T_tag_variant(cx), T_array(T_i8(), size)]) };\n-    cx.tn.associate(s, t);\n+    associate_type(cx.tn, s, t);\n     ret t;\n }\n \n fn T_opaque_tag(cx: @crate_ctxt) -> TypeRef {\n     let s = \"opaque_tag\";\n-    if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n+    alt name_has_type(cx.tn, s) { some(t) { ret t; } _ {} }\n     let t = T_struct([T_tag_variant(cx), T_i8()]);\n-    cx.tn.associate(s, t);\n+    associate_type(cx.tn, s, t);\n     ret t;\n }\n \n@@ -818,7 +821,7 @@ fn C_cstr(cx: @crate_ctxt, s: str) -> ValueRef {\n                         llvm::LLVMConstString(buf, str::byte_len(s), False)\n                     });\n     let g =\n-        str::as_buf(cx.names.next(\"str\"),\n+        str::as_buf(cx.names(\"str\"),\n                     {|buf| llvm::LLVMAddGlobal(cx.llmod, val_ty(sc), buf) });\n     llvm::LLVMSetInitializer(g, sc);\n     llvm::LLVMSetGlobalConstant(g, True);\n@@ -865,11 +868,9 @@ fn C_bytes(bytes: [u8]) -> ValueRef unsafe {\n \n fn C_shape(ccx: @crate_ctxt, bytes: [u8]) -> ValueRef {\n     let llshape = C_bytes(bytes);\n-    let llglobal =\n-        str::as_buf(ccx.names.next(\"shape\"),\n-                    {|buf|\n-                        llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), buf)\n-                    });\n+    let llglobal = str::as_buf(ccx.names(\"shape\"), {|buf|\n+        llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), buf)\n+    });\n     llvm::LLVMSetInitializer(llglobal, llshape);\n     llvm::LLVMSetGlobalConstant(llglobal, True);\n     llvm::LLVMSetLinkage(llglobal,"}, {"sha": "55886df07d55d0453df9c05316f029138674fd0d", "filename": "src/comp/middle/trans_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs?ref=eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb", "patch": "@@ -340,7 +340,7 @@ fn get_static_dict(bcx: @block_ctxt, origin: typeck::dict_origin)\n       none. {}\n     }\n     let ptrs = C_struct(get_dict_ptrs(bcx, origin).ptrs);\n-    let name = ccx.names.next(\"dict\");\n+    let name = ccx.names(\"dict\");\n     let gvar = str::as_buf(name, {|buf|\n         llvm::LLVMAddGlobal(ccx.llmod, val_ty(ptrs), buf)\n     });"}, {"sha": "0dee29db0f9f94998963d2bd0b4e45ff06517a21", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 51, "deletions": 45, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb", "patch": "@@ -33,54 +33,60 @@ fn syntax_expander_table() -> hashmap<str, syntax_extension> {\n     ret syntax_expanders;\n }\n \n-obj ext_ctxt(sess: session,\n-             mutable backtrace: codemap::opt_span) {\n-\n-    fn session() -> session { ret sess; }\n-\n-    fn print_backtrace() { }\n-\n-    fn backtrace() -> codemap::opt_span { ret backtrace; }\n-\n-    fn bt_push(sp: span) {\n-        backtrace =\n-            codemap::os_some(@{lo: sp.lo,\n-                               hi: sp.hi,\n-                               expanded_from: backtrace});\n-    }\n-    fn bt_pop() {\n-        alt backtrace {\n-          codemap::os_some(@{expanded_from: pre, _}) {\n-            let tmp = pre;\n-            backtrace = tmp;\n-          }\n-          _ { self.bug(\"tried to pop without a push\"); }\n-        }\n-    }\n-\n-    fn span_fatal(sp: span, msg: str) -> ! {\n-        self.print_backtrace();\n-        sess.span_fatal(sp, msg);\n-    }\n-    fn span_err(sp: span, msg: str) {\n-        self.print_backtrace();\n-        sess.span_err(sp, msg);\n-    }\n-    fn span_unimpl(sp: span, msg: str) -> ! {\n-        self.print_backtrace();\n-        sess.span_unimpl(sp, msg);\n-    }\n-    fn span_bug(sp: span, msg: str) -> ! {\n-        self.print_backtrace();\n-        sess.span_bug(sp, msg);\n-    }\n-    fn bug(msg: str) -> ! { self.print_backtrace(); sess.bug(msg); }\n-    fn next_id() -> ast::node_id { ret sess.next_node_id(); }\n-\n+iface ext_ctxt {\n+    fn session() -> session;\n+    fn print_backtrace();\n+    fn backtrace() -> codemap::opt_span;\n+    fn bt_push(sp: span);\n+    fn bt_pop();\n+    fn span_fatal(sp: span, msg: str) -> !;\n+    fn span_err(sp: span, msg: str);\n+    fn span_unimpl(sp: span, msg: str) -> !;\n+    fn span_bug(sp: span, msg: str) -> !;\n+    fn bug(msg: str) -> !;\n+    fn next_id() -> ast::node_id;\n }\n \n fn mk_ctxt(sess: session) -> ext_ctxt {\n-    ret ext_ctxt(sess, codemap::os_none);\n+    type ctxt_repr = {sess: session,\n+                      mutable backtrace: codemap::opt_span};\n+    impl of ext_ctxt for ctxt_repr {\n+        fn session() -> session { self.sess }\n+        fn print_backtrace() { }\n+        fn backtrace() -> codemap::opt_span { self.backtrace }\n+        fn bt_push(sp: span) {\n+            self.backtrace = codemap::os_some(\n+                @{lo: sp.lo, hi: sp.hi, expanded_from: self.backtrace});\n+        }\n+        fn bt_pop() {\n+            alt self.backtrace {\n+              codemap::os_some(@{expanded_from: pre, _}) {\n+                let tmp = pre;\n+                self.backtrace = tmp;\n+              }\n+              _ { self.bug(\"tried to pop without a push\"); }\n+            }\n+        }\n+        fn span_fatal(sp: span, msg: str) -> ! {\n+            self.print_backtrace();\n+            self.sess.span_fatal(sp, msg);\n+        }\n+        fn span_err(sp: span, msg: str) {\n+            self.print_backtrace();\n+            self.sess.span_err(sp, msg);\n+        }\n+        fn span_unimpl(sp: span, msg: str) -> ! {\n+            self.print_backtrace();\n+            self.sess.span_unimpl(sp, msg);\n+        }\n+        fn span_bug(sp: span, msg: str) -> ! {\n+            self.print_backtrace();\n+            self.sess.span_bug(sp, msg);\n+        }\n+        fn bug(msg: str) -> ! { self.print_backtrace(); self.sess.bug(msg); }\n+        fn next_id() -> ast::node_id { ret self.sess.next_node_id(); }\n+    }\n+    {sess: sess, mutable backtrace: codemap::os_none} as ext_ctxt\n }\n \n fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, error: str) -> str {"}, {"sha": "eea0bfbcfecb99cf6d63050b02488f1e19cd0cc7", "filename": "src/comp/syntax/print/pp.rs", "status": "modified", "additions": 155, "deletions": 156, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb", "patch": "@@ -100,23 +100,28 @@ const size_infinity: int = 0xffff;\n fn mk_printer(out: io::writer, linewidth: uint) -> printer {\n     // Yes 3, it makes the ring buffers big enough to never\n     // fall behind.\n-\n     let n: uint = 3u * linewidth;\n     #debug(\"mk_printer %u\", linewidth);\n     let token: [mutable token] = vec::init_elt_mut(EOF, n);\n     let size: [mutable int] = vec::init_elt_mut(0, n);\n     let scan_stack: [mutable uint] = vec::init_elt_mut(0u, n);\n     let print_stack: [print_stack_elt] = [];\n-    ret printer(out, n, linewidth as int, // margin\n-                linewidth as int, // space\n-                0u, // left\n-                0u, // right\n-                token, size, 0, // left_total\n-                0, // right_total\n-                scan_stack, true, // scan_stack_empty\n-                0u, // top\n-                0u, // bottom\n-                print_stack, 0);\n+    @{out: out,\n+      buf_len: n,\n+      mutable margin: linewidth as int,\n+      mutable space: linewidth as int,\n+      mutable left: 0u,\n+      mutable right: 0u,\n+      mutable token: token,\n+      mutable size: size,\n+      mutable left_total: 0,\n+      mutable right_total: 0,\n+      mutable scan_stack: scan_stack,\n+      mutable scan_stack_empty: true,\n+      mutable top: 0u,\n+      mutable bottom: 0u,\n+      mutable print_stack: print_stack,\n+      mutable pending_indentation: 0}\n }\n \n \n@@ -197,262 +202,259 @@ fn mk_printer(out: io::writer, linewidth: uint) -> printer {\n  * the method called 'pretty_print', and the 'PRINT' process is the method\n  * called 'print'.\n  */\n-obj printer(out: io::writer,\n-            buf_len: uint,\n-            mutable margin: int, // width of lines we're constrained to\n-\n-            mutable space: int, // number of spaces left on line\n-\n-            mutable left: uint, // index of left side of input stream\n-\n-            mutable right: uint, // index of right side of input stream\n-\n-            mutable token: [mutable token],\n-\n-            // ring-buffr stream goes through\n-            mutable size: [mutable int], // ring-buffer of calculated sizes\n-\n-            mutable left_total: int, // running size of stream \"...left\"\n-\n-            mutable right_total: int, // running size of stream \"...right\"\n-\n-             // pseudo-stack, really a ring too. Holds the\n-             // primary-ring-buffers index of the BEGIN that started the\n-             // current block, possibly with the most recent BREAK after that\n-             // BEGIN (if there is any) on top of it. Stuff is flushed off the\n-             // bottom as it becomes irrelevant due to the primary ring-buffer\n-             // advancing.\n-             mutable scan_stack: [mutable uint],\n-            mutable scan_stack_empty: bool, // top==bottom disambiguator\n-\n-            mutable top: uint, // index of top of scan_stack\n-\n-            mutable bottom: uint, // index of bottom of scan_stack\n-\n-             // stack of blocks-in-progress being flushed by print\n-            mutable print_stack: [print_stack_elt],\n-\n-\n-            // buffered indentation to avoid writing trailing whitespace\n-            mutable pending_indentation: int) {\n-\n-    fn last_token() -> token { ret token[right]; }\n-\n+type printer = @{\n+    out: io::writer,\n+    buf_len: uint,\n+    mutable margin: int, // width of lines we're constrained to\n+    mutable space: int, // number of spaces left on line\n+    mutable left: uint, // index of left side of input stream\n+    mutable right: uint, // index of right side of input stream\n+    mutable token: [mutable token], // ring-buffr stream goes through\n+    mutable size: [mutable int], // ring-buffer of calculated sizes\n+    mutable left_total: int, // running size of stream \"...left\"\n+    mutable right_total: int, // running size of stream \"...right\"\n+    // pseudo-stack, really a ring too. Holds the\n+    // primary-ring-buffers index of the BEGIN that started the\n+    // current block, possibly with the most recent BREAK after that\n+    // BEGIN (if there is any) on top of it. Stuff is flushed off the\n+    // bottom as it becomes irrelevant due to the primary ring-buffer\n+    // advancing.\n+    mutable scan_stack: [mutable uint],\n+    mutable scan_stack_empty: bool, // top==bottom disambiguator\n+    mutable top: uint, // index of top of scan_stack\n+    mutable bottom: uint, // index of bottom of scan_stack\n+    // stack of blocks-in-progress being flushed by print\n+    mutable print_stack: [print_stack_elt],\n+    // buffered indentation to avoid writing trailing whitespace\n+    mutable pending_indentation: int\n+};\n+\n+impl printer for printer {\n+    fn last_token() -> token { self.token[self.right] }\n     // be very careful with this!\n-    fn replace_last_token(t: token) { token[right] = t; }\n-\n+    fn replace_last_token(t: token) { self.token[self.right] = t; }\n     fn pretty_print(t: token) {\n-        #debug(\"pp [%u,%u]\", left, right);\n+        #debug(\"pp [%u,%u]\", self.left, self.right);\n         alt t {\n           EOF. {\n-            if !scan_stack_empty {\n+            if !self.scan_stack_empty {\n                 self.check_stack(0);\n-                self.advance_left(token[left], size[left]);\n+                self.advance_left(self.token[self.left],\n+                                  self.size[self.left]);\n             }\n             self.indent(0);\n           }\n           BEGIN(b) {\n-            if scan_stack_empty {\n-                left_total = 1;\n-                right_total = 1;\n-                left = 0u;\n-                right = 0u;\n+            if self.scan_stack_empty {\n+                self.left_total = 1;\n+                self.right_total = 1;\n+                self.left = 0u;\n+                self.right = 0u;\n             } else { self.advance_right(); }\n-            #debug(\"pp BEGIN/buffer [%u,%u]\", left, right);\n-            token[right] = t;\n-            size[right] = -right_total;\n-            self.scan_push(right);\n+            #debug(\"pp BEGIN/buffer [%u,%u]\", self.left, self.right);\n+            self.token[self.right] = t;\n+            self.size[self.right] = -self.right_total;\n+            self.scan_push(self.right);\n           }\n           END. {\n-            if scan_stack_empty {\n-                #debug(\"pp END/print [%u,%u]\", left, right);\n+            if self.scan_stack_empty {\n+                #debug(\"pp END/print [%u,%u]\", self.left, self.right);\n                 self.print(t, 0);\n             } else {\n-                #debug(\"pp END/buffer [%u,%u]\", left, right);\n+                #debug(\"pp END/buffer [%u,%u]\", self.left, self.right);\n                 self.advance_right();\n-                token[right] = t;\n-                size[right] = -1;\n-                self.scan_push(right);\n+                self.token[self.right] = t;\n+                self.size[self.right] = -1;\n+                self.scan_push(self.right);\n             }\n           }\n           BREAK(b) {\n-            if scan_stack_empty {\n-                left_total = 1;\n-                right_total = 1;\n-                left = 0u;\n-                right = 0u;\n+            if self.scan_stack_empty {\n+                self.left_total = 1;\n+                self.right_total = 1;\n+                self.left = 0u;\n+                self.right = 0u;\n             } else { self.advance_right(); }\n-            #debug(\"pp BREAK/buffer [%u,%u]\", left, right);\n+            #debug(\"pp BREAK/buffer [%u,%u]\", self.left, self.right);\n             self.check_stack(0);\n-            self.scan_push(right);\n-            token[right] = t;\n-            size[right] = -right_total;\n-            right_total += b.blank_space;\n+            self.scan_push(self.right);\n+            self.token[self.right] = t;\n+            self.size[self.right] = -self.right_total;\n+            self.right_total += b.blank_space;\n           }\n           STRING(s, len) {\n-            if scan_stack_empty {\n-                #debug(\"pp STRING/print [%u,%u]\", left, right);\n+            if self.scan_stack_empty {\n+                #debug(\"pp STRING/print [%u,%u]\", self.left, self.right);\n                 self.print(t, len);\n             } else {\n-                #debug(\"pp STRING/buffer [%u,%u]\", left, right);\n+                #debug(\"pp STRING/buffer [%u,%u]\", self.left, self.right);\n                 self.advance_right();\n-                token[right] = t;\n-                size[right] = len;\n-                right_total += len;\n+                self.token[self.right] = t;\n+                self.size[self.right] = len;\n+                self.right_total += len;\n                 self.check_stream();\n             }\n           }\n         }\n     }\n     fn check_stream() {\n         #debug(\"check_stream [%u, %u] with left_total=%d, right_total=%d\",\n-               left, right, left_total, right_total);\n-        if right_total - left_total > space {\n+               self.left, self.right, self.left_total, self.right_total);\n+        if self.right_total - self.left_total > self.space {\n             #debug(\"scan window is %d, longer than space on line (%d)\",\n-                   right_total - left_total, space);\n-            if !scan_stack_empty {\n-                if left == scan_stack[bottom] {\n-                    #debug(\"setting %u to infinity and popping\", left);\n-                    size[self.scan_pop_bottom()] = size_infinity;\n+                   self.right_total - self.left_total, self.space);\n+            if !self.scan_stack_empty {\n+                if self.left == self.scan_stack[self.bottom] {\n+                    #debug(\"setting %u to infinity and popping\", self.left);\n+                    self.size[self.scan_pop_bottom()] = size_infinity;\n                 }\n             }\n-            self.advance_left(token[left], size[left]);\n-            if left != right { self.check_stream(); }\n+            self.advance_left(self.token[self.left], self.size[self.left]);\n+            if self.left != self.right { self.check_stream(); }\n         }\n     }\n     fn scan_push(x: uint) {\n         #debug(\"scan_push %u\", x);\n-        if scan_stack_empty {\n-            scan_stack_empty = false;\n-        } else { top += 1u; top %= buf_len; assert (top != bottom); }\n-        scan_stack[top] = x;\n+        if self.scan_stack_empty {\n+            self.scan_stack_empty = false;\n+        } else {\n+            self.top += 1u;\n+            self.top %= self.buf_len;\n+            assert (self.top != self.bottom);\n+        }\n+        self.scan_stack[self.top] = x;\n     }\n     fn scan_pop() -> uint {\n-        assert (!scan_stack_empty);\n-        let x = scan_stack[top];\n-        if top == bottom {\n-            scan_stack_empty = true;\n-        } else { top += buf_len - 1u; top %= buf_len; }\n+        assert (!self.scan_stack_empty);\n+        let x = self.scan_stack[self.top];\n+        if self.top == self.bottom {\n+            self.scan_stack_empty = true;\n+        } else { self.top += self.buf_len - 1u; self.top %= self.buf_len; }\n         ret x;\n     }\n-    fn scan_top() -> uint { assert (!scan_stack_empty); ret scan_stack[top]; }\n+    fn scan_top() -> uint {\n+        assert (!self.scan_stack_empty);\n+        ret self.scan_stack[self.top];\n+    }\n     fn scan_pop_bottom() -> uint {\n-        assert (!scan_stack_empty);\n-        let x = scan_stack[bottom];\n-        if top == bottom {\n-            scan_stack_empty = true;\n-        } else { bottom += 1u; bottom %= buf_len; }\n+        assert (!self.scan_stack_empty);\n+        let x = self.scan_stack[self.bottom];\n+        if self.top == self.bottom {\n+            self.scan_stack_empty = true;\n+        } else { self.bottom += 1u; self.bottom %= self.buf_len; }\n         ret x;\n     }\n     fn advance_right() {\n-        right += 1u;\n-        right %= buf_len;\n-        assert (right != left);\n+        self.right += 1u;\n+        self.right %= self.buf_len;\n+        assert (self.right != self.left);\n     }\n     fn advance_left(x: token, L: int) {\n-        #debug(\"advnce_left [%u,%u], sizeof(%u)=%d\", left, right, left, L);\n+        #debug(\"advnce_left [%u,%u], sizeof(%u)=%d\", self.left, self.right,\n+               self.left, L);\n         if L >= 0 {\n             self.print(x, L);\n             alt x {\n-              BREAK(b) { left_total += b.blank_space; }\n-              STRING(_, len) { assert (len == L); left_total += len; }\n+              BREAK(b) { self.left_total += b.blank_space; }\n+              STRING(_, len) { assert (len == L); self.left_total += len; }\n               _ { }\n             }\n-            if left != right {\n-                left += 1u;\n-                left %= buf_len;\n-                self.advance_left(token[left], size[left]);\n+            if self.left != self.right {\n+                self.left += 1u;\n+                self.left %= self.buf_len;\n+                self.advance_left(self.token[self.left],\n+                                  self.size[self.left]);\n             }\n         }\n     }\n     fn check_stack(k: int) {\n-        if !scan_stack_empty {\n+        if !self.scan_stack_empty {\n             let x = self.scan_top();\n-            alt token[x] {\n+            alt self.token[x] {\n               BEGIN(b) {\n                 if k > 0 {\n-                    size[self.scan_pop()] = size[x] + right_total;\n+                    self.size[self.scan_pop()] = self.size[x] +\n+                        self.right_total;\n                     self.check_stack(k - 1);\n                 }\n               }\n               END. {\n                 // paper says + not =, but that makes no sense.\n-\n-                size[self.scan_pop()] = 1;\n+                self.size[self.scan_pop()] = 1;\n                 self.check_stack(k + 1);\n               }\n               _ {\n-                size[self.scan_pop()] = size[x] + right_total;\n+                self.size[self.scan_pop()] = self.size[x] + self.right_total;\n                 if k > 0 { self.check_stack(k); }\n               }\n             }\n         }\n     }\n     fn print_newline(amount: int) {\n         #debug(\"NEWLINE %d\", amount);\n-        out.write_str(\"\\n\");\n-        pending_indentation = 0;\n+        self.out.write_str(\"\\n\");\n+        self.pending_indentation = 0;\n         self.indent(amount);\n     }\n     fn indent(amount: int) {\n         #debug(\"INDENT %d\", amount);\n-        pending_indentation += amount;\n+        self.pending_indentation += amount;\n     }\n-    fn top() -> print_stack_elt {\n-        let n = vec::len(print_stack);\n+    fn get_top() -> print_stack_elt {\n+        let n = vec::len(self.print_stack);\n         let top: print_stack_elt = {offset: 0, pbreak: broken(inconsistent)};\n-        if n != 0u { top = print_stack[n - 1u]; }\n+        if n != 0u { top = self.print_stack[n - 1u]; }\n         ret top;\n     }\n     fn write_str(s: str) {\n-        while pending_indentation > 0 {\n-            out.write_str(\" \");\n-            pending_indentation -= 1;\n+        while self.pending_indentation > 0 {\n+            self.out.write_str(\" \");\n+            self.pending_indentation -= 1;\n         }\n-        out.write_str(s);\n+        self.out.write_str(s);\n     }\n     fn print(x: token, L: int) {\n         #debug(\"print %s %d (remaining line space=%d)\", tok_str(x), L,\n-               space);\n-        log(debug, buf_str(token, size, left, right, 6u));\n+               self.space);\n+        log(debug, buf_str(self.token, self.size, self.left, self.right, 6u));\n         alt x {\n           BEGIN(b) {\n-            if L > space {\n-                let col = margin - space + b.offset;\n+            if L > self.space {\n+                let col = self.margin - self.space + b.offset;\n                 #debug(\"print BEGIN -> push broken block at col %d\", col);\n-                print_stack += [{offset: col, pbreak: broken(b.breaks)}];\n+                self.print_stack += [{offset: col, pbreak: broken(b.breaks)}];\n             } else {\n                 #debug(\"print BEGIN -> push fitting block\");\n-                print_stack += [{offset: 0, pbreak: fits}];\n+                self.print_stack += [{offset: 0, pbreak: fits}];\n             }\n           }\n           END. {\n             #debug(\"print END -> pop END\");\n-            assert (vec::len(print_stack) != 0u);\n-            vec::pop(print_stack);\n+            assert (vec::len(self.print_stack) != 0u);\n+            vec::pop(self.print_stack);\n           }\n           BREAK(b) {\n-            let top = self.top();\n+            let top = self.get_top();\n             alt top.pbreak {\n               fits. {\n                 #debug(\"print BREAK in fitting block\");\n-                space -= b.blank_space;\n+                self.space -= b.blank_space;\n                 self.indent(b.blank_space);\n               }\n               broken(consistent.) {\n                 #debug(\"print BREAK in consistent block\");\n                 self.print_newline(top.offset + b.offset);\n-                space = margin - (top.offset + b.offset);\n+                self.space = self.margin - (top.offset + b.offset);\n               }\n               broken(inconsistent.) {\n-                if L > space {\n+                if L > self.space {\n                     #debug(\"print BREAK w/ newline in inconsistent\");\n                     self.print_newline(top.offset + b.offset);\n-                    space = margin - (top.offset + b.offset);\n+                    self.space = self.margin - (top.offset + b.offset);\n                 } else {\n                     #debug(\"print BREAK w/o newline in inconsistent\");\n                     self.indent(b.blank_space);\n-                    space -= b.blank_space;\n+                    self.space -= b.blank_space;\n                 }\n               }\n             }\n@@ -461,20 +463,17 @@ obj printer(out: io::writer,\n             #debug(\"print STRING\");\n             assert (L == len);\n             // assert L <= space;\n-\n-            space -= len;\n+            self.space -= len;\n             self.write_str(s);\n           }\n           EOF. {\n             // EOF should never get here.\n-\n             fail;\n           }\n         }\n     }\n }\n \n-\n // Convenience functions to talk to the printer.\n fn box(p: printer, indent: uint, b: breaks) {\n     p.pretty_print(BEGIN({offset: indent as int, breaks: b}));"}, {"sha": "50fb51986feb3383d9ac1baad44c8677408c1cd3", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb", "patch": "@@ -6,7 +6,7 @@ import syntax::codemap::codemap;\n import ast;\n import ast_util;\n import option::{some, none};\n-import pp::{break_offset, word,\n+import pp::{break_offset, word, printer,\n             space, zerobreak, hardbreak, breaks, consistent,\n             inconsistent, eof};\n "}, {"sha": "7aceaf1ef1a463404670de87ca1455938efe4de7", "filename": "src/comp/util/filesearch.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Futil%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb/src%2Fcomp%2Futil%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ffilesearch.rs?ref=eb07fa4d3ba6f98d26930c908cbe400f5ea7d6bb", "patch": "@@ -24,41 +24,42 @@ fn pick_file(file: fs::path, path: fs::path) -> option::t<fs::path> {\n     else { option::none }\n }\n \n-type filesearch = obj {\n+iface filesearch {\n     fn sysroot() -> fs::path;\n     fn lib_search_paths() -> [fs::path];\n     fn get_target_lib_path() -> fs::path;\n     fn get_target_lib_file_path(file: fs::path) -> fs::path;\n-};\n+}\n \n fn mk_filesearch(maybe_sysroot: option::t<fs::path>,\n                  target_triple: str,\n                  addl_lib_search_paths: [fs::path]) -> filesearch {\n-    obj filesearch_impl(sysroot: fs::path,\n-                        addl_lib_search_paths: [fs::path],\n-                        target_triple: str) {\n-        fn sysroot() -> fs::path { sysroot }\n+    type filesearch_impl = {sysroot: fs::path,\n+                            addl_lib_search_paths: [fs::path],\n+                            target_triple: str};\n+    impl of filesearch for filesearch_impl {\n+        fn sysroot() -> fs::path { self.sysroot }\n         fn lib_search_paths() -> [fs::path] {\n-            addl_lib_search_paths\n-                + [make_target_lib_path(sysroot, target_triple)]\n+            self.addl_lib_search_paths\n+                + [make_target_lib_path(self.sysroot, self.target_triple)]\n                 + alt get_cargo_lib_path() {\n                   result::ok(p) { [p] }\n                   result::err(p) { [] }\n                 }\n         }\n-\n         fn get_target_lib_path() -> fs::path {\n-            make_target_lib_path(sysroot, target_triple)\n+            make_target_lib_path(self.sysroot, self.target_triple)\n         }\n-\n         fn get_target_lib_file_path(file: fs::path) -> fs::path {\n             fs::connect(self.get_target_lib_path(), file)\n         }\n     }\n \n     let sysroot = get_sysroot(maybe_sysroot);\n     #debug(\"using sysroot = %s\", sysroot);\n-    ret filesearch_impl(sysroot, addl_lib_search_paths, target_triple);\n+    {sysroot: sysroot,\n+     addl_lib_search_paths: addl_lib_search_paths,\n+     target_triple: target_triple} as filesearch\n }\n \n // FIXME #1001: This can't be an obj method"}]}