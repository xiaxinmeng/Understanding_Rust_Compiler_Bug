{"sha": "588f7db8ef588ea7e349817bb44b4e37bfd92745", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4OGY3ZGI4ZWY1ODhlYTdlMzQ5ODE3YmI0NGI0ZTM3YmZkOTI3NDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-20T03:58:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-20T03:58:15Z"}, "message": "Auto merge of #46733 - nikomatsakis:nll-master-to-rust-master-5, r=arielb1\n\nnll part 5\n\nNext round of changes from the nll-master branch.\n\nExtensions:\n\n- we now propagate ty-region-outlives constraints out of closures and into their creator when necessary\n- we fix a few ICEs that can occur by doing liveness analysis (and the resulting normalization) during type-checking\n- we handle the implicit region bound that assumes that each type `T` outlives the fn body\n- we handle normalization of inputs/outputs in fn signatures\n\nNot included in this PR (will come next):\n\n- handling `impl Trait`\n- tracking causal information\n- extended errors\n\nr? @arielb1", "tree": {"sha": "8f533a5308ce9b27e5cbc37d2db8632f786e433a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f533a5308ce9b27e5cbc37d2db8632f786e433a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/588f7db8ef588ea7e349817bb44b4e37bfd92745", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/588f7db8ef588ea7e349817bb44b4e37bfd92745", "html_url": "https://github.com/rust-lang/rust/commit/588f7db8ef588ea7e349817bb44b4e37bfd92745", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/588f7db8ef588ea7e349817bb44b4e37bfd92745/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edbd7d232ee1272285be332b8a38eb47b4c8f5c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/edbd7d232ee1272285be332b8a38eb47b4c8f5c6", "html_url": "https://github.com/rust-lang/rust/commit/edbd7d232ee1272285be332b8a38eb47b4c8f5c6"}, {"sha": "1816ede386c6dd6e61f50e7b0f9bdba19adc0e24", "url": "https://api.github.com/repos/rust-lang/rust/commits/1816ede386c6dd6e61f50e7b0f9bdba19adc0e24", "html_url": "https://github.com/rust-lang/rust/commit/1816ede386c6dd6e61f50e7b0f9bdba19adc0e24"}], "stats": {"total": 4703, "additions": 4057, "deletions": 646}, "files": [{"sha": "df67c3abbe86c79fe293f9a425ffb8d706e50951", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -536,14 +536,29 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Literal<'gcx> {\n \n impl_stable_hash_for!(struct mir::Location { block, statement_index });\n \n-impl_stable_hash_for!(struct mir::ClosureRegionRequirements {\n+impl_stable_hash_for!(struct mir::ClosureRegionRequirements<'tcx> {\n     num_external_vids,\n     outlives_requirements\n });\n \n-impl_stable_hash_for!(struct mir::ClosureOutlivesRequirement {\n-    free_region,\n+impl_stable_hash_for!(struct mir::ClosureOutlivesRequirement<'tcx> {\n+    subject,\n     outlived_free_region,\n     blame_span\n });\n \n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::ClosureOutlivesSubject<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            mir::ClosureOutlivesSubject::Ty(ref ty) => {\n+                ty.hash_stable(hcx, hasher);\n+            }\n+            mir::ClosureOutlivesSubject::Region(ref region) => {\n+                region.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}"}, {"sha": "ea3a1074aa2698b140f4020f7eeeff5a192f697a", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -75,6 +75,9 @@ for ty::RegionKind {\n             ty::ReFree(ref free_region) => {\n                 free_region.hash_stable(hcx, hasher);\n             }\n+            ty::ReClosureBound(vid) => {\n+                vid.hash_stable(hcx, hasher);\n+            }\n             ty::ReLateBound(..) |\n             ty::ReVar(..) |\n             ty::ReSkolemized(..) => {"}, {"sha": "f7bc092a3d7ae7b3351e9231c02556263faaf560", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -475,6 +475,14 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                     ty::Bivariant | ty::Covariant | ty::Contravariant => (),\n                 }\n             }\n+\n+            ty::ReClosureBound(..) => {\n+                span_bug!(\n+                    self.span,\n+                    \"encountered unexpected ReClosureBound: {:?}\",\n+                    r,\n+                );\n+            }\n         }\n \n         // FIXME: This is non-ideal because we don't give a"}, {"sha": "3e3aea0256e72e4ef816053900d888fd95e2e81b", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -240,6 +240,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ty::ReErased => {\n                 (format!(\"lifetime {:?}\", region), None)\n             }\n+\n+            // We shouldn't encounter an error message with ReClosureBound.\n+            ty::ReClosureBound(..) => {\n+                bug!(\n+                    \"encountered unexpected ReClosureBound: {:?}\",\n+                    region,\n+                );\n+            }\n         };\n         let message = format!(\"{}{}{}\", prefix, description, suffix);\n         if let Some(span) = span {"}, {"sha": "1783d5abfc7c6b5cabb3edb86adac499a7c4d305", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -113,6 +113,13 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n                 // replace all free regions with 'erased\n                 self.tcx().types.re_erased\n             }\n+\n+            ty::ReClosureBound(..) => {\n+                bug!(\n+                    \"encountered unexpected ReClosureBound: {:?}\",\n+                    r,\n+                );\n+            }\n         }\n     }\n "}, {"sha": "3ac4ec5bee41644390a3e5349096bedb702850bd", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -258,7 +258,12 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n         let tcx = self.region_rels.tcx;\n         match (a, b) {\n-            (&ReLateBound(..), _) | (_, &ReLateBound(..)) | (&ReErased, _) | (_, &ReErased) => {\n+            (&ty::ReClosureBound(..), _) |\n+            (_, &ty::ReClosureBound(..)) |\n+            (&ReLateBound(..), _) |\n+            (_, &ReLateBound(..)) |\n+            (&ReErased, _) |\n+            (_, &ReErased) => {\n                 bug!(\"cannot relate region: LUB({:?}, {:?})\", a, b);\n             }\n "}, {"sha": "efde224c3e1209fda613f2b4a68fb7b1514a7c49", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -1832,8 +1832,17 @@ pub struct GeneratorLayout<'tcx> {\n /// instance of the closure is created, the corresponding free regions\n /// can be extracted from its type and constrained to have the given\n /// outlives relationship.\n+///\n+/// In some cases, we have to record outlives requirements between\n+/// types and regions as well. In that case, if those types include\n+/// any regions, those regions are recorded as `ReClosureBound`\n+/// instances assigned one of these same indices. Those regions will\n+/// be substituted away by the creator. We use `ReClosureBound` in\n+/// that case because the regions must be allocated in the global\n+/// TyCtxt, and hence we cannot use `ReVar` (which is what we use\n+/// internally within the rest of the NLL code).\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub struct ClosureRegionRequirements {\n+pub struct ClosureRegionRequirements<'gcx> {\n     /// The number of external regions defined on the closure.  In our\n     /// example above, it would be 3 -- one for `'static`, then `'1`\n     /// and `'2`. This is just used for a sanity check later on, to\n@@ -1843,15 +1852,15 @@ pub struct ClosureRegionRequirements {\n \n     /// Requirements between the various free regions defined in\n     /// indices.\n-    pub outlives_requirements: Vec<ClosureOutlivesRequirement>,\n+    pub outlives_requirements: Vec<ClosureOutlivesRequirement<'gcx>>,\n }\n \n-/// Indicates an outlives constraint between two free-regions declared\n-/// on the closure.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n-pub struct ClosureOutlivesRequirement {\n-    // This region ...\n-    pub free_region: ty::RegionVid,\n+/// Indicates an outlives constraint between a type or between two\n+/// free-regions declared on the closure.\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub struct ClosureOutlivesRequirement<'tcx> {\n+    // This region or type ...\n+    pub subject: ClosureOutlivesSubject<'tcx>,\n \n     // .. must outlive this one.\n     pub outlived_free_region: ty::RegionVid,\n@@ -1860,6 +1869,23 @@ pub struct ClosureOutlivesRequirement {\n     pub blame_span: Span,\n }\n \n+/// The subject of a ClosureOutlivesRequirement -- that is, the thing\n+/// that must outlive some region.\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub enum ClosureOutlivesSubject<'tcx> {\n+    /// Subject is a type, typically a type parameter, but could also\n+    /// be a projection. Indicates a requirement like `T: 'a` being\n+    /// passed to the caller, where the type here is `T`.\n+    ///\n+    /// The type here is guaranteed not to contain any free regions at\n+    /// present.\n+    Ty(Ty<'tcx>),\n+\n+    /// Subject is a free region from the closure. Indicates a requirement\n+    /// like `'a: 'b` being passed to the caller; the region here is `'a`.\n+    Region(ty::RegionVid),\n+}\n+\n /*\n  * TypeFoldable implementations for MIR types\n  */"}, {"sha": "c5b82730e488c8afea49fdb1344d08e44a93077c", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -97,14 +97,19 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn has_closure_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_CLOSURE)\n     }\n+    /// \"Free\" regions in this context means that it has any region\n+    /// that is not (a) erased or (b) late-bound.\n+    fn has_free_regions(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n+    }\n+\n+    /// True if there any any un-erased free regions.\n     fn has_erasable_regions(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_RE_EARLY_BOUND |\n-                            TypeFlags::HAS_RE_INFER |\n-                            TypeFlags::HAS_FREE_REGIONS)\n+        self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n     }\n+\n     fn is_normalized_for_trans(&self) -> bool {\n-        !self.has_type_flags(TypeFlags::HAS_RE_EARLY_BOUND |\n-                             TypeFlags::HAS_RE_INFER |\n+        !self.has_type_flags(TypeFlags::HAS_RE_INFER |\n                              TypeFlags::HAS_FREE_REGIONS |\n                              TypeFlags::HAS_TY_INFER |\n                              TypeFlags::HAS_PARAMS |"}, {"sha": "23531b7b942f58873977624d17654cf40b0d8564", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -193,7 +193,7 @@ define_maps! { <'tcx>\n \n     /// Borrow checks the function body. If this is a closure, returns\n     /// additional requirements that the closure's creator must verify.\n-    [] fn mir_borrowck: MirBorrowCheck(DefId) -> Option<mir::ClosureRegionRequirements>,\n+    [] fn mir_borrowck: MirBorrowCheck(DefId) -> Option<mir::ClosureRegionRequirements<'tcx>>,\n \n     /// Gets a complete map from all types to their inherent impls.\n     /// Not meant to be used directly outside of coherence."}, {"sha": "3ab322b55c777b6545d25ce7ebb8baef4ee0b687", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -421,8 +421,18 @@ bitflags! {\n         const HAS_TY_INFER       = 1 << 2;\n         const HAS_RE_INFER       = 1 << 3;\n         const HAS_RE_SKOL        = 1 << 4;\n+\n+        /// Does this have any `ReEarlyBound` regions? Used to\n+        /// determine whether substitition is required, since those\n+        /// represent regions that are bound in a `ty::Generics` and\n+        /// hence may be substituted.\n         const HAS_RE_EARLY_BOUND = 1 << 5;\n+\n+        /// Does this have any region that \"appears free\" in the type?\n+        /// Basically anything but `ReLateBound` and `ReErased`.\n         const HAS_FREE_REGIONS   = 1 << 6;\n+\n+        /// Is an error type reachable?\n         const HAS_TY_ERR         = 1 << 7;\n         const HAS_PROJECTION     = 1 << 8;\n "}, {"sha": "02729c6d60084081689edd0d5e9b45e816f8f086", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -1036,6 +1036,12 @@ pub enum RegionKind {\n \n     /// Erased region, used by trait selection, in MIR and during trans.\n     ReErased,\n+\n+    /// These are regions bound in the \"defining type\" for a\n+    /// closure. They are used ONLY as part of the\n+    /// `ClosureRegionRequirements` that are produced by MIR borrowck.\n+    /// See `ClosureRegionRequirements` for more details.\n+    ReClosureBound(RegionVid),\n }\n \n impl<'tcx> serialize::UseSpecializedDecodable for Region<'tcx> {}\n@@ -1184,18 +1190,32 @@ impl RegionKind {\n \n         match *self {\n             ty::ReVar(..) => {\n+                flags = flags | TypeFlags::HAS_FREE_REGIONS;\n                 flags = flags | TypeFlags::HAS_RE_INFER;\n                 flags = flags | TypeFlags::KEEP_IN_LOCAL_TCX;\n             }\n             ty::ReSkolemized(..) => {\n+                flags = flags | TypeFlags::HAS_FREE_REGIONS;\n                 flags = flags | TypeFlags::HAS_RE_INFER;\n                 flags = flags | TypeFlags::HAS_RE_SKOL;\n                 flags = flags | TypeFlags::KEEP_IN_LOCAL_TCX;\n             }\n             ty::ReLateBound(..) => { }\n-            ty::ReEarlyBound(..) => { flags = flags | TypeFlags::HAS_RE_EARLY_BOUND; }\n-            ty::ReStatic | ty::ReErased => { }\n-            _ => { flags = flags | TypeFlags::HAS_FREE_REGIONS; }\n+            ty::ReEarlyBound(..) => {\n+                flags = flags | TypeFlags::HAS_FREE_REGIONS;\n+                flags = flags | TypeFlags::HAS_RE_EARLY_BOUND;\n+            }\n+            ty::ReEmpty |\n+            ty::ReStatic |\n+            ty::ReFree { .. } |\n+            ty::ReScope { .. } => {\n+                flags = flags | TypeFlags::HAS_FREE_REGIONS;\n+            }\n+            ty::ReErased => {\n+            }\n+            ty::ReClosureBound(..) => {\n+                flags = flags | TypeFlags::HAS_FREE_REGIONS;\n+            }\n         }\n \n         match *self {"}, {"sha": "9b930233fad8e9cdd89dee9ed3d989f76e6be417", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -822,6 +822,8 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n             ty::ReEarlyBound(ty::EarlyBoundRegion { def_id, .. }) => {\n                 self.def_id(def_id);\n             }\n+\n+            ty::ReClosureBound(..) |\n             ty::ReLateBound(..) |\n             ty::ReFree(..) |\n             ty::ReScope(..) |"}, {"sha": "5bfa646456857b2f88436841ff052c3278b6bc5f", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -733,6 +733,9 @@ define_print! {\n                 ty::ReErased => Ok(()),\n                 ty::ReStatic => write!(f, \"'static\"),\n                 ty::ReEmpty => write!(f, \"'<empty>\"),\n+\n+                // The user should never encounter these in unsubstituted form.\n+                ty::ReClosureBound(vid) => write!(f, \"{:?}\", vid),\n             }\n         }\n         debug {\n@@ -743,6 +746,11 @@ define_print! {\n                            data.name)\n                 }\n \n+                ty::ReClosureBound(ref vid) => {\n+                    write!(f, \"ReClosureBound({:?})\",\n+                           vid)\n+                }\n+\n                 ty::ReLateBound(binder_id, ref bound_region) => {\n                     write!(f, \"ReLateBound({:?}, {:?})\",\n                            binder_id,"}, {"sha": "5cbe2822e5c038ed33f5192d7ac19802bf384b43", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -367,6 +367,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                     ty::ReStatic => self.item_ub,\n \n                     ty::ReEmpty |\n+                    ty::ReClosureBound(..) |\n                     ty::ReLateBound(..) |\n                     ty::ReVar(..) |\n                     ty::ReSkolemized(..) |"}, {"sha": "c144962fb2d88639d6e702a7c554b28839204d7a", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -381,6 +381,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             },\n             (RegionKind::ReLateBound(_, _), _) |\n             (RegionKind::ReSkolemized(_, _), _) |\n+            (RegionKind::ReClosureBound(_), _) |\n             (RegionKind::ReErased, _) => {\n                 span_bug!(drop_span, \"region does not make sense in this context\");\n             },"}, {"sha": "e0b03aec69a3b3368404a1542948b3babd45834a", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -22,16 +22,16 @@ use rustc::mir::{Field, Statement, StatementKind, Terminator, TerminatorKind};\n use rustc::mir::ClosureRegionRequirements;\n \n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::indexed_set::{IdxSetBuf};\n+use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n \n use syntax::ast;\n use syntax_pos::Span;\n \n use dataflow::{do_dataflow, DebugFormatted};\n+use dataflow::FlowAtLocation;\n use dataflow::MoveDataParamEnv;\n use dataflow::{DataflowAnalysis, DataflowResultsConsumer};\n-use dataflow::{FlowAtLocation, FlowsAtLocation};\n use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use dataflow::{EverInitializedLvals, MovingOutStatements};\n use dataflow::{Borrows, BorrowData, ReserveOrActivateIndex};\n@@ -65,7 +65,7 @@ pub fn provide(providers: &mut Providers) {\n fn mir_borrowck<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n-) -> Option<ClosureRegionRequirements> {\n+) -> Option<ClosureRegionRequirements<'tcx>> {\n     let input_mir = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.item_path_str(def_id));\n \n@@ -89,7 +89,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     input_mir: &Mir<'gcx>,\n     def_id: DefId,\n-) -> Option<ClosureRegionRequirements> {\n+) -> Option<ClosureRegionRequirements<'gcx>> {\n     let tcx = infcx.tcx;\n     let attributes = tcx.get_attrs(def_id);\n     let param_env = tcx.param_env(def_id);"}, {"sha": "673e85e6b61cd23c7ce27d77b6a205c45f40ecf0", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 2, "deletions": 171, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -12,41 +12,25 @@ use rustc::hir;\n use rustc::mir::{BasicBlock, BasicBlockData, Location, Place, Mir, Rvalue};\n use rustc::mir::visit::Visitor;\n use rustc::mir::Place::Projection;\n-use rustc::mir::{Local, PlaceProjection, ProjectionElem};\n+use rustc::mir::{PlaceProjection, ProjectionElem};\n use rustc::mir::visit::TyContext;\n use rustc::infer::InferCtxt;\n-use rustc::traits::{self, ObligationCause};\n-use rustc::ty::{self, ClosureSubsts, Ty};\n+use rustc::ty::{self, ClosureSubsts};\n use rustc::ty::subst::Substs;\n use rustc::ty::fold::TypeFoldable;\n-use rustc::util::common::ErrorReported;\n-use rustc_data_structures::fx::FxHashSet;\n-use syntax::codemap::DUMMY_SP;\n-use borrow_check::{FlowAtLocation, FlowsAtLocation};\n-use dataflow::MaybeInitializedLvals;\n-use dataflow::move_paths::{HasMoveData, MoveData};\n \n-use super::LivenessResults;\n use super::ToRegionVid;\n use super::region_infer::RegionInferenceContext;\n \n pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n     regioncx: &mut RegionInferenceContext<'tcx>,\n     mir: &Mir<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    liveness: &LivenessResults,\n-    flow_inits: &mut FlowAtLocation<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n-    move_data: &MoveData<'tcx>,\n ) {\n     let mut cg = ConstraintGeneration {\n         infcx,\n         regioncx,\n         mir,\n-        liveness,\n-        param_env,\n-        flow_inits,\n-        move_data,\n     };\n \n     for (bb, data) in mir.basic_blocks().iter_enumerated() {\n@@ -59,16 +43,10 @@ struct ConstraintGeneration<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> {\n     infcx: &'cg InferCtxt<'cx, 'gcx, 'tcx>,\n     regioncx: &'cg mut RegionInferenceContext<'tcx>,\n     mir: &'cg Mir<'tcx>,\n-    liveness: &'cg LivenessResults,\n-    param_env: ty::ParamEnv<'tcx>,\n-    flow_inits: &'cg mut FlowAtLocation<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n-    move_data: &'cg MoveData<'tcx>,\n }\n \n-\n impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx, 'tcx> {\n     fn visit_basic_block_data(&mut self, bb: BasicBlock, data: &BasicBlockData<'tcx>) {\n-        self.add_liveness_constraints(bb);\n         self.super_basic_block_data(bb, data);\n     }\n \n@@ -130,84 +108,6 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n }\n \n impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n-    /// Liveness constraints:\n-    ///\n-    /// > If a variable V is live at point P, then all regions R in the type of V\n-    /// > must include the point P.\n-    fn add_liveness_constraints(&mut self, bb: BasicBlock) {\n-        debug!(\"add_liveness_constraints(bb={:?})\", bb);\n-\n-        self.liveness\n-            .regular\n-            .simulate_block(self.mir, bb, |location, live_locals| {\n-                for live_local in live_locals.iter() {\n-                    let live_local_ty = self.mir.local_decls[live_local].ty;\n-                    self.add_regular_live_constraint(live_local_ty, location);\n-                }\n-            });\n-\n-        let mut all_live_locals: Vec<(Location, Vec<Local>)> = vec![];\n-        self.liveness\n-            .drop\n-            .simulate_block(self.mir, bb, |location, live_locals| {\n-                all_live_locals.push((location, live_locals.iter().collect()));\n-            });\n-        debug!(\n-            \"add_liveness_constraints: all_live_locals={:#?}\",\n-            all_live_locals\n-        );\n-\n-        let terminator_index = self.mir.basic_blocks()[bb].statements.len();\n-        self.flow_inits.reset_to_entry_of(bb);\n-        while let Some((location, live_locals)) = all_live_locals.pop() {\n-            for live_local in live_locals {\n-                debug!(\n-                    \"add_liveness_constraints: location={:?} live_local={:?}\",\n-                    location,\n-                    live_local\n-                );\n-\n-                self.flow_inits.each_state_bit(|mpi_init| {\n-                    debug!(\n-                        \"add_liveness_constraints: location={:?} initialized={:?}\",\n-                        location,\n-                        &self.flow_inits\n-                            .operator()\n-                            .move_data()\n-                            .move_paths[mpi_init]\n-                    );\n-                });\n-\n-                let mpi = self.move_data.rev_lookup.find_local(live_local);\n-                if let Some(initialized_child) = self.flow_inits.has_any_child_of(mpi) {\n-                    debug!(\n-                        \"add_liveness_constraints: mpi={:?} has initialized child {:?}\",\n-                        self.move_data.move_paths[mpi],\n-                        self.move_data.move_paths[initialized_child]\n-                    );\n-\n-                    let live_local_ty = self.mir.local_decls[live_local].ty;\n-                    self.add_drop_live_constraint(live_local_ty, location);\n-                }\n-            }\n-\n-            if location.statement_index == terminator_index {\n-                debug!(\n-                    \"add_liveness_constraints: reconstruct_terminator_effect from {:#?}\",\n-                    location\n-                );\n-                self.flow_inits.reconstruct_terminator_effect(location);\n-            } else {\n-                debug!(\n-                    \"add_liveness_constraints: reconstruct_statement_effect from {:#?}\",\n-                    location\n-                );\n-                self.flow_inits.reconstruct_statement_effect(location);\n-            }\n-            self.flow_inits.apply_local_effect(location);\n-        }\n-    }\n-\n     /// Some variable with type `live_ty` is \"regular live\" at\n     /// `location` -- i.e., it may be used later. This means that all\n     /// regions appearing in the type `live_ty` must be live at\n@@ -230,75 +130,6 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n             });\n     }\n \n-    /// Some variable with type `live_ty` is \"drop live\" at `location`\n-    /// -- i.e., it may be dropped later. This means that *some* of\n-    /// the regions in its type must be live at `location`. The\n-    /// precise set will depend on the dropck constraints, and in\n-    /// particular this takes `#[may_dangle]` into account.\n-    fn add_drop_live_constraint(&mut self, dropped_ty: Ty<'tcx>, location: Location) {\n-        debug!(\n-            \"add_drop_live_constraint(dropped_ty={:?}, location={:?})\",\n-            dropped_ty,\n-            location\n-        );\n-\n-        let tcx = self.infcx.tcx;\n-        let mut types = vec![(dropped_ty, 0)];\n-        let mut known = FxHashSet();\n-        while let Some((ty, depth)) = types.pop() {\n-            let span = DUMMY_SP; // FIXME\n-            let result = match tcx.dtorck_constraint_for_ty(span, dropped_ty, depth, ty) {\n-                Ok(result) => result,\n-                Err(ErrorReported) => {\n-                    continue;\n-                }\n-            };\n-\n-            let ty::DtorckConstraint {\n-                outlives,\n-                dtorck_types,\n-            } = result;\n-\n-            // All things in the `outlives` array may be touched by\n-            // the destructor and must be live at this point.\n-            for outlive in outlives {\n-                self.add_regular_live_constraint(outlive, location);\n-            }\n-\n-            // However, there may also be some types that\n-            // `dtorck_constraint_for_ty` could not resolve (e.g.,\n-            // associated types and parameters). We need to normalize\n-            // associated types here and possibly recursively process.\n-            for ty in dtorck_types {\n-                let cause = ObligationCause::dummy();\n-                // We know that our original `dropped_ty` is well-formed,\n-                // so region obligations resulting from this normalization\n-                // should always hold.\n-                //\n-                // Therefore we ignore them instead of trying to match\n-                // them up with a location.\n-                let fulfillcx = traits::FulfillmentContext::new_ignoring_regions();\n-                match traits::fully_normalize_with_fulfillcx(\n-                    self.infcx, fulfillcx, cause, self.param_env, &ty\n-                ) {\n-                    Ok(ty) => match ty.sty {\n-                        ty::TyParam(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n-                            self.add_regular_live_constraint(ty, location);\n-                        }\n-\n-                        _ => if known.insert(ty) {\n-                            types.push((ty, depth + 1));\n-                        },\n-                    },\n-\n-                    Err(errors) => {\n-                        self.infcx.report_fulfillment_errors(&errors, None);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     fn add_reborrow_constraint(\n         &mut self,\n         location: Location,"}, {"sha": "6977d91d25a5d1829004617f912a7724046deaf7", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 30, "deletions": 43, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -9,16 +9,16 @@\n // except according to those terms.\n \n use rustc::hir::def_id::DefId;\n-use rustc::mir::{ClosureRegionRequirements, Mir};\n+use rustc::mir::{ClosureRegionRequirements, ClosureOutlivesSubject, Mir};\n use rustc::infer::InferCtxt;\n use rustc::ty::{self, RegionKind, RegionVid};\n use rustc::util::nodemap::FxHashMap;\n use std::collections::BTreeSet;\n+use std::fmt::Debug;\n use std::io;\n use transform::MirSource;\n-use transform::type_check;\n-use util::liveness::{self, LivenessMode, LivenessResult, LocalSet};\n-use borrow_check::FlowAtLocation;\n+use util::liveness::{LivenessResults, LocalSet};\n+use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedLvals;\n use dataflow::move_paths::MoveData;\n \n@@ -27,14 +27,15 @@ use util::pretty::{self, ALIGN};\n use self::mir_util::PassWhere;\n \n mod constraint_generation;\n+pub(crate) mod region_infer;\n+mod renumber;\n mod subtype_constraint_generation;\n+pub(crate) mod type_check;\n mod universal_regions;\n-use self::universal_regions::UniversalRegions;\n \n-pub(crate) mod region_infer;\n use self::region_infer::RegionInferenceContext;\n+use self::universal_regions::UniversalRegions;\n \n-mod renumber;\n \n /// Rewrites the regions in the MIR to use NLL variables, also\n /// scraping out the set of universal regions (e.g., region parameters)\n@@ -52,7 +53,7 @@ pub(in borrow_check) fn replace_regions_in_mir<'cx, 'gcx, 'tcx>(\n     let universal_regions = UniversalRegions::new(infcx, def_id, param_env);\n \n     // Replace all remaining regions with fresh inference variables.\n-    renumber::renumber_mir(infcx, &universal_regions, mir);\n+    renumber::renumber_mir(infcx, mir);\n \n     let source = MirSource::item(def_id);\n     mir_util::dump_mir(infcx.tcx, None, \"renumber\", &0, source, mir, |_, _| Ok(()));\n@@ -73,47 +74,34 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     move_data: &MoveData<'tcx>,\n ) -> (\n     RegionInferenceContext<'tcx>,\n-    Option<ClosureRegionRequirements>,\n+    Option<ClosureRegionRequirements<'gcx>>,\n ) {\n     // Run the MIR type-checker.\n     let mir_node_id = infcx.tcx.hir.as_local_node_id(def_id).unwrap();\n-    let constraint_sets = &type_check::type_check(infcx, mir_node_id, param_env, mir);\n+    let liveness = &LivenessResults::compute(mir);\n+    let fr_fn_body = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n+    let constraint_sets = &type_check::type_check(\n+        infcx,\n+        mir_node_id,\n+        param_env,\n+        mir,\n+        fr_fn_body,\n+        universal_regions.input_tys,\n+        universal_regions.output_ty,\n+        &liveness,\n+        flow_inits,\n+        move_data,\n+    );\n \n     // Create the region inference context, taking ownership of the region inference\n     // data that was contained in `infcx`.\n     let var_origins = infcx.take_region_var_origins();\n     let mut regioncx = RegionInferenceContext::new(var_origins, universal_regions, mir);\n     subtype_constraint_generation::generate(&mut regioncx, mir, constraint_sets);\n \n-    // Compute what is live where.\n-    let liveness = &LivenessResults {\n-        regular: liveness::liveness_of_locals(\n-            &mir,\n-            LivenessMode {\n-                include_regular_use: true,\n-                include_drops: false,\n-            },\n-        ),\n-\n-        drop: liveness::liveness_of_locals(\n-            &mir,\n-            LivenessMode {\n-                include_regular_use: false,\n-                include_drops: true,\n-            },\n-        ),\n-    };\n \n     // Generate non-subtyping constraints.\n-    constraint_generation::generate_constraints(\n-        infcx,\n-        &mut regioncx,\n-        &mir,\n-        param_env,\n-        liveness,\n-        flow_inits,\n-        move_data,\n-    );\n+    constraint_generation::generate_constraints(infcx, &mut regioncx, &mir);\n \n     // Solve the region constraints.\n     let closure_region_requirements = regioncx.solve(infcx, &mir, def_id);\n@@ -136,11 +124,6 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     (regioncx, closure_region_requirements)\n }\n \n-struct LivenessResults {\n-    regular: LivenessResult,\n-    drop: LivenessResult,\n-}\n-\n fn dump_mir_results<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     liveness: &LivenessResults,\n@@ -283,9 +266,13 @@ fn for_each_region_constraint(\n     with_msg: &mut FnMut(&str) -> io::Result<()>,\n ) -> io::Result<()> {\n     for req in &closure_region_requirements.outlives_requirements {\n+        let subject: &Debug = match &req.subject {\n+            ClosureOutlivesSubject::Region(subject) => subject,\n+            ClosureOutlivesSubject::Ty(ty) => ty,\n+        };\n         with_msg(&format!(\n             \"where {:?}: {:?}\",\n-            req.free_region,\n+            subject,\n             req.outlived_free_region,\n         ))?;\n     }"}, {"sha": "59860d61ab98551662b870387bb956c4c1c9bf79", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dfs.rs", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,234 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Module defining the `dfs` method on `RegionInferenceContext`, along with\n+//! its associated helper traits.\n+\n+use borrow_check::nll::universal_regions::UniversalRegions;\n+use borrow_check::nll::region_infer::RegionInferenceContext;\n+use borrow_check::nll::region_infer::values::{RegionElementIndex, RegionValueElements,\n+                                              RegionValues};\n+use rustc::mir::{Location, Mir};\n+use rustc::ty::RegionVid;\n+use rustc_data_structures::fx::FxHashSet;\n+\n+impl<'tcx> RegionInferenceContext<'tcx> {\n+    /// Function used to satisfy or test a `R1: R2 @ P`\n+    /// constraint. The core idea is that it performs a DFS starting\n+    /// from `P`. The precise actions *during* that DFS depend on the\n+    /// `op` supplied, so see (e.g.) `CopyFromSourceToTarget` for more\n+    /// details.\n+    ///\n+    /// Returns:\n+    ///\n+    /// - `Ok(true)` if the walk was completed and something changed\n+    ///   along the way;\n+    /// - `Ok(false)` if the walk was completed with no changes;\n+    /// - `Err(early)` if the walk was existed early by `op`. `earlyelem` is the\n+    ///   value that `op` returned.\n+    pub(super) fn dfs<C>(&self, mir: &Mir<'tcx>, mut op: C) -> Result<bool, C::Early>\n+    where\n+        C: DfsOp,\n+    {\n+        let mut changed = false;\n+\n+        let mut stack = vec![];\n+        let mut visited = FxHashSet();\n+\n+        stack.push(op.start_point());\n+        while let Some(p) = stack.pop() {\n+            let point_index = self.elements.index(p);\n+\n+            if !op.source_region_contains(point_index) {\n+                debug!(\"            not in from-region\");\n+                continue;\n+            }\n+\n+            if !visited.insert(p) {\n+                debug!(\"            already visited\");\n+                continue;\n+            }\n+\n+            let new = op.add_to_target_region(point_index)?;\n+            changed |= new;\n+\n+            let block_data = &mir[p.block];\n+\n+            let start_stack_len = stack.len();\n+\n+            if p.statement_index < block_data.statements.len() {\n+                stack.push(Location {\n+                    statement_index: p.statement_index + 1,\n+                    ..p\n+                });\n+            } else {\n+                stack.extend(block_data.terminator().successors().iter().map(\n+                    |&basic_block| {\n+                        Location {\n+                            statement_index: 0,\n+                            block: basic_block,\n+                        }\n+                    },\n+                ));\n+            }\n+\n+            if stack.len() == start_stack_len {\n+                // If we reach the END point in the graph, then copy\n+                // over any skolemized end points in the `from_region`\n+                // and make sure they are included in the `to_region`.\n+                changed |= op.add_universal_regions_outlived_by_source_to_target()?;\n+            }\n+        }\n+\n+        Ok(changed)\n+    }\n+}\n+\n+/// Customizes the operation of the `dfs` function. This function is\n+/// used during inference to satisfy a `R1: R2 @ P` constraint.\n+pub(super) trait DfsOp {\n+    /// If this op stops the walk early, what type does it propagate?\n+    type Early;\n+\n+    /// Returns the point from which to start the DFS.\n+    fn start_point(&self) -> Location;\n+\n+    /// Returns true if the source region contains the given point.\n+    fn source_region_contains(&mut self, point_index: RegionElementIndex) -> bool;\n+\n+    /// Adds the given point to the target region, returning true if\n+    /// something has changed. Returns `Err` if we should abort the\n+    /// walk early.\n+    fn add_to_target_region(\n+        &mut self,\n+        point_index: RegionElementIndex,\n+    ) -> Result<bool, Self::Early>;\n+\n+    /// Adds all universal regions in the source region to the target region, returning\n+    /// true if something has changed.\n+    fn add_universal_regions_outlived_by_source_to_target(&mut self) -> Result<bool, Self::Early>;\n+}\n+\n+/// Used during inference to enforce a `R1: R2 @ P` constraint.  For\n+/// each point Q we reach along the DFS, we check if Q is in R2 (the\n+/// \"source region\"). If not, we stop the walk. Otherwise, we add Q to\n+/// R1 (the \"target region\") and continue to Q's successors. If we\n+/// reach the end of the graph, then we add any universal regions from\n+/// R2 into R1.\n+pub(super) struct CopyFromSourceToTarget<'v> {\n+    pub source_region: RegionVid,\n+    pub target_region: RegionVid,\n+    pub inferred_values: &'v mut RegionValues,\n+    pub constraint_point: Location,\n+}\n+\n+impl<'v> DfsOp for CopyFromSourceToTarget<'v> {\n+    /// We never stop the walk early.\n+    type Early = !;\n+\n+    fn start_point(&self) -> Location {\n+        self.constraint_point\n+    }\n+\n+    fn source_region_contains(&mut self, point_index: RegionElementIndex) -> bool {\n+        self.inferred_values\n+            .contains(self.source_region, point_index)\n+    }\n+\n+    fn add_to_target_region(&mut self, point_index: RegionElementIndex) -> Result<bool, !> {\n+        Ok(self.inferred_values.add(self.target_region, point_index))\n+    }\n+\n+    fn add_universal_regions_outlived_by_source_to_target(&mut self) -> Result<bool, !> {\n+        Ok(\n+            self.inferred_values\n+                .add_universal_regions_outlived_by(self.source_region, self.target_region),\n+        )\n+    }\n+}\n+\n+/// Used after inference to *test* a `R1: R2 @ P` constraint.  For\n+/// each point Q we reach along the DFS, we check if Q in R2 is also\n+/// contained in R1. If not, we abort the walk early with an `Err`\n+/// condition. Similarly, if we reach the end of the graph and find\n+/// that R1 contains some universal region that R2 does not contain,\n+/// we abort the walk early.\n+pub(super) struct TestTargetOutlivesSource<'v, 'tcx: 'v> {\n+    pub source_region: RegionVid,\n+    pub target_region: RegionVid,\n+    pub elements: &'v RegionValueElements,\n+    pub universal_regions: &'v UniversalRegions<'tcx>,\n+    pub inferred_values: &'v RegionValues,\n+    pub constraint_point: Location,\n+}\n+\n+impl<'v, 'tcx> DfsOp for TestTargetOutlivesSource<'v, 'tcx> {\n+    /// The element that was not found within R2.\n+    type Early = RegionElementIndex;\n+\n+    fn start_point(&self) -> Location {\n+        self.constraint_point\n+    }\n+\n+    fn source_region_contains(&mut self, point_index: RegionElementIndex) -> bool {\n+        self.inferred_values\n+            .contains(self.source_region, point_index)\n+    }\n+\n+    fn add_to_target_region(\n+        &mut self,\n+        point_index: RegionElementIndex,\n+    ) -> Result<bool, RegionElementIndex> {\n+        if !self.inferred_values\n+            .contains(self.target_region, point_index)\n+        {\n+            return Err(point_index);\n+        }\n+\n+        Ok(false)\n+    }\n+\n+    fn add_universal_regions_outlived_by_source_to_target(\n+        &mut self,\n+    ) -> Result<bool, RegionElementIndex> {\n+        // For all `ur_in_source` in `source_region`.\n+        for ur_in_source in self.inferred_values\n+            .universal_regions_outlived_by(self.source_region)\n+        {\n+            // Check that `target_region` outlives `ur_in_source`.\n+\n+            // If `ur_in_source` is a member of `target_region`, OK.\n+            //\n+            // (This is implied by the loop below, actually, just an\n+            // irresistible micro-opt. Mm. Premature optimization. So\n+            // tasty.)\n+            if self.inferred_values\n+                .contains(self.target_region, ur_in_source)\n+            {\n+                continue;\n+            }\n+\n+            // If there is some other element X such that `target_region: X` and\n+            // `X: ur_in_source`, OK.\n+            if self.inferred_values\n+                .universal_regions_outlived_by(self.target_region)\n+                .any(|ur_in_target| {\n+                    self.universal_regions.outlives(ur_in_target, ur_in_source)\n+                }) {\n+                continue;\n+            }\n+\n+            // Otherwise, not known to be true.\n+            return Err(self.elements.index(ur_in_source));\n+        }\n+\n+        Ok(false)\n+    }\n+}"}, {"sha": "58e16e7673afc75f11eaee271958b6740d287c3d", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 643, "deletions": 219, "changes": 862, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -12,18 +12,23 @@ use super::universal_regions::UniversalRegions;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n use rustc::infer::NLLRegionVariableOrigin;\n+use rustc::infer::RegionObligation;\n use rustc::infer::RegionVariableOrigin;\n use rustc::infer::SubregionOrigin;\n-use rustc::infer::region_constraints::VarOrigins;\n-use rustc::mir::{ClosureOutlivesRequirement, ClosureRegionRequirements, Location, Mir};\n-use rustc::ty::{self, RegionVid};\n+use rustc::infer::region_constraints::{GenericKind, VarOrigins};\n+use rustc::mir::{ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n+                 Location, Mir};\n+use rustc::traits::ObligationCause;\n+use rustc::ty::{self, RegionVid, Ty, TypeFoldable};\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_data_structures::fx::FxHashSet;\n use std::fmt;\n use std::rc::Rc;\n+use syntax::ast;\n use syntax_pos::Span;\n \n mod annotation;\n+mod dfs;\n+use self::dfs::{CopyFromSourceToTarget, TestTargetOutlivesSource};\n mod dump_mir;\n mod graphviz;\n mod values;\n@@ -52,6 +57,9 @@ pub struct RegionInferenceContext<'tcx> {\n     /// The constraints we have accumulated and used during solving.\n     constraints: Vec<Constraint>,\n \n+    /// Type constraints that we check after solving.\n+    type_tests: Vec<TypeTest<'tcx>>,\n+\n     /// Information about the universally quantified regions in scope\n     /// on this function and their (known) relations to one another.\n     universal_regions: UniversalRegions<'tcx>,\n@@ -94,6 +102,92 @@ pub struct Constraint {\n     span: Span,\n }\n \n+/// A \"type test\" corresponds to an outlives constraint between a type\n+/// and a lifetime, like `T: 'x` or `<T as Foo>::Bar: 'x`.  They are\n+/// translated from the `Verify` region constraints in the ordinary\n+/// inference context.\n+///\n+/// These sorts of constraints are handled differently than ordinary\n+/// constraints, at least at present. During type checking, the\n+/// `InferCtxt::process_registered_region_obligations` method will\n+/// attempt to convert a type test like `T: 'x` into an ordinary\n+/// outlives constraint when possible (for example, `&'a T: 'b` will\n+/// be converted into `'a: 'b` and registered as a `Constraint`).\n+///\n+/// In some cases, however, there are outlives relationships that are\n+/// not converted into a region constraint, but rather into one of\n+/// these \"type tests\".  The distinction is that a type test does not\n+/// influence the inference result, but instead just examines the\n+/// values that we ultimately inferred for each region variable and\n+/// checks that they meet certain extra criteria.  If not, an error\n+/// can be issued.\n+///\n+/// One reason for this is that these type tests typically boil down\n+/// to a check like `'a: 'x` where `'a` is a universally quantified\n+/// region -- and therefore not one whose value is really meant to be\n+/// *inferred*, precisely (this is not always the case: one can have a\n+/// type test like `<Foo as Trait<'?0>>::Bar: 'x`, where `'?0` is an\n+/// inference variable). Another reason is that these type tests can\n+/// involve *disjunction* -- that is, they can be satisfied in more\n+/// than one way.\n+///\n+/// For more information about this translation, see\n+/// `InferCtxt::process_registered_region_obligations` and\n+/// `InferCtxt::type_must_outlive` in `rustc::infer::outlives`.\n+#[derive(Clone, Debug)]\n+pub struct TypeTest<'tcx> {\n+    /// The type `T` that must outlive the region.\n+    pub generic_kind: GenericKind<'tcx>,\n+\n+    /// The region `'x` that the type must outlive.\n+    pub lower_bound: RegionVid,\n+\n+    /// The point where the outlives relation must hold.\n+    pub point: Location,\n+\n+    /// Where did this constraint arise?\n+    pub span: Span,\n+\n+    /// A test which, if met by the region `'x`, proves that this type\n+    /// constraint is satisfied.\n+    pub test: RegionTest,\n+}\n+\n+/// A \"test\" that can be applied to some \"subject region\" `'x`. These are used to\n+/// describe type constraints. Tests do not presently affect the\n+/// region values that get inferred for each variable; they only\n+/// examine the results *after* inference.  This means they can\n+/// conveniently include disjuction (\"a or b must be true\").\n+#[derive(Clone, Debug)]\n+pub enum RegionTest {\n+    /// The subject region `'x` must by outlived by *some* region in\n+    /// the given set of regions.\n+    ///\n+    /// This test comes from e.g. a where clause like `T: 'a + 'b`,\n+    /// which implies that we know that `T: 'a` and that `T:\n+    /// 'b`. Therefore, if we are trying to prove that `T: 'x`, we can\n+    /// do so by showing that `'a: 'x` *or* `'b: 'x`.\n+    IsOutlivedByAnyRegionIn(Vec<RegionVid>),\n+\n+    /// The subject region `'x` must by outlived by *all* regions in\n+    /// the given set of regions.\n+    ///\n+    /// This test comes from e.g. a projection type like `T = <u32 as\n+    /// Trait<'a, 'b>>::Foo`, which must outlive `'a` or `'b`, and\n+    /// maybe both. Therefore we can prove that `T: 'x` if we know\n+    /// that `'a: 'x` *and* `'b: 'x`.\n+    IsOutlivedByAllRegionsIn(Vec<RegionVid>),\n+\n+    /// Any of the given tests are true.\n+    ///\n+    /// This arises from projections, for which there are multiple\n+    /// ways to prove an outlives relationship.\n+    Any(Vec<RegionTest>),\n+\n+    /// All of the given tests are true.\n+    All(Vec<RegionTest>),\n+}\n+\n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Creates a new region inference context with a total of\n     /// `num_region_variables` valid inference variables; the first N\n@@ -121,6 +215,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             liveness_constraints: RegionValues::new(elements, num_region_variables),\n             inferred_values: None,\n             constraints: Vec::new(),\n+            type_tests: Vec::new(),\n             universal_regions,\n         };\n \n@@ -242,32 +337,414 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         });\n     }\n \n-    /// Perform region inference.\n-    pub(super) fn solve(\n+    /// Add a \"type test\" that must be satisfied.\n+    pub(super) fn add_type_test(&mut self, type_test: TypeTest<'tcx>) {\n+        self.type_tests.push(type_test);\n+    }\n+\n+    /// Perform region inference and report errors if we see any\n+    /// unsatisfiable constraints. If this is a closure, returns the\n+    /// region requirements to propagate to our creator, if any.\n+    pub(super) fn solve<'gcx>(\n         &mut self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n         mir_def_id: DefId,\n-    ) -> Option<ClosureRegionRequirements> {\n+    ) -> Option<ClosureRegionRequirements<'gcx>> {\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n-        let tcx = infcx.tcx;\n \n-        // Find the minimal regions that can solve the constraints. This is infallible.\n         self.propagate_constraints(mir);\n \n-        // Now, see whether any of the constraints were too strong. In\n-        // particular, we want to check for a case where a universally\n-        // quantified region exceeded its bounds.  Consider:\n-        //\n-        //     fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n-        //\n-        // In this case, returning `x` requires `&'a u32 <: &'b u32`\n-        // and hence we establish (transitively) a constraint that\n-        // `'a: 'b`. The `propagate_constraints` code above will\n-        // therefore add `end('a)` into the region for `'b` -- but we\n-        // have no evidence that `'a` outlives `'b`, so we want to report\n-        // an error.\n+        // If this is a closure, we can propagate unsatisfied\n+        // `outlives_requirements` to our creator, so create a vector\n+        // to store those. Otherwise, we'll pass in `None` to the\n+        // functions below, which will trigger them to report errors\n+        // eagerly.\n+        let mut outlives_requirements = if infcx.tcx.is_closure(mir_def_id) {\n+            Some(vec![])\n+        } else {\n+            None\n+        };\n+\n+        self.check_type_tests(infcx, mir, outlives_requirements.as_mut());\n+\n+        self.check_universal_regions(infcx, outlives_requirements.as_mut());\n+\n+        let outlives_requirements = outlives_requirements.unwrap_or(vec![]);\n+\n+        if outlives_requirements.is_empty() {\n+            None\n+        } else {\n+            let num_external_vids = self.universal_regions.num_global_and_external_regions();\n+            Some(ClosureRegionRequirements {\n+                num_external_vids,\n+                outlives_requirements,\n+            })\n+        }\n+    }\n+\n+    /// Propagate the region constraints: this will grow the values\n+    /// for each region variable until all the constraints are\n+    /// satisfied. Note that some values may grow **too** large to be\n+    /// feasible, but we check this later.\n+    fn propagate_constraints(&mut self, mir: &Mir<'tcx>) {\n+        let mut changed = true;\n+\n+        debug!(\"propagate_constraints()\");\n+        debug!(\"propagate_constraints: constraints={:#?}\", {\n+            let mut constraints: Vec<_> = self.constraints.iter().collect();\n+            constraints.sort();\n+            constraints\n+        });\n+\n+        // The initial values for each region are derived from the liveness\n+        // constraints we have accumulated.\n+        let mut inferred_values = self.liveness_constraints.clone();\n+\n+        while changed {\n+            changed = false;\n+            debug!(\"propagate_constraints: --------------------\");\n+            for constraint in &self.constraints {\n+                debug!(\"propagate_constraints: constraint={:?}\", constraint);\n+\n+                // Grow the value as needed to accommodate the\n+                // outlives constraint.\n+                let Ok(made_changes) = self.dfs(\n+                    mir,\n+                    CopyFromSourceToTarget {\n+                        source_region: constraint.sub,\n+                        target_region: constraint.sup,\n+                        inferred_values: &mut inferred_values,\n+                        constraint_point: constraint.point,\n+                    },\n+                );\n+\n+                if made_changes {\n+                    debug!(\"propagate_constraints:   sub={:?}\", constraint.sub);\n+                    debug!(\"propagate_constraints:   sup={:?}\", constraint.sup);\n+                    changed = true;\n+                }\n+            }\n+            debug!(\"\\n\");\n+        }\n+\n+        self.inferred_values = Some(inferred_values);\n+    }\n+\n+    /// Once regions have been propagated, this method is used to see\n+    /// whether the \"type tests\" produced by typeck were satisfied;\n+    /// type tests encode type-outlives relationships like `T:\n+    /// 'a`. See `TypeTest` for more details.\n+    fn check_type_tests<'gcx>(\n+        &self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n+    ) {\n+        let tcx = infcx.tcx;\n+\n+        for type_test in &self.type_tests {\n+            debug!(\"check_type_test: {:?}\", type_test);\n+\n+            if self.eval_region_test(mir, type_test.point, type_test.lower_bound, &type_test.test) {\n+                continue;\n+            }\n+\n+            if let Some(propagated_outlives_requirements) = &mut propagated_outlives_requirements {\n+                if self.try_promote_type_test(infcx, type_test, propagated_outlives_requirements) {\n+                    continue;\n+                }\n+            }\n+\n+            // Oh the humanity. Obviously we will do better than this error eventually.\n+            tcx.sess.span_err(\n+                type_test.span,\n+                &format!(\n+                    \"`{}` does not outlive `{:?}`\",\n+                    type_test.generic_kind,\n+                    type_test.lower_bound,\n+                ),\n+            );\n+        }\n+    }\n+\n+    fn try_promote_type_test<'gcx>(\n+        &self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        type_test: &TypeTest<'tcx>,\n+        propagated_outlives_requirements: &mut Vec<ClosureOutlivesRequirement<'gcx>>,\n+    ) -> bool {\n+        let tcx = infcx.tcx;\n+\n+        let TypeTest {\n+            generic_kind,\n+            lower_bound,\n+            point: _,\n+            span,\n+            test: _,\n+        } = type_test;\n+\n+        let generic_ty = generic_kind.to_ty(tcx);\n+        let subject = match self.try_promote_type_test_subject(infcx, generic_ty) {\n+            Some(s) => s,\n+            None => return false,\n+        };\n+\n+        // Find some bounding subject-region R+ that is a super-region\n+        // of the existing subject-region R. This should be a non-local, universal\n+        // region, which ensures it can be encoded in a `ClosureOutlivesRequirement`.\n+        let lower_bound_plus = self.non_local_universal_upper_bound(*lower_bound);\n+        assert!(self.universal_regions.is_universal_region(lower_bound_plus));\n+        assert!(!self.universal_regions\n+            .is_local_free_region(lower_bound_plus));\n+\n+        propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n+            subject,\n+            outlived_free_region: lower_bound_plus,\n+            blame_span: *span,\n+        });\n+        true\n+    }\n+\n+    /// When we promote a type test `T: 'r`, we have to convert the\n+    /// type `T` into something we can store in a query result (so\n+    /// something allocated for `'gcx`). This is problematic if `ty`\n+    /// contains regions. During the course of NLL region checking, we\n+    /// will have replaced all of those regions with fresh inference\n+    /// variables. To create a test subject, we want to replace those\n+    /// inference variables with some region from the closure\n+    /// signature -- this is not always possible, so this is a\n+    /// fallible process. Presuming we do find a suitable region, we\n+    /// will represent it with a `ReClosureBound`, which is a\n+    /// `RegionKind` variant that can be allocated in the gcx.\n+    fn try_promote_type_test_subject<'gcx>(\n+        &self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> Option<ClosureOutlivesSubject<'gcx>> {\n+        let tcx = infcx.tcx;\n+        let gcx = tcx.global_tcx();\n+        let inferred_values = self.inferred_values\n+            .as_ref()\n+            .expect(\"region values not yet inferred\");\n+\n+        debug!(\"try_promote_type_test_subject(ty = {:?})\", ty);\n+\n+        let ty = tcx.fold_regions(&ty, &mut false, |r, _depth| {\n+            let region_vid = self.to_region_vid(r);\n+\n+            // The challenge if this. We have some region variable `r`\n+            // whose value is a set of CFG points and universal\n+            // regions. We want to find if that set is *equivalent* to\n+            // any of the named regions found in the closure.\n+            //\n+            // To do so, we compute the\n+            // `non_local_universal_upper_bound`. This will be a\n+            // non-local, universal region that is greater than `r`.\n+            // However, it might not be *contained* within `r`, so\n+            // then we further check whether this bound is contained\n+            // in `r`. If so, we can say that `r` is equivalent to the\n+            // bound.\n+            //\n+            // Let's work through a few examples. For these, imagine\n+            // that we have 3 non-local regions (I'll denote them as\n+            // `'static`, `'a`, and `'b`, though of course in the code\n+            // they would be represented with indices) where:\n+            //\n+            // - `'static: 'a`\n+            // - `'static: 'b`\n+            //\n+            // First, let's assume that `r` is some existential\n+            // variable with an inferred value `{'a, 'static}` (plus\n+            // some CFG nodes). In this case, the non-local upper\n+            // bound is `'static`, since that outlives `'a`. `'static`\n+            // is also a member of `r` and hence we consider `r`\n+            // equivalent to `'static` (and replace it with\n+            // `'static`).\n+            //\n+            // Now let's consider the inferred value `{'a, 'b}`. This\n+            // means `r` is effectively `'a | 'b`. I'm not sure if\n+            // this can come about, actually, but assuming it did, we\n+            // would get a non-local upper bound of `'static`. Since\n+            // `'static` is not contained in `r`, we would fail to\n+            // find an equivalent.\n+            let upper_bound = self.non_local_universal_upper_bound(region_vid);\n+            if inferred_values.contains(region_vid, upper_bound) {\n+                tcx.mk_region(ty::ReClosureBound(upper_bound))\n+            } else {\n+                // In the case of a failure, use a `ReVar`\n+                // result. This will cause the `lift` later on to\n+                // fail.\n+                r\n+            }\n+        });\n+        debug!(\"try_promote_type_test_subject: folded ty = {:?}\", ty);\n+\n+        // `lift` will only fail if we failed to promote some region.\n+        let ty = gcx.lift(&ty)?;\n+\n+        Some(ClosureOutlivesSubject::Ty(ty))\n+    }\n+\n+    /// Given some universal or existential region `r`, finds a\n+    /// non-local, universal region `r+` that outlives `r` at entry to (and\n+    /// exit from) the closure. In the worst case, this will be\n+    /// `'static`.\n+    ///\n+    /// This is used for two purposes. First, if we are propagated\n+    /// some requirement `T: r`, we can use this method to enlarge `r`\n+    /// to something we can encode for our creator (which only knows\n+    /// about non-local, universal regions). It is also used when\n+    /// encoding `T` as part of `try_promote_type_test_subject` (see\n+    /// that fn for details).\n+    ///\n+    /// Since `r` is (potentially) an existential region, it has some\n+    /// value which may include (a) any number of points in the CFG\n+    /// and (b) any number of `end('x)` elements of universally\n+    /// quantified regions. To convert this into a single universal\n+    /// region we do as follows:\n+    ///\n+    /// - Ignore the CFG points in `'r`. All universally quantified regions\n+    ///   include the CFG anyhow.\n+    /// - For each `end('x)` element in `'r`, compute the mutual LUB, yielding\n+    ///   a result `'y`.\n+    /// - Finally, we take the non-local upper bound of `'y`.\n+    ///   - This uses `UniversalRegions::non_local_upper_bound`, which\n+    ///     is similar to this method but only works on universal\n+    ///     regions).\n+    fn non_local_universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n+        let inferred_values = self.inferred_values.as_ref().unwrap();\n+\n+        debug!(\n+            \"non_local_universal_upper_bound(r={:?}={})\",\n+            r,\n+            inferred_values.region_value_str(r)\n+        );\n+\n+        // Find the smallest universal region that contains all other\n+        // universal regions within `region`.\n+        let mut lub = self.universal_regions.fr_fn_body;\n+        for ur in inferred_values.universal_regions_outlived_by(r) {\n+            lub = self.universal_regions.postdom_upper_bound(lub, ur);\n+        }\n+\n+        debug!(\"non_local_universal_upper_bound: lub={:?}\", lub);\n+\n+        // Grow further to get smallest universal region known to\n+        // creator.\n+        let non_local_lub = self.universal_regions.non_local_upper_bound(lub);\n+\n+        debug!(\n+            \"non_local_universal_upper_bound: non_local_lub={:?}\",\n+            non_local_lub\n+        );\n+\n+        non_local_lub\n+    }\n+\n+    /// Test if `test` is true when applied to `lower_bound` at\n+    /// `point`, and returns true or false.\n+    fn eval_region_test(\n+        &self,\n+        mir: &Mir<'tcx>,\n+        point: Location,\n+        lower_bound: RegionVid,\n+        test: &RegionTest,\n+    ) -> bool {\n+        debug!(\n+            \"eval_region_test(point={:?}, lower_bound={:?}, test={:?})\",\n+            point,\n+            lower_bound,\n+            test\n+        );\n \n+        match test {\n+            RegionTest::IsOutlivedByAllRegionsIn(regions) => regions\n+                .iter()\n+                .all(|&r| self.eval_outlives(mir, r, lower_bound, point)),\n+\n+            RegionTest::IsOutlivedByAnyRegionIn(regions) => regions\n+                .iter()\n+                .any(|&r| self.eval_outlives(mir, r, lower_bound, point)),\n+\n+            RegionTest::Any(tests) => tests\n+                .iter()\n+                .any(|test| self.eval_region_test(mir, point, lower_bound, test)),\n+\n+            RegionTest::All(tests) => tests\n+                .iter()\n+                .all(|test| self.eval_region_test(mir, point, lower_bound, test)),\n+        }\n+    }\n+\n+    // Evaluate whether `sup_region: sub_region @ point`.\n+    fn eval_outlives(\n+        &self,\n+        mir: &Mir<'tcx>,\n+        sup_region: RegionVid,\n+        sub_region: RegionVid,\n+        point: Location,\n+    ) -> bool {\n+        debug!(\n+            \"eval_outlives({:?}: {:?} @ {:?})\",\n+            sup_region,\n+            sub_region,\n+            point\n+        );\n+\n+        // Roughly speaking, do a DFS of all region elements reachable\n+        // from `point` contained in `sub_region`. If any of those are\n+        // *not* present in `sup_region`, the DFS will abort early and\n+        // yield an `Err` result.\n+        match self.dfs(\n+            mir,\n+            TestTargetOutlivesSource {\n+                source_region: sub_region,\n+                target_region: sup_region,\n+                constraint_point: point,\n+                elements: &self.elements,\n+                universal_regions: &self.universal_regions,\n+                inferred_values: self.inferred_values.as_ref().unwrap(),\n+            },\n+        ) {\n+            Ok(_) => {\n+                debug!(\"eval_outlives: true\");\n+                true\n+            }\n+\n+            Err(elem) => {\n+                debug!(\n+                    \"eval_outlives: false because `{:?}` is not present in `{:?}`\",\n+                    self.elements.to_element(elem),\n+                    sup_region\n+                );\n+                false\n+            }\n+        }\n+    }\n+\n+    /// Once regions have been propagated, this method is used to see\n+    /// whether any of the constraints were too strong. In particular,\n+    /// we want to check for a case where a universally quantified\n+    /// region exceeded its bounds.  Consider:\n+    ///\n+    ///     fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n+    ///\n+    /// In this case, returning `x` requires `&'a u32 <: &'b u32`\n+    /// and hence we establish (transitively) a constraint that\n+    /// `'a: 'b`. The `propagate_constraints` code above will\n+    /// therefore add `end('a)` into the region for `'b` -- but we\n+    /// have no evidence that `'b` outlives `'a`, so we want to report\n+    /// an error.\n+    ///\n+    /// If `propagated_outlives_requirements` is `Some`, then we will\n+    /// push unsatisfied obligations into there. Otherwise, we'll\n+    /// report them as errors.\n+    fn check_universal_regions<'gcx>(\n+        &self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n+    ) {\n         // The universal regions are always found in a prefix of the\n         // full list.\n         let universal_definitions = self.definitions\n@@ -277,32 +754,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Go through each of the universal regions `fr` and check that\n         // they did not grow too large, accumulating any requirements\n         // for our caller into the `outlives_requirements` vector.\n-        let mut outlives_requirements = vec![];\n         for (fr, _) in universal_definitions {\n-            self.check_universal_region(infcx, fr, &mut outlives_requirements);\n+            self.check_universal_region(infcx, fr, &mut propagated_outlives_requirements);\n         }\n-\n-        // If this is not a closure, then there is no caller to which we can\n-        // \"pass the buck\". So if there are any outlives-requirements that were\n-        // not satisfied, we just have to report a hard error here.\n-        if !tcx.is_closure(mir_def_id) {\n-            for outlives_requirement in outlives_requirements {\n-                self.report_error(\n-                    infcx,\n-                    outlives_requirement.free_region,\n-                    outlives_requirement.outlived_free_region,\n-                    outlives_requirement.blame_span,\n-                );\n-            }\n-            return None;\n-        }\n-\n-        let num_external_vids = self.universal_regions.num_global_and_external_regions();\n-\n-        Some(ClosureRegionRequirements {\n-            num_external_vids,\n-            outlives_requirements,\n-        })\n     }\n \n     /// Check the final value for the free region `fr` to see if it\n@@ -313,11 +767,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///\n     /// Things that are to be propagated are accumulated into the\n     /// `outlives_requirements` vector.\n-    fn check_universal_region(\n+    fn check_universal_region<'gcx>(\n         &self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         longer_fr: RegionVid,\n-        outlives_requirements: &mut Vec<ClosureOutlivesRequirement>,\n+        propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n     ) {\n         let inferred_values = self.inferred_values.as_ref().unwrap();\n \n@@ -339,33 +793,39 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             let blame_span = self.blame_span(longer_fr, shorter_fr);\n \n-            // Shrink `fr` until we find a non-local region (if we do).\n-            // We'll call that `fr-` -- it's ever so slightly smaller than `fr`.\n-            if let Some(fr_minus) = self.universal_regions.non_local_lower_bound(longer_fr) {\n-                debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n-\n-                // Grow `shorter_fr` until we find a non-local\n-                // regon. (We always will.)  We'll call that\n-                // `shorter_fr+` -- it's ever so slightly larger than\n-                // `fr`.\n-                let shorter_fr_plus = self.universal_regions.non_local_upper_bound(shorter_fr);\n-                debug!(\n-                    \"check_universal_region: shorter_fr_plus={:?}\",\n-                    shorter_fr_plus\n-                );\n-\n-                // Push the constraint `fr-: shorter_fr+`\n-                outlives_requirements.push(ClosureOutlivesRequirement {\n-                    free_region: fr_minus,\n-                    outlived_free_region: shorter_fr_plus,\n-                    blame_span: blame_span,\n-                });\n-                return;\n+            if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n+                // Shrink `fr` until we find a non-local region (if we do).\n+                // We'll call that `fr-` -- it's ever so slightly smaller than `fr`.\n+                if let Some(fr_minus) = self.universal_regions.non_local_lower_bound(longer_fr) {\n+                    debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n+\n+                    // Grow `shorter_fr` until we find a non-local\n+                    // regon. (We always will.)  We'll call that\n+                    // `shorter_fr+` -- it's ever so slightly larger than\n+                    // `fr`.\n+                    let shorter_fr_plus = self.universal_regions.non_local_upper_bound(shorter_fr);\n+                    debug!(\n+                        \"check_universal_region: shorter_fr_plus={:?}\",\n+                        shorter_fr_plus\n+                    );\n+\n+                    // Push the constraint `fr-: shorter_fr+`\n+                    propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n+                        subject: ClosureOutlivesSubject::Region(fr_minus),\n+                        outlived_free_region: shorter_fr_plus,\n+                        blame_span: blame_span,\n+                    });\n+                    return;\n+                }\n             }\n \n-            // If we could not shrink `fr` to something smaller that\n-            // the external users care about, then we can't pass the\n-            // buck; just report an error.\n+            // If we are not in a context where we can propagate\n+            // errors, or we could not shrink `fr` to something\n+            // smaller, then just report an error.\n+            //\n+            // Note: in this case, we use the unapproximated regions\n+            // to report the error. This gives better error messages\n+            // in some cases.\n             self.report_error(infcx, longer_fr, shorter_fr, blame_span);\n         }\n     }\n@@ -395,117 +855,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n     }\n \n-    /// Propagate the region constraints: this will grow the values\n-    /// for each region variable until all the constraints are\n-    /// satisfied. Note that some values may grow **too** large to be\n-    /// feasible, but we check this later.\n-    fn propagate_constraints(&mut self, mir: &Mir<'tcx>) {\n-        let mut changed = true;\n-\n-        debug!(\"propagate_constraints()\");\n-        debug!(\"propagate_constraints: constraints={:#?}\", {\n-            let mut constraints: Vec<_> = self.constraints.iter().collect();\n-            constraints.sort();\n-            constraints\n-        });\n-\n-        // The initial values for each region are derived from the liveness\n-        // constraints we have accumulated.\n-        let mut inferred_values = self.liveness_constraints.clone();\n-\n-        while changed {\n-            changed = false;\n-            debug!(\"propagate_constraints: --------------------\");\n-            for constraint in &self.constraints {\n-                debug!(\"propagate_constraints: constraint={:?}\", constraint);\n-\n-                // Grow the value as needed to accommodate the\n-                // outlives constraint.\n-\n-                if self.copy(\n-                    &mut inferred_values,\n-                    mir,\n-                    constraint.sub,\n-                    constraint.sup,\n-                    constraint.point,\n-                ) {\n-                    debug!(\"propagate_constraints:   sub={:?}\", constraint.sub);\n-                    debug!(\"propagate_constraints:   sup={:?}\", constraint.sup);\n-                    changed = true;\n-                }\n-            }\n-            debug!(\"\\n\");\n-        }\n-\n-        self.inferred_values = Some(inferred_values);\n-    }\n-\n-    fn copy(\n-        &self,\n-        inferred_values: &mut RegionValues,\n-        mir: &Mir<'tcx>,\n-        from_region: RegionVid,\n-        to_region: RegionVid,\n-        constraint_point: Location,\n-    ) -> bool {\n-        let mut changed = false;\n-\n-        let mut stack = vec![];\n-        let mut visited = FxHashSet();\n-\n-        stack.push(constraint_point);\n-        while let Some(p) = stack.pop() {\n-            let point_index = self.elements.index(p);\n-\n-            if !inferred_values.contains(from_region, point_index) {\n-                debug!(\"            not in from-region\");\n-                continue;\n-            }\n-\n-            if !visited.insert(p) {\n-                debug!(\"            already visited\");\n-                continue;\n-            }\n-\n-            let new = inferred_values.add(to_region, point_index);\n-            changed |= new;\n-\n-            let block_data = &mir[p.block];\n-            let successor_points = if p.statement_index < block_data.statements.len() {\n-                vec![\n-                    Location {\n-                        statement_index: p.statement_index + 1,\n-                        ..p\n-                    },\n-                ]\n-            } else {\n-                block_data\n-                    .terminator()\n-                    .successors()\n-                    .iter()\n-                    .map(|&basic_block| {\n-                        Location {\n-                            statement_index: 0,\n-                            block: basic_block,\n-                        }\n-                    })\n-                    .collect::<Vec<_>>()\n-            };\n-\n-            if successor_points.is_empty() {\n-                // If we reach the END point in the graph, then copy\n-                // over any skolemized end points in the `from_region`\n-                // and make sure they are included in the `to_region`.\n-                changed |=\n-                    inferred_values.add_universal_regions_outlived_by(from_region, to_region);\n-            } else {\n-                stack.extend(successor_points);\n-            }\n-        }\n-\n-        changed\n-    }\n-\n     /// Tries to finds a good span to blame for the fact that `fr1`\n     /// contains `fr2`.\n     fn blame_span(&self, fr1: RegionVid, fr2: RegionVid) -> Span {\n@@ -520,35 +869,50 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // be obvious to the user -- not to mention the naive notion\n         // of dependencies, which doesn't account for the locations of\n         // contraints at all. But it will do for now.\n-        for constraint in &self.constraints {\n-            if constraint.sub == fr2 && influenced_fr1[constraint.sup] {\n-                return constraint.span;\n-            }\n-        }\n-\n-        bug!(\n-            \"could not find any constraint to blame for {:?}: {:?}\",\n-            fr1,\n-            fr2\n-        );\n+        let relevant_constraint = self.constraints\n+                .iter()\n+                .filter_map(|constraint| {\n+                    if constraint.sub != fr2 {\n+                        None\n+                    } else {\n+                        influenced_fr1[constraint.sup]\n+                            .map(|distance| (distance, constraint.span))\n+                    }\n+                })\n+                .min() // constraining fr1 with fewer hops *ought* to be more obvious\n+                .map(|(_dist, span)| span);\n+\n+        relevant_constraint.unwrap_or_else(|| {\n+            bug!(\n+                \"could not find any constraint to blame for {:?}: {:?}\",\n+                fr1,\n+                fr2\n+            );\n+        })\n     }\n \n     /// Finds all regions whose values `'a` may depend on in some way.\n-    /// Basically if there exists a constraint `'a: 'b @ P`, then `'b`\n-    /// and `dependencies('b)` will be in the final set.\n+    /// For each region, returns either `None` (does not influence\n+    /// `'a`) or `Some(d)` which indicates that it influences `'a`\n+    /// with distinct `d` (minimum number of edges that must be\n+    /// traversed).\n     ///\n     /// Used during error reporting, extremely naive and inefficient.\n-    fn dependencies(&self, r0: RegionVid) -> IndexVec<RegionVid, bool> {\n-        let mut result_set = IndexVec::from_elem(false, &self.definitions);\n+    fn dependencies(&self, r0: RegionVid) -> IndexVec<RegionVid, Option<usize>> {\n+        let mut result_set = IndexVec::from_elem(None, &self.definitions);\n         let mut changed = true;\n-        result_set[r0] = true;\n+        result_set[r0] = Some(0); // distance 0 from `r0`\n \n         while changed {\n             changed = false;\n             for constraint in &self.constraints {\n-                if result_set[constraint.sup] {\n-                    if !result_set[constraint.sub] {\n-                        result_set[constraint.sub] = true;\n+                if let Some(n) = result_set[constraint.sup] {\n+                    let m = n + 1;\n+                    if result_set[constraint.sub]\n+                        .map(|distance| m < distance)\n+                        .unwrap_or(true)\n+                    {\n+                        result_set[constraint.sub] = Some(m);\n                         changed = true;\n                     }\n                 }\n@@ -585,17 +949,27 @@ impl fmt::Debug for Constraint {\n     }\n }\n \n-pub trait ClosureRegionRequirementsExt {\n-    fn apply_requirements<'tcx>(\n+pub trait ClosureRegionRequirementsExt<'gcx, 'tcx> {\n+    fn apply_requirements(\n         &self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        body_id: ast::NodeId,\n         location: Location,\n         closure_def_id: DefId,\n         closure_substs: ty::ClosureSubsts<'tcx>,\n     );\n+\n+    fn subst_closure_mapping<T>(\n+        &self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        closure_mapping: &IndexVec<RegionVid, ty::Region<'tcx>>,\n+        value: &T,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>;\n }\n \n-impl ClosureRegionRequirementsExt for ClosureRegionRequirements {\n+impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequirements<'gcx> {\n     /// Given an instance T of the closure type, this method\n     /// instantiates the \"extra\" requirements that we computed for the\n     /// closure into the inference context. This has the effect of\n@@ -608,9 +982,10 @@ impl ClosureRegionRequirementsExt for ClosureRegionRequirements {\n     /// a vector. Then we can just index into that vector to extract\n     /// out the corresponding region from T and apply the\n     /// requirements.\n-    fn apply_requirements<'tcx>(\n+    fn apply_requirements(\n         &self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        body_id: ast::NodeId,\n         location: Location,\n         closure_def_id: DefId,\n         closure_substs: ty::ClosureSubsts<'tcx>,\n@@ -632,22 +1007,71 @@ impl ClosureRegionRequirementsExt for ClosureRegionRequirements {\n         // into a vector.  These are the regions that we will be\n         // relating to one another.\n         let closure_mapping =\n-            UniversalRegions::closure_mapping(infcx, user_closure_ty, self.num_external_vids);\n+            &UniversalRegions::closure_mapping(infcx, user_closure_ty, self.num_external_vids);\n         debug!(\"apply_requirements: closure_mapping={:?}\", closure_mapping);\n \n         // Create the predicates.\n         for outlives_requirement in &self.outlives_requirements {\n-            let region = closure_mapping[outlives_requirement.free_region];\n             let outlived_region = closure_mapping[outlives_requirement.outlived_free_region];\n-            debug!(\n-                \"apply_requirements: region={:?} outlived_region={:?} outlives_requirements={:?}\",\n-                region,\n-                outlived_region,\n-                outlives_requirement\n-            );\n+\n             // FIXME, this origin is not entirely suitable.\n             let origin = SubregionOrigin::CallRcvr(outlives_requirement.blame_span);\n-            infcx.sub_regions(origin, outlived_region, region);\n+\n+            match outlives_requirement.subject {\n+                ClosureOutlivesSubject::Region(region) => {\n+                    let region = closure_mapping[region];\n+                    debug!(\n+                        \"apply_requirements: region={:?} \\\n+                         outlived_region={:?} \\\n+                         outlives_requirement={:?}\",\n+                        region,\n+                        outlived_region,\n+                        outlives_requirement,\n+                    );\n+                    infcx.sub_regions(origin, outlived_region, region);\n+                }\n+\n+                ClosureOutlivesSubject::Ty(ty) => {\n+                    let ty = self.subst_closure_mapping(infcx, closure_mapping, &ty);\n+                    debug!(\n+                        \"apply_requirements: ty={:?} \\\n+                         outlived_region={:?} \\\n+                         outlives_requirement={:?}\",\n+                        ty,\n+                        outlived_region,\n+                        outlives_requirement,\n+                    );\n+                    infcx.register_region_obligation(\n+                        body_id,\n+                        RegionObligation {\n+                            sup_type: ty,\n+                            sub_region: outlived_region,\n+                            cause: ObligationCause::misc(outlives_requirement.blame_span, body_id),\n+                        },\n+                    );\n+                }\n+            }\n         }\n     }\n+\n+    fn subst_closure_mapping<T>(\n+        &self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        closure_mapping: &IndexVec<RegionVid, ty::Region<'tcx>>,\n+        value: &T,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        infcx.tcx.fold_regions(value, &mut false, |r, _depth| {\n+            if let ty::ReClosureBound(vid) = r {\n+                closure_mapping[*vid]\n+            } else {\n+                bug!(\n+                    \"subst_closure_mapping: encountered non-closure bound free region {:?}\",\n+                    r\n+                )\n+            }\n+        })\n+    }\n }"}, {"sha": "5f23a0e5790af8d5e8141319fea15cf434b7e4b3", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 56, "deletions": 7, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -215,8 +215,11 @@ impl RegionValues {\n         // FIXME. We could optimize this by improving\n         // `BitMatrix::merge` so it does not always merge an entire\n         // row.\n-        debug!(\"add_universal_regions_outlived_by(from_region={:?}, to_region={:?})\",\n-               from_region, to_region);\n+        debug!(\n+            \"add_universal_regions_outlived_by(from_region={:?}, to_region={:?})\",\n+            from_region,\n+            to_region\n+        );\n         let mut changed = false;\n         for elem in self.elements.all_universal_region_indices() {\n             if self.contains(from_region, elem) {\n@@ -269,24 +272,70 @@ impl RegionValues {\n         let mut result = String::new();\n         result.push_str(\"{\");\n \n-        for (index, element) in self.elements_contained_in(r).enumerate() {\n-            if index > 0 {\n-                result.push_str(\", \");\n-            }\n+        // Set to Some(l1, l2) when we have observed all the locations\n+        // from l1..=l2 (inclusive) but not yet printed them. This\n+        // gets extended if we then see l3 where l3 is the successor\n+        // to l2.\n+        let mut open_location: Option<(Location, Location)> = None;\n+\n+        let mut sep = \"\";\n+        let mut push_sep = |s: &mut String| {\n+            s.push_str(sep);\n+            sep = \", \";\n+        };\n \n+        for element in self.elements_contained_in(r) {\n             match element {\n                 RegionElement::Location(l) => {\n-                    result.push_str(&format!(\"{:?}\", l));\n+                    if let Some((location1, location2)) = open_location {\n+                        if location2.block == l.block\n+                            && location2.statement_index == l.statement_index - 1\n+                        {\n+                            open_location = Some((location1, l));\n+                            continue;\n+                        }\n+\n+                        push_sep(&mut result);\n+                        Self::push_location_range(&mut result, location1, location2);\n+                    }\n+\n+                    open_location = Some((l, l));\n                 }\n \n                 RegionElement::UniversalRegion(fr) => {\n+                    if let Some((location1, location2)) = open_location {\n+                        push_sep(&mut result);\n+                        Self::push_location_range(&mut result, location1, location2);\n+                        open_location = None;\n+                    }\n+\n+                    push_sep(&mut result);\n                     result.push_str(&format!(\"{:?}\", fr));\n                 }\n             }\n         }\n \n+        if let Some((location1, location2)) = open_location {\n+            push_sep(&mut result);\n+            Self::push_location_range(&mut result, location1, location2);\n+        }\n+\n         result.push_str(\"}\");\n \n         result\n     }\n+\n+    fn push_location_range(str: &mut String, location1: Location, location2: Location) {\n+        if location1 == location2 {\n+            str.push_str(&format!(\"{:?}\", location1));\n+        } else {\n+            assert_eq!(location1.block, location2.block);\n+            str.push_str(&format!(\n+                \"{:?}[{}..={}]\",\n+                location1.block,\n+                location1.statement_index,\n+                location2.statement_index\n+            ));\n+        }\n+    }\n }"}, {"sha": "79505405692d8b0f6622bf4869ef904a982b43ca", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 5, "deletions": 63, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -8,50 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_data_structures::indexed_vec::Idx;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, ClosureSubsts, Ty, TypeFoldable};\n-use rustc::mir::{BasicBlock, Local, Location, Mir, Statement, StatementKind};\n-use rustc::mir::RETURN_PLACE;\n+use rustc::mir::{BasicBlock, Location, Mir, Statement, StatementKind};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n \n-use super::ToRegionVid;\n-use super::universal_regions::UniversalRegions;\n-\n /// Replaces all free regions appearing in the MIR with fresh\n /// inference variables, returning the number of variables created.\n-pub fn renumber_mir<'a, 'gcx, 'tcx>(\n-    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    universal_regions: &UniversalRegions<'tcx>,\n-    mir: &mut Mir<'tcx>,\n-) {\n+pub fn renumber_mir<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>, mir: &mut Mir<'tcx>) {\n     debug!(\"renumber_mir()\");\n     debug!(\"renumber_mir: mir.arg_count={:?}\", mir.arg_count);\n \n-    // Update the return type and types of the arguments based on the\n-    // `universal_regions` computation.\n-    debug!(\"renumber_mir: output_ty={:?}\", universal_regions.output_ty);\n-    mir.local_decls[RETURN_PLACE].ty = universal_regions.output_ty;\n-    for (&input_ty, local) in universal_regions\n-        .input_tys\n-        .iter()\n-        .zip((1..).map(Local::new))\n-    {\n-        debug!(\"renumber_mir: input_ty={:?} local={:?}\", input_ty, local);\n-        mir.local_decls[local].ty = input_ty;\n-    }\n-\n-    let mut visitor = NLLVisitor {\n-        infcx,\n-        arg_count: mir.arg_count,\n-    };\n+    let mut visitor = NLLVisitor { infcx };\n     visitor.visit_mir(mir);\n }\n \n struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    arg_count: usize,\n }\n \n impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n@@ -71,45 +45,13 @@ impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n                 self.infcx.next_nll_region_var(origin)\n             })\n     }\n-\n-    /// Checks that all the regions appearing in `value` have already\n-    /// been renumbered. `FreeRegions` code should have done this.\n-    fn assert_free_regions_are_renumbered<T>(&self, value: &T)\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        debug!(\"assert_free_regions_are_renumbered(value={:?})\", value);\n-\n-        self.infcx.tcx.for_each_free_region(value, |region| {\n-            region.to_region_vid(); // will panic if `region` is not renumbered\n-        });\n-    }\n-\n-    fn is_argument_or_return_slot(&self, local: Local) -> bool {\n-        // The first argument is return slot, next N are arguments.\n-        local.index() <= self.arg_count\n-    }\n }\n \n impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, ty_context: TyContext) {\n-        let is_arg = match ty_context {\n-            TyContext::LocalDecl { local, .. } => self.is_argument_or_return_slot(local),\n-            TyContext::ReturnTy(..) => true,\n-            TyContext::Location(..) => false,\n-        };\n-        debug!(\n-            \"visit_ty(ty={:?}, is_arg={:?}, ty_context={:?})\",\n-            ty,\n-            is_arg,\n-            ty_context\n-        );\n+        debug!(\"visit_ty(ty={:?}, ty_context={:?})\", ty, ty_context);\n \n-        if is_arg {\n-            self.assert_free_regions_are_renumbered(ty);\n-        } else {\n-            *ty = self.renumber_regions(ty_context, ty);\n-        }\n+        *ty = self.renumber_regions(ty_context, ty);\n \n         debug!(\"visit_ty: ty={:?}\", ty);\n     }"}, {"sha": "e42302761bfa37f577f743d9e44ef617f15ace47", "filename": "src/librustc_mir/borrow_check/nll/subtype_constraint_generation.rs", "status": "modified", "additions": 63, "deletions": 9, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -11,11 +11,14 @@\n use rustc::mir::Mir;\n use rustc::infer::region_constraints::Constraint;\n use rustc::infer::region_constraints::RegionConstraintData;\n+use rustc::infer::region_constraints::{Verify, VerifyBound};\n use rustc::ty;\n-use transform::type_check::MirTypeckRegionConstraints;\n-use transform::type_check::OutlivesSet;\n+use syntax::codemap::Span;\n \n-use super::region_infer::RegionInferenceContext;\n+use super::region_infer::{TypeTest, RegionInferenceContext, RegionTest};\n+use super::type_check::Locations;\n+use super::type_check::MirTypeckRegionConstraints;\n+use super::type_check::OutlivesSet;\n \n /// When the MIR type-checker executes, it validates all the types in\n /// the MIR, and in the process generates a set of constraints that\n@@ -27,10 +30,7 @@ pub(super) fn generate<'tcx>(\n     mir: &Mir<'tcx>,\n     constraints: &MirTypeckRegionConstraints<'tcx>,\n ) {\n-    SubtypeConstraintGenerator {\n-        regioncx,\n-        mir,\n-    }.generate(constraints);\n+    SubtypeConstraintGenerator { regioncx, mir }.generate(constraints);\n }\n \n struct SubtypeConstraintGenerator<'cx, 'tcx: 'cx> {\n@@ -65,6 +65,8 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n                 givens,\n             } = data;\n \n+            let span = self.mir.source_info(locations.from_location).span;\n+\n             for constraint in constraints.keys() {\n                 debug!(\"generate: constraint: {:?}\", constraint);\n                 let (a_vid, b_vid) = match constraint {\n@@ -81,19 +83,71 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n                 // reverse direction, because `regioncx` talks about\n                 // \"outlives\" (`>=`) whereas the region constraints\n                 // talk about `<=`.\n-                let span = self.mir.source_info(locations.from_location).span;\n                 self.regioncx\n                     .add_outlives(span, b_vid, a_vid, locations.at_location);\n             }\n \n-            assert!(verifys.is_empty(), \"verifys not yet implemented\");\n+            for verify in verifys {\n+                let type_test = self.verify_to_type_test(verify, span, locations);\n+                self.regioncx.add_type_test(type_test);\n+            }\n+\n             assert!(\n                 givens.is_empty(),\n                 \"MIR type-checker does not use givens (thank goodness)\"\n             );\n         }\n     }\n \n+    fn verify_to_type_test(\n+        &self,\n+        verify: &Verify<'tcx>,\n+        span: Span,\n+        locations: &Locations,\n+    ) -> TypeTest<'tcx> {\n+        let generic_kind = verify.kind;\n+\n+        let lower_bound = self.to_region_vid(verify.region);\n+\n+        let point = locations.at_location;\n+\n+        let test = self.verify_bound_to_region_test(&verify.bound);\n+\n+        TypeTest {\n+            generic_kind,\n+            lower_bound,\n+            point,\n+            span,\n+            test,\n+        }\n+    }\n+\n+    fn verify_bound_to_region_test(&self, verify_bound: &VerifyBound<'tcx>) -> RegionTest {\n+        match verify_bound {\n+            VerifyBound::AnyRegion(regions) => RegionTest::IsOutlivedByAnyRegionIn(\n+                regions.iter().map(|r| self.to_region_vid(r)).collect(),\n+            ),\n+\n+            VerifyBound::AllRegions(regions) => RegionTest::IsOutlivedByAllRegionsIn(\n+                regions.iter().map(|r| self.to_region_vid(r)).collect(),\n+            ),\n+\n+            VerifyBound::AnyBound(bounds) => RegionTest::Any(\n+                bounds\n+                    .iter()\n+                    .map(|b| self.verify_bound_to_region_test(b))\n+                    .collect(),\n+            ),\n+\n+            VerifyBound::AllBounds(bounds) => RegionTest::All(\n+                bounds\n+                    .iter()\n+                    .map(|b| self.verify_bound_to_region_test(b))\n+                    .collect(),\n+            ),\n+        }\n+    }\n+\n     fn to_region_vid(&self, r: ty::Region<'tcx>) -> ty::RegionVid {\n         // Every region that we see in the constraints came from the\n         // MIR or from the parameter environment. If the former, it"}, {"sha": "e41bf7cda8e6c32ea0d91bcf9bca89742ff21e89", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,220 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use dataflow::{FlowAtLocation, FlowsAtLocation};\n+use dataflow::MaybeInitializedLvals;\n+use dataflow::move_paths::{HasMoveData, MoveData};\n+use rustc::mir::{BasicBlock, Location, Mir};\n+use rustc::mir::Local;\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::util::common::ErrorReported;\n+use rustc_data_structures::fx::FxHashSet;\n+use syntax::codemap::DUMMY_SP;\n+use util::liveness::LivenessResults;\n+\n+use super::TypeChecker;\n+\n+/// Combines liveness analysis with initialization analysis to\n+/// determine which variables are live at which points, both due to\n+/// ordinary uses and drops. Returns a set of (ty, location) pairs\n+/// that indicate which types must be live at which point in the CFG.\n+/// This vector is consumed by `constraint_generation`.\n+///\n+/// NB. This computation requires normalization; therefore, it must be\n+/// performed before\n+pub(super) fn generate<'gcx, 'tcx>(\n+    cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    liveness: &LivenessResults,\n+    flow_inits: &mut FlowAtLocation<MaybeInitializedLvals<'_, 'gcx, 'tcx>>,\n+    move_data: &MoveData<'tcx>,\n+) {\n+    let tcx = cx.tcx();\n+    let mut generator = TypeLivenessGenerator {\n+        cx,\n+        tcx,\n+        mir,\n+        liveness,\n+        flow_inits,\n+        move_data,\n+    };\n+\n+    for bb in mir.basic_blocks().indices() {\n+        generator.add_liveness_constraints(bb);\n+    }\n+}\n+\n+struct TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx>\n+where\n+    'typeck: 'gen,\n+    'flow: 'gen,\n+    'tcx: 'typeck + 'flow,\n+    'gcx: 'tcx,\n+{\n+    cx: &'gen mut TypeChecker<'typeck, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'typeck, 'gcx, 'tcx>,\n+    mir: &'gen Mir<'tcx>,\n+    liveness: &'gen LivenessResults,\n+    flow_inits: &'gen mut FlowAtLocation<MaybeInitializedLvals<'flow, 'gcx, 'tcx>>,\n+    move_data: &'gen MoveData<'tcx>,\n+}\n+\n+impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx> {\n+    /// Liveness constraints:\n+    ///\n+    /// > If a variable V is live at point P, then all regions R in the type of V\n+    /// > must include the point P.\n+    fn add_liveness_constraints(&mut self, bb: BasicBlock) {\n+        debug!(\"add_liveness_constraints(bb={:?})\", bb);\n+\n+        self.liveness\n+            .regular\n+            .simulate_block(self.mir, bb, |location, live_locals| {\n+                for live_local in live_locals.iter() {\n+                    let live_local_ty = self.mir.local_decls[live_local].ty;\n+                    self.push_type_live_constraint(live_local_ty, location);\n+                }\n+            });\n+\n+        let mut all_live_locals: Vec<(Location, Vec<Local>)> = vec![];\n+        self.liveness\n+            .drop\n+            .simulate_block(self.mir, bb, |location, live_locals| {\n+                all_live_locals.push((location, live_locals.iter().collect()));\n+            });\n+        debug!(\n+            \"add_liveness_constraints: all_live_locals={:#?}\",\n+            all_live_locals\n+        );\n+\n+        let terminator_index = self.mir.basic_blocks()[bb].statements.len();\n+        self.flow_inits.reset_to_entry_of(bb);\n+        while let Some((location, live_locals)) = all_live_locals.pop() {\n+            for live_local in live_locals {\n+                debug!(\n+                    \"add_liveness_constraints: location={:?} live_local={:?}\",\n+                    location,\n+                    live_local\n+                );\n+\n+                self.flow_inits.each_state_bit(|mpi_init| {\n+                    debug!(\n+                        \"add_liveness_constraints: location={:?} initialized={:?}\",\n+                        location,\n+                        &self.flow_inits.operator().move_data().move_paths[mpi_init]\n+                    );\n+                });\n+\n+                let mpi = self.move_data.rev_lookup.find_local(live_local);\n+                if let Some(initialized_child) = self.flow_inits.has_any_child_of(mpi) {\n+                    debug!(\n+                        \"add_liveness_constraints: mpi={:?} has initialized child {:?}\",\n+                        self.move_data.move_paths[mpi],\n+                        self.move_data.move_paths[initialized_child]\n+                    );\n+\n+                    let live_local_ty = self.mir.local_decls[live_local].ty;\n+                    self.add_drop_live_constraint(live_local_ty, location);\n+                }\n+            }\n+\n+            if location.statement_index == terminator_index {\n+                debug!(\n+                    \"add_liveness_constraints: reconstruct_terminator_effect from {:#?}\",\n+                    location\n+                );\n+                self.flow_inits.reconstruct_terminator_effect(location);\n+            } else {\n+                debug!(\n+                    \"add_liveness_constraints: reconstruct_statement_effect from {:#?}\",\n+                    location\n+                );\n+                self.flow_inits.reconstruct_statement_effect(location);\n+            }\n+            self.flow_inits.apply_local_effect(location);\n+        }\n+    }\n+\n+    /// Some variable with type `live_ty` is \"regular live\" at\n+    /// `location` -- i.e., it may be used later. This means that all\n+    /// regions appearing in the type `live_ty` must be live at\n+    /// `location`.\n+    fn push_type_live_constraint<T>(&mut self, value: T, location: Location)\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        debug!(\n+            \"push_type_live_constraint(live_ty={:?}, location={:?})\",\n+            value,\n+            location\n+        );\n+\n+        self.tcx.for_each_free_region(&value, |live_region| {\n+            self.cx\n+                .constraints\n+                .liveness_set\n+                .push((live_region, location));\n+        });\n+    }\n+\n+    /// Some variable with type `live_ty` is \"drop live\" at `location`\n+    /// -- i.e., it may be dropped later. This means that *some* of\n+    /// the regions in its type must be live at `location`. The\n+    /// precise set will depend on the dropck constraints, and in\n+    /// particular this takes `#[may_dangle]` into account.\n+    fn add_drop_live_constraint(&mut self, dropped_ty: Ty<'tcx>, location: Location) {\n+        debug!(\n+            \"add_drop_live_constraint(dropped_ty={:?}, location={:?})\",\n+            dropped_ty,\n+            location\n+        );\n+\n+        let tcx = self.cx.infcx.tcx;\n+        let mut types = vec![(dropped_ty, 0)];\n+        let mut known = FxHashSet();\n+        while let Some((ty, depth)) = types.pop() {\n+            let span = DUMMY_SP; // FIXME\n+            let result = match tcx.dtorck_constraint_for_ty(span, dropped_ty, depth, ty) {\n+                Ok(result) => result,\n+                Err(ErrorReported) => {\n+                    continue;\n+                }\n+            };\n+\n+            let ty::DtorckConstraint {\n+                outlives,\n+                dtorck_types,\n+            } = result;\n+\n+            // All things in the `outlives` array may be touched by\n+            // the destructor and must be live at this point.\n+            for outlive in outlives {\n+                self.push_type_live_constraint(outlive, location);\n+            }\n+\n+            // However, there may also be some types that\n+            // `dtorck_constraint_for_ty` could not resolve (e.g.,\n+            // associated types and parameters). We need to normalize\n+            // associated types here and possibly recursively process.\n+            for ty in dtorck_types {\n+                let ty = self.cx.normalize(&ty, location);\n+                match ty.sty {\n+                    ty::TyParam(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n+                        self.push_type_live_constraint(ty, location);\n+                    }\n+\n+                    _ => if known.insert(ty) {\n+                        types.push((ty, depth + 1));\n+                    },\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "6cdd77048c998d2b8e8b122802fe953072bb0606", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "renamed", "additions": 97, "deletions": 8, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -12,6 +12,9 @@\n #![allow(unreachable_code)]\n \n use borrow_check::nll::region_infer::ClosureRegionRequirementsExt;\n+use dataflow::FlowAtLocation;\n+use dataflow::MaybeInitializedLvals;\n+use dataflow::move_paths::MoveData;\n use rustc::infer::{InferCtxt, InferOk, InferResult, LateBoundRegionConversionTime, UnitResult};\n use rustc::infer::region_constraints::RegionConstraintData;\n use rustc::traits::{self, FulfillmentContext};\n@@ -26,24 +29,80 @@ use std::fmt;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n use transform::{MirPass, MirSource};\n+use util::liveness::LivenessResults;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n \n+mod liveness;\n+\n /// Type checks the given `mir` in the context of the inference\n /// context `infcx`. Returns any region constraints that have yet to\n-/// be proven.\n+/// be proven. This result is includes liveness constraints that\n+/// ensure that regions appearing in the types of all local variables\n+/// are live at all points where that local variable may later be\n+/// used.\n ///\n /// This phase of type-check ought to be infallible -- this is because\n /// the original, HIR-based type-check succeeded. So if any errors\n /// occur here, we will get a `bug!` reported.\n-pub fn type_check<'a, 'gcx, 'tcx>(\n-    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+///\n+/// # Parameters\n+///\n+/// - `infcx` -- inference context to use\n+/// - `body_id` -- body-id of the MIR being checked\n+/// - `param_env` -- parameter environment to use for trait solving\n+/// - `mir` -- MIR to type-check\n+/// - `implicit_region_bound` -- a region which all generic parameters are assumed\n+///   to outlive; should represent the fn body\n+/// - `input_tys` -- fully liberated, but **not** normalized, expected types of the arguments;\n+///   the types of the input parameters found in the MIR itself will be equated with these\n+/// - `output_ty` -- fully liberaetd, but **not** normalized, expected return type;\n+///   the type for the RETURN_PLACE will be equated with this\n+/// - `liveness` -- results of a liveness computation on the MIR; used to create liveness\n+///   constraints for the regions in the types of variables\n+/// - `flow_inits` -- results of a maybe-init dataflow analysis\n+/// - `move_data` -- move-data constructed when performing the maybe-init dataflow analysis\n+pub(crate) fn type_check<'gcx, 'tcx>(\n+    infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n     body_id: ast::NodeId,\n     param_env: ty::ParamEnv<'gcx>,\n     mir: &Mir<'tcx>,\n+    implicit_region_bound: ty::Region<'tcx>,\n+    input_tys: &[Ty<'tcx>],\n+    output_ty: Ty<'tcx>,\n+    liveness: &LivenessResults,\n+    flow_inits: &mut FlowAtLocation<MaybeInitializedLvals<'_, 'gcx, 'tcx>>,\n+    move_data: &MoveData<'tcx>,\n ) -> MirTypeckRegionConstraints<'tcx> {\n-    let mut checker = TypeChecker::new(infcx, body_id, param_env);\n+    type_check_internal(\n+        infcx,\n+        body_id,\n+        param_env,\n+        mir,\n+        Some(implicit_region_bound),\n+        &mut |cx| {\n+            liveness::generate(cx, mir, liveness, flow_inits, move_data);\n+\n+            // Equate the input and output tys given by the user with\n+            // the ones found in the MIR.\n+            cx.equate_input_or_output(output_ty, mir.local_decls[RETURN_PLACE].ty);\n+            for (&input_ty, local) in input_tys.iter().zip((1..).map(Local::new)) {\n+                cx.equate_input_or_output(input_ty, mir.local_decls[local].ty);\n+            }\n+        },\n+    )\n+}\n+\n+fn type_check_internal<'gcx, 'tcx>(\n+    infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+    body_id: ast::NodeId,\n+    param_env: ty::ParamEnv<'gcx>,\n+    mir: &Mir<'tcx>,\n+    implicit_region_bound: Option<ty::Region<'tcx>>,\n+    extra: &mut FnMut(&mut TypeChecker<'_, 'gcx, 'tcx>),\n+) -> MirTypeckRegionConstraints<'tcx> {\n+    let mut checker = TypeChecker::new(infcx, body_id, param_env, implicit_region_bound);\n     let errors_reported = {\n         let mut verifier = TypeVerifier::new(&mut checker, mir);\n         verifier.visit_mir(mir);\n@@ -55,9 +114,12 @@ pub fn type_check<'a, 'gcx, 'tcx>(\n         checker.typeck_mir(mir);\n     }\n \n+    extra(&mut checker);\n+\n     checker.constraints\n }\n \n+\n fn mirbug(tcx: TyCtxt, span: Span, msg: &str) {\n     // We sometimes see MIR failures (notably predicate failures) due to\n     // the fact that we check rvalue sized predicates here. So use `delay_span_bug`\n@@ -503,11 +565,12 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n /// constraints needed for it to be valid and well-typed. Along the\n /// way, it accrues region constraints -- these can later be used by\n /// NLL region checking.\n-pub struct TypeChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+struct TypeChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'gcx>,\n     last_span: Span,\n     body_id: ast::NodeId,\n+    implicit_region_bound: Option<ty::Region<'tcx>>,\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     constraints: MirTypeckRegionConstraints<'tcx>,\n }\n@@ -561,12 +624,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n         body_id: ast::NodeId,\n         param_env: ty::ParamEnv<'gcx>,\n+        implicit_region_bound: Option<ty::Region<'tcx>>,\n     ) -> Self {\n         TypeChecker {\n             infcx,\n             last_span: DUMMY_SP,\n             body_id,\n             param_env,\n+            implicit_region_bound,\n             reported_errors: FxHashSet(),\n             constraints: MirTypeckRegionConstraints::default(),\n         }\n@@ -591,8 +656,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             span_mirbug!(self, \"\", \"errors selecting obligation: {:?}\", e);\n         }\n \n-        self.infcx\n-            .process_registered_region_obligations(&[], None, self.param_env, self.body_id);\n+        self.infcx.process_registered_region_obligations(\n+            &[],\n+            self.implicit_region_bound,\n+            self.param_env,\n+            self.body_id,\n+        );\n \n         let data = self.infcx.take_and_reset_region_constraints();\n         if !data.is_empty() {\n@@ -625,6 +694,25 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         })\n     }\n \n+    fn equate_input_or_output(&mut self, unnormalized_a: Ty<'tcx>, b: Ty<'tcx>) {\n+        let start_position = Location {\n+            block: START_BLOCK,\n+            statement_index: 0,\n+        };\n+        let a = self.normalize(&unnormalized_a, start_position);\n+        if let Err(terr) = self.eq_types(a, b, start_position.at_self()) {\n+            span_mirbug!(\n+                self,\n+                start_position,\n+                \"bad input or output {:?} normalized to {:?} should equal {:?} but got error {:?}\",\n+                unnormalized_a,\n+                a,\n+                b,\n+                terr\n+            );\n+        }\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n@@ -1368,6 +1456,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 if let Some(closure_region_requirements) = tcx.mir_borrowck(*def_id) {\n                     closure_region_requirements.apply_requirements(\n                         self.infcx,\n+                        self.body_id,\n                         location,\n                         *def_id,\n                         *substs,\n@@ -1474,7 +1563,7 @@ impl MirPass for TypeckMir {\n         }\n         let param_env = tcx.param_env(def_id);\n         tcx.infer_ctxt().enter(|infcx| {\n-            let _region_constraint_sets = type_check(&infcx, id, param_env, mir);\n+            let _ = type_check_internal(&infcx, id, param_env, mir, None, &mut |_| ());\n \n             // For verification purposes, we just ignore the resulting\n             // region constraint sets. Not our problem. =)", "previous_filename": "src/librustc_mir/transform/type_check.rs"}, {"sha": "a1e6ea135c68dc2a67759393af378ee0fa5d7276", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 57, "deletions": 25, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -45,6 +45,11 @@ pub struct UniversalRegions<'tcx> {\n     /// The vid assigned to `'static`\n     pub fr_static: RegionVid,\n \n+    /// A special region vid created to represent the current MIR fn\n+    /// body.  It will outlive the entire CFG but it will not outlive\n+    /// any other universal regions.\n+    pub fr_fn_body: RegionVid,\n+\n     /// We create region variables such that they are ordered by their\n     /// `RegionClassification`. The first block are globals, then\n     /// externals, then locals. So things from:\n@@ -64,12 +69,16 @@ pub struct UniversalRegions<'tcx> {\n     /// closure type, but for a top-level function it's the `TyFnDef`.\n     pub defining_ty: Ty<'tcx>,\n \n-    /// The return type of this function, with all regions replaced\n-    /// by their universal `RegionVid` equivalents.\n+    /// The return type of this function, with all regions replaced by\n+    /// their universal `RegionVid` equivalents. This type is **NOT\n+    /// NORMALIZED** (i.e., it contains unnormalized associated type\n+    /// projections).\n     pub output_ty: Ty<'tcx>,\n \n     /// The fully liberated input types of this function, with all\n     /// regions replaced by their universal `RegionVid` equivalents.\n+    /// This type is **NOT NORMALIZED** (i.e., it contains\n+    /// unnormalized associated type projections).\n     pub input_tys: &'tcx [Ty<'tcx>],\n \n     /// Each RBP `('a, GK)` indicates that `GK: 'a` can be assumed to\n@@ -242,17 +251,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n         (FIRST_GLOBAL_INDEX..self.num_universals).map(RegionVid::new)\n     }\n \n-    /// True if `r` is classied as a global region.\n-    pub fn is_global_free_region(&self, r: RegionVid) -> bool {\n-        self.region_classification(r) == Some(RegionClassification::Global)\n-    }\n-\n-    /// True if `r` is classied as an external region.\n-    pub fn is_extern_free_region(&self, r: RegionVid) -> bool {\n-        self.region_classification(r) == Some(RegionClassification::External)\n-    }\n-\n-    /// True if `r` is classied as an local region.\n+    /// True if `r` is classified as an local region.\n     pub fn is_local_free_region(&self, r: RegionVid) -> bool {\n         self.region_classification(r) == Some(RegionClassification::Local)\n     }\n@@ -262,6 +261,20 @@ impl<'tcx> UniversalRegions<'tcx> {\n         self.num_universals\n     }\n \n+    /// Given two universal regions, returns the postdominating\n+    /// upper-bound (effectively the least upper bound).\n+    ///\n+    /// (See `TransitiveRelation::postdom_upper_bound` for details on\n+    /// the postdominating upper bound in general.)\n+    pub fn postdom_upper_bound(&self, fr1: RegionVid, fr2: RegionVid) -> RegionVid {\n+        assert!(self.is_universal_region(fr1));\n+        assert!(self.is_universal_region(fr2));\n+        *self.relations\n+            .inverse_outlives\n+            .postdom_upper_bound(&fr1, &fr2)\n+            .unwrap_or(&self.fr_static)\n+    }\n+\n     /// Finds an \"upper bound\" for `fr` that is not local. In other\n     /// words, returns the smallest (*) known region `fr1` that (a)\n     /// outlives `fr` and (b) is not local. This cannot fail, because\n@@ -305,6 +318,10 @@ impl<'tcx> UniversalRegions<'tcx> {\n         relation: &TransitiveRelation<RegionVid>,\n         fr0: RegionVid,\n     ) -> Option<RegionVid> {\n+        // This method assumes that `fr0` is one of the universally\n+        // quantified region variables.\n+        assert!(self.is_universal_region(fr0));\n+\n         let mut external_parents = vec![];\n         let mut queue = vec![&fr0];\n \n@@ -408,6 +425,7 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n         let first_local_index = self.infcx.num_region_vars();\n         let inputs_and_output = self.infcx\n             .replace_bound_regions_with_nll_infer_vars(FR, &bound_inputs_and_output);\n+        let fr_fn_body = self.infcx.next_nll_region_var(FR).to_region_vid();\n         let num_universals = self.infcx.num_region_vars();\n \n         // Insert the facts we know from the predicates. Why? Why not.\n@@ -419,32 +437,46 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n             self.add_implied_bounds(&indices, ty);\n         }\n \n-        // Finally, outlives is reflexive, and static outlives every\n-        // other free region.\n+        // Finally:\n+        // - outlives is reflexive, so `'r: 'r` for every region `'r`\n+        // - `'static: 'r` for every region `'r`\n+        // - `'r: 'fn_body` for every (other) universally quantified\n+        //   region `'r`, all of which are provided by our caller\n         for fr in (FIRST_GLOBAL_INDEX..num_universals).map(RegionVid::new) {\n-            debug!(\"build: relating free region {:?} to itself and to 'static\", fr);\n+            debug!(\n+                \"build: relating free region {:?} to itself and to 'static\",\n+                fr\n+            );\n             self.relations.relate_universal_regions(fr, fr);\n             self.relations.relate_universal_regions(fr_static, fr);\n+            self.relations.relate_universal_regions(fr, fr_fn_body);\n         }\n \n         let (output_ty, input_tys) = inputs_and_output.split_last().unwrap();\n \n         // we should not have created any more variables\n         assert_eq!(self.infcx.num_region_vars(), num_universals);\n \n-        debug!(\"build: global regions = {}..{}\",\n-               FIRST_GLOBAL_INDEX,\n-               first_extern_index);\n-        debug!(\"build: extern regions = {}..{}\",\n-               first_extern_index,\n-               first_local_index);\n-        debug!(\"build: local regions  = {}..{}\",\n-               first_local_index,\n-               num_universals);\n+        debug!(\n+            \"build: global regions = {}..{}\",\n+            FIRST_GLOBAL_INDEX,\n+            first_extern_index\n+        );\n+        debug!(\n+            \"build: extern regions = {}..{}\",\n+            first_extern_index,\n+            first_local_index\n+        );\n+        debug!(\n+            \"build: local regions  = {}..{}\",\n+            first_local_index,\n+            num_universals\n+        );\n \n         UniversalRegions {\n             indices,\n             fr_static,\n+            fr_fn_body,\n             first_extern_index,\n             first_local_index,\n             num_universals,"}, {"sha": "7f243ad6e264c7da515b1dd10af9f8943b4bbef2", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -25,26 +25,43 @@ use std::iter;\n /// There's probably a way to auto-impl this, but I think\n /// it is cleaner to have manual visitor impls.\n pub trait FlowsAtLocation {\n-    // reset the state bitvector to represent the entry to block `bb`.\n+    /// Reset the state bitvector to represent the entry to block `bb`.\n     fn reset_to_entry_of(&mut self, bb: BasicBlock);\n \n-    // build gen + kill sets for statement at `loc`.\n+    /// Build gen + kill sets for statement at `loc`.\n+    ///\n+    /// Note that invoking this method alone does not change the\n+    /// `curr_state` -- you must invoke `apply_local_effect`\n+    /// afterwards.\n     fn reconstruct_statement_effect(&mut self, loc: Location);\n \n-    // build gen + kill sets for terminator for `loc`.\n+    /// Build gen + kill sets for terminator for `loc`.\n+    ///\n+    /// Note that invoking this method alone does not change the\n+    /// `curr_state` -- you must invoke `apply_local_effect`\n+    /// afterwards.\n     fn reconstruct_terminator_effect(&mut self, loc: Location);\n \n-    // apply current gen + kill sets to `flow_state`.\n-    //\n-    // (`bb` and `stmt_idx` parameters can be ignored if desired by\n-    // client. For the terminator, the `stmt_idx` will be the number\n-    // of statements in the block.)\n+    /// Apply current gen + kill sets to `flow_state`.\n+    ///\n+    /// (`loc` parameters can be ignored if desired by\n+    /// client. For the terminator, the `stmt_idx` will be the number\n+    /// of statements in the block.)\n     fn apply_local_effect(&mut self, loc: Location);\n }\n \n /// Represents the state of dataflow at a particular\n /// CFG location, both before and after it is\n /// executed.\n+///\n+/// Data flow results are typically computed only as basic block\n+/// boundaries. A `FlowInProgress` allows you to reconstruct the\n+/// effects at any point in the control-flow graph by starting with\n+/// the state at the start of the basic block (`reset_to_entry_of`)\n+/// and then replaying the effects of statements and terminators\n+/// (e.g. via `reconstruct_statement_effect` and\n+/// `reconstruct_terminator_effect`; don't forget to call\n+/// `apply_local_effect`).\n pub struct FlowAtLocation<BD>\n where\n     BD: BitDenotation,\n@@ -59,6 +76,7 @@ impl<BD> FlowAtLocation<BD>\n where\n     BD: BitDenotation,\n {\n+    /// Iterate over each bit set in the current state.\n     pub fn each_state_bit<F>(&self, f: F)\n     where\n         F: FnMut(BD::Idx),\n@@ -67,6 +85,9 @@ where\n             .each_bit(self.base_results.operator().bits_per_block(), f)\n     }\n \n+    /// Iterate over each `gen` bit in the current effect (invoke\n+    /// `reconstruct_statement_effect` or\n+    /// `reconstruct_terminator_effect` first).\n     pub fn each_gen_bit<F>(&self, f: F)\n     where\n         F: FnMut(BD::Idx),\n@@ -88,6 +109,7 @@ where\n         }\n     }\n \n+    /// Access the underlying operator.\n     pub fn operator(&self) -> &BD {\n         self.base_results.operator()\n     }\n@@ -96,11 +118,15 @@ where\n         self.curr_state.contains(x)\n     }\n \n+    /// Returns an iterator over the elements present in the current state.\n     pub fn elems_incoming(&self) -> iter::Peekable<indexed_set::Elems<BD::Idx>> {\n         let univ = self.base_results.sets().bits_per_block();\n         self.curr_state.elems(univ).peekable()\n     }\n \n+    /// Creates a clone of the current state and applies the local\n+    /// effects to the clone (leaving the state of self intact).\n+    /// Invokes `f` with an iterator over the resulting state.\n     pub fn with_elems_outgoing<F>(&self, f: F)\n     where\n         F: FnOnce(indexed_set::Elems<BD::Idx>),"}, {"sha": "563405fccc970a3dbd612b9fcc5640cdcab4c22a", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use borrow_check::nll::type_check;\n use build;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::mir::{Mir, Promoted};\n@@ -30,7 +31,6 @@ pub mod simplify_branches;\n pub mod simplify;\n pub mod erase_regions;\n pub mod no_landing_pads;\n-pub mod type_check;\n pub mod rustc_peek;\n pub mod elaborate_drops;\n pub mod add_call_guards;"}, {"sha": "5163f74dd25298a78f20dba4fe71db3998c97655", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -80,6 +80,39 @@ pub struct LivenessMode {\n     pub include_drops: bool,\n }\n \n+/// A combination of liveness results, used in NLL.\n+pub struct LivenessResults {\n+    /// Liveness results where a regular use makes a variable X live,\n+    /// but not a drop.\n+    pub regular: LivenessResult,\n+\n+    /// Liveness results where a drop makes a variable X live,\n+    /// but not a regular use.\n+    pub drop: LivenessResult,\n+}\n+\n+impl LivenessResults {\n+    pub fn compute<'tcx>(mir: &Mir<'tcx>) -> LivenessResults {\n+        LivenessResults {\n+            regular: liveness_of_locals(\n+                &mir,\n+                LivenessMode {\n+                    include_regular_use: true,\n+                    include_drops: false,\n+                },\n+            ),\n+\n+            drop: liveness_of_locals(\n+                &mir,\n+                LivenessMode {\n+                    include_regular_use: false,\n+                    include_drops: true,\n+                },\n+            ),\n+        }\n+    }\n+}\n+\n /// Compute which local variables are live within the given function\n /// `mir`. The liveness mode `mode` determines what sorts of uses are\n /// considered to make a variable live (e.g., do drops count?)."}, {"sha": "df42d5eaa0a3d6abd57e443aa1fcf7ffb8d2942e", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -465,6 +465,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::ReFree(..) |\n+            ty::ReClosureBound(..) |\n             ty::ReScope(..) |\n             ty::ReVar(..) |\n             ty::ReSkolemized(..) |"}, {"sha": "2bf701d1f4e50fcd7dba280c596a71e1cc08034f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -1055,6 +1055,7 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n             ty::ReVar(..) |\n             ty::ReSkolemized(..) |\n             ty::ReEmpty |\n+            ty::ReClosureBound(_) |\n             ty::ReErased => None\n         }\n     }"}, {"sha": "6562efeb6d893a628b9ad646a2f001ccad2c21b2", "filename": "src/test/compile-fail/mir_check_cast_closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_closure.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -14,9 +14,9 @@\n \n fn bar<'a, 'b>() -> fn(&'a u32, &'b u32) -> &'a u32 {\n     let g: fn(_, _) -> _ = |_x, y| y;\n+    //~^ ERROR free region `'b` does not outlive free region `'a`\n     g\n     //~^ WARNING not reporting region error due to -Znll\n-    //~| ERROR free region `'b` does not outlive free region `'a`\n }\n \n fn main() {}"}, {"sha": "1736aea2d6de7604aad69d92284f174b46df9b90", "filename": "src/test/compile-fail/mir_check_cast_reify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_reify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_reify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_reify.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -45,8 +45,8 @@ fn bar<'a>(x: &'a u32) -> &'static u32 {\n     // as part of checking the `ReifyFnPointer`.\n     let f: fn(_) -> _ = foo;\n     //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR free region `'_#1r` does not outlive free region `'static`\n     f(x)\n-    //~^ ERROR free region `'_#1r` does not outlive free region `'static`\n }\n \n fn main() {}"}, {"sha": "39eafa10040264f3cdd40fab10b2534085b0c7e8", "filename": "src/test/compile-fail/mir_check_cast_unsafe_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsafe_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsafe_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsafe_fn.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -17,8 +17,8 @@ fn bar<'a>(input: &'a u32, f: fn(&'a u32) -> &'a u32) -> &'static u32 {\n     // in `g`. These are related via the `UnsafeFnPointer` cast.\n     let g: unsafe fn(_) -> _ = f;\n     //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR free region `'_#1r` does not outlive free region `'static`\n     unsafe { g(input) }\n-    //~^ ERROR free region `'_#1r` does not outlive free region `'static`\n }\n \n fn main() {}"}, {"sha": "8feac15d69a82a484b442589d047b18fb95c003b", "filename": "src/test/mir-opt/nll/named-lifetimes-basic.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -27,17 +27,23 @@ fn main() {\n // END RUST SOURCE\n // START rustc.use_x.nll.0.mir\n // | Free Region Mapping\n-// | '_#0r    | Global   | ['_#2r, '_#1r, '_#0r, '_#3r]\n-// | '_#1r    | External | ['_#1r]\n-// | '_#2r    | External | ['_#2r, '_#1r]\n-// | '_#3r    | Local    | ['_#3r]\n+// | '_#0r    | Global   | ['_#2r, '_#1r, '_#0r, '_#4r, '_#3r]\n+// | '_#1r    | External | ['_#1r, '_#4r]\n+// | '_#2r    | External | ['_#2r, '_#1r, '_#4r]\n+// | '_#3r    | Local    | ['_#4r, '_#3r]\n+// | '_#4r    | Local    | ['_#4r]\n // |\n // | Inferred Region Values\n-// | '_#0r    | {'_#0r, bb0[0], bb0[1]}\n-// | '_#1r    | {'_#1r, bb0[0], bb0[1]}\n-// | '_#2r    | {'_#2r, bb0[0], bb0[1]}\n-// | '_#3r    | {'_#3r, bb0[0], bb0[1]}\n+// | '_#0r    | {'_#0r, bb0[0..=1]}\n+// | '_#1r    | {'_#1r, bb0[0..=1]}\n+// | '_#2r    | {'_#2r, bb0[0..=1]}\n+// | '_#3r    | {'_#3r, bb0[0..=1]}\n+// | '_#4r    | {'_#4r, bb0[0..=1]}\n+// | '_#5r    | {'_#1r, bb0[0..=1]}\n+// | '_#6r    | {'_#2r, bb0[0..=1]}\n+// | '_#7r    | {'_#1r, bb0[0..=1]}\n+// | '_#8r    | {'_#3r, bb0[0..=1]}\n // |\n // ...\n-// fn use_x(_1: &'_#1r mut i32, _2: &'_#2r u32, _3: &'_#1r u32, _4: &'_#3r u32) -> bool {\n+// fn use_x(_1: &'_#5r mut i32, _2: &'_#6r u32, _3: &'_#7r u32, _4: &'_#8r u32) -> bool {\n // END rustc.use_x.nll.0.mir"}, {"sha": "f69c51c3562dce3e2d3579169b9466c4afadbbc8", "filename": "src/test/mir-opt/nll/reborrow-basic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -28,11 +28,11 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#6r    | {bb0[6], bb0[7], bb0[8], bb0[9], bb0[10], bb0[11], bb0[12], bb0[13], bb0[14]}\n+// | '_#7r    | {bb0[6..=14]}\n // ...\n-// | '_#8r    | {bb0[11], bb0[12], bb0[13], bb0[14]}\n+// | '_#9r    | {bb0[11..=14]}\n // ...\n-// let _2: &'_#6r mut i32;\n+// let _2: &'_#7r mut i32;\n // ...\n-// let _4: &'_#8r mut i32;\n+// let _4: &'_#9r mut i32;\n // END rustc.main.nll.0.mir"}, {"sha": "e9834305550c39088b170e16695c9ab56b17188d", "filename": "src/test/mir-opt/nll/region-liveness-basic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -31,15 +31,15 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#1r    | {bb2[0], bb2[1], bb3[0], bb3[1]}\n-// | '_#2r    | {bb2[1], bb3[0], bb3[1]}\n+// | '_#2r    | {bb2[0..=1], bb3[0..=1]}\n+// | '_#3r    | {bb2[1], bb3[0..=1]}\n // ...\n-//             let _2: &'_#2r usize;\n+//             let _2: &'_#3r usize;\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n //    bb2: {\n //            | Live variables on entry to bb2[0]: [_1, _3]\n-//        _2 = &'_#1r _1[_3];\n+//        _2 = &'_#2r _1[_3];\n //            | Live variables on entry to bb2[1]: [_2]\n //        switchInt(const true) -> [0u8: bb4, otherwise: bb3];\n //    }"}, {"sha": "c14ce6bb581deb9dfa72c0aa9d2d3f95d5969833", "filename": "src/test/mir-opt/nll/region-liveness-drop-may-dangle.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-may-dangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-may-dangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-may-dangle.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -44,5 +44,7 @@ unsafe impl<#[may_dangle] T> Drop for Wrap<T> {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#5r    | {bb2[3], bb2[4], bb2[5], bb3[0], bb3[1]}\n+// | '_#6r    | {bb2[3..=5], bb3[0..=1]}\n+// ...\n+// let _2: Wrap<&'_#6r usize>;\n // END rustc.main.nll.0.mir"}, {"sha": "058a57fe612cff17c815c36bc1aa832339787130", "filename": "src/test/mir-opt/nll/region-liveness-drop-no-may-dangle.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-no-may-dangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-no-may-dangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-drop-no-may-dangle.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -46,5 +46,7 @@ impl<T> Drop for Wrap<T> {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#5r    | {bb2[3], bb2[4], bb2[5], bb3[0], bb3[1], bb3[2], bb4[0], bb5[0], bb5[1], bb5[2], bb6[0], bb7[0], bb7[1], bb8[0]}\n+// | '_#6r    | {bb2[3..=5], bb3[0..=2], bb4[0], bb5[0..=2], bb6[0], bb7[0..=1], bb8[0]}\n+// ...\n+// let _2: Wrap<&'_#6r usize>;\n // END rustc.main.nll.0.mir"}, {"sha": "821cd73667193afb145773501869b5755a5ab314", "filename": "src/test/mir-opt/nll/region-liveness-two-disjoint-uses.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -36,14 +36,14 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#1r    | {bb2[0], bb2[1], bb3[0], bb3[1]}\n+// | '_#2r    | {bb2[0..=1], bb3[0..=1]}\n // ...\n-// | '_#3r    | {bb8[1], bb8[2], bb8[3], bb8[4]}\n-// | '_#4r    | {bb2[1], bb3[0], bb3[1], bb8[2], bb8[3], bb8[4]}\n+// | '_#4r    | {bb8[1..=4]}\n+// | '_#5r    | {bb2[1], bb3[0..=1], bb8[2..=4]}\n // ...\n-// let mut _2: &'_#4r usize;\n+// let mut _2: &'_#5r usize;\n // ...\n-// _2 = &'_#1r _1[_3];\n+// _2 = &'_#2r _1[_3];\n // ...\n-// _2 = &'_#3r (*_10);\n+// _2 = &'_#4r (*_10);\n // END rustc.main.nll.0.mir"}, {"sha": "a3f68ed5ebf5eecd7f7f17d8bafb2bced9318296", "filename": "src/test/mir-opt/nll/region-subtyping-basic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -32,16 +32,16 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#1r    | {bb2[0], bb2[1], bb2[2], bb2[3], bb2[4], bb2[5], bb2[6], bb3[0], bb3[1]}\n-// | '_#2r    | {bb2[1], bb2[2], bb2[3], bb2[4], bb2[5], bb2[6], bb3[0], bb3[1]}\n-// | '_#3r    | {bb2[5], bb2[6], bb3[0], bb3[1]}\n+// | '_#2r    | {bb2[0..=6], bb3[0..=1]}\n+// | '_#3r    | {bb2[1..=6], bb3[0..=1]}\n+// | '_#4r    | {bb2[5..=6], bb3[0..=1]}\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n-// let _2: &'_#2r usize;\n+// let _2: &'_#3r usize;\n // ...\n-// let _6: &'_#3r usize;\n+// let _6: &'_#4r usize;\n // ...\n-// _2 = &'_#1r _1[_3];\n+// _2 = &'_#2r _1[_3];\n // ...\n // _7 = _2;\n // ..."}, {"sha": "3812ff404079937031cc1598f868bc14e825140d", "filename": "src/test/ui/nll/capture-ref-in-struct.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fcapture-ref-in-struct.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -7,7 +7,7 @@ error[E0597]: `y` does not live long enough\n 37 |     }\n    |      - borrowed value only lives until here\n    |\n-   = note: borrowed value must be valid for lifetime '_#4r...\n+   = note: borrowed value must be valid for lifetime '_#5r...\n \n error: aborting due to previous error\n "}, {"sha": "2dfafd8f1725b337b9221fd0b70134628ff04560", "filename": "src/test/ui/nll/closure-requirements/escape-argument-callee.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -10,7 +10,7 @@ error: free region `'_#4r` does not outlive free region `'_#3r`\n 36 |         let mut closure = expect_sig(|p, y| *p = y);\n    |                                             ^^^^^^\n \n-note: External requirements\n+note: No external requirements\n   --> $DIR/escape-argument-callee.rs:36:38\n    |\n 36 |         let mut closure = expect_sig(|p, y| *p = y);\n@@ -20,7 +20,6 @@ note: External requirements\n                i16,\n                for<'r, 's, 't0> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) mut &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) i32, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't0)) i32))\n            ]\n-   = note: number of external vids: 1\n \n note: No external requirements\n   --> $DIR/escape-argument-callee.rs:30:1"}, {"sha": "940197986001ac4265b905c62300df7ebfc34d5e", "filename": "src/test/ui/nll/closure-requirements/escape-argument.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -1,4 +1,4 @@\n-note: External requirements\n+note: No external requirements\n   --> $DIR/escape-argument.rs:36:38\n    |\n 36 |         let mut closure = expect_sig(|p, y| *p = y);\n@@ -8,7 +8,6 @@ note: External requirements\n                i16,\n                for<'r, 's> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) mut &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) i32, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) i32))\n            ]\n-   = note: number of external vids: 1\n \n note: No external requirements\n   --> $DIR/escape-argument.rs:30:1\n@@ -33,7 +32,7 @@ error[E0597]: `y` does not live long enough\n 39 |     }\n    |      - borrowed value only lives until here\n    |\n-   = note: borrowed value must be valid for lifetime '_#5r...\n+   = note: borrowed value must be valid for lifetime '_#6r...\n \n error: aborting due to previous error\n "}, {"sha": "277e5201416ad256e78e3442bf750678c2472a82", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-nested.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-nested.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -59,7 +59,7 @@ error[E0597]: `y` does not live long enough\n 36 |       }\n    |        - borrowed value only lives until here\n    |\n-   = note: borrowed value must be valid for lifetime '_#3r...\n+   = note: borrowed value must be valid for lifetime '_#4r...\n \n error: aborting due to previous error\n "}, {"sha": "709e6bc2de1592d22a9a56416e8b8edce168a804", "filename": "src/test/ui/nll/closure-requirements/escape-upvar-ref.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-upvar-ref.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -36,7 +36,7 @@ error[E0597]: `y` does not live long enough\n 36 |     }\n    |      - borrowed value only lives until here\n    |\n-   = note: borrowed value must be valid for lifetime '_#3r...\n+   = note: borrowed value must be valid for lifetime '_#4r...\n \n error: aborting due to previous error\n "}, {"sha": "50d7877de50d7be23e3cb9b9692fafd0f30ccb17", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-fail-no-postdom.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -54,8 +54,8 @@ fn supply<'a, 'b, 'c>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>, cell_c: Cell\n             // Only works if 'x: 'y:\n             let p = x.get();\n             //~^ WARN not reporting region error due to -Znll\n+            //~| ERROR free region `'_#5r` does not outlive free region `'_#6r`\n             demand_y(x, y, p)\n-            //~^ ERROR free region `'_#5r` does not outlive free region `'_#6r`\n         },\n     );\n }"}, {"sha": "f90bc7c175a96ba2810d114eb42759770a056938", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-fail-no-postdom.stderr", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -5,28 +5,27 @@ warning: not reporting region error due to -Znll\n    |                     ^^^^^^^\n \n error: free region `'_#5r` does not outlive free region `'_#6r`\n-  --> $DIR/propagate-approximated-fail-no-postdom.rs:57:25\n+  --> $DIR/propagate-approximated-fail-no-postdom.rs:55:17\n    |\n-57 |             demand_y(x, y, p)\n-   |                         ^\n+55 |             let p = x.get();\n+   |                 ^\n \n-note: External requirements\n+note: No external requirements\n   --> $DIR/propagate-approximated-fail-no-postdom.rs:53:9\n    |\n 53 | /         |_outlives1, _outlives2, _outlives3, x, y| {\n 54 | |             // Only works if 'x: 'y:\n 55 | |             let p = x.get();\n 56 | |             //~^ WARN not reporting region error due to -Znll\n-57 | |             demand_y(x, y, p)\n-58 | |             //~^ ERROR free region `'_#5r` does not outlive free region `'_#6r`\n+57 | |             //~| ERROR free region `'_#5r` does not outlive free region `'_#6r`\n+58 | |             demand_y(x, y, p)\n 59 | |         },\n    | |_________^\n    |\n    = note: defining type: DefId(0/1:20 ~ propagate_approximated_fail_no_postdom[317d]::supply[0]::{{closure}}[0]) with closure substs [\n                i16,\n                for<'r, 's> extern \"rust-call\" fn((std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) u32>, std::cell::Cell<&'_#2r &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) &'_#3r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) u32>))\n            ]\n-   = note: number of external vids: 4\n \n note: No external requirements\n   --> $DIR/propagate-approximated-fail-no-postdom.rs:48:1"}, {"sha": "4bae29ad32617128cbfa4b435b72266b83e8aef1", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-ref.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -24,10 +24,10 @@ note: External requirements\n    = note: where '_#1r: '_#2r\n \n error: free region `'_#1r` does not outlive free region `'_#2r`\n-  --> $DIR/propagate-approximated-ref.rs:53:38\n+  --> $DIR/propagate-approximated-ref.rs:53:29\n    |\n 53 |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n-   |                                      ^^^^^^^\n+   |                             ^^^^^^^\n \n note: No external requirements\n   --> $DIR/propagate-approximated-ref.rs:52:1"}, {"sha": "45dc5d913ee13f5b9ce5b97f12f4e81cc54fda53", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -10,7 +10,7 @@ error: free region `'_#2r` does not outlive free region `'_#1r`\n 33 |         cell_a.set(cell_x.get()); // forces 'x: 'a, error in closure\n    |         ^^^^^^\n \n-note: External requirements\n+note: No external requirements\n   --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:31:15\n    |\n 31 |       foo(cell, |cell_a, cell_x| {\n@@ -25,7 +25,6 @@ note: External requirements\n                i32,\n                for<'r> extern \"rust-call\" fn((std::cell::Cell<&'_#1r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) u32>))\n            ]\n-   = note: number of external vids: 2\n \n note: No external requirements\n   --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:28:1\n@@ -80,7 +79,7 @@ error[E0597]: `a` does not live long enough\n 49 | }\n    | - borrowed value only lives until here\n    |\n-   = note: borrowed value must be valid for lifetime '_#1r...\n+   = note: borrowed value must be valid for lifetime '_#2r...\n \n error: aborting due to 2 previous errors\n "}, {"sha": "502b344c89e448b2efcbb48fd689fd2eef8f8bc1", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-to-empty.stderr", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-to-empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-to-empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-to-empty.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,45 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/propagate-approximated-to-empty.rs:41:9\n+   |\n+41 |         demand_y(x, y, x.get())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: free region `'_#6r` does not outlive free region `'_#4r`\n+  --> $DIR/propagate-approximated-to-empty.rs:41:18\n+   |\n+41 |         demand_y(x, y, x.get())\n+   |                  ^\n+\n+note: No external requirements\n+  --> $DIR/propagate-approximated-to-empty.rs:39:47\n+   |\n+39 |       establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n+   |  _______________________________________________^\n+40 | |         // Only works if 'x: 'y:\n+41 | |         demand_y(x, y, x.get())\n+42 | |         //~^ WARN not reporting region error due to -Znll\n+43 | |         //~| ERROR free region `'_#6r` does not outlive free region `'_#4r`\n+44 | |     });\n+   | |_____^\n+   |\n+   = note: defining type: DefId(0/1:18 ~ propagate_approximated_to_empty[317d]::supply[0]::{{closure}}[0]) with closure substs [\n+               i16,\n+               for<'r, 's, 't0, 't1, 't2> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) &'_#1r u32>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't0)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't1)) u32>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't2)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) u32>))\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/propagate-approximated-to-empty.rs:38:1\n+   |\n+38 | / fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+39 | |     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n+40 | |         // Only works if 'x: 'y:\n+41 | |         demand_y(x, y, x.get())\n+...  |\n+44 | |     });\n+45 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:6 ~ propagate_approximated_to_empty[317d]::supply[0]) with substs []\n+\n+error: aborting due to previous error\n+"}, {"sha": "43d61fdf1b5f820bab8cf588d855a3b741715f7b", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-val.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -24,10 +24,10 @@ note: External requirements\n    = note: where '_#1r: '_#2r\n \n error: free region `'_#1r` does not outlive free region `'_#2r`\n-  --> $DIR/propagate-approximated-val.rs:46:37\n+  --> $DIR/propagate-approximated-val.rs:46:29\n    |\n 46 |     establish_relationships(cell_a, cell_b, |outlives1, outlives2, x, y| {\n-   |                                     ^^^^^^\n+   |                             ^^^^^^\n \n note: No external requirements\n   --> $DIR/propagate-approximated-val.rs:45:1"}, {"sha": "f3c40c838fb3ede207b78e55e819a78e877a783f", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-no-bounds.stderr", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -5,12 +5,12 @@ warning: not reporting region error due to -Znll\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: free region `'_#6r` does not outlive free region `'_#4r`\n-  --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:47:21\n+  --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:47:18\n    |\n 47 |         demand_y(x, y, x.get())\n-   |                     ^\n+   |                  ^\n \n-note: External requirements\n+note: No external requirements\n   --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:45:47\n    |\n 45 |       establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n@@ -26,7 +26,6 @@ note: External requirements\n                i16,\n                for<'r, 's, 't0, 't1, 't2> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) &'_#1r u32>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't0)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't1)) u32>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't2)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) u32>))\n            ]\n-   = note: number of external vids: 2\n \n note: No external requirements\n   --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:44:1"}, {"sha": "a66c2a7897024bc3d3b961901011df5f508a6bcf", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-wrong-bounds.stderr", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -5,12 +5,12 @@ warning: not reporting region error due to -Znll\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: free region `'_#5r` does not outlive free region `'_#7r`\n-  --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:51:21\n+  --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:51:18\n    |\n 51 |         demand_y(x, y, x.get())\n-   |                     ^\n+   |                  ^\n \n-note: External requirements\n+note: No external requirements\n   --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:49:47\n    |\n 49 |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n@@ -26,7 +26,6 @@ note: External requirements\n                i16,\n                for<'r, 's, 't0, 't1, 't2, 't3> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) &'_#1r u32>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't0)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't1)) &'_#2r u32>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't2)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) u32>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't3)) std::cell::Cell<&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 't1)) u32>))\n            ]\n-   = note: number of external vids: 3\n \n note: No external requirements\n   --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:48:1"}, {"sha": "604c81da49db31f86a9c9994bad52b7a2646359c", "filename": "src/test/ui/nll/closure-requirements/propagate-from-trait-match.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that regions which appear only in the closure's generics (in\n+// this case, `'a`) are properly mapped to the creator's generics. In\n+// this case, the closure constrains its type parameter `T` to outlive\n+// the same `'a` for which it implements `Trait`, which can only be the `'a`\n+// from the function definition.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+trait Trait<'a> {}\n+\n+fn establish_relationships<T, F>(value: T, closure: F)\n+where\n+    F: FnOnce(T),\n+{\n+    closure(value)\n+}\n+\n+fn require<'a, T>(t: T)\n+where\n+    T: Trait<'a> + 'a,\n+{\n+}\n+\n+#[rustc_regions]\n+fn supply<'a, T>(value: T)\n+where\n+    T: Trait<'a>,\n+{\n+    establish_relationships(value, |value| {\n+        //~^ ERROR `T` does not outlive\n+\n+        // This function call requires that\n+        //\n+        // (a) T: Trait<'a>\n+        //\n+        // and\n+        //\n+        // (b) T: 'a\n+        //\n+        // The latter does not hold.\n+\n+        require(value);\n+        //~^ WARNING not reporting region error due to -Znll\n+    });\n+}\n+\n+fn main() {}"}, {"sha": "efac55f2beeace6b6ff2af98e453300e0ef7f6dd", "filename": "src/test/ui/nll/closure-requirements/propagate-from-trait-match.stderr", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,60 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/propagate-from-trait-match.rs:55:9\n+   |\n+55 |         require(value);\n+   |         ^^^^^^^\n+\n+note: External requirements\n+  --> $DIR/propagate-from-trait-match.rs:42:36\n+   |\n+42 |       establish_relationships(value, |value| {\n+   |  ____________________________________^\n+43 | |         //~^ ERROR `T` does not outlive\n+44 | |\n+45 | |         // This function call requires that\n+...  |\n+56 | |         //~^ WARNING not reporting region error due to -Znll\n+57 | |     });\n+   | |_____^\n+   |\n+   = note: defining type: DefId(0/1:16 ~ propagate_from_trait_match[317d]::supply[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((T,))\n+           ]\n+   = note: number of external vids: 2\n+   = note: where T: '_#1r\n+\n+error: `T` does not outlive `'_#3r`\n+  --> $DIR/propagate-from-trait-match.rs:42:36\n+   |\n+42 |       establish_relationships(value, |value| {\n+   |  ____________________________________^\n+43 | |         //~^ ERROR `T` does not outlive\n+44 | |\n+45 | |         // This function call requires that\n+...  |\n+56 | |         //~^ WARNING not reporting region error due to -Znll\n+57 | |     });\n+   | |_____^\n+\n+note: No external requirements\n+  --> $DIR/propagate-from-trait-match.rs:38:1\n+   |\n+38 | / fn supply<'a, T>(value: T)\n+39 | | where\n+40 | |     T: Trait<'a>,\n+41 | | {\n+...  |\n+57 | |     });\n+58 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:6 ~ propagate_from_trait_match[317d]::supply[0]) with substs [\n+               '_#1r,\n+               T\n+           ]\n+\n+error: aborting due to previous error\n+"}, {"sha": "cb2b2e2f1186086d58a27833284b1bd684d5a53d", "filename": "src/test/ui/nll/closure-requirements/return-wrong-bound-region.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -10,7 +10,7 @@ error: free region `'_#3r` does not outlive free region `'_#2r`\n 21 |     expect_sig(|a, b| b); // ought to return `a`\n    |                       ^\n \n-note: External requirements\n+note: No external requirements\n   --> $DIR/return-wrong-bound-region.rs:21:16\n    |\n 21 |     expect_sig(|a, b| b); // ought to return `a`\n@@ -20,7 +20,6 @@ note: External requirements\n                i16,\n                for<'r, 's> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) i32, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) i32)) -> &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) i32\n            ]\n-   = note: number of external vids: 1\n \n note: No external requirements\n   --> $DIR/return-wrong-bound-region.rs:20:1"}, {"sha": "31388cf50c5586a9924a89dc2c91c4c426715b92", "filename": "src/test/ui/nll/projection-return.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fprojection-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fprojection-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fprojection-return.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Znll -Zborrowck=mir\n+// must-compile-successfully\n+\n+#![feature(rustc_attrs)]\n+\n+trait Foo {\n+    type Bar;\n+}\n+\n+impl Foo for () {\n+    type Bar = u32;\n+}\n+\n+fn foo() -> <() as Foo>::Bar {\n+    22\n+}\n+\n+fn main() { }\n+"}, {"sha": "9451163ace99338090d28ae90901c2d5492317a2", "filename": "src/test/ui/nll/ty-outlives/projection-no-regions-closure.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+// Tests closures that propagate an outlives relationship to their\n+// creator where the subject is a projection with no regions (`<T as\n+// Iterator>::Item`, to be exact).\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+#![feature(rustc_attrs)]\n+\n+trait Anything { }\n+\n+impl<T> Anything for T { }\n+\n+fn with_signature<'a, T, F>(x: Box<T>, op: F) -> Box<dyn Anything + 'a>\n+    where F: FnOnce(Box<T>) -> Box<dyn Anything + 'a>\n+{\n+    op(x)\n+}\n+\n+#[rustc_regions]\n+fn no_region<'a, T>(x: Box<T>) -> Box<dyn Anything + 'a>\n+where\n+    T: Iterator,\n+{\n+    with_signature(x, |mut y| Box::new(y.next()))\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR `<T as std::iter::Iterator>::Item` does not outlive\n+}\n+\n+#[rustc_regions]\n+fn correct_region<'a, T>(x: Box<T>) -> Box<dyn Anything + 'a>\n+where\n+    T: 'a + Iterator,\n+{\n+    with_signature(x, |mut y| Box::new(y.next()))\n+}\n+\n+#[rustc_regions]\n+fn wrong_region<'a, 'b, T>(x: Box<T>) -> Box<dyn Anything + 'a>\n+where\n+    T: 'b + Iterator,\n+{\n+    with_signature(x, |mut y| Box::new(y.next()))\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR `<T as std::iter::Iterator>::Item` does not outlive\n+}\n+\n+#[rustc_regions]\n+fn outlives_region<'a, 'b, T>(x: Box<T>) -> Box<dyn Anything + 'a>\n+where\n+    T: 'b + Iterator,\n+    'b: 'a,\n+{\n+    with_signature(x, |mut y| Box::new(y.next()))\n+}\n+\n+fn main() {}"}, {"sha": "9afd5d41182f41ed1e9c58707add79e7b9ad2643", "filename": "src/test/ui/nll/ty-outlives/projection-no-regions-closure.stderr", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,157 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-no-regions-closure.rs:36:31\n+   |\n+36 |     with_signature(x, |mut y| Box::new(y.next()))\n+   |                               ^^^^^^^^^^^^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-no-regions-closure.rs:54:31\n+   |\n+54 |     with_signature(x, |mut y| Box::new(y.next()))\n+   |                               ^^^^^^^^^^^^^^^^^^\n+\n+note: External requirements\n+  --> $DIR/projection-no-regions-closure.rs:36:23\n+   |\n+36 |     with_signature(x, |mut y| Box::new(y.next()))\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:15 ~ projection_no_regions_closure[317d]::no_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::boxed::Box<T>,)) -> std::boxed::Box<Anything + '_#2r>\n+           ]\n+   = note: number of external vids: 3\n+   = note: where <T as std::iter::Iterator>::Item: '_#2r\n+\n+note: External requirements\n+  --> $DIR/projection-no-regions-closure.rs:46:23\n+   |\n+46 |     with_signature(x, |mut y| Box::new(y.next()))\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:18 ~ projection_no_regions_closure[317d]::correct_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::boxed::Box<T>,)) -> std::boxed::Box<Anything + '_#2r>\n+           ]\n+   = note: number of external vids: 3\n+   = note: where <T as std::iter::Iterator>::Item: '_#2r\n+\n+note: External requirements\n+  --> $DIR/projection-no-regions-closure.rs:54:23\n+   |\n+54 |     with_signature(x, |mut y| Box::new(y.next()))\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:22 ~ projection_no_regions_closure[317d]::wrong_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::boxed::Box<T>,)) -> std::boxed::Box<Anything + '_#3r>\n+           ]\n+   = note: number of external vids: 4\n+   = note: where <T as std::iter::Iterator>::Item: '_#3r\n+\n+note: External requirements\n+  --> $DIR/projection-no-regions-closure.rs:65:23\n+   |\n+65 |     with_signature(x, |mut y| Box::new(y.next()))\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:26 ~ projection_no_regions_closure[317d]::outlives_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::boxed::Box<T>,)) -> std::boxed::Box<Anything + '_#3r>\n+           ]\n+   = note: number of external vids: 4\n+   = note: where <T as std::iter::Iterator>::Item: '_#3r\n+\n+error: `<T as std::iter::Iterator>::Item` does not outlive `'_#4r`\n+  --> $DIR/projection-no-regions-closure.rs:36:23\n+   |\n+36 |     with_signature(x, |mut y| Box::new(y.next()))\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-no-regions-closure.rs:32:1\n+   |\n+32 | / fn no_region<'a, T>(x: Box<T>) -> Box<dyn Anything + 'a>\n+33 | | where\n+34 | |     T: Iterator,\n+35 | | {\n+...  |\n+38 | |     //~| ERROR `<T as std::iter::Iterator>::Item` does not outlive\n+39 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:6 ~ projection_no_regions_closure[317d]::no_region[0]) with substs [\n+               '_#1r,\n+               T\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-no-regions-closure.rs:42:1\n+   |\n+42 | / fn correct_region<'a, T>(x: Box<T>) -> Box<dyn Anything + 'a>\n+43 | | where\n+44 | |     T: 'a + Iterator,\n+45 | | {\n+46 | |     with_signature(x, |mut y| Box::new(y.next()))\n+47 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:7 ~ projection_no_regions_closure[317d]::correct_region[0]) with substs [\n+               '_#1r,\n+               T\n+           ]\n+\n+error: `<T as std::iter::Iterator>::Item` does not outlive `'_#6r`\n+  --> $DIR/projection-no-regions-closure.rs:54:23\n+   |\n+54 |     with_signature(x, |mut y| Box::new(y.next()))\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-no-regions-closure.rs:50:1\n+   |\n+50 | / fn wrong_region<'a, 'b, T>(x: Box<T>) -> Box<dyn Anything + 'a>\n+51 | | where\n+52 | |     T: 'b + Iterator,\n+53 | | {\n+...  |\n+56 | |     //~| ERROR `<T as std::iter::Iterator>::Item` does not outlive\n+57 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:8 ~ projection_no_regions_closure[317d]::wrong_region[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-no-regions-closure.rs:60:1\n+   |\n+60 | / fn outlives_region<'a, 'b, T>(x: Box<T>) -> Box<dyn Anything + 'a>\n+61 | | where\n+62 | |     T: 'b + Iterator,\n+63 | |     'b: 'a,\n+64 | | {\n+65 | |     with_signature(x, |mut y| Box::new(y.next()))\n+66 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:9 ~ projection_no_regions_closure[317d]::outlives_region[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "c815fdc1a0c5e7f81cf3aae98ec63c90b215cd7a", "filename": "src/test/ui/nll/ty-outlives/projection-no-regions-fn.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+\n+trait Anything { }\n+\n+impl<T> Anything for T { }\n+\n+fn no_region<'a, T>(mut x: T) -> Box<dyn Anything + 'a>\n+where\n+    T: Iterator,\n+{\n+    Box::new(x.next())\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR `<T as std::iter::Iterator>::Item` does not outlive\n+}\n+\n+fn correct_region<'a, T>(mut x: T) -> Box<dyn Anything + 'a>\n+where\n+    T: 'a + Iterator,\n+{\n+    Box::new(x.next())\n+}\n+\n+fn wrong_region<'a, 'b, T>(mut x: T) -> Box<dyn Anything + 'a>\n+where\n+    T: 'b + Iterator,\n+{\n+    Box::new(x.next())\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR `<T as std::iter::Iterator>::Item` does not outlive\n+}\n+\n+fn outlives_region<'a, 'b, T>(mut x: T) -> Box<dyn Anything + 'a>\n+where\n+    T: 'b + Iterator,\n+    'b: 'a,\n+{\n+    Box::new(x.next())\n+}\n+\n+fn main() {}"}, {"sha": "4d13972641c16be1a863a19fb8e50a6edfa44def", "filename": "src/test/ui/nll/ty-outlives/projection-no-regions-fn.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-fn.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,26 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-no-regions-fn.rs:24:5\n+   |\n+24 |     Box::new(x.next())\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-no-regions-fn.rs:40:5\n+   |\n+40 |     Box::new(x.next())\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: `<T as std::iter::Iterator>::Item` does not outlive `'_#4r`\n+  --> $DIR/projection-no-regions-fn.rs:24:5\n+   |\n+24 |     Box::new(x.next())\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: `<T as std::iter::Iterator>::Item` does not outlive `'_#5r`\n+  --> $DIR/projection-no-regions-fn.rs:40:5\n+   |\n+40 |     Box::new(x.next())\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "e2a2d20d77d5c8475089917f56e2705896562846", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,106 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test cases where we constrain `<T as Anything<'b>>::AssocType` to\n+// outlive `'a` and there are no bounds in the trait definition of\n+// `Anything`. This means that the constraint can only be satisfied in two\n+// ways:\n+//\n+// - by ensuring that `T: 'a` and `'b: 'a`, or\n+// - by something in the where clauses.\n+//\n+// As of this writing, the where clause option does not work because\n+// of limitations in our region inferencing system (this is true both\n+// with and without NLL). See `projection_outlives`.\n+//\n+// Ensuring that both `T: 'a` and `'b: 'a` holds does work (`elements_outlive`).\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+trait Anything<'a> {\n+    type AssocType;\n+}\n+\n+fn with_signature<'a, T, F>(cell: Cell<&'a ()>, t: T, op: F)\n+where\n+    F: FnOnce(Cell<&'a ()>, T),\n+{\n+    op(cell, t)\n+}\n+\n+fn require<'a, 'b, T>(_cell: Cell<&'a ()>, _t: T)\n+where\n+    T: Anything<'b>,\n+    T::AssocType: 'a,\n+{\n+}\n+\n+#[rustc_regions]\n+fn no_relationships_late<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR `T` does not outlive\n+    //~| ERROR free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+}\n+\n+#[rustc_regions]\n+fn no_relationships_early<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+    'a: 'a,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR `T` does not outlive\n+    //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+}\n+\n+#[rustc_regions]\n+fn projection_outlives<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+    T::AssocType: 'a,\n+{\n+    // This error is unfortunate. This code ought to type-check: we\n+    // are projecting `<T as Anything<'b>>::AssocType`, and we know\n+    // that this outlives `'a` because of the where-clause. However,\n+    // the way the region checker works, we don't register this\n+    // outlives obligation, and hence we get an error: this is because\n+    // what we see is a projection like `<T as\n+    // Anything<'?0>>::AssocType`, and we don't yet know if `?0` will\n+    // equal `'b` or not, so we ignore the where-clause. Obviously we\n+    // can do better here with a more involved verification step.\n+\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR `T` does not outlive\n+    //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+}\n+\n+#[rustc_regions]\n+fn elements_outlive<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+    T: 'a,\n+    'b: 'a,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+fn main() {}"}, {"sha": "cbd80d70bf95553504b351513166ea2ec6a38bf0", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.stderr", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,194 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-one-region-closure.rs:56:39\n+   |\n+56 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                                       ^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-one-region-closure.rs:68:39\n+   |\n+68 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                                       ^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-one-region-closure.rs:90:39\n+   |\n+90 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                                       ^^^^^^^\n+\n+note: External requirements\n+  --> $DIR/projection-one-region-closure.rs:56:29\n+   |\n+56 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:19 ~ projection_one_region_closure[317d]::no_relationships_late[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+           ]\n+   = note: number of external vids: 3\n+   = note: where T: '_#2r\n+   = note: where '_#1r: '_#2r\n+\n+note: External requirements\n+  --> $DIR/projection-one-region-closure.rs:68:29\n+   |\n+68 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:23 ~ projection_one_region_closure[317d]::no_relationships_early[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+   = note: number of external vids: 4\n+   = note: where T: '_#3r\n+   = note: where '_#2r: '_#3r\n+\n+note: External requirements\n+  --> $DIR/projection-one-region-closure.rs:90:29\n+   |\n+90 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:27 ~ projection_one_region_closure[317d]::projection_outlives[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+   = note: number of external vids: 4\n+   = note: where T: '_#3r\n+   = note: where '_#2r: '_#3r\n+\n+note: External requirements\n+   --> $DIR/projection-one-region-closure.rs:103:29\n+    |\n+103 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    |\n+    = note: defining type: DefId(0/1:31 ~ projection_one_region_closure[317d]::elements_outlive[0]::{{closure}}[0]) with closure substs [\n+                '_#1r,\n+                '_#2r,\n+                T,\n+                i32,\n+                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+            ]\n+    = note: number of external vids: 4\n+    = note: where T: '_#3r\n+    = note: where '_#2r: '_#3r\n+\n+error: `T` does not outlive `'_#5r`\n+  --> $DIR/projection-one-region-closure.rs:56:29\n+   |\n+56 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+  --> $DIR/projection-one-region-closure.rs:56:20\n+   |\n+56 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                    ^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-closure.rs:52:1\n+   |\n+52 | / fn no_relationships_late<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+53 | | where\n+54 | |     T: Anything<'b>,\n+55 | | {\n+...  |\n+59 | |     //~| ERROR free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+60 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:8 ~ projection_one_region_closure[317d]::no_relationships_late[0]) with substs [\n+               '_#1r,\n+               T\n+           ]\n+\n+error: `T` does not outlive `'_#6r`\n+  --> $DIR/projection-one-region-closure.rs:68:29\n+   |\n+68 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+  --> $DIR/projection-one-region-closure.rs:68:20\n+   |\n+68 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                    ^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-closure.rs:63:1\n+   |\n+63 | / fn no_relationships_early<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+64 | | where\n+65 | |     T: Anything<'b>,\n+66 | |     'a: 'a,\n+...  |\n+71 | |     //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+72 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:9 ~ projection_one_region_closure[317d]::no_relationships_early[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+error: `T` does not outlive `'_#6r`\n+  --> $DIR/projection-one-region-closure.rs:90:29\n+   |\n+90 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+  --> $DIR/projection-one-region-closure.rs:90:20\n+   |\n+90 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                    ^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-closure.rs:75:1\n+   |\n+75 | / fn projection_outlives<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+76 | | where\n+77 | |     T: Anything<'b>,\n+78 | |     T::AssocType: 'a,\n+...  |\n+93 | |     //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+94 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:10 ~ projection_one_region_closure[317d]::projection_outlives[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+note: No external requirements\n+   --> $DIR/projection-one-region-closure.rs:97:1\n+    |\n+97  | / fn elements_outlive<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+98  | | where\n+99  | |     T: Anything<'b>,\n+100 | |     T: 'a,\n+...   |\n+103 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+104 | | }\n+    | |_^\n+    |\n+    = note: defining type: DefId(0/0:11 ~ projection_one_region_closure[317d]::elements_outlive[0]) with substs [\n+                '_#1r,\n+                '_#2r,\n+                T\n+            ]\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "e179927dfb0b9f05b5033d5142e29d73de54d36e", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-closure.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,106 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test cases where we constrain `<T as Anything<'b>>::AssocType` to\n+// outlive `'a` and there is a unique bound in the trait definition of\n+// `Anything` -- i.e., we know that `AssocType` outlives `'b`. In this\n+// case, the best way to satisfy the trait bound is to show that `'b:\n+// 'a`, which can be done in various ways.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+trait Anything<'a> {\n+    type AssocType: 'a;\n+}\n+\n+fn with_signature<'a, T, F>(cell: Cell<&'a ()>, t: T, op: F)\n+where\n+    F: FnOnce(Cell<&'a ()>, T),\n+{\n+    op(cell, t)\n+}\n+\n+fn require<'a, 'b, T>(_cell: Cell<&'a ()>, _t: T)\n+where\n+    T: Anything<'b>,\n+    T::AssocType: 'a,\n+{\n+}\n+\n+#[rustc_regions]\n+fn no_relationships_late<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+}\n+\n+#[rustc_regions]\n+fn no_relationships_early<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+    'a: 'a,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+}\n+\n+#[rustc_regions]\n+fn projection_outlives<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+    T::AssocType: 'a,\n+{\n+    // This error is unfortunate. This code ought to type-check: we\n+    // are projecting `<T as Anything<'b>>::AssocType`, and we know\n+    // that this outlives `'a` because of the where-clause. However,\n+    // the way the region checker works, we don't register this\n+    // outlives obligation, and hence we get an error: this is because\n+    // what we see is a projection like `<T as\n+    // Anything<'?0>>::AssocType`, and we don't yet know if `?0` will\n+    // equal `'b` or not, so we ignore the where-clause. Obviously we\n+    // can do better here with a more involved verification step.\n+\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+}\n+\n+#[rustc_regions]\n+fn elements_outlive<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+    'b: 'a,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+#[rustc_regions]\n+fn one_region<'a, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'a>,\n+{\n+    // Note that in this case the closure still propagates an external\n+    // requirement between two variables in its signature, but the\n+    // creator maps both those two region variables to `'a` on its\n+    // side.\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+fn main() {}"}, {"sha": "1088ae846fee54073aa815db2f3387dd75fb75ae", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-closure.stderr", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,204 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:48:39\n+   |\n+48 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                                       ^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:59:39\n+   |\n+59 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                                       ^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:80:39\n+   |\n+80 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                                       ^^^^^^^\n+\n+note: External requirements\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:48:29\n+   |\n+48 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:19 ~ projection_one_region_trait_bound_closure[317d]::no_relationships_late[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+           ]\n+   = note: number of external vids: 3\n+   = note: where '_#1r: '_#2r\n+\n+note: External requirements\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:59:29\n+   |\n+59 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:23 ~ projection_one_region_trait_bound_closure[317d]::no_relationships_early[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+   = note: number of external vids: 4\n+   = note: where '_#2r: '_#3r\n+\n+note: External requirements\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:80:29\n+   |\n+80 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:27 ~ projection_one_region_trait_bound_closure[317d]::projection_outlives[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+   = note: number of external vids: 4\n+   = note: where '_#2r: '_#3r\n+\n+note: External requirements\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:91:29\n+   |\n+91 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:31 ~ projection_one_region_trait_bound_closure[317d]::elements_outlive[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+   = note: number of external vids: 4\n+   = note: where '_#2r: '_#3r\n+\n+note: External requirements\n+   --> $DIR/projection-one-region-trait-bound-closure.rs:103:29\n+    |\n+103 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    |\n+    = note: defining type: DefId(0/1:34 ~ projection_one_region_trait_bound_closure[317d]::one_region[0]::{{closure}}[0]) with closure substs [\n+                '_#1r,\n+                T,\n+                i32,\n+                extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+            ]\n+    = note: number of external vids: 3\n+    = note: where '_#1r: '_#2r\n+\n+error: free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:48:20\n+   |\n+48 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                    ^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:44:1\n+   |\n+44 | / fn no_relationships_late<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+45 | | where\n+46 | |     T: Anything<'b>,\n+47 | | {\n+...  |\n+50 | |     //~| ERROR free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+51 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:8 ~ projection_one_region_trait_bound_closure[317d]::no_relationships_late[0]) with substs [\n+               '_#1r,\n+               T\n+           ]\n+\n+error: free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:59:20\n+   |\n+59 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                    ^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:54:1\n+   |\n+54 | / fn no_relationships_early<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+55 | | where\n+56 | |     T: Anything<'b>,\n+57 | |     'a: 'a,\n+...  |\n+61 | |     //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+62 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:9 ~ projection_one_region_trait_bound_closure[317d]::no_relationships_early[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+error: free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:80:20\n+   |\n+80 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                    ^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:65:1\n+   |\n+65 | / fn projection_outlives<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+66 | | where\n+67 | |     T: Anything<'b>,\n+68 | |     T::AssocType: 'a,\n+...  |\n+82 | |     //~| ERROR free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n+83 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:10 ~ projection_one_region_trait_bound_closure[317d]::projection_outlives[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:86:1\n+   |\n+86 | / fn elements_outlive<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+87 | | where\n+88 | |     T: Anything<'b>,\n+89 | |     'b: 'a,\n+90 | | {\n+91 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+92 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:11 ~ projection_one_region_trait_bound_closure[317d]::elements_outlive[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+note: No external requirements\n+   --> $DIR/projection-one-region-trait-bound-closure.rs:95:1\n+    |\n+95  | / fn one_region<'a, T>(cell: Cell<&'a ()>, t: T)\n+96  | | where\n+97  | |     T: Anything<'a>,\n+98  | | {\n+...   |\n+103 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+104 | | }\n+    | |_^\n+    |\n+    = note: defining type: DefId(0/0:12 ~ projection_one_region_trait_bound_closure[317d]::one_region[0]) with substs [\n+                '_#1r,\n+                T\n+            ]\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "67e28af11469d1ad036d81339a7e8b64a3d1747f", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-static-closure.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-static-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-static-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-static-closure.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,99 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test cases where we constrain `<T as Anything<'b>>::AssocType` to\n+// outlive `'static`. In this case, we don't get any errors, and in fact\n+// we don't even propagate constraints from the closures to the callers.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+// must-compile-successfully\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+trait Anything<'a> {\n+    type AssocType: 'static;\n+}\n+\n+fn with_signature<'a, T, F>(cell: Cell<&'a ()>, t: T, op: F)\n+where\n+    F: FnOnce(Cell<&'a ()>, T),\n+{\n+    op(cell, t)\n+}\n+\n+fn require<'a, 'b, T>(_cell: Cell<&'a ()>, _t: T)\n+where\n+    T: Anything<'b>,\n+    T::AssocType: 'a,\n+{\n+}\n+\n+#[rustc_regions]\n+fn no_relationships_late<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+#[rustc_regions]\n+fn no_relationships_early<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+    'a: 'a,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+#[rustc_regions]\n+fn projection_outlives<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+    T::AssocType: 'a,\n+{\n+    // This error is unfortunate. This code ought to type-check: we\n+    // are projecting `<T as Anything<'b>>::AssocType`, and we know\n+    // that this outlives `'a` because of the where-clause. However,\n+    // the way the region checker works, we don't register this\n+    // outlives obligation, and hence we get an error: this is because\n+    // what we see is a projection like `<T as\n+    // Anything<'?0>>::AssocType`, and we don't yet know if `?0` will\n+    // equal `'b` or not, so we ignore the where-clause. Obviously we\n+    // can do better here with a more involved verification step.\n+\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+#[rustc_regions]\n+fn elements_outlive<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b>,\n+    'b: 'a,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+#[rustc_regions]\n+fn one_region<'a, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'a>,\n+{\n+    // Note that in this case the closure still propagates an external\n+    // requirement between two variables in its signature, but the\n+    // creator maps both those two region variables to `'a` on its\n+    // side.\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+fn main() {}"}, {"sha": "986676d28d9209108d17d5ce412bb45750339f0e", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-static-closure.stderr", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-static-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-static-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-static-closure.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,155 @@\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:47:29\n+   |\n+47 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:19 ~ projection_one_region_trait_bound_static_closure[317d]::no_relationships_late[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:56:29\n+   |\n+56 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:23 ~ projection_one_region_trait_bound_static_closure[317d]::no_relationships_early[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:75:29\n+   |\n+75 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:27 ~ projection_one_region_trait_bound_static_closure[317d]::projection_outlives[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:84:29\n+   |\n+84 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:31 ~ projection_one_region_trait_bound_static_closure[317d]::elements_outlive[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:96:29\n+   |\n+96 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:34 ~ projection_one_region_trait_bound_static_closure[317d]::one_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:43:1\n+   |\n+43 | / fn no_relationships_late<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+44 | | where\n+45 | |     T: Anything<'b>,\n+46 | | {\n+47 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+48 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:8 ~ projection_one_region_trait_bound_static_closure[317d]::no_relationships_late[0]) with substs [\n+               '_#1r,\n+               T\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:51:1\n+   |\n+51 | / fn no_relationships_early<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+52 | | where\n+53 | |     T: Anything<'b>,\n+54 | |     'a: 'a,\n+55 | | {\n+56 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+57 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:9 ~ projection_one_region_trait_bound_static_closure[317d]::no_relationships_early[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:60:1\n+   |\n+60 | / fn projection_outlives<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+61 | | where\n+62 | |     T: Anything<'b>,\n+63 | |     T::AssocType: 'a,\n+...  |\n+75 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+76 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:10 ~ projection_one_region_trait_bound_static_closure[317d]::projection_outlives[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:79:1\n+   |\n+79 | / fn elements_outlive<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+80 | | where\n+81 | |     T: Anything<'b>,\n+82 | |     'b: 'a,\n+83 | | {\n+84 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+85 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:11 ~ projection_one_region_trait_bound_static_closure[317d]::elements_outlive[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:88:1\n+   |\n+88 | / fn one_region<'a, T>(cell: Cell<&'a ()>, t: T)\n+89 | | where\n+90 | |     T: Anything<'a>,\n+91 | | {\n+...  |\n+96 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+97 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:12 ~ projection_one_region_trait_bound_static_closure[317d]::one_region[0]) with substs [\n+               '_#1r,\n+               T\n+           ]\n+"}, {"sha": "42bfdfcf9f91b8684b6a5c455632e089c2b379d1", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,135 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test cases where we constrain `<T as Anything<'a, 'b>>::AssocType`\n+// to outlive `'a` and there are two bounds in the trait definition of\n+// `Anything` -- i.e., we know that `AssocType` outlives `'a` and\n+// `'b`. In this case, it's not clear what is the best way to satisfy\n+// the trait bound, and hence we propagate it to the caller as a type\n+// test.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+trait Anything<'a, 'b> {\n+    type AssocType: 'a + 'b;\n+}\n+\n+fn with_signature<'a, T, F>(cell: Cell<&'a ()>, t: T, op: F)\n+where\n+    F: FnOnce(Cell<&'a ()>, T),\n+{\n+    op(cell, t)\n+}\n+\n+fn require<'a, 'b, 'c, T>(_cell: Cell<&'a ()>, _t: T)\n+where\n+    T: Anything<'b, 'c>,\n+    T::AssocType: 'a,\n+{\n+}\n+\n+#[rustc_regions]\n+fn no_relationships_late<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b, 'c>,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR `<T as Anything<'_#5r, '_#6r>>::AssocType` does not outlive `'_#7r`\n+}\n+\n+#[rustc_regions]\n+fn no_relationships_early<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b, 'c>,\n+    'a: 'a,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR `<T as Anything<'_#6r, '_#7r>>::AssocType` does not outlive `'_#8r`\n+}\n+\n+#[rustc_regions]\n+fn projection_outlives<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b, 'c>,\n+    T::AssocType: 'a,\n+{\n+    // This error is unfortunate. This code ought to type-check: we\n+    // are projecting `<T as Anything<'b>>::AssocType`, and we know\n+    // that this outlives `'a` because of the where-clause. However,\n+    // the way the region checker works, we don't register this\n+    // outlives obligation, and hence we get an error: this is because\n+    // what we see is a projection like `<T as\n+    // Anything<'?0>>::AssocType`, and we don't yet know if `?0` will\n+    // equal `'b` or not, so we ignore the where-clause. Obviously we\n+    // can do better here with a more involved verification step.\n+\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR `<T as Anything<'_#6r, '_#7r>>::AssocType` does not outlive `'_#8r`\n+}\n+\n+#[rustc_regions]\n+fn elements_outlive1<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b, 'c>,\n+    'b: 'a,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+#[rustc_regions]\n+fn elements_outlive2<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b, 'c>,\n+    'c: 'a,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+#[rustc_regions]\n+fn two_regions<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b, 'b>,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+}\n+\n+#[rustc_regions]\n+fn two_regions_outlive<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'b, 'b>,\n+    'b: 'a,\n+{\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+#[rustc_regions]\n+fn one_region<'a, T>(cell: Cell<&'a ()>, t: T)\n+where\n+    T: Anything<'a, 'a>,\n+{\n+    // Note that in this case the closure still propagates an external\n+    // requirement between two variables in its signature, but the\n+    // creator maps both those two region variables to `'a` on its\n+    // side.\n+    with_signature(cell, t, |cell, t| require(cell, t));\n+}\n+\n+fn main() {}"}, {"sha": "5b708a0d7e6297d70f46f3c907e0b285f962a4ac", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.stderr", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,326 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:49:39\n+   |\n+49 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                                       ^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:60:39\n+   |\n+60 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                                       ^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:81:39\n+   |\n+81 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                                       ^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:109:39\n+    |\n+109 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                                       ^^^^^^^\n+\n+note: External requirements\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:49:29\n+   |\n+49 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:22 ~ projection_two_region_trait_bound_closure[317d]::no_relationships_late[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+   = note: number of external vids: 4\n+   = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#2r)>>::AssocType: '_#3r\n+\n+note: External requirements\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:60:29\n+   |\n+60 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:27 ~ projection_two_region_trait_bound_closure[317d]::no_relationships_early[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               '_#3r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#4r ()>, T))\n+           ]\n+   = note: number of external vids: 5\n+   = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n+\n+note: External requirements\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:81:29\n+   |\n+81 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:32 ~ projection_two_region_trait_bound_closure[317d]::projection_outlives[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               '_#3r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#4r ()>, T))\n+           ]\n+   = note: number of external vids: 5\n+   = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n+\n+note: External requirements\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:92:29\n+   |\n+92 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:37 ~ projection_two_region_trait_bound_closure[317d]::elements_outlive1[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               '_#3r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#4r ()>, T))\n+           ]\n+   = note: number of external vids: 5\n+   = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n+\n+note: External requirements\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:101:29\n+    |\n+101 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    |\n+    = note: defining type: DefId(0/1:42 ~ projection_two_region_trait_bound_closure[317d]::elements_outlive2[0]::{{closure}}[0]) with closure substs [\n+                '_#1r,\n+                '_#2r,\n+                '_#3r,\n+                T,\n+                i32,\n+                extern \"rust-call\" fn((std::cell::Cell<&'_#4r ()>, T))\n+            ]\n+    = note: number of external vids: 5\n+    = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n+\n+note: External requirements\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:109:29\n+    |\n+109 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    |\n+    = note: defining type: DefId(0/1:46 ~ projection_two_region_trait_bound_closure[317d]::two_regions[0]::{{closure}}[0]) with closure substs [\n+                '_#1r,\n+                T,\n+                i32,\n+                extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+            ]\n+    = note: number of external vids: 3\n+    = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#1r)>>::AssocType: '_#2r\n+\n+note: External requirements\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:120:29\n+    |\n+120 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    |\n+    = note: defining type: DefId(0/1:50 ~ projection_two_region_trait_bound_closure[317d]::two_regions_outlive[0]::{{closure}}[0]) with closure substs [\n+                '_#1r,\n+                '_#2r,\n+                T,\n+                i32,\n+                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+            ]\n+    = note: number of external vids: 4\n+    = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#2r)>>::AssocType: '_#3r\n+\n+note: External requirements\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:132:29\n+    |\n+132 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    |\n+    = note: defining type: DefId(0/1:53 ~ projection_two_region_trait_bound_closure[317d]::one_region[0]::{{closure}}[0]) with closure substs [\n+                '_#1r,\n+                T,\n+                i32,\n+                extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+            ]\n+    = note: number of external vids: 3\n+    = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#1r)>>::AssocType: '_#2r\n+\n+error: `<T as Anything<'_#5r, '_#6r>>::AssocType` does not outlive `'_#7r`\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:49:29\n+   |\n+49 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:45:1\n+   |\n+45 | / fn no_relationships_late<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n+46 | | where\n+47 | |     T: Anything<'b, 'c>,\n+48 | | {\n+...  |\n+51 | |     //~| ERROR `<T as Anything<'_#5r, '_#6r>>::AssocType` does not outlive `'_#7r`\n+52 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:8 ~ projection_two_region_trait_bound_closure[317d]::no_relationships_late[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+error: `<T as Anything<'_#6r, '_#7r>>::AssocType` does not outlive `'_#8r`\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:60:29\n+   |\n+60 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:55:1\n+   |\n+55 | / fn no_relationships_early<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n+56 | | where\n+57 | |     T: Anything<'b, 'c>,\n+58 | |     'a: 'a,\n+...  |\n+62 | |     //~| ERROR `<T as Anything<'_#6r, '_#7r>>::AssocType` does not outlive `'_#8r`\n+63 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:9 ~ projection_two_region_trait_bound_closure[317d]::no_relationships_early[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               '_#3r,\n+               T\n+           ]\n+\n+error: `<T as Anything<'_#6r, '_#7r>>::AssocType` does not outlive `'_#8r`\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:81:29\n+   |\n+81 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: No external requirements\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:66:1\n+   |\n+66 | / fn projection_outlives<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n+67 | | where\n+68 | |     T: Anything<'b, 'c>,\n+69 | |     T::AssocType: 'a,\n+...  |\n+83 | |     //~| ERROR `<T as Anything<'_#6r, '_#7r>>::AssocType` does not outlive `'_#8r`\n+84 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:10 ~ projection_two_region_trait_bound_closure[317d]::projection_outlives[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               '_#3r,\n+               T\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:87:1\n+   |\n+87 | / fn elements_outlive1<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n+88 | | where\n+89 | |     T: Anything<'b, 'c>,\n+90 | |     'b: 'a,\n+91 | | {\n+92 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+93 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:11 ~ projection_two_region_trait_bound_closure[317d]::elements_outlive1[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               '_#3r,\n+               T\n+           ]\n+\n+note: No external requirements\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:96:1\n+    |\n+96  | / fn elements_outlive2<'a, 'b, 'c, T>(cell: Cell<&'a ()>, t: T)\n+97  | | where\n+98  | |     T: Anything<'b, 'c>,\n+99  | |     'c: 'a,\n+100 | | {\n+101 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+102 | | }\n+    | |_^\n+    |\n+    = note: defining type: DefId(0/0:12 ~ projection_two_region_trait_bound_closure[317d]::elements_outlive2[0]) with substs [\n+                '_#1r,\n+                '_#2r,\n+                '_#3r,\n+                T\n+            ]\n+\n+error: free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:109:20\n+    |\n+109 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                    ^^^^\n+\n+note: No external requirements\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:105:1\n+    |\n+105 | / fn two_regions<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+106 | | where\n+107 | |     T: Anything<'b, 'b>,\n+108 | | {\n+...   |\n+111 | |     //~| ERROR free region `ReEarlyBound(0, 'b)` does not outlive free region `'_#2r`\n+112 | | }\n+    | |_^\n+    |\n+    = note: defining type: DefId(0/0:13 ~ projection_two_region_trait_bound_closure[317d]::two_regions[0]) with substs [\n+                '_#1r,\n+                T\n+            ]\n+\n+note: No external requirements\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:115:1\n+    |\n+115 | / fn two_regions_outlive<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+116 | | where\n+117 | |     T: Anything<'b, 'b>,\n+118 | |     'b: 'a,\n+119 | | {\n+120 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+121 | | }\n+    | |_^\n+    |\n+    = note: defining type: DefId(0/0:14 ~ projection_two_region_trait_bound_closure[317d]::two_regions_outlive[0]) with substs [\n+                '_#1r,\n+                '_#2r,\n+                T\n+            ]\n+\n+note: No external requirements\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:124:1\n+    |\n+124 | / fn one_region<'a, T>(cell: Cell<&'a ()>, t: T)\n+125 | | where\n+126 | |     T: Anything<'a, 'a>,\n+127 | | {\n+...   |\n+132 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+133 | | }\n+    | |_^\n+    |\n+    = note: defining type: DefId(0/0:15 ~ projection_two_region_trait_bound_closure[317d]::one_region[0]) with substs [\n+                '_#1r,\n+                T\n+            ]\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "14e2eb26976ab4190fe8008a0c5499fa8c7c711a", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-return-type.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+#![feature(rustc_attrs)]\n+\n+use std::fmt::Debug;\n+\n+fn with_signature<'a, T, F>(x: Box<T>, op: F) -> Box<dyn Debug + 'a>\n+    where F: FnOnce(Box<T>) -> Box<dyn Debug + 'a>\n+{\n+    op(x)\n+}\n+\n+#[rustc_regions]\n+fn no_region<'a, T>(x: Box<T>) -> Box<dyn Debug + 'a>\n+where\n+    T: Debug,\n+{\n+    // Here, the closure winds up being required to prove that `T:\n+    // 'a`.  In principle, it could know that, except that it is\n+    // type-checked in a fully generic way, and hence it winds up with\n+    // a propagated requirement that `T: '_#2`, where `'_#2` appears\n+    // in the return type. The caller makes the mapping from `'_#2` to\n+    // `'a` (and subsequently reports an error).\n+\n+    with_signature(x, |y| y)\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR `T` does not outlive\n+}\n+\n+fn correct_region<'a, T>(x: Box<T>) -> Box<Debug + 'a>\n+where\n+    T: 'a + Debug,\n+{\n+    x\n+}\n+\n+fn wrong_region<'a, 'b, T>(x: Box<T>) -> Box<Debug + 'a>\n+where\n+    T: 'b + Debug,\n+{\n+    x\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR `T` does not outlive\n+}\n+\n+fn outlives_region<'a, 'b, T>(x: Box<T>) -> Box<Debug + 'a>\n+where\n+    T: 'b + Debug,\n+    'b: 'a,\n+{\n+    x\n+}\n+\n+fn main() {}"}, {"sha": "37ebc38da4dae93a3d9cba2c87af4b2835c4d314", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-return-type.stderr", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,58 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/ty-param-closure-outlives-from-return-type.rs:37:27\n+   |\n+37 |     with_signature(x, |y| y)\n+   |                           ^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/ty-param-closure-outlives-from-return-type.rs:53:5\n+   |\n+53 |     x\n+   |     ^\n+\n+note: External requirements\n+  --> $DIR/ty-param-closure-outlives-from-return-type.rs:37:23\n+   |\n+37 |     with_signature(x, |y| y)\n+   |                       ^^^^^\n+   |\n+   = note: defining type: DefId(0/1:14 ~ ty_param_closure_outlives_from_return_type[317d]::no_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::boxed::Box<T>,)) -> std::boxed::Box<std::fmt::Debug + '_#2r>\n+           ]\n+   = note: number of external vids: 3\n+   = note: where T: '_#2r\n+\n+error: `T` does not outlive `'_#4r`\n+  --> $DIR/ty-param-closure-outlives-from-return-type.rs:37:23\n+   |\n+37 |     with_signature(x, |y| y)\n+   |                       ^^^^^\n+\n+note: No external requirements\n+  --> $DIR/ty-param-closure-outlives-from-return-type.rs:26:1\n+   |\n+26 | / fn no_region<'a, T>(x: Box<T>) -> Box<dyn Debug + 'a>\n+27 | | where\n+28 | |     T: Debug,\n+29 | | {\n+...  |\n+39 | |     //~| ERROR `T` does not outlive\n+40 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:5 ~ ty_param_closure_outlives_from_return_type[317d]::no_region[0]) with substs [\n+               '_#1r,\n+               T\n+           ]\n+\n+error: `T` does not outlive `'_#4r`\n+  --> $DIR/ty-param-closure-outlives-from-return-type.rs:53:5\n+   |\n+53 |     x\n+   |     ^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "beed1a740eac355e2eb124ae66af0684392bb0aa", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-where-clause.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can propagate `T: 'a` obligations to our caller.  See\n+// `correct_region` for an explanation of how this test is setup; it's\n+// somewhat intricate.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+fn with_signature<'a, T, F>(a: Cell<&'a ()>, b: T, op: F)\n+where\n+    F: FnOnce(Cell<&'a ()>, T),\n+{\n+    op(a, b)\n+}\n+\n+fn require<'a, T>(_a: &Cell<&'a ()>, _b: &T)\n+where\n+    T: 'a,\n+{\n+}\n+\n+#[rustc_regions]\n+fn no_region<'a, T>(a: Cell<&'a ()>, b: T) {\n+    with_signature(a, b, |x, y| {\n+        //~^ ERROR `T` does not outlive\n+        //\n+        // See `correct_region`, which explains the point of this\n+        // test.  The only difference is that, in the case of this\n+        // function, there is no where clause *anywhere*, and hence we\n+        // get an error (but reported by the closure creator).\n+        require(&x, &y)\n+        //~^ WARNING not reporting region error due to -Znll\n+    })\n+}\n+\n+#[rustc_regions]\n+fn correct_region<'a, T>(a: Cell<&'a ()>, b: T)\n+where\n+    T: 'a,\n+{\n+    with_signature(a, b, |x, y| {\n+        // Key point of this test:\n+        //\n+        // The *closure* is being type-checked with all of its free\n+        // regions \"universalized\". In particular, it does not know\n+        // that `x` has the type `Cell<&'a ()>`, but rather treats it\n+        // as if the type of `x` is `Cell<&'A ()>`, where `'A` is some\n+        // fresh, independent region distinct from the `'a` which\n+        // appears in the environment. The call to `require` here\n+        // forces us then to prove that `T: 'A`, but the closure\n+        // cannot do it on its own. It has to surface this requirement\n+        // to its creator (which knows that `'a == 'A`).\n+        require(&x, &y)\n+    })\n+}\n+\n+#[rustc_regions]\n+fn wrong_region<'a, 'b, T>(a: Cell<&'a ()>, b: T)\n+where\n+    T: 'b,\n+{\n+    with_signature(a, b, |x, y| {\n+        //~^ ERROR `T` does not outlive\n+        // See `correct_region`\n+        require(&x, &y)\n+        //~^ WARNING not reporting region error due to -Znll\n+    })\n+}\n+\n+#[rustc_regions]\n+fn outlives_region<'a, 'b, T>(a: Cell<&'a ()>, b: T)\n+where\n+    T: 'b,\n+    'b: 'a,\n+{\n+    with_signature(a, b, |x, y| {\n+        // See `correct_region`\n+        require(&x, &y)\n+    })\n+}\n+\n+fn main() {}"}, {"sha": "78445eb47c328c38c078a07086da5c6a77b78058", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-where-clause.stderr", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,191 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:45:9\n+   |\n+45 |         require(&x, &y)\n+   |         ^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:79:9\n+   |\n+79 |         require(&x, &y)\n+   |         ^^^^^^^\n+\n+note: External requirements\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:38:26\n+   |\n+38 |       with_signature(a, b, |x, y| {\n+   |  __________________________^\n+39 | |         //~^ ERROR `T` does not outlive\n+40 | |         //\n+41 | |         // See `correct_region`, which explains the point of this\n+...  |\n+46 | |         //~^ WARNING not reporting region error due to -Znll\n+47 | |     })\n+   | |_____^\n+   |\n+   = note: defining type: DefId(0/1:16 ~ ty_param_closure_outlives_from_where_clause[317d]::no_region[0]::{{closure}}[0]) with closure substs [\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#1r ()>, T))\n+           ]\n+   = note: number of external vids: 2\n+   = note: where T: '_#1r\n+\n+note: External requirements\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:55:26\n+   |\n+55 |       with_signature(a, b, |x, y| {\n+   |  __________________________^\n+56 | |         // Key point of this test:\n+57 | |         //\n+58 | |         // The *closure* is being type-checked with all of its free\n+...  |\n+67 | |         require(&x, &y)\n+68 | |     })\n+   | |_____^\n+   |\n+   = note: defining type: DefId(0/1:19 ~ ty_param_closure_outlives_from_where_clause[317d]::correct_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+           ]\n+   = note: number of external vids: 3\n+   = note: where T: '_#2r\n+\n+note: External requirements\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:76:26\n+   |\n+76 |       with_signature(a, b, |x, y| {\n+   |  __________________________^\n+77 | |         //~^ ERROR `T` does not outlive\n+78 | |         // See `correct_region`\n+79 | |         require(&x, &y)\n+80 | |         //~^ WARNING not reporting region error due to -Znll\n+81 | |     })\n+   | |_____^\n+   |\n+   = note: defining type: DefId(0/1:23 ~ ty_param_closure_outlives_from_where_clause[317d]::wrong_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+           ]\n+   = note: number of external vids: 3\n+   = note: where T: '_#2r\n+\n+note: External requirements\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:90:26\n+   |\n+90 |       with_signature(a, b, |x, y| {\n+   |  __________________________^\n+91 | |         // See `correct_region`\n+92 | |         require(&x, &y)\n+93 | |     })\n+   | |_____^\n+   |\n+   = note: defining type: DefId(0/1:27 ~ ty_param_closure_outlives_from_where_clause[317d]::outlives_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+   = note: number of external vids: 4\n+   = note: where T: '_#3r\n+\n+error: `T` does not outlive `'_#3r`\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:38:26\n+   |\n+38 |       with_signature(a, b, |x, y| {\n+   |  __________________________^\n+39 | |         //~^ ERROR `T` does not outlive\n+40 | |         //\n+41 | |         // See `correct_region`, which explains the point of this\n+...  |\n+46 | |         //~^ WARNING not reporting region error due to -Znll\n+47 | |     })\n+   | |_____^\n+\n+note: No external requirements\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:37:1\n+   |\n+37 | / fn no_region<'a, T>(a: Cell<&'a ()>, b: T) {\n+38 | |     with_signature(a, b, |x, y| {\n+39 | |         //~^ ERROR `T` does not outlive\n+40 | |         //\n+...  |\n+47 | |     })\n+48 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:6 ~ ty_param_closure_outlives_from_where_clause[317d]::no_region[0]) with substs [\n+               T\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:51:1\n+   |\n+51 | / fn correct_region<'a, T>(a: Cell<&'a ()>, b: T)\n+52 | | where\n+53 | |     T: 'a,\n+54 | | {\n+...  |\n+68 | |     })\n+69 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:7 ~ ty_param_closure_outlives_from_where_clause[317d]::correct_region[0]) with substs [\n+               '_#1r,\n+               T\n+           ]\n+\n+error: `T` does not outlive `'_#5r`\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:76:26\n+   |\n+76 |       with_signature(a, b, |x, y| {\n+   |  __________________________^\n+77 | |         //~^ ERROR `T` does not outlive\n+78 | |         // See `correct_region`\n+79 | |         require(&x, &y)\n+80 | |         //~^ WARNING not reporting region error due to -Znll\n+81 | |     })\n+   | |_____^\n+\n+note: No external requirements\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:72:1\n+   |\n+72 | / fn wrong_region<'a, 'b, T>(a: Cell<&'a ()>, b: T)\n+73 | | where\n+74 | |     T: 'b,\n+75 | | {\n+...  |\n+81 | |     })\n+82 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:8 ~ ty_param_closure_outlives_from_where_clause[317d]::wrong_region[0]) with substs [\n+               '_#1r,\n+               T\n+           ]\n+\n+note: No external requirements\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:85:1\n+   |\n+85 | / fn outlives_region<'a, 'b, T>(a: Cell<&'a ()>, b: T)\n+86 | | where\n+87 | |     T: 'b,\n+88 | |     'b: 'a,\n+...  |\n+93 | |     })\n+94 | | }\n+   | |_^\n+   |\n+   = note: defining type: DefId(0/0:9 ~ ty_param_closure_outlives_from_where_clause[317d]::outlives_region[0]) with substs [\n+               '_#1r,\n+               '_#2r,\n+               T\n+           ]\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "a1e636cbc444bfae288ae97ba244f24cfb680907", "filename": "src/test/ui/nll/ty-outlives/ty-param-fn-body.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Znll -Zborrowck=mir\n+\n+// Test that we assume that universal types like `T` outlive the\n+// function body.\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+\n+use std::cell::Cell;\n+\n+// No errors here, because `'a` is local to the body.\n+fn region_within_body<T>(t: T) {\n+    let some_int = 22;\n+    let cell = Cell::new(&some_int);\n+    outlives(cell, t)\n+}\n+\n+// Error here, because T: 'a is not satisfied.\n+fn region_static<'a, T>(cell: Cell<&'a usize>, t: T) {\n+    outlives(cell, t)\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR `T` does not outlive\n+}\n+\n+fn outlives<'a, T>(x: Cell<&'a usize>, y: T)\n+where\n+    T: 'a,\n+{\n+}\n+\n+fn main() {}"}, {"sha": "bbe55c52b6ed5684941ee6985171fd5a65144ce5", "filename": "src/test/ui/nll/ty-outlives/ty-param-fn-body.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn-body.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,14 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/ty-param-fn-body.rs:30:5\n+   |\n+30 |     outlives(cell, t)\n+   |     ^^^^^^^^\n+\n+error: `T` does not outlive `'_#4r`\n+  --> $DIR/ty-param-fn-body.rs:30:5\n+   |\n+30 |     outlives(cell, t)\n+   |     ^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "76783af4ceb0e9b39075ac702db02df3246d3ad4", "filename": "src/test/ui/nll/ty-outlives/ty-param-fn.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.rs?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Znll -Zborrowck=mir\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+\n+use std::fmt::Debug;\n+\n+fn no_region<'a, T>(x: Box<T>) -> Box<Debug + 'a>\n+where\n+    T: Debug,\n+{\n+    x\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR `T` does not outlive\n+}\n+\n+fn correct_region<'a, T>(x: Box<T>) -> Box<Debug + 'a>\n+where\n+    T: 'a + Debug,\n+{\n+    x\n+}\n+\n+fn wrong_region<'a, 'b, T>(x: Box<T>) -> Box<Debug + 'a>\n+where\n+    T: 'b + Debug,\n+{\n+    x\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR `T` does not outlive\n+}\n+\n+fn outlives_region<'a, 'b, T>(x: Box<T>) -> Box<Debug + 'a>\n+where\n+    T: 'b + Debug,\n+    'b: 'a,\n+{\n+    x\n+}\n+\n+fn main() {}"}, {"sha": "02c4ebbd5aca9c4f9fc46fd42f19f023e1944ac9", "filename": "src/test/ui/nll/ty-outlives/ty-param-fn.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/588f7db8ef588ea7e349817bb44b4e37bfd92745/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-fn.stderr?ref=588f7db8ef588ea7e349817bb44b4e37bfd92745", "patch": "@@ -0,0 +1,26 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/ty-param-fn.rs:22:5\n+   |\n+22 |     x\n+   |     ^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/ty-param-fn.rs:38:5\n+   |\n+38 |     x\n+   |     ^\n+\n+error: `T` does not outlive `'_#3r`\n+  --> $DIR/ty-param-fn.rs:22:5\n+   |\n+22 |     x\n+   |     ^\n+\n+error: `T` does not outlive `'_#4r`\n+  --> $DIR/ty-param-fn.rs:38:5\n+   |\n+38 |     x\n+   |     ^\n+\n+error: aborting due to 2 previous errors\n+"}]}