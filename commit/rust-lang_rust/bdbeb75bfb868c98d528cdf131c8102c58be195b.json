{"sha": "bdbeb75bfb868c98d528cdf131c8102c58be195b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkYmViNzViZmI4NjhjOThkNTI4Y2RmMTMxYzgxMDJjNThiZTE5NWI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-23T00:37:18Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-23T00:37:18Z"}, "message": "Upgrade libuv to 179f475b2ad64729feb0422f06ce133cb364482a", "tree": {"sha": "1fce689b0606fb8423999990a01f2dc8158d4dc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fce689b0606fb8423999990a01f2dc8158d4dc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdbeb75bfb868c98d528cdf131c8102c58be195b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdbeb75bfb868c98d528cdf131c8102c58be195b", "html_url": "https://github.com/rust-lang/rust/commit/bdbeb75bfb868c98d528cdf131c8102c58be195b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdbeb75bfb868c98d528cdf131c8102c58be195b/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81a44ccacfc9da31dab6434db54ef023e9950ac2", "url": "https://api.github.com/repos/rust-lang/rust/commits/81a44ccacfc9da31dab6434db54ef023e9950ac2", "html_url": "https://github.com/rust-lang/rust/commit/81a44ccacfc9da31dab6434db54ef023e9950ac2"}], "stats": {"total": 21397, "additions": 19561, "deletions": 1836}, "files": [{"sha": "79a35ca39af8ea6530ce0f43b8ea9f3c0050a25b", "filename": "mk/libuv/mac/Makefile", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Fmac%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Fmac%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fmac%2FMakefile?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -37,20 +37,19 @@ abs_obj := $(abspath $(obj))\n # generated dependency rule Makefiles in one pass.\n all_deps :=\n \n-# C++ apps need to be linked with g++.  Not sure what's appropriate.\n+\n+\n+# C++ apps need to be linked with g++.\n #\n-# Note, the flock is used to seralize linking. Linking is a memory-intensive\n+# Note: flock is used to seralize linking. Linking is a memory-intensive\n # process so running parallel links can often lead to thrashing.  To disable\n-# the serialization, override FLOCK via an envrionment variable as follows:\n+# the serialization, override LINK via an envrionment variable as follows:\n #\n-#   export FLOCK=\n+#   export LINK=g++\n #\n # This will allow make to invoke N linker processes as specified in -jN.\n-FLOCK ?= ./gyp-mac-tool flock $(builddir)/linker.lock\n-\n+LINK ?= ./gyp-mac-tool flock $(builddir)/linker.lock $(CXX)\n \n-\n-LINK ?= $(FLOCK) $(CXX)\n CC.target ?= $(CC)\n CFLAGS.target ?= $(CFLAGS)\n CXX.target ?= $(CXX)\n@@ -223,6 +222,23 @@ command_changed = $(or $(subst $(cmd_$(1)),,$(cmd_$(call replace_spaces,$@))),\\\n #   $| -- order-only dependencies\n prereq_changed = $(filter-out FORCE_DO_CMD,$(filter-out $|,$?))\n \n+# Helper that executes all postbuilds, and deletes the output file when done\n+# if any of the postbuilds failed.\n+define do_postbuilds\n+  @E=0;\\\n+  for p in $(POSTBUILDS); do\\\n+    eval $$p;\\\n+    F=$$?;\\\n+    if [ $$F -ne 0 ]; then\\\n+      E=$$F;\\\n+    fi;\\\n+  done;\\\n+  if [ $$E -ne 0 ]; then\\\n+    rm -rf \"$@\";\\\n+    exit $$E;\\\n+  fi\n+endef\n+\n # do_cmd: run a command via the above cmd_foo names, if necessary.\n # Should always run for a given target to handle command-line changes.\n # Second argument, if non-zero, makes it do asm/C/C++ dependency munging.\n@@ -241,7 +257,7 @@ $(if $(or $(command_changed),$(prereq_changed)),\n   @$(call exact_echo,$(call escape_vars,cmd_$(call replace_spaces,$@) := $(cmd_$(1)))) > $(depfile)\n   @$(if $(2),$(fixup_dep))\n   $(if $(and $(3), $(POSTBUILDS)),\n-    @for p in $(POSTBUILDS); do eval $$p; done\n+    $(call do_postbuilds)\n   )\n )\n endef"}, {"sha": "15272c03c13c29387a0c9bd5c8e38e2eff4462cd", "filename": "mk/libuv/mac/gyp-mac-tool", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Fmac%2Fgyp-mac-tool", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Fmac%2Fgyp-mac-tool", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fmac%2Fgyp-mac-tool?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -74,12 +74,14 @@ class MacTool(object):\n     if not plist:\n       return\n \n+    # Only create PkgInfo for executable types.\n+    package_type = plist['CFBundlePackageType']\n+    if package_type != 'APPL':\n+      return\n+\n     # The format of PkgInfo is eight characters, representing the bundle type\n-    # and bundle signature, each four characters. If either is missing, four\n+    # and bundle signature, each four characters. If that is missing, four\n     # '?' characters are used instead.\n-    package_type = plist['CFBundlePackageType']\n-    if len(package_type) != 4:\n-      package_type = '?' * 4\n     signature_code = plist['CFBundleSignature']\n     if len(signature_code) != 4:\n       signature_code = '?' * 4"}, {"sha": "95fe809a17e88a68fc91730caa5cb60c2653a7f9", "filename": "mk/libuv/mac/src/rt/libuv/run-benchmarks.target.mk", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Fmac%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Fmac%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fmac%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -2,11 +2,15 @@\n \n TOOLSET := target\n TARGET := run-benchmarks\n-DEFS_Default := '-D_GNU_SOURCE'\n+DEFS_Default := '-D_LARGEFILE_SOURCE' \\\n+\t'-D_FILE_OFFSET_BITS=64' \\\n+\t'-D_GNU_SOURCE' \\\n+\t'-DEIO_STACKSIZE=262144'\n \n # Flags passed to all source files.\n CFLAGS_Default := -fasm-blocks \\\n \t-mpascal-strings \\\n+\t-Os \\\n \t-gdwarf-2 \\\n \t-arch i386\n \n@@ -31,9 +35,11 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-ares.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-pump.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-sizes.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-spawn.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-tcp-write-batch.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-udp-packet-storm.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/dns-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/echo-server.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/blackhole-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/run-benchmarks.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/runner.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/runner-unix.o"}, {"sha": "f3ef6c3eae3a98c722d02852db27ccc704a59e75", "filename": "mk/libuv/mac/src/rt/libuv/run-tests.target.mk", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Fmac%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Fmac%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fmac%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -2,11 +2,15 @@\n \n TOOLSET := target\n TARGET := run-tests\n-DEFS_Default := '-D_GNU_SOURCE'\n+DEFS_Default := '-D_LARGEFILE_SOURCE' \\\n+\t'-D_FILE_OFFSET_BITS=64' \\\n+\t'-D_GNU_SOURCE' \\\n+\t'-DEIO_STACKSIZE=262144'\n \n # Flags passed to all source files.\n CFLAGS_Default := -fasm-blocks \\\n \t-mpascal-strings \\\n+\t-Os \\\n \t-gdwarf-2 \\\n \t-arch i386\n \n@@ -24,32 +28,41 @@ CFLAGS_OBJCC_Default :=\n \n INCS_Default := -I$(srcdir)/src/rt/libuv/include\n \n-OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/echo-server.o \\\n+OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/blackhole-server.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/echo-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/run-tests.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/runner.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-get-loadavg.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-async.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-callback-stack.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-connection-fail.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-delayed-accept.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-fail-always.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-fs.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-fs-event.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-get-currentexe.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-get-memory.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-getaddrinfo.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-gethostbyname.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-getsockname.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-hrtime.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-idle.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ipc.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-loop-handles.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pass-always.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ping-pong.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pipe-bind-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ref.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-shutdown-eof.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-spawn.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-stdio-over-pipes.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-bind-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-bind6-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-close.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-flags.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-connect-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-connect6-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-write-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-writealot.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-threadpool.o \\\n@@ -59,6 +72,7 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/echo-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-udp-dgram-too-big.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-udp-ipv6.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-udp-send-and-recv.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-udp-multicast-join.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/runner-unix.o\n \n # Add to the list of files we specially track dependencies for."}, {"sha": "75ade3733e0c3e5a077bf1b7d48b999d74674051", "filename": "mk/libuv/mac/src/rt/libuv/uv.target.mk", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Fmac%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Fmac%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fmac%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -2,17 +2,18 @@\n \n TOOLSET := target\n TARGET := uv\n-DEFS_Default := '-DHAVE_CONFIG_H' \\\n-\t'-D_LARGEFILE_SOURCE' \\\n+DEFS_Default := '-D_LARGEFILE_SOURCE' \\\n \t'-D_FILE_OFFSET_BITS=64' \\\n \t'-D_GNU_SOURCE' \\\n \t'-DEIO_STACKSIZE=262144' \\\n+\t'-DHAVE_CONFIG_H' \\\n \t'-DEV_CONFIG_H=\"config_darwin.h\"' \\\n \t'-DEIO_CONFIG_H=\"config_darwin.h\"'\n \n # Flags passed to all source files.\n CFLAGS_Default := -fasm-blocks \\\n \t-mpascal-strings \\\n+\t-Os \\\n \t-gdwarf-2 \\\n \t-arch i386\n \n@@ -35,11 +36,8 @@ INCS_Default := -I$(srcdir)/src/rt/libuv/include \\\n \t-I$(srcdir)/src/rt/libuv/src/ares/config_darwin\n \n OBJS := $(obj).target/$(TARGET)/src/rt/libuv/src/uv-common.o \\\n-\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__close_sockets.o \\\n-\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__get_hostent.o \\\n-\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__read_line.o \\\n-\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__timeval.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_cancel.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__close_sockets.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_data.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_destroy.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_expand_name.o \\\n@@ -49,6 +47,7 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/src/uv-common.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_free_string.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_gethostbyaddr.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_gethostbyname.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__get_hostent.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_getnameinfo.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_getopt.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_getsock.o \\\n@@ -58,26 +57,29 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/src/uv-common.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_mkquery.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_nowarn.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_options.o \\\n-\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_a_reply.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_aaaa_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_a_reply.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_mx_reply.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_ns_reply.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_ptr_reply.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_srv_reply.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_txt_reply.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_process.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_query.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__read_line.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_search.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_send.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_strcasecmp.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_strdup.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_strerror.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_timeout.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__timeval.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_version.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_writev.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/bitncmp.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/inet_net_pton.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/inet_ntop.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/windows_port.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/core.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/uv-eio.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/fs.o \\\n@@ -91,7 +93,8 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/src/uv-common.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/process.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/eio/eio.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/ev/ev.o \\\n-\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/darwin.o\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/darwin.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/kqueue.o\n \n # Add to the list of files we specially track dependencies for.\n all_deps += $(OBJS)"}, {"sha": "f00580ec35b1c30adf74e3922b4b4319879f32a1", "filename": "mk/libuv/unix/Makefile", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Funix%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Funix%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Funix%2FMakefile?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -37,20 +37,19 @@ abs_obj := $(abspath $(obj))\n # generated dependency rule Makefiles in one pass.\n all_deps :=\n \n-# C++ apps need to be linked with g++.  Not sure what's appropriate.\n+\n+\n+# C++ apps need to be linked with g++.\n #\n-# Note, the flock is used to seralize linking. Linking is a memory-intensive\n+# Note: flock is used to seralize linking. Linking is a memory-intensive\n # process so running parallel links can often lead to thrashing.  To disable\n-# the serialization, override FLOCK via an envrionment variable as follows:\n+# the serialization, override LINK via an envrionment variable as follows:\n #\n-#   export FLOCK=\n+#   export LINK=g++\n #\n # This will allow make to invoke N linker processes as specified in -jN.\n-FLOCK ?= flock $(builddir)/linker.lock\n-\n+LINK ?= flock $(builddir)/linker.lock $(CXX)\n \n-\n-LINK ?= $(FLOCK) $(CXX)\n CC.target ?= $(CC)\n CFLAGS.target ?= $(CFLAGS)\n CXX.target ?= $(CXX)\n@@ -213,6 +212,23 @@ command_changed = $(or $(subst $(cmd_$(1)),,$(cmd_$(call replace_spaces,$@))),\\\n #   $| -- order-only dependencies\n prereq_changed = $(filter-out FORCE_DO_CMD,$(filter-out $|,$?))\n \n+# Helper that executes all postbuilds, and deletes the output file when done\n+# if any of the postbuilds failed.\n+define do_postbuilds\n+  @E=0;\\\n+  for p in $(POSTBUILDS); do\\\n+    eval $$p;\\\n+    F=$$?;\\\n+    if [ $$F -ne 0 ]; then\\\n+      E=$$F;\\\n+    fi;\\\n+  done;\\\n+  if [ $$E -ne 0 ]; then\\\n+    rm -rf \"$@\";\\\n+    exit $$E;\\\n+  fi\n+endef\n+\n # do_cmd: run a command via the above cmd_foo names, if necessary.\n # Should always run for a given target to handle command-line changes.\n # Second argument, if non-zero, makes it do asm/C/C++ dependency munging.\n@@ -231,7 +247,7 @@ $(if $(or $(command_changed),$(prereq_changed)),\n   @$(call exact_echo,$(call escape_vars,cmd_$(call replace_spaces,$@) := $(cmd_$(1)))) > $(depfile)\n   @$(if $(2),$(fixup_dep))\n   $(if $(and $(3), $(POSTBUILDS)),\n-    @for p in $(POSTBUILDS); do eval $$p; done\n+    $(call do_postbuilds)\n   )\n )\n endef"}, {"sha": "68135b0eaba25d54e887ebc66fa6cac88ae6cf8d", "filename": "mk/libuv/unix/src/rt/libuv/run-benchmarks.target.mk", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -2,7 +2,10 @@\n \n TOOLSET := target\n TARGET := run-benchmarks\n-DEFS_Default := '-D_GNU_SOURCE'\n+DEFS_Default := '-D_LARGEFILE_SOURCE' \\\n+\t'-D_FILE_OFFSET_BITS=64' \\\n+\t'-D_GNU_SOURCE' \\\n+\t'-DEIO_STACKSIZE=262144'\n \n # Flags passed to all source files.\n CFLAGS_Default := \n@@ -22,9 +25,11 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-ares.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-pump.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-sizes.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-spawn.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-tcp-write-batch.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-udp-packet-storm.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/dns-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/echo-server.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/blackhole-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/run-benchmarks.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/runner.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/runner-unix.o"}, {"sha": "de3b45c6f2117ceeead86a9c8e7181c9a4e97c86", "filename": "mk/libuv/unix/src/rt/libuv/run-tests.target.mk", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -2,7 +2,10 @@\n \n TOOLSET := target\n TARGET := run-tests\n-DEFS_Default := '-D_GNU_SOURCE'\n+DEFS_Default := '-D_LARGEFILE_SOURCE' \\\n+\t'-D_FILE_OFFSET_BITS=64' \\\n+\t'-D_GNU_SOURCE' \\\n+\t'-DEIO_STACKSIZE=262144'\n \n # Flags passed to all source files.\n CFLAGS_Default := \n@@ -15,32 +18,41 @@ CFLAGS_CC_Default :=\n \n INCS_Default := -I$(srcdir)/src/rt/libuv/include\n \n-OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/echo-server.o \\\n+OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/blackhole-server.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/echo-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/run-tests.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/runner.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-get-loadavg.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-async.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-callback-stack.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-connection-fail.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-delayed-accept.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-fail-always.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-fs.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-fs-event.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-get-currentexe.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-get-memory.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-getaddrinfo.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-gethostbyname.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-getsockname.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-hrtime.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-idle.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ipc.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-loop-handles.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pass-always.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ping-pong.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pipe-bind-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ref.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-shutdown-eof.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-spawn.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-stdio-over-pipes.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-bind-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-bind6-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-close.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-flags.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-connect-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-connect6-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-write-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-writealot.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-threadpool.o \\\n@@ -50,6 +62,7 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/echo-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-udp-dgram-too-big.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-udp-ipv6.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-udp-send-and-recv.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-udp-multicast-join.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/runner-unix.o\n \n # Add to the list of files we specially track dependencies for."}, {"sha": "4a9b2b5b888d173650b2ee4344364ad2eb3e412b", "filename": "mk/libuv/unix/src/rt/libuv/uv.target.mk", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Funix%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Funix%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Funix%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -2,11 +2,11 @@\n \n TOOLSET := target\n TARGET := uv\n-DEFS_Default := '-DHAVE_CONFIG_H' \\\n-\t'-D_LARGEFILE_SOURCE' \\\n+DEFS_Default := '-D_LARGEFILE_SOURCE' \\\n \t'-D_FILE_OFFSET_BITS=64' \\\n \t'-D_GNU_SOURCE' \\\n \t'-DEIO_STACKSIZE=262144' \\\n+\t'-DHAVE_CONFIG_H' \\\n \t'-DEV_CONFIG_H=\"config_linux.h\"' \\\n \t'-DEIO_CONFIG_H=\"config_linux.h\"'\n \n@@ -31,11 +31,8 @@ INCS_Default := -I$(srcdir)/src/rt/libuv/include \\\n \t-I$(srcdir)/src/rt/libuv/src/ares/config_linux\n \n OBJS := $(obj).target/$(TARGET)/src/rt/libuv/src/uv-common.o \\\n-\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__close_sockets.o \\\n-\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__get_hostent.o \\\n-\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__read_line.o \\\n-\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__timeval.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_cancel.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__close_sockets.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_data.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_destroy.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_expand_name.o \\\n@@ -45,6 +42,7 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/src/uv-common.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_free_string.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_gethostbyaddr.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_gethostbyname.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__get_hostent.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_getnameinfo.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_getopt.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_getsock.o \\\n@@ -54,26 +52,29 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/src/uv-common.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_mkquery.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_nowarn.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_options.o \\\n-\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_a_reply.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_aaaa_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_a_reply.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_mx_reply.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_ns_reply.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_ptr_reply.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_srv_reply.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_txt_reply.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_process.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_query.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__read_line.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_search.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_send.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_strcasecmp.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_strdup.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_strerror.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_timeout.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__timeval.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_version.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_writev.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/bitncmp.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/inet_net_pton.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/inet_ntop.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/windows_port.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/core.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/uv-eio.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/fs.o \\"}, {"sha": "e77596ae7be5981e85bbd34ce00d3d61a1e4f229", "filename": "mk/libuv/win/Makefile", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Fwin%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Fwin%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fwin%2FMakefile?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -37,20 +37,19 @@ abs_obj := $(abspath $(obj))\n # generated dependency rule Makefiles in one pass.\n all_deps :=\n \n-# C++ apps need to be linked with g++.  Not sure what's appropriate.\n+\n+\n+# C++ apps need to be linked with g++.\n #\n-# Note, the flock is used to seralize linking. Linking is a memory-intensive\n+# Note: flock is used to seralize linking. Linking is a memory-intensive\n # process so running parallel links can often lead to thrashing.  To disable\n-# the serialization, override FLOCK via an envrionment variable as follows:\n+# the serialization, override LINK via an envrionment variable as follows:\n #\n-#   export FLOCK=\n+#   export LINK=g++\n #\n # This will allow make to invoke N linker processes as specified in -jN.\n-FLOCK ?= flock $(builddir)/linker.lock\n-\n+LINK ?= flock $(builddir)/linker.lock $(CXX)\n \n-\n-LINK ?= $(FLOCK) $(CXX)\n CC.target ?= $(CC)\n CFLAGS.target ?= $(CFLAGS)\n CXX.target ?= $(CXX)\n@@ -213,6 +212,23 @@ command_changed = $(or $(subst $(cmd_$(1)),,$(cmd_$(call replace_spaces,$@))),\\\n #   $| -- order-only dependencies\n prereq_changed = $(filter-out FORCE_DO_CMD,$(filter-out $|,$?))\n \n+# Helper that executes all postbuilds, and deletes the output file when done\n+# if any of the postbuilds failed.\n+define do_postbuilds\n+  @E=0;\\\n+  for p in $(POSTBUILDS); do\\\n+    eval $$p;\\\n+    F=$$?;\\\n+    if [ $$F -ne 0 ]; then\\\n+      E=$$F;\\\n+    fi;\\\n+  done;\\\n+  if [ $$E -ne 0 ]; then\\\n+    rm -rf \"$@\";\\\n+    exit $$E;\\\n+  fi\n+endef\n+\n # do_cmd: run a command via the above cmd_foo names, if necessary.\n # Should always run for a given target to handle command-line changes.\n # Second argument, if non-zero, makes it do asm/C/C++ dependency munging.\n@@ -231,7 +247,7 @@ $(if $(or $(command_changed),$(prereq_changed)),\n   @$(call exact_echo,$(call escape_vars,cmd_$(call replace_spaces,$@) := $(cmd_$(1)))) > $(depfile)\n   @$(if $(2),$(fixup_dep))\n   $(if $(and $(3), $(POSTBUILDS)),\n-    @for p in $(POSTBUILDS); do eval $$p; done\n+    $(call do_postbuilds)\n   )\n )\n endef"}, {"sha": "73378736e3720770e472e4bf9bee0d713cfae801", "filename": "mk/libuv/win/src/rt/libuv/run-benchmarks.target.mk", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Fwin%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Fwin%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fwin%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -22,9 +22,11 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-ares.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-pump.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-sizes.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-spawn.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-tcp-write-batch.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/benchmark-udp-packet-storm.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/dns-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/echo-server.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/blackhole-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/run-benchmarks.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/runner.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/runner-win.o"}, {"sha": "860b29f06406c089cc0c20debfdf86eb196b6383", "filename": "mk/libuv/win/src/rt/libuv/run-tests.target.mk", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Fwin%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Fwin%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fwin%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -15,32 +15,41 @@ CFLAGS_CC_Default :=\n \n INCS_Default := -I$(srcdir)/src/rt/libuv/include\n \n-OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/echo-server.o \\\n+OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/blackhole-server.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/echo-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/run-tests.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/runner.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-get-loadavg.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-async.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-callback-stack.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-connection-fail.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-delayed-accept.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-fail-always.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-fs.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-fs-event.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-get-currentexe.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-get-memory.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-getaddrinfo.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-gethostbyname.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-getsockname.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-hrtime.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-idle.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ipc.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-loop-handles.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pass-always.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ping-pong.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pipe-bind-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ref.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-shutdown-eof.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-spawn.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-stdio-over-pipes.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-bind-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-bind6-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-close.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-flags.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-connect-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-connect6-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-write-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-writealot.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-threadpool.o \\\n@@ -50,6 +59,7 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/echo-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-udp-dgram-too-big.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-udp-ipv6.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-udp-send-and-recv.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-udp-multicast-join.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/runner-win.o\n \n # Add to the list of files we specially track dependencies for."}, {"sha": "17c78fb6ff67e67ca9fd945fde24d6da2544eadc", "filename": "mk/libuv/win/src/rt/libuv/uv.target.mk", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Fwin%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/mk%2Flibuv%2Fwin%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fwin%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -22,11 +22,8 @@ INCS_Default := -I$(srcdir)/src/rt/libuv/include \\\n \t-I$(srcdir)/src/rt/libuv/src/ares/config_win32\n \n OBJS := $(obj).target/$(TARGET)/src/rt/libuv/src/uv-common.o \\\n-\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__close_sockets.o \\\n-\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__get_hostent.o \\\n-\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__read_line.o \\\n-\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__timeval.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_cancel.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__close_sockets.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_data.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_destroy.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_expand_name.o \\\n@@ -36,6 +33,7 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/src/uv-common.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_free_string.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_gethostbyaddr.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_gethostbyname.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__get_hostent.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_getnameinfo.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_getopt.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_getsock.o \\\n@@ -45,27 +43,31 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/src/uv-common.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_mkquery.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_nowarn.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_options.o \\\n-\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_a_reply.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_aaaa_reply.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_a_reply.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_mx_reply.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_ns_reply.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_ptr_reply.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_srv_reply.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_parse_txt_reply.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_process.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_query.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__read_line.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_search.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_send.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_strcasecmp.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_strdup.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_strerror.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_timeout.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares__timeval.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_version.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_writev.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/bitncmp.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/inet_net_pton.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/inet_ntop.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/windows_port.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_getenv.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/ares/ares_platform.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/win/async.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/win/cares.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/win/core.o \\\n@@ -78,7 +80,6 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/src/uv-common.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/win/pipe.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/win/process.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/win/req.o \\\n-\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/stdio.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/win/stream.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/win/tcp.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/win/tty.o \\"}, {"sha": "2d608f95f4f16995b328057644254b4d0b21801b", "filename": "src/rt/libuv/.mailmap", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2F.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2F.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2F.mailmap?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -6,3 +6,5 @@\n <alan@prettyrobots.com> <alan@blogometer.com>\n San-Tai Hsu <vanilla@fatpipi.com>\n Isaac Z. Schlueter <i@izs.me>\n+Sa\u00fal Ibarra Corretg\u00e9 <saghul@gmail.com>\n+Yuki OKUMURA <mjt@cltn.org>"}, {"sha": "2d43c3661416c2c422fe927b4700d493844af73a", "filename": "src/rt/libuv/AUTHORS", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2FAUTHORS", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2FAUTHORS", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2FAUTHORS?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -24,3 +24,10 @@ Matthew Sporleder <msporleder@gmail.com>\n Erick Tryzelaar <erick.tryzelaar@gmail.com>\n Isaac Z. Schlueter <i@izs.me>\n Pieter Noordhuis <pcnoordhuis@gmail.com>\n+Marek Jelen <marek@jelen.biz>\n+Fedor Indutny <fedor.indutny@gmail.com>\n+Sa\u00fal Ibarra Corretg\u00e9 <saghul@gmail.com>\n+Felix Geisendo\u0308rfer <felix@debuggable.com>\n+Yuki OKUMURA <mjt@cltn.org>\n+Roman Shtylman <shtylman@gmail.com>\n+Frank DENIS <github@pureftpd.org>"}, {"sha": "cf1e7880bfac42b525dfe3cb126c2b823b23453b", "filename": "src/rt/libuv/Makefile", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2FMakefile?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -77,10 +77,10 @@ else\n include config-unix.mk\n endif\n \n-TESTS=test/echo-server.c test/test-*.c\n-BENCHMARKS=test/echo-server.c test/dns-server.c test/benchmark-*.c\n+TESTS=test/blackhole-server.c test/echo-server.c test/test-*.c\n+BENCHMARKS=test/blackhole-server.c test/echo-server.c test/dns-server.c test/benchmark-*.c\n \n-all: uv.a test/run-tests$(E) test/run-benchmarks$(E)\n+all: uv.a\n \n $(CARES_OBJS): %.o: %.c\n \t$(CC) -o $*.o -c $(CFLAGS) $(CPPFLAGS) $< -DHAVE_CONFIG_H"}, {"sha": "8e569bbfb6128dd0f5f844b94b4cb864457f9711", "filename": "src/rt/libuv/README.md", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2FREADME.md?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -8,8 +8,6 @@ http://nodejs.org/\n \n ## Features\n \n-Implemented:\n-\n  * Non-blocking TCP sockets\n \n  * Non-blocking named pipes\n@@ -30,15 +28,13 @@ Implemented:\n \n  * Thread pool scheduling `uv_queue_work`\n \n-In-progress:\n+ * ANSI escape code controlled TTY `uv_tty_t`\n \n- * File system events (Currently supports inotify, `ReadDirectoryChangesW`\n-   and will support kqueue and event ports in the near future.)\n+ * File system events Currently supports inotify, `ReadDirectoryChangesW`\n+   and kqueue. Event ports in the near future.\n    `uv_fs_event_t`\n \n- * VT100 TTY `uv_tty_t`\n-\n- * Socket sharing between processes `uv_ipc_t`\n+ * IPC and socket sharing between processes `uv_write2`\n \n \n ## Documentation"}, {"sha": "373c3aa980772e85cf449d58b22478db1cb31b90", "filename": "src/rt/libuv/common.gypi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fcommon.gypi", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fcommon.gypi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fcommon.gypi?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -32,6 +32,11 @@\n             'LinkIncremental': 2, # enable incremental linking\n           },\n         },\n+        'conditions': [\n+          ['OS != \"win\"', {\n+            'defines': [ 'EV_VERIFY=2' ],\n+          }],\n+        ]\n       },\n       'Release': {\n         'defines': [ 'NDEBUG' ],"}, {"sha": "5ef189bd738673ec7a7977f25c3f68a00a18fa3c", "filename": "src/rt/libuv/config-mingw.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fconfig-mingw.mk", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fconfig-mingw.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fconfig-mingw.mk?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -28,6 +28,7 @@ CFLAGS=$(CPPFLAGS) -g --std=gnu89 -D_WIN32_WINNT=0x0501 -Isrc/ares/config_win32\n LINKFLAGS=-lm\n \n CARES_OBJS += src/ares/windows_port.o\n+CARES_OBJS += src/ares/ares_platform.o\n WIN_SRCS=$(wildcard src/win/*.c)\n WIN_OBJS=$(WIN_SRCS:.c=.o)\n "}, {"sha": "53bcbd4c9848d558cdc2e3265a8b42078d1e2597", "filename": "src/rt/libuv/config-unix.mk", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fconfig-unix.mk", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fconfig-unix.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fconfig-unix.mk?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -18,8 +18,6 @@\n # FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n # IN THE SOFTWARE.\n \n-CC = $(PREFIX)gcc\n-AR = $(PREFIX)ar\n E=\n CSTDFLAG=--std=c89 -pedantic -Wall -Wextra -Wno-unused-parameter\n CFLAGS += -g\n@@ -44,7 +42,7 @@ ifeq (SunOS,$(uname_S))\n EV_CONFIG=config_sunos.h\n EIO_CONFIG=config_sunos.h\n CPPFLAGS += -Isrc/ares/config_sunos -D__EXTENSIONS__ -D_XOPEN_SOURCE=500\n-LINKFLAGS+=-lsocket -lnsl\n+LINKFLAGS+=-lsocket -lnsl -lkstat\n OBJS += src/unix/sunos.o\n endif\n \n@@ -54,6 +52,7 @@ EIO_CONFIG=config_darwin.h\n CPPFLAGS += -Isrc/ares/config_darwin\n LINKFLAGS+=-framework CoreServices\n OBJS += src/unix/darwin.o\n+OBJS += src/unix/kqueue.o\n endif\n \n ifeq (Linux,$(uname_S))\n@@ -71,6 +70,7 @@ EIO_CONFIG=config_freebsd.h\n CPPFLAGS += -Isrc/ares/config_freebsd\n LINKFLAGS+=\n OBJS += src/unix/freebsd.o\n+OBJS += src/unix/kqueue.o\n endif\n \n ifeq (NetBSD,$(uname_S))\n@@ -79,6 +79,16 @@ EIO_CONFIG=config_netbsd.h\n CPPFLAGS += -Isrc/ares/config_netbsd\n LINKFLAGS+=\n OBJS += src/unix/netbsd.o\n+OBJS += src/unix/kqueue.o\n+endif\n+\n+ifeq (OpenBSD,$(uname_S))\n+EV_CONFIG=config_openbsd.h\n+EIO_CONFIG=config_openbsd.h\n+CPPFLAGS += -Isrc/ares/config_openbsd\n+LINKFLAGS+=\n+OBJS += src/unix/openbsd.o\n+OBJS += src/unix/kqueue.o\n endif\n \n ifneq (,$(findstring CYGWIN,$(uname_S)))"}, {"sha": "53ac861b2cec69c5c5dc21bc70c6e99d638f7bf2", "filename": "src/rt/libuv/include/ares.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Finclude%2Fares.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Finclude%2Fares.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fares.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -1,6 +1,6 @@\n \n /* Copyright 1998, 2009 by the Massachusetts Institute of Technology.\n- * Copyright (C) 2007-2010 by Daniel Stenberg\n+ * Copyright (C) 2007-2011 by Daniel Stenberg\n  *\n  * Permission to use, copy, modify, and distribute this\n  * software and its documentation for any purpose and without\n@@ -96,10 +96,19 @@ typedef int ares_socklen_t;\n #  include <netinet/in.h>\n #  include <sys/socket.h>\n #  include <tcp.h>\n+#elif defined(_WIN32_WCE)\n+#  ifndef WIN32_LEAN_AND_MEAN\n+#    define WIN32_LEAN_AND_MEAN\n+#  endif\n+#  include <windows.h>\n+#  include <winsock.h>\n #elif defined(WIN32)\n+#  ifndef WIN32_LEAN_AND_MEAN\n+#    define WIN32_LEAN_AND_MEAN\n+#  endif\n+#  include <windows.h>\n #  include <winsock2.h>\n #  include <ws2tcpip.h>\n-#  include <windows.h>\n #else\n #  include <sys/socket.h>\n #  include <netinet/in.h>"}, {"sha": "efd0156dd10f3790b2ce5f0628336a347a8cf019", "filename": "src/rt/libuv/include/ares_version.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Finclude%2Fares_version.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Finclude%2Fares_version.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fares_version.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -7,11 +7,11 @@\n \n #define ARES_VERSION_MAJOR 1\n #define ARES_VERSION_MINOR 7\n-#define ARES_VERSION_PATCH 4\n+#define ARES_VERSION_PATCH 5\n #define ARES_VERSION ((ARES_VERSION_MAJOR<<16)|\\\n                        (ARES_VERSION_MINOR<<8)|\\\n                        (ARES_VERSION_PATCH))\n-#define ARES_VERSION_STR \"1.7.4\"\n+#define ARES_VERSION_STR \"1.7.5-DEV\"\n \n #if (ARES_VERSION >= 0x010700)\n #  define CARES_HAVE_ARES_LIBRARY_INIT 1"}, {"sha": "5d2d7a1e37edf50b9686e7ddbe0c5c7709c5d9c9", "filename": "src/rt/libuv/include/uv-private/ev.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fev.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fev.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fev.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -207,6 +207,7 @@ enum {\n   EV_NONE     =       0x00, /* no events */\n   EV_READ     =       0x01, /* ev_io detected read will not block */\n   EV_WRITE    =       0x02, /* ev_io detected write will not block */\n+  EV_LIBUV_KQUEUE_HACK = 0x40,\n   EV__IOFDSET =       0x80, /* internal use only */\n   EV_IO       =    EV_READ, /* alias for type-detection */\n   EV_TIMER    = 0x00000100, /* timer timed out */"}, {"sha": "0db14e9c7f068836a2f0ef86612c3830fd61e6e4", "filename": "src/rt/libuv/include/uv-private/uv-unix.h", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-unix.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-unix.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-unix.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -27,16 +27,13 @@\n #include \"ev.h\"\n #include \"eio.h\"\n \n-#if defined(__linux__)\n-#include \"uv-private/uv-linux.h\"\n-#endif\n-\n #include <sys/types.h>\n #include <sys/socket.h>\n-#include <netdb.h>\n #include <netinet/in.h>\n #include <netinet/tcp.h>\n-\n+#include <arpa/inet.h>\n+#include <netdb.h>\n+#include <termios.h>\n \n /* Note: May be cast to struct iovec. See writev(2). */\n typedef struct {\n@@ -46,11 +43,6 @@ typedef struct {\n \n typedef int uv_file;\n \n-/* Stub. Remove it once all platforms support the file watcher API. */\n-#ifndef UV_FS_EVENT_PRIVATE_FIELDS\n-#define UV_FS_EVENT_PRIVATE_FIELDS /* empty */\n-#endif\n-\n #define UV_LOOP_PRIVATE_FIELDS \\\n   ares_channel channel; \\\n   /* \\\n@@ -99,8 +91,6 @@ typedef int uv_file;\n \n \n #define UV_STREAM_PRIVATE_FIELDS \\\n-  uv_read_cb read_cb; \\\n-  uv_alloc_cb alloc_cb; \\\n   uv_connect_t *connect_req; \\\n   uv_shutdown_t *shutdown_req; \\\n   ev_io read_watcher; \\\n@@ -109,7 +99,8 @@ typedef int uv_file;\n   ngx_queue_t write_completed_queue; \\\n   int delayed_error; \\\n   uv_connection_cb connection_cb; \\\n-  int accepted_fd;\n+  int accepted_fd; \\\n+  int blocking;\n \n \n /* UV_TCP */\n@@ -183,6 +174,32 @@ typedef int uv_file;\n #define UV_WORK_PRIVATE_FIELDS \\\n   eio_req* eio;\n \n-#define UV_TTY_PRIVATE_FIELDS /* empty */\n+#define UV_TTY_PRIVATE_FIELDS \\\n+  struct termios orig_termios; \\\n+  int mode;\n+\n+/* UV_FS_EVENT_PRIVATE_FIELDS */\n+#if defined(__linux__)\n+\n+#define UV_FS_EVENT_PRIVATE_FIELDS \\\n+  ev_io read_watcher; \\\n+  uv_fs_event_cb cb; \\\n+\n+#elif (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED >= 1060) \\\n+  || defined(__FreeBSD__) \\\n+  || defined(__OpenBSD__) \\\n+  || defined(__NetBSD__)\n+\n+#define UV_FS_EVENT_PRIVATE_FIELDS \\\n+  ev_io event_watcher; \\\n+  uv_fs_event_cb cb; \\\n+  int fflags; \\\n+\n+#else\n+\n+/* Stub for platforms where the file watcher isn't implemented yet. */\n+#define UV_FS_EVENT_PRIVATE_FIELDS\n+\n+#endif\n \n #endif /* UV_UNIX_H */"}, {"sha": "ed132d3ad4f6c22f4fb3808ca78d8e8bbd28b96f", "filename": "src/rt/libuv/include/uv-private/uv-win.h", "status": "modified", "additions": 153, "deletions": 17, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-win.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-win.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-win.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -34,6 +34,98 @@\n \n #define MAX_PIPENAME_LEN 256\n \n+/*\n+ * Guids and typedefs for winsock extension functions\n+ * Mingw32 doesn't have these :-(\n+ */\n+#ifndef WSAID_ACCEPTEX\n+# define WSAID_ACCEPTEX                                        \\\n+         {0xb5367df1, 0xcbac, 0x11cf,                          \\\n+         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}\n+\n+# define WSAID_CONNECTEX                                       \\\n+         {0x25a207b9, 0xddf3, 0x4660,                          \\\n+         {0x8e, 0xe9, 0x76, 0xe5, 0x8c, 0x74, 0x06, 0x3e}}\n+\n+# define WSAID_GETACCEPTEXSOCKADDRS                            \\\n+         {0xb5367df2, 0xcbac, 0x11cf,                          \\\n+         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}\n+\n+# define WSAID_DISCONNECTEX                                    \\\n+         {0x7fda2e11, 0x8630, 0x436f,                          \\\n+         {0xa0, 0x31, 0xf5, 0x36, 0xa6, 0xee, 0xc1, 0x57}}\n+\n+# define WSAID_TRANSMITFILE                                    \\\n+         {0xb5367df0, 0xcbac, 0x11cf,                          \\\n+         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}\n+\n+  typedef BOOL PASCAL (*LPFN_ACCEPTEX)\n+                      (SOCKET sListenSocket,\n+                       SOCKET sAcceptSocket,\n+                       PVOID lpOutputBuffer,\n+                       DWORD dwReceiveDataLength,\n+                       DWORD dwLocalAddressLength,\n+                       DWORD dwRemoteAddressLength,\n+                       LPDWORD lpdwBytesReceived,\n+                       LPOVERLAPPED lpOverlapped);\n+\n+  typedef BOOL PASCAL (*LPFN_CONNECTEX)\n+                      (SOCKET s,\n+                       const struct sockaddr* name,\n+                       int namelen,\n+                       PVOID lpSendBuffer,\n+                       DWORD dwSendDataLength,\n+                       LPDWORD lpdwBytesSent,\n+                       LPOVERLAPPED lpOverlapped);\n+\n+  typedef void PASCAL (*LPFN_GETACCEPTEXSOCKADDRS)\n+                      (PVOID lpOutputBuffer,\n+                       DWORD dwReceiveDataLength,\n+                       DWORD dwLocalAddressLength,\n+                       DWORD dwRemoteAddressLength,\n+                       LPSOCKADDR* LocalSockaddr,\n+                       LPINT LocalSockaddrLength,\n+                       LPSOCKADDR* RemoteSockaddr,\n+                       LPINT RemoteSockaddrLength);\n+\n+  typedef BOOL PASCAL (*LPFN_DISCONNECTEX)\n+                      (SOCKET hSocket,\n+                       LPOVERLAPPED lpOverlapped,\n+                       DWORD dwFlags,\n+                       DWORD reserved);\n+\n+  typedef BOOL PASCAL (*LPFN_TRANSMITFILE)\n+                      (SOCKET hSocket,\n+                       HANDLE hFile,\n+                       DWORD nNumberOfBytesToWrite,\n+                       DWORD nNumberOfBytesPerSend,\n+                       LPOVERLAPPED lpOverlapped,\n+                       LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,\n+                       DWORD dwFlags);\n+#endif\n+\n+typedef int (WSAAPI* LPFN_WSARECV)\n+            (SOCKET socket,\n+             LPWSABUF buffers,\n+             DWORD buffer_count,\n+             LPDWORD bytes,\n+             LPDWORD flags,\n+             LPWSAOVERLAPPED overlapped,\n+             LPWSAOVERLAPPED_COMPLETION_ROUTINE\n+             completion_routine);\n+\n+typedef int (WSAAPI* LPFN_WSARECVFROM)\n+            (SOCKET socket,\n+             LPWSABUF buffers,\n+             DWORD buffer_count,\n+             LPDWORD bytes,\n+             LPDWORD flags,\n+             struct sockaddr* addr,\n+             LPINT addr_len,\n+             LPWSAOVERLAPPED overlapped,\n+             LPWSAOVERLAPPED_COMPLETION_ROUTINE completion_routine);\n+\n+\n /**\n  * It should be possible to cast uv_buf_t[] to WSABUF[]\n  * see http://msdn.microsoft.com/en-us/library/ms741542(v=vs.85).aspx\n@@ -75,9 +167,7 @@ RB_HEAD(uv_timer_tree_s, uv_timer_s);\n   uv_idle_t* next_idle_handle;                                                \\\n   ares_channel ares_chan;                                                     \\\n   int ares_active_sockets;                                                    \\\n-  uv_timer_t ares_polling_timer;                                              \\\n-  /* Last error code */                                                       \\\n-  uv_err_t last_error;\n+  uv_timer_t ares_polling_timer;\n \n #define UV_REQ_TYPE_PRIVATE               \\\n   /* TODO: remove the req suffix */       \\\n@@ -100,7 +190,10 @@ RB_HEAD(uv_timer_tree_s, uv_timer_s);\n   struct uv_req_s* next_req;\n \n #define UV_WRITE_PRIVATE_FIELDS           \\\n-  /* empty */\n+  int ipc_header;                         \\\n+  uv_buf_t write_buffer;                  \\\n+  HANDLE event_handle;                    \\\n+  HANDLE wait_handle;\n \n #define UV_CONNECT_PRIVATE_FIELDS         \\\n   /* empty */\n@@ -117,12 +210,21 @@ RB_HEAD(uv_timer_tree_s, uv_timer_s);\n     HANDLE pipeHandle;                    \\\n     struct uv_pipe_accept_s* next_pending; \\\n   } uv_pipe_accept_t;                     \\\n+                                          \\\n   typedef struct uv_tcp_accept_s {        \\\n     UV_REQ_FIELDS                         \\\n     SOCKET accept_socket;                 \\\n     char accept_buffer[sizeof(struct sockaddr_storage) * 2 + 32]; \\\n+    HANDLE event_handle;                  \\\n+    HANDLE wait_handle;                   \\\n     struct uv_tcp_accept_s* next_pending; \\\n-  } uv_tcp_accept_t;\n+  } uv_tcp_accept_t;                      \\\n+                                          \\\n+  typedef struct uv_read_s {              \\\n+    UV_REQ_FIELDS                         \\\n+    HANDLE event_handle;                  \\\n+    HANDLE wait_handle;                   \\\n+  } uv_read_t;\n \n #define uv_stream_connection_fields       \\\n   unsigned int write_reqs_pending;        \\\n@@ -133,24 +235,24 @@ RB_HEAD(uv_timer_tree_s, uv_timer_s);\n \n #define UV_STREAM_PRIVATE_FIELDS          \\\n   unsigned int reqs_pending;              \\\n-  uv_alloc_cb alloc_cb;                   \\\n-  uv_read_cb read_cb;                     \\\n-  uv_req_t read_req;                      \\\n+  uv_read_t read_req;                     \\\n   union {                                 \\\n     struct { uv_stream_connection_fields };  \\\n     struct { uv_stream_server_fields     };  \\\n   };\n \n #define uv_tcp_server_fields              \\\n   uv_tcp_accept_t* accept_reqs;           \\\n-  uv_tcp_accept_t* pending_accepts;\n+  uv_tcp_accept_t* pending_accepts;       \\\n+  LPFN_ACCEPTEX func_acceptex;\n \n #define uv_tcp_connection_fields          \\\n-  uv_buf_t read_buffer;\n+  uv_buf_t read_buffer;                   \\\n+  LPFN_CONNECTEX func_connectex;\n \n #define UV_TCP_PRIVATE_FIELDS             \\\n   SOCKET socket;                          \\\n-  uv_err_t bind_error;                    \\\n+  int bind_error;                         \\\n   union {                                 \\\n     struct { uv_tcp_server_fields };      \\\n     struct { uv_tcp_connection_fields };  \\\n@@ -164,14 +266,21 @@ RB_HEAD(uv_timer_tree_s, uv_timer_s);\n   struct sockaddr_storage recv_from;      \\\n   int recv_from_len;                      \\\n   uv_udp_recv_cb recv_cb;                 \\\n-  uv_alloc_cb alloc_cb;\n+  uv_alloc_cb alloc_cb;                   \\\n+  LPFN_WSARECV func_wsarecv;              \\\n+  LPFN_WSARECVFROM func_wsarecvfrom;\n \n #define uv_pipe_server_fields             \\\n-    uv_pipe_accept_t accept_reqs[4];      \\\n-    uv_pipe_accept_t* pending_accepts;\n+  uv_pipe_accept_t accept_reqs[4];        \\\n+  uv_pipe_accept_t* pending_accepts;\n \n #define uv_pipe_connection_fields         \\\n-  uv_timer_t* eof_timer;\n+  uv_timer_t* eof_timer;                  \\\n+  uv_write_t ipc_header_write_req;        \\\n+  int ipc_pid;                            \\\n+  uint64_t remaining_ipc_rawdata_bytes;   \\\n+  WSAPROTOCOL_INFOW* pending_socket_info; \\\n+  uv_write_t* non_overlapped_writes_tail;\n \n #define UV_PIPE_PRIVATE_FIELDS            \\\n   HANDLE handle;                          \\\n@@ -181,6 +290,33 @@ RB_HEAD(uv_timer_tree_s, uv_timer_s);\n     struct { uv_pipe_connection_fields }; \\\n   };\n \n+/* TODO: put the parser states in an union - TTY handles are always */\n+/* half-duplex so read-state can safely overlap write-state. */\n+#define UV_TTY_PRIVATE_FIELDS             \\\n+  HANDLE handle;                          \\\n+  HANDLE read_line_handle;                \\\n+  uv_buf_t read_line_buffer;              \\\n+  HANDLE read_raw_wait;                   \\\n+  DWORD original_console_mode;            \\\n+  /* Fields used for translating win */   \\\n+  /* keystrokes into vt100 characters */  \\\n+  char last_key[8];                       \\\n+  unsigned char last_key_offset;          \\\n+  unsigned char last_key_len;             \\\n+  INPUT_RECORD last_input_record;         \\\n+  WCHAR last_utf16_high_surrogate;        \\\n+  /* utf8-to-utf16 conversion state */    \\\n+  unsigned char utf8_bytes_left;          \\\n+  unsigned int utf8_codepoint;            \\\n+  /* eol conversion state */              \\\n+  unsigned char previous_eol;             \\\n+  /* ansi parser state */                 \\\n+  unsigned char ansi_parser_state;        \\\n+  unsigned char ansi_csi_argc;            \\\n+  unsigned short ansi_csi_argv[4];        \\\n+  COORD saved_position;                   \\\n+  WORD saved_attributes;\n+\n #define UV_TIMER_PRIVATE_FIELDS           \\\n   RB_ENTRY(uv_timer_s) tree_entry;        \\\n   int64_t due;                            \\\n@@ -244,6 +380,7 @@ RB_HEAD(uv_timer_tree_s, uv_timer_s);\n   HANDLE close_handle;\n \n #define UV_FS_PRIVATE_FIELDS              \\\n+  wchar_t* pathw;                         \\\n   int flags;                              \\\n   int last_error;                         \\\n   struct _stati64 stat;                   \\\n@@ -270,11 +407,10 @@ RB_HEAD(uv_timer_tree_s, uv_timer_s);\n   int req_pending;                        \\\n   uv_fs_event_cb cb;                      \\\n   wchar_t* filew;                         \\\n+  wchar_t* short_filew;                   \\\n   int is_path_dir;                        \\\n   char* buffer;\n \n-#define UV_TTY_PRIVATE_FIELDS /* empty */\n-\n int uv_utf16_to_utf8(const wchar_t* utf16Buffer, size_t utf16Size,\n     char* utf8Buffer, size_t utf8Size);\n int uv_utf8_to_utf16(const char* utf8Buffer, wchar_t* utf16Buffer,"}, {"sha": "7bee299185abe700d895ea123b3d44f7e8e4a27b", "filename": "src/rt/libuv/include/uv.h", "status": "modified", "additions": 179, "deletions": 99, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Finclude%2Fuv.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Finclude%2Fuv.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -41,6 +41,98 @@ extern \"C\" {\n typedef intptr_t ssize_t;\n #endif\n \n+#if defined(__unix__) || defined(__POSIX__) || defined(__APPLE__)\n+# include \"uv-private/uv-unix.h\"\n+#else\n+# include \"uv-private/uv-win.h\"\n+#endif\n+\n+/* Expand this list if necessary. */\n+typedef enum {\n+  UV_UNKNOWN = -1,\n+  UV_OK = 0,\n+  UV_EOF,\n+  UV_EACCESS,\n+  UV_EAGAIN,\n+  UV_EADDRINUSE,\n+  UV_EADDRNOTAVAIL,\n+  UV_EAFNOSUPPORT,\n+  UV_EALREADY,\n+  UV_EBADF,\n+  UV_EBUSY,\n+  UV_ECONNABORTED,\n+  UV_ECONNREFUSED,\n+  UV_ECONNRESET,\n+  UV_EDESTADDRREQ,\n+  UV_EFAULT,\n+  UV_EHOSTUNREACH,\n+  UV_EINTR,\n+  UV_EINVAL,\n+  UV_EISCONN,\n+  UV_EMFILE,\n+  UV_EMSGSIZE,\n+  UV_ENETDOWN,\n+  UV_ENETUNREACH,\n+  UV_ENFILE,\n+  UV_ENOBUFS,\n+  UV_ENOMEM,\n+  UV_ENOTDIR,\n+  UV_ENONET,\n+  UV_ENOPROTOOPT,\n+  UV_ENOTCONN,\n+  UV_ENOTSOCK,\n+  UV_ENOTSUP,\n+  UV_ENOENT,\n+  UV_ENOSYS,\n+  UV_EPIPE,\n+  UV_EPROTO,\n+  UV_EPROTONOSUPPORT,\n+  UV_EPROTOTYPE,\n+  UV_ETIMEDOUT,\n+  UV_ECHARSET,\n+  UV_EAIFAMNOSUPPORT,\n+  UV_EAINONAME,\n+  UV_EAISERVICE,\n+  UV_EAISOCKTYPE,\n+  UV_ESHUTDOWN,\n+  UV_EEXIST\n+} uv_err_code;\n+\n+typedef enum {\n+  UV_UNKNOWN_HANDLE = 0,\n+  UV_TCP,\n+  UV_UDP,\n+  UV_NAMED_PIPE,\n+  UV_TTY,\n+  UV_FILE,\n+  UV_TIMER,\n+  UV_PREPARE,\n+  UV_CHECK,\n+  UV_IDLE,\n+  UV_ASYNC,\n+  UV_ARES_TASK,\n+  UV_ARES_EVENT,\n+  UV_PROCESS,\n+  UV_FS_EVENT\n+} uv_handle_type;\n+\n+typedef enum {\n+  UV_UNKNOWN_REQ = 0,\n+  UV_CONNECT,\n+  UV_ACCEPT,\n+  UV_READ,\n+  UV_WRITE,\n+  UV_SHUTDOWN,\n+  UV_WAKEUP,\n+  UV_UDP_SEND,\n+  UV_FS,\n+  UV_WORK,\n+  UV_GETADDRINFO,\n+  UV_REQ_TYPE_PRIVATE\n+} uv_req_type;\n+\n+\n+\n typedef struct uv_loop_s uv_loop_t;\n typedef struct uv_ares_task_s uv_ares_task_t;\n typedef struct uv_err_s uv_err_t;\n@@ -69,12 +161,6 @@ typedef struct uv_fs_s uv_fs_t;\n typedef struct uv_fs_event_s uv_fs_event_t;\n typedef struct uv_work_s uv_work_t;\n \n-#if defined(__unix__) || defined(__POSIX__) || defined(__APPLE__)\n-# include \"uv-private/uv-unix.h\"\n-#else\n-# include \"uv-private/uv-win.h\"\n-#endif\n-\n \n /*\n  * This function must be called before any other functions in libuv.\n@@ -121,6 +207,13 @@ int64_t uv_now(uv_loop_t*);\n  */\n typedef uv_buf_t (*uv_alloc_cb)(uv_handle_t* handle, size_t suggested_size);\n typedef void (*uv_read_cb)(uv_stream_t* stream, ssize_t nread, uv_buf_t buf);\n+/*\n+ * Just like the uv_read_cb except that if the pending parameter is true\n+ * then you can use uv_accept() to pull the new handle into the process.\n+ * If no handle is pending then pending will be UV_UNKNOWN_HANDLE.\n+ */\n+typedef void (*uv_read2_cb)(uv_pipe_t* pipe, ssize_t nread, uv_buf_t buf,\n+    uv_handle_type pending);\n typedef void (*uv_write_cb)(uv_write_t* req, int status);\n typedef void (*uv_connect_cb)(uv_connect_t* req, int status);\n typedef void (*uv_shutdown_cb)(uv_shutdown_t* req, int status);\n@@ -148,88 +241,10 @@ typedef void (*uv_after_work_cb)(uv_work_t* req);\n typedef void (*uv_fs_event_cb)(uv_fs_event_t* handle, const char* filename,\n     int events, int status);\n \n-\n-/* Expand this list if necessary. */\n-typedef enum {\n-  UV_UNKNOWN = -1,\n-  UV_OK = 0,\n-  UV_EOF,\n-  UV_EACCESS,\n-  UV_EAGAIN,\n-  UV_EADDRINUSE,\n-  UV_EADDRNOTAVAIL,\n-  UV_EAFNOSUPPORT,\n-  UV_EALREADY,\n-  UV_EBADF,\n-  UV_EBUSY,\n-  UV_ECONNABORTED,\n-  UV_ECONNREFUSED,\n-  UV_ECONNRESET,\n-  UV_EDESTADDRREQ,\n-  UV_EFAULT,\n-  UV_EHOSTUNREACH,\n-  UV_EINTR,\n-  UV_EINVAL,\n-  UV_EISCONN,\n-  UV_EMFILE,\n-  UV_EMSGSIZE,\n-  UV_ENETDOWN,\n-  UV_ENETUNREACH,\n-  UV_ENFILE,\n-  UV_ENOBUFS,\n-  UV_ENOMEM,\n-  UV_ENONET,\n-  UV_ENOPROTOOPT,\n-  UV_ENOTCONN,\n-  UV_ENOTSOCK,\n-  UV_ENOTSUP,\n-  UV_ENOENT,\n-  UV_EPIPE,\n-  UV_EPROTO,\n-  UV_EPROTONOSUPPORT,\n-  UV_EPROTOTYPE,\n-  UV_ETIMEDOUT,\n-  UV_ECHARSET,\n-  UV_EAIFAMNOSUPPORT,\n-  UV_EAINONAME,\n-  UV_EAISERVICE,\n-  UV_EAISOCKTYPE,\n-  UV_ESHUTDOWN,\n-  UV_EEXIST\n-} uv_err_code;\n-\n typedef enum {\n-  UV_UNKNOWN_HANDLE = 0,\n-  UV_TCP,\n-  UV_UDP,\n-  UV_NAMED_PIPE,\n-  UV_TTY,\n-  UV_FILE,\n-  UV_TIMER,\n-  UV_PREPARE,\n-  UV_CHECK,\n-  UV_IDLE,\n-  UV_ASYNC,\n-  UV_ARES_TASK,\n-  UV_ARES_EVENT,\n-  UV_PROCESS,\n-  UV_FS_EVENT\n-} uv_handle_type;\n-\n-typedef enum {\n-  UV_UNKNOWN_REQ = 0,\n-  UV_CONNECT,\n-  UV_ACCEPT,\n-  UV_READ,\n-  UV_WRITE,\n-  UV_SHUTDOWN,\n-  UV_WAKEUP,\n-  UV_UDP_SEND,\n-  UV_FS,\n-  UV_WORK,\n-  UV_GETADDRINFO,\n-  UV_REQ_TYPE_PRIVATE\n-} uv_req_type;\n+  UV_LEAVE_GROUP = 0,\n+  UV_JOIN_GROUP\n+} uv_membership;\n \n \n struct uv_err_s {\n@@ -330,6 +345,9 @@ uv_buf_t uv_buf_init(char* base, size_t len);\n #define UV_STREAM_FIELDS \\\n   /* number of bytes queued for writing */ \\\n   size_t write_queue_size; \\\n+  uv_alloc_cb alloc_cb; \\\n+  uv_read_cb read_cb; \\\n+  uv_read2_cb read2_cb; \\\n   /* private */ \\\n   UV_STREAM_PRIVATE_FIELDS\n \n@@ -338,8 +356,8 @@ uv_buf_t uv_buf_init(char* base, size_t len);\n  *\n  * uv_stream is an abstract class.\n  *\n- * uv_stream_t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t\n- * and soon uv_file_t.\n+ * uv_stream_t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t, and\n+ * soon uv_file_t.\n  */\n struct uv_stream_s {\n   UV_HANDLE_FIELDS\n@@ -375,13 +393,12 @@ int uv_read_start(uv_stream_t*, uv_alloc_cb alloc_cb, uv_read_cb read_cb);\n \n int uv_read_stop(uv_stream_t*);\n \n-typedef enum {\n-  UV_STDIN = 0,\n-  UV_STDOUT,\n-  UV_STDERR\n-} uv_std_type;\n+/*\n+ * Extended read methods for receiving handles over a pipe. The pipe must be\n+ * initialized with ipc == 1.\n+ */\n+int uv_read2_start(uv_stream_t*, uv_alloc_cb alloc_cb, uv_read2_cb read_cb);\n \n-uv_stream_t* uv_std_handle(uv_loop_t*, uv_std_type type);\n \n /*\n  * Write data to stream. Buffers are written in order. Example:\n@@ -404,10 +421,14 @@ uv_stream_t* uv_std_handle(uv_loop_t*, uv_std_type type);\n int uv_write(uv_write_t* req, uv_stream_t* handle, uv_buf_t bufs[], int bufcnt,\n     uv_write_cb cb);\n \n+int uv_write2(uv_write_t* req, uv_stream_t* handle, uv_buf_t bufs[], int bufcnt,\n+    uv_stream_t* send_handle, uv_write_cb cb);\n+\n /* uv_write_t is a subclass of uv_req_t */\n struct uv_write_s {\n   UV_REQ_FIELDS\n   uv_write_cb cb;\n+  uv_stream_t* send_handle;\n   uv_stream_t* handle;\n   UV_WRITE_PRIVATE_FIELDS\n };\n@@ -427,6 +448,15 @@ struct uv_tcp_s {\n \n int uv_tcp_init(uv_loop_t*, uv_tcp_t* handle);\n \n+/* Enable/disable Nagle's algorithm. */\n+int uv_tcp_nodelay(uv_tcp_t* handle, int enable);\n+\n+/* Enable/disable TCP keep-alive.\n+ *\n+ * `ms` is the initial delay in seconds, ignored when `enable` is zero.\n+ */\n+int uv_tcp_keepalive(uv_tcp_t* handle, int enable, unsigned int delay);\n+\n int uv_tcp_bind(uv_tcp_t* handle, struct sockaddr_in);\n int uv_tcp_bind6(uv_tcp_t* handle, struct sockaddr_in6);\n int uv_tcp_getsockname(uv_tcp_t* handle, struct sockaddr* name, int* namelen);\n@@ -536,6 +566,21 @@ int uv_udp_bind(uv_udp_t* handle, struct sockaddr_in addr, unsigned flags);\n int uv_udp_bind6(uv_udp_t* handle, struct sockaddr_in6 addr, unsigned flags);\n int uv_udp_getsockname(uv_udp_t* handle, struct sockaddr* name, int* namelen);\n \n+/*\n+ * Set membership for a multicast address\n+ *\n+ * Arguments:\n+ *  handle              UDP handle. Should have been initialized with `uv_udp_init`.\n+ *  multicast_addr      multicast address to set membership for\n+ *  interface_addr      interface address\n+ *  membership          Should be UV_JOIN_GROUP or UV_LEAVE_GROUP\n+ *\n+ * Returns:\n+ *  0 on success, -1 on error.\n+ */\n+int uv_udp_set_membership(uv_udp_t* handle, const char* multicast_addr,\n+  const char* interface_addr, uv_membership membership);\n+\n /*\n  * Send data. If the socket has not previously been bound with `uv_udp_bind`\n  * or `uv_udp_bind6`, it is bound to 0.0.0.0 (the \"all interfaces\" address)\n@@ -574,7 +619,7 @@ int uv_udp_send6(uv_udp_send_t* req, uv_udp_t* handle, uv_buf_t bufs[],\n     int bufcnt, struct sockaddr_in6 addr, uv_udp_send_cb send_cb);\n \n /*\n- * Send data. If the socket has not previously been bound with `uv_udp_bind`\n+ * Receive data. If the socket has not previously been bound with `uv_udp_bind`\n  * or `uv_udp_bind6`, it is bound to 0.0.0.0 (the \"all interfaces\" address)\n  * and a random port number.\n  *\n@@ -612,13 +657,30 @@ struct uv_tty_s {\n   UV_TTY_PRIVATE_FIELDS\n };\n \n-int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_file fd);\n+/*\n+ * Initialize a new TTY stream with the given file descriptor. Usually the\n+ * file descriptor will be\n+ *   0 = stdin\n+ *   1 = stdout\n+ *   2 = stderr\n+ * The last argument, readable, specifies if you plan on calling\n+ * uv_read_start with this stream. stdin is readable, stdout is not.\n+ *\n+ * TTY streams which are not readable have blocking writes.\n+ */\n+int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_file fd, int readable);\n \n /*\n  * Set mode. 0 for normal, 1 for raw.\n  */\n int uv_tty_set_mode(uv_tty_t*, int mode);\n \n+/*\n+ * To be called when the program exits. Resets TTY settings to default\n+ * values for the next process to take over.\n+ */\n+void uv_tty_reset_mode();\n+\n /*\n  * Gets the current Window size. On success zero is returned.\n  */\n@@ -642,9 +704,14 @@ struct uv_pipe_s {\n   UV_HANDLE_FIELDS\n   UV_STREAM_FIELDS\n   UV_PIPE_PRIVATE_FIELDS\n+  int ipc; /* non-zero if this pipe is used for passing handles */\n };\n \n-int uv_pipe_init(uv_loop_t*, uv_pipe_t* handle);\n+/*\n+ * Initialize a pipe. The last argument is a boolean to indicate if\n+ * this pipe will be used for handle passing between processes.\n+ */\n+int uv_pipe_init(uv_loop_t*, uv_pipe_t* handle, int ipc);\n \n /*\n  * Opens an existing file descriptor or HANDLE as a pipe.\n@@ -807,6 +874,8 @@ struct uv_getaddrinfo_s {\n  *\n  * uv_freeaddrinfo() must be called after completion to free the addrinfo\n  * structure.\n+ *\n+ * On error NXDOMAIN the status code will be non-zero and UV_ENOENT returned.\n  */\n  int uv_getaddrinfo(uv_loop_t*,\n                     uv_getaddrinfo_t* handle,\n@@ -1003,7 +1072,7 @@ int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb);\n int uv_fs_link(uv_loop_t* loop, uv_fs_t* req, const char* path,\n     const char* new_path, uv_fs_cb cb);\n \n-/* \n+/*\n  * This flag can be used with uv_fs_symlink on Windows\n  * to specify whether path argument points to a directory.\n  */\n@@ -1038,6 +1107,13 @@ struct uv_fs_event_s {\n };\n \n \n+/*\n+ * Gets load avg\n+ * See: http://en.wikipedia.org/wiki/Load_(computing)\n+ * (Returns [0,0,0] for windows and cygwin)\n+ */\n+void uv_loadavg(double avg[3]);\n+\n /*\n * If filename is a directory then we will watch for all events in that\n * directory. If filename is a file - we will only get events from that\n@@ -1059,6 +1135,10 @@ int uv_ip6_name(struct sockaddr_in6* src, char* dst, size_t size);\n /* Gets the executable path */\n int uv_exepath(char* buffer, size_t* size);\n \n+/* Gets memory info in bytes */\n+uint64_t uv_get_free_memory(void);\n+uint64_t uv_get_total_memory(void);\n+\n /*\n  * Returns the current high-resolution real time. This is expressed in\n  * nanoseconds. It is relative to an arbitrary time in the past. It is not"}, {"sha": "73fe8c77104058d792346a2654080ee45406d2ab", "filename": "src/rt/libuv/src/ares/CHANGES", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2FCHANGES", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2FCHANGES", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FCHANGES?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -1,5 +1,25 @@\n   Changelog for the c-ares project\n \n+Version 1.7.5 (August 16, 2011)\n+\n+Fixed:\n+\n+ o detection of semicolon comments in resolv.conf\n+ o avoid using system's inet_net_pton affected by the WLB-2008080064 advisory\n+ o replacement ares_inet_net_pton affected by the WLB-2008080064 advisory\n+ o replacement ares_inet_ntop affected by potential out of bounds write\n+ o added install target to Makefile.msvc\n+ o only fall back to AF_INET searches when looking for AF_UNSPEC addresses\n+ o fixed ares_parse_*_reply memory leaks\n+ o Use correct sizeof in ares_getnameinfo()\n+ o IPv6-on-windows: find DNS servers correctly\n+ o man pages: docs for the c-ares utility programs\n+ o getservbyport replacement for Win CE\n+ o config_sortlist: (win32) missing else\n+ o advance_tcp_send_queue: avoid NULL ptr dereference\n+ o configure: fix a bashism\n+ o ares_expand_name: Fix encoded length for indirect root\n+\n Version 1.7.4 (December 9, 2010)\n \n Changed:"}, {"sha": "4ff8700cb89a107dd6ce65fbac5777c424cb1070", "filename": "src/rt/libuv/src/ares/README.msvc", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME.msvc", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME.msvc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME.msvc?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -40,6 +40,30 @@\n   library version it is using.\n \n \n+  How to install using MSVC from the command line\n+  -----------------------------------------------\n+\n+  In order to allow easy usage of c-ares libraries it may be convenient to\n+  install c-ares libraries and header files to a common subdirectory tree.\n+\n+  Once that c-ares libraries have been built using procedure described above,\n+  use same command prompt window to define environment variable INSTALL_DIR\n+  to designate the top subdirectory where installation of c-ares libraries and\n+  header files will be done.\n+\n+  > set INSTALL_DIR=c:\\c-ares\n+\n+  Afterwards, run following command to actually perform the installation:\n+\n+  > nmake -f Makefile.msvc install\n+\n+  Installation procedure will copy c-ares libraries to subdirectory 'lib' and\n+  c-ares header files to subdirectory 'include' below the INSTALL_DIR subdir.\n+\n+  When environment variable INSTALL_DIR is not defined, installation is done\n+  to c-ares source folder where Makefile.msvc file is located.\n+\n+\n   How to build using Visual Studio 6 IDE\n   --------------------------------------\n "}, {"sha": "06d7856bc74d15d73c1a7bd779ec9eaeaff4fbcd", "filename": "src/rt/libuv/src/ares/RELEASE-NOTES", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2FRELEASE-NOTES", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2FRELEASE-NOTES", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FRELEASE-NOTES?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -1,25 +1,26 @@\n-c-ares version 1.7.4\n-\n-Changed:\n-\n- o local-bind: Support binding to local interface/IPs, see\n-   ares_set_local_ip4, ares_set_local_ip6, ares_set_local_dev\n+c-ares version 1.7.5\n \n Fixed:\n \n- o memory leak in ares_getnameinfo\n- o add missing break that caused get_ares_servers to fail\n- o ares_parse_a_reply: fix CNAME response parsing\n- o init_by_options: don't copy an empty sortlist\n- o Replaced uint32_t with unsigned int to fix broken builds\n-   on a couple of platforms\n- o Fix lookup with HOSTALIASES set\n- o adig: fix NAPTR parsing\n- o compiler warning cleanups\n+ o detection of semicolon comments in resolv.conf\n+ o avoid using system's inet_net_pton affected by the WLB-2008080064 advisory\n+ o replacement ares_inet_net_pton affected by the WLB-2008080064 advisory\n+ o replacement ares_inet_ntop affected by potential out of bounds write\n+ o added install target to Makefile.msvc\n+ o only fall back to AF_INET searches when looking for AF_UNSPEC addresses\n+ o fixed ares_parse_*_reply memory leaks\n+ o Use correct sizeof in ares_getnameinfo()\n+ o IPv6-on-windows: find DNS servers correctly\n+ o man pages: docs for the c-ares utility programs\n+ o getservbyport replacement for Win CE\n+ o config_sortlist: (win32) missing else\n+ o advance_tcp_send_queue: avoid NULL ptr dereference\n+ o configure: fix a bashism\n+ o ares_expand_name: Fix encoded length for indirect root\n \n Thanks go to these friendly people for their efforts and contributions:\n \n- Andrew C. Morrow, Ben Greear, Ben Noordhuis, Daniel Stenberg,\n- Guenter Knauf, Mike Crowe, Patrik Thunstrom, Yang Tse\n+ Yang Tse, Jakub Hrozek, Gisle Vanem, Tom Hughes, David Stuart, Dima Tisnek,\n+ Peter Pentchev, Stefan Buhler\n \n Have fun!"}, {"sha": "e3eccd2f74d2e3591133985b81f02c4c7199df1d", "filename": "src/rt/libuv/src/ares/ares_expand_name.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_expand_name.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_expand_name.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_expand_name.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -87,7 +87,14 @@ int ares_expand_name(const unsigned char *encoded, const unsigned char *abuf,\n      * Since this function strips trailing dots though, it becomes \"\"\n      */\n     q[0] = '\\0';\n-    *enclen = 1;  /* the caller should move one byte to get past this */\n+\n+    /* indirect root label (like 0xc0 0x0c) is 2 bytes long (stupid, but\n+       valid) */\n+    if ((*encoded & INDIR_MASK) == INDIR_MASK)\n+      *enclen = 2;\n+    else\n+      *enclen = 1;  /* the caller should move one byte to get past this */\n+\n     return ARES_SUCCESS;\n   }\n "}, {"sha": "ac5eedb325390f77bba0a29559a837d8a8c86976", "filename": "src/rt/libuv/src/ares/ares_fds.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_fds.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_fds.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_fds.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -21,6 +21,7 @@\n #endif\n \n #include \"ares.h\"\n+#include \"ares_nowarn.h\"\n #include \"ares_private.h\"\n \n int ares_fds(ares_channel channel, fd_set *read_fds, fd_set *write_fds)"}, {"sha": "349d379af3a0609c259168b1d3cb1b62d8a4c65d", "filename": "src/rt/libuv/src/ares/ares_free_hostent.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_free_hostent.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_free_hostent.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_free_hostent.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -28,6 +28,9 @@ void ares_free_hostent(struct hostent *host)\n {\n   char **p;\n \n+  if (!host)\n+    return;\n+\n   free((char *)(host->h_name));\n   for (p = host->h_aliases; *p; p++)\n     free(*p);"}, {"sha": "1b2e85d2bee9c5ecf027e3b36b106a48ef605741", "filename": "src/rt/libuv/src/ares/ares_getenv.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getenv.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getenv.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getenv.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -0,0 +1,30 @@\n+\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+#include \"ares_getenv.h\"\n+\n+#ifndef HAVE_GETENV\n+\n+char *ares_getenv(const char *name)\n+{\n+#ifdef _WIN32_WCE\n+  return NULL;\n+#endif\n+}\n+\n+#endif"}, {"sha": "6da6cc5081a7be03c622ef4532f076fe1cc15443", "filename": "src/rt/libuv/src/ares/ares_getenv.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getenv.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getenv.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getenv.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -0,0 +1,26 @@\n+#ifndef HEADER_CARES_GETENV_H\n+#define HEADER_CARES_GETENV_H\n+\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#ifndef HAVE_GETENV\n+extern char *ares_getenv(const char *name);\n+#endif\n+\n+#endif /* HEADER_CARES_GETENV_H */"}, {"sha": "4b4c8a7dbde838040dca6d42f54fc827b33895a0", "filename": "src/rt/libuv/src/ares/ares_gethostbyaddr.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_gethostbyaddr.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_gethostbyaddr.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_gethostbyaddr.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -42,6 +42,7 @@\n \n #include \"ares.h\"\n #include \"inet_net_pton.h\"\n+#include \"ares_platform.h\"\n #include \"ares_private.h\"\n \n #ifdef WATT32\n@@ -186,7 +187,13 @@ static int file_lookup(struct ares_addr *addr, struct hostent **host)\n \n #ifdef WIN32\n   char PATH_HOSTS[MAX_PATH];\n-  if (IS_NT()) {\n+  win_platform platform;\n+\n+  PATH_HOSTS[0] = '\\0';\n+\n+  platform = ares__getplatform();\n+\n+  if (platform == WIN_NT) {\n     char tmp[MAX_PATH];\n     HKEY hkeyHosts;\n \n@@ -200,8 +207,10 @@ static int file_lookup(struct ares_addr *addr, struct hostent **host)\n       RegCloseKey(hkeyHosts);\n     }\n   }\n-  else\n+  else if (platform == WIN_9X)\n     GetWindowsDirectory(PATH_HOSTS, MAX_PATH);\n+  else\n+    return ARES_ENOTFOUND;\n \n   strcat(PATH_HOSTS, WIN_PATH_HOSTS);\n "}, {"sha": "ad89dc27bf810c57f0324da46d3da31c2bc04a44", "filename": "src/rt/libuv/src/ares/ares_gethostbyname.c", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_gethostbyname.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_gethostbyname.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_gethostbyname.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -48,6 +48,7 @@\n #include \"ares.h\"\n #include \"inet_net_pton.h\"\n #include \"bitncmp.h\"\n+#include \"ares_platform.h\"\n #include \"ares_private.h\"\n \n #ifdef WATT32\n@@ -193,11 +194,11 @@ static void host_callback(void *arg, int status, int timeouts,\n       else if (hquery->sent_family == AF_INET6)\n         {\n           status = ares_parse_aaaa_reply(abuf, alen, &host, NULL, NULL);\n-          if (status == ARES_ENODATA || status == ARES_EBADRESP) {\n+          if ((status == ARES_ENODATA || status == ARES_EBADRESP) &&\n+               hquery->want_family == AF_UNSPEC) {\n             /* The query returned something but either there were no AAAA\n                records (e.g. just CNAME) or the response was malformed.  Try\n-               looking up A instead.  We should possibly limit this\n-               attempt-next logic to AF_UNSPEC lookups only. */\n+               looking up A instead. */\n             hquery->sent_family = AF_INET;\n             ares_search(hquery->channel, hquery->name, C_IN, T_A,\n                         host_callback, hquery);\n@@ -209,11 +210,10 @@ static void host_callback(void *arg, int status, int timeouts,\n       end_hquery(hquery, status, host);\n     }\n   else if ((status == ARES_ENODATA || status == ARES_EBADRESP ||\n-            status == ARES_ETIMEOUT) && hquery->sent_family == AF_INET6)\n+            status == ARES_ETIMEOUT) && (hquery->sent_family == AF_INET6 &&\n+            hquery->want_family == AF_UNSPEC))\n     {\n-      /* The AAAA query yielded no useful result.  Now look up an A instead.\n-         We should possibly limit this attempt-next logic to AF_UNSPEC lookups\n-         only. */\n+      /* The AAAA query yielded no useful result.  Now look up an A instead. */\n       hquery->sent_family = AF_INET;\n       ares_search(hquery->channel, hquery->name, C_IN, T_A, host_callback,\n                   hquery);\n@@ -344,7 +344,13 @@ static int file_lookup(const char *name, int family, struct hostent **host)\n \n #ifdef WIN32\n   char PATH_HOSTS[MAX_PATH];\n-  if (IS_NT()) {\n+  win_platform platform;\n+\n+  PATH_HOSTS[0] = '\\0';\n+\n+  platform = ares__getplatform();\n+\n+  if (platform == WIN_NT) {\n     char tmp[MAX_PATH];\n     HKEY hkeyHosts;\n \n@@ -358,8 +364,10 @@ static int file_lookup(const char *name, int family, struct hostent **host)\n       RegCloseKey(hkeyHosts);\n     }\n   }\n-  else\n+  else if (platform == WIN_9X)\n     GetWindowsDirectory(PATH_HOSTS, MAX_PATH);\n+  else\n+    return ARES_ENOTFOUND;\n \n   strcat(PATH_HOSTS, WIN_PATH_HOSTS);\n "}, {"sha": "82e261dae41a0a3c7fef4cebba65386a3ca2d4a2", "filename": "src/rt/libuv/src/ares/ares_getnameinfo.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getnameinfo.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getnameinfo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getnameinfo.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -58,6 +58,7 @@\n #include \"ares.h\"\n #include \"ares_ipv6.h\"\n #include \"inet_ntop.h\"\n+#include \"ares_nowarn.h\"\n #include \"ares_private.h\"\n \n struct nameinfo_query {\n@@ -187,15 +188,15 @@ void ares_getnameinfo(ares_channel channel, const struct sockaddr *sa,\n         if (sa->sa_family == AF_INET)\n           {\n             niquery->family = AF_INET;\n-            memcpy(&niquery->addr.addr4, addr, sizeof(addr));\n+            memcpy(&niquery->addr.addr4, addr, sizeof(struct in_addr));\n             ares_gethostbyaddr(channel, &addr->sin_addr,\n                                sizeof(struct in_addr), AF_INET,\n                                nameinfo_callback, niquery);\n           }\n         else\n           {\n             niquery->family = AF_INET6;\n-            memcpy(&niquery->addr.addr6, addr6, sizeof(addr6));\n+            memcpy(&niquery->addr.addr6, addr6, sizeof(struct ares_in6_addr));\n             ares_gethostbyaddr(channel, &addr6->sin6_addr,\n                                sizeof(struct ares_in6_addr), AF_INET6,\n                                nameinfo_callback, niquery);"}, {"sha": "52bb4d6c8941ed163197fbe80c1c699c9ef864dd", "filename": "src/rt/libuv/src/ares/ares_init.c", "status": "modified", "additions": 238, "deletions": 94, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_init.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_init.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_init.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -1,6 +1,6 @@\n \n /* Copyright 1998 by the Massachusetts Institute of Technology.\n- * Copyright (C) 2007-2010 by Daniel Stenberg\n+ * Copyright (C) 2007-2011 by Daniel Stenberg\n  *\n  * Permission to use, copy, modify, and distribute this\n  * software and its documentation for any purpose and without\n@@ -17,10 +17,6 @@\n \n #include \"ares_setup.h\"\n \n-#ifdef USE_WINSOCK\n-#include <iphlpapi.h>\n-#endif\n-\n #ifdef HAVE_SYS_PARAM_H\n #include <sys/param.h>\n #endif\n@@ -63,17 +59,19 @@\n #include <string.h>\n #include <ctype.h>\n #include <time.h>\n-#include <errno.h>\n+\n+#ifdef ANDROID\n+#include <sys/system_properties.h>\n+#endif\n+\n #include \"ares.h\"\n #include \"inet_net_pton.h\"\n #include \"ares_library_init.h\"\n #include \"ares_nowarn.h\"\n+#include \"ares_platform.h\"\n+#include \"inet_ntop.h\"\n #include \"ares_private.h\"\n \n-#ifdef ANDROID\n-#include <sys/system_properties.h>\n-#endif\n-\n #ifdef WATT32\n #undef WIN32  /* Redefined in MingW/MSVC headers */\n #endif\n@@ -102,7 +100,7 @@ static int config_lookup(ares_channel channel, const char *str,\n                          const char *bindch, const char *filech);\n static int config_sortlist(struct apattern **sortlist, int *nsort,\n                            const char *str);\n-static char *try_config(char *s, const char *opt);\n+static char *try_config(char *s, const char *opt, char scc);\n #endif\n \n #define ARES_CONFIG_CHECK(x) (x->lookups && x->nsort > -1 && \\\n@@ -363,7 +361,7 @@ int ares_save_options(ares_channel channel, struct ares_options *options,\n         ipv4_nservers++;\n     }\n     if (ipv4_nservers) {\n-      options->servers = malloc(ipv4_nservers * sizeof(struct server_state));\n+      options->servers = malloc(ipv4_nservers * sizeof(struct in_addr));\n       if (!options->servers)\n         return ARES_ENOMEM;\n       for (i = j = 0; i < channel->nservers; i++)\n@@ -595,73 +593,198 @@ static int get_res_interfaces_nt(HKEY hKey, const char *subkey, char **obuf)\n   return 0;\n }\n \n+/**\n+ * The desired output for this method is that we set \"ret_buf\" to\n+ * something like:\n+ *\n+ * 192.168.0.1,dns01.my.domain,fe80::200:f8ff:fe21:67cf\n+ *\n+ * The only ordering requirement is that primary servers are listed\n+ * before secondary. There is no requirement that IPv4 addresses should\n+ * necessarily be before IPv6.\n+ *\n+ * Note that ret_size should ideally be big enough to hold around\n+ * 2-3 IPv4 and 2-3 IPv6 addresses.\n+ *\n+ * Finally, we need to return the total number of DNS servers located.\n+ */\n static int get_iphlpapi_dns_info (char *ret_buf, size_t ret_size)\n {\n-  FIXED_INFO    *fi, *newfi;\n-  DWORD          size = sizeof (*fi);\n-  IP_ADDR_STRING *ipAddr;\n-  int            i, count = 0;\n-  int            debug  = 0;\n-  size_t         ip_size = sizeof(\"255.255.255.255,\")-1;\n-  size_t         left = ret_size;\n-  char          *ret = ret_buf;\n-  HRESULT        res;\n-\n-  fi = malloc(size);\n-  if (!fi)\n-     return 0;\n-\n-  res = (*ares_fpGetNetworkParams) (fi, &size);\n-  if ((res != ERROR_BUFFER_OVERFLOW) && (res != ERROR_SUCCESS))\n-     goto quit;\n-\n-  newfi = realloc(fi, size);\n-  if (!newfi)\n-     goto quit;\n-\n-  fi = newfi;\n-  res = (*ares_fpGetNetworkParams) (fi, &size);\n-  if (res != ERROR_SUCCESS)\n-     goto quit;\n-\n-  if (debug)\n+  const size_t  ipv4_size = INET_ADDRSTRLEN  + 1;  /* +1 for ',' at end */\n+  const size_t  ipv6_size = INET6_ADDRSTRLEN + 12; /* +12 for \"%0123456789,\" at end */\n+  size_t        left = ret_size;\n+  char         *ret  = ret_buf;\n+  int           count = 0;\n+\n+  /* Use the GetAdaptersAddresses method if it's available, otherwise\n+     fall back to GetNetworkParams. */\n+  if (ares_fpGetAdaptersAddresses != ZERO_NULL)\n   {\n-    printf (\"Host Name: %s\\n\", fi->HostName);\n-    printf (\"Domain Name: %s\\n\", fi->DomainName);\n-    printf (\"DNS Servers:\\n\"\n-            \"    %s (primary)\\n\", fi->DnsServerList.IpAddress.String);\n+    const ULONG            working_buf_size = 15000;\n+    IP_ADAPTER_ADDRESSES   *pFirstEntry = NULL;\n+    IP_ADAPTER_ADDRESSES   *pEntry = NULL;\n+    ULONG                  bufSize = 0;\n+    ULONG                  result = 0;\n+\n+    /* According to MSDN, the recommended way to do this is to use a temporary\n+       buffer of 15K, to \"dramatically reduce the chance that the GetAdaptersAddresses\n+       method returns ERROR_BUFFER_OVERFLOW\" */\n+    pFirstEntry  = ( IP_ADAPTER_ADDRESSES * ) malloc( working_buf_size );\n+    bufSize = working_buf_size;\n+    if( !pFirstEntry )\n+      return 0;\n+\n+    /* Call the method one time */\n+    result = ( *ares_fpGetAdaptersAddresses )( AF_UNSPEC, 0, 0, pFirstEntry, &bufSize );\n+    if( result == ERROR_BUFFER_OVERFLOW )\n+    {\n+      /* Reallocate, bufSize should now be set to the required size */\n+      pFirstEntry = ( IP_ADAPTER_ADDRESSES * ) realloc( pFirstEntry, bufSize );\n+      if( !pFirstEntry )\n+        return 0;\n+\n+      /* Call the method a second time */\n+      result = ( *ares_fpGetAdaptersAddresses )( AF_UNSPEC, 0, 0, pFirstEntry, &bufSize );\n+      if( result == ERROR_BUFFER_OVERFLOW )\n+      {\n+        /* Reallocate, bufSize should now be set to the required size */\n+        pFirstEntry = ( IP_ADAPTER_ADDRESSES * ) realloc( pFirstEntry, bufSize );\n+        if( !pFirstEntry )\n+          return 0;\n+\n+        /* Call the method a third time. The maximum number of times we're going to do\n+           this is 3. Three shall be the number thou shalt count, and the number of the\n+           counting shall be three.  Five is right out. */\n+        result = ( *ares_fpGetAdaptersAddresses )( AF_UNSPEC, 0, 0, pFirstEntry, &bufSize );\n+      }\n+    }\n+\n+    /* Check the current result for failure */\n+    if( result != ERROR_SUCCESS )\n+    {\n+      free( pFirstEntry );\n+      return 0;\n+    }\n+\n+    /* process the results */\n+    for( pEntry = pFirstEntry ; pEntry != NULL ; pEntry = pEntry->Next )\n+    {\n+      IP_ADAPTER_DNS_SERVER_ADDRESS* pDNSAddr = pEntry->FirstDnsServerAddress;\n+      for( ; pDNSAddr != NULL ; pDNSAddr = pDNSAddr->Next )\n+      {\n+        struct sockaddr *pGenericAddr = pDNSAddr->Address.lpSockaddr;\n+        size_t stringlen = 0;\n+\n+        if( pGenericAddr->sa_family == AF_INET && left > ipv4_size )\n+        {\n+          /* Handle the v4 case */\n+          struct sockaddr_in *pIPv4Addr = ( struct sockaddr_in * ) pGenericAddr;\n+          ares_inet_ntop( AF_INET, &pIPv4Addr->sin_addr, ret, ipv4_size - 1 ); /* -1 for comma */\n+\n+          /* Append a comma to the end, THEN NULL. Should be OK because we\n+             already tested the size at the top of the if statement. */\n+          stringlen = strlen( ret );\n+          ret[ stringlen ] = ',';\n+          ret[ stringlen + 1 ] = '\\0';\n+          ret += stringlen + 1;\n+          left -= ret - ret_buf;\n+          ++count;\n+        }\n+        else if( pGenericAddr->sa_family == AF_INET6 && left > ipv6_size )\n+        {\n+          /* Handle the v6 case */\n+          struct sockaddr_in6 *pIPv6Addr = ( struct sockaddr_in6 * ) pGenericAddr;\n+          ares_inet_ntop( AF_INET6, &pIPv6Addr->sin6_addr, ret, ipv6_size - 1 ); /* -1 for comma */\n+\n+          stringlen = strlen( ret );\n+\n+          /* Windows apparently always reports some IPv6 DNS servers that\n+             prefixed with fec0:0:0:ffff. These ususally do not point to\n+             working DNS servers, so we ignore them. */\n+          if (strncmp(ret, \"fec0:0:0:ffff:\", 14) != 0) {\n+            /* Append a comma to the end, THEN NULL. Should be OK because we\n+               already tested the size at the top of the if statement. */\n+            ret[ stringlen ] = ',';\n+            ret[ stringlen + 1 ] = '\\0';\n+            ret += stringlen + 1;\n+            left -= ret - ret_buf;\n+            ++count;\n+          }\n+        }\n+      }\n+    }\n+\n+    if( pFirstEntry )\n+      free( pFirstEntry );\n+    if (ret > ret_buf)\n+      ret[-1] = '\\0';\n+    return count;\n   }\n-  if (strlen(fi->DnsServerList.IpAddress.String) > 0 &&\n-      inet_addr(fi->DnsServerList.IpAddress.String) != INADDR_NONE &&\n-      left > ip_size)\n+  else\n   {\n-    ret += sprintf (ret, \"%s,\", fi->DnsServerList.IpAddress.String);\n-    left -= ret - ret_buf;\n-    count++;\n-  }\n+    FIXED_INFO    *fi, *newfi;\n+    DWORD          size = sizeof (*fi);\n+    IP_ADDR_STRING *ipAddr;\n+    int            i;\n+    int            debug  = 0;\n+    HRESULT        res;\n+\n+    fi = malloc(size);\n+    if (!fi)\n+      return 0;\n+\n+    res = (*ares_fpGetNetworkParams) (fi, &size);\n+    if ((res != ERROR_BUFFER_OVERFLOW) && (res != ERROR_SUCCESS))\n+      goto quit;\n+\n+    newfi = realloc(fi, size);\n+    if (!newfi)\n+      goto quit;\n+\n+    fi = newfi;\n+    res = (*ares_fpGetNetworkParams) (fi, &size);\n+    if (res != ERROR_SUCCESS)\n+      goto quit;\n \n-  for (i = 0, ipAddr = fi->DnsServerList.Next; ipAddr && left > ip_size;\n-       ipAddr = ipAddr->Next, i++)\n-  {\n-    if (inet_addr(ipAddr->IpAddress.String) != INADDR_NONE)\n+    if (debug)\n     {\n-       ret += sprintf (ret, \"%s,\", ipAddr->IpAddress.String);\n-       left -= ret - ret_buf;\n-       count++;\n+      printf (\"Host Name: %s\\n\", fi->HostName);\n+      printf (\"Domain Name: %s\\n\", fi->DomainName);\n+      printf (\"DNS Servers:\\n\"\n+              \"    %s (primary)\\n\", fi->DnsServerList.IpAddress.String);\n+    }\n+    if (strlen(fi->DnsServerList.IpAddress.String) > 0 &&\n+        inet_addr(fi->DnsServerList.IpAddress.String) != INADDR_NONE &&\n+        left > ipv4_size)\n+    {\n+      ret += sprintf (ret, \"%s,\", fi->DnsServerList.IpAddress.String);\n+      left -= ret - ret_buf;\n+      ++count;\n+    }\n+\n+    for (i = 0, ipAddr = fi->DnsServerList.Next; ipAddr && left > ipv4_size;\n+         ipAddr = ipAddr->Next, i++)\n+    {\n+      if (inet_addr(ipAddr->IpAddress.String) != INADDR_NONE)\n+      {\n+         ret += sprintf (ret, \"%s,\", ipAddr->IpAddress.String);\n+         left -= ret - ret_buf;\n+         ++count;\n+      }\n+      if (debug)\n+         printf (\"    %s (secondary %d)\\n\", ipAddr->IpAddress.String, i+1);\n     }\n-    if (debug)\n-       printf (\"    %s (secondary %d)\\n\", ipAddr->IpAddress.String, i+1);\n-  }\n \n quit:\n-  if (fi)\n-     free(fi);\n-\n-  if (debug && left <= ip_size)\n-     printf (\"Too many nameservers. Truncating to %d addressess\", count);\n-  if (ret > ret_buf)\n-     ret[-1] = '\\0';\n-  return count;\n+    if (fi)\n+      free(fi);\n+\n+    if (debug && left <= ipv4_size)\n+      printf (\"Too many nameservers. Truncating to %d addressess\", count);\n+    if (ret > ret_buf)\n+      ret[-1] = '\\0';\n+    return count;\n+  }\n }\n #endif\n \n@@ -704,7 +827,8 @@ DhcpNameServer\n   DWORD data_type;\n   DWORD bytes;\n   DWORD result;\n-  char  buf[256];\n+  char  buf[512];\n+  win_platform platform;\n \n   if (channel->nservers > -1)  /* don't override ARES_OPT_SERVER */\n      return ARES_SUCCESS;\n@@ -716,7 +840,9 @@ DhcpNameServer\n       goto okay;\n   }\n \n-  if (IS_NT())\n+  platform = ares__getplatform();\n+\n+  if (platform == WIN_NT)\n   {\n     if (RegOpenKeyEx(\n           HKEY_LOCAL_MACHINE, WIN_NS_NT_KEY, 0,\n@@ -750,7 +876,7 @@ DhcpNameServer\n       RegCloseKey(mykey);\n     }\n   }\n-  else\n+  else if (platform == WIN_9X)\n   {\n     if (RegOpenKeyEx(\n           HKEY_LOCAL_MACHINE, WIN_NS_9X, 0,\n@@ -832,7 +958,10 @@ DhcpNameServer\n      return ARES_ENOMEM;\n \n   for (i = 0; def_nameservers[i]; i++)\n-      servers[i].addr.addrV4.s_addr = htonl(def_nameservers[i]);\n+  {\n+    servers[i].addr.addrV4.s_addr = htonl(def_nameservers[i]);\n+    servers[i].addr.family = AF_INET;\n+  }\n   status = ARES_EOF;\n \n #elif defined(ANDROID)\n@@ -856,17 +985,19 @@ DhcpNameServer\n     if (fp) {\n       while ((status = ares__read_line(fp, &line, &linesize)) == ARES_SUCCESS)\n       {\n-        if ((p = try_config(line, \"domain\")))\n+        if ((p = try_config(line, \"domain\", ';')))\n           status = config_domain(channel, p);\n-        else if ((p = try_config(line, \"lookup\")) && !channel->lookups)\n+        else if ((p = try_config(line, \"lookup\", ';')) && !channel->lookups)\n           status = config_lookup(channel, p, \"bind\", \"file\");\n-        else if ((p = try_config(line, \"search\")))\n+        else if ((p = try_config(line, \"search\", ';')))\n           status = set_search(channel, p);\n-        else if ((p = try_config(line, \"nameserver\")) && channel->nservers == -1)\n+        else if ((p = try_config(line, \"nameserver\", ';')) &&\n+                 channel->nservers == -1)\n           status = config_nameserver(&servers, &nservers, p);\n-        else if ((p = try_config(line, \"sortlist\")) && channel->nsort == -1)\n+        else if ((p = try_config(line, \"sortlist\", ';')) &&\n+                 channel->nsort == -1)\n           status = config_sortlist(&sortlist, &nsort, p);\n-        else if ((p = try_config(line, \"options\")))\n+        else if ((p = try_config(line, \"options\", ';')))\n           status = set_options(channel, p);\n         else\n           status = ARES_SUCCESS;\n@@ -896,8 +1027,9 @@ DhcpNameServer\n       if (fp) {\n         while ((status = ares__read_line(fp, &line, &linesize)) == ARES_SUCCESS)\n         {\n-          if ((p = try_config(line, \"hosts:\")) && !channel->lookups)\n-            status = config_lookup(channel, p, \"dns\", \"files\");\n+          if ((p = try_config(line, \"hosts:\", '\\0')) && !channel->lookups)\n+            /* ignore errors */\n+            (void)config_lookup(channel, p, \"dns\", \"files\");\n         }\n         fclose(fp);\n       }\n@@ -923,8 +1055,9 @@ DhcpNameServer\n       if (fp) {\n         while ((status = ares__read_line(fp, &line, &linesize)) == ARES_SUCCESS)\n         {\n-          if ((p = try_config(line, \"order\")) && !channel->lookups)\n-            status = config_lookup(channel, p, \"bind\", \"hosts\");\n+          if ((p = try_config(line, \"order\", '\\0')) && !channel->lookups)\n+            /* ignore errors */\n+            (void)config_lookup(channel, p, \"bind\", \"hosts\");\n         }\n         fclose(fp);\n       }\n@@ -950,8 +1083,9 @@ DhcpNameServer\n       if (fp) {\n         while ((status = ares__read_line(fp, &line, &linesize)) == ARES_SUCCESS)\n         {\n-          if ((p = try_config(line, \"hosts=\")) && !channel->lookups)\n-            status = config_lookup(channel, p, \"bind\", \"local\");\n+          if ((p = try_config(line, \"hosts=\", '\\0')) && !channel->lookups)\n+            /* ignore errors */\n+            (void)config_lookup(channel, p, \"bind\", \"local\");\n         }\n         fclose(fp);\n       }\n@@ -1042,10 +1176,13 @@ static int init_by_defaults(ares_channel channel)\n     channel->nservers = 1;\n   }\n \n-#ifdef ENAMETOOLONG\n-#define toolong(x) (x == -1) && ((ENAMETOOLONG == errno) || (EINVAL == errno))\n+#if defined(USE_WINSOCK)\n+#define toolong(x) (x == -1) &&  (SOCKERRNO == WSAEFAULT)\n+#elif defined(ENAMETOOLONG)\n+#define toolong(x) (x == -1) && ((SOCKERRNO == ENAMETOOLONG) || \\\n+                                 (SOCKERRNO == EINVAL))\n #else\n-#define toolong(x) (x == -1) && (EINVAL == errno)\n+#define toolong(x) (x == -1) &&  (SOCKERRNO == EINVAL)\n #endif\n \n   if (channel->ndomains == -1) {\n@@ -1287,9 +1424,9 @@ static int config_sortlist(struct apattern **sortlist, int *nsort,\n           if (!sortlist_alloc(sortlist, nsort, &pat))\n             return ARES_ENOMEM;\n         }\n-      if (ipbufpfx[0] &&\n-          (bits = ares_inet_net_pton(AF_INET, ipbufpfx, &pat.addrV4,\n-                                     sizeof(pat.addrV4))) > 0)\n+      else if (ipbufpfx[0] &&\n+               (bits = ares_inet_net_pton(AF_INET, ipbufpfx, &pat.addrV4,\n+                                          sizeof(pat.addrV4))) > 0)\n         {\n           pat.type = PATTERN_CIDR;\n           pat.mask.bits = (unsigned short)bits;\n@@ -1426,7 +1563,7 @@ static const char *try_option(const char *p, const char *q, const char *opt)\n }\n \n #if !defined(WIN32) && !defined(WATT32)\n-static char *try_config(char *s, const char *opt)\n+static char *try_config(char *s, const char *opt, char scc)\n {\n   size_t len;\n   char *p;\n@@ -1436,10 +1573,17 @@ static char *try_config(char *s, const char *opt)\n     /* no line or no option */\n     return NULL;\n \n+  /* Hash '#' character is always used as primary comment char, additionally\n+     a not-NUL secondary comment char will be considered when specified. */\n+\n   /* trim line comment */\n   p = s;\n-  while (*p && (*p != '#'))\n-    p++;\n+  if(scc)\n+    while (*p && (*p != '#') && (*p != scc))\n+      p++;\n+  else\n+    while (*p && (*p != '#'))\n+      p++;\n   *p = '\\0';\n \n   /* trim trailing whitespace */"}, {"sha": "343aee3ffbdc9bd799a7781f383cc6e698f268a1", "filename": "src/rt/libuv/src/ares/ares_iphlpapi.h", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_iphlpapi.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_iphlpapi.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_iphlpapi.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -0,0 +1,221 @@\n+#ifndef HEADER_CARES_IPHLPAPI_H\n+#define HEADER_CARES_IPHLPAPI_H\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ * Copyright (C) 2004 - 2011 by Daniel Stenberg et al\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#if defined(USE_WINSOCK)\n+\n+#ifndef INET_ADDRSTRLEN\n+#define INET_ADDRSTRLEN  22\n+#endif\n+\n+#ifndef INET6_ADDRSTRLEN\n+#define INET6_ADDRSTRLEN 65\n+#endif\n+\n+/* ---------------------------------- */\n+#if !defined(_WS2DEF_)           && \\\n+    !defined(__CSADDR_DEFINED__) && \\\n+    !defined(__CSADDR_T_DEFINED)\n+/* ---------------------------------- */\n+\n+typedef struct _SOCKET_ADDRESS {\n+  LPSOCKADDR lpSockaddr;\n+  INT iSockaddrLength;\n+} SOCKET_ADDRESS, *PSOCKET_ADDRESS;\n+\n+typedef struct _CSADDR_INFO {\n+  SOCKET_ADDRESS LocalAddr;\n+  SOCKET_ADDRESS RemoteAddr;\n+  INT iSocketType;\n+  INT iProtocol;\n+} CSADDR_INFO, *PCSADDR_INFO;\n+\n+/* --------------------------------- */\n+#endif /* ! _WS2DEF_           && \\  */\n+/*        ! __CSADDR_DEFINED__ && \\  */\n+/*        ! __CSADDR_T_DEFINED       */\n+/* --------------------------------- */\n+\n+/* ------------------------------- */\n+#if !defined(IP_ADAPTER_DDNS_ENABLED)\n+/* ------------------------------- */\n+\n+#define IP_ADAPTER_ADDRESS_DNS_ELIGIBLE  0x0001\n+#define IP_ADAPTER_ADDRESS_TRANSIENT     0x0002\n+\n+#define IP_ADAPTER_DDNS_ENABLED                0x0001\n+#define IP_ADAPTER_REGISTER_ADAPTER_SUFFIX     0x0002\n+#define IP_ADAPTER_DHCP_ENABLED                0x0004\n+#define IP_ADAPTER_RECEIVE_ONLY                0x0008\n+#define IP_ADAPTER_NO_MULTICAST                0x0010\n+#define IP_ADAPTER_IPV6_OTHER_STATEFUL_CONFIG  0x0020\n+\n+#define GAA_FLAG_SKIP_UNICAST        0x0001\n+#define GAA_FLAG_SKIP_ANYCAST        0x0002\n+#define GAA_FLAG_SKIP_MULTICAST      0x0004\n+#define GAA_FLAG_SKIP_DNS_SERVER     0x0008\n+#define GAA_FLAG_INCLUDE_PREFIX      0x0010\n+#define GAA_FLAG_SKIP_FRIENDLY_NAME  0x0020\n+\n+typedef enum {\n+  IpPrefixOriginOther = 0,\n+  IpPrefixOriginManual,\n+  IpPrefixOriginWellKnown,\n+  IpPrefixOriginDhcp,\n+  IpPrefixOriginRouterAdvertisement\n+} IP_PREFIX_ORIGIN;\n+\n+typedef enum {\n+  IpSuffixOriginOther = 0,\n+  IpSuffixOriginManual,\n+  IpSuffixOriginWellKnown,\n+  IpSuffixOriginDhcp,\n+  IpSuffixOriginLinkLayerAddress,\n+  IpSuffixOriginRandom\n+} IP_SUFFIX_ORIGIN;\n+\n+typedef enum {\n+  IpDadStateInvalid = 0,\n+  IpDadStateTentative,\n+  IpDadStateDuplicate,\n+  IpDadStateDeprecated,\n+  IpDadStatePreferred\n+} IP_DAD_STATE;\n+\n+typedef enum {\n+  IfOperStatusUp = 1,\n+  IfOperStatusDown,\n+  IfOperStatusTesting,\n+  IfOperStatusUnknown,\n+  IfOperStatusDormant,\n+  IfOperStatusNotPresent,\n+  IfOperStatusLowerLayerDown\n+} IF_OPER_STATUS;\n+\n+typedef enum {\n+  ScopeLevelInterface    = 0x0001,\n+  ScopeLevelLink         = 0x0002,\n+  ScopeLevelSubnet       = 0x0003,\n+  ScopeLevelAdmin        = 0x0004,\n+  ScopeLevelSite         = 0x0005,\n+  ScopeLevelOrganization = 0x0008,\n+  ScopeLevelGlobal       = 0x000E\n+} SCOPE_LEVEL;\n+\n+typedef struct _IP_ADAPTER_UNICAST_ADDRESS {\n+  union {\n+    ULONGLONG Alignment;\n+    struct {\n+      ULONG Length;\n+      DWORD Flags;\n+    } s;\n+  } u;\n+  struct _IP_ADAPTER_UNICAST_ADDRESS *Next;\n+  SOCKET_ADDRESS Address;\n+  IP_PREFIX_ORIGIN PrefixOrigin;\n+  IP_SUFFIX_ORIGIN SuffixOrigin;\n+  IP_DAD_STATE DadState;\n+  ULONG ValidLifetime;\n+  ULONG PreferredLifetime;\n+  ULONG LeaseLifetime;\n+} IP_ADAPTER_UNICAST_ADDRESS, *PIP_ADAPTER_UNICAST_ADDRESS;\n+\n+typedef struct _IP_ADAPTER_ANYCAST_ADDRESS {\n+  union {\n+    ULONGLONG Alignment;\n+    struct {\n+      ULONG Length;\n+      DWORD Flags;\n+    } s;\n+  } u;\n+  struct _IP_ADAPTER_ANYCAST_ADDRESS *Next;\n+  SOCKET_ADDRESS Address;\n+} IP_ADAPTER_ANYCAST_ADDRESS, *PIP_ADAPTER_ANYCAST_ADDRESS;\n+\n+typedef struct _IP_ADAPTER_MULTICAST_ADDRESS {\n+  union {\n+    ULONGLONG Alignment;\n+    struct {\n+      ULONG Length;\n+      DWORD Flags;\n+    } s;\n+  } u;\n+  struct _IP_ADAPTER_MULTICAST_ADDRESS *Next;\n+  SOCKET_ADDRESS Address;\n+} IP_ADAPTER_MULTICAST_ADDRESS, *PIP_ADAPTER_MULTICAST_ADDRESS;\n+\n+typedef struct _IP_ADAPTER_DNS_SERVER_ADDRESS {\n+  union {\n+    ULONGLONG Alignment;\n+    struct {\n+      ULONG Length;\n+      DWORD Reserved;\n+    } s;\n+  } u;\n+  struct _IP_ADAPTER_DNS_SERVER_ADDRESS *Next;\n+  SOCKET_ADDRESS Address;\n+} IP_ADAPTER_DNS_SERVER_ADDRESS, *PIP_ADAPTER_DNS_SERVER_ADDRESS;\n+\n+typedef struct _IP_ADAPTER_PREFIX {\n+  union {\n+    ULONGLONG Alignment;\n+    struct {\n+      ULONG Length;\n+      DWORD Flags;\n+    } s;\n+  } u;\n+  struct _IP_ADAPTER_PREFIX *Next;\n+  SOCKET_ADDRESS Address;\n+  ULONG PrefixLength;\n+} IP_ADAPTER_PREFIX, *PIP_ADAPTER_PREFIX;\n+\n+typedef struct _IP_ADAPTER_ADDRESSES {\n+  union {\n+    ULONGLONG Alignment;\n+    struct {\n+      ULONG Length;\n+      DWORD IfIndex;\n+    } s;\n+  } u;\n+  struct _IP_ADAPTER_ADDRESSES *Next;\n+  PCHAR AdapterName;\n+  PIP_ADAPTER_UNICAST_ADDRESS FirstUnicastAddress;\n+  PIP_ADAPTER_ANYCAST_ADDRESS FirstAnycastAddress;\n+  PIP_ADAPTER_MULTICAST_ADDRESS FirstMulticastAddress;\n+  PIP_ADAPTER_DNS_SERVER_ADDRESS FirstDnsServerAddress;\n+  PWCHAR DnsSuffix;\n+  PWCHAR Description;\n+  PWCHAR FriendlyName;\n+  BYTE PhysicalAddress[MAX_ADAPTER_ADDRESS_LENGTH];\n+  DWORD PhysicalAddressLength;\n+  DWORD Flags;\n+  DWORD Mtu;\n+  DWORD IfType;\n+  IF_OPER_STATUS OperStatus;\n+  DWORD Ipv6IfIndex;\n+  DWORD ZoneIndices[16];\n+  PIP_ADAPTER_PREFIX FirstPrefix;\n+} IP_ADAPTER_ADDRESSES, *PIP_ADAPTER_ADDRESSES;\n+\n+/* -------------------------------- */\n+#endif /* ! IP_ADAPTER_DDNS_ENABLED */\n+/* -------------------------------- */\n+\n+#endif /* USE_WINSOCK */\n+\n+#endif /* HEADER_CARES_IPHLPAPI_H */"}, {"sha": "f0137a1828e0f226879b87f612a9994f0ca1ef63", "filename": "src/rt/libuv/src/ares/ares_library_init.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_library_init.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_library_init.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_library_init.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -26,6 +26,7 @@\n #ifdef USE_WINSOCK\n fpGetNetworkParams_t ares_fpGetNetworkParams = ZERO_NULL;\n fpSystemFunction036_t ares_fpSystemFunction036 = ZERO_NULL;\n+fpGetAdaptersAddresses_t ares_fpGetAdaptersAddresses = ZERO_NULL;\n #endif\n \n /* library-private global vars with source visibility restricted to this file */\n@@ -56,6 +57,15 @@ static int ares_win32_init(void)\n       return ARES_EADDRGETNETWORKPARAMS;\n     }\n \n+  ares_fpGetAdaptersAddresses = (fpGetAdaptersAddresses_t)\n+    GetProcAddress(hnd_iphlpapi, \"GetAdaptersAddresses\");\n+  if (!ares_fpGetAdaptersAddresses)\n+    {\n+      /* This can happen on clients before WinXP, I don't\n+         think it should be an error, unless we don't want to\n+         support Windows 2000 anymore */\n+    }\n+\n   /*\n    * When advapi32.dll is unavailable or advapi32.dll has no SystemFunction036,\n    * also known as RtlGenRandom, which is the case for Windows versions prior"}, {"sha": "cbbfc6afbad6d4e2621eaf27fa87e93799526530", "filename": "src/rt/libuv/src/ares/ares_library_init.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_library_init.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_library_init.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_library_init.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -3,7 +3,7 @@\n \n \n /* Copyright 1998 by the Massachusetts Institute of Technology.\n- * Copyright (C) 2004-2009 by Daniel Stenberg\n+ * Copyright (C) 2004-2011 by Daniel Stenberg\n  *\n  * Permission to use, copy, modify, and distribute this\n  * software and its documentation for any purpose and without\n@@ -23,15 +23,18 @@\n #ifdef USE_WINSOCK\n \n #include <iphlpapi.h>\n+#include \"ares_iphlpapi.h\"\n \n typedef DWORD (WINAPI *fpGetNetworkParams_t) (FIXED_INFO*, DWORD*);\n typedef BOOLEAN (APIENTRY *fpSystemFunction036_t) (void*, ULONG);\n+typedef ULONG (WINAPI *fpGetAdaptersAddresses_t) ( ULONG, ULONG, void*, IP_ADAPTER_ADDRESSES*, ULONG* );\n \n /* Forward-declaration of variables defined in ares_library_init.c */\n /* that are global and unique instances for whole c-ares library.  */\n \n extern fpGetNetworkParams_t ares_fpGetNetworkParams;\n extern fpSystemFunction036_t ares_fpSystemFunction036;\n+extern fpGetAdaptersAddresses_t ares_fpGetAdaptersAddresses;\n \n #endif /* USE_WINSOCK */\n "}, {"sha": "701add58c6077dce547013c7d9a24ff19ba74524", "filename": "src/rt/libuv/src/ares/ares_nowarn.c", "status": "modified", "additions": 126, "deletions": 4, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_nowarn.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_nowarn.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_nowarn.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -1,5 +1,5 @@\n \n-/* Copyright (C) 2010 by Daniel Stenberg\n+/* Copyright (C) 2010-2011 by Daniel Stenberg\n  *\n  * Permission to use, copy, modify, and distribute this\n  * software and its documentation for any purpose and without\n@@ -17,13 +17,44 @@\n \n #include \"ares_setup.h\"\n \n+#ifdef HAVE_ASSERT_H\n+#  include <assert.h>\n+#endif\n+\n+#if defined(__INTEL_COMPILER) && defined(__unix__)\n+\n+#ifdef HAVE_SYS_SOCKET_H\n+#  include <sys/socket.h>\n+#endif\n+#ifdef HAVE_NETINET_IN_H\n+#  include <netinet/in.h>\n+#endif\n+#ifdef HAVE_ARPA_INET_H\n+#  include <arpa/inet.h>\n+#endif\n+\n+#endif /* __INTEL_COMPILER && __unix__ */\n+\n+#define BUILDING_ARES_NOWARN_C 1\n+\n #include \"ares_nowarn.h\"\n \n-#define CARES_MASK_UINT (~(unsigned int) 0)\n-#define CARES_MASK_SINT (CARES_MASK_UINT >> 1)\n+#if (SIZEOF_INT == 2)\n+#  define CARES_MASK_SINT  0x7FFF\n+#  define CARES_MASK_UINT  0xFFFF\n+#elif (SIZEOF_INT == 4)\n+#  define CARES_MASK_SINT  0x7FFFFFFF\n+#  define CARES_MASK_UINT  0xFFFFFFFF\n+#elif (SIZEOF_INT == 8)\n+#  define CARES_MASK_SINT  0x7FFFFFFFFFFFFFFF\n+#  define CARES_MASK_UINT  0xFFFFFFFFFFFFFFFF\n+#elif (SIZEOF_INT == 16)\n+#  define CARES_MASK_SINT  0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n+#  define CARES_MASK_UINT  0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n+#endif\n \n /*\n-** size_t to signed int\n+** unsigned size_t to signed int\n */\n \n int aresx_uztosi(size_t uznum)\n@@ -51,9 +82,100 @@ int aresx_sltosi(long slnum)\n #  pragma warning(disable:810) /* conversion may lose significant bits */\n #endif\n \n+  DEBUGASSERT(slnum >= 0);\n   return (int)(slnum & (long) CARES_MASK_SINT);\n \n #ifdef __INTEL_COMPILER\n #  pragma warning(pop)\n #endif\n }\n+\n+/*\n+** signed ssize_t to signed int\n+*/\n+\n+int aresx_sztosi(ssize_t sznum)\n+{\n+#ifdef __INTEL_COMPILER\n+#  pragma warning(push)\n+#  pragma warning(disable:810) /* conversion may lose significant bits */\n+#endif\n+\n+  DEBUGASSERT(sznum >= 0);\n+  return (int)(sznum & (ssize_t) CARES_MASK_SINT);\n+\n+#ifdef __INTEL_COMPILER\n+#  pragma warning(pop)\n+#endif\n+}\n+\n+/*\n+** signed ssize_t to unsigned int\n+*/\n+\n+unsigned int aresx_sztoui(ssize_t sznum)\n+{\n+#ifdef __INTEL_COMPILER\n+#  pragma warning(push)\n+#  pragma warning(disable:810) /* conversion may lose significant bits */\n+#endif\n+\n+  DEBUGASSERT(sznum >= 0);\n+  return (unsigned int)(sznum & (ssize_t) CARES_MASK_UINT);\n+\n+#ifdef __INTEL_COMPILER\n+#  pragma warning(pop)\n+#endif\n+}\n+\n+#if defined(__INTEL_COMPILER) && defined(__unix__)\n+\n+int aresx_FD_ISSET(int fd, fd_set *fdset)\n+{\n+  #pragma warning(push)\n+  #pragma warning(disable:1469) /* clobber ignored */\n+  return FD_ISSET(fd, fdset);\n+  #pragma warning(pop)\n+}\n+\n+void aresx_FD_SET(int fd, fd_set *fdset)\n+{\n+  #pragma warning(push)\n+  #pragma warning(disable:1469) /* clobber ignored */\n+  FD_SET(fd, fdset);\n+  #pragma warning(pop)\n+}\n+\n+void aresx_FD_ZERO(fd_set *fdset)\n+{\n+  #pragma warning(push)\n+  #pragma warning(disable:593) /* variable was set but never used */\n+  FD_ZERO(fdset);\n+  #pragma warning(pop)\n+}\n+\n+unsigned short aresx_htons(unsigned short usnum)\n+{\n+#if (__INTEL_COMPILER == 910) && defined(__i386__)\n+  return (unsigned short)(((usnum << 8) & 0xFF00) | ((usnum >> 8) & 0x00FF));\n+#else\n+  #pragma warning(push)\n+  #pragma warning(disable:810) /* conversion may lose significant bits */\n+  return htons(usnum);\n+  #pragma warning(pop)\n+#endif\n+}\n+\n+unsigned short aresx_ntohs(unsigned short usnum)\n+{\n+#if (__INTEL_COMPILER == 910) && defined(__i386__)\n+  return (unsigned short)(((usnum << 8) & 0xFF00) | ((usnum >> 8) & 0x00FF));\n+#else\n+  #pragma warning(push)\n+  #pragma warning(disable:810) /* conversion may lose significant bits */\n+  return ntohs(usnum);\n+  #pragma warning(pop)\n+#endif\n+}\n+\n+#endif /* __INTEL_COMPILER && __unix__ */"}, {"sha": "bcaa22721f17fc8911d4b7ef7d072316c3df77ea", "filename": "src/rt/libuv/src/ares/ares_nowarn.h", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_nowarn.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_nowarn.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_nowarn.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -2,7 +2,7 @@\n #define HEADER_CARES_NOWARN_H\n \n \n-/* Copyright (C) 2010 by Daniel Stenberg\n+/* Copyright (C) 2010-2011 by Daniel Stenberg\n  *\n  * Permission to use, copy, modify, and distribute this\n  * software and its documentation for any purpose and without\n@@ -21,4 +21,35 @@ int aresx_uztosi(size_t uznum);\n \n int aresx_sltosi(long slnum);\n \n+int aresx_sztosi(ssize_t sznum);\n+\n+unsigned int aresx_sztoui(ssize_t sznum);\n+\n+#if defined(__INTEL_COMPILER) && defined(__unix__)\n+\n+int aresx_FD_ISSET(int fd, fd_set *fdset);\n+\n+void aresx_FD_SET(int fd, fd_set *fdset);\n+\n+void aresx_FD_ZERO(fd_set *fdset);\n+\n+unsigned short aresx_htons(unsigned short usnum);\n+\n+unsigned short aresx_ntohs(unsigned short usnum);\n+\n+#ifndef BUILDING_ARES_NOWARN_C\n+#  undef  FD_ISSET\n+#  define FD_ISSET(a,b) aresx_FD_ISSET((a),(b))\n+#  undef  FD_SET\n+#  define FD_SET(a,b)   aresx_FD_SET((a),(b))\n+#  undef  FD_ZERO\n+#  define FD_ZERO(a)    aresx_FD_ZERO((a))\n+#  undef  htons\n+#  define htons(a)      aresx_htons((a))\n+#  undef  ntohs\n+#  define ntohs(a)      aresx_ntohs((a))\n+#endif\n+\n+#endif /* __INTEL_COMPILER && __unix__ */\n+\n #endif /* HEADER_CARES_NOWARN_H */"}, {"sha": "5174ef26e4cfe7d18aba07debf9dbfa2c82cd34e", "filename": "src/rt/libuv/src/ares/ares_options.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_options.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_options.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_options.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -1,6 +1,6 @@\n \n /* Copyright 1998 by the Massachusetts Institute of Technology.\n- * Copyright (C) 2008-2010 by Daniel Stenberg\n+ * Copyright (C) 2008-2011 by Daniel Stenberg\n  *\n  * Permission to use, copy, modify, and distribute this\n  * software and its documentation for any purpose and without\n@@ -135,12 +135,10 @@ int ares_set_servers(ares_channel channel,\n int ares_set_servers_csv(ares_channel channel,\n                          const char* _csv)\n {\n-  int i;\n+  size_t i;\n   char* csv = NULL;\n   char* ptr;\n   char* start_host;\n-  long port;\n-  bool found_port;\n   int rv = ARES_SUCCESS;\n   struct ares_addr_node *servers = NULL;\n   struct ares_addr_node *last = NULL;\n@@ -165,7 +163,6 @@ int ares_set_servers_csv(ares_channel channel,\n   }\n \n   start_host = csv;\n-  found_port = false;\n   for (ptr = csv; *ptr; ptr++) {\n     if (*ptr == ',') {\n       char* pp = ptr - 1;\n@@ -186,9 +183,8 @@ int ares_set_servers_csv(ares_channel channel,\n         pp--;\n       }\n       if ((pp != start_host) && ((pp + 1) < ptr)) {\n-        /* Found it. */\n-        found_port = true;\n-        port = strtol(pp + 1, NULL, 10);\n+        /* Found it. Parse over the port number */\n+        (void)strtol(pp + 1, NULL, 10);\n         *pp = 0; /* null terminate host */\n       }\n       /* resolve host, try ipv4 first, rslt is in network byte order */\n@@ -233,7 +229,6 @@ int ares_set_servers_csv(ares_channel channel,\n       }\n \n       /* Set up for next one */\n-      found_port = false;\n       start_host = ptr + 1;\n     }\n   }"}, {"sha": "4bd08458836bdc014d0f38570fa17e97b4bb1ef9", "filename": "src/rt/libuv/src/ares/ares_parse_a_reply.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_a_reply.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_a_reply.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_a_reply.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -132,6 +132,7 @@ int ares_parse_a_reply(const unsigned char *abuf, int alen,\n       aptr += len;\n       if (aptr + RRFIXEDSZ > abuf + alen)\n         {\n+          free(rr_name);\n           status = ARES_EBADRESP;\n           break;\n         }\n@@ -149,6 +150,7 @@ int ares_parse_a_reply(const unsigned char *abuf, int alen,\n             {\n               if (aptr + sizeof(struct in_addr) > abuf + alen)\n               {\n+                free(rr_name);\n                 status = ARES_EBADRESP;\n                 break;\n               }\n@@ -159,6 +161,7 @@ int ares_parse_a_reply(const unsigned char *abuf, int alen,\n               struct ares_addrttl * const at = &addrttls[naddrs];\n               if (aptr + sizeof(struct in_addr) > abuf + alen)\n               {\n+                free(rr_name);\n                 status = ARES_EBADRESP;\n                 break;\n               }"}, {"sha": "1fbe8389f74fd35f1fbf6a50d914246950bac8c7", "filename": "src/rt/libuv/src/ares/ares_parse_aaaa_reply.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_aaaa_reply.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_aaaa_reply.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_aaaa_reply.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -132,6 +132,7 @@ int ares_parse_aaaa_reply(const unsigned char *abuf, int alen,\n       aptr += len;\n       if (aptr + RRFIXEDSZ > abuf + alen)\n         {\n+          free(rr_name);\n           status = ARES_EBADRESP;\n           break;\n         }\n@@ -149,6 +150,7 @@ int ares_parse_aaaa_reply(const unsigned char *abuf, int alen,\n             {\n               if (aptr + sizeof(struct ares_in6_addr) > abuf + alen)\n               {\n+                free(rr_name);\n                 status = ARES_EBADRESP;\n                 break;\n               }\n@@ -159,6 +161,7 @@ int ares_parse_aaaa_reply(const unsigned char *abuf, int alen,\n               struct ares_addr6ttl * const at = &addrttls[naddrs];\n               if (aptr + sizeof(struct ares_in6_addr) > abuf + alen)\n               {\n+                free(rr_name);\n                 status = ARES_EBADRESP;\n                 break;\n               }"}, {"sha": "21800546b484ec4bfb1679f00bf314f3feb8811d", "filename": "src/rt/libuv/src/ares/ares_parse_mx_reply.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_mx_reply.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_mx_reply.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_mx_reply.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -47,7 +47,7 @@\n \n int\n ares_parse_mx_reply (const unsigned char *abuf, int alen,\n-                      struct ares_mx_reply **mx_out)\n+                     struct ares_mx_reply **mx_out)\n {\n   unsigned int qdcount, ancount, i;\n   const unsigned char *aptr, *vptr;\n@@ -134,7 +134,7 @@ ares_parse_mx_reply (const unsigned char *abuf, int alen,\n           mx_last = mx_curr;\n \n           vptr = aptr;\n-          mx_curr->priority = ntohs (*((unsigned short *)vptr));\n+          mx_curr->priority = DNS__16BIT(vptr);\n           vptr += sizeof(unsigned short);\n \n           status = ares_expand_name (vptr, abuf, alen, &mx_curr->host, &len);"}, {"sha": "5e9af71d1a9676f1d81992151f3eb3abe95ecbb3", "filename": "src/rt/libuv/src/ares/ares_parse_ns_reply.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_ns_reply.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_ns_reply.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_ns_reply.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -1,5 +1,3 @@\n-/* $Id */\n-\n /* Copyright 1998 by the Massachusetts Institute of Technology.\n  *\n  * Permission to use, copy, modify, and distribute this\n@@ -105,6 +103,7 @@ int ares_parse_ns_reply( const unsigned char* abuf, int alen,\n     if ( aptr + RRFIXEDSZ > abuf + alen )\n     {\n       status = ARES_EBADRESP;\n+      free(rr_name);\n       break;\n     }\n     rr_type = DNS_RR_TYPE( aptr );\n@@ -119,6 +118,7 @@ int ares_parse_ns_reply( const unsigned char* abuf, int alen,\n                                                &len);\n       if ( status != ARES_SUCCESS )\n       {\n+        free(rr_name);\n         break;\n       }\n "}, {"sha": "3b6dbc32e07338f6516a6d035d40247ef448d623", "filename": "src/rt/libuv/src/ares/ares_parse_ptr_reply.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_ptr_reply.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_ptr_reply.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_ptr_reply.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -99,6 +99,7 @@ int ares_parse_ptr_reply(const unsigned char *abuf, int alen, const void *addr,\n       aptr += len;\n       if (aptr + RRFIXEDSZ > abuf + alen)\n         {\n+          free(rr_name);\n           status = ARES_EBADRESP;\n           break;\n         }\n@@ -114,13 +115,17 @@ int ares_parse_ptr_reply(const unsigned char *abuf, int alen, const void *addr,\n           status = ares__expand_name_for_response(aptr, abuf, alen, &rr_data,\n                                                   &len);\n           if (status != ARES_SUCCESS)\n-            break;\n+            {\n+              free(rr_name);\n+              break;\n+            }\n           if (hostname)\n             free(hostname);\n           hostname = rr_data;\n-          aliases[aliascnt] = malloc((strlen(rr_data)+1) * sizeof(char *));\n+          aliases[aliascnt] = malloc((strlen(rr_data)+1) * sizeof(char));\n           if (!aliases[aliascnt])\n             {\n+              free(rr_name);\n               status = ARES_ENOMEM;\n               break;\n             }\n@@ -131,6 +136,7 @@ int ares_parse_ptr_reply(const unsigned char *abuf, int alen, const void *addr,\n             alias_alloc *= 2;\n             ptr = realloc(aliases, alias_alloc * sizeof(char *));\n             if(!ptr) {\n+              free(rr_name);\n               status = ARES_ENOMEM;\n               break;\n             }\n@@ -144,7 +150,10 @@ int ares_parse_ptr_reply(const unsigned char *abuf, int alen, const void *addr,\n           status = ares__expand_name_for_response(aptr, abuf, alen, &rr_data,\n                                                   &len);\n           if (status != ARES_SUCCESS)\n-            break;\n+            {\n+              free(rr_name);\n+              break;\n+            }\n           free(ptrname);\n           ptrname = rr_data;\n         }"}, {"sha": "9c7eb6ee3d32df37f840011a34665385b92a875c", "filename": "src/rt/libuv/src/ares/ares_parse_srv_reply.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_srv_reply.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_srv_reply.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_srv_reply.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -139,11 +139,11 @@ ares_parse_srv_reply (const unsigned char *abuf, int alen,\n           srv_last = srv_curr;\n \n           vptr = aptr;\n-          srv_curr->priority = ntohs (*((unsigned short *)vptr));\n+          srv_curr->priority = DNS__16BIT(vptr);\n           vptr += sizeof(unsigned short);\n-          srv_curr->weight = ntohs (*((unsigned short *)vptr));\n+          srv_curr->weight = DNS__16BIT(vptr);\n           vptr += sizeof(unsigned short);\n-          srv_curr->port = ntohs (*((unsigned short *)vptr));\n+          srv_curr->port = DNS__16BIT(vptr);\n           vptr += sizeof(unsigned short);\n \n           status = ares_expand_name (vptr, abuf, alen, &srv_curr->host, &len);"}, {"sha": "c20061583f42d61fa905d711e408a8d2dee96792", "filename": "src/rt/libuv/src/ares/ares_platform.c", "status": "added", "additions": 11035, "deletions": 0, "changes": 11035, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_platform.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_platform.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_platform.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b"}, {"sha": "e6885ae546155a8aed2a1e63f0985d5d9d304c66", "filename": "src/rt/libuv/src/ares/ares_platform.h", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_platform.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_platform.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_platform.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -0,0 +1,43 @@\n+#ifndef HEADER_CARES_PLATFORM_H\n+#define HEADER_CARES_PLATFORM_H\n+\n+\n+/* Copyright 1998 by the Massachusetts Institute of Technology.\n+ * Copyright (C) 2004 - 2011 by Daniel Stenberg et al\n+ *\n+ * Permission to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose and without\n+ * fee is hereby granted, provided that the above copyright\n+ * notice appear in all copies and that both that copyright\n+ * notice and this permission notice appear in supporting\n+ * documentation, and that the name of M.I.T. not be used in\n+ * advertising or publicity pertaining to distribution of the\n+ * software without specific, written prior permission.\n+ * M.I.T. makes no representations about the suitability of\n+ * this software for any purpose.  It is provided \"as is\"\n+ * without express or implied warranty.\n+ */\n+\n+#include \"ares_setup.h\"\n+\n+#if defined(WIN32) && !defined(MSDOS)\n+\n+typedef enum {\n+  WIN_UNKNOWN,\n+  WIN_3X,\n+  WIN_9X,\n+  WIN_NT,\n+  WIN_CE\n+} win_platform;\n+\n+win_platform ares__getplatform(void);\n+\n+#endif\n+\n+#if defined(_WIN32_WCE)\n+\n+struct servent *getservbyport(int port, const char *proto);\n+\n+#endif\n+\n+#endif /* HEADER_CARES_PLATFORM_H */"}, {"sha": "ff45ba7e5ac10ee79cae4563ab0d0f66d2dcd8b6", "filename": "src/rt/libuv/src/ares/ares_private.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_private.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_private.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_private.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -52,7 +52,6 @@\n \n #if defined(WIN32) && !defined(WATT32)\n \n-#define IS_NT()        ((int)GetVersion() > 0)\n #define WIN_NS_9X      \"System\\\\CurrentControlSet\\\\Services\\\\VxD\\\\MSTCP\"\n #define WIN_NS_NT_KEY  \"System\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters\"\n #define NAMESERVER     \"NameServer\"\n@@ -89,6 +88,11 @@\n #include \"ares_ipv6.h\"\n #include \"ares_llist.h\"\n \n+#ifndef HAVE_GETENV\n+#  include \"ares_getenv.h\"\n+#  define getenv(ptr) ares_getenv(ptr)\n+#endif\n+\n #ifndef HAVE_STRDUP\n #  include \"ares_strdup.h\"\n #  define strdup(ptr) ares_strdup(ptr)\n@@ -199,7 +203,7 @@ struct query {\n   void *arg;\n \n   /* Query status */\n-  int try; /* Number of times we tried this query already. */\n+  int try_count; /* Number of times we tried this query already. */\n   int server; /* Server this query has last been sent to. */\n   struct query_server_info *server_info;   /* per-server state */\n   int using_tcp;"}, {"sha": "e5efa5fb304b2870f5a161cac285c59222f11380", "filename": "src/rt/libuv/src/ares/ares_process.c", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_process.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_process.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_process.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -63,10 +63,10 @@\n #include <stdlib.h>\n #include <fcntl.h>\n #include <time.h>\n-#include <errno.h>\n \n #include \"ares.h\"\n #include \"ares_dns.h\"\n+#include \"ares_nowarn.h\"\n #include \"ares_private.h\"\n \n \n@@ -300,29 +300,28 @@ static void advance_tcp_send_queue(ares_channel channel, int whichserver,\n {\n   struct send_request *sendreq;\n   struct server_state *server = &channel->servers[whichserver];\n-  while (num_bytes > 0)\n-    {\n-      sendreq = server->qhead;\n-      if ((size_t)num_bytes >= sendreq->len)\n-       {\n-         num_bytes -= sendreq->len;\n-         server->qhead = sendreq->next;\n-         if (server->qhead == NULL)\n-           {\n-             SOCK_STATE_CALLBACK(channel, server->tcp_socket, 1, 0);\n-             server->qtail = NULL;\n-           }\n-         if (sendreq->data_storage != NULL)\n-           free(sendreq->data_storage);\n-         free(sendreq);\n-       }\n-      else\n-       {\n-         sendreq->data += num_bytes;\n-         sendreq->len -= num_bytes;\n-         num_bytes = 0;\n-       }\n+  while (num_bytes > 0) {\n+    sendreq = server->qhead;\n+    if ((size_t)num_bytes >= sendreq->len) {\n+      num_bytes -= sendreq->len;\n+      server->qhead = sendreq->next;\n+      if (sendreq->data_storage)\n+        free(sendreq->data_storage);\n+      free(sendreq);\n+      if (server->qhead == NULL) {\n+        SOCK_STATE_CALLBACK(channel, server->tcp_socket, 1, 0);\n+        server->qtail = NULL;\n+\n+        /* qhead is NULL so we cannot continue this loop */\n+        break;\n+      }\n+    }\n+    else {\n+      sendreq->data += num_bytes;\n+      sendreq->len -= num_bytes;\n+      num_bytes = 0;\n     }\n+  }\n }\n \n /* If any TCP socket selects true for reading, read some data,\n@@ -686,7 +685,7 @@ static void next_server(ares_channel channel, struct query *query,\n    * servers to try. In total, we need to do channel->nservers * channel->tries\n    * attempts. Use query->try to remember how many times we already attempted\n    * this query. Use modular arithmetic to find the next server to try. */\n-  while (++(query->try) < (channel->nservers * channel->tries))\n+  while (++(query->try_count) < (channel->nservers * channel->tries))\n     {\n       struct server_state *server;\n \n@@ -791,7 +790,7 @@ void ares__send_query(ares_channel channel, struct query *query,\n           return;\n         }\n     }\n-    timeplus = channel->timeout << (query->try / channel->nservers);\n+    timeplus = channel->timeout << (query->try_count / channel->nservers);\n     timeplus = (timeplus * (9 + (rand () & 7))) / 16;\n     query->timeout = *now;\n     ares__timeadd(&query->timeout,"}, {"sha": "1877c19f772b8782ee4308872cf9e90c18a9d86a", "filename": "src/rt/libuv/src/ares/ares_search.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_search.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_search.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_search.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -20,7 +20,6 @@\n #include <stdlib.h>\n #include <string.h>\n #include <ctype.h>\n-#include <errno.h>\n \n #ifdef HAVE_STRINGS_H\n #  include <strings.h>\n@@ -292,7 +291,7 @@ static int single_domain(ares_channel channel, const char *name, char **s)\n             }\n           else\n             {\n-              error = errno;\n+              error = ERRNO;\n               switch(error)\n                 {\n                 case ENOENT:"}, {"sha": "37b0704579c63219aa15c25f04e30677fb2a77ed", "filename": "src/rt/libuv/src/ares/ares_send.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_send.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_send.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_send.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -96,7 +96,7 @@ void ares_send(ares_channel channel, const unsigned char *qbuf, int qlen,\n   query->arg = arg;\n \n   /* Initialize query status. */\n-  query->try = 0;\n+  query->try_count = 0;\n \n   /* Choose the server to send the query to. If rotation is enabled, keep track\n    * of the next server we want to use. */"}, {"sha": "254cccbb85165667af4f3f584710de19dcb6d153", "filename": "src/rt/libuv/src/ares/ares_setup.h", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_setup.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_setup.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_setup.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -1,7 +1,6 @@\n #ifndef HEADER_CARES_SETUP_H\n #define HEADER_CARES_SETUP_H\n \n-/* $Id$ */\n \n /* Copyright (C) 2004 - 2009 by Daniel Stenberg et al\n  *\n@@ -31,6 +30,12 @@\n \n #ifdef HAVE_CONFIG_H\n #include \"ares_config.h\"\n+#else\n+\n+#ifdef WIN32\n+#include \"config-win32.h\"\n+#endif\n+\n #endif /* HAVE_CONFIG_H */\n \n /* ================================================================ */\n@@ -70,7 +75,7 @@\n /*  please, do it beyond the point further indicated in this file.  */\n /* ================================================================ */\n \n-#if 0 /* libuv disabled */\n+#if 0 /* libuv hack */\n /*\n  * c-ares external interface definitions are also used internally,\n  * and might also include required system header files to define them.\n@@ -83,7 +88,7 @@\n  */\n \n #include <ares_rules.h>\n-#endif\n+#endif /* libuv hack */\n \n /* ================================================================= */\n /* No system header file shall be included in this file before this  */\n@@ -102,6 +107,10 @@\n  */\n \n #ifdef HAVE_WINDOWS_H\n+#  ifndef WIN32_LEAN_AND_MEAN\n+#    define WIN32_LEAN_AND_MEAN\n+#  endif\n+#  include <windows.h>\n #  ifdef HAVE_WINSOCK2_H\n #    include <winsock2.h>\n #    ifdef HAVE_WS2TCPIP_H\n@@ -112,7 +121,6 @@\n #      include <winsock.h>\n #    endif\n #  endif\n-#  include <windows.h>\n #endif\n \n /*"}, {"sha": "592a245985e02d6d4eda57aced778171e3cd8f50", "filename": "src/rt/libuv/src/ares/config_cygwin/ares_config.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_cygwin%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_cygwin%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_cygwin%2Fares_config.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -508,3 +508,5 @@\n \n /* the signed version of size_t */\n /* #undef ssize_t */\n+\n+#define HAVE_GETENV 1"}, {"sha": "920d922c81c15545aa55aa2385ea5ba0c6e76d7b", "filename": "src/rt/libuv/src/ares/config_darwin/ares_config.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_darwin%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_darwin%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_darwin%2Fares_config.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -508,3 +508,5 @@\n \n /* the signed version of size_t */\n /* #undef ssize_t */\n+\n+#define HAVE_GETENV 1"}, {"sha": "2f9b75d02c254fdb43c1ebf77d405734b253b8d8", "filename": "src/rt/libuv/src/ares/config_freebsd/ares_config.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_freebsd%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_freebsd%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_freebsd%2Fares_config.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -508,3 +508,5 @@\n \n /* the signed version of size_t */\n /* #undef ssize_t */\n+\n+#define HAVE_GETENV 1"}, {"sha": "8f8e3307434962c4f74238f34fb99176b07ff1fa", "filename": "src/rt/libuv/src/ares/config_linux/ares_config.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_linux%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_linux%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_linux%2Fares_config.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -508,3 +508,5 @@\n \n /* the signed version of size_t */\n /* #undef ssize_t */\n+\n+#define HAVE_GETENV 1"}, {"sha": "b5891486553d7bf79c9f6b92179debe5cec8c995", "filename": "src/rt/libuv/src/ares/config_netbsd/ares_config.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_netbsd%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_netbsd%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_netbsd%2Fares_config.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -508,3 +508,5 @@\n \n /* the signed version of size_t */\n /* #undef ssize_t */\n+\n+#define HAVE_GETENV 1"}, {"sha": "b5891486553d7bf79c9f6b92179debe5cec8c995", "filename": "src/rt/libuv/src/ares/config_openbsd/ares_config.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_openbsd%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_openbsd%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_openbsd%2Fares_config.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -508,3 +508,5 @@\n \n /* the signed version of size_t */\n /* #undef ssize_t */\n+\n+#define HAVE_GETENV 1"}, {"sha": "fb8565e15b61a73c7dbad487106750bed113597c", "filename": "src/rt/libuv/src/ares/config_sunos/ares_config.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_sunos%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_sunos%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_sunos%2Fares_config.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -508,3 +508,5 @@\n \n /* the signed version of size_t */\n /* #undef ssize_t */\n+\n+#define HAVE_GETENV 1"}, {"sha": "4c9c9f6786a0dff6425c98a62fd4730863cc5fc0", "filename": "src/rt/libuv/src/ares/config_win32/ares_config.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_win32%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_win32%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_win32%2Fares_config.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -108,6 +108,9 @@\n /* Define if you have the strcasecmp function. */\n /* #define HAVE_STRCASECMP 1 */\n \n+/* Define if you have the getenv function. */\n+#define HAVE_GETENV 1\n+\n /* Define if you have the strdup function. */\n #define HAVE_STRDUP 1\n "}, {"sha": "45bb5d48fd1bf5b82088e3e266874fe4b403fe43", "filename": "src/rt/libuv/src/ares/inet_net_pton.c", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_net_pton.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_net_pton.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_net_pton.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -37,20 +37,20 @@\n #endif\n \n #include <ctype.h>\n-#include <errno.h>\n #include <stdio.h>\n #include <string.h>\n #include <stdlib.h>\n \n #include \"ares.h\"\n #include \"ares_ipv6.h\"\n+#include \"ares_nowarn.h\"\n #include \"inet_net_pton.h\"\n \n \n const struct ares_in6_addr ares_in6addr_any = { { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } } };\n \n \n-#if !defined(HAVE_INET_NET_PTON) || !defined(HAVE_INET_NET_PTON_IPV6)\n+#ifndef HAVE_INET_NET_PTON\n \n /*\n  * static int\n@@ -83,16 +83,17 @@ inet_net_pton_ipv4(const char *src, unsigned char *dst, size_t size)\n \n   ch = *src++;\n   if (ch == '0' && (src[0] == 'x' || src[0] == 'X')\n+      && ISASCII(src[1])\n       && ISXDIGIT(src[1])) {\n     /* Hexadecimal: Eat nybble string. */\n     if (!size)\n       goto emsgsize;\n     dirty = 0;\n     src++;  /* skip x or X. */\n-    while ((ch = *src++) != '\\0' && ISXDIGIT(ch)) {\n+    while ((ch = *src++) != '\\0' && ISASCII(ch) && ISXDIGIT(ch)) {\n       if (ISUPPER(ch))\n         ch = tolower(ch);\n-      n = (int)(strchr(xdigits, ch) - xdigits);\n+      n = aresx_sztosi(strchr(xdigits, ch) - xdigits);\n       if (dirty == 0)\n         tmp = n;\n       else\n@@ -109,18 +110,18 @@ inet_net_pton_ipv4(const char *src, unsigned char *dst, size_t size)\n         goto emsgsize;\n       *dst++ = (unsigned char) (tmp << 4);\n     }\n-  } else if (ISDIGIT(ch)) {\n+  } else if (ISASCII(ch) && ISDIGIT(ch)) {\n     /* Decimal: eat dotted digit string. */\n     for (;;) {\n       tmp = 0;\n       do {\n-        n = (int)(strchr(digits, ch) - digits);\n+        n = aresx_sztosi(strchr(digits, ch) - digits);\n         tmp *= 10;\n         tmp += n;\n         if (tmp > 255)\n           goto enoent;\n       } while ((ch = *src++) != '\\0' &&\n-               ISDIGIT(ch));\n+               ISASCII(ch) && ISDIGIT(ch));\n       if (!size--)\n         goto emsgsize;\n       *dst++ = (unsigned char) tmp;\n@@ -129,27 +130,27 @@ inet_net_pton_ipv4(const char *src, unsigned char *dst, size_t size)\n       if (ch != '.')\n         goto enoent;\n       ch = *src++;\n-      if (!ISDIGIT(ch))\n+      if (!ISASCII(ch) || !ISDIGIT(ch))\n         goto enoent;\n     }\n   } else\n     goto enoent;\n \n   bits = -1;\n-  if (ch == '/' &&\n+  if (ch == '/' && ISASCII(src[0]) &&\n       ISDIGIT(src[0]) && dst > odst) {\n     /* CIDR width specifier.  Nothing can follow it. */\n     ch = *src++;    /* Skip over the /. */\n     bits = 0;\n     do {\n-      n = (int)(strchr(digits, ch) - digits);\n+      n = aresx_sztosi(strchr(digits, ch) - digits);\n       bits *= 10;\n       bits += n;\n-    } while ((ch = *src++) != '\\0' && ISDIGIT(ch));\n+      if (bits > 32)\n+        goto enoent;\n+    } while ((ch = *src++) != '\\0' && ISASCII(ch) && ISDIGIT(ch));\n     if (ch != '\\0')\n       goto enoent;\n-    if (bits > 32)\n-      goto emsgsize;\n   }\n \n   /* Firey death and destruction unless we prefetched EOS. */\n@@ -173,7 +174,7 @@ inet_net_pton_ipv4(const char *src, unsigned char *dst, size_t size)\n       bits = 8;\n     /* If imputed mask is narrower than specified octets, widen. */\n     if (bits < ((dst - odst) * 8))\n-      bits = (int)(dst - odst) * 8;\n+      bits = aresx_sztosi(dst - odst) * 8;\n     /*\n      * If there are no additional bits specified for a class D\n      * address adjust bits to 4.\n@@ -216,7 +217,7 @@ getbits(const char *src, int *bitsp)\n       if (n++ != 0 && val == 0)       /* no leading zeros */\n         return (0);\n       val *= 10;\n-      val += (pch - digits);\n+      val += aresx_sztosi(pch - digits);\n       if (val > 128)                  /* range */\n         return (0);\n       continue;\n@@ -248,7 +249,7 @@ getv4(const char *src, unsigned char *dst, int *bitsp)\n       if (n++ != 0 && val == 0)       /* no leading zeros */\n         return (0);\n       val *= 10;\n-      val += (pch - digits);\n+      val += aresx_sztoui(pch - digits);\n       if (val > 255)                  /* range */\n         return (0);\n       continue;\n@@ -269,8 +270,8 @@ getv4(const char *src, unsigned char *dst, int *bitsp)\n     return (0);\n   if (dst - odst > 3)             /* too many octets? */\n     return (0);\n-  *dst++ = (unsigned char)val;\n-  return (1);\n+  *dst = (unsigned char)val;\n+  return 1;\n }\n \n static int\n@@ -308,7 +309,7 @@ inet_net_pton_ipv6(const char *src, unsigned char *dst, size_t size)\n       pch = strchr((xdigits = xdigits_u), ch);\n     if (pch != NULL) {\n       val <<= 4;\n-      val |= (pch - xdigits);\n+      val |= aresx_sztoui(pch - xdigits);\n       if (++digits > 4)\n         goto enoent;\n       saw_xdigit = 1;\n@@ -425,7 +426,7 @@ ares_inet_net_pton(int af, const char *src, void *dst, size_t size)\n   }\n }\n \n-#endif\n+#endif /* HAVE_INET_NET_PTON */\n \n #ifndef HAVE_INET_PTON\n int ares_inet_pton(int af, const char *src, void *dst)"}, {"sha": "5396a7f2a71001f6e4ca626d7eb9de0057ff4c3a", "filename": "src/rt/libuv/src/ares/inet_net_pton.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_net_pton.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_net_pton.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_net_pton.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -1,8 +1,7 @@\n-#ifndef __ARES_INET_NET_PTON_H\n-#define __ARES_INET_NET_PTON_H\n+#ifndef HEADER_CARES_INET_NET_PTON_H\n+#define HEADER_CARES_INET_NET_PTON_H\n \n-\n-/* Copyright (C) 2005 by Daniel Stenberg\n+/* Copyright (C) 2005-2010 by Daniel Stenberg et al\n  *\n  * Permission to use, copy, modify, and distribute this\n  * software and its documentation for any purpose and without\n@@ -22,10 +21,11 @@\n #else\n int ares_inet_pton(int af, const char *src, void *dst);\n #endif\n-#if defined(HAVE_INET_NET_PTON) && defined(HAVE_INET_NET_PTON_IPV6)\n+\n+#ifdef HAVE_INET_NET_PTON\n #define ares_inet_net_pton(w,x,y,z) inet_net_pton(w,x,y,z)\n #else\n int ares_inet_net_pton(int af, const char *src, void *dst, size_t size);\n #endif\n \n-#endif /* __ARES_INET_NET_PTON_H */\n+#endif /* HEADER_CARES_INET_NET_PTON_H */"}, {"sha": "57e1146b76c1df3ec000bc0f7ea51b12b3552e65", "filename": "src/rt/libuv/src/ares/inet_ntop.c", "status": "modified", "additions": 79, "deletions": 103, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_ntop.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_ntop.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_ntop.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -1,18 +1,18 @@\n-\n-/* Copyright (c) 1996 by Internet Software Consortium.\n+/*\n+ * Copyright (c) 2004 by Internet Systems Consortium, Inc. (\"ISC\")\n+ * Copyright (c) 1996-1999 by Internet Software Consortium.\n  *\n  * Permission to use, copy, modify, and distribute this software for any\n  * purpose with or without fee is hereby granted, provided that the above\n  * copyright notice and this permission notice appear in all copies.\n  *\n- * THE SOFTWARE IS PROVIDED \"AS IS\" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS\n- * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES\n- * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE\n- * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL\n- * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR\n- * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS\n- * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS\n- * SOFTWARE.\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND ISC DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT\n+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n  */\n \n #include \"ares_setup.h\"\n@@ -36,7 +36,6 @@\n #endif\n \n #include <ctype.h>\n-#include <errno.h>\n #include <stdio.h>\n #include <string.h>\n #include <stdlib.h>\n@@ -48,12 +47,6 @@\n \n #ifndef HAVE_INET_NTOP\n \n-#ifdef SPRINTF_CHAR\n-# define SPRINTF(x) strlen(sprintf/**/x)\n-#else\n-# define SPRINTF(x) ((size_t)sprintf x)\n-#endif\n-\n /*\n  * WARNING: Don't even consider trying to compile this on a system where\n  * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.\n@@ -68,32 +61,31 @@ static const char *inet_ntop6(const unsigned char *src, char *dst, size_t size);\n  * return:\n  *     pointer to presentation format address (`dst'), or NULL (see errno).\n  * note:\n- *      On Windows we store the error in the thread errno, not\n- *      in the winsock error code. This is to avoid loosing the\n- *      actual last winsock error. So use macro ERRNO to fetch the\n- *      errno this funtion sets when returning NULL, not SOCKERRNO.\n+ *     On Windows we store the error in the thread errno, not\n+ *     in the winsock error code. This is to avoid loosing the\n+ *     actual last winsock error. So use macro ERRNO to fetch the\n+ *     errno this funtion sets when returning NULL, not SOCKERRNO.\n  * author:\n  *     Paul Vixie, 1996.\n  */\n const char *\n ares_inet_ntop(int af, const void *src, char *dst, size_t size)\n {\n-  switch (af)\n-    {\n-    case AF_INET:\n-      return (inet_ntop4(src, dst, size));\n-    case AF_INET6:\n-      return (inet_ntop6(src, dst, size));\n-    default:\n-      SET_ERRNO(EAFNOSUPPORT);\n-      return (NULL);\n-    }\n+  switch (af) {\n+  case AF_INET:\n+    return (inet_ntop4(src, dst, size));\n+  case AF_INET6:\n+    return (inet_ntop6(src, dst, size));\n+  default:\n+    SET_ERRNO(EAFNOSUPPORT);\n+    return (NULL);\n+  }\n   /* NOTREACHED */\n }\n \n /* const char *\n  * inet_ntop4(src, dst, size)\n- *     format an IPv4 address, more or less like inet_ntoa()\n+ *     format an IPv4 address\n  * return:\n  *     `dst' (as a const)\n  * notes:\n@@ -106,22 +98,21 @@ static const char *\n inet_ntop4(const unsigned char *src, char *dst, size_t size)\n {\n   static const char fmt[] = \"%u.%u.%u.%u\";\n-  char tmp[sizeof \"255.255.255.255\"];\n+  char tmp[sizeof(\"255.255.255.255\")];\n \n-  if (SPRINTF((tmp, fmt, src[0], src[1], src[2], src[3])) > size)\n-    {\n-      SET_ERRNO(ENOSPC);\n-      return (NULL);\n-    }\n-    strcpy(dst, tmp);\n-    return (dst);\n+  if ((size_t)sprintf(tmp, fmt, src[0], src[1], src[2], src[3]) >= size) {\n+    SET_ERRNO(ENOSPC);\n+    return (NULL);\n+  }\n+  strcpy(dst, tmp);\n+  return (dst);\n }\n \n /* const char *\n  * inet_ntop6(src, dst, size)\n- *    convert IPv6 binary address into presentation (printable) format\n+ *     convert IPv6 binary address into presentation (printable) format\n  * author:\n- *    Paul Vixie, 1996.\n+ *     Paul Vixie, 1996.\n  */\n static const char *\n inet_ntop6(const unsigned char *src, char *dst, size_t size)\n@@ -135,11 +126,8 @@ inet_ntop6(const unsigned char *src, char *dst, size_t size)\n    */\n   char tmp[sizeof(\"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\")];\n   char *tp;\n-  struct {\n-    long base;\n-    long len;\n-  } best, cur;\n-  unsigned long words[NS_IN6ADDRSZ / NS_INT16SZ];\n+  struct { int base, len; } best, cur;\n+  unsigned int words[NS_IN6ADDRSZ / NS_INT16SZ];\n   int i;\n \n   /*\n@@ -149,84 +137,72 @@ inet_ntop6(const unsigned char *src, char *dst, size_t size)\n    */\n   memset(words, '\\0', sizeof(words));\n   for (i = 0; i < NS_IN6ADDRSZ; i++)\n-      words[i / 2] |= (src[i] << ((1 - (i % 2)) << 3));\n-\n+    words[i / 2] |= (src[i] << ((1 - (i % 2)) << 3));\n   best.base = -1;\n-  cur.base = -1;\n   best.len = 0;\n+  cur.base = -1;\n   cur.len = 0;\n-\n-  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++)\n-    {\n-      if (words[i] == 0)\n-        {\n-          if (cur.base == -1)\n-            cur.base = i, cur.len = 1;\n-          else\n-            cur.len++;\n-        }\n+  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {\n+    if (words[i] == 0) {\n+      if (cur.base == -1)\n+        cur.base = i, cur.len = 1;\n       else\n-        {\n-          if (cur.base != -1)\n-            {\n-              if (best.base == -1 || cur.len > best.len)\n-                best = cur;\n-              cur.base = -1;\n-            }\n-        }\n-    }\n-  if (cur.base != -1)\n-    {\n-      if (best.base == -1 || cur.len > best.len)\n-        best = cur;\n+        cur.len++;\n+    } else {\n+      if (cur.base != -1) {\n+        if (best.base == -1 || cur.len > best.len)\n+          best = cur;\n+        cur.base = -1;\n+      }\n     }\n+  }\n+  if (cur.base != -1) {\n+    if (best.base == -1 || cur.len > best.len)\n+      best = cur;\n+  }\n   if (best.base != -1 && best.len < 2)\n     best.base = -1;\n \n   /*\n    * Format the result.\n    */\n   tp = tmp;\n-  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++)\n-    {\n-      /* Are we inside the best run of 0x00's? */\n-      if (best.base != -1 && i >= best.base &&\n-          i < (best.base + best.len))\n-        {\n-          if (i == best.base)\n-             *tp++ = ':';\n-          continue;\n-        }\n-      /* Are we following an initial run of 0x00s or any real hex? */\n-      if (i != 0)\n+  for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {\n+    /* Are we inside the best run of 0x00's? */\n+    if (best.base != -1 && i >= best.base &&\n+        i < (best.base + best.len)) {\n+      if (i == best.base)\n         *tp++ = ':';\n-      /* Is this address an encapsulated IPv4? */\n-      if (i == 6 && best.base == 0 &&\n-          (best.len == 6 || (best.len == 5 && words[5] == 0xffff)))\n-        {\n-          if (!inet_ntop4(src+12, tp, sizeof(tmp) - (tp - tmp)))\n-            return (NULL);\n-          tp += strlen(tp);\n-          break;\n-        }\n-        tp += SPRINTF((tp, \"%lx\", words[i]));\n+      continue;\n     }\n-\n+    /* Are we following an initial run of 0x00s or any real hex? */\n+    if (i != 0)\n+      *tp++ = ':';\n+    /* Is this address an encapsulated IPv4? */\n+    if (i == 6 && best.base == 0 && (best.len == 6 ||\n+        (best.len == 7 && words[7] != 0x0001) ||\n+        (best.len == 5 && words[5] == 0xffff))) {\n+      if (!inet_ntop4(src+12, tp, sizeof(tmp) - (tp - tmp)))\n+        return (NULL);\n+      tp += strlen(tp);\n+      break;\n+    }\n+    tp += sprintf(tp, \"%x\", words[i]);\n+  }\n   /* Was it a trailing run of 0x00's? */\n-  if (best.base != -1 && (best.base + best.len) == (NS_IN6ADDRSZ / NS_INT16SZ))\n+  if (best.base != -1 && (best.base + best.len) == \n+      (NS_IN6ADDRSZ / NS_INT16SZ))\n     *tp++ = ':';\n   *tp++ = '\\0';\n \n   /*\n    * Check for overflow, copy, and we're done.\n    */\n-  if ((size_t)(tp - tmp) > size)\n-    {\n-      SET_ERRNO(ENOSPC);\n-      return (NULL);\n-    }\n+  if ((size_t)(tp - tmp) > size) {\n+    SET_ERRNO(ENOSPC);\n+    return (NULL);\n+  }\n   strcpy(dst, tmp);\n   return (dst);\n }\n #endif\n-"}, {"sha": "c583488f75e736f78cca93c8e13539de2a60e4a0", "filename": "src/rt/libuv/src/ares/inet_ntop.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_ntop.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_ntop.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_ntop.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -18,7 +18,6 @@\n  */\n \n #ifdef HAVE_INET_NTOP\n-#include <arpa/inet.h>\n #define ares_inet_ntop(w,x,y,z) inet_ntop(w,x,y,z)\n #else\n const char *ares_inet_ntop(int af, const void *src, char *dst, size_t size);"}, {"sha": "45f1e3eb80ade024134ab2be854a1bac2a48da06", "filename": "src/rt/libuv/src/ares/nameser.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fnameser.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fnameser.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fnameser.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -75,6 +75,11 @@ typedef enum __ns_type {\n     ns_t_sink = 40,         /* Kitchen sink (experimentatl) */\n     ns_t_opt = 41,          /* EDNS0 option (meta-RR) */\n     ns_t_apl = 42,          /* Address prefix list (RFC3123) */\n+    ns_t_ds = 43,           /* Delegation Signer (RFC4034) */\n+    ns_t_sshfp = 44,        /* SSH Key Fingerprint (RFC4255) */\n+    ns_t_rrsig = 46,        /* Resource Record Signature (RFC4034) */\n+    ns_t_nsec = 47,         /* Next Secure (RFC4034) */\n+    ns_t_dnskey = 48,       /* DNS Public Key (RFC4034) */\n     ns_t_tkey = 249,        /* Transaction key */\n     ns_t_tsig = 250,        /* Transaction signature. */\n     ns_t_ixfr = 251,        /* Incremental zone transfer. */\n@@ -181,6 +186,11 @@ typedef enum __ns_rcode {\n #define T_SRV           ns_t_srv\n #define T_ATMA          ns_t_atma\n #define T_NAPTR         ns_t_naptr\n+#define T_DS            ns_t_ds\n+#define T_SSHFP         ns_t_sshfp\n+#define T_RRSIG         ns_t_rrsig\n+#define T_NSEC          ns_t_nsec\n+#define T_DNSKEY        ns_t_dnskey\n #define T_TSIG          ns_t_tsig\n #define T_IXFR          ns_t_ixfr\n #define T_AXFR          ns_t_axfr"}, {"sha": "a333f54a7c0798eeb4215c6cc35fce9e99840c0a", "filename": "src/rt/libuv/src/ares/setup_once.h", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fsetup_once.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fsetup_once.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fsetup_once.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -2,7 +2,7 @@\n #define __SETUP_ONCE_H\n \n \n-/* Copyright (C) 2004 - 2010 by Daniel Stenberg et al\n+/* Copyright (C) 2004 - 2011 by Daniel Stenberg et al\n  *\n  * Permission to use, copy, modify, and distribute this software and its\n  * documentation for any purpose and without fee is hereby granted, provided\n@@ -35,7 +35,10 @@\n #include <string.h>\n #include <stdarg.h>\n #include <ctype.h>\n+\n+#ifdef HAVE_ERRNO_H\n #include <errno.h>\n+#endif\n \n #ifdef HAVE_SYS_TYPES_H\n #include <sys/types.h>\n@@ -248,6 +251,7 @@ struct timeval {\n #define ISPRINT(x)  (isprint((int)  ((unsigned char)x)))\n #define ISUPPER(x)  (isupper((int)  ((unsigned char)x)))\n #define ISLOWER(x)  (islower((int)  ((unsigned char)x)))\n+#define ISASCII(x)  (isascii((int)  ((unsigned char)x)))\n \n #define ISBLANK(x)  (int)((((unsigned char)x) == ' ') || \\\n                           (((unsigned char)x) == '\\t'))\n@@ -366,7 +370,7 @@ typedef int sig_atomic_t;\n  * (or equivalent) on this platform to hide platform details to code using it.\n  */\n \n-#ifdef WIN32\n+#if defined(WIN32) && !defined(WATT32)\n #define ERRNO         ((int)GetLastError())\n #define SET_ERRNO(x)  (SetLastError((DWORD)(x)))\n #else\n@@ -455,6 +459,18 @@ typedef int sig_atomic_t;\n #endif\n \n \n+/*\n+ *  System error codes for Windows CE\n+ */\n+\n+#if defined(WIN32) && !defined(HAVE_ERRNO_H)\n+#define ENOENT       ERROR_FILE_NOT_FOUND\n+#define ESRCH        ERROR_PATH_NOT_FOUND\n+#define ENOMEM       ERROR_NOT_ENOUGH_MEMORY\n+#define ENOSPC       ERROR_INVALID_PARAMETER\n+#endif\n+\n+\n /*\n  *  Actually use __32_getpwuid() on 64-bit VMS builds for getpwuid()\n  */"}, {"sha": "85cabac46ea626dabd4a6fa0097c981e0b3db0eb", "filename": "src/rt/libuv/src/unix/cares.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcares.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcares.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcares.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -67,6 +67,7 @@ static uv_ares_task_t* uv__ares_task_create(int fd) {\n \n   if (h == NULL) {\n     uv_fatal_error(ENOMEM, \"malloc\");\n+    return NULL;\n   }\n \n   h->sock = fd;\n@@ -146,7 +147,7 @@ int uv_ares_init_options(uv_loop_t* loop, ares_channel *channelptr,\n \n   /* only allow single init at a time */\n   if (loop->channel != NULL) {\n-    uv_err_new_artificial(loop, UV_EALREADY);\n+    uv__set_artificial_error(loop, UV_EALREADY);\n     return -1;\n   }\n "}, {"sha": "27e949e90b282a630f15cbfb607409fb7ea4ec98", "filename": "src/rt/libuv/src/unix/core.c", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcore.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcore.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcore.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -172,7 +172,7 @@ void uv_loop_delete(uv_loop_t* loop) {\n uv_loop_t* uv_default_loop() {\n   if (!default_loop_ptr) {\n     default_loop_ptr = &default_loop_struct;\n-#if defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED >= 1060\n+#if HAVE_KQUEUE\n     default_loop_struct.ev = ev_default_loop(EVBACKEND_KQUEUE);\n #else\n     default_loop_struct.ev = ev_default_loop(EVFLAG_AUTO);\n@@ -563,7 +563,7 @@ int uv_timer_stop(uv_timer_t* timer) {\n \n int uv_timer_again(uv_timer_t* timer) {\n   if (!ev_is_active(&timer->timer_watcher)) {\n-    uv_err_new(timer->loop, EINVAL);\n+    uv__set_sys_error(timer->loop, EINVAL);\n     return -1;\n   }\n \n@@ -595,7 +595,7 @@ static int uv_getaddrinfo_done(eio_req* req) {\n \n   if (handle->retcode != 0) {\n     /* TODO how to display gai error strings? */\n-    uv_err_new(handle->loop, handle->retcode);\n+    uv__set_sys_error(handle->loop, handle->retcode);\n   }\n \n   handle->cb(handle, handle->retcode, res);\n@@ -626,7 +626,7 @@ int uv_getaddrinfo(uv_loop_t* loop,\n \n   if (handle == NULL || cb == NULL ||\n       (hostname == NULL && service == NULL)) {\n-    uv_err_new_artificial(loop, UV_EINVAL);\n+    uv__set_artificial_error(loop, UV_EINVAL);\n     return -1;\n   }\n \n@@ -639,7 +639,7 @@ int uv_getaddrinfo(uv_loop_t* loop,\n \n   if (hints) {\n     handle->hints = malloc(sizeof(struct addrinfo));\n-    memcpy(&handle->hints, hints, sizeof(struct addrinfo));\n+    memcpy(handle->hints, hints, sizeof(struct addrinfo));\n   }\n   else {\n     handle->hints = NULL;\n@@ -667,7 +667,8 @@ int uv_getaddrinfo(uv_loop_t* loop,\n \n \n void uv_freeaddrinfo(struct addrinfo* ai) {\n-  freeaddrinfo(ai);\n+  if (ai)\n+    freeaddrinfo(ai);\n }\n \n \n@@ -790,10 +791,3 @@ size_t uv__strlcpy(char* dst, const char* src, size_t size) {\n \n   return src - org;\n }\n-\n-\n-uv_stream_t* uv_std_handle(uv_loop_t* loop, uv_std_type type) {\n-  assert(0 && \"implement me\");\n-  return NULL;\n-}\n-"}, {"sha": "2f0680a4b76af9626bff97f67bb27c6d050b5855", "filename": "src/rt/libuv/src/unix/cygwin.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcygwin.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcygwin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcygwin.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -36,6 +36,11 @@ uint64_t uv_hrtime() {\n   return (ts.tv_sec * NANOSEC + ts.tv_nsec);\n }\n \n+void uv_loadavg(double avg[3]) {\n+  /* Unsupported as of cygwin 1.7.7 */\n+  avg[0] = avg[1] = avg[2] = 0;\n+}\n+\n \n int uv_exepath(char* buffer, size_t* size) {\n   uint32_t usize;\n@@ -53,12 +58,19 @@ int uv_exepath(char* buffer, size_t* size) {\n   return 0;\n }\n \n+uint64_t uv_get_free_memory(void) {\n+  return (uint64_t) sysconf(_SC_PAGESIZE) * sysconf(_SC_AVPHYS_PAGES);\n+}\n+\n+uint64_t uv_get_total_memory(void) {\n+  return (uint64_t) sysconf(_SC_PAGESIZE) * sysconf(_SC_PHYS_PAGES);\n+}\n \n int uv_fs_event_init(uv_loop_t* loop,\n                      uv_fs_event_t* handle,\n                      const char* filename,\n                      uv_fs_event_cb cb) {\n-  uv_err_new(loop, ENOSYS);\n+  uv__set_sys_error(loop, ENOSYS);\n   return -1;\n }\n "}, {"sha": "675e0ad488a45bfb579362cfcecd148f9138abbb", "filename": "src/rt/libuv/src/unix/darwin.c", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fdarwin.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fdarwin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fdarwin.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -29,6 +29,9 @@\n #include <mach/mach.h>\n #include <mach/mach_time.h>\n #include <mach-o/dyld.h> /* _NSGetExecutablePath */\n+#include <sys/resource.h>\n+#include <sys/sysctl.h>\n+#include <unistd.h>  /* sysconf */\n \n \n uint64_t uv_hrtime() {\n@@ -68,16 +71,38 @@ int uv_exepath(char* buffer, size_t* size) {\n   return 0;\n }\n \n+uint64_t uv_get_free_memory(void) {\n+  vm_statistics_data_t info;\n+  mach_msg_type_number_t count = sizeof(info) / sizeof(integer_t);\n \n-int uv_fs_event_init(uv_loop_t* loop,\n-                     uv_fs_event_t* handle,\n-                     const char* filename,\n-                     uv_fs_event_cb cb) {\n-  uv_err_new(loop, ENOSYS);\n-  return -1;\n+  if (host_statistics(mach_host_self(), HOST_VM_INFO,\n+                      (host_info_t)&info, &count) != KERN_SUCCESS) {\n+    return -1;\n+  }\n+\n+  return (uint64_t) info.free_count * sysconf(_SC_PAGESIZE);\n+}\n+\n+uint64_t uv_get_total_memory(void) {\n+  uint64_t info;\n+  int which[] = {CTL_HW, HW_MEMSIZE};\n+  size_t size = sizeof(info);\n+\n+  if (sysctl(which, 2, &info, &size, NULL, 0) < 0) {\n+    return -1;\n+  }\n+\n+  return (uint64_t) info;\n }\n \n+void uv_loadavg(double avg[3]) {\n+  struct loadavg info;\n+  size_t size = sizeof(info);\n+  int which[] = {CTL_VM, VM_LOADAVG};\n+\n+  if (sysctl(which, 2, &info, &size, NULL, 0) < 0) return;\n \n-void uv__fs_event_destroy(uv_fs_event_t* handle) {\n-  assert(0 && \"implement me\");\n+  avg[0] = (double) info.ldavg[0] / info.fscale;\n+  avg[1] = (double) info.ldavg[1] / info.fscale;\n+  avg[2] = (double) info.ldavg[2] / info.fscale;\n }"}, {"sha": "a73b8a8830739736b32677b10a55b8424fa07802", "filename": "src/rt/libuv/src/unix/eio/config_openbsd.h", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_openbsd.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_openbsd.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_openbsd.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -0,0 +1,137 @@\n+/* config.h.  Generated from config.h.in by configure.  */\n+/* config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#define HAVE_DLFCN_H 1\n+\n+/* fallocate(2) is available */\n+/* #undef HAVE_FALLOCATE */\n+\n+/* fdatasync(2) is available */\n+/* #undef HAVE_FDATASYNC */\n+\n+/* futimes(2) is available */\n+#define HAVE_FUTIMES 1\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#define HAVE_INTTYPES_H 1\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#define HAVE_MEMORY_H 1\n+\n+/* posix_fadvise(2) is available */\n+/* #undef HAVE_POSIX_FADVISE */\n+\n+/* posix_madvise(2) is available */\n+#define HAVE_POSIX_MADVISE 1\n+\n+/* prctl(PR_SET_NAME) is available */\n+/* #undef HAVE_PRCTL_SET_NAME */\n+\n+/* pread(2) and pwrite(2) are available */\n+#define HAVE_PREADWRITE 1\n+\n+/* readahead(2) is available (linux) */\n+/* #undef HAVE_READAHEAD */\n+\n+/* sendfile(2) is available and supported */\n+/* #undef HAVE_SENDFILE */\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#define HAVE_STDINT_H 1\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#define HAVE_STDLIB_H 1\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#define HAVE_STRINGS_H 1\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#define HAVE_STRING_H 1\n+\n+/* sync_file_range(2) is available */\n+/* #undef HAVE_SYNC_FILE_RANGE */\n+\n+/* Define to 1 if you have the <sys/prctl.h> header file. */\n+/* #undef HAVE_SYS_PRCTL_H */\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#define HAVE_SYS_STAT_H 1\n+\n+/* syscall(__NR_syncfs) is available */\n+/* #undef HAVE_SYS_SYNCFS */\n+\n+/* Define to 1 if you have the <sys/syscall.h> header file. */\n+#define HAVE_SYS_SYSCALL_H 1\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#define HAVE_SYS_TYPES_H 1\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#define HAVE_UNISTD_H 1\n+\n+/* utimes(2) is available */\n+#define HAVE_UTIMES 1\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#define LT_OBJDIR \".libs/\"\n+\n+/* Name of package */\n+#define PACKAGE \"libeio\"\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#define PACKAGE_BUGREPORT \"\"\n+\n+/* Define to the full name of this package. */\n+#define PACKAGE_NAME \"\"\n+\n+/* Define to the full name and version of this package. */\n+#define PACKAGE_STRING \"\"\n+\n+/* Define to the one symbol short name of this package. */\n+#define PACKAGE_TARNAME \"\"\n+\n+/* Define to the home page for this package. */\n+#define PACKAGE_URL \"\"\n+\n+/* Define to the version of this package. */\n+#define PACKAGE_VERSION \"\"\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#define STDC_HEADERS 1\n+\n+/* Enable extensions on AIX 3, Interix.  */\n+#ifndef _ALL_SOURCE\n+# define _ALL_SOURCE 1\n+#endif\n+/* Enable GNU extensions on systems that have them.  */\n+#ifndef _GNU_SOURCE\n+# define _GNU_SOURCE 1\n+#endif\n+/* Enable threading extensions on Solaris.  */\n+#ifndef _POSIX_PTHREAD_SEMANTICS\n+# define _POSIX_PTHREAD_SEMANTICS 1\n+#endif\n+/* Enable extensions on HP NonStop.  */\n+#ifndef _TANDEM_SOURCE\n+# define _TANDEM_SOURCE 1\n+#endif\n+/* Enable general extensions on Solaris.  */\n+#ifndef __EXTENSIONS__\n+# define __EXTENSIONS__ 1\n+#endif\n+\n+\n+/* Version number of package */\n+#define VERSION \"1.0\"\n+\n+/* Define to 1 if on MINIX. */\n+/* #undef _MINIX */\n+\n+/* Define to 2 if the system does not provide POSIX.1 features except with\n+   this defined. */\n+/* #undef _POSIX_1_SOURCE */\n+\n+/* Define to 1 if you need to in order for `stat' and other things to work. */\n+/* #undef _POSIX_SOURCE */"}, {"sha": "546926fcb50065f7d8b6cd9ec034b782e3105f64", "filename": "src/rt/libuv/src/unix/eio/config_sunos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_sunos.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_sunos.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_sunos.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -11,7 +11,7 @@\n #define HAVE_UTIMES 1\n \n /* futimes(2) is available */\n-/* #undef HAVE_FUTIMES */\n+#define HAVE_FUTIMES 1\n \n /* Define to 1 if you have the <inttypes.h> header file. */\n #define HAVE_INTTYPES_H 1"}, {"sha": "2374006110d8d7be4eed7e7a7f02683845df6f28", "filename": "src/rt/libuv/src/unix/eio/eio.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Feio.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Feio.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Feio.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -108,6 +108,10 @@ static void eio_destroy (eio_req *req);\n \n #define EIO_ENOSYS() EIO_ERRNO (ENOSYS, -1)\n \n+#ifdef __sun\n+# define futimes(fd, times) futimesat (fd, NULL, times)\n+#endif\n+\n #ifdef _WIN32\n \n   #include <direct.h>"}, {"sha": "374e6eb29b04472bd0f2b85278cfaf86676ffa28", "filename": "src/rt/libuv/src/unix/error.c", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ferror.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ferror.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ferror.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -56,19 +56,37 @@ void uv_fatal_error(const int errorno, const char* syscall) {\n }\n \n \n-uv_err_t uv_last_error(uv_loop_t* loop) {\n-  return loop->last_err;\n-}\n-\n+static int uv__translate_lib_error(int code) {\n+  switch (code) {\n+    case UV_ENOSYS: return ENOSYS;\n+    case UV_ENOENT: return ENOENT;\n+    case UV_EACCESS: return EACCES;\n+    case UV_EBADF: return EBADF;\n+    case UV_EPIPE: return EPIPE;\n+    case UV_EAGAIN: return EAGAIN;\n+    case UV_ECONNRESET: return ECONNRESET;\n+    case UV_EFAULT: return EFAULT;\n+    case UV_EMFILE: return EMFILE;\n+    case UV_EMSGSIZE: return EMSGSIZE;\n+    case UV_EINVAL: return EINVAL;\n+    case UV_ECONNREFUSED: return ECONNREFUSED;\n+    case UV_EADDRINUSE: return EADDRINUSE;\n+    case UV_EADDRNOTAVAIL: return EADDRNOTAVAIL;\n+    case UV_ENOTDIR: return ENOTDIR;\n+    case UV_ENOTCONN: return ENOTCONN;\n+    case UV_EEXIST: return EEXIST;\n+    default: return -1;\n+  }\n \n-char* uv_strerror(uv_err_t err) {\n-  return strerror(err.sys_errno_);\n+  assert(0 && \"unreachable\");\n+  return -1;\n }\n \n \n uv_err_code uv_translate_sys_error(int sys_errno) {\n   switch (sys_errno) {\n     case 0: return UV_OK;\n+    case ENOSYS: return UV_ENOSYS;\n     case ENOENT: return UV_ENOENT;\n     case EACCES: return UV_EACCESS;\n     case EBADF: return UV_EBADF;\n@@ -82,8 +100,10 @@ uv_err_code uv_translate_sys_error(int sys_errno) {\n     case ECONNREFUSED: return UV_ECONNREFUSED;\n     case EADDRINUSE: return UV_EADDRINUSE;\n     case EADDRNOTAVAIL: return UV_EADDRNOTAVAIL;\n+    case ENOTDIR: return UV_ENOTDIR;\n     case ENOTCONN: return UV_ENOTCONN;\n     case EEXIST: return UV_EEXIST;\n+    case EAI_NONAME: return UV_ENOENT;\n     default: return UV_UNKNOWN;\n   }\n \n@@ -92,19 +112,20 @@ uv_err_code uv_translate_sys_error(int sys_errno) {\n }\n \n \n-uv_err_t uv_err_new_artificial(uv_loop_t* loop, int code) {\n-  uv_err_t err;\n-  err.sys_errno_ = 0;\n-  err.code = code;\n-  loop->last_err = err;\n-  return err;\n-}\n+/* TODO Pull in error messages so we don't have to\n+ *  a) rely on what the system provides us\n+ *  b) reverse-map the error codes\n+ */\n+char* uv_strerror(uv_err_t err) {\n+  int errorno;\n \n+  if (err.sys_errno_)\n+    errorno = err.sys_errno_;\n+  else\n+    errorno = uv__translate_lib_error(err.code);\n \n-uv_err_t uv_err_new(uv_loop_t* loop, int sys_error) {\n-  uv_err_t err;\n-  err.sys_errno_ = sys_error;\n-  err.code = uv_translate_sys_error(sys_error);\n-  loop->last_err = err;\n-  return err;\n+  if (errorno == -1)\n+    return \"Unknown error\";\n+  else\n+    return strerror(errorno);\n }"}, {"sha": "8bc9b89041f5a9c7650ff646695411a08744921b", "filename": "src/rt/libuv/src/unix/ev/config_openbsd.h", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_openbsd.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_openbsd.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_openbsd.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -0,0 +1,126 @@\n+/* config.h.  Generated from config.h.in by configure.  */\n+/* config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define to 1 if you have the `clock_gettime' function. */\n+#define HAVE_CLOCK_GETTIME 1\n+\n+/* \"use syscall interface for clock_gettime\" */\n+/* #undef HAVE_CLOCK_SYSCALL */\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#define HAVE_DLFCN_H 1\n+\n+/* Define to 1 if you have the `epoll_ctl' function. */\n+/* #undef HAVE_EPOLL_CTL */\n+\n+/* Define to 1 if you have the `eventfd' function. */\n+/* #undef HAVE_EVENTFD */\n+\n+/* Define to 1 if you have the `inotify_init' function. */\n+/* #undef HAVE_INOTIFY_INIT */\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#define HAVE_INTTYPES_H 1\n+\n+/* Define to 1 if you have the `kqueue' function. */\n+#define HAVE_KQUEUE 1\n+\n+/* Define to 1 if you have the `m' library (-lm). */\n+#define HAVE_LIBM 1\n+\n+/* Define to 1 if you have the `rt' library (-lrt). */\n+/* #undef HAVE_LIBRT */\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#define HAVE_MEMORY_H 1\n+\n+/* Define to 1 if you have the `nanosleep' function. */\n+#define HAVE_NANOSLEEP 1\n+\n+/* Define to 1 if you have the `poll' function. */\n+#define HAVE_POLL 1\n+\n+/* Define to 1 if you have the <poll.h> header file. */\n+#define HAVE_POLL_H 1\n+\n+/* Define to 1 if you have the `port_create' function. */\n+/* #undef HAVE_PORT_CREATE */\n+\n+/* Define to 1 if you have the <port.h> header file. */\n+/* #undef HAVE_PORT_H */\n+\n+/* Define to 1 if you have the `select' function. */\n+#define HAVE_SELECT 1\n+\n+/* Define to 1 if you have the `signalfd' function. */\n+/* #undef HAVE_SIGNALFD */\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#define HAVE_STDINT_H 1\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#define HAVE_STDLIB_H 1\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#define HAVE_STRINGS_H 1\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#define HAVE_STRING_H 1\n+\n+/* Define to 1 if you have the <sys/epoll.h> header file. */\n+/* #undef HAVE_SYS_EPOLL_H */\n+\n+/* Define to 1 if you have the <sys/eventfd.h> header file. */\n+/* #undef HAVE_SYS_EVENTFD_H */\n+\n+/* Define to 1 if you have the <sys/event.h> header file. */\n+#define HAVE_SYS_EVENT_H 1\n+\n+/* Define to 1 if you have the <sys/inotify.h> header file. */\n+/* #undef HAVE_SYS_INOTIFY_H */\n+\n+/* Define to 1 if you have the <sys/select.h> header file. */\n+#define HAVE_SYS_SELECT_H 1\n+\n+/* Define to 1 if you have the <sys/signalfd.h> header file. */\n+/* #undef HAVE_SYS_SIGNALFD_H */\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#define HAVE_SYS_STAT_H 1\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#define HAVE_SYS_TYPES_H 1\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#define HAVE_UNISTD_H 1\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#define LT_OBJDIR \".libs/\"\n+\n+/* Name of package */\n+#define PACKAGE \"libev\"\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#define PACKAGE_BUGREPORT \"\"\n+\n+/* Define to the full name of this package. */\n+#define PACKAGE_NAME \"\"\n+\n+/* Define to the full name and version of this package. */\n+#define PACKAGE_STRING \"\"\n+\n+/* Define to the one symbol short name of this package. */\n+#define PACKAGE_TARNAME \"\"\n+\n+/* Define to the home page for this package. */\n+#define PACKAGE_URL \"\"\n+\n+/* Define to the version of this package. */\n+#define PACKAGE_VERSION \"\"\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#define STDC_HEADERS 1\n+\n+/* Version number of package */\n+#define VERSION \"4.04\""}, {"sha": "a3bec43fbec9c815ba17f627a84d586802021516", "filename": "src/rt/libuv/src/unix/ev/ev.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -2663,7 +2663,8 @@ ev_io_start (EV_P_ ev_io *w)\n     return;\n \n   assert ((\"libev: ev_io_start called with negative fd\", fd >= 0));\n-  assert ((\"libev: ev_io_start called with illegal event mask\", !(w->events & ~(EV__IOFDSET | EV_READ | EV_WRITE))));\n+  assert ((\"libev: ev_io_start called with illegal event mask\",\n+      !(w->events & ~(EV__IOFDSET | EV_READ | EV_WRITE | EV_LIBUV_KQUEUE_HACK))));\n \n   EV_FREQUENT_CHECK;\n "}, {"sha": "212ca29ae643e7843c36d1b643771d29d3791a55", "filename": "src/rt/libuv/src/unix/ev/ev_kqueue.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_kqueue.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_kqueue.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_kqueue.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -43,6 +43,9 @@\n #include <string.h>\n #include <errno.h>\n \n+extern void\n+uv__kqueue_hack (EV_P_ int fflags, ev_io *w);\n+\n void inline_speed\n kqueue_change (EV_P_ int fd, int filter, int flags, int fflags)\n {\n@@ -80,6 +83,10 @@ kqueue_modify (EV_P_ int fd, int oev, int nev)\n \n   if (nev & EV_WRITE)\n     kqueue_change (EV_A_ fd, EVFILT_WRITE, EV_ADD | EV_ENABLE, NOTE_EOF);\n+\n+  if (nev & EV_LIBUV_KQUEUE_HACK)\n+    kqueue_change (EV_A_ fd, EVFILT_VNODE, EV_ADD | EV_ENABLE | EV_ONESHOT,\n+      NOTE_ATTRIB | NOTE_WRITE | NOTE_RENAME | NOTE_DELETE | NOTE_EXTEND | NOTE_REVOKE);\n }\n \n static void\n@@ -114,6 +121,13 @@ kqueue_poll (EV_P_ ev_tstamp timeout)\n     {\n       int fd = kqueue_events [i].ident;\n \n+      if (kqueue_events [i].filter == EVFILT_VNODE)\n+        {\n+          /* pass kqueue filter flags to libuv */\n+          ev_io *w = (ev_io *)(anfds [fd].head);\n+          uv__kqueue_hack (EV_A_ kqueue_events [i].fflags, w);\n+        }\n+\n       if (expect_false (kqueue_events [i].flags & EV_ERROR))\n         {\n           int err = kqueue_events [i].data;\n@@ -140,6 +154,7 @@ kqueue_poll (EV_P_ ev_tstamp timeout)\n           fd,\n           kqueue_events [i].filter == EVFILT_READ ? EV_READ\n           : kqueue_events [i].filter == EVFILT_WRITE ? EV_WRITE\n+          : kqueue_events [i].filter == EVFILT_VNODE ? EV_LIBUV_KQUEUE_HACK\n           : 0\n         );\n     }"}, {"sha": "cd14d22669fcb69aee1ce4d657a7daa5db350131", "filename": "src/rt/libuv/src/unix/freebsd.c", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ffreebsd.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ffreebsd.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ffreebsd.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -25,8 +25,11 @@\n #include <errno.h>\n \n #include <sys/types.h>\n+#include <sys/resource.h>\n #include <sys/sysctl.h>\n+#include <vm/vm_param.h> /* VM_LOADAVG */\n #include <time.h>\n+#include <unistd.h> /* sysconf */\n \n #undef NANOSEC\n #define NANOSEC 1000000000\n@@ -67,16 +70,39 @@ int uv_exepath(char* buffer, size_t* size) {\n   return 0;\n }\n \n+uint64_t uv_get_free_memory(void) {\n+  int freecount;\n+  size_t size = sizeof(freecount);\n+\n+  if(sysctlbyname(\"vm.stats.vm.v_free_count\",\n+                  &freecount, &size, NULL, 0) == -1){\n+    return -1;\n+  }\n+  return (uint64_t) freecount * sysconf(_SC_PAGESIZE);\n \n-int uv_fs_event_init(uv_loop_t* loop,\n-                     uv_fs_event_t* handle,\n-                     const char* filename,\n-                     uv_fs_event_cb cb) {\n-  uv_err_new(loop, ENOSYS);\n-  return -1;\n }\n \n+uint64_t uv_get_total_memory(void) {\n+  unsigned long info;\n+  int which[] = {CTL_HW, HW_PHYSMEM};\n+\n+  size_t size = sizeof(info);\n+\n+  if (sysctl(which, 2, &info, &size, NULL, 0) < 0) {\n+    return -1;\n+  }\n+\n+  return (uint64_t) info;\n+}\n+\n+void uv_loadavg(double avg[3]) {\n+  struct loadavg info;\n+  size_t size = sizeof(info);\n+  int which[] = {CTL_VM, VM_LOADAVG};\n+\n+  if (sysctl(which, 2, &info, &size, NULL, 0) < 0) return;\n \n-void uv__fs_event_destroy(uv_fs_event_t* handle) {\n-  assert(0 && \"implement me\");\n+  avg[0] = (double) info.ldavg[0] / info.fscale;\n+  avg[1] = (double) info.ldavg[1] / info.fscale;\n+  avg[2] = (double) info.ldavg[2] / info.fscale;\n }"}, {"sha": "57664c83c024aa88898876c2342de8233941e5cf", "filename": "src/rt/libuv/src/unix/fs.c", "status": "modified", "additions": 51, "deletions": 45, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ffs.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ffs.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ffs.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -46,15 +46,15 @@\n     /* async */ \\\n     req->eio = eiofunc(args, EIO_PRI_DEFAULT, uv__fs_after, req); \\\n     if (!req->eio) { \\\n-      uv_err_new(loop, ENOMEM); \\\n+      uv__set_sys_error(loop, ENOMEM); \\\n       return -1; \\\n     } \\\n     uv_ref(loop); \\\n   } else { \\\n     /* sync */ \\\n     req->result = func(args); \\\n     if (req->result) { \\\n-      uv_err_new(loop, errno); \\\n+      uv__set_sys_error(loop, errno); \\\n     }  \\\n     return req->result; \\\n   } \\\n@@ -85,8 +85,7 @@ void uv_fs_req_cleanup(uv_fs_t* req) {\n \n   switch (req->fs_type) {\n     case UV_FS_READDIR:\n-      assert((req->result == -1 && req->ptr == NULL)\n-          || (req->result >= 0 && req->ptr != NULL));\n+      assert(req->result > 0 ? (req->ptr != NULL) : (req->ptr == NULL));\n       free(req->ptr);\n       req->ptr = NULL;\n       break;\n@@ -116,9 +115,6 @@ static int uv__fs_after(eio_req* eio) {\n \n   switch (req->fs_type) {\n     case UV_FS_READDIR:\n-      if (req->eio->result == -1)\n-        break; /* opendir() or readdir() operation failed. */\n-\n       /*\n        * XXX This is pretty bad.\n        * We alloc and copy the large null terminated string list from libeio.\n@@ -128,16 +124,21 @@ static int uv__fs_after(eio_req* eio) {\n        */\n       buflen = 0;\n       name = req->eio->ptr2;\n+\n       for (i = 0; i < req->result; i++) {\n         namelen = strlen(name);\n         buflen += namelen + 1;\n-        /* TODO check ENOMEM */\n         name += namelen;\n         assert(*name == '\\0');\n         name++;\n       }\n-      req->ptr = malloc(buflen);\n-      memcpy(req->ptr, req->eio->ptr2, buflen);\n+\n+      if (buflen) {\n+        if ((req->ptr = malloc(buflen)))\n+          memcpy(req->ptr, req->eio->ptr2, buflen);\n+        else\n+          uv__set_sys_error(req->loop, ENOMEM);\n+      }\n       break;\n \n     case UV_FS_STAT:\n@@ -149,19 +150,20 @@ static int uv__fs_after(eio_req* eio) {\n     case UV_FS_READLINK:\n       if (req->result == -1) {\n         req->ptr = NULL;\n-      } else {\n-        assert(req->result > 0);\n-\n-        if ((name = realloc(req->eio->ptr2, req->result + 1)) == NULL) {\n-          /* Not enough memory. Reuse buffer, chop off last byte. */\n-          name = req->eio->ptr2;\n-          req->result--;\n-        }\n+        break;\n+      }\n+      assert(req->result > 0);\n \n+      /* Make zero-terminated copy of req->eio->ptr2 */\n+      if ((req->ptr = name = malloc(req->result + 1))) {\n+        memcpy(name, req->eio->ptr2, req->result);\n         name[req->result] = '\\0';\n-        req->ptr = name;\n         req->result = 0;\n       }\n+      else {\n+        req->errorno = ENOMEM;\n+        req->result = -1;\n+      }\n       break;\n \n     default:\n@@ -191,15 +193,15 @@ int uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,\n     uv_ref(loop);\n     req->eio = eio_open(path, flags, mode, EIO_PRI_DEFAULT, uv__fs_after, req);\n     if (!req->eio) {\n-      uv_err_new(loop, ENOMEM);\n+      uv__set_sys_error(loop, ENOMEM);\n       return -1;\n     }\n \n   } else {\n     /* sync */\n     req->result = open(path, flags, mode);\n     if (req->result < 0) {\n-      uv_err_new(loop, errno);\n+      uv__set_sys_error(loop, errno);\n       return -1;\n     }\n \n@@ -223,7 +225,7 @@ int uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file fd, void* buf,\n         uv__fs_after, req);\n \n     if (!req->eio) {\n-      uv_err_new(loop, ENOMEM);\n+      uv__set_sys_error(loop, ENOMEM);\n       return -1;\n     }\n \n@@ -234,7 +236,7 @@ int uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file fd, void* buf,\n       pread(fd, buf, length, offset);\n \n     if (req->result < 0) {\n-      uv_err_new(loop, errno);\n+      uv__set_sys_error(loop, errno);\n       return -1;\n     }\n \n@@ -260,7 +262,7 @@ int uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file file, void* buf,\n     req->eio = eio_write(file, buf, length, offset, EIO_PRI_DEFAULT,\n         uv__fs_after, req);\n     if (!req->eio) {\n-      uv_err_new(loop, ENOMEM);\n+      uv__set_sys_error(loop, ENOMEM);\n       return -1;\n     }\n \n@@ -271,7 +273,7 @@ int uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file file, void* buf,\n         pwrite(file, buf, length, offset);\n \n     if (req->result < 0) {\n-      uv_err_new(loop, errno);\n+      uv__set_sys_error(loop, errno);\n       return -1;\n     }\n \n@@ -307,15 +309,15 @@ int uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,\n     uv_ref(loop);\n     req->eio = eio_readdir(path, flags, EIO_PRI_DEFAULT, uv__fs_after, req);\n     if (!req->eio) {\n-      uv_err_new(loop, ENOMEM);\n+      uv__set_sys_error(loop, ENOMEM);\n       return -1;\n     }\n \n   } else {\n     /* sync */\n     DIR* dir = opendir(path);\n     if (!dir) {\n-      uv_err_new(loop, errno);\n+      uv__set_sys_error(loop, errno);\n       req->result = -1;\n       return -1;\n     }\n@@ -344,7 +346,7 @@ int uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,\n \n     r = closedir(dir);\n     if (r) {\n-      uv_err_new(loop, errno);\n+      uv__set_sys_error(loop, errno);\n       req->result = -1;\n       return -1;\n     }\n@@ -380,7 +382,7 @@ int uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n     free(pathdup);\n \n     if (!req->eio) {\n-      uv_err_new(loop, ENOMEM);\n+      uv__set_sys_error(loop, ENOMEM);\n       return -1;\n     }\n \n@@ -391,7 +393,7 @@ int uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n     free(pathdup);\n \n     if (req->result < 0) {\n-      uv_err_new(loop, errno);\n+      uv__set_sys_error(loop, errno);\n       return -1;\n     }\n \n@@ -412,7 +414,7 @@ int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n     req->eio = eio_fstat(file, EIO_PRI_DEFAULT, uv__fs_after, req);\n \n     if (!req->eio) {\n-      uv_err_new(loop, ENOMEM);\n+      uv__set_sys_error(loop, ENOMEM);\n       return -1;\n     }\n \n@@ -421,7 +423,7 @@ int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n     req->result = fstat(file, &req->statbuf);\n \n     if (req->result < 0) {\n-      uv_err_new(loop, errno);\n+      uv__set_sys_error(loop, errno);\n       return -1;\n     }\n \n@@ -447,8 +449,11 @@ int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n \n int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n   char* path = NULL;\n-#ifdef __FreeBSD__\n-  /* freebsd doesn't have fdatasync, do a full fsync instead. */\n+#if defined(__FreeBSD__) \\\n+  || (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ < 1060)\n+  /* freebsd and pre-10.6 darwin don't have fdatasync,\n+   * do a full fsync instead.\n+   */\n   WRAP_EIO(UV_FS_FDATASYNC, eio_fdatasync, fsync, ARGS1(file))\n #else\n   WRAP_EIO(UV_FS_FDATASYNC, eio_fdatasync, fdatasync, ARGS1(file))\n@@ -491,7 +496,7 @@ int uv_fs_utime(uv_loop_t* loop, uv_fs_t* req, const char* path, double atime,\n }\n \n \n-#if defined(HAVE_FUTIMES)\n+#if HAVE_FUTIMES\n static int _futime(const uv_file file, double atime, double mtime) {\n   struct timeval tv[2];\n \n@@ -502,21 +507,25 @@ static int _futime(const uv_file file, double atime, double mtime) {\n   tv[1].tv_sec = mtime;\n   tv[1].tv_usec = (unsigned long)(mtime * 1000000) % 1000000;\n \n+#ifdef __sun\n+  return futimesat(file, NULL, tv);\n+#else\n   return futimes(file, tv);\n+#endif\n }\n #endif\n \n \n int uv_fs_futime(uv_loop_t* loop, uv_fs_t* req, uv_file file, double atime,\n     double mtime, uv_fs_cb cb) {\n-#if defined(HAVE_FUTIMES)\n+#if HAVE_FUTIMES\n   const char* path = NULL;\n \n   uv_fs_req_init(loop, req, UV_FS_FUTIME, path, cb);\n \n   WRAP_EIO(UV_FS_FUTIME, eio_futime, _futime, ARGS3(file, atime, mtime))\n #else\n-  uv_err_new(loop, ENOSYS);\n+  uv__set_sys_error(loop, ENOSYS);\n   return -1;\n #endif\n }\n@@ -546,7 +555,7 @@ int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n     free(pathdup);\n \n     if (!req->eio) {\n-      uv_err_new(loop, ENOMEM);\n+      uv__set_sys_error(loop, ENOMEM);\n       return -1;\n     }\n \n@@ -557,7 +566,7 @@ int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n     free(pathdup);\n \n     if (req->result < 0) {\n-      uv_err_new(loop, errno);\n+      uv__set_sys_error(loop, errno);\n       return -1;\n     }\n \n@@ -584,19 +593,16 @@ int uv_fs_symlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n int uv_fs_readlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n     uv_fs_cb cb) {\n   ssize_t size;\n-  int status;\n   char* buf;\n \n-  status = -1;\n-\n   uv_fs_req_init(loop, req, UV_FS_READLINK, path, cb);\n \n   if (cb) {\n     if ((req->eio = eio_readlink(path, EIO_PRI_DEFAULT, uv__fs_after, req))) {\n       uv_ref(loop);\n       return 0;\n     } else {\n-      uv_err_new(loop, ENOMEM);\n+      uv__set_sys_error(loop, ENOMEM);\n       return -1;\n     }\n   } else {\n@@ -612,7 +618,7 @@ int uv_fs_readlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n     }\n \n     if ((buf = malloc(size + 1)) == NULL) {\n-      uv_err_new(loop, ENOMEM);\n+      uv__set_sys_error(loop, ENOMEM);\n       return -1;\n     }\n \n@@ -689,7 +695,7 @@ int uv_queue_work(uv_loop_t* loop, uv_work_t* req, uv_work_cb work_cb,\n   req->eio = eio_custom(uv__work, EIO_PRI_DEFAULT, uv__after_work, req);\n \n   if (!req->eio) {\n-    uv_err_new(loop, ENOMEM);\n+    uv__set_sys_error(loop, ENOMEM);\n     return -1;\n   }\n "}, {"sha": "0ab8ba9579f1e55c300e0abed4f075bbdbe6cd0e", "filename": "src/rt/libuv/src/unix/internal.h", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Finternal.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Finternal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Finternal.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -32,33 +32,33 @@\n #include <linux/version.h>\n #include <features.h>\n \n-#undef HAVE_FUTIMES\n-#undef HAVE_PIPE2\n-#undef HAVE_ACCEPT4\n-\n /* futimes() requires linux >= 2.6.22 and glib >= 2.6 */\n #if LINUX_VERSION_CODE >= 0x20616 && __GLIBC_PREREQ(2, 6)\n-#define HAVE_FUTIMES\n+#define HAVE_FUTIMES 1\n #endif\n \n /* pipe2() requires linux >= 2.6.27 and glibc >= 2.9 */\n #if LINUX_VERSION_CODE >= 0x2061B && __GLIBC_PREREQ(2, 9)\n-#define HAVE_PIPE2\n+#define HAVE_PIPE2 1\n #endif\n \n /* accept4() requires linux >= 2.6.28 and glib >= 2.10 */\n #if LINUX_VERSION_CODE >= 0x2061C && __GLIBC_PREREQ(2, 10)\n-#define HAVE_ACCEPT4\n+#define HAVE_ACCEPT4 1\n #endif\n \n #endif /* __linux__ */\n \n-#ifdef __APPLE__\n-# define HAVE_FUTIMES\n+#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__sun)\n+# define HAVE_FUTIMES 1\n #endif\n \n-#ifdef __FreeBSD__\n-# define HAVE_FUTIMES\n+/* FIXME exact copy of the #ifdef guard in uv-unix.h */\n+#if (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED >= 1060) \\\n+  || defined(__FreeBSD__) \\\n+  || defined(__OpenBSD__) \\\n+  || defined(__NetBSD__)\n+# define HAVE_KQUEUE 1\n #endif\n \n #define container_of(ptr, type, member) \\\n@@ -74,13 +74,15 @@\n \n /* flags */\n enum {\n-  UV_CLOSING  = 0x00000001, /* uv_close() called but not finished. */\n-  UV_CLOSED   = 0x00000002, /* close(2) finished. */\n-  UV_READING  = 0x00000004, /* uv_read_start() called. */\n-  UV_SHUTTING = 0x00000008, /* uv_shutdown() called but not complete. */\n-  UV_SHUT     = 0x00000010, /* Write side closed. */\n-  UV_READABLE = 0x00000020, /* The stream is readable */\n-  UV_WRITABLE = 0x00000040  /* The stream is writable */\n+  UV_CLOSING       = 0x01,   /* uv_close() called but not finished. */\n+  UV_CLOSED        = 0x02,   /* close(2) finished. */\n+  UV_READING       = 0x04,   /* uv_read_start() called. */\n+  UV_SHUTTING      = 0x08,   /* uv_shutdown() called but not complete. */\n+  UV_SHUT          = 0x10,   /* Write side closed. */\n+  UV_READABLE      = 0x20,   /* The stream is readable */\n+  UV_WRITABLE      = 0x40,   /* The stream is writable */\n+  UV_TCP_NODELAY   = 0x080,  /* Disable Nagle. */\n+  UV_TCP_KEEPALIVE = 0x100   /* Turn on keep-alive. */\n };\n \n size_t uv__strlcpy(char* dst, const char* src, size_t size);\n@@ -96,8 +98,6 @@ int uv__socket(int domain, int type, int protocol);\n \n /* error */\n uv_err_code uv_translate_sys_error(int sys_errno);\n-uv_err_t uv_err_new(uv_loop_t* loop, int sys_error);\n-uv_err_t uv_err_new_artificial(uv_loop_t* loop, int code);\n void uv_fatal_error(const int errorno, const char* syscall);\n \n /* stream */\n@@ -113,6 +113,8 @@ int uv__connect(uv_connect_t* req, uv_stream_t* stream, struct sockaddr* addr,\n \n /* tcp */\n int uv_tcp_listen(uv_tcp_t* tcp, int backlog, uv_connection_cb cb);\n+int uv__tcp_nodelay(uv_tcp_t* handle, int enable);\n+int uv__tcp_keepalive(uv_tcp_t* handle, int enable, unsigned int delay);\n \n /* pipe */\n int uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb);"}, {"sha": "c2cb7194aab5767db6fa44bc4bdb1ebf431c8ebb", "filename": "src/rt/libuv/src/unix/kqueue.c", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fkqueue.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fkqueue.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fkqueue.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -0,0 +1,141 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"internal.h\"\n+\n+#include <assert.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <errno.h>\n+\n+#if HAVE_KQUEUE\n+\n+#include <sys/sysctl.h>\n+#include <sys/types.h>\n+#include <sys/event.h>\n+#include <fcntl.h>\n+#include <time.h>\n+\n+static void uv__fs_event(EV_P_ ev_io* w, int revents);\n+\n+\n+static void uv__fs_event_start(uv_fs_event_t* handle) {\n+  ev_io_init(&handle->event_watcher,\n+             uv__fs_event,\n+             handle->fd,\n+             EV_LIBUV_KQUEUE_HACK);\n+  ev_io_start(handle->loop->ev, &handle->event_watcher);\n+}\n+\n+\n+static void uv__fs_event_stop(uv_fs_event_t* handle) {\n+  ev_io_stop(handle->loop->ev, &handle->event_watcher);\n+}\n+\n+\n+static void uv__fs_event(EV_P_ ev_io* w, int revents) {\n+  uv_fs_event_t* handle;\n+  int events;\n+\n+  assert(revents == EV_LIBUV_KQUEUE_HACK);\n+\n+  handle = container_of(w, uv_fs_event_t, event_watcher);\n+\n+  if (handle->fflags & (NOTE_ATTRIB | NOTE_EXTEND))\n+    events = UV_CHANGE;\n+  else\n+    events = UV_RENAME;\n+\n+  handle->cb(handle, NULL, events, 0);\n+\n+  uv__fs_event_stop(handle);\n+\n+  /* File watcher operates in one-shot mode, re-arm it. */\n+  if (handle->fd != -1)\n+    uv__fs_event_start(handle);\n+}\n+\n+\n+/* Called by libev, don't touch. */\n+void uv__kqueue_hack(EV_P_ int fflags, ev_io *w) {\n+  uv_fs_event_t* handle;\n+\n+  handle = container_of(w, uv_fs_event_t, event_watcher);\n+  handle->fflags = fflags;\n+}\n+\n+\n+int uv_fs_event_init(uv_loop_t* loop,\n+                     uv_fs_event_t* handle,\n+                     const char* filename,\n+                     uv_fs_event_cb cb) {\n+  int fd;\n+\n+  if (cb == NULL) {\n+    uv__set_sys_error(loop, EINVAL);\n+    return -1;\n+  }\n+\n+  /* TODO open asynchronously - but how do we report back errors? */\n+  if ((fd = open(filename, O_RDONLY)) == -1) {\n+    uv__set_sys_error(loop, errno);\n+    return -1;\n+  }\n+\n+  uv__handle_init(loop, (uv_handle_t*)handle, UV_FS_EVENT);\n+  handle->filename = strdup(filename);\n+  handle->fflags = 0;\n+  handle->cb = cb;\n+  handle->fd = fd;\n+  uv__fs_event_start(handle);\n+\n+  return 0;\n+}\n+\n+\n+void uv__fs_event_destroy(uv_fs_event_t* handle) {\n+  free(handle->filename);\n+  uv__close(handle->fd);\n+  handle->fd = -1;\n+}\n+\n+#else /* !HAVE_KQUEUE */\n+\n+int uv_fs_event_init(uv_loop_t* loop,\n+                     uv_fs_event_t* handle,\n+                     const char* filename,\n+                     uv_fs_event_cb cb) {\n+  uv__set_sys_error(loop, ENOSYS);\n+  return -1;\n+}\n+\n+\n+void uv__fs_event_destroy(uv_fs_event_t* handle) {\n+  assert(0 && \"unreachable\");\n+}\n+\n+\n+/* Called by libev, don't touch. */\n+void uv__kqueue_hack(EV_P_ int fflags, ev_io *w) {\n+  assert(0 && \"unreachable\");\n+}\n+\n+#endif /* HAVE_KQUEUE */"}, {"sha": "e7ca1840f200d19030c9fe70df5f819b1b75fe9e", "filename": "src/rt/libuv/src/unix/linux.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Flinux.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Flinux.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Flinux.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -28,6 +28,7 @@\n #include <errno.h>\n \n #include <sys/inotify.h>\n+#include <sys/sysinfo.h>\n #include <unistd.h>\n #include <time.h>\n \n@@ -52,6 +53,16 @@ uint64_t uv_hrtime() {\n   return (ts.tv_sec * NANOSEC + ts.tv_nsec);\n }\n \n+void uv_loadavg(double avg[3]) {\n+  struct sysinfo info;\n+\n+  if (sysinfo(&info) < 0) return;\n+\n+  avg[0] = (double) info.loads[0] / 65536.0;\n+  avg[1] = (double) info.loads[1] / 65536.0;\n+  avg[2] = (double) info.loads[2] / 65536.0;\n+}\n+\n \n int uv_exepath(char* buffer, size_t* size) {\n   if (!buffer || !size) {\n@@ -64,6 +75,13 @@ int uv_exepath(char* buffer, size_t* size) {\n   return 0;\n }\n \n+uint64_t uv_get_free_memory(void) {\n+  return (uint64_t) sysconf(_SC_PAGESIZE) * sysconf(_SC_AVPHYS_PAGES);\n+}\n+\n+uint64_t uv_get_total_memory(void) {\n+  return (uint64_t) sysconf(_SC_PAGESIZE) * sysconf(_SC_PHYS_PAGES);\n+}\n \n static int new_inotify_fd(void) {\n #if defined(IN_NONBLOCK) && defined(IN_CLOEXEC)\n@@ -126,6 +144,9 @@ static void uv__inotify_read(EV_P_ ev_io* w, int revents) {\n       filename = e->len ? e->name : basename_r(handle->filename);\n \n       handle->cb(handle, filename, events, 0);\n+\n+      if (handle->fd == -1)\n+        break;\n     }\n   }\n   while (handle->fd != -1); /* handle might've been closed by callback */\n@@ -145,7 +166,7 @@ int uv_fs_event_init(uv_loop_t* loop,\n    * keep creating new inotify fds.\n    */\n   if ((fd = new_inotify_fd()) == -1) {\n-    uv_err_new(loop, errno);\n+    uv__set_sys_error(loop, errno);\n     return -1;\n   }\n \n@@ -158,7 +179,7 @@ int uv_fs_event_init(uv_loop_t* loop,\n         | IN_MOVED_TO;\n \n   if (inotify_add_watch(fd, filename, flags) == -1) {\n-    uv_err_new(loop, errno);\n+    uv__set_sys_error(loop, errno);\n     uv__close(fd);\n     return -1;\n   }\n@@ -180,4 +201,5 @@ void uv__fs_event_destroy(uv_fs_event_t* handle) {\n   uv__close(handle->fd);\n   handle->fd = -1;\n   free(handle->filename);\n+  handle->filename = NULL;\n }"}, {"sha": "8b91f65c74ac5980bd7e609bc090fb8ff806ca9f", "filename": "src/rt/libuv/src/unix/netbsd.c", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fnetbsd.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fnetbsd.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fnetbsd.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -24,6 +24,7 @@\n #include <string.h>\n #include <errno.h>\n \n+#include <sys/resource.h>\n #include <sys/types.h>\n #include <sys/sysctl.h>\n \n@@ -40,6 +41,17 @@ uint64_t uv_hrtime(void) {\n   return (ts.tv_sec * NANOSEC + ts.tv_nsec);\n }\n \n+void uv_loadavg(double avg[3]) {\n+  struct loadavg info;\n+  size_t size = sizeof(info);\n+  int which[] = {CTL_VM, VM_LOADAVG};\n+\n+  if (sysctl(which, 2, &info, &size, NULL, 0) < 0) return;\n+\n+  avg[0] = (double) info.ldavg[0] / info.fscale;\n+  avg[1] = (double) info.ldavg[1] / info.fscale;\n+  avg[2] = (double) info.ldavg[2] / info.fscale;\n+}\n \n int uv_exepath(char* buffer, size_t* size) {\n   uint32_t usize;\n@@ -70,16 +82,31 @@ int uv_exepath(char* buffer, size_t* size) {\n   return 0;\n }\n \n+uint64_t uv_get_free_memory(void) {\n+  struct uvmexp info;\n+  size_t size = sizeof(info);\n+  int which[] = {CTL_VM, VM_UVMEXP};\n+\n+  if (sysctl(which, 2, &info, &size, NULL, 0) < 0) {\n+    return -1;\n+  }\n \n-int uv_fs_event_init(uv_loop_t* loop,\n-                     uv_fs_event_t* handle,\n-                     const char* filename,\n-                     uv_fs_event_cb cb) {\n-  uv_err_new(loop, ENOSYS);\n-  return -1;\n+  return (uint64_t) info.free * psysconf(_SC_PAGESIZE);\n }\n \n+uint64_t uv_get_total_memory(void) {\n+#if defined(HW_PHYSMEM64)\n+  uint64_t info;\n+  int which[] = {CTL_HW, HW_PHYSMEM64};\n+#else\n+  unsigned int info;\n+  int which[] = {CTL_HW, HW_PHYSMEM};\n+#endif\n+  size_t size = sizeof(info);\n+\n+  if (sysctl(which, 2, &info, &size, NULL, 0) < 0) {\n+    return -1;\n+  }\n \n-void uv__fs_event_destroy(uv_fs_event_t* handle) {\n-  assert(0 && \"implement me\");\n+  return (uint64_t) info;\n }"}, {"sha": "55f8ceb0ded227588a3f17ee74f25f788aafb35d", "filename": "src/rt/libuv/src/unix/openbsd.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fopenbsd.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fopenbsd.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fopenbsd.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -0,0 +1,123 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include <sys/types.h>\n+#include <sys/param.h>\n+#include <sys/resource.h>\n+#include <sys/time.h>\n+#include <sys/sysctl.h>\n+\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <unistd.h>\n+\n+#undef NANOSEC\n+#define NANOSEC 1000000000\n+\n+\n+uint64_t uv_hrtime(void) {\n+  struct timespec ts;\n+  clock_gettime(CLOCK_MONOTONIC, &ts);\n+  return (ts.tv_sec * NANOSEC + ts.tv_nsec);\n+}\n+\n+void uv_loadavg(double avg[3]) {\n+  struct loadavg info;\n+  size_t size = sizeof(info);\n+  int which[] = {CTL_VM, VM_LOADAVG};\n+\n+  if (sysctl(which, 2, &info, &size, NULL, 0) < 0) return;\n+\n+  avg[0] = (double) info.ldavg[0] / info.fscale;\n+  avg[1] = (double) info.ldavg[1] / info.fscale;\n+  avg[2] = (double) info.ldavg[2] / info.fscale;\n+}\n+\n+int uv_exepath(char* buffer, size_t* size) {\n+  int mib[4];\n+  char **argsbuf = NULL;\n+  char **argsbuf_tmp;\n+  size_t argsbuf_size = 100U;\n+  size_t exepath_size;\n+  pid_t mypid;\n+  int status = -1;\n+\n+  if (!buffer || !size) {\n+    goto out;\n+  }\n+  mypid = getpid();\n+  for (;;) {\n+    if ((argsbuf_tmp = realloc(argsbuf, argsbuf_size)) == NULL) {\n+      goto out;\n+    }\n+    argsbuf = argsbuf_tmp;\n+    mib[0] = CTL_KERN;\n+    mib[1] = KERN_PROC_ARGS;\n+    mib[2] = mypid;\n+    mib[3] = KERN_PROC_ARGV;\n+    if (sysctl(mib, 4, argsbuf, &argsbuf_size, NULL, 0) == 0) {\n+      break;\n+    }\n+    if (errno != ENOMEM) {\n+      goto out;\n+    }\n+    argsbuf_size *= 2U;\n+  }\n+  if (argsbuf[0] == NULL) {\n+    goto out;\n+  }\n+  exepath_size = strlen(argsbuf[0]);\n+  if (exepath_size >= *size) {\n+    goto out;\n+  }\n+  memcpy(buffer, argsbuf[0], exepath_size + 1U);\n+  *size = exepath_size;\n+  status = 0;\n+\n+out:\n+  free(argsbuf);\n+\n+  return status;\n+}\n+\n+uint64_t uv_get_free_memory(void) {\n+  struct uvmexp info;\n+  size_t size = sizeof(info);\n+  int which[] = {CTL_VM, VM_UVMEXP};\n+\n+  if (sysctl(which, 2, &info, &size, NULL, 0) < 0) {\n+    return -1;\n+  }\n+\n+  return (uint64_t) info.free * sysconf(_SC_PAGESIZE);\n+}\n+\n+uint64_t uv_get_total_memory(void) {\n+  uint64_t info;\n+  int which[] = {CTL_HW, HW_PHYSMEM64};\n+  size_t size = sizeof(info);\n+\n+  if (sysctl(which, 2, &info, &size, NULL, 0) < 0) {\n+    return -1;\n+  }\n+\n+  return (uint64_t) info;\n+}"}, {"sha": "dabdcd6cff81ff06f889986fa2f8c9ef609e9441", "filename": "src/rt/libuv/src/unix/pipe.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fpipe.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fpipe.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fpipe.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -29,10 +29,12 @@\n #include <unistd.h>\n #include <stdlib.h>\n \n-int uv_pipe_init(uv_loop_t* loop, uv_pipe_t* handle) {\n+\n+int uv_pipe_init(uv_loop_t* loop, uv_pipe_t* handle, int ipc) {\n   uv__stream_init(loop, (uv_stream_t*)handle, UV_NAMED_PIPE);\n   loop->counters.pipe_init++;\n   handle->pipe_fname = NULL;\n+  handle->ipc = ipc;\n   return 0;\n }\n \n@@ -53,21 +55,21 @@ int uv_pipe_bind(uv_pipe_t* handle, const char* name) {\n \n   /* Already bound? */\n   if (handle->fd >= 0) {\n-    uv_err_new_artificial(handle->loop, UV_EINVAL);\n+    uv__set_artificial_error(handle->loop, UV_EINVAL);\n     goto out;\n   }\n \n   /* Make a copy of the file name, it outlives this function's scope. */\n   if ((pipe_fname = strdup(name)) == NULL) {\n-    uv_err_new(handle->loop, ENOMEM);\n+    uv__set_sys_error(handle->loop, ENOMEM);\n     goto out;\n   }\n \n   /* We've got a copy, don't touch the original any more. */\n   name = NULL;\n \n   if ((sockfd = uv__socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {\n-    uv_err_new(handle->loop, errno);\n+    uv__set_sys_error(handle->loop, errno);\n     goto out;\n   }\n \n@@ -88,7 +90,7 @@ int uv_pipe_bind(uv_pipe_t* handle, const char* name) {\n         || unlink(pipe_fname) == -1\n         || bind(sockfd, (struct sockaddr*)&saddr, sizeof saddr) == -1) {\n       /* Convert ENOENT to EACCES for compatibility with Windows. */\n-      uv_err_new(handle->loop, (errno == ENOENT) ? EACCES : errno);\n+      uv__set_sys_error(handle->loop, (errno == ENOENT) ? EACCES : errno);\n       goto out;\n     }\n   }\n@@ -125,13 +127,13 @@ int uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb) {\n   status = -1;\n \n   if (handle->fd == -1) {\n-    uv_err_new_artificial(handle->loop, UV_EINVAL);\n+    uv__set_artificial_error(handle->loop, UV_EINVAL);\n     goto out;\n   }\n   assert(handle->fd >= 0);\n \n   if ((status = listen(handle->fd, backlog)) == -1) {\n-    uv_err_new(handle->loop, errno);\n+    uv__set_sys_error(handle->loop, errno);\n   } else {\n     handle->connection_cb = cb;\n     ev_io_init(&handle->read_watcher, uv__pipe_accept, handle->fd, EV_READ);\n@@ -190,7 +192,7 @@ int uv_pipe_connect(uv_connect_t* req,\n   status = -1;\n \n   if ((sockfd = uv__socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {\n-    uv_err_new(handle->loop, errno);\n+    uv__set_sys_error(handle->loop, errno);\n     goto out;\n   }\n \n@@ -207,7 +209,7 @@ int uv_pipe_connect(uv_connect_t* req,\n   while (r == -1 && errno == EINTR);\n \n   if (r == -1) {\n-    uv_err_new(handle->loop, errno);\n+    uv__set_sys_error(handle->loop, errno);\n     uv__close(sockfd);\n     goto out;\n   }\n@@ -257,7 +259,7 @@ void uv__pipe_accept(EV_P_ ev_io* watcher, int revents) {\n     if (errno == EAGAIN || errno == EWOULDBLOCK) {\n       assert(0 && \"EAGAIN on uv__accept(pipefd)\");\n     } else {\n-      uv_err_new(pipe->loop, errno);\n+      uv__set_sys_error(pipe->loop, errno);\n     }\n   } else {\n     pipe->accepted_fd = sockfd;"}, {"sha": "a76864500c09b07ff148dc872accf530c22ee86b", "filename": "src/rt/libuv/src/unix/process.c", "status": "modified", "additions": 48, "deletions": 46, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fprocess.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fprocess.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fprocess.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -1,4 +1,3 @@\n-\n /* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n  *\n  * Permission is hereby granted, free of charge, to any person obtaining a copy\n@@ -63,6 +62,34 @@ static void uv__chld(EV_P_ ev_child* watcher, int revents) {\n   }\n }\n \n+\n+/*\n+ * Used for initializing stdio streams like options.stdin_stream. Returns\n+ * zero on success.\n+ */\n+static int uv__process_init_pipe(uv_pipe_t* handle, int fds[2]) {\n+  if (handle->type != UV_NAMED_PIPE) {\n+    errno = EINVAL;\n+    return -1;\n+  }\n+\n+  if (handle->ipc) {\n+    if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds) < 0) {\n+      return -1;\n+    }\n+  } else {\n+    if (pipe(fds) < 0) {\n+      return -1;\n+    }\n+  }\n+\n+  uv__cloexec(fds[0], 1);\n+  uv__cloexec(fds[1], 1);\n+\n+  return 0;\n+}\n+\n+\n #ifndef SPAWN_WAIT_EXEC\n # define SPAWN_WAIT_EXEC 1\n #endif\n@@ -83,49 +110,26 @@ int uv_spawn(uv_loop_t* loop, uv_process_t* process,\n #endif\n   int status;\n   pid_t pid;\n+  int flags;\n \n   uv__handle_init(loop, (uv_handle_t*)process, UV_PROCESS);\n   loop->counters.process_init++;\n \n   process->exit_cb = options.exit_cb;\n \n-  if (options.stdin_stream) {\n-    if (options.stdin_stream->type != UV_NAMED_PIPE) {\n-      errno = EINVAL;\n-      goto error;\n-    }\n-\n-    if (pipe(stdin_pipe) < 0) {\n-      goto error;\n-    }\n-    uv__cloexec(stdin_pipe[0], 1);\n-    uv__cloexec(stdin_pipe[1], 1);\n+  if (options.stdin_stream &&\n+      uv__process_init_pipe(options.stdin_stream, stdin_pipe)) {\n+    goto error;\n   }\n \n-  if (options.stdout_stream) {\n-    if (options.stdout_stream->type != UV_NAMED_PIPE) {\n-      errno = EINVAL;\n-      goto error;\n-    }\n-\n-    if (pipe(stdout_pipe) < 0) {\n-      goto error;\n-    }\n-    uv__cloexec(stdout_pipe[0], 1);\n-    uv__cloexec(stdout_pipe[1], 1);\n+  if (options.stdout_stream &&\n+      uv__process_init_pipe(options.stdout_stream, stdout_pipe)) {\n+    goto error;\n   }\n \n-  if (options.stderr_stream) {\n-    if (options.stderr_stream->type != UV_NAMED_PIPE) {\n-      errno = EINVAL;\n-      goto error;\n-    }\n-\n-    if (pipe(stderr_pipe) < 0) {\n-      goto error;\n-    }\n-    uv__cloexec(stderr_pipe[0], 1);\n-    uv__cloexec(stderr_pipe[1], 1);\n+  if (options.stderr_stream &&\n+      uv__process_init_pipe(options.stderr_stream, stderr_pipe)) {\n+    goto error;\n   }\n \n   /* This pipe is used by the parent to wait until\n@@ -154,7 +158,7 @@ int uv_spawn(uv_loop_t* loop, uv_process_t* process,\n     goto error;\n   }\n # else\n-  if (pipe(signal_pipe) < 0) {\n+  if (socketpair(AF_UNIX, SOCK_STREAM, 0, signal_pipe) < 0) {\n     goto error;\n   }\n   uv__cloexec(signal_pipe[0], 1);\n@@ -232,13 +236,8 @@ int uv_spawn(uv_loop_t* loop, uv_process_t* process,\n   }\n   while (status == -1 && (errno == EINTR || errno == ENOMEM));\n \n+  assert((status == 1) && \"poll() on pipe read end failed\");\n   uv__close(signal_pipe[0]);\n-  uv__close(signal_pipe[1]);\n-\n-  assert((status == 1)\n-      && \"poll() on pipe read end failed\");\n-  assert((pfd.revents & POLLHUP) == POLLHUP\n-      && \"no POLLHUP on pipe read end\");\n #endif\n \n   process->pid = pid;\n@@ -252,32 +251,35 @@ int uv_spawn(uv_loop_t* loop, uv_process_t* process,\n     assert(stdin_pipe[0] >= 0);\n     uv__close(stdin_pipe[0]);\n     uv__nonblock(stdin_pipe[1], 1);\n+    flags = UV_WRITABLE | (options.stdin_stream->ipc ? UV_READABLE : 0);\n     uv__stream_open((uv_stream_t*)options.stdin_stream, stdin_pipe[1],\n-        UV_WRITABLE);\n+        flags);\n   }\n \n   if (stdout_pipe[0] >= 0) {\n     assert(options.stdout_stream);\n     assert(stdout_pipe[1] >= 0);\n     uv__close(stdout_pipe[1]);\n     uv__nonblock(stdout_pipe[0], 1);\n+    flags = UV_READABLE | (options.stdout_stream->ipc ? UV_WRITABLE : 0);\n     uv__stream_open((uv_stream_t*)options.stdout_stream, stdout_pipe[0],\n-        UV_READABLE);\n+        flags);\n   }\n \n   if (stderr_pipe[0] >= 0) {\n     assert(options.stderr_stream);\n     assert(stderr_pipe[1] >= 0);\n     uv__close(stderr_pipe[1]);\n     uv__nonblock(stderr_pipe[0], 1);\n+    flags = UV_READABLE | (options.stderr_stream->ipc ? UV_WRITABLE : 0);\n     uv__stream_open((uv_stream_t*)options.stderr_stream, stderr_pipe[0],\n-        UV_READABLE);\n+        flags);\n   }\n \n   return 0;\n \n error:\n-  uv_err_new(process->loop, errno);\n+  uv__set_sys_error(process->loop, errno);\n   uv__close(stdin_pipe[0]);\n   uv__close(stdin_pipe[1]);\n   uv__close(stdout_pipe[0]);\n@@ -292,7 +294,7 @@ int uv_process_kill(uv_process_t* process, int signum) {\n   int r = kill(process->pid, signum);\n \n   if (r) {\n-    uv_err_new(process->loop, errno);\n+    uv__set_sys_error(process->loop, errno);\n     return -1;\n   } else {\n     return 0;"}, {"sha": "2e5bde0143c942b5d1df7ffd09f8a2e604958e28", "filename": "src/rt/libuv/src/unix/stream.c", "status": "modified", "additions": 205, "deletions": 52, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fstream.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fstream.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fstream.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -29,6 +29,8 @@\n #include <string.h>\n #include <sys/uio.h>\n \n+#include <stdio.h>\n+\n \n static void uv__stream_connect(uv_stream_t*);\n static void uv__write(uv_stream_t* stream);\n@@ -51,6 +53,7 @@ void uv__stream_init(uv_loop_t* loop,\n                      uv_stream_t* stream,\n                      uv_handle_type type) {\n   uv__handle_init(loop, (uv_handle_t*)stream, type);\n+  loop->counters.stream_init++;\n \n   stream->alloc_cb = NULL;\n   stream->close_cb = NULL;\n@@ -81,14 +84,26 @@ int uv__stream_open(uv_stream_t* stream, int fd, int flags) {\n   assert(fd >= 0);\n   stream->fd = fd;\n \n-  ((uv_handle_t*)stream)->flags |= flags;\n+  stream->flags |= flags;\n \n-  /* Reuse the port address if applicable. */\n-  yes = 1;\n-  if (stream->type == UV_TCP\n-      && setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1) {\n-    uv_err_new(stream->loop, errno);\n-    return -1;\n+  if (stream->type == UV_TCP) {\n+    /* Reuse the port address if applicable. */\n+    yes = 1;\n+    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof yes) == -1) {\n+      uv__set_sys_error(stream->loop, errno);\n+      return -1;\n+    }\n+\n+    if ((stream->flags & UV_TCP_NODELAY) &&\n+        uv__tcp_nodelay((uv_tcp_t*)stream, 1)) {\n+      return -1;\n+    }\n+\n+    /* TODO Use delay the user passed in. */\n+    if ((stream->flags & UV_TCP_KEEPALIVE) &&\n+        uv__tcp_keepalive((uv_tcp_t*)stream, 1, 60)) {\n+      return -1;\n+    }\n   }\n \n   /* Associate the fd with each ev_io watcher. */\n@@ -118,7 +133,7 @@ void uv__stream_destroy(uv_stream_t* stream) {\n       free(req->bufs);\n \n     if (req->cb) {\n-      uv_err_new_artificial(req->handle->loop, UV_EINTR);\n+      uv__set_artificial_error(req->handle->loop, UV_EINTR);\n       req->cb(req, -1);\n     }\n   }\n@@ -129,7 +144,7 @@ void uv__stream_destroy(uv_stream_t* stream) {\n \n     req = ngx_queue_data(q, uv_write_t, queue);\n     if (req->cb) {\n-      uv_err_new_artificial(stream->loop, req->error);\n+      uv__set_artificial_error(stream->loop, req->error);\n       req->cb(req, req->error ? -1 : 0);\n     }\n   }\n@@ -167,7 +182,7 @@ void uv__server_io(EV_P_ ev_io* watcher, int revents) {\n         /* TODO special trick. unlock reserved socket, accept, close. */\n         return;\n       } else {\n-        uv_err_new(stream->loop, errno);\n+        uv__set_sys_error(stream->loop, errno);\n         stream->connection_cb((uv_stream_t*)stream, -1);\n       }\n     } else {\n@@ -199,15 +214,15 @@ int uv_accept(uv_stream_t* server, uv_stream_t* client) {\n   streamClient = (uv_stream_t*)client;\n \n   if (streamServer->accepted_fd < 0) {\n-    uv_err_new(server->loop, EAGAIN);\n+    uv__set_sys_error(server->loop, EAGAIN);\n     goto out;\n   }\n \n   if (uv__stream_open(streamClient, streamServer->accepted_fd,\n         UV_READABLE | UV_WRITABLE)) {\n     /* TODO handle error */\n-    streamServer->accepted_fd = -1;\n     uv__close(streamServer->accepted_fd);\n+    streamServer->accepted_fd = -1;\n     goto out;\n   }\n \n@@ -272,12 +287,12 @@ static void uv__drain(uv_stream_t* stream) {\n \n     if (shutdown(stream->fd, SHUT_WR)) {\n       /* Error. Report it. User should call uv_close(). */\n-      uv_err_new(stream->loop, errno);\n+      uv__set_sys_error(stream->loop, errno);\n       if (req->cb) {\n         req->cb(req, -1);\n       }\n     } else {\n-      uv_err_new(stream->loop, 0);\n+      uv__set_sys_error(stream->loop, 0);\n       ((uv_handle_t*) stream)->flags |= UV_SHUT;\n       if (req->cb) {\n         req->cb(req, 0);\n@@ -349,14 +364,43 @@ static void uv__write(uv_stream_t* stream) {\n    * inside the iov each time we write. So there is no need to offset it.\n    */\n \n-  do {\n-    if (iovcnt == 1) {\n-      n = write(stream->fd, iov[0].iov_base, iov[0].iov_len);\n-    } else {\n-      n = writev(stream->fd, iov, iovcnt);\n+  if (req->send_handle) {\n+    struct msghdr msg;\n+    char scratch[64];\n+    struct cmsghdr *cmsg;\n+    int fd_to_send = req->send_handle->fd;\n+\n+    assert(fd_to_send >= 0);\n+\n+    msg.msg_name = NULL;\n+    msg.msg_namelen = 0;\n+    msg.msg_iov = iov;\n+    msg.msg_iovlen = iovcnt;\n+    msg.msg_flags = 0;\n+\n+    msg.msg_control = (void*) scratch;\n+    msg.msg_controllen = CMSG_LEN(sizeof(fd_to_send));\n+\n+    cmsg = CMSG_FIRSTHDR(&msg);\n+    cmsg->cmsg_level = SOL_SOCKET;\n+    cmsg->cmsg_type = SCM_RIGHTS;\n+    cmsg->cmsg_len = msg.msg_controllen;\n+    *(int*) CMSG_DATA(cmsg) = fd_to_send;\n+\n+    do {\n+      n = sendmsg(stream->fd, &msg, 0);\n+    }\n+    while (n == -1 && errno == EINTR);\n+  } else {\n+    do {\n+      if (iovcnt == 1) {\n+        n = write(stream->fd, iov[0].iov_base, iov[0].iov_len);\n+      } else {\n+        n = writev(stream->fd, iov, iovcnt);\n+      }\n     }\n+    while (n == -1 && errno == EINTR);\n   }\n-  while (n == -1 && errno == EINTR);\n \n   if (n < 0) {\n     if (errno != EAGAIN) {\n@@ -428,7 +472,7 @@ static void uv__write_callbacks(uv_stream_t* stream) {\n \n     /* NOTE: call callback AFTER freeing the request data. */\n     if (req->cb) {\n-      uv_err_new_artificial(stream->loop, req->error);\n+      uv__set_artificial_error(stream->loop, req->error);\n       req->cb(req, req->error ? -1 : 0);\n     }\n \n@@ -447,23 +491,46 @@ static void uv__write_callbacks(uv_stream_t* stream) {\n static void uv__read(uv_stream_t* stream) {\n   uv_buf_t buf;\n   ssize_t nread;\n+  struct msghdr msg;\n+  struct cmsghdr* cmsg;\n+  char cmsg_space[64];\n   struct ev_loop* ev = stream->loop->ev;\n \n   /* XXX: Maybe instead of having UV_READING we just test if\n    * tcp->read_cb is NULL or not?\n    */\n-  while (stream->read_cb && ((uv_handle_t*)stream)->flags & UV_READING) {\n+  while ((stream->read_cb || stream->read2_cb) &&\n+         stream->flags & UV_READING) {\n     assert(stream->alloc_cb);\n     buf = stream->alloc_cb((uv_handle_t*)stream, 64 * 1024);\n \n     assert(buf.len > 0);\n     assert(buf.base);\n     assert(stream->fd >= 0);\n \n-    do {\n-      nread = read(stream->fd, buf.base, buf.len);\n+    if (stream->read_cb) {\n+      do {\n+        nread = read(stream->fd, buf.base, buf.len);\n+      }\n+      while (nread < 0 && errno == EINTR);\n+    } else {\n+      assert(stream->read2_cb);\n+      /* read2_cb uses recvmsg */\n+      msg.msg_flags = 0;\n+      msg.msg_iov = (struct iovec*) &buf;\n+      msg.msg_iovlen = 1;\n+      msg.msg_name = NULL;\n+      msg.msg_namelen = 0;\n+      /* Set up to receive a descriptor even if one isn't in the message */\n+      msg.msg_controllen = 64;\n+      msg.msg_control = (void *) cmsg_space;\n+\n+      do {\n+        nread = recvmsg(stream->fd, &msg, 0);\n+      }\n+      while (nread < 0 && errno == EINTR);\n     }\n-    while (nread < 0 && errno == EINTR);\n+\n \n     if (nread < 0) {\n       /* Error */\n@@ -472,25 +539,85 @@ static void uv__read(uv_stream_t* stream) {\n         if (stream->flags & UV_READING) {\n           ev_io_start(ev, &stream->read_watcher);\n         }\n-        uv_err_new(stream->loop, EAGAIN);\n-        stream->read_cb(stream, 0, buf);\n+        uv__set_sys_error(stream->loop, EAGAIN);\n+\n+        if (stream->read_cb) {\n+          stream->read_cb(stream, 0, buf);\n+        } else {\n+          stream->read2_cb((uv_pipe_t*)stream, 0, buf, UV_UNKNOWN_HANDLE);\n+        }\n+\n         return;\n       } else {\n         /* Error. User should call uv_close(). */\n-        uv_err_new(stream->loop, errno);\n-        stream->read_cb(stream, -1, buf);\n+        uv__set_sys_error(stream->loop, errno);\n+\n+        if (stream->read_cb) {\n+          stream->read_cb(stream, -1, buf);\n+        } else {\n+          stream->read2_cb((uv_pipe_t*)stream, -1, buf, UV_UNKNOWN_HANDLE);\n+        }\n+\n         assert(!ev_is_active(&stream->read_watcher));\n         return;\n       }\n+\n     } else if (nread == 0) {\n       /* EOF */\n-      uv_err_new_artificial(stream->loop, UV_EOF);\n+      uv__set_artificial_error(stream->loop, UV_EOF);\n       ev_io_stop(ev, &stream->read_watcher);\n-      stream->read_cb(stream, -1, buf);\n+\n+      if (stream->read_cb) {\n+        stream->read_cb(stream, -1, buf);\n+      } else {\n+        stream->read2_cb((uv_pipe_t*)stream, -1, buf, UV_UNKNOWN_HANDLE);\n+      }\n       return;\n     } else {\n       /* Successful read */\n-      stream->read_cb(stream, nread, buf);\n+      ssize_t buflen = buf.len;\n+\n+      if (stream->read_cb) {\n+        stream->read_cb(stream, nread, buf);\n+      } else {\n+        assert(stream->read2_cb);\n+\n+        /*\n+         * XXX: Some implementations can send multiple file descriptors in a\n+         * single message. We should be using CMSG_NXTHDR() to walk the\n+         * chain to get at them all. This would require changing the API to\n+         * hand these back up the caller, is a pain.\n+         */\n+\n+        for (cmsg = CMSG_FIRSTHDR(&msg);\n+             msg.msg_controllen > 0 && cmsg != NULL;\n+             cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n+\n+          if (cmsg->cmsg_type == SCM_RIGHTS) {\n+            if (stream->accepted_fd != -1) {\n+              fprintf(stderr, \"(libuv) ignoring extra FD received\\n\");\n+            }\n+\n+            stream->accepted_fd = *(int *) CMSG_DATA(cmsg);\n+\n+          } else {\n+            fprintf(stderr, \"ignoring non-SCM_RIGHTS ancillary data: %d\\n\",\n+                cmsg->cmsg_type);\n+          }\n+        }\n+\n+\n+        if (stream->accepted_fd >= 0) {\n+          stream->read2_cb((uv_pipe_t*)stream, nread, buf, UV_TCP);\n+        } else {\n+          stream->read2_cb((uv_pipe_t*)stream, nread, buf, UV_UNKNOWN_HANDLE);\n+        }\n+      }\n+\n+      /* Return if we didn't fill the buffer, there is no more data to read. */\n+      if (nread < buflen) {\n+        return;\n+      }\n     }\n   }\n }\n@@ -505,7 +632,7 @@ int uv_shutdown(uv_shutdown_t* req, uv_stream_t* stream, uv_shutdown_cb cb) {\n       stream->flags & UV_SHUT ||\n       stream->flags & UV_CLOSED ||\n       stream->flags & UV_CLOSING) {\n-    uv_err_new(stream->loop, EINVAL);\n+    uv__set_sys_error(stream->loop, EINVAL);\n     return -1;\n   }\n \n@@ -593,7 +720,7 @@ static void uv__stream_connect(uv_stream_t* stream) {\n     return;\n   } else {\n     /* Error */\n-    uv_err_new(stream->loop, error);\n+    uv__set_sys_error(stream->loop, error);\n \n     stream->connect_req = NULL;\n     if (req->cb) {\n@@ -610,7 +737,7 @@ int uv__connect(uv_connect_t* req, uv_stream_t* stream, struct sockaddr* addr,\n \n   if (stream->fd <= 0) {\n     if ((sockfd = uv__socket(addr->sa_family, SOCK_STREAM, 0)) == -1) {\n-      uv_err_new(stream->loop, errno);\n+      uv__set_sys_error(stream->loop, errno);\n       return -1;\n     }\n \n@@ -627,12 +754,12 @@ int uv__connect(uv_connect_t* req, uv_stream_t* stream, struct sockaddr* addr,\n   ngx_queue_init(&req->queue);\n \n   if (stream->connect_req) {\n-    uv_err_new(stream->loop, EALREADY);\n+    uv__set_sys_error(stream->loop, EALREADY);\n     return -1;\n   }\n \n   if (stream->type != UV_TCP) {\n-    uv_err_new(stream->loop, ENOTSOCK);\n+    uv__set_sys_error(stream->loop, ENOTSOCK);\n     return -1;\n   }\n \n@@ -656,7 +783,7 @@ int uv__connect(uv_connect_t* req, uv_stream_t* stream, struct sockaddr* addr,\n         break;\n \n       default:\n-        uv_err_new(stream->loop, errno);\n+        uv__set_sys_error(stream->loop, errno);\n         return -1;\n     }\n   }\n@@ -672,29 +799,34 @@ int uv__connect(uv_connect_t* req, uv_stream_t* stream, struct sockaddr* addr,\n }\n \n \n-/* The buffers to be written must remain valid until the callback is called.\n- * This is not required for the uv_buf_t array.\n- */\n-int uv_write(uv_write_t* req, uv_stream_t* stream, uv_buf_t bufs[], int bufcnt,\n-    uv_write_cb cb) {\n+int uv_write2(uv_write_t* req, uv_stream_t* stream, uv_buf_t bufs[], int bufcnt,\n+    uv_stream_t* send_handle, uv_write_cb cb) {\n   int empty_queue;\n \n   assert((stream->type == UV_TCP || stream->type == UV_NAMED_PIPE ||\n       stream->type == UV_TTY) &&\n       \"uv_write (unix) does not yet support other types of streams\");\n \n   if (stream->fd < 0) {\n-    uv_err_new(stream->loop, EBADF);\n+    uv__set_sys_error(stream->loop, EBADF);\n     return -1;\n   }\n \n+  if (send_handle) {\n+    if (stream->type != UV_NAMED_PIPE || !((uv_pipe_t*)stream)->ipc) {\n+      uv__set_sys_error(stream->loop, EOPNOTSUPP);\n+      return -1;\n+    }\n+  }\n+\n   empty_queue = (stream->write_queue_size == 0);\n \n   /* Initialize the req */\n   uv__req_init((uv_req_t*) req);\n   req->cb = cb;\n   req->handle = stream;\n   req->error = 0;\n+  req->send_handle = send_handle;\n   req->type = UV_WRITE;\n   ngx_queue_init(&req->queue);\n \n@@ -737,12 +869,22 @@ int uv_write(uv_write_t* req, uv_stream_t* stream, uv_buf_t bufs[], int bufcnt,\n }\n \n \n-int uv_read_start(uv_stream_t* stream, uv_alloc_cb alloc_cb, uv_read_cb read_cb) {\n+/* The buffers to be written must remain valid until the callback is called.\n+ * This is not required for the uv_buf_t array.\n+ */\n+int uv_write(uv_write_t* req, uv_stream_t* stream, uv_buf_t bufs[], int bufcnt,\n+    uv_write_cb cb) {\n+  return uv_write2(req, stream, bufs, bufcnt, NULL, cb);\n+}\n+\n+\n+int uv__read_start_common(uv_stream_t* stream, uv_alloc_cb alloc_cb,\n+    uv_read_cb read_cb, uv_read2_cb read2_cb) {\n   assert(stream->type == UV_TCP || stream->type == UV_NAMED_PIPE ||\n       stream->type == UV_TTY);\n \n   if (stream->flags & UV_CLOSING) {\n-    uv_err_new(stream->loop, EINVAL);\n+    uv__set_sys_error(stream->loop, EINVAL);\n     return -1;\n   }\n \n@@ -759,6 +901,7 @@ int uv_read_start(uv_stream_t* stream, uv_alloc_cb alloc_cb, uv_read_cb read_cb)\n   assert(alloc_cb);\n \n   stream->read_cb = read_cb;\n+  stream->read2_cb = read2_cb;\n   stream->alloc_cb = alloc_cb;\n \n   /* These should have been set by uv_tcp_init. */\n@@ -769,14 +912,24 @@ int uv_read_start(uv_stream_t* stream, uv_alloc_cb alloc_cb, uv_read_cb read_cb)\n }\n \n \n-int uv_read_stop(uv_stream_t* stream) {\n-  uv_tcp_t* tcp = (uv_tcp_t*)stream;\n+int uv_read_start(uv_stream_t* stream, uv_alloc_cb alloc_cb,\n+    uv_read_cb read_cb) {\n+  return uv__read_start_common(stream, alloc_cb, read_cb, NULL);\n+}\n \n-  ((uv_handle_t*)tcp)->flags &= ~UV_READING;\n \n-  ev_io_stop(tcp->loop->ev, &tcp->read_watcher);\n-  tcp->read_cb = NULL;\n-  tcp->alloc_cb = NULL;\n+int uv_read2_start(uv_stream_t* stream, uv_alloc_cb alloc_cb,\n+    uv_read2_cb read_cb) {\n+  return uv__read_start_common(stream, alloc_cb, NULL, read_cb);\n+}\n+\n+\n+int uv_read_stop(uv_stream_t* stream) {\n+  ev_io_stop(stream->loop->ev, &stream->read_watcher);\n+  stream->flags &= ~UV_READING;\n+  stream->read_cb = NULL;\n+  stream->read2_cb = NULL;\n+  stream->alloc_cb = NULL;\n   return 0;\n }\n "}, {"sha": "c0bfe32e0397cd49dbc39b050170517c7a547a2c", "filename": "src/rt/libuv/src/unix/sunos.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fsunos.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fsunos.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fsunos.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -19,14 +19,17 @@\n  */\n \n #include \"uv.h\"\n+#include \"internal.h\"\n \n #include <stdio.h>\n #include <stdint.h>\n #include <assert.h>\n #include <errno.h>\n \n #include <sys/time.h>\n+#include <sys/loadavg.h>\n #include <unistd.h>\n+#include <kstat.h>\n \n \n uint64_t uv_hrtime() {\n@@ -63,11 +66,26 @@ int uv_exepath(char* buffer, size_t* size) {\n }\n \n \n+uint64_t uv_get_free_memory(void) {\n+  return (uint64_t) sysconf(_SC_PAGESIZE) * sysconf(_SC_AVPHYS_PAGES);\n+}\n+\n+\n+uint64_t uv_get_total_memory(void) {\n+  return (uint64_t) sysconf(_SC_PAGESIZE) * sysconf(_SC_PHYS_PAGES);\n+}\n+\n+\n+void uv_loadavg(double avg[3]) {\n+  (void) getloadavg(avg, 3);\n+}\n+\n+\n int uv_fs_event_init(uv_loop_t* loop,\n                      uv_fs_event_t* handle,\n                      const char* filename,\n                      uv_fs_event_cb cb) {\n-  uv_err_new(loop, ENOSYS);\n+  uv__set_sys_error(loop, ENOSYS);\n   return -1;\n }\n "}, {"sha": "67ed217196d081a64dc1bb44550f261d142a5966", "filename": "src/rt/libuv/src/unix/tcp.c", "status": "modified", "additions": 108, "deletions": 67, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftcp.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftcp.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftcp.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -33,10 +33,10 @@ int uv_tcp_init(uv_loop_t* loop, uv_tcp_t* tcp) {\n }\n \n \n-static int uv__tcp_bind(uv_tcp_t* tcp,\n-                        int domain,\n-                        struct sockaddr* addr,\n-                        int addrsize) {\n+static int uv__bind(uv_tcp_t* tcp,\n+                    int domain,\n+                    struct sockaddr* addr,\n+                    int addrsize) {\n   int saved_errno;\n   int status;\n \n@@ -45,7 +45,7 @@ static int uv__tcp_bind(uv_tcp_t* tcp,\n \n   if (tcp->fd < 0) {\n     if ((tcp->fd = uv__socket(domain, SOCK_STREAM, 0)) == -1) {\n-      uv_err_new(tcp->loop, errno);\n+      uv__set_sys_error(tcp->loop, errno);\n       goto out;\n     }\n \n@@ -64,7 +64,7 @@ static int uv__tcp_bind(uv_tcp_t* tcp,\n     if (errno == EADDRINUSE) {\n       tcp->delayed_error = errno;\n     } else {\n-      uv_err_new(tcp->loop, errno);\n+      uv__set_sys_error(tcp->loop, errno);\n       goto out;\n     }\n   }\n@@ -76,29 +76,19 @@ static int uv__tcp_bind(uv_tcp_t* tcp,\n }\n \n \n-int uv_tcp_bind(uv_tcp_t* tcp, struct sockaddr_in addr) {\n-  if (addr.sin_family != AF_INET) {\n-    uv_err_new(tcp->loop, EFAULT);\n-    return -1;\n-  }\n-\n-  return uv__tcp_bind(tcp,\n-                      AF_INET,\n-                      (struct sockaddr*)&addr,\n-                      sizeof(struct sockaddr_in));\n+int uv__tcp_bind(uv_tcp_t* handle, struct sockaddr_in addr) {\n+  return uv__bind(handle,\n+                  AF_INET,\n+                  (struct sockaddr*)&addr,\n+                  sizeof(struct sockaddr_in));\n }\n \n \n-int uv_tcp_bind6(uv_tcp_t* tcp, struct sockaddr_in6 addr) {\n-  if (addr.sin6_family != AF_INET6) {\n-    uv_err_new(tcp->loop, EFAULT);\n-    return -1;\n-  }\n-\n-  return uv__tcp_bind(tcp,\n-                      AF_INET6,\n-                      (struct sockaddr*)&addr,\n-                      sizeof(struct sockaddr_in6));\n+int uv__tcp_bind6(uv_tcp_t* handle, struct sockaddr_in6 addr) {\n+  return uv__bind(handle,\n+                  AF_INET6,\n+                  (struct sockaddr*)&addr,\n+                  sizeof(struct sockaddr_in6));\n }\n \n \n@@ -112,13 +102,13 @@ int uv_tcp_getsockname(uv_tcp_t* handle, struct sockaddr* name,\n   saved_errno = errno;\n \n   if (handle->delayed_error) {\n-    uv_err_new(handle->loop, handle->delayed_error);\n+    uv__set_sys_error(handle->loop, handle->delayed_error);\n     rv = -1;\n     goto out;\n   }\n \n   if (handle->fd < 0) {\n-    uv_err_new(handle->loop, EINVAL);\n+    uv__set_sys_error(handle->loop, EINVAL);\n     rv = -1;\n     goto out;\n   }\n@@ -127,7 +117,7 @@ int uv_tcp_getsockname(uv_tcp_t* handle, struct sockaddr* name,\n   socklen = (socklen_t)*namelen;\n \n   if (getsockname(handle->fd, name, &socklen) == -1) {\n-    uv_err_new(handle->loop, errno);\n+    uv__set_sys_error(handle->loop, errno);\n     rv = -1;\n   } else {\n     *namelen = (int)socklen;\n@@ -149,13 +139,13 @@ int uv_tcp_getpeername(uv_tcp_t* handle, struct sockaddr* name,\n   saved_errno = errno;\n \n   if (handle->delayed_error) {\n-    uv_err_new(handle->loop, handle->delayed_error);\n+    uv__set_sys_error(handle->loop, handle->delayed_error);\n     rv = -1;\n     goto out;\n   }\n \n   if (handle->fd < 0) {\n-    uv_err_new(handle->loop, EINVAL);\n+    uv__set_sys_error(handle->loop, EINVAL);\n     rv = -1;\n     goto out;\n   }\n@@ -164,7 +154,7 @@ int uv_tcp_getpeername(uv_tcp_t* handle, struct sockaddr* name,\n   socklen = (socklen_t)*namelen;\n \n   if (getpeername(handle->fd, name, &socklen) == -1) {\n-    uv_err_new(handle->loop, errno);\n+    uv__set_sys_error(handle->loop, errno);\n     rv = -1;\n   } else {\n     *namelen = (int)socklen;\n@@ -180,13 +170,13 @@ int uv_tcp_listen(uv_tcp_t* tcp, int backlog, uv_connection_cb cb) {\n   int r;\n \n   if (tcp->delayed_error) {\n-    uv_err_new(tcp->loop, tcp->delayed_error);\n+    uv__set_sys_error(tcp->loop, tcp->delayed_error);\n     return -1;\n   }\n \n   if (tcp->fd < 0) {\n     if ((tcp->fd = uv__socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n-      uv_err_new(tcp->loop, errno);\n+      uv__set_sys_error(tcp->loop, errno);\n       return -1;\n     }\n \n@@ -201,7 +191,7 @@ int uv_tcp_listen(uv_tcp_t* tcp, int backlog, uv_connection_cb cb) {\n \n   r = listen(tcp->fd, backlog);\n   if (r < 0) {\n-    uv_err_new(tcp->loop, errno);\n+    uv__set_sys_error(tcp->loop, errno);\n     return -1;\n   }\n \n@@ -216,65 +206,116 @@ int uv_tcp_listen(uv_tcp_t* tcp, int backlog, uv_connection_cb cb) {\n }\n \n \n-int uv_tcp_connect(uv_connect_t* req,\n+int uv__tcp_connect(uv_connect_t* req,\n                    uv_tcp_t* handle,\n                    struct sockaddr_in address,\n                    uv_connect_cb cb) {\n-  int saved_errno;\n+  int saved_errno = errno;\n   int status;\n \n-  saved_errno = errno;\n-  status = -1;\n-\n-  if (handle->type != UV_TCP) {\n-    uv_err_new(handle->loop, EINVAL);\n-    goto out;\n-  }\n-\n-  if (address.sin_family != AF_INET) {\n-    uv_err_new(handle->loop, EINVAL);\n-    goto out;\n-  }\n-\n   status = uv__connect(req,\n                        (uv_stream_t*)handle,\n                        (struct sockaddr*)&address,\n                        sizeof address,\n                        cb);\n \n-out:\n   errno = saved_errno;\n   return status;\n }\n \n \n-int uv_tcp_connect6(uv_connect_t* req,\n+int uv__tcp_connect6(uv_connect_t* req,\n                     uv_tcp_t* handle,\n                     struct sockaddr_in6 address,\n                     uv_connect_cb cb) {\n-  int saved_errno;\n+  int saved_errno = errno;\n   int status;\n \n-  saved_errno = errno;\n-  status = -1;\n-\n-  if (handle->type != UV_TCP) {\n-    uv_err_new(handle->loop, EINVAL);\n-    goto out;\n-  }\n-\n-  if (address.sin6_family != AF_INET6) {\n-    uv_err_new(handle->loop, EINVAL);\n-    goto out;\n-  }\n-\n   status = uv__connect(req,\n                        (uv_stream_t*)handle,\n                        (struct sockaddr*)&address,\n                        sizeof address,\n                        cb);\n \n-out:\n   errno = saved_errno;\n   return status;\n }\n+\n+\n+int uv__tcp_nodelay(uv_tcp_t* handle, int enable) {\n+  if (setsockopt(handle->fd,\n+                 IPPROTO_TCP,\n+                 TCP_NODELAY,\n+                 &enable,\n+                 sizeof enable) == -1) {\n+    uv__set_sys_error(handle->loop, errno);\n+    return -1;\n+  }\n+  return 0;\n+}\n+\n+\n+int uv__tcp_keepalive(uv_tcp_t* handle, int enable, unsigned int delay) {\n+  if (setsockopt(handle->fd,\n+                 SOL_SOCKET,\n+                 SO_KEEPALIVE,\n+                 &enable,\n+                 sizeof enable) == -1) {\n+    uv__set_sys_error(handle->loop, errno);\n+    return -1;\n+  }\n+\n+#ifdef TCP_KEEPIDLE\n+  if (enable && setsockopt(handle->fd,\n+                           IPPROTO_TCP,\n+                           TCP_KEEPIDLE,\n+                           &delay,\n+                           sizeof delay) == -1) {\n+    uv__set_sys_error(handle->loop, errno);\n+    return -1;\n+  }\n+#endif\n+\n+#ifdef TCP_KEEPALIVE\n+  if (enable && setsockopt(handle->fd,\n+                           IPPROTO_TCP,\n+                           TCP_KEEPALIVE,\n+                           &delay,\n+                           sizeof delay) == -1) {\n+    uv__set_sys_error(handle->loop, errno);\n+    return -1;\n+  }\n+#endif\n+\n+  return 0;\n+}\n+\n+\n+int uv_tcp_nodelay(uv_tcp_t* handle, int enable) {\n+  if (handle->fd != -1 && uv__tcp_nodelay(handle, enable))\n+    return -1;\n+\n+  if (enable)\n+    handle->flags |= UV_TCP_NODELAY;\n+  else\n+    handle->flags &= ~UV_TCP_NODELAY;\n+\n+  return 0;\n+}\n+\n+\n+int uv_tcp_keepalive(uv_tcp_t* handle, int enable, unsigned int delay) {\n+  if (handle->fd != -1 && uv__tcp_keepalive(handle, enable, delay))\n+    return -1;\n+\n+  if (enable)\n+    handle->flags |= UV_TCP_KEEPALIVE;\n+  else\n+    handle->flags &= ~UV_TCP_KEEPALIVE;\n+\n+  /* TODO Store delay if handle->fd == -1 but don't want to enlarge\n+   *       uv_tcp_t with an int that's almost never used...\n+   */\n+\n+  return 0;\n+}"}, {"sha": "32ac2c71c7d551961d6f28f03e6ba572b63d42ce", "filename": "src/rt/libuv/src/unix/tty.c", "status": "modified", "additions": 67, "deletions": 28, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftty.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftty.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftty.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -29,43 +29,75 @@\n #include <sys/ioctl.h>\n \n \n-int uv_tty_init(uv_loop_t* loop, uv_tty_t* tty, int fd) {\n-  uv__nonblock(fd, 1);\n+static int orig_termios_fd = -1;\n+static struct termios orig_termios;\n+\n+\n+int uv_tty_init(uv_loop_t* loop, uv_tty_t* tty, int fd, int readable) {\n   uv__stream_init(loop, (uv_stream_t*)tty, UV_TTY);\n-  uv__stream_open((uv_stream_t*)tty, fd, UV_READABLE | UV_WRITABLE);\n+\n+  if (readable) {\n+    uv__nonblock(fd, 1);\n+    uv__stream_open((uv_stream_t*)tty, fd, UV_READABLE);\n+  } else {\n+    /* Note: writable tty we set to blocking mode. */\n+    uv__nonblock(fd, 0);\n+    uv__stream_open((uv_stream_t*)tty, fd, UV_WRITABLE);\n+    tty->blocking = 1;\n+  }\n+\n   loop->counters.tty_init++;\n+  tty->mode = 0;\n   return 0;\n }\n \n \n int uv_tty_set_mode(uv_tty_t* tty, int mode) {\n   int fd = tty->fd;\n-  struct termios orig_termios; /* in order to restore at exit */\n   struct termios raw;\n \n-  if (tcgetattr(fd, &orig_termios) == -1) goto fatal;\n-\n-  raw = orig_termios;  /* modify the original mode */\n-  /* input modes: no break, no CR to NL, no parity check, no strip char,\n-   * no start/stop output control. */\n-  raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);\n-  /* output modes */\n-  raw.c_oflag |= (ONLCR);\n-  /* control modes - set 8 bit chars */\n-  raw.c_cflag |= (CS8);\n-  /* local modes - echoing off, canonical off, no extended functions,\n-   * no signal chars (^Z,^C) */\n-  raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);\n-  /* control chars - set return condition: min number of bytes and timer.\n-   * We want read to return every single byte, without timeout. */\n-  raw.c_cc[VMIN] = 1; raw.c_cc[VTIME] = 0; /* 1 byte, no timer */\n-\n-  /* put terminal in raw mode after flushing */\n-  if (tcsetattr(fd, TCSAFLUSH, &raw) < 0) goto fatal;\n-  return 0;\n+  if (mode && tty->mode == 0) {\n+    /* on */\n+\n+    if (tcgetattr(fd, &tty->orig_termios)) {\n+      goto fatal;\n+    }\n+\n+    /* This is used for uv_tty_reset_mode() */\n+    if (orig_termios_fd == -1) {\n+      orig_termios = tty->orig_termios;\n+      orig_termios_fd = fd;\n+    }\n+\n+    raw = tty->orig_termios;\n+    raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);\n+    raw.c_oflag |= (ONLCR);\n+    raw.c_cflag |= (CS8);\n+    raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);\n+    raw.c_cc[VMIN] = 1;\n+    raw.c_cc[VTIME] = 0;\n+\n+    /* Put terminal in raw mode after flushing */\n+    if (tcsetattr(fd, TCSAFLUSH, &raw)) {\n+      goto fatal;\n+    }\n+\n+    tty->mode = 1;\n+    return 0;\n+  } else if (mode == 0 && tty->mode) {\n+    /* off */\n+\n+    /* Put terminal in original mode after flushing */\n+    if (tcsetattr(fd, TCSAFLUSH, &tty->orig_termios)) {\n+      goto fatal;\n+    }\n+\n+    tty->mode = 0;\n+    return 0;\n+  }\n \n fatal:\n-  uv_err_new(tty->loop, ENOTTY);\n+  uv__set_sys_error(tty->loop, errno);\n   return -1;\n }\n \n@@ -74,7 +106,7 @@ int uv_tty_get_winsize(uv_tty_t* tty, int* width, int* height) {\n   struct winsize ws;\n \n   if (ioctl(tty->fd, TIOCGWINSZ, &ws) < 0) {\n-    uv_err_new(tty->loop, errno);\n+    uv__set_sys_error(tty->loop, errno);\n     return -1;\n   }\n \n@@ -89,7 +121,7 @@ uv_handle_type uv_guess_handle(uv_file file) {\n   struct stat s;\n \n   if (file < 0) {\n-    uv_err_new(NULL, EINVAL); /* XXX Need loop? */\n+    uv__set_sys_error(NULL, EINVAL); /* XXX Need loop? */\n     return -1;\n   }\n \n@@ -98,7 +130,7 @@ uv_handle_type uv_guess_handle(uv_file file) {\n   }\n \n   if (fstat(file, &s)) {\n-    uv_err_new(NULL, errno); /* XXX Need loop? */\n+    uv__set_sys_error(NULL, errno); /* XXX Need loop? */\n     return -1;\n   }\n \n@@ -108,3 +140,10 @@ uv_handle_type uv_guess_handle(uv_file file) {\n \n   return UV_NAMED_PIPE;\n }\n+\n+\n+void uv_tty_reset_mode() {\n+  if (orig_termios_fd >= 0) {\n+    tcsetattr(orig_termios_fd, TCSANOW, &orig_termios);\n+  }\n+}"}, {"sha": "15cd609bbecea145c22039bead4b661116a32453", "filename": "src/rt/libuv/src/unix/udp.c", "status": "modified", "additions": 71, "deletions": 36, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fudp.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fudp.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fudp.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -34,8 +34,6 @@ static void uv__udp_run_pending(uv_udp_t* handle);\n static void uv__udp_recvmsg(uv_udp_t* handle);\n static void uv__udp_sendmsg(uv_udp_t* handle);\n static void uv__udp_io(EV_P_ ev_io* w, int events);\n-static int uv__udp_bind(uv_udp_t* handle, int domain, struct sockaddr* addr,\n-    socklen_t len, unsigned flags);\n static int uv__udp_maybe_deferred_bind(uv_udp_t* handle, int domain);\n static int uv__udp_send(uv_udp_send_t* req, uv_udp_t* handle, uv_buf_t bufs[],\n     int bufcnt, struct sockaddr* addr, socklen_t addrlen, uv_udp_send_cb send_cb);\n@@ -84,7 +82,7 @@ void uv__udp_destroy(uv_udp_t* handle) {\n     req = ngx_queue_data(q, uv_udp_send_t, queue);\n     if (req->send_cb) {\n       /* FIXME proper error code like UV_EABORTED */\n-      uv_err_new_artificial(handle->loop, UV_EINTR);\n+      uv__set_artificial_error(handle->loop, UV_EINTR);\n       req->send_cb(req, -1);\n     }\n   }\n@@ -187,7 +185,7 @@ static void uv__udp_run_completed(uv_udp_t* handle) {\n       req->send_cb(req, 0);\n     }\n     else {\n-      uv_err_new(handle->loop, -req->status);\n+      uv__set_sys_error(handle->loop, -req->status);\n       req->send_cb(req, -1);\n     }\n   }\n@@ -223,11 +221,11 @@ static void uv__udp_recvmsg(uv_udp_t* handle) {\n \n     if (nread == -1) {\n       if (errno == EAGAIN || errno == EWOULDBLOCK) {\n-        uv_err_new(handle->loop, EAGAIN);\n+        uv__set_sys_error(handle->loop, EAGAIN);\n         handle->recv_cb(handle, 0, buf, NULL, 0);\n       }\n       else {\n-        uv_err_new(handle->loop, errno);\n+        uv__set_sys_error(handle->loop, errno);\n         handle->recv_cb(handle, -1, buf, NULL, 0);\n       }\n     }\n@@ -289,57 +287,58 @@ static void uv__udp_io(EV_P_ ev_io* w, int events) {\n }\n \n \n-static int uv__udp_bind(uv_udp_t* handle,\n-                        int domain,\n-                        struct sockaddr* addr,\n-                        socklen_t len,\n-                        unsigned flags) {\n+static int uv__bind(uv_udp_t* handle,\n+                    int domain,\n+                    struct sockaddr* addr,\n+                    socklen_t len,\n+                    unsigned flags) {\n   int saved_errno;\n   int status;\n   int yes;\n   int fd;\n \n   saved_errno = errno;\n   status = -1;\n+  fd = -1;\n \n   /* Check for bad flags. */\n   if (flags & ~UV_UDP_IPV6ONLY) {\n-    uv_err_new(handle->loop, EINVAL);\n+    uv__set_sys_error(handle->loop, EINVAL);\n     goto out;\n   }\n \n   /* Cannot set IPv6-only mode on non-IPv6 socket. */\n   if ((flags & UV_UDP_IPV6ONLY) && domain != AF_INET6) {\n-    uv_err_new(handle->loop, EINVAL);\n+    uv__set_sys_error(handle->loop, EINVAL);\n     goto out;\n   }\n \n   /* Check for already active socket. */\n   if (handle->fd != -1) {\n-    uv_err_new_artificial(handle->loop, UV_EALREADY);\n+    uv__set_artificial_error(handle->loop, UV_EALREADY);\n     goto out;\n   }\n \n   if ((fd = uv__socket(domain, SOCK_DGRAM, 0)) == -1) {\n-    uv_err_new(handle->loop, errno);\n+    uv__set_sys_error(handle->loop, errno);\n     goto out;\n   }\n \n   if (flags & UV_UDP_IPV6ONLY) {\n #ifdef IPV6_V6ONLY\n     yes = 1;\n     if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &yes, sizeof yes) == -1) {\n-      uv_err_new(handle->loop, errno);\n+      uv__set_sys_error(handle->loop, errno);\n       goto out;\n     }\n #else\n-    uv_err_new((uv_handle_t*)handle, ENOTSUP);\n+    uv__set_sys_error((uv_handle_t*)handle, ENOTSUP);\n     goto out;\n #endif\n   }\n \n   if (bind(fd, addr, len) == -1) {\n-    uv_err_new(handle->loop, errno);\n+    uv__set_sys_error(handle->loop, errno);\n     goto out;\n   }\n \n@@ -388,7 +387,7 @@ static int uv__udp_maybe_deferred_bind(uv_udp_t* handle, int domain) {\n     abort();\n   }\n \n-  return uv__udp_bind(handle, domain, (struct sockaddr*)&taddr, addrlen, 0);\n+  return uv__bind(handle, domain, (struct sockaddr*)&taddr, addrlen, 0);\n }\n \n \n@@ -416,7 +415,7 @@ static int uv__udp_send(uv_udp_send_t* req,\n     req->bufs = req->bufsml;\n   }\n   else if ((req->bufs = malloc(bufcnt * sizeof(bufs[0]))) == NULL) {\n-    uv_err_new(handle->loop, ENOMEM);\n+    uv__set_sys_error(handle->loop, ENOMEM);\n     return -1;\n   }\n   memcpy(req->bufs, bufs, bufcnt * sizeof(bufs[0]));\n@@ -442,21 +441,57 @@ int uv_udp_init(uv_loop_t* loop, uv_udp_t* handle) {\n }\n \n \n-int uv_udp_bind(uv_udp_t* handle, struct sockaddr_in addr, unsigned flags) {\n-  return uv__udp_bind(handle,\n-                      AF_INET,\n-                      (struct sockaddr*)&addr,\n-                      sizeof addr,\n-                      flags);\n+int uv__udp_bind(uv_udp_t* handle, struct sockaddr_in addr, unsigned flags) {\n+  return uv__bind(handle,\n+                  AF_INET,\n+                  (struct sockaddr*)&addr,\n+                  sizeof addr,\n+                  flags);\n }\n \n \n-int uv_udp_bind6(uv_udp_t* handle, struct sockaddr_in6 addr, unsigned flags) {\n-  return uv__udp_bind(handle,\n-                      AF_INET6,\n-                      (struct sockaddr*)&addr,\n-                      sizeof addr,\n-                      flags);\n+int uv__udp_bind6(uv_udp_t* handle, struct sockaddr_in6 addr, unsigned flags) {\n+  return uv__bind(handle,\n+                  AF_INET6,\n+                  (struct sockaddr*)&addr,\n+                  sizeof addr,\n+                  flags);\n+}\n+\n+\n+int uv_udp_set_membership(uv_udp_t* handle, const char* multicast_addr,\n+  const char* interface_addr, uv_membership membership) {\n+\n+  int optname;\n+  struct ip_mreq mreq;\n+  memset(&mreq, 0, sizeof mreq);\n+\n+  if (interface_addr) {\n+    mreq.imr_interface.s_addr = inet_addr(interface_addr);\n+  } else {\n+    mreq.imr_interface.s_addr = htonl(INADDR_ANY);\n+  }\n+\n+  mreq.imr_multiaddr.s_addr = inet_addr(multicast_addr);\n+\n+  switch (membership) {\n+  case UV_JOIN_GROUP:\n+    optname = IP_ADD_MEMBERSHIP;\n+    break;\n+  case UV_LEAVE_GROUP:\n+    optname = IP_DROP_MEMBERSHIP;\n+    break;\n+  default:\n+    uv__set_sys_error(handle->loop, EFAULT);\n+    return -1;\n+  }\n+\n+  if (setsockopt(handle->fd, IPPROTO_IP, optname, (void*) &mreq, sizeof mreq) == -1) {\n+    uv__set_sys_error(handle->loop, errno);\n+    return -1;\n+  }\n+\n+  return 0;\n }\n \n \n@@ -470,7 +505,7 @@ int uv_udp_getsockname(uv_udp_t* handle, struct sockaddr* name,\n   saved_errno = errno;\n \n   if (handle->fd < 0) {\n-    uv_err_new(handle->loop, EINVAL);\n+    uv__set_sys_error(handle->loop, EINVAL);\n     rv = -1;\n     goto out;\n   }\n@@ -479,7 +514,7 @@ int uv_udp_getsockname(uv_udp_t* handle, struct sockaddr* name,\n   socklen = (socklen_t)*namelen;\n \n   if (getsockname(handle->fd, name, &socklen) == -1) {\n-    uv_err_new(handle->loop, errno);\n+    uv__set_sys_error(handle->loop, errno);\n     rv = -1;\n   } else {\n     *namelen = (int)socklen;\n@@ -527,12 +562,12 @@ int uv_udp_recv_start(uv_udp_t* handle,\n                       uv_alloc_cb alloc_cb,\n                       uv_udp_recv_cb recv_cb) {\n   if (alloc_cb == NULL || recv_cb == NULL) {\n-    uv_err_new_artificial(handle->loop, UV_EINVAL);\n+    uv__set_artificial_error(handle->loop, UV_EINVAL);\n     return -1;\n   }\n \n   if (ev_is_active(&handle->read_watcher)) {\n-    uv_err_new_artificial(handle->loop, UV_EALREADY);\n+    uv__set_artificial_error(handle->loop, UV_EALREADY);\n     return -1;\n   }\n "}, {"sha": "b42c761e13f106414de166b0c44aaf3ad24c1cd7", "filename": "src/rt/libuv/src/uv-common.c", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -76,12 +76,14 @@ const char* uv_err_name(uv_err_t err) {\n     case UV_ENFILE: return \"ENFILE\";\n     case UV_ENOBUFS: return \"ENOBUFS\";\n     case UV_ENOMEM: return \"ENOMEM\";\n+    case UV_ENOTDIR: return \"ENOTDIR\";\n     case UV_ENONET: return \"ENONET\";\n     case UV_ENOPROTOOPT: return \"ENOPROTOOPT\";\n     case UV_ENOTCONN: return \"ENOTCONN\";\n     case UV_ENOTSOCK: return \"ENOTSOCK\";\n     case UV_ENOTSUP: return \"ENOTSUP\";\n     case UV_ENOENT: return \"ENOENT\";\n+    case UV_ENOSYS: return \"ENOSYS\";\n     case UV_EPIPE: return \"EPIPE\";\n     case UV_EPROTO: return \"EPROTO\";\n     case UV_EPROTONOSUPPORT: return \"EPROTONOSUPPORT\";\n@@ -95,6 +97,29 @@ const char* uv_err_name(uv_err_t err) {\n }\n \n \n+void uv__set_error(uv_loop_t* loop, uv_err_code code, int sys_error) {\n+  loop->last_err.code = code;\n+  loop->last_err.sys_errno_ = sys_error;\n+}\n+\n+\n+void uv__set_sys_error(uv_loop_t* loop, int sys_error) {\n+  loop->last_err.code = uv_translate_sys_error(sys_error);\n+  loop->last_err.sys_errno_ = sys_error;\n+}\n+\n+\n+void uv__set_artificial_error(uv_loop_t* loop, uv_err_code code) {\n+  loop->last_err.code = code;\n+  loop->last_err.sys_errno_ = 0;\n+}\n+\n+\n+uv_err_t uv_last_error(uv_loop_t* loop) {\n+  return loop->last_err;\n+}\n+\n+\n struct sockaddr_in uv_ip4_addr(const char* ip, int port) {\n   struct sockaddr_in addr;\n \n@@ -183,3 +208,65 @@ void uv_remove_ares_handle(uv_ares_task_t* handle) {\n int uv_ares_handles_empty(uv_loop_t* loop) {\n   return loop->uv_ares_handles_ ? 0 : 1;\n }\n+\n+int uv_tcp_bind(uv_tcp_t* handle, struct sockaddr_in addr) {\n+  if (handle->type != UV_TCP || addr.sin_family != AF_INET) {\n+    uv__set_artificial_error(handle->loop, UV_EFAULT);\n+    return -1;\n+  }\n+\n+  return uv__tcp_bind(handle, addr);\n+}\n+\n+int uv_tcp_bind6(uv_tcp_t* handle, struct sockaddr_in6 addr) {\n+  if (handle->type != UV_TCP || addr.sin6_family != AF_INET6) {\n+    uv__set_artificial_error(handle->loop, UV_EFAULT);\n+    return -1;\n+  }\n+\n+  return uv__tcp_bind6(handle, addr);\n+}\n+\n+int uv_udp_bind(uv_udp_t* handle, struct sockaddr_in addr,\n+    unsigned int flags) {\n+  if (handle->type != UV_UDP || addr.sin_family != AF_INET) {\n+    uv__set_artificial_error(handle->loop, UV_EFAULT);\n+    return -1;\n+  }\n+\n+  return uv__udp_bind(handle, addr, flags);\n+}\n+\n+int uv_udp_bind6(uv_udp_t* handle, struct sockaddr_in6 addr,\n+    unsigned int flags) {\n+  if (handle->type != UV_UDP || addr.sin6_family != AF_INET6) {\n+    uv__set_artificial_error(handle->loop, UV_EFAULT);\n+    return -1;\n+  }\n+\n+  return uv__udp_bind6(handle, addr, flags);\n+}\n+\n+int uv_tcp_connect(uv_connect_t* req,\n+                   uv_tcp_t* handle,\n+                   struct sockaddr_in address,\n+                   uv_connect_cb cb) {\n+  if (handle->type != UV_TCP || address.sin_family != AF_INET) {\n+    uv__set_artificial_error(handle->loop, UV_EINVAL);\n+    return -1;\n+  }\n+\n+  return uv__tcp_connect(req, handle, address, cb);\n+}\n+\n+int uv_tcp_connect6(uv_connect_t* req,\n+                    uv_tcp_t* handle,\n+                    struct sockaddr_in6 address,\n+                    uv_connect_cb cb) {\n+  if (handle->type != UV_TCP || address.sin6_family != AF_INET6) {\n+    uv__set_artificial_error(handle->loop, UV_EINVAL);\n+    return -1;\n+  }\n+\n+  return uv__tcp_connect6(req, handle, address, cb);\n+}"}, {"sha": "ff81e0dc0a8687bec192ba1d015d09e107060754", "filename": "src/rt/libuv/src/uv-common.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -48,5 +48,26 @@ void uv_add_ares_handle(uv_loop_t* loop, uv_ares_task_t* handle);\n \n int uv_ares_handles_empty(uv_loop_t* loop);\n \n+uv_err_code uv_translate_sys_error(int sys_errno);\n+void uv__set_error(uv_loop_t* loop, uv_err_code code, int sys_error);\n+void uv__set_sys_error(uv_loop_t* loop, int sys_error);\n+void uv__set_artificial_error(uv_loop_t* loop, uv_err_code code);\n+\n+int uv__tcp_bind(uv_tcp_t* handle, struct sockaddr_in addr);\n+int uv__tcp_bind6(uv_tcp_t* handle, struct sockaddr_in6 addr);\n+\n+int uv__udp_bind(uv_udp_t* handle, struct sockaddr_in addr, unsigned flags);\n+int uv__udp_bind6(uv_udp_t* handle, struct sockaddr_in6 addr, unsigned flags);\n+\n+int uv__tcp_connect(uv_connect_t* req,\n+                   uv_tcp_t* handle,\n+                   struct sockaddr_in address,\n+                   uv_connect_cb cb);\n+\n+int uv__tcp_connect6(uv_connect_t* req,\n+                    uv_tcp_t* handle,\n+                    struct sockaddr_in6 address,\n+                    uv_connect_cb cb);\n+\n \n #endif /* UV_COMMON_H_ */"}, {"sha": "ecdc5fb05193daa2ffa72c0b582b77a6e6c9ebe1", "filename": "src/rt/libuv/src/win/core.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fcore.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fcore.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fcore.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -48,6 +48,9 @@ static void uv_init(void) {\n \n   /* Initialize FS */\n   uv_fs_init();\n+\n+  /* Initialize console */\n+  uv_console_init();\n }\n \n \n@@ -79,7 +82,7 @@ static void uv_loop_init(uv_loop_t* loop) {\n   loop->ares_active_sockets = 0;\n   loop->ares_chan = NULL;\n \n-  loop->last_error = uv_ok_;\n+  loop->last_err = uv_ok_;\n }\n \n "}, {"sha": "a060b2b962b513219cedb8df75e4e2007f3e3ced", "filename": "src/rt/libuv/src/win/error.c", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ferror.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ferror.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ferror.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -67,11 +67,6 @@ void uv_fatal_error(const int errorno, const char* syscall) {\n }\n \n \n-uv_err_t uv_last_error(uv_loop_t* loop) {\n-  return loop->last_error;\n-}\n-\n-\n /* TODO: thread safety */\n static char* last_err_str_ = NULL;\n \n@@ -110,6 +105,8 @@ uv_err_code uv_translate_sys_error(int sys_errno) {\n     case WSAECONNABORTED:                   return UV_ECONNABORTED;\n     case ERROR_CONNECTION_REFUSED:          return UV_ECONNREFUSED;\n     case WSAECONNREFUSED:                   return UV_ECONNREFUSED;\n+    case ERROR_NETNAME_DELETED:             return UV_ECONNRESET;\n+    case WSAECONNRESET:                     return UV_ECONNRESET;\n     case WSAEFAULT:                         return UV_EFAULT;\n     case ERROR_HOST_UNREACHABLE:            return UV_EHOSTUNREACH;\n     case WSAEHOSTUNREACH:                   return UV_EHOSTUNREACH;\n@@ -132,26 +129,8 @@ uv_err_code uv_translate_sys_error(int sys_errno) {\n     case ERROR_PIPE_BUSY:                   return UV_EBUSY;\n     case ERROR_SEM_TIMEOUT:                 return UV_ETIMEDOUT;\n     case ERROR_ALREADY_EXISTS:              return UV_EEXIST;\n+    case WSAHOST_NOT_FOUND:                 return UV_ENOENT;\n     default:                                return UV_UNKNOWN;\n   }\n }\n \n-\n-uv_err_t uv_new_sys_error(int sys_errno) {\n-  uv_err_t e;\n-  e.code = uv_translate_sys_error(sys_errno);\n-  e.sys_errno_ = sys_errno;\n-  return e;\n-}\n-\n-\n-void uv_set_sys_error(uv_loop_t* loop, int sys_errno) {\n-  loop->last_error.code = uv_translate_sys_error(sys_errno);\n-  loop->last_error.sys_errno_ = sys_errno;\n-}\n-\n-\n-void uv_set_error(uv_loop_t* loop, uv_err_code code, int sys_errno) {\n-  loop->last_error.code = code;\n-  loop->last_error.sys_errno_ = sys_errno;\n-}"}, {"sha": "a416df2f5044adcdac87b0f0a110975b37ba92a4", "filename": "src/rt/libuv/src/win/fs-event.c", "status": "modified", "additions": 55, "deletions": 24, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs-event.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs-event.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs-event.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -41,7 +41,8 @@ static void uv_fs_event_init_handle(uv_loop_t* loop, uv_fs_event_t* handle,\n   handle->buffer = NULL;\n   handle->req_pending = 0;\n   handle->filew = NULL;\n-  \n+  handle->short_filew = NULL;\n+\n   uv_req_init(loop, (uv_req_t*)&handle->req);\n   handle->req.type = UV_FS_EVENT_REQ;\n   handle->req.data = (void*)handle;\n@@ -95,25 +96,29 @@ static int uv_split_path(const wchar_t* filename, wchar_t** dir,\n   while (i > 0 && filename[--i] != '\\\\' && filename[i] != '/');\n \n   if (i == 0) {\n-    *dir = (wchar_t*)malloc((MAX_PATH + 1) * sizeof(wchar_t));\n-    if (!*dir) {\n-      uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");\n-    }\n-\n-    if (!GetCurrentDirectoryW(MAX_PATH, *dir)) {\n-      free(*dir);\n-      *dir = NULL;\n-      return -1;\n+    if (dir) {\n+      *dir = (wchar_t*)malloc((MAX_PATH + 1) * sizeof(wchar_t));\n+      if (!*dir) {\n+        uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");\n+      }\n+\n+      if (!GetCurrentDirectoryW(MAX_PATH, *dir)) {\n+        free(*dir);\n+        *dir = NULL;\n+        return -1;\n+      }\n     }\n     \n     *file = wcsdup(filename);\n   } else {\n-    *dir = (wchar_t*)malloc((i + 1) * sizeof(wchar_t));\n-    if (!*dir) {\n-      uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");\n+    if (dir) {\n+      *dir = (wchar_t*)malloc((i + 1) * sizeof(wchar_t));\n+      if (!*dir) {\n+        uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");\n+      }\n+      wcsncpy(*dir, filename, i);\n+      (*dir)[i] = L'\\0';\n     }\n-    wcsncpy(*dir, filename, i);\n-    (*dir)[i] = L'\\0';\n \n     *file = (wchar_t*)malloc((len - i) * sizeof(wchar_t));\n     if (!*file) {\n@@ -132,6 +137,7 @@ int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle,\n   int name_size;\n   DWORD attr, last_error;\n   wchar_t* dir = NULL, *dir_to_watch, *filenamew;\n+  wchar_t short_path[MAX_PATH];\n \n   uv_fs_event_init_handle(loop, handle, filename, cb);\n \n@@ -144,7 +150,7 @@ int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle,\n \n   if (!uv_utf8_to_utf16(filename, filenamew, \n       name_size / sizeof(wchar_t))) {\n-    uv_set_sys_error(loop, GetLastError());\n+    uv__set_sys_error(loop, GetLastError());\n     return -1;\n   }\n \n@@ -165,11 +171,23 @@ int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle,\n      * filename is a file.  So we split filename into dir & file parts, and\n      * watch the dir directory.\n      */\n+    \n+    /* Convert to short path. */\n+    if (!GetShortPathNameW(filenamew, short_path, COUNTOF(short_path))) {\n+      last_error = GetLastError();\n+      goto error;\n+    }\n+\n     if (uv_split_path(filenamew, &dir, &handle->filew) != 0) {\n       last_error = GetLastError();\n       goto error;\n     }\n \n+    if (uv_split_path(short_path, NULL, &handle->short_filew) != 0) {\n+      last_error = GetLastError();\n+      goto error;\n+    }\n+\n     dir_to_watch = dir;\n   }\n \n@@ -194,9 +212,9 @@ int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle,\n   }\n \n   if (CreateIoCompletionPort(handle->dir_handle,\n-                              loop->iocp,\n-                              (ULONG_PTR)handle,\n-                              0) == NULL) {\n+                             loop->iocp,\n+                             (ULONG_PTR)handle,\n+                             0) == NULL) {\n     last_error = GetLastError();\n     goto error;\n   }\n@@ -242,6 +260,11 @@ int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle,\n     handle->filew = NULL;\n   }\n \n+  if (handle->short_filew) {\n+    free(handle->short_filew);\n+    handle->short_filew = NULL;\n+  }\n+\n   if (handle->dir_handle != INVALID_HANDLE_VALUE) {\n     CloseHandle(handle->dir_handle);\n     handle->dir_handle = INVALID_HANDLE_VALUE;\n@@ -252,7 +275,7 @@ int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle,\n     handle->buffer = NULL;\n   }\n \n-  uv_set_sys_error(loop, last_error);\n+  uv__set_sys_error(loop, last_error);\n   return -1;\n }\n \n@@ -279,8 +302,11 @@ void uv_process_fs_event_req(uv_loop_t* loop, uv_req_t* req,\n          * Fire the event only if we were asked to watch a directory,\n          * or if the filename filter matches.\n          */\n-        if (handle->is_path_dir || _wcsnicmp(handle->filew, file_info->FileName,\n-          file_info->FileNameLength / sizeof(wchar_t)) == 0) {\n+        if (handle->is_path_dir ||\n+          _wcsnicmp(handle->filew, file_info->FileName,\n+            file_info->FileNameLength / sizeof(wchar_t)) == 0 ||\n+          _wcsnicmp(handle->short_filew, file_info->FileName,\n+            file_info->FileNameLength / sizeof(wchar_t)) == 0) {\n         \n           /* Convert the filename to utf8. */\n           utf8size = uv_utf16_to_utf8(file_info->FileName,\n@@ -300,7 +326,7 @@ void uv_process_fs_event_req(uv_loop_t* loop, uv_req_t* req,\n                                         filename,\n                                         utf8size);\n             if (utf8size) {\n-              filename[utf8size] = L'\\0';\n+              filename[utf8size] = '\\0';\n             } else {\n               free(filename);\n               filename = NULL;\n@@ -330,7 +356,7 @@ void uv_process_fs_event_req(uv_loop_t* loop, uv_req_t* req,\n       handle->cb(handle, NULL, UV_CHANGE, 0);\n     }\n   } else {\n-    loop->last_error = GET_REQ_UV_ERROR(req);\n+    uv__set_sys_error(loop, GET_REQ_ERROR(req));\n     handle->cb(handle, NULL, 0, -1);\n   }\n \n@@ -370,6 +396,11 @@ void uv_fs_event_endgame(uv_loop_t* loop, uv_fs_event_t* handle) {\n       handle->filew = NULL;\n     }\n \n+    if (handle->short_filew) {\n+      free(handle->short_filew);\n+      handle->short_filew = NULL;\n+    }\n+\n     if (handle->filename) {\n       free(handle->filename);\n       handle->filename = NULL;"}, {"sha": "a2c572d64f0d4db3a110d9351e10e94c76d60214", "filename": "src/rt/libuv/src/win/fs.c", "status": "modified", "additions": 334, "deletions": 122, "changes": 456, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -40,13 +40,28 @@\n #define UV_FS_CLEANEDUP          0x0010\n #define UV_FS_LAST_ERROR_SET     0x0020\n \n+\n+#define UTF8_TO_UTF16(s, t)                                                 \\\n+  size = uv_utf8_to_utf16(s, NULL, 0) * sizeof(wchar_t);                    \\\n+  t = (wchar_t*)malloc(size);                                               \\\n+  if (!t) {                                                                 \\\n+    uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");                            \\\n+  }                                                                         \\\n+  if (!uv_utf8_to_utf16(s, t, size / sizeof(wchar_t))) {                    \\\n+    uv__set_sys_error(loop, GetLastError());                                \\\n+    return -1;                                                              \\\n+  }\n+\n #define STRDUP_ARG(req, i)                                                  \\\n   req->arg##i = (void*)strdup((const char*)req->arg##i);                    \\\n   if (!req->arg##i) {                                                       \\\n     uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");                            \\\n   }                                                                         \\\n   req->flags |= UV_FS_FREE_ARG##i;\n \n+#define SET_ALLOCED_ARG(req, i)                                             \\\n+  req->flags |= UV_FS_FREE_ARG##i;\n+\n #define WRAP_REQ_ARGS1(req, a0)                                             \\\n   req->arg0 = (void*)a0;\n \n@@ -66,16 +81,17 @@\n   if (!QueueUserWorkItem(&uv_fs_thread_proc,                                \\\n                          req,                                               \\\n                          WT_EXECUTELONGFUNCTION)) {                         \\\n-    uv_set_sys_error((loop), GetLastError());                               \\\n+    uv__set_sys_error((loop), GetLastError());                              \\\n     return -1;                                                              \\\n   }                                                                         \\\n   req->flags |= UV_FS_ASYNC_QUEUED;                                         \\\n   uv_ref((loop));\n \n-\n #define SET_UV_LAST_ERROR_FROM_REQ(req)                                     \\\n   if (req->flags & UV_FS_LAST_ERROR_SET) {                                  \\\n-    uv_set_sys_error(req->loop, req->last_error);                           \\\n+    uv__set_sys_error(req->loop, req->last_error);                          \\\n+  } else if (req->result == -1) {                                           \\\n+    uv__set_error(req->loop, (uv_err_code)req->errorno, req->last_error);   \\\n   }\n \n #define SET_REQ_LAST_ERROR(req, error)                                      \\\n@@ -85,22 +101,31 @@\n #define SET_REQ_RESULT(req, result_value)                                   \\\n   req->result = (result_value);                                             \\\n   if (req->result == -1) {                                                  \\\n-    req->errorno = uv_translate_sys_error(_doserrno);                       \\\n+    req->last_error = _doserrno;                                            \\\n+    req->errorno = uv_translate_sys_error(req->last_error);                 \\\n   }\n \n #define SET_REQ_RESULT_WIN32_ERROR(req, sys_errno)                          \\\n   req->result = -1;                                                         \\\n   req->errorno = uv_translate_sys_error(sys_errno);                         \\\n   SET_REQ_LAST_ERROR(req, sys_errno);\n \n+#define VERIFY_UV_FILE(file, req)                                           \\\n+  if (file == -1) {                                                         \\\n+    req->result = -1;                                                       \\\n+    req->errorno = UV_EBADF;                                                \\\n+    req->last_error = ERROR_SUCCESS;                                        \\\n+    return;                                                                 \\\n+  }\n+\n \n void uv_fs_init() {\n   _fmode = _O_BINARY;\n }\n \n \n static void uv_fs_req_init_async(uv_loop_t* loop, uv_fs_t* req,\n-    uv_fs_type fs_type, const char* path, uv_fs_cb cb) {\n+    uv_fs_type fs_type, const char* path, const wchar_t* pathw, uv_fs_cb cb) {\n   uv_req_init(loop, (uv_req_t*) req);\n   req->type = UV_FS;\n   req->loop = loop;\n@@ -110,6 +135,7 @@ static void uv_fs_req_init_async(uv_loop_t* loop, uv_fs_t* req,\n   req->result = 0;\n   req->ptr = NULL;\n   req->path = path ? strdup(path) : NULL;\n+  req->pathw = (wchar_t*)pathw;\n   req->errorno = 0;\n   req->last_error = 0;\n   memset(&req->overlapped, 0, sizeof(req->overlapped));\n@@ -126,11 +152,12 @@ static void uv_fs_req_init_sync(uv_loop_t* loop, uv_fs_t* req,\n   req->result = 0;\n   req->ptr = NULL;\n   req->path = NULL;\n+  req->pathw = NULL;\n   req->errorno = 0;\n }\n \n \n-void fs__open(uv_fs_t* req, const char* path, int flags, int mode) {\n+void fs__open(uv_fs_t* req, const wchar_t* path, int flags, int mode) {\n   DWORD access;\n   DWORD share;\n   DWORD disposition;\n@@ -221,7 +248,12 @@ void fs__open(uv_fs_t* req, const char* path, int flags, int mode) {\n     goto end;\n   }\n \n-  file = CreateFileA(path,\n+  /* Figure out whether path is a file or a directory. */\n+  if (GetFileAttributesW(path) & FILE_ATTRIBUTE_DIRECTORY) {\n+    attributes |= FILE_FLAG_BACKUP_SEMANTICS;\n+  }\n+\n+  file = CreateFileW(path,\n                      access,\n                      share,\n                      NULL,\n@@ -238,7 +270,11 @@ void fs__open(uv_fs_t* req, const char* path, int flags, int mode) {\n }\n \n void fs__close(uv_fs_t* req, uv_file file) {\n-  int result = _close(file);\n+  int result;\n+\n+  VERIFY_UV_FILE(file, req);\n+\n+  result = _close(file);\n   SET_REQ_RESULT(req, result);\n }\n \n@@ -250,6 +286,8 @@ void fs__read(uv_fs_t* req, uv_file file, void *buf, size_t length,\n   LARGE_INTEGER offset_;\n   DWORD bytes;\n \n+  VERIFY_UV_FILE(file, req);\n+\n   handle = (HANDLE) _get_osfhandle(file);\n   if (handle == INVALID_HANDLE_VALUE) {\n     SET_REQ_RESULT(req, -1);\n@@ -288,6 +326,8 @@ void fs__write(uv_fs_t* req, uv_file file, void *buf, size_t length,\n   LARGE_INTEGER offset_;\n   DWORD bytes;\n \n+  VERIFY_UV_FILE(file, req);\n+\n   handle = (HANDLE) _get_osfhandle(file);\n   if (handle == INVALID_HANDLE_VALUE) {\n     SET_REQ_RESULT(req, -1);\n@@ -319,93 +359,135 @@ void fs__write(uv_fs_t* req, uv_file file, void *buf, size_t length,\n }\n \n \n-void fs__unlink(uv_fs_t* req, const char* path) {\n-  int result = _unlink(path);\n+void fs__unlink(uv_fs_t* req, const wchar_t* path) {\n+  int result = _wunlink(path);\n   SET_REQ_RESULT(req, result);\n }\n \n \n-void fs__mkdir(uv_fs_t* req, const char* path, int mode) {\n-  int result = _mkdir(path);\n+void fs__mkdir(uv_fs_t* req, const wchar_t* path, int mode) {\n+  int result = _wmkdir(path);\n   SET_REQ_RESULT(req, result);\n }\n \n \n-void fs__rmdir(uv_fs_t* req, const char* path) {\n-  int result = _rmdir(path);\n+void fs__rmdir(uv_fs_t* req, const wchar_t* path) {\n+  int result = _wrmdir(path);\n   SET_REQ_RESULT(req, result);\n }\n \n \n-void fs__readdir(uv_fs_t* req, const char* path, int flags) {\n-  int result;\n-  char* buf, *ptr, *name;\n+void fs__readdir(uv_fs_t* req, const wchar_t* path, int flags) {\n+  int result, size;\n+  wchar_t* buf = NULL, *ptr, *name;\n   HANDLE dir;\n-  WIN32_FIND_DATAA ent = {0};\n-  size_t len = strlen(path);\n+  WIN32_FIND_DATAW ent = {0};\n+  size_t len = wcslen(path);\n   size_t buf_size = 4096;\n-  const char* fmt = !len                                            ? \"./*\"\n-                  : (path[len - 1] == '/' || path[len - 1] == '\\\\') ? \"%s*\"\n-                  :                                                   \"%s\\\\*\";\n+  wchar_t* path2;\n+  const wchar_t* fmt = !len                                         ? L\"./*\"\n+                : (path[len - 1] == L'/' || path[len - 1] == L'\\\\') ? L\"%s*\"\n+                :                                                     L\"%s\\\\*\";\n+\n+  /* Figure out whether path is a file or a directory. */\n+  if (!(GetFileAttributesW(path) & FILE_ATTRIBUTE_DIRECTORY)) {\n+    req->result = -1;\n+    req->errorno = UV_ENOTDIR;\n+    req->last_error = ERROR_SUCCESS;\n+    return;\n+  }\n \n-  char* path2 = (char*)malloc(len + 4);\n+  path2 = (wchar_t*)malloc(sizeof(wchar_t) * (len + 4));\n   if (!path2) {\n     uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");\n   }\n \n-  sprintf(path2, fmt, path);\n-  dir = FindFirstFileA(path2, &ent);\n+#ifdef _MSC_VER\n+  swprintf(path2, len + 3, fmt, path);\n+#else\n+  swprintf(path2, fmt, path);\n+#endif\n+  dir = FindFirstFileW(path2, &ent);\n   free(path2);\n \n   if(dir == INVALID_HANDLE_VALUE) {\n     SET_REQ_RESULT_WIN32_ERROR(req, GetLastError());\n     return;\n   }\n \n-  buf = (char*)malloc(buf_size);\n-  if (!buf) {\n-    uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");\n-  }\n-\n-  ptr = buf;\n   result = 0;\n \n   do {\n     name = ent.cFileName;\n \n-    if (name[0] != '.' || (name[1] && (name[1] != '.' || name[2]))) {\n-      len = strlen(name);\n+    if (name[0] != L'.' || (name[1] && (name[1] != L'.' || name[2]))) {\n+      len = wcslen(name);\n+\n+      if (!buf) {\n+        buf = (wchar_t*)malloc(buf_size * sizeof(wchar_t));\n+        if (!buf) {\n+          uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");\n+        }\n+\n+        ptr = buf;\n+      }\n \n       while ((ptr - buf) + len + 1 > buf_size) {\n         buf_size *= 2;\n         path2 = buf;\n-        buf = (char*)realloc(buf, buf_size);\n+        buf = (wchar_t*)realloc(buf, buf_size * sizeof(wchar_t));\n         if (!buf) {\n           uv_fatal_error(ERROR_OUTOFMEMORY, \"realloc\");\n         }\n \n         ptr = buf + (ptr - path2);\n       }\n \n-      strcpy(ptr, name);\n+      wcscpy(ptr, name);\n       ptr += len + 1;\n       result++;\n     }\n-  } while(FindNextFileA(dir, &ent));\n+  } while(FindNextFileW(dir, &ent));\n \n   FindClose(dir);\n \n-  req->ptr = buf;\n-  req->flags |= UV_FS_FREE_PTR;\n+  if (buf) {\n+    /* Convert result to UTF8. */\n+    size = uv_utf16_to_utf8(buf, buf_size / sizeof(wchar_t), NULL, 0);\n+    if (!size) {\n+      SET_REQ_RESULT_WIN32_ERROR(req, GetLastError());\n+      return;\n+    }\n+\n+    req->ptr = (char*)malloc(size + 1);\n+    if (!req->ptr) {\n+      uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");\n+    }\n+\n+    size = uv_utf16_to_utf8(buf, buf_size / sizeof(wchar_t), (char*)req->ptr, size);\n+    if (!size) {\n+      free(buf);\n+      free(req->ptr);\n+      req->ptr = NULL;\n+      SET_REQ_RESULT_WIN32_ERROR(req, GetLastError());\n+      return;\n+    }\n+    free(buf);\n+\n+    ((char*)req->ptr)[size] = '\\0';\n+    req->flags |= UV_FS_FREE_PTR;\n+  } else {\n+    req->ptr = NULL;\n+  }\n \n   SET_REQ_RESULT(req, result);\n }\n \n \n-void fs__stat(uv_fs_t* req, const char* path) {\n+void fs__stat(uv_fs_t* req, const wchar_t* path) {\n   int result;\n \n-  result = _stati64(path, &req->stat);\n+  result = _wstati64(path, &req->stat);\n   if (result == -1) {\n     req->ptr = NULL;\n   } else {\n@@ -419,6 +501,8 @@ void fs__stat(uv_fs_t* req, const char* path) {\n void fs__fstat(uv_fs_t* req, uv_file file) {\n   int result;\n \n+  VERIFY_UV_FILE(file, req);\n+\n   result = _fstati64(file, &req->stat);\n   if (result == -1) {\n     req->ptr = NULL;\n@@ -430,14 +514,18 @@ void fs__fstat(uv_fs_t* req, uv_file file) {\n }\n \n \n-void fs__rename(uv_fs_t* req, const char* path, const char* new_path) {\n-  int result = rename(path, new_path);\n+void fs__rename(uv_fs_t* req, const wchar_t* path, const wchar_t* new_path) {\n+  int result = _wrename(path, new_path);\n   SET_REQ_RESULT(req, result);\n }\n \n \n void fs__fsync(uv_fs_t* req, uv_file file) {\n-  int result = FlushFileBuffers((HANDLE)_get_osfhandle(file)) ? 0 : -1;\n+  int result;\n+\n+  VERIFY_UV_FILE(file, req);\n+\n+  result = FlushFileBuffers((HANDLE)_get_osfhandle(file)) ? 0 : -1;\n   if (result == -1) {\n     SET_REQ_RESULT_WIN32_ERROR(req, GetLastError());\n   } else {\n@@ -447,7 +535,11 @@ void fs__fsync(uv_fs_t* req, uv_file file) {\n \n \n void fs__ftruncate(uv_fs_t* req, uv_file file, off_t offset) {\n-  int result = _chsize(file, offset);\n+  int result;\n+\n+  VERIFY_UV_FILE(file, req);\n+\n+  result = _chsize(file, offset);\n   SET_REQ_RESULT(req, result);\n }\n \n@@ -492,8 +584,8 @@ void fs__sendfile(uv_fs_t* req, uv_file out_file, uv_file in_file,\n }\n \n \n-void fs__chmod(uv_fs_t* req, const char* path, int mode) {\n-  int result = _chmod(path, mode);\n+void fs__chmod(uv_fs_t* req, const wchar_t* path, int mode) {\n+  int result = _wchmod(path, mode);\n   SET_REQ_RESULT(req, result);\n }\n \n@@ -505,6 +597,8 @@ void fs__fchmod(uv_fs_t* req, uv_file file, int mode) {\n   IO_STATUS_BLOCK io_status;\n   FILE_BASIC_INFORMATION file_info;\n \n+  VERIFY_UV_FILE(file, req);\n+\n   handle = (HANDLE)_get_osfhandle(file);\n \n   nt_status = pNtQueryInformationFile(handle,\n@@ -542,24 +636,27 @@ void fs__fchmod(uv_fs_t* req, uv_file file, int mode) {\n }\n \n \n-void fs__utime(uv_fs_t* req, const char* path, double atime, double mtime) {\n+void fs__utime(uv_fs_t* req, const wchar_t* path, double atime, double mtime) {\n   int result;\n   struct _utimbuf b = {(time_t)atime, (time_t)mtime};\n-  result = _utime(path, &b);\n+  result = _wutime(path, &b);\n   SET_REQ_RESULT(req, result);\n }\n \n \n void fs__futime(uv_fs_t* req, uv_file file, double atime, double mtime) {\n   int result;\n   struct _utimbuf b = {(time_t)atime, (time_t)mtime};\n+\n+  VERIFY_UV_FILE(file, req);\n+\n   result = _futime(file, &b);\n   SET_REQ_RESULT(req, result);\n }\n \n \n-void fs__link(uv_fs_t* req, const char* path, const char* new_path) {\n-  int result = CreateHardLinkA(new_path, path, NULL) ? 0 : -1;\n+void fs__link(uv_fs_t* req, const wchar_t* path, const wchar_t* new_path) {\n+  int result = CreateHardLinkW(new_path, path, NULL) ? 0 : -1;\n   if (result == -1) {\n     SET_REQ_RESULT_WIN32_ERROR(req, GetLastError());\n   } else {\n@@ -568,26 +665,29 @@ void fs__link(uv_fs_t* req, const char* path, const char* new_path) {\n }\n \n \n-void fs__symlink(uv_fs_t* req, const char* path, const char* new_path,\n+void fs__symlink(uv_fs_t* req, const wchar_t* path, const wchar_t* new_path,\n                  int flags) {\n   int result;\n-  if (pCreateSymbolicLinkA) {\n-    result = pCreateSymbolicLinkA(new_path,\n+  if (pCreateSymbolicLinkW) {\n+    result = pCreateSymbolicLinkW(new_path,\n                                   path,\n                                   flags & UV_FS_SYMLINK_DIR ? SYMBOLIC_LINK_FLAG_DIRECTORY : 0) ? 0 : -1;\n     if (result == -1) {\n-      SET_REQ_LAST_ERROR(req, GetLastError());\n+      SET_REQ_RESULT_WIN32_ERROR(req, GetLastError());\n+      return;\n     }\n   } else {\n-    result = -1;\n-    errno = ENOSYS;\n+    req->result = -1;\n+    req->errorno = UV_ENOTSUP;\n+    req->last_error = ERROR_SUCCESS;\n+    return;\n   }\n   \n   SET_REQ_RESULT(req, result);\n }\n \n \n-void fs__readlink(uv_fs_t* req, const char* path) {\n+void fs__readlink(uv_fs_t* req, const wchar_t* path) {\n   int result = -1;\n   BOOL rv;\n   HANDLE symlink;\n@@ -598,7 +698,7 @@ void fs__readlink(uv_fs_t* req, const char* path) {\n   wchar_t* substitute_name;\n   int substitute_name_length;\n \n-  symlink = CreateFileA(path,\n+  symlink = CreateFileW(path,\n                         0,\n                         0,\n                         NULL,\n@@ -632,16 +732,18 @@ void fs__readlink(uv_fs_t* req, const char* path) {\n     goto done;\n   }\n \n-  reparse_data = buffer;\n+  reparse_data = (REPARSE_DATA_BUFFER*)buffer;\n   if (reparse_data->ReparseTag != IO_REPARSE_TAG_SYMLINK) {\n     result = -1;\n     /* something is seriously wrong */\n     SET_REQ_LAST_ERROR(req, GetLastError());\n     goto done;\n   }\n \n-  substitute_name = reparse_data->SymbolicLinkReparseBuffer.PathBuffer + (reparse_data->SymbolicLinkReparseBuffer.SubstituteNameOffset / sizeof(wchar_t));\n-  substitute_name_length = reparse_data->SymbolicLinkReparseBuffer.SubstituteNameLength / sizeof(wchar_t);\n+  substitute_name = reparse_data->SymbolicLinkReparseBuffer.PathBuffer +\n+    (reparse_data->SymbolicLinkReparseBuffer.SubstituteNameOffset / sizeof(wchar_t));\n+  substitute_name_length =\n+    reparse_data->SymbolicLinkReparseBuffer.SubstituteNameLength / sizeof(wchar_t);\n \n   /* Strip off the leading \\??\\ from the substitute name buffer.*/\n   if (memcmp(substitute_name, L\"\\\\??\\\\\", 8) == 0) {\n@@ -666,7 +768,7 @@ void fs__readlink(uv_fs_t* req, const char* path) {\n \n   utf8size = uv_utf16_to_utf8(substitute_name,\n                               substitute_name_length,\n-                              req->ptr,\n+                              (char*)req->ptr,\n                               utf8size);\n   if (!utf8size) {\n     result = -1;\n@@ -705,7 +807,7 @@ static DWORD WINAPI uv_fs_thread_proc(void* parameter) {\n \n   switch (req->fs_type) {\n     case UV_FS_OPEN:\n-      fs__open(req, req->path, (int)req->arg0, (int)req->arg1);\n+      fs__open(req, req->pathw, (int)req->arg0, (int)req->arg1);\n       break;\n     case UV_FS_CLOSE:\n       fs__close(req, (uv_file)req->arg0);\n@@ -725,26 +827,26 @@ static DWORD WINAPI uv_fs_thread_proc(void* parameter) {\n                 (off_t) req->arg3);\n       break;\n     case UV_FS_UNLINK:\n-      fs__unlink(req, req->path);\n+      fs__unlink(req, req->pathw);\n       break;\n     case UV_FS_MKDIR:\n-      fs__mkdir(req, req->path, (int)req->arg0);\n+      fs__mkdir(req, req->pathw, (int)req->arg0);\n       break;\n     case UV_FS_RMDIR:\n-      fs__rmdir(req, req->path);\n+      fs__rmdir(req, req->pathw);\n       break;\n     case UV_FS_READDIR:\n-      fs__readdir(req, req->path, (int)req->arg0);\n+      fs__readdir(req, req->pathw, (int)req->arg0);\n       break;\n     case UV_FS_STAT:\n     case UV_FS_LSTAT:\n-      fs__stat(req, req->path);\n+      fs__stat(req, req->pathw);\n       break;\n     case UV_FS_FSTAT:\n       fs__fstat(req, (uv_file)req->arg0);\n       break;\n     case UV_FS_RENAME:\n-      fs__rename(req, req->path, (const char*)req->arg0);\n+      fs__rename(req, req->pathw, (const wchar_t*)req->arg0);\n       break;\n     case UV_FS_FSYNC:\n     case UV_FS_FDATASYNC:\n@@ -761,25 +863,25 @@ static DWORD WINAPI uv_fs_thread_proc(void* parameter) {\n         (size_t) req->arg3);\n       break;\n     case UV_FS_CHMOD:\n-      fs__chmod(req, req->path, (int)req->arg0);\n+      fs__chmod(req, req->pathw, (int)req->arg0);\n       break;\n     case UV_FS_FCHMOD:\n       fs__fchmod(req, (uv_file)req->arg0, (int)req->arg1);\n       break;\n     case UV_FS_UTIME:\n-      fs__utime(req, req->path, req->arg4, req->arg5);\n+      fs__utime(req, req->pathw, req->arg4, req->arg5);\n       break;\n     case UV_FS_FUTIME:\n       fs__futime(req, (uv_file)req->arg0, req->arg4, req->arg5);\n       break;\n     case UV_FS_LINK:\n-      fs__link(req, req->path, (const char*)req->arg0);\n+      fs__link(req, req->pathw, (const wchar_t*)req->arg0);\n       break;\n     case UV_FS_SYMLINK:\n-      fs__symlink(req, req->path, (const char*)req->arg0, (int)req->arg1);\n+      fs__symlink(req, req->pathw, (const wchar_t*)req->arg0, (int)req->arg1);\n       break;\n     case UV_FS_READLINK:\n-      fs__readlink(req, req->path);\n+      fs__readlink(req, req->pathw);\n       break;\n     case UV_FS_CHOWN:\n     case UV_FS_FCHOWN:\n@@ -797,13 +899,20 @@ static DWORD WINAPI uv_fs_thread_proc(void* parameter) {\n \n int uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,\n     int mode, uv_fs_cb cb) {\n+  wchar_t* pathw;\n+  int size;\n+\n+  /* Convert to UTF16. */\n+  UTF8_TO_UTF16(path, pathw);\n+\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_OPEN, path, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_OPEN, path, pathw, cb);\n     WRAP_REQ_ARGS2(req, flags, mode);\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n     uv_fs_req_init_sync(loop, req, UV_FS_OPEN);\n-    fs__open(req, path, flags, mode);\n+    fs__open(req, pathw, flags, mode);\n+    free(pathw);\n     SET_UV_LAST_ERROR_FROM_REQ(req);\n     return req->result;\n   }\n@@ -814,7 +923,7 @@ int uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,\n \n int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_CLOSE, NULL, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_CLOSE, NULL, NULL, cb);\n     WRAP_REQ_ARGS1(req, file);\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n@@ -831,7 +940,7 @@ int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n int uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file file, void* buf,\n     size_t length, off_t offset, uv_fs_cb cb) {\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_READ, NULL, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_READ, NULL, NULL, cb);\n     WRAP_REQ_ARGS4(req, file, buf, length, offset);\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n@@ -848,7 +957,7 @@ int uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file file, void* buf,\n int uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file file, void* buf,\n     size_t length, off_t offset, uv_fs_cb cb) {\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_WRITE, NULL, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_WRITE, NULL, NULL, cb);\n     WRAP_REQ_ARGS4(req, file, buf, length, offset);\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n@@ -864,12 +973,19 @@ int uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file file, void* buf,\n \n int uv_fs_unlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n     uv_fs_cb cb) {\n+  wchar_t* pathw;\n+  int size;\n+\n+  /* Convert to UTF16. */\n+  UTF8_TO_UTF16(path, pathw);\n+\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_UNLINK, path, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_UNLINK, path, pathw, cb);\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n     uv_fs_req_init_sync(loop, req, UV_FS_UNLINK);\n-    fs__unlink(req, path);\n+    fs__unlink(req, pathw);\n+    free(pathw);\n     SET_UV_LAST_ERROR_FROM_REQ(req);\n     return req->result;\n   }\n@@ -880,13 +996,20 @@ int uv_fs_unlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n \n int uv_fs_mkdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode,\n     uv_fs_cb cb) {\n+  wchar_t* pathw;\n+  int size;\n+\n+  /* Convert to UTF16. */\n+  UTF8_TO_UTF16(path, pathw);\n+\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_MKDIR, path, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_MKDIR, path, pathw, cb);\n     WRAP_REQ_ARGS1(req, mode);\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n     uv_fs_req_init_sync(loop, req, UV_FS_MKDIR);\n-    fs__mkdir(req, path, mode);\n+    fs__mkdir(req, pathw, mode);\n+    free(pathw);\n     SET_UV_LAST_ERROR_FROM_REQ(req);\n     return req->result;\n   }\n@@ -896,12 +1019,19 @@ int uv_fs_mkdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode,\n \n \n int uv_fs_rmdir(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n+  wchar_t* pathw;\n+  int size;\n+\n+  /* Convert to UTF16. */\n+  UTF8_TO_UTF16(path, pathw);\n+\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_RMDIR, path, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_RMDIR, path, pathw, cb);\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n     uv_fs_req_init_sync(loop, req, UV_FS_RMDIR);\n-    fs__rmdir(req, path);\n+    fs__rmdir(req, pathw);\n+    free(pathw);\n     SET_UV_LAST_ERROR_FROM_REQ(req);\n     return req->result;\n   }\n@@ -912,13 +1042,20 @@ int uv_fs_rmdir(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n \n int uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,\n     uv_fs_cb cb) {\n+  wchar_t* pathw;\n+  int size;\n+\n+  /* Convert to UTF16. */\n+  UTF8_TO_UTF16(path, pathw);\n+\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_READDIR, path, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_READDIR, path, pathw, cb);\n     WRAP_REQ_ARGS1(req, flags);\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n     uv_fs_req_init_sync(loop, req, UV_FS_READDIR);\n-    fs__readdir(req, path, flags);\n+    fs__readdir(req, pathw, flags);\n+    free(pathw);\n     SET_UV_LAST_ERROR_FROM_REQ(req);\n     return req->result;\n   }\n@@ -929,14 +1066,24 @@ int uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,\n \n int uv_fs_link(uv_loop_t* loop, uv_fs_t* req, const char* path,\n     const char* new_path, uv_fs_cb cb) {\n+  wchar_t* pathw;\n+  wchar_t* new_pathw;\n+  int size;\n+\n+  /* Convert to UTF16. */\n+  UTF8_TO_UTF16(path, pathw);\n+  UTF8_TO_UTF16(new_path, new_pathw);\n+\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_LINK, path, cb);\n-    WRAP_REQ_ARGS1(req, new_path);\n-    STRDUP_ARG(req, 0);\n+    uv_fs_req_init_async(loop, req, UV_FS_LINK, path, pathw, cb);\n+    WRAP_REQ_ARGS1(req, new_pathw);\n+    SET_ALLOCED_ARG(req, 0);\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n     uv_fs_req_init_sync(loop, req, UV_FS_LINK);\n-    fs__link(req, path, new_path);\n+    fs__link(req, pathw, new_pathw);\n+    free(pathw);\n+    free(new_pathw);\n     SET_UV_LAST_ERROR_FROM_REQ(req);\n     return req->result;\n   }\n@@ -947,14 +1094,24 @@ int uv_fs_link(uv_loop_t* loop, uv_fs_t* req, const char* path,\n \n int uv_fs_symlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n     const char* new_path, int flags, uv_fs_cb cb) {\n+  wchar_t* pathw;\n+  wchar_t* new_pathw;\n+  int size;\n+\n+  /* Convert to UTF16. */\n+  UTF8_TO_UTF16(path, pathw);\n+  UTF8_TO_UTF16(new_path, new_pathw);\n+\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_SYMLINK, path, cb);\n-    WRAP_REQ_ARGS2(req, new_path, flags);\n-    STRDUP_ARG(req, 0);\n+    uv_fs_req_init_async(loop, req, UV_FS_SYMLINK, path, pathw, cb);\n+    WRAP_REQ_ARGS2(req, new_pathw, flags);\n+    SET_ALLOCED_ARG(req, 0);\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n     uv_fs_req_init_sync(loop, req, UV_FS_SYMLINK);\n-    fs__symlink(req, path, new_path, flags);\n+    fs__symlink(req, pathw, new_pathw, flags);\n+    free(pathw);\n+    free(new_pathw);\n     SET_UV_LAST_ERROR_FROM_REQ(req);\n     return req->result;\n   }\n@@ -965,12 +1122,19 @@ int uv_fs_symlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n \n int uv_fs_readlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n     uv_fs_cb cb) {\n+  wchar_t* pathw;\n+  int size;\n+\n+  /* Convert to UTF16. */\n+  UTF8_TO_UTF16(path, pathw);\n+\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_READLINK, path, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_READLINK, path, pathw, cb);\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n     uv_fs_req_init_sync(loop, req, UV_FS_READLINK);\n-    fs__readlink(req, path);\n+    fs__readlink(req, pathw);\n+    free(pathw);\n     SET_UV_LAST_ERROR_FROM_REQ(req);\n     return req->result;\n   }\n@@ -981,13 +1145,20 @@ int uv_fs_readlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n \n int uv_fs_chown(uv_loop_t* loop, uv_fs_t* req, const char* path, int uid,\n     int gid, uv_fs_cb cb) {\n+  wchar_t* pathw;\n+  int size;\n+\n+  /* Convert to UTF16. */\n+  UTF8_TO_UTF16(path, pathw);\n+\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_CHOWN, path, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_CHOWN, path, pathw, cb);\n     WRAP_REQ_ARGS2(req, uid, gid);\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n     uv_fs_req_init_sync(loop, req, UV_FS_CHOWN);\n     fs__nop(req);\n+    free(pathw);\n     SET_UV_LAST_ERROR_FROM_REQ(req);\n     return req->result;\n   }\n@@ -999,7 +1170,7 @@ int uv_fs_chown(uv_loop_t* loop, uv_fs_t* req, const char* path, int uid,\n int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_file file, int uid,\n     int gid, uv_fs_cb cb) {\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_FCHOWN, NULL, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_FCHOWN, NULL, NULL, cb);\n     WRAP_REQ_ARGS3(req, file, uid, gid);\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n@@ -1016,9 +1187,11 @@ int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_file file, int uid,\n int uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n   int len = strlen(path);\n   char* path2 = NULL;\n-  int has_backslash = (path[len - 1] == '\\\\' || path[len - 1] == '/');\n+  wchar_t* pathw;\n+  int size;\n \n-  if (path[len - 1] == '\\\\' || path[len - 1] == '/') {\n+  if (len > 1 && path[len - 2] != ':' &&\n+      (path[len - 1] == '\\\\' || path[len - 1] == '/')) {\n     path2 = strdup(path);\n     if (!path2) {\n       uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");\n@@ -1028,20 +1201,24 @@ int uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n   }\n \n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_STAT, NULL, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_STAT, NULL, NULL, cb);\n     if (path2) {\n       req->path = path2;\n+      UTF8_TO_UTF16(path2, req->pathw);\n     } else {\n       req->path = strdup(path);\n+      UTF8_TO_UTF16(path, req->pathw);\n     }\n \n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n     uv_fs_req_init_sync(loop, req, UV_FS_STAT);\n-    fs__stat(req, path2 ? path2 : path);\n+    UTF8_TO_UTF16(path2 ? path2 : path, pathw);\n+    fs__stat(req, pathw);\n     if (path2) {\n       free(path2);\n     }\n+    free(pathw);\n     SET_UV_LAST_ERROR_FROM_REQ(req);\n     return req->result;\n   }\n@@ -1054,9 +1231,11 @@ int uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n   int len = strlen(path);\n   char* path2 = NULL;\n-  int has_backslash = (path[len - 1] == '\\\\' || path[len - 1] == '/');\n+  wchar_t* pathw;\n+  int size;\n \n-  if (path[len - 1] == '\\\\' || path[len - 1] == '/') {\n+  if (len > 1 && path[len - 2] != ':' &&\n+      (path[len - 1] == '\\\\' || path[len - 1] == '/')) {\n     path2 = strdup(path);\n     if (!path2) {\n       uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");\n@@ -1066,20 +1245,24 @@ int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n   }\n \n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_LSTAT, NULL, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_LSTAT, NULL, NULL, cb);\n      if (path2) {\n       req->path = path2;\n+      UTF8_TO_UTF16(path2, req->pathw);\n     } else {\n       req->path = strdup(path);\n+      UTF8_TO_UTF16(path, req->pathw);\n     }\n \n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n     uv_fs_req_init_sync(loop, req, UV_FS_LSTAT);\n-    fs__stat(req, path2 ? path2 : path);\n+    UTF8_TO_UTF16(path2 ? path2 : path, pathw);\n+    fs__stat(req, pathw);\n     if (path2) {\n       free(path2);\n     }\n+    free(pathw);\n     SET_UV_LAST_ERROR_FROM_REQ(req);\n     return req->result;\n   }\n@@ -1090,7 +1273,7 @@ int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n \n int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_FSTAT, NULL, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_FSTAT, NULL, NULL, cb);\n     WRAP_REQ_ARGS1(req, file);\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n@@ -1106,14 +1289,24 @@ int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n \n int uv_fs_rename(uv_loop_t* loop, uv_fs_t* req, const char* path,\n     const char* new_path, uv_fs_cb cb) {\n+  wchar_t* pathw;\n+  wchar_t* new_pathw;\n+  int size;\n+\n+  /* Convert to UTF16. */\n+  UTF8_TO_UTF16(path, pathw);\n+  UTF8_TO_UTF16(new_path, new_pathw);\n+\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_RENAME, path, cb);\n-    WRAP_REQ_ARGS1(req, new_path);\n-    STRDUP_ARG(req, 0);\n+    uv_fs_req_init_async(loop, req, UV_FS_RENAME, path, pathw, cb);\n+    WRAP_REQ_ARGS1(req, new_pathw);\n+    SET_ALLOCED_ARG(req, 0);\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n     uv_fs_req_init_sync(loop, req, UV_FS_RENAME);\n-    fs__rename(req, path, new_path);\n+    fs__rename(req, pathw, new_pathw);\n+    free(pathw);\n+    free(new_pathw);\n     SET_UV_LAST_ERROR_FROM_REQ(req);\n     return req->result;\n   }\n@@ -1124,7 +1317,7 @@ int uv_fs_rename(uv_loop_t* loop, uv_fs_t* req, const char* path,\n \n int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_FDATASYNC, NULL, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_FDATASYNC, NULL, NULL, cb);\n     WRAP_REQ_ARGS1(req, file);\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n@@ -1140,7 +1333,7 @@ int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n \n int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_FSYNC, NULL, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_FSYNC, NULL, NULL, cb);\n     WRAP_REQ_ARGS1(req, file);\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n@@ -1157,7 +1350,7 @@ int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n int uv_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n     off_t offset, uv_fs_cb cb) {\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_FTRUNCATE, NULL, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_FTRUNCATE, NULL, NULL, cb);\n     WRAP_REQ_ARGS2(req, file, offset);\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n@@ -1174,7 +1367,7 @@ int uv_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n int uv_fs_sendfile(uv_loop_t* loop, uv_fs_t* req, uv_file out_fd,\n     uv_file in_fd, off_t in_offset, size_t length, uv_fs_cb cb) {\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_SENDFILE, NULL, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_SENDFILE, NULL, NULL, cb);\n     WRAP_REQ_ARGS4(req, out_fd, in_fd, in_offset, length);\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n@@ -1190,13 +1383,20 @@ int uv_fs_sendfile(uv_loop_t* loop, uv_fs_t* req, uv_file out_fd,\n \n int uv_fs_chmod(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode,\n     uv_fs_cb cb) {\n+  wchar_t* pathw;\n+  int size;\n+\n+  /* Convert to UTF16. */\n+  UTF8_TO_UTF16(path, pathw);\n+\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_CHMOD, path, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_CHMOD, path, pathw, cb);\n     WRAP_REQ_ARGS1(req, mode);\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n     uv_fs_req_init_sync(loop, req, UV_FS_CHMOD);\n-    fs__chmod(req, path, mode);\n+    fs__chmod(req, pathw, mode);\n+    free(pathw);\n     SET_UV_LAST_ERROR_FROM_REQ(req);\n     return req->result;\n   }\n@@ -1208,7 +1408,7 @@ int uv_fs_chmod(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode,\n int uv_fs_fchmod(uv_loop_t* loop, uv_fs_t* req, uv_file file, int mode,\n     uv_fs_cb cb) {\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_FCHMOD, NULL, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_FCHMOD, NULL, NULL, cb);\n     WRAP_REQ_ARGS2(req, file, mode);\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n@@ -1224,14 +1424,21 @@ int uv_fs_fchmod(uv_loop_t* loop, uv_fs_t* req, uv_file file, int mode,\n \n int uv_fs_utime(uv_loop_t* loop, uv_fs_t* req, const char* path, double atime,\n     double mtime, uv_fs_cb cb) {\n+  wchar_t* pathw;\n+  int size;\n+\n+  /* Convert to UTF16. */\n+  UTF8_TO_UTF16(path, pathw);\n+\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_UTIME, path, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_UTIME, path, pathw, cb);\n     req->arg4 = (ssize_t)atime;\n     req->arg5 = (ssize_t)mtime;\n     QUEUE_FS_TP_JOB(loop, req);\n   } else {\n     uv_fs_req_init_sync(loop, req, UV_FS_UTIME);\n-    fs__utime(req, path, atime, mtime);\n+    fs__utime(req, pathw, atime, mtime);\n+    free(pathw);\n     SET_UV_LAST_ERROR_FROM_REQ(req);\n     return req->result;\n   }\n@@ -1243,7 +1450,7 @@ int uv_fs_utime(uv_loop_t* loop, uv_fs_t* req, const char* path, double atime,\n int uv_fs_futime(uv_loop_t* loop, uv_fs_t* req, uv_file file, double atime,\n     double mtime, uv_fs_cb cb) {\n   if (cb) {\n-    uv_fs_req_init_async(loop, req, UV_FS_FUTIME, NULL, cb);\n+    uv_fs_req_init_async(loop, req, UV_FS_FUTIME, NULL, NULL, cb);\n     WRAP_REQ_ARGS1(req, file);\n     req->arg4 = (ssize_t)atime;\n     req->arg5 = (ssize_t)mtime;\n@@ -1294,6 +1501,11 @@ void uv_fs_req_cleanup(uv_fs_t* req) {\n     req->path = NULL;\n   }\n \n+  if (req->pathw) {\n+    free(req->pathw);\n+    req->pathw = NULL;\n+  }\n+\n   if (req->flags & UV_FS_ASYNC_QUEUED) {\n     uv_unref(loop);\n   }"}, {"sha": "f0d854216be6f67f025505addf824a22c2bf83f8", "filename": "src/rt/libuv/src/win/getaddrinfo.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fgetaddrinfo.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fgetaddrinfo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fgetaddrinfo.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -256,7 +256,7 @@ int uv_getaddrinfo(uv_loop_t* loop,\n \n   if (handle == NULL || getaddrinfo_cb == NULL ||\n      (node == NULL && service == NULL)) {\n-    uv_set_sys_error(loop, WSAEINVAL);\n+    uv__set_sys_error(loop, WSAEINVAL);\n     goto error;\n   }\n \n@@ -271,7 +271,7 @@ int uv_getaddrinfo(uv_loop_t* loop,\n   if (node != NULL) {\n     nodesize = ALIGNED_SIZE(uv_utf8_to_utf16(node, NULL, 0) * sizeof(wchar_t));\n     if (nodesize == 0) {\n-      uv_set_sys_error(loop, GetLastError());\n+      uv__set_sys_error(loop, GetLastError());\n       goto error;\n     }\n   }\n@@ -280,7 +280,7 @@ int uv_getaddrinfo(uv_loop_t* loop,\n     servicesize = ALIGNED_SIZE(uv_utf8_to_utf16(service, NULL, 0) *\n                                sizeof(wchar_t));\n     if (servicesize == 0) {\n-      uv_set_sys_error(loop, GetLastError());\n+      uv__set_sys_error(loop, GetLastError());\n       goto error;\n     }\n   }\n@@ -291,7 +291,7 @@ int uv_getaddrinfo(uv_loop_t* loop,\n   /* allocate memory for inputs, and partition it as needed */\n   alloc_ptr = (char*)malloc(nodesize + servicesize + hintssize);\n   if (!alloc_ptr) {\n-    uv_set_sys_error(loop, WSAENOBUFS);\n+    uv__set_sys_error(loop, WSAENOBUFS);\n     goto error;\n   }\n \n@@ -305,7 +305,7 @@ int uv_getaddrinfo(uv_loop_t* loop,\n     if (uv_utf8_to_utf16(node,\n                          (wchar_t*) alloc_ptr,\n                          nodesize / sizeof(wchar_t)) == 0) {\n-      uv_set_sys_error(loop, GetLastError());\n+      uv__set_sys_error(loop, GetLastError());\n       goto error;\n     }\n     alloc_ptr += nodesize;\n@@ -320,7 +320,7 @@ int uv_getaddrinfo(uv_loop_t* loop,\n     if (uv_utf8_to_utf16(service,\n                          (wchar_t*) alloc_ptr,\n                          servicesize / sizeof(wchar_t)) == 0) {\n-      uv_set_sys_error(loop, GetLastError());\n+      uv__set_sys_error(loop, GetLastError());\n       goto error;\n     }\n     alloc_ptr += servicesize;\n@@ -352,7 +352,7 @@ int uv_getaddrinfo(uv_loop_t* loop,\n   if (QueueUserWorkItem(&getaddrinfo_thread_proc,\n                         handle,\n                         WT_EXECUTELONGFUNCTION) == 0) {\n-    uv_set_sys_error(loop, GetLastError());\n+    uv__set_sys_error(loop, GetLastError());\n     goto error;\n   }\n "}, {"sha": "b67139cbc6a561a0c2639b635538df036810ed50", "filename": "src/rt/libuv/src/win/handle.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fhandle.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fhandle.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fhandle.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -20,11 +20,36 @@\n  */\n \n #include <assert.h>\n+#include <io.h>\n \n #include \"uv.h\"\n #include \"internal.h\"\n \n \n+uv_handle_type uv_guess_handle(uv_file file) {\n+  HANDLE handle = (HANDLE) _get_osfhandle(file);\n+  DWORD mode;\n+\n+  switch (GetFileType(handle)) {\n+    case FILE_TYPE_CHAR:\n+      if (GetConsoleMode(handle, &mode)) {\n+        return UV_TTY;\n+      } else {\n+        return UV_UNKNOWN_HANDLE;\n+      }\n+\n+    case FILE_TYPE_PIPE:\n+      return UV_NAMED_PIPE;\n+\n+    case FILE_TYPE_DISK:\n+      return UV_FILE;\n+\n+    default:\n+      return UV_UNKNOWN_HANDLE;\n+  }\n+}\n+\n+\n int uv_is_active(uv_handle_t* handle) {\n   switch (handle->type) {\n     case UV_TIMER:\n@@ -80,6 +105,10 @@ void uv_close(uv_handle_t* handle, uv_close_cb cb) {\n       }\n       return;\n \n+    case UV_TTY:\n+      uv_tty_close((uv_tty_t*) handle);\n+      return;\n+\n     case UV_UDP:\n       udp = (uv_udp_t*) handle;\n       uv_udp_recv_stop(udp);\n@@ -159,6 +188,10 @@ void uv_process_endgames(uv_loop_t* loop) {\n         uv_pipe_endgame(loop, (uv_pipe_t*) handle);\n         break;\n \n+      case UV_TTY:\n+        uv_tty_endgame(loop, (uv_tty_t*) handle);\n+        break;\n+\n       case UV_UDP:\n         uv_udp_endgame(loop, (uv_udp_t*) handle);\n         break;"}, {"sha": "55e02df57e1ab540030ee2093e4427fc019e9511", "filename": "src/rt/libuv/src/win/internal.h", "status": "modified", "additions": 91, "deletions": 35, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Finternal.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Finternal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Finternal.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -44,26 +44,30 @@ void uv_process_timers(uv_loop_t* loop);\n  */\n \n /* Private uv_handle flags */\n-#define UV_HANDLE_CLOSING          0x0001\n-#define UV_HANDLE_CLOSED           0x0002\n-#define UV_HANDLE_BOUND            0x0004\n-#define UV_HANDLE_LISTENING        0x0008\n-#define UV_HANDLE_CONNECTION       0x0010\n-#define UV_HANDLE_CONNECTED        0x0020\n-#define UV_HANDLE_READING          0x0040\n-#define UV_HANDLE_ACTIVE           0x0040\n-#define UV_HANDLE_EOF              0x0080\n-#define UV_HANDLE_SHUTTING         0x0100\n-#define UV_HANDLE_SHUT             0x0200\n-#define UV_HANDLE_ENDGAME_QUEUED   0x0400\n-#define UV_HANDLE_BIND_ERROR       0x1000\n-#define UV_HANDLE_IPV6             0x2000\n-#define UV_HANDLE_PIPESERVER       0x4000\n-#define UV_HANDLE_READ_PENDING     0x8000\n-#define UV_HANDLE_GIVEN_OS_HANDLE  0x10000\n-#define UV_HANDLE_UV_ALLOCED       0x20000\n-#define UV_HANDLE_SYNC_BYPASS_IOCP 0x40000\n-#define UV_HANDLE_ZERO_READ        0x80000\n+#define UV_HANDLE_CLOSING                 0x000001\n+#define UV_HANDLE_CLOSED                  0x000002\n+#define UV_HANDLE_BOUND                   0x000004\n+#define UV_HANDLE_LISTENING               0x000008\n+#define UV_HANDLE_CONNECTION              0x000010\n+#define UV_HANDLE_CONNECTED               0x000020\n+#define UV_HANDLE_READING                 0x000040\n+#define UV_HANDLE_ACTIVE                  0x000040\n+#define UV_HANDLE_EOF                     0x000080\n+#define UV_HANDLE_SHUTTING                0x000100\n+#define UV_HANDLE_SHUT                    0x000200\n+#define UV_HANDLE_ENDGAME_QUEUED          0x000400\n+#define UV_HANDLE_BIND_ERROR              0x001000\n+#define UV_HANDLE_IPV6                    0x002000\n+#define UV_HANDLE_PIPESERVER              0x004000\n+#define UV_HANDLE_READ_PENDING            0x008000\n+#define UV_HANDLE_UV_ALLOCED              0x010000\n+#define UV_HANDLE_SYNC_BYPASS_IOCP        0x020000\n+#define UV_HANDLE_ZERO_READ               0x040000\n+#define UV_HANDLE_TTY_RAW                 0x080000\n+#define UV_HANDLE_EMULATE_IOCP            0x100000\n+#define UV_HANDLE_NON_OVERLAPPED_PIPE     0x200000\n+#define UV_HANDLE_TTY_SAVED_POSITION      0x400000\n+#define UV_HANDLE_TTY_SAVED_ATTRIBUTES    0x800000\n \n void uv_want_endgame(uv_loop_t* loop, uv_handle_t* handle);\n void uv_process_endgames(uv_loop_t* loop);\n@@ -96,8 +100,8 @@ uv_req_t* uv_overlapped_to_req(OVERLAPPED* overlapped);\n void uv_insert_pending_req(uv_loop_t* loop, uv_req_t* req);\n void uv_process_reqs(uv_loop_t* loop);\n \n-#define POST_COMPLETION_FOR_REQ(loop, req)                                    \\\n-  if (!PostQueuedCompletionStatus((loop)->iocp,                           \\\n+#define POST_COMPLETION_FOR_REQ(loop, req)                              \\\n+  if (!PostQueuedCompletionStatus((loop)->iocp,                         \\\n                                   0,                                    \\\n                                   0,                                    \\\n                                   &((req)->overlapped))) {              \\\n@@ -134,6 +138,8 @@ void uv_process_tcp_connect_req(uv_loop_t* loop, uv_tcp_t* handle,\n \n void uv_tcp_endgame(uv_loop_t* loop, uv_tcp_t* handle);\n \n+int uv_tcp_import(uv_tcp_t* tcp, WSAPROTOCOL_INFOW* socket_protocol_info);\n+\n \n /*\n  * UDP\n@@ -148,19 +154,21 @@ void uv_udp_endgame(uv_loop_t* loop, uv_udp_t* handle);\n /*\n  * Pipes\n  */\n-int uv_pipe_init_with_handle(uv_loop_t* loop, uv_pipe_t* handle,\n-    HANDLE pipeHandle);\n int uv_stdio_pipe_server(uv_loop_t* loop, uv_pipe_t* handle, DWORD access,\n     char* name, size_t nameSize);\n void close_pipe(uv_pipe_t* handle, int* status, uv_err_t* err);\n void uv_pipe_endgame(uv_loop_t* loop, uv_pipe_t* handle);\n \n int uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb);\n-int uv_pipe_accept(uv_pipe_t* server, uv_pipe_t* client);\n+int uv_pipe_accept(uv_pipe_t* server, uv_stream_t* client);\n int uv_pipe_read_start(uv_pipe_t* handle, uv_alloc_cb alloc_cb,\n     uv_read_cb read_cb);\n+int uv_pipe_read2_start(uv_pipe_t* handle, uv_alloc_cb alloc_cb,\n+    uv_read2_cb read_cb);\n int uv_pipe_write(uv_loop_t* loop, uv_write_t* req, uv_pipe_t* handle,\n     uv_buf_t bufs[], int bufcnt, uv_write_cb cb);\n+int uv_pipe_write2(uv_loop_t* loop, uv_write_t* req, uv_pipe_t* handle,\n+    uv_buf_t bufs[], int bufcnt, uv_stream_t* send_handle, uv_write_cb cb);\n \n void uv_process_pipe_read_req(uv_loop_t* loop, uv_pipe_t* handle,\n     uv_req_t* req);\n@@ -173,6 +181,33 @@ void uv_process_pipe_connect_req(uv_loop_t* loop, uv_pipe_t* handle,\n void uv_process_pipe_shutdown_req(uv_loop_t* loop, uv_pipe_t* handle,\n     uv_shutdown_t* req);\n \n+\n+/*\n+ * TTY\n+ */\n+void uv_console_init();\n+\n+int uv_tty_read_start(uv_tty_t* handle, uv_alloc_cb alloc_cb,\n+    uv_read_cb read_cb);\n+int uv_tty_read_stop(uv_tty_t* handle);\n+int uv_tty_write(uv_loop_t* loop, uv_write_t* req, uv_tty_t* handle,\n+    uv_buf_t bufs[], int bufcnt, uv_write_cb cb);\n+void uv_tty_close(uv_tty_t* handle);\n+\n+void uv_process_tty_read_req(uv_loop_t* loop, uv_tty_t* handle,\n+    uv_req_t* req);\n+void uv_process_tty_write_req(uv_loop_t* loop, uv_tty_t* handle,\n+    uv_write_t* req);\n+/* TODO: remove me */\n+void uv_process_tty_accept_req(uv_loop_t* loop, uv_tty_t* handle,\n+    uv_req_t* raw_req);\n+/* TODO: remove me */\n+void uv_process_tty_connect_req(uv_loop_t* loop, uv_tty_t* handle,\n+    uv_connect_t* req);\n+\n+void uv_tty_endgame(uv_loop_t* loop, uv_tty_t* handle);\n+\n+\n /*\n  * Loop watchers\n  */\n@@ -239,6 +274,10 @@ void uv_fs_event_close(uv_loop_t* loop, uv_fs_event_t* handle);\n void uv_fs_event_endgame(uv_loop_t* loop, uv_fs_event_t* handle);\n \n \n+/* Utils */\n+int uv_parent_pid();\n+\n+\n /*\n  * Error handling\n  */\n@@ -247,9 +286,6 @@ extern const uv_err_t uv_ok_;\n void uv_fatal_error(const int errorno, const char* syscall);\n \n uv_err_code uv_translate_sys_error(int sys_errno);\n-uv_err_t uv_new_sys_error(int sys_errno);\n-void uv_set_sys_error(uv_loop_t* loop, int sys_errno);\n-void uv_set_error(uv_loop_t* loop, uv_err_code code, int sys_errno);\n \n #define SET_REQ_STATUS(req, status)                                     \\\n    (req)->overlapped.Internal = (ULONG_PTR) (status)\n@@ -272,22 +308,42 @@ void uv_set_error(uv_loop_t* loop, uv_err_code code, int sys_errno);\n #define GET_REQ_SOCK_ERROR(req)                                         \\\n   (uv_ntstatus_to_winsock_error(GET_REQ_STATUS((req))))\n \n-#define GET_REQ_UV_ERROR(req)                                           \\\n-  (uv_new_sys_error(GET_REQ_ERROR((req))))\n \n-#define GET_REQ_UV_SOCK_ERROR(req)                                      \\\n-  (uv_new_sys_error(GET_REQ_SOCK_ERROR((req))))\n+/*\n+ * Winapi and ntapi utility functions\n+ */\n+void uv_winapi_init();\n \n \n /*\n- * Initialization for the windows and winsock api\n+ * Winsock utility functions\n  */\n-void uv_winapi_init();\n void uv_winsock_init();\n+\n int uv_ntstatus_to_winsock_error(NTSTATUS status);\n \n+BOOL uv_get_acceptex_function(SOCKET socket, LPFN_ACCEPTEX* target);\n+BOOL uv_get_connectex_function(SOCKET socket, LPFN_CONNECTEX* target);\n+\n+int WSAAPI uv_wsarecv_workaround(SOCKET socket, WSABUF* buffers,\n+    DWORD buffer_count, DWORD* bytes, DWORD* flags, WSAOVERLAPPED *overlapped,\n+    LPWSAOVERLAPPED_COMPLETION_ROUTINE completion_routine);\n+int WSAAPI uv_wsarecvfrom_workaround(SOCKET socket, WSABUF* buffers,\n+    DWORD buffer_count, DWORD* bytes, DWORD* flags, struct sockaddr* addr,\n+    int* addr_len, WSAOVERLAPPED *overlapped,\n+    LPWSAOVERLAPPED_COMPLETION_ROUTINE completion_routine);\n+\n+/* Whether ipv6 is supported */\n+extern int uv_allow_ipv6;\n+\n+/* Ip address used to bind to any port at any interface */\n+extern struct sockaddr_in uv_addr_ip4_any_;\n+extern struct sockaddr_in6 uv_addr_ip6_any_;\n \n-/* Threads and synchronization */\n+\n+/*\n+ * Threads and synchronization\n+ */\n typedef struct uv_once_s {\n   unsigned char ran;\n   /* The actual event handle must be aligned to sizeof(HANDLE), so in */"}, {"sha": "65d1f11cd1c1086609528e05a03361618b614533", "filename": "src/rt/libuv/src/win/pipe.c", "status": "modified", "additions": 635, "deletions": 144, "changes": 779, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fpipe.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fpipe.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fpipe.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -20,6 +20,7 @@\n  */\n \n #include <assert.h>\n+#include <io.h>\n #include <string.h>\n #include <stdio.h>\n \n@@ -38,6 +39,22 @@ static const uv_buf_t uv_null_buf_ = { 0, NULL };\n /* when the local ends wants to shut it down. */\n static const int64_t eof_timeout = 50; /* ms */\n \n+/* IPC protocol flags. */\n+#define UV_IPC_RAW_DATA   0x0001\n+#define UV_IPC_UV_STREAM  0x0002\n+\n+/* IPC frame header. */\n+typedef struct {\n+  int flags;\n+  uint64_t raw_data_length;\n+} uv_ipc_frame_header_t;\n+\n+/* IPC frame, which contains an imported TCP socket stream. */\n+typedef struct {\n+  uv_ipc_frame_header_t header;\n+  WSAPROTOCOL_INFOW socket_info;\n+} uv_ipc_frame_uv_stream;\n+\n static void eof_timer_init(uv_pipe_t* pipe);\n static void eof_timer_start(uv_pipe_t* pipe);\n static void eof_timer_stop(uv_pipe_t* pipe);\n@@ -51,40 +68,30 @@ static void uv_unique_pipe_name(char* ptr, char* name, size_t size) {\n }\n \n \n-int uv_pipe_init(uv_loop_t* loop, uv_pipe_t* handle) {\n+int uv_pipe_init(uv_loop_t* loop, uv_pipe_t* handle, int ipc) {\n   uv_stream_init(loop, (uv_stream_t*)handle);\n \n   handle->type = UV_NAMED_PIPE;\n   handle->reqs_pending = 0;\n   handle->handle = INVALID_HANDLE_VALUE;\n   handle->name = NULL;\n+  handle->ipc_pid = 0;\n+  handle->remaining_ipc_rawdata_bytes = 0;\n+  handle->pending_socket_info = NULL;\n+  handle->ipc = ipc;\n+  handle->non_overlapped_writes_tail = NULL;\n+\n+  uv_req_init(loop, (uv_req_t*) &handle->ipc_header_write_req);\n \n   loop->counters.pipe_init++;\n \n   return 0;\n }\n \n \n-int uv_pipe_init_with_handle(uv_loop_t* loop, uv_pipe_t* handle,\n-    HANDLE pipeHandle) {\n-  int err = uv_pipe_init(loop, handle);\n-\n-  if (!err) {\n-    /*\n-     * At this point we don't know whether the pipe will be used as a client\n-     * or a server.  So, we assume that it will be a client until\n-     * uv_listen is called.\n-     */\n-    handle->handle = pipeHandle;\n-    handle->flags |= UV_HANDLE_GIVEN_OS_HANDLE;\n-  }\n-\n-  return err;\n-}\n-\n-\n static void uv_pipe_connection_init(uv_pipe_t* handle) {\n   uv_connection_init((uv_stream_t*) handle);\n+  handle->read_req.data = handle;\n   handle->eof_timer = NULL;\n }\n \n@@ -111,7 +118,7 @@ int uv_stdio_pipe_server(uv_loop_t* loop, uv_pipe_t* handle, DWORD access,\n \n     errno = GetLastError();\n     if (errno != ERROR_PIPE_BUSY && errno != ERROR_ACCESS_DENIED) {\n-      uv_set_sys_error(loop, errno);\n+      uv__set_sys_error(loop, errno);\n       err = -1;\n       goto done;\n     }\n@@ -124,14 +131,13 @@ int uv_stdio_pipe_server(uv_loop_t* loop, uv_pipe_t* handle, DWORD access,\n                              loop->iocp,\n                              (ULONG_PTR)handle,\n                              0) == NULL) {\n-    uv_set_sys_error(loop, GetLastError());\n+    uv__set_sys_error(loop, GetLastError());\n     err = -1;\n     goto done;\n   }\n \n   uv_pipe_connection_init(handle);\n   handle->handle = pipeHandle;\n-  handle->flags |= UV_HANDLE_GIVEN_OS_HANDLE;\n   err = 0;\n \n done:\n@@ -145,19 +151,39 @@ int uv_stdio_pipe_server(uv_loop_t* loop, uv_pipe_t* handle, DWORD access,\n \n static int uv_set_pipe_handle(uv_loop_t* loop, uv_pipe_t* handle,\n     HANDLE pipeHandle) {\n+  NTSTATUS nt_status;\n+  IO_STATUS_BLOCK io_status;\n+  FILE_MODE_INFORMATION mode_info;\n   DWORD mode = PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT;\n \n   if (!SetNamedPipeHandleState(pipeHandle, &mode, NULL, NULL)) {\n     return -1;\n   }\n \n-  if (CreateIoCompletionPort(pipeHandle,\n-                             loop->iocp,\n-                             (ULONG_PTR)handle,\n-                             0) == NULL) {\n+  /* Check if the pipe was created with FILE_FLAG_OVERLAPPED. */\n+  nt_status = pNtQueryInformationFile(pipeHandle,\n+                                      &io_status,\n+                                      &mode_info,\n+                                      sizeof(mode_info),\n+                                      FileModeInformation);\n+  if (nt_status != STATUS_SUCCESS) {\n     return -1;\n   }\n \n+  if (mode_info.Mode & FILE_SYNCHRONOUS_IO_ALERT ||\n+      mode_info.Mode & FILE_SYNCHRONOUS_IO_NONALERT) {\n+    /* Non-overlapped pipe. */\n+    handle->flags |= UV_HANDLE_NON_OVERLAPPED_PIPE;\n+  } else {\n+    /* Overlapped pipe.  Try to associate with IOCP. */\n+    if (CreateIoCompletionPort(pipeHandle,\n+                               loop->iocp,\n+                               (ULONG_PTR)handle,\n+                               0) == NULL) {\n+      handle->flags |= UV_HANDLE_EMULATE_IOCP;\n+    }\n+  }\n+\n   return 0;\n }\n \n@@ -192,7 +218,6 @@ void uv_pipe_endgame(uv_loop_t* loop, uv_pipe_t* handle) {\n   IO_STATUS_BLOCK io_status;\n   FILE_PIPE_LOCAL_INFORMATION pipe_info;\n \n-\n   if (handle->flags & UV_HANDLE_SHUTTING &&\n       !(handle->flags & UV_HANDLE_SHUT) &&\n       handle->write_reqs_pending == 0) {\n@@ -209,7 +234,7 @@ void uv_pipe_endgame(uv_loop_t* loop, uv_pipe_t* handle) {\n       /* Failure */\n       handle->flags &= ~UV_HANDLE_SHUTTING;\n       if (req->cb) {\n-        uv_set_sys_error(loop, pRtlNtStatusToDosError(nt_status));\n+        uv__set_sys_error(loop, pRtlNtStatusToDosError(nt_status));\n         req->cb(req, -1);\n       }\n       DECREASE_PENDING_REQ_COUNT(handle);\n@@ -231,12 +256,13 @@ void uv_pipe_endgame(uv_loop_t* loop, uv_pipe_t* handle) {\n     if (result) {\n       /* Mark the handle as shut now to avoid going through this again. */\n       handle->flags |= UV_HANDLE_SHUT;\n+      return;\n \n     } else {\n       /* Failure. */\n       handle->flags &= ~UV_HANDLE_SHUTTING;\n       if (req->cb) {\n-        uv_set_sys_error(loop, GetLastError());\n+        uv__set_sys_error(loop, GetLastError());\n         req->cb(req, -1);\n       }\n       DECREASE_PENDING_REQ_COUNT(handle);\n@@ -249,6 +275,24 @@ void uv_pipe_endgame(uv_loop_t* loop, uv_pipe_t* handle) {\n     assert(!(handle->flags & UV_HANDLE_CLOSED));\n     handle->flags |= UV_HANDLE_CLOSED;\n \n+    if (handle->flags & UV_HANDLE_CONNECTION) {\n+      if (handle->pending_socket_info) {\n+        free(handle->pending_socket_info);\n+        handle->pending_socket_info = NULL;\n+      }\n+      \n+      if (handle->flags & UV_HANDLE_EMULATE_IOCP) {\n+        if (handle->read_req.wait_handle != INVALID_HANDLE_VALUE) {\n+          UnregisterWait(handle->read_req.wait_handle);\n+          handle->read_req.wait_handle = INVALID_HANDLE_VALUE;\n+        }\n+        if (handle->read_req.event_handle) {\n+          CloseHandle(handle->read_req.event_handle);\n+          handle->read_req.event_handle = NULL;\n+        }\n+      }\n+    }\n+\n     /* Remember the state of this flag because the close callback is */\n     /* allowed to clobber or free the handle's memory */\n     uv_alloced = handle->flags & UV_HANDLE_UV_ALLOCED;\n@@ -273,12 +317,12 @@ int uv_pipe_bind(uv_pipe_t* handle, const char* name) {\n   uv_pipe_accept_t* req;\n \n   if (handle->flags & UV_HANDLE_BOUND) {\n-    uv_set_sys_error(loop, WSAEINVAL);\n+    uv__set_sys_error(loop, WSAEINVAL);\n     return -1;\n   }\n \n   if (!name) {\n-    uv_set_sys_error(loop, WSAEINVAL);\n+    uv__set_sys_error(loop, WSAEINVAL);\n     return -1;\n   }\n \n@@ -299,7 +343,7 @@ int uv_pipe_bind(uv_pipe_t* handle, const char* name) {\n   }\n \n   if (!uv_utf8_to_utf16(name, handle->name, nameSize / sizeof(wchar_t))) {\n-    uv_set_sys_error(loop, GetLastError());\n+    uv__set_sys_error(loop, GetLastError());\n     return -1;\n   }\n \n@@ -316,17 +360,17 @@ int uv_pipe_bind(uv_pipe_t* handle, const char* name) {\n   if (handle->accept_reqs[0].pipeHandle == INVALID_HANDLE_VALUE) {\n     errno = GetLastError();\n     if (errno == ERROR_ACCESS_DENIED) {\n-      uv_set_error(loop, UV_EADDRINUSE, errno);\n+      uv__set_error(loop, UV_EADDRINUSE, errno);\n     } else if (errno == ERROR_PATH_NOT_FOUND || errno == ERROR_INVALID_NAME) {\n-      uv_set_error(loop, UV_EACCESS, errno);\n+      uv__set_error(loop, UV_EACCESS, errno);\n     } else {\n-      uv_set_sys_error(loop, errno);\n+      uv__set_sys_error(loop, errno);\n     }\n     goto error;\n   }\n \n   if (uv_set_pipe_handle(loop, handle, handle->accept_reqs[0].pipeHandle)) {\n-    uv_set_sys_error(loop, GetLastError());\n+    uv__set_sys_error(loop, GetLastError());\n     goto error;\n   }\n \n@@ -472,7 +516,7 @@ int uv_pipe_connect(uv_connect_t* req, uv_pipe_t* handle,\n   if (pipeHandle != INVALID_HANDLE_VALUE) {\n     CloseHandle(pipeHandle);\n   }\n-  uv_set_sys_error(loop, errno);\n+  uv__set_sys_error(loop, errno);\n   return -1;\n }\n \n@@ -566,30 +610,44 @@ static void uv_pipe_queue_accept(uv_loop_t* loop, uv_pipe_t* handle,\n }\n \n \n-int uv_pipe_accept(uv_pipe_t* server, uv_pipe_t* client) {\n+int uv_pipe_accept(uv_pipe_t* server, uv_stream_t* client) {\n   uv_loop_t* loop = server->loop;\n-  /* Find a connection instance that has been connected, but not yet */\n-  /* accepted. */\n-  uv_pipe_accept_t* req = server->pending_accepts;\n+  uv_pipe_t* pipe_client;\n+  uv_pipe_accept_t* req;\n \n-  if (!req) {\n-    /* No valid connections found, so we error out. */\n-    uv_set_sys_error(loop, WSAEWOULDBLOCK);\n-    return -1;\n-  }\n+  if (server->ipc) {\n+    if (!server->pending_socket_info) {\n+      /* No valid pending sockets. */\n+      uv__set_sys_error(loop, WSAEWOULDBLOCK);\n+      return -1;\n+    }\n+\n+    return uv_tcp_import((uv_tcp_t*)client, server->pending_socket_info);\n+  } else {\n+    pipe_client = (uv_pipe_t*)client;\n \n-  /* Initialize the client handle and copy the pipeHandle to the client */\n-  uv_pipe_connection_init(client);\n-  client->handle = req->pipeHandle;\n+    /* Find a connection instance that has been connected, but not yet */\n+    /* accepted. */\n+    req = server->pending_accepts;\n \n-  /* Prepare the req to pick up a new connection */\n-  server->pending_accepts = req->next_pending;\n-  req->next_pending = NULL;\n-  req->pipeHandle = INVALID_HANDLE_VALUE;\n+    if (!req) {\n+      /* No valid connections found, so we error out. */\n+      uv__set_sys_error(loop, WSAEWOULDBLOCK);\n+      return -1;\n+    }\n+\n+    /* Initialize the client handle and copy the pipeHandle to the client */\n+    uv_pipe_connection_init(pipe_client);\n+    pipe_client->handle = req->pipeHandle;\n+\n+    /* Prepare the req to pick up a new connection */\n+    server->pending_accepts = req->next_pending;\n+    req->next_pending = NULL;\n+    req->pipeHandle = INVALID_HANDLE_VALUE;\n \n-  if (!(server->flags & UV_HANDLE_CLOSING) &&\n-      !(server->flags & UV_HANDLE_GIVEN_OS_HANDLE)) {\n-    uv_pipe_queue_accept(loop, server, req, FALSE);\n+    if (!(server->flags & UV_HANDLE_CLOSING)) {\n+      uv_pipe_queue_accept(loop, server, req, FALSE);\n+    }\n   }\n \n   return 0;\n@@ -601,62 +659,130 @@ int uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb) {\n   uv_loop_t* loop = handle->loop;\n \n   int i, errno;\n-  uv_pipe_accept_t* req;\n-  HANDLE pipeHandle;\n \n-  if (!(handle->flags & UV_HANDLE_BOUND) &&\n-      !(handle->flags & UV_HANDLE_GIVEN_OS_HANDLE)) {\n-    uv_set_error(loop, UV_EINVAL, 0);\n+  if (!(handle->flags & UV_HANDLE_BOUND)) {\n+    uv__set_artificial_error(loop, UV_EINVAL);\n     return -1;\n   }\n \n   if (handle->flags & UV_HANDLE_LISTENING ||\n       handle->flags & UV_HANDLE_READING) {\n-    uv_set_error(loop, UV_EALREADY, 0);\n+    uv__set_artificial_error(loop, UV_EALREADY);\n     return -1;\n   }\n \n-  if (!(handle->flags & UV_HANDLE_PIPESERVER) &&\n-      !(handle->flags & UV_HANDLE_GIVEN_OS_HANDLE)) {\n-    uv_set_error(loop, UV_ENOTSUP, 0);\n+  if (!(handle->flags & UV_HANDLE_PIPESERVER)) {\n+    uv__set_artificial_error(loop, UV_ENOTSUP);\n     return -1;\n   }\n \n   handle->flags |= UV_HANDLE_LISTENING;\n   handle->connection_cb = cb;\n \n-  if (handle->flags & UV_HANDLE_GIVEN_OS_HANDLE) {\n-    handle->flags |= UV_HANDLE_PIPESERVER;\n-    pipeHandle = handle->handle;\n-    assert(pipeHandle != INVALID_HANDLE_VALUE);\n-    req = &handle->accept_reqs[0];\n-    uv_req_init(loop, (uv_req_t*) req);\n-    req->pipeHandle = pipeHandle;\n-    req->type = UV_ACCEPT;\n-    req->data = handle;\n-    req->next_pending = NULL;\n+  /* First pipe handle should have already been created in uv_pipe_bind */\n+  assert(handle->accept_reqs[0].pipeHandle != INVALID_HANDLE_VALUE);\n \n-    if (uv_set_pipe_handle(loop, handle, pipeHandle)) {\n-      uv_set_sys_error(loop, GetLastError());\n-      return -1;\n-    }\n+  for (i = 0; i < COUNTOF(handle->accept_reqs); i++) {\n+    uv_pipe_queue_accept(loop, handle, &handle->accept_reqs[i], i == 0);\n+  }\n \n-    uv_pipe_queue_accept(loop, handle, req, TRUE);\n-  } else {\n-    /* First pipe handle should have already been created in uv_pipe_bind */\n-    assert(handle->accept_reqs[0].pipeHandle != INVALID_HANDLE_VALUE);\n+  return 0;\n+}\n \n-    for (i = 0; i < COUNTOF(handle->accept_reqs); i++) {\n-      uv_pipe_queue_accept(loop, handle, &handle->accept_reqs[i], i == 0);\n-    }\n+\n+static DWORD WINAPI uv_pipe_zero_readfile_thread_proc(void* parameter) {\n+  int result;\n+  DWORD bytes;\n+  uv_read_t* req = (uv_read_t*) parameter;\n+  uv_pipe_t* handle = (uv_pipe_t*) req->data;\n+  uv_loop_t* loop = handle->loop;\n+\n+  assert(req != NULL);\n+  assert(req->type == UV_READ);\n+  assert(handle->type == UV_NAMED_PIPE);\n+\n+  result = ReadFile(handle->handle,\n+                    &uv_zero_,\n+                    0,\n+                    &bytes,\n+                    NULL);\n+\n+  if (!result) {\n+    SET_REQ_ERROR(req, GetLastError());\n   }\n \n+  POST_COMPLETION_FOR_REQ(loop, req);\n   return 0;\n }\n \n \n+static DWORD WINAPI uv_pipe_writefile_thread_proc(void* parameter) {\n+  int result;\n+  DWORD bytes;\n+  uv_write_t* req = (uv_write_t*) parameter;\n+  uv_pipe_t* handle = (uv_pipe_t*) req->handle;\n+  uv_loop_t* loop = handle->loop;\n+\n+  assert(req != NULL);\n+  assert(req->type == UV_WRITE);\n+  assert(handle->type == UV_NAMED_PIPE);\n+  assert(req->write_buffer.base);\n+\n+  result = WriteFile(handle->handle,\n+                     req->write_buffer.base,\n+                     req->write_buffer.len,\n+                     &bytes,\n+                     NULL);\n+\n+  if (!result) {\n+    SET_REQ_ERROR(req, GetLastError());\n+  }\n+\n+  POST_COMPLETION_FOR_REQ(loop, req);\n+  return 0;\n+}\n+\n+\n+static void CALLBACK post_completion_read_wait(void* context, BOOLEAN timed_out) {\n+  uv_read_t* req;\n+  uv_tcp_t* handle;\n+\n+  req = (uv_read_t*) context;\n+  assert(req != NULL);\n+  handle = (uv_tcp_t*)req->data;\n+  assert(handle != NULL);\n+  assert(!timed_out);\n+\n+  if (!PostQueuedCompletionStatus(handle->loop->iocp,\n+                                  req->overlapped.InternalHigh,\n+                                  0,\n+                                  &req->overlapped)) {\n+    uv_fatal_error(GetLastError(), \"PostQueuedCompletionStatus\");\n+  }\n+}\n+\n+\n+static void CALLBACK post_completion_write_wait(void* context, BOOLEAN timed_out) {\n+  uv_write_t* req;\n+  uv_tcp_t* handle;\n+\n+  req = (uv_write_t*) context;\n+  assert(req != NULL);\n+  handle = (uv_tcp_t*)req->handle;\n+  assert(handle != NULL);\n+  assert(!timed_out);\n+\n+  if (!PostQueuedCompletionStatus(handle->loop->iocp,\n+                                  req->overlapped.InternalHigh,\n+                                  0,\n+                                  &req->overlapped)) {\n+    uv_fatal_error(GetLastError(), \"PostQueuedCompletionStatus\");\n+  }\n+}\n+\n+\n static void uv_pipe_queue_read(uv_loop_t* loop, uv_pipe_t* handle) {\n-  uv_req_t* req;\n+  uv_read_t* req;\n   int result;\n \n   assert(handle->flags & UV_HANDLE_READING);\n@@ -665,55 +791,90 @@ static void uv_pipe_queue_read(uv_loop_t* loop, uv_pipe_t* handle) {\n   assert(handle->handle != INVALID_HANDLE_VALUE);\n \n   req = &handle->read_req;\n-  memset(&req->overlapped, 0, sizeof(req->overlapped));\n \n-  /* Do 0-read */\n-  result = ReadFile(handle->handle,\n-                    &uv_zero_,\n-                    0,\n-                    NULL,\n-                    &req->overlapped);\n+  if (handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE) {\n+    if (!QueueUserWorkItem(&uv_pipe_zero_readfile_thread_proc,\n+                           req,\n+                           WT_EXECUTELONGFUNCTION)) {\n+      /* Make this req pending reporting an error. */\n+      SET_REQ_ERROR(req, GetLastError());\n+      goto error;\n+    } \n+  } else {\n+    memset(&req->overlapped, 0, sizeof(req->overlapped));\n+    if (handle->flags & UV_HANDLE_EMULATE_IOCP) {\n+      req->overlapped.hEvent = (HANDLE) ((DWORD) req->event_handle | 1);\n+    }\n \n-  if (!result && GetLastError() != ERROR_IO_PENDING) {\n-    /* Make this req pending reporting an error. */\n-    SET_REQ_ERROR(req, WSAGetLastError());\n-    uv_insert_pending_req(loop, req);\n-    handle->reqs_pending++;\n-    return;\n+    /* Do 0-read */\n+    result = ReadFile(handle->handle,\n+                      &uv_zero_,\n+                      0,\n+                      NULL,\n+                      &req->overlapped);\n+\n+    if (!result && GetLastError() != ERROR_IO_PENDING) {\n+      /* Make this req pending reporting an error. */\n+      SET_REQ_ERROR(req, GetLastError());\n+      goto error;\n+    }\n+\n+    if (handle->flags & UV_HANDLE_EMULATE_IOCP) {\n+      if (!req->event_handle) {\n+        req->event_handle = CreateEvent(NULL, 0, 0, NULL);\n+        if (!req->event_handle) {\n+          uv_fatal_error(GetLastError(), \"CreateEvent\");\n+        }\n+      }\n+      if (req->wait_handle == INVALID_HANDLE_VALUE) {\n+        if (!RegisterWaitForSingleObject(&req->wait_handle,\n+            req->overlapped.hEvent, post_completion_read_wait, (void*) req,\n+            INFINITE, WT_EXECUTEINWAITTHREAD)) {\n+          SET_REQ_ERROR(req, GetLastError());\n+          goto error;\n+        }\n+      }\n+    }\n   }\n \n   /* Start the eof timer if there is one */\n   eof_timer_start(handle);\n+  handle->flags |= UV_HANDLE_READ_PENDING;\n+  handle->reqs_pending++;\n+  return;\n \n+error:\n+  uv_insert_pending_req(loop, (uv_req_t*)req);\n   handle->flags |= UV_HANDLE_READ_PENDING;\n   handle->reqs_pending++;\n }\n \n \n-int uv_pipe_read_start(uv_pipe_t* handle, uv_alloc_cb alloc_cb,\n-    uv_read_cb read_cb) {\n+static int uv_pipe_read_start_impl(uv_pipe_t* handle, uv_alloc_cb alloc_cb,\n+    uv_read_cb read_cb, uv_read2_cb read2_cb) {\n   uv_loop_t* loop = handle->loop;\n \n   if (!(handle->flags & UV_HANDLE_CONNECTION)) {\n-    uv_set_error(loop, UV_EINVAL, 0);\n+    uv__set_artificial_error(loop, UV_EINVAL);\n     return -1;\n   }\n \n   if (handle->flags & UV_HANDLE_READING) {\n-    uv_set_error(loop, UV_EALREADY, 0);\n+    uv__set_artificial_error(loop, UV_EALREADY);\n     return -1;\n   }\n \n   if (handle->flags & UV_HANDLE_EOF) {\n-    uv_set_error(loop, UV_EOF, 0);\n+    uv__set_artificial_error(loop, UV_EOF);\n     return -1;\n   }\n \n   handle->flags |= UV_HANDLE_READING;\n   handle->read_cb = read_cb;\n+  handle->read2_cb = read2_cb;\n   handle->alloc_cb = alloc_cb;\n \n-  /* If reading was stopped and then started again, there could stell be a */\n+  /* If reading was stopped and then started again, there could still be a */\n   /* read request pending. */\n   if (!(handle->flags & UV_HANDLE_READ_PENDING))\n     uv_pipe_queue_read(loop, handle);\n@@ -722,51 +883,237 @@ int uv_pipe_read_start(uv_pipe_t* handle, uv_alloc_cb alloc_cb,\n }\n \n \n-int uv_pipe_write(uv_loop_t* loop, uv_write_t* req, uv_pipe_t* handle,\n-    uv_buf_t bufs[], int bufcnt, uv_write_cb cb) {\n+int uv_pipe_read_start(uv_pipe_t* handle, uv_alloc_cb alloc_cb,\n+    uv_read_cb read_cb) {\n+  return uv_pipe_read_start_impl(handle, alloc_cb, read_cb, NULL);\n+}\n+\n+\n+int uv_pipe_read2_start(uv_pipe_t* handle, uv_alloc_cb alloc_cb,\n+    uv_read2_cb read_cb) {\n+  return uv_pipe_read_start_impl(handle, alloc_cb, NULL, read_cb);\n+}\n+\n+\n+static void uv_insert_non_overlapped_write_req(uv_pipe_t* handle,\n+    uv_write_t* req) {\n+  req->next_req = NULL;\n+  if (handle->non_overlapped_writes_tail) {\n+    req->next_req =\n+      handle->non_overlapped_writes_tail->next_req;\n+    handle->non_overlapped_writes_tail->next_req = (uv_req_t*)req;\n+    handle->non_overlapped_writes_tail = req;\n+  } else {\n+    req->next_req = (uv_req_t*)req;\n+    handle->non_overlapped_writes_tail = req;\n+  }\n+}\n+\n+\n+static uv_write_t* uv_remove_non_overlapped_write_req(uv_pipe_t* handle) {\n+  uv_write_t* req;\n+\n+  if (handle->non_overlapped_writes_tail) {\n+    req = (uv_write_t*)handle->non_overlapped_writes_tail->next_req;\n+\n+    if (req == handle->non_overlapped_writes_tail) {\n+      handle->non_overlapped_writes_tail = NULL;\n+    } else {\n+      handle->non_overlapped_writes_tail->next_req =\n+        req->next_req;\n+    }\n+\n+    return req;\n+  } else {\n+    /* queue empty */\n+    return NULL;\n+  }\n+}\n+\n+\n+static void uv_queue_non_overlapped_write(uv_pipe_t* handle) {\n+  uv_write_t* req = uv_remove_non_overlapped_write_req(handle);\n+  if (req) {\n+    if (!QueueUserWorkItem(&uv_pipe_writefile_thread_proc,\n+                           req,\n+                           WT_EXECUTELONGFUNCTION)) {\n+      uv_fatal_error(GetLastError(), \"QueueUserWorkItem\");\n+    }\n+  }\n+}\n+\n+\n+static int uv_pipe_write_impl(uv_loop_t* loop, uv_write_t* req,\n+    uv_pipe_t* handle, uv_buf_t bufs[], int bufcnt,\n+    uv_stream_t* send_handle, uv_write_cb cb) {\n   int result;\n+  uv_tcp_t* tcp_send_handle;\n+  uv_write_t* ipc_header_req;\n+  uv_ipc_frame_uv_stream ipc_frame;\n+\n+  if (bufcnt != 1 && (bufcnt != 0 || !send_handle)) {\n+    uv__set_artificial_error(loop, UV_ENOTSUP);\n+    return -1;\n+  }\n \n-  if (bufcnt != 1) {\n-    uv_set_error(loop, UV_ENOTSUP, 0);\n+  if (send_handle && send_handle->type != UV_TCP) {\n+    uv__set_artificial_error(loop, UV_ENOTSUP);\n     return -1;\n   }\n \n   assert(handle->handle != INVALID_HANDLE_VALUE);\n \n   if (!(handle->flags & UV_HANDLE_CONNECTION)) {\n-    uv_set_error(loop, UV_EINVAL, 0);\n+    uv__set_artificial_error(loop, UV_EINVAL);\n     return -1;\n   }\n \n   if (handle->flags & UV_HANDLE_SHUTTING) {\n-    uv_set_error(loop, UV_EOF, 0);\n+    uv__set_artificial_error(loop, UV_EOF);\n     return -1;\n   }\n \n   uv_req_init(loop, (uv_req_t*) req);\n   req->type = UV_WRITE;\n   req->handle = (uv_stream_t*) handle;\n   req->cb = cb;\n+  req->ipc_header = 0;\n+  req->event_handle = NULL;\n+  req->wait_handle = INVALID_HANDLE_VALUE;\n   memset(&req->overlapped, 0, sizeof(req->overlapped));\n \n-  result = WriteFile(handle->handle,\n-                     bufs[0].base,\n-                     bufs[0].len,\n-                     NULL,\n-                     &req->overlapped);\n+  if (handle->ipc) {\n+    assert(!(handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE));\n+    ipc_frame.header.flags = 0;\n+\n+    /* Use the IPC framing protocol. */\n+    if (send_handle) {\n+      tcp_send_handle = (uv_tcp_t*)send_handle;\n+      if (WSADuplicateSocketW(tcp_send_handle->socket, handle->ipc_pid,\n+          &ipc_frame.socket_info)) {\n+        uv__set_sys_error(loop, WSAGetLastError());\n+        return -1;\n+      }\n+      ipc_frame.header.flags |= UV_IPC_UV_STREAM;\n+    }\n \n-  if (!result && GetLastError() != ERROR_IO_PENDING) {\n-    uv_set_sys_error(loop, GetLastError());\n-    return -1;\n+    if (bufcnt == 1) {\n+      ipc_frame.header.flags |= UV_IPC_RAW_DATA;\n+      ipc_frame.header.raw_data_length = bufs[0].len;\n+    }\n+\n+    /* \n+     * Use the provided req if we're only doing a single write.\n+     * If we're doing multiple writes, use ipc_header_write_req to do\n+     * the first write, and then use the provided req for the second write.\n+     */\n+    if (!(ipc_frame.header.flags & UV_IPC_RAW_DATA)) {\n+      ipc_header_req = req;\n+    } else {\n+      /* \n+       * Try to use the preallocated write req if it's available.\n+       * Otherwise allocate a new one.\n+       */\n+      if (handle->ipc_header_write_req.type != UV_WRITE) {\n+        ipc_header_req = (uv_write_t*)&handle->ipc_header_write_req;\n+      } else {\n+        ipc_header_req = (uv_write_t*)malloc(sizeof(uv_write_t));\n+        if (!handle->accept_reqs) {\n+          uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");\n+        }\n+      }\n+\n+      uv_req_init(loop, (uv_req_t*) ipc_header_req);\n+      ipc_header_req->type = UV_WRITE;\n+      ipc_header_req->handle = (uv_stream_t*) handle;\n+      ipc_header_req->cb = NULL;\n+      ipc_header_req->ipc_header = 1;\n+    }\n+\n+    /* Write the header or the whole frame. */\n+    memset(&ipc_header_req->overlapped, 0, sizeof(ipc_header_req->overlapped));\n+\n+    result = WriteFile(handle->handle,\n+                        &ipc_frame,\n+                        ipc_frame.header.flags & UV_IPC_UV_STREAM ?\n+                          sizeof(ipc_frame) : sizeof(ipc_frame.header),\n+                        NULL,\n+                        &ipc_header_req->overlapped);\n+    if (!result && GetLastError() != ERROR_IO_PENDING) {\n+      uv__set_sys_error(loop, GetLastError());\n+      return -1;\n+    }\n+\n+    if (result) {\n+      /* Request completed immediately. */\n+      ipc_header_req->queued_bytes = 0;\n+    } else {\n+      /* Request queued by the kernel. */\n+      ipc_header_req->queued_bytes = ipc_frame.header.flags & UV_IPC_UV_STREAM ?\n+        sizeof(ipc_frame) : sizeof(ipc_frame.header);\n+      handle->write_queue_size += req->queued_bytes;\n+    }\n+\n+    if (handle->write_reqs_pending == 0) {\n+      uv_ref(loop);\n+    }\n+\n+    handle->reqs_pending++;\n+    handle->write_reqs_pending++;\n+\n+    /* If we don't have any raw data to write - we're done. */\n+    if (!(ipc_frame.header.flags & UV_IPC_RAW_DATA)) {\n+      return 0;\n+    }\n   }\n \n-  if (result) {\n-    /* Request completed immediately. */\n-    req->queued_bytes = 0;\n-  } else {\n+  if (handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE) {\n+    req->write_buffer = bufs[0];\n+    uv_insert_non_overlapped_write_req(handle, req);\n+    if (handle->write_reqs_pending == 0) {\n+      uv_queue_non_overlapped_write(handle);\n+    }\n+\n     /* Request queued by the kernel. */\n     req->queued_bytes = uv_count_bufs(bufs, bufcnt);\n     handle->write_queue_size += req->queued_bytes;\n+  } else {\n+    result = WriteFile(handle->handle,\n+                       bufs[0].base,\n+                       bufs[0].len,\n+                       NULL,\n+                       &req->overlapped);\n+\n+    if (!result && GetLastError() != ERROR_IO_PENDING) {\n+      uv__set_sys_error(loop, GetLastError());\n+      return -1;\n+    }\n+\n+    if (result) {\n+      /* Request completed immediately. */\n+      req->queued_bytes = 0;\n+    } else {\n+      /* Request queued by the kernel. */\n+      req->queued_bytes = uv_count_bufs(bufs, bufcnt);\n+      handle->write_queue_size += req->queued_bytes;\n+    }\n+\n+    if (handle->flags & UV_HANDLE_EMULATE_IOCP) {\n+      req->event_handle = CreateEvent(NULL, 0, 0, NULL);\n+      if (!req->event_handle) {\n+        uv_fatal_error(GetLastError(), \"CreateEvent\");\n+      }\n+      if (!RegisterWaitForSingleObject(&req->wait_handle,\n+          req->overlapped.hEvent, post_completion_write_wait, (void*) req,\n+          INFINITE, WT_EXECUTEINWAITTHREAD)) {\n+        uv__set_sys_error(loop, GetLastError());\n+        return -1;\n+      }\n+    }\n+  }\n+\n+  if (handle->write_reqs_pending == 0) {\n+    uv_ref(loop);\n   }\n \n   handle->reqs_pending++;\n@@ -776,6 +1123,23 @@ int uv_pipe_write(uv_loop_t* loop, uv_write_t* req, uv_pipe_t* handle,\n }\n \n \n+int uv_pipe_write(uv_loop_t* loop, uv_write_t* req, uv_pipe_t* handle,\n+    uv_buf_t bufs[], int bufcnt, uv_write_cb cb) {\n+  return uv_pipe_write_impl(loop, req, handle, bufs, bufcnt, NULL, cb);\n+}\n+\n+\n+int uv_pipe_write2(uv_loop_t* loop, uv_write_t* req, uv_pipe_t* handle,\n+    uv_buf_t bufs[], int bufcnt, uv_stream_t* send_handle, uv_write_cb cb) {\n+  if (!handle->ipc) {\n+    uv__set_artificial_error(loop, UV_EINVAL);\n+    return -1;\n+  }\n+\n+  return uv_pipe_write_impl(loop, req, handle, bufs, bufcnt, send_handle, cb);\n+}\n+\n+\n static void uv_pipe_read_eof(uv_loop_t* loop, uv_pipe_t* handle,\n     uv_buf_t buf) {\n   /* If there is an eof timer running, we don't need it any more, */\n@@ -785,8 +1149,12 @@ static void uv_pipe_read_eof(uv_loop_t* loop, uv_pipe_t* handle,\n   handle->flags |= UV_HANDLE_EOF;\n   uv_read_stop((uv_stream_t*) handle);\n \n-  uv_set_error(loop, UV_EOF, 0);\n-  handle->read_cb((uv_stream_t*) handle, -1, uv_null_buf_);\n+  uv__set_artificial_error(loop, UV_EOF);\n+  if (handle->read2_cb) {\n+    handle->read2_cb(handle, -1, uv_null_buf_, UV_UNKNOWN_HANDLE);\n+  } else {\n+    handle->read_cb((uv_stream_t*) handle, -1, uv_null_buf_);\n+  }\n }\n \n \n@@ -798,8 +1166,12 @@ static void uv_pipe_read_error(uv_loop_t* loop, uv_pipe_t* handle, int error,\n \n   uv_read_stop((uv_stream_t*) handle);\n \n-  uv_set_sys_error(loop, error);\n-  handle->read_cb((uv_stream_t*)handle, -1, buf);\n+  uv__set_sys_error(loop, error);\n+  if (handle->read2_cb) {\n+    handle->read2_cb(handle, -1, buf, UV_UNKNOWN_HANDLE);\n+  } else {\n+    handle->read_cb((uv_stream_t*)handle, -1, buf);\n+  }\n }\n \n \n@@ -817,6 +1189,7 @@ void uv_process_pipe_read_req(uv_loop_t* loop, uv_pipe_t* handle,\n     uv_req_t* req) {\n   DWORD bytes, avail;\n   uv_buf_t buf;\n+  uv_ipc_frame_uv_stream ipc_frame;\n \n   assert(handle->type == UV_NAMED_PIPE);\n \n@@ -835,11 +1208,11 @@ void uv_process_pipe_read_req(uv_loop_t* loop, uv_pipe_t* handle,\n     /* Do non-blocking reads until the buffer is empty */\n     while (handle->flags & UV_HANDLE_READING) {\n       if (!PeekNamedPipe(handle->handle,\n-                         NULL,\n-                         0,\n-                         NULL,\n-                         &avail,\n-                         NULL)) {\n+                          NULL,\n+                          0,\n+                          NULL,\n+                          &avail,\n+                          NULL)) {\n         uv_pipe_read_error_or_eof(loop, handle, GetLastError(), uv_null_buf_);\n         break;\n       }\n@@ -849,6 +1222,63 @@ void uv_process_pipe_read_req(uv_loop_t* loop, uv_pipe_t* handle,\n         break;\n       }\n \n+      if (handle->ipc) {\n+        /* Use the IPC framing protocol to read the incoming data. */\n+        if (handle->remaining_ipc_rawdata_bytes == 0) {\n+          /* We're reading a new frame.  First, read the header. */\n+          assert(avail >= sizeof(ipc_frame.header));\n+\n+          if (!ReadFile(handle->handle,\n+                        &ipc_frame.header,\n+                        sizeof(ipc_frame.header),\n+                        &bytes,\n+                        NULL)) {\n+            uv_pipe_read_error_or_eof(loop, handle, GetLastError(),\n+              uv_null_buf_);\n+            break;\n+          }\n+\n+          assert(bytes == sizeof(ipc_frame.header));\n+          assert(ipc_frame.header.flags <= (UV_IPC_UV_STREAM | UV_IPC_RAW_DATA));\n+\n+          if (ipc_frame.header.flags & UV_IPC_UV_STREAM) {\n+            assert(avail - sizeof(ipc_frame.header) >=\n+              sizeof(ipc_frame.socket_info));\n+\n+            /* Read the TCP socket info. */\n+            if (!ReadFile(handle->handle,\n+                          &ipc_frame.socket_info,\n+                          sizeof(ipc_frame) - sizeof(ipc_frame.header),\n+                          &bytes,\n+                          NULL)) {\n+              uv_pipe_read_error_or_eof(loop, handle, GetLastError(),\n+                uv_null_buf_);\n+              break;\n+            }\n+\n+            assert(bytes == sizeof(ipc_frame) - sizeof(ipc_frame.header));\n+\n+            /* Store the pending socket info. */\n+            assert(!handle->pending_socket_info);\n+            handle->pending_socket_info =\n+              (WSAPROTOCOL_INFOW*)malloc(sizeof(*(handle->pending_socket_info)));\n+            if (!handle->pending_socket_info) {\n+              uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");\n+            }\n+\n+            *(handle->pending_socket_info) = ipc_frame.socket_info;\n+          }\n+\n+          if (ipc_frame.header.flags & UV_IPC_RAW_DATA) {\n+            handle->remaining_ipc_rawdata_bytes =\n+              ipc_frame.header.raw_data_length;\n+            continue;\n+          }\n+        } else {\n+          avail = min(avail, (DWORD)handle->remaining_ipc_rawdata_bytes);\n+        }\n+      }\n+\n       buf = handle->alloc_cb((uv_handle_t*) handle, avail);\n       assert(buf.len > 0);\n \n@@ -858,7 +1288,25 @@ void uv_process_pipe_read_req(uv_loop_t* loop, uv_pipe_t* handle,\n                    &bytes,\n                    NULL)) {\n         /* Successful read */\n-        handle->read_cb((uv_stream_t*)handle, bytes, buf);\n+        if (handle->ipc) {\n+          assert(handle->remaining_ipc_rawdata_bytes >= bytes);\n+          handle->remaining_ipc_rawdata_bytes = \n+            handle->remaining_ipc_rawdata_bytes - bytes;\n+          if (handle->read2_cb) {\n+            handle->read2_cb(handle, bytes, buf,\n+              handle->pending_socket_info ? UV_TCP : UV_UNKNOWN_HANDLE);\n+          } else if (handle->read_cb) {\n+            handle->read_cb((uv_stream_t*)handle, bytes, buf);\n+          }\n+\n+          if (handle->pending_socket_info) {\n+            free(handle->pending_socket_info);\n+            handle->pending_socket_info = NULL;\n+          }\n+        } else {\n+          handle->read_cb((uv_stream_t*)handle, bytes, buf);\n+        }\n+\n         /* Read again only if bytes == buf.len */\n         if (bytes <= buf.len) {\n           break;\n@@ -884,18 +1332,49 @@ void uv_process_pipe_write_req(uv_loop_t* loop, uv_pipe_t* handle,\n     uv_write_t* req) {\n   assert(handle->type == UV_NAMED_PIPE);\n \n+  assert(handle->write_queue_size >= req->queued_bytes);\n   handle->write_queue_size -= req->queued_bytes;\n \n-  if (req->cb) {\n-    if (!REQ_SUCCESS(req)) {\n-      loop->last_error = GET_REQ_UV_ERROR(req);\n-      ((uv_write_cb)req->cb)(req, -1);\n+  if (handle->flags & UV_HANDLE_EMULATE_IOCP) {\n+    if (req->wait_handle != INVALID_HANDLE_VALUE) {\n+      UnregisterWait(req->wait_handle);\n+      req->wait_handle = INVALID_HANDLE_VALUE;\n+    }\n+    if (req->event_handle) {\n+      CloseHandle(req->event_handle);\n+      req->event_handle = NULL;\n+    }\n+  }\n+\n+  if (req->ipc_header) {\n+    if (req == &handle->ipc_header_write_req) {\n+      req->type = UV_UNKNOWN_REQ;\n     } else {\n-      ((uv_write_cb)req->cb)(req, 0);\n+      free(req);\n+    }\n+  } else {\n+    if (req->cb) {\n+      if (!REQ_SUCCESS(req)) {\n+        uv__set_sys_error(loop, GET_REQ_ERROR(req));\n+        ((uv_write_cb)req->cb)(req, -1);\n+      } else {\n+        ((uv_write_cb)req->cb)(req, 0);\n+      }\n     }\n   }\n \n   handle->write_reqs_pending--;\n+\n+  if (handle->flags & UV_HANDLE_NON_OVERLAPPED_PIPE &&\n+      handle->non_overlapped_writes_tail) {\n+    assert(handle->write_reqs_pending > 0);\n+    uv_queue_non_overlapped_write(handle);\n+  }\n+\n+  if (handle->write_reqs_pending == 0) {\n+    uv_unref(loop);\n+  }\n+\n   if (handle->write_reqs_pending == 0 &&\n       handle->flags & UV_HANDLE_SHUTTING) {\n     uv_want_endgame(loop, (uv_handle_t*)handle);\n@@ -924,8 +1403,7 @@ void uv_process_pipe_accept_req(uv_loop_t* loop, uv_pipe_t* handle,\n       CloseHandle(req->pipeHandle);\n       req->pipeHandle = INVALID_HANDLE_VALUE;\n     }\n-    if (!(handle->flags & UV_HANDLE_CLOSING) &&\n-        !(handle->flags & UV_HANDLE_GIVEN_OS_HANDLE)) {\n+    if (!(handle->flags & UV_HANDLE_CLOSING)) {\n       uv_pipe_queue_accept(loop, handle, req, FALSE);\n     }\n   }\n@@ -943,7 +1421,7 @@ void uv_process_pipe_connect_req(uv_loop_t* loop, uv_pipe_t* handle,\n       uv_pipe_connection_init(handle);\n       ((uv_connect_cb)req->cb)(req, 0);\n     } else {\n-      loop->last_error = GET_REQ_UV_ERROR(req);\n+      uv__set_sys_error(loop, GET_REQ_ERROR(req));\n       ((uv_connect_cb)req->cb)(req, -1);\n     }\n   }\n@@ -1062,6 +1540,19 @@ static void eof_timer_close_cb(uv_handle_t* handle) {\n \n \n void uv_pipe_open(uv_pipe_t* pipe, uv_file file) {\n-  assert(0 && \"implement me\");\n-}\n+  HANDLE os_handle = (HANDLE)_get_osfhandle(file);\n+\n+  if (os_handle == INVALID_HANDLE_VALUE ||\n+      uv_set_pipe_handle(pipe->loop, pipe, os_handle) == -1) {\n+    return;\n+  }\n \n+  uv_pipe_connection_init(pipe);\n+  pipe->handle = os_handle;\n+\n+  if (pipe->ipc) {\n+    assert(!(pipe->flags & UV_HANDLE_NON_OVERLAPPED_PIPE));\n+    pipe->ipc_pid = uv_parent_pid();\n+    assert(pipe->ipc_pid != -1);\n+  }\n+}"}, {"sha": "0e70984013aaf7aa44b889463d1445701b295c42", "filename": "src/rt/libuv/src/win/process.c", "status": "modified", "additions": 66, "deletions": 25, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fprocess.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fprocess.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fprocess.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -45,7 +45,7 @@ typedef struct env_var {\n     uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");          \\\n   }                                                       \\\n   if (!uv_utf8_to_utf16(s, t, size / sizeof(wchar_t))) {  \\\n-    uv_set_sys_error(loop, GetLastError());                     \\\n+    uv__set_sys_error(loop, GetLastError());              \\\n     err = -1;                                             \\\n     goto done;                                            \\\n   }\n@@ -739,14 +739,15 @@ void uv_process_close(uv_loop_t* loop, uv_process_t* handle) {\n \n \n static int uv_create_stdio_pipe_pair(uv_loop_t* loop, uv_pipe_t* server_pipe,\n-    HANDLE* child_pipe,  DWORD server_access, DWORD child_access) {\n+    HANDLE* child_pipe,  DWORD server_access, DWORD child_access,\n+    int overlapped) {\n   int err;\n   SECURITY_ATTRIBUTES sa = { sizeof(SECURITY_ATTRIBUTES), NULL, TRUE };\n   char pipe_name[64];\n   DWORD mode = PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT;\n \n   if (server_pipe->type != UV_NAMED_PIPE) {\n-    uv_set_error(loop, UV_EINVAL, 0);\n+    uv__set_artificial_error(loop, UV_EINVAL);\n     err = -1;\n     goto done;\n   }\n@@ -767,17 +768,17 @@ static int uv_create_stdio_pipe_pair(uv_loop_t* loop, uv_pipe_t* server_pipe,\n                             0,\n                             &sa,\n                             OPEN_EXISTING,\n-                            0,\n+                            overlapped ? FILE_FLAG_OVERLAPPED : 0,\n                             NULL);\n \n   if (*child_pipe == INVALID_HANDLE_VALUE) {\n-    uv_set_sys_error(loop, GetLastError());\n+    uv__set_sys_error(loop, GetLastError());\n     err = -1;\n     goto done;\n   }\n \n   if (!SetNamedPipeHandleState(*child_pipe, &mode, NULL, NULL)) {\n-    uv_set_sys_error(loop, GetLastError());\n+    uv__set_sys_error(loop, GetLastError());\n     err = -1;\n     goto done;\n   }\n@@ -787,7 +788,7 @@ static int uv_create_stdio_pipe_pair(uv_loop_t* loop, uv_pipe_t* server_pipe,\n    */\n   if (!ConnectNamedPipe(server_pipe->handle, NULL)) {\n     if (GetLastError() != ERROR_PIPE_CONNECTED) {\n-      uv_set_sys_error(loop, GetLastError());\n+      uv__set_sys_error(loop, GetLastError());\n       err = -1;\n       goto done;\n     }\n@@ -822,7 +823,7 @@ static int duplicate_std_handle(uv_loop_t* loop, DWORD id, HANDLE* dup) {\n     return 0;\n   } else if (handle == INVALID_HANDLE_VALUE) {\n     *dup = INVALID_HANDLE_VALUE;\n-    uv_set_sys_error(loop, GetLastError());\n+    uv__set_sys_error(loop, GetLastError());\n     return -1;\n   }\n \n@@ -834,7 +835,7 @@ static int duplicate_std_handle(uv_loop_t* loop, DWORD id, HANDLE* dup) {\n                        TRUE,\n                        DUPLICATE_SAME_ACCESS)) {\n     *dup = INVALID_HANDLE_VALUE;\n-    uv_set_sys_error(loop, GetLastError());\n+    uv__set_sys_error(loop, GetLastError());\n     return -1;\n   }\n \n@@ -848,13 +849,14 @@ int uv_spawn(uv_loop_t* loop, uv_process_t* process,\n   wchar_t* path = NULL;\n   int size;\n   BOOL result;\n-  wchar_t* application_path = NULL, *application = NULL, *arguments = NULL, *env = NULL, *cwd = NULL;\n+  wchar_t* application_path = NULL, *application = NULL, *arguments = NULL,\n+    *env = NULL, *cwd = NULL;\n   HANDLE* child_stdio = process->child_stdio;\n   STARTUPINFOW startup;\n   PROCESS_INFORMATION info;\n \n   if (!options.file) {\n-    uv_set_error(loop, UV_EINVAL, 0);\n+    uv__set_artificial_error(loop, UV_EINVAL);\n     return -1;\n   }\n \n@@ -877,7 +879,7 @@ int uv_spawn(uv_loop_t* loop, uv_process_t* process,\n       }\n       GetCurrentDirectoryW(size, cwd);\n     } else {\n-      uv_set_sys_error(loop, GetLastError());\n+      uv__set_sys_error(loop, GetLastError());\n       err = -1;\n       goto done;\n     }\n@@ -904,12 +906,23 @@ int uv_spawn(uv_loop_t* loop, uv_process_t* process,\n \n   /* Create stdio pipes. */\n   if (options.stdin_stream) {\n-    err = uv_create_stdio_pipe_pair(\n-        loop,\n-        options.stdin_stream,\n-        &child_stdio[0],\n-        PIPE_ACCESS_OUTBOUND,\n-        GENERIC_READ | FILE_WRITE_ATTRIBUTES);\n+    if (options.stdin_stream->ipc) {\n+      err = uv_create_stdio_pipe_pair(\n+          loop,\n+          options.stdin_stream,\n+          &child_stdio[0],\n+          PIPE_ACCESS_DUPLEX,\n+          GENERIC_READ | FILE_WRITE_ATTRIBUTES | GENERIC_WRITE,\n+          1);\n+    } else {\n+      err = uv_create_stdio_pipe_pair(\n+          loop,\n+          options.stdin_stream,\n+          &child_stdio[0],\n+          PIPE_ACCESS_OUTBOUND,\n+          GENERIC_READ | FILE_WRITE_ATTRIBUTES,\n+          0);\n+    }\n   } else {\n     err = duplicate_std_handle(loop, STD_INPUT_HANDLE, &child_stdio[0]);\n   }\n@@ -922,7 +935,8 @@ int uv_spawn(uv_loop_t* loop, uv_process_t* process,\n         loop, options.stdout_stream,\n         &child_stdio[1],\n         PIPE_ACCESS_INBOUND,\n-        GENERIC_WRITE);\n+        GENERIC_WRITE,\n+        0);\n   } else {\n     err = duplicate_std_handle(loop, STD_OUTPUT_HANDLE, &child_stdio[1]);\n   }\n@@ -936,7 +950,8 @@ int uv_spawn(uv_loop_t* loop, uv_process_t* process,\n         options.stderr_stream,\n         &child_stdio[2],\n         PIPE_ACCESS_INBOUND,\n-        GENERIC_WRITE);\n+        GENERIC_WRITE,\n+        0);\n   } else {\n     err = duplicate_std_handle(loop, STD_ERROR_HANDLE, &child_stdio[2]);\n   }\n@@ -969,6 +984,11 @@ int uv_spawn(uv_loop_t* loop, uv_process_t* process,\n     process->process_handle = info.hProcess;\n     process->pid = info.dwProcessId;\n \n+    if (options.stdin_stream &&\n+        options.stdin_stream->ipc) {\n+      options.stdin_stream->ipc_pid = info.dwProcessId;\n+    }\n+\n     /* Setup notifications for when the child process exits. */\n     result = RegisterWaitForSingleObject(&process->wait_handle,\n         process->process_handle, exit_wait_callback, (void*)process, INFINITE,\n@@ -1033,13 +1053,34 @@ int uv_spawn(uv_loop_t* loop, uv_process_t* process,\n \n \n int uv_process_kill(uv_process_t* process, int signum) {\n-  process->exit_signal = signum;\n+  DWORD status;\n \n-  /* On windows killed processes normally return 1 */\n-  if (process->process_handle != INVALID_HANDLE_VALUE &&\n-      TerminateProcess(process->process_handle, 1)) {\n+  if (process->process_handle == INVALID_HANDLE_VALUE) {\n+    uv__set_artificial_error(process->loop, UV_EINVAL);\n+    return -1;\n+  }\n+\n+  if (signum) {\n+    /* Kill the process. On Windows, killed processes normally return 1. */\n+    if (TerminateProcess(process->process_handle, 1)) {\n+        process->exit_signal = signum;\n+        return 0;\n+    }\n+    else {\n+      uv__set_sys_error(process->loop, GetLastError());\n+      return -1;\n+    }\n+  }\n+  else {\n+    /* Health check: is the process still alive? */\n+    if (GetExitCodeProcess(process->process_handle, &status) && status == STILL_ACTIVE) {\n       return 0;\n+    }\n+    else {\n+      uv__set_artificial_error(process->loop, UV_EINVAL);\n+      return -1;\n+    }\n   }\n \n-  return -1;\n+  assert(0 && \"unreachable\");\n }"}, {"sha": "dd2b38809e9e20d49ff92b25946850ae8b9c0238", "filename": "src/rt/libuv/src/win/req.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Freq.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Freq.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Freq.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -87,6 +87,12 @@ static uv_req_t* uv_remove_pending_req(uv_loop_t* loop) {\n                                        req);                                  \\\n         break;                                                                \\\n                                                                               \\\n+      case UV_TTY:                                                            \\\n+        uv_process_tty_##method##_req(loop,                                   \\\n+                                      (uv_tty_t*) ((req)->handle_at),         \\\n+                                      req);                                   \\\n+        break;                                                                \\\n+                                                                              \\\n       default:                                                                \\\n         assert(0);                                                            \\\n     }                                                                         \\"}, {"sha": "c2354eecba023f09efb4d75f8f8ac14cf0627384", "filename": "src/rt/libuv/src/win/stream.c", "status": "modified", "additions": 43, "deletions": 9, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fstream.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fstream.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fstream.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -43,6 +43,8 @@ void uv_connection_init(uv_stream_t* handle) {\n   handle->write_reqs_pending = 0;\n \n   uv_req_init(handle->loop, (uv_req_t*) &(handle->read_req));\n+  handle->read_req.event_handle = NULL;\n+  handle->read_req.wait_handle = INVALID_HANDLE_VALUE;\n   handle->read_req.type = UV_READ;\n   handle->read_req.data = handle;\n }\n@@ -62,13 +64,11 @@ int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb) {\n \n \n int uv_accept(uv_stream_t* server, uv_stream_t* client) {\n-  assert(client->type == server->type);\n-\n   switch (server->type) {\n     case UV_TCP:\n       return uv_tcp_accept((uv_tcp_t*)server, (uv_tcp_t*)client);\n     case UV_NAMED_PIPE:\n-      return uv_pipe_accept((uv_pipe_t*)server, (uv_pipe_t*)client);\n+      return uv_pipe_accept((uv_pipe_t*)server, client);\n     default:\n       assert(0);\n       return -1;\n@@ -83,17 +83,34 @@ int uv_read_start(uv_stream_t* handle, uv_alloc_cb alloc_cb,\n       return uv_tcp_read_start((uv_tcp_t*)handle, alloc_cb, read_cb);\n     case UV_NAMED_PIPE:\n       return uv_pipe_read_start((uv_pipe_t*)handle, alloc_cb, read_cb);\n+    case UV_TTY:\n+      return uv_tty_read_start((uv_tty_t*) handle, alloc_cb, read_cb);\n     default:\n       assert(0);\n       return -1;\n   }\n }\n \n \n-int uv_read_stop(uv_stream_t* handle) {\n-  handle->flags &= ~UV_HANDLE_READING;\n+int uv_read2_start(uv_stream_t* handle, uv_alloc_cb alloc_cb,\n+    uv_read2_cb read_cb) {\n+  switch (handle->type) {\n+    case UV_NAMED_PIPE:\n+      return uv_pipe_read2_start((uv_pipe_t*)handle, alloc_cb, read_cb);\n+    default:\n+      assert(0);\n+      return -1;\n+  }\n+}\n \n-  return 0;\n+\n+int uv_read_stop(uv_stream_t* handle) {\n+  if (handle->type == UV_TTY) {\n+    return uv_tty_read_stop((uv_tty_t*) handle);\n+  } else {\n+    handle->flags &= ~UV_HANDLE_READING;\n+    return 0;\n+  }\n }\n \n \n@@ -106,9 +123,26 @@ int uv_write(uv_write_t* req, uv_stream_t* handle, uv_buf_t bufs[], int bufcnt,\n       return uv_tcp_write(loop, req, (uv_tcp_t*) handle, bufs, bufcnt, cb);\n     case UV_NAMED_PIPE:\n       return uv_pipe_write(loop, req, (uv_pipe_t*) handle, bufs, bufcnt, cb);\n+    case UV_TTY:\n+      return uv_tty_write(loop, req, (uv_tty_t*) handle, bufs, bufcnt, cb);\n+    default:\n+      assert(0);\n+      uv__set_sys_error(loop, WSAEINVAL);\n+      return -1;\n+  }\n+}\n+\n+\n+int uv_write2(uv_write_t* req, uv_stream_t* handle, uv_buf_t bufs[], int bufcnt,\n+    uv_stream_t* send_handle, uv_write_cb cb) {\n+  uv_loop_t* loop = handle->loop;\n+\n+  switch (handle->type) {\n+    case UV_NAMED_PIPE:\n+      return uv_pipe_write2(loop, req, (uv_pipe_t*) handle, bufs, bufcnt, send_handle, cb);\n     default:\n       assert(0);\n-      uv_set_sys_error(loop, WSAEINVAL);\n+      uv__set_sys_error(loop, WSAEINVAL);\n       return -1;\n   }\n }\n@@ -118,12 +152,12 @@ int uv_shutdown(uv_shutdown_t* req, uv_stream_t* handle, uv_shutdown_cb cb) {\n   uv_loop_t* loop = handle->loop;\n \n   if (!(handle->flags & UV_HANDLE_CONNECTION)) {\n-    uv_set_sys_error(loop, WSAEINVAL);\n+    uv__set_sys_error(loop, WSAEINVAL);\n     return -1;\n   }\n \n   if (handle->flags & UV_HANDLE_SHUTTING) {\n-    uv_set_sys_error(loop, WSAESHUTDOWN);\n+    uv__set_sys_error(loop, WSAESHUTDOWN);\n     return -1;\n   }\n "}, {"sha": "0ff6890bcf79e74341f3ac6dc746f93ae9f9914e", "filename": "src/rt/libuv/src/win/tcp.c", "status": "modified", "additions": 215, "deletions": 115, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftcp.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftcp.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftcp.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -47,20 +47,20 @@ static unsigned int active_tcp_streams = 0;\n \n \n static int uv_tcp_set_socket(uv_loop_t* loop, uv_tcp_t* handle,\n-    SOCKET socket) {\n+    SOCKET socket, int imported) {\n   DWORD yes = 1;\n \n   assert(handle->socket == INVALID_SOCKET);\n \n   /* Set the socket to nonblocking mode */\n   if (ioctlsocket(socket, FIONBIO, &yes) == SOCKET_ERROR) {\n-    uv_set_sys_error(loop, WSAGetLastError());\n+    uv__set_sys_error(loop, WSAGetLastError());\n     return -1;\n   }\n \n   /* Make the socket non-inheritable */\n   if (!SetHandleInformation((HANDLE)socket, HANDLE_FLAG_INHERIT, 0)) {\n-    uv_set_sys_error(loop, GetLastError());\n+    uv__set_sys_error(loop, GetLastError());\n     return -1;\n   }\n \n@@ -70,8 +70,12 @@ static int uv_tcp_set_socket(uv_loop_t* loop, uv_tcp_t* handle,\n                              loop->iocp,\n                              (ULONG_PTR)socket,\n                              0) == NULL) {\n-    uv_set_sys_error(loop, GetLastError());\n-    return -1;\n+    if (imported) {\n+      handle->flags |= UV_HANDLE_EMULATE_IOCP;\n+    } else {\n+      uv__set_sys_error(loop, GetLastError());\n+      return -1;\n+    }\n   }\n \n   if (pSetFileCompletionNotificationModes) {\n@@ -80,7 +84,7 @@ static int uv_tcp_set_socket(uv_loop_t* loop, uv_tcp_t* handle,\n         FILE_SKIP_COMPLETION_PORT_ON_SUCCESS)) {\n       handle->flags |= UV_HANDLE_SYNC_BYPASS_IOCP;\n     } else if (GetLastError() != ERROR_INVALID_FUNCTION) {\n-      uv_set_sys_error(loop, GetLastError());\n+      uv__set_sys_error(loop, GetLastError());\n       return -1;\n     }\n   }\n@@ -99,6 +103,8 @@ int uv_tcp_init(uv_loop_t* loop, uv_tcp_t* handle) {\n   handle->socket = INVALID_SOCKET;\n   handle->type = UV_TCP;\n   handle->reqs_pending = 0;\n+  handle->func_acceptex = NULL;\n+  handle->func_connectex = NULL;\n \n   loop->counters.tcp_init++;\n \n@@ -107,8 +113,10 @@ int uv_tcp_init(uv_loop_t* loop, uv_tcp_t* handle) {\n \n \n void uv_tcp_endgame(uv_loop_t* loop, uv_tcp_t* handle) {\n-  uv_err_t err;\n   int status;\n+  int sys_error;\n+  unsigned int i;\n+  uv_tcp_accept_t* req;\n \n   if (handle->flags & UV_HANDLE_CONNECTION &&\n       handle->flags & UV_HANDLE_SHUTTING &&\n@@ -120,15 +128,17 @@ void uv_tcp_endgame(uv_loop_t* loop, uv_tcp_t* handle) {\n       handle->flags |= UV_HANDLE_SHUT;\n     } else {\n       status = -1;\n-      err = uv_new_sys_error(WSAGetLastError());\n+      sys_error = WSAGetLastError();\n     }\n     if (handle->shutdown_req->cb) {\n       if (status == -1) {\n-        loop->last_error = err;\n+        uv__set_sys_error(loop, sys_error);\n       }\n       handle->shutdown_req->cb(handle->shutdown_req, status);\n     }\n-    handle->reqs_pending--;\n+\n+    DECREASE_PENDING_REQ_COUNT(handle);\n+    return;\n   }\n \n   if (handle->flags & UV_HANDLE_CLOSING &&\n@@ -137,6 +147,20 @@ void uv_tcp_endgame(uv_loop_t* loop, uv_tcp_t* handle) {\n     handle->flags |= UV_HANDLE_CLOSED;\n \n     if (!(handle->flags & UV_HANDLE_CONNECTION) && handle->accept_reqs) {\n+      if (handle->flags & UV_HANDLE_EMULATE_IOCP) {\n+        for (i = 0; i < uv_simultaneous_server_accepts; i++) {\n+          req = &handle->accept_reqs[i];\n+          if (req->wait_handle != INVALID_HANDLE_VALUE) {\n+            UnregisterWait(req->wait_handle);\n+            req->wait_handle = INVALID_HANDLE_VALUE;\n+          }\n+          if (req->event_handle) {\n+            CloseHandle(req->event_handle);\n+            req->event_handle = NULL;\n+          }\n+        }\n+      }\n+\n       free(handle->accept_reqs);\n       handle->accept_reqs = NULL;\n     }\n@@ -152,20 +176,22 @@ void uv_tcp_endgame(uv_loop_t* loop, uv_tcp_t* handle) {\n }\n \n \n-static int uv__bind(uv_loop_t* loop, uv_tcp_t* handle, int domain,\n-    struct sockaddr* addr, int addrsize) {\n+static int uv__bind(uv_tcp_t* handle,\n+                    int domain,\n+                    struct sockaddr* addr,\n+                    int addrsize) {\n   DWORD err;\n   int r;\n   SOCKET sock;\n \n   if (handle->socket == INVALID_SOCKET) {\n     sock = socket(domain, SOCK_STREAM, 0);\n     if (sock == INVALID_SOCKET) {\n-      uv_set_sys_error(loop, WSAGetLastError());\n+      uv__set_sys_error(handle->loop, WSAGetLastError());\n       return -1;\n     }\n \n-    if (uv_tcp_set_socket(loop, handle, sock) == -1) {\n+    if (uv_tcp_set_socket(handle->loop, handle, sock, 0) == -1) {\n       closesocket(sock);\n       return -1;\n     }\n@@ -177,10 +203,10 @@ static int uv__bind(uv_loop_t* loop, uv_tcp_t* handle, int domain,\n     err = WSAGetLastError();\n     if (err == WSAEADDRINUSE) {\n       /* Some errors are not to be reported until connect() or listen() */\n-      handle->bind_error = uv_new_sys_error(err);\n+      handle->bind_error = err;\n       handle->flags |= UV_HANDLE_BIND_ERROR;\n     } else {\n-      uv_set_sys_error(loop, err);\n+      uv__set_sys_error(handle->loop, err);\n       return -1;\n     }\n   }\n@@ -191,63 +217,63 @@ static int uv__bind(uv_loop_t* loop, uv_tcp_t* handle, int domain,\n }\n \n \n-int uv_tcp_bind(uv_tcp_t* handle, struct sockaddr_in addr) {\n-  uv_loop_t* loop = handle->loop;\n-\n-  if (addr.sin_family != AF_INET) {\n-    uv_set_sys_error(loop, WSAEFAULT);\n-    return -1;\n-  }\n-\n-  return uv__bind(loop,\n-                  handle,\n+int uv__tcp_bind(uv_tcp_t* handle, struct sockaddr_in addr) {\n+  return uv__bind(handle,\n                   AF_INET,\n                   (struct sockaddr*)&addr,\n                   sizeof(struct sockaddr_in));\n }\n \n \n-int uv_tcp_bind6(uv_tcp_t* handle, struct sockaddr_in6 addr) {\n-  uv_loop_t* loop = handle->loop;\n-\n-  if (addr.sin6_family != AF_INET6) {\n-    uv_set_sys_error(loop, WSAEFAULT);\n-    return -1;\n-  }\n-\n+int uv__tcp_bind6(uv_tcp_t* handle, struct sockaddr_in6 addr) {\n   if (uv_allow_ipv6) {\n     handle->flags |= UV_HANDLE_IPV6;\n-    return uv__bind(loop,\n-                    handle,\n+    return uv__bind(handle,\n                     AF_INET6,\n                     (struct sockaddr*)&addr,\n                     sizeof(struct sockaddr_in6));\n \n   } else {\n-    uv_set_sys_error(loop, WSAEAFNOSUPPORT);\n+    uv__set_sys_error(handle->loop, WSAEAFNOSUPPORT);\n     return -1;\n   }\n }\n \n \n+static void CALLBACK post_completion(void* context, BOOLEAN timed_out) {\n+  uv_tcp_accept_t* req;\n+  uv_tcp_t* handle;\n+\n+  req = (uv_tcp_accept_t*) context;\n+  assert(req != NULL);\n+  handle = (uv_tcp_t*)req->data;\n+  assert(handle != NULL);\n+  assert(!timed_out);\n+\n+  if (!PostQueuedCompletionStatus(handle->loop->iocp,\n+                                  req->overlapped.InternalHigh,\n+                                  0,\n+                                  &req->overlapped)) {\n+    uv_fatal_error(GetLastError(), \"PostQueuedCompletionStatus\");\n+  }\n+}\n+\n+\n static void uv_tcp_queue_accept(uv_tcp_t* handle, uv_tcp_accept_t* req) {\n   uv_loop_t* loop = handle->loop;\n   BOOL success;\n   DWORD bytes;\n   SOCKET accept_socket;\n   short family;\n-  LPFN_ACCEPTEX pAcceptExFamily;\n \n   assert(handle->flags & UV_HANDLE_LISTENING);\n   assert(req->accept_socket == INVALID_SOCKET);\n \n   /* choose family and extension function */\n-  if ((handle->flags & UV_HANDLE_IPV6) != 0) {\n+  if (handle->flags & UV_HANDLE_IPV6) {\n     family = AF_INET6;\n-    pAcceptExFamily = pAcceptEx6;\n   } else {\n     family = AF_INET;\n-    pAcceptExFamily = pAcceptEx;\n   }\n \n   /* Open a socket for the accepted connection. */\n@@ -261,15 +287,18 @@ static void uv_tcp_queue_accept(uv_tcp_t* handle, uv_tcp_accept_t* req) {\n \n   /* Prepare the overlapped structure. */\n   memset(&(req->overlapped), 0, sizeof(req->overlapped));\n+  if (handle->flags & UV_HANDLE_EMULATE_IOCP) {\n+    req->overlapped.hEvent = (HANDLE) ((DWORD) req->event_handle | 1);\n+  }\n \n-  success = pAcceptExFamily(handle->socket,\n-                          accept_socket,\n-                          (void*)req->accept_buffer,\n-                          0,\n-                          sizeof(struct sockaddr_storage),\n-                          sizeof(struct sockaddr_storage),\n-                          &bytes,\n-                          &req->overlapped);\n+  success = handle->func_acceptex(handle->socket,\n+                                  accept_socket,\n+                                  (void*)req->accept_buffer,\n+                                  0,\n+                                  sizeof(struct sockaddr_storage),\n+                                  sizeof(struct sockaddr_storage),\n+                                  &bytes,\n+                                  &req->overlapped);\n \n   if (UV_SUCCEEDED_WITHOUT_IOCP(success)) {\n     /* Process the req without IOCP. */\n@@ -280,19 +309,34 @@ static void uv_tcp_queue_accept(uv_tcp_t* handle, uv_tcp_accept_t* req) {\n     /* The req will be processed with IOCP. */\n     req->accept_socket = accept_socket;\n     handle->reqs_pending++;\n+    if (handle->flags & UV_HANDLE_EMULATE_IOCP &&\n+        req->wait_handle == INVALID_HANDLE_VALUE &&\n+        !RegisterWaitForSingleObject(&req->wait_handle,\n+          req->overlapped.hEvent, post_completion, (void*) req,\n+          INFINITE, WT_EXECUTEINWAITTHREAD)) {\n+      SET_REQ_ERROR(req, GetLastError());\n+      uv_insert_pending_req(loop, (uv_req_t*)req);\n+      handle->reqs_pending++;\n+      return;\n+    }\n   } else {\n     /* Make this req pending reporting an error. */\n     SET_REQ_ERROR(req, WSAGetLastError());\n     uv_insert_pending_req(loop, (uv_req_t*)req);\n     handle->reqs_pending++;\n     /* Destroy the preallocated client socket. */\n     closesocket(accept_socket);\n+    /* Destroy the event handle */\n+    if (handle->flags & UV_HANDLE_EMULATE_IOCP) {\n+      CloseHandle(req->overlapped.hEvent);\n+      req->event_handle = NULL;\n+    }\n   }\n }\n \n \n static void uv_tcp_queue_read(uv_loop_t* loop, uv_tcp_t* handle) {\n-  uv_req_t* req;\n+  uv_read_t* req;\n   uv_buf_t buf;\n   int result;\n   DWORD bytes, flags;\n@@ -332,15 +376,15 @@ static void uv_tcp_queue_read(uv_loop_t* loop, uv_tcp_t* handle) {\n     handle->flags |= UV_HANDLE_READ_PENDING;\n     req->overlapped.InternalHigh = bytes;\n     handle->reqs_pending++;\n-    uv_insert_pending_req(loop, req);\n+    uv_insert_pending_req(loop, (uv_req_t*)req);\n   } else if (UV_SUCCEEDED_WITH_IOCP(result == 0)) {\n     /* The req will be processed with IOCP. */\n     handle->flags |= UV_HANDLE_READ_PENDING;\n     handle->reqs_pending++;\n   } else {\n     /* Make this req pending reporting an error. */\n     SET_REQ_ERROR(req, WSAGetLastError());\n-    uv_insert_pending_req(loop, req);\n+    uv_insert_pending_req(loop, (uv_req_t*)req);\n     handle->reqs_pending++;\n   }\n }\n@@ -354,23 +398,30 @@ int uv_tcp_listen(uv_tcp_t* handle, int backlog, uv_connection_cb cb) {\n   assert(backlog > 0);\n \n   if (handle->flags & UV_HANDLE_BIND_ERROR) {\n-    loop->last_error = handle->bind_error;\n+    uv__set_sys_error(loop, handle->bind_error);\n     return -1;\n   }\n \n   if (handle->flags & UV_HANDLE_LISTENING ||\n       handle->flags & UV_HANDLE_READING) {\n     /* Already listening. */\n-    uv_set_sys_error(loop, WSAEALREADY);\n+    uv__set_sys_error(loop, WSAEALREADY);\n     return -1;\n   }\n \n   if (!(handle->flags & UV_HANDLE_BOUND) &&\n       uv_tcp_bind(handle, uv_addr_ip4_any_) < 0)\n     return -1;\n \n+  if (!handle->func_acceptex) {\n+    if(!uv_get_acceptex_function(handle->socket, &handle->func_acceptex)) {\n+      uv__set_sys_error(loop, WSAEAFNOSUPPORT);\n+      return -1;\n+    }\n+  }\n+\n   if (listen(handle->socket, backlog) == SOCKET_ERROR) {\n-    uv_set_sys_error(loop, WSAGetLastError());\n+    uv__set_sys_error(loop, WSAGetLastError());\n     return -1;\n   }\n \n@@ -390,6 +441,17 @@ int uv_tcp_listen(uv_tcp_t* handle, int backlog, uv_connection_cb cb) {\n     req->type = UV_ACCEPT;\n     req->accept_socket = INVALID_SOCKET;\n     req->data = handle;\n+\n+    req->wait_handle = INVALID_HANDLE_VALUE;\n+    if (handle->flags & UV_HANDLE_EMULATE_IOCP) {\n+      req->event_handle = CreateEvent(NULL, 0, 0, NULL);\n+      if (!req->event_handle) {\n+        uv_fatal_error(GetLastError(), \"CreateEvent\");\n+      }\n+    } else {\n+      req->event_handle = NULL;\n+    }\n+\n     uv_tcp_queue_accept(handle, req);\n   }\n \n@@ -405,16 +467,16 @@ int uv_tcp_accept(uv_tcp_t* server, uv_tcp_t* client) {\n \n   if (!req) {\n     /* No valid connections found, so we error out. */\n-    uv_set_sys_error(loop, WSAEWOULDBLOCK);\n+    uv__set_sys_error(loop, WSAEWOULDBLOCK);\n     return -1;\n   }\n \n   if (req->accept_socket == INVALID_SOCKET) {\n-    uv_set_sys_error(loop, WSAENOTCONN);\n+    uv__set_sys_error(loop, WSAENOTCONN);\n     return -1;\n   }\n \n-  if (uv_tcp_set_socket(client->loop, client, req->accept_socket) == -1) {\n+  if (uv_tcp_set_socket(client->loop, client, req->accept_socket, 0) == -1) {\n     closesocket(req->accept_socket);\n     rv = -1;\n   } else {\n@@ -443,17 +505,17 @@ int uv_tcp_read_start(uv_tcp_t* handle, uv_alloc_cb alloc_cb,\n   uv_loop_t* loop = handle->loop;\n \n   if (!(handle->flags & UV_HANDLE_CONNECTION)) {\n-    uv_set_sys_error(loop, WSAEINVAL);\n+    uv__set_sys_error(loop, WSAEINVAL);\n     return -1;\n   }\n \n   if (handle->flags & UV_HANDLE_READING) {\n-    uv_set_sys_error(loop, WSAEALREADY);\n+    uv__set_sys_error(loop, WSAEALREADY);\n     return -1;\n   }\n \n   if (handle->flags & UV_HANDLE_EOF) {\n-    uv_set_sys_error(loop, WSAESHUTDOWN);\n+    uv__set_sys_error(loop, WSAESHUTDOWN);\n     return -1;\n   }\n \n@@ -470,40 +532,44 @@ int uv_tcp_read_start(uv_tcp_t* handle, uv_alloc_cb alloc_cb,\n }\n \n \n-int uv_tcp_connect(uv_connect_t* req, uv_tcp_t* handle,\n-    struct sockaddr_in address, uv_connect_cb cb) {\n+int uv__tcp_connect(uv_connect_t* req,\n+                    uv_tcp_t* handle,\n+                    struct sockaddr_in address,\n+                    uv_connect_cb cb) {\n   uv_loop_t* loop = handle->loop;\n   int addrsize = sizeof(struct sockaddr_in);\n   BOOL success;\n   DWORD bytes;\n \n   if (handle->flags & UV_HANDLE_BIND_ERROR) {\n-    loop->last_error = handle->bind_error;\n-    return -1;\n-  }\n-\n-  if (address.sin_family != AF_INET) {\n-    uv_set_sys_error(loop, WSAEFAULT);\n+    uv__set_sys_error(loop, handle->bind_error);\n     return -1;\n   }\n \n   if (!(handle->flags & UV_HANDLE_BOUND) &&\n       uv_tcp_bind(handle, uv_addr_ip4_any_) < 0)\n     return -1;\n \n+  if (!handle->func_connectex) {\n+    if(!uv_get_connectex_function(handle->socket, &handle->func_connectex)) {\n+      uv__set_sys_error(loop, WSAEAFNOSUPPORT);\n+      return -1;\n+    }\n+  }\n+\n   uv_req_init(loop, (uv_req_t*) req);\n   req->type = UV_CONNECT;\n   req->handle = (uv_stream_t*) handle;\n   req->cb = cb;\n   memset(&req->overlapped, 0, sizeof(req->overlapped));\n \n-  success = pConnectEx(handle->socket,\n-                       (struct sockaddr*) &address,\n-                       addrsize,\n-                       NULL,\n-                       0,\n-                       &bytes,\n-                       &req->overlapped);\n+  success = handle->func_connectex(handle->socket,\n+                                   (struct sockaddr*) &address,\n+                                   addrsize,\n+                                   NULL,\n+                                   0,\n+                                   &bytes,\n+                                   &req->overlapped);\n \n   if (UV_SUCCEEDED_WITHOUT_IOCP(success)) {\n     /* Process the req without IOCP. */\n@@ -513,61 +579,65 @@ int uv_tcp_connect(uv_connect_t* req, uv_tcp_t* handle,\n     /* The req will be processed with IOCP. */\n     handle->reqs_pending++;\n   } else {\n-    uv_set_sys_error(loop, WSAGetLastError());\n+    uv__set_sys_error(loop, WSAGetLastError());\n     return -1;\n   }\n \n   return 0;\n }\n \n \n-int uv_tcp_connect6(uv_connect_t* req, uv_tcp_t* handle,\n-    struct sockaddr_in6 address, uv_connect_cb cb) {\n+int uv__tcp_connect6(uv_connect_t* req,\n+                     uv_tcp_t* handle,\n+                     struct sockaddr_in6 address,\n+                     uv_connect_cb cb) {\n   uv_loop_t* loop = handle->loop;\n   int addrsize = sizeof(struct sockaddr_in6);\n   BOOL success;\n   DWORD bytes;\n \n   if (!uv_allow_ipv6) {\n-    uv_new_sys_error(WSAEAFNOSUPPORT);\n+    uv__set_sys_error(loop, WSAEAFNOSUPPORT);\n     return -1;\n   }\n \n   if (handle->flags & UV_HANDLE_BIND_ERROR) {\n-    loop->last_error = handle->bind_error;\n-    return -1;\n-  }\n-\n-  if (address.sin6_family != AF_INET6) {\n-    uv_set_sys_error(loop, WSAEFAULT);\n+    uv__set_sys_error(loop, handle->bind_error);\n     return -1;\n   }\n \n   if (!(handle->flags & UV_HANDLE_BOUND) &&\n       uv_tcp_bind6(handle, uv_addr_ip6_any_) < 0)\n     return -1;\n \n+  if (!handle->func_connectex) {\n+    if(!uv_get_connectex_function(handle->socket, &handle->func_connectex)) {\n+      uv__set_sys_error(loop, WSAEAFNOSUPPORT);\n+      return -1;\n+    }\n+  }\n+\n   uv_req_init(loop, (uv_req_t*) req);\n   req->type = UV_CONNECT;\n   req->handle = (uv_stream_t*) handle;\n   req->cb = cb;\n   memset(&req->overlapped, 0, sizeof(req->overlapped));\n \n-  success = pConnectEx6(handle->socket,\n-                       (struct sockaddr*) &address,\n-                       addrsize,\n-                       NULL,\n-                       0,\n-                       &bytes,\n-                       &req->overlapped);\n+  success = handle->func_connectex(handle->socket,\n+                                   (struct sockaddr*) &address,\n+                                   addrsize,\n+                                   NULL,\n+                                   0,\n+                                   &bytes,\n+                                   &req->overlapped);\n \n   if (UV_SUCCEEDED_WITHOUT_IOCP(success)) {\n     handle->reqs_pending++;\n     uv_insert_pending_req(loop, (uv_req_t*)req);\n   } else if (UV_SUCCEEDED_WITH_IOCP(success)) {\n     handle->reqs_pending++;\n   } else {\n-    uv_set_sys_error(loop, WSAGetLastError());\n+    uv__set_sys_error(loop, WSAGetLastError());\n     return -1;\n   }\n \n@@ -581,18 +651,18 @@ int uv_tcp_getsockname(uv_tcp_t* handle, struct sockaddr* name,\n   int result;\n \n   if (!(handle->flags & UV_HANDLE_BOUND)) {\n-    uv_set_sys_error(loop, WSAEINVAL);\n+    uv__set_sys_error(loop, WSAEINVAL);\n     return -1;\n   }\n \n   if (handle->flags & UV_HANDLE_BIND_ERROR) {\n-    loop->last_error = handle->bind_error;\n+    uv__set_sys_error(loop, handle->bind_error);\n     return -1;\n   }\n \n   result = getsockname(handle->socket, name, namelen);\n   if (result != 0) {\n-    uv_set_sys_error(loop, WSAGetLastError());\n+    uv__set_sys_error(loop, WSAGetLastError());\n     return -1;\n   }\n \n@@ -606,18 +676,18 @@ int uv_tcp_getpeername(uv_tcp_t* handle, struct sockaddr* name,\n   int result;\n \n   if (!(handle->flags & UV_HANDLE_BOUND)) {\n-    uv_set_sys_error(loop, WSAEINVAL);\n+    uv__set_sys_error(loop, WSAEINVAL);\n     return -1;\n   }\n \n   if (handle->flags & UV_HANDLE_BIND_ERROR) {\n-    loop->last_error = handle->bind_error;\n+    uv__set_sys_error(loop, handle->bind_error);\n     return -1;\n   }\n \n   result = getpeername(handle->socket, name, namelen);\n   if (result != 0) {\n-    uv_set_sys_error(loop, WSAGetLastError());\n+    uv__set_sys_error(loop, WSAGetLastError());\n     return -1;\n   }\n \n@@ -631,12 +701,12 @@ int uv_tcp_write(uv_loop_t* loop, uv_write_t* req, uv_tcp_t* handle,\n   DWORD bytes;\n \n   if (!(handle->flags & UV_HANDLE_CONNECTION)) {\n-    uv_set_sys_error(loop, WSAEINVAL);\n+    uv__set_sys_error(loop, WSAEINVAL);\n     return -1;\n   }\n \n   if (handle->flags & UV_HANDLE_SHUTTING) {\n-    uv_set_sys_error(loop, WSAESHUTDOWN);\n+    uv__set_sys_error(loop, WSAESHUTDOWN);\n     return -1;\n   }\n \n@@ -668,7 +738,7 @@ int uv_tcp_write(uv_loop_t* loop, uv_write_t* req, uv_tcp_t* handle,\n     handle->write_queue_size += req->queued_bytes;\n   } else {\n     /* Send failed due to an error. */\n-    uv_set_sys_error(loop, WSAGetLastError());\n+    uv__set_sys_error(loop, WSAGetLastError());\n     return -1;\n   }\n \n@@ -689,7 +759,7 @@ void uv_process_tcp_read_req(uv_loop_t* loop, uv_tcp_t* handle,\n     /* An error occurred doing the read. */\n     if ((handle->flags & UV_HANDLE_READING)) {\n       handle->flags &= ~UV_HANDLE_READING;\n-      loop->last_error = GET_REQ_UV_SOCK_ERROR(req);\n+      uv__set_sys_error(loop, GET_REQ_SOCK_ERROR(req));\n       buf = (handle->flags & UV_HANDLE_ZERO_READ) ?\n             uv_buf_init(NULL, 0) : handle->read_buffer;\n       handle->read_cb((uv_stream_t*)handle, -1, buf);\n@@ -710,8 +780,7 @@ void uv_process_tcp_read_req(uv_loop_t* loop, uv_tcp_t* handle,\n         /* Connection closed */\n         handle->flags &= ~UV_HANDLE_READING;\n         handle->flags |= UV_HANDLE_EOF;\n-        loop->last_error.code = UV_EOF;\n-        loop->last_error.sys_errno_ = ERROR_SUCCESS;\n+        uv__set_error(loop, UV_EOF, ERROR_SUCCESS);\n         buf.base = 0;\n         buf.len = 0;\n         handle->read_cb((uv_stream_t*)handle, -1, handle->read_buffer);\n@@ -742,20 +811,19 @@ void uv_process_tcp_read_req(uv_loop_t* loop, uv_tcp_t* handle,\n           /* Connection closed */\n           handle->flags &= ~UV_HANDLE_READING;\n           handle->flags |= UV_HANDLE_EOF;\n-          loop->last_error.code = UV_EOF;\n-          loop->last_error.sys_errno_ = ERROR_SUCCESS;\n+          uv__set_error(loop, UV_EOF, ERROR_SUCCESS);\n           handle->read_cb((uv_stream_t*)handle, -1, buf);\n           break;\n         }\n       } else {\n         err = WSAGetLastError();\n         if (err == WSAEWOULDBLOCK) {\n           /* Read buffer was completely empty, report a 0-byte read. */\n-          uv_set_sys_error(loop, WSAEWOULDBLOCK);\n+          uv__set_sys_error(loop, WSAEWOULDBLOCK);\n           handle->read_cb((uv_stream_t*)handle, 0, buf);\n         } else {\n           /* Ouch! serious error. */\n-          uv_set_sys_error(loop, err);\n+          uv__set_sys_error(loop, err);\n           handle->flags &= ~UV_HANDLE_READING;\n           handle->read_cb((uv_stream_t*)handle, -1, buf);\n         }\n@@ -779,11 +847,12 @@ void uv_process_tcp_write_req(uv_loop_t* loop, uv_tcp_t* handle,\n     uv_write_t* req) {\n   assert(handle->type == UV_TCP);\n \n+  assert(handle->write_queue_size >= req->queued_bytes);\n   handle->write_queue_size -= req->queued_bytes;\n \n   if (req->cb) {\n-    loop->last_error = GET_REQ_UV_SOCK_ERROR(req);\n-    ((uv_write_cb)req->cb)(req, loop->last_error.code == UV_OK ? 0 : -1);\n+    uv__set_sys_error(loop, GET_REQ_SOCK_ERROR(req));\n+    ((uv_write_cb)req->cb)(req, loop->last_err.code == UV_OK ? 0 : -1);\n   }\n \n   handle->write_reqs_pending--;\n@@ -810,7 +879,7 @@ void uv_process_tcp_accept_req(uv_loop_t* loop, uv_tcp_t* handle,\n     if (handle->flags & UV_HANDLE_LISTENING) {\n       handle->flags &= ~UV_HANDLE_LISTENING;\n       if (handle->connection_cb) {\n-        loop->last_error = GET_REQ_UV_SOCK_ERROR(req);\n+        uv__set_sys_error(loop, GET_REQ_SOCK_ERROR(req));\n         handle->connection_cb((uv_stream_t*)handle, -1);\n       }\n     }\n@@ -857,14 +926,45 @@ void uv_process_tcp_connect_req(uv_loop_t* loop, uv_tcp_t* handle,\n         active_tcp_streams++;\n         ((uv_connect_cb)req->cb)(req, 0);\n       } else {\n-        uv_set_sys_error(loop, WSAGetLastError());\n+        uv__set_sys_error(loop, WSAGetLastError());\n         ((uv_connect_cb)req->cb)(req, -1);\n       }\n     } else {\n-      loop->last_error = GET_REQ_UV_SOCK_ERROR(req);\n+      uv__set_sys_error(loop, GET_REQ_SOCK_ERROR(req));\n       ((uv_connect_cb)req->cb)(req, -1);\n     }\n   }\n \n   DECREASE_PENDING_REQ_COUNT(handle);\n }\n+\n+\n+int uv_tcp_import(uv_tcp_t* tcp, WSAPROTOCOL_INFOW* socket_protocol_info) {\n+  SOCKET socket = WSASocketW(AF_INET,\n+                             SOCK_STREAM,\n+                             IPPROTO_IP,\n+                             socket_protocol_info,\n+                             0,\n+                             WSA_FLAG_OVERLAPPED);\n+\n+  if (socket == INVALID_SOCKET) {\n+    uv__set_sys_error(tcp->loop, WSAGetLastError());\n+    return -1;\n+  }\n+\n+  tcp->flags |= UV_HANDLE_BOUND;\n+\n+  return uv_tcp_set_socket(tcp->loop, tcp, socket, 1);\n+}\n+\n+\n+int uv_tcp_nodelay(uv_tcp_t* handle, int enable) {\n+  uv__set_artificial_error(handle->loop, UV_ENOSYS);\n+  return -1;\n+}\n+\n+\n+int uv_tcp_keepalive(uv_tcp_t* handle, int enable, unsigned int delay) {\n+  uv__set_artificial_error(handle->loop, UV_ENOSYS);\n+  return -1;\n+}"}, {"sha": "4fb20d34bc46c7150a71466191988e0dd6bd97e5", "filename": "src/rt/libuv/src/win/threadpool.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fthreadpool.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fthreadpool.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fthreadpool.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -57,7 +57,7 @@ int uv_queue_work(uv_loop_t* loop, uv_work_t* req, uv_work_cb work_cb,\n   uv_work_req_init(loop, req, work_cb, after_work_cb);\n \n   if (!QueueUserWorkItem(&uv_work_thread_proc, req, WT_EXECUTELONGFUNCTION)) {\n-    uv_set_sys_error(loop, GetLastError());\n+    uv__set_sys_error(loop, GetLastError());\n     return -1;\n   }\n "}, {"sha": "58f2eef05f0d7293ccf950e45246fab44c7b5922", "filename": "src/rt/libuv/src/win/timer.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftimer.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftimer.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftimer.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -77,12 +77,12 @@ uint64_t uv_hrtime(void) {\n \n   /* If the performance frequency is zero, there's no support. */\n   if (!uv_hrtime_frequency_) {\n-    /* uv_set_sys_error(loop, ERROR_NOT_SUPPORTED); */\n+    /* uv__set_sys_error(loop, ERROR_NOT_SUPPORTED); */\n     return 0;\n   }\n \n   if (!QueryPerformanceCounter(&counter)) {\n-    /* uv_set_sys_error(loop, GetLastError()); */\n+    /* uv__set_sys_error(loop, GetLastError()); */\n     return 0;\n   }\n \n@@ -181,7 +181,7 @@ int uv_timer_again(uv_timer_t* handle) {\n \n   /* If timer_cb is NULL that means that the timer was never started. */\n   if (!handle->timer_cb) {\n-    uv_set_sys_error(loop, ERROR_INVALID_DATA);\n+    uv__set_sys_error(loop, ERROR_INVALID_DATA);\n     return -1;\n   }\n "}, {"sha": "a72851276a6184b7af5d741a6b926bd476d19165", "filename": "src/rt/libuv/src/win/tty.c", "status": "modified", "additions": 1712, "deletions": 15, "changes": 1727, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftty.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftty.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftty.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -19,43 +19,1740 @@\n  * IN THE SOFTWARE.\n  */\n \n+#include <assert.h>\n+#include <io.h>\n+#include <string.h>\n+#include <stdint.h>\n+\n #include \"uv.h\"\n+#include \"../uv-common.h\"\n #include \"internal.h\"\n \n-#include <assert.h>\n \n+#define UNICODE_REPLACEMENT_CHARACTER (0xfffd)\n+\n+#define ANSI_NORMAL           0x00\n+#define ANSI_ESCAPE_SEEN      0x02\n+#define ANSI_CSI              0x04\n+#define ANSI_ST_CONTROL       0x08\n+#define ANSI_IGNORE           0x10\n+#define ANSI_IN_ARG           0x20\n+#define ANSI_IN_STRING        0x40\n+#define ANSI_BACKSLASH_SEEN   0x80\n+\n+\n+static void uv_tty_update_virtual_window(CONSOLE_SCREEN_BUFFER_INFO* info);\n+\n+\n+/* Null uv_buf_t */\n+static const uv_buf_t uv_null_buf_ = { 0, NULL };\n+\n+\n+/*\n+ * The console virtual window.\n+ *\n+ * Normally cursor movement in windows is relative to the console screen buffer,\n+ * e.g. the application is allowed to overwrite the 'history'. This is very\n+ * inconvenient, it makes absolute cursor movement pretty useless. There is\n+ * also the concept of 'client rect' which is defined by the actual size of\n+ * the console window and the scroll position of the screen buffer, but it's\n+ * very volatile because it changes when the user scrolls.\n+ *\n+ * To make cursor movement behave sensibly we define a virtual window to which\n+ * cursor movement is confined. The virtual window is always as wide as the\n+ * console screen buffer, but it's height is defined by the size of the\n+ * console window. The top of the virtual window aligns with the position\n+ * of the caret when the first stdout/err handle is created, unless that would\n+ * mean that it would extend beyond the bottom of the screen buffer -  in that\n+ * that case it's located as far down as possible.\n+ *\n+ * When the user writes a long text or many newlines, such that the output\n+ * reaches beyond the bottom of the virtual window, the virtual window is\n+ * shifted downwards, but not resized.\n+ *\n+ * Since all tty i/o happens on the same console, this window is shared\n+ * between all stdout/stderr handles.\n+ */\n+\n+static int uv_tty_virtual_offset = -1;\n+static int uv_tty_virtual_height = -1;\n+static int uv_tty_virtual_width = -1;\n+\n+static CRITICAL_SECTION uv_tty_output_lock;\n+\n+\n+void uv_console_init() {\n+  InitializeCriticalSection(&uv_tty_output_lock);\n+}\n+\n+\n+int uv_tty_init(uv_loop_t* loop, uv_tty_t* tty, uv_file fd, int readable) {\n+  HANDLE win_handle;\n+  CONSOLE_SCREEN_BUFFER_INFO info;\n+\n+  win_handle = (HANDLE) _get_osfhandle(fd);\n+  if (win_handle == INVALID_HANDLE_VALUE) {\n+    uv__set_sys_error(loop, ERROR_INVALID_HANDLE);\n+    return -1;\n+  }\n+\n+  if (!GetConsoleMode(win_handle, &tty->original_console_mode)) {\n+    uv__set_sys_error(loop, GetLastError());\n+    return -1;\n+  }\n+\n+  /* Initialize virtual window size; if it fails, assume that this is stdin. */\n+  if (GetConsoleScreenBufferInfo(win_handle, &info)) {\n+    EnterCriticalSection(&uv_tty_output_lock);\n+    uv_tty_update_virtual_window(&info);\n+    LeaveCriticalSection(&uv_tty_output_lock);\n+  }\n+\n+  uv_stream_init(loop, (uv_stream_t*) tty);\n+  uv_connection_init((uv_stream_t*) tty);\n+\n+  tty->type = UV_TTY;\n+  tty->handle = win_handle;\n+  tty->read_line_handle = NULL;\n+  tty->read_line_buffer = uv_null_buf_;\n+  tty->read_raw_wait = NULL;\n+  tty->reqs_pending = 0;\n+  tty->flags |= UV_HANDLE_BOUND;\n+\n+  /* Init keycode-to-vt100 mapper state. */\n+  tty->last_key_len = 0;\n+  tty->last_key_offset = 0;\n+  tty->last_utf16_high_surrogate = 0;\n+  memset(&tty->last_input_record, 0, sizeof tty->last_input_record);\n+\n+  /* Init utf8-to-utf16 conversion state. */\n+  tty->utf8_bytes_left = 0;\n+  tty->utf8_codepoint = 0;\n+\n+  /* Initialize eol conversion state */\n+  tty->previous_eol = 0;\n \n-int uv_tty_init(uv_loop_t* loop, uv_tty_t* tty, uv_file fd) {\n-  assert(0 && \"implement me\");\n-  return -1;\n+  /* Init ANSI parser state. */\n+  tty->ansi_parser_state = ANSI_NORMAL;\n+\n+  return 0;\n }\n \n \n int uv_tty_set_mode(uv_tty_t* tty, int mode) {\n-  assert(0 && \"implement me\");\n-  return -1;\n+  DWORD flags = 0;\n+  unsigned char was_reading;\n+  uv_alloc_cb alloc_cb;\n+  uv_read_cb read_cb;\n+\n+  if (!!mode == !!(tty->flags & UV_HANDLE_TTY_RAW)) {\n+    return 0;\n+  }\n+\n+  if (tty->original_console_mode & ENABLE_QUICK_EDIT_MODE) {\n+    flags = ENABLE_QUICK_EDIT_MODE | ENABLE_EXTENDED_FLAGS;\n+  }\n+\n+  if (mode) {\n+    /* Raw input */\n+    flags |= ENABLE_WINDOW_INPUT;\n+  } else {\n+    /* Line-buffered mode. */\n+    flags |= ENABLE_ECHO_INPUT | ENABLE_INSERT_MODE | ENABLE_LINE_INPUT |\n+        ENABLE_EXTENDED_FLAGS | ENABLE_PROCESSED_INPUT;\n+  }\n+\n+  if (!SetConsoleMode(tty->handle, flags)) {\n+    uv__set_sys_error(tty->loop, GetLastError());\n+    return -1;\n+  }\n+\n+  /* If currently reading, stop, and restart reading. */\n+  if (tty->flags & UV_HANDLE_READING) {\n+    was_reading = 1;\n+    alloc_cb = tty->alloc_cb;\n+    read_cb = tty->read_cb;\n+\n+    if (was_reading && uv_tty_read_stop(tty) != 0) {\n+      return -1;\n+    }\n+  } else {\n+    was_reading = 0;\n+  }\n+\n+  /* Update flag. */\n+  tty->flags &= ~UV_HANDLE_TTY_RAW;\n+  tty->flags |= mode ? UV_HANDLE_TTY_RAW : 0;\n+\n+  /* If we just stopped reading, restart. */\n+  if (was_reading && uv_tty_read_start(tty, alloc_cb, read_cb) != 0) {\n+    return -1;\n+  }\n+\n+  return 0;\n }\n \n \n int uv_is_tty(uv_file file) {\n+  DWORD result;\n+  return GetConsoleMode((HANDLE) _get_osfhandle(file), &result) != 0;\n }\n \n \n int uv_tty_get_winsize(uv_tty_t* tty, int* width, int* height) {\n-  assert(0 && \"implement me\");\n-  return -1;\n+  CONSOLE_SCREEN_BUFFER_INFO info;\n+\n+  if (!GetConsoleScreenBufferInfo(tty->handle, &info)) {\n+    uv__set_sys_error(tty->loop, GetLastError());\n+    return -1;\n+  }\n+\n+  EnterCriticalSection(&uv_tty_output_lock);\n+  uv_tty_update_virtual_window(&info);\n+  LeaveCriticalSection(&uv_tty_output_lock);\n+\n+  *width = uv_tty_virtual_width;\n+  *height = uv_tty_virtual_height;\n+\n+  return 0;\n }\n \n \n-uv_handle_type uv_guess_handle(uv_file file) {\n-  DWORD result;\n-  int r = GetConsoleMode((HANDLE)_get_osfhandle(file), &result);\n+static void CALLBACK uv_tty_post_raw_read(void* data, BOOLEAN didTimeout) {\n+  uv_loop_t* loop;\n+  uv_tty_t* handle;\n+  uv_req_t* req;\n+\n+  assert(data);\n+  assert(!didTimeout);\n+\n+  req = (uv_req_t*) data;\n+  handle = (uv_tty_t*) req->data;\n+  loop = handle->loop;\n+\n+  UnregisterWait(handle->read_raw_wait);\n+  handle->read_raw_wait = NULL;\n+\n+  SET_REQ_SUCCESS(req);\n+  POST_COMPLETION_FOR_REQ(loop, req);\n+}\n+\n+\n+static void uv_tty_queue_read_raw(uv_loop_t* loop, uv_tty_t* handle) {\n+  uv_read_t* req;\n+  BOOL r;\n+\n+  assert(handle->flags & UV_HANDLE_READING);\n+  assert(!(handle->flags & UV_HANDLE_READ_PENDING));\n+\n+  assert(handle->handle && handle->handle != INVALID_HANDLE_VALUE);\n+\n+  handle->read_line_buffer = uv_null_buf_;\n+\n+  req = &handle->read_req;\n+  memset(&req->overlapped, 0, sizeof(req->overlapped));\n+\n+  r = RegisterWaitForSingleObject(&handle->read_raw_wait,\n+                                  handle->handle,\n+                                  uv_tty_post_raw_read,\n+                                  (void*) req,\n+                                  INFINITE,\n+                                  WT_EXECUTEINWAITTHREAD | WT_EXECUTEONLYONCE);\n+  if (!r) {\n+    handle->read_raw_wait = NULL;\n+    SET_REQ_ERROR(req, GetLastError());\n+    uv_insert_pending_req(loop, (uv_req_t*)req);\n+  }\n+\n+  handle->flags |= UV_HANDLE_READ_PENDING;\n+  handle->reqs_pending++;\n+}\n+\n+\n+static DWORD CALLBACK uv_tty_line_read_thread(void* data) {\n+  uv_loop_t* loop;\n+  uv_tty_t* handle;\n+  uv_req_t* req;\n+  DWORD bytes, read_bytes;\n+\n+  assert(data);\n+\n+  req = (uv_req_t*) data;\n+  handle = (uv_tty_t*) req->data;\n+  loop = handle->loop;\n+\n+  assert(handle->read_line_buffer.base != NULL);\n+  assert(handle->read_line_buffer.len > 0);\n+\n+  /* ReadConsole can't handle big buffers. */\n+  if (handle->read_line_buffer.len < 8192) {\n+    bytes = handle->read_line_buffer.len;\n+  } else {\n+    bytes = 8192;\n+  }\n \n-  if (r) {\n-    return UV_TTY;\n+  /* Todo: Unicode */\n+  if (ReadConsoleA(handle->read_line_handle,\n+                   (void*) handle->read_line_buffer.base,\n+                   bytes,\n+                   &read_bytes,\n+                   NULL)) {\n+    SET_REQ_SUCCESS(req);\n+    req->overlapped.InternalHigh = read_bytes;\n+  } else {\n+    SET_REQ_ERROR(req, GetLastError());\n   }\n \n-  assert(0 && \"implement me\");\n+  POST_COMPLETION_FOR_REQ(loop, req);\n+  return 0;\n+}\n+\n+\n+static void uv_tty_queue_read_line(uv_loop_t* loop, uv_tty_t* handle) {\n+  uv_read_t* req;\n+  BOOL r;\n+\n+  assert(handle->flags & UV_HANDLE_READING);\n+  assert(!(handle->flags & UV_HANDLE_READ_PENDING));\n+  assert(handle->handle && handle->handle != INVALID_HANDLE_VALUE);\n+\n+  req = &handle->read_req;\n+  memset(&req->overlapped, 0, sizeof(req->overlapped));\n+\n+  handle->read_line_buffer = handle->alloc_cb((uv_handle_t*) handle, 8192);\n+  assert(handle->read_line_buffer.base != NULL);\n+  assert(handle->read_line_buffer.len > 0);\n+\n+  /* Duplicate the console handle, so if we want to cancel the read, we can */\n+  /* just close this handle duplicate. */\n+  if (handle->read_line_handle == NULL) {\n+    HANDLE this_process = GetCurrentProcess();\n+    r = DuplicateHandle(this_process,\n+                        handle->handle,\n+                        this_process,\n+                        &handle->read_line_handle,\n+                        0,\n+                        0,\n+                        DUPLICATE_SAME_ACCESS);\n+    if (!r) {\n+      handle->read_line_handle = NULL;\n+      SET_REQ_ERROR(req, GetLastError());\n+      uv_insert_pending_req(loop, (uv_req_t*)req);\n+      goto out;\n+    }\n+  }\n+\n+  r = QueueUserWorkItem(uv_tty_line_read_thread,\n+                        (void*) req,\n+                        WT_EXECUTELONGFUNCTION);\n+  if (!r) {\n+    SET_REQ_ERROR(req, GetLastError());\n+    uv_insert_pending_req(loop, (uv_req_t*)req);\n+  }\n+\n+ out:\n+  handle->flags |= UV_HANDLE_READ_PENDING;\n+  handle->reqs_pending++;\n+}\n+\n+\n+static void uv_tty_queue_read(uv_loop_t* loop, uv_tty_t* handle) {\n+  if (handle->flags & UV_HANDLE_TTY_RAW) {\n+    uv_tty_queue_read_raw(loop, handle);\n+  } else {\n+    uv_tty_queue_read_line(loop, handle);\n+  }\n+}\n+\n+\n+static const char* get_vt100_fn_key(DWORD code, char shift, char ctrl,\n+    size_t* len) {\n+#define VK_CASE(vk, normal_str, shift_str, ctrl_str, shift_ctrl_str)          \\\n+    case (vk):                                                                \\\n+      if (shift && ctrl) {                                                    \\\n+        *len = sizeof shift_ctrl_str;                                         \\\n+        return \"\\033\" shift_ctrl_str;                                         \\\n+      } else if (shift) {                                                     \\\n+        *len = sizeof shift_str ;                                             \\\n+        return \"\\033\" shift_str;                                              \\\n+      } else if (ctrl) {                                                      \\\n+        *len = sizeof ctrl_str;                                               \\\n+        return \"\\033\" ctrl_str;                                               \\\n+      } else {                                                                \\\n+        *len = sizeof normal_str;                                             \\\n+        return \"\\033\" normal_str;                                             \\\n+      }\n+\n+  switch (code) {\n+    /* These mappings are the same as Cygwin's. Unmodified and alt-modified */\n+    /* keypad keys comply with linux console, modifiers comply with xterm */\n+    /* modifier usage. F1..f12 and shift-f1..f10 comply with linux console, */\n+    /* f6..f12 with and without modifiers comply with rxvt. */\n+    VK_CASE(VK_INSERT,  \"[2~\",  \"[2;2~\", \"[2;5~\", \"[2;6~\")\n+    VK_CASE(VK_END,     \"[4~\",  \"[4;2~\", \"[4;5~\", \"[4;6~\")\n+    VK_CASE(VK_DOWN,    \"[B\",   \"[1;2B\", \"[1;5B\", \"[1;6B\")\n+    VK_CASE(VK_NEXT,    \"[6~\",  \"[6;2~\", \"[6;5~\", \"[6;6~\")\n+    VK_CASE(VK_LEFT,    \"[D\",   \"[1;2D\", \"[1;5D\", \"[1;6D\")\n+    VK_CASE(VK_CLEAR,   \"[G\",   \"[1;2G\", \"[1;5G\", \"[1;6G\")\n+    VK_CASE(VK_RIGHT,   \"[C\",   \"[1;2C\", \"[1;5C\", \"[1;6C\")\n+    VK_CASE(VK_UP,      \"[A\",   \"[1;2A\", \"[1;5A\", \"[1;6A\")\n+    VK_CASE(VK_HOME,    \"[1~\",  \"[1;2~\", \"[1;5~\", \"[1;6~\")\n+    VK_CASE(VK_PRIOR,   \"[5~\",  \"[5;2~\", \"[5;5~\", \"[5;6~\")\n+    VK_CASE(VK_DELETE,  \"[3~\",  \"[3;2~\", \"[3;5~\", \"[3;6~\")\n+    VK_CASE(VK_NUMPAD0, \"[2~\",  \"[2;2~\", \"[2;5~\", \"[2;6~\")\n+    VK_CASE(VK_NUMPAD1, \"[4~\",  \"[4;2~\", \"[4;5~\", \"[4;6~\")\n+    VK_CASE(VK_NUMPAD2, \"[B\",   \"[1;2B\", \"[1;5B\", \"[1;6B\")\n+    VK_CASE(VK_NUMPAD3, \"[6~\",  \"[6;2~\", \"[6;5~\", \"[6;6~\")\n+    VK_CASE(VK_NUMPAD4, \"[D\",   \"[1;2D\", \"[1;5D\", \"[1;6D\")\n+    VK_CASE(VK_NUMPAD5, \"[G\",   \"[1;2G\", \"[1;5G\", \"[1;6G\")\n+    VK_CASE(VK_NUMPAD6, \"[C\",   \"[1;2C\", \"[1;5C\", \"[1;6C\")\n+    VK_CASE(VK_NUMPAD7, \"[A\",   \"[1;2A\", \"[1;5A\", \"[1;6A\")\n+    VK_CASE(VK_NUMPAD8, \"[1~\",  \"[1;2~\", \"[1;5~\", \"[1;6~\")\n+    VK_CASE(VK_NUMPAD9, \"[5~\",  \"[5;2~\", \"[5;5~\", \"[5;6~\")\n+    VK_CASE(VK_DECIMAL, \"[3~\",  \"[3;2~\", \"[3;5~\", \"[3;6~\")\n+    VK_CASE(VK_F1,      \"[[A\",  \"[23~\",  \"[11^\",  \"[23^\" )\n+    VK_CASE(VK_F2,      \"[[B\",  \"[24~\",  \"[12^\",  \"[24^\" )\n+    VK_CASE(VK_F3,      \"[[C\",  \"[25~\",  \"[13^\",  \"[25^\" )\n+    VK_CASE(VK_F4,      \"[[D\",  \"[26~\",  \"[14^\",  \"[26^\" )\n+    VK_CASE(VK_F5,      \"[[E\",  \"[28~\",  \"[15^\",  \"[28^\" )\n+    VK_CASE(VK_F6,      \"[17~\", \"[29~\",  \"[17^\",  \"[29^\" )\n+    VK_CASE(VK_F7,      \"[18~\", \"[31~\",  \"[18^\",  \"[31^\" )\n+    VK_CASE(VK_F8,      \"[19~\", \"[32~\",  \"[19^\",  \"[32^\" )\n+    VK_CASE(VK_F9,      \"[20~\", \"[33~\",  \"[20^\",  \"[33^\" )\n+    VK_CASE(VK_F10,     \"[21~\", \"[34~\",  \"[21^\",  \"[34^\" )\n+    VK_CASE(VK_F11,     \"[23~\", \"[23$\",  \"[23^\",  \"[23@\" )\n+    VK_CASE(VK_F12,     \"[24~\", \"[24$\",  \"[24^\",  \"[24@\" )\n+\n+    default:\n+      *len = 0;\n+      return NULL;\n+  }\n+#undef VK_CASE\n+}\n+\n+\n+void uv_process_tty_read_raw_req(uv_loop_t* loop, uv_tty_t* handle,\n+    uv_req_t* req) {\n+  /* Shortcut for handle->last_input_record.Event.KeyEvent. */\n+#define KEV handle->last_input_record.Event.KeyEvent\n+\n+  DWORD records_left, records_read;\n+  uv_buf_t buf;\n+  off_t buf_used;\n+\n+  assert(handle->type == UV_TTY);\n+  handle->flags &= ~UV_HANDLE_READ_PENDING;\n+\n+  if (!(handle->flags & UV_HANDLE_READING) ||\n+      !(handle->flags & UV_HANDLE_TTY_RAW)) {\n+    goto out;\n+  }\n+\n+  if (!REQ_SUCCESS(req)) {\n+    /* An error occurred while waiting for the event. */\n+    if ((handle->flags & UV_HANDLE_READING)) {\n+      handle->flags &= ~UV_HANDLE_READING;\n+      uv__set_sys_error(loop, GET_REQ_ERROR(req));\n+      handle->read_cb((uv_stream_t*)handle, -1, uv_null_buf_);\n+    }\n+    goto out;\n+  }\n+\n+  /* Fetch the number of events  */\n+  if (!GetNumberOfConsoleInputEvents(handle->handle, &records_left)) {\n+    handle->flags &= ~UV_HANDLE_READING;\n+    uv__set_sys_error(loop, GetLastError());\n+    handle->read_cb((uv_stream_t*)handle, -1, uv_null_buf_);\n+    goto out;\n+  }\n+\n+  /* Windows sends a lot of events that we're not interested in, so buf */\n+  /* will be allocated on demand, when there's actually something to emit. */\n+  buf = uv_null_buf_;\n+  buf_used = 0;\n+\n+  while ((records_left > 0 || handle->last_key_len > 0) &&\n+         (handle->flags & UV_HANDLE_READING)) {\n+    if (handle->last_key_len == 0) {\n+      /* Read the next input record */\n+      if (!ReadConsoleInputW(handle->handle,\n+                             &handle->last_input_record,\n+                             1,\n+                             &records_read)) {\n+        uv__set_sys_error(loop, GetLastError());\n+        handle->flags &= ~UV_HANDLE_READING;\n+        handle->read_cb((uv_stream_t*) handle, -1, buf);\n+        goto out;\n+      }\n+      records_left--;\n+\n+      /* Ignore events that are not keyboard events */\n+      if (handle->last_input_record.EventType != KEY_EVENT) {\n+        continue;\n+      }\n+\n+      /* Ignore keyup events, unless the left alt key was held and a valid */\n+      /* unicode character was emitted. */\n+      if (!KEV.bKeyDown && !(((KEV.dwControlKeyState & LEFT_ALT_PRESSED) ||\n+          KEV.wVirtualKeyCode==VK_MENU) && KEV.uChar.UnicodeChar != 0)) {\n+        continue;\n+      }\n+\n+      /* Ignore keypresses to numpad number keys if the left alt is held */\n+      /* because the user is composing a character, or windows simulating */\n+      /* this. */\n+      if ((KEV.dwControlKeyState & LEFT_ALT_PRESSED) &&\n+          !(KEV.dwControlKeyState & ENHANCED_KEY) &&\n+          (KEV.wVirtualKeyCode == VK_INSERT ||\n+          KEV.wVirtualKeyCode == VK_END ||\n+          KEV.wVirtualKeyCode == VK_DOWN ||\n+          KEV.wVirtualKeyCode == VK_NEXT ||\n+          KEV.wVirtualKeyCode == VK_LEFT ||\n+          KEV.wVirtualKeyCode == VK_CLEAR ||\n+          KEV.wVirtualKeyCode == VK_RIGHT ||\n+          KEV.wVirtualKeyCode == VK_HOME ||\n+          KEV.wVirtualKeyCode == VK_UP ||\n+          KEV.wVirtualKeyCode == VK_PRIOR ||\n+          KEV.wVirtualKeyCode == VK_NUMPAD0 ||\n+          KEV.wVirtualKeyCode == VK_NUMPAD1 ||\n+          KEV.wVirtualKeyCode == VK_NUMPAD2 ||\n+          KEV.wVirtualKeyCode == VK_NUMPAD3 ||\n+          KEV.wVirtualKeyCode == VK_NUMPAD4 ||\n+          KEV.wVirtualKeyCode == VK_NUMPAD5 ||\n+          KEV.wVirtualKeyCode == VK_NUMPAD6 ||\n+          KEV.wVirtualKeyCode == VK_NUMPAD7 ||\n+          KEV.wVirtualKeyCode == VK_NUMPAD8 ||\n+          KEV.wVirtualKeyCode == VK_NUMPAD9)) {\n+        continue;\n+      }\n+\n+      if (KEV.uChar.UnicodeChar != 0) {\n+        int prefix_len, char_len;\n+\n+        /* Character key pressed */\n+        if (KEV.uChar.UnicodeChar >= 0xD800 &&\n+            KEV.uChar.UnicodeChar < 0xDC00) {\n+          /* UTF-16 high surrogate */\n+          handle->last_utf16_high_surrogate = KEV.uChar.UnicodeChar;\n+          continue;\n+        }\n+\n+        /* Prefix with \\u033 if alt was held, but alt was not used as part */\n+        /* a compose sequence. */\n+        if ((KEV.dwControlKeyState & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED))\n+            && !(KEV.dwControlKeyState & (LEFT_CTRL_PRESSED |\n+            RIGHT_CTRL_PRESSED)) && KEV.bKeyDown) {\n+          handle->last_key[0] = '\\033';\n+          prefix_len = 1;\n+        } else {\n+          prefix_len = 0;\n+        }\n+\n+        if (KEV.uChar.UnicodeChar >= 0xDC00 &&\n+            KEV.uChar.UnicodeChar < 0xE000) {\n+          /* UTF-16 surrogate pair */\n+          WCHAR utf16_buffer[2] = { handle->last_utf16_high_surrogate,\n+                                    KEV.uChar.UnicodeChar};\n+          char_len = WideCharToMultiByte(CP_UTF8,\n+                                         0,\n+                                         utf16_buffer,\n+                                         2,\n+                                         &handle->last_key[prefix_len],\n+                                         sizeof handle->last_key,\n+                                         NULL,\n+                                         NULL);\n+        } else {\n+          /* Single UTF-16 character */\n+          char_len = WideCharToMultiByte(CP_UTF8,\n+                                         0,\n+                                         &KEV.uChar.UnicodeChar,\n+                                         1,\n+                                         &handle->last_key[prefix_len],\n+                                         sizeof handle->last_key,\n+                                         NULL,\n+                                         NULL);\n+        }\n+\n+        /* Whatever happened, the last character wasn't a high surrogate. */\n+        handle->last_utf16_high_surrogate = 0;\n+\n+        /* If the utf16 character(s) couldn't be converted something must */\n+        /* be wrong. */\n+        if (!char_len) {\n+          uv__set_sys_error(loop, GetLastError());\n+          handle->flags &= ~UV_HANDLE_READING;\n+          handle->read_cb((uv_stream_t*) handle, -1, buf);\n+          goto out;\n+        }\n+\n+        handle->last_key_len = (unsigned char) (prefix_len + char_len);\n+        handle->last_key_offset = 0;\n+        continue;\n+\n+      } else {\n+        /* Function key pressed */\n+        const char* vt100;\n+        size_t prefix_len, vt100_len;\n+\n+        vt100 = get_vt100_fn_key(KEV.wVirtualKeyCode,\n+                                  !!(KEV.dwControlKeyState & SHIFT_PRESSED),\n+                                  !!(KEV.dwControlKeyState & (\n+                                    LEFT_CTRL_PRESSED |\n+                                    RIGHT_CTRL_PRESSED)),\n+                                  &vt100_len);\n+\n+        /* If we were unable to map to a vt100 sequence, just ignore. */\n+        if (!vt100) {\n+          continue;\n+        }\n+\n+        /* Prefix with \\x033 when the alt key was held. */\n+        if (KEV.dwControlKeyState & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED)) {\n+          handle->last_key[0] = '\\033';\n+          prefix_len = 1;\n+        } else {\n+          prefix_len = 0;\n+        }\n+\n+        /* Copy the vt100 sequence to the handle buffer. */\n+        assert(prefix_len + vt100_len < sizeof handle->last_key);\n+        memcpy(&handle->last_key[prefix_len], vt100, vt100_len);\n+\n+        handle->last_key_len = (unsigned char) (prefix_len + vt100_len);\n+        handle->last_key_offset = 0;\n+        continue;\n+      }\n+    } else {\n+      /* Copy any bytes left from the last keypress to the user buffer. */\n+      if (handle->last_key_offset < handle->last_key_len) {\n+        /* Allocate a buffer if needed */\n+        if (buf_used == 0) {\n+          buf = handle->alloc_cb((uv_handle_t*) handle, 1024);\n+        }\n+\n+        buf.base[buf_used++] = handle->last_key[handle->last_key_offset++];\n+\n+        /* If the buffer is full, emit it */\n+        if (buf_used == buf.len) {\n+          handle->read_cb((uv_stream_t*) handle, buf_used, buf);\n+          buf = uv_null_buf_;\n+          buf_used = 0;\n+        }\n+\n+        continue;\n+      }\n+\n+      /* Apply dwRepeat from the last input record. */\n+      if (--KEV.wRepeatCount > 0) {\n+        handle->last_key_offset = 0;\n+        continue;\n+      }\n+\n+      handle->last_key_len = 0;\n+      continue;\n+    }\n+  }\n+\n+  /* Send the buffer back to the user */\n+  if (buf_used > 0) {\n+    handle->read_cb((uv_stream_t*) handle, buf_used, buf);\n+  }\n+\n+ out:\n+  /* Wait for more input events. */\n+  if ((handle->flags & UV_HANDLE_READING) &&\n+      !(handle->flags & UV_HANDLE_READ_PENDING)) {\n+    uv_tty_queue_read(loop, handle);\n+  }\n+\n+  DECREASE_PENDING_REQ_COUNT(handle);\n+\n+#undef KEV\n+}\n+\n+\n+\n+void uv_process_tty_read_line_req(uv_loop_t* loop, uv_tty_t* handle,\n+    uv_req_t* req) {\n+  uv_buf_t buf;\n+\n+  assert(handle->type == UV_TTY);\n+\n+  buf = handle->read_line_buffer;\n+\n+  handle->flags &= ~UV_HANDLE_READ_PENDING;\n+  handle->read_line_buffer = uv_null_buf_;\n+\n+  if (!REQ_SUCCESS(req)) {\n+    /* Read was not successful */\n+    if ((handle->flags & UV_HANDLE_READING) &&\n+        !(handle->flags & UV_HANDLE_TTY_RAW)) {\n+      /* Real error */\n+      handle->flags &= ~UV_HANDLE_READING;\n+      uv__set_sys_error(loop, GET_REQ_ERROR(req));\n+      handle->read_cb((uv_stream_t*) handle, -1, buf);\n+    } else {\n+      /* The read was cancelled, or whatever we don't care */\n+      uv__set_sys_error(loop, WSAEWOULDBLOCK); /* maps to UV_EAGAIN */\n+      handle->read_cb((uv_stream_t*) handle, 0, buf);\n+    }\n+\n+  } else {\n+    /* Read successful */\n+    /* TODO: read unicode, convert to utf-8 */\n+    DWORD bytes = req->overlapped.InternalHigh;\n+    if (bytes == 0) {\n+      uv__set_sys_error(loop, WSAEWOULDBLOCK); /* maps to UV_EAGAIN */\n+    }\n+    handle->read_cb((uv_stream_t*) handle, bytes, buf);\n+  }\n+\n+  /* Wait for more input events. */\n+  if ((handle->flags & UV_HANDLE_READING) &&\n+      !(handle->flags & UV_HANDLE_READ_PENDING)) {\n+    uv_tty_queue_read(loop, handle);\n+  }\n+\n+  DECREASE_PENDING_REQ_COUNT(handle);\n+}\n+\n+\n+void uv_process_tty_read_req(uv_loop_t* loop, uv_tty_t* handle,\n+    uv_req_t* req) {\n+\n+  /* If the read_line_buffer member is zero, it must have been an raw read. */\n+  /* Otherwise it was a line-buffered read. */\n+  /* FIXME: This is quite obscure. Use a flag or something. */\n+  if (handle->read_line_buffer.len == 0) {\n+    uv_process_tty_read_raw_req(loop, handle, req);\n+  } else {\n+    uv_process_tty_read_line_req(loop, handle, req);\n+  }\n+}\n+\n+\n+int uv_tty_read_start(uv_tty_t* handle, uv_alloc_cb alloc_cb,\n+    uv_read_cb read_cb) {\n+  uv_loop_t* loop = handle->loop;\n+\n+  handle->flags |= UV_HANDLE_READING;\n+  handle->read_cb = read_cb;\n+  handle->alloc_cb = alloc_cb;\n+\n+  /* If reading was stopped and then started again, there could stell be a */\n+  /* read request pending. */\n+  if (handle->flags & UV_HANDLE_READ_PENDING) {\n+    return 0;\n+  }\n+\n+  /* Maybe the user stopped reading half-way while processing key events. */\n+  /* Short-circuit if this could be the case. */\n+  if (handle->last_key_len > 0) {\n+    SET_REQ_SUCCESS(&handle->read_req);\n+    uv_insert_pending_req(handle->loop, (uv_req_t*) &handle->read_req);\n+    return -1;\n+  }\n+\n+  uv_tty_queue_read(loop, handle);\n+\n+  return 0;\n+}\n+\n+\n+int uv_tty_read_stop(uv_tty_t* handle) {\n+  handle->flags &= ~UV_HANDLE_READING;\n+\n+  /* Cancel raw read */\n+  if ((handle->flags & UV_HANDLE_READ_PENDING) &&\n+      (handle->flags & UV_HANDLE_TTY_RAW)) {\n+    /* Write some bullshit event to force the console wait to return. */\n+    INPUT_RECORD record;\n+    DWORD written;\n+    memset(&record, 0, sizeof record);\n+    if (!WriteConsoleInputW(handle->handle, &record, 1, &written)) {\n+      uv__set_sys_error(handle->loop, GetLastError());\n+      return -1;\n+    }\n+  }\n+\n+  /* Cancel line-buffered read */\n+  if (handle->read_line_handle != NULL) {\n+    /* Closing this handle will cancel the ReadConsole operation */\n+    CloseHandle(handle->read_line_handle);\n+    handle->read_line_handle = NULL;\n+  }\n+\n+\n+  return 0;\n+}\n+\n+\n+static void uv_tty_update_virtual_window(CONSOLE_SCREEN_BUFFER_INFO* info) {\n+  uv_tty_virtual_height = info->srWindow.Bottom - info->srWindow.Top + 1;\n+  uv_tty_virtual_width = info->dwSize.X;\n+\n+  /* Recompute virtual window offset row. */\n+  if (uv_tty_virtual_offset == -1) {\n+    uv_tty_virtual_offset = info->dwCursorPosition.Y;\n+  } else if (uv_tty_virtual_offset < info->dwCursorPosition.Y -\n+             uv_tty_virtual_height + 1) {\n+    /* If suddenly find the cursor outside of the virtual window, it must */\n+    /* have somehow scrolled. Update the virtual window offset. */\n+    uv_tty_virtual_offset = info->dwCursorPosition.Y -\n+                            uv_tty_virtual_height + 1;\n+  }\n+  if (uv_tty_virtual_offset + uv_tty_virtual_height > info->dwSize.Y) {\n+    uv_tty_virtual_offset = info->dwSize.Y - uv_tty_virtual_height;\n+  }\n+  if (uv_tty_virtual_offset < 0) {\n+    uv_tty_virtual_offset = 0;\n+  }\n+}\n+\n+\n+static COORD uv_tty_make_real_coord(uv_tty_t* handle,\n+    CONSOLE_SCREEN_BUFFER_INFO* info, int x, unsigned char x_relative, int y,\n+    unsigned char y_relative) {\n+  COORD result;\n+\n+  uv_tty_update_virtual_window(info);\n+\n+  /* Adjust y position */\n+  if (y_relative) {\n+    y = info->dwCursorPosition.Y + y;\n+  } else {\n+    y = uv_tty_virtual_offset + y;\n+  }\n+  /* Clip y to virtual client rectangle */\n+  if (y < uv_tty_virtual_offset) {\n+    y = uv_tty_virtual_offset;\n+  } else if (y >= uv_tty_virtual_offset + uv_tty_virtual_height) {\n+    y = uv_tty_virtual_offset + uv_tty_virtual_height - 1;\n+  }\n+\n+  /* Adjust x */\n+  if (x_relative) {\n+    x = info->dwCursorPosition.X + x;\n+  }\n+  /* Clip x */\n+  if (x < 0) {\n+    x = 0;\n+  } else if (x >= uv_tty_virtual_width) {\n+    x = uv_tty_virtual_width - 1;\n+  }\n+\n+  result.X = (unsigned short) x;\n+  result.Y = (unsigned short) y;\n+  return result;\n+}\n+\n+\n+static int uv_tty_emit_text(uv_tty_t* handle, WCHAR buffer[], DWORD length,\n+    DWORD* error) {\n+  DWORD written;\n+\n+  if (*error != ERROR_SUCCESS) {\n+    return -1;\n+  }\n+\n+  if (!WriteConsoleW(handle->handle,\n+                     (void*) buffer,\n+                     length,\n+                     &written,\n+                     NULL)) {\n+    *error = GetLastError();\n+    return -1;\n+  }\n+\n+  return 0;\n+}\n+\n+\n+static int uv_tty_move_caret(uv_tty_t* handle, int x, unsigned char x_relative,\n+    int y, unsigned char y_relative, DWORD* error) {\n+  CONSOLE_SCREEN_BUFFER_INFO info;\n+  COORD pos;\n+\n+  if (*error != ERROR_SUCCESS) {\n+    return -1;\n+  }\n+\n+ retry:\n+  if (!GetConsoleScreenBufferInfo(handle->handle, &info)) {\n+    *error = GetLastError();\n+  }\n+\n+  pos = uv_tty_make_real_coord(handle, &info, x, x_relative, y, y_relative);\n+\n+  if (!SetConsoleCursorPosition(handle->handle, pos)) {\n+    if (GetLastError() == ERROR_INVALID_PARAMETER) {\n+      /* The console may be resized - retry */\n+      goto retry;\n+    } else {\n+      *error = GetLastError();\n+      return -1;\n+    }\n+  }\n+\n+  return 0;\n+}\n+\n+\n+static int uv_tty_reset(uv_tty_t* handle, DWORD* error) {\n+  const COORD origin = {0, 0};\n+  const WORD char_attrs = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_RED;\n+  CONSOLE_SCREEN_BUFFER_INFO info;\n+  DWORD count, written;\n+\n+  if (*error != ERROR_SUCCESS) {\n+    return -1;\n+  }\n+\n+  /* Reset original text attributes. */\n+  if (!SetConsoleTextAttribute(handle->handle, char_attrs)) {\n+    *error = GetLastError();\n+    return -1;\n+  }\n+\n+  /* Move the cursor position to (0, 0). */\n+  if (!SetConsoleCursorPosition(handle->handle, origin)) {\n+    *error = GetLastError();\n+    return -1;\n+  }\n+\n+  /* Clear the screen buffer. */\n+ retry:\n+  if (!GetConsoleScreenBufferInfo(handle->handle, &info)) {\n+    *error = GetLastError();\n+    return -1;\n+  }\n+\n+  count = info.dwSize.X * info.dwSize.Y;\n+\n+  if (!(FillConsoleOutputCharacterW(handle->handle,\n+                              L'\\x20',\n+                              count,\n+                              origin,\n+                              &written) &&\n+        FillConsoleOutputAttribute(handle->handle,\n+                                   char_attrs,\n+                                   written,\n+                                   origin,\n+                                   &written))) {\n+    if (GetLastError() == ERROR_INVALID_PARAMETER) {\n+      /* The console may be resized - retry */\n+      goto retry;\n+    } else {\n+      *error = GetLastError();\n+      return -1;\n+    }\n+  }\n+\n+  /* Move the virtual window up to the top. */\n+  uv_tty_virtual_offset = 0;\n+  uv_tty_update_virtual_window(&info);\n+\n+  return 0;\n+}\n+\n+\n+static int uv_tty_clear(uv_tty_t* handle, int dir, char entire_screen,\n+    DWORD* error) {\n+  unsigned short argc = handle->ansi_csi_argc;\n+  unsigned short* argv = handle->ansi_csi_argv;\n+\n+  CONSOLE_SCREEN_BUFFER_INFO info;\n+  COORD start, end;\n+  DWORD count, written;\n+\n+  int x1, x2, y1, y2;\n+  int x1r, x2r, y1r, y2r;\n+\n+  if (*error != ERROR_SUCCESS) {\n+    return -1;\n+  }\n+\n+  if (dir == 0) {\n+    /* Clear from current position */\n+    x1 = 0;\n+    x1r = 1;\n+  } else {\n+    /* Clear from column 0 */\n+    x1 = 0;\n+    x1r = 0;\n+  }\n+\n+  if (dir == 1) {\n+    /* Clear to current position */\n+    x2 = 0;\n+    x2r = 1;\n+  } else {\n+    /* Clear to end of row. We pretend the console is 65536 characters wide, */\n+    /* uv_tty_make_real_coord will clip it to the actual console width. */\n+    x2 = 0xffff;\n+    x2r = 0;\n+  }\n+\n+  if (!entire_screen) {\n+    /* Stay on our own row */\n+    y1 = y2 = 0;\n+    y1r = y2r = 1;\n+  } else {\n+    /* Apply columns direction to row */\n+    y1 = x1;\n+    y1r = x1r;\n+    y2 = x2;\n+    y2r = x2r;\n+  }\n+\n+ retry:\n+  if (!GetConsoleScreenBufferInfo(handle->handle, &info)) {\n+    *error = GetLastError();\n+    return -1;\n+  }\n+\n+  start = uv_tty_make_real_coord(handle, &info, x1, x1r, y1, y1r);\n+  end = uv_tty_make_real_coord(handle, &info, x2, x2r, y2, y2r);\n+  count = (end.Y * info.dwSize.X + end.X) -\n+          (start.Y * info.dwSize.X + start.X) + 1;\n+\n+  if (!(FillConsoleOutputCharacterW(handle->handle,\n+                              L'\\x20',\n+                              count,\n+                              start,\n+                              &written) &&\n+        FillConsoleOutputAttribute(handle->handle,\n+                                   info.wAttributes,\n+                                   written,\n+                                   start,\n+                                   &written))) {\n+    if (GetLastError() == ERROR_INVALID_PARAMETER) {\n+      /* The console may be resized - retry */\n+      goto retry;\n+    } else {\n+      *error = GetLastError();\n+      return -1;\n+    }\n+  }\n+\n+  return 0;\n+}\n+\n+\n+static int uv_tty_set_style(uv_tty_t* handle, DWORD* error) {\n+  unsigned short argc = handle->ansi_csi_argc;\n+  unsigned short* argv = handle->ansi_csi_argv;\n+  int i;\n+  CONSOLE_SCREEN_BUFFER_INFO info;\n+\n+  char fg_color = -1, bg_color = -1;\n+  char fg_bright = -1, bg_bright = -1;\n+\n+  if (argc == 0) {\n+    /* Reset mode */\n+    fg_color = 7;\n+    bg_color = 0;\n+    fg_bright = 0;\n+    bg_bright = 0;\n+  }\n+\n+  for (i = 0; i < argc; i++) {\n+    short arg = argv[i];\n+\n+    if (arg == 0) {\n+      /* Reset mode */\n+      fg_color = 7;\n+      bg_color = 0;\n+      fg_bright = 0;\n+      bg_bright = 0;\n+\n+    } else if (arg == 1) {\n+      /* Bright */\n+      fg_bright = 1;\n+\n+    } else if (arg == 21 || arg == 22) {\n+      /* Bright off. */\n+      fg_bright = 0;\n+\n+    } else if (arg >= 30 && arg <= 37) {\n+      /* Set foreground color */\n+      fg_color = arg - 30;\n+\n+    } else if (arg == 39) {\n+      /* Default text color */\n+      fg_color = 7;\n+\n+    } else if (arg >= 40 && arg <= 47) {\n+      /* Set background color */\n+      bg_color = arg - 40;\n+\n+    } else if (arg ==  49) {\n+      /* Default background color */\n+      bg_color = 0;\n+    }\n+  }\n+\n+  if (fg_color == -1 && bg_color == -1 && fg_bright == -1 &&\n+      bg_bright == -1) {\n+    /* Nothing changed */\n+    return 0;\n+  }\n+\n+  if (!GetConsoleScreenBufferInfo(handle->handle, &info)) {\n+    *error = GetLastError();\n+    return -1;\n+  }\n+\n+  if (fg_color != -1) {\n+    info.wAttributes &= ~(FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE);\n+    if (fg_color & 1) info.wAttributes |= FOREGROUND_RED;\n+    if (fg_color & 2) info.wAttributes |= FOREGROUND_GREEN;\n+    if (fg_color & 4) info.wAttributes |= FOREGROUND_BLUE;\n+  }\n+\n+  if (fg_bright != -1) {\n+    if (fg_bright) {\n+      info.wAttributes |= FOREGROUND_INTENSITY;\n+    } else {\n+      info.wAttributes &= ~FOREGROUND_INTENSITY;\n+    }\n+  }\n+\n+  if (bg_color != -1) {\n+    info.wAttributes &= ~(BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE);\n+    if (bg_color & 1) info.wAttributes |= BACKGROUND_RED;\n+    if (bg_color & 2) info.wAttributes |= BACKGROUND_GREEN;\n+    if (bg_color & 4) info.wAttributes |= BACKGROUND_BLUE;\n+  }\n+\n+  if (bg_bright != -1) {\n+    if (bg_bright) {\n+      info.wAttributes |= BACKGROUND_INTENSITY;\n+    } else {\n+      info.wAttributes &= ~BACKGROUND_INTENSITY;\n+    }\n+  }\n+\n+  if (!SetConsoleTextAttribute(handle->handle, info.wAttributes)) {\n+    *error = GetLastError();\n+    return -1;\n+  }\n+\n+  return 0;\n+}\n+\n+\n+static int uv_tty_save_state(uv_tty_t* handle, unsigned char save_attributes,\n+    DWORD* error) {\n+  CONSOLE_SCREEN_BUFFER_INFO info;\n+\n+  if (*error != ERROR_SUCCESS) {\n+    return -1;\n+  }\n+\n+  if (!GetConsoleScreenBufferInfo(handle->handle, &info)) {\n+    *error = GetLastError();\n+    return -1;\n+  }\n+\n+  uv_tty_update_virtual_window(&info);\n+\n+  handle->saved_position.X = info.dwCursorPosition.X;\n+  handle->saved_position.Y = info.dwCursorPosition.Y - uv_tty_virtual_offset;\n+  handle->flags |= UV_HANDLE_TTY_SAVED_POSITION;\n+\n+  if (save_attributes) {\n+    handle->saved_attributes = info.wAttributes &\n+        (FOREGROUND_INTENSITY | BACKGROUND_INTENSITY);\n+    handle->flags |= UV_HANDLE_TTY_SAVED_ATTRIBUTES;\n+  }\n+\n+  return 0;\n+}\n+\n+\n+static int uv_tty_restore_state(uv_tty_t* handle,\n+    unsigned char restore_attributes, DWORD* error) {\n+  CONSOLE_SCREEN_BUFFER_INFO info;\n+  WORD new_attributes;\n+\n+  if (*error != ERROR_SUCCESS) {\n+    return -1;\n+  }\n+\n+  if (handle->flags & UV_HANDLE_TTY_SAVED_POSITION) {\n+    if (uv_tty_move_caret(handle,\n+                          handle->saved_position.X,\n+                          0,\n+                          handle->saved_position.Y,\n+                          0,\n+                          error) != 0) {\n+      return -1;\n+    }\n+  }\n+\n+  if (restore_attributes &&\n+      (handle->flags & UV_HANDLE_TTY_SAVED_ATTRIBUTES)) {\n+    if (!GetConsoleScreenBufferInfo(handle->handle, &info)) {\n+      *error = GetLastError();\n+      return -1;\n+    }\n+\n+    new_attributes = info.wAttributes;\n+    new_attributes &= ~(FOREGROUND_INTENSITY | BACKGROUND_INTENSITY);\n+    new_attributes |= handle->saved_attributes;\n+\n+    if (!SetConsoleTextAttribute(handle->handle, new_attributes)) {\n+      *error = GetLastError();\n+      return -1;\n+    }\n+  }\n+\n+  return 0;\n+}\n+\n+\n+static int uv_tty_write_bufs(uv_tty_t* handle, uv_buf_t bufs[], int bufcnt,\n+    DWORD* error) {\n+  /* We can only write 8k characters at a time. Windows can't handle */\n+  /* much more characters in a single console write anyway. */\n+  WCHAR utf16_buf[8192];\n+  DWORD utf16_buf_used = 0;\n+  int i;\n+\n+#define FLUSH_TEXT()                                                \\\n+  do {                                                              \\\n+    if (utf16_buf_used > 0) {                                       \\\n+      uv_tty_emit_text(handle, utf16_buf, utf16_buf_used, error);   \\\n+      utf16_buf_used = 0;                                           \\\n+    }                                                               \\\n+  } while (0)\n+\n+  /* Cache for fast access */\n+  unsigned char utf8_bytes_left = handle->utf8_bytes_left;\n+  unsigned int utf8_codepoint = handle->utf8_codepoint;\n+  unsigned char previous_eol = handle->previous_eol;\n+  unsigned char ansi_parser_state = handle->ansi_parser_state;\n+\n+  /* Store the error here. If we encounter an error, stop trying to do i/o */\n+  /* but keep parsing the buffer so we leave the parser in a consistent */\n+  /* state. */\n+  *error = ERROR_SUCCESS;\n+\n+  EnterCriticalSection(&uv_tty_output_lock);\n+\n+  for (i = 0; i < bufcnt; i++) {\n+    uv_buf_t buf = bufs[i];\n+    unsigned int j;\n+\n+    for (j = 0; j < buf.len; j++) {\n+      unsigned char c = buf.base[j];\n+\n+      /* Run the character through the utf8 decoder We happily accept non */\n+      /* shortest form encodings and invalid code points - there's no real */\n+      /* harm that can be done. */\n+      if (utf8_bytes_left == 0) {\n+        /* Read utf-8 start byte */\n+        DWORD first_zero_bit;\n+        unsigned char not_c = ~c;\n+#ifdef _MSC_VER /* msvc */\n+        if (_BitScanReverse(&first_zero_bit, not_c)) {\n+#else /* assume gcc */\n+        if (first_zero_bit = __builtin_clzl(not_c), c != 0) {\n+#endif\n+          if (first_zero_bit == 7) {\n+            /* Ascii - pass right through */\n+            utf8_codepoint = (unsigned int) c;\n+\n+          } else if (first_zero_bit <= 5) {\n+            /* Multibyte sequence */\n+            utf8_codepoint = (0xff >> (8 - first_zero_bit)) & c;\n+            utf8_bytes_left = (char) (6 - first_zero_bit);\n+\n+          } else {\n+            /* Invalid continuation */\n+            utf8_codepoint = UNICODE_REPLACEMENT_CHARACTER;\n+          }\n+\n+        } else {\n+          /* 0xff -- invalid */\n+          utf8_codepoint = UNICODE_REPLACEMENT_CHARACTER;\n+        }\n+\n+      } else if ((c & 0xc0) == 0x80) {\n+        /* Valid continuation of utf-8 multibyte sequence */\n+        utf8_bytes_left--;\n+        utf8_codepoint <<= 6;\n+        utf8_codepoint |= ((unsigned int) c & 0x3f);\n+\n+      } else {\n+        /* Start byte where continuation was expected. */\n+        utf8_bytes_left = 0;\n+        utf8_codepoint = UNICODE_REPLACEMENT_CHARACTER;\n+        /* Patch buf offset so this character will be parsed again as a */\n+        /* start byte. */\n+        j--;\n+      }\n+\n+      /* Maybe we need to parse more bytes to find a character. */\n+      if (utf8_bytes_left != 0) {\n+        continue;\n+      }\n+\n+      /* Parse vt100/ansi escape codes */\n+      if (ansi_parser_state == ANSI_NORMAL) {\n+        switch (utf8_codepoint) {\n+          case '\\033':\n+            ansi_parser_state = ANSI_ESCAPE_SEEN;\n+            continue;\n+\n+          case 0233:\n+            ansi_parser_state = ANSI_CSI;\n+            handle->ansi_csi_argc = 0;\n+            continue;\n+        }\n+\n+      } else if (ansi_parser_state == ANSI_ESCAPE_SEEN) {\n+        switch (utf8_codepoint) {\n+          case '[':\n+            ansi_parser_state = ANSI_CSI;\n+            handle->ansi_csi_argc = 0;\n+            continue;\n+\n+          case '^':\n+          case '_':\n+          case 'P':\n+          case ']':\n+            /* Not supported, but we'll have to parse until we see a stop */\n+            /* code, e.g. ESC \\ or BEL. */\n+            ansi_parser_state = ANSI_ST_CONTROL;\n+            continue;\n+\n+          case '\\033':\n+            /* Ignore double escape. */\n+            continue;\n+\n+          case 'c':\n+            /* Full console reset. */\n+            FLUSH_TEXT();\n+            uv_tty_reset(handle, error);\n+            ansi_parser_state = ANSI_NORMAL;\n+            continue;\n+\n+          case '7':\n+            /* Save the cursor position and text attributes. */\n+            FLUSH_TEXT();\n+            uv_tty_save_state(handle, 1, error);\n+            ansi_parser_state = ANSI_NORMAL;\n+            continue;\n+\n+           case '8':\n+            /* Restore the cursor position and text attributes */\n+            FLUSH_TEXT();\n+            uv_tty_restore_state(handle, 1, error);\n+            ansi_parser_state = ANSI_NORMAL;\n+            continue;\n+\n+          default:\n+            if (utf8_codepoint >= '@' && utf8_codepoint <= '_') {\n+              /* Single-char control. */\n+              ansi_parser_state = ANSI_NORMAL;\n+              continue;\n+            } else {\n+              /* Invalid - proceed as normal, */\n+              ansi_parser_state = ANSI_NORMAL;\n+            }\n+        }\n+\n+      } else if (ansi_parser_state & ANSI_CSI) {\n+        if (!(ansi_parser_state & ANSI_IGNORE)) {\n+          if (utf8_codepoint >= '0' && utf8_codepoint <= '9') {\n+            /* Parsing a numerical argument */\n+\n+            if (!(ansi_parser_state & ANSI_IN_ARG)) {\n+              /* We were not currently parsing a number */\n+\n+              /* Check for too many arguments */\n+              if (handle->ansi_csi_argc >= COUNTOF(handle->ansi_csi_argv)) {\n+                ansi_parser_state |= ANSI_IGNORE;\n+                continue;\n+              }\n+\n+              ansi_parser_state |= ANSI_IN_ARG;\n+              handle->ansi_csi_argc++;\n+              handle->ansi_csi_argv[handle->ansi_csi_argc - 1] =\n+                  (unsigned short) utf8_codepoint - '0';\n+              continue;\n+            } else {\n+              /* We were already parsing a number. Parse next digit. */\n+              uint32_t value = 10 *\n+                  handle->ansi_csi_argv[handle->ansi_csi_argc - 1];\n+\n+              /* Check for overflow. */\n+              if (value > UINT16_MAX) {\n+                ansi_parser_state |= ANSI_IGNORE;\n+                continue;\n+              }\n+\n+               handle->ansi_csi_argv[handle->ansi_csi_argc - 1] =\n+                   (unsigned short) value + (utf8_codepoint - '0');\n+               continue;\n+            }\n+\n+          } else if (utf8_codepoint == ';') {\n+            /* Denotes the end of an argument. */\n+            if (ansi_parser_state & ANSI_IN_ARG) {\n+              ansi_parser_state &= ~ANSI_IN_ARG;\n+              continue;\n+\n+            } else {\n+              /* If ANSI_IN_ARG is not set, add another argument and */\n+              /* default it to 0. */\n+              /* Check for too many arguments */\n+              if (handle->ansi_csi_argc >= COUNTOF(handle->ansi_csi_argv)) {\n+                ansi_parser_state |= ANSI_IGNORE;\n+                continue;\n+              }\n+\n+              handle->ansi_csi_argc++;\n+              handle->ansi_csi_argv[handle->ansi_csi_argc - 1] = 0;\n+              continue;\n+            }\n+\n+          } else if (utf8_codepoint >= '@' && utf8_codepoint <= '~' &&\n+                     (handle->ansi_csi_argc > 0 || utf8_codepoint != '[')) {\n+            int x, y, d;\n+\n+            /* Command byte */\n+            switch (utf8_codepoint) {\n+              case 'A':\n+                /* cursor up */\n+                FLUSH_TEXT();\n+                y = -(handle->ansi_csi_argc ? handle->ansi_csi_argv[0] : 1);\n+                uv_tty_move_caret(handle, 0, 1, y, 1, error);\n+                break;\n+\n+              case 'B':\n+                /* cursor down */\n+                FLUSH_TEXT();\n+                y = handle->ansi_csi_argc ? handle->ansi_csi_argv[0] : 1;\n+                uv_tty_move_caret(handle, 0, 1, y, 1, error);\n+                break;\n+\n+              case 'C':\n+                /* cursor forward */\n+                FLUSH_TEXT();\n+                x = handle->ansi_csi_argc ? handle->ansi_csi_argv[0] : 1;\n+                uv_tty_move_caret(handle, x, 1, 0, 1, error);\n+                break;\n+\n+              case 'D':\n+                /* cursor back */\n+                FLUSH_TEXT();\n+                x = -(handle->ansi_csi_argc ? handle->ansi_csi_argv[0] : 1);\n+                uv_tty_move_caret(handle, x, 1, 0, 1, error);\n+                break;\n+\n+              case 'E':\n+                /* cursor next line */\n+                FLUSH_TEXT();\n+                y = handle->ansi_csi_argc ? handle->ansi_csi_argv[0] : 1;\n+                uv_tty_move_caret(handle, 0, 0, y, 1, error);\n+                break;\n+\n+              case 'F':\n+                /* cursor previous line */\n+                FLUSH_TEXT();\n+                y = -(handle->ansi_csi_argc ? handle->ansi_csi_argv[0] : 1);\n+                uv_tty_move_caret(handle, 0, 0, y, 1, error);\n+                break;\n+\n+              case 'G':\n+                /* cursor horizontal move absolute */\n+                FLUSH_TEXT();\n+                x = (handle->ansi_csi_argc >= 1 && handle->ansi_csi_argv[0])\n+                  ? handle->ansi_csi_argv[0] - 1 : 0;\n+                uv_tty_move_caret(handle, x, 0, 0, 1, error);\n+                break;\n+\n+              case 'H':\n+              case 'f':\n+                /* cursor move absolute */\n+                FLUSH_TEXT();\n+                y = (handle->ansi_csi_argc >= 1 && handle->ansi_csi_argv[0])\n+                  ? handle->ansi_csi_argv[0] - 1 : 0;\n+                x = (handle->ansi_csi_argc >= 2 && handle->ansi_csi_argv[1])\n+                  ? handle->ansi_csi_argv[1] - 1 : 0;\n+                uv_tty_move_caret(handle, x, 0, y, 0, error);\n+                break;\n+\n+              case 'J':\n+                /* Erase screen */\n+                FLUSH_TEXT();\n+                d = handle->ansi_csi_argc ? handle->ansi_csi_argv[0] : 0;\n+                if (d >= 0 && d <= 2) {\n+                  uv_tty_clear(handle, d, 1, error);\n+                }\n+                break;\n+\n+              case 'K':\n+                /* Erase line */\n+                FLUSH_TEXT();\n+                d = handle->ansi_csi_argc ? handle->ansi_csi_argv[0] : 0;\n+                if (d >= 0 && d <= 2) {\n+                  uv_tty_clear(handle, d, 0, error);\n+                }\n+                break;\n+\n+              case 'm':\n+                /* Set style */\n+                FLUSH_TEXT();\n+                uv_tty_set_style(handle, error);\n+                break;\n+\n+              case 's':\n+                /* Save the cursor position. */\n+                FLUSH_TEXT();\n+                uv_tty_save_state(handle, 0, error);\n+                break;\n+\n+              case 'u':\n+                /* Restore the cursor position */\n+                FLUSH_TEXT();\n+                uv_tty_restore_state(handle, 0, error);\n+                break;\n+            }\n+\n+            /* Sequence ended - go back to normal state. */\n+            ansi_parser_state = ANSI_NORMAL;\n+            continue;\n+\n+          } else {\n+            /* We don't support commands that use private mode characters or */\n+            /* intermediaries. Ignore the rest of the sequence. */\n+            ansi_parser_state |= ANSI_IGNORE;\n+            continue;\n+          }\n+        } else {\n+          /* We're ignoring this command. Stop only on command character. */\n+          if (utf8_codepoint >= '@' && utf8_codepoint <= '~') {\n+            ansi_parser_state = ANSI_NORMAL;\n+          }\n+          continue;\n+        }\n+\n+      } else if (ansi_parser_state & ANSI_ST_CONTROL) {\n+        /* Unsupported control code */\n+        /* Ignore everything until we see BEL or ESC \\ */\n+        if (ansi_parser_state & ANSI_IN_STRING) {\n+          if (!(ansi_parser_state & ANSI_BACKSLASH_SEEN)) {\n+            if (utf8_codepoint == '\"') {\n+              ansi_parser_state &= ~ANSI_IN_STRING;\n+            } else if (utf8_codepoint == '\\\\') {\n+              ansi_parser_state |= ANSI_BACKSLASH_SEEN;\n+            }\n+          } else {\n+            ansi_parser_state &= ~ANSI_BACKSLASH_SEEN;\n+          }\n+        } else {\n+          if (utf8_codepoint == '\\007' || (utf8_codepoint == '\\\\' &&\n+              (ansi_parser_state & ANSI_ESCAPE_SEEN))) {\n+            /* End of sequence */\n+            ansi_parser_state = ANSI_NORMAL;\n+          } else if (utf8_codepoint == '\\033') {\n+            /* Escape character */\n+            ansi_parser_state |= ANSI_ESCAPE_SEEN;\n+          } else if (utf8_codepoint == '\"') {\n+             /* String starting */\n+            ansi_parser_state |= ANSI_IN_STRING;\n+            ansi_parser_state &= ~ANSI_ESCAPE_SEEN;\n+            ansi_parser_state &= ~ANSI_BACKSLASH_SEEN;\n+          } else {\n+            ansi_parser_state &= ~ANSI_ESCAPE_SEEN;\n+          }\n+        }\n+        continue;\n+      } else {\n+        /* Inconsistent state */\n+        abort();\n+      }\n+\n+      /* We wouldn't mind emitting utf-16 surrogate pairs. Too bad, the */\n+      /* windows console doesn't really support UTF-16, so just emit the */\n+      /* replacement character. */\n+      if (utf8_codepoint > 0xffff) {\n+        utf8_codepoint = UNICODE_REPLACEMENT_CHARACTER;\n+      }\n+\n+      if (utf8_codepoint == 0x0a || utf8_codepoint == 0x0d) {\n+        /* EOL conversion - emit \\r\\n, when we see either \\r or \\n. */\n+        /* If a \\n immediately follows a \\r or vice versa, ignore it. */\n+        if (previous_eol == 0 || utf8_codepoint == previous_eol) {\n+          /* If there's no room in the utf16 buf, flush it first. */\n+          if (2 > COUNTOF(utf16_buf) - utf16_buf_used) {\n+            uv_tty_emit_text(handle, utf16_buf, utf16_buf_used, error);\n+            utf16_buf_used = 0;\n+          }\n+\n+          utf16_buf[utf16_buf_used++] = L'\\r';\n+          utf16_buf[utf16_buf_used++] = L'\\n';\n+          previous_eol = (char) utf8_codepoint;\n+        } else {\n+          /* Ignore this newline, but don't ignore later ones. */\n+          previous_eol = 0;\n+        }\n+\n+      } else if (utf8_codepoint <= 0xffff) {\n+        /* Encode character into utf-16 buffer. */\n+\n+        /* If there's no room in the utf16 buf, flush it first. */\n+        if (1 > COUNTOF(utf16_buf) - utf16_buf_used) {\n+          uv_tty_emit_text(handle, utf16_buf, utf16_buf_used, error);\n+          utf16_buf_used = 0;\n+        }\n+\n+        utf16_buf[utf16_buf_used++] = (WCHAR) utf8_codepoint;\n+        previous_eol = 0;\n+      }\n+    }\n+  }\n+\n+  /* Flush remaining characters */\n+  FLUSH_TEXT();\n+\n+  /* Copy cached values back to struct. */\n+  handle->utf8_bytes_left = utf8_bytes_left;\n+  handle->utf8_codepoint = utf8_codepoint;\n+  handle->previous_eol = previous_eol;\n+  handle->ansi_parser_state = ansi_parser_state;\n+\n+  LeaveCriticalSection(&uv_tty_output_lock);\n+\n+  if (*error == STATUS_SUCCESS) {\n+    return 0;\n+  } else {\n+    return -1;\n+  }\n+\n+#undef FLUSH_TEXT\n+}\n+\n+\n+int uv_tty_write(uv_loop_t* loop, uv_write_t* req, uv_tty_t* handle,\n+    uv_buf_t bufs[], int bufcnt, uv_write_cb cb) {\n+  DWORD error;\n+\n+  if ((handle->flags & UV_HANDLE_SHUTTING) ||\n+      (handle->flags & UV_HANDLE_CLOSING)) {\n+    uv__set_sys_error(loop, WSAESHUTDOWN);\n+    return -1;\n+  }\n+\n+  uv_req_init(loop, (uv_req_t*) req);\n+  req->type = UV_WRITE;\n+  req->handle = (uv_stream_t*) handle;\n+  req->cb = cb;\n+\n+  handle->reqs_pending++;\n+  handle->write_reqs_pending++;\n+\n+  req->queued_bytes = 0;\n+\n+  if (!uv_tty_write_bufs(handle, bufs, bufcnt, &error)) {\n+    SET_REQ_SUCCESS(req);\n+  } else {\n+    SET_REQ_ERROR(req, error);\n+  }\n+\n+  uv_insert_pending_req(loop, (uv_req_t*) req);\n+\n+  return 0;\n+}\n+\n+\n+void uv_process_tty_write_req(uv_loop_t* loop, uv_tty_t* handle,\n+  uv_write_t* req) {\n+\n+  handle->write_queue_size -= req->queued_bytes;\n+\n+  if (req->cb) {\n+    uv__set_sys_error(loop, GET_REQ_ERROR(req));\n+    ((uv_write_cb)req->cb)(req, loop->last_err.code == UV_OK ? 0 : -1);\n+  }\n+\n+  handle->write_reqs_pending--;\n+  if (handle->flags & UV_HANDLE_SHUTTING &&\n+      handle->write_reqs_pending == 0) {\n+    uv_want_endgame(loop, (uv_handle_t*)handle);\n+  }\n+\n+  DECREASE_PENDING_REQ_COUNT(handle);\n+}\n+\n+\n+void uv_tty_close(uv_tty_t* handle) {\n+  uv_tty_read_stop(handle);\n+  CloseHandle(handle->handle);\n+\n+  if (handle->reqs_pending == 0) {\n+    uv_want_endgame(handle->loop, (uv_handle_t*) handle);\n+  }\n+}\n+\n+\n+void uv_tty_endgame(uv_loop_t* loop, uv_tty_t* handle) {\n+  if (handle->flags & UV_HANDLE_CONNECTION &&\n+      handle->flags & UV_HANDLE_SHUTTING &&\n+      !(handle->flags & UV_HANDLE_SHUT) &&\n+      handle->write_reqs_pending == 0) {\n+    handle->flags |= UV_HANDLE_SHUT;\n+\n+    /* TTY shutdown is really just a no-op */\n+    if (handle->shutdown_req->cb) {\n+      handle->shutdown_req->cb(handle->shutdown_req, 0);\n+    }\n+\n+    DECREASE_PENDING_REQ_COUNT(handle);\n+    return;\n+  }\n+\n+  if (handle->flags & UV_HANDLE_CLOSING &&\n+      handle->reqs_pending == 0) {\n+    /* The console handle duplicate used for line reading should be destroyed */\n+    /* by uv_tty_read_stop. */\n+    assert(handle->read_line_handle == NULL);\n+\n+    /* The wait handle used for raw reading should be unregistered when the */\n+    /* wait callback runs. */\n+    assert(handle->read_raw_wait == NULL);\n+\n+    assert(!(handle->flags & UV_HANDLE_CLOSED));\n+    handle->flags |= UV_HANDLE_CLOSED;\n+\n+    if (handle->close_cb) {\n+      handle->close_cb((uv_handle_t*)handle);\n+    }\n+\n+    uv_unref(loop);\n+  }\n+}\n+\n+\n+/* TODO: remove me */\n+void uv_process_tty_accept_req(uv_loop_t* loop, uv_tty_t* handle,\n+    uv_req_t* raw_req) {\n+  abort();\n+}\n+\n+\n+/* TODO: remove me */\n+void uv_process_tty_connect_req(uv_loop_t* loop, uv_tty_t* handle,\n+    uv_connect_t* req) {\n+  abort();\n+}\n+\n \n-  return UV_UNKNOWN_HANDLE;\n+void uv_tty_reset_mode() {\n+  /* Not necessary to do anything. */\n+  ;\n }"}, {"sha": "07082ddb5d421dcb844ae4185cbad066801879fc", "filename": "src/rt/libuv/src/win/udp.c", "status": "modified", "additions": 97, "deletions": 131, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fudp.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fudp.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fudp.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -24,17 +24,15 @@\n #include \"uv.h\"\n #include \"../uv-common.h\"\n #include \"internal.h\"\n-#include <stdio.h>\n \n-#if 0\n+\n /*\n  * Threshold of active udp streams for which to preallocate udp read buffers.\n  */\n const unsigned int uv_active_udp_streams_threshold = 0;\n \n /* A zero-size buffer for use by uv_udp_read */\n static char uv_zero_[] = \"\";\n-#endif\n \n /* Counter to keep track of active udp streams */\n static unsigned int active_udp_streams = 0;\n@@ -46,13 +44,13 @@ int uv_udp_getsockname(uv_udp_t* handle, struct sockaddr* name,\n   int result;\n \n   if (!(handle->flags & UV_HANDLE_BOUND)) {\n-    uv_set_sys_error(loop, WSAEINVAL);\n+    uv__set_sys_error(loop, WSAEINVAL);\n     return -1;\n   }\n \n   result = getsockname(handle->socket, name, namelen);\n   if (result != 0) {\n-    uv_set_sys_error(loop, WSAGetLastError());\n+    uv__set_sys_error(loop, WSAGetLastError());\n     return -1;\n   }\n \n@@ -63,18 +61,20 @@ int uv_udp_getsockname(uv_udp_t* handle, struct sockaddr* name,\n static int uv_udp_set_socket(uv_loop_t* loop, uv_udp_t* handle,\n     SOCKET socket) {\n   DWORD yes = 1;\n+  WSAPROTOCOL_INFOW info;\n+  int opt_len;\n \n   assert(handle->socket == INVALID_SOCKET);\n \n   /* Set the socket to nonblocking mode */\n   if (ioctlsocket(socket, FIONBIO, &yes) == SOCKET_ERROR) {\n-    uv_set_sys_error(loop, WSAGetLastError());\n+    uv__set_sys_error(loop, WSAGetLastError());\n     return -1;\n   }\n \n   /* Make the socket non-inheritable */\n   if (!SetHandleInformation((HANDLE)socket, HANDLE_FLAG_INHERIT, 0)) {\n-    uv_set_sys_error(loop, GetLastError());\n+    uv__set_sys_error(loop, GetLastError());\n     return -1;\n   }\n \n@@ -84,18 +84,38 @@ static int uv_udp_set_socket(uv_loop_t* loop, uv_udp_t* handle,\n                              loop->iocp,\n                              (ULONG_PTR)socket,\n                              0) == NULL) {\n-    uv_set_sys_error(loop, GetLastError());\n+    uv__set_sys_error(loop, GetLastError());\n     return -1;\n   }\n \n   if (pSetFileCompletionNotificationModes) {\n-    if (!pSetFileCompletionNotificationModes((HANDLE)socket,\n-       FILE_SKIP_SET_EVENT_ON_HANDLE | FILE_SKIP_COMPLETION_PORT_ON_SUCCESS)) {\n-      uv_set_sys_error(loop, GetLastError());\n+    /* All know windowses that support SetFileCompletionNotificationModes */\n+    /* have a bug that makes it impossible to use this function in */\n+    /* conjunction with datagram sockets. We can work around that but only */\n+    /* if the user is using the default UDP driver (AFD) and has no other */\n+    /* LSPs stacked on top. Here we check whether that is the case. */\n+    opt_len = (int) sizeof info;\n+    if (!getsockopt(socket,\n+                   SOL_SOCKET,\n+                   SO_PROTOCOL_INFOW,\n+                   (char*) &info,\n+                   &opt_len) == SOCKET_ERROR) {\n+      uv__set_sys_error(loop, GetLastError());\n       return -1;\n     }\n \n-    handle->flags |= UV_HANDLE_SYNC_BYPASS_IOCP;\n+    if (info.ProtocolChain.ChainLen == 1) {\n+      if (pSetFileCompletionNotificationModes((HANDLE)socket,\n+          FILE_SKIP_SET_EVENT_ON_HANDLE |\n+          FILE_SKIP_COMPLETION_PORT_ON_SUCCESS)) {\n+        handle->flags |= UV_HANDLE_SYNC_BYPASS_IOCP;\n+        handle->func_wsarecv = uv_wsarecv_workaround;\n+        handle->func_wsarecvfrom = uv_wsarecvfrom_workaround;\n+      } else if (GetLastError() != ERROR_INVALID_FUNCTION) {\n+        uv__set_sys_error(loop, GetLastError());\n+        return -1;\n+      }\n+    }\n   }\n \n   handle->socket = socket;\n@@ -110,6 +130,8 @@ int uv_udp_init(uv_loop_t* loop, uv_udp_t* handle) {\n   handle->reqs_pending = 0;\n   handle->loop = loop;\n   handle->flags = 0;\n+  handle->func_wsarecv = WSARecv;\n+  handle->func_wsarecvfrom = WSARecvFrom;\n \n   uv_req_init(loop, (uv_req_t*) &(handle->recv_req));\n   handle->recv_req.type = UV_UDP_RECV;\n@@ -139,26 +161,29 @@ void uv_udp_endgame(uv_loop_t* loop, uv_udp_t* handle) {\n }\n \n \n-static int uv__bind(uv_udp_t* handle, int domain, struct sockaddr* addr,\n-    int addrsize, unsigned int flags) {\n-  uv_loop_t* loop = handle->loop;\n+static int uv__bind(uv_udp_t* handle,\n+                    int domain,\n+                    struct sockaddr* addr,\n+                    int addrsize,\n+                    unsigned int flags) {\n   DWORD err;\n   int r;\n   SOCKET sock;\n \n   if ((flags & UV_UDP_IPV6ONLY) && domain != AF_INET6) {\n     /* UV_UDP_IPV6ONLY is supported only for IPV6 sockets */\n-    uv_set_sys_error(loop, UV_EINVAL);\n+    uv__set_artificial_error(handle->loop, UV_EINVAL);\n+    return -1;\n   }\n \n   if (handle->socket == INVALID_SOCKET) {\n     sock = socket(domain, SOCK_DGRAM, 0);\n     if (sock == INVALID_SOCKET) {\n-      uv_set_sys_error(loop, WSAGetLastError());\n+      uv__set_sys_error(handle->loop, WSAGetLastError());\n       return -1;\n     }\n \n-    if (uv_udp_set_socket(loop, handle, sock) == -1) {\n+    if (uv_udp_set_socket(handle->loop, handle, sock) == -1) {\n       closesocket(sock);\n       return -1;\n     }\n@@ -183,7 +208,7 @@ static int uv__bind(uv_udp_t* handle, int domain, struct sockaddr* addr,\n \n   if (r == SOCKET_ERROR) {\n     err = WSAGetLastError();\n-    uv_set_sys_error(loop, WSAGetLastError());\n+    uv__set_sys_error(handle->loop, WSAGetLastError());\n     return -1;\n   }\n \n@@ -193,15 +218,8 @@ static int uv__bind(uv_udp_t* handle, int domain, struct sockaddr* addr,\n }\n \n \n-int uv_udp_bind(uv_udp_t* handle, struct sockaddr_in addr,\n+int uv__udp_bind(uv_udp_t* handle, struct sockaddr_in addr,\n     unsigned int flags) {\n-  uv_loop_t* loop = handle->loop;\n-\n-  if (addr.sin_family != AF_INET) {\n-    uv_set_sys_error(loop, WSAEFAULT);\n-    return -1;\n-  }\n-\n   return uv__bind(handle,\n                   AF_INET,\n                   (struct sockaddr*) &addr,\n@@ -210,15 +228,8 @@ int uv_udp_bind(uv_udp_t* handle, struct sockaddr_in addr,\n }\n \n \n-int uv_udp_bind6(uv_udp_t* handle, struct sockaddr_in6 addr,\n+int uv__udp_bind6(uv_udp_t* handle, struct sockaddr_in6 addr,\n     unsigned int flags) {\n-  uv_loop_t* loop = handle->loop;\n-\n-  if (addr.sin6_family != AF_INET6) {\n-    uv_set_sys_error(loop, WSAEFAULT);\n-    return -1;\n-  }\n-\n   if (uv_allow_ipv6) {\n     handle->flags |= UV_HANDLE_IPV6;\n     return uv__bind(handle,\n@@ -227,12 +238,21 @@ int uv_udp_bind6(uv_udp_t* handle, struct sockaddr_in6 addr,\n                     sizeof(struct sockaddr_in6),\n                     flags);\n   } else {\n-    uv_new_sys_error(WSAEAFNOSUPPORT);\n+    uv__set_sys_error(handle->loop, WSAEAFNOSUPPORT);\n     return -1;\n   }\n }\n \n \n+int uv_udp_set_membership(uv_udp_t* handle, const char* multicast_addr,\n+  const char* interface_addr, uv_membership membership) {\n+\n+  /* not implemented yet */\n+  uv__set_artificial_error(handle->loop, UV_ENOSYS);\n+  return -1;\n+}\n+\n+\n static void uv_udp_queue_recv(uv_loop_t* loop, uv_udp_t* handle) {\n   uv_req_t* req;\n   uv_buf_t buf;\n@@ -249,10 +269,9 @@ static void uv_udp_queue_recv(uv_loop_t* loop, uv_udp_t* handle) {\n    * Preallocate a read buffer if the number of active streams is below\n    * the threshold.\n   */\n-#if 0\n   if (active_udp_streams < uv_active_udp_streams_threshold) {\n     handle->flags &= ~UV_HANDLE_ZERO_READ;\n-#endif\n+\n     handle->recv_buffer = handle->alloc_cb((uv_handle_t*) handle, 65536);\n     assert(handle->recv_buffer.len > 0);\n \n@@ -261,15 +280,15 @@ static void uv_udp_queue_recv(uv_loop_t* loop, uv_udp_t* handle) {\n     handle->recv_from_len = sizeof handle->recv_from;\n     flags = 0;\n \n-    result = WSARecvFrom(handle->socket,\n-                      (WSABUF*) &buf,\n-                      1,\n-                      &bytes,\n-                      &flags,\n-                      (struct sockaddr*) &handle->recv_from,\n-                      &handle->recv_from_len,\n-                      &req->overlapped,\n-                      NULL);\n+    result = handle->func_wsarecvfrom(handle->socket,\n+                                      (WSABUF*) &buf,\n+                                      1,\n+                                      &bytes,\n+                                      &flags,\n+                                      (struct sockaddr*) &handle->recv_from,\n+                                      &handle->recv_from_len,\n+                                      &req->overlapped,\n+                                      NULL);\n \n     if (UV_SUCCEEDED_WITHOUT_IOCP(result == 0)) {\n       /* Process the req without IOCP. */\n@@ -287,21 +306,21 @@ static void uv_udp_queue_recv(uv_loop_t* loop, uv_udp_t* handle) {\n       uv_insert_pending_req(loop, req);\n       handle->reqs_pending++;\n     }\n-#if 0\n+\n   } else {\n     handle->flags |= UV_HANDLE_ZERO_READ;\n \n     buf.base = (char*) uv_zero_;\n     buf.len = 0;\n-    flags = MSG_PARTIAL;\n+    flags = MSG_PEEK;\n \n-    result = WSARecv(handle->socket,\n-                     (WSABUF*) &buf,\n-                     1,\n-                     &bytes,\n-                     &flags,\n-                     &req->overlapped,\n-                     NULL);\n+    result = handle->func_wsarecv(handle->socket,\n+                                  (WSABUF*) &buf,\n+                                  1,\n+                                  &bytes,\n+                                  &flags,\n+                                  &req->overlapped,\n+                                  NULL);\n \n     if (UV_SUCCEEDED_WITHOUT_IOCP(result == 0)) {\n       /* Process the req without IOCP. */\n@@ -320,7 +339,6 @@ static void uv_udp_queue_recv(uv_loop_t* loop, uv_udp_t* handle) {\n       handle->reqs_pending++;\n     }\n   }\n-#endif\n }\n \n \n@@ -329,7 +347,7 @@ int uv_udp_recv_start(uv_udp_t* handle, uv_alloc_cb alloc_cb,\n   uv_loop_t* loop = handle->loop;\n \n   if (handle->flags & UV_HANDLE_READING) {\n-    uv_set_sys_error(loop, WSAEALREADY);\n+    uv__set_sys_error(loop, WSAEALREADY);\n     return -1;\n   }\n \n@@ -363,55 +381,6 @@ int uv_udp_recv_stop(uv_udp_t* handle) {\n }\n \n \n-int uv_udp_connect6(uv_connect_t* req, uv_udp_t* handle,\n-    struct sockaddr_in6 address, uv_connect_cb cb) {\n-  uv_loop_t* loop = handle->loop;\n-  int addrsize = sizeof(struct sockaddr_in6);\n-  BOOL success;\n-  DWORD bytes;\n-\n-  if (!uv_allow_ipv6) {\n-    uv_new_sys_error(WSAEAFNOSUPPORT);\n-    return -1;\n-  }\n-\n-  if (address.sin6_family != AF_INET6) {\n-    uv_set_sys_error(loop, WSAEFAULT);\n-    return -1;\n-  }\n-\n-  if (!(handle->flags & UV_HANDLE_BOUND) &&\n-      uv_udp_bind6(handle, uv_addr_ip6_any_, 0) < 0)\n-    return -1;\n-\n-  uv_req_init(loop, (uv_req_t*) req);\n-  req->type = UV_CONNECT;\n-  req->handle = (uv_stream_t*) handle;\n-  req->cb = cb;\n-  memset(&req->overlapped, 0, sizeof(req->overlapped));\n-\n-  success = pConnectEx6(handle->socket,\n-                       (struct sockaddr*) &address,\n-                       addrsize,\n-                       NULL,\n-                       0,\n-                       &bytes,\n-                       &req->overlapped);\n-\n-  if (UV_SUCCEEDED_WITHOUT_IOCP(success)) {\n-    handle->reqs_pending++;\n-    uv_insert_pending_req(loop, (uv_req_t*)req);\n-  } else if (UV_SUCCEEDED_WITH_IOCP(success)) {\n-    handle->reqs_pending++;\n-  } else {\n-    uv_set_sys_error(loop, WSAGetLastError());\n-    return -1;\n-  }\n-\n-  return 0;\n-}\n-\n-\n static int uv__udp_send(uv_udp_send_t* req, uv_udp_t* handle, uv_buf_t bufs[],\n     int bufcnt, struct sockaddr* addr, int addr_len, uv_udp_send_cb cb) {\n   uv_loop_t* loop = handle->loop;\n@@ -444,7 +413,7 @@ static int uv__udp_send(uv_udp_send_t* req, uv_udp_t* handle, uv_buf_t bufs[],\n     handle->reqs_pending++;\n   } else {\n     /* Send failed due to an error. */\n-    uv_set_sys_error(loop, WSAGetLastError());\n+    uv__set_sys_error(loop, WSAGetLastError());\n     return -1;\n   }\n \n@@ -498,34 +467,27 @@ void uv_process_udp_recv_req(uv_loop_t* loop, uv_udp_t* handle,\n   handle->flags &= ~UV_HANDLE_READ_PENDING;\n \n   if (!REQ_SUCCESS(req) &&\n-      GET_REQ_STATUS(req) != STATUS_RECEIVE_EXPEDITED) {\n+      GET_REQ_SOCK_ERROR(req) != WSAEMSGSIZE) {\n     /* An error occurred doing the read. */\n-    if ((handle->flags & UV_HANDLE_READING)) {\n-      loop->last_error = GET_REQ_UV_SOCK_ERROR(req);\n+    if (handle->flags & UV_HANDLE_READING) {\n+      uv__set_sys_error(loop, GET_REQ_SOCK_ERROR(req));\n       uv_udp_recv_stop(handle);\n-#if 0\n       buf = (handle->flags & UV_HANDLE_ZERO_READ) ?\n             uv_buf_init(NULL, 0) : handle->recv_buffer;\n-#else\n-      buf = handle->recv_buffer;\n-#endif\n       handle->recv_cb(handle, -1, buf, NULL, 0);\n     }\n     goto done;\n   }\n \n-#if 0\n   if (!(handle->flags & UV_HANDLE_ZERO_READ)) {\n-#endif\n     /* Successful read */\n-    partial = (GET_REQ_STATUS(req) == STATUS_RECEIVE_EXPEDITED);\n+    partial = !REQ_SUCCESS(req);\n     handle->recv_cb(handle,\n                     req->overlapped.InternalHigh,\n                     handle->recv_buffer,\n                     (struct sockaddr*) &handle->recv_from,\n                     partial ? UV_UDP_PARTIAL : 0);\n-#if 0\n-  } else {\n+  } else if (handle->flags & UV_HANDLE_READING) {\n     DWORD bytes, err, flags;\n     struct sockaddr_storage from;\n     int from_len;\n@@ -537,7 +499,8 @@ void uv_process_udp_recv_req(uv_loop_t* loop, uv_udp_t* handle,\n \n     memset(&from, 0, sizeof from);\n     from_len = sizeof from;\n-    flags = MSG_PARTIAL;\n+\n+    flags = 0;\n \n     if (WSARecvFrom(handle->socket,\n                     (WSABUF*)&buf,\n@@ -550,24 +513,27 @@ void uv_process_udp_recv_req(uv_loop_t* loop, uv_udp_t* handle,\n                     NULL) != SOCKET_ERROR) {\n \n       /* Message received */\n-      handle->recv_cb(handle,\n-                      bytes,\n-                      buf,\n-                      (struct sockaddr*) &from,\n-                        (flags & MSG_PARTIAL) ? UV_UDP_PARTIAL : 0);\n+      handle->recv_cb(handle, bytes, buf, (struct sockaddr*) &from, 0);\n     } else {\n       err = WSAGetLastError();\n-      if (err == WSAEWOULDBLOCK) {\n-        uv_set_sys_error(loop, WSAEWOULDBLOCK);\n+      if (err == WSAEMSGSIZE) {\n+        /* Message truncated */\n+        handle->recv_cb(handle,\n+                        bytes,\n+                        buf,\n+                        (struct sockaddr*) &from,\n+                        UV_UDP_PARTIAL);\n+      } if (err == WSAEWOULDBLOCK) {\n+        /* Kernel buffer empty */\n+        uv__set_sys_error(loop, WSAEWOULDBLOCK);\n         handle->recv_cb(handle, 0, buf, NULL, 0);\n       } else {\n         /* Ouch! serious error. */\n-        uv_set_sys_error(loop, err);\n+        uv__set_sys_error(loop, err);\n         handle->recv_cb(handle, -1, buf, NULL, 0);\n       }\n     }\n   }\n-#endif\n \n done:\n   /* Post another read if still reading and not closing. */\n@@ -588,7 +554,7 @@ void uv_process_udp_send_req(uv_loop_t* loop, uv_udp_t* handle,\n     if (REQ_SUCCESS(req)) {\n       req->cb(req, 0);\n     } else {\n-      loop->last_error = GET_REQ_UV_SOCK_ERROR(req);\n+      uv__set_sys_error(loop, GET_REQ_SOCK_ERROR(req));\n       req->cb(req, -1);\n     }\n   }"}, {"sha": "3bc3e1dbd43ea3a8909e818ce54085c06ab79eec", "filename": "src/rt/libuv/src/win/util.c", "status": "modified", "additions": 58, "deletions": 2, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Futil.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Futil.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Futil.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -25,6 +25,7 @@\n \n #include \"uv.h\"\n #include \"internal.h\"\n+#include \"Tlhelp32.h\"\n \n \n int uv_utf16_to_utf8(const wchar_t* utf16Buffer, size_t utf16Size,\n@@ -69,7 +70,7 @@ int uv_exepath(char* buffer, size_t* size) {\n   /* Get the path as UTF-16 */\n   utf16Size = GetModuleFileNameW(NULL, utf16Buffer, *size - 1);\n   if (utf16Size <= 0) {\n-    /* uv_set_sys_error(loop, GetLastError()); */\n+    /* uv__set_sys_error(loop, GetLastError()); */\n     retVal = -1;\n     goto done;\n   }\n@@ -79,7 +80,7 @@ int uv_exepath(char* buffer, size_t* size) {\n   /* Convert to UTF-8 */\n   *size = uv_utf16_to_utf8(utf16Buffer, utf16Size, buffer, *size);\n   if (!*size) {\n-    /* uv_set_sys_error(loop, GetLastError()); */\n+    /* uv__set_sys_error(loop, GetLastError()); */\n     retVal = -1;\n     goto done;\n   }\n@@ -94,3 +95,58 @@ int uv_exepath(char* buffer, size_t* size) {\n \n   return retVal;\n }\n+\n+\n+void uv_loadavg(double avg[3]) {\n+  /* Can't be implemented */\n+  avg[0] = avg[1] = avg[2] = 0;\n+}\n+\n+\n+uint64_t uv_get_free_memory(void) {\n+  MEMORYSTATUSEX memory_status;\n+  memory_status.dwLength = sizeof(memory_status);\n+\n+  if(!GlobalMemoryStatusEx(&memory_status))\n+  {\n+     return -1;\n+  }\n+\n+  return (uint64_t)memory_status.ullAvailPhys;\n+}\n+\n+\n+uint64_t uv_get_total_memory(void) {\n+  MEMORYSTATUSEX memory_status;\n+  memory_status.dwLength = sizeof(memory_status);\n+\n+  if(!GlobalMemoryStatusEx(&memory_status))\n+  {\n+    return -1;\n+  }\n+\n+  return (uint64_t)memory_status.ullTotalPhys;\n+}\n+\n+\n+int uv_parent_pid() {\n+  int parent_pid = -1;\n+  HANDLE handle;\n+  PROCESSENTRY32 pe;\n+  int current_pid = GetCurrentProcessId();\n+\n+  pe.dwSize = sizeof(PROCESSENTRY32);\n+  handle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n+\n+  if (Process32First(handle, &pe)) {\n+    do {\n+      if (pe.th32ProcessID == current_pid) {\n+        parent_pid = pe.th32ParentProcessID;\n+        break;\n+      }\n+    } while( Process32Next(handle, &pe));\n+  }\n+\n+  CloseHandle(handle);\n+  return parent_pid;\n+}"}, {"sha": "cc21361bc70cca68f420176011df6f648d3bb17b", "filename": "src/rt/libuv/src/win/winapi.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinapi.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinapi.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinapi.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -27,11 +27,12 @@\n \n \n sRtlNtStatusToDosError pRtlNtStatusToDosError;\n+sNtDeviceIoControlFile pNtDeviceIoControlFile;\n sNtQueryInformationFile pNtQueryInformationFile;\n sNtSetInformationFile pNtSetInformationFile;\n sGetQueuedCompletionStatusEx pGetQueuedCompletionStatusEx;\n sSetFileCompletionNotificationModes pSetFileCompletionNotificationModes;\n-sCreateSymbolicLinkA pCreateSymbolicLinkA;\n+sCreateSymbolicLinkW pCreateSymbolicLinkW;\n \n \n void uv_winapi_init() {\n@@ -57,6 +58,13 @@ void uv_winapi_init() {\n     uv_fatal_error(GetLastError(), \"GetProcAddress\");\n   }\n \n+  pNtDeviceIoControlFile = (sNtDeviceIoControlFile) GetProcAddress(\n+      ntdll_module,\n+      \"NtDeviceIoControlFile\");\n+  if (pNtDeviceIoControlFile == NULL) {\n+    uv_fatal_error(GetLastError(), \"GetProcAddress\");\n+  }\n+\n   pNtSetInformationFile = (sNtSetInformationFile) GetProcAddress(\n       ntdll_module,\n       \"NtSetInformationFile\");\n@@ -76,6 +84,6 @@ void uv_winapi_init() {\n   pSetFileCompletionNotificationModes = (sSetFileCompletionNotificationModes)\n     GetProcAddress(kernel32_module, \"SetFileCompletionNotificationModes\");\n \n-  pCreateSymbolicLinkA = (sCreateSymbolicLinkA)\n-    GetProcAddress(kernel32_module, \"CreateSymbolicLinkA\");\n+  pCreateSymbolicLinkW = (sCreateSymbolicLinkW)\n+    GetProcAddress(kernel32_module, \"CreateSymbolicLinkW\");\n }"}, {"sha": "e0038f14aca5172473fe8e5b31a878586785a1eb", "filename": "src/rt/libuv/src/win/winapi.h", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinapi.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinapi.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinapi.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -4137,6 +4137,13 @@ typedef struct _FILE_BASIC_INFORMATION {\n   DWORD FileAttributes;\n } FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;\n \n+typedef struct _FILE_MODE_INFORMATION {\n+  ULONG Mode;\n+} FILE_MODE_INFORMATION, *PFILE_MODE_INFORMATION;\n+\n+#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010\n+#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020\n+\n typedef enum _FILE_INFORMATION_CLASS {\n   FileDirectoryInformation = 1,\n   FileFullDirectoryInformation,\n@@ -4204,6 +4211,10 @@ typedef enum _FILE_INFORMATION_CLASS {\n # define FILE_DEVICE_FILE_SYSTEM 0x00000009\n #endif\n \n+#ifndef FILE_DEVICE_NETWORK\n+# define FILE_DEVICE_NETWORK 0x00000012\n+#endif\n+\n #ifndef METHOD_BUFFERED\n # define METHOD_BUFFERED 0\n #endif\n@@ -4270,9 +4281,26 @@ typedef enum _FILE_INFORMATION_CLASS {\n                                              FILE_SPECIAL_ACCESS)\n #endif\n \n+typedef VOID (NTAPI *PIO_APC_ROUTINE)\n+             (PVOID ApcContext,\n+              PIO_STATUS_BLOCK IoStatusBlock,\n+              ULONG Reserved);\n+\n typedef ULONG (NTAPI *sRtlNtStatusToDosError)\n               (NTSTATUS Status);\n \n+typedef NTSTATUS (NTAPI *sNtDeviceIoControlFile)\n+                 (HANDLE FileHandle,\n+                  HANDLE Event,\n+                  PIO_APC_ROUTINE ApcRoutine,\n+                  PVOID ApcContext,\n+                  PIO_STATUS_BLOCK IoStatusBlock,\n+                  ULONG IoControlCode,\n+                  PVOID InputBuffer,\n+                  ULONG InputBufferLength,\n+                  PVOID OutputBuffer,\n+                  ULONG OutputBufferLength);\n+\n typedef NTSTATUS (NTAPI *sNtQueryInformationFile)\n                  (HANDLE FileHandle,\n                   PIO_STATUS_BLOCK IoStatusBlock,\n@@ -4317,21 +4345,22 @@ typedef BOOL (WINAPI* sSetFileCompletionNotificationModes)\n              (HANDLE FileHandle,\n               UCHAR Flags);\n \n-typedef BOOLEAN (WINAPI* sCreateSymbolicLinkA)\n-                (LPCSTR lpSymlinkFileName,\n-                 LPCSTR lpTargetFileName,\n+typedef BOOLEAN (WINAPI* sCreateSymbolicLinkW)\n+                (LPCWSTR lpSymlinkFileName,\n+                 LPCWSTR lpTargetFileName,\n                  DWORD dwFlags);\n \n \n /* Ntapi function pointers */\n extern sRtlNtStatusToDosError pRtlNtStatusToDosError;\n+extern sNtDeviceIoControlFile pNtDeviceIoControlFile;\n extern sNtQueryInformationFile pNtQueryInformationFile;\n extern sNtSetInformationFile pNtSetInformationFile;\n \n \n /* Kernel32 function pointers */\n extern sGetQueuedCompletionStatusEx pGetQueuedCompletionStatusEx;\n extern sSetFileCompletionNotificationModes pSetFileCompletionNotificationModes;\n-extern sCreateSymbolicLinkA pCreateSymbolicLinkA;\n+extern sCreateSymbolicLinkW pCreateSymbolicLinkW;\n \n #endif /* UV_WIN_WINAPI_H_ */"}, {"sha": "5309f1eedb17a6359b46bef143df5c1af77e77a6", "filename": "src/rt/libuv/src/win/winsock.c", "status": "modified", "additions": 220, "deletions": 65, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinsock.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinsock.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinsock.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -25,21 +25,6 @@\n #include \"../uv-common.h\"\n #include \"internal.h\"\n \n-\n-/* Winsock extension functions (ipv4) */\n-LPFN_CONNECTEX pConnectEx;\n-LPFN_ACCEPTEX pAcceptEx;\n-LPFN_GETACCEPTEXSOCKADDRS pGetAcceptExSockAddrs;\n-LPFN_DISCONNECTEX pDisconnectEx;\n-LPFN_TRANSMITFILE pTransmitFile;\n-\n-/* Winsock extension functions (ipv6) */\n-LPFN_CONNECTEX pConnectEx6;\n-LPFN_ACCEPTEX pAcceptEx6;\n-LPFN_GETACCEPTEXSOCKADDRS pGetAcceptExSockAddrs6;\n-LPFN_DISCONNECTEX pDisconnectEx6;\n-LPFN_TRANSMITFILE  pTransmitFile6;\n-\n /* Whether ipv6 is supported */\n int uv_allow_ipv6;\n \n@@ -74,6 +59,18 @@ static BOOL uv_get_extension_function(SOCKET socket, GUID guid,\n }\n \n \n+BOOL uv_get_acceptex_function(SOCKET socket, LPFN_ACCEPTEX* target) {\n+  const GUID wsaid_acceptex = WSAID_ACCEPTEX;\n+  return uv_get_extension_function(socket, wsaid_acceptex, (void**)target);\n+}\n+\n+\n+BOOL uv_get_connectex_function(SOCKET socket, LPFN_CONNECTEX* target) {\n+  const GUID wsaid_connectex = WSAID_CONNECTEX;\n+  return uv_get_extension_function(socket, wsaid_connectex, (void**)target);\n+}\n+\n+\n void uv_winsock_init() {\n   const GUID wsaid_connectex            = WSAID_CONNECTEX;\n   const GUID wsaid_acceptex             = WSAID_ACCEPTEX;\n@@ -83,7 +80,6 @@ void uv_winsock_init() {\n \n   WSADATA wsa_data;\n   int errorno;\n-  SOCKET dummy;\n   SOCKET dummy6;\n \n   /* Initialize winsock */\n@@ -96,58 +92,10 @@ void uv_winsock_init() {\n   uv_addr_ip4_any_ = uv_ip4_addr(\"0.0.0.0\", 0);\n   uv_addr_ip6_any_ = uv_ip6_addr(\"::\", 0);\n \n-  /* Retrieve the needed winsock extension function pointers. */\n-  dummy = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);\n-  if (dummy == INVALID_SOCKET) {\n-    uv_fatal_error(WSAGetLastError(), \"socket\");\n-  }\n-\n-  if (!uv_get_extension_function(dummy,\n-                            wsaid_connectex,\n-                            (void**)&pConnectEx) ||\n-      !uv_get_extension_function(dummy,\n-                            wsaid_acceptex,\n-                            (void**)&pAcceptEx) ||\n-      !uv_get_extension_function(dummy,\n-                            wsaid_getacceptexsockaddrs,\n-                            (void**)&pGetAcceptExSockAddrs) ||\n-      !uv_get_extension_function(dummy,\n-                            wsaid_disconnectex,\n-                            (void**)&pDisconnectEx) ||\n-      !uv_get_extension_function(dummy,\n-                            wsaid_transmitfile,\n-                            (void**)&pTransmitFile)) {\n-    uv_fatal_error(WSAGetLastError(),\n-                   \"WSAIoctl(SIO_GET_EXTENSION_FUNCTION_POINTER)\");\n-  }\n-\n-  if (closesocket(dummy) == SOCKET_ERROR) {\n-    uv_fatal_error(WSAGetLastError(), \"closesocket\");\n-  }\n-\n-  /* optional IPv6 versions of winsock extension functions */\n+  /* Detect IPV6 support */\n   dummy6 = socket(AF_INET6, SOCK_STREAM, IPPROTO_IP);\n   if (dummy6 != INVALID_SOCKET) {\n     uv_allow_ipv6 = TRUE;\n-\n-    if (!uv_get_extension_function(dummy6,\n-                              wsaid_connectex,\n-                              (void**)&pConnectEx6) ||\n-        !uv_get_extension_function(dummy6,\n-                              wsaid_acceptex,\n-                              (void**)&pAcceptEx6) ||\n-        !uv_get_extension_function(dummy6,\n-                              wsaid_getacceptexsockaddrs,\n-                              (void**)&pGetAcceptExSockAddrs6) ||\n-        !uv_get_extension_function(dummy6,\n-                              wsaid_disconnectex,\n-                              (void**)&pDisconnectEx6) ||\n-        !uv_get_extension_function(dummy6,\n-                              wsaid_transmitfile,\n-                              (void**)&pTransmitFile6)) {\n-      uv_allow_ipv6 = FALSE;\n-    }\n-\n     if (closesocket(dummy6) == SOCKET_ERROR) {\n       uv_fatal_error(WSAGetLastError(), \"closesocket\");\n     }\n@@ -268,3 +216,210 @@ int uv_ntstatus_to_winsock_error(NTSTATUS status) {\n       }\n   }\n }\n+\n+\n+/*\n+ * This function provides a workaround for a bug in the winsock implementation\n+ * of WSARecv. The problem is that when SetFileCompletionNotificationModes is\n+ * used to avoid IOCP notifications of completed reads, WSARecv does not\n+ * reliably indicate whether we can expect a completion package to be posted\n+ * when the receive buffer is smaller than the received datagram.\n+ *\n+ * However it is desirable to use SetFileCompletionNotificationModes because\n+ * it yields a massive performance increase.\n+ *\n+ * This function provides a workaround for that bug, but it only works for the\n+ * specific case that we need it for. E.g. it assumes that the \"avoid iocp\"\n+ * bit has been set, and supports only overlapped operation. It also requires\n+ * the user to use the default msafd driver, doesn't work when other LSPs are\n+ * stacked on top of it.\n+ */\n+int WSAAPI uv_wsarecv_workaround(SOCKET socket, WSABUF* buffers,\n+    DWORD buffer_count, DWORD* bytes, DWORD* flags, WSAOVERLAPPED *overlapped,\n+    LPWSAOVERLAPPED_COMPLETION_ROUTINE completion_routine) {\n+  NTSTATUS status;\n+  void* apc_context;\n+  IO_STATUS_BLOCK* iosb = (IO_STATUS_BLOCK*) &overlapped->Internal;\n+  AFD_RECV_INFO info;\n+  DWORD error;\n+\n+  if (overlapped == NULL || completion_routine != NULL) {\n+    WSASetLastError(WSAEINVAL);\n+    return SOCKET_ERROR;\n+  }\n+\n+  info.BufferArray = buffers;\n+  info.BufferCount = buffer_count;\n+  info.AfdFlags = AFD_OVERLAPPED;\n+  info.TdiFlags = TDI_RECEIVE_NORMAL;\n+\n+  if (*flags & MSG_PEEK) {\n+    info.TdiFlags |= TDI_RECEIVE_PEEK;\n+  }\n+\n+  if (*flags & MSG_PARTIAL) {\n+    info.TdiFlags |= TDI_RECEIVE_PARTIAL;\n+  }\n+\n+  if (!((intptr_t) overlapped->hEvent & 1)) {\n+    apc_context = (void*) overlapped;\n+  } else {\n+    apc_context = NULL;\n+  }\n+\n+  iosb->Status = STATUS_PENDING;\n+  iosb->Pointer = 0;\n+\n+  status = pNtDeviceIoControlFile((HANDLE) socket,\n+                                  overlapped->hEvent,\n+                                  NULL,\n+                                  apc_context,\n+                                  iosb,\n+                                  IOCTL_AFD_RECEIVE,\n+                                  &info,\n+                                  sizeof(info),\n+                                  NULL,\n+                                  0);\n+\n+  *flags = 0;\n+  *bytes = (DWORD) iosb->Information;\n+\n+  switch (status) {\n+    case STATUS_SUCCESS:\n+      error = ERROR_SUCCESS;\n+      break;\n+\n+    case STATUS_PENDING:\n+      error = WSA_IO_PENDING;\n+      break;\n+\n+    case STATUS_BUFFER_OVERFLOW:\n+      error = WSAEMSGSIZE;\n+      break;\n+\n+    case STATUS_RECEIVE_EXPEDITED:\n+      error = ERROR_SUCCESS;\n+      *flags = MSG_OOB;\n+      break;\n+\n+    case STATUS_RECEIVE_PARTIAL_EXPEDITED:\n+      error = ERROR_SUCCESS;\n+      *flags = MSG_PARTIAL | MSG_OOB;\n+      break;\n+\n+    case STATUS_RECEIVE_PARTIAL:\n+      error = ERROR_SUCCESS;\n+      *flags = MSG_PARTIAL;\n+      break;\n+\n+    default:\n+      error = uv_ntstatus_to_winsock_error(status);\n+      break;\n+  }\n+\n+  WSASetLastError(error);\n+\n+  if (error == ERROR_SUCCESS) {\n+    return 0;\n+  } else {\n+    return SOCKET_ERROR;\n+  }\n+}\n+\n+\n+/* See description of uv_wsarecv_workaround. */\n+int WSAAPI uv_wsarecvfrom_workaround(SOCKET socket, WSABUF* buffers,\n+    DWORD buffer_count, DWORD* bytes, DWORD* flags, struct sockaddr* addr,\n+    int* addr_len, WSAOVERLAPPED *overlapped,\n+    LPWSAOVERLAPPED_COMPLETION_ROUTINE completion_routine) {\n+  NTSTATUS status;\n+  void* apc_context;\n+  IO_STATUS_BLOCK* iosb = (IO_STATUS_BLOCK*) &overlapped->Internal;\n+  AFD_RECV_DATAGRAM_INFO info;\n+  DWORD error;\n+\n+  if (overlapped == NULL || addr == NULL || addr_len == NULL ||\n+      completion_routine != NULL) {\n+    WSASetLastError(WSAEINVAL);\n+    return SOCKET_ERROR;\n+  }\n+\n+  info.BufferArray = buffers;\n+  info.BufferCount = buffer_count;\n+  info.AfdFlags = AFD_OVERLAPPED;\n+  info.TdiFlags = TDI_RECEIVE_NORMAL;\n+  info.Address = addr;\n+  info.AddressLength = addr_len;\n+\n+  if (*flags & MSG_PEEK) {\n+    info.TdiFlags |= TDI_RECEIVE_PEEK;\n+  }\n+\n+  if (*flags & MSG_PARTIAL) {\n+    info.TdiFlags |= TDI_RECEIVE_PARTIAL;\n+  }\n+\n+  if (!((intptr_t) overlapped->hEvent & 1)) {\n+    apc_context = (void*) overlapped;\n+  } else {\n+    apc_context = NULL;\n+  }\n+\n+  iosb->Status = STATUS_PENDING;\n+  iosb->Pointer = 0;\n+\n+  status = pNtDeviceIoControlFile((HANDLE) socket,\n+                                  overlapped->hEvent,\n+                                  NULL,\n+                                  apc_context,\n+                                  iosb,\n+                                  IOCTL_AFD_RECEIVE_DATAGRAM,\n+                                  &info,\n+                                  sizeof(info),\n+                                  NULL,\n+                                  0);\n+\n+  *flags = 0;\n+  *bytes = (DWORD) iosb->Information;\n+\n+  switch (status) {\n+    case STATUS_SUCCESS:\n+      error = ERROR_SUCCESS;\n+      break;\n+\n+    case STATUS_PENDING:\n+      error = WSA_IO_PENDING;\n+      break;\n+\n+    case STATUS_BUFFER_OVERFLOW:\n+      error = WSAEMSGSIZE;\n+      break;\n+\n+    case STATUS_RECEIVE_EXPEDITED:\n+      error = ERROR_SUCCESS;\n+      *flags = MSG_OOB;\n+      break;\n+\n+    case STATUS_RECEIVE_PARTIAL_EXPEDITED:\n+      error = ERROR_SUCCESS;\n+      *flags = MSG_PARTIAL | MSG_OOB;\n+      break;\n+\n+    case STATUS_RECEIVE_PARTIAL:\n+      error = ERROR_SUCCESS;\n+      *flags = MSG_PARTIAL;\n+      break;\n+\n+    default:\n+      error = uv_ntstatus_to_winsock_error(status);\n+      break;\n+  }\n+\n+  WSASetLastError(error);\n+\n+  if (error == ERROR_SUCCESS) {\n+    return 0;\n+  } else {\n+    return SOCKET_ERROR;\n+  }\n+}"}, {"sha": "beee032137cfa070571b9a4548141905cceb761f", "filename": "src/rt/libuv/src/win/winsock.h", "status": "modified", "additions": 58, "deletions": 86, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinsock.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinsock.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinsock.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -27,76 +27,8 @@\n #include <ws2tcpip.h>\n #include <windows.h>\n \n+#include \"winapi.h\"\n \n-/*\n- * Guids and typedefs for winsock extension functions\n- * Mingw32 doesn't have these :-(\n- */\n-#ifndef WSAID_ACCEPTEX\n-# define WSAID_ACCEPTEX                                        \\\n-         {0xb5367df1, 0xcbac, 0x11cf,                          \\\n-         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}\n-\n-# define WSAID_CONNECTEX                                       \\\n-         {0x25a207b9, 0xddf3, 0x4660,                          \\\n-         {0x8e, 0xe9, 0x76, 0xe5, 0x8c, 0x74, 0x06, 0x3e}}\n-\n-# define WSAID_GETACCEPTEXSOCKADDRS                            \\\n-         {0xb5367df2, 0xcbac, 0x11cf,                          \\\n-         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}\n-\n-# define WSAID_DISCONNECTEX                                    \\\n-         {0x7fda2e11, 0x8630, 0x436f,                          \\\n-         {0xa0, 0x31, 0xf5, 0x36, 0xa6, 0xee, 0xc1, 0x57}}\n-\n-# define WSAID_TRANSMITFILE                                    \\\n-         {0xb5367df0, 0xcbac, 0x11cf,                          \\\n-         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}\n-\n-  typedef BOOL PASCAL (*LPFN_ACCEPTEX)\n-                      (SOCKET sListenSocket,\n-                       SOCKET sAcceptSocket,\n-                       PVOID lpOutputBuffer,\n-                       DWORD dwReceiveDataLength,\n-                       DWORD dwLocalAddressLength,\n-                       DWORD dwRemoteAddressLength,\n-                       LPDWORD lpdwBytesReceived,\n-                       LPOVERLAPPED lpOverlapped);\n-\n-  typedef BOOL PASCAL (*LPFN_CONNECTEX)\n-                      (SOCKET s,\n-                       const struct sockaddr* name,\n-                       int namelen,\n-                       PVOID lpSendBuffer,\n-                       DWORD dwSendDataLength,\n-                       LPDWORD lpdwBytesSent,\n-                       LPOVERLAPPED lpOverlapped);\n-\n-  typedef void PASCAL (*LPFN_GETACCEPTEXSOCKADDRS)\n-                      (PVOID lpOutputBuffer,\n-                       DWORD dwReceiveDataLength,\n-                       DWORD dwLocalAddressLength,\n-                       DWORD dwRemoteAddressLength,\n-                       LPSOCKADDR* LocalSockaddr,\n-                       LPINT LocalSockaddrLength,\n-                       LPSOCKADDR* RemoteSockaddr,\n-                       LPINT RemoteSockaddrLength);\n-\n-  typedef BOOL PASCAL (*LPFN_DISCONNECTEX)\n-                      (SOCKET hSocket,\n-                       LPOVERLAPPED lpOverlapped,\n-                       DWORD dwFlags,\n-                       DWORD reserved);\n-\n-  typedef BOOL PASCAL (*LPFN_TRANSMITFILE)\n-                      (SOCKET hSocket,\n-                       HANDLE hFile,\n-                       DWORD nNumberOfBytesToWrite,\n-                       DWORD nNumberOfBytesPerSend,\n-                       LPOVERLAPPED lpOverlapped,\n-                       LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,\n-                       DWORD dwFlags);\n-#endif\n \n /*\n  * MinGW is missing these too\n@@ -109,26 +41,66 @@\n   #define IPV6_V6ONLY 27\n #endif\n \n+/*\n+ * TDI defines that are only in the DDK.\n+ * We only need receive flags so far.\n+ */\n+#ifndef TDI_RECEIVE_NORMAL\n+  #define TDI_RECEIVE_BROADCAST           0x00000004\n+  #define TDI_RECEIVE_MULTICAST           0x00000008\n+  #define TDI_RECEIVE_PARTIAL             0x00000010\n+  #define TDI_RECEIVE_NORMAL              0x00000020\n+  #define TDI_RECEIVE_EXPEDITED           0x00000040\n+  #define TDI_RECEIVE_PEEK                0x00000080\n+  #define TDI_RECEIVE_NO_RESPONSE_EXP     0x00000100\n+  #define TDI_RECEIVE_COPY_LOOKAHEAD      0x00000200\n+  #define TDI_RECEIVE_ENTIRE_MESSAGE      0x00000400\n+  #define TDI_RECEIVE_AT_DISPATCH_LEVEL   0x00000800\n+  #define TDI_RECEIVE_CONTROL_INFO        0x00001000\n+  #define TDI_RECEIVE_FORCE_INDICATION    0x00002000\n+  #define TDI_RECEIVE_NO_PUSH             0x00004000\n+#endif\n+\n+/*\n+ * The \"Auxiliary Function Driver\" is the windows kernel-mode driver that does\n+ * TCP, UDP etc. Winsock is just a layer that dispatches requests to it.\n+ * Having these definitions allows us to bypass winsock and make an AFD kernel\n+ * call directly, avoiding a bug in winsock's recvfrom implementation.\n+ */\n+\n+#define AFD_NO_FAST_IO   0x00000001\n+#define AFD_OVERLAPPED   0x00000002\n+#define AFD_IMMEDIATE    0x00000004\n+\n+typedef struct _AFD_RECV_DATAGRAM_INFO {\n+    LPWSABUF BufferArray;\n+    ULONG BufferCount;\n+    ULONG AfdFlags;\n+    ULONG TdiFlags;\n+    struct sockaddr* Address;\n+    int* AddressLength;\n+} AFD_RECV_DATAGRAM_INFO, *PAFD_RECV_DATAGRAM_INFO;\n+\n+typedef struct _AFD_RECV_INFO {\n+    LPWSABUF BufferArray;\n+    ULONG BufferCount;\n+    ULONG AfdFlags;\n+    ULONG TdiFlags;\n+} AFD_RECV_INFO, *PAFD_RECV_INFO;\n+\n+\n+#define _AFD_CONTROL_CODE(operation, method) \\\n+    ((FSCTL_AFD_BASE) << 12 | (operation << 2) | method)\n \n-/* Winsock extension functions (ipv4) */\n-extern LPFN_CONNECTEX pConnectEx;\n-extern LPFN_ACCEPTEX pAcceptEx;\n-extern LPFN_GETACCEPTEXSOCKADDRS pGetAcceptExSockAddrs;\n-extern LPFN_DISCONNECTEX pDisconnectEx;\n-extern LPFN_TRANSMITFILE pTransmitFile;\n+#define FSCTL_AFD_BASE FILE_DEVICE_NETWORK\n \n-/* Winsock extension functions (ipv6) */\n-extern LPFN_CONNECTEX pConnectEx6;\n-extern LPFN_ACCEPTEX pAcceptEx6;\n-extern LPFN_GETACCEPTEXSOCKADDRS pGetAcceptExSockAddrs6;\n-extern LPFN_DISCONNECTEX pDisconnectEx6;\n-extern LPFN_TRANSMITFILE  pTransmitFile6;\n+#define AFD_RECEIVE            5\n+#define AFD_RECEIVE_DATAGRAM   6\n \n-/* Whether ipv6 is supported */\n-extern int uv_allow_ipv6;\n+#define IOCTL_AFD_RECEIVE \\\n+    _AFD_CONTROL_CODE(AFD_RECEIVE, METHOD_NEITHER)\n \n-/* Ip address used to bind to any port at any interface */\n-extern struct sockaddr_in uv_addr_ip4_any_;\n-extern struct sockaddr_in6 uv_addr_ip6_any_;\n+#define IOCTL_AFD_RECEIVE_DATAGRAM \\\n+    _AFD_CONTROL_CODE(AFD_RECEIVE_DATAGRAM, METHOD_NEITHER)\n \n #endif /* UV_WIN_WINSOCK_H_ */"}, {"sha": "0a72fb9861534a17bee1cded87ecd04fcb44e791", "filename": "src/rt/libuv/test/benchmark-list.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-list.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-list.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -21,6 +21,7 @@\n \n BENCHMARK_DECLARE (sizes)\n BENCHMARK_DECLARE (ping_pongs)\n+BENCHMARK_DECLARE (tcp_write_batch)\n BENCHMARK_DECLARE (tcp4_pound_100)\n BENCHMARK_DECLARE (tcp4_pound_1000)\n BENCHMARK_DECLARE (pipe_pound_100)\n@@ -42,6 +43,7 @@ BENCHMARK_DECLARE (udp_packet_storm_1000v1000)\n BENCHMARK_DECLARE (gethostbyname)\n BENCHMARK_DECLARE (getaddrinfo)\n BENCHMARK_DECLARE (spawn)\n+HELPER_DECLARE    (tcp4_blackhole_server)\n HELPER_DECLARE    (tcp_pump_server)\n HELPER_DECLARE    (pipe_pump_server)\n HELPER_DECLARE    (tcp4_echo_server)\n@@ -54,6 +56,9 @@ TASK_LIST_START\n   BENCHMARK_ENTRY  (ping_pongs)\n   BENCHMARK_HELPER (ping_pongs, tcp4_echo_server)\n \n+  BENCHMARK_ENTRY  (tcp_write_batch)\n+  BENCHMARK_HELPER (tcp_write_batch, tcp4_blackhole_server)\n+\n   BENCHMARK_ENTRY  (tcp_pump100_client)\n   BENCHMARK_HELPER (tcp_pump100_client, tcp_pump_server)\n "}, {"sha": "af7ce247dab48cc1043f918903899851d405bafd", "filename": "src/rt/libuv/test/benchmark-pound.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pound.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pound.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pound.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -222,7 +222,7 @@ static void tcp_make_connect(conn_rec* p) {\n static void pipe_make_connect(conn_rec* p) {\n   int r;\n \n-  r = uv_pipe_init(loop, (uv_pipe_t*)&p->stream);\n+  r = uv_pipe_init(loop, (uv_pipe_t*)&p->stream, 0);\n   ASSERT(r == 0);\n \n   r = uv_pipe_connect(&((pipe_conn_rec*)p)->conn_req, (uv_pipe_t*)&p->stream, TEST_PIPENAME, connect_cb);"}, {"sha": "27e8abe0c82139e78b4a621e5a75efa0e276c3b0", "filename": "src/rt/libuv/test/benchmark-pump.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pump.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pump.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pump.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -253,7 +253,7 @@ static void maybe_connect_some() {\n     } else {\n       pipe = &pipe_write_handles[max_connect_socket++];\n \n-      r = uv_pipe_init(loop, pipe);\n+      r = uv_pipe_init(loop, pipe, 0);\n       ASSERT(r == 0);\n \n       req = (uv_connect_t*) req_alloc();\n@@ -277,7 +277,7 @@ static void connection_cb(uv_stream_t* s, int status) {\n     ASSERT(r == 0);\n   } else {\n     stream = (uv_stream_t*)malloc(sizeof(uv_pipe_t));\n-    r = uv_pipe_init(loop, (uv_pipe_t*)stream);\n+    r = uv_pipe_init(loop, (uv_pipe_t*)stream, 0);\n     ASSERT(r == 0);\n   }\n \n@@ -396,7 +396,7 @@ HELPER_IMPL(pipe_pump_server) {\n \n   /* Server */\n   server = (uv_stream_t*)&pipeServer;\n-  r = uv_pipe_init(loop, &pipeServer);\n+  r = uv_pipe_init(loop, &pipeServer, 0);\n   ASSERT(r == 0);\n   r = uv_pipe_bind(&pipeServer, TEST_PIPENAME);\n   ASSERT(r == 0);"}, {"sha": "d75cb8e0a409395688372cd7d4b5df4ab97f3c13", "filename": "src/rt/libuv/test/benchmark-sizes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-sizes.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-sizes.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-sizes.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -29,6 +29,7 @@ BENCHMARK_IMPL(sizes) {\n   LOGF(\"uv_connect_t: %u bytes\\n\", (unsigned int) sizeof(uv_connect_t));\n   LOGF(\"uv_tcp_t: %u bytes\\n\", (unsigned int) sizeof(uv_tcp_t));\n   LOGF(\"uv_pipe_t: %u bytes\\n\", (unsigned int) sizeof(uv_pipe_t));\n+  LOGF(\"uv_tty_t: %u bytes\\n\", (unsigned int) sizeof(uv_tty_t));\n   LOGF(\"uv_prepare_t: %u bytes\\n\", (unsigned int) sizeof(uv_prepare_t));\n   LOGF(\"uv_check_t: %u bytes\\n\", (unsigned int) sizeof(uv_check_t));\n   LOGF(\"uv_idle_t: %u bytes\\n\", (unsigned int) sizeof(uv_idle_t));"}, {"sha": "d34f42b9feb3b01bf5c9693b8599ddfdd166a04a", "filename": "src/rt/libuv/test/benchmark-spawn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-spawn.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-spawn.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-spawn.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -113,7 +113,7 @@ static void spawn() {\n   options.args = args;\n   options.exit_cb = exit_cb;\n \n-  uv_pipe_init(loop, &out);\n+  uv_pipe_init(loop, &out, 0);\n   options.stdout_stream = &out;\n \n   r = uv_spawn(loop, &process, options);"}, {"sha": "77bb0191b1e83030747b5bc5dbfbd63f2d832c25", "filename": "src/rt/libuv/test/benchmark-tcp-write-batch.c", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-tcp-write-batch.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-tcp-write-batch.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-tcp-write-batch.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -0,0 +1,144 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"task.h\"\n+\n+#include <stdio.h>\n+#include <stddef.h>\n+#include <stdlib.h>\n+\n+#define WRITE_REQ_DATA  \"Hello, world.\"\n+#define NUM_WRITE_REQS  (1000 * 1000)\n+\n+#define container_of(ptr, type, member) \\\n+  ((type *) ((char *) (ptr) - offsetof(type, member)))\n+\n+typedef struct {\n+  uv_write_t req;\n+  uv_buf_t buf;\n+} write_req;\n+\n+\n+static write_req* write_reqs;\n+static uv_tcp_t tcp_client;\n+static uv_connect_t connect_req;\n+static uv_shutdown_t shutdown_req;\n+\n+static int shutdown_cb_called = 0;\n+static int connect_cb_called = 0;\n+static int write_cb_called = 0;\n+static int close_cb_called = 0;\n+\n+static void connect_cb(uv_connect_t* req, int status);\n+static void write_cb(uv_write_t* req, int status);\n+static void shutdown_cb(uv_shutdown_t* req, int status);\n+static void close_cb(uv_handle_t* handle);\n+\n+\n+static void connect_cb(uv_connect_t* req, int status) {\n+  write_req* w;\n+  int i;\n+  int r;\n+\n+  ASSERT(req->handle == (uv_stream_t*)&tcp_client);\n+\n+  for (i = 0; i < NUM_WRITE_REQS; i++) {\n+    w = &write_reqs[i];\n+    r = uv_write(&w->req, req->handle, &w->buf, 1, write_cb);\n+    ASSERT(r == 0);\n+  }\n+\n+  r = uv_shutdown(&shutdown_req, req->handle, shutdown_cb);\n+  ASSERT(r == 0);\n+\n+  connect_cb_called++;\n+}\n+\n+\n+static void write_cb(uv_write_t* req, int status) {\n+  ASSERT(req != NULL);\n+  ASSERT(status == 0);\n+  write_cb_called++;\n+}\n+\n+\n+static void shutdown_cb(uv_shutdown_t* req, int status) {\n+  ASSERT(req->handle == (uv_stream_t*)&tcp_client);\n+  ASSERT(req->handle->write_queue_size == 0);\n+\n+  uv_close((uv_handle_t*)req->handle, close_cb);\n+  free(write_reqs);\n+\n+  shutdown_cb_called++;\n+}\n+\n+\n+static void close_cb(uv_handle_t* handle) {\n+  ASSERT(handle == (uv_handle_t*)&tcp_client);\n+  close_cb_called++;\n+}\n+\n+\n+BENCHMARK_IMPL(tcp_write_batch) {\n+  struct sockaddr_in addr;\n+  uv_loop_t* loop;\n+  uint64_t start;\n+  uint64_t stop;\n+  int i;\n+  int r;\n+\n+  write_reqs = malloc(sizeof(*write_reqs) * NUM_WRITE_REQS);\n+  ASSERT(write_reqs != NULL);\n+\n+  /* Prepare the data to write out. */\n+  for (i = 0; i < NUM_WRITE_REQS; i++) {\n+    write_reqs[i].buf = uv_buf_init(WRITE_REQ_DATA,\n+                                    sizeof(WRITE_REQ_DATA) - 1);\n+  }\n+\n+  loop = uv_default_loop();\n+  addr = uv_ip4_addr(\"127.0.0.1\", TEST_PORT);\n+\n+  r = uv_tcp_init(loop, &tcp_client);\n+  ASSERT(r == 0);\n+\n+  r = uv_tcp_connect(&connect_req, &tcp_client, addr, connect_cb);\n+  ASSERT(r == 0);\n+\n+  start = uv_hrtime();\n+\n+  r = uv_run(loop);\n+  ASSERT(r == 0);\n+\n+  stop = uv_hrtime();\n+\n+  ASSERT(connect_cb_called == 1);\n+  ASSERT(write_cb_called == NUM_WRITE_REQS);\n+  ASSERT(shutdown_cb_called == 1);\n+  ASSERT(close_cb_called == 1);\n+\n+  printf(\"%ld write requests in %.2fs.\\n\",\n+         (long)NUM_WRITE_REQS,\n+         (stop - start) / 10e8);\n+\n+  return 0;\n+}"}, {"sha": "85a0efc26bfaba0a52e63ec56de549f558332356", "filename": "src/rt/libuv/test/blackhole-server.c", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Fblackhole-server.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Fblackhole-server.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fblackhole-server.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -0,0 +1,122 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"task.h\"\n+\n+#include <stdio.h>\n+#include <stddef.h>\n+#include <stdlib.h>\n+\n+#define container_of(ptr, type, member) \\\n+  ((type *) ((char *) (ptr) - offsetof(type, member)))\n+\n+typedef struct {\n+  uv_tcp_t handle;\n+  uv_shutdown_t shutdown_req;\n+} conn_rec;\n+\n+static uv_tcp_t tcp_server;\n+\n+static void connection_cb(uv_stream_t* stream, int status);\n+static uv_buf_t alloc_cb(uv_handle_t* handle, size_t suggested_size);\n+static void read_cb(uv_stream_t* stream, ssize_t nread, uv_buf_t buf);\n+static void shutdown_cb(uv_shutdown_t* req, int status);\n+static void close_cb(uv_handle_t* handle);\n+\n+\n+static void connection_cb(uv_stream_t* stream, int status) {\n+  conn_rec* conn;\n+  int r;\n+\n+  ASSERT(status == 0);\n+  ASSERT(stream == (uv_stream_t*)&tcp_server);\n+\n+  conn = malloc(sizeof *conn);\n+  ASSERT(conn != NULL);\n+\n+  r = uv_tcp_init(stream->loop, &conn->handle);\n+  ASSERT(r == 0);\n+\n+  r = uv_accept(stream, (uv_stream_t*)&conn->handle);\n+  ASSERT(r == 0);\n+\n+  r = uv_read_start((uv_stream_t*)&conn->handle, alloc_cb, read_cb);\n+  ASSERT(r == 0);\n+}\n+\n+\n+static uv_buf_t alloc_cb(uv_handle_t* handle, size_t suggested_size) {\n+  static char buf[65536];\n+  return uv_buf_init(buf, sizeof buf);\n+}\n+\n+\n+static void read_cb(uv_stream_t* stream, ssize_t nread, uv_buf_t buf) {\n+  conn_rec* conn;\n+  int r;\n+\n+  if (nread >= 0)\n+    return;\n+\n+  ASSERT(uv_last_error(stream->loop).code == UV_EOF);\n+\n+  conn = container_of(stream, conn_rec, handle);\n+\n+  r = uv_shutdown(&conn->shutdown_req, stream, shutdown_cb);\n+  ASSERT(r == 0);\n+}\n+\n+\n+static void shutdown_cb(uv_shutdown_t* req, int status) {\n+  conn_rec* conn = container_of(req, conn_rec, shutdown_req);\n+  uv_close((uv_handle_t*)&conn->handle, close_cb);\n+}\n+\n+\n+static void close_cb(uv_handle_t* handle) {\n+  conn_rec* conn = container_of(handle, conn_rec, handle);\n+  free(conn);\n+}\n+\n+\n+HELPER_IMPL(tcp4_blackhole_server) {\n+  struct sockaddr_in addr;\n+  uv_loop_t* loop;\n+  int r;\n+\n+  loop = uv_default_loop();\n+  addr = uv_ip4_addr(\"127.0.0.1\", TEST_PORT);\n+\n+  r = uv_tcp_init(loop, &tcp_server);\n+  ASSERT(r == 0);\n+\n+  r = uv_tcp_bind(&tcp_server, addr);\n+  ASSERT(r == 0);\n+\n+  r = uv_listen((uv_stream_t*)&tcp_server, 128, connection_cb);\n+  ASSERT(r == 0);\n+\n+  r = uv_run(loop);\n+  ASSERT(0 && \"Blackhole server dropped out of event loop.\");\n+\n+  return 0;\n+}"}, {"sha": "8b1754410cd160e3e125781bc80f41405c09d97c", "filename": "src/rt/libuv/test/echo-server.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Fecho-server.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Fecho-server.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fecho-server.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -151,7 +151,7 @@ static void on_connection(uv_stream_t* server, int status) {\n   case PIPE:\n     stream = malloc(sizeof(uv_pipe_t));\n     ASSERT(stream != NULL);\n-    r = uv_pipe_init(loop, (uv_pipe_t*)stream);\n+    r = uv_pipe_init(loop, (uv_pipe_t*)stream, 0);\n     ASSERT(r == 0);\n     break;\n \n@@ -248,7 +248,7 @@ static int pipe_echo_start(char* pipeName) {\n   server = (uv_handle_t*)&pipeServer;\n   serverType = PIPE;\n \n-  r = uv_pipe_init(loop, &pipeServer);\n+  r = uv_pipe_init(loop, &pipeServer, 0);\n   if (r) {\n     fprintf(stderr, \"uv_pipe_init: %s\\n\",\n         uv_strerror(uv_last_error(loop)));"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/rt/libuv/test/fixtures/empty_file", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ffixtures%2Fempty_file", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ffixtures%2Fempty_file", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ffixtures%2Fempty_file?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b"}, {"sha": "7fb48d14b68a16b4ae9053b18d904c73456fa814", "filename": "src/rt/libuv/test/run-tests.c", "status": "modified", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Frun-tests.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Frun-tests.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frun-tests.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -22,6 +22,7 @@\n #include <stdio.h>\n #include <string.h>\n \n+#include \"uv.h\"\n #include \"runner.h\"\n #include \"task.h\"\n \n@@ -48,12 +49,216 @@ int main(int argc, char **argv) {\n }\n \n \n+static uv_pipe_t channel;\n+static uv_tcp_t tcp_server;\n+static uv_write_t conn_notify_req;\n+static int close_cb_called;\n+static int connection_accepted;\n+\n+static uv_pipe_t stdin_pipe;\n+static uv_pipe_t stdout_pipe;\n+static int on_pipe_read_called;\n+static int after_write_called;\n+\n+\n+static void close_cb(uv_handle_t* handle) {\n+  close_cb_called++;\n+}\n+\n+\n+static void close_conn_cb(uv_handle_t* handle) {\n+  free(handle);\n+  close_cb_called++;\n+}\n+\n+\n+void conn_notify_write_cb(uv_write_t* req, int status) {\n+  uv_close((uv_handle_t*)&tcp_server, close_cb);\n+  uv_close((uv_handle_t*)&channel, close_cb);\n+}\n+\n+\n+static void ipc_on_connection(uv_stream_t* server, int status) {\n+  int r;\n+  uv_buf_t buf;\n+  uv_tcp_t* conn;\n+\n+  if (!connection_accepted) {\n+    /* \n+     * Accept the connection and close it.  Also let the other\n+     * side know.\n+     */\n+    ASSERT(status == 0);\n+    ASSERT((uv_stream_t*)&tcp_server == server);\n+\n+    conn = malloc(sizeof(*conn));\n+    ASSERT(conn);\n+\n+    r = uv_tcp_init(server->loop, conn);\n+    ASSERT(r == 0);\n+\n+    r = uv_accept(server, (uv_stream_t*)conn);\n+    ASSERT(r == 0);\n+\n+    uv_close((uv_handle_t*)conn, close_conn_cb);\n+\n+    buf = uv_buf_init(\"accepted_connection\\n\", 20);\n+    r = uv_write2(&conn_notify_req, (uv_stream_t*)&channel, &buf, 1,\n+      NULL, conn_notify_write_cb);\n+    ASSERT(r == 0);\n+\n+    connection_accepted = 1;\n+  }\n+}\n+\n+\n+static int ipc_helper() {\n+  /*\n+   * This is launched from test-ipc.c. stdin is a duplex channel that we\n+   * over which a handle will be transmitted. In this initial version only\n+   * data is transfered over the channel. XXX edit this comment after handle\n+   * transfer is added.\n+   */\n+  \n+  uv_write_t write_req;\n+  int r;\n+  uv_buf_t buf;\n+\n+  r = uv_pipe_init(uv_default_loop(), &channel, 1);\n+  ASSERT(r == 0);\n+\n+  uv_pipe_open(&channel, 0);\n+\n+  r = uv_tcp_init(uv_default_loop(), &tcp_server);\n+  ASSERT(r == 0);\n+\n+  r = uv_tcp_bind(&tcp_server, uv_ip4_addr(\"0.0.0.0\", TEST_PORT));\n+  ASSERT(r == 0);\n+\n+  r = uv_listen((uv_stream_t*)&tcp_server, 12, ipc_on_connection);\n+  ASSERT(r == 0);\n+\n+  buf = uv_buf_init(\"hello\\n\", 6);\n+  r = uv_write2(&write_req, (uv_stream_t*)&channel, &buf, 1,\n+      (uv_stream_t*)&tcp_server, NULL);\n+  ASSERT(r == 0);\n+\n+  r = uv_run(uv_default_loop());\n+  ASSERT(r == 0);\n+\n+  ASSERT(connection_accepted == 1);\n+  ASSERT(close_cb_called == 3);\n+\n+  return 0;\n+}\n+\n+\n+void on_pipe_read(uv_stream_t* tcp, ssize_t nread, uv_buf_t buf) {\n+  ASSERT(nread > 0);\n+  ASSERT(memcmp(\"hello world\\n\", buf.base, nread) == 0);\n+  on_pipe_read_called++;\n+\n+  free(buf.base);\n+\n+  uv_close((uv_handle_t*)&stdin_pipe, close_cb);\n+  uv_close((uv_handle_t*)&stdout_pipe, close_cb);\n+}\n+\n+\n+static uv_buf_t on_pipe_read_alloc(uv_handle_t* handle,\n+    size_t suggested_size) {\n+  uv_buf_t buf;\n+  buf.base = (char*)malloc(suggested_size);\n+  buf.len = suggested_size;\n+  return buf;\n+}\n+\n+\n+static void after_pipe_write(uv_write_t* req, int status) {\n+  ASSERT(status == 0);\n+  after_write_called++;\n+}\n+\n+\n+static int stdio_over_pipes_helper() {\n+  /* Write several buffers to test that the write order is preserved. */\n+  char* buffers[] = {\n+    \"he\",\n+    \"ll\",\n+    \"o \",\n+    \"wo\",\n+    \"rl\",\n+    \"d\",\n+    \"\\n\"\n+  };\n+\n+  uv_write_t write_req[COUNTOF(buffers)];\n+  uv_buf_t buf[COUNTOF(buffers)];\n+  int r, i;\n+  uv_loop_t* loop = uv_default_loop();\n+  \n+  ASSERT(UV_NAMED_PIPE == uv_guess_handle(0));\n+  ASSERT(UV_NAMED_PIPE == uv_guess_handle(1));\n+\n+  r = uv_pipe_init(loop, &stdin_pipe, 0);\n+  ASSERT(r == 0);\n+  r = uv_pipe_init(loop, &stdout_pipe, 0);\n+  ASSERT(r == 0);\n+\n+  uv_pipe_open(&stdin_pipe, 0);\n+  uv_pipe_open(&stdout_pipe, 1);\n+\n+  /* Unref both stdio handles to make sure that all writes complete. */\n+  uv_unref(loop);\n+  uv_unref(loop);\n+\n+  for (i = 0; i < COUNTOF(buffers); i++) {\n+    buf[i] = uv_buf_init((char*)buffers[i], strlen(buffers[i]));\n+  }\n+\n+  for (i = 0; i < COUNTOF(buffers); i++) {\n+    r = uv_write(&write_req[i], (uv_stream_t*)&stdout_pipe, &buf[i], 1,\n+      after_pipe_write);\n+    ASSERT(r == 0);\n+  }\n+\n+  uv_run(loop);\n+\n+  ASSERT(after_write_called == 7);\n+  ASSERT(on_pipe_read_called == 0);\n+  ASSERT(close_cb_called == 0);\n+\n+  uv_ref(loop);\n+  uv_ref(loop);\n+\n+  r = uv_read_start((uv_stream_t*)&stdin_pipe, on_pipe_read_alloc,\n+    on_pipe_read);\n+  ASSERT(r == 0);\n+\n+  uv_run(loop);\n+\n+  ASSERT(after_write_called == 7);\n+  ASSERT(on_pipe_read_called == 1);\n+  ASSERT(close_cb_called == 2);\n+\n+  return 0;\n+}\n+\n+\n static int maybe_run_test(int argc, char **argv) {\n   if (strcmp(argv[1], \"--list\") == 0) {\n     print_tests(stdout);\n     return 0;\n   }\n \n+  if (strcmp(argv[1], \"ipc_helper\") == 0) {\n+    return ipc_helper();\n+  }\n+\n+  if (strcmp(argv[1], \"stdio_over_pipes_helper\") == 0) {\n+    return stdio_over_pipes_helper();\n+  }\n+\n   if (strcmp(argv[1], \"spawn_helper1\") == 0) {\n     return 1;\n   }"}, {"sha": "e28b393bb727caf6f568b056f30d8e399565e626", "filename": "src/rt/libuv/test/task.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftask.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftask.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftask.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -38,6 +38,8 @@\n # define TEST_PIPENAME_2 \"/tmp/uv-test-sock2\"\n #endif\n \n+#define COUNTOF(a) (sizeof(a) / sizeof(a[0]))\n+\n typedef enum {\n   TCP = 0,\n   PIPE"}, {"sha": "8d6f2355273baa691eabd728578c26ab79195916", "filename": "src/rt/libuv/test/test-error.c", "status": "renamed", "additions": 27, "deletions": 43, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-error.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -19,57 +19,41 @@\n  * IN THE SOFTWARE.\n  */\n \n-#include <assert.h>\n-#include <string.h>\n-\n #include \"uv.h\"\n-#include \"../uv-common.h\"\n-#include \"internal.h\"\n-\n-\n-static uv_pipe_t* uv_make_pipe_for_std_handle(uv_loop_t* loop, HANDLE handle) {\n-  uv_pipe_t* pipe = NULL;\n+#include \"task.h\"\n \n-  pipe = (uv_pipe_t*)malloc(sizeof(uv_pipe_t));\n-  if (!pipe) {\n-    uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");\n-  }\n-\n-  if (uv_pipe_init_with_handle(loop, pipe, handle)) {\n-    free(pipe);\n-    return NULL;\n-  }\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n \n-  pipe->flags |= UV_HANDLE_UV_ALLOCED;\n-  return pipe;\n-}\n \n+/*\n+ * Synthetic errors (errors that originate from within libuv, not the system)\n+ * should produce sensible error messages when run through uv_strerror().\n+ *\n+ * See https://github.com/joyent/libuv/issues/210\n+ */\n+TEST_IMPL(error_message) {\n+  uv_err_t e;\n \n-uv_stream_t* uv_std_handle(uv_loop_t* loop, uv_std_type type) {\n-  HANDLE handle;\n+  /* Cop out. Can't do proper checks on systems with\n+   * i18n-ized error messages...\n+   */\n+  e.code = 0, e.sys_errno_ = 0;\n \n-  switch (type) {\n-    case UV_STDIN:\n-      handle = GetStdHandle(STD_INPUT_HANDLE);\n-      if (handle == INVALID_HANDLE_VALUE) {\n-        return NULL;\n-      }\n+  if (strcmp(uv_strerror(e), \"Success\") != 0) {\n+    printf(\"i18n error messages detected, skipping test.\\n\");\n+    return 0;\n+  }\n \n-      /* Assume only named pipes for now. */\n-      return (uv_stream_t*)uv_make_pipe_for_std_handle(loop, handle);\n-      break;\n+  e.code = UV_EINVAL, e.sys_errno_ = 0;\n+  ASSERT(strstr(uv_strerror(e), \"Success\") == NULL);\n \n-    case UV_STDOUT:\n-      return NULL;\n-      break;\n+  e.code = UV_UNKNOWN, e.sys_errno_ = 0;\n+  ASSERT(strcmp(uv_strerror(e), \"Unknown error\") == 0);\n \n-    case UV_STDERR:\n-      return NULL;\n-      break;\n+  e.code = 1337, e.sys_errno_ = 0;\n+  ASSERT(strcmp(uv_strerror(e), \"Unknown error\") == 0);\n \n-    default:\n-      assert(0);\n-      uv_set_error(loop, UV_EINVAL, 0);\n-      return NULL;\n-  }\n+  return 0;\n }", "previous_filename": "src/rt/libuv/src/win/stdio.c"}, {"sha": "724000db153c6864e49582202760e2a0046abfb3", "filename": "src/rt/libuv/test/test-fs-event.c", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-fs-event.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-fs-event.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-fs-event.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -25,11 +25,12 @@\n #include <string.h>\n #include <fcntl.h>\n \n-uv_fs_event_t fs_event;\n-uv_timer_t timer;\n-int timer_cb_called;\n-int close_cb_called;\n-int fs_event_cb_called;\n+static uv_fs_event_t fs_event;\n+static uv_timer_t timer;\n+static int timer_cb_called;\n+static int close_cb_called;\n+static int fs_event_cb_called;\n+static int timer_cb_touch_called;\n \n static void create_dir(uv_loop_t* loop, const char* name) {\n   int r;\n@@ -84,7 +85,7 @@ static void fs_event_cb_dir(uv_fs_event_t* handle, const char* filename,\n   ASSERT(handle == &fs_event);\n   ASSERT(status == 0);\n   ASSERT(events == UV_RENAME);\n-  ASSERT(strcmp(filename, \"file1\") == 0);\n+  ASSERT(filename == NULL || strcmp(filename, \"file1\") == 0);\n   uv_close((uv_handle_t*)handle, close_cb);\n }\n \n@@ -94,7 +95,7 @@ static void fs_event_cb_file(uv_fs_event_t* handle, const char* filename,\n   ASSERT(handle == &fs_event);\n   ASSERT(status == 0);\n   ASSERT(events == UV_CHANGE);\n-  ASSERT(strcmp(filename, \"file2\") == 0);\n+  ASSERT(filename == NULL || strcmp(filename, \"file2\") == 0);\n   uv_close((uv_handle_t*)handle, close_cb);\n }\n \n@@ -104,7 +105,7 @@ static void fs_event_cb_file_current_dir(uv_fs_event_t* handle,\n   ASSERT(handle == &fs_event);\n   ASSERT(status == 0);\n   ASSERT(events == UV_CHANGE);\n-  ASSERT(strcmp(filename, \"watch_file\") == 0);\n+  ASSERT(filename == NULL || strcmp(filename, \"watch_file\") == 0);\n   uv_close((uv_handle_t*)handle, close_cb);\n }\n \n@@ -125,6 +126,13 @@ static void timer_cb_file(uv_timer_t* handle, int status) {\n   }\n }\n \n+static void timer_cb_touch(uv_timer_t* timer, int status) {\n+  ASSERT(status == 0);\n+  uv_close((uv_handle_t*)timer, NULL);\n+  touch_file(timer->loop, \"watch_file\");\n+  timer_cb_touch_called++;\n+}\n+\n TEST_IMPL(fs_event_watch_dir) {\n   uv_fs_t fs_req;\n   uv_loop_t* loop = uv_default_loop();\n@@ -192,22 +200,34 @@ TEST_IMPL(fs_event_watch_file) {\n }\n \n TEST_IMPL(fs_event_watch_file_current_dir) {\n+  uv_timer_t timer;\n+  uv_loop_t* loop;\n   uv_fs_t fs_req;\n-  uv_loop_t* loop = uv_default_loop();\n   int r;\n \n+  loop = uv_default_loop();\n+\n   /* Setup */\n   uv_fs_unlink(loop, &fs_req, \"watch_file\", NULL);\n   create_file(loop, \"watch_file\");\n \n   r = uv_fs_event_init(loop, &fs_event, \"watch_file\",\n     fs_event_cb_file_current_dir);\n   ASSERT(r != -1);\n-  \n-  touch_file(loop, \"watch_file\");\n+\n+  r = uv_timer_init(loop, &timer);\n+  ASSERT(r == 0);\n+\n+  r = uv_timer_start(&timer, timer_cb_touch, 1, 0);\n+  ASSERT(r == 0);\n+\n+  ASSERT(timer_cb_touch_called == 0);\n+  ASSERT(fs_event_cb_called == 0);\n+  ASSERT(close_cb_called == 0);\n \n   uv_run(loop);\n \n+  ASSERT(timer_cb_touch_called == 1);\n   ASSERT(fs_event_cb_called == 1);\n   ASSERT(close_cb_called == 1);\n "}, {"sha": "a8065192fa4aac1b54ae97b643c856976843bc6e", "filename": "src/rt/libuv/test/test-fs.c", "status": "modified", "additions": 172, "deletions": 9, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-fs.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-fs.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-fs.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -155,7 +155,7 @@ static void fchmod_cb(uv_fs_t* req) {\n   ASSERT(req->result == 0);\n   fchmod_cb_count++;\n   uv_fs_req_cleanup(req);\n-  check_permission(\"test_file\", (int)req->data);\n+  check_permission(\"test_file\", *(int*)req->data);\n }\n \n \n@@ -164,7 +164,7 @@ static void chmod_cb(uv_fs_t* req) {\n   ASSERT(req->result == 0);\n   chmod_cb_count++;\n   uv_fs_req_cleanup(req);\n-  check_permission(\"test_file\", (int)req->data);\n+  check_permission(\"test_file\", *(int*)req->data);\n }\n \n \n@@ -263,6 +263,19 @@ static void open_cb(uv_fs_t* req) {\n }\n \n \n+static void open_cb_simple(uv_fs_t* req) {\n+  ASSERT(req->fs_type == UV_FS_OPEN);\n+  if (req->result < 0) {\n+    /* TODO get error with uv_last_error() */\n+    fprintf(stderr, \"async open error: %d\\n\", req->errorno);\n+    ASSERT(0);\n+  }\n+  open_cb_count++;\n+  ASSERT(req->path);\n+  uv_fs_req_cleanup(req);\n+}\n+\n+\n static void fsync_cb(uv_fs_t* req) {\n   int r;\n   ASSERT(req == &fsync_req);\n@@ -354,6 +367,27 @@ static void readdir_cb(uv_fs_t* req) {\n }\n \n \n+static void empty_readdir_cb(uv_fs_t* req) {\n+  ASSERT(req == &readdir_req);\n+  ASSERT(req->fs_type == UV_FS_READDIR);\n+  ASSERT(req->result == 0);\n+  ASSERT(req->ptr == NULL);\n+  uv_fs_req_cleanup(req);\n+  readdir_cb_count++;\n+}\n+\n+\n+static void file_readdir_cb(uv_fs_t* req) {\n+  ASSERT(req == &readdir_req);\n+  ASSERT(req->fs_type == UV_FS_READDIR);\n+  ASSERT(req->result == -1);\n+  ASSERT(req->ptr == NULL);\n+  ASSERT(uv_last_error(req->loop).code == UV_ENOTDIR);\n+  uv_fs_req_cleanup(req);\n+  readdir_cb_count++;\n+}\n+\n+\n static void stat_cb(uv_fs_t* req) {\n   ASSERT(req == &stat_req);\n   ASSERT(req->fs_type == UV_FS_STAT || req->fs_type == UV_FS_LSTAT);\n@@ -869,7 +903,10 @@ TEST_IMPL(fs_chmod) {\n \n #ifndef _WIN32\n   /* async chmod */\n-  req.data = (void*)0200;\n+  {\n+    static int mode = 0200;\n+    req.data = &mode;\n+  }\n   r = uv_fs_chmod(loop, &req, \"test_file\", 0200, chmod_cb);\n   ASSERT(r == 0);\n   uv_run(loop);\n@@ -878,14 +915,20 @@ TEST_IMPL(fs_chmod) {\n #endif\n \n   /* async chmod */\n-  req.data = (void*)0400;\n+  {\n+    static int mode = 0400;\n+    req.data = &mode;\n+  }\n   r = uv_fs_chmod(loop, &req, \"test_file\", 0400, chmod_cb);\n   ASSERT(r == 0);\n   uv_run(loop);\n   ASSERT(chmod_cb_count == 1);\n \n   /* async fchmod */\n-  req.data = (void*)0600;\n+  {\n+    static int mode = 0600;\n+    req.data = &mode;\n+  }\n   r = uv_fs_fchmod(loop, &req, file, 0600, fchmod_cb);\n   ASSERT(r == 0);\n   uv_run(loop);\n@@ -1077,7 +1120,7 @@ TEST_IMPL(fs_symlink) {\n   r = uv_fs_symlink(loop, &req, \"test_file\", \"test_file_symlink\", 0, NULL);\n #ifdef _WIN32\n   if (r == -1) {\n-    if (req.errorno == ENOSYS) {\n+    if (uv_last_error(loop).code == UV_ENOTSUP) {\n       /*\n        * Windows doesn't support symlinks on older versions.\n        * We just pass the test and bail out early if we get ENOTSUP.\n@@ -1163,13 +1206,21 @@ TEST_IMPL(fs_symlink) {\n \n TEST_IMPL(fs_utime) {\n   utime_check_t checkme;\n-  const char* path = \".\";\n+  const char* path = \"test_file\";\n   double atime;\n   double mtime;\n   uv_fs_t req;\n   int r;\n \n+  /* Setup. */\n   loop = uv_default_loop();\n+  unlink(path);\n+  r = uv_fs_open(loop, &req, path, O_RDWR | O_CREAT,\n+      S_IWRITE | S_IREAD, NULL);\n+  ASSERT(r != -1);\n+  ASSERT(req.result != -1);\n+  uv_fs_req_cleanup(&req);\n+  close(r);\n \n   atime = mtime = 400497753; /* 1982-09-10 11:22:33 */\n \n@@ -1196,24 +1247,35 @@ TEST_IMPL(fs_utime) {\n   uv_run(loop);\n   ASSERT(utime_cb_count == 1);\n \n+  /* Cleanup. */\n+  unlink(path);\n+\n   return 0;\n }\n \n \n TEST_IMPL(fs_futime) {\n   utime_check_t checkme;\n-  const char* path = \".\";\n+  const char* path = \"test_file\";\n   double atime;\n   double mtime;\n   uv_file file;\n   uv_fs_t req;\n   int r;\n \n+  /* Setup. */\n   loop = uv_default_loop();\n+  unlink(path);\n+  r = uv_fs_open(loop, &req, path, O_RDWR | O_CREAT,\n+      S_IWRITE | S_IREAD, NULL);\n+  ASSERT(r != -1);\n+  ASSERT(req.result != -1);\n+  uv_fs_req_cleanup(&req);\n+  close(r);\n \n   atime = mtime = 400497753; /* 1982-09-10 11:22:33 */\n \n-  r = uv_fs_open(loop, &req, path, O_RDONLY, 0, NULL);\n+  r = uv_fs_open(loop, &req, path, O_RDWR, 0, NULL);\n   ASSERT(r != -1);\n   ASSERT(req.result != -1);\n   file = req.result; /* FIXME probably not how it's supposed to be used */\n@@ -1243,5 +1305,106 @@ TEST_IMPL(fs_futime) {\n   uv_run(loop);\n   ASSERT(futime_cb_count == 1);\n \n+  /* Cleanup. */\n+  unlink(path);\n+\n+  return 0;\n+}\n+\n+\n+TEST_IMPL(fs_stat_missing_path) {\n+  uv_fs_t req;\n+  int r;\n+\n+  loop = uv_default_loop();\n+\n+  r = uv_fs_stat(loop, &req, \"non_existent_file\", NULL);\n+  ASSERT(r == -1);\n+  ASSERT(req.result == -1);\n+  ASSERT(uv_last_error(loop).code == UV_ENOENT);\n+  uv_fs_req_cleanup(&req);\n+\n+  return 0;\n+}\n+\n+\n+TEST_IMPL(fs_readdir_empty_dir) {\n+  const char* path;\n+  uv_fs_t req;\n+  int r;\n+\n+  path = \"./empty_dir/\";\n+  loop = uv_default_loop();\n+\n+  uv_fs_mkdir(loop, &req, path, 0777, NULL);\n+  uv_fs_req_cleanup(&req);\n+\n+  r = uv_fs_readdir(loop, &req, path, 0, NULL);\n+  ASSERT(r == 0);\n+  ASSERT(req.result == 0);\n+  ASSERT(req.ptr == NULL);\n+  uv_fs_req_cleanup(&req);\n+\n+  r = uv_fs_readdir(loop, &readdir_req, path, 0, empty_readdir_cb);\n+  ASSERT(r == 0);\n+\n+  ASSERT(readdir_cb_count == 0);\n+  uv_run(loop);\n+  ASSERT(readdir_cb_count == 1);\n+\n+  uv_fs_rmdir(loop, &req, path, NULL);\n+  uv_fs_req_cleanup(&req);\n+\n+  return 0;\n+}\n+\n+\n+TEST_IMPL(fs_readdir_file) {\n+  const char* path;\n+  int r;\n+\n+  path = \"test/fixtures/empty_file\";\n+  loop = uv_default_loop();\n+\n+  r = uv_fs_readdir(loop, &readdir_req, path, 0, NULL);\n+  ASSERT(r == -1);\n+  ASSERT(uv_last_error(loop).code == UV_ENOTDIR);\n+\n+  r = uv_fs_readdir(loop, &readdir_req, path, 0, file_readdir_cb);\n+  ASSERT(r == 0);\n+\n+  ASSERT(readdir_cb_count == 0);\n+  uv_run(loop);\n+  ASSERT(readdir_cb_count == 1);\n+\n+  return 0;\n+}\n+\n+\n+TEST_IMPL(fs_open_dir) {\n+  const char* path;\n+  uv_fs_t req;\n+  int r, file;\n+\n+  path = \".\";\n+  loop = uv_default_loop();\n+\n+  r = uv_fs_open(loop, &req, path, O_RDONLY, 0, NULL);\n+  ASSERT(r != -1);\n+  ASSERT(req.result != -1);\n+  ASSERT(req.ptr == NULL);\n+  file = r;\n+  uv_fs_req_cleanup(&req);\n+\n+  r = uv_fs_close(loop, &req, file, NULL);\n+  ASSERT(r == 0);\n+\n+  r = uv_fs_open(loop, &req, path, O_RDONLY, 0, open_cb_simple);\n+  ASSERT(r == 0);\n+\n+  ASSERT(open_cb_count == 0);\n+  uv_run(loop);\n+  ASSERT(open_cb_count == 1);\n+\n   return 0;\n }"}, {"sha": "7465e18b91e9c740834c2a668b4e859d79736fa6", "filename": "src/rt/libuv/test/test-get-loadavg.c", "status": "renamed", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-get-loadavg.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-get-loadavg.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-get-loadavg.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -19,11 +19,18 @@\n  * IN THE SOFTWARE.\n  */\n \n-#ifndef UV_LINUX_H\n-#define UV_LINUX_H\n+#include \"uv.h\"\n+#include \"task.h\"\n \n-#define UV_FS_EVENT_PRIVATE_FIELDS \\\n-  ev_io read_watcher; \\\n-  uv_fs_event_cb cb; \\\n+TEST_IMPL(get_loadavg) {\n \n-#endif /* UV_LINUX_H */\n+  double avg[3];\n+  uv_loadavg(avg);\n+\n+  ASSERT(avg != NULL);\n+  ASSERT(avg[0] >= 0);\n+  ASSERT(avg[1] >= 0);\n+  ASSERT(avg[2] >= 0);\n+\n+  return 0;\n+}", "previous_filename": "src/rt/libuv/include/uv-private/uv-linux.h"}, {"sha": "00281af632445727dd03ddcd18316d5df2c63879", "filename": "src/rt/libuv/test/test-get-memory.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-get-memory.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-get-memory.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-get-memory.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -0,0 +1,36 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"task.h\"\n+\n+TEST_IMPL(get_memory) {\n+  uint64_t free_mem = uv_get_free_memory();\n+  uint64_t total_mem = uv_get_total_memory();\n+\n+  printf(\"free_mem=%llu, total_mem=%llu\\n\", free_mem, total_mem);\n+\n+  ASSERT(free_mem > 0);\n+  ASSERT(total_mem > 0);\n+  ASSERT(total_mem > free_mem);\n+\n+  return 0;\n+}"}, {"sha": "5119b59bf5c31c59ee0dfd1410e8bc75bcf7c9c4", "filename": "src/rt/libuv/test/test-ipc.c", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-ipc.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-ipc.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-ipc.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -0,0 +1,222 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"task.h\"\n+\n+#include <stdio.h>\n+#include <string.h>\n+\n+static char exepath[1024];\n+static size_t exepath_size = 1024;\n+static char* args[3];\n+static uv_pipe_t channel;\n+static uv_tcp_t tcp_server;\n+\n+static int exit_cb_called;\n+static int read2_cb_called;\n+static int local_conn_accepted;\n+static int remote_conn_accepted;\n+static int tcp_server_listening;\n+\n+static uv_write_t write_req;\n+\n+typedef struct {\n+  uv_connect_t conn_req;\n+  uv_tcp_t conn;\n+} tcp_conn;\n+\n+#define CONN_COUNT 100\n+\n+\n+static void close_server_conn_cb(uv_handle_t* handle) {\n+  free(handle);\n+}\n+\n+\n+static void ipc_on_connection(uv_stream_t* server, int status) {\n+  uv_tcp_t* conn;\n+  int r;\n+\n+  if (!local_conn_accepted) {\n+    /* Accept the connection and close it.  Also and close the server. */\n+    ASSERT(status == 0);\n+    ASSERT((uv_stream_t*)&tcp_server == server);\n+\n+    conn = malloc(sizeof(*conn));\n+    ASSERT(conn);\n+    r = uv_tcp_init(server->loop, conn);\n+    ASSERT(r == 0);\n+\n+    r = uv_accept(server, (uv_stream_t*)conn);\n+    ASSERT(r == 0);\n+\n+    uv_close((uv_handle_t*)conn, close_server_conn_cb);\n+    uv_close((uv_handle_t*)server, NULL);\n+    local_conn_accepted = 1;\n+  }\n+}\n+\n+\n+static void exit_cb(uv_process_t* process, int exit_status, int term_signal) {\n+  printf(\"exit_cb\\n\");\n+  exit_cb_called++;\n+  ASSERT(exit_status == 0);\n+  uv_close((uv_handle_t*)process, NULL);\n+}\n+\n+\n+static uv_buf_t on_alloc(uv_handle_t* handle, size_t suggested_size) {\n+  return uv_buf_init(malloc(suggested_size), suggested_size);\n+}\n+\n+\n+static void close_client_conn_cb(uv_handle_t* handle) {\n+  tcp_conn* p = (tcp_conn*)handle->data;\n+  free(p);\n+}\n+\n+\n+static void connect_cb(uv_connect_t* req, int status) {\n+  uv_close((uv_handle_t*)req->handle, close_client_conn_cb);\n+}\n+\n+\n+static void make_many_connections() {\n+  tcp_conn* conn;\n+  struct sockaddr_in addr;\n+  int r, i;\n+\n+  for (i = 0; i < CONN_COUNT; i++) {\n+    conn = malloc(sizeof(*conn));\n+    ASSERT(conn);\n+\n+    r = uv_tcp_init(uv_default_loop(), &conn->conn);\n+    ASSERT(r == 0);\n+\n+    addr = uv_ip4_addr(\"127.0.0.1\", TEST_PORT);\n+\n+    r = uv_tcp_connect(&conn->conn_req, (uv_tcp_t*)&conn->conn, addr, connect_cb);\n+    ASSERT(r == 0);\n+\n+    conn->conn.data = conn;\n+  }\n+}\n+\n+\n+static void on_read(uv_pipe_t* pipe, ssize_t nread, uv_buf_t buf,\n+    uv_handle_type pending) {\n+  int r;\n+  uv_buf_t outbuf;\n+  uv_err_t err;\n+\n+  if (nread == 0) {\n+    /* Everything OK, but nothing read. */\n+    free(buf.base);\n+    return;\n+  }\n+\n+  if (nread < 0) {\n+    err = uv_last_error(pipe->loop);\n+    if (err.code == UV_EOF) {\n+      free(buf.base);\n+      return;\n+    }\n+\n+    printf(\"error recving on channel: %s\\n\", uv_strerror(err));\n+    abort();\n+  }\n+\n+  fprintf(stderr, \"got %d bytes\\n\", (int)nread);\n+\n+  if (!tcp_server_listening) {\n+    ASSERT(nread > 0 && buf.base && pending != UV_UNKNOWN_HANDLE);\n+    read2_cb_called++;\n+\n+    /* Accept the pending TCP server, and start listening on it. */\n+    ASSERT(pending == UV_TCP);\n+    r = uv_tcp_init(uv_default_loop(), &tcp_server);\n+    ASSERT(r == 0);\n+\n+    r = uv_accept((uv_stream_t*)pipe, (uv_stream_t*)&tcp_server);\n+    ASSERT(r == 0);\n+\n+    r = uv_listen((uv_stream_t*)&tcp_server, 12, ipc_on_connection);\n+    ASSERT(r == 0);\n+\n+    tcp_server_listening = 1;\n+\n+    /* Make sure that the expected data is correctly multiplexed. */\n+    ASSERT(memcmp(\"hello\\n\", buf.base, nread) == 0);\n+\n+    outbuf = uv_buf_init(\"world\\n\", 6);\n+    r = uv_write(&write_req, (uv_stream_t*)pipe, &outbuf, 1, NULL);\n+    ASSERT(r == 0);\n+\n+    /* Create a bunch of connections to get both servers to accept. */\n+    make_many_connections();\n+  } else if (memcmp(\"accepted_connection\\n\", buf.base, nread) == 0) {\n+    /* Remote server has accepted a connection.  Close the channel. */\n+    ASSERT(pending == UV_UNKNOWN_HANDLE);\n+    remote_conn_accepted = 1;\n+    uv_close((uv_handle_t*)&channel, NULL);\n+  }\n+\n+  free(buf.base);\n+}\n+\n+\n+TEST_IMPL(ipc) {\n+  int r;\n+  uv_process_options_t options;\n+  uv_process_t process;\n+\n+  r = uv_pipe_init(uv_default_loop(), &channel, 1);\n+  ASSERT(r == 0);\n+  ASSERT(channel.ipc);\n+\n+  memset(&options, 0, sizeof(uv_process_options_t));\n+\n+  r = uv_exepath(exepath, &exepath_size);\n+  ASSERT(r == 0);\n+  exepath[exepath_size] = '\\0';\n+  args[0] = exepath;\n+  args[1] = \"ipc_helper\";\n+  args[2] = NULL;\n+  options.file = exepath;\n+  options.args = args;\n+  options.exit_cb = exit_cb;\n+  options.stdin_stream = &channel;\n+\n+  r = uv_spawn(uv_default_loop(), &process, options);\n+  ASSERT(r == 0);\n+\n+  uv_read2_start((uv_stream_t*)&channel, on_alloc, on_read);\n+\n+  r = uv_run(uv_default_loop());\n+  ASSERT(r == 0);\n+\n+  ASSERT(local_conn_accepted == 1);\n+  ASSERT(remote_conn_accepted == 1);\n+  ASSERT(read2_cb_called == 1);\n+  ASSERT(exit_cb_called == 1);\n+  return 0;\n+}"}, {"sha": "19c999132676986cf1dd1c64b6893b36c649183e", "filename": "src/rt/libuv/test/test-list.h", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-list.h", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-list.h?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -20,8 +20,12 @@\n  */\n \n TEST_DECLARE   (tty)\n+TEST_DECLARE   (stdio_over_pipes)\n+TEST_DECLARE   (ipc)\n TEST_DECLARE   (tcp_ping_pong)\n TEST_DECLARE   (tcp_ping_pong_v6)\n+TEST_DECLARE   (tcp_ref)\n+TEST_DECLARE   (tcp_ref2)\n TEST_DECLARE   (pipe_ping_pong)\n TEST_DECLARE   (delayed_accept)\n TEST_DECLARE   (tcp_writealot)\n@@ -33,13 +37,15 @@ TEST_DECLARE   (tcp_bind_error_inval)\n TEST_DECLARE   (tcp_bind_localhost_ok)\n TEST_DECLARE   (tcp_listen_without_bind)\n TEST_DECLARE   (tcp_close)\n+TEST_DECLARE   (tcp_flags)\n TEST_DECLARE   (tcp_write_error)\n TEST_DECLARE   (tcp_bind6_error_addrinuse)\n TEST_DECLARE   (tcp_bind6_error_addrnotavail)\n TEST_DECLARE   (tcp_bind6_error_fault)\n TEST_DECLARE   (tcp_bind6_error_inval)\n TEST_DECLARE   (tcp_bind6_localhost_ok)\n TEST_DECLARE   (udp_send_and_recv)\n+TEST_DECLARE   (udp_multicast_join)\n TEST_DECLARE   (udp_dgram_too_big)\n TEST_DECLARE   (udp_dual_stack)\n TEST_DECLARE   (udp_ipv6_only)\n@@ -51,18 +57,23 @@ TEST_DECLARE   (connection_fail)\n TEST_DECLARE   (connection_fail_doesnt_auto_close)\n TEST_DECLARE   (shutdown_eof)\n TEST_DECLARE   (callback_stack)\n+TEST_DECLARE   (error_message)\n TEST_DECLARE   (timer)\n+TEST_DECLARE   (timer_ref)\n+TEST_DECLARE   (timer_ref2)\n TEST_DECLARE   (timer_again)\n TEST_DECLARE   (idle_starvation)\n TEST_DECLARE   (loop_handles)\n TEST_DECLARE   (ref)\n TEST_DECLARE   (idle_ref)\n+TEST_DECLARE   (get_loadavg)\n TEST_DECLARE   (async_ref)\n TEST_DECLARE   (prepare_ref)\n TEST_DECLARE   (check_ref)\n TEST_DECLARE   (unref_in_prepare_cb)\n TEST_DECLARE   (async)\n TEST_DECLARE   (get_currentexe)\n+TEST_DECLARE   (get_memory)\n TEST_DECLARE   (hrtime)\n TEST_DECLARE   (getaddrinfo_basic)\n TEST_DECLARE   (getaddrinfo_concurrent)\n@@ -75,6 +86,7 @@ TEST_DECLARE   (spawn_exit_code)\n TEST_DECLARE   (spawn_stdout)\n TEST_DECLARE   (spawn_stdin)\n TEST_DECLARE   (spawn_and_kill)\n+TEST_DECLARE   (spawn_and_ping)\n TEST_DECLARE   (fs_file_noent)\n TEST_DECLARE   (fs_file_async)\n TEST_DECLARE   (fs_file_sync)\n@@ -87,9 +99,13 @@ TEST_DECLARE   (fs_link)\n TEST_DECLARE   (fs_symlink)\n TEST_DECLARE   (fs_utime)\n TEST_DECLARE   (fs_futime)\n+TEST_DECLARE   (fs_stat_missing_path)\n TEST_DECLARE   (fs_event_watch_dir)\n TEST_DECLARE   (fs_event_watch_file)\n TEST_DECLARE   (fs_event_watch_file_current_dir)\n+TEST_DECLARE   (fs_readdir_empty_dir)\n+TEST_DECLARE   (fs_readdir_file)\n+TEST_DECLARE   (fs_open_dir)\n TEST_DECLARE   (threadpool_queue_work_simple)\n #ifdef _WIN32\n TEST_DECLARE   (spawn_detect_pipe_name_collisions_on_windows)\n@@ -103,6 +119,14 @@ HELPER_DECLARE (pipe_echo_server)\n \n TASK_LIST_START\n   TEST_ENTRY  (tty)\n+  TEST_ENTRY  (stdio_over_pipes)\n+  TEST_ENTRY  (ipc)\n+\n+\n+  TEST_ENTRY  (tcp_ref)\n+\n+  TEST_ENTRY  (tcp_ref2)\n+  TEST_HELPER (tcp_ref2, tcp4_echo_server)\n \n   TEST_ENTRY  (tcp_ping_pong)\n   TEST_HELPER (tcp_ping_pong, tcp4_echo_server)\n@@ -126,6 +150,7 @@ TASK_LIST_START\n   TEST_ENTRY  (tcp_bind_localhost_ok)\n   TEST_ENTRY  (tcp_listen_without_bind)\n   TEST_ENTRY  (tcp_close)\n+  TEST_ENTRY  (tcp_flags)\n   TEST_ENTRY  (tcp_write_error)\n \n   TEST_ENTRY  (tcp_bind6_error_addrinuse)\n@@ -138,6 +163,7 @@ TASK_LIST_START\n   TEST_ENTRY  (udp_dgram_too_big)\n   TEST_ENTRY  (udp_dual_stack)\n   TEST_ENTRY  (udp_ipv6_only)\n+  TEST_ENTRY  (udp_multicast_join)\n \n   TEST_ENTRY  (pipe_bind_error_addrinuse)\n   TEST_ENTRY  (pipe_bind_error_addrnotavail)\n@@ -153,7 +179,11 @@ TASK_LIST_START\n   TEST_ENTRY  (callback_stack)\n   TEST_HELPER (callback_stack, tcp4_echo_server)\n \n+  TEST_ENTRY  (error_message)\n+\n   TEST_ENTRY  (timer)\n+  TEST_ENTRY  (timer_ref)\n+  TEST_ENTRY  (timer_ref2)\n \n   TEST_ENTRY  (timer_again)\n \n@@ -172,6 +202,10 @@ TASK_LIST_START\n \n   TEST_ENTRY  (get_currentexe)\n \n+  TEST_ENTRY  (get_memory)\n+\n+  TEST_ENTRY  (get_loadavg)\n+\n   TEST_ENTRY  (hrtime)\n \n   TEST_ENTRY  (getaddrinfo_basic)\n@@ -187,6 +221,7 @@ TASK_LIST_START\n   TEST_ENTRY  (spawn_stdout)\n   TEST_ENTRY  (spawn_stdin)\n   TEST_ENTRY  (spawn_and_kill)\n+  TEST_ENTRY  (spawn_and_ping)\n #ifdef _WIN32\n   TEST_ENTRY  (spawn_detect_pipe_name_collisions_on_windows)\n   TEST_ENTRY  (argument_escaping)\n@@ -204,10 +239,13 @@ TASK_LIST_START\n   TEST_ENTRY  (fs_utime)\n   TEST_ENTRY  (fs_futime)\n   TEST_ENTRY  (fs_symlink)\n+  TEST_ENTRY  (fs_stat_missing_path)\n   TEST_ENTRY  (fs_event_watch_dir)\n   TEST_ENTRY  (fs_event_watch_file)\n   TEST_ENTRY  (fs_event_watch_file_current_dir)\n-\n+  TEST_ENTRY  (fs_readdir_empty_dir)\n+  TEST_ENTRY  (fs_readdir_file)\n+  TEST_ENTRY  (fs_open_dir)\n   TEST_ENTRY  (threadpool_queue_work_simple)\n \n #if 0"}, {"sha": "0e59166c48d13073ade17f3c419c5818b018f470", "filename": "src/rt/libuv/test/test-ping-pong.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-ping-pong.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-ping-pong.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-ping-pong.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -204,7 +204,7 @@ static void pipe_pinger_new() {\n   pinger->pongs = 0;\n \n   /* Try to connec to the server and do NUM_PINGS ping-pongs. */\n-  r = uv_pipe_init(uv_default_loop(), &pinger->stream.pipe);\n+  r = uv_pipe_init(uv_default_loop(), &pinger->stream.pipe, 0);\n   pinger->stream.pipe.data = pinger;\n   ASSERT(!r);\n "}, {"sha": "3443f19dc872096482594808e2124efdb3ef743b", "filename": "src/rt/libuv/test/test-pipe-bind-error.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-pipe-bind-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-pipe-bind-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-pipe-bind-error.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -45,12 +45,12 @@ TEST_IMPL(pipe_bind_error_addrinuse) {\n   uv_pipe_t server1, server2;\n   int r;\n \n-  r = uv_pipe_init(uv_default_loop(), &server1);\n+  r = uv_pipe_init(uv_default_loop(), &server1, 0);\n   ASSERT(r == 0);\n   r = uv_pipe_bind(&server1, TEST_PIPENAME);\n   ASSERT(r == 0);\n \n-  r = uv_pipe_init(uv_default_loop(), &server2);\n+  r = uv_pipe_init(uv_default_loop(), &server2, 0);\n   ASSERT(r == 0);\n   r = uv_pipe_bind(&server2, TEST_PIPENAME);\n   ASSERT(r == -1);\n@@ -79,7 +79,7 @@ TEST_IMPL(pipe_bind_error_addrnotavail) {\n   uv_pipe_t server;\n   int r;\n \n-  r = uv_pipe_init(uv_default_loop(), &server);\n+  r = uv_pipe_init(uv_default_loop(), &server, 0);\n   ASSERT(r == 0);\n   r = uv_pipe_bind(&server, BAD_PIPENAME);\n \n@@ -100,7 +100,7 @@ TEST_IMPL(pipe_bind_error_inval) {\n   uv_pipe_t server;\n   int r;\n \n-  r = uv_pipe_init(uv_default_loop(), &server);\n+  r = uv_pipe_init(uv_default_loop(), &server, 0);\n   ASSERT(r == 0);\n   r = uv_pipe_bind(&server, TEST_PIPENAME);\n   ASSERT(r == 0);\n@@ -123,7 +123,7 @@ TEST_IMPL(pipe_listen_without_bind) {\n   uv_pipe_t server;\n   int r;\n \n-  r = uv_pipe_init(uv_default_loop(), &server);\n+  r = uv_pipe_init(uv_default_loop(), &server, 0);\n   ASSERT(r == 0);\n   r = uv_listen((uv_stream_t*)&server, SOMAXCONN, NULL);\n   ASSERT(r == -1);"}, {"sha": "e73515858ceedb0a067944bb7bd62e5e847e6493", "filename": "src/rt/libuv/test/test-spawn.c", "status": "modified", "additions": 47, "deletions": 6, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-spawn.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-spawn.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-spawn.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -67,7 +67,7 @@ static void kill_cb(uv_process_t* process, int exit_status, int term_signal) {\n }\n \n \n-uv_buf_t on_alloc(uv_handle_t* handle, size_t suggested_size) {\n+static uv_buf_t on_alloc(uv_handle_t* handle, size_t suggested_size) {\n   uv_buf_t buf;\n   buf.base = output + output_used;\n   buf.len = OUTPUT_SIZE - output_used;\n@@ -138,7 +138,7 @@ TEST_IMPL(spawn_stdout) {\n \n   init_process_options(\"spawn_helper2\", exit_cb);\n \n-  uv_pipe_init(uv_default_loop(), &out);\n+  uv_pipe_init(uv_default_loop(), &out, 0);\n   options.stdout_stream = &out;\n \n   r = uv_spawn(uv_default_loop(), &process, options);\n@@ -160,7 +160,7 @@ TEST_IMPL(spawn_stdout) {\n \n \n TEST_IMPL(spawn_stdin) {\n-int r;\n+  int r;\n   uv_pipe_t out;\n   uv_pipe_t in;\n   uv_write_t write_req;\n@@ -169,8 +169,8 @@ int r;\n \n   init_process_options(\"spawn_helper3\", exit_cb);\n \n-  uv_pipe_init(uv_default_loop(), &out);\n-  uv_pipe_init(uv_default_loop(), &in);\n+  uv_pipe_init(uv_default_loop(), &out, 0);\n+  uv_pipe_init(uv_default_loop(), &in, 0);\n   options.stdout_stream = &out;\n   options.stdin_stream = &in;\n \n@@ -220,6 +220,47 @@ TEST_IMPL(spawn_and_kill) {\n }\n \n \n+TEST_IMPL(spawn_and_ping) {\n+  uv_write_t write_req;\n+  uv_pipe_t in, out;\n+  uv_buf_t buf;\n+  int r;\n+\n+  init_process_options(\"spawn_helper3\", exit_cb);\n+  buf = uv_buf_init(\"TEST\", 4);\n+\n+  uv_pipe_init(uv_default_loop(), &out, 0);\n+  uv_pipe_init(uv_default_loop(), &in, 0);\n+  options.stdout_stream = &out;\n+  options.stdin_stream = &in;\n+\n+  r = uv_spawn(uv_default_loop(), &process, options);\n+  ASSERT(r == 0);\n+\n+  /* Sending signum == 0 should check if the\n+   * child process is still alive, not kill it.\n+   */\n+  r = uv_process_kill(&process, 0);\n+  ASSERT(r == 0);\n+\n+  r = uv_write(&write_req, (uv_stream_t*)&in, &buf, 1, write_cb);\n+  ASSERT(r == 0);\n+\n+  r = uv_read_start((uv_stream_t*)&out, on_alloc, on_read);\n+  ASSERT(r == 0);\n+\n+  ASSERT(exit_cb_called == 0);\n+\n+  r = uv_run(uv_default_loop());\n+  ASSERT(r == 0);\n+\n+  ASSERT(exit_cb_called == 1);\n+  ASSERT(strcmp(output, \"TEST\") == 0);\n+\n+  return 0;\n+}\n+\n+\n #ifdef _WIN32\n TEST_IMPL(spawn_detect_pipe_name_collisions_on_windows) {\n   int r;\n@@ -229,7 +270,7 @@ TEST_IMPL(spawn_detect_pipe_name_collisions_on_windows) {\n \n   init_process_options(\"spawn_helper2\", exit_cb);\n \n-  uv_pipe_init(uv_default_loop(), &out);\n+  uv_pipe_init(uv_default_loop(), &out, 0);\n   options.stdout_stream = &out;\n \n   /* Create a pipe that'll cause a collision. */"}, {"sha": "fd96fc2d28a818dcbc46bcacffc5e115c43cc19e", "filename": "src/rt/libuv/test/test-stdio-over-pipes.c", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-stdio-over-pipes.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-stdio-over-pipes.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-stdio-over-pipes.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -0,0 +1,154 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"task.h\"\n+\n+\n+static char exepath[1024];\n+static size_t exepath_size = 1024;\n+static char* args[3];\n+static uv_process_options_t options;\n+static int close_cb_called;\n+static int exit_cb_called;\n+static int on_read_cb_called;\n+static int after_write_cb_called;\n+uv_pipe_t out, in;\n+static uv_loop_t* loop;\n+#define OUTPUT_SIZE 1024\n+static char output[OUTPUT_SIZE];\n+static int output_used;\n+\n+typedef struct {\n+  uv_write_t req;\n+  uv_buf_t buf;\n+} write_req_t;\n+\n+\n+static void close_cb(uv_handle_t* handle) {\n+  printf(\"close_cb\\n\");\n+  close_cb_called++;\n+}\n+\n+\n+static void exit_cb(uv_process_t* process, int exit_status, int term_signal) {\n+  printf(\"exit_cb\\n\");\n+  exit_cb_called++;\n+  ASSERT(exit_status == 0);\n+  ASSERT(term_signal == 0);\n+  uv_close((uv_handle_t*)process, close_cb);\n+  uv_close((uv_handle_t*)&in, close_cb);\n+  uv_close((uv_handle_t*)&out, close_cb);\n+}\n+\n+\n+static void init_process_options(char* test, uv_exit_cb exit_cb) {\n+  int r = uv_exepath(exepath, &exepath_size);\n+  ASSERT(r == 0);\n+  exepath[exepath_size] = '\\0';\n+  args[0] = exepath;\n+  args[1] = test;\n+  args[2] = NULL;\n+  options.file = exepath;\n+  options.args = args;\n+  options.exit_cb = exit_cb;\n+}\n+\n+\n+static uv_buf_t on_alloc(uv_handle_t* handle, size_t suggested_size) {\n+  uv_buf_t buf;\n+  buf.base = output + output_used;\n+  buf.len = OUTPUT_SIZE - output_used;\n+  return buf;\n+}\n+\n+\n+static void after_write(uv_write_t* req, int status) {\n+  write_req_t* wr;\n+\n+  if (status) {\n+    uv_err_t err = uv_last_error(loop);\n+    fprintf(stderr, \"uv_write error: %s\\n\", uv_strerror(err));\n+    ASSERT(0);\n+  }\n+\n+  wr = (write_req_t*) req;\n+\n+  /* Free the read/write buffer and the request */\n+  free(wr);\n+\n+  after_write_cb_called++;\n+}\n+\n+\n+static void on_read(uv_stream_t* tcp, ssize_t nread, uv_buf_t buf) {\n+  write_req_t* write_req;\n+  int r;\n+  uv_err_t err = uv_last_error(uv_default_loop());\n+\n+  ASSERT(nread > 0 || err.code == UV_EOF);\n+\n+  if (nread > 0) {\n+    output_used += nread;\n+    if (output_used == 12) {\n+      ASSERT(memcmp(\"hello world\\n\", output, 12) == 0);\n+      write_req = (write_req_t*)malloc(sizeof(*write_req));\n+      write_req->buf = uv_buf_init(output, output_used);\n+      r = uv_write(&write_req->req, (uv_stream_t*)&in, &write_req->buf, 1, after_write);\n+      ASSERT(r == 0);\n+    }\n+  }\n+\n+  on_read_cb_called++;\n+}\n+\n+\n+TEST_IMPL(stdio_over_pipes) {\n+  int r;\n+  uv_process_t process;\n+  loop = uv_default_loop();\n+\n+  init_process_options(\"stdio_over_pipes_helper\", exit_cb);\n+\n+  uv_pipe_init(loop, &out, 0);\n+  options.stdout_stream = &out;\n+  uv_pipe_init(loop, &in, 0);\n+  options.stdin_stream = &in;\n+\n+  r = uv_spawn(loop, &process, options);\n+  ASSERT(r == 0);\n+\n+  r = uv_read_start((uv_stream_t*) &out, on_alloc, on_read);\n+  ASSERT(r == 0);\n+\n+  r = uv_run(uv_default_loop());\n+  ASSERT(r == 0);\n+\n+  ASSERT(on_read_cb_called > 1);\n+  ASSERT(after_write_cb_called == 1);\n+  ASSERT(exit_cb_called == 1);\n+  ASSERT(close_cb_called == 3);\n+  ASSERT(memcmp(\"hello world\\n\", output, 12) == 0);\n+  ASSERT(output_used == 12);\n+\n+  return 0;\n+}\n+"}, {"sha": "f5dd0a440582be4888c1f4254018174a6dfe1b34", "filename": "src/rt/libuv/test/test-tcp-close.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-close.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-close.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-close.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -127,3 +127,50 @@ TEST_IMPL(tcp_close) {\n \n   return 0;\n }\n+\n+\n+TEST_IMPL(tcp_ref) {\n+  uv_tcp_t never;\n+  int r;\n+\n+  /* A tcp just initialized should count as one reference. */\n+  r = uv_tcp_init(uv_default_loop(), &never);\n+  ASSERT(r == 0);\n+\n+  /* One unref should set the loop ref count to zero. */\n+  uv_unref(uv_default_loop());\n+\n+  /* Therefore this does not block */\n+  uv_run(uv_default_loop());\n+\n+  return 0;\n+}\n+\n+\n+static void never_cb(uv_connect_t* conn_req, int status) {\n+  FATAL(\"never_cb should never be called\");\n+}\n+\n+\n+TEST_IMPL(tcp_ref2) {\n+  uv_tcp_t never;\n+  int r;\n+\n+  /* A tcp just initialized should count as one reference. */\n+  r = uv_tcp_init(uv_default_loop(), &never);\n+  ASSERT(r == 0);\n+\n+  r = uv_tcp_connect(&connect_req,\n+                     &never,\n+                     uv_ip4_addr(\"127.0.0.1\", TEST_PORT),\n+                     never_cb);\n+  ASSERT(r == 0);\n+\n+  /* One unref should set the loop ref count to zero. */\n+  uv_unref(uv_default_loop());\n+\n+  /* Therefore this does not block */\n+  uv_run(uv_default_loop());\n+\n+  return 0;\n+}"}, {"sha": "5cdacab6321e609856c7df62eeb63f4b49f2281f", "filename": "src/rt/libuv/test/test-tcp-connect-error.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-connect-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-connect-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-connect-error.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -0,0 +1,70 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"task.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+\n+static int connect_cb_called = 0;\n+static int close_cb_called = 0;\n+\n+\n+\n+static void connect_cb(uv_connect_t* handle, int status) {\n+  ASSERT(handle != NULL);\n+  connect_cb_called++;\n+}\n+\n+\n+\n+static void close_cb(uv_handle_t* handle) {\n+  ASSERT(handle != NULL);\n+  close_cb_called++;\n+}\n+\n+\n+TEST_IMPL(tcp_connect_error_fault) {\n+  char garbage[] = \"blah blah blah blah blah blah blah blah blah blah blah blah\";\n+  struct sockaddr_in* garbage_addr;\n+  uv_tcp_t server;\n+  int r;\n+  uv_connect_t req;\n+\n+  garbage_addr = (struct sockaddr_in*) &garbage;\n+\n+  r = uv_tcp_init(uv_default_loop(), &server);\n+  ASSERT(r == 0);\n+  r = uv_tcp_connect(&req, &server, *garbage_addr, connect_cb);\n+  ASSERT(r == -1);\n+\n+  ASSERT(uv_last_error(uv_default_loop()).code == UV_EINVAL);\n+\n+  uv_close((uv_handle_t*)&server, close_cb);\n+\n+  uv_run(uv_default_loop());\n+\n+  ASSERT(connect_cb_called == 0);\n+  ASSERT(close_cb_called == 1);\n+\n+  return 0;\n+}"}, {"sha": "5c158ff87656983b7b89161087d7811dda36a6ca", "filename": "src/rt/libuv/test/test-tcp-connect6-error.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-connect6-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-connect6-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-connect6-error.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -0,0 +1,68 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"task.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+\n+static int connect_cb_called = 0;\n+static int close_cb_called = 0;\n+\n+\n+static void connect_cb(uv_connect_t* handle, int status) {\n+  ASSERT(handle != NULL);\n+  connect_cb_called++;\n+}\n+\n+\n+static void close_cb(uv_handle_t* handle) {\n+  ASSERT(handle != NULL);\n+  close_cb_called++;\n+}\n+\n+\n+TEST_IMPL(tcp_connect6_error_fault) {\n+  char garbage[] = \"blah blah blah blah blah blah blah blah blah blah blah blah\";\n+  struct sockaddr_in6* garbage_addr;\n+  uv_tcp_t server;\n+  int r;\n+  uv_connect_t req;\n+\n+  garbage_addr = (struct sockaddr_in6*) &garbage;\n+\n+  r = uv_tcp_init(uv_default_loop(), &server);\n+  ASSERT(r == 0);\n+  r = uv_tcp_connect6(&req, &server, *garbage_addr, connect_cb);\n+  ASSERT(r == -1);\n+\n+  ASSERT(uv_last_error(uv_default_loop()).code == UV_EINVAL);\n+\n+  uv_close((uv_handle_t*)&server, close_cb);\n+\n+  uv_run(uv_default_loop());\n+\n+  ASSERT(connect_cb_called == 0);\n+  ASSERT(close_cb_called == 1);\n+\n+  return 0;\n+}"}, {"sha": "c441b563f4a44529a3da7c8598c14fa5e518d545", "filename": "src/rt/libuv/test/test-tcp-flags.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-flags.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-flags.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-flags.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -0,0 +1,51 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"task.h\"\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+\n+TEST_IMPL(tcp_flags) {\n+  uv_loop_t* loop;\n+  uv_tcp_t handle;\n+  int r;\n+\n+  loop = uv_default_loop();\n+\n+  r = uv_tcp_init(loop, &handle);\n+  ASSERT(r == 0);\n+\n+  r = uv_tcp_nodelay(&handle, 1);\n+  ASSERT(r == 0);\n+\n+  r = uv_tcp_keepalive(&handle, 1, 60);\n+  ASSERT(r == 0);\n+\n+  uv_close((uv_handle_t*)&handle, NULL);\n+\n+  r = uv_run(loop);\n+  ASSERT(r == 0);\n+\n+  return 0;\n+}"}, {"sha": "c5907676be90199c0b5e9bbd3df8e61e508f71a5", "filename": "src/rt/libuv/test/test-tcp-write-error.c", "status": "modified", "additions": 39, "deletions": 25, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-write-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-write-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-write-error.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -35,10 +35,15 @@ static uv_buf_t alloc_cb(uv_handle_t* handle, size_t suggested_size);\n static uv_tcp_t tcp_server;\n static uv_tcp_t tcp_client;\n static uv_tcp_t tcp_peer; /* client socket as accept()-ed by server */\n-static uv_write_t write_req;\n static uv_connect_t connect_req;\n \n static int write_cb_called;\n+static int write_cb_error_called;\n+ \n+typedef struct {\n+  uv_write_t req;\n+  uv_buf_t buf;\n+} write_req_t;\n \n \n static void connection_cb(uv_stream_t* server, int status) {\n@@ -75,40 +80,47 @@ static void connect_cb(uv_connect_t* req, int status) {\n   size_t size;\n   char* data;\n   int r;\n+  write_req_t* wr;\n \n   ASSERT(req == &connect_req);\n   ASSERT(status == 0);\n \n-  size = 10*1024*1024;\n-  data = malloc(size);\n-  ASSERT(data != NULL);\n-\n-  memset(data, '$', size);\n-  buf = uv_buf_init(data, size);\n-\n-  write_req.data = data;\n-\n-  r = uv_write(&write_req, req->handle, &buf, 1, write_cb);\n-  ASSERT(r == 0);\n-\n-  /* Write queue should have been updated. */\n-  ASSERT(req->handle->write_queue_size > 0);\n-\n-  /* write_queue_size <= size, part may have already been written. */\n-  ASSERT(req->handle->write_queue_size <= size);\n+  while (1) {\n+    size = 10 * 1024 * 1024;\n+    data = malloc(size);\n+    ASSERT(data != NULL);\n+ \n+    memset(data, '$', size);\n+    buf = uv_buf_init(data, size);\n+ \n+    wr = (write_req_t*) malloc(sizeof *wr);\n+    wr->buf = buf;\n+    wr->req.data = data;\n+ \n+    r = uv_write(&(wr->req), req->handle, &wr->buf, 1, write_cb);\n+    ASSERT(r == 0);\n+ \n+    if (req->handle->write_queue_size > 0) {\n+      break;\n+    }\n+  }\n }\n \n \n static void write_cb(uv_write_t* req, int status) {\n-  ASSERT(req == &write_req);\n-  ASSERT(status == -1);\n+  write_req_t* wr;\n+  wr = (write_req_t*) req;\n \n-  /* This is what this test is all about. */\n-  ASSERT(tcp_client.write_queue_size == 0);\n+  if (status == -1) {\n+    write_cb_error_called++;\n+  }\n \n-  free(write_req.data);\n+  if (req->handle->write_queue_size == 0) {\n+    uv_close((uv_handle_t*)&tcp_client, NULL);\n+  }\n \n-  uv_close((uv_handle_t*)&tcp_client, NULL);\n+  free(wr->buf.base);\n+  free(wr);\n \n   write_cb_called++;\n }\n@@ -148,7 +160,9 @@ TEST_IMPL(tcp_write_error) {\n   r = uv_run(loop);\n   ASSERT(r == 0);\n \n-  ASSERT(write_cb_called == 1);\n+  ASSERT(write_cb_called > 0);\n+  ASSERT(write_cb_error_called == 1);\n+  ASSERT(tcp_client.write_queue_size == 0);\n \n   return 0;\n }"}, {"sha": "87235a51bc744282123a1e0b1c3b2aa746b62379", "filename": "src/rt/libuv/test/test-timer.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-timer.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-timer.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-timer.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -130,3 +130,43 @@ TEST_IMPL(timer) {\n \n   return 0;\n }\n+\n+\n+TEST_IMPL(timer_ref) {\n+  uv_timer_t never;\n+  int r;\n+\n+  /* A timer just initialized should count as one reference. */\n+  r = uv_timer_init(uv_default_loop(), &never);\n+  ASSERT(r == 0);\n+\n+  /* One unref should set the loop ref count to zero. */\n+  uv_unref(uv_default_loop());\n+\n+  /* Therefore this does not block */\n+  uv_run(uv_default_loop());\n+\n+  return 0;\n+}\n+\n+\n+TEST_IMPL(timer_ref2) {\n+  uv_timer_t never;\n+  int r;\n+\n+  /* A timer just initialized should count as one reference. */\n+  r = uv_timer_init(uv_default_loop(), &never);\n+  ASSERT(r == 0);\n+\n+  /* We start the timer, this should not effect the ref count. */\n+  r = uv_timer_start(&never, never_cb, 1000, 1000);\n+  ASSERT(r == 0);\n+\n+  /* One unref should set the loop ref count to zero. */\n+  uv_unref(uv_default_loop());\n+\n+  /* Therefore this does not block */\n+  uv_run(uv_default_loop());\n+\n+  return 0;\n+}"}, {"sha": "60aedf39a940a3568eede455c7299139606a97c6", "filename": "src/rt/libuv/test/test-tty.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-tty.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-tty.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tty.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -33,7 +33,7 @@ TEST_IMPL(tty) {\n    */\n   ASSERT(UV_TTY == uv_guess_handle(0));\n \n-  r = uv_tty_init(uv_default_loop(), &tty, 0);\n+  r = uv_tty_init(uv_default_loop(), &tty, 0, 1);\n   ASSERT(r == 0);\n \n   r = uv_tty_get_winsize(&tty, &width, &height);\n@@ -48,6 +48,16 @@ TEST_IMPL(tty) {\n   ASSERT(width > 10);\n   ASSERT(height > 10);\n \n+  /* Turn on raw mode. */\n+  r = uv_tty_set_mode(&tty, 1);\n+  ASSERT(r == 0);\n+\n+  /* Turn off raw mode. */\n+  r = uv_tty_set_mode(&tty, 0);\n+  ASSERT(r == 0);\n+\n+  /* TODO check the actual mode! */\n+\n   uv_close((uv_handle_t*)&tty, NULL);\n \n   uv_run(loop);"}, {"sha": "159dba0819661fd68cbeb0805912b517cc2adc25", "filename": "src/rt/libuv/test/test-udp-multicast-join.c", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-multicast-join.c", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-multicast-join.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-multicast-join.c?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -0,0 +1,139 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"task.h\"\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#define CHECK_HANDLE(handle) \\\n+  ASSERT((uv_udp_t*)(handle) == &server || (uv_udp_t*)(handle) == &client)\n+\n+static uv_udp_t server;\n+static uv_udp_t client;\n+\n+static int cl_recv_cb_called;\n+\n+static int sv_send_cb_called;\n+\n+static int close_cb_called;\n+\n+static uv_buf_t alloc_cb(uv_handle_t* handle, size_t suggested_size) {\n+  static char slab[65536];\n+\n+  CHECK_HANDLE(handle);\n+  ASSERT(suggested_size <= sizeof slab);\n+\n+  return uv_buf_init(slab, sizeof slab);\n+}\n+\n+\n+static void close_cb(uv_handle_t* handle) {\n+  CHECK_HANDLE(handle);\n+  close_cb_called++;\n+}\n+\n+\n+static void sv_send_cb(uv_udp_send_t* req, int status) {\n+  ASSERT(req != NULL);\n+  ASSERT(status == 0);\n+  CHECK_HANDLE(req->handle);\n+\n+  sv_send_cb_called++;\n+\n+  uv_close((uv_handle_t*) req->handle, close_cb);\n+}\n+\n+\n+static void cl_recv_cb(uv_udp_t* handle,\n+                       ssize_t nread,\n+                       uv_buf_t buf,\n+                       struct sockaddr* addr,\n+                       unsigned flags) {\n+  CHECK_HANDLE(handle);\n+  ASSERT(flags == 0);\n+\n+  cl_recv_cb_called++;\n+\n+  if (nread < 0) {\n+    ASSERT(0 && \"unexpected error\");\n+  }\n+\n+  if (nread == 0) {\n+    /* Returning unused buffer */\n+    /* Don't count towards cl_recv_cb_called */\n+    ASSERT(addr == NULL);\n+    return;\n+  }\n+\n+  ASSERT(addr != NULL);\n+  ASSERT(nread == 4);\n+  ASSERT(!memcmp(\"PING\", buf.base, nread));\n+\n+  /* we are done with the client handle, we can close it */\n+  uv_close((uv_handle_t*) &client, close_cb);\n+}\n+\n+\n+TEST_IMPL(udp_multicast_join) {\n+  int r;\n+  uv_udp_send_t req;\n+  uv_buf_t buf;\n+  struct sockaddr_in addr = uv_ip4_addr(\"239.255.0.1\", TEST_PORT);\n+\n+  r = uv_udp_init(uv_default_loop(), &server);\n+  ASSERT(r == 0);\n+\n+  r = uv_udp_init(uv_default_loop(), &client);\n+  ASSERT(r == 0);\n+\n+  /* bind to the desired port */\n+  r = uv_udp_bind(&client, addr, 0);\n+  ASSERT(r == 0);\n+\n+  /* join the multicast channel */\n+  r = uv_udp_set_membership(&client, \"239.255.0.1\", NULL, UV_JOIN_GROUP);\n+  ASSERT(r == 0);\n+\n+  r = uv_udp_recv_start(&client, alloc_cb, cl_recv_cb);\n+  ASSERT(r == 0);\n+\n+  buf = uv_buf_init(\"PING\", 4);\n+\n+  /* server sends \"PING\" */\n+  r = uv_udp_send(&req, &server, &buf, 1, addr, sv_send_cb);\n+  ASSERT(r == 0);\n+\n+  ASSERT(close_cb_called == 0);\n+  ASSERT(cl_recv_cb_called == 0);\n+  ASSERT(sv_send_cb_called == 0);\n+\n+  /* run the loop till all events are processed */\n+  uv_run(uv_default_loop());\n+\n+  ASSERT(cl_recv_cb_called == 1);\n+  ASSERT(sv_send_cb_called == 1);\n+  ASSERT(close_cb_called == 2);\n+\n+  return 0;\n+}"}, {"sha": "b4ef0144048b33531ba0840acfeb134eaca394df", "filename": "src/rt/libuv/uv.gyp", "status": "modified", "additions": 59, "deletions": 14, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fuv.gyp", "raw_url": "https://github.com/rust-lang/rust/raw/bdbeb75bfb868c98d528cdf131c8102c58be195b/src%2Frt%2Flibuv%2Fuv.gyp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fuv.gyp?ref=bdbeb75bfb868c98d528cdf131c8102c58be195b", "patch": "@@ -1,4 +1,17 @@\n {\n+  'target_defaults': {\n+    'conditions': [\n+      ['OS != \"win\"', {\n+        'defines': [\n+          '_LARGEFILE_SOURCE',\n+          '_FILE_OFFSET_BITS=64',\n+          '_GNU_SOURCE',\n+          'EIO_STACKSIZE=262144'\n+        ],\n+      }],\n+    ],\n+  },\n+\n   'targets': [\n     {\n       'target_name': 'uv',\n@@ -21,11 +34,8 @@\n         'include/uv.h',\n         'src/uv-common.c',\n         'src/uv-common.h',\n-        'src/ares/ares__close_sockets.c',\n-        'src/ares/ares__get_hostent.c',\n-        'src/ares/ares__read_line.c',\n-        'src/ares/ares__timeval.c',\n         'src/ares/ares_cancel.c',\n+        'src/ares/ares__close_sockets.c',\n         'src/ares/ares_data.c',\n         'src/ares/ares_data.h',\n         'src/ares/ares_destroy.c',\n@@ -35,8 +45,10 @@\n         'src/ares/ares_fds.c',\n         'src/ares/ares_free_hostent.c',\n         'src/ares/ares_free_string.c',\n+        'src/ares/ares_getenv.h',\n         'src/ares/ares_gethostbyaddr.c',\n         'src/ares/ares_gethostbyname.c',\n+        'src/ares/ares__get_hostent.c',\n         'src/ares/ares_getnameinfo.c',\n         'src/ares/ares_getopt.c',\n         'src/ares/ares_getopt.h',\n@@ -51,16 +63,18 @@\n         'src/ares/ares_nowarn.c',\n         'src/ares/ares_nowarn.h',\n         'src/ares/ares_options.c',\n-        'src/ares/ares_parse_a_reply.c',\n         'src/ares/ares_parse_aaaa_reply.c',\n+        'src/ares/ares_parse_a_reply.c',\n         'src/ares/ares_parse_mx_reply.c',\n         'src/ares/ares_parse_ns_reply.c',\n         'src/ares/ares_parse_ptr_reply.c',\n         'src/ares/ares_parse_srv_reply.c',\n         'src/ares/ares_parse_txt_reply.c',\n+        'src/ares/ares_platform.h',\n         'src/ares/ares_private.h',\n         'src/ares/ares_process.c',\n         'src/ares/ares_query.c',\n+        'src/ares/ares__read_line.c',\n         'src/ares/ares_rules.h',\n         'src/ares/ares_search.c',\n         'src/ares/ares_send.c',\n@@ -71,6 +85,7 @@\n         'src/ares/ares_strdup.h',\n         'src/ares/ares_strerror.c',\n         'src/ares/ares_timeout.c',\n+        'src/ares/ares__timeval.c',\n         'src/ares/ares_version.c',\n         'src/ares/ares_writev.c',\n         'src/ares/ares_writev.h',\n@@ -82,6 +97,7 @@\n         'src/ares/inet_ntop.h',\n         'src/ares/nameser.h',\n         'src/ares/setup_once.h',\n+        'src/ares/windows_port.c',\n       ],\n       'conditions': [\n         [ 'OS==\"win\"', {\n@@ -98,6 +114,9 @@\n             'include/uv-private/uv-win.h',\n             'src/ares/config_win32/ares_config.h',\n             'src/ares/windows_port.c',\n+            'src/ares/ares_getenv.c',\n+            'src/ares/ares_iphlpapi.h',\n+            'src/ares/ares_platform.c',\n             'src/win/async.c',\n             'src/win/cares.c',\n             'src/win/core.c',\n@@ -111,7 +130,6 @@\n             'src/win/pipe.c',\n             'src/win/process.c',\n             'src/win/req.c',\n-            'src/win/stdio.c',\n             'src/win/stream.c',\n             'src/win/tcp.c',\n             'src/win/tty.c',\n@@ -166,12 +184,6 @@\n             'src/unix/ev/event.h',\n           ],\n           'include_dirs': [ 'src/unix/ev', ],\n-          'defines': [\n-            '_LARGEFILE_SOURCE',\n-            '_FILE_OFFSET_BITS=64',\n-            '_GNU_SOURCE',\n-            'EIO_STACKSIZE=262144'\n-          ],\n           'libraries': [ '-lm' ]\n         }],\n         [ 'OS==\"mac\"', {\n@@ -209,7 +221,11 @@\n             'EIO_CONFIG_H=\"config_sunos.h\"',\n           ],\n           'direct_dependent_settings': {\n-            'libraries': [ '-lrt' ],\n+            'libraries': [\n+              '-lkstat',\n+              '-lsocket',\n+              '-lnsl',\n+            ],\n           },\n         }],\n         [ 'OS==\"freebsd\"', {\n@@ -220,6 +236,17 @@\n             'EIO_CONFIG_H=\"config_freebsd.h\"',\n           ],\n         }],\n+        [ 'OS==\"openbsd\"', {\n+          'include_dirs': [ 'src/ares/config_openbsd' ],\n+          'sources': [ 'src/unix/openbsd.c' ],\n+          'defines': [\n+            'EV_CONFIG_H=\"config_openbsd.h\"',\n+            'EIO_CONFIG_H=\"config_openbsd.h\"',\n+          ],\n+        }],\n+        [ 'OS==\"mac\" or OS==\"freebsd\" or OS==\"openbsd\" or OS==\"netbsd\"', {\n+          'sources': [ 'src/unix/kqueue.c' ],\n+        }],\n       ]\n     },\n \n@@ -228,24 +255,29 @@\n       'type': 'executable',\n       'dependencies': [ 'uv' ],\n       'sources': [\n+        'test/blackhole-server.c',\n         'test/echo-server.c',\n         'test/run-tests.c',\n         'test/runner.c',\n         'test/runner.h',\n+        'test/test-get-loadavg.c',\n         'test/task.h',\n         'test/test-async.c',\n+        'test/test-error.c',\n         'test/test-callback-stack.c',\n         'test/test-connection-fail.c',\n         'test/test-delayed-accept.c',\n         'test/test-fail-always.c',\n         'test/test-fs.c',\n         'test/test-fs-event.c',\n         'test/test-get-currentexe.c',\n+        'test/test-get-memory.c',\n         'test/test-getaddrinfo.c',\n         'test/test-gethostbyname.c',\n         'test/test-getsockname.c',\n         'test/test-hrtime.c',\n         'test/test-idle.c',\n+        'test/test-ipc.c',\n         'test/test-list.h',\n         'test/test-loop-handles.c',\n         'test/test-pass-always.c',\n@@ -254,9 +286,13 @@\n         'test/test-ref.c',\n         'test/test-shutdown-eof.c',\n         'test/test-spawn.c',\n+        'test/test-stdio-over-pipes.c',\n         'test/test-tcp-bind-error.c',\n         'test/test-tcp-bind6-error.c',\n         'test/test-tcp-close.c',\n+        'test/test-tcp-flags.c',\n+        'test/test-tcp-connect-error.c',\n+        'test/test-tcp-connect6-error.c',\n         'test/test-tcp-write-error.c',\n         'test/test-tcp-writealot.c',\n         'test/test-threadpool.c',\n@@ -266,6 +302,7 @@\n         'test/test-udp-dgram-too-big.c',\n         'test/test-udp-ipv6.c',\n         'test/test-udp-send-and-recv.c',\n+        'test/test-udp-multicast-join.c',\n       ],\n       'conditions': [\n         [ 'OS==\"win\"', {\n@@ -281,7 +318,13 @@\n             'test/runner-unix.c',\n             'test/runner-unix.h',\n           ]\n-        }]\n+        }],\n+        [ 'OS==\"solaris\"', { # make test-fs.c compile, needs _POSIX_C_SOURCE\n+          'defines': [\n+            '__EXTENSIONS__',\n+            '_XOPEN_SOURCE=500',\n+          ],\n+        }],\n       ],\n       'msvs-settings': {\n         'VCLinkerTool': {\n@@ -303,9 +346,11 @@\n         'test/benchmark-pump.c',\n         'test/benchmark-sizes.c',\n         'test/benchmark-spawn.c',\n+        'test/benchmark-tcp-write-batch.c',\n         'test/benchmark-udp-packet-storm.c',\n         'test/dns-server.c',\n         'test/echo-server.c',\n+        'test/blackhole-server.c',\n         'test/run-benchmarks.c',\n         'test/runner.c',\n         'test/runner.h',"}]}