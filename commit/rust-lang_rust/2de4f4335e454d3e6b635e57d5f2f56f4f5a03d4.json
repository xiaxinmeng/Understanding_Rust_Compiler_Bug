{"sha": "2de4f4335e454d3e6b635e57d5f2f56f4f5a03d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkZTRmNDMzNWU0NTRkM2U2YjYzNWU1N2Q1ZjJmNTZmNGY1YTAzZDQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-19T14:00:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-19T14:00:56Z"}, "message": "Rollup merge of #65505 - RalfJung:rc, r=Centril\n\nRc: value -> allocation\n\nSee https://github.com/rust-lang/rust/issues/64484. This does not yet edit `Arc` as I first wanted to be sure we agree on the terminology the way it actually ends up. \"value\" as a term appears a lot in this file, and sometimes it refers to the value stored inside the `RcBox` while sometimes it refers to the `RcBox` itself. I tried to properly tease these apart but may have made some mistakes. The former should now always be called \"inner value\" and the latter \"allocation\".\n\nOne area where I was very unsure of which terminology is dropping: the `value` field of the `RcBox` will get dropped *earlier* than the `RcBox` itself if there are weak references. I decided that \"dropping the value stored in the allocation\" refers to dropping the value field, while \"destroying the allocation\" refers to actually freeing its backing memory.\n\nr? @Centril", "tree": {"sha": "6cbfafcebd329f33d8db10c6199af49409b80b9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cbfafcebd329f33d8db10c6199af49409b80b9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2de4f4335e454d3e6b635e57d5f2f56f4f5a03d4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdqxcYCRBK7hj4Ov3rIwAAdHIIAA2i6ZM2MuR+0vmHCBAgnJgW\nCnyeapuD6TTDTgOPJoY0befkJ8JqxVrSW3vb91bAkNQUeC4hOliCb1w6d2zKZ2VM\noAf++f9Xt1Gu9O1wJds/hJ4PK9E7oEj9LbiIJnfzC2gTffAmDmxGXEVWoFlGtmMW\n5azSD3UMMHYFV9jGINkhTlgR+5x1RbNgydvj938UPKbiBlTT7x26WdOg5quVkGny\nNPkiqvhobhtpDyomD5wa1QIdSugZp6NZgM4/JuLT2Av6hWFmH92hhizYFavmLler\nA4utg9LC9E1HC6wUAZLz033GZMJ44twfSm23s+NklE9HCegTQhuAdqHFeztbAT8=\n=ixAa\n-----END PGP SIGNATURE-----\n", "payload": "tree 6cbfafcebd329f33d8db10c6199af49409b80b9e\nparent 55326992513aefa96af2a70c44aed4334e9eca23\nparent 1b3846359a084f62eaab74390134011ed9e6cd48\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1571493656 +0200\ncommitter GitHub <noreply@github.com> 1571493656 +0200\n\nRollup merge of #65505 - RalfJung:rc, r=Centril\n\nRc: value -> allocation\n\nSee https://github.com/rust-lang/rust/issues/64484. This does not yet edit `Arc` as I first wanted to be sure we agree on the terminology the way it actually ends up. \"value\" as a term appears a lot in this file, and sometimes it refers to the value stored inside the `RcBox` while sometimes it refers to the `RcBox` itself. I tried to properly tease these apart but may have made some mistakes. The former should now always be called \"inner value\" and the latter \"allocation\".\n\nOne area where I was very unsure of which terminology is dropping: the `value` field of the `RcBox` will get dropped *earlier* than the `RcBox` itself if there are weak references. I decided that \"dropping the value stored in the allocation\" refers to dropping the value field, while \"destroying the allocation\" refers to actually freeing its backing memory.\n\nr? @Centril\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2de4f4335e454d3e6b635e57d5f2f56f4f5a03d4", "html_url": "https://github.com/rust-lang/rust/commit/2de4f4335e454d3e6b635e57d5f2f56f4f5a03d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2de4f4335e454d3e6b635e57d5f2f56f4f5a03d4/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55326992513aefa96af2a70c44aed4334e9eca23", "url": "https://api.github.com/repos/rust-lang/rust/commits/55326992513aefa96af2a70c44aed4334e9eca23", "html_url": "https://github.com/rust-lang/rust/commit/55326992513aefa96af2a70c44aed4334e9eca23"}, {"sha": "1b3846359a084f62eaab74390134011ed9e6cd48", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b3846359a084f62eaab74390134011ed9e6cd48", "html_url": "https://github.com/rust-lang/rust/commit/1b3846359a084f62eaab74390134011ed9e6cd48"}], "stats": {"total": 247, "additions": 137, "deletions": 110}, "files": [{"sha": "f1c4c32e116ea74dcc59bec6eb349841517662b4", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 72, "deletions": 59, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/2de4f4335e454d3e6b635e57d5f2f56f4f5a03d4/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2de4f4335e454d3e6b635e57d5f2f56f4f5a03d4/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=2de4f4335e454d3e6b635e57d5f2f56f4f5a03d4", "patch": "@@ -3,8 +3,9 @@\n //!\n //! The type [`Rc<T>`][`Rc`] provides shared ownership of a value of type `T`,\n //! allocated in the heap. Invoking [`clone`][clone] on [`Rc`] produces a new\n-//! pointer to the same value in the heap. When the last [`Rc`] pointer to a\n-//! given value is destroyed, the pointed-to value is also destroyed.\n+//! pointer to the same allocation in the heap. When the last [`Rc`] pointer to a\n+//! given allocation is destroyed, the value stored in that allocation (often\n+//! referred to as \"inner value\") is also dropped.\n //!\n //! Shared references in Rust disallow mutation by default, and [`Rc`]\n //! is no exception: you cannot generally obtain a mutable reference to\n@@ -21,8 +22,10 @@\n //!\n //! The [`downgrade`][downgrade] method can be used to create a non-owning\n //! [`Weak`] pointer. A [`Weak`] pointer can be [`upgrade`][upgrade]d\n-//! to an [`Rc`], but this will return [`None`] if the value has\n-//! already been dropped.\n+//! to an [`Rc`], but this will return [`None`] if the value stored in the allocation has\n+//! already been dropped. In other words, `Weak` pointers do not keep the value\n+//! inside the allocation alive; however, they *do* keep the allocation\n+//! (the backing store for the inner value) alive.\n //!\n //! A cycle between [`Rc`] pointers will never be deallocated. For this reason,\n //! [`Weak`] is used to break cycles. For example, a tree could have strong\n@@ -41,13 +44,13 @@\n //! Rc::downgrade(&my_rc);\n //! ```\n //!\n-//! [`Weak<T>`][`Weak`] does not auto-dereference to `T`, because the value may have\n-//! already been destroyed.\n+//! [`Weak<T>`][`Weak`] does not auto-dereference to `T`, because the inner value may have\n+//! already been dropped.\n //!\n //! # Cloning references\n //!\n-//! Creating a new reference from an existing reference counted pointer is done using the\n-//! `Clone` trait implemented for [`Rc<T>`][`Rc`] and [`Weak<T>`][`Weak`].\n+//! Creating a new reference to the same allocation as an existing reference counted pointer\n+//! is done using the `Clone` trait implemented for [`Rc<T>`][`Rc`] and [`Weak<T>`][`Weak`].\n //!\n //! ```\n //! use std::rc::Rc;\n@@ -93,7 +96,7 @@\n //!     );\n //!\n //!     // Create `Gadget`s belonging to `gadget_owner`. Cloning the `Rc<Owner>`\n-//!     // value gives us a new pointer to the same `Owner` value, incrementing\n+//!     // gives us a new pointer to the same `Owner` allocation, incrementing\n //!     // the reference count in the process.\n //!     let gadget1 = Gadget {\n //!         id: 1,\n@@ -110,8 +113,8 @@\n //!     // Despite dropping `gadget_owner`, we're still able to print out the name\n //!     // of the `Owner` of the `Gadget`s. This is because we've only dropped a\n //!     // single `Rc<Owner>`, not the `Owner` it points to. As long as there are\n-//!     // other `Rc<Owner>` values pointing at the same `Owner`, it will remain\n-//!     // allocated. The field projection `gadget1.owner.name` works because\n+//!     // other `Rc<Owner>` pointing at the same `Owner` allocation, it will remain\n+//!     // live. The field projection `gadget1.owner.name` works because\n //!     // `Rc<Owner>` automatically dereferences to `Owner`.\n //!     println!(\"Gadget {} owned by {}\", gadget1.id, gadget1.owner.name);\n //!     println!(\"Gadget {} owned by {}\", gadget2.id, gadget2.owner.name);\n@@ -124,9 +127,9 @@\n //!\n //! If our requirements change, and we also need to be able to traverse from\n //! `Owner` to\u00a0`Gadget`, we will run into problems. An [`Rc`] pointer from `Owner`\n-//! to `Gadget` introduces a cycle between the values. This means that their\n-//! reference counts can never reach 0, and the values will remain allocated\n-//! forever: a memory leak. In order to get around this, we can use [`Weak`]\n+//! to `Gadget` introduces a cycle. This means that their\n+//! reference counts can never reach 0, and the allocation will never be destroyed:\n+//! a memory leak. In order to get around this, we can use [`Weak`]\n //! pointers.\n //!\n //! Rust actually makes it somewhat difficult to produce this loop in the first\n@@ -193,10 +196,10 @@\n //!     for gadget_weak in gadget_owner.gadgets.borrow().iter() {\n //!\n //!         // `gadget_weak` is a `Weak<Gadget>`. Since `Weak` pointers can't\n-//!         // guarantee the value is still allocated, we need to call\n+//!         // guarantee the allocation still exists, we need to call\n //!         // `upgrade`, which returns an `Option<Rc<Gadget>>`.\n //!         //\n-//!         // In this case we know the value still exists, so we simply\n+//!         // In this case we know the allocation still exists, so we simply\n //!         // `unwrap` the `Option`. In a more complicated program, you might\n //!         // need graceful error handling for a `None` result.\n //!\n@@ -365,7 +368,7 @@ impl<T> Rc<T> {\n         unsafe { Pin::new_unchecked(Rc::new(value)) }\n     }\n \n-    /// Returns the contained value, if the `Rc` has exactly one strong reference.\n+    /// Returns the inner value, if the `Rc` has exactly one strong reference.\n     ///\n     /// Otherwise, an [`Err`][result] is returned with the same `Rc` that was\n     /// passed in.\n@@ -446,7 +449,7 @@ impl<T> Rc<mem::MaybeUninit<T>> {\n     /// # Safety\n     ///\n     /// As with [`MaybeUninit::assume_init`],\n-    /// it is up to the caller to guarantee that the value\n+    /// it is up to the caller to guarantee that the inner value\n     /// really is in an initialized state.\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n@@ -485,7 +488,7 @@ impl<T> Rc<[mem::MaybeUninit<T>]> {\n     /// # Safety\n     ///\n     /// As with [`MaybeUninit::assume_init`],\n-    /// it is up to the caller to guarantee that the value\n+    /// it is up to the caller to guarantee that the inner value\n     /// really is in an initialized state.\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n@@ -604,7 +607,7 @@ impl<T: ?Sized> Rc<T> {\n         unsafe { NonNull::new_unchecked(Rc::into_raw(this) as *mut _) }\n     }\n \n-    /// Creates a new [`Weak`][weak] pointer to this value.\n+    /// Creates a new [`Weak`][weak] pointer to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     ///\n@@ -625,7 +628,7 @@ impl<T: ?Sized> Rc<T> {\n         Weak { ptr: this.ptr }\n     }\n \n-    /// Gets the number of [`Weak`][weak] pointers to this value.\n+    /// Gets the number of [`Weak`][weak] pointers to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     ///\n@@ -645,7 +648,7 @@ impl<T: ?Sized> Rc<T> {\n         this.weak() - 1\n     }\n \n-    /// Gets the number of strong (`Rc`) pointers to this value.\n+    /// Gets the number of strong (`Rc`) pointers to this allocation.\n     ///\n     /// # Examples\n     ///\n@@ -664,22 +667,22 @@ impl<T: ?Sized> Rc<T> {\n     }\n \n     /// Returns `true` if there are no other `Rc` or [`Weak`][weak] pointers to\n-    /// this inner value.\n+    /// this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     #[inline]\n     fn is_unique(this: &Self) -> bool {\n         Rc::weak_count(this) == 0 && Rc::strong_count(this) == 1\n     }\n \n-    /// Returns a mutable reference to the inner value, if there are\n-    /// no other `Rc` or [`Weak`][weak] pointers to the same value.\n+    /// Returns a mutable reference into the given `Rc`, if there are\n+    /// no other `Rc` or [`Weak`][weak] pointers to the same allocation.\n     ///\n     /// Returns [`None`] otherwise, because it is not safe to\n     /// mutate a shared value.\n     ///\n     /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n-    /// the inner value when it's shared.\n+    /// the inner value when there are other pointers.\n     ///\n     /// [weak]: struct.Weak.html\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n@@ -710,7 +713,7 @@ impl<T: ?Sized> Rc<T> {\n         }\n     }\n \n-    /// Returns a mutable reference to the inner value,\n+    /// Returns a mutable reference into the given `Rc`,\n     /// without any check.\n     ///\n     /// See also [`get_mut`], which is safe and does appropriate checks.\n@@ -719,7 +722,7 @@ impl<T: ?Sized> Rc<T> {\n     ///\n     /// # Safety\n     ///\n-    /// Any other `Rc` or [`Weak`] pointers to the same value must not be dereferenced\n+    /// Any other `Rc` or [`Weak`] pointers to the same allocation must not be dereferenced\n     /// for the duration of the returned borrow.\n     /// This is trivially the case if no such pointers exist,\n     /// for example immediately after `Rc::new`.\n@@ -745,8 +748,8 @@ impl<T: ?Sized> Rc<T> {\n \n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n-    /// Returns `true` if the two `Rc`s point to the same value (not\n-    /// just values that compare as equal).\n+    /// Returns `true` if the two `Rc`s point to the same allocation\n+    /// (in a vein similar to [`ptr::eq`]).\n     ///\n     /// # Examples\n     ///\n@@ -760,6 +763,8 @@ impl<T: ?Sized> Rc<T> {\n     /// assert!(Rc::ptr_eq(&five, &same_five));\n     /// assert!(!Rc::ptr_eq(&five, &other_five));\n     /// ```\n+    ///\n+    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n         this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n@@ -768,12 +773,12 @@ impl<T: ?Sized> Rc<T> {\n impl<T: Clone> Rc<T> {\n     /// Makes a mutable reference into the given `Rc`.\n     ///\n-    /// If there are other `Rc` pointers to the same value, then `make_mut` will\n-    /// [`clone`] the inner value to ensure unique ownership.  This is also\n+    /// If there are other `Rc` pointers to the same allocation, then `make_mut` will\n+    /// [`clone`] the inner value to a new allocation to ensure unique ownership.  This is also\n     /// referred to as clone-on-write.\n     ///\n-    /// If there are no other `Rc` pointers to this value, then [`Weak`]\n-    /// pointers to this value will be disassociated.\n+    /// If there are no other `Rc` pointers to this allocation, then [`Weak`]\n+    /// pointers to this allocation will be disassociated.\n     ///\n     /// See also [`get_mut`], which will fail rather than cloning.\n     ///\n@@ -794,7 +799,7 @@ impl<T: Clone> Rc<T> {\n     /// *Rc::make_mut(&mut data) += 1;        // Won't clone anything\n     /// *Rc::make_mut(&mut other_data) *= 2;  // Won't clone anything\n     ///\n-    /// // Now `data` and `other_data` point to different values.\n+    /// // Now `data` and `other_data` point to different allocations.\n     /// assert_eq!(*data, 8);\n     /// assert_eq!(*other_data, 12);\n     /// ```\n@@ -837,7 +842,7 @@ impl<T: Clone> Rc<T> {\n         // returned is the *only* pointer that will ever be returned to T. Our\n         // reference count is guaranteed to be 1 at this point, and we required\n         // the `Rc<T>` itself to be `mut`, so we're returning the only possible\n-        // reference to the inner value.\n+        // reference to the allocation.\n         unsafe {\n             &mut this.ptr.as_mut().value\n         }\n@@ -878,7 +883,7 @@ impl Rc<dyn Any> {\n \n impl<T: ?Sized> Rc<T> {\n     /// Allocates an `RcBox<T>` with sufficient space for\n-    /// a possibly-unsized value where the value has the layout provided.\n+    /// a possibly-unsized inner value where the value has the layout provided.\n     ///\n     /// The function `mem_to_rcbox` is called with the data pointer\n     /// and must return back a (potentially fat)-pointer for the `RcBox<T>`.\n@@ -908,7 +913,7 @@ impl<T: ?Sized> Rc<T> {\n         inner\n     }\n \n-    /// Allocates an `RcBox<T>` with sufficient space for an unsized value\n+    /// Allocates an `RcBox<T>` with sufficient space for an unsized inner value\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n         // Allocate for the `RcBox<T>` using the given value.\n         Self::allocate_for_layout(\n@@ -1111,7 +1116,7 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n impl<T: ?Sized> Clone for Rc<T> {\n     /// Makes a clone of the `Rc` pointer.\n     ///\n-    /// This creates another pointer to the same inner value, increasing the\n+    /// This creates another pointer to the same allocation, increasing the\n     /// strong reference count.\n     ///\n     /// # Examples\n@@ -1172,6 +1177,8 @@ impl<T: ?Sized + PartialEq> RcEqIdent<T> for Rc<T> {\n /// store large values, that are slow to clone, but also heavy to check for equality, causing this\n /// cost to pay off more easily. It's also more likely to have two `Rc` clones, that point to\n /// the same value, than two `&T`s.\n+///\n+/// We can only do this when `T: Eq` as a `PartialEq` might be deliberately irreflexive.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> RcEqIdent<T> for Rc<T> {\n     #[inline]\n@@ -1189,9 +1196,11 @@ impl<T: ?Sized + Eq> RcEqIdent<T> for Rc<T> {\n impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     /// Equality for two `Rc`s.\n     ///\n-    /// Two `Rc`s are equal if their inner values are equal.\n+    /// Two `Rc`s are equal if their inner values are equal, even if they are\n+    /// stored in different allocation.\n     ///\n-    /// If `T` also implements `Eq`, two `Rc`s that point to the same value are\n+    /// If `T` also implements `Eq` (implying reflexivity of equality),\n+    /// two `Rc`s that point to the same allocation are\n     /// always equal.\n     ///\n     /// # Examples\n@@ -1212,7 +1221,8 @@ impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     ///\n     /// Two `Rc`s are unequal if their inner values are unequal.\n     ///\n-    /// If `T` also implements `Eq`, two `Rc`s that point to the same value are\n+    /// If `T` also implements `Eq` (implying reflexivity of equality),\n+    /// two `Rc`s that point to the same allocation are\n     /// never unequal.\n     ///\n     /// # Examples\n@@ -1541,17 +1551,18 @@ impl<'a, T: 'a + Clone> RcFromIter<&'a T, slice::Iter<'a, T>> for Rc<[T]> {\n }\n \n /// `Weak` is a version of [`Rc`] that holds a non-owning reference to the\n-/// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n+/// managed allocation. The allocation is accessed by calling [`upgrade`] on the `Weak`\n /// pointer, which returns an [`Option`]`<`[`Rc`]`<T>>`.\n ///\n /// Since a `Weak` reference does not count towards ownership, it will not\n-/// prevent the inner value from being dropped, and `Weak` itself makes no\n-/// guarantees about the value still being present and may return [`None`]\n-/// when [`upgrade`]d.\n+/// prevent the value stored in the allocation from being dropped, and `Weak` itself makes no\n+/// guarantees about the value still being present. Thus it may return [`None`]\n+/// when [`upgrade`]d. Note however that a `Weak` reference *does* prevent the allocation\n+/// itself (the backing store) from being deallocated.\n ///\n-/// A `Weak` pointer is useful for keeping a temporary reference to the value\n-/// within [`Rc`] without extending its lifetime. It is also used to prevent\n-/// circular references between [`Rc`] pointers, since mutual owning references\n+/// A `Weak` pointer is useful for keeping a temporary reference to the allocation\n+/// managed by [`Rc`] without preventing its inner value from being dropped. It is also used to\n+/// prevent circular references between [`Rc`] pointers, since mutual owning references\n /// would never allow either [`Rc`] to be dropped. For example, a tree could\n /// have strong [`Rc`] pointers from parent nodes to children, and `Weak`\n /// pointers from children back to their parents.\n@@ -1750,10 +1761,10 @@ pub(crate) fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n }\n \n impl<T: ?Sized> Weak<T> {\n-    /// Attempts to upgrade the `Weak` pointer to an [`Rc`], extending\n-    /// the lifetime of the value if successful.\n+    /// Attempts to upgrade the `Weak` pointer to an [`Rc`], delaying\n+    /// dropping of the inner value if successful.\n     ///\n-    /// Returns [`None`] if the value has since been dropped.\n+    /// Returns [`None`] if the inner value has since been dropped.\n     ///\n     /// [`Rc`]: struct.Rc.html\n     /// [`None`]: ../../std/option/enum.Option.html\n@@ -1787,7 +1798,7 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Gets the number of strong (`Rc`) pointers pointing to this value.\n+    /// Gets the number of strong (`Rc`) pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0.\n     ///\n@@ -1801,11 +1812,11 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Gets the number of `Weak` pointers pointing to this value.\n+    /// Gets the number of `Weak` pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return `None`. If\n     /// not, the returned value is at least 1, since `self` still points to the\n-    /// value.\n+    /// allocation.\n     ///\n     /// [`Weak::new`]: #method.new\n     #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n@@ -1830,14 +1841,14 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns `true` if the two `Weak`s point to the same value (not just\n-    /// values that compare as equal), or if both don't point to any value\n+    /// Returns `true` if the two `Weak`s point to the same allocation (similar to\n+    /// [`ptr::eq`]), or if both don't point to any allocation\n     /// (because they were created with `Weak::new()`).\n     ///\n     /// # Notes\n     ///\n     /// Since this compares pointers it means that `Weak::new()` will equal each\n-    /// other, even though they don't point to any value.\n+    /// other, even though they don't point to any allocation.\n     ///\n     /// # Examples\n     ///\n@@ -1869,6 +1880,8 @@ impl<T: ?Sized> Weak<T> {\n     /// let third = Rc::downgrade(&third_rc);\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n+    ///\n+    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n     #[inline]\n     #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n@@ -1918,7 +1931,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak` pointer that points to the same value.\n+    /// Makes a clone of the `Weak` pointer that points to the same allocation.\n     ///\n     /// # Examples\n     ///"}, {"sha": "69f8f71197c1f24e826d62c71a2c1f179350c92a", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 65, "deletions": 51, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/2de4f4335e454d3e6b635e57d5f2f56f4f5a03d4/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2de4f4335e454d3e6b635e57d5f2f56f4f5a03d4/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=2de4f4335e454d3e6b635e57d5f2f56f4f5a03d4", "patch": "@@ -45,10 +45,10 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n ///\n /// The type `Arc<T>` provides shared ownership of a value of type `T`,\n /// allocated in the heap. Invoking [`clone`][clone] on `Arc` produces\n-/// a new `Arc` instance, which points to the same value on the heap as the\n+/// a new `Arc` instance, which points to the same allocation on the heap as the\n /// source `Arc`, while increasing a reference count. When the last `Arc`\n-/// pointer to a given value is destroyed, the pointed-to value is also\n-/// destroyed.\n+/// pointer to a given allocation is destroyed, the value stored in that allocation (often\n+/// referred to as \"inner value\") is also dropped.\n ///\n /// Shared references in Rust disallow mutation by default, and `Arc` is no\n /// exception: you cannot generally obtain a mutable reference to something\n@@ -61,7 +61,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// Unlike [`Rc<T>`], `Arc<T>` uses atomic operations for its reference\n /// counting. This means that it is thread-safe. The disadvantage is that\n /// atomic operations are more expensive than ordinary memory accesses. If you\n-/// are not sharing reference-counted values between threads, consider using\n+/// are not sharing reference-counted allocations between threads, consider using\n /// [`Rc<T>`] for lower overhead. [`Rc<T>`] is a safe default, because the\n /// compiler will catch any attempt to send an [`Rc<T>`] between threads.\n /// However, a library might choose `Arc<T>` in order to give library consumers\n@@ -85,8 +85,10 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n ///\n /// The [`downgrade`][downgrade] method can be used to create a non-owning\n /// [`Weak`][weak] pointer. A [`Weak`][weak] pointer can be [`upgrade`][upgrade]d\n-/// to an `Arc`, but this will return [`None`] if the value has already been\n-/// dropped.\n+/// to an `Arc`, but this will return [`None`] if the value stored in the allocation has\n+/// already been dropped. In other words, `Weak` pointers do not keep the value\n+/// inside the allocation alive; however, they *do* keep the allocation\n+/// (the backing store for the value) alive.\n ///\n /// A cycle between `Arc` pointers will never be deallocated. For this reason,\n /// [`Weak`][weak] is used to break cycles. For example, a tree could have\n@@ -121,8 +123,8 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// Arc::downgrade(&my_arc);\n /// ```\n ///\n-/// [`Weak<T>`][weak] does not auto-dereference to `T`, because the value may have\n-/// already been destroyed.\n+/// [`Weak<T>`][weak] does not auto-dereference to `T`, because the inner value may have\n+/// already been dropped.\n ///\n /// [arc]: struct.Arc.html\n /// [weak]: struct.Weak.html\n@@ -221,17 +223,18 @@ impl<T: ?Sized> Arc<T> {\n }\n \n /// `Weak` is a version of [`Arc`] that holds a non-owning reference to the\n-/// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n+/// managed allocation. The allocation is accessed by calling [`upgrade`] on the `Weak`\n /// pointer, which returns an [`Option`]`<`[`Arc`]`<T>>`.\n ///\n /// Since a `Weak` reference does not count towards ownership, it will not\n-/// prevent the inner value from being dropped, and `Weak` itself makes no\n-/// guarantees about the value still being present and may return [`None`]\n-/// when [`upgrade`]d.\n+/// prevent the value stored in the allocation from being dropped, and `Weak` itself makes no\n+/// guarantees about the value still being present. Thus it may return [`None`]\n+/// when [`upgrade`]d. Note however that a `Weak` reference *does* prevent the allocation\n+/// itself (the backing store) from being deallocated.\n ///\n-/// A `Weak` pointer is useful for keeping a temporary reference to the value\n-/// within [`Arc`] without extending its lifetime. It is also used to prevent\n-/// circular references between [`Arc`] pointers, since mutual owning references\n+/// A `Weak` pointer is useful for keeping a temporary reference to the allocation\n+/// managed by [`Arc`] without preventing its inner value from being dropped. It is also used to\n+/// prevent circular references between [`Arc`] pointers, since mutual owning references\n /// would never allow either [`Arc`] to be dropped. For example, a tree could\n /// have strong [`Arc`] pointers from parent nodes to children, and `Weak`\n /// pointers from children back to their parents.\n@@ -345,7 +348,7 @@ impl<T> Arc<T> {\n         unsafe { Pin::new_unchecked(Arc::new(data)) }\n     }\n \n-    /// Returns the contained value, if the `Arc` has exactly one strong reference.\n+    /// Returns the inner value, if the `Arc` has exactly one strong reference.\n     ///\n     /// Otherwise, an [`Err`][result] is returned with the same `Arc` that was\n     /// passed in.\n@@ -426,7 +429,7 @@ impl<T> Arc<mem::MaybeUninit<T>> {\n     /// # Safety\n     ///\n     /// As with [`MaybeUninit::assume_init`],\n-    /// it is up to the caller to guarantee that the value\n+    /// it is up to the caller to guarantee that the inner value\n     /// really is in an initialized state.\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n@@ -465,7 +468,7 @@ impl<T> Arc<[mem::MaybeUninit<T>]> {\n     /// # Safety\n     ///\n     /// As with [`MaybeUninit::assume_init`],\n-    /// it is up to the caller to guarantee that the value\n+    /// it is up to the caller to guarantee that the inner value\n     /// really is in an initialized state.\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n@@ -584,7 +587,7 @@ impl<T: ?Sized> Arc<T> {\n         unsafe { NonNull::new_unchecked(Arc::into_raw(this) as *mut _) }\n     }\n \n-    /// Creates a new [`Weak`][weak] pointer to this value.\n+    /// Creates a new [`Weak`][weak] pointer to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     ///\n@@ -628,7 +631,7 @@ impl<T: ?Sized> Arc<T> {\n         }\n     }\n \n-    /// Gets the number of [`Weak`][weak] pointers to this value.\n+    /// Gets the number of [`Weak`][weak] pointers to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     ///\n@@ -659,7 +662,7 @@ impl<T: ?Sized> Arc<T> {\n         if cnt == usize::MAX { 0 } else { cnt - 1 }\n     }\n \n-    /// Gets the number of strong (`Arc`) pointers to this value.\n+    /// Gets the number of strong (`Arc`) pointers to this allocation.\n     ///\n     /// # Safety\n     ///\n@@ -710,8 +713,8 @@ impl<T: ?Sized> Arc<T> {\n \n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n-    /// Returns `true` if the two `Arc`s point to the same value (not\n-    /// just values that compare as equal).\n+    /// Returns `true` if the two `Arc`s point to the same allocation\n+    /// (in a vein similar to [`ptr::eq`]).\n     ///\n     /// # Examples\n     ///\n@@ -725,14 +728,16 @@ impl<T: ?Sized> Arc<T> {\n     /// assert!(Arc::ptr_eq(&five, &same_five));\n     /// assert!(!Arc::ptr_eq(&five, &other_five));\n     /// ```\n+    ///\n+    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n         this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n }\n \n impl<T: ?Sized> Arc<T> {\n     /// Allocates an `ArcInner<T>` with sufficient space for\n-    /// a possibly-unsized value where the value has the layout provided.\n+    /// a possibly-unsized inner value where the value has the layout provided.\n     ///\n     /// The function `mem_to_arcinner` is called with the data pointer\n     /// and must return back a (potentially fat)-pointer for the `ArcInner<T>`.\n@@ -761,7 +766,7 @@ impl<T: ?Sized> Arc<T> {\n         inner\n     }\n \n-    /// Allocates an `ArcInner<T>` with sufficient space for an unsized value.\n+    /// Allocates an `ArcInner<T>` with sufficient space for an unsized inner value.\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n         // Allocate for the `ArcInner<T>` using the given value.\n         Self::allocate_for_layout(\n@@ -903,7 +908,7 @@ impl<T: Copy> ArcFromSlice<T> for Arc<[T]> {\n impl<T: ?Sized> Clone for Arc<T> {\n     /// Makes a clone of the `Arc` pointer.\n     ///\n-    /// This creates another pointer to the same inner value, increasing the\n+    /// This creates another pointer to the same allocation, increasing the\n     /// strong reference count.\n     ///\n     /// # Examples\n@@ -965,15 +970,19 @@ impl<T: ?Sized> Receiver for Arc<T> {}\n impl<T: Clone> Arc<T> {\n     /// Makes a mutable reference into the given `Arc`.\n     ///\n-    /// If there are other `Arc` or [`Weak`][weak] pointers to the same value,\n-    /// then `make_mut` will invoke [`clone`][clone] on the inner value to\n-    /// ensure unique ownership. This is also referred to as clone-on-write.\n+    /// If there are other `Arc` or [`Weak`][weak] pointers to the same allocation,\n+    /// then `make_mut` will create a new allocation and invoke [`clone`][clone] on the inner value\n+    /// to ensure unique ownership. This is also referred to as clone-on-write.\n+    ///\n+    /// Note that this differs from the behavior of [`Rc::make_mut`] which disassociates\n+    /// any remaining `Weak` pointers.\n     ///\n     /// See also [`get_mut`][get_mut], which will fail rather than cloning.\n     ///\n     /// [weak]: struct.Weak.html\n     /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n     /// [get_mut]: struct.Arc.html#method.get_mut\n+    /// [`Rc::make_mut`]: ../rc/struct.Rc.html#method.make_mut\n     ///\n     /// # Examples\n     ///\n@@ -988,7 +997,7 @@ impl<T: Clone> Arc<T> {\n     /// *Arc::make_mut(&mut data) += 1;         // Won't clone anything\n     /// *Arc::make_mut(&mut other_data) *= 2;   // Won't clone anything\n     ///\n-    /// // Now `data` and `other_data` point to different values.\n+    /// // Now `data` and `other_data` point to different allocations.\n     /// assert_eq!(*data, 8);\n     /// assert_eq!(*other_data, 12);\n     /// ```\n@@ -1048,14 +1057,14 @@ impl<T: Clone> Arc<T> {\n }\n \n impl<T: ?Sized> Arc<T> {\n-    /// Returns a mutable reference to the inner value, if there are\n-    /// no other `Arc` or [`Weak`][weak] pointers to the same value.\n+    /// Returns a mutable reference into the given `Arc`, if there are\n+    /// no other `Arc` or [`Weak`][weak] pointers to the same allocation.\n     ///\n     /// Returns [`None`][option] otherwise, because it is not safe to\n     /// mutate a shared value.\n     ///\n     /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n-    /// the inner value when it's shared.\n+    /// the inner value when there are other pointers.\n     ///\n     /// [weak]: struct.Weak.html\n     /// [option]: ../../std/option/enum.Option.html\n@@ -1091,7 +1100,7 @@ impl<T: ?Sized> Arc<T> {\n         }\n     }\n \n-    /// Returns a mutable reference to the inner value,\n+    /// Returns a mutable reference into the given `Arc`,\n     /// without any check.\n     ///\n     /// See also [`get_mut`], which is safe and does appropriate checks.\n@@ -1100,7 +1109,7 @@ impl<T: ?Sized> Arc<T> {\n     ///\n     /// # Safety\n     ///\n-    /// Any other `Arc` or [`Weak`] pointers to the same value must not be dereferenced\n+    /// Any other `Arc` or [`Weak`] pointers to the same allocation must not be dereferenced\n     /// for the duration of the returned borrow.\n     /// This is trivially the case if no such pointers exist,\n     /// for example immediately after `Arc::new`.\n@@ -1424,10 +1433,10 @@ impl<T> Weak<T> {\n }\n \n impl<T: ?Sized> Weak<T> {\n-    /// Attempts to upgrade the `Weak` pointer to an [`Arc`], extending\n-    /// the lifetime of the value if successful.\n+    /// Attempts to upgrade the `Weak` pointer to an [`Arc`], delaying\n+    /// dropping of the inner value if successful.\n     ///\n-    /// Returns [`None`] if the value has since been dropped.\n+    /// Returns [`None`] if the inner value has since been dropped.\n     ///\n     /// [`Arc`]: struct.Arc.html\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n@@ -1482,7 +1491,7 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Gets the number of strong (`Arc`) pointers pointing to this value.\n+    /// Gets the number of strong (`Arc`) pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0.\n     ///\n@@ -1497,17 +1506,17 @@ impl<T: ?Sized> Weak<T> {\n     }\n \n     /// Gets an approximation of the number of `Weak` pointers pointing to this\n-    /// value.\n+    /// allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0. If not,\n     /// the returned value is at least 1, since `self` still points to the\n-    /// value.\n+    /// allocation.\n     ///\n     /// # Accuracy\n     ///\n     /// Due to implementation details, the returned value can be off by 1 in\n     /// either direction when other threads are manipulating any `Arc`s or\n-    /// `Weak`s pointing to the same value.\n+    /// `Weak`s pointing to the same allocation.\n     ///\n     /// [`Weak::new`]: #method.new\n     #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n@@ -1548,14 +1557,14 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns `true` if the two `Weak`s point to the same value (not just\n-    /// values that compare as equal), or if both don't point to any value\n+    /// Returns `true` if the two `Weak`s point to the same allocation (similar to\n+    /// [`ptr::eq`]), or if both don't point to any allocation\n     /// (because they were created with `Weak::new()`).\n     ///\n     /// # Notes\n     ///\n     /// Since this compares pointers it means that `Weak::new()` will equal each\n-    /// other, even though they don't point to any value.\n+    /// other, even though they don't point to any allocation.\n     ///\n     /// # Examples\n     ///\n@@ -1587,6 +1596,8 @@ impl<T: ?Sized> Weak<T> {\n     /// let third = Arc::downgrade(&third_rc);\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n+    ///\n+    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n     #[inline]\n     #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n@@ -1596,7 +1607,7 @@ impl<T: ?Sized> Weak<T> {\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak` pointer that points to the same value.\n+    /// Makes a clone of the `Weak` pointer that points to the same allocation.\n     ///\n     /// # Examples\n     ///\n@@ -1726,6 +1737,8 @@ impl<T: ?Sized + PartialEq> ArcEqIdent<T> for Arc<T> {\n /// store large values, that are slow to clone, but also heavy to check for equality, causing this\n /// cost to pay off more easily. It's also more likely to have two `Arc` clones, that point to\n /// the same value, than two `&T`s.\n+///\n+/// We can only do this when `T: Eq` as a `PartialEq` might be deliberately irreflexive.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> ArcEqIdent<T> for Arc<T> {\n     #[inline]\n@@ -1743,10 +1756,11 @@ impl<T: ?Sized + Eq> ArcEqIdent<T> for Arc<T> {\n impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n     /// Equality for two `Arc`s.\n     ///\n-    /// Two `Arc`s are equal if their inner values are equal.\n+    /// Two `Arc`s are equal if their inner values are equal, even if they are\n+    /// stored in different allocation.\n     ///\n-    /// If `T` also implements `Eq`, two `Arc`s that point to the same value are\n-    /// always equal.\n+    /// If `T` also implements `Eq` (implying reflexivity of equality),\n+    /// two `Arc`s that point to the same allocation are always equal.\n     ///\n     /// # Examples\n     ///\n@@ -1766,8 +1780,8 @@ impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n     ///\n     /// Two `Arc`s are unequal if their inner values are unequal.\n     ///\n-    /// If `T` also implements `Eq`, two `Arc`s that point to the same value are\n-    /// never unequal.\n+    /// If `T` also implements `Eq` (implying reflexivity of equality),\n+    /// two `Arc`s that point to the same value are never unequal.\n     ///\n     /// # Examples\n     ///"}]}