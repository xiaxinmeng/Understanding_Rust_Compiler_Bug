{"sha": "b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0ZDFmMWIyYzExZGIzNzBhMmVmODI2NDZhNGZkYzA5MTY5OWU3YjY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-11T02:58:23Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-11T04:14:43Z"}, "message": "replace mutbl pass with borrowck", "tree": {"sha": "bbe84fc4da25c57bd46a1db0eea25624ca6f997f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbe84fc4da25c57bd46a1db0eea25624ca6f997f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "html_url": "https://github.com/rust-lang/rust/commit/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c23d6a50d786e926d001423f36dc43fe480acbae", "url": "https://api.github.com/repos/rust-lang/rust/commits/c23d6a50d786e926d001423f36dc43fe480acbae", "html_url": "https://github.com/rust-lang/rust/commit/c23d6a50d786e926d001423f36dc43fe480acbae"}], "stats": {"total": 1039, "additions": 499, "deletions": 540}, "files": [{"sha": "1cc19143eec0c9196e87dccc0dcf64ba6c776517", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -188,12 +188,9 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n          bind middle::check_alt::check_crate(ty_cx, crate));\n     time(time_passes, \"typestate checking\",\n          bind middle::tstate::ck::check_crate(ty_cx, crate));\n-    let _root_map = time(\n+    let (_root_map, mutbl_map) = time(\n         time_passes, \"borrow checking\",\n         bind middle::borrowck::check_crate(ty_cx, method_map, crate));\n-    let mutbl_map =\n-        time(time_passes, \"mutability checking\",\n-             bind middle::mutbl::check_crate(ty_cx, crate));\n     time(time_passes, \"region checking\",\n          bind middle::regionck::check_crate(ty_cx, crate));\n     let (copy_map, ref_map) ="}, {"sha": "81f90c8eef2e4e77857979a5d8a745444d990d17", "filename": "src/rustc/middle/alias.rs", "status": "modified", "additions": 133, "deletions": 4, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Frustc%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Frustc%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Falias.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -1,4 +1,3 @@\n-\n import syntax::{ast, ast_util};\n import ast::{ident, fn_ident, node_id};\n import syntax::codemap::span;\n@@ -640,11 +639,141 @@ fn pattern_roots(tcx: ty::ctxt, mutbl: option<unsafe_ty>, pat: @ast::pat)\n     ret set;\n }\n \n-// Wraps the expr_root in mutbl.rs to also handle roots that exist through\n-// return-by-reference\n+enum deref_t { unbox(bool), field, index, }\n+\n+type deref = @{mutbl: bool, kind: deref_t, outer_t: ty::t};\n+\n fn expr_root(cx: ctx, ex: @ast::expr, autoderef: bool)\n     -> {ex: @ast::expr, mutbl: option<unsafe_ty>} {\n-    let base_root = mutbl::expr_root_(cx.tcx, none, ex, autoderef);\n+\n+    fn maybe_auto_unbox(tcx: ty::ctxt, t: ty::t) -> {t: ty::t, ds: [deref]} {\n+        let mut ds = [], t = t;\n+        loop {\n+            alt ty::get(t).struct {\n+              ty::ty_box(mt) | ty::ty_uniq(mt) | ty::ty_rptr(_, mt) {\n+                ds += [@{mutbl: mt.mutbl == ast::m_mutbl,\n+                         kind: unbox(false),\n+                         outer_t: t}];\n+                t = mt.ty;\n+              }\n+              ty::ty_res(_, inner, substs) {\n+                ds += [@{mutbl: false, kind: unbox(false), outer_t: t}];\n+                t = ty::subst(tcx, substs, inner);\n+              }\n+              ty::ty_enum(did, substs) {\n+                let variants = ty::enum_variants(tcx, did);\n+                if vec::len(*variants) != 1u ||\n+                    vec::len(variants[0].args) != 1u {\n+                    break;\n+                }\n+                ds += [@{mutbl: false, kind: unbox(false), outer_t: t}];\n+                t = ty::subst(tcx, substs, variants[0].args[0]);\n+              }\n+              _ { break; }\n+            }\n+        }\n+        ret {t: t, ds: ds};\n+    }\n+\n+    fn expr_root_(tcx: ty::ctxt, ctor_self: option<node_id>,\n+                  ex: @ast::expr, autoderef: bool) -> {ex: @ast::expr,\n+                                                       ds: @[deref]} {\n+        let mut ds: [deref] = [], ex = ex;\n+        loop {\n+            alt copy ex.node {\n+              ast::expr_field(base, ident, _) {\n+                let auto_unbox =\n+                    maybe_auto_unbox(tcx, ty::expr_ty(tcx, base));\n+                let mut is_mutbl = false;\n+                alt ty::get(auto_unbox.t).struct {\n+                  ty::ty_rec(fields) {\n+                    for fields.each {|fld|\n+                        if str::eq(ident, fld.ident) {\n+                            is_mutbl = fld.mt.mutbl == ast::m_mutbl;\n+                            break;\n+                        }\n+                    }\n+                  }\n+                  ty::ty_class(did, _) {\n+                    util::common::log_expr(*base);\n+                    let in_self = alt ctor_self {\n+                      some(selfid) {\n+                        alt tcx.def_map.find(base.id) {\n+                          some(ast::def_self(slfid)) { slfid == selfid }\n+                          _ { false }\n+                        }\n+                      }\n+                      none { false }\n+                    };\n+                    for ty::lookup_class_fields(tcx, did).each {|fld|\n+                        if str::eq(ident, fld.ident) {\n+                            is_mutbl = fld.mutability == ast::class_mutable\n+                                || in_self; // all fields can be mutated\n+                            // in the ctor\n+                            break;\n+                        }\n+                    }\n+                  }\n+                  _ {}\n+                }\n+                ds += [@{mutbl:is_mutbl, kind:field, outer_t:auto_unbox.t}];\n+                ds += auto_unbox.ds;\n+                ex = base;\n+              }\n+              ast::expr_index(base, _) {\n+                let auto_unbox =\n+                    maybe_auto_unbox(tcx, ty::expr_ty(tcx, base));\n+                alt ty::get(auto_unbox.t).struct {\n+                  ty::ty_evec(mt, _) |\n+                  ty::ty_vec(mt) {\n+                    ds +=\n+                        [@{mutbl: mt.mutbl == ast::m_mutbl,\n+                           kind: index,\n+                           outer_t: auto_unbox.t}];\n+                  }\n+                  ty::ty_estr(_) |\n+                  ty::ty_str {\n+                    ds += [@{mutbl:false, kind:index, outer_t:auto_unbox.t}];\n+                  }\n+                  _ { break; }\n+                }\n+                ds += auto_unbox.ds;\n+                ex = base;\n+              }\n+              ast::expr_unary(op, base) {\n+                if op == ast::deref {\n+                    let base_t = ty::expr_ty(tcx, base);\n+                    let mut is_mutbl = false, ptr = false;\n+                    alt ty::get(base_t).struct {\n+                      ty::ty_box(mt) { is_mutbl = mt.mutbl==ast::m_mutbl; }\n+                      ty::ty_uniq(mt) { is_mutbl = mt.mutbl==ast::m_mutbl; }\n+                      ty::ty_res(_, _, _) { }\n+                      ty::ty_enum(_, _) { }\n+                      ty::ty_ptr(mt) | ty::ty_rptr(_, mt) {\n+                        is_mutbl = mt.mutbl==ast::m_mutbl;\n+                        ptr = true;\n+                      }\n+                      _ {\n+                        tcx.sess.span_bug(\n+                            base.span,\n+                            \"ill-typed base expression in deref\"); }\n+                    }\n+                    ds += [@{mutbl: is_mutbl, kind: unbox(ptr && is_mutbl),\n+                             outer_t: base_t}];\n+                    ex = base;\n+                } else { break; }\n+              }\n+              _ { break; }\n+            }\n+        }\n+        if autoderef {\n+            let auto_unbox = maybe_auto_unbox(tcx, ty::expr_ty(tcx, ex));\n+            ds += auto_unbox.ds;\n+        }\n+        ret {ex: ex, ds: @ds};\n+    }\n+\n+    let base_root = expr_root_(cx.tcx, none, ex, autoderef);\n     let mut unsafe_ty = none;\n     for vec::each(*base_root.ds) {|d|\n         if d.mutbl { unsafe_ty = some(contains(d.outer_t)); break; }"}, {"sha": "1d79ea41fb8d0153d1a3f10fda5d374a1e072507", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 261, "deletions": 125, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -12,11 +12,11 @@ import result::{result, ok, err, extensions};\n import syntax::print::pprust;\n import util::common::indenter;\n \n-export check_crate, root_map;\n+export check_crate, root_map, mutbl_map;\n \n fn check_crate(tcx: ty::ctxt,\n                method_map: typeck::method_map,\n-               crate: @ast::crate) -> root_map {\n+               crate: @ast::crate) -> (root_map, mutbl_map) {\n \n     // big hack to keep this off except when I want it on\n     let msg_level = alt os::getenv(\"RUST_BORROWCK\") {\n@@ -28,13 +28,15 @@ fn check_crate(tcx: ty::ctxt,\n                  method_map: method_map,\n                  msg_level: msg_level,\n                  root_map: int_hash(),\n-                 in_ctor: none};\n+                 mutbl_map: int_hash()};\n \n-    if msg_level > 0u {\n-        let req_loan_map = gather_loans(bccx, crate);\n-        check_loans(bccx, req_loan_map, crate);\n-    }\n-    ret bccx.root_map;\n+    let req_loan_map = if msg_level > 0u {\n+        gather_loans(bccx, crate)\n+    } else {\n+        int_hash()\n+    };\n+    check_loans(bccx, req_loan_map, crate);\n+    ret (bccx.root_map, bccx.mutbl_map);\n }\n \n const TREAT_CONST_AS_IMM: bool = true;\n@@ -46,17 +48,17 @@ type borrowck_ctxt = @{tcx: ty::ctxt,\n                        method_map: typeck::method_map,\n                        msg_level: uint,\n                        root_map: root_map,\n-\n-                       // Keep track of whether we're inside a ctor, so as to\n-                       // allow mutating immutable fields in the same class if\n-                       // we are in a ctor, we track the self id\n-                       in_ctor: option<ast::node_id>};\n+                       mutbl_map: mutbl_map};\n \n // a map mapping id's of expressions of task-local type (@T, []/@, etc) where\n // the box needs to be kept live to the id of the scope for which they must\n // stay live.\n type root_map = hashmap<ast::node_id, ast::node_id>;\n \n+// set of ids of local vars / formal arguments that are modified / moved.\n+// this is used in trans for optimization purposes.\n+type mutbl_map = std::map::hashmap<ast::node_id, ()>;\n+\n enum bckerr_code {\n     err_mutbl(ast::mutability, ast::mutability),\n     err_mut_uniq,\n@@ -69,9 +71,11 @@ type bckerr = {cmt: cmt, code: bckerr_code};\n type bckres<T> = result<T, bckerr>;\n \n enum categorization {\n-    cat_rvalue(rvalue_kind),    // result of eval'ing some rvalue\n+    cat_rvalue,                 // result of eval'ing some misc expr\n+    cat_special(special_kind),  //\n     cat_local(ast::node_id),    // local variable\n     cat_arg(ast::node_id),      // formal argument\n+    cat_stack_upvar(cmt),       // upvar in stack closure\n     cat_deref(cmt, ptr_kind),   // deref of a ptr\n     cat_comp(cmt, comp_kind),   // adjust to locate an internal component\n }\n@@ -82,19 +86,18 @@ enum ptr_kind {uniq_ptr, gc_ptr, region_ptr, unsafe_ptr}\n // I am coining the term \"components\" to mean \"pieces of a data\n // structure accessible without a dereference\":\n enum comp_kind {comp_tuple, comp_res, comp_variant,\n-                comp_field(str), comp_index}\n+                comp_field(str), comp_index(ty::t)}\n \n // We pun on *T to mean both actual deref of a ptr as well\n // as accessing of components:\n enum deref_kind {deref_ptr(ptr_kind), deref_comp(comp_kind)}\n \n // different kinds of expressions we might evaluate\n-enum rvalue_kind {\n-    rv_method,\n-    rv_static_item,\n-    rv_upvar,\n-    rv_misc,\n-    rv_self\n+enum special_kind {\n+    sk_method,\n+    sk_static_item,\n+    sk_self,\n+    sk_heap_upvar\n }\n \n // a complete categorization of a value indicating where it originated\n@@ -184,19 +187,13 @@ fn req_loans_in_expr(ex: @ast::expr,\n       ast::expr_addr_of(mutbl, base) {\n         let base_cmt = self.bccx.cat_expr(base);\n \n-        // make sure that if we taking an &mut or &imm ptr, the thing it\n-        // points at is mutable or immutable respectively:\n-        self.bccx.report_if_err(\n-            check_sup_mutbl(mutbl, base_cmt).chain { |_ok|\n-                // make sure that the thing we are pointing out stays valid\n-                // for the lifetime `scope_r`:\n-                let scope_r =\n-                    alt check ty::get(tcx.ty(ex)).struct {\n-                      ty::ty_rptr(r, _) { r }\n-                    };\n-                self.guarantee_valid(base_cmt, mutbl, scope_r);\n-                ok(())\n-            });\n+        // make sure that the thing we are pointing out stays valid\n+        // for the lifetime `scope_r` of the resulting ptr:\n+        let scope_r =\n+            alt check ty::get(tcx.ty(ex)).struct {\n+              ty::ty_rptr(r, _) { r }\n+            };\n+        self.guarantee_valid(base_cmt, mutbl, scope_r);\n       }\n \n       ast::expr_call(f, args, _) {\n@@ -396,19 +393,43 @@ impl methods for gather_loan_ctxt {\n \n enum check_loan_ctxt = @{\n     bccx: borrowck_ctxt,\n-    req_loan_map: req_loan_map\n+    req_loan_map: req_loan_map,\n+\n+    // Keep track of whether we're inside a ctor, so as to\n+    // allow mutating immutable fields in the same class if\n+    // we are in a ctor, we track the self id\n+    mut in_ctor: bool\n };\n \n fn check_loans(bccx: borrowck_ctxt,\n                req_loan_map: req_loan_map,\n                crate: @ast::crate) {\n-    let clcx = check_loan_ctxt(@{bccx: bccx, req_loan_map: req_loan_map});\n+    let clcx = check_loan_ctxt(@{bccx: bccx,\n+                                 req_loan_map: req_loan_map,\n+                                 mut in_ctor: false});\n     let vt = visit::mk_vt(@{visit_expr: check_loans_in_expr,\n-                            visit_block: check_loans_in_block\n+                            visit_block: check_loans_in_block,\n+                            visit_fn: check_loans_in_fn\n                             with *visit::default_visitor()});\n     visit::visit_crate(*crate, clcx, vt);\n }\n \n+enum assignment_type {\n+    at_straight_up,\n+    at_swap,\n+    at_mutbl_ref,\n+}\n+\n+impl methods for assignment_type {\n+    fn ing_form(desc: str) -> str {\n+        alt self {\n+          at_straight_up { \"assigning to \" + desc }\n+          at_swap { \"swapping to and from \" + desc }\n+          at_mutbl_ref { \"taking mut reference to \" + desc }\n+        }\n+    }\n+}\n+\n impl methods for check_loan_ctxt {\n     fn tcx() -> ty::ctxt { self.bccx.tcx }\n \n@@ -479,99 +500,184 @@ impl methods for check_loan_ctxt {\n         }\n     }\n \n-    fn check_assignment(ex: @ast::expr) {\n+    fn is_self_field(cmt: cmt) -> bool {\n+        alt cmt.cat {\n+          cat_comp(cmt_base, comp_field(_)) {\n+            alt cmt_base.cat {\n+              cat_special(sk_self) { true }\n+              _ { false }\n+            }\n+          }\n+          _ { false }\n+        }\n+    }\n+\n+    fn check_assignment(at: assignment_type, ex: @ast::expr) {\n         let cmt = self.bccx.cat_expr(ex);\n \n         #debug[\"check_assignment(cmt=%s)\",\n                self.bccx.cmt_to_repr(cmt)];\n \n-        alt cmt.mutbl {\n-          m_mutbl { /*ok*/ }\n-          m_const | m_imm {\n-            self.bccx.span_err(\n-                ex.span,\n-                #fmt[\"Cannot assign to %s\", self.bccx.cmt_to_str(cmt)]);\n-            ret;\n-          }\n-        }\n-\n-        // check for a conflicting loan as well\n-        let lp = alt cmt.lp {\n-          none { ret; }\n-          some(lp) { lp }\n-        };\n-        for self.walk_loans_of(ex.id, lp) { |loan|\n-            alt loan.mutbl {\n-              m_mutbl | m_const { /*ok*/ }\n-              m_imm {\n+        // check that the lvalue `ex` is assignable, but be careful\n+        // because assigning to self.foo in a ctor is always allowed.\n+        if !self.in_ctor || !self.is_self_field(cmt) {\n+            alt cmt.mutbl {\n+              m_mutbl { /*ok*/ }\n+              m_const | m_imm {\n                 self.bccx.span_err(\n                     ex.span,\n-                    #fmt[\"cannot assign to %s due to outstanding loan\",\n-                         self.bccx.cmt_to_str(cmt)]);\n-                self.bccx.span_note(\n-                    loan.cmt.span,\n-                    #fmt[\"loan of %s granted here\",\n-                         self.bccx.cmt_to_str(loan.cmt)]);\n+                    at.ing_form(self.bccx.cmt_to_str(cmt)));\n                 ret;\n               }\n             }\n         }\n+\n+        // check for a conflicting loan as well, except in the case of\n+        // taking a mutable ref.  that will create a loan of its own\n+        // which will be checked for compat separately in\n+        // check_for_conflicting_loans()\n+        if at != at_mutbl_ref {\n+            let lp = alt cmt.lp {\n+              none { ret; }\n+              some(lp) { lp }\n+            };\n+            for self.walk_loans_of(ex.id, lp) { |loan|\n+                alt loan.mutbl {\n+                  m_mutbl | m_const { /*ok*/ }\n+                  m_imm {\n+                    self.bccx.span_err(\n+                        ex.span,\n+                        #fmt[\"%s prohibited due to outstanding loan\",\n+                             at.ing_form(self.bccx.cmt_to_str(cmt))]);\n+                    self.bccx.span_note(\n+                        loan.cmt.span,\n+                        #fmt[\"loan of %s granted here\",\n+                             self.bccx.cmt_to_str(loan.cmt)]);\n+                    ret;\n+                  }\n+                }\n+            }\n+        }\n+\n+        self.bccx.add_to_mutbl_map(cmt);\n     }\n \n     fn check_move_out(ex: @ast::expr) {\n         let cmt = self.bccx.cat_expr(ex);\n+        self.check_move_out_from_cmt(cmt);\n+    }\n+\n+    fn check_move_out_from_cmt(cmt: cmt) {\n+        #debug[\"check_move_out_from_cmt(cmt=%s)\",\n+               self.bccx.cmt_to_repr(cmt)];\n \n         alt cmt.cat {\n           // Rvalues and locals can be moved:\n-          cat_rvalue(_) | cat_local(_) { /*ok*/ }\n+          cat_rvalue | cat_local(_) { }\n \n           // Owned arguments can be moved:\n-          cat_arg(_) if cmt.mutbl == m_mutbl { /*ok*/ }\n+          cat_arg(_) if cmt.mutbl == m_mutbl { }\n+\n+          // We allow moving out of static items because the old code\n+          // did.  This seems consistent with permitting moves out of\n+          // rvalues, I guess.\n+          cat_special(sk_static_item) { }\n \n           // Nothing else.\n           _ {\n             self.bccx.span_err(\n-                ex.span,\n-                #fmt[\"Cannot move from %s\", self.bccx.cmt_to_str(cmt)]);\n+                cmt.span,\n+                #fmt[\"moving out of %s\", self.bccx.cmt_to_str(cmt)]);\n             ret;\n           }\n         }\n \n+        self.bccx.add_to_mutbl_map(cmt);\n+\n         // check for a conflicting loan:\n         let lp = alt cmt.lp {\n           none { ret; }\n           some(lp) { lp }\n         };\n-        for self.walk_loans_of(ex.id, lp) { |loan|\n+        for self.walk_loans_of(cmt.id, lp) { |loan|\n             self.bccx.span_err(\n-                ex.span,\n-                #fmt[\"Cannot move from %s due to outstanding loan\",\n+                cmt.span,\n+                #fmt[\"moving out of %s prohibited due to outstanding loan\",\n                      self.bccx.cmt_to_str(cmt)]);\n             self.bccx.span_note(\n                 loan.cmt.span,\n-                #fmt[\"Loan of %s granted here\",\n+                #fmt[\"loan of %s granted here\",\n                      self.bccx.cmt_to_str(loan.cmt)]);\n             ret;\n         }\n     }\n }\n \n+fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n+                     sp: span, id: ast::node_id, &&self: check_loan_ctxt,\n+                     visitor: visit::vt<check_loan_ctxt>) {\n+\n+    let old_in_ctor = self.in_ctor;\n+\n+    // In principle, we could consider fk_anon(*) or fk_fn_block(*) to\n+    // be in a ctor, I suppose, but the purpose of the in_ctor flag is\n+    // to allow modifications of otherwise immutable fields and\n+    // typestate wouldn't be able to \"see\" into those functions\n+    // anyway, so it wouldn't be very helpful.\n+    alt fk {\n+      visit::fk_ctor(*) { self.in_ctor = true; }\n+      _ { self.in_ctor = false; }\n+    };\n+\n+    visit::visit_fn(fk, decl, body, sp, id, self, visitor);\n+\n+    self.in_ctor = old_in_ctor;\n+}\n+\n fn check_loans_in_expr(expr: @ast::expr,\n                        &&self: check_loan_ctxt,\n                        vt: visit::vt<check_loan_ctxt>) {\n     self.check_for_conflicting_loans(expr.id);\n     alt expr.node {\n       ast::expr_swap(l, r) {\n-        self.check_assignment(l);\n-        self.check_assignment(r);\n+        self.check_assignment(at_swap, l);\n+        self.check_assignment(at_swap, r);\n       }\n       ast::expr_move(dest, src) {\n-        self.check_assignment(dest);\n+        self.check_assignment(at_straight_up, dest);\n         self.check_move_out(src);\n       }\n       ast::expr_assign(dest, _) |\n       ast::expr_assign_op(_, dest, _) {\n-        self.check_assignment(dest);\n+        self.check_assignment(at_straight_up, dest);\n+      }\n+      ast::expr_fn(_, _, _, cap_clause) |\n+      ast::expr_fn_block(_, _, cap_clause) {\n+        for (*cap_clause).each { |cap_item|\n+            if cap_item.is_move {\n+                let def = self.tcx().def_map.get(cap_item.id);\n+\n+                // Hack: the type that is used in the cmt doesn't actually\n+                // matter here, so just subst nil instead of looking up\n+                // the type of the def that is referred to\n+                let cmt = self.bccx.cat_def(cap_item.id, cap_item.span,\n+                                            ty::mk_nil(self.tcx()), def);\n+                self.check_move_out_from_cmt(cmt);\n+            }\n+        }\n+      }\n+      ast::expr_addr_of(mutbl, base) {\n+        alt mutbl {\n+          m_const { /*all memory is const*/ }\n+          m_mutbl {\n+            // If we are taking an &mut ptr, make sure the memory\n+            // being pointed at is assignable in the first place:\n+            self.check_assignment(at_mutbl_ref, base);\n+          }\n+          m_imm {\n+            // XXX explain why no check is req'd here\n+          }\n+        }\n       }\n       ast::expr_call(f, args, _) {\n         let arg_tys = ty::ty_fn_args(ty::expr_ty(self.tcx(), f));\n@@ -580,11 +686,10 @@ fn check_loans_in_expr(expr: @ast::expr,\n               ast::by_move {\n                 self.check_move_out(arg);\n               }\n-              ast::by_mutbl_ref |\n-              ast::by_ref {\n-                // these are translated into loans\n+              ast::by_mutbl_ref {\n+                self.check_assignment(at_mutbl_ref, arg);\n               }\n-              ast::by_copy | ast::by_val {\n+              ast::by_ref | ast::by_copy | ast::by_val {\n               }\n             }\n         }\n@@ -720,7 +825,7 @@ impl categorize_methods for borrowck_ctxt {\n \n         if self.method_map.contains_key(expr.id) {\n             ret @{id:expr.id, span:expr.span,\n-                  cat:cat_rvalue(rv_method), lp:none,\n+                  cat:cat_special(sk_method), lp:none,\n                   mutbl:m_imm, ty:expr_ty};\n         }\n \n@@ -749,7 +854,7 @@ impl categorize_methods for borrowck_ctxt {\n \n           ast::expr_path(_) {\n             let def = self.tcx.def_map.get(expr.id);\n-            self.cat_def(expr, expr_ty, def)\n+            self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n           ast::expr_addr_of(*) | ast::expr_call(*) | ast::expr_bind(*) |\n@@ -765,7 +870,7 @@ impl categorize_methods for borrowck_ctxt {\n           ast::expr_lit(*) | ast::expr_break | ast::expr_mac(*) |\n           ast::expr_cont | ast::expr_rec(*) {\n             @{id:expr.id, span:expr.span,\n-              cat:cat_rvalue(rv_misc), lp:none,\n+              cat:cat_rvalue, lp:none,\n               mutbl:m_imm, ty:expr_ty}\n           }\n         }\n@@ -870,9 +975,10 @@ impl categorize_methods for borrowck_ctxt {\n         let deref_cmt = @{id:expr.id, span:expr.span,\n                           cat:cat_deref(base_cmt, ptr), lp:deref_lp,\n                           mutbl:mt.mutbl, ty:mt.ty};\n-        let index_lp = deref_lp.map { |lp| @lp_comp(lp, comp_index) };\n+        let comp = comp_index(base_cmt.ty);\n+        let index_lp = deref_lp.map { |lp| @lp_comp(lp, comp) };\n         @{id:expr.id, span:expr.span,\n-          cat:cat_comp(deref_cmt, comp_index), lp:index_lp,\n+          cat:cat_comp(deref_cmt, comp), lp:index_lp,\n           mutbl:mt.mutbl, ty:mt.ty}\n     }\n \n@@ -892,7 +998,8 @@ impl categorize_methods for borrowck_ctxt {\n           ty: self.tcx.ty(elt)}\n     }\n \n-    fn cat_def(expr: @ast::expr,\n+    fn cat_def(id: ast::node_id,\n+               span: span,\n                expr_ty: ty::t,\n                def: ast::def) -> cmt {\n         alt def {\n@@ -902,8 +1009,8 @@ impl categorize_methods for borrowck_ctxt {\n           ast::def_ty(_) | ast::def_prim_ty(_) |\n           ast::def_ty_param(_, _) | ast::def_class(_) |\n           ast::def_region(_) {\n-            @{id:expr.id, span:expr.span,\n-              cat:cat_rvalue(rv_static_item), lp:none,\n+            @{id:id, span:span,\n+              cat:cat_special(sk_static_item), lp:none,\n               mutbl:m_imm, ty:expr_ty}\n           }\n \n@@ -931,14 +1038,14 @@ impl categorize_methods for borrowck_ctxt {\n                 {m:m_imm, lp:some(@lp_arg(vid))}\n               }\n             };\n-            @{id:expr.id, span:expr.span,\n+            @{id:id, span:span,\n               cat:cat_arg(vid), lp:lp,\n               mutbl:m, ty:expr_ty}\n           }\n \n           ast::def_self(_) {\n-            @{id:expr.id, span:expr.span,\n-              cat:cat_rvalue(rv_self), lp:none,\n+            @{id:id, span:span,\n+              cat:cat_special(sk_self), lp:none,\n               mutbl:m_imm, ty:expr_ty}\n           }\n \n@@ -947,59 +1054,45 @@ impl categorize_methods for borrowck_ctxt {\n             let proto = ty::ty_fn_proto(ty);\n             alt proto {\n               ast::proto_any | ast::proto_block {\n-                self.cat_def(expr, expr_ty, *inner)\n+                let upcmt = self.cat_def(id, span, expr_ty, *inner);\n+                @{id:id, span:span,\n+                  cat:cat_stack_upvar(upcmt), lp:upcmt.lp,\n+                  mutbl:upcmt.mutbl, ty:upcmt.ty}\n               }\n               ast::proto_bare | ast::proto_uniq | ast::proto_box {\n                 // FIXME #2152 allow mutation of moved upvars\n-                @{id:expr.id, span:expr.span,\n-                  cat:cat_rvalue(rv_upvar), lp:none,\n+                @{id:id, span:span,\n+                  cat:cat_special(sk_heap_upvar), lp:none,\n                   mutbl:m_imm, ty:expr_ty}\n               }\n             }\n           }\n \n           ast::def_local(vid, mutbl) {\n             let m = if mutbl {m_mutbl} else {m_imm};\n-            @{id:expr.id, span:expr.span,\n+            @{id:id, span:span,\n               cat:cat_local(vid), lp:some(@lp_local(vid)),\n               mutbl:m, ty:expr_ty}\n           }\n \n           ast::def_binding(vid) {\n             // no difference between a binding and any other local variable\n             // from out point of view, except that they are always immutable\n-            @{id:expr.id, span:expr.span,\n+            @{id:id, span:span,\n               cat:cat_local(vid), lp:some(@lp_local(vid)),\n               mutbl:m_imm, ty:expr_ty}\n           }\n         }\n     }\n \n-    fn cat_to_str(mutbl: str, cat: categorization) -> str {\n-        alt cat {\n-          cat_rvalue(rv_method) { \"method\" }\n-          cat_rvalue(rv_static_item) { \"static item\" }\n-          cat_rvalue(rv_upvar) { \"upvar\" }\n-          cat_rvalue(rv_misc) { \"non-lvalue\" }\n-          cat_rvalue(rv_self) { \"self reference\" }\n-          cat_local(_) { mutbl + \" local variable\" }\n-          cat_arg(_) { mutbl + \" argument\" }\n-          cat_deref(_, _) { mutbl + \" dereference\" }\n-          cat_comp(_, comp_field(_)) { mutbl + \" field\" }\n-          cat_comp(_, comp_index) { mutbl + \" vector/string contents\" }\n-          cat_comp(_, comp_tuple) { mutbl + \" tuple contents\" }\n-          cat_comp(_, comp_res) { mutbl + \" resource contents\" }\n-          cat_comp(_, comp_variant) { mutbl + \" enum contents\" }\n-        }\n-    }\n-\n     fn cat_to_repr(cat: categorization) -> str {\n         alt cat {\n-          cat_rvalue(rv_method) { \"method\" }\n-          cat_rvalue(rv_static_item) { \"static_item\" }\n-          cat_rvalue(rv_upvar) { \"upvar\" }\n-          cat_rvalue(rv_misc) { \"rvalue\" }\n-          cat_rvalue(rv_self) { \"self\" }\n+          cat_special(sk_method) { \"method\" }\n+          cat_special(sk_static_item) { \"static_item\" }\n+          cat_special(sk_self) { \"self\" }\n+          cat_special(sk_heap_upvar) { \"heap-upvar\" }\n+          cat_stack_upvar(_) { \"stack-upvar\" }\n+          cat_rvalue { \"rvalue\" }\n           cat_local(node_id) { #fmt[\"local(%d)\", node_id] }\n           cat_arg(node_id) { #fmt[\"arg(%d)\", node_id] }\n           cat_deref(cmt, ptr) {\n@@ -1031,7 +1124,7 @@ impl categorize_methods for borrowck_ctxt {\n     fn comp_to_repr(comp: comp_kind) -> str {\n         alt comp {\n           comp_field(fld) { fld }\n-          comp_index { \"[]\" }\n+          comp_index(_) { \"[]\" }\n           comp_tuple { \"()\" }\n           comp_res { \"<res>\" }\n           comp_variant { \"<enum>\" }\n@@ -1068,7 +1161,34 @@ impl categorize_methods for borrowck_ctxt {\n \n     fn cmt_to_str(cmt: cmt) -> str {\n         let mut_str = self.mut_to_str(cmt.mutbl);\n-        self.cat_to_str(mut_str, cmt.cat)\n+        alt cmt.cat {\n+          cat_special(sk_method) { \"method\" }\n+          cat_special(sk_static_item) { \"static item\" }\n+          cat_special(sk_self) { \"self reference\" }\n+          cat_special(sk_heap_upvar) { \"upvar\" }\n+          cat_rvalue { \"non-lvalue\" }\n+          cat_local(_) { mut_str + \" local variable\" }\n+          cat_arg(_) { mut_str + \" argument\" }\n+          cat_deref(_, _) { \"dereference of \" + mut_str + \" pointer\" }\n+          cat_stack_upvar(_) { mut_str + \" upvar\" }\n+          cat_comp(_, comp_field(_)) { mut_str + \" field\" }\n+          cat_comp(_, comp_tuple) { \"tuple content\" }\n+          cat_comp(_, comp_res) { \"resource content\" }\n+          cat_comp(_, comp_variant) { \"enum content\" }\n+          cat_comp(_, comp_index(t)) {\n+            alt ty::get(t).struct {\n+              ty::ty_vec(*) | ty::ty_evec(*) {\n+                mut_str + \" vec content\"\n+              }\n+\n+              ty::ty_str | ty::ty_estr(*) {\n+                mut_str + \" str content\"\n+              }\n+\n+              _ { mut_str + \" indexed content\" }\n+            }\n+          }\n+        }\n     }\n \n     fn bckerr_code_to_str(code: bckerr_code) -> str {\n@@ -1115,6 +1235,18 @@ impl categorize_methods for borrowck_ctxt {\n     fn span_note(s: span, m: str) {\n         self.tcx.sess.span_note(s, m);\n     }\n+\n+    fn add_to_mutbl_map(cmt: cmt) {\n+        alt cmt.cat {\n+          cat_local(id) | cat_arg(id) {\n+            self.mutbl_map.insert(id, ());\n+          }\n+          cat_stack_upvar(cmt) {\n+            self.add_to_mutbl_map(cmt);\n+          }\n+          _ {}\n+        }\n+    }\n }\n \n fn field_mutbl(tcx: ty::ctxt,\n@@ -1167,9 +1299,12 @@ impl preserve_methods for preserve_ctxt {\n         let _i = indenter();\n \n         alt cmt.cat {\n-          cat_rvalue(_) {\n+          cat_rvalue | cat_special(_) {\n             ok(())\n           }\n+          cat_stack_upvar(cmt) {\n+            self.preserve(cmt)\n+          }\n           cat_local(_) {\n             // This should never happen.  Local variables are always lendable,\n             // so either `loan()` should be called or there must be some\n@@ -1185,7 +1320,7 @@ impl preserve_methods for preserve_ctxt {\n             ok(())\n           }\n           cat_comp(cmt_base, comp_field(_)) |\n-          cat_comp(cmt_base, comp_index) |\n+          cat_comp(cmt_base, comp_index(_)) |\n           cat_comp(cmt_base, comp_tuple) |\n           cat_comp(cmt_base, comp_res) {\n             // Most embedded components: if the base is stable, the\n@@ -1282,16 +1417,17 @@ impl loan_methods for loan_ctxt {\n         }\n \n         alt cmt.cat {\n-          cat_rvalue(_) {\n+          cat_rvalue | cat_special(_) {\n+            // should never be loanable\n             self.bccx.tcx.sess.span_bug(\n                 cmt.span,\n                 \"rvalue with a non-none lp\");\n           }\n-          cat_local(_) | cat_arg(_) {\n+          cat_local(_) | cat_arg(_) | cat_stack_upvar(_) {\n             self.ok_with_loan_of(cmt, req_mutbl)\n           }\n           cat_comp(cmt_base, comp_field(_)) |\n-          cat_comp(cmt_base, comp_index) |\n+          cat_comp(cmt_base, comp_index(_)) |\n           cat_comp(cmt_base, comp_tuple) |\n           cat_comp(cmt_base, comp_res) {\n             // For most components, the type of the embedded data is"}, {"sha": "c74d1d01bfbf05d205671275b55099bdb652956b", "filename": "src/rustc/middle/mutbl.rs", "status": "removed", "additions": 0, "deletions": 372, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/c23d6a50d786e926d001423f36dc43fe480acbae/src%2Frustc%2Fmiddle%2Fmutbl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c23d6a50d786e926d001423f36dc43fe480acbae/src%2Frustc%2Fmiddle%2Fmutbl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmutbl.rs?ref=c23d6a50d786e926d001423f36dc43fe480acbae", "patch": "@@ -1,372 +0,0 @@\n-import syntax::ast::*;\n-import syntax::visit;\n-import syntax::ast_util;\n-import driver::session::session;\n-import std::map::hashmap;\n-\n-enum deref_t { unbox(bool), field, index, }\n-\n-type deref = @{mutbl: bool, kind: deref_t, outer_t: ty::t};\n-\n-// Finds the root (the thing that is dereferenced) for the given expr, and a\n-// vec of dereferences that were used on this root. Note that, in this vec,\n-// the inner derefs come in front, so foo.bar[1] becomes rec(ex=foo,\n-// ds=[index,field])\n-fn expr_root(cx: @ctx, ex: @expr, autoderef: bool)\n-    -> {ex: @expr, ds: @[deref]} {\n-    expr_root_(cx.tcx, cx.in_ctor, ex, autoderef)\n-}\n-\n-fn expr_root_(tcx: ty::ctxt, ctor_self: option<node_id>,\n-             ex: @expr, autoderef: bool) ->\n-   {ex: @expr, ds: @[deref]} {\n-    fn maybe_auto_unbox(tcx: ty::ctxt, t: ty::t) -> {t: ty::t, ds: [deref]} {\n-        let mut ds = [], t = t;\n-        loop {\n-            alt ty::get(t).struct {\n-              ty::ty_box(mt) | ty::ty_uniq(mt) | ty::ty_rptr(_, mt) {\n-                ds += [@{mutbl: mt.mutbl == m_mutbl,\n-                         kind: unbox(false),\n-                         outer_t: t}];\n-                t = mt.ty;\n-              }\n-              ty::ty_res(_, inner, substs) {\n-                ds += [@{mutbl: false, kind: unbox(false), outer_t: t}];\n-                t = ty::subst(tcx, substs, inner);\n-              }\n-              ty::ty_enum(did, substs) {\n-                let variants = ty::enum_variants(tcx, did);\n-                if vec::len(*variants) != 1u ||\n-                       vec::len(variants[0].args) != 1u {\n-                    break;\n-                }\n-                ds += [@{mutbl: false, kind: unbox(false), outer_t: t}];\n-                t = ty::subst(tcx, substs, variants[0].args[0]);\n-              }\n-              _ { break; }\n-            }\n-        }\n-        ret {t: t, ds: ds};\n-    }\n-    let mut ds: [deref] = [], ex = ex;\n-    loop {\n-        alt copy ex.node {\n-          expr_field(base, ident, _) {\n-            let auto_unbox = maybe_auto_unbox(tcx, ty::expr_ty(tcx, base));\n-            let mut is_mutbl = false;\n-            alt ty::get(auto_unbox.t).struct {\n-              ty::ty_rec(fields) {\n-                for fields.each {|fld|\n-                    if str::eq(ident, fld.ident) {\n-                        is_mutbl = fld.mt.mutbl == m_mutbl;\n-                        break;\n-                    }\n-                }\n-              }\n-              ty::ty_class(did, _) {\n-                  util::common::log_expr(*base);\n-                  let in_self = alt ctor_self {\n-                          some(selfid) {\n-                              alt tcx.def_map.find(base.id) {\n-                                 some(def_self(slfid)) { slfid == selfid }\n-                                 _ { false }\n-                              }\n-                          }\n-                          none { false }\n-                  };\n-                  for ty::lookup_class_fields(tcx, did).each {|fld|\n-                    if str::eq(ident, fld.ident) {\n-                        is_mutbl = fld.mutability == class_mutable\n-                            || in_self; // all fields can be mutated\n-                                        // in the ctor\n-                        break;\n-                    }\n-                  }\n-              }\n-              _ {}\n-            }\n-            ds += [@{mutbl: is_mutbl, kind: field, outer_t: auto_unbox.t}];\n-            ds += auto_unbox.ds;\n-            ex = base;\n-          }\n-          expr_index(base, _) {\n-            let auto_unbox = maybe_auto_unbox(tcx, ty::expr_ty(tcx, base));\n-            alt ty::get(auto_unbox.t).struct {\n-              ty::ty_evec(mt, _) |\n-              ty::ty_vec(mt) {\n-                ds +=\n-                    [@{mutbl: mt.mutbl == m_mutbl,\n-                       kind: index,\n-                       outer_t: auto_unbox.t}];\n-              }\n-              ty::ty_estr(_) |\n-              ty::ty_str {\n-                ds += [@{mutbl: false, kind: index, outer_t: auto_unbox.t}];\n-              }\n-              _ { break; }\n-            }\n-            ds += auto_unbox.ds;\n-            ex = base;\n-          }\n-          expr_unary(op, base) {\n-            if op == deref {\n-                let base_t = ty::expr_ty(tcx, base);\n-                let mut is_mutbl = false, ptr = false;\n-                alt ty::get(base_t).struct {\n-                  ty::ty_box(mt) { is_mutbl = mt.mutbl == m_mutbl; }\n-                  ty::ty_uniq(mt) { is_mutbl = mt.mutbl == m_mutbl; }\n-                  ty::ty_res(_, _, _) { }\n-                  ty::ty_enum(_, _) { }\n-                  ty::ty_ptr(mt) | ty::ty_rptr(_, mt) {\n-                    is_mutbl = mt.mutbl == m_mutbl;\n-                    ptr = true;\n-                  }\n-                  _ { tcx.sess.span_bug(base.span, \"ill-typed base \\\n-                        expression in deref\"); }\n-                }\n-                ds += [@{mutbl: is_mutbl, kind: unbox(ptr && is_mutbl),\n-                         outer_t: base_t}];\n-                ex = base;\n-            } else { break; }\n-          }\n-          _ { break; }\n-        }\n-    }\n-    if autoderef {\n-        let auto_unbox = maybe_auto_unbox(tcx, ty::expr_ty(tcx, ex));\n-        ds += auto_unbox.ds;\n-    }\n-    ret {ex: ex, ds: @ds};\n-}\n-\n-// Actual mutbl-checking pass\n-\n-type mutbl_map = std::map::hashmap<node_id, ()>;\n-// Keep track of whether we're inside a ctor, so as to\n-// allow mutating immutable fields in the same class\n-// if we are in a ctor, we track the self id\n-type ctx = {tcx: ty::ctxt, mutbl_map: mutbl_map, in_ctor: option<node_id>};\n-\n-fn check_crate(tcx: ty::ctxt, crate: @crate) -> mutbl_map {\n-    let cx = @{tcx: tcx, mutbl_map: std::map::int_hash(), in_ctor: none};\n-    let v = @{visit_expr: visit_expr,\n-              visit_decl: visit_decl,\n-              visit_item: visit_item\n-              with *visit::default_visitor()};\n-    visit::visit_crate(*crate, cx, visit::mk_vt(v));\n-    ret cx.mutbl_map;\n-}\n-\n-enum msg { msg_assign, msg_move_out, msg_mutbl_ref, }\n-\n-fn mk_err(cx: @ctx, span: syntax::codemap::span, msg: msg, name: str) {\n-    cx.tcx.sess.span_err(span, alt msg {\n-      msg_assign { \"assigning to \" + name }\n-      msg_move_out { \"moving out of \" + name }\n-      msg_mutbl_ref { \"passing \" + name + \" by mut reference\" }\n-    });\n-}\n-\n-fn visit_decl(d: @decl, &&cx: @ctx, v: visit::vt<@ctx>) {\n-    visit::visit_decl(d, cx, v);\n-    alt d.node {\n-      decl_local(locs) {\n-        for locs.each {|loc|\n-            alt loc.node.init {\n-              some(init) {\n-                if init.op == init_move { check_move_rhs(cx, init.expr); }\n-              }\n-              none { }\n-            }\n-        }\n-      }\n-      _ { }\n-    }\n-}\n-\n-fn visit_expr(ex: @expr, &&cx: @ctx, v: visit::vt<@ctx>) {\n-    alt ex.node {\n-      expr_call(f, args, _) { check_call(cx, f, args); }\n-      expr_bind(f, args) { check_bind(cx, f, args); }\n-      expr_swap(lhs, rhs) {\n-        check_lval(cx, lhs, msg_assign);\n-        check_lval(cx, rhs, msg_assign);\n-      }\n-      expr_move(dest, src) {\n-        check_lval(cx, dest, msg_assign);\n-        check_move_rhs(cx, src);\n-      }\n-      expr_assign(dest, src) | expr_assign_op(_, dest, src) {\n-        check_lval(cx, dest, msg_assign);\n-      }\n-      expr_fn(_, _, _, cap_clause) | expr_fn_block(_, _, cap_clause) {\n-        for (*cap_clause).each { |cap_item|\n-            if cap_item.is_move {\n-                let def = cx.tcx.def_map.get(cap_item.id);\n-                alt is_illegal_to_modify_def(cx, def, msg_move_out) {\n-                  some(name) { mk_err(cx, cap_item.span,\n-                                      msg_move_out, name); }\n-                  _ { }\n-                }\n-                cx.mutbl_map.insert(ast_util::def_id_of_def(def).node, ());\n-            }\n-        }\n-      }\n-      _ { }\n-    }\n-    visit::visit_expr(ex, cx, v);\n-}\n-\n-fn visit_item(item: @item, &&cx: @ctx, v: visit::vt<@ctx>) {\n-    alt item.node {\n-      item_class(tps, _, items, ctor, _) {\n-         v.visit_ty_params(tps, cx, v);\n-         vec::map::<@class_member, ()>(items,\n-             {|i| v.visit_class_item(i, cx, v); });\n-         visit::visit_class_ctor_helper(ctor, item.ident, tps,\n-                                        ast_util::local_def(item.id),\n-                    @{in_ctor: some(ctor.node.self_id) with *cx}, v);\n-      }\n-      _ { visit::visit_item(item, cx, v); }\n-    }\n-}\n-\n-fn check_lval(cx: @ctx, dest: @expr, msg: msg) {\n-    alt dest.node {\n-      expr_path(p) {\n-        let def = cx.tcx.def_map.get(dest.id);\n-        alt is_illegal_to_modify_def(cx, def, msg) {\n-          some(name) { mk_err(cx, dest.span, msg, name); }\n-          _ { }\n-        }\n-        cx.mutbl_map.insert(ast_util::def_id_of_def(def).node, ());\n-      }\n-      _ {\n-        let root = expr_root(cx, dest, false);\n-        if vec::len(*root.ds) == 0u {\n-            if msg != msg_move_out {\n-                mk_err(cx, dest.span, msg, \"non-lvalue\");\n-            }\n-        } else if !root.ds[0].mutbl {\n-            let name =\n-                alt root.ds[0].kind {\n-                  mutbl::unbox(_) { \"immutable box\" }\n-                  mutbl::field { \"immutable field\" }\n-                  mutbl::index { \"immutable vec content\" }\n-                };\n-            mk_err(cx, dest.span, msg, name);\n-        }\n-      }\n-    }\n-}\n-\n-fn check_move_rhs(cx: @ctx, src: @expr) {\n-    alt src.node {\n-      expr_path(p) {\n-        alt cx.tcx.def_map.get(src.id) {\n-          def_self(_) {\n-            mk_err(cx, src.span, msg_move_out, \"method self\");\n-          }\n-          _ { }\n-        }\n-        check_lval(cx, src, msg_move_out);\n-      }\n-      _ {\n-        let root = expr_root(cx, src, false);\n-\n-        // Not a path and no-derefs means this is a temporary.\n-        if vec::len(*root.ds) != 0u &&\n-           root.ds[vec::len(*root.ds) - 1u].kind != unbox(true) {\n-            cx.tcx.sess.span_err(src.span, \"moving out of a data structure\");\n-        }\n-      }\n-    }\n-}\n-\n-fn check_call(cx: @ctx, f: @expr, args: [@expr]) {\n-    let arg_ts = ty::ty_fn_args(ty::expr_ty(cx.tcx, f));\n-    let mut i = 0u;\n-    for arg_ts.each {|arg_t|\n-        alt ty::resolved_mode(cx.tcx, arg_t.mode) {\n-          by_mutbl_ref { check_lval(cx, args[i], msg_mutbl_ref); }\n-          by_move { check_lval(cx, args[i], msg_move_out); }\n-          by_ref | by_val | by_copy { }\n-        }\n-        i += 1u;\n-    }\n-}\n-\n-fn check_bind(cx: @ctx, f: @expr, args: [option<@expr>]) {\n-    let arg_ts = ty::ty_fn_args(ty::expr_ty(cx.tcx, f));\n-    let mut i = 0u;\n-    for args.each {|arg|\n-        alt arg {\n-          some(expr) {\n-            let o_msg = alt ty::resolved_mode(cx.tcx, arg_ts[i].mode) {\n-              by_mutbl_ref { some(\"by mut reference\") }\n-              by_move { some(\"by move\") }\n-              _ { none }\n-            };\n-            alt o_msg {\n-              some(name) {\n-                cx.tcx.sess.span_err(\n-                    expr.span, \"can not bind an argument passed \" + name);\n-              }\n-              none {}\n-            }\n-          }\n-          _ {}\n-        }\n-        i += 1u;\n-    }\n-}\n-\n-// returns some if the def cannot be modified.  the kind of modification is\n-// indicated by `msg`.\n-fn is_illegal_to_modify_def(cx: @ctx, def: def, msg: msg) -> option<str> {\n-    alt def {\n-      def_fn(_, _) | def_mod(_) | def_native_mod(_) | def_const(_) |\n-      def_use(_) {\n-        some(\"static item\")\n-      }\n-      def_arg(_, m) {\n-        alt ty::resolved_mode(cx.tcx, m) {\n-          by_ref | by_val { some(\"argument of enclosing function\") }\n-          by_mutbl_ref | by_move | by_copy { none }\n-        }\n-      }\n-      def_self(_) { some(\"self argument\") }\n-      def_upvar(_, inner, node_id) {\n-        let ty = ty::node_id_to_type(cx.tcx, node_id);\n-        let proto = ty::ty_fn_proto(ty);\n-        ret alt proto {\n-          proto_any | proto_block {\n-            is_illegal_to_modify_def(cx, *inner, msg)\n-          }\n-          proto_bare | proto_uniq | proto_box {\n-            some(\"upvar\")\n-          }\n-        };\n-      }\n-\n-      // Note: we should *always* allow all local variables to be assigned\n-      // here and then guarantee in the typestate pass that immutable local\n-      // variables are assigned at most once.  But this requires a new kind of\n-      // propagation (def. not assigned), so I didn't do that.\n-      def_local(_, false) if msg == msg_move_out { none }\n-      def_local(_, false) {\n-        some(\"immutable local variable\")\n-      }\n-\n-      def_binding(_) { some(\"binding\") }\n-      _ { none }\n-    }\n-}\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "2635476dfb723c5dcca43337e8ee1a2c0abbaadb", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -340,6 +340,16 @@ fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n                       with cx};\n         visit::visit_expr(expr, new_cx, visitor);\n       }\n+      ast::expr_fn(_, _, _, cap_clause) |\n+      ast::expr_fn_block(_, _, cap_clause) {\n+        // although the capture items are not expressions per se, they\n+        // do get \"evaluated\" in some sense as copies or moves of the\n+        // relevant variables so we parent them like an expression\n+        for (*cap_clause).each { |cap_item|\n+            record_parent(cx, cap_item.id);\n+        }\n+        visit::visit_expr(expr, cx, visitor);\n+      }\n       _ {\n         visit::visit_expr(expr, cx, visitor);\n       }"}, {"sha": "c2e9d8ed5fb840d657bd05301a2e3812f2bbbaf8", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -64,7 +64,7 @@ resource BuilderRef_res(B: BuilderRef) { llvm::LLVMDisposeBuilder(B); }\n \n // Misc. auxiliary maps used in the crate_ctxt\n type maps = {\n-    mutbl_map: middle::mutbl::mutbl_map,\n+    mutbl_map: middle::borrowck::mutbl_map,\n     copy_map: middle::alias::copy_map,\n     last_uses: middle::last_use::last_uses,\n     impl_map: middle::resolve::impl_map,"}, {"sha": "cdfecad1b152714cebffd2a79fea0b450a846f52", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -43,7 +43,6 @@ mod middle {\n     mod check_alt;\n     mod check_const;\n     mod lint;\n-    mod mutbl;\n     mod borrowck;\n     mod alias;\n     mod last_use;"}, {"sha": "f7577d21c7e374fb5f835c7bfb586629cd9dca57", "filename": "src/test/compile-fail/assign-to-method.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -1,4 +1,3 @@\n-// error-pattern:assigning to immutable field\n class cat {\n   priv {\n     let mut meows : uint;\n@@ -12,5 +11,5 @@ class cat {\n \n fn main() {\n   let nyan : cat = cat(52u, 99);\n-  nyan.speak = fn@() { log(error, \"meow\"); };\n+  nyan.speak = fn@() { #debug[\"meow\"]; }; //! ERROR assigning to method\n }"}, {"sha": "275d8ed7e703c5aa9ef62f0ad74514935360abfa", "filename": "src/test/compile-fail/borrowck-assign-to-subfield.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-subfield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-subfield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-subfield.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -0,0 +1,20 @@\n+fn main() {\n+    let mut p = {a: 1,\n+                 w: {a: 1},\n+                 x: @{a: 1},\n+                 y: @const {a: 1},\n+                 z: @mut{a: 1}};\n+\n+    // even though `x` is not declared as a mutable field,\n+    // `p` as a whole is mutable, so it can be modified.\n+    p.a = 2;\n+\n+    // this is true for an interior field too\n+    p.w.a = 2;\n+\n+    // in these cases we pass through a box, so the mut\n+    // of the box is dominant\n+    p.x.a = 2;     //! ERROR assigning to immutable field\n+    p.y.a = 2;     //! ERROR assigning to const field\n+    p.z.a = 2;\n+}\n\\ No newline at end of file"}, {"sha": "d56bdf958c8b6c59f293a3f763ee3a9b9c81c806", "filename": "src/test/compile-fail/borrowck-lend-flow.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -61,6 +61,15 @@ fn while_aliased_mut_cond(cond: bool, cond2: bool) {\n     }\n }\n \n+fn loop_in_block() {\n+    let mut v = ~3, w = ~4;\n+    let mut _x = &mut w;\n+    uint::range(0u, 10u) {|_i|\n+        borrow(v); //! ERROR loan of mutable upvar as immutable conflicts with prior loan\n+        _x = &mut v; //! NOTE prior loan as mutable granted here\n+    }\n+}\n+\n fn at_most_once_block() {\n     fn at_most_once(f: fn()) { f() }\n \n@@ -70,7 +79,7 @@ fn at_most_once_block() {\n     let mut v = ~3, w = ~4;\n     let mut _x = &mut w;\n     at_most_once {||\n-        borrow(v); //! ERROR loan of mutable local variable as immutable conflicts with prior loan\n+        borrow(v); //! ERROR loan of mutable upvar as immutable conflicts with prior loan\n         _x = &mut v; //! NOTE prior loan as mutable granted here\n     }\n }"}, {"sha": "b5b2f24d0dac6b6d2bf8923897af793d97b7f74a", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -0,0 +1,24 @@\n+// compile-flags:--borrowck=err\n+\n+fn borrow(v: &int, f: fn(x: &int)) {\n+    f(v);\n+}\n+\n+fn box_imm() {\n+    let mut v = ~3;\n+    let _w = &mut v; //! NOTE loan of mutable local variable granted here\n+    task::spawn { |move v|\n+        //!^ ERROR moving out of mutable local variable prohibited due to outstanding loan\n+        #debug[\"v=%d\", *v];\n+    }\n+\n+    let mut v = ~3;\n+    let _w = &mut v; //! NOTE loan of mutable local variable granted here\n+    task::spawn(fn~(move v) {\n+        //!^ ERROR moving out of mutable local variable prohibited due to outstanding loan\n+        #debug[\"v=%d\", *v];\n+    });\n+}\n+\n+fn main() {\n+}"}, {"sha": "4e266b21fbe98e68439080c91f00cf1c190051e2", "filename": "src/test/compile-fail/borrowck-loan-blocks-move.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -0,0 +1,13 @@\n+// compile-flags:--borrowck=err\n+\n+fn take(-_v: ~int) {\n+}\n+\n+fn box_imm() {\n+    let v = ~3;\n+    let _w = &v; //! NOTE loan of immutable local variable granted here\n+    take(v); //! ERROR moving out of immutable local variable prohibited due to outstanding loan\n+}\n+\n+fn main() {\n+}"}, {"sha": "18423c4f20e85b5cf42d3a19b9f584fcf2933dd1", "filename": "src/test/compile-fail/borrowck-loan-blocks-mut-uniq.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -7,7 +7,7 @@ fn borrow(v: &int, f: fn(x: &int)) {\n fn box_imm() {\n     let mut v = ~3;\n     borrow(v) { |w| //! NOTE loan of mutable local variable granted here\n-        v = ~4; //! ERROR cannot assign to mutable local variable due to outstanding loan\n+        v = ~4; //! ERROR assigning to mutable upvar prohibited due to outstanding loan\n         assert *v == 3;\n         assert *w == 4;\n     }", "previous_filename": "src/test/compile-fail/borrowck-hold-box.rs"}, {"sha": "d9436d90f9c6dd2c23ee2071e4ecda55e1ea9302", "filename": "src/test/compile-fail/borrowck-mut-addr-of-imm-var.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-addr-of-imm-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-addr-of-imm-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-addr-of-imm-var.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let x: int = 3;\n+    let y: &mut int = &mut x; //! ERROR taking mut reference to immutable local variable\n+    *y = 5;\n+    log (debug, *y);\n+}"}, {"sha": "a41fa9901e59e39385c8decaebbc8f7f8f4ea198", "filename": "src/test/compile-fail/borrowck-pat-reassign-binding.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-binding.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -7,8 +7,7 @@ fn main() {\n       none {}\n       some(i) {\n         // Not ok: i is an outstanding ptr into x.\n-        x = some(i+1);\n-        //!^ ERROR cannot assign to mutable local variable due to outstanding loan\n+        x = some(i+1); //! ERROR assigning to mutable local variable prohibited due to outstanding loan\n       }\n     }\n }"}, {"sha": "ce41f469597863bbadc7329d85b4df4440d94b72", "filename": "src/test/compile-fail/borrowck-pat-reassign-sometimes-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pat-reassign-sometimes-binding.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -10,7 +10,7 @@ fn main() {\n         x = some(0);\n       }\n       some(i) {\n-        x = some(1); //! ERROR cannot assign to mutable local variable due to outstanding loan\n+        x = some(1); //! ERROR assigning to mutable local variable prohibited due to outstanding loan\n       }\n     }\n }"}, {"sha": "9368b5aae5cc0af088aee2840738c0cb4e90b098", "filename": "src/test/compile-fail/borrowck-uniq-via-lend.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-uniq-via-lend.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -17,9 +17,9 @@ fn local_recs() {\n     borrow(v.f.g.h);\n }\n \n-fn aliased_imm() { // NDM: Spurious\n+fn aliased_imm() {\n     let mut v = ~3;\n-    let _w = &v; //! ERROR illegal borrow: mutability mismatch, required immutable but found mutable\n+    let _w = &v;\n     borrow(v);\n }\n "}, {"sha": "62c8ece0493aa710f3e91abb6fbb5384a04ea8e5", "filename": "src/test/compile-fail/fn-variance-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -20,5 +20,5 @@ fn main() {\n     // mutability check will fail, because the\n     // type of r has been inferred to be\n     // fn(@const int) -> @const int\n-    *r(@mut 3) = 4; //! ERROR assigning to immutable box\n+    *r(@mut 3) = 4; //! ERROR assigning to dereference of const pointer\n }"}, {"sha": "f2ef8c90c3f657290514d573f06a01083426f99d", "filename": "src/test/compile-fail/issue-511.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fissue-511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-511.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -7,4 +7,5 @@ fn f<T>(&o: option<T>) {\n \n fn main() {\n     f::<int>(option::none);\n+    //!^ ERROR taking mut reference to static item\n }\n\\ No newline at end of file", "previous_filename": "src/test/run-pass/issue-511.rs"}, {"sha": "ecc56e6408b107994b7269ea6bfa06748aa51162", "filename": "src/test/compile-fail/lambda-mutate-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:assigning to upvar\n+// error-pattern:assigning to immutable upvar\n // Make sure that nesting a block within a fn@ doesn't let us\n // mutate upvars from a fn@.\n fn f2(x: fn()) { x(); }"}, {"sha": "750faf44c927650eb86b6bf66f70457a836974da", "filename": "src/test/compile-fail/mutable-huh-box-assign.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fmutable-huh-box-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fmutable-huh-box-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-box-assign.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -1,9 +1,6 @@\n-// error-pattern: assigning to immutable box\n-\n fn main() {\n     fn f(&&v: @const int) {\n-        // This shouldn't be possible\n-        *v = 1\n+        *v = 1 //! ERROR assigning to dereference of const pointer\n     }\n \n     let v = @0;"}, {"sha": "e1bf6fe665bb4b14d2a99105cff50a0021784d32", "filename": "src/test/compile-fail/mutable-huh-field-assign.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fmutable-huh-field-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fmutable-huh-field-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-field-assign.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -1,9 +1,7 @@\n-// error-pattern: assigning to immutable field\n-\n fn main() {\n     fn f(&&v: {const field: int}) {\n         // This shouldn't be possible\n-        v.field = 1\n+        v.field = 1 //! ERROR assigning to const field\n     }\n \n     let v = {field: 0};"}, {"sha": "4b249aa8e1dd5c8d7e4df48bd785b88904dd2e04", "filename": "src/test/compile-fail/mutable-huh-ptr-assign.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -1,11 +1,8 @@\n-// error-pattern: assigning to immutable box\n-\n use std;\n \n fn main() {\n     unsafe fn f(&&v: *const int) {\n-        // This shouldn't be possible\n-        *v = 1\n+        *v = 1 //! ERROR assigning to dereference of const pointer\n     }\n \n     unsafe {"}, {"sha": "6a16c1cf250a49b688826948113557ee021415fb", "filename": "src/test/compile-fail/mutable-huh-unique-assign.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fmutable-huh-unique-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fmutable-huh-unique-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-unique-assign.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -1,9 +1,6 @@\n-// error-pattern: assigning to immutable box\n-\n fn main() {\n     fn f(&&v: ~const int) {\n-        // This shouldn't be possible\n-        *v = 1\n+        *v = 1 //! ERROR assigning to dereference of const pointer\n     }\n \n     let v = ~0;"}, {"sha": "0f2845a8bd06999f24d7bf5762c26a726825f642", "filename": "src/test/compile-fail/mutable-huh-vec-assign.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fmutable-huh-vec-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fmutable-huh-vec-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-vec-assign.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -1,9 +1,7 @@\n-// error-pattern: assigning to immutable vec content\n-\n fn main() {\n     fn f(&&v: [const int]) {\n         // This shouldn't be possible\n-        v[0] = 1\n+        v[0] = 1 //! ERROR assigning to const vec content\n     }\n \n     let v = [0];"}, {"sha": "8366aa5421e6a2082f92a5e7b54a374eeb0a44df", "filename": "src/test/compile-fail/swap-no-lval.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fswap-no-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Fcompile-fail%2Fswap-no-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fswap-no-lval.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -1,3 +1,5 @@\n-// error-pattern: assigning to non-lvalue\n-\n-fn main() { 5 <-> 3; }\n+fn main() {\n+    5 <-> 3;\n+    //!^ ERROR swapping to and from non-lvalue\n+    //!^^ ERROR swapping to and from non-lvalue\n+}"}, {"sha": "21664bb720d431c7cb657ba2651b0405ccbd7801", "filename": "src/test/run-pass/regions-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Frun-pass%2Fregions-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d1f1b2c11db370a2ef82646a4fdc091699e7b6/src%2Ftest%2Frun-pass%2Fregions-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-simple.rs?ref=b4d1f1b2c11db370a2ef82646a4fdc091699e7b6", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    let x: int = 3;\n+    let mut x: int = 3;\n     let y: &mut int = &mut x;\n     *y = 5;\n     log (debug, *y);"}]}