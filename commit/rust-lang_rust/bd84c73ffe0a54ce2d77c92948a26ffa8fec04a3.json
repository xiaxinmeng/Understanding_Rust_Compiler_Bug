{"sha": "bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3", "node_id": "C_kwDOAAsO6NoAKGJkODRjNzNmZmUwYTU0Y2UyZDc3YzkyOTQ4YTI2ZmZhOGZlYzA0YTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-30T04:05:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-30T04:05:28Z"}, "message": "Auto merge of #99123 - mystor:crossbeam_bridge, r=eddyb\n\nproc_macro: use crossbeam channels for the proc_macro cross-thread bridge\n\nThis is done by having the crossbeam dependency inserted into the `proc_macro` server code from the server side, to avoid adding a dependency to `proc_macro`.\n\nIn addition, this introduces a -Z command-line option which will switch rustc to run proc-macros using this cross-thread executor. With the changes to the bridge in #98186, #98187, #98188 and #98189, the performance of the executor should be much closer to same-thread execution.\n\nIn local testing, the crossbeam executor was substantially more performant than either of the two existing `CrossThread` strategies, so they have been removed to keep things simple.\n\nr? `@eddyb`", "tree": {"sha": "919e97a62fd366d81a3ed0e0051e89d7519f246d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/919e97a62fd366d81a3ed0e0051e89d7519f246d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3", "html_url": "https://github.com/rust-lang/rust/commit/bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f68c43ca6a6381a4d73f887f112e9fb95769905", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f68c43ca6a6381a4d73f887f112e9fb95769905", "html_url": "https://github.com/rust-lang/rust/commit/8f68c43ca6a6381a4d73f887f112e9fb95769905"}, {"sha": "6d1650fe45e675cd976a5401067606de325d8ae8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d1650fe45e675cd976a5401067606de325d8ae8", "html_url": "https://github.com/rust-lang/rust/commit/6d1650fe45e675cd976a5401067606de325d8ae8"}], "stats": {"total": 213, "additions": 133, "deletions": 80}, "files": [{"sha": "90f4516a0693a1c40369cb0f07f1a802f79fc577", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3", "patch": "@@ -3885,6 +3885,7 @@ dependencies = [\n name = \"rustc_expand\"\n version = \"0.0.0\"\n dependencies = [\n+ \"crossbeam-channel\",\n  \"rustc_ast\",\n  \"rustc_ast_passes\",\n  \"rustc_ast_pretty\","}, {"sha": "4ee7b6c42bbf5015e912de73beb059df4ece742b", "filename": "compiler/rustc_expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3/compiler%2Frustc_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3/compiler%2Frustc_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2FCargo.toml?ref=bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3", "patch": "@@ -24,3 +24,4 @@ rustc_parse = { path = \"../rustc_parse\" }\n rustc_session = { path = \"../rustc_session\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n rustc_ast = { path = \"../rustc_ast\" }\n+crossbeam-channel = \"0.5.0\""}, {"sha": "1b1078a67eec068508f4f19736875f9ab71969e7", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3", "patch": "@@ -8,10 +8,37 @@ use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::ErrorGuaranteed;\n use rustc_parse::parser::ForceCollect;\n+use rustc_session::config::ProcMacroExecutionStrategy;\n use rustc_span::profiling::SpannedEventArgRecorder;\n use rustc_span::{Span, DUMMY_SP};\n \n-const EXEC_STRATEGY: pm::bridge::server::SameThread = pm::bridge::server::SameThread;\n+struct CrossbeamMessagePipe<T> {\n+    tx: crossbeam_channel::Sender<T>,\n+    rx: crossbeam_channel::Receiver<T>,\n+}\n+\n+impl<T> pm::bridge::server::MessagePipe<T> for CrossbeamMessagePipe<T> {\n+    fn new() -> (Self, Self) {\n+        let (tx1, rx1) = crossbeam_channel::bounded(1);\n+        let (tx2, rx2) = crossbeam_channel::bounded(1);\n+        (CrossbeamMessagePipe { tx: tx1, rx: rx2 }, CrossbeamMessagePipe { tx: tx2, rx: rx1 })\n+    }\n+\n+    fn send(&mut self, value: T) {\n+        self.tx.send(value).unwrap();\n+    }\n+\n+    fn recv(&mut self) -> Option<T> {\n+        self.rx.recv().ok()\n+    }\n+}\n+\n+fn exec_strategy(ecx: &ExtCtxt<'_>) -> impl pm::bridge::server::ExecutionStrategy {\n+    pm::bridge::server::MaybeCrossThread::<CrossbeamMessagePipe<_>>::new(\n+        ecx.sess.opts.unstable_opts.proc_macro_execution_strategy\n+            == ProcMacroExecutionStrategy::CrossThread,\n+    )\n+}\n \n pub struct BangProcMacro {\n     pub client: pm::bridge::client::Client<pm::TokenStream, pm::TokenStream>,\n@@ -30,8 +57,9 @@ impl base::BangProcMacro for BangProcMacro {\n             });\n \n         let proc_macro_backtrace = ecx.ecfg.proc_macro_backtrace;\n+        let strategy = exec_strategy(ecx);\n         let server = proc_macro_server::Rustc::new(ecx);\n-        self.client.run(&EXEC_STRATEGY, server, input, proc_macro_backtrace).map_err(|e| {\n+        self.client.run(&strategy, server, input, proc_macro_backtrace).map_err(|e| {\n             let mut err = ecx.struct_span_err(span, \"proc macro panicked\");\n             if let Some(s) = e.as_str() {\n                 err.help(&format!(\"message: {}\", s));\n@@ -59,16 +87,17 @@ impl base::AttrProcMacro for AttrProcMacro {\n             });\n \n         let proc_macro_backtrace = ecx.ecfg.proc_macro_backtrace;\n+        let strategy = exec_strategy(ecx);\n         let server = proc_macro_server::Rustc::new(ecx);\n-        self.client\n-            .run(&EXEC_STRATEGY, server, annotation, annotated, proc_macro_backtrace)\n-            .map_err(|e| {\n+        self.client.run(&strategy, server, annotation, annotated, proc_macro_backtrace).map_err(\n+            |e| {\n                 let mut err = ecx.struct_span_err(span, \"custom attribute panicked\");\n                 if let Some(s) = e.as_str() {\n                     err.help(&format!(\"message: {}\", s));\n                 }\n                 err.emit()\n-            })\n+            },\n+        )\n     }\n }\n \n@@ -105,8 +134,9 @@ impl MultiItemModifier for DeriveProcMacro {\n                     recorder.record_arg_with_span(ecx.expansion_descr(), span);\n                 });\n             let proc_macro_backtrace = ecx.ecfg.proc_macro_backtrace;\n+            let strategy = exec_strategy(ecx);\n             let server = proc_macro_server::Rustc::new(ecx);\n-            match self.client.run(&EXEC_STRATEGY, server, input, proc_macro_backtrace) {\n+            match self.client.run(&strategy, server, input, proc_macro_backtrace) {\n                 Ok(stream) => stream,\n                 Err(e) => {\n                     let mut err = ecx.struct_span_err(span, \"proc-macro derive panicked\");"}, {"sha": "a9fdfa241416812eb2cac218a211cd0d05739499", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3", "patch": "@@ -11,7 +11,7 @@ use rustc_session::config::{\n };\n use rustc_session::config::{\n     BranchProtection, Externs, OomStrategy, OutputType, OutputTypes, PAuthKey, PacRet,\n-    SymbolManglingVersion, WasiExecModel,\n+    ProcMacroExecutionStrategy, SymbolManglingVersion, WasiExecModel,\n };\n use rustc_session::config::{CFGuard, ExternEntry, LinkerPluginLto, LtoCli, SwitchWithOptPath};\n use rustc_session::lint::Level;\n@@ -685,6 +685,7 @@ fn test_unstable_options_tracking_hash() {\n     untracked!(print_mono_items, Some(String::from(\"abc\")));\n     untracked!(print_type_sizes, true);\n     untracked!(proc_macro_backtrace, true);\n+    untracked!(proc_macro_execution_strategy, ProcMacroExecutionStrategy::CrossThread);\n     untracked!(query_dep_graph, true);\n     untracked!(save_analysis, true);\n     untracked!(self_profile, SwitchWithOptPath::Enabled(None));"}, {"sha": "70f942a65089a8ba3af99d5227c57a566fd1951e", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3", "patch": "@@ -2972,3 +2972,13 @@ impl OomStrategy {\n         }\n     }\n }\n+\n+/// How to run proc-macro code when building this crate\n+#[derive(Clone, Copy, PartialEq, Hash, Debug)]\n+pub enum ProcMacroExecutionStrategy {\n+    /// Run the proc-macro code on the same thread as the server.\n+    SameThread,\n+\n+    /// Run the proc-macro code on a different thread.\n+    CrossThread,\n+}"}, {"sha": "6495339eaf19c1adef0ea7e5094b359cf29fa4f1", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3", "patch": "@@ -415,6 +415,8 @@ mod desc {\n         \"one of (`none` (default), `basic`, `strong`, or `all`)\";\n     pub const parse_branch_protection: &str =\n         \"a `,` separated combination of `bti`, `b-key`, `pac-ret`, or `leaf`\";\n+    pub const parse_proc_macro_execution_strategy: &str =\n+        \"one of supported execution strategies (`same-thread`, or `cross-thread`)\";\n }\n \n mod parse {\n@@ -1062,6 +1064,18 @@ mod parse {\n         }\n         true\n     }\n+\n+    pub(crate) fn parse_proc_macro_execution_strategy(\n+        slot: &mut ProcMacroExecutionStrategy,\n+        v: Option<&str>,\n+    ) -> bool {\n+        *slot = match v {\n+            Some(\"same-thread\") => ProcMacroExecutionStrategy::SameThread,\n+            Some(\"cross-thread\") => ProcMacroExecutionStrategy::CrossThread,\n+            _ => return false,\n+        };\n+        true\n+    }\n }\n \n options! {\n@@ -1457,6 +1471,9 @@ options! {\n         \"print layout information for each type encountered (default: no)\"),\n     proc_macro_backtrace: bool = (false, parse_bool, [UNTRACKED],\n          \"show backtraces for panics during proc-macro execution (default: no)\"),\n+    proc_macro_execution_strategy: ProcMacroExecutionStrategy = (ProcMacroExecutionStrategy::SameThread,\n+        parse_proc_macro_execution_strategy, [UNTRACKED],\n+        \"how to run proc-macro code (default: same-thread)\"),\n     profile: bool = (false, parse_bool, [TRACKED],\n         \"insert profiling code (default: no)\"),\n     profile_closures: bool = (false, parse_no_flag, [UNTRACKED],"}, {"sha": "e068ec60b6af0d654c07db30bf06d39e5fe53173", "filename": "library/proc_macro/src/bridge/server.rs", "status": "modified", "additions": 64, "deletions": 72, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs?ref=bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3", "patch": "@@ -2,6 +2,8 @@\n \n use super::*;\n \n+use std::marker::PhantomData;\n+\n // FIXME(eddyb) generate the definition of `HandleStore` in `server.rs`.\n use super::client::HandleStore;\n \n@@ -143,6 +145,41 @@ pub trait ExecutionStrategy {\n     ) -> Buffer;\n }\n \n+pub struct MaybeCrossThread<P> {\n+    cross_thread: bool,\n+    marker: PhantomData<P>,\n+}\n+\n+impl<P> MaybeCrossThread<P> {\n+    pub const fn new(cross_thread: bool) -> Self {\n+        MaybeCrossThread { cross_thread, marker: PhantomData }\n+    }\n+}\n+\n+impl<P> ExecutionStrategy for MaybeCrossThread<P>\n+where\n+    P: MessagePipe<Buffer> + Send + 'static,\n+{\n+    fn run_bridge_and_client(\n+        &self,\n+        dispatcher: &mut impl DispatcherTrait,\n+        input: Buffer,\n+        run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n+        force_show_panics: bool,\n+    ) -> Buffer {\n+        if self.cross_thread {\n+            <CrossThread<P>>::new().run_bridge_and_client(\n+                dispatcher,\n+                input,\n+                run_client,\n+                force_show_panics,\n+            )\n+        } else {\n+            SameThread.run_bridge_and_client(dispatcher, input, run_client, force_show_panics)\n+        }\n+    }\n+}\n+\n pub struct SameThread;\n \n impl ExecutionStrategy for SameThread {\n@@ -164,28 +201,31 @@ impl ExecutionStrategy for SameThread {\n     }\n }\n \n-// NOTE(eddyb) Two implementations are provided, the second one is a bit\n-// faster but neither is anywhere near as fast as same-thread execution.\n+pub struct CrossThread<P>(PhantomData<P>);\n \n-pub struct CrossThread1;\n+impl<P> CrossThread<P> {\n+    pub const fn new() -> Self {\n+        CrossThread(PhantomData)\n+    }\n+}\n \n-impl ExecutionStrategy for CrossThread1 {\n+impl<P> ExecutionStrategy for CrossThread<P>\n+where\n+    P: MessagePipe<Buffer> + Send + 'static,\n+{\n     fn run_bridge_and_client(\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n         input: Buffer,\n         run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n         force_show_panics: bool,\n     ) -> Buffer {\n-        use std::sync::mpsc::channel;\n-\n-        let (req_tx, req_rx) = channel();\n-        let (res_tx, res_rx) = channel();\n+        let (mut server, mut client) = P::new();\n \n         let join_handle = thread::spawn(move || {\n-            let mut dispatch = |buf| {\n-                req_tx.send(buf).unwrap();\n-                res_rx.recv().unwrap()\n+            let mut dispatch = |b: Buffer| -> Buffer {\n+                client.send(b);\n+                client.recv().expect(\"server died while client waiting for reply\")\n             };\n \n             run_client(BridgeConfig {\n@@ -196,75 +236,27 @@ impl ExecutionStrategy for CrossThread1 {\n             })\n         });\n \n-        for b in req_rx {\n-            res_tx.send(dispatcher.dispatch(b)).unwrap();\n+        while let Some(b) = server.recv() {\n+            server.send(dispatcher.dispatch(b));\n         }\n \n         join_handle.join().unwrap()\n     }\n }\n \n-pub struct CrossThread2;\n+/// A message pipe used for communicating between server and client threads.\n+pub trait MessagePipe<T>: Sized {\n+    /// Create a new pair of endpoints for the message pipe.\n+    fn new() -> (Self, Self);\n \n-impl ExecutionStrategy for CrossThread2 {\n-    fn run_bridge_and_client(\n-        &self,\n-        dispatcher: &mut impl DispatcherTrait,\n-        input: Buffer,\n-        run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n-        force_show_panics: bool,\n-    ) -> Buffer {\n-        use std::sync::{Arc, Mutex};\n-\n-        enum State<T> {\n-            Req(T),\n-            Res(T),\n-        }\n-\n-        let mut state = Arc::new(Mutex::new(State::Res(Buffer::new())));\n-\n-        let server_thread = thread::current();\n-        let state2 = state.clone();\n-        let join_handle = thread::spawn(move || {\n-            let mut dispatch = |b| {\n-                *state2.lock().unwrap() = State::Req(b);\n-                server_thread.unpark();\n-                loop {\n-                    thread::park();\n-                    if let State::Res(b) = &mut *state2.lock().unwrap() {\n-                        break b.take();\n-                    }\n-                }\n-            };\n-\n-            let r = run_client(BridgeConfig {\n-                input,\n-                dispatch: (&mut dispatch).into(),\n-                force_show_panics,\n-                _marker: marker::PhantomData,\n-            });\n-\n-            // Wake up the server so it can exit the dispatch loop.\n-            drop(state2);\n-            server_thread.unpark();\n-\n-            r\n-        });\n-\n-        // Check whether `state2` was dropped, to know when to stop.\n-        while Arc::get_mut(&mut state).is_none() {\n-            thread::park();\n-            let mut b = match &mut *state.lock().unwrap() {\n-                State::Req(b) => b.take(),\n-                _ => continue,\n-            };\n-            b = dispatcher.dispatch(b.take());\n-            *state.lock().unwrap() = State::Res(b);\n-            join_handle.thread().unpark();\n-        }\n+    /// Send a message to the other endpoint of this pipe.\n+    fn send(&mut self, value: T);\n \n-        join_handle.join().unwrap()\n-    }\n+    /// Receive a message from the other endpoint of this pipe.\n+    ///\n+    /// Returns `None` if the other end of the pipe has been destroyed, and no\n+    /// message was received.\n+    fn recv(&mut self) -> Option<T>;\n }\n \n fn run_server<"}, {"sha": "c8e5cac059412c6c26298f7fd3c19776c0c67d07", "filename": "src/test/rustdoc-ui/z-help.stdout", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout?ref=bd84c73ffe0a54ce2d77c92948a26ffa8fec04a3", "patch": "@@ -114,6 +114,7 @@\n     -Z                        print-mono-items=val -- print the result of the monomorphization collection pass\n     -Z                        print-type-sizes=val -- print layout information for each type encountered (default: no)\n     -Z                    proc-macro-backtrace=val -- show backtraces for panics during proc-macro execution (default: no)\n+    -Z           proc-macro-execution-strategy=val -- how to run proc-macro code (default: same-thread)\n     -Z                                 profile=val -- insert profiling code (default: no)\n     -Z                        profile-closures=val -- profile size of closures\n     -Z                            profile-emit=val -- file path to emit profiling data at runtime when using 'profile' (default based on relative source path)"}]}