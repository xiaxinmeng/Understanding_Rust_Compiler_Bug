{"sha": "7e0c6dba0d83dbee96bbf7eac7b4cb563e297a5f", "node_id": "C_kwDOAAsO6NoAKDdlMGM2ZGJhMGQ4M2RiZWU5NmJiZjdlYWM3YjRjYjU2M2UyOTdhNWY", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-12-05T05:09:45Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-12-05T05:33:24Z"}, "message": "Remove `LitKind::synthesize_token_lit`.\n\nIt has a single call site in the HIR pretty printer, where the resulting\ntoken lit is immediately converted to a string.\n\nThis commit replaces `LitKind::synthesize_token_lit` with a `Display`\nimpl for `LitKind`, which can be used by the HIR pretty printer.", "tree": {"sha": "515d2bb20a4bba33579955c60fba264f7b03e9d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/515d2bb20a4bba33579955c60fba264f7b03e9d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e0c6dba0d83dbee96bbf7eac7b4cb563e297a5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e0c6dba0d83dbee96bbf7eac7b4cb563e297a5f", "html_url": "https://github.com/rust-lang/rust/commit/7e0c6dba0d83dbee96bbf7eac7b4cb563e297a5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e0c6dba0d83dbee96bbf7eac7b4cb563e297a5f/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "568e647047e2a3b817a3f39d2ecb25989a4981ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/568e647047e2a3b817a3f39d2ecb25989a4981ce", "html_url": "https://github.com/rust-lang/rust/commit/568e647047e2a3b817a3f39d2ecb25989a4981ce"}], "stats": {"total": 85, "additions": 45, "deletions": 40}, "files": [{"sha": "762fd00e409fb83f544aba8036ce9afb2087e7a0", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 44, "deletions": 39, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/7e0c6dba0d83dbee96bbf7eac7b4cb563e297a5f/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0c6dba0d83dbee96bbf7eac7b4cb563e297a5f/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=7e0c6dba0d83dbee96bbf7eac7b4cb563e297a5f", "patch": "@@ -5,8 +5,7 @@ use crate::token::{self, Token};\n use rustc_lexer::unescape::{byte_from_char, unescape_byte, unescape_char, unescape_literal, Mode};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n-use std::ascii;\n-use std::str;\n+use std::{ascii, fmt, str};\n \n // Escapes a string, represented as a symbol. Reuses the original symbol,\n // avoiding interning, if no changes are required.\n@@ -162,54 +161,60 @@ impl LitKind {\n             token::Err => LitKind::Err,\n         })\n     }\n+}\n \n-    /// Synthesizes a token from a semantic literal.\n-    /// This function is used when the original token doesn't exist (e.g. the literal is created\n-    /// by an AST-based macro) or unavailable (e.g. from HIR pretty-printing).\n-    pub fn synthesize_token_lit(&self) -> token::Lit {\n-        let (kind, symbol, suffix) = match *self {\n-            LitKind::Str(symbol, ast::StrStyle::Cooked) => {\n-                (token::Str, escape_string_symbol(symbol), None)\n+impl fmt::Display for LitKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            LitKind::Byte(b) => {\n+                let b: String = ascii::escape_default(b).map(Into::<char>::into).collect();\n+                write!(f, \"b'{}'\", b)?;\n             }\n-            LitKind::Str(symbol, ast::StrStyle::Raw(n)) => (token::StrRaw(n), symbol, None),\n-            LitKind::ByteStr(ref bytes, ast::StrStyle::Cooked) => {\n-                (token::ByteStr, escape_byte_str_symbol(bytes), None)\n+            LitKind::Char(ch) => write!(f, \"'{}'\", escape_char_symbol(ch))?,\n+            LitKind::Str(sym, StrStyle::Cooked) => write!(f, \"\\\"{}\\\"\", escape_string_symbol(sym))?,\n+            LitKind::Str(sym, StrStyle::Raw(n)) => write!(\n+                f,\n+                \"r{delim}\\\"{string}\\\"{delim}\",\n+                delim = \"#\".repeat(n as usize),\n+                string = sym\n+            )?,\n+            LitKind::ByteStr(ref bytes, StrStyle::Cooked) => {\n+                write!(f, \"b\\\"{}\\\"\", escape_byte_str_symbol(bytes))?\n             }\n-            LitKind::ByteStr(ref bytes, ast::StrStyle::Raw(n)) => {\n+            LitKind::ByteStr(ref bytes, StrStyle::Raw(n)) => {\n                 // Unwrap because raw byte string literals can only contain ASCII.\n-                let string = str::from_utf8(bytes).unwrap();\n-                (token::ByteStrRaw(n), Symbol::intern(&string), None)\n-            }\n-            LitKind::Byte(byte) => {\n-                let string: String = ascii::escape_default(byte).map(Into::<char>::into).collect();\n-                (token::Byte, Symbol::intern(&string), None)\n+                let symbol = str::from_utf8(bytes).unwrap();\n+                write!(\n+                    f,\n+                    \"br{delim}\\\"{string}\\\"{delim}\",\n+                    delim = \"#\".repeat(n as usize),\n+                    string = symbol\n+                )?;\n             }\n-            LitKind::Char(ch) => (token::Char, escape_char_symbol(ch), None),\n             LitKind::Int(n, ty) => {\n-                let suffix = match ty {\n-                    ast::LitIntType::Unsigned(ty) => Some(ty.name()),\n-                    ast::LitIntType::Signed(ty) => Some(ty.name()),\n-                    ast::LitIntType::Unsuffixed => None,\n-                };\n-                (token::Integer, sym::integer(n), suffix)\n+                write!(f, \"{}\", n)?;\n+                match ty {\n+                    ast::LitIntType::Unsigned(ty) => write!(f, \"{}\", ty.name())?,\n+                    ast::LitIntType::Signed(ty) => write!(f, \"{}\", ty.name())?,\n+                    ast::LitIntType::Unsuffixed => {}\n+                }\n             }\n             LitKind::Float(symbol, ty) => {\n-                let suffix = match ty {\n-                    ast::LitFloatType::Suffixed(ty) => Some(ty.name()),\n-                    ast::LitFloatType::Unsuffixed => None,\n-                };\n-                (token::Float, symbol, suffix)\n+                write!(f, \"{}\", symbol)?;\n+                match ty {\n+                    ast::LitFloatType::Suffixed(ty) => write!(f, \"{}\", ty.name())?,\n+                    ast::LitFloatType::Unsuffixed => {}\n+                }\n             }\n-            LitKind::Bool(value) => {\n-                let symbol = if value { kw::True } else { kw::False };\n-                (token::Bool, symbol, None)\n+            LitKind::Bool(b) => write!(f, \"{}\", if b { \"true\" } else { \"false\" })?,\n+            LitKind::Err => {\n+                // This only shows up in places like `-Zunpretty=hir` output, so we\n+                // don't bother to produce something useful.\n+                write!(f, \"<bad-literal>\")?;\n             }\n-            // This only shows up in places like `-Zunpretty=hir` output, so we\n-            // don't bother to produce something useful.\n-            LitKind::Err => (token::Err, Symbol::intern(\"<bad-literal>\"), None),\n-        };\n+        }\n \n-        token::Lit::new(kind, symbol, suffix)\n+        Ok(())\n     }\n }\n "}, {"sha": "81d933b8e7f0f21a458ab7194d7f7a8d6e60366f", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e0c6dba0d83dbee96bbf7eac7b4cb563e297a5f/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e0c6dba0d83dbee96bbf7eac7b4cb563e297a5f/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=7e0c6dba0d83dbee96bbf7eac7b4cb563e297a5f", "patch": "@@ -1256,7 +1256,7 @@ impl<'a> State<'a> {\n \n     fn print_literal(&mut self, lit: &hir::Lit) {\n         self.maybe_print_comment(lit.span.lo());\n-        self.word(lit.node.synthesize_token_lit().to_string())\n+        self.word(lit.node.to_string())\n     }\n \n     fn print_inline_asm(&mut self, asm: &hir::InlineAsm<'_>) {"}]}