{"sha": "62db786fc82cff397bbb031cfb03fab34b5043a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyZGI3ODZmYzgyY2ZmMzk3YmJiMDMxY2ZiMDNmYWIzNGI1MDQzYTU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2016-05-01T14:19:11Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-05-03T15:52:55Z"}, "message": "stop using commit_if_ok where no errors can happen", "tree": {"sha": "d4724d15c2b2f4cd28d06e5c8a69132b9f44076c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4724d15c2b2f4cd28d06e5c8a69132b9f44076c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62db786fc82cff397bbb031cfb03fab34b5043a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62db786fc82cff397bbb031cfb03fab34b5043a5", "html_url": "https://github.com/rust-lang/rust/commit/62db786fc82cff397bbb031cfb03fab34b5043a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62db786fc82cff397bbb031cfb03fab34b5043a5/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6057a7f18827f065668fcf22cfc0242de8f694b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6057a7f18827f065668fcf22cfc0242de8f694b9", "html_url": "https://github.com/rust-lang/rust/commit/6057a7f18827f065668fcf22cfc0242de8f694b9"}], "stats": {"total": 94, "additions": 42, "deletions": 52}, "files": [{"sha": "6da4c44fe9ad11c1dea4a1c95754b004ee59a936", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/62db786fc82cff397bbb031cfb03fab34b5043a5/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62db786fc82cff397bbb031cfb03fab34b5043a5/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=62db786fc82cff397bbb031cfb03fab34b5043a5", "patch": "@@ -814,6 +814,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         r\n     }\n \n+    // Execute `f` in a snapshot, and commit the bindings it creates\n+    pub fn in_snapshot<T, F>(&self, f: F) -> T where\n+        F: FnOnce(&CombinedSnapshot) -> T\n+    {\n+        debug!(\"in_snapshot()\");\n+        let snapshot = self.start_snapshot();\n+        let r = f(&snapshot);\n+        self.commit_from(snapshot);\n+        r\n+    }\n+\n     /// Execute `f` and commit only the region bindings if successful.\n     /// The function f must be very careful not to leak any non-region\n     /// variables that get created."}, {"sha": "8a6582e8420c087d837fc0a91ce6ac1e47db61d5", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 31, "deletions": 52, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/62db786fc82cff397bbb031cfb03fab34b5043a5/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62db786fc82cff397bbb031cfb03fab34b5043a5/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=62db786fc82cff397bbb031cfb03fab34b5043a5", "patch": "@@ -49,7 +49,6 @@ use std::fmt;\n use std::rc::Rc;\n use syntax::abi::Abi;\n use hir;\n-use util::common::ErrorReported;\n use util::nodemap::FnvHashMap;\n \n pub struct SelectionContext<'cx, 'tcx:'cx> {\n@@ -1402,7 +1401,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return;\n         }\n \n-        self.infcx.commit_if_ok(|snapshot| {\n+        self.infcx.in_snapshot(|snapshot| {\n             let (self_ty, _) =\n                 self.infcx().skolemize_late_bound_regions(&obligation.self_ty(), snapshot);\n             let poly_trait_ref = match self_ty.sty {\n@@ -1413,7 +1412,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                 debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n                                         pushing candidate\");\n                                 candidates.vec.push(BuiltinObjectCandidate);\n-                                return Ok(());\n+                                return;\n                             }\n                         }\n                         _ => {}\n@@ -1424,10 +1423,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ty::TyInfer(ty::TyVar(_)) => {\n                     debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n                     candidates.ambiguous = true; // could wind up being an object type\n-                    return Ok(());\n+                    return;\n                 }\n                 _ => {\n-                    return Ok(());\n+                    return;\n                 }\n             };\n \n@@ -1455,9 +1454,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             } else if upcast_trait_refs == 1 {\n                 candidates.vec.push(ObjectCandidate);\n             }\n-\n-            Ok::<(),()>(())\n-        }).unwrap();\n+        })\n     }\n \n     /// Search for unsizing that might apply to `obligation`.\n@@ -1854,21 +1851,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // 2. Produce something like `&'0 int : Copy`\n         // 3. Re-bind the regions back to `for<'a> &'a int : Copy`\n \n-        // Move the binder into the individual types\n-        let bound_types: Vec<ty::Binder<Ty<'tcx>>> =\n-            types.skip_binder()\n-                 .iter()\n-                 .map(|&nested_ty| ty::Binder(nested_ty))\n-                 .collect();\n+        types.skip_binder().into_iter().flat_map(|ty| { // binder moved -\\\n+            let ty: ty::Binder<Ty<'tcx>> = ty::Binder(ty); // <----------/\n \n-        // For each type, produce a vector of resulting obligations\n-        let obligations: Result<Vec<Vec<_>>, _> = bound_types.iter().map(|nested_ty| {\n-            self.infcx.commit_if_ok(|snapshot| {\n+            self.infcx.in_snapshot(|snapshot| {\n                 let (skol_ty, skol_map) =\n-                    self.infcx().skolemize_late_bound_regions(nested_ty, snapshot);\n+                    self.infcx().skolemize_late_bound_regions(&ty, snapshot);\n                 let Normalized { value: normalized_ty, mut obligations } =\n                     project::normalize_with_depth(self,\n-                                                  obligation.cause.clone(),\n+                                                  derived_cause.clone(),\n                                                   obligation.recursion_depth + 1,\n                                                   &skol_ty);\n                 let skol_obligation =\n@@ -1879,15 +1870,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                   normalized_ty,\n                                                   vec![]);\n                 obligations.push(skol_obligation);\n-                Ok(self.infcx().plug_leaks(skol_map, snapshot, &obligations))\n+                self.infcx().plug_leaks(skol_map, snapshot, &obligations)\n             })\n-        }).collect();\n-\n-        // Flatten those vectors (couldn't do it above due `collect`)\n-        match obligations {\n-            Ok(obligations) => obligations.into_iter().flat_map(|o| o).collect(),\n-            Err(ErrorReported) => Vec::new(),\n-        }\n+        }).collect()\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -1928,9 +1913,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ImplCandidate(impl_def_id) => {\n-                let vtable_impl =\n-                    self.confirm_impl_candidate(obligation, impl_def_id)?;\n-                Ok(VtableImpl(vtable_impl))\n+                Ok(VtableImpl(self.confirm_impl_candidate(obligation, impl_def_id)))\n             }\n \n             ClosureCandidate(closure_def_id, substs, kind) => {\n@@ -1974,14 +1957,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_projection_candidate(&mut self,\n                                     obligation: &TraitObligation<'tcx>)\n     {\n-        let _: Result<(),()> =\n-            self.infcx.commit_if_ok(|snapshot| {\n-                let result =\n-                    self.match_projection_obligation_against_bounds_from_trait(obligation,\n-                                                                               snapshot);\n-                assert!(result);\n-                Ok(())\n-            });\n+        self.infcx.in_snapshot(|snapshot| {\n+            let result =\n+                self.match_projection_obligation_against_bounds_from_trait(obligation,\n+                                                                           snapshot);\n+            assert!(result);\n+        })\n     }\n \n     fn confirm_param_candidate(&mut self,\n@@ -2112,20 +2093,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                                 trait_def_id,\n                                                                 nested);\n \n-        let trait_obligations: Result<Vec<_>,()> = self.infcx.commit_if_ok(|snapshot| {\n+        let trait_obligations = self.infcx.in_snapshot(|snapshot| {\n             let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n             let (trait_ref, skol_map) =\n                 self.infcx().skolemize_late_bound_regions(&poly_trait_ref, snapshot);\n-            Ok(self.impl_or_trait_obligations(obligation.cause.clone(),\n-                                              obligation.recursion_depth + 1,\n-                                              trait_def_id,\n-                                              &trait_ref.substs,\n-                                              skol_map,\n-                                              snapshot))\n+            self.impl_or_trait_obligations(obligation.cause.clone(),\n+                                           obligation.recursion_depth + 1,\n+                                           trait_def_id,\n+                                           &trait_ref.substs,\n+                                           skol_map,\n+                                           snapshot)\n         });\n \n-        // no Errors in that code above\n-        obligations.append(&mut trait_obligations.unwrap());\n+        obligations.extend(trait_obligations);\n \n         debug!(\"vtable_default_impl_data: obligations={:?}\", obligations);\n \n@@ -2138,22 +2118,21 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_impl_candidate(&mut self,\n                               obligation: &TraitObligation<'tcx>,\n                               impl_def_id: DefId)\n-                              -> Result<VtableImplData<'tcx, PredicateObligation<'tcx>>,\n-                                        SelectionError<'tcx>>\n+                              -> VtableImplData<'tcx, PredicateObligation<'tcx>>\n     {\n         debug!(\"confirm_impl_candidate({:?},{:?})\",\n                obligation,\n                impl_def_id);\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n-        self.infcx.commit_if_ok(|snapshot| {\n+        self.infcx.in_snapshot(|snapshot| {\n             let (substs, skol_map) =\n                 self.rematch_impl(impl_def_id, obligation,\n                                   snapshot);\n             debug!(\"confirm_impl_candidate substs={:?}\", substs);\n-            Ok(self.vtable_impl(impl_def_id, substs, obligation.cause.clone(),\n-                                obligation.recursion_depth + 1, skol_map, snapshot))\n+            self.vtable_impl(impl_def_id, substs, obligation.cause.clone(),\n+                             obligation.recursion_depth + 1, skol_map, snapshot)\n         })\n     }\n "}]}