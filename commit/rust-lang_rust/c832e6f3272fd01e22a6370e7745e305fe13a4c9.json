{"sha": "c832e6f3272fd01e22a6370e7745e305fe13a4c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4MzJlNmYzMjcyZmQwMWUyMmE2MzcwZTc3NDVlMzA1ZmUxM2E0Yzk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-19T12:46:29Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-25T16:35:26Z"}, "message": "rustc_typeck: rework coherence to be almost completely on-demand.", "tree": {"sha": "c26d1acd868b805dbddb49259a70ff1e2b9d3548", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c26d1acd868b805dbddb49259a70ff1e2b9d3548"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c832e6f3272fd01e22a6370e7745e305fe13a4c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c832e6f3272fd01e22a6370e7745e305fe13a4c9", "html_url": "https://github.com/rust-lang/rust/commit/c832e6f3272fd01e22a6370e7745e305fe13a4c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c832e6f3272fd01e22a6370e7745e305fe13a4c9/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9890e0466d951d1b0020ae38e2a4c0d8c43cfea1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1", "html_url": "https://github.com/rust-lang/rust/commit/9890e0466d951d1b0020ae38e2a4c0d8c43cfea1"}], "stats": {"total": 1494, "additions": 824, "deletions": 670}, "files": [{"sha": "e0233d6f8b98cd1bf818a8766f58da2781a6919c", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -70,6 +70,7 @@ pub enum DepNode<D: Clone + Debug> {\n     Resolve,\n     EntryPoint,\n     CheckEntryFn,\n+    CoherenceCheckTrait(D),\n     CoherenceCheckImpl(D),\n     CoherenceOverlapCheck(D),\n     CoherenceOverlapCheckSpecial(D),\n@@ -241,6 +242,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             MetaData(ref d) => op(d).map(MetaData),\n             CollectItem(ref d) => op(d).map(CollectItem),\n             CollectItemSig(ref d) => op(d).map(CollectItemSig),\n+            CoherenceCheckTrait(ref d) => op(d).map(CoherenceCheckTrait),\n             CoherenceCheckImpl(ref d) => op(d).map(CoherenceCheckImpl),\n             CoherenceOverlapCheck(ref d) => op(d).map(CoherenceOverlapCheck),\n             CoherenceOverlapCheckSpecial(ref d) => op(d).map(CoherenceOverlapCheckSpecial),"}, {"sha": "468421a68b54cb5f88168056a7d67ddf07f77761", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -80,6 +80,9 @@ pub struct LoweringContext<'a> {\n     impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n     bodies: FxHashMap<hir::BodyId, hir::Body>,\n \n+    trait_impls: BTreeMap<DefId, Vec<NodeId>>,\n+    trait_default_impl: BTreeMap<DefId, NodeId>,\n+\n     loop_scopes: Vec<NodeId>,\n     is_in_loop_condition: bool,\n \n@@ -116,6 +119,8 @@ pub fn lower_crate(sess: &Session,\n         trait_items: BTreeMap::new(),\n         impl_items: BTreeMap::new(),\n         bodies: FxHashMap(),\n+        trait_impls: BTreeMap::new(),\n+        trait_default_impl: BTreeMap::new(),\n         loop_scopes: Vec::new(),\n         is_in_loop_condition: false,\n         type_def_lifetime_params: DefIdMap(),\n@@ -201,6 +206,8 @@ impl<'a> LoweringContext<'a> {\n             trait_items: self.trait_items,\n             impl_items: self.impl_items,\n             bodies: self.bodies,\n+            trait_impls: self.trait_impls,\n+            trait_default_impl: self.trait_default_impl,\n         }\n     }\n \n@@ -1089,14 +1096,27 @@ impl<'a> LoweringContext<'a> {\n                 hir::ItemUnion(vdata, self.lower_generics(generics))\n             }\n             ItemKind::DefaultImpl(unsafety, ref trait_ref) => {\n+                let trait_ref = self.lower_trait_ref(trait_ref);\n+\n+                if let Def::Trait(def_id) = trait_ref.path.def {\n+                    self.trait_default_impl.insert(def_id, id);\n+                }\n+\n                 hir::ItemDefaultImpl(self.lower_unsafety(unsafety),\n-                                     self.lower_trait_ref(trait_ref))\n+                                     trait_ref)\n             }\n             ItemKind::Impl(unsafety, polarity, ref generics, ref ifce, ref ty, ref impl_items) => {\n                 let new_impl_items = impl_items.iter()\n                                                .map(|item| self.lower_impl_item_ref(item))\n                                                .collect();\n                 let ifce = ifce.as_ref().map(|trait_ref| self.lower_trait_ref(trait_ref));\n+\n+                if let Some(ref trait_ref) = ifce {\n+                    if let Def::Trait(def_id) = trait_ref.path.def {\n+                        self.trait_impls.entry(def_id).or_insert(vec![]).push(id);\n+                    }\n+                }\n+\n                 hir::ItemImpl(self.lower_unsafety(unsafety),\n                               self.lower_impl_polarity(polarity),\n                               self.lower_generics(generics),"}, {"sha": "20b4d8d8a8f031b71be26fe141630fef933d1fdd", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -461,6 +461,26 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    pub fn trait_impls(&self, trait_did: DefId) -> &'hir [NodeId] {\n+        self.dep_graph.read(DepNode::TraitImpls(trait_did));\n+\n+        // NB: intentionally bypass `self.forest.krate()` so that we\n+        // do not trigger a read of the whole krate here\n+        self.forest.krate.trait_impls.get(&trait_did).map_or(&[], |xs| &xs[..])\n+    }\n+\n+    pub fn trait_default_impl(&self, trait_did: DefId) -> Option<NodeId> {\n+        self.dep_graph.read(DepNode::TraitImpls(trait_did));\n+\n+        // NB: intentionally bypass `self.forest.krate()` so that we\n+        // do not trigger a read of the whole krate here\n+        self.forest.krate.trait_default_impl.get(&trait_did).cloned()\n+    }\n+\n+    pub fn trait_is_auto(&self, trait_did: DefId) -> bool {\n+        self.trait_default_impl(trait_did).is_some()\n+    }\n+\n     /// Get the attributes on the krate. This is preferable to\n     /// invoking `krate.attrs` because it registers a tighter\n     /// dep-graph access."}, {"sha": "8b6c75886baa8121ff62903a2c773202766531f3", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -410,6 +410,9 @@ pub struct Crate {\n     pub trait_items: BTreeMap<TraitItemId, TraitItem>,\n     pub impl_items: BTreeMap<ImplItemId, ImplItem>,\n     pub bodies: FxHashMap<BodyId, Body>,\n+\n+    pub trait_impls: BTreeMap<DefId, Vec<NodeId>>,\n+    pub trait_default_impl: BTreeMap<DefId, NodeId>,\n }\n \n impl Crate {"}, {"sha": "a929060cf98904e53d626677c179b43d20fce79a", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -505,7 +505,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             evaluation_cache: traits::EvaluationCache::new(),\n             projection_cache: RefCell::new(traits::ProjectionCache::new()),\n             reported_trait_errors: RefCell::new(FxHashSet()),\n-            projection_mode: Reveal::NotSpecializable,\n+            projection_mode: Reveal::UserFacing,\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: self.sess.err_count(),\n             obligations_in_snapshot: Cell::new(false),"}, {"sha": "4a7027b8997a5854befdef64121af1d4b96a373e", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -191,7 +191,6 @@ pub trait CrateStore {\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool;\n-    fn is_defaulted_trait(&self, did: DefId) -> bool;\n     fn is_default_impl(&self, impl_did: DefId) -> bool;\n     fn is_foreign_item(&self, did: DefId) -> bool;\n     fn is_dllimport_foreign_item(&self, def: DefId) -> bool;\n@@ -327,7 +326,6 @@ impl CrateStore for DummyCrateStore {\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool { bug!(\"is_const_fn\") }\n-    fn is_defaulted_trait(&self, did: DefId) -> bool { bug!(\"is_defaulted_trait\") }\n     fn is_default_impl(&self, impl_did: DefId) -> bool { bug!(\"is_default_impl\") }\n     fn is_foreign_item(&self, did: DefId) -> bool { bug!(\"is_foreign_item\") }\n     fn is_dllimport_foreign_item(&self, id: DefId) -> bool { false }"}, {"sha": "7e7d06e4b814e681e025a1b33e5966582c7043c0", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -473,7 +473,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n \n-    tcx.infer_ctxt(elaborated_env, Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt(elaborated_env, Reveal::UserFacing).enter(|infcx| {\n         let predicates = match fully_normalize(&infcx, cause,\n                                                &infcx.parameter_environment.caller_bounds) {\n             Ok(predicates) => predicates,"}, {"sha": "3d8f9e41c675b877e8fba6edf51f4155ceba7aed", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 4, "deletions": 33, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -38,36 +38,6 @@ use util::common::FN_OUTPUT_NAME;\n /// more or less conservative.\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub enum Reveal {\n-    /// FIXME (#32205)\n-    /// At coherence-checking time, we're still constructing the\n-    /// specialization graph, and thus we only project\n-    /// non-`default` associated types that are defined directly in\n-    /// the applicable impl. (This behavior should be improved over\n-    /// time, to allow for successful projections modulo cycles\n-    /// between different impls).\n-    ///\n-    /// Here's an example that will fail due to the restriction:\n-    ///\n-    /// ```\n-    /// trait Assoc {\n-    ///     type Output;\n-    /// }\n-    ///\n-    /// impl<T> Assoc for T {\n-    ///     type Output = bool;\n-    /// }\n-    ///\n-    /// impl Assoc for u8 {} // <- inherits the non-default type from above\n-    ///\n-    /// trait Foo {}\n-    /// impl Foo for u32 {}\n-    /// impl Foo for <u8 as Assoc>::Output {}  // <- this projection will fail\n-    /// ```\n-    ///\n-    /// The projection would succeed if `Output` had been defined\n-    /// directly in the impl for `u8`.\n-    ExactMatch,\n-\n     /// At type-checking time, we refuse to project any associated\n     /// type that is marked `default`. Non-`default` (\"final\") types\n     /// are always projected. This is necessary in general for\n@@ -90,7 +60,7 @@ pub enum Reveal {\n     /// fn main() {\n     ///     let <() as Assoc>::Output = true;\n     /// }\n-    NotSpecializable,\n+    UserFacing,\n \n     /// At trans time, all monomorphic projections will succeed.\n     /// Also, `impl Trait` is normalized to the concrete type,\n@@ -1347,8 +1317,9 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n     -> Option<specialization_graph::NodeItem<ty::AssociatedItem>>\n {\n     let trait_def_id = selcx.tcx().impl_trait_ref(impl_def_id).unwrap().def_id;\n+    let trait_def = selcx.tcx().lookup_trait_def(trait_def_id);\n \n-    if selcx.projection_mode() == Reveal::ExactMatch {\n+    if !trait_def.is_complete(selcx.tcx()) {\n         let impl_node = specialization_graph::Node::Impl(impl_def_id);\n         for item in impl_node.items(selcx.tcx()) {\n             if item.kind == ty::AssociatedKind::Type && item.name == assoc_ty_name {\n@@ -1360,7 +1331,7 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n         }\n         None\n     } else {\n-        selcx.tcx().lookup_trait_def(trait_def_id)\n+        trait_def\n             .ancestors(impl_def_id)\n             .defs(selcx.tcx(), assoc_ty_name, ty::AssociatedKind::Type)\n             .next()"}, {"sha": "79df7de04f540a9c955a0a942660c5336d3d41da", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -189,7 +189,7 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              .subst(tcx, &penv.free_substs);\n \n     // Create a infcx, taking the predicates of impl1 as assumptions:\n-    let result = tcx.infer_ctxt(penv, Reveal::ExactMatch).enter(|infcx| {\n+    let result = tcx.infer_ctxt(penv, Reveal::UserFacing).enter(|infcx| {\n         // Normalize the trait reference. The WF rules ought to ensure\n         // that this always succeeds.\n         let impl1_trait_ref ="}, {"sha": "40eb69395678f2bd63d39a03d35b980e9d0524e9", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'gcx, 'tcx> Children {\n             let possible_sibling = *slot;\n \n             let tcx = tcx.global_tcx();\n-            let (le, ge) = tcx.infer_ctxt((), Reveal::ExactMatch).enter(|infcx| {\n+            let (le, ge) = tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n                 let overlap = traits::overlapping_impls(&infcx,\n                                                         possible_sibling,\n                                                         impl_def_id);"}, {"sha": "e14295982916f44ad0578777db464581b6a4554d", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -219,7 +219,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                         res = res - TC::OwnsDtor;\n                     }\n \n-                    if def.has_dtor() {\n+                    if def.has_dtor(tcx) {\n                         res = res | TC::OwnsDtor;\n                     }\n "}, {"sha": "358d69ff8dba99d529a6982d51a328db990436cb", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -24,6 +24,15 @@ trait Key {\n     fn default_span(&self, tcx: TyCtxt) -> Span;\n }\n \n+impl Key for CrateNum {\n+    fn map_crate(&self) -> CrateNum {\n+        *self\n+    }\n+    fn default_span(&self, _: TyCtxt) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n impl Key for DefId {\n     fn map_crate(&self) -> CrateNum {\n         self.krate\n@@ -42,6 +51,15 @@ impl Key for (DefId, DefId) {\n     }\n }\n \n+impl Key for (CrateNum, DefId) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.0\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.1.default_span(tcx)\n+    }\n+}\n+\n trait Value<'tcx>: Sized {\n     fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self;\n }\n@@ -141,6 +159,19 @@ impl<'tcx> QueryDescription for queries::type_param_predicates<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::coherent_trait<'tcx> {\n+    fn describe(tcx: TyCtxt, (_, def_id): (CrateNum, DefId)) -> String {\n+        format!(\"coherence checking all impls of trait `{}`\",\n+                tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::coherent_inherent_impls<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        format!(\"coherence checking all inherent impls\")\n+    }\n+}\n+\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n@@ -238,6 +269,12 @@ macro_rules! define_maps {\n             }\n \n             pub fn force(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K) {\n+                // FIXME(eddyb) Move away from using `DepTrackingMap`\n+                // so we don't have to explicitly ignore a false edge:\n+                // we can't observe a value dependency, only side-effects,\n+                // through `force`, and once everything has been updated,\n+                // perhaps only diagnostics, if those, will remain.\n+                let _ignore = tcx.dep_graph.in_ignore();\n                 match Self::try_get_with(tcx, span, key, |_| ()) {\n                     Ok(()) => {}\n                     Err(e) => tcx.report_cycle(e)\n@@ -338,7 +375,19 @@ define_maps! { <'tcx>\n \n     pub typeck_tables: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n \n+    pub coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n+\n+    pub coherent_inherent_impls: coherent_inherent_impls_dep_node(CrateNum) -> (),\n+\n     /// Results of evaluating monomorphic constants embedded in\n     /// other items, such as enum variant explicit discriminants.\n     pub monomorphic_const_eval: MonomorphicConstEval(DefId) -> Result<ConstVal, ()>\n }\n+\n+fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n+    DepNode::CoherenceCheckTrait(def_id)\n+}\n+\n+fn coherent_inherent_impls_dep_node(_: CrateNum) -> DepNode<DefId> {\n+    DepNode::Coherence\n+}"}, {"sha": "55b6f61148d7715b947e7665d25942536f4b82f0", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -1301,6 +1301,7 @@ bitflags! {\n         const IS_FUNDAMENTAL      = 1 << 4,\n         const IS_UNION            = 1 << 5,\n         const IS_BOX              = 1 << 6,\n+        const IS_DTOR_VALID       = 1 << 7,\n     }\n }\n \n@@ -1522,8 +1523,8 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n \n     /// Returns whether this type has a destructor.\n-    pub fn has_dtor(&self) -> bool {\n-        self.destructor.get().is_some()\n+    pub fn has_dtor(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+        self.destructor(tcx).is_some()\n     }\n \n     /// Asserts this is a struct and returns the struct's unique\n@@ -1578,12 +1579,36 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n     }\n \n-    pub fn destructor(&self) -> Option<DefId> {\n-        self.destructor.get()\n+    pub fn destructor(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<DefId> {\n+        if self.flags.get().intersects(AdtFlags::IS_DTOR_VALID) {\n+            return self.destructor.get();\n+        }\n+\n+        let dtor = self.destructor_uncached(tcx);\n+        self.destructor.set(dtor);\n+        self.flags.set(self.flags.get() | AdtFlags::IS_DTOR_VALID);\n+\n+        dtor\n     }\n \n-    pub fn set_destructor(&self, dtor: DefId) {\n-        self.destructor.set(Some(dtor));\n+    fn destructor_uncached(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<DefId> {\n+        let drop_trait = if let Some(def_id) = tcx.lang_items.drop_trait() {\n+            def_id\n+        } else {\n+            return None;\n+        };\n+\n+        queries::coherent_trait::get(tcx, DUMMY_SP, (LOCAL_CRATE, drop_trait));\n+\n+        let mut dtor = None;\n+        let ty = tcx.item_type(self.did);\n+        tcx.lookup_trait_def(drop_trait).for_each_relevant_impl(tcx, ty, |def_id| {\n+            if let Some(item) = tcx.associated_items(def_id).next() {\n+                dtor = Some(item.def_id);\n+            }\n+        });\n+\n+        dtor\n     }\n \n     pub fn discriminants(&'a self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n@@ -2367,23 +2392,18 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn trait_has_default_impl(self, trait_def_id: DefId) -> bool {\n-        self.populate_implementations_for_trait_if_necessary(trait_def_id);\n-\n         let def = self.lookup_trait_def(trait_def_id);\n         def.flags.get().intersects(TraitFlags::HAS_DEFAULT_IMPL)\n     }\n \n-    /// Records a trait-to-implementation mapping.\n-    pub fn record_trait_has_default_impl(self, trait_def_id: DefId) {\n-        let def = self.lookup_trait_def(trait_def_id);\n-        def.flags.set(def.flags.get() | TraitFlags::HAS_DEFAULT_IMPL)\n-    }\n-\n     /// Populates the type context with all the inherent implementations for\n     /// the given type if necessary.\n     pub fn populate_inherent_implementations_for_type_if_necessary(self,\n+                                                                   span: Span,\n                                                                    type_id: DefId) {\n         if type_id.is_local() {\n+            // Make sure coherence of inherent impls ran already.\n+            ty::queries::coherent_inherent_impls::force(self, span, LOCAL_CRATE);\n             return\n         }\n \n@@ -2416,16 +2436,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let _ignore = self.dep_graph.in_ignore();\n \n         let def = self.lookup_trait_def(trait_id);\n-        if def.flags.get().intersects(TraitFlags::IMPLS_VALID) {\n+        if def.flags.get().intersects(TraitFlags::HAS_REMOTE_IMPLS) {\n             return;\n         }\n \n         debug!(\"populate_implementations_for_trait_if_necessary: searching for {:?}\", def);\n \n-        if self.sess.cstore.is_defaulted_trait(trait_id) {\n-            self.record_trait_has_default_impl(trait_id);\n-        }\n-\n         for impl_def_id in self.sess.cstore.implementations_of_trait(Some(trait_id)) {\n             let trait_ref = self.impl_trait_ref(impl_def_id).unwrap();\n \n@@ -2434,7 +2450,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             def.record_remote_impl(self, impl_def_id, trait_ref, parent);\n         }\n \n-        def.flags.set(def.flags.get() | TraitFlags::IMPLS_VALID);\n+        def.flags.set(def.flags.get() | TraitFlags::HAS_REMOTE_IMPLS);\n     }\n \n     pub fn closure_kind(self, def_id: DefId) -> ty::ClosureKind {"}, {"sha": "097b596c5ebb6b6c9e08219168643855605b265a", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 72, "deletions": 3, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use dep_graph::DepNode;\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, LOCAL_CRATE};\n use traits::{self, specialization_graph};\n use ty;\n use ty::fast_reject;\n@@ -18,6 +18,9 @@ use std::cell::{Cell, RefCell};\n use hir;\n use util::nodemap::FxHashMap;\n \n+use syntax::ast;\n+use syntax_pos::DUMMY_SP;\n+\n /// A trait's definition with type information.\n pub struct TraitDef {\n     pub def_id: DefId,\n@@ -60,6 +63,11 @@ pub struct TraitDef {\n     /// Various flags\n     pub flags: Cell<TraitFlags>,\n \n+    /// The number of impls we've added from the local crate.\n+    /// When this number matches up the list in the HIR map,\n+    /// we're done, and the specialization graph is correct.\n+    local_impl_count: Cell<usize>,\n+\n     /// The ICH of this trait's DefPath, cached here so it doesn't have to be\n     /// recomputed all the time.\n     pub def_path_hash: u64,\n@@ -78,6 +86,7 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n             nonblanket_impls: RefCell::new(FxHashMap()),\n             blanket_impls: RefCell::new(vec![]),\n             flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS),\n+            local_impl_count: Cell::new(0),\n             specialization_graph: RefCell::new(traits::specialization_graph::Graph::new()),\n             def_path_hash: def_path_hash,\n         }\n@@ -155,6 +164,13 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n         assert!(impl_def_id.is_local());\n         let was_new = self.record_impl(tcx, impl_def_id, impl_trait_ref);\n         assert!(was_new);\n+\n+        self.local_impl_count.set(self.local_impl_count.get() + 1);\n+    }\n+\n+    /// Records a trait-to-implementation mapping.\n+    pub fn record_has_default_impl(&self) {\n+        self.flags.set(self.flags.get() | TraitFlags::HAS_DEFAULT_IMPL);\n     }\n \n     /// Records a trait-to-implementation mapping for a non-local impl.\n@@ -194,10 +210,51 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n         specialization_graph::ancestors(self, of_impl)\n     }\n \n+    /// Whether the impl set and specialization graphs are complete.\n+    pub fn is_complete(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+        tcx.populate_implementations_for_trait_if_necessary(self.def_id);\n+        ty::queries::coherent_trait::try_get(tcx, DUMMY_SP, (LOCAL_CRATE, self.def_id)).is_ok()\n+    }\n+\n+    /// If any local impls haven't been added yet, returns\n+    /// Some(list of local impls for this trait).\n+    fn missing_local_impls(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n+                           -> Option<&'gcx [ast::NodeId]> {\n+        if self.flags.get().intersects(TraitFlags::HAS_LOCAL_IMPLS) {\n+            return None;\n+        }\n+\n+        if self.is_complete(tcx) {\n+            self.flags.set(self.flags.get() | TraitFlags::HAS_LOCAL_IMPLS);\n+            return None;\n+        }\n+\n+        let impls = tcx.hir.trait_impls(self.def_id);\n+        assert!(self.local_impl_count.get() <= impls.len());\n+        if self.local_impl_count.get() == impls.len() {\n+            self.flags.set(self.flags.get() | TraitFlags::HAS_LOCAL_IMPLS);\n+            return None;\n+        }\n+\n+        Some(impls)\n+    }\n+\n     pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, mut f: F) {\n         self.read_trait_impls(tcx);\n         tcx.populate_implementations_for_trait_if_necessary(self.def_id);\n \n+        let local_impls = self.missing_local_impls(tcx);\n+        if let Some(impls) = local_impls {\n+            for &id in impls {\n+                f(tcx.hir.local_def_id(id));\n+            }\n+        }\n+        let mut f = |def_id: DefId| {\n+            if !(local_impls.is_some() && def_id.is_local()) {\n+                f(def_id);\n+            }\n+        };\n+\n         for &impl_def_id in self.blanket_impls.borrow().iter() {\n             f(impl_def_id);\n         }\n@@ -217,9 +274,20 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n                                                    mut f: F)\n     {\n         self.read_trait_impls(tcx);\n-\n         tcx.populate_implementations_for_trait_if_necessary(self.def_id);\n \n+        let local_impls = self.missing_local_impls(tcx);\n+        if let Some(impls) = local_impls {\n+            for &id in impls {\n+                f(tcx.hir.local_def_id(id));\n+            }\n+        }\n+        let mut f = |def_id: DefId| {\n+            if !(local_impls.is_some() && def_id.is_local()) {\n+                f(def_id);\n+            }\n+        };\n+\n         for &impl_def_id in self.blanket_impls.borrow().iter() {\n             f(impl_def_id);\n         }\n@@ -258,6 +326,7 @@ bitflags! {\n         const HAS_DEFAULT_IMPL      = 1 << 0,\n         const IS_OBJECT_SAFE        = 1 << 1,\n         const OBJECT_SAFETY_VALID   = 1 << 2,\n-        const IMPLS_VALID           = 1 << 3,\n+        const HAS_REMOTE_IMPLS      = 1 << 3,\n+        const HAS_LOCAL_IMPLS       = 1 << 4,\n     }\n }"}, {"sha": "64480e510229ea66bb8e22775cc05a50b8f1e662", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -149,7 +149,7 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n                                        self_type: Ty<'tcx>, span: Span)\n                                        -> Result<(), CopyImplementationError> {\n         // FIXME: (@jroesch) float this code up\n-        tcx.infer_ctxt(self.clone(), Reveal::NotSpecializable).enter(|infcx| {\n+        tcx.infer_ctxt(self.clone(), Reveal::UserFacing).enter(|infcx| {\n             let (adt, substs) = match self_type.sty {\n                 ty::TyAdt(adt, substs) => (adt, substs),\n                 _ => return Err(CopyImplementationError::NotAnAdt)\n@@ -171,7 +171,7 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n                 }\n             }\n \n-            if adt.has_dtor() {\n+            if adt.has_dtor(tcx) {\n                 return Err(CopyImplementationError::HasDestructor);\n             }\n \n@@ -353,7 +353,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// (This allows programs to make cyclic structures without\n     /// resorting to unasfe means; see RFCs 769 and 1238).\n     pub fn is_adt_dtorck(self, adt: &ty::AdtDef) -> bool {\n-        let dtor_method = match adt.destructor() {\n+        let dtor_method = match adt.destructor(self) {\n             Some(dtor) => dtor,\n             None => return false\n         };\n@@ -524,7 +524,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             }\n         }\n         let result =\n-            tcx.infer_ctxt(param_env.clone(), Reveal::ExactMatch)\n+            tcx.infer_ctxt(param_env.clone(), Reveal::UserFacing)\n             .enter(|infcx| {\n                 traits::type_known_to_meet_bound(&infcx, self, def_id, span)\n             });"}, {"sha": "3ce31882b86c4583ec1c4f5a7d5a5f05dad26aa8", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -783,7 +783,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             }\n             LpExtend(ref lp_base, _, LpInterior(_, InteriorField(_))) => {\n                 match lp_base.to_type().sty {\n-                    ty::TyAdt(def, _) if def.has_dtor() => {\n+                    ty::TyAdt(def, _) if def.has_dtor(self.tcx()) => {\n                         // In the case where the owner implements drop, then\n                         // the path must be initialized to prevent a case of\n                         // partial reinitialization"}, {"sha": "0577ba7f45a938883d3767c8b697acd94913dca3", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -177,7 +177,7 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         Categorization::Interior(ref b, mc::InteriorElement(Kind::Pattern, _)) => {\n             match b.ty.sty {\n                 ty::TyAdt(def, _) => {\n-                    if def.has_dtor() {\n+                    if def.has_dtor(bccx.tcx) {\n                         Some(cmt.clone())\n                     } else {\n                         check_and_get_illegal_move_origin(bccx, b)"}, {"sha": "3678c2e55c1fdb17d0d175796e282f167f98f861", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -150,7 +150,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         Categorization::Downcast(ref b, _) |\n         Categorization::Interior(ref b, mc::InteriorField(_)) => {\n             match b.ty.sty {\n-                ty::TyAdt(def, _) if def.has_dtor() => {\n+                ty::TyAdt(def, _) if def.has_dtor(bccx.tcx) => {\n                     let mut err = struct_span_err!(bccx, move_from.span, E0509,\n                                                    \"cannot move out of type `{}`, \\\n                                                    which implements the `Drop` trait\","}, {"sha": "13f898219bc12dfba9c9d456cb34c7d15a5b51e5", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -898,7 +898,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n         match ty.sty {\n             ty::TyAdt(def, _) => {\n-                if def.has_dtor() && !def.is_box() {\n+                if def.has_dtor(self.tcx) && !def.is_box() {\n                     self.tcx.sess.span_warn(\n                         c.source_info.span,\n                         &format!(\"dataflow bug??? moving out of type with dtor {:?}\","}, {"sha": "8d866676dbd1875dc3838da2e0491e4db397ae00", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -289,7 +289,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             // error: can't move out of borrowed content\n             ty::TyRef(..) | ty::TyRawPtr(..) => return Err(MovePathError::IllegalMove),\n             // error: can't move out of struct with destructor\n-            ty::TyAdt(adt, _) if adt.has_dtor() && !adt.is_box() =>\n+            ty::TyAdt(adt, _) if adt.has_dtor(self.tcx) && !adt.is_box() =>\n                 return Err(MovePathError::IllegalMove),\n             // move out of union - always move the entire union\n             ty::TyAdt(adt, _) if adt.is_union() =>"}, {"sha": "1c9ee335699ae13439d689cbb1af77e826b72b69", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -248,7 +248,7 @@ fn lvalue_contents_drop_state_cannot_differ<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n                    lv, ty);\n             true\n         }\n-        ty::TyAdt(def, _) if (def.has_dtor() && !def.is_box()) || def.is_union() => {\n+        ty::TyAdt(def, _) if (def.has_dtor(tcx) && !def.is_box()) || def.is_union() => {\n             debug!(\"lvalue_contents_drop_state_cannot_differ lv: {:?} ty: {:?} Drop => true\",\n                    lv, ty);\n             true"}, {"sha": "db5df72267df7919622723fb89e2c9f946d0fe9d", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -516,7 +516,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n ///\n /// FIXME: this should be done by borrowck.\n fn check_for_mutation_in_guard(cx: &MatchVisitor, guard: &hir::Expr) {\n-    cx.tcx.infer_ctxt((cx.tables, cx.param_env.clone()), Reveal::NotSpecializable).enter(|infcx| {\n+    cx.tcx.infer_ctxt((cx.tables, cx.param_env.clone()), Reveal::UserFacing).enter(|infcx| {\n         let mut checker = MutationChecker {\n             cx: cx,\n         };"}, {"sha": "0ab2255aab0ff8b2d66a7f1fc305796339f681b9", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -922,7 +922,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(\n            trait_ref);\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_id);\n-    tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n         let mut selcx = traits::SelectionContext::new(&infcx);\n         let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n                                                  trait_ref.to_poly_trait_predicate());"}, {"sha": "9568cc3d6de0e35c8cc00fce917dc91b73e344c0", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -151,7 +151,7 @@ fn test_env<F>(source_string: &str,\n                              index,\n                              \"test_crate\",\n                              |tcx| {\n-        tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n+        tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n \n             body(Env { infcx: &infcx });\n             let free_regions = FreeRegionMap::new();"}, {"sha": "150a2c39db7a827e9796d5dca3edb992b88e39d5", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -1167,6 +1167,9 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n             trait_items: _,\n             impl_items: _,\n             bodies: _,\n+\n+            trait_impls: _,\n+            trait_default_impl: _,\n         } = *krate;\n \n         visit::Visitor::visit_mod(self, module, span, ast::CRATE_NODE_ID);"}, {"sha": "b3f09c28277ada98725c0c6729d148ee23499fdf", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -523,7 +523,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n             }\n             _ => return,\n         };\n-        if def.has_dtor() {\n+        if def.has_dtor(cx.tcx) {\n             return;\n         }\n         let parameter_environment = cx.tcx.empty_parameter_environment();\n@@ -882,7 +882,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                     let node_id = tcx.hir.as_local_node_id(method.def_id).unwrap();\n \n                     let param_env = ty::ParameterEnvironment::for_item(tcx, node_id);\n-                    tcx.infer_ctxt(param_env, Reveal::NotSpecializable).enter(|infcx| {\n+                    tcx.infer_ctxt(param_env, Reveal::UserFacing).enter(|infcx| {\n                         let mut selcx = traits::SelectionContext::new(&infcx);\n                         match selcx.select(&obligation) {\n                             // The method comes from a `T: Trait` bound."}, {"sha": "443e75e63d3ddc9b514ea64009a394544fcccb64", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -203,12 +203,6 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(did.krate).is_const_fn(did.index)\n     }\n \n-    fn is_defaulted_trait(&self, trait_def_id: DefId) -> bool\n-    {\n-        self.dep_graph.read(DepNode::MetaData(trait_def_id));\n-        self.get_crate_data(trait_def_id.krate).is_defaulted_trait(trait_def_id.index)\n-    }\n-\n     fn is_default_impl(&self, impl_did: DefId) -> bool {\n         self.dep_graph.read(DepNode::MetaData(impl_did));\n         self.get_crate_data(impl_did.krate).is_default_impl(impl_did.index)"}, {"sha": "1627b22cd5fa18a5eb68e37ac67bdbec96fef3d1", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -501,10 +501,16 @@ impl<'a, 'tcx> CrateMetadata {\n             _ => bug!(),\n         };\n \n-        ty::TraitDef::new(self.local_def_id(item_id),\n-                          data.unsafety,\n-                          data.paren_sugar,\n-                          self.def_path(item_id).deterministic_hash(tcx))\n+        let def = ty::TraitDef::new(self.local_def_id(item_id),\n+                                    data.unsafety,\n+                                    data.paren_sugar,\n+                                    self.def_path(item_id).deterministic_hash(tcx));\n+\n+        if data.has_default_impl {\n+            def.record_has_default_impl();\n+        }\n+\n+        def\n     }\n \n     fn get_variant(&self,\n@@ -1027,13 +1033,6 @@ impl<'a, 'tcx> CrateMetadata {\n         self.dllimport_foreign_items.contains(&id)\n     }\n \n-    pub fn is_defaulted_trait(&self, trait_id: DefIndex) -> bool {\n-        match self.entry(trait_id).kind {\n-            EntryKind::Trait(data) => data.decode(self).has_default_impl,\n-            _ => bug!(),\n-        }\n-    }\n-\n     pub fn is_default_impl(&self, impl_id: DefIndex) -> bool {\n         match self.entry(impl_id).kind {\n             EntryKind::DefaultImpl(_) => true,"}, {"sha": "0d7be189f883aa57f5f2cf30883aece26f9adfe4", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -96,7 +96,7 @@ fn build_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     };\n \n     let src = MirSource::from_node(tcx, id);\n-    tcx.infer_ctxt(body_id, Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt(body_id, Reveal::UserFacing).enter(|infcx| {\n         let cx = Cx::new(&infcx, src);\n         let mut mir = if let MirSource::Fn(id) = src {\n             // fetch the fully liberated fn signature (that is, all bound"}, {"sha": "9f38564d1e2f34489bfc4479952c0581c9a42529", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -758,7 +758,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n             Rvalue::Aggregate(ref kind, _) => {\n                 if let AggregateKind::Adt(def, ..) = *kind {\n-                    if def.has_dtor() {\n+                    if def.has_dtor(self.tcx) {\n                         self.add(Qualif::NEEDS_DROP);\n                         self.deny_drop();\n                     }\n@@ -1042,7 +1042,7 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants {\n         // Statics must be Sync.\n         if mode == Mode::Static {\n             let ty = mir.return_ty;\n-            tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n+            tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n                 let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n                 let mut fulfillment_cx = traits::FulfillmentContext::new();\n                 fulfillment_cx.register_bound(&infcx, ty,"}, {"sha": "af4a4a53905eb05ffb265d9ee4fc1e8676b90098", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -699,7 +699,7 @@ impl<'tcx> MirPass<'tcx> for TypeckMir {\n             return;\n         }\n         let param_env = ty::ParameterEnvironment::for_item(tcx, src.item_id());\n-        tcx.infer_ctxt(param_env, Reveal::NotSpecializable).enter(|infcx| {\n+        tcx.infer_ctxt(param_env, Reveal::UserFacing).enter(|infcx| {\n             let mut checker = TypeChecker::new(&infcx, src.item_id());\n             {\n                 let mut verifier = TypeVerifier::new(&mut checker, mir);"}, {"sha": "e3a77a9359980cdd18f6cb0e6e1fbf6b18850c4a", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n             self.check_const_eval(&body.value);\n         }\n \n-        let outer_penv = self.tcx.infer_ctxt(body_id, Reveal::NotSpecializable).enter(|infcx| {\n+        let outer_penv = self.tcx.infer_ctxt(body_id, Reveal::UserFacing).enter(|infcx| {\n             let param_env = infcx.parameter_environment.clone();\n             let outer_penv = mem::replace(&mut self.param_env, param_env);\n             euv::ExprUseVisitor::new(self, &infcx).consume_body(body);\n@@ -274,7 +274,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n /// instead of producing errors.\n fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node_ty: Ty<'tcx>) {\n     match node_ty.sty {\n-        ty::TyAdt(def, _) if def.has_dtor() => {\n+        ty::TyAdt(def, _) if def.has_dtor(v.tcx) => {\n             v.promotable = false;\n         }\n         _ => {}"}, {"sha": "c367e71fcd24619417dd41e20e2077739503b535", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -38,7 +38,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RvalueContext<'a, 'tcx> {\n \n     fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n         let body = self.tcx.hir.body(body_id);\n-        self.tcx.infer_ctxt(body_id, Reveal::NotSpecializable).enter(|infcx| {\n+        self.tcx.infer_ctxt(body_id, Reveal::UserFacing).enter(|infcx| {\n             let mut delegate = RvalueContextDelegate {\n                 tcx: infcx.tcx,\n                 param_env: &infcx.parameter_environment"}, {"sha": "b12c1220b2b4de797a9c9f4be568a02839fd35eb", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -754,7 +754,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     // If the type implements Drop, also add a translation item for the\n     // monomorphized Drop::drop() implementation.\n     let destructor_did = match ty.sty {\n-        ty::TyAdt(def, _) => def.destructor(),\n+        ty::TyAdt(def, _) => def.destructor(scx.tcx()),\n         _ => None\n     };\n "}, {"sha": "32fc3d5af24451f21d97a2a39d6c176329f1dd26", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -237,7 +237,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n             bcx.call(dtor, &[ptr.llval], None);\n             bcx\n         }\n-        ty::TyAdt(def, ..) if def.has_dtor() && !skip_dtor => {\n+        ty::TyAdt(def, ..) if def.has_dtor(bcx.tcx()) && !skip_dtor => {\n             let shallow_drop = def.is_union();\n             let tcx = bcx.tcx();\n \n@@ -265,7 +265,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n                 traits::VtableImpl(data) => data,\n                 _ => bug!(\"dtor for {:?} is not an impl???\", t)\n             };\n-            let dtor_did = def.destructor().unwrap();\n+            let dtor_did = def.destructor(tcx).unwrap();\n             let callee = Callee::def(bcx.ccx, dtor_did, vtbl.substs);\n             let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n             let llret;"}, {"sha": "0e9abaf1cf955e86c272e91acc882fcccbfcedb6", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -224,7 +224,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                                trait_param_env,\n                                                                normalize_cause.clone());\n \n-    tcx.infer_ctxt(trait_param_env, Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt(trait_param_env, Reveal::UserFacing).enter(|infcx| {\n         let inh = Inherited::new(infcx);\n         let infcx = &inh.infcx;\n         let fulfillment_cx = &inh.fulfillment_cx;\n@@ -730,7 +730,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     impl_trait_ref: ty::TraitRef<'tcx>) {\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n-    tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n         // The below is for the most part highly similar to the procedure"}, {"sha": "07cc35ed67bbb76ab86bf82bd3e446544cd0f7e1", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -80,7 +80,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     // check that the impl type can be made to match the trait type.\n \n     let impl_param_env = ty::ParameterEnvironment::for_item(tcx, self_type_node_id);\n-    tcx.infer_ctxt(impl_param_env, Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt(impl_param_env, Reveal::UserFacing).enter(|infcx| {\n         let tcx = infcx.tcx;\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n@@ -554,7 +554,7 @@ fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n             // Find the `impl<..> Drop for _` to inspect any\n             // attributes attached to the impl's generics.\n-            let dtor_method = adt_def.destructor()\n+            let dtor_method = adt_def.destructor(tcx)\n                 .expect(\"dtorck type without destructor impossible\");\n             let method = tcx.associated_item(dtor_method);\n             let impl_def_id = method.container.id();"}, {"sha": "dfa7ababca0bbd8b97f143cbc9efcdca24d44ec6", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -481,7 +481,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn assemble_inherent_impl_candidates_for_type(&mut self, def_id: DefId) {\n         // Read the inherent implementation candidates for this type from the\n         // metadata if necessary.\n-        self.tcx.populate_inherent_implementations_for_type_if_necessary(def_id);\n+        self.tcx.populate_inherent_implementations_for_type_if_necessary(self.span, def_id);\n \n         if let Some(impl_infos) = self.tcx.maps.inherent_impls.borrow().get(&def_id) {\n             for &impl_def_id in impl_infos.iter() {"}, {"sha": "aa1fc0f8579daecfe02b523db9160ceea5bcaf51", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -477,7 +477,7 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n         let tables = ty::TypeckTables::empty();\n         let param_env = ParameterEnvironment::for_item(tcx, id);\n         InheritedBuilder {\n-            infcx: tcx.infer_ctxt((tables, param_env), Reveal::NotSpecializable)\n+            infcx: tcx.infer_ctxt((tables, param_env), Reveal::UserFacing)\n         }\n     }\n }"}, {"sha": "3cdf9fc93ae600617a4c84aa935dfdb1adcaec07", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 24, "deletions": 33, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -26,47 +26,38 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n use rustc::hir::{self, ItemImpl};\n \n-pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    check_trait(tcx, tcx.lang_items.drop_trait(), visit_implementation_of_drop);\n-    check_trait(tcx, tcx.lang_items.copy_trait(), visit_implementation_of_copy);\n-    check_trait(\n-        tcx,\n-        tcx.lang_items.coerce_unsized_trait(),\n-        visit_implementation_of_coerce_unsized);\n+pub fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_def_id: DefId) {\n+    Checker { tcx, trait_def_id }\n+        .check(tcx.lang_items.drop_trait(), visit_implementation_of_drop)\n+        .check(tcx.lang_items.copy_trait(), visit_implementation_of_copy)\n+        .check(tcx.lang_items.coerce_unsized_trait(),\n+               visit_implementation_of_coerce_unsized);\n }\n \n-fn check_trait<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            trait_def_id: Option<DefId>,\n-                            mut f: F)\n-    where F: FnMut(TyCtxt<'a, 'tcx, 'tcx>, DefId, DefId)\n-{\n-    if let Some(trait_def_id) = trait_def_id {\n-        let mut impls = vec![];\n-        tcx.lookup_trait_def(trait_def_id).for_each_impl(tcx, |did| {\n-            impls.push(did);\n-        });\n-        impls.sort();\n-        for impl_def_id in impls {\n-            f(tcx, trait_def_id, impl_def_id);\n+struct Checker<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    trait_def_id: DefId\n+}\n+\n+impl<'a, 'tcx> Checker<'a, 'tcx> {\n+    fn check<F>(&self, trait_def_id: Option<DefId>, mut f: F) -> &Self\n+        where F: FnMut(TyCtxt<'a, 'tcx, 'tcx>, DefId, DefId)\n+    {\n+        if Some(self.trait_def_id) == trait_def_id {\n+            for &impl_id in self.tcx.hir.trait_impls(self.trait_def_id) {\n+                let impl_def_id = self.tcx.hir.local_def_id(impl_id);\n+                f(self.tcx, self.trait_def_id, impl_def_id);\n+            }\n         }\n+        self\n     }\n }\n \n fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                           _drop_did: DefId,\n                                           impl_did: DefId) {\n-    let items = tcx.associated_item_def_ids(impl_did);\n-    if items.is_empty() {\n-        // We'll error out later. For now, just don't ICE.\n-        return;\n-    }\n-    let method_def_id = items[0];\n-\n-    let self_type = tcx.item_type(impl_did);\n-    match self_type.sty {\n-        ty::TyAdt(type_def, _) => {\n-            type_def.set_destructor(method_def_id);\n-        }\n+    match tcx.item_type(impl_did).sty {\n+        ty::TyAdt(..) => {}\n         _ => {\n             // Destructors only work on nominal types.\n             if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_did) {\n@@ -205,7 +196,7 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            source,\n            target);\n \n-    tcx.infer_ctxt(param_env, Reveal::ExactMatch).enter(|infcx| {\n+    tcx.infer_ctxt(param_env, Reveal::UserFacing).enter(|infcx| {\n         let cause = ObligationCause::misc(span, impl_node_id);\n         let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n                            mt_b: ty::TypeAndMut<'tcx>,"}, {"sha": "e3b4ba9eb1b9e3fc89da9b826cacc3d8579d2b90", "filename": "src/librustc_typeck/coherence/inherent.rs", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcoherence%2Finherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcoherence%2Finherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -0,0 +1,356 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::dep_graph::DepNode;\n+use rustc::hir::def_id::DefId;\n+use rustc::hir;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::lint;\n+use rustc::traits::{self, Reveal};\n+use rustc::ty::{self, TyCtxt};\n+\n+use syntax::ast;\n+use syntax_pos::Span;\n+\n+struct InherentCollect<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+}\n+\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &hir::Item) {\n+        let (unsafety, ty) = match item.node {\n+            hir::ItemImpl(unsafety, .., None, ref ty, _) => (unsafety, ty),\n+            _ => return\n+        };\n+\n+        match unsafety {\n+            hir::Unsafety::Normal => {\n+                // OK\n+            }\n+            hir::Unsafety::Unsafe => {\n+                span_err!(self.tcx.sess,\n+                          item.span,\n+                          E0197,\n+                          \"inherent impls cannot be declared as unsafe\");\n+            }\n+        }\n+\n+        let def_id = self.tcx.hir.local_def_id(item.id);\n+        let self_ty = self.tcx.item_type(def_id);\n+        match self_ty.sty {\n+            ty::TyAdt(def, _) => {\n+                self.check_def_id(item, def.did);\n+            }\n+            ty::TyDynamic(ref data, ..) if data.principal().is_some() => {\n+                self.check_def_id(item, data.principal().unwrap().def_id());\n+            }\n+            ty::TyChar => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.char_impl(),\n+                                          \"char\",\n+                                          \"char\",\n+                                          item.span);\n+            }\n+            ty::TyStr => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.str_impl(),\n+                                          \"str\",\n+                                          \"str\",\n+                                          item.span);\n+            }\n+            ty::TySlice(_) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.slice_impl(),\n+                                          \"slice\",\n+                                          \"[T]\",\n+                                          item.span);\n+            }\n+            ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.const_ptr_impl(),\n+                                          \"const_ptr\",\n+                                          \"*const T\",\n+                                          item.span);\n+            }\n+            ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.mut_ptr_impl(),\n+                                          \"mut_ptr\",\n+                                          \"*mut T\",\n+                                          item.span);\n+            }\n+            ty::TyInt(ast::IntTy::I8) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.i8_impl(),\n+                                          \"i8\",\n+                                          \"i8\",\n+                                          item.span);\n+            }\n+            ty::TyInt(ast::IntTy::I16) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.i16_impl(),\n+                                          \"i16\",\n+                                          \"i16\",\n+                                          item.span);\n+            }\n+            ty::TyInt(ast::IntTy::I32) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.i32_impl(),\n+                                          \"i32\",\n+                                          \"i32\",\n+                                          item.span);\n+            }\n+            ty::TyInt(ast::IntTy::I64) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.i64_impl(),\n+                                          \"i64\",\n+                                          \"i64\",\n+                                          item.span);\n+            }\n+            ty::TyInt(ast::IntTy::I128) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.i128_impl(),\n+                                          \"i128\",\n+                                          \"i128\",\n+                                          item.span);\n+            }\n+            ty::TyInt(ast::IntTy::Is) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.isize_impl(),\n+                                          \"isize\",\n+                                          \"isize\",\n+                                          item.span);\n+            }\n+            ty::TyUint(ast::UintTy::U8) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.u8_impl(),\n+                                          \"u8\",\n+                                          \"u8\",\n+                                          item.span);\n+            }\n+            ty::TyUint(ast::UintTy::U16) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.u16_impl(),\n+                                          \"u16\",\n+                                          \"u16\",\n+                                          item.span);\n+            }\n+            ty::TyUint(ast::UintTy::U32) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.u32_impl(),\n+                                          \"u32\",\n+                                          \"u32\",\n+                                          item.span);\n+            }\n+            ty::TyUint(ast::UintTy::U64) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.u64_impl(),\n+                                          \"u64\",\n+                                          \"u64\",\n+                                          item.span);\n+            }\n+            ty::TyUint(ast::UintTy::U128) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.u128_impl(),\n+                                          \"u128\",\n+                                          \"u128\",\n+                                          item.span);\n+            }\n+            ty::TyUint(ast::UintTy::Us) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.usize_impl(),\n+                                          \"usize\",\n+                                          \"usize\",\n+                                          item.span);\n+            }\n+            ty::TyFloat(ast::FloatTy::F32) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.f32_impl(),\n+                                          \"f32\",\n+                                          \"f32\",\n+                                          item.span);\n+            }\n+            ty::TyFloat(ast::FloatTy::F64) => {\n+                self.check_primitive_impl(def_id,\n+                                          self.tcx.lang_items.f64_impl(),\n+                                          \"f64\",\n+                                          \"f64\",\n+                                          item.span);\n+            }\n+            ty::TyError => {\n+                return;\n+            }\n+            _ => {\n+                struct_span_err!(self.tcx.sess,\n+                                 ty.span,\n+                                 E0118,\n+                                 \"no base type found for inherent implementation\")\n+                    .span_label(ty.span, &format!(\"impl requires a base type\"))\n+                    .note(&format!(\"either implement a trait on it or create a newtype \\\n+                                    to wrap it instead\"))\n+                    .emit();\n+                return;\n+            }\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n+}\n+\n+impl<'a, 'tcx> InherentCollect<'a, 'tcx> {\n+    fn check_def_id(&self, item: &hir::Item, def_id: DefId) {\n+        if def_id.is_local() {\n+            // Add the implementation to the mapping from implementation to base\n+            // type def ID, if there is a base type for this implementation and\n+            // the implementation does not have any associated traits.\n+            let impl_def_id = self.tcx.hir.local_def_id(item.id);\n+\n+            // Subtle: it'd be better to collect these into a local map\n+            // and then write the vector only once all items are known,\n+            // but that leads to degenerate dep-graphs. The problem is\n+            // that the write of that big vector winds up having reads\n+            // from *all* impls in the krate, since we've lost the\n+            // precision basically.  This would be ok in the firewall\n+            // model so once we've made progess towards that we can modify\n+            // the strategy here. In the meantime, using `push` is ok\n+            // because we are doing this as a pre-pass before anyone\n+            // actually reads from `inherent_impls` -- and we know this is\n+            // true beacuse we hold the refcell lock.\n+            self.tcx.maps.inherent_impls.borrow_mut().push(def_id, impl_def_id);\n+        } else {\n+            struct_span_err!(self.tcx.sess,\n+                             item.span,\n+                             E0116,\n+                             \"cannot define inherent `impl` for a type outside of the crate \\\n+                              where the type is defined\")\n+                .span_label(item.span,\n+                            &format!(\"impl for type defined outside of crate.\"))\n+                .note(\"define and implement a trait or new type instead\")\n+                .emit();\n+        }\n+    }\n+\n+    fn check_primitive_impl(&self,\n+                            impl_def_id: DefId,\n+                            lang_def_id: Option<DefId>,\n+                            lang: &str,\n+                            ty: &str,\n+                            span: Span) {\n+        match lang_def_id {\n+            Some(lang_def_id) if lang_def_id == impl_def_id => {\n+                // OK\n+            }\n+            _ => {\n+                struct_span_err!(self.tcx.sess,\n+                                 span,\n+                                 E0390,\n+                                 \"only a single inherent implementation marked with `#[lang = \\\n+                                  \\\"{}\\\"]` is allowed for the `{}` primitive\",\n+                                 lang,\n+                                 ty)\n+                    .span_help(span, \"consider using a trait to implement these methods\")\n+                    .emit();\n+            }\n+        }\n+    }\n+}\n+\n+struct InherentOverlapChecker<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+}\n+\n+impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n+    fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId) {\n+        #[derive(Copy, Clone, PartialEq)]\n+        enum Namespace {\n+            Type,\n+            Value,\n+        }\n+\n+        let name_and_namespace = |def_id| {\n+            let item = self.tcx.associated_item(def_id);\n+            (item.name, match item.kind {\n+                ty::AssociatedKind::Type => Namespace::Type,\n+                ty::AssociatedKind::Const |\n+                ty::AssociatedKind::Method => Namespace::Value,\n+            })\n+        };\n+\n+        let impl_items1 = self.tcx.associated_item_def_ids(impl1);\n+        let impl_items2 = self.tcx.associated_item_def_ids(impl2);\n+\n+        for &item1 in &impl_items1[..] {\n+            let (name, namespace) = name_and_namespace(item1);\n+\n+            for &item2 in &impl_items2[..] {\n+                if (name, namespace) == name_and_namespace(item2) {\n+                    let msg = format!(\"duplicate definitions with name `{}`\", name);\n+                    let node_id = self.tcx.hir.as_local_node_id(item1).unwrap();\n+                    self.tcx.sess.add_lint(lint::builtin::OVERLAPPING_INHERENT_IMPLS,\n+                                           node_id,\n+                                           self.tcx.span_of_impl(item1).unwrap(),\n+                                           msg);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_for_overlapping_inherent_impls(&self, ty_def_id: DefId) {\n+        let _task = self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapInherentCheck(ty_def_id));\n+\n+        let inherent_impls = self.tcx.maps.inherent_impls.borrow();\n+        let impls = match inherent_impls.get(&ty_def_id) {\n+            Some(impls) => impls,\n+            None => return,\n+        };\n+\n+        for (i, &impl1_def_id) in impls.iter().enumerate() {\n+            for &impl2_def_id in &impls[(i + 1)..] {\n+                self.tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n+                    if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n+                        self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n+                    }\n+                });\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentOverlapChecker<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &'v hir::Item) {\n+        match item.node {\n+            hir::ItemEnum(..) |\n+            hir::ItemStruct(..) |\n+            hir::ItemTrait(..) |\n+            hir::ItemUnion(..) => {\n+                let type_def_id = self.tcx.hir.local_def_id(item.id);\n+                self.check_for_overlapping_inherent_impls(type_def_id);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n+}\n+\n+pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    tcx.visit_all_item_likes_in_krate(DepNode::CoherenceCheckImpl,\n+                                      &mut InherentCollect { tcx });\n+    tcx.visit_all_item_likes_in_krate(DepNode::CoherenceOverlapCheckSpecial,\n+                                      &mut InherentOverlapChecker { tcx });\n+}"}, {"sha": "9ecf42daeaae52021fd7f60f0a4dfd91de90f3d7", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 79, "deletions": 124, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -15,146 +15,72 @@\n // done by the orphan and overlap modules. Then we build up various\n // mappings. That mapping code resides here.\n \n-use dep_graph::DepTrackingMap;\n-use hir::def_id::DefId;\n-use rustc::ty::{self, maps, TyCtxt, TypeFoldable};\n-use rustc::ty::{Ty, TyBool, TyChar, TyError};\n-use rustc::ty::{TyParam, TyRawPtr};\n-use rustc::ty::{TyRef, TyAdt, TyDynamic, TyNever, TyTuple};\n-use rustc::ty::{TyStr, TyArray, TySlice, TyFloat, TyInfer, TyInt};\n-use rustc::ty::{TyUint, TyClosure, TyFnDef, TyFnPtr};\n-use rustc::ty::{TyProjection, TyAnon};\n-use syntax_pos::Span;\n+use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc::ty::{self, TyCtxt, TypeFoldable};\n+use rustc::ty::maps::Providers;\n use rustc::dep_graph::DepNode;\n-use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::hir::{Item, ItemImpl};\n-use rustc::hir;\n-use std::cell::RefMut;\n+\n+use syntax::ast;\n+use syntax_pos::DUMMY_SP;\n \n mod builtin;\n+mod inherent;\n mod orphan;\n mod overlap;\n mod unsafety;\n \n-struct CoherenceCollect<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    inherent_impls: RefMut<'a, DepTrackingMap<maps::queries::inherent_impls<'tcx>>>,\n-}\n-\n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceCollect<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &Item) {\n-        if let ItemImpl(..) = item.node {\n-            self.check_implementation(item)\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n-    }\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n-    }\n-}\n-\n-impl<'a, 'tcx> CoherenceCollect<'a, 'tcx> {\n-    fn check(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-        let inherent_impls = tcx.maps.inherent_impls.borrow_mut();\n-        let mut this = &mut CoherenceCollect { tcx, inherent_impls };\n-\n-        // Check implementations and traits. This populates the tables\n-        // containing the inherent methods and extension methods. It also\n-        // builds up the trait inheritance table.\n-        tcx.visit_all_item_likes_in_krate(DepNode::CoherenceCheckImpl, this);\n-    }\n+fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n+    let impl_def_id = tcx.hir.local_def_id(node_id);\n \n-    // Returns the def ID of the base type, if there is one.\n-    fn get_base_type_def_id(&self, span: Span, ty: Ty<'tcx>) -> Option<DefId> {\n-        match ty.sty {\n-            TyAdt(def, _) => Some(def.did),\n+    // If there are no traits, then this implementation must have a\n+    // base type.\n \n-            TyDynamic(ref t, ..) => t.principal().map(|p| p.def_id()),\n+    if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n+        debug!(\"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n+                trait_ref,\n+                tcx.item_path_str(impl_def_id));\n \n-            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) | TyStr | TyArray(..) |\n-            TySlice(..) | TyFnDef(..) | TyFnPtr(_) | TyTuple(..) | TyParam(..) | TyError |\n-            TyNever | TyRawPtr(_) | TyRef(..) | TyProjection(..) => None,\n-\n-            TyInfer(..) | TyClosure(..) | TyAnon(..) => {\n-                // `ty` comes from a user declaration so we should only expect types\n-                // that the user can type\n-                span_bug!(span,\n-                          \"coherence encountered unexpected type searching for base type: {}\",\n-                          ty);\n-            }\n+        // Skip impls where one of the self type is an error type.\n+        // This occurs with e.g. resolve failures (#30589).\n+        if trait_ref.references_error() {\n+            return;\n         }\n-    }\n \n-    fn check_implementation(&mut self, item: &Item) {\n-        let tcx = self.tcx;\n-        let impl_did = tcx.hir.local_def_id(item.id);\n-        let self_type = tcx.item_type(impl_did);\n-\n-        // If there are no traits, then this implementation must have a\n-        // base type.\n-\n-        if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_did) {\n-            debug!(\"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n-                   trait_ref,\n-                   item.name);\n-\n-            // Skip impls where one of the self type is an error type.\n-            // This occurs with e.g. resolve failures (#30589).\n-            if trait_ref.references_error() {\n-                return;\n-            }\n-\n-            enforce_trait_manually_implementable(self.tcx, item.span, trait_ref.def_id);\n-            self.add_trait_impl(trait_ref, impl_did);\n-        } else {\n-            // Skip inherent impls where the self type is an error\n-            // type. This occurs with e.g. resolve failures (#30589).\n-            if self_type.references_error() {\n-                return;\n-            }\n-\n-            // Add the implementation to the mapping from implementation to base\n-            // type def ID, if there is a base type for this implementation and\n-            // the implementation does not have any associated traits.\n-            if let Some(base_def_id) = self.get_base_type_def_id(item.span, self_type) {\n-                self.add_inherent_impl(base_def_id, impl_did);\n-            }\n-        }\n+        enforce_trait_manually_implementable(tcx, impl_def_id, trait_ref.def_id);\n+        let trait_def = tcx.lookup_trait_def(trait_ref.def_id);\n+        trait_def.record_local_impl(tcx, impl_def_id, trait_ref);\n     }\n+}\n+\n+fn enforce_trait_manually_implementable(tcx: TyCtxt, impl_def_id: DefId, trait_def_id: DefId) {\n+    let did = Some(trait_def_id);\n+    let li = &tcx.lang_items;\n \n-    fn add_inherent_impl(&mut self, base_def_id: DefId, impl_def_id: DefId) {\n-        // Subtle: it'd be better to collect these into a local map\n-        // and then write the vector only once all items are known,\n-        // but that leads to degenerate dep-graphs. The problem is\n-        // that the write of that big vector winds up having reads\n-        // from *all* impls in the krate, since we've lost the\n-        // precision basically.  This would be ok in the firewall\n-        // model so once we've made progess towards that we can modify\n-        // the strategy here. In the meantime, using `push` is ok\n-        // because we are doing this as a pre-pass before anyone\n-        // actually reads from `inherent_impls` -- and we know this is\n-        // true beacuse we hold the refcell lock.\n-        self.inherent_impls.push(base_def_id, impl_def_id);\n+    // Disallow *all* explicit impls of `Sized` and `Unsize` for now.\n+    if did == li.sized_trait() {\n+        let span = tcx.span_of_impl(impl_def_id).unwrap();\n+        struct_span_err!(tcx.sess,\n+                         span,\n+                         E0322,\n+                         \"explicit impls for the `Sized` trait are not permitted\")\n+            .span_label(span, &format!(\"impl of 'Sized' not allowed\"))\n+            .emit();\n+        return;\n     }\n \n-    fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'tcx>, impl_def_id: DefId) {\n-        debug!(\"add_trait_impl: impl_trait_ref={:?} impl_def_id={:?}\",\n-               impl_trait_ref,\n-               impl_def_id);\n-        let trait_def = self.tcx.lookup_trait_def(impl_trait_ref.def_id);\n-        trait_def.record_local_impl(self.tcx, impl_def_id, impl_trait_ref);\n+    if did == li.unsize_trait() {\n+        let span = tcx.span_of_impl(impl_def_id).unwrap();\n+        span_err!(tcx.sess,\n+                  span,\n+                  E0328,\n+                  \"explicit impls for the `Unsize` trait are not permitted\");\n+        return;\n     }\n-}\n \n-fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: DefId) {\n     if tcx.sess.features.borrow().unboxed_closures {\n-        // the feature gate allows all of them\n+        // the feature gate allows all Fn traits\n         return;\n     }\n-    let did = Some(trait_def_id);\n-    let li = &tcx.lang_items;\n \n     let trait_name = if did == li.fn_trait() {\n         \"Fn\"\n@@ -166,7 +92,7 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: Def\n         return; // everything OK\n     };\n     let mut err = struct_span_err!(tcx.sess,\n-                                   sp,\n+                                   tcx.span_of_impl(impl_def_id).unwrap(),\n                                    E0183,\n                                    \"manual implementations of `{}` are experimental\",\n                                    trait_name);\n@@ -175,12 +101,41 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: Def\n     err.emit();\n }\n \n-pub fn check_coherence<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    CoherenceCollect::check(tcx);\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        coherent_trait,\n+        coherent_inherent_impls,\n+        ..*providers\n+    };\n+}\n \n+fn coherent_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            (_, def_id): (CrateNum, DefId)) {\n+    tcx.populate_implementations_for_trait_if_necessary(def_id);\n+\n+    let impls = tcx.hir.trait_impls(def_id);\n+    for &impl_id in impls {\n+        check_impl(tcx, impl_id);\n+    }\n+    for &impl_id in impls {\n+        overlap::check_impl(tcx, impl_id);\n+    }\n+    builtin::check_trait(tcx, def_id);\n+}\n+\n+fn coherent_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, _: CrateNum) {\n+    inherent::check(tcx);\n+}\n+\n+pub fn check_coherence<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _task = tcx.dep_graph.in_task(DepNode::Coherence);\n+    for &trait_def_id in tcx.hir.krate().trait_impls.keys() {\n+        ty::queries::coherent_trait::get(tcx, DUMMY_SP, (LOCAL_CRATE, trait_def_id));\n+    }\n+\n     unsafety::check(tcx);\n     orphan::check(tcx);\n-    overlap::check(tcx);\n-    builtin::check(tcx);\n+    overlap::check_default_impls(tcx);\n+\n+    ty::queries::coherent_inherent_impls::get(tcx, DUMMY_SP, LOCAL_CRATE);\n }"}, {"sha": "ee361ab6073d4e5c4df5b2029cef9ad10a430da0", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 225, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -11,11 +11,8 @@\n //! Orphan checker: every impl either implements a trait defined in this\n //! crate or pertains to a type defined in this crate.\n \n-use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::traits;\n use rustc::ty::{self, TyCtxt};\n-use syntax::ast;\n-use syntax_pos::Span;\n use rustc::dep_graph::DepNode;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir;\n@@ -29,46 +26,6 @@ struct OrphanChecker<'cx, 'tcx: 'cx> {\n     tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n }\n \n-impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n-    fn check_def_id(&self, item: &hir::Item, def_id: DefId) {\n-        if def_id.krate != LOCAL_CRATE {\n-            struct_span_err!(self.tcx.sess,\n-                             item.span,\n-                             E0116,\n-                             \"cannot define inherent `impl` for a type outside of the crate \\\n-                              where the type is defined\")\n-                .span_label(item.span,\n-                            &format!(\"impl for type defined outside of crate.\"))\n-                .note(\"define and implement a trait or new type instead\")\n-                .emit();\n-        }\n-    }\n-\n-    fn check_primitive_impl(&self,\n-                            impl_def_id: DefId,\n-                            lang_def_id: Option<DefId>,\n-                            lang: &str,\n-                            ty: &str,\n-                            span: Span) {\n-        match lang_def_id {\n-            Some(lang_def_id) if lang_def_id == impl_def_id => {\n-                // OK\n-            }\n-            _ => {\n-                struct_span_err!(self.tcx.sess,\n-                                 span,\n-                                 E0390,\n-                                 \"only a single inherent implementation marked with `#[lang = \\\n-                                  \\\"{}\\\"]` is allowed for the `{}` primitive\",\n-                                 lang,\n-                                 ty)\n-                    .span_help(span, \"consider using a trait to implement these methods\")\n-                    .emit();\n-            }\n-        }\n-    }\n-}\n-\n impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n     /// Checks exactly one impl for orphan rules and other such\n     /// restrictions.  In this fn, it can happen that multiple errors\n@@ -78,168 +35,6 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let def_id = self.tcx.hir.local_def_id(item.id);\n         match item.node {\n-            hir::ItemImpl(.., None, ref ty, _) => {\n-                // For inherent impls, self type must be a nominal type\n-                // defined in this crate.\n-                debug!(\"coherence2::orphan check: inherent impl {}\",\n-                       self.tcx.hir.node_to_string(item.id));\n-                let self_ty = self.tcx.item_type(def_id);\n-                match self_ty.sty {\n-                    ty::TyAdt(def, _) => {\n-                        self.check_def_id(item, def.did);\n-                    }\n-                    ty::TyDynamic(ref data, ..) if data.principal().is_some() => {\n-                        self.check_def_id(item, data.principal().unwrap().def_id());\n-                    }\n-                    ty::TyChar => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.char_impl(),\n-                                                  \"char\",\n-                                                  \"char\",\n-                                                  item.span);\n-                    }\n-                    ty::TyStr => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.str_impl(),\n-                                                  \"str\",\n-                                                  \"str\",\n-                                                  item.span);\n-                    }\n-                    ty::TySlice(_) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.slice_impl(),\n-                                                  \"slice\",\n-                                                  \"[T]\",\n-                                                  item.span);\n-                    }\n-                    ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.const_ptr_impl(),\n-                                                  \"const_ptr\",\n-                                                  \"*const T\",\n-                                                  item.span);\n-                    }\n-                    ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.mut_ptr_impl(),\n-                                                  \"mut_ptr\",\n-                                                  \"*mut T\",\n-                                                  item.span);\n-                    }\n-                    ty::TyInt(ast::IntTy::I8) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.i8_impl(),\n-                                                  \"i8\",\n-                                                  \"i8\",\n-                                                  item.span);\n-                    }\n-                    ty::TyInt(ast::IntTy::I16) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.i16_impl(),\n-                                                  \"i16\",\n-                                                  \"i16\",\n-                                                  item.span);\n-                    }\n-                    ty::TyInt(ast::IntTy::I32) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.i32_impl(),\n-                                                  \"i32\",\n-                                                  \"i32\",\n-                                                  item.span);\n-                    }\n-                    ty::TyInt(ast::IntTy::I64) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.i64_impl(),\n-                                                  \"i64\",\n-                                                  \"i64\",\n-                                                  item.span);\n-                    }\n-                    ty::TyInt(ast::IntTy::I128) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.i128_impl(),\n-                                                  \"i128\",\n-                                                  \"i128\",\n-                                                  item.span);\n-                    }\n-                    ty::TyInt(ast::IntTy::Is) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.isize_impl(),\n-                                                  \"isize\",\n-                                                  \"isize\",\n-                                                  item.span);\n-                    }\n-                    ty::TyUint(ast::UintTy::U8) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.u8_impl(),\n-                                                  \"u8\",\n-                                                  \"u8\",\n-                                                  item.span);\n-                    }\n-                    ty::TyUint(ast::UintTy::U16) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.u16_impl(),\n-                                                  \"u16\",\n-                                                  \"u16\",\n-                                                  item.span);\n-                    }\n-                    ty::TyUint(ast::UintTy::U32) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.u32_impl(),\n-                                                  \"u32\",\n-                                                  \"u32\",\n-                                                  item.span);\n-                    }\n-                    ty::TyUint(ast::UintTy::U64) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.u64_impl(),\n-                                                  \"u64\",\n-                                                  \"u64\",\n-                                                  item.span);\n-                    }\n-                    ty::TyUint(ast::UintTy::U128) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.u128_impl(),\n-                                                  \"u128\",\n-                                                  \"u128\",\n-                                                  item.span);\n-                    }\n-                    ty::TyUint(ast::UintTy::Us) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.usize_impl(),\n-                                                  \"usize\",\n-                                                  \"usize\",\n-                                                  item.span);\n-                    }\n-                    ty::TyFloat(ast::FloatTy::F32) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.f32_impl(),\n-                                                  \"f32\",\n-                                                  \"f32\",\n-                                                  item.span);\n-                    }\n-                    ty::TyFloat(ast::FloatTy::F64) => {\n-                        self.check_primitive_impl(def_id,\n-                                                  self.tcx.lang_items.f64_impl(),\n-                                                  \"f64\",\n-                                                  \"f64\",\n-                                                  item.span);\n-                    }\n-                    ty::TyError => {\n-                        return;\n-                    }\n-                    _ => {\n-                        struct_span_err!(self.tcx.sess,\n-                                         ty.span,\n-                                         E0118,\n-                                         \"no base type found for inherent implementation\")\n-                            .span_label(ty.span, &format!(\"impl requires a base type\"))\n-                            .note(&format!(\"either implement a trait on it or create a newtype \\\n-                                            to wrap it instead\"))\n-                            .emit();\n-                        return;\n-                    }\n-                }\n-            }\n             hir::ItemImpl(.., Some(_), _, _) => {\n                 // \"Trait\" impl\n                 debug!(\"coherence2::orphan check: trait impl {}\",\n@@ -311,7 +106,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                        trait_def_id,\n                        self.tcx.trait_has_default_impl(trait_def_id));\n                 if self.tcx.trait_has_default_impl(trait_def_id) &&\n-                   trait_def_id.krate != LOCAL_CRATE {\n+                   !trait_def_id.is_local() {\n                     let self_ty = trait_ref.self_ty();\n                     let opt_self_def_id = match self_ty.sty {\n                         ty::TyAdt(self_def, _) => Some(self_def.did),\n@@ -346,31 +141,13 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                         return;\n                     }\n                 }\n-\n-                // Disallow *all* explicit impls of `Sized` and `Unsize` for now.\n-                if Some(trait_def_id) == self.tcx.lang_items.sized_trait() {\n-                    struct_span_err!(self.tcx.sess,\n-                                     item.span,\n-                                     E0322,\n-                                     \"explicit impls for the `Sized` trait are not permitted\")\n-                        .span_label(item.span, &format!(\"impl of 'Sized' not allowed\"))\n-                        .emit();\n-                    return;\n-                }\n-                if Some(trait_def_id) == self.tcx.lang_items.unsize_trait() {\n-                    span_err!(self.tcx.sess,\n-                              item.span,\n-                              E0328,\n-                              \"explicit impls for the `Unsize` trait are not permitted\");\n-                    return;\n-                }\n             }\n             hir::ItemDefaultImpl(_, ref item_trait_ref) => {\n                 // \"Trait\" impl\n                 debug!(\"coherence2::orphan check: default trait impl {}\",\n                        self.tcx.hir.node_to_string(item.id));\n                 let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n-                if trait_ref.def_id.krate != LOCAL_CRATE {\n+                if !trait_ref.def_id.is_local() {\n                     struct_span_err!(self.tcx.sess,\n                                      item_trait_ref.path.span,\n                                      E0318,"}, {"sha": "d334d0c4338f9bc843887410dd1945f061f7c1be", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 71, "deletions": 142, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -12,111 +12,110 @@\n //! same type. Likewise, no two inherent impls for a given type\n //! constructor provide a method with the same name.\n \n-use hir::def_id::DefId;\n-use rustc::traits::{self, Reveal};\n+use rustc::traits;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n use syntax::ast;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use util::nodemap::DefIdMap;\n-use lint;\n \n-pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let mut overlap = OverlapChecker {\n-        tcx: tcx,\n-        default_impls: DefIdMap(),\n-    };\n+pub fn check_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    let mut overlap = OverlapChecker { tcx };\n \n     // this secondary walk specifically checks for some other cases,\n     // like defaulted traits, for which additional overlap rules exist\n     tcx.visit_all_item_likes_in_krate(DepNode::CoherenceOverlapCheckSpecial, &mut overlap);\n }\n \n-struct OverlapChecker<'cx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n-\n-    // maps from a trait def-id to an impl id\n-    default_impls: DefIdMap<ast::NodeId>,\n-}\n+pub fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n+    let impl_def_id = tcx.hir.local_def_id(node_id);\n+    let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+    let trait_def_id = trait_ref.def_id;\n \n-impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n-    fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId) {\n-        #[derive(Copy, Clone, PartialEq)]\n-        enum Namespace {\n-            Type,\n-            Value,\n-        }\n+    if trait_ref.references_error() {\n+        debug!(\"coherence: skipping impl {:?} with error {:?}\",\n+               impl_def_id, trait_ref);\n+        return\n+    }\n \n-        let name_and_namespace = |def_id| {\n-            let item = self.tcx.associated_item(def_id);\n-            (item.name, match item.kind {\n-                ty::AssociatedKind::Type => Namespace::Type,\n-                ty::AssociatedKind::Const |\n-                ty::AssociatedKind::Method => Namespace::Value,\n-            })\n-        };\n-\n-        let impl_items1 = self.tcx.associated_item_def_ids(impl1);\n-        let impl_items2 = self.tcx.associated_item_def_ids(impl2);\n-\n-        for &item1 in &impl_items1[..] {\n-            let (name, namespace) = name_and_namespace(item1);\n-\n-            for &item2 in &impl_items2[..] {\n-                if (name, namespace) == name_and_namespace(item2) {\n-                    let msg = format!(\"duplicate definitions with name `{}`\", name);\n-                    let node_id = self.tcx.hir.as_local_node_id(item1).unwrap();\n-                    self.tcx.sess.add_lint(lint::builtin::OVERLAPPING_INHERENT_IMPLS,\n-                                           node_id,\n-                                           self.tcx.span_of_impl(item1).unwrap(),\n-                                           msg);\n-                }\n+    let _task =\n+        tcx.dep_graph.in_task(DepNode::CoherenceOverlapCheck(trait_def_id));\n+\n+    let def = tcx.lookup_trait_def(trait_def_id);\n+\n+    // attempt to insert into the specialization graph\n+    let insert_result = def.add_impl_for_specialization(tcx, impl_def_id);\n+\n+    // insertion failed due to overlap\n+    if let Err(overlap) = insert_result {\n+        let mut err = struct_span_err!(tcx.sess,\n+                                       tcx.span_of_impl(impl_def_id).unwrap(),\n+                                       E0119,\n+                                       \"conflicting implementations of trait `{}`{}:\",\n+                                       overlap.trait_desc,\n+                                       overlap.self_desc.clone().map_or(String::new(),\n+                                                                        |ty| {\n+            format!(\" for type `{}`\", ty)\n+        }));\n+\n+        match tcx.span_of_impl(overlap.with_impl) {\n+            Ok(span) => {\n+                err.span_label(span, &format!(\"first implementation here\"));\n+                err.span_label(tcx.span_of_impl(impl_def_id).unwrap(),\n+                               &format!(\"conflicting implementation{}\",\n+                                        overlap.self_desc\n+                                            .map_or(String::new(),\n+                                                    |ty| format!(\" for `{}`\", ty))));\n+            }\n+            Err(cname) => {\n+                err.note(&format!(\"conflicting implementation in crate `{}`\", cname));\n             }\n         }\n+\n+        err.emit();\n     }\n \n-    fn check_for_overlapping_inherent_impls(&self, ty_def_id: DefId) {\n-        let _task = self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapInherentCheck(ty_def_id));\n-\n-        let inherent_impls = self.tcx.maps.inherent_impls.borrow();\n-        let impls = match inherent_impls.get(&ty_def_id) {\n-            Some(impls) => impls,\n-            None => return,\n-        };\n-\n-        for (i, &impl1_def_id) in impls.iter().enumerate() {\n-            for &impl2_def_id in &impls[(i + 1)..] {\n-                self.tcx.infer_ctxt((), Reveal::ExactMatch).enter(|infcx| {\n-                    if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n-                        self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n-                    }\n-                });\n+    // check for overlap with the automatic `impl Trait for Trait`\n+    if let ty::TyDynamic(ref data, ..) = trait_ref.self_ty().sty {\n+        // This is something like impl Trait1 for Trait2. Illegal\n+        // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n+\n+        if data.principal().map_or(true, |p| !tcx.is_object_safe(p.def_id())) {\n+            // This is an error, but it will be reported by wfcheck.  Ignore it here.\n+            // This is tested by `coherence-impl-trait-for-trait-object-safe.rs`.\n+        } else {\n+            let mut supertrait_def_ids =\n+                traits::supertrait_def_ids(tcx,\n+                                           data.principal().unwrap().def_id());\n+            if supertrait_def_ids.any(|d| d == trait_def_id) {\n+                span_err!(tcx.sess,\n+                          tcx.span_of_impl(impl_def_id).unwrap(),\n+                          E0371,\n+                          \"the object type `{}` automatically \\\n+                           implements the trait `{}`\",\n+                          trait_ref.self_ty(),\n+                          tcx.item_path_str(trait_def_id));\n             }\n         }\n     }\n }\n \n+struct OverlapChecker<'cx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n+}\n+\n impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OverlapChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n-            hir::ItemEnum(..) |\n-            hir::ItemStruct(..) |\n-            hir::ItemTrait(..) |\n-            hir::ItemUnion(..) => {\n-                let type_def_id = self.tcx.hir.local_def_id(item.id);\n-                self.check_for_overlapping_inherent_impls(type_def_id);\n-            }\n-\n             hir::ItemDefaultImpl(..) => {\n                 // look for another default impl; note that due to the\n                 // general orphan/coherence rules, it must always be\n                 // in this crate.\n                 let impl_def_id = self.tcx.hir.local_def_id(item.id);\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n \n-                let prev_default_impl = self.default_impls.insert(trait_ref.def_id, item.id);\n-                if let Some(prev_id) = prev_default_impl {\n+                let prev_id = self.tcx.hir.trait_default_impl(trait_ref.def_id).unwrap();\n+                if prev_id != item.id {\n                     let mut err = struct_span_err!(self.tcx.sess,\n                                                    self.tcx.span_of_impl(impl_def_id).unwrap(),\n                                                    E0521,\n@@ -131,76 +130,6 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 }\n             }\n             hir::ItemImpl(.., Some(_), _, _) => {\n-                let impl_def_id = self.tcx.hir.local_def_id(item.id);\n-                let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n-                let trait_def_id = trait_ref.def_id;\n-\n-                if trait_ref.references_error() {\n-                    debug!(\"coherence: skipping impl {:?} with error {:?}\",\n-                           impl_def_id, trait_ref);\n-                    return\n-                }\n-\n-                let _task =\n-                    self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapCheck(trait_def_id));\n-\n-                let def = self.tcx.lookup_trait_def(trait_def_id);\n-\n-                // attempt to insert into the specialization graph\n-                let insert_result = def.add_impl_for_specialization(self.tcx, impl_def_id);\n-\n-                // insertion failed due to overlap\n-                if let Err(overlap) = insert_result {\n-                    let mut err = struct_span_err!(self.tcx.sess,\n-                                                   self.tcx.span_of_impl(impl_def_id).unwrap(),\n-                                                   E0119,\n-                                                   \"conflicting implementations of trait `{}`{}:\",\n-                                                   overlap.trait_desc,\n-                                                   overlap.self_desc.clone().map_or(String::new(),\n-                                                                                    |ty| {\n-                        format!(\" for type `{}`\", ty)\n-                    }));\n-\n-                    match self.tcx.span_of_impl(overlap.with_impl) {\n-                        Ok(span) => {\n-                            err.span_label(span, &format!(\"first implementation here\"));\n-                            err.span_label(self.tcx.span_of_impl(impl_def_id).unwrap(),\n-                                           &format!(\"conflicting implementation{}\",\n-                                                    overlap.self_desc\n-                                                        .map_or(String::new(),\n-                                                                |ty| format!(\" for `{}`\", ty))));\n-                        }\n-                        Err(cname) => {\n-                            err.note(&format!(\"conflicting implementation in crate `{}`\", cname));\n-                        }\n-                    }\n-\n-                    err.emit();\n-                }\n-\n-                // check for overlap with the automatic `impl Trait for Trait`\n-                if let ty::TyDynamic(ref data, ..) = trait_ref.self_ty().sty {\n-                    // This is something like impl Trait1 for Trait2. Illegal\n-                    // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n-\n-                    if data.principal().map_or(true, |p| !self.tcx.is_object_safe(p.def_id())) {\n-                        // This is an error, but it will be reported by wfcheck.  Ignore it here.\n-                        // This is tested by `coherence-impl-trait-for-trait-object-safe.rs`.\n-                    } else {\n-                        let mut supertrait_def_ids =\n-                            traits::supertrait_def_ids(self.tcx,\n-                                                       data.principal().unwrap().def_id());\n-                        if supertrait_def_ids.any(|d| d == trait_def_id) {\n-                            span_err!(self.tcx.sess,\n-                                      item.span,\n-                                      E0371,\n-                                      \"the object type `{}` automatically \\\n-                                       implements the trait `{}`\",\n-                                      trait_ref.self_ty(),\n-                                      self.tcx.item_path_str(trait_def_id));\n-                        }\n-                    }\n-                }\n             }\n             _ => {}\n         }"}, {"sha": "22247d2531aec32e821417765016ae4de0e0017f", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -31,20 +31,7 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n                                 unsafety: hir::Unsafety,\n                                 polarity: hir::ImplPolarity) {\n         match self.tcx.impl_trait_ref(self.tcx.hir.local_def_id(item.id)) {\n-            None => {\n-                // Inherent impl.\n-                match unsafety {\n-                    hir::Unsafety::Normal => {\n-                        // OK\n-                    }\n-                    hir::Unsafety::Unsafe => {\n-                        span_err!(self.tcx.sess,\n-                                  item.span,\n-                                  E0197,\n-                                  \"inherent impls cannot be declared as unsafe\");\n-                    }\n-                }\n-            }\n+            None => {}\n \n             Some(trait_ref) => {\n                 let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id);\n@@ -100,7 +87,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n             hir::ItemDefaultImpl(unsafety, _) => {\n                 self.check_unsafety_coherence(item, None, unsafety, hir::ImplPolarity::Positive);\n             }\n-            hir::ItemImpl(unsafety, polarity, ref generics, ..) => {\n+            hir::ItemImpl(unsafety, polarity, ref generics, Some(_), _, _) => {\n                 self.check_unsafety_coherence(item, Some(generics), unsafety, polarity);\n             }\n             _ => {}"}, {"sha": "ecdbf170702aabef6cdd94d762c6d8e40a00698d", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -519,9 +519,7 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &hir::Item) {\n             convert_enum_variant_types(tcx, def_id, &enum_definition.variants);\n         },\n         hir::ItemDefaultImpl(..) => {\n-            if let Some(trait_ref) = tcx.impl_trait_ref(def_id) {\n-                tcx.record_trait_has_default_impl(trait_ref.def_id);\n-            }\n+            tcx.impl_trait_ref(def_id);\n         }\n         hir::ItemImpl(..) => {\n             tcx.item_generics(def_id);\n@@ -869,7 +867,13 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let def_path_hash = tcx.def_path(def_id).deterministic_hash(tcx);\n-    tcx.alloc_trait_def(ty::TraitDef::new(def_id, unsafety, paren_sugar, def_path_hash))\n+    let def = ty::TraitDef::new(def_id, unsafety, paren_sugar, def_path_hash);\n+\n+    if tcx.hir.trait_is_auto(def_id) {\n+        def.record_has_default_impl();\n+    }\n+\n+    tcx.alloc_trait_def(def)\n }\n \n fn generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "2c325d46c0bc060ff3e8b1aa4c6ca90a4bfad11e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -155,7 +155,7 @@ fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 expected: Ty<'tcx>,\n                                 actual: Ty<'tcx>)\n                                 -> bool {\n-    tcx.infer_ctxt((), Reveal::NotSpecializable).enter(|infcx| {\n+    tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n         match infcx.eq_types(false, &cause, expected, actual) {\n             Ok(InferOk { obligations, .. }) => {\n                 // FIXME(#32730) propagate obligations\n@@ -287,6 +287,7 @@ fn check_for_entry_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n pub fn provide(providers: &mut Providers) {\n     collect::provide(providers);\n+    coherence::provide(providers);\n     check::provide(providers);\n }\n "}, {"sha": "c4476483186c7a35ed1de6bb20e9de0e52ff179f", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -15,6 +15,7 @@ use std::io;\n use std::iter::once;\n \n use syntax::ast;\n+use syntax_pos::DUMMY_SP;\n use rustc::hir;\n \n use rustc::hir::def::{Def, CtorKind};\n@@ -231,7 +232,7 @@ fn build_type_alias(cx: &DocContext, did: DefId) -> clean::Typedef {\n \n pub fn build_impls(cx: &DocContext, did: DefId) -> Vec<clean::Item> {\n     let tcx = cx.tcx;\n-    tcx.populate_inherent_implementations_for_type_if_necessary(did);\n+    tcx.populate_inherent_implementations_for_type_if_necessary(DUMMY_SP, did);\n     let mut impls = Vec::new();\n \n     if let Some(i) = tcx.maps.inherent_impls.borrow().get(&did) {"}, {"sha": "3da00da205fec27e1d827b0a08d613a9ee59fbd4", "filename": "src/test/compile-fail/E0117.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Ftest%2Fcompile-fail%2FE0117.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Ftest%2Fcompile-fail%2FE0117.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0117.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -12,6 +12,8 @@ impl Drop for u32 {} //~ ERROR E0117\n //~^ NOTE impl doesn't use types inside crate\n //~| NOTE the impl does not reference any types defined in this crate\n //~| NOTE define and implement a trait or new type instead\n+//~| ERROR the Drop trait may only be implemented on structures\n+//~| implementing Drop requires a struct\n \n fn main() {\n }"}, {"sha": "aac870293fd5500ae27a04fbf764f2b016d1a026", "filename": "src/test/compile-fail/coherence-cross-crate-conflict.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Ftest%2Fcompile-fail%2Fcoherence-cross-crate-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Ftest%2Fcompile-fail%2Fcoherence-cross-crate-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-cross-crate-conflict.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -17,6 +17,7 @@ use trait_impl_conflict::Foo;\n \n impl<A> Foo for A {\n     //~^ ERROR type parameter `A` must be used as the type parameter for some local type\n+    //~| ERROR conflicting implementations of trait `trait_impl_conflict::Foo` for type `isize`\n }\n \n fn main() {"}, {"sha": "15a80c64f8b0621fcd07d054ba4580a01e914377", "filename": "src/test/compile-fail/coherence-default-trait-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -13,9 +13,9 @@\n trait MyTrait {}\n \n impl MyTrait for .. {}\n+//~^ ERROR redundant default implementations of trait `MyTrait`\n \n impl MyTrait for .. {}\n-//~^ ERROR redundant default implementations of trait `MyTrait`\n \n trait MySafeTrait {}\n "}, {"sha": "60b5d14d1587a9f9706defd1eb3a56c2b4c169d6", "filename": "src/test/compile-fail/coherence-impls-sized.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -27,14 +27,20 @@ impl Sized for TestE {} //~ ERROR E0322\n impl Sized for MyType {} //~ ERROR E0322\n //~^ impl of 'Sized' not allowed\n \n-impl Sized for (MyType, MyType) {} //~ ERROR E0117\n+impl Sized for (MyType, MyType) {} //~ ERROR E0322\n+//~^ impl of 'Sized' not allowed\n+//~| ERROR E0117\n \n impl Sized for &'static NotSync {} //~ ERROR E0322\n //~^ impl of 'Sized' not allowed\n \n-impl Sized for [MyType] {} //~ ERROR E0117\n+impl Sized for [MyType] {} //~ ERROR E0322\n+//~^ impl of 'Sized' not allowed\n+//~| ERROR E0117\n \n-impl Sized for &'static [NotSync] {} //~ ERROR E0117\n+impl Sized for &'static [NotSync] {} //~ ERROR E0322\n+//~^ impl of 'Sized' not allowed\n+//~| ERROR E0117\n \n fn main() {\n }"}, {"sha": "4fe6afaca8ec658a4eae9fdba79b35dc37cacb29", "filename": "src/test/ui/span/E0204.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Ftest%2Fui%2Fspan%2FE0204.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Ftest%2Fui%2Fspan%2FE0204.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0204.stderr?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -7,15 +7,6 @@ error[E0204]: the trait `Copy` may not be implemented for this type\n 15 | impl Copy for Foo { }\n    |      ^^^^\n \n-error[E0204]: the trait `Copy` may not be implemented for this type\n-  --> $DIR/E0204.rs:27:6\n-   |\n-23 |     Bar { x: Vec<u32> },\n-   |           ----------- this field does not implement `Copy`\n-...\n-27 | impl Copy for EFoo { }\n-   |      ^^^^\n-\n error[E0204]: the trait `Copy` may not be implemented for this type\n   --> $DIR/E0204.rs:17:10\n    |\n@@ -25,6 +16,15 @@ error[E0204]: the trait `Copy` may not be implemented for this type\n 19 |     ty: &'a mut bool,\n    |     ---------------- this field does not implement `Copy`\n \n+error[E0204]: the trait `Copy` may not be implemented for this type\n+  --> $DIR/E0204.rs:27:6\n+   |\n+23 |     Bar { x: Vec<u32> },\n+   |           ----------- this field does not implement `Copy`\n+...\n+27 | impl Copy for EFoo { }\n+   |      ^^^^\n+\n error[E0204]: the trait `Copy` may not be implemented for this type\n   --> $DIR/E0204.rs:29:10\n    |"}]}