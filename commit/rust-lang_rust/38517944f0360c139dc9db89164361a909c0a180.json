{"sha": "38517944f0360c139dc9db89164361a909c0a180", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NTE3OTQ0ZjAzNjBjMTM5ZGM5ZGI4OTE2NDM2MWE5MDljMGExODA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-03T23:47:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-03T23:47:02Z"}, "message": "Auto merge of #26783 - eddyb:methrec, r=huonw\n\nAfter #26694, the overloaded operator and \"impl not known at method lookup time\" cases started triggering the lint.\r\nI've also added checks for overloaded autoderef and method calls via paths (i.e. `T::method()`).\r\nAll new 8 test cases did not trigger the lint before #26694.\r\nr? @huonw", "tree": {"sha": "b1f5e979b95444b9e75234b181f23a88b25214c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1f5e979b95444b9e75234b181f23a88b25214c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38517944f0360c139dc9db89164361a909c0a180", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38517944f0360c139dc9db89164361a909c0a180", "html_url": "https://github.com/rust-lang/rust/commit/38517944f0360c139dc9db89164361a909c0a180", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38517944f0360c139dc9db89164361a909c0a180/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ceded6adb3a4e172eabef09e1c78717a99c16b14", "url": "https://api.github.com/repos/rust-lang/rust/commits/ceded6adb3a4e172eabef09e1c78717a99c16b14", "html_url": "https://github.com/rust-lang/rust/commit/ceded6adb3a4e172eabef09e1c78717a99c16b14"}, {"sha": "585f0e928b0e88e6da8d7203ef5d077147569ce0", "url": "https://api.github.com/repos/rust-lang/rust/commits/585f0e928b0e88e6da8d7203ef5d077147569ce0", "html_url": "https://github.com/rust-lang/rust/commit/585f0e928b0e88e6da8d7203ef5d077147569ce0"}], "stats": {"total": 343, "additions": 215, "deletions": 128}, "files": [{"sha": "b3ddd3869cb9f6fea45a048fb4defdc2977677b7", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=38517944f0360c139dc9db89164361a909c0a180", "patch": "@@ -299,15 +299,7 @@ fn item_to_def_like(cdata: Cmd, item: rbml::Doc, did: ast::DefId) -> DefLike {\n         Constant  => {\n             // Check whether we have an associated const item.\n             if item_sort(item) == Some('C') {\n-                // Check whether the associated const is from a trait or impl.\n-                // See the comment for methods below.\n-                let provenance = if reader::maybe_get_doc(\n-                      item, tag_item_trait_parent_sort).is_some() {\n-                    def::FromTrait(item_require_parent_item(cdata, item))\n-                } else {\n-                    def::FromImpl(item_require_parent_item(cdata, item))\n-                };\n-                DlDef(def::DefAssociatedConst(did, provenance))\n+                DlDef(def::DefAssociatedConst(did))\n             } else {\n                 // Regular const item.\n                 DlDef(def::DefConst(did))\n@@ -319,18 +311,7 @@ fn item_to_def_like(cdata: Cmd, item: rbml::Doc, did: ast::DefId) -> DefLike {\n         Fn        => DlDef(def::DefFn(did, false)),\n         CtorFn    => DlDef(def::DefFn(did, true)),\n         Method | StaticMethod => {\n-            // def_static_method carries an optional field of its enclosing\n-            // trait or enclosing impl (if this is an inherent static method).\n-            // So we need to detect whether this is in a trait or not, which\n-            // we do through the mildly hacky way of checking whether there is\n-            // a trait_parent_sort.\n-            let provenance = if reader::maybe_get_doc(\n-                  item, tag_item_trait_parent_sort).is_some() {\n-                def::FromTrait(item_require_parent_item(cdata, item))\n-            } else {\n-                def::FromImpl(item_require_parent_item(cdata, item))\n-            };\n-            DlDef(def::DefMethod(did, provenance))\n+            DlDef(def::DefMethod(did))\n         }\n         Type => {\n             if item_sort(item) == Some('t') {"}, {"sha": "5c3b0a1c2d246be127de646f04b1c9b560741e45", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=38517944f0360c139dc9db89164361a909c0a180", "patch": "@@ -444,9 +444,7 @@ impl tr for def::Def {\n     fn tr(&self, dcx: &DecodeContext) -> def::Def {\n         match *self {\n           def::DefFn(did, is_ctor) => def::DefFn(did.tr(dcx), is_ctor),\n-          def::DefMethod(did, p) => {\n-            def::DefMethod(did.tr(dcx), p.map(|did2| did2.tr(dcx)))\n-          }\n+          def::DefMethod(did) => def::DefMethod(did.tr(dcx)),\n           def::DefSelfTy(opt_did, impl_ids) => { def::DefSelfTy(opt_did.map(|did| did.tr(dcx)),\n                                                                 impl_ids.map(|(nid1, nid2)| {\n                                                                     (dcx.tr_id(nid1),\n@@ -456,9 +454,7 @@ impl tr for def::Def {\n           def::DefForeignMod(did) => { def::DefForeignMod(did.tr(dcx)) }\n           def::DefStatic(did, m) => { def::DefStatic(did.tr(dcx), m) }\n           def::DefConst(did) => { def::DefConst(did.tr(dcx)) }\n-          def::DefAssociatedConst(did, p) => {\n-              def::DefAssociatedConst(did.tr(dcx), p.map(|did2| did2.tr(dcx)))\n-          }\n+          def::DefAssociatedConst(did) => def::DefAssociatedConst(did.tr(dcx)),\n           def::DefLocal(nid) => { def::DefLocal(dcx.tr_id(nid)) }\n           def::DefVariant(e_did, v_did, is_s) => {\n             def::DefVariant(e_did.tr(dcx), v_did.tr(dcx), is_s)"}, {"sha": "9667312b37057a65cebd864e648dc08b349b1c47", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=38517944f0360c139dc9db89164361a909c0a180", "patch": "@@ -650,7 +650,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                     }\n                 }\n                 Some(def::DefConst(did)) |\n-                Some(def::DefAssociatedConst(did, _)) => {\n+                Some(def::DefAssociatedConst(did)) => {\n                     if let Some(expr) = const_eval::lookup_const_by_id(v.tcx, did,\n                                                                        Some(e.id)) {\n                         let inner = v.global_expr(Mode::Const, expr);\n@@ -696,10 +696,17 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                     v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                     true\n                 }\n-                Some(def::DefMethod(did, def::FromImpl(_))) |\n                 Some(def::DefFn(did, _)) => {\n                     v.handle_const_fn_call(e, did, node_ty)\n                 }\n+                Some(def::DefMethod(did)) => {\n+                    match v.tcx.impl_or_trait_item(did).container() {\n+                        ty::ImplContainer(_) => {\n+                            v.handle_const_fn_call(e, did, node_ty)\n+                        }\n+                        ty::TraitContainer(_) => false\n+                    }\n+                }\n                 _ => false\n             };\n             if !is_const {"}, {"sha": "f17cb673a5f2d670b6989a343d170cb1a91c68e9", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=38517944f0360c139dc9db89164361a909c0a180", "patch": "@@ -442,7 +442,7 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n             ast::PatIdent(..) | ast::PatEnum(..) | ast::PatQPath(..) => {\n                 let def = self.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def());\n                 match def {\n-                    Some(DefAssociatedConst(did, _)) |\n+                    Some(DefAssociatedConst(did)) |\n                     Some(DefConst(did)) => match lookup_const_by_id(self.tcx, did, Some(pat.id)) {\n                         Some(const_expr) => {\n                             const_expr_to_pat(self.tcx, const_expr, pat.span).map(|new_pat| {"}, {"sha": "77bb53a77bc943809713abd49a3f1829e3edfa23", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=38517944f0360c139dc9db89164361a909c0a180", "patch": "@@ -238,7 +238,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n             ast::ExprPath(..) => {\n                 match self.def_map.borrow().get(&e.id).map(|d| d.base_def) {\n                     Some(DefStatic(def_id, _)) |\n-                    Some(DefAssociatedConst(def_id, _)) |\n+                    Some(DefAssociatedConst(def_id)) |\n                     Some(DefConst(def_id))\n                            if ast_util::is_local(def_id) => {\n                         match self.ast_map.get(def_id.node) {"}, {"sha": "fd1c8d4892a10bfef7932efe7f731c704499b521", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=38517944f0360c139dc9db89164361a909c0a180", "patch": "@@ -41,7 +41,7 @@ fn lookup_const<'a>(tcx: &'a ty::ctxt, e: &Expr) -> Option<&'a Expr> {\n     let opt_def = tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n     match opt_def {\n         Some(def::DefConst(def_id)) |\n-        Some(def::DefAssociatedConst(def_id, _)) => {\n+        Some(def::DefAssociatedConst(def_id)) => {\n             lookup_const_by_id(tcx, def_id, Some(e.id))\n         }\n         Some(def::DefVariant(enum_def, variant_def, _)) => {\n@@ -929,10 +929,10 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       (lookup_const_by_id(tcx, def_id, Some(e.id)), None)\n                   }\n               }\n-              Some(def::DefAssociatedConst(def_id, provenance)) => {\n+              Some(def::DefAssociatedConst(def_id)) => {\n                   if ast_util::is_local(def_id) {\n-                      match provenance {\n-                          def::FromTrait(trait_id) => match tcx.map.find(def_id.node) {\n+                      match tcx.impl_or_trait_item(def_id).container() {\n+                          ty::TraitContainer(trait_id) => match tcx.map.find(def_id.node) {\n                               Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n                                   ast::ConstTraitItem(ref ty, _) => {\n                                       if let ExprTypeChecked = ty_hint {\n@@ -950,7 +950,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                               },\n                               _ => (None, None)\n                           },\n-                          def::FromImpl(_) => match tcx.map.find(def_id.node) {\n+                          ty::ImplContainer(_) => match tcx.map.find(def_id.node) {\n                               Some(ast_map::NodeImplItem(ii)) => match ii.node {\n                                   ast::ConstImplItem(ref ty, ref expr) => {\n                                       (Some(&**expr), Some(&**ty))"}, {"sha": "36c6630c8227b0dd7b909df7732fd4de91402dea", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=38517944f0360c139dc9db89164361a909c0a180", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n pub use self::Def::*;\n-pub use self::MethodProvenance::*;\n \n use middle::privacy::LastPrivate;\n use middle::subst::ParamSpace;\n@@ -28,7 +27,7 @@ pub enum Def {\n     DefForeignMod(ast::DefId),\n     DefStatic(ast::DefId, bool /* is_mutbl */),\n     DefConst(ast::DefId),\n-    DefAssociatedConst(ast::DefId /* const */, MethodProvenance),\n+    DefAssociatedConst(ast::DefId),\n     DefLocal(ast::NodeId),\n     DefVariant(ast::DefId /* enum */, ast::DefId /* variant */, bool /* is_structure */),\n     DefTy(ast::DefId, bool /* is_enum */),\n@@ -51,7 +50,7 @@ pub enum Def {\n     DefStruct(ast::DefId),\n     DefRegion(ast::NodeId),\n     DefLabel(ast::NodeId),\n-    DefMethod(ast::DefId /* method */, MethodProvenance),\n+    DefMethod(ast::DefId),\n }\n \n /// The result of resolving a path.\n@@ -112,23 +111,6 @@ pub struct Export {\n     pub def_id: ast::DefId, // The definition of the target.\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum MethodProvenance {\n-    FromTrait(ast::DefId),\n-    FromImpl(ast::DefId),\n-}\n-\n-impl MethodProvenance {\n-    pub fn map<F>(self, f: F) -> MethodProvenance where\n-        F: FnOnce(ast::DefId) -> ast::DefId,\n-    {\n-        match self {\n-            FromTrait(did) => FromTrait(f(did)),\n-            FromImpl(did) => FromImpl(f(did))\n-        }\n-    }\n-}\n-\n impl Def {\n     pub fn local_node_id(&self) -> ast::NodeId {\n         let def_id = self.def_id();\n@@ -141,7 +123,7 @@ impl Def {\n             DefFn(id, _) | DefMod(id) | DefForeignMod(id) | DefStatic(id, _) |\n             DefVariant(_, id, _) | DefTy(id, _) | DefAssociatedTy(_, id) |\n             DefTyParam(_, _, id, _) | DefUse(id) | DefStruct(id) | DefTrait(id) |\n-            DefMethod(id, _) | DefConst(id) | DefAssociatedConst(id, _) |\n+            DefMethod(id) | DefConst(id) | DefAssociatedConst(id) |\n             DefSelfTy(Some(id), None)=> {\n                 id\n             }"}, {"sha": "ffd09326abc35aba550c6c1f57608e11d03837ce", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 53, "deletions": 15, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=38517944f0360c139dc9db89164361a909c0a180", "patch": "@@ -33,7 +33,6 @@\n \n use metadata::{csearch, decoder};\n use middle::{cfg, def, infer, pat_util, stability, traits};\n-use middle::def::*;\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use middle::const_eval::{eval_const_expr_partial, ConstVal};\n@@ -2251,34 +2250,73 @@ impl LintPass for UnconditionalRecursion {\n             }\n         }\n \n-        // Check if the method call `id` refers to method `method`.\n+        // Check if the expression `id` performs a call to `method`.\n         fn expr_refers_to_this_method(tcx: &ty::ctxt,\n                                       method: &ty::Method,\n                                       id: ast::NodeId) -> bool {\n-            let method_call = ty::MethodCall::expr(id);\n-            let callee = match tcx.tables.borrow().method_map.get(&method_call) {\n-                Some(&m) => m,\n-                None => return false\n-            };\n-            let callee_item = tcx.impl_or_trait_item(callee.def_id);\n+            let tables = tcx.tables.borrow();\n+\n+            // Check for method calls and overloaded operators.\n+            if let Some(m) = tables.method_map.get(&ty::MethodCall::expr(id)) {\n+                if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n+                    return true;\n+                }\n+            }\n+\n+            // Check for overloaded autoderef method calls.\n+            if let Some(&ty::AdjustDerefRef(ref adj)) = tables.adjustments.get(&id) {\n+                for i in 0..adj.autoderefs {\n+                    let method_call = ty::MethodCall::autoderef(id, i as u32);\n+                    if let Some(m) = tables.method_map.get(&method_call) {\n+                        if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Check for calls to methods via explicit paths (e.g. `T::method()`).\n+            match tcx.map.get(id) {\n+                ast_map::NodeExpr(&ast::Expr { node: ast::ExprCall(ref callee, _), .. }) => {\n+                    match tcx.def_map.borrow().get(&callee.id).map(|d| d.full_def()) {\n+                        Some(def::DefMethod(def_id)) => {\n+                            let no_substs = &ty::ItemSubsts::empty();\n+                            let ts = tables.item_substs.get(&callee.id).unwrap_or(no_substs);\n+                            method_call_refers_to_method(tcx, method, def_id, &ts.substs, id)\n+                        }\n+                        _ => false\n+                    }\n+                }\n+                _ => false\n+            }\n+        }\n+\n+        // Check if the method call to the method with the ID `callee_id`\n+        // and instantiated with `callee_substs` refers to method `method`.\n+        fn method_call_refers_to_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                              method: &ty::Method,\n+                                              callee_id: ast::DefId,\n+                                              callee_substs: &Substs<'tcx>,\n+                                              expr_id: ast::NodeId) -> bool {\n+            let callee_item = tcx.impl_or_trait_item(callee_id);\n \n             match callee_item.container() {\n                 // This is an inherent method, so the `def_id` refers\n                 // directly to the method definition.\n                 ty::ImplContainer(_) => {\n-                    callee.def_id == method.def_id\n+                    callee_id == method.def_id\n                 }\n \n                 // A trait method, from any number of possible sources.\n                 // Attempt to select a concrete impl before checking.\n                 ty::TraitContainer(trait_def_id) => {\n-                    let trait_substs = callee.substs.clone().method_to_trait();\n+                    let trait_substs = callee_substs.clone().method_to_trait();\n                     let trait_substs = tcx.mk_substs(trait_substs);\n                     let trait_ref = ty::TraitRef::new(trait_def_id, trait_substs);\n                     let trait_ref = ty::Binder(trait_ref);\n-                    let span = tcx.map.span(id);\n+                    let span = tcx.map.span(expr_id);\n                     let obligation =\n-                        traits::Obligation::new(traits::ObligationCause::misc(span, id),\n+                        traits::Obligation::new(traits::ObligationCause::misc(span, expr_id),\n                                                 trait_ref.to_poly_trait_predicate());\n \n                     let param_env = ty::ParameterEnvironment::for_item(tcx, method.def_id.node);\n@@ -2289,12 +2327,12 @@ impl LintPass for UnconditionalRecursion {\n                         // If `T` is `Self`, then this call is inside\n                         // a default method definition.\n                         Ok(Some(traits::VtableParam(_))) => {\n-                            let self_ty = callee.substs.self_ty();\n+                            let self_ty = callee_substs.self_ty();\n                             let on_self = self_ty.map_or(false, |t| t.is_self());\n                             // We can only be recurring in a default\n                             // method if we're being called literally\n                             // on the `Self` type.\n-                            on_self && callee.def_id == method.def_id\n+                            on_self && callee_id == method.def_id\n                         }\n \n                         // The `impl` is known, so we check that with a\n@@ -2454,7 +2492,7 @@ impl LintPass for MutableTransmutes {\n                 ast::ExprPath(..) => (),\n                 _ => return None\n             }\n-            if let DefFn(did, _) = cx.tcx.resolve_expr(expr) {\n+            if let def::DefFn(did, _) = cx.tcx.resolve_expr(expr) {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }"}, {"sha": "656d6a36614706d3d2eb4375b21be2cb6723398d", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=38517944f0360c139dc9db89164361a909c0a180", "patch": "@@ -545,14 +545,12 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                     match trait_item.node {\n                         ast::ConstTraitItem(..) => {\n-                            let def = DefAssociatedConst(local_def(trait_item.id),\n-                                                         FromTrait(local_def(item.id)));\n+                            let def = DefAssociatedConst(local_def(trait_item.id));\n                             // NB: not DefModifiers::IMPORTABLE\n                             name_bindings.define_value(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n                         ast::MethodTraitItem(..) => {\n-                            let def = DefMethod(local_def(trait_item.id),\n-                                                FromTrait(local_def(item.id)));\n+                            let def = DefMethod(local_def(trait_item.id));\n                             // NB: not DefModifiers::IMPORTABLE\n                             name_bindings.define_value(def, trait_item.span, DefModifiers::PUBLIC);\n                         }"}, {"sha": "c1f8af1562db373c741e7b446228174360f1ab6c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=38517944f0360c139dc9db89164361a909c0a180", "patch": "@@ -3448,7 +3448,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Look for a method in the current self type's impl module.\n         if let Some(module) = get_module(self, path.span, &name_path) {\n             if let Some(binding) = module.children.borrow().get(&name) {\n-                if let Some(DefMethod(did, _)) = binding.def_for_namespace(ValueNS) {\n+                if let Some(DefMethod(did)) = binding.def_for_namespace(ValueNS) {\n                     if is_static_method(self, did) {\n                         return StaticMethod(path_names_to_string(&path, 0))\n                     }"}, {"sha": "1fbec6f66cfdf237aa04c30f20412bb6c4330e0d", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=38517944f0360c139dc9db89164361a909c0a180", "patch": "@@ -719,7 +719,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         let def_map = self.tcx.def_map.borrow();\n         let def = def_map.get(&id).unwrap().full_def();\n         match def {\n-            def::DefMethod(did, _) => {\n+            def::DefMethod(did) => {\n                 let ti = self.tcx.impl_or_trait_item(did);\n                 if let ty::MethodTraitItem(m) = ti {\n                     if m.explicit_self == ty::StaticExplicitSelfCategory {"}, {"sha": "796850ad6f28b95f24cf483b78f424b558d7985b", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=38517944f0360c139dc9db89164361a909c0a180", "patch": "@@ -551,20 +551,20 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     scope: self.enclosing_scope(id),\n                 }))\n             }\n-            def::DefMethod(decl_id, provenence) => {\n+            def::DefMethod(decl_id) => {\n                 let sub_span = self.span_utils.sub_span_for_meth_name(path.span);\n                 let def_id = if decl_id.krate == ast::LOCAL_CRATE {\n                     let ti = self.tcx.impl_or_trait_item(decl_id);\n-                    match provenence {\n-                        def::FromTrait(def_id) => {\n+                    match ti.container() {\n+                        ty::TraitContainer(def_id) => {\n                             self.tcx.trait_items(def_id)\n                                 .iter()\n                                 .find(|mr| {\n                                     mr.name() == ti.name() && self.trait_method_has_body(mr)\n                                 })\n                                 .map(|mr| mr.def_id())\n                         }\n-                        def::FromImpl(def_id) => {\n+                        ty::ImplContainer(def_id) => {\n                             let impl_items = self.tcx.impl_items.borrow();\n                             Some(impl_items.get(&def_id)\n                                            .unwrap()"}, {"sha": "a60217be40988591e10229a953ed3ae545f0b48b", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=38517944f0360c139dc9db89164361a909c0a180", "patch": "@@ -159,16 +159,27 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 let def_id = inline::maybe_instantiate_inline(bcx.ccx(), did);\n                 Callee { bcx: bcx, data: Intrinsic(def_id.node, substs), ty: expr_ty }\n             }\n-            def::DefFn(did, _) | def::DefMethod(did, def::FromImpl(_)) => {\n+            def::DefFn(did, _) => {\n                 fn_callee(bcx, trans_fn_ref(bcx.ccx(), did, ExprId(ref_expr.id),\n                                             bcx.fcx.param_substs))\n             }\n-            def::DefMethod(meth_did, def::FromTrait(trait_did)) => {\n-                fn_callee(bcx, meth::trans_static_method_callee(bcx.ccx(),\n-                                                                meth_did,\n-                                                                trait_did,\n-                                                                ref_expr.id,\n-                                                                bcx.fcx.param_substs))\n+            def::DefMethod(meth_did) => {\n+                let method_item = bcx.tcx().impl_or_trait_item(meth_did);\n+                let fn_datum = match method_item.container() {\n+                    ty::ImplContainer(_) => {\n+                        trans_fn_ref(bcx.ccx(), meth_did,\n+                                     ExprId(ref_expr.id),\n+                                     bcx.fcx.param_substs)\n+                    }\n+                    ty::TraitContainer(trait_did) => {\n+                        meth::trans_static_method_callee(bcx.ccx(),\n+                                                         meth_did,\n+                                                         trait_did,\n+                                                         ref_expr.id,\n+                                                         bcx.fcx.param_substs)\n+                    }\n+                };\n+                fn_callee(bcx, fn_datum)\n             }\n             def::DefVariant(tid, vid, _) => {\n                 let vinfo = bcx.tcx().enum_variant_with_id(tid, vid);"}, {"sha": "71ba4d73dace090bfc77b2d3f2521e06ad620f77", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=38517944f0360c139dc9db89164361a909c0a180", "patch": "@@ -229,7 +229,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ast::ExprPath(..) => {\n             let def = ccx.tcx().def_map.borrow().get(&expr.id).unwrap().full_def();\n             match def {\n-                def::DefConst(def_id) | def::DefAssociatedConst(def_id, _) => {\n+                def::DefConst(def_id) | def::DefAssociatedConst(def_id) => {\n                     if !ccx.tcx().tables.borrow().adjustments.contains_key(&expr.id) {\n                         debug!(\"get_const_expr_as_global ({:?}): found const {:?}\",\n                                expr.id, def_id);\n@@ -802,7 +802,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 def::DefFn(..) | def::DefMethod(..) => {\n                     expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n                 }\n-                def::DefConst(def_id) | def::DefAssociatedConst(def_id, _) => {\n+                def::DefConst(def_id) | def::DefAssociatedConst(def_id) => {\n                     const_deref_ptr(cx, get_const_val(cx, def_id, e))\n                 }\n                 def::DefVariant(enum_did, variant_did, _) => {\n@@ -846,32 +846,32 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let def = cx.tcx().def_map.borrow()[&callee.id].full_def();\n             let arg_vals = map_list(args);\n             match def {\n-                def::DefFn(did, _) | def::DefMethod(did, _) => {\n+                def::DefFn(did, _) | def::DefMethod(did) => {\n                     const_fn_call(cx, ExprId(callee.id), did, &arg_vals, param_substs)\n-                },\n+                }\n                 def::DefStruct(_) => {\n                     if ety.is_simd(cx.tcx()) {\n                         C_vector(&arg_vals[..])\n                     } else {\n                         let repr = adt::represent_type(cx, ety);\n                         adt::trans_const(cx, &*repr, 0, &arg_vals[..])\n                     }\n-                },\n+                }\n                 def::DefVariant(enum_did, variant_did, _) => {\n                     let repr = adt::represent_type(cx, ety);\n                     let vinfo = cx.tcx().enum_variant_with_id(enum_did, variant_did);\n                     adt::trans_const(cx,\n                                      &*repr,\n                                      vinfo.disr_val,\n                                      &arg_vals[..])\n-                },\n+                }\n                 _ => cx.sess().span_bug(e.span, \"expected a struct, variant, or const fn def\"),\n             }\n         },\n         ast::ExprMethodCall(_, _, ref args) => {\n             let arg_vals = map_list(args);\n             let method_call = ty::MethodCall::expr(e.id);\n-              let method_did = cx.tcx().tables.borrow().method_map[&method_call].def_id;\n+            let method_did = cx.tcx().tables.borrow().method_map[&method_call].def_id;\n             const_fn_call(cx, MethodCallKey(method_call),\n                           method_did, &arg_vals, param_substs)\n         },"}, {"sha": "619447df3c551a621a660f46dd4a21a946b6b888", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=38517944f0360c139dc9db89164361a909c0a180", "patch": "@@ -1293,14 +1293,22 @@ pub fn trans_def_fn_unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     match def {\n         def::DefFn(did, _) |\n-        def::DefStruct(did) | def::DefVariant(_, did, _) |\n-        def::DefMethod(did, def::FromImpl(_)) => {\n+        def::DefStruct(did) | def::DefVariant(_, did, _) => {\n             callee::trans_fn_ref(ccx, did, ExprId(ref_expr.id), param_substs)\n         }\n-        def::DefMethod(impl_did, def::FromTrait(trait_did)) => {\n-            meth::trans_static_method_callee(ccx, impl_did,\n-                                             trait_did, ref_expr.id,\n-                                             param_substs)\n+        def::DefMethod(method_did) => {\n+            match ccx.tcx().impl_or_trait_item(method_did).container() {\n+                ty::ImplContainer(_) => {\n+                    callee::trans_fn_ref(ccx, method_did,\n+                                         ExprId(ref_expr.id),\n+                                         param_substs)\n+                }\n+                ty::TraitContainer(trait_did) => {\n+                    meth::trans_static_method_callee(ccx, method_did,\n+                                                     trait_did, ref_expr.id,\n+                                                     param_substs)\n+                }\n+            }\n         }\n         _ => {\n             ccx.tcx().sess.span_bug(ref_expr.span, &format!("}, {"sha": "fd5d8d8d1961f9e5a308d3bc7d3e547389be59be", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=38517944f0360c139dc9db89164361a909c0a180", "patch": "@@ -334,19 +334,14 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let pick = try!(probe::probe(fcx, span, mode, method_name, self_ty, expr_id));\n     let def_id = pick.item.def_id();\n     let mut lp = LastMod(AllPublic);\n-    let container_def_id = pick.item.container().id();\n-    let provenance = match pick.kind {\n-        probe::InherentImplPick => {\n-            if pick.item.vis() != ast::Public {\n-                lp = LastMod(DependsOn(def_id));\n-            }\n-            def::FromImpl(container_def_id)\n+    if let probe::InherentImplPick = pick.kind {\n+        if pick.item.vis() != ast::Public {\n+            lp = LastMod(DependsOn(def_id));\n         }\n-        _ => def::FromTrait(container_def_id)\n-    };\n+    }\n     let def_result = match pick.item {\n-        ty::ImplOrTraitItem::MethodTraitItem(..) => def::DefMethod(def_id, provenance),\n-        ty::ImplOrTraitItem::ConstTraitItem(..) => def::DefAssociatedConst(def_id, provenance),\n+        ty::ImplOrTraitItem::MethodTraitItem(..) => def::DefMethod(def_id),\n+        ty::ImplOrTraitItem::ConstTraitItem(..) => def::DefAssociatedConst(def_id),\n         ty::ImplOrTraitItem::TypeTraitItem(..) => {\n             fcx.tcx().sess.span_bug(span, \"resolve_ufcs: probe picked associated type\");\n         }"}, {"sha": "6851fb4667015b8cd9faf685151668f3ea4acacd", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=38517944f0360c139dc9db89164361a909c0a180", "patch": "@@ -4447,9 +4447,9 @@ fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             (ty::TypeScheme { generics: ty::Generics::empty(), ty: typ },\n              ty::GenericPredicates::empty())\n         }\n-        def::DefFn(id, _) | def::DefMethod(id, _) |\n+        def::DefFn(id, _) | def::DefMethod(id) |\n         def::DefStatic(id, _) | def::DefVariant(_, id, _) |\n-        def::DefStruct(id) | def::DefConst(id) | def::DefAssociatedConst(id, _) => {\n+        def::DefStruct(id) | def::DefConst(id) | def::DefAssociatedConst(id) => {\n             (fcx.tcx().lookup_item_type(id), fcx.tcx().lookup_predicates(id))\n         }\n         def::DefTrait(_) |\n@@ -4555,7 +4555,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     assert!(!segments.is_empty());\n \n-    let mut ufcs_method = None;\n+    let mut ufcs_associated = None;\n     let mut segment_spaces: Vec<_>;\n     match def {\n         // Case 1 and 1b. Reference to a *type* or *enum variant*.\n@@ -4582,12 +4582,13 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         // Case 3. Reference to a method.\n-        def::DefMethod(_, provenance) => {\n-            match provenance {\n-                def::FromTrait(trait_did) => {\n+        def::DefMethod(def_id) => {\n+            let container = fcx.tcx().impl_or_trait_item(def_id).container();\n+            match container {\n+                ty::TraitContainer(trait_did) => {\n                     callee::check_legal_trait_for_method_call(fcx.ccx, span, trait_did)\n                 }\n-                def::FromImpl(_) => {}\n+                ty::ImplContainer(_) => {}\n             }\n \n             if segments.len() >= 2 {\n@@ -4598,24 +4599,28 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 // `<T>::method` will end up here, and so can `T::method`.\n                 let self_ty = opt_self_ty.expect(\"UFCS sugared method missing Self\");\n                 segment_spaces = vec![Some(subst::FnSpace)];\n-                ufcs_method = Some((provenance, self_ty));\n+                ufcs_associated = Some((container, self_ty));\n             }\n         }\n \n-        def::DefAssociatedConst(_, provenance) => {\n-            match provenance {\n-                def::FromTrait(trait_did) => {\n+        def::DefAssociatedConst(def_id) => {\n+            let container = fcx.tcx().impl_or_trait_item(def_id).container();\n+            match container {\n+                ty::TraitContainer(trait_did) => {\n                     callee::check_legal_trait_for_method_call(fcx.ccx, span, trait_did)\n                 }\n-                def::FromImpl(_) => {}\n+                ty::ImplContainer(_) => {}\n             }\n \n             if segments.len() >= 2 {\n                 segment_spaces = vec![None; segments.len() - 2];\n                 segment_spaces.push(Some(subst::TypeSpace));\n                 segment_spaces.push(None);\n             } else {\n+                // `<T>::CONST` will end up here, and so can `T::CONST`.\n+                let self_ty = opt_self_ty.expect(\"UFCS sugared const missing Self\");\n                 segment_spaces = vec![None];\n+                ufcs_associated = Some((container, self_ty));\n             }\n         }\n \n@@ -4637,7 +4642,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // In `<T as Trait<A, B>>::method`, `A` and `B` are mandatory, but\n     // `opt_self_ty` can also be Some for `Foo::method`, where Foo's\n     // type parameters are not mandatory.\n-    let require_type_space = opt_self_ty.is_some() && ufcs_method.is_none();\n+    let require_type_space = opt_self_ty.is_some() && ufcs_associated.is_none();\n \n     debug!(\"segment_spaces={:?}\", segment_spaces);\n \n@@ -4707,7 +4712,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let ty_substituted = fcx.instantiate_type_scheme(span, &substs, &type_scheme.ty);\n \n \n-    if let Some((def::FromImpl(impl_def_id), self_ty)) = ufcs_method {\n+    if let Some((ty::ImplContainer(impl_def_id), self_ty)) = ufcs_associated {\n         // In the case of `Foo<T>::method` and `<Foo<T>>::method`, if `method`\n         // is inherent, there is no `Self` parameter, instead, the impl needs\n         // type parameters, which we can infer by unifying the provided `Self`"}, {"sha": "31cd8ce1b53e53385e6d481862a8821c8aaf4d65", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38517944f0360c139dc9db89164361a909c0a180/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=38517944f0360c139dc9db89164361a909c0a180", "patch": "@@ -107,7 +107,7 @@ fn try_inline_def(cx: &DocContext, tcx: &ty::ctxt,\n             record_extern_fqn(cx, did, clean::TypeStatic);\n             clean::StaticItem(build_static(cx, tcx, did, mtbl))\n         }\n-        def::DefConst(did) | def::DefAssociatedConst(did, _) => {\n+        def::DefConst(did) | def::DefAssociatedConst(did) => {\n             record_extern_fqn(cx, did, clean::TypeConst);\n             clean::ConstantItem(build_const(cx, tcx, did))\n         }"}, {"sha": "6e3a00746f3e6107bcd3654e5f41a57fdc57bef4", "filename": "src/test/compile-fail/lint-unconditional-recursion.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/38517944f0360c139dc9db89164361a909c0a180/src%2Ftest%2Fcompile-fail%2Flint-unconditional-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38517944f0360c139dc9db89164361a909c0a180/src%2Ftest%2Fcompile-fail%2Flint-unconditional-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unconditional-recursion.rs?ref=38517944f0360c139dc9db89164361a909c0a180", "patch": "@@ -41,6 +41,7 @@ fn quz() -> bool { //~ ERROR function cannot return without recurring\n     }\n }\n \n+// Trait method calls.\n trait Foo {\n     fn bar(&self) { //~ ERROR function cannot return without recurring\n         self.bar() //~ NOTE recursive call site\n@@ -53,14 +54,79 @@ impl Foo for Box<Foo+'static> {\n             self.bar() //~ NOTE recursive call site\n         }\n     }\n+}\n+\n+// Trait method call with integer fallback after method resolution.\n+impl Foo for i32 {\n+    fn bar(&self) { //~ ERROR function cannot return without recurring\n+        0.bar() //~ NOTE recursive call site\n+    }\n+}\n+\n+impl Foo for u32 {\n+    fn bar(&self) {\n+        0.bar()\n+    }\n+}\n \n+// Trait method calls via paths.\n+trait Foo2 {\n+    fn bar(&self) { //~ ERROR function cannot return without recurring\n+        Foo2::bar(self) //~ NOTE recursive call site\n+    }\n+}\n+\n+impl Foo2 for Box<Foo2+'static> {\n+    fn bar(&self) { //~ ERROR function cannot return without recurring\n+        loop {\n+            Foo2::bar(self) //~ NOTE recursive call site\n+        }\n+    }\n }\n \n struct Baz;\n impl Baz {\n+    // Inherent method call.\n     fn qux(&self) { //~ ERROR function cannot return without recurring\n         self.qux(); //~ NOTE recursive call site\n     }\n+\n+    // Inherent method call via path.\n+    fn as_ref(&self) -> &Self { //~ ERROR function cannot return without recurring\n+        Baz::as_ref(self) //~ NOTE recursive call site\n+    }\n+}\n+\n+// Trait method calls to impls via paths.\n+impl Default for Baz {\n+    fn default() -> Baz { //~ ERROR function cannot return without recurring\n+        let x = Default::default(); //~ NOTE recursive call site\n+        x\n+    }\n+}\n+\n+// Overloaded operators.\n+impl std::ops::Deref for Baz {\n+    type Target = ();\n+    fn deref(&self) -> &() { //~ ERROR function cannot return without recurring\n+        &**self //~ NOTE recursive call site\n+    }\n+}\n+\n+impl std::ops::Index<usize> for Baz {\n+    type Output = Baz;\n+    fn index(&self, x: usize) -> &Baz { //~ ERROR function cannot return without recurring\n+        &self[x] //~ NOTE recursive call site\n+    }\n+}\n+\n+// Overloaded autoderef.\n+struct Quux;\n+impl std::ops::Deref for Quux {\n+    type Target = Baz;\n+    fn deref(&self) -> &Baz { //~ ERROR function cannot return without recurring\n+        self.as_ref() //~ NOTE recursive call site\n+    }\n }\n \n fn all_fine() {"}]}