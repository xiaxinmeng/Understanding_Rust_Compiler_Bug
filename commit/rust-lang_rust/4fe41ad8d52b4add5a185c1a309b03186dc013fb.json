{"sha": "4fe41ad8d52b4add5a185c1a309b03186dc013fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmZTQxYWQ4ZDUyYjRhZGQ1YTE4NWMxYTMwOWIwMzE4NmRjMDEzZmI=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-12-17T11:09:57Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-12-17T11:09:57Z"}, "message": "Refactor PrimVal::bits() out of existence.", "tree": {"sha": "78e6421d414f3b3e983ca5f6adee84f04d25ec74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78e6421d414f3b3e983ca5f6adee84f04d25ec74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fe41ad8d52b4add5a185c1a309b03186dc013fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fe41ad8d52b4add5a185c1a309b03186dc013fb", "html_url": "https://github.com/rust-lang/rust/commit/4fe41ad8d52b4add5a185c1a309b03186dc013fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fe41ad8d52b4add5a185c1a309b03186dc013fb/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e244251a0c05ba5c06fd94970b01d11cfbb73f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e244251a0c05ba5c06fd94970b01d11cfbb73f1", "html_url": "https://github.com/rust-lang/rust/commit/9e244251a0c05ba5c06fd94970b01d11cfbb73f1"}], "stats": {"total": 162, "additions": 91, "deletions": 71}, "files": [{"sha": "2b3194a59940c42b6d7dab7a35fff219c65a557c", "filename": "src/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fe41ad8d52b4add5a185c1a309b03186dc013fb/src%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe41ad8d52b4add5a185c1a309b03186dc013fb/src%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcast.rs?ref=4fe41ad8d52b4add5a185c1a309b03186dc013fb", "patch": "@@ -20,9 +20,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             F32 => self.cast_float(val.to_f32()? as f64, dest_ty),\n             F64 => self.cast_float(val.to_f64()?, dest_ty),\n \n-            I8 | I16 | I32 | I64 => self.cast_signed_int(val.bits() as i64, dest_ty),\n+            I8 | I16 | I32 | I64 => self.cast_signed_int(val.to_i64()?, dest_ty),\n \n-            Bool | Char | U8 | U16 | U32 | U64 => self.cast_int(val.bits(), dest_ty, false),\n+            Bool | Char | U8 | U16 | U32 | U64 => self.cast_int(val.to_u64()?, dest_ty, false),\n \n             FnPtr | Ptr => self.cast_ptr(val.to_ptr()?, dest_ty),\n         }"}, {"sha": "7696a70f379a146c5511bc586e0bbeb78afb649b", "filename": "src/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fe41ad8d52b4add5a185c1a309b03186dc013fb/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe41ad8d52b4add5a185c1a309b03186dc013fb/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=4fe41ad8d52b4add5a185c1a309b03186dc013fb", "patch": "@@ -1093,10 +1093,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     fn ensure_valid_value(&self, val: PrimVal, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n         match ty.sty {\n-            ty::TyBool if val.bits() > 1 => Err(EvalError::InvalidBool),\n+            ty::TyBool if val.to_bytes()? > 1 => Err(EvalError::InvalidBool),\n \n-            ty::TyChar if ::std::char::from_u32(val.bits() as u32).is_none()\n-                => Err(EvalError::InvalidChar(val.bits() as u32 as u64)),\n+            ty::TyChar if ::std::char::from_u32(val.to_bytes()? as u32).is_none()\n+                => Err(EvalError::InvalidChar(val.to_bytes()? as u32 as u64)),\n \n             _ => Ok(()),\n         }"}, {"sha": "d65bf7f14500709d0e6964374f416dcd546355e4", "filename": "src/memory.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4fe41ad8d52b4add5a185c1a309b03186dc013fb/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe41ad8d52b4add5a185c1a309b03186dc013fb/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=4fe41ad8d52b4add5a185c1a309b03186dc013fb", "patch": "@@ -77,8 +77,7 @@ impl Pointer {\n \n     pub fn to_int<'tcx>(&self) -> EvalResult<'tcx, u64> {\n         match self.alloc_id {\n-            NEVER_ALLOC_ID |\n-            ZST_ALLOC_ID => Ok(self.offset),\n+            NEVER_ALLOC_ID => Ok(self.offset),\n             _ => Err(EvalError::ReadPointerAsBytes),\n         }\n     }"}, {"sha": "1cf929b886684be9e19afbea941cfc365405383d", "filename": "src/operator.rs", "status": "modified", "additions": 52, "deletions": 28, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/4fe41ad8d52b4add5a185c1a309b03186dc013fb/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe41ad8d52b4add5a185c1a309b03186dc013fb/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=4fe41ad8d52b4add5a185c1a309b03186dc013fb", "patch": "@@ -139,16 +139,38 @@ pub fn binary_op<'tcx>(\n     use rustc::mir::BinOp::*;\n     use value::PrimValKind::*;\n \n-    // If the pointers are into the same allocation, fall through to the more general match\n-    // later, which will do comparisons on the `bits` fields, which are the pointer offsets\n-    // in this case.\n-    let left_ptr = left.to_ptr()?;\n-    let right_ptr = right.to_ptr()?;\n-    if left_ptr.alloc_id != right_ptr.alloc_id {\n-        return Ok((unrelated_ptr_ops(bin_op, left_ptr, right_ptr)?, false));\n+    // FIXME(solson): Temporary hack. It will go away when we get rid of Pointer's ability to store\n+    // plain bytes, and leave that to PrimVal::Bytes.\n+    fn normalize(val: PrimVal) -> PrimVal {\n+        if let PrimVal::Ptr(ptr) = val {\n+            if let Ok(bytes) = ptr.to_int() {\n+                return PrimVal::Bytes(bytes);\n+            }\n+        }\n+        val\n     }\n+    let (left, right) = (normalize(left), normalize(right));\n+\n+    let (l, r) = match (left, right) {\n+        (PrimVal::Bytes(left_bytes), PrimVal::Bytes(right_bytes)) => (left_bytes, right_bytes),\n+\n+        (PrimVal::Ptr(left_ptr), PrimVal::Ptr(right_ptr)) => {\n+            if left_ptr.alloc_id == right_ptr.alloc_id {\n+                // If the pointers are into the same allocation, fall through to the more general\n+                // match later, which will do comparisons on the pointer offsets.\n+                (left_ptr.offset, right_ptr.offset)\n+            } else {\n+                return Ok((unrelated_ptr_ops(bin_op, left_ptr, right_ptr)?, false));\n+            }\n+        }\n+\n+        (PrimVal::Ptr(ptr), PrimVal::Bytes(bytes)) |\n+        (PrimVal::Bytes(bytes), PrimVal::Ptr(ptr)) => {\n+            return Ok((unrelated_ptr_ops(bin_op, ptr, Pointer::from_int(bytes))?, false));\n+        }\n \n-    let (l, r) = (left.bits(), right.bits());\n+        (PrimVal::Undef, _) | (_, PrimVal::Undef) => return Err(EvalError::ReadUndefBytes),\n+    };\n \n     // These ops can have an RHS with a different numeric type.\n     if bin_op == Shl || bin_op == Shr {\n@@ -165,11 +187,11 @@ pub fn binary_op<'tcx>(\n \n         // Cast to `u32` because `overflowing_sh{l,r}` only take `u32`, then apply the bitmask\n         // to ensure it's within the valid shift value range.\n-        let r = (right.bits() as u32) & (type_bits - 1);\n+        let masked_shift_width = (r as u32) & (type_bits - 1);\n \n         return match bin_op {\n-            Shl => int_shift!(left_kind, overflowing_shl, l, r),\n-            Shr => int_shift!(left_kind, overflowing_shr, l, r),\n+            Shl => int_shift!(left_kind, overflowing_shl, l, masked_shift_width),\n+            Shr => int_shift!(left_kind, overflowing_shr, l, masked_shift_width),\n             _ => bug!(\"it has already been checked that this is a shift op\"),\n         };\n     }\n@@ -253,32 +275,34 @@ pub fn unary_op<'tcx>(\n     use rustc::mir::UnOp::*;\n     use value::PrimValKind::*;\n \n-    let bits = match (un_op, val_kind) {\n-        (Not, Bool) => !bits_to_bool(val.bits()) as u64,\n+    let bytes = val.to_bytes()?;\n+\n+    let result_bytes = match (un_op, val_kind) {\n+        (Not, Bool) => !bits_to_bool(bytes) as u64,\n \n-        (Not, U8)  => !(val.bits() as u8) as u64,\n-        (Not, U16) => !(val.bits() as u16) as u64,\n-        (Not, U32) => !(val.bits() as u32) as u64,\n-        (Not, U64) => !val.bits(),\n+        (Not, U8)  => !(bytes as u8) as u64,\n+        (Not, U16) => !(bytes as u16) as u64,\n+        (Not, U32) => !(bytes as u32) as u64,\n+        (Not, U64) => !bytes,\n \n-        (Not, I8)  => !(val.bits() as i8) as u64,\n-        (Not, I16) => !(val.bits() as i16) as u64,\n-        (Not, I32) => !(val.bits() as i32) as u64,\n-        (Not, I64) => !(val.bits() as i64) as u64,\n+        (Not, I8)  => !(bytes as i8) as u64,\n+        (Not, I16) => !(bytes as i16) as u64,\n+        (Not, I32) => !(bytes as i32) as u64,\n+        (Not, I64) => !(bytes as i64) as u64,\n \n-        (Neg, I8)  => -(val.bits() as i8) as u64,\n-        (Neg, I16) => -(val.bits() as i16) as u64,\n-        (Neg, I32) => -(val.bits() as i32) as u64,\n-        (Neg, I64) => -(val.bits() as i64) as u64,\n+        (Neg, I8)  => -(bytes as i8) as u64,\n+        (Neg, I16) => -(bytes as i16) as u64,\n+        (Neg, I32) => -(bytes as i32) as u64,\n+        (Neg, I64) => -(bytes as i64) as u64,\n \n-        (Neg, F32) => f32_to_bits(-bits_to_f32(val.bits())),\n-        (Neg, F64) => f64_to_bits(-bits_to_f64(val.bits())),\n+        (Neg, F32) => f32_to_bits(-bits_to_f32(bytes)),\n+        (Neg, F64) => f64_to_bits(-bits_to_f64(bytes)),\n \n         _ => {\n             let msg = format!(\"unimplemented unary op: {:?}, {:?}\", un_op, val);\n             return Err(EvalError::Unimplemented(msg));\n         }\n     };\n \n-    Ok(PrimVal::Bytes(bits))\n+    Ok(PrimVal::Bytes(result_bytes))\n }"}, {"sha": "a25d10d05aeaee53ce57dfe1712c25f4e3ad95b8", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4fe41ad8d52b4add5a185c1a309b03186dc013fb/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe41ad8d52b4add5a185c1a309b03186dc013fb/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=4fe41ad8d52b4add5a185c1a309b03186dc013fb", "patch": "@@ -163,7 +163,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ty = substs.type_at(0);\n                 let num = self.value_to_primval(arg_vals[0], ty)?;\n                 let kind = self.ty_to_primval_kind(ty)?;\n-                let num = numeric_intrinsic(intrinsic_name, num, kind);\n+                let num = numeric_intrinsic(intrinsic_name, num, kind)?;\n                 self.write_primval(dest, num, ty)?;\n             }\n \n@@ -501,33 +501,40 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n }\n \n-macro_rules! integer_intrinsic {\n-    ($name:expr, $val:expr, $kind:expr, $method:ident) => ({\n-        let val = $val;\n-\n-        use value::PrimValKind::*;\n-        let bits = match $kind {\n-            I8 => (val.bits() as i8).$method() as u64,\n-            U8 => (val.bits() as u8).$method() as u64,\n-            I16 => (val.bits() as i16).$method() as u64,\n-            U16 => (val.bits() as u16).$method() as u64,\n-            I32 => (val.bits() as i32).$method() as u64,\n-            U32 => (val.bits() as u32).$method() as u64,\n-            I64 => (val.bits() as i64).$method() as u64,\n-            U64 => (val.bits() as u64).$method() as u64,\n-            _ => bug!(\"invalid `{}` argument: {:?}\", $name, val),\n-        };\n-\n-        PrimVal::Bytes(bits)\n-    });\n-}\n+fn numeric_intrinsic<'tcx>(\n+    name: &str,\n+    val: PrimVal,\n+    kind: PrimValKind\n+) -> EvalResult<'tcx, PrimVal> {\n+    macro_rules! integer_intrinsic {\n+        ($name:expr, $val:expr, $kind:expr, $method:ident) => ({\n+            let val = $val;\n+            let bytes = val.to_bytes()?;\n+\n+            use value::PrimValKind::*;\n+            let result_bytes = match $kind {\n+                I8 => (bytes as i8).$method() as u64,\n+                U8 => (bytes as u8).$method() as u64,\n+                I16 => (bytes as i16).$method() as u64,\n+                U16 => (bytes as u16).$method() as u64,\n+                I32 => (bytes as i32).$method() as u64,\n+                U32 => (bytes as u32).$method() as u64,\n+                I64 => (bytes as i64).$method() as u64,\n+                U64 => bytes.$method() as u64,\n+                _ => bug!(\"invalid `{}` argument: {:?}\", $name, val),\n+            };\n+\n+            PrimVal::Bytes(result_bytes)\n+        });\n+    }\n \n-fn numeric_intrinsic(name: &str, val: PrimVal, kind: PrimValKind) -> PrimVal {\n-    match name {\n+    let result_val = match name {\n         \"bswap\" => integer_intrinsic!(\"bswap\", val, kind, swap_bytes),\n         \"ctlz\"  => integer_intrinsic!(\"ctlz\",  val, kind, leading_zeros),\n         \"ctpop\" => integer_intrinsic!(\"ctpop\", val, kind, count_ones),\n         \"cttz\"  => integer_intrinsic!(\"cttz\",  val, kind, trailing_zeros),\n         _       => bug!(\"not a numeric intrinsic: {}\", name),\n-    }\n+    };\n+\n+    Ok(result_val)\n }"}, {"sha": "b4cad215b77aacff90ea2cdd6591066e77c23e3d", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fe41ad8d52b4add5a185c1a309b03186dc013fb/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe41ad8d52b4add5a185c1a309b03186dc013fb/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=4fe41ad8d52b4add5a185c1a309b03186dc013fb", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 for (index, const_val) in values.iter().enumerate() {\n                     let val = self.const_to_value(const_val)?;\n                     let prim = self.value_to_primval(val, discr_ty)?;\n-                    if discr_prim.bits() == prim.bits() {\n+                    if discr_prim.to_bytes()? == prim.to_bytes()? {\n                         target_block = targets[index];\n                         break;\n                     }"}, {"sha": "05acb68436dc048af73ca41e9dbd88e2c28d9172", "filename": "src/value.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4fe41ad8d52b4add5a185c1a309b03186dc013fb/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fe41ad8d52b4add5a185c1a309b03186dc013fb/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=4fe41ad8d52b4add5a185c1a309b03186dc013fb", "patch": "@@ -117,16 +117,6 @@ impl<'a, 'tcx: 'a> Value {\n }\n \n impl<'tcx> PrimVal {\n-    // FIXME(solson): Remove this. It's a temporary function to aid refactoring, but it shouldn't\n-    // stick around with this name.\n-    pub fn bits(self) -> u64 {\n-        match self {\n-            PrimVal::Bytes(b) => b,\n-            PrimVal::Ptr(p) => p.offset,\n-            PrimVal::Undef => panic!(\".bits()() on PrimVal::Undef\"),\n-        }\n-    }\n-\n     pub fn from_u64(n: u64) -> Self {\n         PrimVal::Bytes(n)\n     }\n@@ -151,7 +141,7 @@ impl<'tcx> PrimVal {\n         PrimVal::Bytes(c as u64)\n     }\n \n-    fn to_bytes(self) -> EvalResult<'tcx, u64> {\n+    pub fn to_bytes(self) -> EvalResult<'tcx, u64> {\n         match self {\n             PrimVal::Bytes(b) => Ok(b),\n             PrimVal::Ptr(p) => p.to_int(),"}]}