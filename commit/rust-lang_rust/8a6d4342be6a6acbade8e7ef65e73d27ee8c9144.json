{"sha": "8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhNmQ0MzQyYmU2YTZhY2JhZGU4ZTdlZjY1ZTczZDI3ZWU4YzkxNDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-02T12:35:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-02T12:35:08Z"}, "message": "Auto merge of #73954 - Manishearth:rollup-8qvh170, r=Manishearth\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #73414 (Implement `slice_strip` feature)\n - #73564 (linker: Create GNU_EH_FRAME header by default when producing ELFs)\n - #73622 (Deny unsafe ops in unsafe fns in libcore)\n - #73684 (add spans to injected coverage counters, extract with CoverageData query)\n - #73812 (ast_pretty: Pass some token streams and trees by reference)\n - #73853 (Add newline to rustc MultiSpan docs)\n - #73883 (Compile rustdoc less often.)\n - #73885 (Fix wasm32 being broken due to a NodeJS version bump)\n - #73903 (Changes required for rustc/cargo to build for iOS targets)\n - #73938 (Optimise fast path of checked_ops with `unlikely`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "bdb127fa9e94e052cdae4c50e5212d8080863342", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdb127fa9e94e052cdae4c50e5212d8080863342"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "html_url": "https://github.com/rust-lang/rust/commit/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7856f695d65a8ebc846754f97d15814bcb1c244", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7856f695d65a8ebc846754f97d15814bcb1c244", "html_url": "https://github.com/rust-lang/rust/commit/b7856f695d65a8ebc846754f97d15814bcb1c244"}, {"sha": "4f536f2c36622328e7eb1d859cb74ba0a7d34ac8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f536f2c36622328e7eb1d859cb74ba0a7d34ac8", "html_url": "https://github.com/rust-lang/rust/commit/4f536f2c36622328e7eb1d859cb74ba0a7d34ac8"}], "stats": {"total": 2420, "additions": 1790, "deletions": 630}, "files": [{"sha": "1e75e67af0c9e17f847e5e63255ad1d41e2d8feb", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -54,6 +54,11 @@ fn dist_baseline() {\n         &[dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },]\n     );\n     assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    // Make sure rustdoc is only built once.\n+    assert_eq!(\n+        first(builder.cache.all::<tool::Rustdoc>()),\n+        &[tool::Rustdoc { compiler: Compiler { host: a, stage: 2 } },]\n+    );\n }\n \n #[test]\n@@ -414,3 +419,77 @@ fn test_exclude() {\n     // Ensure other tests are not affected.\n     assert!(builder.cache.contains::<test::RustdocUi>());\n }\n+\n+#[test]\n+fn doc_default() {\n+    let mut config = configure(&[], &[]);\n+    config.compiler_docs = true;\n+    config.cmd = Subcommand::Doc { paths: Vec::new(), open: false };\n+    let build = Build::new(config);\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Doc), &[]);\n+    let a = INTERNER.intern_str(\"A\");\n+\n+    // error_index_generator uses stage 1 to share rustdoc artifacts with the\n+    // rustdoc tool.\n+    assert_eq!(\n+        first(builder.cache.all::<doc::ErrorIndex>()),\n+        &[doc::ErrorIndex { compiler: Compiler { host: a, stage: 1 }, target: a },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<tool::ErrorIndex>()),\n+        &[tool::ErrorIndex { compiler: Compiler { host: a, stage: 1 } }]\n+    );\n+    // This is actually stage 1, but Rustdoc::run swaps out the compiler with\n+    // stage minus 1 if --stage is not 0. Very confusing!\n+    assert_eq!(\n+        first(builder.cache.all::<tool::Rustdoc>()),\n+        &[tool::Rustdoc { compiler: Compiler { host: a, stage: 2 } },]\n+    );\n+}\n+\n+#[test]\n+fn test_docs() {\n+    // Behavior of `x.py test` doing various documentation tests.\n+    let mut config = configure(&[], &[]);\n+    config.cmd = Subcommand::Test {\n+        paths: vec![],\n+        test_args: vec![],\n+        rustc_args: vec![],\n+        fail_fast: true,\n+        doc_tests: DocTests::Yes,\n+        bless: false,\n+        compare_mode: None,\n+        rustfix_coverage: false,\n+        pass: None,\n+    };\n+    let build = Build::new(config);\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n+    let a = INTERNER.intern_str(\"A\");\n+\n+    // error_index_generator uses stage 1 to share rustdoc artifacts with the\n+    // rustdoc tool.\n+    assert_eq!(\n+        first(builder.cache.all::<doc::ErrorIndex>()),\n+        &[doc::ErrorIndex { compiler: Compiler { host: a, stage: 1 }, target: a },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<tool::ErrorIndex>()),\n+        &[tool::ErrorIndex { compiler: Compiler { host: a, stage: 1 } }]\n+    );\n+    // Unfortunately rustdoc is built twice. Once from stage1 for compiletest\n+    // (and other things), and once from stage0 for std crates. Ideally it\n+    // would only be built once. If someone wants to fix this, it might be\n+    // worth investigating if it would be possible to test std from stage1.\n+    // Note that the stages here are +1 than what they actually are because\n+    // Rustdoc::run swaps out the compiler with stage minus 1 if --stage is\n+    // not 0.\n+    assert_eq!(\n+        first(builder.cache.all::<tool::Rustdoc>()),\n+        &[\n+            tool::Rustdoc { compiler: Compiler { host: a, stage: 1 } },\n+            tool::Rustdoc { compiler: Compiler { host: a, stage: 2 } },\n+        ]\n+    );\n+}"}, {"sha": "d02c19467ee68da0b9b420a038f7bdf8d6eb43e5", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -518,8 +518,7 @@ impl Step for Rustc {\n         let out = builder.compiler_doc_out(target);\n         t!(fs::create_dir_all(&out));\n \n-        // Get the correct compiler for this stage.\n-        let compiler = builder.compiler_for(stage, builder.config.build, target);\n+        let compiler = builder.compiler(stage, builder.config.build);\n \n         if !builder.config.compiler_docs {\n             builder.info(\"\\tskipping - compiler/librustdoc docs disabled\");\n@@ -599,8 +598,7 @@ impl Step for Rustdoc {\n         let out = builder.compiler_doc_out(target);\n         t!(fs::create_dir_all(&out));\n \n-        // Get the correct compiler for this stage.\n-        let compiler = builder.compiler_for(stage, builder.config.build, target);\n+        let compiler = builder.compiler(stage, builder.config.build);\n \n         if !builder.config.compiler_docs {\n             builder.info(\"\\tskipping - compiler/librustdoc docs disabled\");\n@@ -639,9 +637,10 @@ impl Step for Rustdoc {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Ord, PartialOrd, Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct ErrorIndex {\n-    target: Interned<String>,\n+    pub compiler: Compiler,\n+    pub target: Interned<String>,\n }\n \n impl Step for ErrorIndex {\n@@ -655,26 +654,26 @@ impl Step for ErrorIndex {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(ErrorIndex { target: run.target });\n+        let target = run.target;\n+        // error_index_generator depends on librustdoc. Use the compiler that\n+        // is normally used to build rustdoc for other documentation so that\n+        // it shares the same artifacts.\n+        let compiler =\n+            run.builder.compiler_for(run.builder.top_stage, run.builder.config.build, target);\n+        run.builder.ensure(ErrorIndex { compiler, target });\n     }\n \n     /// Generates the HTML rendered error-index by running the\n     /// `error_index_generator` tool.\n     fn run(self, builder: &Builder<'_>) {\n-        let target = self.target;\n-\n-        builder.info(&format!(\"Documenting error index ({})\", target));\n-        let out = builder.doc_out(target);\n+        builder.info(&format!(\"Documenting error index ({})\", self.target));\n+        let out = builder.doc_out(self.target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(2, builder.config.build);\n-        let mut index = tool::ErrorIndex::command(builder, compiler);\n+        let mut index = tool::ErrorIndex::command(builder, self.compiler);\n         index.arg(\"html\");\n         index.arg(out.join(\"error-index.html\"));\n         index.arg(crate::channel::CFG_RELEASE_NUM);\n \n-        // FIXME: shouldn't have to pass this env var\n-        index.env(\"CFG_BUILD\", &builder.config.build);\n-\n         builder.run(&mut index);\n     }\n }"}, {"sha": "cceb7941650592f51b48ccb74523ad4960e4e564", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -175,6 +175,17 @@ impl Step for Llvm {\n             cfg.define(\"LLVM_ENABLE_ZLIB\", \"OFF\");\n         }\n \n+        // Are we compiling for iOS/tvOS?\n+        if target.contains(\"apple-ios\") || target.contains(\"apple-tvos\") {\n+            // These two defines prevent CMake from automatically trying to add a MacOSX sysroot, which leads to a compiler error.\n+            cfg.define(\"CMAKE_OSX_SYSROOT\", \"/\");\n+            cfg.define(\"CMAKE_OSX_DEPLOYMENT_TARGET\", \"\");\n+            // Prevent cmake from adding -bundle to CFLAGS automatically, which leads to a compiler error because \"-bitcode_bundle\" also gets added.\n+            cfg.define(\"LLVM_ENABLE_PLUGINS\", \"OFF\");\n+            // Zlib fails to link properly, leading to a compiler error.\n+            cfg.define(\"LLVM_ENABLE_ZLIB\", \"OFF\");\n+        }\n+\n         if builder.config.llvm_thin_lto {\n             cfg.define(\"LLVM_ENABLE_LTO\", \"Thin\");\n             if !target.contains(\"apple\") {\n@@ -412,6 +423,14 @@ fn configure_cmake(\n     if let Some(ref s) = builder.config.llvm_cflags {\n         cflags.push_str(&format!(\" {}\", s));\n     }\n+    // Some compiler features used by LLVM (such as thread locals) will not work on a min version below iOS 10.\n+    if target.contains(\"apple-ios\") {\n+        if target.contains(\"86-\") {\n+            cflags.push_str(\" -miphonesimulator-version-min=10.0\");\n+        } else {\n+            cflags.push_str(\" -miphoneos-version-min=10.0\");\n+        }\n+    }\n     cfg.define(\"CMAKE_C_FLAGS\", cflags);\n     let mut cxxflags = builder.cflags(target, GitRepo::Llvm).join(\" \");\n     if builder.config.llvm_static_stdcpp && !target.contains(\"msvc\") && !target.contains(\"netbsd\") {"}, {"sha": "77bcc00d75b2b68c8ab14e7b42bc7f34bd54c0cf", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 47, "deletions": 13, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -1454,8 +1454,11 @@ impl Step for ErrorIndex {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder\n-            .ensure(ErrorIndex { compiler: run.builder.compiler(run.builder.top_stage, run.host) });\n+        // error_index_generator depends on librustdoc. Use the compiler that\n+        // is normally used to build rustdoc for other tests (like compiletest\n+        // tests in src/test/rustdoc) so that it shares the same artifacts.\n+        let compiler = run.builder.compiler_for(run.builder.top_stage, run.host, run.host);\n+        run.builder.ensure(ErrorIndex { compiler });\n     }\n \n     /// Runs the error index generator tool to execute the tests located in the error\n@@ -1467,22 +1470,23 @@ impl Step for ErrorIndex {\n     fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n \n-        builder.ensure(compile::Std { compiler, target: compiler.host });\n-\n         let dir = testdir(builder, compiler.host);\n         t!(fs::create_dir_all(&dir));\n         let output = dir.join(\"error-index.md\");\n \n-        let mut tool = tool::ErrorIndex::command(\n-            builder,\n-            builder.compiler(compiler.stage, builder.config.build),\n-        );\n-        tool.arg(\"markdown\").arg(&output).env(\"CFG_BUILD\", &builder.config.build);\n+        let mut tool = tool::ErrorIndex::command(builder, compiler);\n+        tool.arg(\"markdown\").arg(&output);\n \n-        builder.info(&format!(\"Testing error-index stage{}\", compiler.stage));\n+        // Use the rustdoc that was built by self.compiler. This copy of\n+        // rustdoc is shared with other tests (like compiletest tests in\n+        // src/test/rustdoc). This helps avoid building rustdoc multiple\n+        // times.\n+        let rustdoc_compiler = builder.compiler(builder.top_stage, builder.config.build);\n+        builder.info(&format!(\"Testing error-index stage{}\", rustdoc_compiler.stage));\n         let _time = util::timeit(&builder);\n         builder.run_quiet(&mut tool);\n-        markdown_test(builder, compiler, &output);\n+        builder.ensure(compile::Std { compiler: rustdoc_compiler, target: rustdoc_compiler.host });\n+        markdown_test(builder, rustdoc_compiler, &output);\n     }\n }\n \n@@ -1797,9 +1801,13 @@ impl Step for CrateRustdoc {\n \n     fn run(self, builder: &Builder<'_>) {\n         let test_kind = self.test_kind;\n+        let target = self.host;\n \n-        let compiler = builder.compiler(builder.top_stage, self.host);\n-        let target = compiler.host;\n+        // Use the previous stage compiler to reuse the artifacts that are\n+        // created when running compiletest for src/test/rustdoc. If this used\n+        // `compiler`, then it would cause rustdoc to be built *again*, which\n+        // isn't really necessary.\n+        let compiler = builder.compiler_for(builder.top_stage, target, target);\n         builder.ensure(compile::Rustc { compiler, target });\n \n         let mut cargo = tool::prepare_tool_cargo(\n@@ -1825,6 +1833,32 @@ impl Step for CrateRustdoc {\n             cargo.arg(\"'-Ctarget-feature=-crt-static'\");\n         }\n \n+        // This is needed for running doctests on librustdoc. This is a bit of\n+        // an unfortunate interaction with how bootstrap works and how cargo\n+        // sets up the dylib path, and the fact that the doctest (in\n+        // html/markdown.rs) links to rustc-private libs. For stage1, the\n+        // compiler host dylibs (in stage1/lib) are not the same as the target\n+        // dylibs (in stage1/lib/rustlib/...). This is different from a normal\n+        // rust distribution where they are the same.\n+        //\n+        // On the cargo side, normal tests use `target_process` which handles\n+        // setting up the dylib for a *target* (stage1/lib/rustlib/... in this\n+        // case). However, for doctests it uses `rustdoc_process` which only\n+        // sets up the dylib path for the *host* (stage1/lib), which is the\n+        // wrong directory.\n+        //\n+        // It should be considered to just stop running doctests on\n+        // librustdoc. There is only one test, and it doesn't look too\n+        // important. There might be other ways to avoid this, but it seems\n+        // pretty convoluted.\n+        //\n+        // See also https://github.com/rust-lang/rust/issues/13983 where the\n+        // host vs target dylibs for rustdoc are consistently tricky to deal\n+        // with.\n+        let mut dylib_path = dylib_path();\n+        dylib_path.insert(0, PathBuf::from(&*builder.sysroot_libdir(compiler, target)));\n+        cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n+\n         if !builder.config.verbose_tests {\n             cargo.arg(\"--quiet\");\n         }"}, {"sha": "45f5073f4310081b221c90493ddfb993f875495f", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -366,7 +366,7 @@ bootstrap_tool!(\n     ExpandYamlAnchors, \"src/tools/expand-yaml-anchors\", \"expand-yaml-anchors\";\n );\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]\n pub struct ErrorIndex {\n     pub compiler: Compiler,\n }\n@@ -392,9 +392,9 @@ impl Step for ErrorIndex {\n     fn make_run(run: RunConfig<'_>) {\n         // Compile the error-index in the same stage as rustdoc to avoid\n         // recompiling rustdoc twice if we can.\n-        let stage = if run.builder.top_stage >= 2 { run.builder.top_stage } else { 0 };\n-        run.builder\n-            .ensure(ErrorIndex { compiler: run.builder.compiler(stage, run.builder.config.build) });\n+        let host = run.builder.config.build;\n+        let compiler = run.builder.compiler_for(run.builder.top_stage, host, host);\n+        run.builder.ensure(ErrorIndex { compiler });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n@@ -449,7 +449,7 @@ impl Step for RemoteTestServer {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]\n pub struct Rustdoc {\n     /// This should only ever be 0 or 2.\n     /// We sometimes want to reference the \"bootstrap\" rustdoc, which is why this option is here."}, {"sha": "92461305320eee8d67e68f3f67c5d4bcc863c4a7", "filename": "src/ci/docker/wasm32/Dockerfile", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Fci%2Fdocker%2Fwasm32%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Fci%2Fdocker%2Fwasm32%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fwasm32%2FDockerfile?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -25,7 +25,18 @@ RUN ln `which python3` /usr/bin/python\n \n ENV PATH=$PATH:/emsdk-portable\n ENV PATH=$PATH:/emsdk-portable/upstream/emscripten/\n-ENV PATH=$PATH:/emsdk-portable/node/12.9.1_64bit/bin/\n+\n+# Rust's build system requires NodeJS to be in the path, but the directory in\n+# which emsdk stores it contains the version number. This caused breakages in\n+# the past when emsdk bumped the node version causing the path to point to a\n+# missing directory.\n+#\n+# To avoid the problem this symlinks the latest NodeJs version available to\n+# \"latest\", and adds that to the path.\n+RUN ln -s /emsdk-portable/node/$(ls /emsdk-portable/node | sort -V | tail -n 1) \\\n+          /emsdk-portable/node/latest\n+ENV PATH=$PATH:/emsdk-portable/node/latest/bin/\n+\n ENV BINARYEN_ROOT=/emsdk-portable/upstream/\n ENV EMSDK=/emsdk-portable\n ENV EM_CONFIG=/emsdk-portable/.emscripten"}, {"sha": "c198797e650f6f05e263fc850f0fd2820c44533c", "filename": "src/libcore/alloc/global.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Falloc%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Falloc%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fglobal.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -127,9 +127,12 @@ pub unsafe trait GlobalAlloc {\n     #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n     unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n         let size = layout.size();\n-        let ptr = self.alloc(layout);\n+        // SAFETY: the safety contract for `alloc` must be upheld by the caller.\n+        let ptr = unsafe { self.alloc(layout) };\n         if !ptr.is_null() {\n-            ptr::write_bytes(ptr, 0, size);\n+            // SAFETY: as allocation succeeded, the region from `ptr`\n+            // of size `size` is guaranteed to be valid for writes.\n+            unsafe { ptr::write_bytes(ptr, 0, size) };\n         }\n         ptr\n     }\n@@ -187,11 +190,18 @@ pub unsafe trait GlobalAlloc {\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n     unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n-        let new_ptr = self.alloc(new_layout);\n+        // SAFETY: the caller must ensure that the `new_size` does not overflow.\n+        // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid.\n+        let new_layout = unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n+        // SAFETY: the caller must ensure that `new_layout` is greater than zero.\n+        let new_ptr = unsafe { self.alloc(new_layout) };\n         if !new_ptr.is_null() {\n-            ptr::copy_nonoverlapping(ptr, new_ptr, cmp::min(layout.size(), new_size));\n-            self.dealloc(ptr, layout);\n+            // SAFETY: the previously allocated block cannot overlap the newly allocated block.\n+            // The safety contract for `dealloc` must be upheld by the caller.\n+            unsafe {\n+                ptr::copy_nonoverlapping(ptr, new_ptr, cmp::min(layout.size(), new_size));\n+                self.dealloc(ptr, layout);\n+            }\n         }\n         new_ptr\n     }"}, {"sha": "ae7ae7044655bae38bfd4e7dae87938e31e3b726", "filename": "src/libcore/alloc/layout.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Flayout.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -90,7 +90,8 @@ impl Layout {\n     #[rustc_const_stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n     #[inline]\n     pub const unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {\n-        Layout { size_: size, align_: NonZeroUsize::new_unchecked(align) }\n+        // SAFETY: the caller must ensure that `align` is greater than zero.\n+        Layout { size_: size, align_: unsafe { NonZeroUsize::new_unchecked(align) } }\n     }\n \n     /// The minimum size in bytes for a memory block of this layout."}, {"sha": "be4e051b1ca42b71e32f4218eebd39a8ea1e4d1a", "filename": "src/libcore/alloc/mod.rs", "status": "modified", "additions": 45, "deletions": 13, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fmod.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -54,7 +54,9 @@ impl AllocInit {\n     #[inline]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     pub unsafe fn init(self, memory: MemoryBlock) {\n-        self.init_offset(memory, 0)\n+        // SAFETY: the safety contract for `init_offset` must be\n+        // upheld by the caller.\n+        unsafe { self.init_offset(memory, 0) }\n     }\n \n     /// Initialize the memory block like specified by `init` at the specified `offset`.\n@@ -78,7 +80,10 @@ impl AllocInit {\n         match self {\n             AllocInit::Uninitialized => (),\n             AllocInit::Zeroed => {\n-                memory.ptr.as_ptr().add(offset).write_bytes(0, memory.size - offset)\n+                // SAFETY: the caller must guarantee that `offset` is smaller than or equal to `memory.size`,\n+                // so the memory from `memory.ptr + offset` of length `memory.size - offset`\n+                // is guaranteed to be contaned in `memory` and thus valid for writes.\n+                unsafe { memory.ptr.as_ptr().add(offset).write_bytes(0, memory.size - offset) }\n             }\n         }\n     }\n@@ -281,11 +286,23 @@ pub unsafe trait AllocRef {\n                     return Ok(MemoryBlock { ptr, size });\n                 }\n \n-                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+                let new_layout =\n+                    // SAFETY: the caller must ensure that the `new_size` does not overflow.\n+                    // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n+                    // The caller must ensure that `new_size` is greater than zero.\n+                    unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n                 let new_memory = self.alloc(new_layout, init)?;\n-                ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), size);\n-                self.dealloc(ptr, layout);\n-                Ok(new_memory)\n+\n+                // SAFETY: because `new_size` must be greater than or equal to `size`, both the old and new\n+                // memory allocation are valid for reads and writes for `size` bytes. Also, because the old\n+                // allocation wasn't yet deallocated, it cannot overlap `new_memory`. Thus, the call to\n+                // `copy_nonoverlapping` is safe.\n+                // The safety contract for `dealloc` must be upheld by the caller.\n+                unsafe {\n+                    ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), size);\n+                    self.dealloc(ptr, layout);\n+                    Ok(new_memory)\n+                }\n             }\n         }\n     }\n@@ -356,11 +373,23 @@ pub unsafe trait AllocRef {\n                     return Ok(MemoryBlock { ptr, size });\n                 }\n \n-                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+                let new_layout =\n+                // SAFETY: the caller must ensure that the `new_size` does not overflow.\n+                // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid for a Layout.\n+                // The caller must ensure that `new_size` is greater than zero.\n+                    unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n                 let new_memory = self.alloc(new_layout, AllocInit::Uninitialized)?;\n-                ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), new_size);\n-                self.dealloc(ptr, layout);\n-                Ok(new_memory)\n+\n+                // SAFETY: because `new_size` must be lower than or equal to `size`, both the old and new\n+                // memory allocation are valid for reads and writes for `new_size` bytes. Also, because the\n+                // old allocation wasn't yet deallocated, it cannot overlap `new_memory`. Thus, the call to\n+                // `copy_nonoverlapping` is safe.\n+                // The safety contract for `dealloc` must be upheld by the caller.\n+                unsafe {\n+                    ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr.as_ptr(), new_size);\n+                    self.dealloc(ptr, layout);\n+                    Ok(new_memory)\n+                }\n             }\n         }\n     }\n@@ -386,7 +415,8 @@ where\n \n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n-        (**self).dealloc(ptr, layout)\n+        // SAFETY: the safety contract must be upheld by the caller\n+        unsafe { (**self).dealloc(ptr, layout) }\n     }\n \n     #[inline]\n@@ -398,7 +428,8 @@ where\n         placement: ReallocPlacement,\n         init: AllocInit,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        (**self).grow(ptr, layout, new_size, placement, init)\n+        // SAFETY: the safety contract must be upheld by the caller\n+        unsafe { (**self).grow(ptr, layout, new_size, placement, init) }\n     }\n \n     #[inline]\n@@ -409,6 +440,7 @@ where\n         new_size: usize,\n         placement: ReallocPlacement,\n     ) -> Result<MemoryBlock, AllocErr> {\n-        (**self).shrink(ptr, layout, new_size, placement)\n+        // SAFETY: the safety contract must be upheld by the caller\n+        unsafe { (**self).shrink(ptr, layout, new_size, placement) }\n     }\n }"}, {"sha": "51d9695687f4afad7a141c95afb3cde5103715dc", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -1005,7 +1005,12 @@ impl<T: ?Sized> RefCell<T> {\n     #[inline]\n     pub unsafe fn try_borrow_unguarded(&self) -> Result<&T, BorrowError> {\n         if !is_writing(self.borrow.get()) {\n-            Ok(&*self.value.get())\n+            // SAFETY: We check that nobody is actively writing now, but it is\n+            // the caller's responsibility to ensure that nobody writes until\n+            // the returned reference is no longer in use.\n+            // Also, `self.value.get()` refers to the value owned by `self`\n+            // and is thus guaranteed to be valid for the lifetime of `self`.\n+            Ok(unsafe { &*self.value.get() })\n         } else {\n             Err(BorrowError { _private: () })\n         }"}, {"sha": "c329eec76ac3d9e28afc61a2adae447ffa1006b5", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -99,7 +99,8 @@ pub fn from_u32(i: u32) -> Option<char> {\n #[inline]\n #[stable(feature = \"char_from_unchecked\", since = \"1.5.0\")]\n pub unsafe fn from_u32_unchecked(i: u32) -> char {\n-    if cfg!(debug_assertions) { char::from_u32(i).unwrap() } else { transmute(i) }\n+    // SAFETY: the caller must guarantee that `i` is a valid char value.\n+    if cfg!(debug_assertions) { char::from_u32(i).unwrap() } else { unsafe { transmute(i) } }\n }\n \n #[stable(feature = \"char_convert\", since = \"1.13.0\")]"}, {"sha": "72555d781ed38e2580a6c2c15be5fc037938b035", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -183,7 +183,8 @@ impl char {\n     #[unstable(feature = \"assoc_char_funcs\", reason = \"recently added\", issue = \"71763\")]\n     #[inline]\n     pub unsafe fn from_u32_unchecked(i: u32) -> char {\n-        super::convert::from_u32_unchecked(i)\n+        // SAFETY: the safety contract must be upheld by the caller.\n+        unsafe { super::convert::from_u32_unchecked(i) }\n     }\n \n     /// Converts a digit in the given radix to a `char`."}, {"sha": "336c0b26bc7d71afffc08dae0d249eaf3ae0ffa5", "filename": "src/libcore/convert/num.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fnum.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -28,7 +28,8 @@ macro_rules! impl_float_to_int {\n                 #[doc(hidden)]\n                 #[inline]\n                 unsafe fn to_int_unchecked(self) -> $Int {\n-                    crate::intrinsics::float_to_int_unchecked(self)\n+                    // SAFETY: the safety contract must be upheld by the caller.\n+                    unsafe { crate::intrinsics::float_to_int_unchecked(self) }\n                 }\n             }\n         )+"}, {"sha": "ca4632006509fec3f368a96001265ad5dacb9224", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -333,7 +333,8 @@ impl<'f> VaListImpl<'f> {\n     /// Advance to the next arg.\n     #[inline]\n     pub unsafe fn arg<T: sealed_trait::VaArgSafe>(&mut self) -> T {\n-        va_arg(self)\n+        // SAFETY: the caller must uphold the safety contract for `va_arg`.\n+        unsafe { va_arg(self) }\n     }\n \n     /// Copies the `va_list` at the current location.\n@@ -343,7 +344,10 @@ impl<'f> VaListImpl<'f> {\n     {\n         let mut ap = self.clone();\n         let ret = f(ap.as_va_list());\n-        va_end(&mut ap);\n+        // SAFETY: the caller must uphold the safety contract for `va_end`.\n+        unsafe {\n+            va_end(&mut ap);\n+        }\n         ret\n     }\n }"}, {"sha": "2555d91ae8d9a287a60d256ebc5adecae70eda38", "filename": "src/libcore/future/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fmod.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -85,5 +85,7 @@ where\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n #[inline]\n pub unsafe fn get_context<'a, 'b>(cx: ResumeTy) -> &'a mut Context<'b> {\n-    &mut *cx.0.as_ptr().cast()\n+    // SAFETY: the caller must guarantee that `cx.0` is a valid pointer\n+    // that fulfills all the requirements for a mutable reference.\n+    unsafe { &mut *cx.0.as_ptr().cast() }\n }"}, {"sha": "f2bbf646f3272b87d1c5beb7e8b22721f985abce", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -130,15 +130,19 @@ unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n     let mut i = 0; // current byte index (from LSB) in the output u64\n     let mut out = 0;\n     if i + 3 < len {\n-        out = load_int_le!(buf, start + i, u32) as u64;\n+        // SAFETY: `i` cannot be greater than `len`, and the caller must guarantee\n+        // that the index start..start+len is in bounds.\n+        out = unsafe { load_int_le!(buf, start + i, u32) } as u64;\n         i += 4;\n     }\n     if i + 1 < len {\n-        out |= (load_int_le!(buf, start + i, u16) as u64) << (i * 8);\n+        // SAFETY: same as above.\n+        out |= (unsafe { load_int_le!(buf, start + i, u16) } as u64) << (i * 8);\n         i += 2\n     }\n     if i < len {\n-        out |= (*buf.get_unchecked(start + i) as u64) << (i * 8);\n+        // SAFETY: same as above.\n+        out |= (unsafe { *buf.get_unchecked(start + i) } as u64) << (i * 8);\n         i += 1;\n     }\n     debug_assert_eq!(i, len);"}, {"sha": "9ebcde79b633d3ea0492f5c90991a1d803e15e0f", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -46,7 +46,9 @@ use crate::intrinsics;\n #[inline]\n #[stable(feature = \"unreachable\", since = \"1.27.0\")]\n pub unsafe fn unreachable_unchecked() -> ! {\n-    intrinsics::unreachable()\n+    // SAFETY: the safety contract for `intrinsics::unreachable` must\n+    // be upheld by the caller.\n+    unsafe { intrinsics::unreachable() }\n }\n \n /// Emits a machine instruction hinting to the processor that it is running in busy-wait"}, {"sha": "aff4e4a8d98255f421b6966ee61b4f00ef4a7eee", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -1958,7 +1958,40 @@ extern \"rust-intrinsic\" {\n     /// generation.\n     #[cfg(not(bootstrap))]\n     #[lang = \"count_code_region\"]\n-    pub fn count_code_region(index: u32);\n+    pub fn count_code_region(index: u32, start_byte_pos: u32, end_byte_pos: u32);\n+\n+    /// Internal marker for code coverage expressions, injected into the MIR when the\n+    /// \"instrument-coverage\" option is enabled. This intrinsic is not converted into a\n+    /// backend intrinsic call, but its arguments are extracted during the production of a\n+    /// \"coverage map\", which is injected into the generated code, as additional data.\n+    /// This marker identifies a code region and two other counters or counter expressions\n+    /// whose sum is the number of times the code region was executed.\n+    #[cfg(not(bootstrap))]\n+    pub fn coverage_counter_add(\n+        index: u32,\n+        left_index: u32,\n+        right_index: u32,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    );\n+\n+    /// This marker identifies a code region and two other counters or counter expressions\n+    /// whose difference is the number of times the code region was executed.\n+    /// (See `coverage_counter_add` for more information.)\n+    #[cfg(not(bootstrap))]\n+    pub fn coverage_counter_subtract(\n+        index: u32,\n+        left_index: u32,\n+        right_index: u32,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    );\n+\n+    /// This marker identifies a code region to be added to the \"coverage map\" to indicate source\n+    /// code that can never be reached.\n+    /// (See `coverage_counter_add` for more information.)\n+    #[cfg(not(bootstrap))]\n+    pub fn coverage_unreachable(start_byte_pos: u32, end_byte_pos: u32);\n \n     /// See documentation of `<*const T>::guaranteed_eq` for details.\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n@@ -2099,7 +2132,10 @@ pub unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n         // Not panicking to keep codegen impact smaller.\n         abort();\n     }\n-    copy_nonoverlapping(src, dst, count)\n+\n+    // SAFETY: the safety contract for `copy_nonoverlapping` must be\n+    // upheld by the caller.\n+    unsafe { copy_nonoverlapping(src, dst, count) }\n }\n \n /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n@@ -2165,7 +2201,9 @@ pub unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n         // Not panicking to keep codegen impact smaller.\n         abort();\n     }\n-    copy(src, dst, count)\n+\n+    // SAFETY: the safety contract for `copy` must be upheld by the caller.\n+    unsafe { copy(src, dst, count) }\n }\n \n /// Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n@@ -2248,5 +2286,7 @@ pub unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n     }\n \n     debug_assert!(is_aligned_and_not_null(dst), \"attempt to write to unaligned or null pointer\");\n-    write_bytes(dst, val, count)\n+\n+    // SAFETY: the safety contract for `write_bytes` must be upheld by the caller.\n+    unsafe { write_bytes(dst, val, count) }\n }"}, {"sha": "d2e2fc04a2b7661001f1741c256d14de124f23e1", "filename": "src/libcore/iter/adapters/fuse.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -178,9 +178,10 @@ where\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> I::Item {\n         match self.iter {\n-            Some(ref mut iter) => iter.get_unchecked(i),\n+            // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n+            Some(ref mut iter) => unsafe { iter.get_unchecked(i) },\n             // SAFETY: the caller asserts there is an item at `i`, so we're not exhausted.\n-            None => intrinsics::unreachable(),\n+            None => unsafe { intrinsics::unreachable() },\n         }\n     }\n "}, {"sha": "133643a0c7f0368c0b7f1cf6eb78c4d1c538dc6f", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -272,7 +272,8 @@ where\n     T: Copy,\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        *self.it.get_unchecked(i)\n+        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n+        unsafe { *self.it.get_unchecked(i) }\n     }\n \n     #[inline]\n@@ -402,7 +403,8 @@ where\n     T: Clone,\n {\n     default unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        self.it.get_unchecked(i).clone()\n+        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n+        unsafe { self.it.get_unchecked(i) }.clone()\n     }\n \n     #[inline]\n@@ -418,7 +420,8 @@ where\n     T: Copy,\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        *self.it.get_unchecked(i)\n+        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n+        unsafe { *self.it.get_unchecked(i) }\n     }\n \n     #[inline]\n@@ -930,7 +933,8 @@ where\n     F: FnMut(I::Item) -> B,\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n-        (self.f)(self.iter.get_unchecked(i))\n+        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n+        (self.f)(unsafe { self.iter.get_unchecked(i) })\n     }\n     #[inline]\n     fn may_have_side_effect() -> bool {\n@@ -1392,7 +1396,8 @@ where\n     I: TrustedRandomAccess,\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> (usize, I::Item) {\n-        (self.count + i, self.iter.get_unchecked(i))\n+        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n+        (self.count + i, unsafe { self.iter.get_unchecked(i) })\n     }\n \n     fn may_have_side_effect() -> bool {"}, {"sha": "985e6561665c7e923511274e8cb31d2ca7b992e8", "filename": "src/libcore/iter/adapters/zip.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -271,7 +271,8 @@ where\n     B: TrustedRandomAccess,\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> (A::Item, B::Item) {\n-        (self.a.get_unchecked(i), self.b.get_unchecked(i))\n+        // SAFETY: the caller must uphold the contract for `TrustedRandomAccess::get_unchecked`.\n+        unsafe { (self.a.get_unchecked(i), self.b.get_unchecked(i)) }\n     }\n \n     fn may_have_side_effect() -> bool {"}, {"sha": "ee53b6a13f837627028c2f1530aaeaf8aa6ec288", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -189,12 +189,14 @@ macro_rules! step_identical_methods {\n     () => {\n         #[inline]\n         unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n-            start.unchecked_add(n as Self)\n+            // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.\n+            unsafe { start.unchecked_add(n as Self) }\n         }\n \n         #[inline]\n         unsafe fn backward_unchecked(start: Self, n: usize) -> Self {\n-            start.unchecked_sub(n as Self)\n+            // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.\n+            unsafe { start.unchecked_sub(n as Self) }\n         }\n \n         #[inline]\n@@ -450,21 +452,33 @@ unsafe impl Step for char {\n     #[inline]\n     unsafe fn forward_unchecked(start: char, count: usize) -> char {\n         let start = start as u32;\n-        let mut res = Step::forward_unchecked(start, count);\n+        // SAFETY: the caller must guarantee that this doesn't overflow\n+        // the range of values for a char.\n+        let mut res = unsafe { Step::forward_unchecked(start, count) };\n         if start < 0xD800 && 0xD800 <= res {\n-            res = Step::forward_unchecked(res, 0x800);\n+            // SAFETY: the caller must guarantee that this doesn't overflow\n+            // the range of values for a char.\n+            res = unsafe { Step::forward_unchecked(res, 0x800) };\n         }\n-        char::from_u32_unchecked(res)\n+        // SAFETY: because of the previous contract, this is guaranteed\n+        // by the caller to be a valid char.\n+        unsafe { char::from_u32_unchecked(res) }\n     }\n \n     #[inline]\n     unsafe fn backward_unchecked(start: char, count: usize) -> char {\n         let start = start as u32;\n-        let mut res = Step::backward_unchecked(start, count);\n+        // SAFETY: the caller must guarantee that this doesn't overflow\n+        // the range of values for a char.\n+        let mut res = unsafe { Step::backward_unchecked(start, count) };\n         if start >= 0xE000 && 0xE000 > res {\n-            res = Step::backward_unchecked(res, 0x800);\n+            // SAFETY: the caller must guarantee that this doesn't overflow\n+            // the range of values for a char.\n+            res = unsafe { Step::backward_unchecked(res, 0x800) };\n         }\n-        char::from_u32_unchecked(res)\n+        // SAFETY: because of the previous contract, this is guaranteed\n+        // by the caller to be a valid char.\n+        unsafe { char::from_u32_unchecked(res) }\n     }\n }\n "}, {"sha": "50c56434fa9a188771987492b97a72a618513924", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -149,6 +149,8 @@\n #![feature(const_type_id)]\n #![feature(const_caller_location)]\n #![feature(no_niche)] // rust-lang/rust#68303\n+#![feature(unsafe_block_in_unsafe_fn)]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n #[prelude_import]\n #[allow(unused)]\n@@ -279,7 +281,13 @@ pub mod primitive;\n // set up in such a way that directly pulling it here works such that the\n // crate uses the this crate as its libcore.\n #[path = \"../stdarch/crates/core_arch/src/mod.rs\"]\n-#[allow(missing_docs, missing_debug_implementations, dead_code, unused_imports)]\n+#[allow(\n+    missing_docs,\n+    missing_debug_implementations,\n+    dead_code,\n+    unused_imports,\n+    unsafe_op_in_unsafe_fn\n+)]\n // FIXME: This annotation should be moved into rust-lang/stdarch after clashing_extern_declarations is\n // merged. It currently cannot because bootstrap fails as the lint hasn't been defined yet.\n #[cfg_attr(not(bootstrap), allow(clashing_extern_declarations))]"}, {"sha": "920f5e9c0bd28521e732e3e5159862168fd1c807", "filename": "src/libcore/mem/manually_drop.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmanually_drop.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -122,7 +122,9 @@ impl<T> ManuallyDrop<T> {\n     #[stable(feature = \"manually_drop_take\", since = \"1.42.0\")]\n     #[inline]\n     pub unsafe fn take(slot: &mut ManuallyDrop<T>) -> T {\n-        ptr::read(&slot.value)\n+        // SAFETY: we are reading from a reference, which is guaranteed\n+        // to be valid for reads.\n+        unsafe { ptr::read(&slot.value) }\n     }\n }\n \n@@ -152,7 +154,10 @@ impl<T: ?Sized> ManuallyDrop<T> {\n     #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {\n-        ptr::drop_in_place(&mut slot.value)\n+        // SAFETY: we are dropping the value pointed to by a mutable reference\n+        // which is guaranteed to be valid for writes.\n+        // It is up to the caller to make sure that `slot` isn't dropped again.\n+        unsafe { ptr::drop_in_place(&mut slot.value) }\n     }\n }\n "}, {"sha": "7732525a0fc28a0556be5acac26724fbfd39dd20", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -494,8 +494,12 @@ impl<T> MaybeUninit<T> {\n     #[inline(always)]\n     #[rustc_diagnostic_item = \"assume_init\"]\n     pub unsafe fn assume_init(self) -> T {\n-        intrinsics::assert_inhabited::<T>();\n-        ManuallyDrop::into_inner(self.value)\n+        // SAFETY: the caller must guarantee that `self` is initialized.\n+        // This also means that `self` must be a `value` variant.\n+        unsafe {\n+            intrinsics::assert_inhabited::<T>();\n+            ManuallyDrop::into_inner(self.value)\n+        }\n     }\n \n     /// Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n@@ -558,8 +562,12 @@ impl<T> MaybeUninit<T> {\n     #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n     #[inline(always)]\n     pub unsafe fn read(&self) -> T {\n-        intrinsics::assert_inhabited::<T>();\n-        self.as_ptr().read()\n+        // SAFETY: the caller must guarantee that `self` is initialized.\n+        // Reading from `self.as_ptr()` is safe since `self` should be initialized.\n+        unsafe {\n+            intrinsics::assert_inhabited::<T>();\n+            self.as_ptr().read()\n+        }\n     }\n \n     /// Gets a shared reference to the contained value.\n@@ -620,8 +628,12 @@ impl<T> MaybeUninit<T> {\n     #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n     pub unsafe fn get_ref(&self) -> &T {\n-        intrinsics::assert_inhabited::<T>();\n-        &*self.value\n+        // SAFETY: the caller must guarantee that `self` is initialized.\n+        // This also means that `self` must be a `value` variant.\n+        unsafe {\n+            intrinsics::assert_inhabited::<T>();\n+            &*self.value\n+        }\n     }\n \n     /// Gets a mutable (unique) reference to the contained value.\n@@ -738,8 +750,12 @@ impl<T> MaybeUninit<T> {\n     #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n     pub unsafe fn get_mut(&mut self) -> &mut T {\n-        intrinsics::assert_inhabited::<T>();\n-        &mut *self.value\n+        // SAFETY: the caller must guarantee that `self` is initialized.\n+        // This also means that `self` must be a `value` variant.\n+        unsafe {\n+            intrinsics::assert_inhabited::<T>();\n+            &mut *self.value\n+        }\n     }\n \n     /// Assuming all the elements are initialized, get a slice to them.\n@@ -752,7 +768,11 @@ impl<T> MaybeUninit<T> {\n     #[unstable(feature = \"maybe_uninit_slice_assume_init\", issue = \"none\")]\n     #[inline(always)]\n     pub unsafe fn slice_get_ref(slice: &[Self]) -> &[T] {\n-        &*(slice as *const [Self] as *const [T])\n+        // SAFETY: casting slice to a `*const [T]` is safe since the caller guarantees that\n+        // `slice` is initialized, and`MaybeUninit` is guaranteed to have the same layout as `T`.\n+        // The pointer obtained is valid since it refers to memory owned by `slice` which is a\n+        // reference and thus guaranteed to be valid for reads.\n+        unsafe { &*(slice as *const [Self] as *const [T]) }\n     }\n \n     /// Assuming all the elements are initialized, get a mutable slice to them.\n@@ -765,7 +785,9 @@ impl<T> MaybeUninit<T> {\n     #[unstable(feature = \"maybe_uninit_slice_assume_init\", issue = \"none\")]\n     #[inline(always)]\n     pub unsafe fn slice_get_mut(slice: &mut [Self]) -> &mut [T] {\n-        &mut *(slice as *mut [Self] as *mut [T])\n+        // SAFETY: similar to safety notes for `slice_get_ref`, but we have a\n+        // mutable reference which is also guaranteed to be valid for writes.\n+        unsafe { &mut *(slice as *mut [Self] as *mut [T]) }\n     }\n \n     /// Gets a pointer to the first element of the array."}, {"sha": "272088815ece90194a40aa0645902a484d7837fe", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -623,8 +623,11 @@ pub const fn needs_drop<T>() -> bool {\n #[allow(deprecated)]\n #[rustc_diagnostic_item = \"mem_zeroed\"]\n pub unsafe fn zeroed<T>() -> T {\n-    intrinsics::assert_zero_valid::<T>();\n-    MaybeUninit::zeroed().assume_init()\n+    // SAFETY: the caller must guarantee that an all-zero value is valid for `T`.\n+    unsafe {\n+        intrinsics::assert_zero_valid::<T>();\n+        MaybeUninit::zeroed().assume_init()\n+    }\n }\n \n /// Bypasses Rust's normal memory-initialization checks by pretending to\n@@ -656,8 +659,11 @@ pub unsafe fn zeroed<T>() -> T {\n #[allow(deprecated)]\n #[rustc_diagnostic_item = \"mem_uninitialized\"]\n pub unsafe fn uninitialized<T>() -> T {\n-    intrinsics::assert_uninit_valid::<T>();\n-    MaybeUninit::uninit().assume_init()\n+    // SAFETY: the caller must guarantee that an unitialized value is valid for `T`.\n+    unsafe {\n+        intrinsics::assert_uninit_valid::<T>();\n+        MaybeUninit::uninit().assume_init()\n+    }\n }\n \n /// Swaps the values at two mutable locations, without deinitializing either one.\n@@ -922,9 +928,14 @@ pub fn drop<T>(_x: T) {}\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     // If U has a higher alignment requirement, src may not be suitably aligned.\n     if align_of::<U>() > align_of::<T>() {\n-        ptr::read_unaligned(src as *const T as *const U)\n+        // SAFETY: `src` is a reference which is guaranteed to be valid for reads.\n+        // The caller must guarantee that the actual transmutation is safe.\n+        unsafe { ptr::read_unaligned(src as *const T as *const U) }\n     } else {\n-        ptr::read(src as *const T as *const U)\n+        // SAFETY: `src` is a reference which is guaranteed to be valid for reads.\n+        // We just checked that `src as *const U` was properly aligned.\n+        // The caller must guarantee that the actual transmutation is safe.\n+        unsafe { ptr::read(src as *const T as *const U) }\n     }\n }\n "}, {"sha": "061d1ea6b1c46974ffe7f7e11d3c3a6a878c8842", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -629,7 +629,9 @@ impl f32 {\n     where\n         Self: FloatToInt<Int>,\n     {\n-        FloatToInt::<Int>::to_int_unchecked(self)\n+        // SAFETY: the caller must uphold the safety contract for\n+        // `FloatToInt::to_int_unchecked`.\n+        unsafe { FloatToInt::<Int>::to_int_unchecked(self) }\n     }\n \n     /// Raw transmutation to `u32`."}, {"sha": "b0df4d64f6ee1880583c42f5bc83c8a5a6dbd9d2", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -643,7 +643,9 @@ impl f64 {\n     where\n         Self: FloatToInt<Int>,\n     {\n-        FloatToInt::<Int>::to_int_unchecked(self)\n+        // SAFETY: the caller must uphold the safety contract for\n+        // `FloatToInt::to_int_unchecked`.\n+        unsafe { FloatToInt::<Int>::to_int_unchecked(self) }\n     }\n \n     /// Raw transmutation to `u64`."}, {"sha": "f4a1afd436adb7608a9e08695f0c839dccc86fac", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 63, "deletions": 34, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -21,6 +21,21 @@ macro_rules! try_opt {\n     };\n }\n \n+#[cfg(bootstrap)]\n+macro_rules! unlikely {\n+    ($e: expr) => {\n+        $e\n+    };\n+}\n+\n+#[cfg(not(bootstrap))]\n+#[allow_internal_unstable(const_likely)]\n+macro_rules! unlikely {\n+    ($e: expr) => {\n+        intrinsics::unlikely($e)\n+    };\n+}\n+\n macro_rules! impl_nonzero_fmt {\n     ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => {\n         $(\n@@ -74,7 +89,8 @@ assert_eq!(size_of::<Option<core::num::\", stringify!($Ty), \">>(), size_of::<\", s\n                 #[rustc_const_stable(feature = \"nonzero\", since = \"1.34.0\")]\n                 #[inline]\n                 pub const unsafe fn new_unchecked(n: $Int) -> Self {\n-                    Self(n)\n+                    // SAFETY: this is guaranteed to be safe by the caller.\n+                    unsafe { Self(n) }\n                 }\n \n                 /// Creates a non-zero if the given value is not zero.\n@@ -745,7 +761,7 @@ $EndFeature, \"\n             #[inline]\n             pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_add(rhs);\n-                if b {None} else {Some(a)}\n+                if unlikely!(b) {None} else {Some(a)}\n             }\n         }\n \n@@ -762,7 +778,9 @@ cannot occur. This results in undefined behavior when `self + rhs > \", stringify\n                           without modifying the original\"]\n             #[inline]\n             pub unsafe fn unchecked_add(self, rhs: Self) -> Self {\n-                intrinsics::unchecked_add(self, rhs)\n+                // SAFETY: the caller must uphold the safety contract for\n+                // `unchecked_add`.\n+                unsafe { intrinsics::unchecked_add(self, rhs) }\n             }\n         }\n \n@@ -787,7 +805,7 @@ $EndFeature, \"\n             #[inline]\n             pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_sub(rhs);\n-                if b {None} else {Some(a)}\n+                if unlikely!(b) {None} else {Some(a)}\n             }\n         }\n \n@@ -804,7 +822,9 @@ cannot occur. This results in undefined behavior when `self - rhs > \", stringify\n                           without modifying the original\"]\n             #[inline]\n             pub unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n-                intrinsics::unchecked_sub(self, rhs)\n+                // SAFETY: the caller must uphold the safety contract for\n+                // `unchecked_sub`.\n+                unsafe { intrinsics::unchecked_sub(self, rhs) }\n             }\n         }\n \n@@ -829,7 +849,7 @@ $EndFeature, \"\n             #[inline]\n             pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_mul(rhs);\n-                if b {None} else {Some(a)}\n+                if unlikely!(b) {None} else {Some(a)}\n             }\n         }\n \n@@ -846,7 +866,9 @@ cannot occur. This results in undefined behavior when `self * rhs > \", stringify\n                           without modifying the original\"]\n             #[inline]\n             pub unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n-                intrinsics::unchecked_mul(self, rhs)\n+                // SAFETY: the caller must uphold the safety contract for\n+                // `unchecked_mul`.\n+                unsafe { intrinsics::unchecked_mul(self, rhs) }\n             }\n         }\n \n@@ -871,7 +893,7 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n-                if rhs == 0 || (self == Self::MIN && rhs == -1) {\n+                if unlikely!(rhs == 0 || (self == Self::MIN && rhs == -1)) {\n                     None\n                 } else {\n                     // SAFETY: div by zero and by INT_MIN have been checked above\n@@ -900,7 +922,7 @@ assert_eq!((1\", stringify!($SelfT), \").checked_div_euclid(0), None);\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n-                if rhs == 0 || (self == Self::MIN && rhs == -1) {\n+                if unlikely!(rhs == 0 || (self == Self::MIN && rhs == -1)) {\n                     None\n                 } else {\n                     Some(self.div_euclid(rhs))\n@@ -929,7 +951,7 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n-                if rhs == 0 || (self == Self::MIN && rhs == -1) {\n+                if unlikely!(rhs == 0 || (self == Self::MIN && rhs == -1)) {\n                     None\n                 } else {\n                     // SAFETY: div by zero and by INT_MIN have been checked above\n@@ -957,7 +979,7 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem_euclid(-1), None);\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n-                if rhs == 0 || (self == Self::MIN && rhs == -1) {\n+                if unlikely!(rhs == 0 || (self == Self::MIN && rhs == -1)) {\n                     None\n                 } else {\n                     Some(self.rem_euclid(rhs))\n@@ -983,7 +1005,7 @@ $EndFeature, \"\n             #[inline]\n             pub const fn checked_neg(self) -> Option<Self> {\n                 let (a, b) = self.overflowing_neg();\n-                if b {None} else {Some(a)}\n+                if unlikely!(b) {None} else {Some(a)}\n             }\n         }\n \n@@ -1007,7 +1029,7 @@ $EndFeature, \"\n             #[inline]\n             pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n                 let (a, b) = self.overflowing_shl(rhs);\n-                if b {None} else {Some(a)}\n+                if unlikely!(b) {None} else {Some(a)}\n             }\n         }\n \n@@ -1031,7 +1053,7 @@ $EndFeature, \"\n             #[inline]\n             pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n                 let (a, b) = self.overflowing_shr(rhs);\n-                if b {None} else {Some(a)}\n+                if unlikely!(b) {None} else {Some(a)}\n             }\n         }\n \n@@ -1738,7 +1760,7 @@ $EndFeature, \"\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n-                if self == Self::MIN && rhs == -1 {\n+                if unlikely!(self == Self::MIN && rhs == -1) {\n                     (self, true)\n                 } else {\n                     (self / rhs, false)\n@@ -1771,7 +1793,7 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div_euclid(-1), (\", stringi\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n-                if self == Self::MIN && rhs == -1 {\n+                if unlikely!(self == Self::MIN && rhs == -1) {\n                     (self, true)\n                 } else {\n                     (self.div_euclid(rhs), false)\n@@ -1805,7 +1827,7 @@ $EndFeature, \"\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n-                if self == Self::MIN && rhs == -1 {\n+                if unlikely!(self == Self::MIN && rhs == -1) {\n                     (0, true)\n                 } else {\n                     (self % rhs, false)\n@@ -1838,7 +1860,7 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem_euclid(-1), (0, true));\n                           without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n-                if self == Self::MIN && rhs == -1 {\n+                if unlikely!(self == Self::MIN && rhs == -1) {\n                     (0, true)\n                 } else {\n                     (self.rem_euclid(rhs), false)\n@@ -1869,7 +1891,7 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_neg(), (\", stringify!($Self\n             #[allow(unused_attributes)]\n             #[cfg_attr(bootstrap, allow_internal_unstable(const_if_match))]\n             pub const fn overflowing_neg(self) -> (Self, bool) {\n-                if self == Self::MIN {\n+                if unlikely!(self == Self::MIN) {\n                     (Self::MIN, true)\n                 } else {\n                     (-self, false)\n@@ -2981,7 +3003,7 @@ assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\", $EndFeat\n             #[inline]\n             pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_add(rhs);\n-                if b {None} else {Some(a)}\n+                if unlikely!(b) {None} else {Some(a)}\n             }\n         }\n \n@@ -2998,7 +3020,9 @@ cannot occur. This results in undefined behavior when `self + rhs > \", stringify\n                           without modifying the original\"]\n             #[inline]\n             pub unsafe fn unchecked_add(self, rhs: Self) -> Self {\n-                intrinsics::unchecked_add(self, rhs)\n+                // SAFETY: the caller must uphold the safety contract for\n+                // `unchecked_add`.\n+                unsafe { intrinsics::unchecked_add(self, rhs) }\n             }\n         }\n \n@@ -3021,7 +3045,7 @@ assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\", $EndFeature, \"\n             #[inline]\n             pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_sub(rhs);\n-                if b {None} else {Some(a)}\n+                if unlikely!(b) {None} else {Some(a)}\n             }\n         }\n \n@@ -3038,7 +3062,9 @@ cannot occur. This results in undefined behavior when `self - rhs > \", stringify\n                           without modifying the original\"]\n             #[inline]\n             pub unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n-                intrinsics::unchecked_sub(self, rhs)\n+                // SAFETY: the caller must uphold the safety contract for\n+                // `unchecked_sub`.\n+                unsafe { intrinsics::unchecked_sub(self, rhs) }\n             }\n         }\n \n@@ -3061,7 +3087,7 @@ assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\", $EndFeature, \"\n             #[inline]\n             pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_mul(rhs);\n-                if b {None} else {Some(a)}\n+                if unlikely!(b) {None} else {Some(a)}\n             }\n         }\n \n@@ -3078,7 +3104,9 @@ cannot occur. This results in undefined behavior when `self * rhs > \", stringify\n                           without modifying the original\"]\n             #[inline]\n             pub unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n-                intrinsics::unchecked_mul(self, rhs)\n+                // SAFETY: the caller must uphold the safety contract for\n+                // `unchecked_mul`.\n+                unsafe { intrinsics::unchecked_mul(self, rhs) }\n             }\n         }\n \n@@ -3100,11 +3128,12 @@ assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\", $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n-                match rhs {\n-                    0 => None,\n+                if unlikely!(rhs == 0) {\n+                    None\n+                } else {\n                     // SAFETY: div by zero has been checked above and unsigned types have no other\n                     // failure modes for division\n-                    rhs => Some(unsafe { intrinsics::unchecked_div(self, rhs) }),\n+                    Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n                 }\n             }\n         }\n@@ -3127,7 +3156,7 @@ assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n-                if rhs == 0 {\n+                if unlikely!(rhs == 0) {\n                     None\n                 } else {\n                     Some(self.div_euclid(rhs))\n@@ -3154,7 +3183,7 @@ assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\", $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n-                if rhs == 0 {\n+                if unlikely!(rhs == 0) {\n                     None\n                 } else {\n                     // SAFETY: div by zero has been checked above and unsigned types have no other\n@@ -3182,7 +3211,7 @@ assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n-                if rhs == 0 {\n+                if unlikely!(rhs == 0) {\n                     None\n                 } else {\n                     Some(self.rem_euclid(rhs))\n@@ -3209,7 +3238,7 @@ assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\", $EndFeature, \"\n             #[inline]\n             pub const fn checked_neg(self) -> Option<Self> {\n                 let (a, b) = self.overflowing_neg();\n-                if b {None} else {Some(a)}\n+                if unlikely!(b) {None} else {Some(a)}\n             }\n         }\n \n@@ -3232,7 +3261,7 @@ assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\", $EndFeature,\n             #[inline]\n             pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n                 let (a, b) = self.overflowing_shl(rhs);\n-                if b {None} else {Some(a)}\n+                if unlikely!(b) {None} else {Some(a)}\n             }\n         }\n \n@@ -3255,7 +3284,7 @@ assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\", $EndFeature,\n             #[inline]\n             pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n                 let (a, b) = self.overflowing_shr(rhs);\n-                if b {None} else {Some(a)}\n+                if unlikely!(b) {None} else {Some(a)}\n             }\n         }\n "}, {"sha": "da299f026f8f16c87f0d7dd4f64fe3e62f37491b", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -679,7 +679,10 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n     {\n         let pointer = &*self.pointer;\n         let new_pointer = func(pointer);\n-        Pin::new_unchecked(new_pointer)\n+\n+        // SAFETY: the safety contract for `new_unchecked` must be\n+        // upheld by the caller.\n+        unsafe { Pin::new_unchecked(new_pointer) }\n     }\n \n     /// Gets a shared reference out of a pin.\n@@ -769,9 +772,13 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n         U: ?Sized,\n         F: FnOnce(&mut T) -> &mut U,\n     {\n-        let pointer = Pin::get_unchecked_mut(self);\n+        // SAFETY: the caller is responsible for not moving the\n+        // value out of this reference.\n+        let pointer = unsafe { Pin::get_unchecked_mut(self) };\n         let new_pointer = func(pointer);\n-        Pin::new_unchecked(new_pointer)\n+        // SAFETY: as the value of `this` is guaranteed to not have\n+        // been moved out, this call to `new_unchecked` is safe.\n+        unsafe { Pin::new_unchecked(new_pointer) }\n     }\n }\n "}, {"sha": "d1d7a71523822a12c2679917a2f355f064857783", "filename": "src/libcore/ptr/const_ptr.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -95,7 +95,9 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n     pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n-        if self.is_null() { None } else { Some(&*self) }\n+        // SAFETY: the caller must guarantee that `self` is valid\n+        // for a reference if it isn't null.\n+        if self.is_null() { None } else { unsafe { Some(&*self) } }\n     }\n \n     /// Calculates the offset from a pointer.\n@@ -157,7 +159,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        intrinsics::offset(self, count)\n+        // SAFETY: the caller must uphold the safety contract for `offset`.\n+        unsafe { intrinsics::offset(self, count) }\n     }\n \n     /// Calculates the offset from a pointer using wrapping arithmetic.\n@@ -292,7 +295,8 @@ impl<T: ?Sized> *const T {\n     {\n         let pointee_size = mem::size_of::<T>();\n         assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n-        intrinsics::ptr_offset_from(self, origin)\n+        // SAFETY: the caller must uphold the safety contract for `ptr_offset_from`.\n+        unsafe { intrinsics::ptr_offset_from(self, origin) }\n     }\n \n     /// Returns whether two pointers are guaranteed to be equal.\n@@ -471,7 +475,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        self.offset(count as isize)\n+        // SAFETY: the caller must uphold the safety contract for `offset`.\n+        unsafe { self.offset(count as isize) }\n     }\n \n     /// Calculates the offset from a pointer (convenience for\n@@ -534,7 +539,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        self.offset((count as isize).wrapping_neg())\n+        // SAFETY: the caller must uphold the safety contract for `offset`.\n+        unsafe { self.offset((count as isize).wrapping_neg()) }\n     }\n \n     /// Calculates the offset from a pointer using wrapping arithmetic.\n@@ -663,7 +669,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        read(self)\n+        // SAFETY: the caller must uphold the safety contract for `read`.\n+        unsafe { read(self) }\n     }\n \n     /// Performs a volatile read of the value from `self` without moving it. This\n@@ -682,7 +689,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        read_volatile(self)\n+        // SAFETY: the caller must uphold the safety contract for `read_volatile`.\n+        unsafe { read_volatile(self) }\n     }\n \n     /// Reads the value from `self` without moving it. This leaves the\n@@ -699,7 +707,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        read_unaligned(self)\n+        // SAFETY: the caller must uphold the safety contract for `read_unaligned`.\n+        unsafe { read_unaligned(self) }\n     }\n \n     /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n@@ -716,7 +725,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        copy(self, dest, count)\n+        // SAFETY: the caller must uphold the safety contract for `copy`.\n+        unsafe { copy(self, dest, count) }\n     }\n \n     /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n@@ -733,7 +743,8 @@ impl<T: ?Sized> *const T {\n     where\n         T: Sized,\n     {\n-        copy_nonoverlapping(self, dest, count)\n+        // SAFETY: the caller must uphold the safety contract for `copy_nonoverlapping`.\n+        unsafe { copy_nonoverlapping(self, dest, count) }\n     }\n \n     /// Computes the offset that needs to be applied to the pointer in order to make it aligned to"}, {"sha": "5f028f9ea76cac453c771afc7f5cbbb42021d4e0", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 93, "deletions": 33, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -184,7 +184,9 @@ mod mut_ptr;\n pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n     // Code here does not matter - this is replaced by the\n     // real drop glue by the compiler.\n-    drop_in_place(to_drop)\n+\n+    // SAFETY: see comment above\n+    unsafe { drop_in_place(to_drop) }\n }\n \n /// Creates a null raw pointer.\n@@ -374,9 +376,15 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     let mut tmp = MaybeUninit::<T>::uninit();\n \n     // Perform the swap\n-    copy_nonoverlapping(x, tmp.as_mut_ptr(), 1);\n-    copy(y, x, 1); // `x` and `y` may overlap\n-    copy_nonoverlapping(tmp.as_ptr(), y, 1);\n+    // SAFETY: the caller must guarantee that `x` and `y` are\n+    // valid for writes and properly aligned. `tmp` cannot be\n+    // overlapping either `x` or `y` because `tmp` was just allocated\n+    // on the stack as a separate allocated object.\n+    unsafe {\n+        copy_nonoverlapping(x, tmp.as_mut_ptr(), 1);\n+        copy(y, x, 1); // `x` and `y` may overlap\n+        copy_nonoverlapping(tmp.as_ptr(), y, 1);\n+    }\n }\n \n /// Swaps `count * size_of::<T>()` bytes between the two regions of memory\n@@ -432,19 +440,26 @@ pub unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n     let x = x as *mut u8;\n     let y = y as *mut u8;\n     let len = mem::size_of::<T>() * count;\n-    swap_nonoverlapping_bytes(x, y, len)\n+    // SAFETY: the caller must guarantee that `x` and `y` are\n+    // valid for writes and properly aligned.\n+    unsafe { swap_nonoverlapping_bytes(x, y, len) }\n }\n \n #[inline]\n pub(crate) unsafe fn swap_nonoverlapping_one<T>(x: *mut T, y: *mut T) {\n     // For types smaller than the block optimization below,\n     // just swap directly to avoid pessimizing codegen.\n     if mem::size_of::<T>() < 32 {\n-        let z = read(x);\n-        copy_nonoverlapping(y, x, 1);\n-        write(y, z);\n+        // SAFETY: the caller must guarantee that `x` and `y` are valid\n+        // for writes, properly aligned, and non-overlapping.\n+        unsafe {\n+            let z = read(x);\n+            copy_nonoverlapping(y, x, 1);\n+            write(y, z);\n+        }\n     } else {\n-        swap_nonoverlapping(x, y, 1);\n+        // SAFETY: the caller must uphold the safety contract for `swap_nonoverlapping`.\n+        unsafe { swap_nonoverlapping(x, y, 1) };\n     }\n }\n \n@@ -471,14 +486,23 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n         // Declaring `t` here avoids aligning the stack when this loop is unused\n         let mut t = mem::MaybeUninit::<Block>::uninit();\n         let t = t.as_mut_ptr() as *mut u8;\n-        let x = x.add(i);\n-        let y = y.add(i);\n \n-        // Swap a block of bytes of x & y, using t as a temporary buffer\n-        // This should be optimized into efficient SIMD operations where available\n-        copy_nonoverlapping(x, t, block_size);\n-        copy_nonoverlapping(y, x, block_size);\n-        copy_nonoverlapping(t, y, block_size);\n+        // SAFETY: As `i < len`, and as the caller must guarantee that `x` and `y` are valid\n+        // for `len` bytes, `x + i` and `y + i` must be valid adresses, which fulfills the\n+        // safety contract for `add`.\n+        //\n+        // Also, the caller must guarantee that `x` and `y` are valid for writes, properly aligned,\n+        // and non-overlapping, which fulfills the safety contract for `copy_nonoverlapping`.\n+        unsafe {\n+            let x = x.add(i);\n+            let y = y.add(i);\n+\n+            // Swap a block of bytes of x & y, using t as a temporary buffer\n+            // This should be optimized into efficient SIMD operations where available\n+            copy_nonoverlapping(x, t, block_size);\n+            copy_nonoverlapping(y, x, block_size);\n+            copy_nonoverlapping(t, y, block_size);\n+        }\n         i += block_size;\n     }\n \n@@ -488,12 +512,16 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n         let rem = len - i;\n \n         let t = t.as_mut_ptr() as *mut u8;\n-        let x = x.add(i);\n-        let y = y.add(i);\n \n-        copy_nonoverlapping(x, t, rem);\n-        copy_nonoverlapping(y, x, rem);\n-        copy_nonoverlapping(t, y, rem);\n+        // SAFETY: see previous safety comment.\n+        unsafe {\n+            let x = x.add(i);\n+            let y = y.add(i);\n+\n+            copy_nonoverlapping(x, t, rem);\n+            copy_nonoverlapping(y, x, rem);\n+            copy_nonoverlapping(t, y, rem);\n+        }\n     }\n }\n \n@@ -540,7 +568,13 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n-    mem::swap(&mut *dst, &mut src); // cannot overlap\n+    // SAFETY: the caller must guarantee that `dst` is valid to be\n+    // cast to a mutable reference (valid for writes, aligned, initialized),\n+    // and cannot overlap `src` since `dst` must point to a distinct\n+    // allocated object.\n+    unsafe {\n+        mem::swap(&mut *dst, &mut src); // cannot overlap\n+    }\n     src\n }\n \n@@ -658,8 +692,16 @@ pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n pub unsafe fn read<T>(src: *const T) -> T {\n     // `copy_nonoverlapping` takes care of debug_assert.\n     let mut tmp = MaybeUninit::<T>::uninit();\n-    copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-    tmp.assume_init()\n+    // SAFETY: the caller must guarantee that `src` is valid for reads.\n+    // `src` cannot overlap `tmp` because `tmp` was just allocated on\n+    // the stack as a separate allocated object.\n+    //\n+    // Also, since we just wrote a valid value into `tmp`, it is guaranteed\n+    // to be properly initialized.\n+    unsafe {\n+        copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n+        tmp.assume_init()\n+    }\n }\n \n /// Reads the value from `src` without moving it. This leaves the\n@@ -752,8 +794,16 @@ pub unsafe fn read<T>(src: *const T) -> T {\n pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n     // `copy_nonoverlapping` takes care of debug_assert.\n     let mut tmp = MaybeUninit::<T>::uninit();\n-    copy_nonoverlapping(src as *const u8, tmp.as_mut_ptr() as *mut u8, mem::size_of::<T>());\n-    tmp.assume_init()\n+    // SAFETY: the caller must guarantee that `src` is valid for reads.\n+    // `src` cannot overlap `tmp` because `tmp` was just allocated on\n+    // the stack as a separate allocated object.\n+    //\n+    // Also, since we just wrote a valid value into `tmp`, it is guaranteed\n+    // to be properly initialized.\n+    unsafe {\n+        copy_nonoverlapping(src as *const u8, tmp.as_mut_ptr() as *mut u8, mem::size_of::<T>());\n+        tmp.assume_init()\n+    }\n }\n \n /// Overwrites a memory location with the given value without reading or\n@@ -847,7 +897,8 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n         // Not panicking to keep codegen impact smaller.\n         abort();\n     }\n-    intrinsics::move_val_init(&mut *dst, src)\n+    // SAFETY: the caller must uphold the safety contract for `move_val_init`.\n+    unsafe { intrinsics::move_val_init(&mut *dst, src) }\n }\n \n /// Overwrites a memory location with the given value without reading or\n@@ -939,8 +990,13 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n-    // `copy_nonoverlapping` takes care of debug_assert.\n-    copy_nonoverlapping(&src as *const T as *const u8, dst as *mut u8, mem::size_of::<T>());\n+    // SAFETY: the caller must guarantee that `dst` is valid for writes.\n+    // `dst` cannot overlap `src` because the caller has mutable access\n+    // to `dst` while `src` is owned by this function.\n+    unsafe {\n+        // `copy_nonoverlapping` takes care of debug_assert.\n+        copy_nonoverlapping(&src as *const T as *const u8, dst as *mut u8, mem::size_of::<T>());\n+    }\n     mem::forget(src);\n }\n \n@@ -1015,7 +1071,8 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n         // Not panicking to keep codegen impact smaller.\n         abort();\n     }\n-    intrinsics::volatile_load(src)\n+    // SAFETY: the caller must uphold the safety contract for `volatile_load`.\n+    unsafe { intrinsics::volatile_load(src) }\n }\n \n /// Performs a volatile write of a memory location with the given value without\n@@ -1087,7 +1144,10 @@ pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n         // Not panicking to keep codegen impact smaller.\n         abort();\n     }\n-    intrinsics::volatile_store(dst, src);\n+    // SAFETY: the caller must uphold the safety contract for `volatile_store`.\n+    unsafe {\n+        intrinsics::volatile_store(dst, src);\n+    }\n }\n \n /// Align pointer `p`.\n@@ -1173,8 +1233,8 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     }\n \n     let smoda = stride & a_minus_one;\n-    // a is power-of-two so cannot be 0. stride = 0 is handled above.\n-    let gcdpow = intrinsics::cttz_nonzero(stride).min(intrinsics::cttz_nonzero(a));\n+    // SAFETY: a is power-of-two so cannot be 0. stride = 0 is handled above.\n+    let gcdpow = unsafe { intrinsics::cttz_nonzero(stride).min(intrinsics::cttz_nonzero(a)) };\n     let gcd = 1usize << gcdpow;\n \n     if p as usize & (gcd.wrapping_sub(1)) == 0 {"}, {"sha": "7d4b6339b511f2b2e2ea331e156319b09af88da1", "filename": "src/libcore/ptr/mut_ptr.rs", "status": "modified", "additions": 44, "deletions": 20, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmut_ptr.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -89,7 +89,9 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n     pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n-        if self.is_null() { None } else { Some(&*self) }\n+        // SAFETY: the caller must guarantee that `self` is valid for a\n+        // reference if it isn't null.\n+        if self.is_null() { None } else { unsafe { Some(&*self) } }\n     }\n \n     /// Calculates the offset from a pointer.\n@@ -151,7 +153,10 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        intrinsics::offset(self, count) as *mut T\n+        // SAFETY: the caller must uphold the safety contract for `offset`.\n+        // The obtained pointer is valid for writes since the caller must\n+        // guarantee that it points to the same allocated object as `self`.\n+        unsafe { intrinsics::offset(self, count) as *mut T }\n     }\n \n     /// Calculates the offset from a pointer using wrapping arithmetic.\n@@ -270,7 +275,9 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n     pub unsafe fn as_mut<'a>(self) -> Option<&'a mut T> {\n-        if self.is_null() { None } else { Some(&mut *self) }\n+        // SAFETY: the caller must guarantee that `self` is be valid for\n+        // a mutable reference if it isn't null.\n+        if self.is_null() { None } else { unsafe { Some(&mut *self) } }\n     }\n \n     /// Returns whether two pointers are guaranteed to be equal.\n@@ -406,7 +413,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        (self as *const T).offset_from(origin)\n+        // SAFETY: the caller must uphold the safety contract for `offset_from`.\n+        unsafe { (self as *const T).offset_from(origin) }\n     }\n \n     /// Calculates the distance between two pointers. The returned value is in\n@@ -518,7 +526,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        self.offset(count as isize)\n+        // SAFETY: the caller must uphold the safety contract for `offset`.\n+        unsafe { self.offset(count as isize) }\n     }\n \n     /// Calculates the offset from a pointer (convenience for\n@@ -581,7 +590,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        self.offset((count as isize).wrapping_neg())\n+        // SAFETY: the caller must uphold the safety contract for `offset`.\n+        unsafe { self.offset((count as isize).wrapping_neg()) }\n     }\n \n     /// Calculates the offset from a pointer using wrapping arithmetic.\n@@ -710,7 +720,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        read(self)\n+        // SAFETY: the caller must uphold the safety contract for ``.\n+        unsafe { read(self) }\n     }\n \n     /// Performs a volatile read of the value from `self` without moving it. This\n@@ -729,7 +740,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        read_volatile(self)\n+        // SAFETY: the caller must uphold the safety contract for `read_volatile`.\n+        unsafe { read_volatile(self) }\n     }\n \n     /// Reads the value from `self` without moving it. This leaves the\n@@ -746,7 +758,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        read_unaligned(self)\n+        // SAFETY: the caller must uphold the safety contract for `read_unaligned`.\n+        unsafe { read_unaligned(self) }\n     }\n \n     /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n@@ -763,7 +776,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        copy(self, dest, count)\n+        // SAFETY: the caller must uphold the safety contract for `copy`.\n+        unsafe { copy(self, dest, count) }\n     }\n \n     /// Copies `count * size_of<T>` bytes from `self` to `dest`. The source\n@@ -780,7 +794,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        copy_nonoverlapping(self, dest, count)\n+        // SAFETY: the caller must uphold the safety contract for `copy_nonoverlapping`.\n+        unsafe { copy_nonoverlapping(self, dest, count) }\n     }\n \n     /// Copies `count * size_of<T>` bytes from `src` to `self`. The source\n@@ -797,7 +812,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        copy(src, self, count)\n+        // SAFETY: the caller must uphold the safety contract for `copy`.\n+        unsafe { copy(src, self, count) }\n     }\n \n     /// Copies `count * size_of<T>` bytes from `src` to `self`. The source\n@@ -814,7 +830,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        copy_nonoverlapping(src, self, count)\n+        // SAFETY: the caller must uphold the safety contract for `copy_nonoverlapping`.\n+        unsafe { copy_nonoverlapping(src, self, count) }\n     }\n \n     /// Executes the destructor (if any) of the pointed-to value.\n@@ -825,7 +842,8 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[inline]\n     pub unsafe fn drop_in_place(self) {\n-        drop_in_place(self)\n+        // SAFETY: the caller must uphold the safety contract for `drop_in_place`.\n+        unsafe { drop_in_place(self) }\n     }\n \n     /// Overwrites a memory location with the given value without reading or\n@@ -840,7 +858,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        write(self, val)\n+        // SAFETY: the caller must uphold the safety contract for `write`.\n+        unsafe { write(self, val) }\n     }\n \n     /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n@@ -855,7 +874,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        write_bytes(self, val, count)\n+        // SAFETY: the caller must uphold the safety contract for `write_bytes`.\n+        unsafe { write_bytes(self, val, count) }\n     }\n \n     /// Performs a volatile write of a memory location with the given value without\n@@ -874,7 +894,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        write_volatile(self, val)\n+        // SAFETY: the caller must uphold the safety contract for `write_volatile`.\n+        unsafe { write_volatile(self, val) }\n     }\n \n     /// Overwrites a memory location with the given value without reading or\n@@ -891,7 +912,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        write_unaligned(self, val)\n+        // SAFETY: the caller must uphold the safety contract for `write_unaligned`.\n+        unsafe { write_unaligned(self, val) }\n     }\n \n     /// Replaces the value at `self` with `src`, returning the old\n@@ -906,7 +928,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        replace(self, src)\n+        // SAFETY: the caller must uphold the safety contract for `replace`.\n+        unsafe { replace(self, src) }\n     }\n \n     /// Swaps the values at two mutable locations of the same type, without\n@@ -922,7 +945,8 @@ impl<T: ?Sized> *mut T {\n     where\n         T: Sized,\n     {\n-        swap(self, with)\n+        // SAFETY: the caller must uphold the safety contract for `swap`.\n+        unsafe { swap(self, with) }\n     }\n \n     /// Computes the offset that needs to be applied to the pointer in order to make it aligned to"}, {"sha": "c2d31bfb6a4ee717f01d547f2ca5133aa72a9e87", "filename": "src/libcore/ptr/non_null.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -87,7 +87,8 @@ impl<T: ?Sized> NonNull<T> {\n     #[rustc_const_stable(feature = \"const_nonnull_new_unchecked\", since = \"1.32.0\")]\n     #[inline]\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n-        NonNull { pointer: ptr as _ }\n+        // SAFETY: the caller must guarantee that `ptr` is non-null.\n+        unsafe { NonNull { pointer: ptr as _ } }\n     }\n \n     /// Creates a new `NonNull` if `ptr` is non-null.\n@@ -118,7 +119,9 @@ impl<T: ?Sized> NonNull<T> {\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n     pub unsafe fn as_ref(&self) -> &T {\n-        &*self.as_ptr()\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a reference.\n+        unsafe { &*self.as_ptr() }\n     }\n \n     /// Mutably dereferences the content.\n@@ -129,7 +132,9 @@ impl<T: ?Sized> NonNull<T> {\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n     pub unsafe fn as_mut(&mut self) -> &mut T {\n-        &mut *self.as_ptr()\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a mutable reference.\n+        unsafe { &mut *self.as_ptr() }\n     }\n \n     /// Casts to a pointer of another type."}, {"sha": "78647eee3389a3ee0d5a897b8af10fc8a3ced3b8", "filename": "src/libcore/ptr/unique.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Funique.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -87,7 +87,8 @@ impl<T: ?Sized> Unique<T> {\n     /// `ptr` must be non-null.\n     #[inline]\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n-        Unique { pointer: ptr as _, _marker: PhantomData }\n+        // SAFETY: the caller must guarantee that `ptr` is non-null.\n+        unsafe { Unique { pointer: ptr as _, _marker: PhantomData } }\n     }\n \n     /// Creates a new `Unique` if `ptr` is non-null.\n@@ -114,7 +115,9 @@ impl<T: ?Sized> Unique<T> {\n     /// (unbound) lifetime is needed, use `&*my_ptr.as_ptr()`.\n     #[inline]\n     pub unsafe fn as_ref(&self) -> &T {\n-        &*self.as_ptr()\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a reference.\n+        unsafe { &*self.as_ptr() }\n     }\n \n     /// Mutably dereferences the content.\n@@ -124,7 +127,9 @@ impl<T: ?Sized> Unique<T> {\n     /// (unbound) lifetime is needed, use `&mut *my_ptr.as_ptr()`.\n     #[inline]\n     pub unsafe fn as_mut(&mut self) -> &mut T {\n-        &mut *self.as_ptr()\n+        // SAFETY: the caller must guarantee that `self` meets all the\n+        // requirements for a mutable reference.\n+        unsafe { &mut *self.as_ptr() }\n     }\n \n     /// Casts to a pointer of another type."}, {"sha": "e7a2d7adedea0ddc56e62475a11c83dcb9408063", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 162, "deletions": 43, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -310,7 +310,8 @@ impl<T> [T] {\n     where\n         I: SliceIndex<Self>,\n     {\n-        index.get_unchecked(self)\n+        // SAFETY: the caller must uphold the safety requirements for `get_unchecked`.\n+        unsafe { index.get_unchecked(self) }\n     }\n \n     /// Returns a mutable reference to an element or subslice, without doing\n@@ -341,7 +342,8 @@ impl<T> [T] {\n     where\n         I: SliceIndex<Self>,\n     {\n-        index.get_unchecked_mut(self)\n+        // SAFETY: the caller must uphold the safety requirements for `get_unchecked_mut`.\n+        unsafe { index.get_unchecked_mut(self) }\n     }\n \n     /// Returns a raw pointer to the slice's buffer.\n@@ -1459,6 +1461,68 @@ impl<T> [T] {\n         m >= n && needle == &self[m - n..]\n     }\n \n+    /// Returns a subslice with the prefix removed.\n+    ///\n+    /// This method returns [`None`] if slice does not start with `prefix`.\n+    /// Also it returns the original slice if `prefix` is an empty slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_strip)]\n+    /// let v = &[10, 40, 30];\n+    /// assert_eq!(v.strip_prefix(&[10]), Some(&[40, 30][..]));\n+    /// assert_eq!(v.strip_prefix(&[10, 40]), Some(&[30][..]));\n+    /// assert_eq!(v.strip_prefix(&[50]), None);\n+    /// assert_eq!(v.strip_prefix(&[10, 50]), None);\n+    /// ```\n+    #[must_use = \"returns the subslice without modifying the original\"]\n+    #[unstable(feature = \"slice_strip\", issue = \"73413\")]\n+    pub fn strip_prefix(&self, prefix: &[T]) -> Option<&[T]>\n+    where\n+        T: PartialEq,\n+    {\n+        let n = prefix.len();\n+        if n <= self.len() {\n+            let (head, tail) = self.split_at(n);\n+            if head == prefix {\n+                return Some(tail);\n+            }\n+        }\n+        None\n+    }\n+\n+    /// Returns a subslice with the suffix removed.\n+    ///\n+    /// This method returns [`None`] if slice does not end with `suffix`.\n+    /// Also it returns the original slice if `suffix` is an empty slice\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_strip)]\n+    /// let v = &[10, 40, 30];\n+    /// assert_eq!(v.strip_suffix(&[30]), Some(&[10, 40][..]));\n+    /// assert_eq!(v.strip_suffix(&[40, 30]), Some(&[10][..]));\n+    /// assert_eq!(v.strip_suffix(&[50]), None);\n+    /// assert_eq!(v.strip_suffix(&[50, 30]), None);\n+    /// ```\n+    #[must_use = \"returns the subslice without modifying the original\"]\n+    #[unstable(feature = \"slice_strip\", issue = \"73413\")]\n+    pub fn strip_suffix(&self, suffix: &[T]) -> Option<&[T]>\n+    where\n+        T: PartialEq,\n+    {\n+        let (len, n) = (self.len(), suffix.len());\n+        if n <= len {\n+            let (head, tail) = self.split_at(len - n);\n+            if tail == suffix {\n+                return Some(head);\n+            }\n+        }\n+        None\n+    }\n+\n     /// Binary searches this sorted slice for a given element.\n     ///\n     /// If the value is found then [`Result::Ok`] is returned, containing the\n@@ -2519,18 +2583,21 @@ impl<T> [T] {\n         // First, find at what point do we split between the first and 2nd slice. Easy with\n         // ptr.align_offset.\n         let ptr = self.as_ptr();\n-        let offset = crate::ptr::align_offset(ptr, mem::align_of::<U>());\n+        let offset = unsafe { crate::ptr::align_offset(ptr, mem::align_of::<U>()) };\n         if offset > self.len() {\n             (self, &[], &[])\n         } else {\n             let (left, rest) = self.split_at(offset);\n-            // now `rest` is definitely aligned, so `from_raw_parts_mut` below is okay\n             let (us_len, ts_len) = rest.align_to_offsets::<U>();\n-            (\n-                left,\n-                from_raw_parts(rest.as_ptr() as *const U, us_len),\n-                from_raw_parts(rest.as_ptr().add(rest.len() - ts_len), ts_len),\n-            )\n+            // SAFETY: now `rest` is definitely aligned, so `from_raw_parts` below is okay,\n+            // since the caller guarantees that we can transmute `T` to `U` safely.\n+            unsafe {\n+                (\n+                    left,\n+                    from_raw_parts(rest.as_ptr() as *const U, us_len),\n+                    from_raw_parts(rest.as_ptr().add(rest.len() - ts_len), ts_len),\n+                )\n+            }\n         }\n     }\n \n@@ -2575,21 +2642,23 @@ impl<T> [T] {\n         // First, find at what point do we split between the first and 2nd slice. Easy with\n         // ptr.align_offset.\n         let ptr = self.as_ptr();\n-        let offset = crate::ptr::align_offset(ptr, mem::align_of::<U>());\n+        let offset = unsafe { crate::ptr::align_offset(ptr, mem::align_of::<U>()) };\n         if offset > self.len() {\n             (self, &mut [], &mut [])\n         } else {\n             let (left, rest) = self.split_at_mut(offset);\n-            // now `rest` is definitely aligned, so `from_raw_parts_mut` below is okay\n             let (us_len, ts_len) = rest.align_to_offsets::<U>();\n             let rest_len = rest.len();\n             let mut_ptr = rest.as_mut_ptr();\n             // We can't use `rest` again after this, that would invalidate its alias `mut_ptr`!\n-            (\n-                left,\n-                from_raw_parts_mut(mut_ptr as *mut U, us_len),\n-                from_raw_parts_mut(mut_ptr.add(rest_len - ts_len), ts_len),\n-            )\n+            // SAFETY: see comments for `align_to`.\n+            unsafe {\n+                (\n+                    left,\n+                    from_raw_parts_mut(mut_ptr as *mut U, us_len),\n+                    from_raw_parts_mut(mut_ptr.add(rest_len - ts_len), ts_len),\n+                )\n+            }\n         }\n     }\n \n@@ -2914,12 +2983,18 @@ impl<T> SliceIndex<[T]> for usize {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &T {\n-        &*slice.as_ptr().add(self)\n+        // SAFETY: `slice` cannot be longer than `isize::MAX` and\n+        // the caller guarantees that `self` is in bounds of `slice`\n+        // so `self` cannot overflow an `isize`, so the call to `add` is safe.\n+        // The obtained pointer comes from a reference which is guaranteed\n+        // to be valid.\n+        unsafe { &*slice.as_ptr().add(self) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut T {\n-        &mut *slice.as_mut_ptr().add(self)\n+        // SAFETY: see comments for `get_unchecked` above.\n+        unsafe { &mut *slice.as_mut_ptr().add(self) }\n     }\n \n     #[inline]\n@@ -2959,12 +3034,18 @@ impl<T> SliceIndex<[T]> for ops::Range<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start)\n+        // SAFETY: `slice` cannot be longer than `isize::MAX` and\n+        // the caller guarantees that `self` is in bounds of `slice`\n+        // so `self` cannot overflow an `isize`, so the call to `add` is safe.\n+        // Also, since the caller guarantees that `self` is in bounds of `slice`,\n+        // `from_raw_parts` will give a subslice of `slice` which is always safe.\n+        unsafe { from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start)\n+        // SAFETY: see comments for `get_unchecked` above.\n+        unsafe { from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start) }\n     }\n \n     #[inline]\n@@ -3004,12 +3085,14 @@ impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        (0..self.end).get_unchecked(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (0..self.end).get_unchecked(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (0..self.end).get_unchecked_mut(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (0..self.end).get_unchecked_mut(slice) }\n     }\n \n     #[inline]\n@@ -3039,12 +3122,14 @@ impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        (self.start..slice.len()).get_unchecked(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (self.start..slice.len()).get_unchecked(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (self.start..slice.len()).get_unchecked_mut(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (self.start..slice.len()).get_unchecked_mut(slice) }\n     }\n \n     #[inline]\n@@ -3113,12 +3198,14 @@ impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        (*self.start()..self.end() + 1).get_unchecked(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (*self.start()..self.end() + 1).get_unchecked_mut(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n     }\n \n     #[inline]\n@@ -3154,12 +3241,14 @@ impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        (0..=self.end).get_unchecked(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (0..=self.end).get_unchecked(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (0..=self.end).get_unchecked_mut(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (0..=self.end).get_unchecked_mut(slice) }\n     }\n \n     #[inline]\n@@ -3308,7 +3397,9 @@ macro_rules! iterator {\n                     self.ptr.as_ptr()\n                 } else {\n                     let old = self.ptr.as_ptr();\n-                    self.ptr = NonNull::new_unchecked(self.ptr.as_ptr().offset(offset));\n+                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n+                    // so this new pointer is inside `self` and thus guaranteed to be non-null.\n+                    self.ptr = unsafe { NonNull::new_unchecked(self.ptr.as_ptr().offset(offset)) };\n                     old\n                 }\n             }\n@@ -3322,7 +3413,10 @@ macro_rules! iterator {\n                     zst_shrink!(self, offset);\n                     self.ptr.as_ptr()\n                 } else {\n-                    self.end = self.end.offset(-offset);\n+                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n+                    // which is guaranteed to not overflow an `isize`. Also, the resulting pointer\n+                    // is in bounds of `slice`, which fulfills the other requirements for `offset`.\n+                    self.end = unsafe { self.end.offset(-offset) };\n                     self.end\n                 }\n             }\n@@ -4640,7 +4734,11 @@ impl<T> FusedIterator for Windows<'_, T> {}\n #[doc(hidden)]\n unsafe impl<'a, T> TrustedRandomAccess for Windows<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n-        from_raw_parts(self.v.as_ptr().add(i), self.size)\n+        // SAFETY: since the caller guarantees that `i` is in bounds,\n+        // which means that `i` cannot overflow an `isize`, and the\n+        // slice created by `from_raw_parts` is a subslice of `self.v`\n+        // thus is guaranteed to be valid for the lifetime `'a` of `self.v`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(i), self.size) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -4784,7 +4882,14 @@ unsafe impl<'a, T> TrustedRandomAccess for Chunks<'a, T> {\n             None => self.v.len(),\n             Some(end) => cmp::min(end, self.v.len()),\n         };\n-        from_raw_parts(self.v.as_ptr().add(start), end - start)\n+        // SAFETY: the caller guarantees that `i` is in bounds,\n+        // which means that `start` must be in bounds of the\n+        // underlying `self.v` slice, and we made sure that `end`\n+        // is also in bounds of `self.v`. Thus, `start` cannot overflow\n+        // an `isize`, and the slice constructed by `from_raw_parts`\n+        // is a subslice of `self.v` which is guaranteed to be valid\n+        // for the lifetime `'a` of `self.v`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(start), end - start) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -4926,7 +5031,8 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksMut<'a, T> {\n             None => self.v.len(),\n             Some(end) => cmp::min(end, self.v.len()),\n         };\n-        from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start)\n+        // SAFETY: see comments for `Chunks::get_unchecked`.\n+        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5063,7 +5169,8 @@ impl<T> FusedIterator for ChunksExact<'_, T> {}\n unsafe impl<'a, T> TrustedRandomAccess for ChunksExact<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n         let start = i * self.chunk_size;\n-        from_raw_parts(self.v.as_ptr().add(start), self.chunk_size)\n+        // SAFETY: mostly identical to `Chunks::get_unchecked`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(start), self.chunk_size) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5197,7 +5304,8 @@ impl<T> FusedIterator for ChunksExactMut<'_, T> {}\n unsafe impl<'a, T> TrustedRandomAccess for ChunksExactMut<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n         let start = i * self.chunk_size;\n-        from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size)\n+        // SAFETY: see comments for `ChunksExactMut::get_unchecked`.\n+        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5344,7 +5452,8 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunks<'a, T> {\n             None => 0,\n             Some(start) => start,\n         };\n-        from_raw_parts(self.v.as_ptr().add(start), end - start)\n+        // SAFETY: mostly identical to `Chunks::get_unchecked`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(start), end - start) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5489,7 +5598,8 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksMut<'a, T> {\n             None => 0,\n             Some(start) => start,\n         };\n-        from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start)\n+        // SAFETY: see comments for `RChunks::get_unchecked`.\n+        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5630,7 +5740,8 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksExact<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n         let end = self.v.len() - i * self.chunk_size;\n         let start = end - self.chunk_size;\n-        from_raw_parts(self.v.as_ptr().add(start), self.chunk_size)\n+        // SAFETY: mostmy identical to `Chunks::get_unchecked`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(start), self.chunk_size) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5769,7 +5880,8 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksExactMut<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n         let end = self.v.len() - i * self.chunk_size;\n         let start = end - self.chunk_size;\n-        from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size)\n+        // SAFETY: see comments for `RChunksExact::get_unchecked`.\n+        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5865,7 +5977,8 @@ pub unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n         mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n         \"attempt to create slice covering at least half the address space\"\n     );\n-    &*ptr::slice_from_raw_parts(data, len)\n+    // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n+    unsafe { &*ptr::slice_from_raw_parts(data, len) }\n }\n \n /// Performs the same functionality as [`from_raw_parts`], except that a\n@@ -5905,7 +6018,8 @@ pub unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T]\n         mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n         \"attempt to create slice covering at least half the address space\"\n     );\n-    &mut *ptr::slice_from_raw_parts_mut(data, len)\n+    // SAFETY: the caller must uphold the safety contract for `from_raw_parts_mut`.\n+    unsafe { &mut *ptr::slice_from_raw_parts_mut(data, len) }\n }\n \n /// Converts a reference to T into a slice of length 1 (without copying).\n@@ -6181,7 +6295,11 @@ impl_marker_for!(BytewiseEquality,\n #[doc(hidden)]\n unsafe impl<'a, T> TrustedRandomAccess for Iter<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a T {\n-        &*self.ptr.as_ptr().add(i)\n+        // SAFETY: the caller must guarantee that `i` is in bounds\n+        // of the underlying slice, so `i` cannot overflow an `isize`,\n+        // and the returned references is guaranteed to refer to an element\n+        // of the slice and thus guaranteed to be valid.\n+        unsafe { &*self.ptr.as_ptr().add(i) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -6191,7 +6309,8 @@ unsafe impl<'a, T> TrustedRandomAccess for Iter<'a, T> {\n #[doc(hidden)]\n unsafe impl<'a, T> TrustedRandomAccess for IterMut<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut T {\n-        &mut *self.ptr.as_ptr().add(i)\n+        // SAFETY: see comments for `Iter::get_unchecked`.\n+        unsafe { &mut *self.ptr.as_ptr().add(i) }\n     }\n     fn may_have_side_effect() -> bool {\n         false"}, {"sha": "a89596b15ef94c31122c845e3f6041449f6018e8", "filename": "src/libcore/slice/rotate.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Frotate.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -1,3 +1,5 @@\n+// ignore-tidy-undocumented-unsafe\n+\n use crate::cmp;\n use crate::mem::{self, MaybeUninit};\n use crate::ptr;\n@@ -77,9 +79,9 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             // the way until about `left + right == 32`, but the worst case performance breaks even\n             // around 16. 24 was chosen as middle ground. If the size of `T` is larger than 4\n             // `usize`s, this algorithm also outperforms other algorithms.\n-            let x = mid.sub(left);\n+            let x = unsafe { mid.sub(left) };\n             // beginning of first round\n-            let mut tmp: T = x.read();\n+            let mut tmp: T = unsafe { x.read() };\n             let mut i = right;\n             // `gcd` can be found before hand by calculating `gcd(left + right, right)`,\n             // but it is faster to do one loop which calculates the gcd as a side effect, then\n@@ -90,15 +92,15 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             // the very end. This is possibly due to the fact that swapping or replacing temporaries\n             // uses only one memory address in the loop instead of needing to manage two.\n             loop {\n-                tmp = x.add(i).replace(tmp);\n+                tmp = unsafe { x.add(i).replace(tmp) };\n                 // instead of incrementing `i` and then checking if it is outside the bounds, we\n                 // check if `i` will go outside the bounds on the next increment. This prevents\n                 // any wrapping of pointers or `usize`.\n                 if i >= left {\n                     i -= left;\n                     if i == 0 {\n                         // end of first round\n-                        x.write(tmp);\n+                        unsafe { x.write(tmp) };\n                         break;\n                     }\n                     // this conditional must be here if `left + right >= 15`\n@@ -111,14 +113,14 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             }\n             // finish the chunk with more rounds\n             for start in 1..gcd {\n-                tmp = x.add(start).read();\n+                tmp = unsafe { x.add(start).read() };\n                 i = start + right;\n                 loop {\n-                    tmp = x.add(i).replace(tmp);\n+                    tmp = unsafe { x.add(i).replace(tmp) };\n                     if i >= left {\n                         i -= left;\n                         if i == start {\n-                            x.add(start).write(tmp);\n+                            unsafe { x.add(start).write(tmp) };\n                             break;\n                         }\n                     } else {\n@@ -133,15 +135,19 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             // The `[T; 0]` here is to ensure this is appropriately aligned for T\n             let mut rawarray = MaybeUninit::<(BufType, [T; 0])>::uninit();\n             let buf = rawarray.as_mut_ptr() as *mut T;\n-            let dim = mid.sub(left).add(right);\n+            let dim = unsafe { mid.sub(left).add(right) };\n             if left <= right {\n-                ptr::copy_nonoverlapping(mid.sub(left), buf, left);\n-                ptr::copy(mid, mid.sub(left), right);\n-                ptr::copy_nonoverlapping(buf, dim, left);\n+                unsafe {\n+                    ptr::copy_nonoverlapping(mid.sub(left), buf, left);\n+                    ptr::copy(mid, mid.sub(left), right);\n+                    ptr::copy_nonoverlapping(buf, dim, left);\n+                }\n             } else {\n-                ptr::copy_nonoverlapping(mid, buf, right);\n-                ptr::copy(mid.sub(left), dim, left);\n-                ptr::copy_nonoverlapping(buf, mid.sub(left), right);\n+                unsafe {\n+                    ptr::copy_nonoverlapping(mid, buf, right);\n+                    ptr::copy(mid.sub(left), dim, left);\n+                    ptr::copy_nonoverlapping(buf, mid.sub(left), right);\n+                }\n             }\n             return;\n         } else if left >= right {\n@@ -150,8 +156,10 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             // of this algorithm would be, and swapping using that last chunk instead of swapping\n             // adjacent chunks like this algorithm is doing, but this way is still faster.\n             loop {\n-                ptr::swap_nonoverlapping(mid.sub(right), mid, right);\n-                mid = mid.sub(right);\n+                unsafe {\n+                    ptr::swap_nonoverlapping(mid.sub(right), mid, right);\n+                    mid = mid.sub(right);\n+                }\n                 left -= right;\n                 if left < right {\n                     break;\n@@ -160,8 +168,10 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n         } else {\n             // Algorithm 3, `left < right`\n             loop {\n-                ptr::swap_nonoverlapping(mid.sub(left), mid, left);\n-                mid = mid.add(left);\n+                unsafe {\n+                    ptr::swap_nonoverlapping(mid.sub(left), mid, left);\n+                    mid = mid.add(left);\n+                }\n                 right -= left;\n                 if right < left {\n                     break;"}, {"sha": "0014501d2c4d0624958317bcde37ecd587454180", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 77, "deletions": 22, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -419,7 +419,11 @@ pub fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n-    &*(v as *const [u8] as *const str)\n+    // SAFETY: the caller must guarantee that the bytes `v`\n+    // are valid UTF-8, thus the cast to `*const str` is safe.\n+    // Also, the pointer dereference is safe because that pointer\n+    // comes from a reference which is guaranteed to be valid for reads.\n+    unsafe { &*(v as *const [u8] as *const str) }\n }\n \n /// Converts a slice of bytes to a string slice without checking\n@@ -444,7 +448,11 @@ pub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n #[inline]\n #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n pub unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {\n-    &mut *(v as *mut [u8] as *mut str)\n+    // SAFETY: the caller must guarantee that the bytes `v`\n+    // are valid UTF-8, thus the cast to `*mut str` is safe.\n+    // Also, the pointer dereference is safe because that pointer\n+    // comes from a reference which is guaranteed to be valid for writes.\n+    unsafe { &mut *(v as *mut [u8] as *mut str) }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -867,7 +875,9 @@ unsafe impl TrustedLen for Bytes<'_> {}\n #[doc(hidden)]\n unsafe impl TrustedRandomAccess for Bytes<'_> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> u8 {\n-        self.0.get_unchecked(i)\n+        // SAFETY: the caller must uphold the safety contract\n+        // for `TrustedRandomAccess::get_unchecked`.\n+        unsafe { self.0.get_unchecked(i) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -1904,15 +1914,27 @@ mod traits {\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n-            let ptr = slice.as_ptr().add(self.start);\n+            // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n+            // which satisfies all the conditions for `add`.\n+            let ptr = unsafe { slice.as_ptr().add(self.start) };\n             let len = self.end - self.start;\n-            super::from_utf8_unchecked(slice::from_raw_parts(ptr, len))\n+            // SAFETY: as the caller guarantees that `self` is in bounds of `slice`,\n+            // we can safely construct a subslice with `from_raw_parts` and use it\n+            // since we return a shared thus immutable reference.\n+            // The call to `from_utf8_unchecked` is safe since the data comes from\n+            // a `str` which is guaranteed to be valid utf8, since the caller\n+            // must guarantee that `self.start` and `self.end` are char boundaries.\n+            unsafe { super::from_utf8_unchecked(slice::from_raw_parts(ptr, len)) }\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            let ptr = slice.as_mut_ptr().add(self.start);\n+            // SAFETY: see comments for `get_unchecked`.\n+            let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n             let len = self.end - self.start;\n-            super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, len))\n+            // SAFETY: mostly identical to the comments for `get_unchecked`, except that we\n+            // can return a mutable reference since the caller passed a mutable reference\n+            // and is thus guaranteed to have exclusive write access to `slice`.\n+            unsafe { super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, len)) }\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -1974,12 +1996,21 @@ mod traits {\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n             let ptr = slice.as_ptr();\n-            super::from_utf8_unchecked(slice::from_raw_parts(ptr, self.end))\n+            // SAFETY: as the caller guarantees that `self` is in bounds of `slice`,\n+            // we can safely construct a subslice with `from_raw_parts` and use it\n+            // since we return a shared thus immutable reference.\n+            // The call to `from_utf8_unchecked` is safe since the data comes from\n+            // a `str` which is guaranteed to be valid utf8, since the caller\n+            // must guarantee that `self.end` is a char boundary.\n+            unsafe { super::from_utf8_unchecked(slice::from_raw_parts(ptr, self.end)) }\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n             let ptr = slice.as_mut_ptr();\n-            super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, self.end))\n+            // SAFETY: mostly identical to `get_unchecked`, except that we can safely\n+            // return a mutable reference since the caller passed a mutable reference\n+            // and is thus guaranteed to have exclusive write access to `slice`.\n+            unsafe { super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, self.end)) }\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -2036,15 +2067,27 @@ mod traits {\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n-            let ptr = slice.as_ptr().add(self.start);\n+            // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n+            // which satisfies all the conditions for `add`.\n+            let ptr = unsafe { slice.as_ptr().add(self.start) };\n             let len = slice.len() - self.start;\n-            super::from_utf8_unchecked(slice::from_raw_parts(ptr, len))\n+            // SAFETY: as the caller guarantees that `self` is in bounds of `slice`,\n+            // we can safely construct a subslice with `from_raw_parts` and use it\n+            // since we return a shared thus immutable reference.\n+            // The call to `from_utf8_unchecked` is safe since the data comes from\n+            // a `str` which is guaranteed to be valid utf8, since the caller\n+            // must guarantee that `self.start` is a char boundary.\n+            unsafe { super::from_utf8_unchecked(slice::from_raw_parts(ptr, len)) }\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            let ptr = slice.as_mut_ptr().add(self.start);\n+            // SAFETY: identical to `get_unchecked`.\n+            let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n             let len = slice.len() - self.start;\n-            super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, len))\n+            // SAFETY: mostly identical to `get_unchecked`, except that we can safely\n+            // return a mutable reference since the caller passed a mutable reference\n+            // and is thus guaranteed to have exclusive write access to `slice`.\n+            unsafe { super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, len)) }\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -2099,11 +2142,13 @@ mod traits {\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n-            (*self.start()..self.end() + 1).get_unchecked(slice)\n+            // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n+            unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            (*self.start()..self.end() + 1).get_unchecked_mut(slice)\n+            // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n+            unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -2148,11 +2193,13 @@ mod traits {\n         }\n         #[inline]\n         unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n-            (..self.end + 1).get_unchecked(slice)\n+            // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n+            unsafe { (..self.end + 1).get_unchecked(slice) }\n         }\n         #[inline]\n         unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n-            (..self.end + 1).get_unchecked_mut(slice)\n+            // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n+            unsafe { (..self.end + 1).get_unchecked_mut(slice) }\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -2373,7 +2420,11 @@ impl str {\n     #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n     #[inline(always)]\n     pub unsafe fn as_bytes_mut(&mut self) -> &mut [u8] {\n-        &mut *(self as *mut str as *mut [u8])\n+        // SAFETY: the cast from `&str` to `&[u8]` is safe since `str`\n+        // has the same layout as `&[u8]` (only libstd can make this guarantee).\n+        // The pointer dereference is safe since it comes from a mutable reference which\n+        // is guaranteed to be valid for writes.\n+        unsafe { &mut *(self as *mut str as *mut [u8]) }\n     }\n \n     /// Converts a string slice to a raw pointer.\n@@ -2509,7 +2560,8 @@ impl str {\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n-        i.get_unchecked(self)\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n+        unsafe { i.get_unchecked(self) }\n     }\n \n     /// Returns a mutable, unchecked subslice of `str`.\n@@ -2541,7 +2593,8 @@ impl str {\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n-        i.get_unchecked_mut(self)\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { i.get_unchecked_mut(self) }\n     }\n \n     /// Creates a string slice from another string slice, bypassing safety\n@@ -2591,7 +2644,8 @@ impl str {\n     #[rustc_deprecated(since = \"1.29.0\", reason = \"use `get_unchecked(begin..end)` instead\")]\n     #[inline]\n     pub unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n-        (begin..end).get_unchecked(self)\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n+        unsafe { (begin..end).get_unchecked(self) }\n     }\n \n     /// Creates a string slice from another string slice, bypassing safety\n@@ -2622,7 +2676,8 @@ impl str {\n     #[rustc_deprecated(since = \"1.29.0\", reason = \"use `get_unchecked_mut(begin..end)` instead\")]\n     #[inline]\n     pub unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n-        (begin..end).get_unchecked_mut(self)\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (begin..end).get_unchecked_mut(self) }\n     }\n \n     /// Divide one string slice into two at an index."}, {"sha": "fcae6c86774f24c9397aee4d6626e55a2526f9db", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 149, "deletions": 104, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -2335,61 +2335,76 @@ fn strongest_failure_ordering(order: Ordering) -> Ordering {\n \n #[inline]\n unsafe fn atomic_store<T: Copy>(dst: *mut T, val: T, order: Ordering) {\n-    match order {\n-        Release => intrinsics::atomic_store_rel(dst, val),\n-        Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_store(dst, val),\n-        Acquire => panic!(\"there is no such thing as an acquire store\"),\n-        AcqRel => panic!(\"there is no such thing as an acquire/release store\"),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_store`.\n+    unsafe {\n+        match order {\n+            Release => intrinsics::atomic_store_rel(dst, val),\n+            Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_store(dst, val),\n+            Acquire => panic!(\"there is no such thing as an acquire store\"),\n+            AcqRel => panic!(\"there is no such thing as an acquire/release store\"),\n+        }\n     }\n }\n \n #[inline]\n unsafe fn atomic_load<T: Copy>(dst: *const T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_load_acq(dst),\n-        Relaxed => intrinsics::atomic_load_relaxed(dst),\n-        SeqCst => intrinsics::atomic_load(dst),\n-        Release => panic!(\"there is no such thing as a release load\"),\n-        AcqRel => panic!(\"there is no such thing as an acquire/release load\"),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_load`.\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_load_acq(dst),\n+            Relaxed => intrinsics::atomic_load_relaxed(dst),\n+            SeqCst => intrinsics::atomic_load(dst),\n+            Release => panic!(\"there is no such thing as a release load\"),\n+            AcqRel => panic!(\"there is no such thing as an acquire/release load\"),\n+        }\n     }\n }\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_swap<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_xchg_acq(dst, val),\n-        Release => intrinsics::atomic_xchg_rel(dst, val),\n-        AcqRel => intrinsics::atomic_xchg_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_xchg_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_xchg(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_swap`.\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_xchg_acq(dst, val),\n+            Release => intrinsics::atomic_xchg_rel(dst, val),\n+            AcqRel => intrinsics::atomic_xchg_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_xchg_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_xchg(dst, val),\n+        }\n     }\n }\n \n /// Returns the previous value (like __sync_fetch_and_add).\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_add<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_xadd_acq(dst, val),\n-        Release => intrinsics::atomic_xadd_rel(dst, val),\n-        AcqRel => intrinsics::atomic_xadd_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_xadd_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_xadd(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_add`.\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_xadd_acq(dst, val),\n+            Release => intrinsics::atomic_xadd_rel(dst, val),\n+            AcqRel => intrinsics::atomic_xadd_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_xadd_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_xadd(dst, val),\n+        }\n     }\n }\n \n /// Returns the previous value (like __sync_fetch_and_sub).\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_sub<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_xsub_acq(dst, val),\n-        Release => intrinsics::atomic_xsub_rel(dst, val),\n-        AcqRel => intrinsics::atomic_xsub_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_xsub_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_xsub(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_sub`.\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_xsub_acq(dst, val),\n+            Release => intrinsics::atomic_xsub_rel(dst, val),\n+            AcqRel => intrinsics::atomic_xsub_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_xsub_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_xsub(dst, val),\n+        }\n     }\n }\n \n@@ -2402,19 +2417,22 @@ unsafe fn atomic_compare_exchange<T: Copy>(\n     success: Ordering,\n     failure: Ordering,\n ) -> Result<T, T> {\n-    let (val, ok) = match (success, failure) {\n-        (Acquire, Acquire) => intrinsics::atomic_cxchg_acq(dst, old, new),\n-        (Release, Relaxed) => intrinsics::atomic_cxchg_rel(dst, old, new),\n-        (AcqRel, Acquire) => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n-        (Relaxed, Relaxed) => intrinsics::atomic_cxchg_relaxed(dst, old, new),\n-        (SeqCst, SeqCst) => intrinsics::atomic_cxchg(dst, old, new),\n-        (Acquire, Relaxed) => intrinsics::atomic_cxchg_acq_failrelaxed(dst, old, new),\n-        (AcqRel, Relaxed) => intrinsics::atomic_cxchg_acqrel_failrelaxed(dst, old, new),\n-        (SeqCst, Relaxed) => intrinsics::atomic_cxchg_failrelaxed(dst, old, new),\n-        (SeqCst, Acquire) => intrinsics::atomic_cxchg_failacq(dst, old, new),\n-        (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n-        (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n-        _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_compare_exchange`.\n+    let (val, ok) = unsafe {\n+        match (success, failure) {\n+            (Acquire, Acquire) => intrinsics::atomic_cxchg_acq(dst, old, new),\n+            (Release, Relaxed) => intrinsics::atomic_cxchg_rel(dst, old, new),\n+            (AcqRel, Acquire) => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n+            (Relaxed, Relaxed) => intrinsics::atomic_cxchg_relaxed(dst, old, new),\n+            (SeqCst, SeqCst) => intrinsics::atomic_cxchg(dst, old, new),\n+            (Acquire, Relaxed) => intrinsics::atomic_cxchg_acq_failrelaxed(dst, old, new),\n+            (AcqRel, Relaxed) => intrinsics::atomic_cxchg_acqrel_failrelaxed(dst, old, new),\n+            (SeqCst, Relaxed) => intrinsics::atomic_cxchg_failrelaxed(dst, old, new),\n+            (SeqCst, Acquire) => intrinsics::atomic_cxchg_failacq(dst, old, new),\n+            (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n+            (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n+            _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n+        }\n     };\n     if ok { Ok(val) } else { Err(val) }\n }\n@@ -2428,120 +2446,147 @@ unsafe fn atomic_compare_exchange_weak<T: Copy>(\n     success: Ordering,\n     failure: Ordering,\n ) -> Result<T, T> {\n-    let (val, ok) = match (success, failure) {\n-        (Acquire, Acquire) => intrinsics::atomic_cxchgweak_acq(dst, old, new),\n-        (Release, Relaxed) => intrinsics::atomic_cxchgweak_rel(dst, old, new),\n-        (AcqRel, Acquire) => intrinsics::atomic_cxchgweak_acqrel(dst, old, new),\n-        (Relaxed, Relaxed) => intrinsics::atomic_cxchgweak_relaxed(dst, old, new),\n-        (SeqCst, SeqCst) => intrinsics::atomic_cxchgweak(dst, old, new),\n-        (Acquire, Relaxed) => intrinsics::atomic_cxchgweak_acq_failrelaxed(dst, old, new),\n-        (AcqRel, Relaxed) => intrinsics::atomic_cxchgweak_acqrel_failrelaxed(dst, old, new),\n-        (SeqCst, Relaxed) => intrinsics::atomic_cxchgweak_failrelaxed(dst, old, new),\n-        (SeqCst, Acquire) => intrinsics::atomic_cxchgweak_failacq(dst, old, new),\n-        (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n-        (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n-        _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_compare_exchange_weak`.\n+    let (val, ok) = unsafe {\n+        match (success, failure) {\n+            (Acquire, Acquire) => intrinsics::atomic_cxchgweak_acq(dst, old, new),\n+            (Release, Relaxed) => intrinsics::atomic_cxchgweak_rel(dst, old, new),\n+            (AcqRel, Acquire) => intrinsics::atomic_cxchgweak_acqrel(dst, old, new),\n+            (Relaxed, Relaxed) => intrinsics::atomic_cxchgweak_relaxed(dst, old, new),\n+            (SeqCst, SeqCst) => intrinsics::atomic_cxchgweak(dst, old, new),\n+            (Acquire, Relaxed) => intrinsics::atomic_cxchgweak_acq_failrelaxed(dst, old, new),\n+            (AcqRel, Relaxed) => intrinsics::atomic_cxchgweak_acqrel_failrelaxed(dst, old, new),\n+            (SeqCst, Relaxed) => intrinsics::atomic_cxchgweak_failrelaxed(dst, old, new),\n+            (SeqCst, Acquire) => intrinsics::atomic_cxchgweak_failacq(dst, old, new),\n+            (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n+            (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n+            _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n+        }\n     };\n     if ok { Ok(val) } else { Err(val) }\n }\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_and<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_and_acq(dst, val),\n-        Release => intrinsics::atomic_and_rel(dst, val),\n-        AcqRel => intrinsics::atomic_and_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_and_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_and(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_and`\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_and_acq(dst, val),\n+            Release => intrinsics::atomic_and_rel(dst, val),\n+            AcqRel => intrinsics::atomic_and_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_and_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_and(dst, val),\n+        }\n     }\n }\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_nand<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_nand_acq(dst, val),\n-        Release => intrinsics::atomic_nand_rel(dst, val),\n-        AcqRel => intrinsics::atomic_nand_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_nand_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_nand(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_nand`\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_nand_acq(dst, val),\n+            Release => intrinsics::atomic_nand_rel(dst, val),\n+            AcqRel => intrinsics::atomic_nand_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_nand_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_nand(dst, val),\n+        }\n     }\n }\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_or<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_or_acq(dst, val),\n-        Release => intrinsics::atomic_or_rel(dst, val),\n-        AcqRel => intrinsics::atomic_or_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_or_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_or(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_or`\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_or_acq(dst, val),\n+            Release => intrinsics::atomic_or_rel(dst, val),\n+            AcqRel => intrinsics::atomic_or_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_or_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_or(dst, val),\n+        }\n     }\n }\n \n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_xor<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_xor_acq(dst, val),\n-        Release => intrinsics::atomic_xor_rel(dst, val),\n-        AcqRel => intrinsics::atomic_xor_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_xor_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_xor(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_xor`\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_xor_acq(dst, val),\n+            Release => intrinsics::atomic_xor_rel(dst, val),\n+            AcqRel => intrinsics::atomic_xor_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_xor_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_xor(dst, val),\n+        }\n     }\n }\n \n /// returns the max value (signed comparison)\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_max<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_max_acq(dst, val),\n-        Release => intrinsics::atomic_max_rel(dst, val),\n-        AcqRel => intrinsics::atomic_max_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_max_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_max(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_max`\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_max_acq(dst, val),\n+            Release => intrinsics::atomic_max_rel(dst, val),\n+            AcqRel => intrinsics::atomic_max_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_max_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_max(dst, val),\n+        }\n     }\n }\n \n /// returns the min value (signed comparison)\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_min<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_min_acq(dst, val),\n-        Release => intrinsics::atomic_min_rel(dst, val),\n-        AcqRel => intrinsics::atomic_min_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_min_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_min(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_min`\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_min_acq(dst, val),\n+            Release => intrinsics::atomic_min_rel(dst, val),\n+            AcqRel => intrinsics::atomic_min_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_min_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_min(dst, val),\n+        }\n     }\n }\n \n /// returns the max value (unsigned comparison)\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_umax<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_umax_acq(dst, val),\n-        Release => intrinsics::atomic_umax_rel(dst, val),\n-        AcqRel => intrinsics::atomic_umax_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_umax_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_umax(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_umax`\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_umax_acq(dst, val),\n+            Release => intrinsics::atomic_umax_rel(dst, val),\n+            AcqRel => intrinsics::atomic_umax_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_umax_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_umax(dst, val),\n+        }\n     }\n }\n \n /// returns the min value (unsigned comparison)\n #[inline]\n #[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_umin<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_umin_acq(dst, val),\n-        Release => intrinsics::atomic_umin_rel(dst, val),\n-        AcqRel => intrinsics::atomic_umin_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_umin_relaxed(dst, val),\n-        SeqCst => intrinsics::atomic_umin(dst, val),\n+    // SAFETY: the caller must uphold the safety contract for `atomic_umin`\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_umin_acq(dst, val),\n+            Release => intrinsics::atomic_umin_rel(dst, val),\n+            AcqRel => intrinsics::atomic_umin_acqrel(dst, val),\n+            Relaxed => intrinsics::atomic_umin_relaxed(dst, val),\n+            SeqCst => intrinsics::atomic_umin(dst, val),\n+        }\n     }\n }\n "}, {"sha": "68a5e20a66fdc8a89bfad516b3057a3a6ac2bb23", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -44,6 +44,8 @@\n #![feature(option_unwrap_none)]\n #![feature(peekable_next_if)]\n #![feature(partition_point)]\n+#![feature(unsafe_block_in_unsafe_fn)]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n extern crate test;\n "}, {"sha": "2d803262f79e1cf2ffeeb523035f1e59ed395942", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -9,7 +9,7 @@ use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_ast::attr;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, BinOpToken, DelimToken, Nonterminal, Token, TokenKind};\n-use rustc_ast::tokenstream::{self, TokenStream, TokenTree};\n+use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::util::parser::{self, AssocOp, Fixity};\n use rustc_ast::util::{classify, comments};\n use rustc_span::edition::Edition;\n@@ -305,7 +305,7 @@ pub fn nonterminal_to_string(nt: &Nonterminal) -> String {\n         token::NtIdent(e, is_raw) => IdentPrinter::for_ast_ident(e, is_raw).to_string(),\n         token::NtLifetime(e) => e.to_string(),\n         token::NtLiteral(ref e) => expr_to_string(e),\n-        token::NtTT(ref tree) => tt_to_string(tree.clone()),\n+        token::NtTT(ref tree) => tt_to_string(tree),\n         token::NtVis(ref e) => vis_to_string(e),\n     }\n }\n@@ -326,11 +326,11 @@ pub fn expr_to_string(e: &ast::Expr) -> String {\n     to_string(|s| s.print_expr(e))\n }\n \n-pub fn tt_to_string(tt: tokenstream::TokenTree) -> String {\n+pub fn tt_to_string(tt: &TokenTree) -> String {\n     to_string(|s| s.print_tt(tt, false))\n }\n \n-pub fn tts_to_string(tokens: TokenStream) -> String {\n+pub fn tts_to_string(tokens: &TokenStream) -> String {\n     to_string(|s| s.print_tts(tokens, false))\n }\n \n@@ -597,7 +597,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 false,\n                 None,\n                 delim.to_token(),\n-                tokens.clone(),\n+                tokens,\n                 true,\n                 span,\n             ),\n@@ -606,7 +606,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 if let MacArgs::Eq(_, tokens) = &item.args {\n                     self.space();\n                     self.word_space(\"=\");\n-                    self.print_tts(tokens.clone(), true);\n+                    self.print_tts(tokens, true);\n                 }\n             }\n         }\n@@ -647,9 +647,9 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     /// appropriate macro, transcribe back into the grammar we just parsed from,\n     /// and then pretty-print the resulting AST nodes (so, e.g., we print\n     /// expression arguments as expressions). It can be done! I think.\n-    fn print_tt(&mut self, tt: tokenstream::TokenTree, convert_dollar_crate: bool) {\n+    fn print_tt(&mut self, tt: &TokenTree, convert_dollar_crate: bool) {\n         match tt {\n-            TokenTree::Token(ref token) => {\n+            TokenTree::Token(token) => {\n                 self.word(token_to_string_ext(&token, convert_dollar_crate));\n                 if let token::DocComment(..) = token.kind {\n                     self.hardbreak()\n@@ -660,7 +660,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                     None,\n                     false,\n                     None,\n-                    delim,\n+                    *delim,\n                     tts,\n                     convert_dollar_crate,\n                     dspan.entire(),\n@@ -669,14 +669,14 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         }\n     }\n \n-    fn print_tts(&mut self, tts: tokenstream::TokenStream, convert_dollar_crate: bool) {\n-        let mut iter = tts.into_trees().peekable();\n+    fn print_tts(&mut self, tts: &TokenStream, convert_dollar_crate: bool) {\n+        let mut iter = tts.trees().peekable();\n         while let Some(tt) = iter.next() {\n-            let show_space =\n-                if let Some(next) = iter.peek() { tt_prepend_space(next, &tt) } else { false };\n-            self.print_tt(tt, convert_dollar_crate);\n-            if show_space {\n-                self.space();\n+            self.print_tt(&tt, convert_dollar_crate);\n+            if let Some(next) = iter.peek() {\n+                if tt_prepend_space(next, &tt) {\n+                    self.space();\n+                }\n             }\n         }\n     }\n@@ -687,7 +687,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         has_bang: bool,\n         ident: Option<Ident>,\n         delim: DelimToken,\n-        tts: TokenStream,\n+        tts: &TokenStream,\n         convert_dollar_crate: bool,\n         span: Span,\n     ) {\n@@ -1265,7 +1265,7 @@ impl<'a> State<'a> {\n                     has_bang,\n                     Some(item.ident),\n                     macro_def.body.delim(),\n-                    macro_def.body.inner_tokens(),\n+                    &macro_def.body.inner_tokens(),\n                     true,\n                     item.span,\n                 );\n@@ -1589,7 +1589,7 @@ impl<'a> State<'a> {\n             true,\n             None,\n             m.args.delim(),\n-            m.args.inner_tokens(),\n+            &m.args.inner_tokens(),\n             true,\n             m.span(),\n         );"}, {"sha": "ede34a7612589c531e051481460d82db3d740184", "filename": "src/librustc_builtin_macros/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_builtin_macros%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_builtin_macros%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Flog_syntax.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -7,7 +7,7 @@ pub fn expand_log_syntax<'cx>(\n     sp: rustc_span::Span,\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'cx> {\n-    println!(\"{}\", pprust::tts_to_string(tts));\n+    println!(\"{}\", pprust::tts_to_string(&tts));\n \n     // any so that `log_syntax` can be invoked as an expression and item.\n     base::DummyResult::any_valid(sp)"}, {"sha": "e46cf67e64d664326dde5cfee97bdc7b33d1392d", "filename": "src/librustc_builtin_macros/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_builtin_macros%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_builtin_macros%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fsource_util.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -71,7 +71,7 @@ pub fn expand_stringify(\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'static> {\n     let sp = cx.with_def_site_ctxt(sp);\n-    let s = pprust::tts_to_string(tts);\n+    let s = pprust::tts_to_string(&tts);\n     base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&s)))\n }\n "}, {"sha": "d5e0d7d36ee7a010e2d257c42f5ca7e9ecbee62b", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -150,6 +150,11 @@ pub fn compile_codegen_unit(\n                 cx.create_used_variable()\n             }\n \n+            // Finalize code coverage by injecting the coverage map\n+            if cx.sess().opts.debugging_opts.instrument_coverage {\n+                cx.coverageinfo_finalize();\n+            }\n+\n             // Finalize debuginfo\n             if cx.sess().opts.debuginfo != DebugInfo::None {\n                 cx.debuginfo_finalize();"}, {"sha": "e9a001bab75405317cf8b311fb2516a0496b6fe4", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -1,5 +1,6 @@\n use crate::attributes;\n use crate::callee::get_fn;\n+use crate::coverageinfo;\n use crate::debuginfo;\n use crate::llvm;\n use crate::llvm_util;\n@@ -77,6 +78,7 @@ pub struct CodegenCx<'ll, 'tcx> {\n     pub pointee_infos: RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>>,\n     pub isize_ty: &'ll Type,\n \n+    pub coverage_cx: Option<coverageinfo::CrateCoverageContext<'tcx>>,\n     pub dbg_cx: Option<debuginfo::CrateDebugContext<'ll, 'tcx>>,\n \n     eh_personality: Cell<Option<&'ll Value>>,\n@@ -256,6 +258,13 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n \n         let (llcx, llmod) = (&*llvm_module.llcx, llvm_module.llmod());\n \n+        let coverage_cx = if tcx.sess.opts.debugging_opts.instrument_coverage {\n+            let covctx = coverageinfo::CrateCoverageContext::new();\n+            Some(covctx)\n+        } else {\n+            None\n+        };\n+\n         let dbg_cx = if tcx.sess.opts.debuginfo != DebugInfo::None {\n             let dctx = debuginfo::CrateDebugContext::new(llmod);\n             debuginfo::metadata::compile_unit_metadata(tcx, &codegen_unit.name().as_str(), &dctx);\n@@ -285,6 +294,7 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n             scalar_lltypes: Default::default(),\n             pointee_infos: Default::default(),\n             isize_ty,\n+            coverage_cx,\n             dbg_cx,\n             eh_personality: Cell::new(None),\n             rust_try_fn: Cell::new(None),\n@@ -296,6 +306,11 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n     crate fn statics_to_rauw(&self) -> &RefCell<Vec<(&'ll Value, &'ll Value)>> {\n         &self.statics_to_rauw\n     }\n+\n+    #[inline]\n+    pub fn coverage_context(&'a self) -> &'a coverageinfo::CrateCoverageContext<'tcx> {\n+        self.coverage_cx.as_ref().unwrap()\n+    }\n }\n \n impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n@@ -749,8 +764,6 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.lifetime.start.p0i8\", fn(t_i64, i8p) -> void);\n         ifn!(\"llvm.lifetime.end.p0i8\", fn(t_i64, i8p) -> void);\n \n-        ifn!(\"llvm.instrprof.increment\", fn(i8p, t_i64, t_i32, t_i32) -> void);\n-\n         ifn!(\"llvm.expect.i1\", fn(i1, i1) -> i1);\n         ifn!(\"llvm.eh.typeid.for\", fn(i8p) -> t_i32);\n         ifn!(\"llvm.localescape\", fn(...) -> void);\n@@ -765,6 +778,10 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.va_end\", fn(i8p) -> void);\n         ifn!(\"llvm.va_copy\", fn(i8p, i8p) -> void);\n \n+        if self.sess().opts.debugging_opts.instrument_coverage {\n+            ifn!(\"llvm.instrprof.increment\", fn(i8p, t_i64, t_i32, t_i32) -> void);\n+        }\n+\n         if self.sess().opts.debuginfo != DebugInfo::None {\n             ifn!(\"llvm.dbg.declare\", fn(self.type_metadata(), self.type_metadata()) -> void);\n             ifn!(\"llvm.dbg.value\", fn(self.type_metadata(), t_i64, self.type_metadata()) -> void);"}, {"sha": "ff9f8f7aeaa544ec591697a2528c5383edc037bd", "filename": "src/librustc_codegen_llvm/coverageinfo/mod.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -0,0 +1,126 @@\n+use crate::builder::Builder;\n+use crate::common::CodegenCx;\n+use log::debug;\n+use rustc_codegen_ssa::coverageinfo::map::*;\n+use rustc_codegen_ssa::traits::{CoverageInfoBuilderMethods, CoverageInfoMethods};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::ty::Instance;\n+\n+use std::cell::RefCell;\n+\n+/// A context object for maintaining all state needed by the coverageinfo module.\n+pub struct CrateCoverageContext<'tcx> {\n+    // Coverage region data for each instrumented function identified by DefId.\n+    pub(crate) coverage_regions: RefCell<FxHashMap<Instance<'tcx>, FunctionCoverageRegions>>,\n+}\n+\n+impl<'tcx> CrateCoverageContext<'tcx> {\n+    pub fn new() -> Self {\n+        Self { coverage_regions: Default::default() }\n+    }\n+}\n+\n+/// Generates and exports the Coverage Map.\n+// FIXME(richkadel): Actually generate and export the coverage map to LLVM.\n+// The current implementation is actually just debug messages to show the data is available.\n+pub fn finalize(cx: &CodegenCx<'_, '_>) {\n+    let coverage_regions = &*cx.coverage_context().coverage_regions.borrow();\n+    for instance in coverage_regions.keys() {\n+        let coverageinfo = cx.tcx.coverageinfo(instance.def_id());\n+        debug_assert!(coverageinfo.num_counters > 0);\n+        debug!(\n+            \"Generate coverage map for: {:?}, hash: {}, num_counters: {}\",\n+            instance, coverageinfo.hash, coverageinfo.num_counters\n+        );\n+        let function_coverage_regions = &coverage_regions[instance];\n+        for (index, region) in function_coverage_regions.indexed_regions() {\n+            match region.kind {\n+                CoverageKind::Counter => debug!(\n+                    \"  Counter {}, for {}..{}\",\n+                    index, region.coverage_span.start_byte_pos, region.coverage_span.end_byte_pos\n+                ),\n+                CoverageKind::CounterExpression(lhs, op, rhs) => debug!(\n+                    \"  CounterExpression {} = {} {:?} {}, for {}..{}\",\n+                    index,\n+                    lhs,\n+                    op,\n+                    rhs,\n+                    region.coverage_span.start_byte_pos,\n+                    region.coverage_span.end_byte_pos\n+                ),\n+            }\n+        }\n+        for unreachable in function_coverage_regions.unreachable_regions() {\n+            debug!(\n+                \"  Unreachable code region: {}..{}\",\n+                unreachable.start_byte_pos, unreachable.end_byte_pos\n+            );\n+        }\n+    }\n+}\n+\n+impl CoverageInfoMethods for CodegenCx<'ll, 'tcx> {\n+    fn coverageinfo_finalize(&self) {\n+        finalize(self)\n+    }\n+}\n+\n+impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+    fn add_counter_region(\n+        &mut self,\n+        instance: Instance<'tcx>,\n+        index: u32,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    ) {\n+        debug!(\n+            \"adding counter to coverage map: instance={:?}, index={}, byte range {}..{}\",\n+            instance, index, start_byte_pos, end_byte_pos,\n+        );\n+        let mut coverage_regions = self.coverage_context().coverage_regions.borrow_mut();\n+        coverage_regions.entry(instance).or_default().add_counter(\n+            index,\n+            start_byte_pos,\n+            end_byte_pos,\n+        );\n+    }\n+\n+    fn add_counter_expression_region(\n+        &mut self,\n+        instance: Instance<'tcx>,\n+        index: u32,\n+        lhs: u32,\n+        op: CounterOp,\n+        rhs: u32,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    ) {\n+        debug!(\n+            \"adding counter expression to coverage map: instance={:?}, index={}, {} {:?} {}, byte range {}..{}\",\n+            instance, index, lhs, op, rhs, start_byte_pos, end_byte_pos,\n+        );\n+        let mut coverage_regions = self.coverage_context().coverage_regions.borrow_mut();\n+        coverage_regions.entry(instance).or_default().add_counter_expression(\n+            index,\n+            lhs,\n+            op,\n+            rhs,\n+            start_byte_pos,\n+            end_byte_pos,\n+        );\n+    }\n+\n+    fn add_unreachable_region(\n+        &mut self,\n+        instance: Instance<'tcx>,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    ) {\n+        debug!(\n+            \"adding unreachable code to coverage map: instance={:?}, byte range {}..{}\",\n+            instance, start_byte_pos, end_byte_pos,\n+        );\n+        let mut coverage_regions = self.coverage_context().coverage_regions.borrow_mut();\n+        coverage_regions.entry(instance).or_default().add_unreachable(start_byte_pos, end_byte_pos);\n+    }\n+}"}, {"sha": "de90ac0bac1d333941cc52854096efa470e36f11", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 60, "deletions": 5, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -13,12 +13,15 @@ use rustc_ast::ast;\n use rustc_codegen_ssa::base::{compare_simd_types, to_immediate, wants_msvc_seh};\n use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n+use rustc_codegen_ssa::coverageinfo::CounterOp;\n use rustc_codegen_ssa::glue;\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::MemFlags;\n use rustc_hir as hir;\n+use rustc_middle::mir::coverage;\n+use rustc_middle::mir::Operand;\n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::{self, Ty};\n use rustc_middle::{bug, span_bug};\n@@ -81,6 +84,53 @@ fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Valu\n }\n \n impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+    fn is_codegen_intrinsic(\n+        &mut self,\n+        intrinsic: &str,\n+        args: &Vec<Operand<'tcx>>,\n+        caller_instance: ty::Instance<'tcx>,\n+    ) -> bool {\n+        match intrinsic {\n+            \"count_code_region\" => {\n+                use coverage::count_code_region_args::*;\n+                self.add_counter_region(\n+                    caller_instance,\n+                    op_to_u32(&args[COUNTER_INDEX]),\n+                    op_to_u32(&args[START_BYTE_POS]),\n+                    op_to_u32(&args[END_BYTE_POS]),\n+                );\n+                true // Also inject the counter increment in the backend\n+            }\n+            \"coverage_counter_add\" | \"coverage_counter_subtract\" => {\n+                use coverage::coverage_counter_expression_args::*;\n+                self.add_counter_expression_region(\n+                    caller_instance,\n+                    op_to_u32(&args[COUNTER_EXPRESSION_INDEX]),\n+                    op_to_u32(&args[LEFT_INDEX]),\n+                    if intrinsic == \"coverage_counter_add\" {\n+                        CounterOp::Add\n+                    } else {\n+                        CounterOp::Subtract\n+                    },\n+                    op_to_u32(&args[RIGHT_INDEX]),\n+                    op_to_u32(&args[START_BYTE_POS]),\n+                    op_to_u32(&args[END_BYTE_POS]),\n+                );\n+                false // Does not inject backend code\n+            }\n+            \"coverage_unreachable\" => {\n+                use coverage::coverage_unreachable_args::*;\n+                self.add_unreachable_region(\n+                    caller_instance,\n+                    op_to_u32(&args[START_BYTE_POS]),\n+                    op_to_u32(&args[END_BYTE_POS]),\n+                );\n+                false // Does not inject backend code\n+            }\n+            _ => true, // Unhandled intrinsics should be passed to `codegen_intrinsic_call()`\n+        }\n+    }\n+\n     fn codegen_intrinsic_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n@@ -143,15 +193,16 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 // FIXME(richkadel): The current implementation assumes the MIR for the given\n                 // caller_instance represents a single function. Validate and/or correct if inlining\n                 // and/or monomorphization invalidates these assumptions.\n-                let coverage_data = tcx.coverage_data(caller_instance.def_id());\n+                let coverageinfo = tcx.coverageinfo(caller_instance.def_id());\n                 let mangled_fn = tcx.symbol_name(caller_instance);\n                 let (mangled_fn_name, _len_val) = self.const_str(mangled_fn.name);\n-                let hash = self.const_u64(coverage_data.hash);\n-                let num_counters = self.const_u32(coverage_data.num_counters);\n-                let index = args[0].immediate();\n+                let hash = self.const_u64(coverageinfo.hash);\n+                let num_counters = self.const_u32(coverageinfo.num_counters);\n+                use coverage::count_code_region_args::*;\n+                let index = args[COUNTER_INDEX].immediate();\n                 debug!(\n                     \"count_code_region to LLVM intrinsic instrprof.increment(fn_name={}, hash={:?}, num_counters={:?}, index={:?})\",\n-                    mangled_fn.name, hash, num_counters, index\n+                    mangled_fn.name, hash, num_counters, index,\n                 );\n                 self.instrprof_increment(mangled_fn_name, hash, num_counters, index)\n             }\n@@ -2131,3 +2182,7 @@ fn float_type_width(ty: Ty<'_>) -> Option<u64> {\n         _ => None,\n     }\n }\n+\n+fn op_to_u32<'tcx>(op: &Operand<'tcx>) -> u32 {\n+    Operand::scalar_from_const(op).to_u32().expect(\"Scalar is u32\")\n+}"}, {"sha": "565968f9952e5755ae2e688da7442fd9869d2c92", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -55,6 +55,7 @@ mod callee;\n mod common;\n mod consts;\n mod context;\n+mod coverageinfo;\n mod debuginfo;\n mod declare;\n mod intrinsic;"}, {"sha": "3adaa07db91b012c054e80fa1a274fbf53db9184", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -1597,6 +1597,9 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n         cmd.arg(format!(\"--dynamic-linker={}ld.so.1\", prefix));\n     }\n \n+    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n+    cmd.add_eh_frame_header();\n+\n     // NO-OPT-OUT, OBJECT-FILES-NO\n     if crt_objects_fallback {\n         cmd.no_crt_objects();"}, {"sha": "54f55c806d0350c13676056049c8aa39575077ab", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -129,6 +129,7 @@ pub trait Linker {\n     fn group_start(&mut self);\n     fn group_end(&mut self);\n     fn linker_plugin_lto(&mut self);\n+    fn add_eh_frame_header(&mut self) {}\n     fn finalize(&mut self);\n }\n \n@@ -615,6 +616,19 @@ impl<'a> Linker for GccLinker<'a> {\n             }\n         }\n     }\n+\n+    // Add the `GNU_EH_FRAME` program header which is required to locate unwinding information.\n+    // Some versions of `gcc` add it implicitly, some (e.g. `musl-gcc`) don't,\n+    // so we just always add it.\n+    fn add_eh_frame_header(&mut self) {\n+        // The condition here is \"uses ELF\" basically.\n+        if !self.sess.target.target.options.is_like_osx\n+            && !self.sess.target.target.options.is_like_windows\n+            && self.sess.target.target.target_os != \"uefi\"\n+        {\n+            self.linker_arg(\"--eh-frame-hdr\");\n+        }\n+    }\n }\n \n pub struct MsvcLinker<'a> {"}, {"sha": "3bd262cf2b21374915a0b2ff9c9bc82cf2cd82cd", "filename": "src/librustc_codegen_ssa/coverageinfo/map.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -0,0 +1,83 @@\n+use rustc_data_structures::fx::FxHashMap;\n+use std::collections::hash_map;\n+use std::slice;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum CounterOp {\n+    Add,\n+    Subtract,\n+}\n+\n+pub enum CoverageKind {\n+    Counter,\n+    CounterExpression(u32, CounterOp, u32),\n+}\n+\n+pub struct CoverageSpan {\n+    pub start_byte_pos: u32,\n+    pub end_byte_pos: u32,\n+}\n+\n+pub struct CoverageRegion {\n+    pub kind: CoverageKind,\n+    pub coverage_span: CoverageSpan,\n+}\n+\n+/// Collects all of the coverage regions associated with (a) injected counters, (b) counter\n+/// expressions (additions or subtraction), and (c) unreachable regions (always counted as zero),\n+/// for a given Function. Counters and counter expressions are indexed because they can be operands\n+/// in an expression.\n+///\n+/// Note, it's important to distinguish the `unreachable` region type from what LLVM's refers to as\n+/// a \"gap region\" (or \"gap area\"). A gap region is a code region within a counted region (either\n+/// counter or expression), but the line or lines in the gap region are not executable (such as\n+/// lines with only whitespace or comments). According to LLVM Code Coverage Mapping documentation,\n+/// \"A count for a gap area is only used as the line execution count if there are no other regions\n+/// on a line.\"\n+#[derive(Default)]\n+pub struct FunctionCoverageRegions {\n+    indexed: FxHashMap<u32, CoverageRegion>,\n+    unreachable: Vec<CoverageSpan>,\n+}\n+\n+impl FunctionCoverageRegions {\n+    pub fn add_counter(&mut self, index: u32, start_byte_pos: u32, end_byte_pos: u32) {\n+        self.indexed.insert(\n+            index,\n+            CoverageRegion {\n+                kind: CoverageKind::Counter,\n+                coverage_span: CoverageSpan { start_byte_pos, end_byte_pos },\n+            },\n+        );\n+    }\n+\n+    pub fn add_counter_expression(\n+        &mut self,\n+        index: u32,\n+        lhs: u32,\n+        op: CounterOp,\n+        rhs: u32,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    ) {\n+        self.indexed.insert(\n+            index,\n+            CoverageRegion {\n+                kind: CoverageKind::CounterExpression(lhs, op, rhs),\n+                coverage_span: CoverageSpan { start_byte_pos, end_byte_pos },\n+            },\n+        );\n+    }\n+\n+    pub fn add_unreachable(&mut self, start_byte_pos: u32, end_byte_pos: u32) {\n+        self.unreachable.push(CoverageSpan { start_byte_pos, end_byte_pos });\n+    }\n+\n+    pub fn indexed_regions(&self) -> hash_map::Iter<'_, u32, CoverageRegion> {\n+        self.indexed.iter()\n+    }\n+\n+    pub fn unreachable_regions(&self) -> slice::Iter<'_, CoverageSpan> {\n+        self.unreachable.iter()\n+    }\n+}"}, {"sha": "304f8e19da4e672cbb0b49312552c6767760e5a1", "filename": "src/librustc_codegen_ssa/coverageinfo/mod.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -0,0 +1,3 @@\n+pub mod map;\n+\n+pub use map::CounterOp;"}, {"sha": "618df15f5bcbe7aa94736ed19642b7f05426c841", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -34,6 +34,7 @@ use std::path::{Path, PathBuf};\n pub mod back;\n pub mod base;\n pub mod common;\n+pub mod coverageinfo;\n pub mod debuginfo;\n pub mod glue;\n pub mod meth;"}, {"sha": "7514eb8e889a8cc58f7beffc4b46e0b675e31a76", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -651,6 +651,18 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n \n         if intrinsic.is_some() && intrinsic != Some(\"drop_in_place\") {\n+            let intrinsic = intrinsic.unwrap();\n+\n+            // `is_codegen_intrinsic()` allows the backend implementation to perform compile-time\n+            // operations before converting the `args` to backend values.\n+            if !bx.is_codegen_intrinsic(intrinsic, &args, self.instance) {\n+                // If the intrinsic call was fully addressed by the `is_codegen_intrinsic()` call\n+                // (as a compile-time operation), return immediately. This avoids the need to\n+                // convert the arguments, the call to `codegen_intrinsic_call()`, and the return\n+                // value handling.\n+                return;\n+            }\n+\n             let dest = match ret_dest {\n                 _ if fn_abi.ret.is_indirect() => llargs[0],\n                 ReturnDest::Nothing => {\n@@ -670,7 +682,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     // third argument must be constant. This is\n                     // checked by const-qualification, which also\n                     // promotes any complex rvalues to constants.\n-                    if i == 2 && intrinsic.unwrap().starts_with(\"simd_shuffle\") {\n+                    if i == 2 && intrinsic.starts_with(\"simd_shuffle\") {\n                         if let mir::Operand::Constant(constant) = arg {\n                             let c = self.eval_mir_constant(constant);\n                             let (llval, ty) = self.simd_shuffle_indices("}, {"sha": "994d8e0395dc7d52334d7ecc0cfbba028698d9f0", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -1,5 +1,6 @@\n use super::abi::AbiBuilderMethods;\n use super::asm::AsmBuilderMethods;\n+use super::coverageinfo::CoverageInfoBuilderMethods;\n use super::debuginfo::DebugInfoBuilderMethods;\n use super::intrinsic::IntrinsicCallMethods;\n use super::type_::ArgAbiMethods;\n@@ -29,6 +30,7 @@ pub enum OverflowOp {\n \n pub trait BuilderMethods<'a, 'tcx>:\n     HasCodegen<'tcx>\n+    + CoverageInfoBuilderMethods<'tcx>\n     + DebugInfoBuilderMethods\n     + ArgAbiMethods<'tcx>\n     + AbiBuilderMethods<'tcx>"}, {"sha": "d80f90fa4fa0d7eb6412b83aa7ef387c2d58ae4c", "filename": "src/librustc_codegen_ssa/traits/coverageinfo.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -0,0 +1,35 @@\n+use super::BackendTypes;\n+use crate::coverageinfo::CounterOp;\n+use rustc_middle::ty::Instance;\n+\n+pub trait CoverageInfoMethods: BackendTypes {\n+    fn coverageinfo_finalize(&self);\n+}\n+\n+pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n+    fn add_counter_region(\n+        &mut self,\n+        instance: Instance<'tcx>,\n+        index: u32,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    );\n+\n+    fn add_counter_expression_region(\n+        &mut self,\n+        instance: Instance<'tcx>,\n+        index: u32,\n+        lhs: u32,\n+        op: CounterOp,\n+        rhs: u32,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    );\n+\n+    fn add_unreachable_region(\n+        &mut self,\n+        instance: Instance<'tcx>,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    );\n+}"}, {"sha": "e713cc948c10d0869e77965a03610ff310943beb", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -1,5 +1,6 @@\n use super::BackendTypes;\n use crate::mir::operand::OperandRef;\n+use rustc_middle::mir::Operand;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n use rustc_target::abi::call::FnAbi;\n@@ -18,6 +19,16 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n         caller_instance: ty::Instance<'tcx>,\n     );\n \n+    /// Intrinsic-specific pre-codegen processing, if any is required. Some intrinsics are handled\n+    /// at compile time and do not generate code. Returns true if codegen is required or false if\n+    /// the intrinsic does not need code generation.\n+    fn is_codegen_intrinsic(\n+        &mut self,\n+        intrinsic: &str,\n+        args: &Vec<Operand<'tcx>>,\n+        caller_instance: ty::Instance<'tcx>,\n+    ) -> bool;\n+\n     fn abort(&mut self);\n     fn assume(&mut self, val: Self::Value);\n     fn expect(&mut self, cond: Self::Value, expected: bool) -> Self::Value;"}, {"sha": "0ac519dd0b17cb9e2b7a5891c96c44142d5c243e", "filename": "src/librustc_codegen_ssa/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -19,6 +19,7 @@ mod asm;\n mod backend;\n mod builder;\n mod consts;\n+mod coverageinfo;\n mod debuginfo;\n mod declare;\n mod intrinsic;\n@@ -32,6 +33,7 @@ pub use self::asm::{AsmBuilderMethods, AsmMethods, InlineAsmOperandRef};\n pub use self::backend::{Backend, BackendTypes, CodegenBackend, ExtraBackendMethods};\n pub use self::builder::{BuilderMethods, OverflowOp};\n pub use self::consts::ConstMethods;\n+pub use self::coverageinfo::{CoverageInfoBuilderMethods, CoverageInfoMethods};\n pub use self::debuginfo::{DebugInfoBuilderMethods, DebugInfoMethods};\n pub use self::declare::{DeclareMethods, PreDefineMethods};\n pub use self::intrinsic::IntrinsicCallMethods;\n@@ -56,6 +58,7 @@ pub trait CodegenMethods<'tcx>:\n     + MiscMethods<'tcx>\n     + ConstMethods<'tcx>\n     + StaticMethods\n+    + CoverageInfoMethods\n     + DebugInfoMethods<'tcx>\n     + DeclareMethods<'tcx>\n     + AsmMethods\n@@ -72,6 +75,7 @@ impl<'tcx, T> CodegenMethods<'tcx> for T where\n         + MiscMethods<'tcx>\n         + ConstMethods<'tcx>\n         + StaticMethods\n+        + CoverageInfoMethods\n         + DebugInfoMethods<'tcx>\n         + DeclareMethods<'tcx>\n         + AsmMethods"}, {"sha": "36b323df6979709ac9249422205ee32488332a1c", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -224,7 +224,7 @@ fn generic_extension<'cx>(\n     let sess = cx.parse_sess;\n \n     if cx.trace_macros() {\n-        let msg = format!(\"expanding `{}! {{ {} }}`\", name, pprust::tts_to_string(arg.clone()));\n+        let msg = format!(\"expanding `{}! {{ {} }}`\", name, pprust::tts_to_string(&arg));\n         trace_macros_note(&mut cx.expansions, sp, msg);\n     }\n \n@@ -300,7 +300,7 @@ fn generic_extension<'cx>(\n                 }\n \n                 if cx.trace_macros() {\n-                    let msg = format!(\"to `{}`\", pprust::tts_to_string(tts.clone()));\n+                    let msg = format!(\"to `{}`\", pprust::tts_to_string(&tts));\n                     trace_macros_note(&mut cx.expansions, sp, msg);\n                 }\n "}, {"sha": "ce53b9c0b66c8fb017a1ff1c5ed57c2ce01c8db9", "filename": "src/librustc_expand/proc_macro_server.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_expand%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_expand%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro_server.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -408,7 +408,7 @@ impl server::TokenStream for Rustc<'_> {\n         )\n     }\n     fn to_string(&mut self, stream: &Self::TokenStream) -> String {\n-        pprust::tts_to_string(stream.clone())\n+        pprust::tts_to_string(stream)\n     }\n     fn from_token_tree(\n         &mut self,"}, {"sha": "c5dedab979326ab6a6c2657c2db775e317de759c", "filename": "src/librustc_index/vec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_index%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_index%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fvec.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -536,7 +536,8 @@ impl<I: Idx, T> IndexVec<I, T> {\n     }\n \n     /// Create an `IndexVec` with `n` elements, where the value of each\n-    /// element is the result of `func(i)`\n+    /// element is the result of `func(i)`. (The underlying vector will\n+    /// be allocated only once, with a capacity of at least `n`.)\n     #[inline]\n     pub fn from_fn_n(func: impl FnMut(I) -> T, n: usize) -> Self {\n         let indices = (0..n).map(I::new);"}, {"sha": "327f321bd7534d8eb02ba7890bdac3b30a11cb7c", "filename": "src/librustc_middle/mir/coverage/mod.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -0,0 +1,24 @@\n+//! Metadata from source code coverage analysis and instrumentation.\n+\n+/// Positional arguments to `libcore::count_code_region()`\n+pub mod count_code_region_args {\n+    pub const COUNTER_INDEX: usize = 0;\n+    pub const START_BYTE_POS: usize = 1;\n+    pub const END_BYTE_POS: usize = 2;\n+}\n+\n+/// Positional arguments to `libcore::coverage_counter_add()` and\n+/// `libcore::coverage_counter_subtract()`\n+pub mod coverage_counter_expression_args {\n+    pub const COUNTER_EXPRESSION_INDEX: usize = 0;\n+    pub const LEFT_INDEX: usize = 1;\n+    pub const RIGHT_INDEX: usize = 2;\n+    pub const START_BYTE_POS: usize = 3;\n+    pub const END_BYTE_POS: usize = 4;\n+}\n+\n+/// Positional arguments to `libcore::coverage_unreachable()`\n+pub mod coverage_unreachable_args {\n+    pub const START_BYTE_POS: usize = 0;\n+    pub const END_BYTE_POS: usize = 1;\n+}"}, {"sha": "ad4e8b55b75e162a2a1319a0174d9664d918f13f", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -39,6 +39,7 @@ use std::{iter, mem, option};\n use self::predecessors::{PredecessorCache, Predecessors};\n pub use self::query::*;\n \n+pub mod coverage;\n pub mod interpret;\n pub mod mono;\n mod predecessors;\n@@ -1817,6 +1818,18 @@ impl<'tcx> Operand<'tcx> {\n         })\n     }\n \n+    /// Convenience helper to make a `Scalar` from the given `Operand`, assuming that `Operand`\n+    /// wraps a constant literal value. Panics if this is not the case.\n+    pub fn scalar_from_const(operand: &Operand<'tcx>) -> Scalar {\n+        match operand {\n+            Operand::Constant(constant) => match constant.literal.val.try_to_scalar() {\n+                Some(scalar) => scalar,\n+                _ => panic!(\"{:?}: Scalar value expected\", constant.literal.val),\n+            },\n+            _ => panic!(\"{:?}: Constant expected\", operand),\n+        }\n+    }\n+\n     pub fn to_copy(&self) -> Self {\n         match *self {\n             Operand::Copy(_) | Operand::Constant(_) => self.clone(),\n@@ -2490,18 +2503,3 @@ impl Location {\n         }\n     }\n }\n-\n-/// Coverage data associated with each function (MIR) instrumented with coverage counters, when\n-/// compiled with `-Zinstrument_coverage`. The query `tcx.coverage_data(DefId)` computes these\n-/// values on demand (during code generation). This query is only valid after executing the MIR pass\n-/// `InstrumentCoverage`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct CoverageData {\n-    /// A hash value that can be used by the consumer of the coverage profile data to detect\n-    /// changes to the instrumented source of the associated MIR body (typically, for an\n-    /// individual function).\n-    pub hash: u64,\n-\n-    /// The total number of coverage region counters added to the MIR `Body`.\n-    pub num_counters: u32,\n-}"}, {"sha": "8dddaf40c8264a12b7651def9b9764e00e8c9a45", "filename": "src/librustc_middle/mir/query.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fquery.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -309,3 +309,17 @@ pub struct DestructuredConst<'tcx> {\n     pub variant: Option<VariantIdx>,\n     pub fields: &'tcx [&'tcx ty::Const<'tcx>],\n }\n+\n+/// Coverage information summarized from a MIR if instrumented for source code coverage (see\n+/// compiler option `-Zinstrument-coverage`). This information is generated by the\n+/// `InstrumentCoverage` MIR pass and can be retrieved via the `coverageinfo` query.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+pub struct CoverageInfo {\n+    /// A hash value that can be used by the consumer of the coverage profile data to detect\n+    /// changes to the instrumented source of the associated MIR body (typically, for an\n+    /// individual function).\n+    pub hash: u64,\n+\n+    /// The total number of coverage region counters added to the MIR `Body`.\n+    pub num_counters: u32,\n+}"}, {"sha": "3285be555d30f9fd8fd2d9a3b24920a328365b04", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -231,8 +231,10 @@ rustc_queries! {\n             cache_on_disk_if { key.is_local() }\n         }\n \n-        query coverage_data(key: DefId) -> mir::CoverageData {\n-            desc { |tcx| \"retrieving coverage data from MIR for `{}`\", tcx.def_path_str(key) }\n+        /// Returns coverage summary info for a function, after executing the `InstrumentCoverage`\n+        /// MIR pass (assuming the -Zinstrument-coverage option is enabled).\n+        query coverageinfo(key: DefId) -> mir::CoverageInfo {\n+            desc { |tcx| \"retrieving coverage info from MIR for `{}`\", tcx.def_path_str(key) }\n             storage(ArenaCacheSelector<'tcx>)\n             cache_on_disk_if { key.is_local() }\n         }"}, {"sha": "851862640226f5a2b303c135b83ba000a93c144c", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -414,7 +414,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.copy_op(args[0], dest)?;\n             }\n             // FIXME(#73156): Handle source code coverage in const eval\n-            sym::count_code_region => (),\n+            sym::count_code_region\n+            | sym::coverage_counter_add\n+            | sym::coverage_counter_subtract\n+            | sym::coverage_unreachable => (),\n             _ => return Ok(false),\n         }\n "}, {"sha": "c03be2a8fcd69c15d9d914784daf1977f4ca3073", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -39,7 +39,14 @@ struct CallSite<'tcx> {\n impl<'tcx> MirPass<'tcx> for Inline {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n-            Inliner { tcx, source }.run_pass(body);\n+            if tcx.sess.opts.debugging_opts.instrument_coverage {\n+                // The current implementation of source code coverage injects code region counters\n+                // into the MIR, and assumes a 1-to-1 correspondence between MIR and source-code-\n+                // based function.\n+                debug!(\"function inlining is disabled when compiling with `instrument_coverage`\");\n+            } else {\n+                Inliner { tcx, source }.run_pass(body);\n+            }\n         }\n     }\n }"}, {"sha": "25e154f2e95979f6f72be3ad7aa74f6515afcc92", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "modified", "additions": 72, "deletions": 55, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -5,65 +5,71 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::lang_items;\n use rustc_middle::hir;\n use rustc_middle::ich::StableHashingContext;\n-use rustc_middle::mir::interpret::{ConstValue, Scalar};\n+use rustc_middle::mir::coverage::*;\n+use rustc_middle::mir::interpret::Scalar;\n+use rustc_middle::mir::CoverageInfo;\n use rustc_middle::mir::{\n-    self, traversal, BasicBlock, BasicBlockData, CoverageData, Operand, Place, SourceInfo,\n-    StatementKind, Terminator, TerminatorKind, START_BLOCK,\n+    self, traversal, BasicBlock, BasicBlockData, Operand, Place, SourceInfo, StatementKind,\n+    Terminator, TerminatorKind, START_BLOCK,\n };\n use rustc_middle::ty;\n use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::FnDef;\n use rustc_middle::ty::TyCtxt;\n-use rustc_middle::ty::{ConstKind, FnDef};\n use rustc_span::def_id::DefId;\n-use rustc_span::Span;\n+use rustc_span::{Pos, Span};\n \n /// Inserts call to count_code_region() as a placeholder to be replaced during code generation with\n /// the intrinsic llvm.instrprof.increment.\n pub struct InstrumentCoverage;\n \n-/// The `query` provider for `CoverageData`, requested by `codegen_intrinsic_call()` when\n+/// The `query` provider for `CoverageInfo`, requested by `codegen_intrinsic_call()` when\n /// constructing the arguments for `llvm.instrprof.increment`.\n pub(crate) fn provide(providers: &mut Providers<'_>) {\n-    providers.coverage_data = |tcx, def_id| {\n-        let mir_body = tcx.optimized_mir(def_id);\n-        // FIXME(richkadel): The current implementation assumes the MIR for the given DefId\n-        // represents a single function. Validate and/or correct if inlining and/or monomorphization\n-        // invalidates these assumptions.\n-        let count_code_region_fn =\n-            tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None);\n-        let mut num_counters: u32 = 0;\n-        // The `num_counters` argument to `llvm.instrprof.increment` is the number of injected\n-        // counters, with each counter having an index from `0..num_counters-1`. MIR optimization\n-        // may split and duplicate some BasicBlock sequences. Simply counting the calls may not\n-        // not work; but computing the num_counters by adding `1` to the highest index (for a given\n-        // instrumented function) is valid.\n-        for (_, data) in traversal::preorder(mir_body) {\n-            if let Some(terminator) = &data.terminator {\n-                if let TerminatorKind::Call { func: Operand::Constant(func), args, .. } =\n-                    &terminator.kind\n-                {\n-                    if let FnDef(called_fn_def_id, _) = func.literal.ty.kind {\n-                        if called_fn_def_id == count_code_region_fn {\n-                            if let Operand::Constant(constant) =\n-                                args.get(0).expect(\"count_code_region has at least one arg\")\n-                            {\n-                                if let ConstKind::Value(ConstValue::Scalar(value)) =\n-                                    constant.literal.val\n-                                {\n-                                    let index = value\n-                                        .to_u32()\n-                                        .expect(\"count_code_region index at arg0 is u32\");\n-                                    num_counters = std::cmp::max(num_counters, index + 1);\n-                                }\n-                            }\n-                        }\n-                    }\n+    providers.coverageinfo = |tcx, def_id| coverageinfo_from_mir(tcx, def_id);\n+}\n+\n+fn coverageinfo_from_mir<'tcx>(tcx: TyCtxt<'tcx>, mir_def_id: DefId) -> CoverageInfo {\n+    let mir_body = tcx.optimized_mir(mir_def_id);\n+    // FIXME(richkadel): The current implementation assumes the MIR for the given DefId\n+    // represents a single function. Validate and/or correct if inlining (which should be disabled\n+    // if -Zinstrument-coverage is enabled) and/or monomorphization invalidates these assumptions.\n+    let count_code_region_fn = tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None);\n+\n+    // The `num_counters` argument to `llvm.instrprof.increment` is the number of injected\n+    // counters, with each counter having an index from `0..num_counters-1`. MIR optimization\n+    // may split and duplicate some BasicBlock sequences. Simply counting the calls may not\n+    // not work; but computing the num_counters by adding `1` to the highest index (for a given\n+    // instrumented function) is valid.\n+    let mut num_counters: u32 = 0;\n+    for terminator in traversal::preorder(mir_body)\n+        .map(|(_, data)| (data, count_code_region_fn))\n+        .filter_map(terminators_that_call_given_fn)\n+    {\n+        if let TerminatorKind::Call { args, .. } = &terminator.kind {\n+            let index_arg = args.get(count_code_region_args::COUNTER_INDEX).expect(\"arg found\");\n+            let index =\n+                mir::Operand::scalar_from_const(index_arg).to_u32().expect(\"index arg is u32\");\n+            num_counters = std::cmp::max(num_counters, index + 1);\n+        }\n+    }\n+    let hash = if num_counters > 0 { hash_mir_source(tcx, mir_def_id) } else { 0 };\n+    CoverageInfo { num_counters, hash }\n+}\n+\n+fn terminators_that_call_given_fn(\n+    (data, fn_def_id): (&'tcx BasicBlockData<'tcx>, DefId),\n+) -> Option<&'tcx Terminator<'tcx>> {\n+    if let Some(terminator) = &data.terminator {\n+        if let TerminatorKind::Call { func: Operand::Constant(func), .. } = &terminator.kind {\n+            if let FnDef(called_fn_def_id, _) = func.literal.ty.kind {\n+                if called_fn_def_id == fn_def_id {\n+                    return Some(&terminator);\n                 }\n             }\n         }\n-        let hash = if num_counters > 0 { hash_mir_source(tcx, def_id) } else { 0 };\n-        CoverageData { num_counters, hash }\n-    };\n+    }\n+    None\n }\n \n struct Instrumentor<'tcx> {\n@@ -102,17 +108,16 @@ impl<'tcx> Instrumentor<'tcx> {\n     fn inject_counters(&mut self, mir_body: &mut mir::Body<'tcx>) {\n         // FIXME(richkadel): As a first step, counters are only injected at the top of each\n         // function. The complete solution will inject counters at each conditional code branch.\n-        let top_of_function = START_BLOCK;\n-        let entire_function = mir_body.span;\n-\n-        self.inject_counter(mir_body, top_of_function, entire_function);\n+        let code_region = mir_body.span;\n+        let next_block = START_BLOCK;\n+        self.inject_counter(mir_body, code_region, next_block);\n     }\n \n     fn inject_counter(\n         &mut self,\n         mir_body: &mut mir::Body<'tcx>,\n-        next_block: BasicBlock,\n         code_region: Span,\n+        next_block: BasicBlock,\n     ) {\n         let injection_point = code_region.shrink_to_lo();\n \n@@ -121,12 +126,20 @@ impl<'tcx> Instrumentor<'tcx> {\n             self.tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None),\n             injection_point,\n         );\n-        let counter_index = Operand::const_from_scalar(\n-            self.tcx,\n-            self.tcx.types.u32,\n-            Scalar::from_u32(self.next_counter()),\n-            injection_point,\n-        );\n+\n+        let index = self.next_counter();\n+\n+        let mut args = Vec::new();\n+\n+        use count_code_region_args::*;\n+        debug_assert_eq!(COUNTER_INDEX, args.len());\n+        args.push(self.const_u32(index, injection_point));\n+\n+        debug_assert_eq!(START_BYTE_POS, args.len());\n+        args.push(self.const_u32(code_region.lo().to_u32(), injection_point));\n+\n+        debug_assert_eq!(END_BYTE_POS, args.len());\n+        args.push(self.const_u32(code_region.hi().to_u32(), injection_point));\n \n         let mut patch = MirPatch::new(mir_body);\n \n@@ -136,7 +149,7 @@ impl<'tcx> Instrumentor<'tcx> {\n             new_block,\n             TerminatorKind::Call {\n                 func: count_code_region_fn,\n-                args: vec![counter_index],\n+                args,\n                 // new_block will swapped with the next_block, after applying patch\n                 destination: Some((Place::from(temp), new_block)),\n                 cleanup: None,\n@@ -154,6 +167,10 @@ impl<'tcx> Instrumentor<'tcx> {\n         // `next_block`), just swap the indexes, leaving the rest of the graph unchanged.\n         mir_body.basic_blocks_mut().swap(next_block, new_block);\n     }\n+\n+    fn const_u32(&self, value: u32, span: Span) -> Operand<'tcx> {\n+        Operand::const_from_scalar(self.tcx, self.tcx.types.u32, Scalar::from_u32(value), span)\n+    }\n }\n \n fn function_handle<'tcx>(tcx: TyCtxt<'tcx>, fn_def_id: DefId, span: Span) -> Operand<'tcx> {"}, {"sha": "2ad7d09cbf415ff4ebb3bc5c0a77f73bbe5b4388", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -881,8 +881,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         (default: no)\"),\n     instrument_coverage: bool = (false, parse_bool, [TRACKED],\n         \"instrument the generated code with LLVM code region counters to (in the \\\n-        future) generate coverage reports (default: no; note, the compiler build \\\n-        config must include `profiler = true`)\"),\n+        future) generate coverage reports; disables/overrides some optimization \\\n+        options (note, the compiler build config must include `profiler = true`) \\\n+        (default: no)\"),\n     instrument_mcount: bool = (false, parse_bool, [TRACKED],\n         \"insert function instrument code for mcount-based tracing (default: no)\"),\n     keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "046554067f4ce4fca4e8d69b2cc93cef726975dd", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -309,7 +309,9 @@ impl Ord for Span {\n     }\n }\n \n-/// A collection of spans. Spans have two orthogonal attributes:\n+/// A collection of `Span`s.\n+///\n+/// Spans have two orthogonal attributes:\n ///\n /// - They can be *primary spans*. In this case they are the locus of\n ///   the error, and would be rendered with `^^^`."}, {"sha": "a01830216b4c5d772801c55c10dc548f58efdcf8", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -242,6 +242,9 @@ symbols! {\n         core,\n         core_intrinsics,\n         count_code_region,\n+        coverage_counter_add,\n+        coverage_counter_subtract,\n+        coverage_unreachable,\n         crate_id,\n         crate_in_paths,\n         crate_local,"}, {"sha": "39039435f5815c19ef568f95b51eb4c383be423f", "filename": "src/librustc_target/spec/cloudabi_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_target%2Fspec%2Fcloudabi_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_target%2Fspec%2Fcloudabi_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fcloudabi_base.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -7,7 +7,6 @@ pub fn opts() -> TargetOptions {\n         vec![\n             \"-Wl,-Bstatic\".to_string(),\n             \"-Wl,--no-dynamic-linker\".to_string(),\n-            \"-Wl,--eh-frame-hdr\".to_string(),\n             \"-Wl,--gc-sections\".to_string(),\n         ],\n     );"}, {"sha": "6f432dc11718d40466bb6fa6a56f43297f2eac41", "filename": "src/librustc_target/spec/fuchsia_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_target%2Fspec%2Ffuchsia_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_target%2Fspec%2Ffuchsia_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Ffuchsia_base.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -6,7 +6,6 @@ pub fn opts() -> TargetOptions {\n         LinkerFlavor::Lld(LldFlavor::Ld),\n         vec![\n             \"--build-id\".to_string(),\n-            \"--eh-frame-hdr\".to_string(),\n             \"--hash-style=gnu\".to_string(),\n             \"-z\".to_string(),\n             \"max-page-size=4096\".to_string(),"}, {"sha": "b90e91d2901a8124c293b6d520be98ae3f77d3e3", "filename": "src/librustc_target/spec/linux_musl_base.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_target%2Fspec%2Flinux_musl_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_target%2Fspec%2Flinux_musl_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Flinux_musl_base.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -1,15 +1,9 @@\n use crate::spec::crt_objects::{self, CrtObjectsFallback};\n-use crate::spec::{LinkerFlavor, TargetOptions};\n+use crate::spec::TargetOptions;\n \n pub fn opts() -> TargetOptions {\n     let mut base = super::linux_base::opts();\n \n-    // At least when this was tested, the linker would not add the\n-    // `GNU_EH_FRAME` program header to executables generated, which is required\n-    // when unwinding to locate the unwinding information. I'm not sure why this\n-    // argument is *not* necessary for normal builds, but it can't hurt!\n-    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-Wl,--eh-frame-hdr\".to_string());\n-\n     base.pre_link_objects_fallback = crt_objects::pre_musl_fallback();\n     base.post_link_objects_fallback = crt_objects::post_musl_fallback();\n     base.crt_objects_fallback = Some(CrtObjectsFallback::Musl);"}, {"sha": "b3bda97c8a5707db931f06668ba9d93c626d306b", "filename": "src/librustc_target/spec/mipsel_sony_psp.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_target%2Fspec%2Fmipsel_sony_psp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_target%2Fspec%2Fmipsel_sony_psp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmipsel_sony_psp.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -6,10 +6,7 @@ const LINKER_SCRIPT: &str = include_str!(\"./mipsel_sony_psp_linker_script.ld\");\n \n pub fn target() -> TargetResult {\n     let mut pre_link_args = LinkArgs::new();\n-    pre_link_args.insert(\n-        LinkerFlavor::Lld(LldFlavor::Ld),\n-        vec![\"--eh-frame-hdr\".to_string(), \"--emit-relocs\".to_string()],\n-    );\n+    pre_link_args.insert(LinkerFlavor::Lld(LldFlavor::Ld), vec![\"--emit-relocs\".to_string()]);\n \n     Ok(Target {\n         llvm_target: \"mipsel-sony-psp\".to_string(),"}, {"sha": "3b5233a3e677df967273e2fef6238fe50c130815", "filename": "src/librustc_target/spec/x86_64_fortanix_unknown_sgx.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_target%2Fspec%2Fx86_64_fortanix_unknown_sgx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_target%2Fspec%2Fx86_64_fortanix_unknown_sgx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_fortanix_unknown_sgx.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -5,7 +5,6 @@ use super::{LinkerFlavor, LldFlavor, PanicStrategy, Target, TargetOptions};\n pub fn target() -> Result<Target, String> {\n     const PRE_LINK_ARGS: &[&str] = &[\n         \"--as-needed\",\n-        \"--eh-frame-hdr\",\n         \"-z\",\n         \"noexecstack\",\n         \"-e\","}, {"sha": "6205088adadb78384d60bfa222d1d564c4496933", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -352,7 +352,17 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 return;\n             }\n \n-            \"count_code_region\" => (0, vec![tcx.types.u32], tcx.mk_unit()),\n+            \"count_code_region\" => {\n+                (0, vec![tcx.types.u32, tcx.types.u32, tcx.types.u32], tcx.mk_unit())\n+            }\n+\n+            \"coverage_counter_add\" | \"coverage_counter_subtract\" => (\n+                0,\n+                vec![tcx.types.u32, tcx.types.u32, tcx.types.u32, tcx.types.u32, tcx.types.u32],\n+                tcx.mk_unit(),\n+            ),\n+\n+            \"coverage_unreachable\" => (0, vec![tcx.types.u32, tcx.types.u32], tcx.mk_unit()),\n \n             ref other => {\n                 struct_span_err!("}, {"sha": "af2899c887a949cc17ce55d119002c4d9904902a", "filename": "src/test/mir-opt/instrument_coverage/rustc.bar.InstrumentCoverage.diff", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.bar.InstrumentCoverage.diff", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.bar.InstrumentCoverage.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.bar.InstrumentCoverage.diff?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -7,19 +7,31 @@\n   \n       bb0: {\n +         StorageLive(_1);                 // scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n-+         _1 = const std::intrinsics::count_code_region(const 0_u32) -> bb2; // scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n++         _1 = const std::intrinsics::count_code_region(const 0_u32, const 484_u32, const 513_u32) -> bb2; // scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n +                                          // ty::Const\n-+                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u32) {std::intrinsics::count_code_region}\n++                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u32, u32, u32) {std::intrinsics::count_code_region}\n +                                          // + val: Value(Scalar(<ZST>))\n +                                          // mir::Constant\n +                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n-+                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n +                                          // + val: Value(Scalar(0x00000000))\n +                                          // mir::Constant\n +                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n +                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000000)) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x000001e4))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x000001e4)) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x00000201))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000201)) }\n +     }\n + \n +     bb1 (cleanup): {"}, {"sha": "4a300230f8a9728334eb680876ec48676a067696", "filename": "src/test/mir-opt/instrument_coverage/rustc.main.InstrumentCoverage.diff", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.main.InstrumentCoverage.diff", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.main.InstrumentCoverage.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.main.InstrumentCoverage.diff?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -11,19 +11,31 @@\n       bb0: {\n -         falseUnwind -> [real: bb1, cleanup: bb2]; // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n +         StorageLive(_4);                 // scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n-+         _4 = const std::intrinsics::count_code_region(const 0_u32) -> bb7; // scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n++         _4 = const std::intrinsics::count_code_region(const 0_u32, const 387_u32, const 465_u32) -> bb7; // scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n +                                          // ty::Const\n-+                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u32) {std::intrinsics::count_code_region}\n++                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u32, u32, u32) {std::intrinsics::count_code_region}\n +                                          // + val: Value(Scalar(<ZST>))\n +                                          // mir::Constant\n +                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n-+                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n +                                          // + val: Value(Scalar(0x00000000))\n +                                          // mir::Constant\n +                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n +                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000000)) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x00000183))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000183)) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x000001d1))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x000001d1)) }\n       }\n   \n       bb1: {"}, {"sha": "1fa3992cc5afdb13c89365180d43112595758ac9", "filename": "src/test/ui/consts/miri_unleashed/drop.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fdrop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fdrop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fdrop.stderr?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -4,7 +4,9 @@ error[E0080]: could not evaluate static initializer\n LL | / pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n LL | |     // Code here does not matter - this is replaced by the\n LL | |     // real drop glue by the compiler.\n-LL | |     drop_in_place(to_drop)\n+LL | |\n+LL | |     // SAFETY: see comment above\n+LL | |     unsafe { drop_in_place(to_drop) }\n LL | | }\n    | | ^\n    | | |"}, {"sha": "aa65f4de3e17ee7a1269bb3c33f5ac4f0e1b8029", "filename": "src/test/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -1,12 +1,12 @@\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |           intrinsics::ptr_offset_from(self, origin)\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |           |\n-   |           ptr_offset_from cannot compute offset of pointers into different allocations.\n-   |           inside `std::ptr::const_ptr::<impl *const Struct>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |           inside `DIFFERENT_ALLOC` at $DIR/offset_from_ub.rs:17:27\n+LL |           unsafe { intrinsics::ptr_offset_from(self, origin) }\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    |\n+   |                    ptr_offset_from cannot compute offset of pointers into different allocations.\n+   |                    inside `std::ptr::const_ptr::<impl *const Struct>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                    inside `DIFFERENT_ALLOC` at $DIR/offset_from_ub.rs:17:27\n    | \n   ::: $DIR/offset_from_ub.rs:11:1\n    |\n@@ -24,12 +24,12 @@ LL | | };\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |           intrinsics::ptr_offset_from(self, origin)\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |           |\n-   |           unable to turn bytes into a pointer\n-   |           inside `std::ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |           inside `NOT_PTR` at $DIR/offset_from_ub.rs:23:14\n+LL |           unsafe { intrinsics::ptr_offset_from(self, origin) }\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    |\n+   |                    unable to turn bytes into a pointer\n+   |                    inside `std::ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                    inside `NOT_PTR` at $DIR/offset_from_ub.rs:23:14\n    | \n   ::: $DIR/offset_from_ub.rs:21:1\n    |\n@@ -42,12 +42,12 @@ LL | | };\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |           intrinsics::ptr_offset_from(self, origin)\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |           |\n-   |           exact_div: 1_isize cannot be divided by 2_isize without remainder\n-   |           inside `std::ptr::const_ptr::<impl *const u16>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |           inside `NOT_MULTIPLE_OF_SIZE` at $DIR/offset_from_ub.rs:31:14\n+LL |           unsafe { intrinsics::ptr_offset_from(self, origin) }\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    |\n+   |                    exact_div: 1_isize cannot be divided by 2_isize without remainder\n+   |                    inside `std::ptr::const_ptr::<impl *const u16>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                    inside `NOT_MULTIPLE_OF_SIZE` at $DIR/offset_from_ub.rs:31:14\n    | \n   ::: $DIR/offset_from_ub.rs:26:1\n    |\n@@ -63,12 +63,12 @@ LL | | };\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |           intrinsics::ptr_offset_from(self, origin)\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |           |\n-   |           inbounds test failed: 0x0 is not a valid pointer\n-   |           inside `std::ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |           inside `OFFSET_FROM_NULL` at $DIR/offset_from_ub.rs:37:14\n+LL |           unsafe { intrinsics::ptr_offset_from(self, origin) }\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    |\n+   |                    inbounds test failed: 0x0 is not a valid pointer\n+   |                    inside `std::ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                    inside `OFFSET_FROM_NULL` at $DIR/offset_from_ub.rs:37:14\n    | \n   ::: $DIR/offset_from_ub.rs:34:1\n    |\n@@ -82,12 +82,12 @@ LL | | };\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |           intrinsics::ptr_offset_from(self, origin)\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |           |\n-   |           unable to turn bytes into a pointer\n-   |           inside `std::ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |           inside `DIFFERENT_INT` at $DIR/offset_from_ub.rs:44:14\n+LL |           unsafe { intrinsics::ptr_offset_from(self, origin) }\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    |\n+   |                    unable to turn bytes into a pointer\n+   |                    inside `std::ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                    inside `DIFFERENT_INT` at $DIR/offset_from_ub.rs:44:14\n    | \n   ::: $DIR/offset_from_ub.rs:40:1\n    |"}, {"sha": "0a144a6bac2f18ae0124aee27d10cf0dcd3dfac0", "filename": "src/test/ui/consts/offset_ub.stderr", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -1,12 +1,12 @@\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         overflowing in-bounds pointer arithmetic\n-   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |         inside `BEFORE_START` at $DIR/offset_ub.rs:7:46\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  overflowing in-bounds pointer arithmetic\n+   |                  inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                  inside `BEFORE_START` at $DIR/offset_ub.rs:7:46\n    | \n   ::: $DIR/offset_ub.rs:7:1\n    |\n@@ -18,12 +18,12 @@ LL | pub const BEFORE_START: *const u8 = unsafe { (&0u8 as *const u8).offset(-1)\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         inbounds test failed: pointer must be in-bounds at offset 2, but is outside bounds of allocN which has size 1\n-   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |         inside `AFTER_END` at $DIR/offset_ub.rs:8:43\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  inbounds test failed: pointer must be in-bounds at offset 2, but is outside bounds of allocN which has size 1\n+   |                  inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                  inside `AFTER_END` at $DIR/offset_ub.rs:8:43\n    | \n   ::: $DIR/offset_ub.rs:8:1\n    |\n@@ -33,12 +33,12 @@ LL | pub const AFTER_END: *const u8 = unsafe { (&0u8 as *const u8).offset(2) };\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         inbounds test failed: pointer must be in-bounds at offset 101, but is outside bounds of allocN which has size 100\n-   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |         inside `AFTER_ARRAY` at $DIR/offset_ub.rs:9:45\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  inbounds test failed: pointer must be in-bounds at offset 101, but is outside bounds of allocN which has size 100\n+   |                  inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                  inside `AFTER_ARRAY` at $DIR/offset_ub.rs:9:45\n    | \n   ::: $DIR/offset_ub.rs:9:1\n    |\n@@ -48,12 +48,12 @@ LL | pub const AFTER_ARRAY: *const u8 = unsafe { [0u8; 100].as_ptr().offset(101)\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         overflowing in-bounds pointer arithmetic\n-   |         inside `std::ptr::const_ptr::<impl *const u16>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |         inside `OVERFLOW` at $DIR/offset_ub.rs:11:43\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  overflowing in-bounds pointer arithmetic\n+   |                  inside `std::ptr::const_ptr::<impl *const u16>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                  inside `OVERFLOW` at $DIR/offset_ub.rs:11:43\n    | \n   ::: $DIR/offset_ub.rs:11:1\n    |\n@@ -63,12 +63,12 @@ LL | pub const OVERFLOW: *const u16 = unsafe { [0u16; 1].as_ptr().offset(isize::\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         overflowing in-bounds pointer arithmetic\n-   |         inside `std::ptr::const_ptr::<impl *const u16>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |         inside `UNDERFLOW` at $DIR/offset_ub.rs:12:44\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  overflowing in-bounds pointer arithmetic\n+   |                  inside `std::ptr::const_ptr::<impl *const u16>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                  inside `UNDERFLOW` at $DIR/offset_ub.rs:12:44\n    | \n   ::: $DIR/offset_ub.rs:12:1\n    |\n@@ -78,12 +78,12 @@ LL | pub const UNDERFLOW: *const u16 = unsafe { [0u16; 1].as_ptr().offset(isize:\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         overflowing in-bounds pointer arithmetic\n-   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |         inside `OVERFLOW_ADDRESS_SPACE` at $DIR/offset_ub.rs:13:56\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  overflowing in-bounds pointer arithmetic\n+   |                  inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                  inside `OVERFLOW_ADDRESS_SPACE` at $DIR/offset_ub.rs:13:56\n    | \n   ::: $DIR/offset_ub.rs:13:1\n    |\n@@ -93,12 +93,12 @@ LL | pub const OVERFLOW_ADDRESS_SPACE: *const u8 = unsafe { (usize::MAX as *cons\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         overflowing in-bounds pointer arithmetic\n-   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |         inside `UNDERFLOW_ADDRESS_SPACE` at $DIR/offset_ub.rs:14:57\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  overflowing in-bounds pointer arithmetic\n+   |                  inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                  inside `UNDERFLOW_ADDRESS_SPACE` at $DIR/offset_ub.rs:14:57\n    | \n   ::: $DIR/offset_ub.rs:14:1\n    |\n@@ -108,12 +108,12 @@ LL | pub const UNDERFLOW_ADDRESS_SPACE: *const u8 = unsafe { (1 as *const u8).of\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         inbounds test failed: pointer must be in-bounds at offset 1, but is outside bounds of allocN which has size 0\n-   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |         inside `ZERO_SIZED_ALLOC` at $DIR/offset_ub.rs:16:50\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  inbounds test failed: pointer must be in-bounds at offset 1, but is outside bounds of allocN which has size 0\n+   |                  inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                  inside `ZERO_SIZED_ALLOC` at $DIR/offset_ub.rs:16:50\n    | \n   ::: $DIR/offset_ub.rs:16:1\n    |\n@@ -123,12 +123,12 @@ LL | pub const ZERO_SIZED_ALLOC: *const u8 = unsafe { [0u8; 0].as_ptr().offset(1\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/mut_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count) as *mut T\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         unable to turn bytes into a pointer\n-   |         inside `std::ptr::mut_ptr::<impl *mut u8>::offset` at $SRC_DIR/libcore/ptr/mut_ptr.rs:LL:COL\n-   |         inside `DANGLING` at $DIR/offset_ub.rs:17:42\n+LL |         unsafe { intrinsics::offset(self, count) as *mut T }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  unable to turn bytes into a pointer\n+   |                  inside `std::ptr::mut_ptr::<impl *mut u8>::offset` at $SRC_DIR/libcore/ptr/mut_ptr.rs:LL:COL\n+   |                  inside `DANGLING` at $DIR/offset_ub.rs:17:42\n    | \n   ::: $DIR/offset_ub.rs:17:1\n    |\n@@ -138,12 +138,12 @@ LL | pub const DANGLING: *const u8 = unsafe { ptr::NonNull::<u8>::dangling().as_\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         inbounds test failed: 0x0 is not a valid pointer\n-   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |         inside `NULL_OFFSET_ZERO` at $DIR/offset_ub.rs:20:50\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  inbounds test failed: 0x0 is not a valid pointer\n+   |                  inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                  inside `NULL_OFFSET_ZERO` at $DIR/offset_ub.rs:20:50\n    | \n   ::: $DIR/offset_ub.rs:20:1\n    |\n@@ -153,12 +153,12 @@ LL | pub const NULL_OFFSET_ZERO: *const u8 = unsafe { ptr::null::<u8>().offset(0\n error: any use of this value will cause an error\n   --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n    |\n-LL |         intrinsics::offset(self, count)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         unable to turn bytes into a pointer\n-   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n-   |         inside `UNDERFLOW_ABS` at $DIR/offset_ub.rs:23:47\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  unable to turn bytes into a pointer\n+   |                  inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |                  inside `UNDERFLOW_ABS` at $DIR/offset_ub.rs:23:47\n    | \n   ::: $DIR/offset_ub.rs:23:1\n    |"}, {"sha": "3296a2cb094a15f67d3d02677b3a2c69ba46ea05", "filename": "src/test/ui/recursion/issue-38591-non-regular-dropck-recursion.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Ftest%2Fui%2Frecursion%2Fissue-38591-non-regular-dropck-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a6d4342be6a6acbade8e7ef65e73d27ee8c9144/src%2Ftest%2Fui%2Frecursion%2Fissue-38591-non-regular-dropck-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Fissue-38591-non-regular-dropck-recursion.stderr?ref=8a6d4342be6a6acbade8e7ef65e73d27ee8c9144", "patch": "@@ -4,7 +4,9 @@ error: reached the recursion limit while instantiating `std::intrinsics::drop_in\n LL | / pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n LL | |     // Code here does not matter - this is replaced by the\n LL | |     // real drop glue by the compiler.\n-LL | |     drop_in_place(to_drop)\n+LL | |\n+LL | |     // SAFETY: see comment above\n+LL | |     unsafe { drop_in_place(to_drop) }\n LL | | }\n    | |_^\n    |\n@@ -14,7 +16,9 @@ note: `std::intrinsics::drop_in_place` defined here\n LL | / pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n LL | |     // Code here does not matter - this is replaced by the\n LL | |     // real drop glue by the compiler.\n-LL | |     drop_in_place(to_drop)\n+LL | |\n+LL | |     // SAFETY: see comment above\n+LL | |     unsafe { drop_in_place(to_drop) }\n LL | | }\n    | |_^\n "}]}