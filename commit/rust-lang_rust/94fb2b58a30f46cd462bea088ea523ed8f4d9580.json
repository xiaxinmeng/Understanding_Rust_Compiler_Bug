{"sha": "94fb2b58a30f46cd462bea088ea523ed8f4d9580", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0ZmIyYjU4YTMwZjQ2Y2Q0NjJiZWEwODhlYTUyM2VkOGY0ZDk1ODA=", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-13T08:17:10Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-17T15:49:03Z"}, "message": "move chars_cmp and chars_next_cmp to its own modules", "tree": {"sha": "06a1ef3227519b1d84052227b0e21bd54ca350ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06a1ef3227519b1d84052227b0e21bd54ca350ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94fb2b58a30f46cd462bea088ea523ed8f4d9580", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94fb2b58a30f46cd462bea088ea523ed8f4d9580", "html_url": "https://github.com/rust-lang/rust/commit/94fb2b58a30f46cd462bea088ea523ed8f4d9580", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94fb2b58a30f46cd462bea088ea523ed8f4d9580/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6595d5571b4c498ca18ffc1fdca17b3815271df0", "url": "https://api.github.com/repos/rust-lang/rust/commits/6595d5571b4c498ca18ffc1fdca17b3815271df0", "html_url": "https://github.com/rust-lang/rust/commit/6595d5571b4c498ca18ffc1fdca17b3815271df0"}], "stats": {"total": 121, "additions": 68, "deletions": 53}, "files": [{"sha": "f9af06d200c843a2f17ddab01e852a6deeadef58", "filename": "clippy_lints/src/methods/chars_cmp.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/94fb2b58a30f46cd462bea088ea523ed8f4d9580/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fb2b58a30f46cd462bea088ea523ed8f4d9580/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs?ref=94fb2b58a30f46cd462bea088ea523ed8f4d9580", "patch": "@@ -0,0 +1,54 @@\n+use crate::utils::{method_chain_args, single_segment_path};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_lint::Lint;\n+use rustc_middle::ty;\n+use rustc_span::sym;\n+\n+/// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints.\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    info: &crate::methods::BinaryExprInfo<'_>,\n+    chain_methods: &[&str],\n+    lint: &'static Lint,\n+    suggest: &str,\n+) -> bool {\n+    if_chain! {\n+        if let Some(args) = method_chain_args(info.chain, chain_methods);\n+        if let hir::ExprKind::Call(ref fun, ref arg_char) = info.other.kind;\n+        if arg_char.len() == 1;\n+        if let hir::ExprKind::Path(ref qpath) = fun.kind;\n+        if let Some(segment) = single_segment_path(qpath);\n+        if segment.ident.name == sym::Some;\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0][0]).peel_refs();\n+\n+            if *self_ty.kind() != ty::Str {\n+                return false;\n+            }\n+\n+            span_lint_and_sugg(\n+                cx,\n+                lint,\n+                info.expr.span,\n+                &format!(\"you should use the `{}` method\", suggest),\n+                \"like this\",\n+                format!(\"{}{}.{}({})\",\n+                        if info.eq { \"\" } else { \"!\" },\n+                        snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n+                        suggest,\n+                        snippet_with_applicability(cx, arg_char[0].span, \"..\", &mut applicability)),\n+                applicability,\n+            );\n+\n+            return true;\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "a6701d8830e77d099f17bcc7192f6f6cac566190", "filename": "clippy_lints/src/methods/chars_next_cmp.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94fb2b58a30f46cd462bea088ea523ed8f4d9580/clippy_lints%2Fsrc%2Fmethods%2Fchars_next_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fb2b58a30f46cd462bea088ea523ed8f4d9580/clippy_lints%2Fsrc%2Fmethods%2Fchars_next_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fchars_next_cmp.rs?ref=94fb2b58a30f46cd462bea088ea523ed8f4d9580", "patch": "@@ -0,0 +1,8 @@\n+use rustc_lint::LateContext;\n+\n+use super::CHARS_NEXT_CMP;\n+\n+/// Checks for the `CHARS_NEXT_CMP` lint.\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, info: &crate::methods::BinaryExprInfo<'_>) -> bool {\n+    crate::methods::chars_cmp::check(cx, info, &[\"chars\", \"next\"], CHARS_NEXT_CMP, \"starts_with\")\n+}"}, {"sha": "d288c51907e210c5824a231f39846c5cd7e779a0", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 6, "deletions": 53, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/94fb2b58a30f46cd462bea088ea523ed8f4d9580/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fb2b58a30f46cd462bea088ea523ed8f4d9580/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=94fb2b58a30f46cd462bea088ea523ed8f4d9580", "patch": "@@ -1,5 +1,7 @@\n mod bind_instead_of_map;\n mod bytes_nth;\n+mod chars_cmp;\n+mod chars_next_cmp;\n mod clone_on_copy;\n mod clone_on_ref_ptr;\n mod expect_fun_call;\n@@ -2024,7 +2026,7 @@ struct BinaryExprInfo<'a> {\n /// Checks for the `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints.\n fn lint_binary_expr_with_method_call(cx: &LateContext<'_>, info: &mut BinaryExprInfo<'_>) {\n     macro_rules! lint_with_both_lhs_and_rhs {\n-        ($func:ident, $cx:expr, $info:ident) => {\n+        ($func:expr, $cx:expr, $info:ident) => {\n             if !$func($cx, $info) {\n                 ::std::mem::swap(&mut $info.chain, &mut $info.other);\n                 if $func($cx, $info) {\n@@ -2034,67 +2036,18 @@ fn lint_binary_expr_with_method_call(cx: &LateContext<'_>, info: &mut BinaryExpr\n         };\n     }\n \n-    lint_with_both_lhs_and_rhs!(lint_chars_next_cmp, cx, info);\n+    lint_with_both_lhs_and_rhs!(chars_next_cmp::check, cx, info);\n     lint_with_both_lhs_and_rhs!(lint_chars_last_cmp, cx, info);\n     lint_with_both_lhs_and_rhs!(lint_chars_next_cmp_with_unwrap, cx, info);\n     lint_with_both_lhs_and_rhs!(lint_chars_last_cmp_with_unwrap, cx, info);\n }\n \n-/// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints.\n-fn lint_chars_cmp(\n-    cx: &LateContext<'_>,\n-    info: &BinaryExprInfo<'_>,\n-    chain_methods: &[&str],\n-    lint: &'static Lint,\n-    suggest: &str,\n-) -> bool {\n-    if_chain! {\n-        if let Some(args) = method_chain_args(info.chain, chain_methods);\n-        if let hir::ExprKind::Call(ref fun, ref arg_char) = info.other.kind;\n-        if arg_char.len() == 1;\n-        if let hir::ExprKind::Path(ref qpath) = fun.kind;\n-        if let Some(segment) = single_segment_path(qpath);\n-        if segment.ident.name == sym::Some;\n-        then {\n-            let mut applicability = Applicability::MachineApplicable;\n-            let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0][0]).peel_refs();\n-\n-            if *self_ty.kind() != ty::Str {\n-                return false;\n-            }\n-\n-            span_lint_and_sugg(\n-                cx,\n-                lint,\n-                info.expr.span,\n-                &format!(\"you should use the `{}` method\", suggest),\n-                \"like this\",\n-                format!(\"{}{}.{}({})\",\n-                        if info.eq { \"\" } else { \"!\" },\n-                        snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n-                        suggest,\n-                        snippet_with_applicability(cx, arg_char[0].span, \"..\", &mut applicability)),\n-                applicability,\n-            );\n-\n-            return true;\n-        }\n-    }\n-\n-    false\n-}\n-\n-/// Checks for the `CHARS_NEXT_CMP` lint.\n-fn lint_chars_next_cmp<'tcx>(cx: &LateContext<'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n-    lint_chars_cmp(cx, info, &[\"chars\", \"next\"], CHARS_NEXT_CMP, \"starts_with\")\n-}\n-\n /// Checks for the `CHARS_LAST_CMP` lint.\n fn lint_chars_last_cmp<'tcx>(cx: &LateContext<'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n-    if lint_chars_cmp(cx, info, &[\"chars\", \"last\"], CHARS_LAST_CMP, \"ends_with\") {\n+    if chars_cmp::check(cx, info, &[\"chars\", \"last\"], CHARS_LAST_CMP, \"ends_with\") {\n         true\n     } else {\n-        lint_chars_cmp(cx, info, &[\"chars\", \"next_back\"], CHARS_LAST_CMP, \"ends_with\")\n+        chars_cmp::check(cx, info, &[\"chars\", \"next_back\"], CHARS_LAST_CMP, \"ends_with\")\n     }\n }\n "}]}