{"sha": "4bb84f6002d8b57f7baf3d31feb636a1d3711ffc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiYjg0ZjYwMDJkOGI1N2Y3YmFmM2QzMWZlYjYzNmExZDM3MTFmZmM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-10-17T22:45:55Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-10-18T02:39:11Z"}, "message": "Remove NLL feature\n\nAnd do some refactoring in comments.rs\n\nCloses #3107", "tree": {"sha": "a2f405e7aa979483b6a69797e69ea6c5fe3f6b66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2f405e7aa979483b6a69797e69ea6c5fe3f6b66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bb84f6002d8b57f7baf3d31feb636a1d3711ffc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bb84f6002d8b57f7baf3d31feb636a1d3711ffc", "html_url": "https://github.com/rust-lang/rust/commit/4bb84f6002d8b57f7baf3d31feb636a1d3711ffc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bb84f6002d8b57f7baf3d31feb636a1d3711ffc/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "613dfcc521e07088dbd72a8dcf484f002139f453", "url": "https://api.github.com/repos/rust-lang/rust/commits/613dfcc521e07088dbd72a8dcf484f002139f453", "html_url": "https://github.com/rust-lang/rust/commit/613dfcc521e07088dbd72a8dcf484f002139f453"}], "stats": {"total": 523, "additions": 298, "deletions": 225}, "files": [{"sha": "be38300619641dee0ff06d0adae036ffe8d4b9f6", "filename": "src/chains.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bb84f6002d8b57f7baf3d31feb636a1d3711ffc/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb84f6002d8b57f7baf3d31feb636a1d3711ffc/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=4bb84f6002d8b57f7baf3d31feb636a1d3711ffc", "patch": "@@ -447,7 +447,7 @@ trait ChainFormatter {\n     // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n     // Root is the parent plus any other chain items placed on the first line to\n     // avoid an orphan. E.g.,\n-    // ```\n+    // ```ignore\n     // foo.bar\n     //     .baz()\n     // ```\n@@ -509,7 +509,7 @@ impl<'a> ChainFormatterShared<'a> {\n     // know whether 'overflowing' the last child make a better formatting:\n     //\n     // A chain with overflowing the last child:\n-    // ```\n+    // ```ignore\n     // parent.child1.child2.last_child(\n     //     a,\n     //     b,\n@@ -518,7 +518,7 @@ impl<'a> ChainFormatterShared<'a> {\n     // ```\n     //\n     // A chain without overflowing the last child (in vertical layout):\n-    // ```\n+    // ```ignore\n     // parent\n     //     .child1\n     //     .child2\n@@ -527,7 +527,7 @@ impl<'a> ChainFormatterShared<'a> {\n     //\n     // In particular, overflowing is effective when the last child is a method with a multi-lined\n     // block-like argument (e.g. closure):\n-    // ```\n+    // ```ignore\n     // parent.child1.child2.last_child(|a, b, c| {\n     //     let x = foo(a, b, c);\n     //     let y = bar(a, b, c);"}, {"sha": "9dd7d68965598929ef3c8b4fc2c2861fb2a13511", "filename": "src/comment.rs", "status": "modified", "additions": 244, "deletions": 208, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/4bb84f6002d8b57f7baf3d31feb636a1d3711ffc/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb84f6002d8b57f7baf3d31feb636a1d3711ffc/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=4bb84f6002d8b57f7baf3d31feb636a1d3711ffc", "patch": "@@ -488,70 +488,75 @@ impl ItemizedBlock {\n     }\n }\n \n-fn rewrite_comment_inner(\n-    orig: &str,\n-    block_style: bool,\n-    style: CommentStyle,\n-    shape: Shape,\n-    config: &Config,\n-    is_doc_comment: bool,\n-) -> Option<String> {\n-    let (opener, closer, line_start) = if block_style {\n-        CommentStyle::SingleBullet.to_str_tuplet()\n-    } else {\n-        comment_style(orig, config.normalize_comments()).to_str_tuplet()\n-    };\n+struct CommentRewrite<'a> {\n+    result: String,\n+    code_block_buffer: String,\n+    is_prev_line_multi_line: bool,\n+    code_block_attr: Option<CodeBlockAttribute>,\n+    item_block_buffer: String,\n+    item_block: Option<ItemizedBlock>,\n+    comment_line_separator: String,\n+    indent_str: String,\n+    max_chars: usize,\n+    fmt_indent: Indent,\n+    fmt: StringFormat<'a>,\n \n-    let max_chars = shape\n-        .width\n-        .checked_sub(closer.len() + opener.len())\n-        .unwrap_or(1);\n-    let indent_str = shape.indent.to_string_with_newline(config);\n-    let fmt_indent = shape.indent + (opener.len() - line_start.len());\n-    let mut fmt = StringFormat {\n-        opener: \"\",\n-        closer: \"\",\n-        line_start,\n-        line_end: \"\",\n-        shape: Shape::legacy(max_chars, fmt_indent),\n-        trim_end: true,\n-        config,\n-    };\n+    opener: String,\n+    closer: String,\n+    line_start: String,\n+}\n \n-    let line_breaks = count_newlines(orig.trim_right());\n-    let lines = orig\n-        .lines()\n-        .enumerate()\n-        .map(|(i, mut line)| {\n-            line = trim_right_unless_two_whitespaces(line.trim_left(), is_doc_comment);\n-            // Drop old closer.\n-            if i == line_breaks && line.ends_with(\"*/\") && !line.starts_with(\"//\") {\n-                line = line[..(line.len() - 2)].trim_right();\n-            }\n+impl<'a> CommentRewrite<'a> {\n+    fn new(\n+        orig: &'a str,\n+        block_style: bool,\n+        shape: Shape,\n+        config: &'a Config,\n+    ) -> CommentRewrite<'a> {\n+        let (opener, closer, line_start) = if block_style {\n+            CommentStyle::SingleBullet.to_str_tuplet()\n+        } else {\n+            comment_style(orig, config.normalize_comments()).to_str_tuplet()\n+        };\n \n-            line\n-        })\n-        .map(|s| left_trim_comment_line(s, &style))\n-        .map(|(line, has_leading_whitespace)| {\n-            if orig.starts_with(\"/*\") && line_breaks == 0 {\n-                (\n-                    line.trim_left(),\n-                    has_leading_whitespace || config.normalize_comments(),\n-                )\n-            } else {\n-                (line, has_leading_whitespace || config.normalize_comments())\n-            }\n-        });\n+        let max_chars = shape\n+            .width\n+            .checked_sub(closer.len() + opener.len())\n+            .unwrap_or(1);\n+        let indent_str = shape.indent.to_string_with_newline(config).to_string();\n+        let fmt_indent = shape.indent + (opener.len() - line_start.len());\n+\n+        let mut cr = CommentRewrite {\n+            result: String::with_capacity(orig.len() * 2),\n+            code_block_buffer: String::with_capacity(128),\n+            is_prev_line_multi_line: false,\n+            code_block_attr: None,\n+            item_block_buffer: String::with_capacity(128),\n+            item_block: None,\n+            comment_line_separator: format!(\"{}{}\", indent_str, line_start),\n+            max_chars,\n+            indent_str,\n+            fmt_indent,\n+\n+            fmt: StringFormat {\n+                opener: \"\",\n+                closer: \"\",\n+                line_start,\n+                line_end: \"\",\n+                shape: Shape::legacy(max_chars, fmt_indent),\n+                trim_end: true,\n+                config,\n+            },\n \n-    let mut result = String::with_capacity(orig.len() * 2);\n-    result.push_str(opener);\n-    let mut code_block_buffer = String::with_capacity(128);\n-    let mut is_prev_line_multi_line = false;\n-    let mut code_block_attr = None;\n-    let mut item_block_buffer = String::with_capacity(128);\n-    let mut item_block: Option<ItemizedBlock> = None;\n-    let comment_line_separator = format!(\"{}{}\", indent_str, line_start);\n-    let join_block = |s: &str, sep: &str| {\n+            opener: opener.to_owned(),\n+            closer: closer.to_owned(),\n+            line_start: line_start.to_owned(),\n+        };\n+        cr.result.push_str(opener);\n+        cr\n+    }\n+\n+    fn join_block(s: &str, sep: &str) -> String {\n         let mut result = String::with_capacity(s.len() + 128);\n         let mut iter = s.lines().peekable();\n         while let Some(line) = iter.next() {\n@@ -563,186 +568,252 @@ fn rewrite_comment_inner(\n             });\n         }\n         result\n-    };\n+    }\n \n-    for (i, (line, has_leading_whitespace)) in lines.enumerate() {\n+    fn finish(mut self) -> String {\n+        if !self.code_block_buffer.is_empty() {\n+            // There is a code block that is not properly enclosed by backticks.\n+            // We will leave them untouched.\n+            self.result.push_str(&self.comment_line_separator);\n+            self.result.push_str(&Self::join_block(\n+                &trim_custom_comment_prefix(&self.code_block_buffer),\n+                &self.comment_line_separator,\n+            ));\n+        }\n+\n+        if !self.item_block_buffer.is_empty() {\n+            // the last few lines are part of an itemized block\n+            self.fmt.shape = Shape::legacy(self.max_chars, self.fmt_indent);\n+            let mut ib = None;\n+            ::std::mem::swap(&mut ib, &mut self.item_block);\n+            let ib = ib.unwrap();\n+            let item_fmt = ib.create_string_format(&self.fmt);\n+            self.result.push_str(&self.comment_line_separator);\n+            self.result.push_str(&ib.opener);\n+            match rewrite_string(\n+                &self.item_block_buffer.replace(\"\\n\", \" \"),\n+                &item_fmt,\n+                self.max_chars.saturating_sub(ib.indent),\n+            ) {\n+                Some(s) => self.result.push_str(&Self::join_block(\n+                    &s,\n+                    &format!(\"{}{}\", &self.comment_line_separator, ib.line_start),\n+                )),\n+                None => self.result.push_str(&Self::join_block(\n+                    &self.item_block_buffer,\n+                    &self.comment_line_separator,\n+                )),\n+            };\n+        }\n+\n+        self.result.push_str(&self.closer);\n+        if self.result.ends_with(&self.opener) && self.opener.ends_with(' ') {\n+            // Trailing space.\n+            self.result.pop();\n+        }\n+\n+        self.result\n+    }\n+\n+    fn handle_line(\n+        &mut self,\n+        orig: &'a str,\n+        i: usize,\n+        line: &'a str,\n+        has_leading_whitespace: bool,\n+    ) -> bool {\n         let is_last = i == count_newlines(orig);\n \n-        if let Some(ref ib) = item_block {\n+        if let Some(ref ib) = self.item_block {\n             if ib.in_block(&line) {\n-                item_block_buffer.push_str(&line);\n-                item_block_buffer.push('\\n');\n-                continue;\n+                self.item_block_buffer.push_str(&line);\n+                self.item_block_buffer.push('\\n');\n+                return false;\n             }\n-            is_prev_line_multi_line = false;\n-            fmt.shape = Shape::legacy(max_chars, fmt_indent);\n-            let item_fmt = ib.create_string_format(&fmt);\n-            result.push_str(&comment_line_separator);\n-            result.push_str(&ib.opener);\n+            self.is_prev_line_multi_line = false;\n+            self.fmt.shape = Shape::legacy(self.max_chars, self.fmt_indent);\n+            let item_fmt = ib.create_string_format(&self.fmt);\n+            self.result.push_str(&self.comment_line_separator);\n+            self.result.push_str(&ib.opener);\n             match rewrite_string(\n-                &item_block_buffer.replace(\"\\n\", \" \"),\n+                &self.item_block_buffer.replace(\"\\n\", \" \"),\n                 &item_fmt,\n-                max_chars.saturating_sub(ib.indent),\n+                self.max_chars.saturating_sub(ib.indent),\n             ) {\n-                Some(s) => result.push_str(&join_block(\n+                Some(s) => self.result.push_str(&Self::join_block(\n                     &s,\n-                    &format!(\"{}{}\", &comment_line_separator, ib.line_start),\n+                    &format!(\"{}{}\", &self.comment_line_separator, ib.line_start),\n+                )),\n+                None => self.result.push_str(&Self::join_block(\n+                    &self.item_block_buffer,\n+                    &self.comment_line_separator,\n                 )),\n-                None => result.push_str(&join_block(&item_block_buffer, &comment_line_separator)),\n             };\n-            item_block_buffer.clear();\n-        } else if let Some(ref attr) = code_block_attr {\n+            self.item_block_buffer.clear();\n+        } else if self.code_block_attr.is_some() {\n             if line.starts_with(\"```\") {\n-                let code_block = match attr {\n+                let code_block = match self.code_block_attr.as_ref().unwrap() {\n                     CodeBlockAttribute::Ignore | CodeBlockAttribute::Text => {\n-                        trim_custom_comment_prefix(&code_block_buffer)\n+                        trim_custom_comment_prefix(&self.code_block_buffer)\n                     }\n-                    _ if code_block_buffer.is_empty() => String::new(),\n+                    _ if self.code_block_buffer.is_empty() => String::new(),\n                     _ => {\n-                        let mut config = config.clone();\n+                        let mut config = self.fmt.config.clone();\n                         config.set().format_doc_comments(false);\n-                        match ::format_code_block(&code_block_buffer, &config) {\n+                        match ::format_code_block(&self.code_block_buffer, &config) {\n                             Some(ref s) => trim_custom_comment_prefix(s),\n-                            None => trim_custom_comment_prefix(&code_block_buffer),\n+                            None => trim_custom_comment_prefix(&self.code_block_buffer),\n                         }\n                     }\n                 };\n                 if !code_block.is_empty() {\n-                    result.push_str(&comment_line_separator);\n-                    result.push_str(&join_block(&code_block, &comment_line_separator));\n+                    self.result.push_str(&self.comment_line_separator);\n+                    self.result\n+                        .push_str(&Self::join_block(&code_block, &self.comment_line_separator));\n                 }\n-                code_block_buffer.clear();\n-                result.push_str(&comment_line_separator);\n-                result.push_str(line);\n-                code_block_attr = None;\n+                self.code_block_buffer.clear();\n+                self.result.push_str(&self.comment_line_separator);\n+                self.result.push_str(line);\n+                self.code_block_attr = None;\n             } else {\n-                code_block_buffer.push_str(&hide_sharp_behind_comment(line));\n-                code_block_buffer.push('\\n');\n+                self.code_block_buffer\n+                    .push_str(&hide_sharp_behind_comment(line));\n+                self.code_block_buffer.push('\\n');\n             }\n-            continue;\n+            return false;\n         }\n \n-        code_block_attr = None;\n-        item_block = None;\n+        self.code_block_attr = None;\n+        self.item_block = None;\n         if line.starts_with(\"```\") {\n-            code_block_attr = Some(CodeBlockAttribute::new(&line[3..]))\n-        } else if config.wrap_comments() && ItemizedBlock::is_itemized_line(&line) {\n+            self.code_block_attr = Some(CodeBlockAttribute::new(&line[3..]))\n+        } else if self.fmt.config.wrap_comments() && ItemizedBlock::is_itemized_line(&line) {\n             let ib = ItemizedBlock::new(&line);\n-            item_block_buffer.push_str(&line[ib.indent..]);\n-            item_block_buffer.push('\\n');\n-            item_block = Some(ib);\n-            continue;\n+            self.item_block_buffer.push_str(&line[ib.indent..]);\n+            self.item_block_buffer.push('\\n');\n+            self.item_block = Some(ib);\n+            return false;\n         }\n \n-        if result == opener {\n-            let force_leading_whitespace = opener == \"/* \" && count_newlines(orig) == 0;\n-            if !has_leading_whitespace && !force_leading_whitespace && result.ends_with(' ') {\n-                result.pop();\n+        if self.result == self.opener {\n+            let force_leading_whitespace = &self.opener == \"/* \" && count_newlines(orig) == 0;\n+            if !has_leading_whitespace && !force_leading_whitespace && self.result.ends_with(' ') {\n+                self.result.pop();\n             }\n             if line.is_empty() {\n-                continue;\n+                return false;\n             }\n-        } else if is_prev_line_multi_line && !line.is_empty() {\n-            result.push(' ')\n+        } else if self.is_prev_line_multi_line && !line.is_empty() {\n+            self.result.push(' ')\n         } else if is_last && line.is_empty() {\n             // trailing blank lines are unwanted\n-            if !closer.is_empty() {\n-                result.push_str(&indent_str);\n+            if !self.closer.is_empty() {\n+                self.result.push_str(&self.indent_str);\n             }\n-            break;\n+            return true;\n         } else {\n-            result.push_str(&comment_line_separator);\n-            if !has_leading_whitespace && result.ends_with(' ') {\n-                result.pop();\n+            self.result.push_str(&self.comment_line_separator);\n+            if !has_leading_whitespace && self.result.ends_with(' ') {\n+                self.result.pop();\n             }\n         }\n \n-        if config.wrap_comments() && line.len() > fmt.shape.width && !has_url(line) {\n-            match rewrite_string(line, &fmt, max_chars) {\n+        if self.fmt.config.wrap_comments() && line.len() > self.fmt.shape.width && !has_url(line) {\n+            match rewrite_string(line, &self.fmt, self.max_chars) {\n                 Some(ref s) => {\n-                    is_prev_line_multi_line = s.contains('\\n');\n-                    result.push_str(s);\n+                    self.is_prev_line_multi_line = s.contains('\\n');\n+                    self.result.push_str(s);\n                 }\n-                None if is_prev_line_multi_line => {\n+                None if self.is_prev_line_multi_line => {\n                     // We failed to put the current `line` next to the previous `line`.\n                     // Remove the trailing space, then start rewrite on the next line.\n-                    result.pop();\n-                    result.push_str(&comment_line_separator);\n-                    fmt.shape = Shape::legacy(max_chars, fmt_indent);\n-                    match rewrite_string(line, &fmt, max_chars) {\n+                    self.result.pop();\n+                    self.result.push_str(&self.comment_line_separator);\n+                    self.fmt.shape = Shape::legacy(self.max_chars, self.fmt_indent);\n+                    match rewrite_string(line, &self.fmt, self.max_chars) {\n                         Some(ref s) => {\n-                            is_prev_line_multi_line = s.contains('\\n');\n-                            result.push_str(s);\n+                            self.is_prev_line_multi_line = s.contains('\\n');\n+                            self.result.push_str(s);\n                         }\n                         None => {\n-                            is_prev_line_multi_line = false;\n-                            result.push_str(line);\n+                            self.is_prev_line_multi_line = false;\n+                            self.result.push_str(line);\n                         }\n                     }\n                 }\n                 None => {\n-                    is_prev_line_multi_line = false;\n-                    result.push_str(line);\n+                    self.is_prev_line_multi_line = false;\n+                    self.result.push_str(line);\n                 }\n             }\n \n-            fmt.shape = if is_prev_line_multi_line {\n+            self.fmt.shape = if self.is_prev_line_multi_line {\n                 // 1 = \" \"\n-                let offset = 1 + last_line_width(&result) - line_start.len();\n+                let offset = 1 + last_line_width(&self.result) - self.line_start.len();\n                 Shape {\n-                    width: max_chars.saturating_sub(offset),\n-                    indent: fmt_indent,\n-                    offset: fmt.shape.offset + offset,\n+                    width: self.max_chars.saturating_sub(offset),\n+                    indent: self.fmt_indent,\n+                    offset: self.fmt.shape.offset + offset,\n                 }\n             } else {\n-                Shape::legacy(max_chars, fmt_indent)\n+                Shape::legacy(self.max_chars, self.fmt_indent)\n             };\n         } else {\n-            if line.is_empty() && result.ends_with(' ') && !is_last {\n+            if line.is_empty() && self.result.ends_with(' ') && !is_last {\n                 // Remove space if this is an empty comment or a doc comment.\n-                result.pop();\n+                self.result.pop();\n             }\n-            result.push_str(line);\n-            fmt.shape = Shape::legacy(max_chars, fmt_indent);\n-            is_prev_line_multi_line = false;\n+            self.result.push_str(line);\n+            self.fmt.shape = Shape::legacy(self.max_chars, self.fmt_indent);\n+            self.is_prev_line_multi_line = false;\n         }\n+\n+        false\n     }\n-    if !code_block_buffer.is_empty() {\n-        // There is a code block that is not properly enclosed by backticks.\n-        // We will leave them untouched.\n-        result.push_str(&comment_line_separator);\n-        result.push_str(&join_block(\n-            &trim_custom_comment_prefix(&code_block_buffer),\n-            &comment_line_separator,\n-        ));\n-    }\n-    if !item_block_buffer.is_empty() {\n-        // the last few lines are part of an itemized block\n-        let ib = item_block.unwrap();\n-        fmt.shape = Shape::legacy(max_chars, fmt_indent);\n-        let item_fmt = ib.create_string_format(&fmt);\n-        result.push_str(&comment_line_separator);\n-        result.push_str(&ib.opener);\n-        match rewrite_string(\n-            &item_block_buffer.replace(\"\\n\", \" \"),\n-            &item_fmt,\n-            max_chars.saturating_sub(ib.indent),\n-        ) {\n-            Some(s) => result.push_str(&join_block(\n-                &s,\n-                &format!(\"{}{}\", &comment_line_separator, ib.line_start),\n-            )),\n-            None => result.push_str(&join_block(&item_block_buffer, &comment_line_separator)),\n-        };\n-    }\n+}\n \n-    result.push_str(closer);\n-    if result.ends_with(opener) && opener.ends_with(' ') {\n-        // Trailing space.\n-        result.pop();\n+fn rewrite_comment_inner(\n+    orig: &str,\n+    block_style: bool,\n+    style: CommentStyle,\n+    shape: Shape,\n+    config: &Config,\n+    is_doc_comment: bool,\n+) -> Option<String> {\n+    let mut rewriter = CommentRewrite::new(orig, block_style, shape, config);\n+\n+    let line_breaks = count_newlines(orig.trim_right());\n+    let lines = orig\n+        .lines()\n+        .enumerate()\n+        .map(|(i, mut line)| {\n+            line = trim_right_unless_two_whitespaces(line.trim_left(), is_doc_comment);\n+            // Drop old closer.\n+            if i == line_breaks && line.ends_with(\"*/\") && !line.starts_with(\"//\") {\n+                line = line[..(line.len() - 2)].trim_right();\n+            }\n+\n+            line\n+        })\n+        .map(|s| left_trim_comment_line(s, &style))\n+        .map(|(line, has_leading_whitespace)| {\n+            if orig.starts_with(\"/*\") && line_breaks == 0 {\n+                (\n+                    line.trim_left(),\n+                    has_leading_whitespace || config.normalize_comments(),\n+                )\n+            } else {\n+                (line, has_leading_whitespace || config.normalize_comments())\n+            }\n+        });\n+\n+    for (i, (line, has_leading_whitespace)) in lines.enumerate() {\n+        if rewriter.handle_line(orig, i, line, has_leading_whitespace) {\n+            break;\n+        }\n     }\n \n-    Some(result)\n+    Some(rewriter.finish())\n }\n \n const RUSTFMT_CUSTOM_COMMENT_PREFIX: &str = \"//#### \";\n@@ -957,35 +1028,6 @@ pub fn contains_comment(text: &str) -> bool {\n     CharClasses::new(text.chars()).any(|(kind, _)| kind.is_comment())\n }\n \n-/// Remove trailing spaces from the specified snippet. We do not remove spaces\n-/// inside strings or comments.\n-pub fn remove_trailing_white_spaces(text: &str) -> String {\n-    let mut buffer = String::with_capacity(text.len());\n-    let mut space_buffer = String::with_capacity(128);\n-    for (char_kind, c) in CharClasses::new(text.chars()) {\n-        match c {\n-            '\\n' => {\n-                if char_kind == FullCodeCharKind::InString {\n-                    buffer.push_str(&space_buffer);\n-                }\n-                space_buffer.clear();\n-                buffer.push('\\n');\n-            }\n-            _ if c.is_whitespace() => {\n-                space_buffer.push(c);\n-            }\n-            _ => {\n-                if !space_buffer.is_empty() {\n-                    buffer.push_str(&space_buffer);\n-                    space_buffer.clear();\n-                }\n-                buffer.push(c);\n-            }\n-        }\n-    }\n-    buffer\n-}\n-\n pub struct CharClasses<T>\n where\n     T: Iterator,\n@@ -1780,12 +1822,6 @@ mod test {\n         check(\"\\\"/* abc\", \"abc\", Some(4));\n     }\n \n-    #[test]\n-    fn test_remove_trailing_white_spaces() {\n-        let s = \"    r#\\\"\\n        test\\n    \\\"#\";\n-        assert_eq!(remove_trailing_white_spaces(&s), s);\n-    }\n-\n     #[test]\n     fn test_filter_normal_code() {\n         let s = r#\""}, {"sha": "d2748b35736ce5dabdda535a939012dc54ff806c", "filename": "src/formatting.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4bb84f6002d8b57f7baf3d31feb636a1d3711ffc/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb84f6002d8b57f7baf3d31feb636a1d3711ffc/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=4bb84f6002d8b57f7baf3d31feb636a1d3711ffc", "patch": "@@ -528,7 +528,8 @@ impl<'a> FormatLines<'a> {\n                 && !self.is_skipped_line()\n                 && self.should_report_error(kind, &error_kind)\n             {\n-                self.push_err(error_kind, kind.is_comment(), self.is_string);\n+                let is_string = self.is_string;\n+                self.push_err(error_kind, kind.is_comment(), is_string);\n             }\n         }\n "}, {"sha": "ff006325be0f672140ec61b89ed3f75493417197", "filename": "src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bb84f6002d8b57f7baf3d31feb636a1d3711ffc/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb84f6002d8b57f7baf3d31feb636a1d3711ffc/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4bb84f6002d8b57f7baf3d31feb636a1d3711ffc", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(nll)]\n-\n #[macro_use]\n extern crate derive_new;\n extern crate atty;"}, {"sha": "10a037e35a3b01fa0693137955340d0ac0de5739", "filename": "src/macros.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4bb84f6002d8b57f7baf3d31feb636a1d3711ffc/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb84f6002d8b57f7baf3d31feb636a1d3711ffc/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=4bb84f6002d8b57f7baf3d31feb636a1d3711ffc", "patch": "@@ -32,18 +32,15 @@ use syntax::tokenstream::{Cursor, ThinTokenStream, TokenStream, TokenTree};\n use syntax::ThinVec;\n use syntax::{ast, ptr};\n \n-use comment::{\n-    contains_comment, remove_trailing_white_spaces, CharClasses, FindUncommented, FullCodeCharKind,\n-    LineClasses,\n-};\n+use comment::{contains_comment, CharClasses, FindUncommented, FullCodeCharKind, LineClasses};\n use expr::rewrite_array;\n use lists::{itemize_list, write_list, ListFormatting};\n use overflow;\n use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n use source_map::SpanUtils;\n use spanned::Spanned;\n-use utils::{format_visibility, mk_sp, rewrite_ident, wrap_str};\n+use utils::{format_visibility, mk_sp, remove_trailing_white_spaces, rewrite_ident, wrap_str};\n use visitor::FmtVisitor;\n \n const FORCED_BRACKET_MACROS: &[&str] = &[\"vec!\"];"}, {"sha": "aa3e729bb43a4114a7dab61d8dee8a35aaf8674b", "filename": "src/test/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bb84f6002d8b57f7baf3d31feb636a1d3711ffc/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb84f6002d8b57f7baf3d31feb636a1d3711ffc/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=4bb84f6002d8b57f7baf3d31feb636a1d3711ffc", "patch": "@@ -281,7 +281,7 @@ fn stdin_formatting_smoke_test() {\n         session.format(input).unwrap();\n         assert!(session.has_no_errors());\n     }\n-    //eprintln!(\"{:?}\", );\n+\n     #[cfg(not(windows))]\n     assert_eq!(buf, \"fn main() {}\\n\".as_bytes());\n     #[cfg(windows)]"}, {"sha": "d90bcc5931dc0c6f0c2f92bab3b2f3d0505cba3d", "filename": "src/utils.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4bb84f6002d8b57f7baf3d31feb636a1d3711ffc/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb84f6002d8b57f7baf3d31feb636a1d3711ffc/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=4bb84f6002d8b57f7baf3d31feb636a1d3711ffc", "patch": "@@ -20,7 +20,7 @@ use syntax::ast::{\n use syntax::ptr;\n use syntax::source_map::{BytePos, Span, NO_EXPANSION};\n \n-use comment::filter_normal_code;\n+use comment::{filter_normal_code, CharClasses, FullCodeCharKind};\n use rewrite::RewriteContext;\n use shape::Shape;\n \n@@ -452,3 +452,38 @@ pub fn is_block_expr(context: &RewriteContext, expr: &ast::Expr, repr: &str) ->\n         _ => false,\n     }\n }\n+\n+/// Remove trailing spaces from the specified snippet. We do not remove spaces\n+/// inside strings or comments.\n+pub fn remove_trailing_white_spaces(text: &str) -> String {\n+    let mut buffer = String::with_capacity(text.len());\n+    let mut space_buffer = String::with_capacity(128);\n+    for (char_kind, c) in CharClasses::new(text.chars()) {\n+        match c {\n+            '\\n' => {\n+                if char_kind == FullCodeCharKind::InString {\n+                    buffer.push_str(&space_buffer);\n+                }\n+                space_buffer.clear();\n+                buffer.push('\\n');\n+            }\n+            _ if c.is_whitespace() => {\n+                space_buffer.push(c);\n+            }\n+            _ => {\n+                if !space_buffer.is_empty() {\n+                    buffer.push_str(&space_buffer);\n+                    space_buffer.clear();\n+                }\n+                buffer.push(c);\n+            }\n+        }\n+    }\n+    buffer\n+}\n+\n+#[test]\n+fn test_remove_trailing_white_spaces() {\n+    let s = \"    r#\\\"\\n        test\\n    \\\"#\";\n+    assert_eq!(remove_trailing_white_spaces(&s), s);\n+}"}, {"sha": "a6f926736ccf286ec36ff6b75d81ad15151d7e9a", "filename": "src/visitor.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bb84f6002d8b57f7baf3d31feb636a1d3711ffc/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb84f6002d8b57f7baf3d31feb636a1d3711ffc/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=4bb84f6002d8b57f7baf3d31feb636a1d3711ffc", "patch": "@@ -791,9 +791,15 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n     where\n         F: Fn(&RewriteContext) -> Option<String>,\n     {\n-        let context = self.get_context();\n-        let result = f(&context);\n-        self.macro_rewrite_failure |= *context.macro_rewrite_failure.borrow();\n+        // FIXME borrow checker fighting - can be simplified a lot with NLL.\n+        let (result, mrf) = {\n+            let context = self.get_context();\n+            let result = f(&context);\n+            let mrf = &context.macro_rewrite_failure.borrow();\n+            (result, *std::ops::Deref::deref(mrf))\n+        };\n+\n+        self.macro_rewrite_failure |= mrf;\n         result\n     }\n "}]}