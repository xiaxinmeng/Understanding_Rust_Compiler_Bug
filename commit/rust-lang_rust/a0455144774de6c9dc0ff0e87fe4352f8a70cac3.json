{"sha": "a0455144774de6c9dc0ff0e87fe4352f8a70cac3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwNDU1MTQ0Nzc0ZGU2YzlkYzBmZjBlODdmZTQzNTJmOGE3MGNhYzM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-03-24T11:11:32Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-25T15:22:52Z"}, "message": "Start making the standard-lib utf-8 aware\n\nFinally implements _str.is_utf8, adds from_chars, from_char, to_chars,\nchar_at, char_len, (push|pop|shift|unshift)_char. Also, proper\ncharacter I/O for streams.", "tree": {"sha": "a487499a7e61e5fbda47d93eba806fb02373d1ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a487499a7e61e5fbda47d93eba806fb02373d1ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0455144774de6c9dc0ff0e87fe4352f8a70cac3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0455144774de6c9dc0ff0e87fe4352f8a70cac3", "html_url": "https://github.com/rust-lang/rust/commit/a0455144774de6c9dc0ff0e87fe4352f8a70cac3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0455144774de6c9dc0ff0e87fe4352f8a70cac3/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3b49f5aab6a9e9efc2ab1d6713cc0d2bde94f4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3b49f5aab6a9e9efc2ab1d6713cc0d2bde94f4e", "html_url": "https://github.com/rust-lang/rust/commit/d3b49f5aab6a9e9efc2ab1d6713cc0d2bde94f4e"}], "stats": {"total": 332, "additions": 287, "deletions": 45}, "files": [{"sha": "5a75ae055316caae5bee573b8c6df8487b962bf2", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a0455144774de6c9dc0ff0e87fe4352f8a70cac3/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/a0455144774de6c9dc0ff0e87fe4352f8a70cac3/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=a0455144774de6c9dc0ff0e87fe4352f8a70cac3", "patch": "@@ -712,6 +712,7 @@ TEST_XFAILS_STAGE0 := $(FLOAT_XFAILS) \\\n                         use-import-export.rs \\\n                         user.rs \\\n                         utf8.rs \\\n+                        utf8_chars.rs \\\n                         vec-alloc-append.rs \\\n                         vec-append.rs \\\n                         vec-slice.rs \\"}, {"sha": "9c05b5706c2bb9ea2362e1d633c2b46edcf107e8", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a0455144774de6c9dc0ff0e87fe4352f8a70cac3/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0455144774de6c9dc0ff0e87fe4352f8a70cac3/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=a0455144774de6c9dc0ff0e87fe4352f8a70cac3", "patch": "@@ -76,7 +76,7 @@ impure fn new_reader(io.reader rdr, str filename) -> reader\n                     col += 1u;\n                 }\n \n-                n = rdr.read_char() as char;\n+                n = rdr.read_byte() as char;\n             }\n \n             fn mark() {\n@@ -204,8 +204,8 @@ impure fn new_reader(io.reader rdr, str filename) -> reader\n     reserved.insert(\"m128\", ()); // IEEE 754-2008 'decimal128'\n     reserved.insert(\"dec\", ());  // One of m32, m64, m128\n \n-    ret reader(rdr, filename, rdr.read_char() as char,\n-               rdr.read_char() as char, 1u, 0u, 1u, 0u, keywords, reserved);\n+    ret reader(rdr, filename, rdr.read_byte() as char,\n+               rdr.read_byte() as char, 1u, 0u, 1u, 0u, keywords, reserved);\n }\n \n "}, {"sha": "31d0790d22dd7d5198e3b80b810ae76b3cfc6a68", "filename": "src/lib/_str.rs", "status": "modified", "additions": 164, "deletions": 3, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/a0455144774de6c9dc0ff0e87fe4352f8a70cac3/src%2Flib%2F_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0455144774de6c9dc0ff0e87fe4352f8a70cac3/src%2Flib%2F_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_str.rs?ref=a0455144774de6c9dc0ff0e87fe4352f8a70cac3", "patch": "@@ -10,6 +10,7 @@ native \"rust\" mod rustrt {\n     fn str_from_vec(vec[mutable? u8] b) -> str;\n     fn str_from_cstr(sbuf cstr) -> str;\n     fn str_from_buf(sbuf buf, uint len) -> str;\n+    fn str_push_byte(str s, uint byte) -> str;\n     fn refcount[T](str s) -> uint;\n }\n \n@@ -65,15 +66,42 @@ fn hash(&str s) -> uint {\n     ret u;\n }\n \n+// UTF-8 tags and ranges\n+const u8 tag_cont_u8 = 0x80_u8;\n+const uint tag_cont = 0x80_u;\n+const uint max_one_b = 0x80_u;\n+const uint tag_two_b = 0xc0_u;\n+const uint max_two_b = 0x800_u;\n+const uint tag_three_b = 0xe0_u;\n+const uint max_three_b = 0x10000_u;\n+const uint tag_four_b = 0xf0_u;\n+const uint max_four_b = 0x200000_u;\n+const uint tag_five_b = 0xf8_u;\n+const uint max_five_b = 0x4000000_u;\n+const uint tag_six_b = 0xfc_u;\n+\n fn is_utf8(vec[u8] v) -> bool {\n-    fail; // FIXME\n+    auto i = 0u;\n+    auto total = _vec.len[u8](v);\n+    while (i < total) {\n+        auto chsize = utf8_char_width(v.(i));\n+        if (chsize == 0u) {ret false;}\n+        if (i + chsize > total) {ret false;}\n+        i += 1u;\n+        while (chsize > 1u) {\n+            if (v.(i) & 0xc0_u8 != tag_cont_u8) {ret false;}\n+            i += 1u;\n+            chsize -= 1u;\n+        }\n+    }\n+    ret true;\n }\n \n fn is_ascii(str s) -> bool {\n     let uint i = byte_len(s);\n     while (i > 0u) {\n         i -= 1u;\n-        if ((s.(i) & 0x80u8) != 0u8) {\n+        if ((s.(i) & 0x80_u8) != 0u8) {\n             ret false;\n         }\n     }\n@@ -134,6 +162,139 @@ unsafe fn str_from_buf(sbuf buf, uint len) -> str {\n     ret rustrt.str_from_buf(buf, len);\n }\n \n+fn push_utf8_bytes(&mutable str s, char ch) {\n+    auto code = ch as uint;\n+    if (code < max_one_b) {\n+        s = rustrt.str_push_byte(s, code);\n+    } else if (code < max_two_b) {\n+        s = rustrt.str_push_byte(s, ((code >> 6u) & 0x1f_u) | tag_two_b);\n+        s = rustrt.str_push_byte(s, (code & 0x3f_u) | tag_cont);\n+    } else if (code < max_three_b) {\n+        s = rustrt.str_push_byte(s, ((code >> 12u) & 0x0f_u) | tag_three_b);\n+        s = rustrt.str_push_byte(s, ((code >> 6u) & 0x3f_u) | tag_cont);\n+        s = rustrt.str_push_byte(s, (code & 0x3f_u) | tag_cont);\n+    } else if (code < max_four_b) {\n+        s = rustrt.str_push_byte(s, ((code >> 18u) & 0x07_u) | tag_four_b);\n+        s = rustrt.str_push_byte(s, ((code >> 12u) & 0x3f_u) | tag_cont);\n+        s = rustrt.str_push_byte(s, ((code >> 6u) & 0x3f_u) | tag_cont);\n+        s = rustrt.str_push_byte(s, (code & 0x3f_u) | tag_cont);\n+    } else if (code < max_five_b) {\n+        s = rustrt.str_push_byte(s, ((code >> 24u) & 0x03_u) | tag_five_b);\n+        s = rustrt.str_push_byte(s, ((code >> 18u) & 0x3f_u) | tag_cont);\n+        s = rustrt.str_push_byte(s, ((code >> 12u) & 0x3f_u) | tag_cont);\n+        s = rustrt.str_push_byte(s, ((code >> 6u) & 0x3f_u) | tag_cont);\n+        s = rustrt.str_push_byte(s, (code & 0x3f_u) | tag_cont);\n+    } else {\n+        s = rustrt.str_push_byte(s, ((code >> 30u) & 0x01_u) | tag_six_b);\n+        s = rustrt.str_push_byte(s, ((code >> 24u) & 0x3f_u) | tag_cont);\n+        s = rustrt.str_push_byte(s, ((code >> 18u) & 0x3f_u) | tag_cont);\n+        s = rustrt.str_push_byte(s, ((code >> 12u) & 0x3f_u) | tag_cont);\n+        s = rustrt.str_push_byte(s, ((code >> 6u) & 0x3f_u) | tag_cont);\n+        s = rustrt.str_push_byte(s, (code & 0x3f_u) | tag_cont);\n+    }\n+}\n+\n+fn from_char(char ch) -> str {\n+    auto buf = \"\";\n+    push_utf8_bytes(buf, ch);\n+    ret buf;\n+}\n+\n+fn from_chars(vec[char] chs) -> str {\n+    auto buf = \"\";\n+    for (char ch in chs) {push_utf8_bytes(buf, ch);}\n+    ret buf;\n+}\n+\n+fn utf8_char_width(u8 b) -> uint {\n+    let uint byte = b as uint;\n+    if (byte < 0x80_u) {ret 1u;}\n+    if (byte < 0xc0_u) {ret 0u;} // Not a valid start byte\n+    if (byte < 0xe0_u) {ret 2u;}\n+    if (byte < 0xf0_u) {ret 3u;}\n+    if (byte < 0xf8_u) {ret 4u;}\n+    if (byte < 0xfc_u) {ret 5u;}\n+    ret 6u;\n+}\n+\n+fn char_range_at(str s, uint i) -> tup(char, uint) {\n+    auto b0 = s.(i);\n+    auto w = utf8_char_width(b0);\n+    check(w != 0u);\n+    if (w == 1u) {ret tup(b0 as char, i + 1u);}\n+    auto val = 0u;\n+    auto end = i + w;\n+    i += 1u;\n+    while (i < end) {\n+        auto byte = s.(i);\n+        check(byte & 0xc0_u8 == tag_cont_u8);\n+        val <<= 6u;\n+        val += (byte & 0x3f_u8) as uint;\n+        i += 1u;\n+    }\n+    // Clunky way to get the right bits from the first byte. Uses two shifts,\n+    // the first to clip off the marker bits at the left of the byte, and then\n+    // a second (as uint) to get it to the right position.\n+    val += ((b0 << ((w + 1u) as u8)) as uint) << ((w - 1u) * 6u - w - 1u);\n+    ret tup(val as char, i);\n+}\n+\n+fn char_at(str s, uint i) -> char {\n+    ret char_range_at(s, i)._0;\n+}\n+\n+fn char_len(str s) -> uint {\n+    auto i = 0u;\n+    auto len = 0u;\n+    auto total = byte_len(s);\n+    while (i < total) {\n+        auto chsize = utf8_char_width(s.(i));\n+        check(chsize > 0u);\n+        len += 1u;\n+        i += chsize;\n+    }\n+    check(i == total);\n+    ret len;\n+}\n+\n+fn to_chars(str s) -> vec[char] {\n+    let vec[char] buf = vec();\n+    auto i = 0u;\n+    auto len = byte_len(s);\n+    while (i < len) {\n+        auto cur = char_range_at(s, i);\n+        _vec.push[char](buf, cur._0);\n+        i = cur._1;\n+    }\n+    ret buf;\n+}\n+\n+fn push_char(&mutable str s, char ch) {\n+    s += from_char(ch);\n+}\n+\n+fn pop_char(&mutable str s) -> char {\n+    auto end = byte_len(s);\n+    while (end > 0u && s.(end - 1u) & 0xc0_u8 == tag_cont_u8) {end -= 1u;}\n+    check(end > 0u);\n+    auto ch = char_at(s, end - 1u);\n+    s = substr(s, 0u, end - 1u);\n+    ret ch;\n+}\n+\n+fn shift_char(&mutable str s) -> char {\n+    auto r = char_range_at(s, 0u);\n+    s = substr(s, r._1, byte_len(s) - r._1);\n+    ret r._0;\n+}\n+\n+fn unshift_char(&mutable str s, char ch) {\n+    // Workaround for rustboot order-of-evaluation issue -- if I put s\n+    // directly after the +, the string ends up containing (only) the\n+    // character, twice.\n+    auto x = s;\n+    s = from_char(ch) + x;\n+}\n \n fn refcount(str s) -> uint {\n     auto r = rustrt.refcount[u8](s);\n@@ -256,7 +417,7 @@ fn pop_byte(&mutable str s) -> u8 {\n }\n \n fn push_byte(&mutable str s, u8 b) {\n-    s += unsafe_from_byte(b);\n+    s = rustrt.str_push_byte(s, b as uint);\n }\n \n fn unshift_byte(&mutable str s, u8 b) {"}, {"sha": "d1697ebaeed34843a742b1909c56325c24d76b59", "filename": "src/lib/ebml.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a0455144774de6c9dc0ff0e87fe4352f8a70cac3/src%2Flib%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0455144774de6c9dc0ff0e87fe4352f8a70cac3/src%2Flib%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febml.rs?ref=a0455144774de6c9dc0ff0e87fe4352f8a70cac3", "patch": "@@ -21,18 +21,18 @@ type reader = rec(\n \n // TODO: eventually use u64 or big here\n impure fn read_vint(&io.reader reader) -> uint {\n-    auto a = reader.read_byte();\n+    auto a = reader.read_byte() as u8;\n     if (a & 0x80u8 != 0u8) { ret (a & 0x7fu8) as uint; }\n-    auto b = reader.read_byte();\n+    auto b = reader.read_byte() as u8;\n     if (a & 0x40u8 != 0u8) {\n         ret (((a & 0x3fu8) as uint) << 8u) | (b as uint);\n     }\n-    auto c = reader.read_byte();\n+    auto c = reader.read_byte() as u8;\n     if (a & 0x20u8 != 0u8) {\n         ret (((a & 0x1fu8) as uint) << 16u) | ((b as uint) << 8u) |\n             (c as uint);\n     }\n-    auto d = reader.read_byte();\n+    auto d = reader.read_byte() as u8;\n     if (a & 0x10u8 != 0u8) {\n         ret (((a & 0x0fu8) as uint) << 24u) | ((b as uint) << 16u) |\n             ((c as uint) << 8u) | (d as uint);"}, {"sha": "5bced0ba07127f359059744172396c16cab3f37f", "filename": "src/lib/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0455144774de6c9dc0ff0e87fe4352f8a70cac3/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0455144774de6c9dc0ff0e87fe4352f8a70cac3/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=a0455144774de6c9dc0ff0e87fe4352f8a70cac3", "patch": "@@ -3,7 +3,7 @@ native \"rust\" mod rustrt {\n }\n \n fn path_sep() -> str {\n-  ret _str.unsafe_from_bytes(vec(os_fs.path_sep as u8));\n+    ret _str.from_char(os_fs.path_sep);\n }\n \n type path = str;"}, {"sha": "39399aaa8bcbe8edcc01d07ba4b8b2f0baa058e8", "filename": "src/lib/io.rs", "status": "modified", "additions": 57, "deletions": 34, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a0455144774de6c9dc0ff0e87fe4352f8a70cac3/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0455144774de6c9dc0ff0e87fe4352f8a70cac3/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=a0455144774de6c9dc0ff0e87fe4352f8a70cac3", "patch": "@@ -7,24 +7,24 @@ native \"rust\" mod rustrt {\n \n // Reading\n \n-// TODO This is all buffered. We might need an unbuffered variant as well\n+// FIXME This is all buffered. We might need an unbuffered variant as well\n \n tag seek_style {seek_set; seek_end; seek_cur;}\n \n type reader =\n     state obj {\n-          impure fn read_byte() -> u8;\n+          impure fn read_byte() -> int;\n+          impure fn unread_byte(int byte);\n           impure fn read_bytes(uint len) -> vec[u8];\n-          impure fn read_char() -> int;\n-          impure fn unread_char(int i);\n+          impure fn read_char() -> char;\n           impure fn eof() -> bool;\n           impure fn read_line() -> str;\n           impure fn read_c_str() -> str;\n           impure fn read_le_uint(uint size) -> uint;\n           impure fn read_le_int(uint size) -> int;\n \n           impure fn seek(int offset, seek_style whence);\n-          impure fn tell() -> uint; // TODO: eventually u64\n+          impure fn tell() -> uint; // FIXME: eventually u64\n     };\n \n fn convert_whence(seek_style whence) -> int {\n@@ -36,47 +36,66 @@ fn convert_whence(seek_style whence) -> int {\n }\n \n state obj FILE_reader(os.libc.FILE f, bool must_close) {\n-    impure fn read_byte() -> u8 {\n-        ret os.libc.fgetc(f) as u8;\n+    impure fn read_byte() -> int {\n+        ret os.libc.fgetc(f);\n+    }\n+    impure fn unread_byte(int byte) {\n+        os.libc.ungetc(byte, f);\n     }\n     impure fn read_bytes(uint len) -> vec[u8] {\n         auto buf = _vec.alloc[u8](len);\n         auto read = os.libc.fread(_vec.buf[u8](buf), 1u, len, f);\n         _vec.len_set[u8](buf, read);\n         ret buf;\n     }\n-    impure fn read_char() -> int {\n-        ret os.libc.fgetc(f);\n-    }\n-    impure fn unread_char(int ch) {\n-        os.libc.ungetc(ch, f);\n-    }\n+    impure fn read_char() -> char {\n+        auto c0 = os.libc.fgetc(f);\n+        if (c0 == -1) {ret -1 as char;} // FIXME will this stay valid?\n+        auto b0 = c0 as u8;\n+        auto w = _str.utf8_char_width(b0);\n+        check(w > 0u);\n+        if (w == 1u) {ret b0 as char;}\n+        auto val = 0u;\n+        while (w > 1u) {\n+            w -= 1u;\n+            auto next = os.libc.fgetc(f);\n+            check(next > -1);\n+            check(next & 0xc0 == 0x80);\n+            val <<= 6u;\n+            val += (next & 0x3f) as uint;\n+        }\n+        // See _str.char_at\n+        val += ((b0 << ((w + 1u) as u8)) as uint) << ((w - 1u) * 6u - w - 1u);\n+        ret val as char;\n+    }        \n     impure fn eof() -> bool {\n       auto ch = os.libc.fgetc(f);\n       if (ch == -1) {ret true;}\n       os.libc.ungetc(ch, f);\n       ret false;\n     }\n     impure fn read_line() -> str {\n-      auto buf = \"\";\n-      while (true) {\n-        auto ch = os.libc.fgetc(f);\n-        if (ch == -1) { ret buf; }\n-        if (ch == 10) { ret buf; }\n-        buf += _str.unsafe_from_bytes(vec(ch as u8));\n-      }\n-      ret buf;\n+        let vec[u8] buf = vec();\n+        // No break yet in rustc\n+        auto go_on = true;\n+        while (go_on) {\n+            auto ch = os.libc.fgetc(f);\n+            if (ch == -1 || ch == 10) {go_on = false;}\n+            else {_vec.push[u8](buf, ch as u8);}\n+        }\n+        ret _str.unsafe_from_bytes(buf);\n     }\n     impure fn read_c_str() -> str {\n-        auto buf = \"\";\n-        while (true) {\n+        let vec[u8] buf = vec();\n+        auto go_on = true;\n+        while (go_on) {\n             auto ch = os.libc.fgetc(f);\n-            if (ch < 1) { ret buf; }\n-            buf += _str.unsafe_from_bytes(vec(ch as u8));\n+            if (ch < 1) {go_on = false;}\n+            else {_vec.push[u8](buf, ch as u8);}\n         }\n-        ret buf;\n+        ret _str.unsafe_from_bytes(buf);\n     }\n-    // TODO deal with eof?\n+    // FIXME deal with eof?\n     impure fn read_le_uint(uint size) -> uint {\n         auto val = 0u;\n         auto pos = 0u;\n@@ -95,7 +114,7 @@ state obj FILE_reader(os.libc.FILE f, bool must_close) {\n             pos += 8u;\n             size -= 1u;\n         }\n-        ret val as int; // TODO does that work?\n+        ret val as int;\n     }\n     impure fn seek(int offset, seek_style whence) {\n         check(os.libc.fseek(f, offset, convert_whence(whence)) == 0);\n@@ -123,8 +142,6 @@ fn file_reader(str path) -> reader {\n \n // Writing\n \n-// TODO This is all unbuffered. We might need a buffered variant as well\n-\n tag fileflag {\n     append;\n     create;\n@@ -136,7 +153,7 @@ type buf_writer = state obj {\n   fn write(vec[u8] v);\n \n   fn seek(int offset, seek_style whence);\n-  fn tell() -> uint; // TODO: eventually u64\n+  fn tell() -> uint; // FIXME: eventually u64\n };\n \n state obj FILE_writer(os.libc.FILE f, bool must_close) {\n@@ -224,7 +241,10 @@ fn file_buf_writer(str path, vec[fileflag] flags) -> buf_writer {\n type writer =\n     state obj {\n           fn get_buf_writer() -> buf_writer;\n+          // write_str will continue to do utf-8 output only. an alternative\n+          // function will be provided for general encoded string output\n           impure fn write_str(str s);\n+          impure fn write_char(char ch);\n           impure fn write_int(int n);\n           impure fn write_uint(uint n);\n           impure fn write_bytes(vec[u8] bytes);\n@@ -249,6 +269,10 @@ state obj new_writer(buf_writer out) {\n     impure fn write_str(str s) {\n         out.write(_str.bytes(s));\n     }\n+    impure fn write_char(char ch) {\n+        // FIXME needlessly consy\n+        out.write(_str.bytes(_str.from_char(ch)));\n+    }\n     impure fn write_int(int n) {\n         out.write(_str.bytes(_int.to_str(n, 10u)));\n     }\n@@ -275,7 +299,7 @@ fn file_writer(str path, vec[fileflag] flags) -> writer {\n     ret new_writer(file_buf_writer(path, flags));\n }\n \n-// TODO: fileflags\n+// FIXME: fileflags\n fn buffered_file_buf_writer(str path) -> buf_writer {\n     auto f = os.libc.fopen(_str.buf(path), _str.buf(\"w\"));\n     if (f as uint == 0u) {\n@@ -300,7 +324,7 @@ type byte_buf = @rec(mutable vec[mutable u8] buf, mutable uint pos);\n \n state obj byte_buf_writer(byte_buf buf) {\n     fn write(vec[u8] v) {\n-        // TODO: optimize\n+        // FIXME: optimize\n         auto vlen = _vec.len[u8](v);\n         auto vpos = 0u;\n         while (vpos < vlen) {\n@@ -336,7 +360,6 @@ state obj byte_buf_writer(byte_buf buf) {\n     fn tell() -> uint { ret buf.pos; }\n }\n \n-// TODO awkward! it's not possible to implement a writer with an extra method\n fn string_writer() -> str_writer {\n     // FIXME: yikes, this is bad. Needs fixing of mutable syntax.\n     let vec[mutable u8] b = vec(mutable 0u8);"}, {"sha": "e691fb9d72c44fcc932477b8e329e53c581814f4", "filename": "src/lib/std.rc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0455144774de6c9dc0ff0e87fe4352f8a70cac3/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a0455144774de6c9dc0ff0e87fe4352f8a70cac3/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=a0455144774de6c9dc0ff0e87fe4352f8a70cac3", "patch": "@@ -41,6 +41,9 @@ auth _task = unsafe;\n auth _str.unshift_byte = impure;\n auth _str.shift_byte = impure;\n auth _str.pop_byte = impure;\n+auth _str.unshift_char = impure;\n+auth _str.shift_char = impure;\n+auth _str.pop_char = impure;\n auth _vec.shift = impure;\n auth _vec.unshift = impure;\n auth _vec.pop = impure;"}, {"sha": "e20cadeae49ac6e4eac727624076f93f9f201469", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a0455144774de6c9dc0ff0e87fe4352f8a70cac3/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a0455144774de6c9dc0ff0e87fe4352f8a70cac3/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=a0455144774de6c9dc0ff0e87fe4352f8a70cac3", "patch": "@@ -196,6 +196,27 @@ str_alloc(rust_task *task, size_t n_bytes)\n     return st;\n }\n \n+extern \"C\" CDECL rust_str*\n+str_push_byte(rust_task* task, rust_str* v, size_t byte)\n+{\n+    size_t fill = v->fill;\n+    size_t alloc = next_power_of_two(sizeof(rust_vec) + fill + 1);\n+    if (v->ref_count > 1 || v->alloc < alloc) {\n+        v = vec_alloc_with_data(task, fill + 1, fill, 1, (void*)&v->data[0]);\n+        if (!v) {\n+            task->fail(2);\n+            return NULL;\n+        }\n+    }\n+    else if (v->ref_count != CONST_REFCOUNT) {\n+        v->ref();\n+    }\n+    v->data[fill-1] = (char)byte;\n+    v->data[fill] = '\\0';\n+    v->fill++;\n+    return v;\n+}\n+\n extern \"C\" CDECL char const *\n str_buf(rust_task *task, rust_str *s)\n {"}, {"sha": "5f9300f7ca96fcb49c4f818b681a21397a9382ca", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a0455144774de6c9dc0ff0e87fe4352f8a70cac3/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/a0455144774de6c9dc0ff0e87fe4352f8a70cac3/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=a0455144774de6c9dc0ff0e87fe4352f8a70cac3", "patch": "@@ -29,6 +29,7 @@ str_byte_len\n str_from_buf\n str_from_cstr\n str_from_vec\n+str_push_byte\n task_sleep\n unsupervise\n upcall_clone_chan"}, {"sha": "04f8f574133bbd423939a37135625f326bf64bd0", "filename": "src/test/run-pass/utf8_chars.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a0455144774de6c9dc0ff0e87fe4352f8a70cac3/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0455144774de6c9dc0ff0e87fe4352f8a70cac3/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=a0455144774de6c9dc0ff0e87fe4352f8a70cac3", "patch": "@@ -0,0 +1,32 @@\n+use std;\n+import std._str;\n+import std._vec;\n+import std.io;\n+\n+fn main() {\n+  // Chars of 1, 2, 3, and 4 bytes\n+  let vec[char] chs = vec('e', '\u00e9', '\u20ac', 0x10000 as char);\n+  let str s = _str.from_chars(chs);\n+\n+  check(_str.byte_len(s) == 10u);\n+  check(_str.char_len(s) == 4u);\n+  check(_vec.len[char](_str.to_chars(s)) == 4u);\n+  check(_str.eq(_str.from_chars(_str.to_chars(s)), s));\n+  check(_str.char_at(s, 0u) == 'e');\n+  check(_str.char_at(s, 1u) == '\u00e9');\n+\n+  check(_str.is_utf8(_str.bytes(s)));\n+  check(!_str.is_utf8(vec(0x80_u8)));\n+  check(!_str.is_utf8(vec(0xc0_u8)));\n+  check(!_str.is_utf8(vec(0xc0_u8, 0x10_u8)));\n+\n+  auto stack = \"a\u00d7c\u20ac\";\n+  check(_str.pop_char(stack) == '\u20ac');\n+  check(_str.pop_char(stack) == 'c');\n+  _str.push_char(stack, 'u');\n+  check(_str.eq(stack, \"a\u00d7u\"));\n+  check(_str.shift_char(stack) == 'a');\n+  check(_str.shift_char(stack) == '\u00d7');\n+  _str.unshift_char(stack, '\u00df');\n+  check(_str.eq(stack, \"\u00dfu\"));\n+}"}]}