{"sha": "fab7020bd95c695be4f3c06dce236fada0dabb8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhYjcwMjBiZDk1YzY5NWJlNGYzYzA2ZGNlMjM2ZmFkYTBkYWJiOGU=", "commit": {"author": {"name": "Yukio Siraichi", "email": "yukio.siraichi@gmail.com", "date": "2018-02-09T18:04:12Z"}, "committer": {"name": "Yukio Siraichi", "email": "yukio.siraichi@gmail.com", "date": "2018-03-17T18:53:33Z"}, "message": "Add span_suggestion while removing TyRefs based on the snippet String.", "tree": {"sha": "50718df5dcf4503c34452be9a1d4d1f1999f2830", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50718df5dcf4503c34452be9a1d4d1f1999f2830"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fab7020bd95c695be4f3c06dce236fada0dabb8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fab7020bd95c695be4f3c06dce236fada0dabb8e", "html_url": "https://github.com/rust-lang/rust/commit/fab7020bd95c695be4f3c06dce236fada0dabb8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fab7020bd95c695be4f3c06dce236fada0dabb8e/comments", "author": {"login": "ysiraichi", "id": 3337141, "node_id": "MDQ6VXNlcjMzMzcxNDE=", "avatar_url": "https://avatars.githubusercontent.com/u/3337141?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ysiraichi", "html_url": "https://github.com/ysiraichi", "followers_url": "https://api.github.com/users/ysiraichi/followers", "following_url": "https://api.github.com/users/ysiraichi/following{/other_user}", "gists_url": "https://api.github.com/users/ysiraichi/gists{/gist_id}", "starred_url": "https://api.github.com/users/ysiraichi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ysiraichi/subscriptions", "organizations_url": "https://api.github.com/users/ysiraichi/orgs", "repos_url": "https://api.github.com/users/ysiraichi/repos", "events_url": "https://api.github.com/users/ysiraichi/events{/privacy}", "received_events_url": "https://api.github.com/users/ysiraichi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ysiraichi", "id": 3337141, "node_id": "MDQ6VXNlcjMzMzcxNDE=", "avatar_url": "https://avatars.githubusercontent.com/u/3337141?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ysiraichi", "html_url": "https://github.com/ysiraichi", "followers_url": "https://api.github.com/users/ysiraichi/followers", "following_url": "https://api.github.com/users/ysiraichi/following{/other_user}", "gists_url": "https://api.github.com/users/ysiraichi/gists{/gist_id}", "starred_url": "https://api.github.com/users/ysiraichi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ysiraichi/subscriptions", "organizations_url": "https://api.github.com/users/ysiraichi/orgs", "repos_url": "https://api.github.com/users/ysiraichi/repos", "events_url": "https://api.github.com/users/ysiraichi/events{/privacy}", "received_events_url": "https://api.github.com/users/ysiraichi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61b6bf54fdf56195baf9a8ee7383551b0d468c81", "url": "https://api.github.com/repos/rust-lang/rust/commits/61b6bf54fdf56195baf9a8ee7383551b0d468c81", "html_url": "https://github.com/rust-lang/rust/commit/61b6bf54fdf56195baf9a8ee7383551b0d468c81"}], "stats": {"total": 87, "additions": 87, "deletions": 0}, "files": [{"sha": "c90a6d0709db65dd4f56fcadecc1760e8fdb4362", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/fab7020bd95c695be4f3c06dce236fada0dabb8e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab7020bd95c695be4f3c06dce236fada0dabb8e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=fab7020bd95c695be4f3c06dce236fada0dabb8e", "patch": "@@ -575,6 +575,44 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             = self.on_unimplemented_note(trait_ref, obligation);\n                         let have_alt_message = message.is_some() || label.is_some();\n \n+                        // {\n+                        //     let ty::Binder(trait_ref) = trait_ref;\n+                        //     println!(\"TraitRef: {:?}\", trait_ref);\n+                        //     println!(\"TraitRef: id:{:?}; subst:{:?}\", trait_ref.def_id, trait_ref.substs);\n+\n+                        //     if let ty::Predicate::Trait(trait_predicate_binder) =\n+                        //         trait_ref.to_predicate() {\n+                        //             let trait_predicate = trait_predicate_binder.skip_binder();\n+                        //             println!(\"TraitPredicateBinder: {:?}\", trait_predicate_binder);\n+                        //             println!(\"TraitPredicate: {:?}\", trait_predicate);\n+\n+                        //             let trait_ty = trait_ref.self_ty();\n+                        //             println!(\"TraitPredicateTy: {:?}\", trait_ty);\n+                        //             println!(\"TraitPredicateTy: sty:{:?}; flags{:?}\", trait_ty.sty, trait_ty.flags);\n+                        //         }\n+\n+                        //     for in_ty in trait_ref.input_types() {\n+                        //         println!(\"\\t- {:?}\", in_ty);\n+                        //         println!(\"\\t\\t- sty:{:?}; flags:{:?}\", in_ty.sty, in_ty.flags);\n+                        //     }\n+\n+                        //     println!(\"Message: {:?}\", message);\n+                        //     println!(\"Label: {:?}\", label);\n+                        //     println!(\"Obligation: {:?}\", obligation);\n+                        //     println!(\"Span: {:?}\", self.tcx.sess.codemap().span_to_string(span));\n+\n+                        //     let body_id = obligation.cause.body_id;\n+                        //     println!(\"BodyId: {:?}\", body_id);\n+                        //     println!(\"BodyIdSpan: {:?}\", self.tcx.hir.span(body_id));\n+\n+                        //     match self.tcx.hir.find(body_id) {\n+                        //         Some(node) => println!(\"Node: {:?}\", node),\n+                        //         None => println!(\"Node not found.\"),\n+                        //     }\n+\n+                        //     println!(\"=------------------------------=\");\n+                        // }\n+\n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n                             span,\n@@ -606,6 +644,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         }\n \n                         self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n+                        self.suggest_remove_reference(&obligation, &mut err, &trait_ref);\n \n                         // Try to report a help message\n                         if !trait_ref.has_infer_types() &&\n@@ -844,6 +883,54 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn suggest_remove_reference(&self,\n+                                obligation: &PredicateObligation<'tcx>,\n+                                err: &mut DiagnosticBuilder<'tcx>,\n+                                trait_ref: &ty::Binder<ty::TraitRef<'tcx>>) {\n+        let ty::Binder(trait_ref) = trait_ref;\n+\n+        let span = obligation.cause.span;\n+        let mut snippet = match self.tcx.sess.codemap().span_to_snippet(span) {\n+            Ok(s) => s,\n+            Err(_) => String::from(\"\"),\n+        };\n+\n+        let mut refs_number = 0;\n+\n+        for c in snippet.chars() {\n+            if c == '&' {\n+                refs_number += 1;\n+            }\n+        }\n+\n+        let mut refs_remaining = refs_number;\n+        let mut trait_type = trait_ref.self_ty();\n+        let mut selcx = SelectionContext::new(self);\n+\n+        while refs_remaining > 0 {\n+            if let ty::TypeVariants::TyRef(_, ty::TypeAndMut{ ty: t_type, mutbl: _ }) =\n+                trait_type.sty {\n+                    trait_type = t_type;\n+                    refs_remaining -= 1;\n+\n+                    let substs = self.tcx.mk_substs_trait(trait_type, &[]);\n+                    let new_trait_ref = ty::TraitRef::new(trait_ref.def_id, substs);\n+                    let new_obligation = Obligation::new(ObligationCause::dummy(),\n+                                                         obligation.param_env,\n+                                                         new_trait_ref.to_predicate());\n+\n+                    if selcx.evaluate_obligation(&new_obligation) {\n+                        for i in 0..refs_number {\n+                            snippet.remove(i);\n+                        }\n+                        err.span_suggestion(span, \"consider removing `&`s like\", format!(\"{}\", snippet));\n+                    }\n+                } else {\n+                    break;\n+                }\n+        }\n+    }\n+\n     /// Given some node representing a fn-like thing in the HIR map,\n     /// returns a span and `ArgKind` information that describes the\n     /// arguments it expects. This can be supplied to"}]}