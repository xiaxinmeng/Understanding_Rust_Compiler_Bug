{"sha": "79e78c4b0c49003c8191f7094651753ecfabfd24", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZTc4YzRiMGM0OTAwM2M4MTkxZjcwOTQ2NTE3NTNlY2ZhYmZkMjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-07T18:31:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-07T18:31:06Z"}, "message": "auto merge of #8906 : novalis/rust/master, r=alexcrichton\n\nThis is a patch to fix #6031.  I didn't see any tests for the C++ library code, so I didn't write a test for my changes.  Did I miss something, or are there really no tests?", "tree": {"sha": "1b1f5cec449a345f1eb6cb23b3f5f23e070bcaec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b1f5cec449a345f1eb6cb23b3f5f23e070bcaec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79e78c4b0c49003c8191f7094651753ecfabfd24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79e78c4b0c49003c8191f7094651753ecfabfd24", "html_url": "https://github.com/rust-lang/rust/commit/79e78c4b0c49003c8191f7094651753ecfabfd24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79e78c4b0c49003c8191f7094651753ecfabfd24/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa1d4ef55a1f544c245f0ef163a3292dbbb9393a", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa1d4ef55a1f544c245f0ef163a3292dbbb9393a", "html_url": "https://github.com/rust-lang/rust/commit/aa1d4ef55a1f544c245f0ef163a3292dbbb9393a"}, {"sha": "c684df103e05a15d4e0403b5fca1197f16d15703", "url": "https://api.github.com/repos/rust-lang/rust/commits/c684df103e05a15d4e0403b5fca1197f16d15703", "html_url": "https://github.com/rust-lang/rust/commit/c684df103e05a15d4e0403b5fca1197f16d15703"}], "stats": {"total": 199, "additions": 150, "deletions": 49}, "files": [{"sha": "3c6157e44ba6f111b2b56978c0b05deddbd4d7d3", "filename": "doc/rust.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/79e78c4b0c49003c8191f7094651753ecfabfd24/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/79e78c4b0c49003c8191f7094651753ecfabfd24/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=79e78c4b0c49003c8191f7094651753ecfabfd24", "patch": "@@ -3385,9 +3385,11 @@ The path to a module consists of the crate name, any parent modules,\n then the module itself, all separated by double colons (`::`).  The\n optional log level can be appended to the module path with an equals\n sign (`=`) followed by the log level, from 1 to 4, inclusive. Level 1\n-is the error level, 2 is warning, 3 info, and 4 debug. Any logs\n-less than or equal to the specified level will be output. If not\n-specified then log level 4 is assumed.\n+is the error level, 2 is warning, 3 info, and 4 debug. You can also\n+use the symbolic constants `error`, `warn`, `info`, and `debug`.  Any\n+logs less than or equal to the specified level will be output. If not\n+specified then log level 4 is assumed.  However, debug messages are\n+only available if `--cfg=debug` is passed to `rustc`.\n \n As an example, to see all the logs generated by the compiler, you would set\n `RUST_LOG` to `rustc`, which is the crate name (as specified in its `link`"}, {"sha": "8a4aba3eb8792d0713df1ae62b02146e4325abed", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 145, "deletions": 46, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/79e78c4b0c49003c8191f7094651753ecfabfd24/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79e78c4b0c49003c8191f7094651753ecfabfd24/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=79e78c4b0c49003c8191f7094651753ecfabfd24", "patch": "@@ -10,7 +10,7 @@\n use cast::transmute;\n use either::*;\n use libc::{c_void, uintptr_t, c_char, exit, STDERR_FILENO};\n-use option::{Some, None};\n+use option::{Some, None, Option};\n use rt::util::dumb_println;\n use str::StrSlice;\n use str::raw::from_c_str;\n@@ -20,7 +20,7 @@ use vec::ImmutableVector;\n \n \n struct LogDirective {\n-    name: ~str,\n+    name: Option<~str>,\n     level: u32\n }\n \n@@ -30,7 +30,6 @@ struct ModEntry{\n     log_level: *mut u32\n }\n \n-static MAX_LOG_DIRECTIVES: u32 = 255;\n static MAX_LOG_LEVEL: u32 = 255;\n static DEFAULT_LOG_LEVEL: u32 = 1;\n \n@@ -68,42 +67,82 @@ fn iter_crate_map(map: *u8, f: &fn(*mut ModEntry)) {\n                     data: *c_void);\n     }\n }\n+static log_level_names : &'static[&'static str] = &'static[\"error\", \"warn\", \"info\", \"debug\"];\n+\n+/// Parse an individual log level that is either a number or a symbolic log level\n+fn parse_log_level(level: &str) -> Option<u32> {\n+    let num = u32::from_str(level);\n+    let mut log_level;\n+    match num {\n+        Some(num) => {\n+            if num < MAX_LOG_LEVEL {\n+                log_level = Some(num);\n+            } else {\n+                log_level = Some(MAX_LOG_LEVEL);\n+            }\n+        }\n+        _ => {\n+            let position = log_level_names.iter().position(|&name| name == level);\n+            match position {\n+                Some(position) => {\n+                    log_level = Some(u32::min(MAX_LOG_LEVEL, (position + 1) as u32))\n+                },\n+                _ => {\n+                    log_level = None;\n+                }\n+            }\n+        }\n+    }\n+    log_level\n+}\n+\n \n /// Parse a logging specification string (e.g: \"crate1,crate2::mod3,crate3::x=1\")\n /// and return a vector with log directives.\n-/// Valid log levels are 0-255, with the most likely ones being 0-3 (defined in std::).\n+/// Valid log levels are 0-255, with the most likely ones being 1-4 (defined in std::).\n+/// Also supports string log levels of error, warn, info, and debug\n+\n fn parse_logging_spec(spec: ~str) -> ~[LogDirective]{\n     let mut dirs = ~[];\n     for s in spec.split_iter(',') {\n         let parts: ~[&str] = s.split_iter('=').collect();\n-        let mut loglevel;\n+        let mut log_level;\n+        let mut name = Some(parts[0].to_owned());\n         match parts.len() {\n-            1 => loglevel = MAX_LOG_LEVEL,\n-            2 => {\n-                let num = u32::from_str(parts[1]);\n-                match (num) {\n+            1 => {\n+                //if the single argument is a log-level string or number,\n+                //treat that as a global fallback\n+                let possible_log_level = parse_log_level(parts[0]);\n+                match possible_log_level {\n                     Some(num) => {\n-                        if num < MAX_LOG_LEVEL {\n-                            loglevel = num;\n-                        } else {\n-                            loglevel = MAX_LOG_LEVEL;\n-                        }\n+                        name = None;\n+                        log_level = num;\n+                    },\n+                    _ => {\n+                        log_level = MAX_LOG_LEVEL\n                     }\n+                }\n+            }\n+            2 => {\n+                let possible_log_level = parse_log_level(parts[1]);\n+                match possible_log_level {\n+                    Some(num) => {\n+                        log_level = num;\n+                    },\n                     _ => {\n-                         dumb_println(fmt!(\"warning: invalid logging spec \\\n-                                           '%s', ignoring it\", s));\n-                         loop;\n+                        dumb_println(fmt!(\"warning: invalid logging spec \\\n+                                           '%s', ignoring it\", parts[1]));\n+                        loop;\n                     }\n                 }\n-                if loglevel > MAX_LOG_LEVEL { loglevel = MAX_LOG_LEVEL}\n             },\n             _ => {\n                 dumb_println(fmt!(\"warning: invalid logging spec '%s',\\\n                                   ignoring it\", s));\n                 loop;\n             }\n         }\n-        let dir = LogDirective {name: parts[0].to_owned(), level: loglevel};\n+        let dir = LogDirective {name: name, level: log_level};\n         dirs.push(dir);\n     }\n     return dirs;\n@@ -113,18 +152,30 @@ fn parse_logging_spec(spec: ~str) -> ~[LogDirective]{\n /// of log directives\n fn update_entry(dirs: &[LogDirective], entry: *mut ModEntry) -> u32 {\n     let mut new_lvl: u32 = DEFAULT_LOG_LEVEL;\n-    let mut longest_match = 0;\n+    let mut longest_match = -1i;\n     unsafe {\n         for dir in dirs.iter() {\n-            let name = from_c_str((*entry).name);\n-            if name.starts_with(dir.name) && dir.name.len() > longest_match {\n-                longest_match = dir.name.len();\n-                new_lvl = dir.level;\n-            }\n+            match dir.name {\n+                None => {\n+                    if longest_match == -1 {\n+                        longest_match = 0;\n+                        new_lvl = dir.level;\n+                    }\n+                }\n+                Some(ref dir_name) => {\n+                    let name = from_c_str((*entry).name);\n+                    let len = dir_name.len() as int;\n+                    if name.starts_with(*dir_name) &&\n+                        len >= longest_match {\n+                        longest_match = len;\n+                        new_lvl = dir.level;\n+                    }\n+                }\n+            };\n         }\n         *(*entry).log_level = new_lvl;\n     }\n-    if longest_match > 0 { return 1; } else { return 0; }\n+    if longest_match >= 0 { return 1; } else { return 0; }\n }\n \n #[fixed_stack_segment] #[inline(never)]\n@@ -238,45 +289,66 @@ extern {\n // Tests for parse_logging_spec()\n #[test]\n fn parse_logging_spec_valid() {\n-    let dirs: ~[LogDirective] = parse_logging_spec(~\"crate1::mod1=1,crate1::mod2,crate2=4\");\n+    let dirs = parse_logging_spec(~\"crate1::mod1=1,crate1::mod2,crate2=4\");\n     assert_eq!(dirs.len(), 3);\n-    assert!(dirs[0].name == ~\"crate1::mod1\");\n+    assert!(dirs[0].name == Some(~\"crate1::mod1\"));\n     assert_eq!(dirs[0].level, 1);\n \n-    assert!(dirs[1].name == ~\"crate1::mod2\");\n+    assert!(dirs[1].name == Some(~\"crate1::mod2\"));\n     assert_eq!(dirs[1].level, MAX_LOG_LEVEL);\n \n-    assert!(dirs[2].name == ~\"crate2\");\n+    assert!(dirs[2].name == Some(~\"crate2\"));\n     assert_eq!(dirs[2].level, 4);\n }\n \n #[test]\n fn parse_logging_spec_invalid_crate() {\n     // test parse_logging_spec with multiple = in specification\n-    let dirs: ~[LogDirective] = parse_logging_spec(~\"crate1::mod1=1=2,crate2=4\");\n+    let dirs = parse_logging_spec(~\"crate1::mod1=1=2,crate2=4\");\n     assert_eq!(dirs.len(), 1);\n-    assert!(dirs[0].name == ~\"crate2\");\n+    assert!(dirs[0].name == Some(~\"crate2\"));\n     assert_eq!(dirs[0].level, 4);\n }\n \n #[test]\n fn parse_logging_spec_invalid_log_level() {\n     // test parse_logging_spec with 'noNumber' as log level\n-    let dirs: ~[LogDirective] = parse_logging_spec(~\"crate1::mod1=noNumber,crate2=4\");\n+    let dirs = parse_logging_spec(~\"crate1::mod1=noNumber,crate2=4\");\n     assert_eq!(dirs.len(), 1);\n-    assert!(dirs[0].name == ~\"crate2\");\n+    assert!(dirs[0].name == Some(~\"crate2\"));\n     assert_eq!(dirs[0].level, 4);\n }\n \n+#[test]\n+fn parse_logging_spec_string_log_level() {\n+    // test parse_logging_spec with 'warn' as log level\n+    let dirs = parse_logging_spec(~\"crate1::mod1=wrong,crate2=warn\");\n+    assert_eq!(dirs.len(), 1);\n+    assert!(dirs[0].name == Some(~\"crate2\"));\n+    assert_eq!(dirs[0].level, 2);\n+}\n+\n+#[test]\n+fn parse_logging_spec_global() {\n+    // test parse_logging_spec with no crate\n+    let dirs = parse_logging_spec(~\"warn,crate2=4\");\n+    assert_eq!(dirs.len(), 2);\n+    assert!(dirs[0].name == None);\n+    assert_eq!(dirs[0].level, 2);\n+    assert!(dirs[1].name == Some(~\"crate2\"));\n+    assert_eq!(dirs[1].level, 4);\n+}\n+\n // Tests for update_entry\n #[test]\n fn update_entry_match_full_path() {\n     use c_str::ToCStr;\n-    let dirs = ~[LogDirective {name: ~\"crate1::mod1\", level: 2 },\n-    LogDirective {name: ~\"crate2\", level: 3}];\n+    let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n+                 LogDirective {name: Some(~\"crate2\"), level: 3}];\n+    let level = &mut 0;\n     unsafe {\n         do \"crate1::mod1\".to_c_str().with_ref |ptr| {\n-            let entry= &ModEntry {name: ptr, log_level: &mut 0};\n+            let entry= &ModEntry {name: ptr, log_level: level};\n             let m = update_entry(dirs, transmute(entry));\n             assert!(*entry.log_level == 2);\n             assert!(m == 1);\n@@ -287,11 +359,12 @@ fn update_entry_match_full_path() {\n #[test]\n fn update_entry_no_match() {\n     use c_str::ToCStr;\n-    let dirs = ~[LogDirective {name: ~\"crate1::mod1\", level: 2 },\n-        LogDirective {name: ~\"crate2\", level: 3}];\n+    let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n+                 LogDirective {name: Some(~\"crate2\"), level: 3}];\n+    let level = &mut 0;\n     unsafe {\n         do \"crate3::mod1\".to_c_str().with_ref |ptr| {\n-            let entry= &ModEntry {name: ptr, log_level: &mut 0};\n+            let entry= &ModEntry {name: ptr, log_level: level};\n             let m = update_entry(dirs, transmute(entry));\n             assert!(*entry.log_level == DEFAULT_LOG_LEVEL);\n             assert!(m == 0);\n@@ -302,11 +375,12 @@ fn update_entry_no_match() {\n #[test]\n fn update_entry_match_beginning() {\n     use c_str::ToCStr;\n-    let dirs = ~[LogDirective {name: ~\"crate1::mod1\", level: 2 },\n-        LogDirective {name: ~\"crate2\", level: 3}];\n+    let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n+                 LogDirective {name: Some(~\"crate2\"), level: 3}];\n+    let level = &mut 0;\n     unsafe {\n         do \"crate2::mod1\".to_c_str().with_ref |ptr| {\n-            let entry= &ModEntry {name: ptr, log_level: &mut 0};\n+            let entry= &ModEntry {name: ptr, log_level: level};\n             let m = update_entry(dirs, transmute(entry));\n             assert!(*entry.log_level == 3);\n             assert!(m == 1);\n@@ -317,14 +391,39 @@ fn update_entry_match_beginning() {\n #[test]\n fn update_entry_match_beginning_longest_match() {\n     use c_str::ToCStr;\n-    let dirs = ~[LogDirective {name: ~\"crate1::mod1\", level: 2 },\n-        LogDirective {name: ~\"crate2\", level: 3}, LogDirective {name: ~\"crate2::mod\", level: 4}];\n+    let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n+                 LogDirective {name: Some(~\"crate2\"), level: 3},\n+                 LogDirective {name: Some(~\"crate2::mod\"), level: 4}];\n+    let level = &mut 0;\n     unsafe {\n         do \"crate2::mod1\".to_c_str().with_ref |ptr| {\n-            let entry = &ModEntry {name: ptr, log_level: &mut 0};\n+            let entry = &ModEntry {name: ptr, log_level: level};\n             let m = update_entry(dirs, transmute(entry));\n             assert!(*entry.log_level == 4);\n             assert!(m == 1);\n         }\n     }\n }\n+\n+#[test]\n+fn update_entry_match_default() {\n+    use c_str::ToCStr;\n+    let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n+                 LogDirective {name: None, level: 3}\n+                ];\n+    let level = &mut 0;\n+    unsafe {\n+        do \"crate1::mod1\".to_c_str().with_ref |ptr| {\n+            let entry= &ModEntry {name: ptr, log_level: level};\n+            let m = update_entry(dirs, transmute(entry));\n+            assert!(*entry.log_level == 2);\n+            assert!(m == 1);\n+        }\n+        do \"crate2::mod2\".to_c_str().with_ref |ptr| {\n+            let entry= &ModEntry {name: ptr, log_level: level};\n+            let m = update_entry(dirs, transmute(entry));\n+            assert!(*entry.log_level == 3);\n+            assert!(m == 1);\n+        }\n+    }\n+}"}]}