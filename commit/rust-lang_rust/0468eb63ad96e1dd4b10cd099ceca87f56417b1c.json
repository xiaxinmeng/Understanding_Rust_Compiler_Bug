{"sha": "0468eb63ad96e1dd4b10cd099ceca87f56417b1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0NjhlYjYzYWQ5NmUxZGQ0YjEwY2QwOTljZWNhODdmNTY0MTdiMWM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-06T22:59:27Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-10T18:33:33Z"}, "message": "syntax: Improve documentation of `SyntaxExtension`", "tree": {"sha": "4dcb2f497c5794b4947f39117d03b6ed1931815a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4dcb2f497c5794b4947f39117d03b6ed1931815a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0468eb63ad96e1dd4b10cd099ceca87f56417b1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0468eb63ad96e1dd4b10cd099ceca87f56417b1c", "html_url": "https://github.com/rust-lang/rust/commit/0468eb63ad96e1dd4b10cd099ceca87f56417b1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0468eb63ad96e1dd4b10cd099ceca87f56417b1c/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8edbbacbcac3fe88995f02e08789ca458667b6b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8edbbacbcac3fe88995f02e08789ca458667b6b4", "html_url": "https://github.com/rust-lang/rust/commit/8edbbacbcac3fe88995f02e08789ca458667b6b4"}], "stats": {"total": 90, "additions": 54, "deletions": 36}, "files": [{"sha": "e4f4b40fc7cc618b782d25a95249e47814ae6cac", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 54, "deletions": 36, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/0468eb63ad96e1dd4b10cd099ceca87f56417b1c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0468eb63ad96e1dd4b10cd099ceca87f56417b1c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=0468eb63ad96e1dd4b10cd099ceca87f56417b1c", "patch": "@@ -552,60 +552,78 @@ impl MacroKind {\n \n /// An enum representing the different kinds of syntax extensions.\n pub enum SyntaxExtension {\n-    /// A trivial \"extension\" that does nothing, only keeps the attribute and marks it as known.\n-    NonMacroAttr { mark_used: bool },\n-\n-    /// A syntax extension that is attached to an item and modifies it\n-    /// in-place. Also allows decoration, i.e., creating new items.\n-    MultiModifier(Box<dyn MultiItemModifier + sync::Sync + sync::Send>),\n-\n-    /// A function-like procedural macro. TokenStream -> TokenStream.\n+    /// A token-based function-like macro.\n     ProcMacro {\n+        /// An expander with signature TokenStream -> TokenStream.\n         expander: Box<dyn ProcMacro + sync::Sync + sync::Send>,\n-        /// Whitelist of unstable features that are treated as stable inside this macro\n+        /// Whitelist of unstable features that are treated as stable inside this macro.\n         allow_internal_unstable: Option<Lrc<[Symbol]>>,\n+        /// Edition of the crate in which this macro is defined.\n         edition: Edition,\n     },\n \n-    /// An attribute-like procedural macro. TokenStream, TokenStream -> TokenStream.\n-    /// The first TokenSteam is the attribute, the second is the annotated item.\n-    /// Allows modification of the input items and adding new items, similar to\n-    /// MultiModifier, but uses TokenStreams, rather than AST nodes.\n-    AttrProcMacro(Box<dyn AttrProcMacro + sync::Sync + sync::Send>, Edition),\n-\n-    /// A normal, function-like syntax extension.\n-    ///\n-    /// `bytes!` is a `NormalTT`.\n+    /// An AST-based function-like macro.\n     NormalTT {\n+        /// An expander with signature TokenStream -> AST.\n         expander: Box<dyn TTMacroExpander + sync::Sync + sync::Send>,\n+        /// Some info about the macro's definition point.\n         def_info: Option<(ast::NodeId, Span)>,\n+        /// Hygienic properties of identifiers produced by this macro.\n         transparency: Transparency,\n-        /// Whether the contents of the macro can\n-        /// directly use `#[unstable]` things.\n-        ///\n-        /// Only allows things that require a feature gate in the given whitelist\n+        /// Whitelist of unstable features that are treated as stable inside this macro.\n         allow_internal_unstable: Option<Lrc<[Symbol]>>,\n-        /// Whether the contents of the macro can use `unsafe`\n-        /// without triggering the `unsafe_code` lint.\n+        /// Suppresses the `unsafe_code` lint for code produced by this macro.\n         allow_internal_unsafe: bool,\n-        /// Enables the macro helper hack (`ident!(...)` -> `$crate::ident!(...)`)\n-        /// for a given macro.\n+        /// Enables the macro helper hack (`ident!(...)` -> `$crate::ident!(...)`) for this macro.\n         local_inner_macros: bool,\n-        /// The macro's feature name if it is unstable, and the stability feature\n+        /// The macro's feature name and tracking issue number if it is unstable.\n         unstable_feature: Option<(Symbol, u32)>,\n-        /// Edition of the crate in which the macro is defined\n+        /// Edition of the crate in which this macro is defined.\n         edition: Edition,\n     },\n \n-    /// An attribute-like procedural macro. TokenStream -> TokenStream.\n-    /// The input is the annotated item.\n-    /// Allows generating code to implement a Trait for a given struct\n-    /// or enum item.\n-    ProcMacroDerive(Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n-                    Vec<Symbol> /* inert attribute names */, Edition),\n+    /// A token-based attribute macro.\n+    AttrProcMacro(\n+        /// An expander with signature (TokenStream, TokenStream) -> TokenStream.\n+        /// The first TokenSteam is the attribute itself, the second is the annotated item.\n+        /// The produced TokenSteam replaces the input TokenSteam.\n+        Box<dyn AttrProcMacro + sync::Sync + sync::Send>,\n+        /// Edition of the crate in which this macro is defined.\n+        Edition,\n+    ),\n+\n+    /// An AST-based attribute macro.\n+    MultiModifier(\n+        /// An expander with signature (AST, AST) -> AST.\n+        /// The first AST fragment is the attribute itself, the second is the annotated item.\n+        /// The produced AST fragment replaces the input AST fragment.\n+        Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n+    ),\n+\n+    /// A trivial attribute \"macro\" that does nothing,\n+    /// only keeps the attribute and marks it as known.\n+    NonMacroAttr {\n+        /// Suppresses the `unused_attributes` lint for this attribute.\n+        mark_used: bool,\n+    },\n \n-    /// An attribute-like procedural macro that derives a builtin trait.\n-    BuiltinDerive(Box<dyn MultiItemModifier + sync::Sync + sync::Send>),\n+    /// A token-based derive macro.\n+    ProcMacroDerive(\n+        /// An expander with signature TokenStream -> TokenStream (not yet).\n+        /// The produced TokenSteam is appended to the input TokenSteam.\n+        Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n+        /// Names of helper attributes registered by this macro.\n+        Vec<Symbol>,\n+        /// Edition of the crate in which this macro is defined.\n+        Edition,\n+    ),\n+\n+    /// An AST-based derive macro.\n+    BuiltinDerive(\n+        /// An expander with signature AST -> AST.\n+        /// The produced AST fragment is appended to the input AST fragment.\n+        Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n+    ),\n }\n \n impl SyntaxExtension {"}]}