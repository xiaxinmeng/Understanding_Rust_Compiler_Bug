{"sha": "ff9eb56c6e4bff6c1c74bd628a7e0dd79321829b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmOWViNTZjNmU0YmZmNmMxYzc0YmQ2MjhhN2UwZGQ3OTMyMTgyOWI=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2018-02-15T18:47:40Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2018-02-23T00:27:26Z"}, "message": "Use Sparse bitsets instead of dense ones for NLL results\n\nFixes #48170", "tree": {"sha": "9500d893f5259db71996cf56a125b02cae5bd5f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9500d893f5259db71996cf56a125b02cae5bd5f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff9eb56c6e4bff6c1c74bd628a7e0dd79321829b", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEmNHc6jmXzkUyxd4xiMlBzaHUZDIFAlqPX/EACgkQiMlBzaHU\nZDIiDhAAqHJ977YkOQSBmFrKjjUen7KchCFZMJm3loBnIj+e8FPqHwBIv4IQjfud\nuYvVKSaV+EiHyU2bwnvzQR/AZRi/CbT3cHjB3AiSAYJwkdn3H0QA3aF8BnS9XwIy\nPxDXIF4YWHKhmYAC5p2spljN4OyrJuEeytbVCAqD+nDP/6oos4Iq423O11To8QPs\nhsAEwQq2WFXfdkX+3Wi1IOx7ptsLzjf/qbCY+nltIvLyxKNPakI4E1EoyBo0oR0C\nUwnty7m819gy2qzmBcSoDQ4EhKxp6Ugm4uGqMx5/hIT4mEpVfky09EmPKPAOCAEc\nqfpczrQpS8oOUTLBaDYv1WfodkOgT79hBf/RHVLo6QbJohpYKGOqnbgaJdSi0dny\nnCosCHcdesR41lD/s0YFAFzkcDOSMoFYnhQ5Q+MkgZa8JfuoUhB48c1BfTxHo3zp\nLx0RCSZZneUFAz91cF9jrQlhGMCR5M8TEZp+jEhS5R9ns1XnYUR8i3dbwprXbe6M\njm46gmw7cIq/HUEpu8cLHA1Q4U6P+IHSF7xcye9pVOvHWNKVxO8ZLhYkrscVU/Xv\nIFiYI3lp3oQ1yoDsm1H1NhGy2MqzSaLzCxaPJPyzREfM1wAK5xnbed0LrLFSo/80\nKo3L3qcn6uTtg5xSELtW5SkC5NPMOY6tmpS3HTX25A0XGSbfEwg=\n=i7jq\n-----END PGP SIGNATURE-----", "payload": "tree 9500d893f5259db71996cf56a125b02cae5bd5f5\nparent e5d79c4bc7c46d8d85a18e71caa02bfb6a3c6df3\nauthor Santiago Pastorino <spastorino@gmail.com> 1518720460 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1519345646 -0300\n\nUse Sparse bitsets instead of dense ones for NLL results\n\nFixes #48170\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff9eb56c6e4bff6c1c74bd628a7e0dd79321829b", "html_url": "https://github.com/rust-lang/rust/commit/ff9eb56c6e4bff6c1c74bd628a7e0dd79321829b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff9eb56c6e4bff6c1c74bd628a7e0dd79321829b/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5d79c4bc7c46d8d85a18e71caa02bfb6a3c6df3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5d79c4bc7c46d8d85a18e71caa02bfb6a3c6df3", "html_url": "https://github.com/rust-lang/rust/commit/e5d79c4bc7c46d8d85a18e71caa02bfb6a3c6df3"}], "stats": {"total": 235, "additions": 224, "deletions": 11}, "files": [{"sha": "688e9ca9e034655ce71a1a470a9e27c809b326ec", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/ff9eb56c6e4bff6c1c74bd628a7e0dd79321829b/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9eb56c6e4bff6c1c74bd628a7e0dd79321829b/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=ff9eb56c6e4bff6c1c74bd628a7e0dd79321829b", "patch": "@@ -8,7 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::collections::BTreeMap;\n+use std::collections::btree_map::Entry;\n+use std::marker::PhantomData;\n use std::iter::FromIterator;\n+use indexed_vec::{Idx, IndexVec};\n \n type Word = u128;\n const WORD_BITS: usize = 128;\n@@ -257,6 +261,199 @@ impl BitMatrix {\n     }\n }\n \n+#[derive(Clone, Debug)]\n+pub struct SparseBitMatrix<R, C> where R: Idx, C: Idx {\n+    vector: IndexVec<R, SparseBitSet<C>>,\n+}\n+\n+impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n+    /// Create a new `rows x columns` matrix, initially empty.\n+    pub fn new(rows: R, _columns: C) -> SparseBitMatrix<R, C> {\n+        SparseBitMatrix {\n+            vector: IndexVec::from_elem_n(SparseBitSet::new(), rows.index()),\n+        }\n+    }\n+\n+    /// Sets the cell at `(row, column)` to true. Put another way, insert\n+    /// `column` to the bitset for `row`.\n+    ///\n+    /// Returns true if this changed the matrix, and false otherwise.\n+    pub fn add(&mut self, row: R, column: C) -> bool {\n+        self.vector[row].insert(column)\n+    }\n+\n+    /// Do the bits from `row` contain `column`? Put another way, is\n+    /// the matrix cell at `(row, column)` true?  Put yet another way,\n+    /// if the matrix represents (transitive) reachability, can\n+    /// `row` reach `column`?\n+    pub fn contains(&self, row: R, column: C) -> bool {\n+        self.vector[row].contains(column)\n+    }\n+\n+    /// Add the bits from row `read` to the bits from row `write`,\n+    /// return true if anything changed.\n+    ///\n+    /// This is used when computing transitive reachability because if\n+    /// you have an edge `write -> read`, because in that case\n+    /// `write` can reach everything that `read` can (and\n+    /// potentially more).\n+    pub fn merge(&mut self, read: R, write: R) -> bool {\n+        let mut changed = false;\n+\n+        if read != write {\n+            let (bit_set_read, bit_set_write) = self.vector.pick2_mut(read, write);\n+\n+            for read_val in bit_set_read.iter() {\n+                changed = changed | bit_set_write.insert(read_val);\n+            }\n+        }\n+\n+        changed\n+    }\n+\n+    /// Iterates through all the columns set to true in a given row of\n+    /// the matrix.\n+    pub fn iter<'a>(&'a self, row: R) -> impl Iterator<Item = C> + 'a {\n+        self.vector[row].iter()\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct SparseBitSet<I: Idx> {\n+    chunk_bits: BTreeMap<u32, Word>,\n+    _marker: PhantomData<I>,\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct SparseChunk<I> {\n+    key: u32,\n+    bits: Word,\n+    _marker: PhantomData<I>,\n+}\n+\n+impl<I: Idx> SparseChunk<I> {\n+    pub fn one(index: I) -> Self {\n+        let index = index.index();\n+        let key_usize = index / 128;\n+        let key = key_usize as u32;\n+        assert_eq!(key as usize, key_usize);\n+        SparseChunk {\n+            key,\n+            bits: 1 << (index % 128),\n+            _marker: PhantomData\n+        }\n+    }\n+\n+    pub fn any(&self) -> bool {\n+        self.bits != 0\n+    }\n+\n+    pub fn iter(&self) -> impl Iterator<Item = I> {\n+        let base = self.key as usize * 128;\n+        let mut bits = self.bits;\n+        (0..128).map(move |i| {\n+            let current_bits = bits;\n+            bits >>= 1;\n+            (i, current_bits)\n+        }).take_while(|&(_, bits)| bits != 0)\n+          .filter_map(move |(i, bits)| {\n+            if (bits & 1) != 0 {\n+                Some(I::new(base + i))\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+}\n+\n+impl<I: Idx> SparseBitSet<I> {\n+    pub fn new() -> Self {\n+        SparseBitSet {\n+            chunk_bits: BTreeMap::new(),\n+            _marker: PhantomData\n+        }\n+    }\n+\n+    pub fn capacity(&self) -> usize {\n+        self.chunk_bits.len() * 128\n+    }\n+\n+    pub fn contains_chunk(&self, chunk: SparseChunk<I>) -> SparseChunk<I> {\n+        SparseChunk {\n+            bits: self.chunk_bits.get(&chunk.key).map_or(0, |bits| bits & chunk.bits),\n+            ..chunk\n+        }\n+    }\n+\n+    pub fn insert_chunk(&mut self, chunk: SparseChunk<I>) -> SparseChunk<I> {\n+        if chunk.bits == 0 {\n+            return chunk;\n+        }\n+        let bits = self.chunk_bits.entry(chunk.key).or_insert(0);\n+        let old_bits = *bits;\n+        let new_bits = old_bits | chunk.bits;\n+        *bits = new_bits;\n+        let changed = new_bits ^ old_bits;\n+        SparseChunk {\n+            bits: changed,\n+            ..chunk\n+        }\n+    }\n+\n+    pub fn remove_chunk(&mut self, chunk: SparseChunk<I>) -> SparseChunk<I> {\n+        if chunk.bits == 0 {\n+            return chunk;\n+        }\n+        let changed = match self.chunk_bits.entry(chunk.key) {\n+            Entry::Occupied(mut bits) => {\n+                let old_bits = *bits.get();\n+                let new_bits = old_bits & !chunk.bits;\n+                if new_bits == 0 {\n+                    bits.remove();\n+                } else {\n+                    bits.insert(new_bits);\n+                }\n+                new_bits ^ old_bits\n+            }\n+            Entry::Vacant(_) => 0\n+        };\n+        SparseChunk {\n+            bits: changed,\n+            ..chunk\n+        }\n+    }\n+\n+    pub fn clear(&mut self) {\n+        self.chunk_bits.clear();\n+    }\n+\n+    pub fn chunks<'a>(&'a self) -> impl Iterator<Item = SparseChunk<I>> + 'a {\n+        self.chunk_bits.iter().map(|(&key, &bits)| {\n+            SparseChunk {\n+                key,\n+                bits,\n+                _marker: PhantomData\n+            }\n+        })\n+    }\n+\n+    pub fn contains(&self, index: I) -> bool {\n+        self.contains_chunk(SparseChunk::one(index)).any()\n+    }\n+\n+    pub fn insert(&mut self, index: I) -> bool {\n+        self.insert_chunk(SparseChunk::one(index)).any()\n+    }\n+\n+    pub fn remove(&mut self, index: I) -> bool {\n+        self.remove_chunk(SparseChunk::one(index)).any()\n+    }\n+\n+    pub fn iter<'a>(&'a self) -> impl Iterator<Item = I> + 'a {\n+        self.chunks().flat_map(|chunk| chunk.iter())\n+    }\n+}\n+\n #[inline]\n fn words(elements: usize) -> usize {\n     (elements + WORD_BITS - 1) / WORD_BITS"}, {"sha": "3e94b3f4d302a95029b495b1887b65e6573a753e", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ff9eb56c6e4bff6c1c74bd628a7e0dd79321829b/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9eb56c6e4bff6c1c74bd628a7e0dd79321829b/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=ff9eb56c6e4bff6c1c74bd628a7e0dd79321829b", "patch": "@@ -482,6 +482,21 @@ impl<I: Idx, T> IndexVec<I, T> {\n     pub fn get_mut(&mut self, index: I) -> Option<&mut T> {\n         self.raw.get_mut(index.index())\n     }\n+\n+    /// Return mutable references to two distinct elements, a and b. Panics if a == b.\n+    #[inline]\n+    pub fn pick2_mut(&mut self, a: I, b: I) -> (&mut T, &mut T) {\n+        let (ai, bi) = (a.index(), b.index());\n+        assert!(ai != bi);\n+\n+        if ai < bi {\n+            let (c1, c2) = self.raw.split_at_mut(bi);\n+            (&mut c1[ai], &mut c2[0])\n+        } else {\n+            let (c2, c1) = self.pick2_mut(b, a);\n+            (c1, c2)\n+        }\n+    }\n }\n \n impl<I: Idx, T: Clone> IndexVec<I, T> {"}, {"sha": "be3d02be876c5c7678da1d61e0d5ef7e6cfa6da2", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ff9eb56c6e4bff6c1c74bd628a7e0dd79321829b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9eb56c6e4bff6c1c74bd628a7e0dd79321829b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=ff9eb56c6e4bff6c1c74bd628a7e0dd79321829b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::rc::Rc;\n-use rustc_data_structures::bitvec::BitMatrix;\n+use rustc_data_structures::bitvec::SparseBitMatrix;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -132,7 +132,7 @@ impl RegionValueElements {\n }\n \n /// A newtype for the integers that represent one of the possible\n-/// elements in a region. These are the rows in the `BitMatrix` that\n+/// elements in a region. These are the rows in the `SparseBitMatrix` that\n /// is used to store the values of all regions. They have the following\n /// convention:\n ///\n@@ -184,18 +184,18 @@ impl ToElementIndex for RegionElementIndex {\n }\n \n /// Stores the values for a set of regions. These are stored in a\n-/// compact `BitMatrix` representation, with one row per region\n+/// compact `SparseBitMatrix` representation, with one row per region\n /// variable. The columns consist of either universal regions or\n /// points in the CFG.\n #[derive(Clone)]\n pub(super) struct RegionValues {\n     elements: Rc<RegionValueElements>,\n-    matrix: BitMatrix,\n+    matrix: SparseBitMatrix<RegionVid, RegionElementIndex>,\n \n     /// If cause tracking is enabled, maps from a pair (r, e)\n     /// consisting of a region `r` that contains some element `e` to\n     /// the reason that the element is contained. There should be an\n-    /// entry for every bit set to 1 in `BitMatrix`.\n+    /// entry for every bit set to 1 in `SparseBitMatrix`.\n     causes: Option<CauseMap>,\n }\n \n@@ -214,7 +214,8 @@ impl RegionValues {\n \n         Self {\n             elements: elements.clone(),\n-            matrix: BitMatrix::new(num_region_variables, elements.num_elements()),\n+            matrix: SparseBitMatrix::new(RegionVid::new(num_region_variables),\n+                                         RegionElementIndex::new(elements.num_elements())),\n             causes: if track_causes.0 {\n                 Some(CauseMap::default())\n             } else {\n@@ -238,7 +239,7 @@ impl RegionValues {\n     where\n         F: FnOnce(&CauseMap) -> Cause,\n     {\n-        if self.matrix.add(r.index(), i.index()) {\n+        if self.matrix.add(r, i) {\n             debug!(\"add(r={:?}, i={:?})\", r, self.elements.to_element(i));\n \n             if let Some(causes) = &mut self.causes {\n@@ -289,7 +290,7 @@ impl RegionValues {\n         constraint_location: Location,\n         constraint_span: Span,\n     ) -> bool {\n-        // We could optimize this by improving `BitMatrix::merge` so\n+        // We could optimize this by improving `SparseBitMatrix::merge` so\n         // it does not always merge an entire row. That would\n         // complicate causal tracking though.\n         debug!(\n@@ -315,7 +316,7 @@ impl RegionValues {\n     /// True if the region `r` contains the given element.\n     pub(super) fn contains<E: ToElementIndex>(&self, r: RegionVid, elem: E) -> bool {\n         let i = self.elements.index(elem);\n-        self.matrix.contains(r.index(), i.index())\n+        self.matrix.contains(r, i)\n     }\n \n     /// Iterate over the value of the region `r`, yielding up element\n@@ -326,8 +327,8 @@ impl RegionValues {\n         r: RegionVid,\n     ) -> impl Iterator<Item = RegionElementIndex> + 'a {\n         self.matrix\n-            .iter(r.index())\n-            .map(move |i| RegionElementIndex::new(i))\n+            .iter(r)\n+            .map(move |i| i)\n     }\n \n     /// Returns just the universal regions that are contained in a given region's value."}]}