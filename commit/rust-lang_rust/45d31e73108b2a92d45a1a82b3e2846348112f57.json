{"sha": "45d31e73108b2a92d45a1a82b3e2846348112f57", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ZDMxZTczMTA4YjJhOTJkNDVhMWE4MmIzZTI4NDYzNDgxMTJmNTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-01T04:50:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-01T04:50:00Z"}, "message": "Auto merge of #44233 - Mark-Simulacrum:rollup, r=Mark-Simulacrum\n\nRollup of 10 pull requests\n\n- Successful merges: #44192, #44199, #44202, #44203, #44205, #44207, #44209, #44223, #44230, #44231\n- Failed merges:", "tree": {"sha": "8fce55366857901258fcbeb0a194d19f740f0230", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fce55366857901258fcbeb0a194d19f740f0230"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45d31e73108b2a92d45a1a82b3e2846348112f57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45d31e73108b2a92d45a1a82b3e2846348112f57", "html_url": "https://github.com/rust-lang/rust/commit/45d31e73108b2a92d45a1a82b3e2846348112f57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45d31e73108b2a92d45a1a82b3e2846348112f57/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69dbe6602ddc32dad1febb65232c999dd9980ead", "url": "https://api.github.com/repos/rust-lang/rust/commits/69dbe6602ddc32dad1febb65232c999dd9980ead", "html_url": "https://github.com/rust-lang/rust/commit/69dbe6602ddc32dad1febb65232c999dd9980ead"}, {"sha": "81fc0e1150808b4f0aab525482bb0934e587ea80", "url": "https://api.github.com/repos/rust-lang/rust/commits/81fc0e1150808b4f0aab525482bb0934e587ea80", "html_url": "https://github.com/rust-lang/rust/commit/81fc0e1150808b4f0aab525482bb0934e587ea80"}], "stats": {"total": 334, "additions": 239, "deletions": 95}, "files": [{"sha": "5815cb0f9726007f7a372956268658087d0e76e0", "filename": "RELEASES.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45d31e73108b2a92d45a1a82b3e2846348112f57/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/45d31e73108b2a92d45a1a82b3e2846348112f57/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=45d31e73108b2a92d45a1a82b3e2846348112f57", "patch": "@@ -3,7 +3,7 @@ Version 1.20.0 (2017-08-31)\n \n Language\n --------\n-- [Associated constants in traits is now stabilised.][42809]\n+- [Associated constants are now stabilised.][42809]\n - [A lot of macro bugs are now fixed.][42913]\n \n Compiler\n@@ -77,7 +77,7 @@ Stabilized APIs\n - [`slice::sort_unstable_by_key`]\n - [`slice::sort_unstable_by`]\n - [`slice::sort_unstable`]\n-- [`ste::from_boxed_utf8_unchecked`]\n+- [`str::from_boxed_utf8_unchecked`]\n - [`str::as_bytes_mut`]\n - [`str::as_bytes_mut`]\n - [`str::from_utf8_mut`]"}, {"sha": "05d59e7d59565b359c2790d586e0fc2e6886cb40", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=45d31e73108b2a92d45a1a82b3e2846348112f57", "patch": "@@ -757,7 +757,7 @@ impl Step for Src {\n             \"src/libprofiler_builtins\",\n         ];\n         let std_src_dirs_exclude = [\n-            \"src/compiler-rt/test\",\n+            \"src/libcompiler_builtins/compiler-rt/test\",\n             \"src/jemalloc/test/unit\",\n         ];\n "}, {"sha": "8173903c03440527bec8aff42a3d6f44fcc93a8a", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=45d31e73108b2a92d45a1a82b3e2846348112f57", "patch": "@@ -407,6 +407,7 @@ impl Step for Openssl {\n             \"i686-unknown-freebsd\" => \"BSD-x86-elf\",\n             \"i686-unknown-linux-gnu\" => \"linux-elf\",\n             \"i686-unknown-linux-musl\" => \"linux-elf\",\n+            \"i686-unknown-netbsd\" => \"BSD-x86-elf\",\n             \"mips-unknown-linux-gnu\" => \"linux-mips32\",\n             \"mips64-unknown-linux-gnuabi64\" => \"linux64-mips64\",\n             \"mips64el-unknown-linux-gnuabi64\" => \"linux64-mips64\","}, {"sha": "2eb77ef3ffc1849e8fd58cfeab9cc9b5f6bec4a6", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 81, "deletions": 80, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=45d31e73108b2a92d45a1a82b3e2846348112f57", "patch": "@@ -593,7 +593,7 @@ macro_rules! profq_key {\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n-       [$($modifiers:tt)*] $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n+       [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n         define_map_struct! {\n             tcx: $tcx,\n             input: ($(([$($modifiers)*] [$($attr)*] [$name]))*)\n@@ -954,191 +954,192 @@ macro_rules! define_provider_struct {\n // the driver creates (using several `rustc_*` crates).\n define_maps! { <'tcx>\n     /// Records the type of every item.\n-    [] type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n+    [] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n     /// associated generics and predicates.\n-    [] generics_of: GenericsOfItem(DefId) -> &'tcx ty::Generics,\n-    [] predicates_of: PredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n+    [] fn generics_of: GenericsOfItem(DefId) -> &'tcx ty::Generics,\n+    [] fn predicates_of: PredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n \n     /// Maps from the def-id of a trait to the list of\n     /// super-predicates. This is a subset of the full list of\n     /// predicates. We store these in a separate map because we must\n     /// evaluate them even during type conversion, often before the\n     /// full predicates are available (note that supertraits have\n     /// additional acyclicity requirements).\n-    [] super_predicates_of: SuperPredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n+    [] fn super_predicates_of: SuperPredicatesOfItem(DefId) -> ty::GenericPredicates<'tcx>,\n \n     /// To avoid cycles within the predicates of a single item we compute\n     /// per-type-parameter predicates for resolving `T::AssocTy`.\n-    [] type_param_predicates: type_param_predicates((DefId, DefId))\n+    [] fn type_param_predicates: type_param_predicates((DefId, DefId))\n         -> ty::GenericPredicates<'tcx>,\n \n-    [] trait_def: TraitDefOfItem(DefId) -> &'tcx ty::TraitDef,\n-    [] adt_def: AdtDefOfItem(DefId) -> &'tcx ty::AdtDef,\n-    [] adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n-    [] adt_sized_constraint: SizedConstraint(DefId) -> &'tcx [Ty<'tcx>],\n-    [] adt_dtorck_constraint: DtorckConstraint(DefId) -> ty::DtorckConstraint<'tcx>,\n+    [] fn trait_def: TraitDefOfItem(DefId) -> &'tcx ty::TraitDef,\n+    [] fn adt_def: AdtDefOfItem(DefId) -> &'tcx ty::AdtDef,\n+    [] fn adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n+    [] fn adt_sized_constraint: SizedConstraint(DefId) -> &'tcx [Ty<'tcx>],\n+    [] fn adt_dtorck_constraint: DtorckConstraint(DefId) -> ty::DtorckConstraint<'tcx>,\n \n     /// True if this is a const fn\n-    [] is_const_fn: IsConstFn(DefId) -> bool,\n+    [] fn is_const_fn: IsConstFn(DefId) -> bool,\n \n     /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n-    [] is_foreign_item: IsForeignItem(DefId) -> bool,\n+    [] fn is_foreign_item: IsForeignItem(DefId) -> bool,\n \n     /// True if this is a default impl (aka impl Foo for ..)\n-    [] is_default_impl: IsDefaultImpl(DefId) -> bool,\n+    [] fn is_default_impl: IsDefaultImpl(DefId) -> bool,\n \n     /// Get a map with the variance of every item; use `item_variance`\n     /// instead.\n-    [] crate_variances: crate_variances(CrateNum) -> Rc<ty::CrateVariancesMap>,\n+    [] fn crate_variances: crate_variances(CrateNum) -> Rc<ty::CrateVariancesMap>,\n \n     /// Maps from def-id of a type or region parameter to its\n     /// (inferred) variance.\n-    [] variances_of: ItemVariances(DefId) -> Rc<Vec<ty::Variance>>,\n+    [] fn variances_of: ItemVariances(DefId) -> Rc<Vec<ty::Variance>>,\n \n     /// Maps from an impl/trait def-id to a list of the def-ids of its items\n-    [] associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n+    [] fn associated_item_def_ids: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>>,\n \n     /// Maps from a trait item to the trait item \"descriptor\"\n-    [] associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n+    [] fn associated_item: AssociatedItems(DefId) -> ty::AssociatedItem,\n \n-    [] impl_trait_ref: ImplTraitRef(DefId) -> Option<ty::TraitRef<'tcx>>,\n-    [] impl_polarity: ImplPolarity(DefId) -> hir::ImplPolarity,\n+    [] fn impl_trait_ref: ImplTraitRef(DefId) -> Option<ty::TraitRef<'tcx>>,\n+    [] fn impl_polarity: ImplPolarity(DefId) -> hir::ImplPolarity,\n \n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n     /// Methods in these implementations don't need to be exported.\n-    [] inherent_impls: InherentImpls(DefId) -> Rc<Vec<DefId>>,\n+    [] fn inherent_impls: InherentImpls(DefId) -> Rc<Vec<DefId>>,\n \n     /// Set of all the def-ids in this crate that have MIR associated with\n     /// them. This includes all the body owners, but also things like struct\n     /// constructors.\n-    [] mir_keys: mir_keys(CrateNum) -> Rc<DefIdSet>,\n+    [] fn mir_keys: mir_keys(CrateNum) -> Rc<DefIdSet>,\n \n     /// Maps DefId's that have an associated Mir to the result\n     /// of the MIR qualify_consts pass. The actual meaning of\n     /// the value isn't known except to the pass itself.\n-    [] mir_const_qualif: MirConstQualif(DefId) -> u8,\n+    [] fn mir_const_qualif: MirConstQualif(DefId) -> u8,\n \n     /// Fetch the MIR for a given def-id up till the point where it is\n     /// ready for const evaluation.\n     ///\n     /// See the README for the `mir` module for details.\n-    [] mir_const: MirConst(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+    [] fn mir_const: MirConst(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n \n-    [] mir_validated: MirValidated(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+    [] fn mir_validated: MirValidated(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n \n     /// MIR after our optimization passes have run. This is MIR that is ready\n     /// for trans. This is also the only query that can fetch non-local MIR, at present.\n-    [] optimized_mir: MirOptimized(DefId) -> &'tcx mir::Mir<'tcx>,\n+    [] fn optimized_mir: MirOptimized(DefId) -> &'tcx mir::Mir<'tcx>,\n \n     /// Type of each closure. The def ID is the ID of the\n     /// expression defining the closure.\n-    [] closure_kind: ClosureKind(DefId) -> ty::ClosureKind,\n+    [] fn closure_kind: ClosureKind(DefId) -> ty::ClosureKind,\n \n     /// The signature of functions and closures.\n-    [] fn_sig: FnSignature(DefId) -> ty::PolyFnSig<'tcx>,\n+    [] fn fn_sig: FnSignature(DefId) -> ty::PolyFnSig<'tcx>,\n \n     /// Records the signature of each generator. The def ID is the ID of the\n     /// expression defining the closure.\n-    [] generator_sig: GenSignature(DefId) -> Option<ty::PolyGenSig<'tcx>>,\n+    [] fn generator_sig: GenSignature(DefId) -> Option<ty::PolyGenSig<'tcx>>,\n \n     /// Caches CoerceUnsized kinds for impls on custom types.\n-    [] coerce_unsized_info: CoerceUnsizedInfo(DefId)\n+    [] fn coerce_unsized_info: CoerceUnsizedInfo(DefId)\n         -> ty::adjustment::CoerceUnsizedInfo,\n \n-    [] typeck_item_bodies: typeck_item_bodies_dep_node(CrateNum) -> CompileResult,\n+    [] fn typeck_item_bodies: typeck_item_bodies_dep_node(CrateNum) -> CompileResult,\n \n-    [] typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n+    [] fn typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n \n-    [] has_typeck_tables: HasTypeckTables(DefId) -> bool,\n+    [] fn has_typeck_tables: HasTypeckTables(DefId) -> bool,\n \n-    [] coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n+    [] fn coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n \n-    [] borrowck: BorrowCheck(DefId) -> (),\n+    [] fn borrowck: BorrowCheck(DefId) -> (),\n     // FIXME: shouldn't this return a `Result<(), BorrowckErrors>` instead?\n-    [] mir_borrowck: MirBorrowCheck(DefId) -> (),\n+    [] fn mir_borrowck: MirBorrowCheck(DefId) -> (),\n \n     /// Gets a complete map from all types to their inherent impls.\n     /// Not meant to be used directly outside of coherence.\n     /// (Defined only for LOCAL_CRATE)\n-    [] crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum) -> CrateInherentImpls,\n+    [] fn crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum) -> CrateInherentImpls,\n \n     /// Checks all types in the krate for overlap in their inherent impls. Reports errors.\n     /// Not meant to be used directly outside of coherence.\n     /// (Defined only for LOCAL_CRATE)\n-    [] crate_inherent_impls_overlap_check: inherent_impls_overlap_check_dep_node(CrateNum) -> (),\n+    [] fn crate_inherent_impls_overlap_check: inherent_impls_overlap_check_dep_node(CrateNum) -> (),\n \n     /// Results of evaluating const items or constants embedded in\n     /// other items (such as enum variant explicit discriminants).\n-    [] const_eval: const_eval_dep_node(ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>)\n+    [] fn const_eval: const_eval_dep_node(ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>)\n         -> const_val::EvalResult<'tcx>,\n \n     /// Performs the privacy check and computes \"access levels\".\n-    [] privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,\n+    [] fn privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,\n \n-    [] reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n+    [] fn reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n \n     /// Per-function `RegionMaps`. The `DefId` should be the owner-def-id for the fn body;\n     /// in the case of closures or \"inline\" expressions, this will be redirected to the enclosing\n     /// fn item.\n-    [] region_maps: RegionMaps(DefId) -> Rc<RegionMaps>,\n-\n-    [] mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx>,\n-\n-    [] def_symbol_name: SymbolName(DefId) -> ty::SymbolName,\n-    [] symbol_name: symbol_name_dep_node(ty::Instance<'tcx>) -> ty::SymbolName,\n-\n-    [] describe_def: DescribeDef(DefId) -> Option<Def>,\n-    [] def_span: DefSpan(DefId) -> Span,\n-    [] stability: Stability(DefId) -> Option<attr::Stability>,\n-    [] deprecation: Deprecation(DefId) -> Option<attr::Deprecation>,\n-    [] item_attrs: ItemAttrs(DefId) -> Rc<[ast::Attribute]>,\n-    [] fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n-    [] impl_parent: ImplParent(DefId) -> Option<DefId>,\n-    [] trait_of_item: TraitOfItem(DefId) -> Option<DefId>,\n-    [] is_exported_symbol: IsExportedSymbol(DefId) -> bool,\n-    [] item_body_nested_bodies: ItemBodyNestedBodies(DefId) -> Rc<BTreeMap<hir::BodyId, hir::Body>>,\n-    [] const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n-    [] is_mir_available: IsMirAvailable(DefId) -> bool,\n-\n-    [] trait_impls_of: TraitImpls(DefId) -> Rc<ty::trait_def::TraitImpls>,\n-    [] specialization_graph_of: SpecializationGraph(DefId) -> Rc<specialization_graph::Graph>,\n-    [] is_object_safe: ObjectSafety(DefId) -> bool,\n+    [] fn region_maps: RegionMaps(DefId) -> Rc<RegionMaps>,\n+\n+    [] fn mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx>,\n+\n+    [] fn def_symbol_name: SymbolName(DefId) -> ty::SymbolName,\n+    [] fn symbol_name: symbol_name_dep_node(ty::Instance<'tcx>) -> ty::SymbolName,\n+\n+    [] fn describe_def: DescribeDef(DefId) -> Option<Def>,\n+    [] fn def_span: DefSpan(DefId) -> Span,\n+    [] fn stability: Stability(DefId) -> Option<attr::Stability>,\n+    [] fn deprecation: Deprecation(DefId) -> Option<attr::Deprecation>,\n+    [] fn item_attrs: ItemAttrs(DefId) -> Rc<[ast::Attribute]>,\n+    [] fn fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n+    [] fn impl_parent: ImplParent(DefId) -> Option<DefId>,\n+    [] fn trait_of_item: TraitOfItem(DefId) -> Option<DefId>,\n+    [] fn is_exported_symbol: IsExportedSymbol(DefId) -> bool,\n+    [] fn item_body_nested_bodies: ItemBodyNestedBodies(DefId)\n+        -> Rc<BTreeMap<hir::BodyId, hir::Body>>,\n+    [] fn const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n+    [] fn is_mir_available: IsMirAvailable(DefId) -> bool,\n+\n+    [] fn trait_impls_of: TraitImpls(DefId) -> Rc<ty::trait_def::TraitImpls>,\n+    [] fn specialization_graph_of: SpecializationGraph(DefId) -> Rc<specialization_graph::Graph>,\n+    [] fn is_object_safe: ObjectSafety(DefId) -> bool,\n \n     // Get the ParameterEnvironment for a given item; this environment\n     // will be in \"user-facing\" mode, meaning that it is suitabe for\n     // type-checking etc, and it does not normalize specializable\n     // associated types. This is almost always what you want,\n     // unless you are doing MIR optimizations, in which case you\n     // might want to use `reveal_all()` method to change modes.\n-    [] param_env: ParamEnv(DefId) -> ty::ParamEnv<'tcx>,\n+    [] fn param_env: ParamEnv(DefId) -> ty::ParamEnv<'tcx>,\n \n     // Trait selection queries. These are best used by invoking `ty.moves_by_default()`,\n     // `ty.is_copy()`, etc, since that will prune the environment where possible.\n-    [] is_copy_raw: is_copy_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-    [] is_sized_raw: is_sized_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-    [] is_freeze_raw: is_freeze_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-    [] needs_drop_raw: needs_drop_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n-    [] layout_raw: layout_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n+    [] fn is_copy_raw: is_copy_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] fn is_sized_raw: is_sized_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] fn is_freeze_raw: is_freeze_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] fn needs_drop_raw: needs_drop_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] fn layout_raw: layout_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n                                   -> Result<&'tcx Layout, LayoutError<'tcx>>,\n \n-    [] dylib_dependency_formats: DylibDepFormats(DefId)\n+    [] fn dylib_dependency_formats: DylibDepFormats(DefId)\n                                     -> Rc<Vec<(CrateNum, LinkagePreference)>>,\n \n-    [] is_allocator: IsAllocator(DefId) -> bool,\n-    [] is_panic_runtime: IsPanicRuntime(DefId) -> bool,\n-    [] is_compiler_builtins: IsCompilerBuiltins(DefId) -> bool,\n-    [] has_global_allocator: HasGlobalAllocator(DefId) -> bool,\n+    [] fn is_allocator: IsAllocator(DefId) -> bool,\n+    [] fn is_panic_runtime: IsPanicRuntime(DefId) -> bool,\n+    [] fn is_compiler_builtins: IsCompilerBuiltins(DefId) -> bool,\n+    [] fn has_global_allocator: HasGlobalAllocator(DefId) -> bool,\n \n-    [] extern_crate: ExternCrate(DefId) -> Rc<Option<ExternCrate>>,\n+    [] fn extern_crate: ExternCrate(DefId) -> Rc<Option<ExternCrate>>,\n \n-    [] lint_levels: lint_levels(CrateNum) -> Rc<lint::LintLevelMap>,\n+    [] fn lint_levels: lint_levels(CrateNum) -> Rc<lint::LintLevelMap>,\n \n-    [] specializes: specializes_node((DefId, DefId)) -> bool,\n-    [] in_scope_traits: InScopeTraits(HirId) -> Option<Rc<Vec<TraitCandidate>>>,\n-    [] module_exports: ModuleExports(HirId) -> Option<Rc<Vec<Export>>>,\n+    [] fn specializes: specializes_node((DefId, DefId)) -> bool,\n+    [] fn in_scope_traits: InScopeTraits(HirId) -> Option<Rc<Vec<TraitCandidate>>>,\n+    [] fn module_exports: ModuleExports(HirId) -> Option<Rc<Vec<Export>>>,\n }\n \n fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {"}, {"sha": "872a29e7bc0c56f46ed8649207fbb3f0e0c355ef", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=45d31e73108b2a92d45a1a82b3e2846348112f57", "patch": "@@ -447,6 +447,7 @@ impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b\n             ty::TyProjection(ref proj) => Some(proj.item_def_id),\n             ty::TyFnDef(def_id, ..) |\n             ty::TyClosure(def_id, ..) |\n+            ty::TyGenerator(def_id, ..) |\n             ty::TyAnon(def_id, _) => Some(def_id),\n             _ => None\n         };"}, {"sha": "ca55d0e5d2a8ef4cfbc6b64be5c5bb8a424f21d9", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=45d31e73108b2a92d45a1a82b3e2846348112f57", "patch": "@@ -658,11 +658,13 @@ h3 > .collapse-toggle, h4 > .collapse-toggle {\n \n .toggle-wrapper {\n \tposition: relative;\n+\tmargin-top: 5px;\n }\n \n .toggle-wrapper.collapsed {\n-\theight: 1em;\n+\theight: 25px;\n \ttransition: height .2s;\n+\tmargin-bottom: .6em;\n }\n \n .collapse-toggle > .inner {\n@@ -704,14 +706,16 @@ span.since {\n \tmargin-top: 5px;\n }\n \n-.variant + .toggle-wrapper > a {\n-\tmargin-top: 5px;\n-}\n-\n .sub-variant, .sub-variant > h3 {\n \tmargin-top: 0 !important;\n }\n \n+.toggle-label {\n+\tdisplay: inline-block;\n+\tmargin-left: 4px;\n+\tmargin-top: 3px;\n+}\n+\n .enum > .toggle-wrapper + .docblock, .struct > .toggle-wrapper + .docblock {\n \tmargin-left: 30px;\n \tmargin-bottom: 20px;"}, {"sha": "e1d7a2531b6c92b15884d0d3a0a544975498aed7", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=45d31e73108b2a92d45a1a82b3e2846348112f57", "patch": "@@ -767,7 +767,7 @@ impl hash::Hash for SocketAddrV6 {\n ///\n /// let stream = TcpStream::connect((\"127.0.0.1\", 443));\n /// // or\n-/// let stream = TcpStream::connect(\"127.0.0.1.443\");\n+/// let stream = TcpStream::connect(\"127.0.0.1:443\");\n /// // or\n /// let stream = TcpStream::connect((Ipv4Addr::new(127, 0, 0, 1), 443));\n /// ```"}, {"sha": "5467eff202b02847cd45ca92966ffbd7ce6df08e", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=45d31e73108b2a92d45a1a82b3e2846348112f57", "patch": "@@ -111,15 +111,18 @@ impl TcpStream {\n     /// `addr` is an address of the remote host. Anything which implements\n     /// [`ToSocketAddrs`] trait can be supplied for the address; see this trait\n     /// documentation for concrete examples.\n-    /// In case [`ToSocketAddrs::to_socket_addrs()`] returns more than one entry,\n-    /// then the first valid and reachable address is used.\n+    ///\n+    /// If `addr` yields multiple addresses, `connect` will be attempted with\n+    /// each of the addresses until a connection is successful. If none of\n+    /// the addresses result in a successful connection, the error returned from\n+    /// the last connection attempt (the last address) is returned.\n     ///\n     /// [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n-    /// [`ToSocketAddrs::to_socket_addrs()`]:\n-    /// ../../std/net/trait.ToSocketAddrs.html#tymethod.to_socket_addrs\n     ///\n     /// # Examples\n     ///\n+    /// Open a TCP connection to `127.0.0.1:8080`:\n+    ///\n     /// ```no_run\n     /// use std::net::TcpStream;\n     ///\n@@ -129,6 +132,23 @@ impl TcpStream {\n     ///     println!(\"Couldn't connect to server...\");\n     /// }\n     /// ```\n+    ///\n+    /// Open a TCP connection to `127.0.0.1:8080`. If the connection fails, open\n+    /// a TCP connection to `127.0.0.1:8081`:\n+    ///\n+    /// ```no_run\n+    /// use std::net::{SocketAddr, TcpStream};\n+    ///\n+    /// let addrs = [\n+    ///     SocketAddr::from(([127, 0, 0, 1], 8080)),\n+    ///     SocketAddr::from(([127, 0, 0, 1], 8081)),\n+    /// ];\n+    /// if let Ok(stream) = TcpStream::connect(&addrs[..]) {\n+    ///     println!(\"Connected to the server!\");\n+    /// } else {\n+    ///     println!(\"Couldn't connect to server...\");\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn connect<A: ToSocketAddrs>(addr: A) -> io::Result<TcpStream> {\n         super::each_addr(addr, net_imp::TcpStream::connect).map(TcpStream)\n@@ -557,16 +577,36 @@ impl TcpListener {\n     /// The address type can be any implementor of [`ToSocketAddrs`] trait. See\n     /// its documentation for concrete examples.\n     ///\n+    /// If `addr` yields multiple addresses, `bind` will be attempted with\n+    /// each of the addresses until one succeeds and returns the listener. If\n+    /// none of the addresses succeed in creating a listener, the error returned\n+    /// from the last attempt (the last address) is returned.\n+    ///\n     /// [`local_addr`]: #method.local_addr\n     /// [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n     ///\n     /// # Examples\n     ///\n+    /// Create a TCP listener bound to `127.0.0.1:80`:\n+    ///\n     /// ```no_run\n     /// use std::net::TcpListener;\n     ///\n     /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n     /// ```\n+    ///\n+    /// Create a TCP listener bound to `127.0.0.1:80`. If that fails, create a\n+    /// TCP listener bound to `127.0.0.1:443`:\n+    ///\n+    /// ```no_run\n+    /// use std::net::{SocketAddr, TcpListener};\n+    ///\n+    /// let addrs = [\n+    ///     SocketAddr::from(([127, 0, 0, 1], 80)),\n+    ///     SocketAddr::from(([127, 0, 0, 1], 443)),\n+    /// ];\n+    /// let listener = TcpListener::bind(&addrs[..]).unwrap();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<TcpListener> {\n         super::each_addr(addr, net_imp::TcpListener::bind).map(TcpListener)"}, {"sha": "35001833383c0253da750d37385d77e52cb42a0c", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=45d31e73108b2a92d45a1a82b3e2846348112f57", "patch": "@@ -69,14 +69,34 @@ impl UdpSocket {\n     /// The address type can be any implementor of [`ToSocketAddrs`] trait. See\n     /// its documentation for concrete examples.\n     ///\n+    /// If `addr` yields multiple addresses, `bind` will be attempted with\n+    /// each of the addresses until one succeeds and returns the socket. If none\n+    /// of the addresses succeed in creating a socket, the error returned from\n+    /// the last attempt (the last address) is returned.\n+    ///\n     /// [`ToSocketAddrs`]: ../../std/net/trait.ToSocketAddrs.html\n     ///\n     /// # Examples\n     ///\n+    /// Create a UDP socket bound to `127.0.0.1:3400`:\n+    ///\n     /// ```no_run\n     /// use std::net::UdpSocket;\n     ///\n-    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:3400\").expect(\"couldn't bind to address\");\n+    /// ```\n+    ///\n+    /// Create a UDP socket bound to `127.0.0.1:3400`. If the socket cannot be\n+    /// bound to that address, create a UDP socket bound to `127.0.0.1:3401`:\n+    ///\n+    /// ```no_run\n+    /// use std::net::{SocketAddr, UdpSocket};\n+    ///\n+    /// let addrs = [\n+    ///     SocketAddr::from(([127, 0, 0, 1], 3400)),\n+    ///     SocketAddr::from(([127, 0, 0, 1], 3401)),\n+    /// ];\n+    /// let socket = UdpSocket::bind(&addrs[..]).expect(\"couldn't bind to address\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<UdpSocket> {\n@@ -130,6 +150,9 @@ impl UdpSocket {\n     /// Address type can be any implementor of [`ToSocketAddrs`] trait. See its\n     /// documentation for concrete examples.\n     ///\n+    /// It is possible for `addr` to yield multiple addresses, but `send_to`\n+    /// will only send data to the first address yielded by `addr`.\n+    ///\n     /// This will return an error when the IP version of the local socket\n     /// does not match that returned from [`ToSocketAddrs`].\n     ///\n@@ -562,14 +585,37 @@ impl UdpSocket {\n     /// `recv` syscalls to be used to send data and also applies filters to only\n     /// receive data from the specified address.\n     ///\n+    /// If `addr` yields multiple addresses, `connect` will be attempted with\n+    /// each of the addresses until a connection is successful. If none of\n+    /// the addresses are able to be connected, the error returned from the\n+    /// last connection attempt (the last address) is returned.\n+    ///\n     /// # Examples\n     ///\n+    /// Create a UDP socket bound to `127.0.0.1:3400` and connect the socket to\n+    /// `127.0.0.1:8080`:\n+    ///\n     /// ```no_run\n     /// use std::net::UdpSocket;\n     ///\n-    /// let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:3400\").expect(\"couldn't bind to address\");\n     /// socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n     /// ```\n+    ///\n+    /// Create a UDP socket bound to `127.0.0.1:3400` and connect the socket to\n+    /// `127.0.0.1:8080`. If that connection fails, then the UDP socket will\n+    /// connect to `127.0.0.1:8081`:\n+    ///\n+    /// ```no_run\n+    /// use std::net::{SocketAddr, UdpSocket};\n+    ///\n+    /// let socket = UdpSocket::bind(\"127.0.0.1:3400\").expect(\"couldn't bind to address\");\n+    /// let connect_addrs = [\n+    ///     SocketAddr::from(([127, 0, 0, 1], 8080)),\n+    ///     SocketAddr::from(([127, 0, 0, 1], 8081)),\n+    /// ];\n+    /// socket.connect(&connect_addrs[..]).expect(\"connect function failed\");\n+    /// ```\n     #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n     pub fn connect<A: ToSocketAddrs>(&self, addr: A) -> io::Result<()> {\n         super::each_addr(addr, |addr| self.0.connect(addr))"}, {"sha": "4d3db15ef29dbd8fead00742db3303c032284af2", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=45d31e73108b2a92d45a1a82b3e2846348112f57", "patch": "@@ -115,6 +115,12 @@ impl Symbol {\n     }\n }\n \n+impl<'a> From<&'a str> for Symbol {\n+    fn from(string: &'a str) -> Symbol {\n+        Symbol::intern(string)\n+    }\n+}\n+\n impl fmt::Debug for Symbol {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}({})\", self, self.0)"}, {"sha": "a6a2a2d081e1f68cb1f2d852b28e8ebd55f0b5be", "filename": "src/test/run-pass/generator/auxiliary/xcrate-reachable.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Ftest%2Frun-pass%2Fgenerator%2Fauxiliary%2Fxcrate-reachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Ftest%2Frun-pass%2Fgenerator%2Fauxiliary%2Fxcrate-reachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fauxiliary%2Fxcrate-reachable.rs?ref=45d31e73108b2a92d45a1a82b3e2846348112f57", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait, generators, generator_trait)]\n+\n+use std::ops::Generator;\n+\n+fn msg() -> u32 {\n+    0\n+}\n+\n+pub fn foo() -> impl Generator<Yield=(), Return=u32> {\n+    || {\n+        yield;\n+        return msg();\n+    }\n+}"}, {"sha": "dff5e08b9c20e3a54f0dafef49eb9c2cf227d20e", "filename": "src/test/run-pass/generator/xcrate-reachable.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Ftest%2Frun-pass%2Fgenerator%2Fxcrate-reachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d31e73108b2a92d45a1a82b3e2846348112f57/src%2Ftest%2Frun-pass%2Fgenerator%2Fxcrate-reachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fxcrate-reachable.rs?ref=45d31e73108b2a92d45a1a82b3e2846348112f57", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:xcrate-reachable.rs\n+\n+#![feature(conservative_impl_trait, generator_trait)]\n+\n+extern crate xcrate_reachable as foo;\n+\n+use std::ops::Generator;\n+\n+fn main() {\n+    foo::foo().resume();\n+}"}]}