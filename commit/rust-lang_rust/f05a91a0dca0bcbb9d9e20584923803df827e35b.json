{"sha": "f05a91a0dca0bcbb9d9e20584923803df827e35b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNWE5MWEwZGNhMGJjYmI5ZDllMjA1ODQ5MjM4MDNkZjgyN2UzNWI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-15T23:38:23Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-16T17:36:19Z"}, "message": "Rename std::ivec to std::vec", "tree": {"sha": "f0e871d856829a09fa3408c7354e0dcbc059f4d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0e871d856829a09fa3408c7354e0dcbc059f4d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f05a91a0dca0bcbb9d9e20584923803df827e35b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f05a91a0dca0bcbb9d9e20584923803df827e35b", "html_url": "https://github.com/rust-lang/rust/commit/f05a91a0dca0bcbb9d9e20584923803df827e35b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f05a91a0dca0bcbb9d9e20584923803df827e35b/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38c2363c459b481f40392f78b4db843172961fd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/38c2363c459b481f40392f78b4db843172961fd4", "html_url": "https://github.com/rust-lang/rust/commit/38c2363c459b481f40392f78b4db843172961fd4"}], "stats": {"total": 1485, "additions": 740, "deletions": 745}, "files": [{"sha": "5d58fe21961e25c41d4a47564aac5e2768caa3a7", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -7,7 +7,7 @@ import metadata::encoder;\n import middle::trans_common::crate_ctxt;\n import std::str;\n import std::fs;\n-import std::ivec;\n+import std::vec;\n import std::option;\n import option::some;\n import option::none;\n@@ -358,8 +358,8 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n                     {\n                         let os =\n                             str::split(fs::basename(output), '.' as u8);\n-                        assert (ivec::len(os) >= 2u);\n-                        ivec::pop(os);\n+                        assert (vec::len(os) >= 2u);\n+                        vec::pop(os);\n                         str::connect(os, \".\")\n                     };\n                 warn_missing(sess, \"name\", name);"}, {"sha": "9a3f528600b7acfe5516c7d09b440c72553dc69b", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -27,7 +27,7 @@ import std::option;\n import std::option::some;\n import std::option::none;\n import std::str;\n-import std::ivec;\n+import std::vec;\n import std::int;\n import std::io;\n import std::run;\n@@ -441,8 +441,8 @@ fn opts() -> [getopts::opt] {\n }\n \n fn main(args: vec[str]) {\n-    let args_ivec = ivec::from_vec(args);\n-    let binary = ivec::shift(args_ivec);\n+    let args_ivec = vec::from_vec(args);\n+    let binary = vec::shift(args_ivec);\n     let binary_dir = fs::dirname(binary);\n     let match =\n         alt getopts::getopts(args_ivec, opts()) {\n@@ -462,7 +462,7 @@ fn main(args: vec[str]) {\n     }\n     let sopts = build_session_options(binary, match, binary_dir);\n     let sess = build_session(sopts);\n-    let n_inputs = ivec::len[str](match.free);\n+    let n_inputs = vec::len[str](match.free);\n     let output_file = getopts::opt_maybe_str(match, \"o\");\n     let glue = opt_present(match, \"glue\");\n     if glue {\n@@ -523,7 +523,7 @@ fn main(args: vec[str]) {\n         } else {\n             ~[\"default\", \"rs\"]\n         };\n-        ivec::pop(parts);\n+        vec::pop(parts);\n         saved_out_filename = str::connect(parts, \".\");\n         let suffix = alt sopts.output_type {\n           link::output_type_none. { \"none\" }\n@@ -580,7 +580,7 @@ fn main(args: vec[str]) {\n                  }(config, _);\n         fn rmext(filename: str) -> str {\n             let parts = str::split(filename, '.' as u8);\n-            ivec::pop(parts);\n+            vec::pop(parts);\n             ret str::connect(parts, \".\");\n         }\n         ret alt config.os {\n@@ -639,8 +639,6 @@ fn main(args: vec[str]) {\n #[cfg(test)]\n mod test {\n \n-    import std::ivec;\n-\n     // When the user supplies --test we should implicitly supply --cfg test\n     #[test]\n     fn test_switch_implies_cfg_test() {\n@@ -666,7 +664,7 @@ mod test {\n         let sess = build_session(sessopts);\n         let cfg = build_configuration(sess, \"whatever\", \"whatever\");\n         let test_items = attr::find_meta_items_by_name(cfg, \"test\");\n-        assert (ivec::len(test_items) == 1u);\n+        assert (vec::len(test_items) == 1u);\n     }\n }\n "}, {"sha": "48a33b4dd19a14db72e7eb4ca7a3f2e09a72a2e1", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,6 +1,6 @@\n // Functions dealing with attributes and meta_items\n \n-import std::ivec;\n+import std::vec;\n import std::str;\n import std::map;\n import std::option;\n@@ -50,7 +50,7 @@ fn find_attrs_by_name(attrs: &[ast::attribute], name: ast::ident) ->\n                      option::some(a)\n                  } else { option::none }\n              }(_, name);\n-    ret ivec::filter_map(filter, attrs);\n+    ret vec::filter_map(filter, attrs);\n }\n \n fn get_attr_name(attr: &ast::attribute) -> ast::ident {\n@@ -66,7 +66,7 @@ fn find_meta_items_by_name(metas: &[@ast::meta_item], name: ast::ident) ->\n                      option::some(m)\n                  } else { option::none }\n              }(_, name);\n-    ret ivec::filter_map(filter, metas);\n+    ret vec::filter_map(filter, metas);\n }\n \n fn get_meta_item_name(meta: &@ast::meta_item) -> ast::ident {\n@@ -135,7 +135,7 @@ fn contains(haystack: &[@ast::meta_item], needle: @ast::meta_item) -> bool {\n \n fn contains_name(metas: &[@ast::meta_item], name: ast::ident) -> bool {\n     let matches = find_meta_items_by_name(metas, name);\n-    ret ivec::len(matches) > 0u;\n+    ret vec::len(matches) > 0u;\n }\n \n // FIXME: This needs to sort by meta_item variant in addition to the item name\n@@ -173,7 +173,7 @@ fn remove_meta_items_by_name(items: &[@ast::meta_item], name: str) ->\n                  } else { option::none }\n              }(_, name);\n \n-    ret ivec::filter_map(filter, items);\n+    ret vec::filter_map(filter, items);\n }\n \n fn require_unique_names(sess: &session::session,"}, {"sha": "42d55688c1dd3c546726184026c789cdfbe16233", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,4 +1,4 @@\n-import std::ivec;\n+import std::vec;\n import std::option;\n import syntax::ast;\n import syntax::fold;\n@@ -32,9 +32,9 @@ fn filter_item(cfg: &ast::crate_cfg, item: &@ast::item) ->\n fn fold_mod(cfg: &ast::crate_cfg, m: &ast::_mod, fld: fold::ast_fold) ->\n    ast::_mod {\n     let filter = bind filter_item(cfg, _);\n-    let filtered_items = ivec::filter_map(filter, m.items);\n-    ret {view_items: ivec::map(fld.fold_view_item, m.view_items),\n-         items: ivec::map(fld.fold_item, filtered_items)};\n+    let filtered_items = vec::filter_map(filter, m.items);\n+    ret {view_items: vec::map(fld.fold_view_item, m.view_items),\n+         items: vec::map(fld.fold_item, filtered_items)};\n }\n \n fn filter_native_item(cfg: &ast::crate_cfg, item: &@ast::native_item) ->\n@@ -47,10 +47,10 @@ fn filter_native_item(cfg: &ast::crate_cfg, item: &@ast::native_item) ->\n fn fold_native_mod(cfg: &ast::crate_cfg, nm: &ast::native_mod,\n                    fld: fold::ast_fold) -> ast::native_mod {\n     let filter = bind filter_native_item(cfg, _);\n-    let filtered_items = ivec::filter_map(filter, nm.items);\n+    let filtered_items = vec::filter_map(filter, nm.items);\n     ret {native_name: nm.native_name,\n          abi: nm.abi,\n-         view_items: ivec::map(fld.fold_view_item, nm.view_items),\n+         view_items: vec::map(fld.fold_view_item, nm.view_items),\n          items: filtered_items};\n }\n \n@@ -74,8 +74,8 @@ fn filter_stmt(cfg: &ast::crate_cfg, stmt: &@ast::stmt) ->\n fn fold_block(cfg: &ast::crate_cfg, b: &ast::blk_, fld: fold::ast_fold) ->\n    ast::blk_ {\n     let filter = bind filter_stmt(cfg, _);\n-    let filtered_stmts = ivec::filter_map(filter, b.stmts);\n-    ret {stmts: ivec::map(fld.fold_stmt, filtered_stmts),\n+    let filtered_stmts = vec::filter_map(filter, b.stmts);\n+    ret {stmts: vec::map(fld.fold_stmt, filtered_stmts),\n          expr: option::map(fld.fold_expr, b.expr),\n          id: b.id};\n }\n@@ -95,7 +95,7 @@ fn in_cfg(cfg: &ast::crate_cfg, attrs: &[ast::attribute]) -> bool {\n \n     // The \"cfg\" attributes on the item\n     let item_cfg_attrs = attr::find_attrs_by_name(attrs, \"cfg\");\n-    let item_has_cfg_attrs = ivec::len(item_cfg_attrs) > 0u;\n+    let item_has_cfg_attrs = vec::len(item_cfg_attrs) > 0u;\n     if !item_has_cfg_attrs { ret true; }\n \n     // Pull the inner meta_items from the #[cfg(meta_item, ...)]  attributes,\n@@ -115,7 +115,7 @@ fn in_cfg(cfg: &ast::crate_cfg, attrs: &[ast::attribute]) -> bool {\n                 }\n             }\n             let cfg_metas = attr::attr_metas(item_cfg_attrs);\n-            ivec::foldl(extract_metas, ~[], cfg_metas)\n+            vec::foldl(extract_metas, ~[], cfg_metas)\n         };\n \n     for cfg_mi: @ast::meta_item in item_cfg_metas {"}, {"sha": "309d2e21777da33a44291ee16da9cdb3ac87e07b", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,7 +1,7 @@\n // Code that generates a test runner to run all the tests in a crate\n \n import std::option;\n-import std::ivec;\n+import std::vec;\n import syntax::ast;\n import syntax::fold;\n import syntax::print::pprust;\n@@ -69,7 +69,7 @@ fn fold_mod(cx: &test_ctxt, m: &ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n     }\n \n     let mod_nomain =\n-        {view_items: m.view_items, items: ivec::filter_map(nomain, m.items)};\n+        {view_items: m.view_items, items: vec::filter_map(nomain, m.items)};\n     ret fold::noop_fold_mod(mod_nomain, fld);\n }\n \n@@ -93,24 +93,24 @@ fn fold_item(cx: &test_ctxt, i: &@ast::item, fld: fold::ast_fold) ->\n         log \"this is a test function\";\n         let test = {path: cx.path, ignore: is_ignored(i)};\n         cx.testfns += ~[test];\n-        log #fmt(\"have %u test functions\", ivec::len(cx.testfns));\n+        log #fmt(\"have %u test functions\", vec::len(cx.testfns));\n     }\n \n     let res = fold::noop_fold_item(i, fld);\n-    ivec::pop(cx.path);\n+    vec::pop(cx.path);\n     ret res;\n }\n \n fn is_test_fn(i: &@ast::item) -> bool {\n     let has_test_attr =\n-        ivec::len(attr::find_attrs_by_name(i.attrs, \"test\")) > 0u;\n+        vec::len(attr::find_attrs_by_name(i.attrs, \"test\")) > 0u;\n \n     fn has_test_signature(i: &@ast::item) -> bool {\n         alt i.node {\n           ast::item_fn(f, tps) {\n-            let input_cnt = ivec::len(f.decl.inputs);\n+            let input_cnt = vec::len(f.decl.inputs);\n             let no_output = f.decl.output.node == ast::ty_nil;\n-            let tparm_cnt = ivec::len(tps);\n+            let tparm_cnt = vec::len(tps);\n             input_cnt == 0u && no_output && tparm_cnt == 0u\n           }\n           _ { false }\n@@ -227,7 +227,7 @@ fn mk_test_desc_ivec_ty(cx: &test_ctxt) -> @ast::ty {\n }\n \n fn mk_test_desc_vec(cx: &test_ctxt) -> @ast::expr {\n-    log #fmt(\"building test vector from %u tests\", ivec::len(cx.testfns));\n+    log #fmt(\"building test vector from %u tests\", vec::len(cx.testfns));\n     let descs = ~[];\n     for test: test in cx.testfns {\n         let test_ = test; // Satisfy alias analysis"}, {"sha": "3c22299b19cb669209281c921ff96a952e142afc", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,4 +1,4 @@\n-import std::ivec;\n+import std::vec;\n import std::str;\n import std::str::rustrt::sbuf;\n \n@@ -928,8 +928,8 @@ obj builder(B: BuilderRef, terminated: @mutable bool,\n     fn AggregateRet(RetVals: &[ValueRef]) -> ValueRef {\n         assert (!*terminated);\n         *terminated = true;\n-        ret llvm::LLVMBuildAggregateRet(B, ivec::to_ptr(RetVals),\n-                                        ivec::len(RetVals));\n+        ret llvm::LLVMBuildAggregateRet(B, vec::to_ptr(RetVals),\n+                                        vec::len(RetVals));\n     }\n \n     fn Br(Dest: BasicBlockRef) -> ValueRef {\n@@ -961,7 +961,7 @@ obj builder(B: BuilderRef, terminated: @mutable bool,\n               Catch: BasicBlockRef) -> ValueRef {\n         assert (!*terminated);\n         *terminated = true;\n-        ret llvm::LLVMBuildInvoke(B, Fn, ivec::to_ptr(Args), ivec::len(Args),\n+        ret llvm::LLVMBuildInvoke(B, Fn, vec::to_ptr(Args), vec::len(Args),\n                                   Then, Catch, str::buf(\"\"));\n     }\n \n@@ -1163,14 +1163,14 @@ obj builder(B: BuilderRef, terminated: @mutable bool,\n \n     fn GEP(Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildGEP(B, Pointer, ivec::to_ptr(Indices),\n-                               ivec::len(Indices), str::buf(\"\"));\n+        ret llvm::LLVMBuildGEP(B, Pointer, vec::to_ptr(Indices),\n+                               vec::len(Indices), str::buf(\"\"));\n     }\n \n     fn InBoundsGEP(Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildInBoundsGEP(B, Pointer, ivec::to_ptr(Indices),\n-                                       ivec::len(Indices), str::buf(\"\"));\n+        ret llvm::LLVMBuildInBoundsGEP(B, Pointer, vec::to_ptr(Indices),\n+                                       vec::len(Indices), str::buf(\"\"));\n     }\n \n     fn StructGEP(Pointer: ValueRef, Idx: uint) -> ValueRef {\n@@ -1303,29 +1303,29 @@ obj builder(B: BuilderRef, terminated: @mutable bool,\n        ValueRef {\n         assert (!*terminated);\n         let phi = llvm::LLVMBuildPhi(B, Ty, str::buf(\"\"));\n-        assert (ivec::len[ValueRef](vals) == ivec::len[BasicBlockRef](bbs));\n-        llvm::LLVMAddIncoming(phi, ivec::to_ptr(vals), ivec::to_ptr(bbs),\n-                              ivec::len(vals));\n+        assert (vec::len[ValueRef](vals) == vec::len[BasicBlockRef](bbs));\n+        llvm::LLVMAddIncoming(phi, vec::to_ptr(vals), vec::to_ptr(bbs),\n+                              vec::len(vals));\n         ret phi;\n     }\n \n     fn AddIncomingToPhi(phi: ValueRef, vals: &[ValueRef],\n                         bbs: &[BasicBlockRef]) {\n-        assert (ivec::len[ValueRef](vals) == ivec::len[BasicBlockRef](bbs));\n-        llvm::LLVMAddIncoming(phi, ivec::to_ptr(vals), ivec::to_ptr(bbs),\n-                              ivec::len(vals));\n+        assert (vec::len[ValueRef](vals) == vec::len[BasicBlockRef](bbs));\n+        llvm::LLVMAddIncoming(phi, vec::to_ptr(vals), vec::to_ptr(bbs),\n+                              vec::len(vals));\n     }\n \n     fn Call(Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n         assert (!*terminated);\n-        ret llvm::LLVMBuildCall(B, Fn, ivec::to_ptr(Args), ivec::len(Args),\n+        ret llvm::LLVMBuildCall(B, Fn, vec::to_ptr(Args), vec::len(Args),\n                                 str::buf(\"\"));\n     }\n \n     fn FastCall(Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n         assert (!*terminated);\n         let v =\n-            llvm::LLVMBuildCall(B, Fn, ivec::to_ptr(Args), ivec::len(Args),\n+            llvm::LLVMBuildCall(B, Fn, vec::to_ptr(Args), vec::len(Args),\n                                 str::buf(\"\"));\n         llvm::LLVMSetInstructionCallConv(v, LLVMFastCallConv);\n         ret v;\n@@ -1334,7 +1334,7 @@ obj builder(B: BuilderRef, terminated: @mutable bool,\n     fn CallWithConv(Fn: ValueRef, Args: &[ValueRef], Conv: uint) -> ValueRef {\n         assert (!*terminated);\n         let v =\n-            llvm::LLVMBuildCall(B, Fn, ivec::to_ptr(Args), ivec::len(Args),\n+            llvm::LLVMBuildCall(B, Fn, vec::to_ptr(Args), vec::len(Args),\n                                 str::buf(\"\"));\n         llvm::LLVMSetInstructionCallConv(v, Conv);\n         ret v;\n@@ -1403,7 +1403,7 @@ obj builder(B: BuilderRef, terminated: @mutable bool,\n             llvm::LLVMGetNamedFunction(M, str::buf(\"llvm.trap\"));\n         assert (T as int != 0);\n         let Args: [ValueRef] = ~[];\n-        ret llvm::LLVMBuildCall(B, T, ivec::to_ptr(Args), ivec::len(Args),\n+        ret llvm::LLVMBuildCall(B, T, vec::to_ptr(Args), vec::len(Args),\n                                 str::buf(\"\"));\n     }\n \n@@ -1503,8 +1503,8 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n         let s = \"fn(\";\n         let out_ty: TypeRef = llvm::LLVMGetReturnType(ty);\n         let n_args: uint = llvm::LLVMCountParamTypes(ty);\n-        let args: [TypeRef] = ivec::init_elt[TypeRef](0 as TypeRef, n_args);\n-        llvm::LLVMGetParamTypes(ty, ivec::to_ptr(args));\n+        let args: [TypeRef] = vec::init_elt[TypeRef](0 as TypeRef, n_args);\n+        llvm::LLVMGetParamTypes(ty, vec::to_ptr(args));\n         s += tys_str(names, outer, args);\n         s += \") -> \";\n         s += type_to_str_inner(names, outer, out_ty);\n@@ -1515,8 +1515,8 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n       9 {\n         let s: str = \"{\";\n         let n_elts: uint = llvm::LLVMCountStructElementTypes(ty);\n-        let elts: [TypeRef] = ivec::init_elt[TypeRef](0 as TypeRef, n_elts);\n-        llvm::LLVMGetStructElementTypes(ty, ivec::to_ptr(elts));\n+        let elts: [TypeRef] = vec::init_elt[TypeRef](0 as TypeRef, n_elts);\n+        llvm::LLVMGetStructElementTypes(ty, vec::to_ptr(elts));\n         s += tys_str(names, outer, elts);\n         s += \"}\";\n         ret s;\n@@ -1534,7 +1534,7 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n         for tout: TypeRef in outer0 {\n             i += 1u;\n             if tout as int == ty as int {\n-                let n: uint = ivec::len[TypeRef](outer0) - i;\n+                let n: uint = vec::len[TypeRef](outer0) - i;\n                 ret \"*\\\\\" + std::int::str(n as int);\n             }\n         }\n@@ -1563,8 +1563,8 @@ fn float_width(llt: TypeRef) -> uint {\n }\n \n fn fn_ty_param_tys(fn_ty: TypeRef) -> [TypeRef] {\n-    let args = ivec::init_elt(0 as TypeRef, llvm::LLVMCountParamTypes(fn_ty));\n-    llvm::LLVMGetParamTypes(fn_ty, ivec::to_ptr(args));\n+    let args = vec::init_elt(0 as TypeRef, llvm::LLVMCountParamTypes(fn_ty));\n+    llvm::LLVMGetParamTypes(fn_ty, vec::to_ptr(args));\n     ret args;\n }\n "}, {"sha": "e00ddb11be6599977fafacbcd5eddcd27441d9ba", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -12,7 +12,7 @@ import syntax::visit;\n import syntax::codemap::span;\n import back::x86;\n import util::common;\n-import std::ivec;\n+import std::vec;\n import std::str;\n import std::fs;\n import std::io;\n@@ -94,7 +94,7 @@ fn metadata_matches(crate_data: &@[u8], metas: &[@ast::meta_item]) -> bool {\n     let linkage_metas = attr::find_linkage_metas(attrs);\n \n     log #fmt(\"matching %u metadata requirements against %u items\",\n-             ivec::len(metas), ivec::len(linkage_metas));\n+             vec::len(metas), vec::len(linkage_metas));\n \n     for needed: @ast::meta_item in metas {\n         if !attr::contains(linkage_metas, needed) {\n@@ -126,7 +126,7 @@ fn find_library_crate(sess: &session::session, ident: &ast::ident,\n     // is using the wrong type of meta item\n     let crate_name = {\n         let name_items = attr::find_meta_items_by_name(metas, \"name\");\n-        alt ivec::last(name_items) {\n+        alt vec::last(name_items) {\n           some(i) {\n             alt attr::get_meta_item_value_str(i) {\n               some(n) { n }\n@@ -196,7 +196,7 @@ fn get_metadata_section(filename: str) -> option::t[@[u8]] {\n             let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n             let csz = llvm::LLVMGetSectionSize(si.llsi);\n             let cvbuf: *u8 = std::unsafe::reinterpret_cast(cbuf);\n-            ret option::some[@[u8]](@ivec::unsafe::from_buf(cvbuf, csz));\n+            ret option::some[@[u8]](@vec::unsafe::from_buf(cvbuf, csz));\n         }\n         llvm::LLVMMoveToNextSection(si.llsi);\n     }"}, {"sha": "e93b674bc32a0112ac570b1242fbe26a3f374eb2", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,7 +1,7 @@\n // The crate store - a central repo for information collected about external\n // crates and libraries\n \n-import std::ivec;\n+import std::vec;\n import std::map;\n import std::str;\n import syntax::ast;\n@@ -83,7 +83,7 @@ iter iter_crate_data(cstore: &cstore) ->\n }\n \n fn add_used_crate_file(cstore: &cstore, lib: &str) {\n-    if !ivec::member(lib, p(cstore).used_crate_files) {\n+    if !vec::member(lib, p(cstore).used_crate_files) {\n         p(cstore).used_crate_files += ~[lib];\n     }\n }\n@@ -95,7 +95,7 @@ fn get_used_crate_files(cstore: &cstore) -> [str] {\n fn add_used_library(cstore: &cstore, lib: &str) -> bool {\n     if lib == \"\" { ret false; }\n \n-    if ivec::member(lib, p(cstore).used_libraries) { ret false; }\n+    if vec::member(lib, p(cstore).used_libraries) { ret false; }\n \n     p(cstore).used_libraries += ~[lib];\n     ret true;"}, {"sha": "d365d58fc60c2e883927926a0cd237bc16663c18", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,7 +1,7 @@\n // Decoding metadata from a single crate's metadata\n \n import std::ebml;\n-import std::ivec;\n+import std::vec;\n import std::option;\n import std::str;\n import std::io;\n@@ -48,7 +48,7 @@ fn lookup_hash(d: &ebml::doc, eq_fn: fn(&[u8]) -> bool , hash: uint) ->\n     let belt = tag_index_buckets_bucket_elt;\n     for each elt: ebml::doc in ebml::tagged_docs(bucket, belt) {\n         let pos = ebml::be_uint_from_bytes(elt.data, elt.start, 4u);\n-        if eq_fn(ivec::slice[u8](*elt.data, elt.start + 4u, elt.end)) {\n+        if eq_fn(vec::slice[u8](*elt.data, elt.start + 4u, elt.end)) {\n             result += ~[ebml::doc_at(d.data, pos)];\n         }\n     }\n@@ -62,7 +62,7 @@ fn maybe_find_item(item_id: int, items: &ebml::doc) ->\n     }\n     let eqer = bind eq_item(_, item_id);\n     let found = lookup_hash(items, eqer, hash_node_id(item_id));\n-    if ivec::len(found) == 0u {\n+    if vec::len(found) == 0u {\n         ret option::none[ebml::doc];\n     } else { ret option::some[ebml::doc](found.(0)); }\n }\n@@ -166,7 +166,7 @@ fn resolve_path(path: &[ast::ident], data: @[u8]) -> [ast::def_id] {\n // Crate metadata queries\n fn lookup_defs(data: &@[u8], cnum: ast::crate_num, path: &[ast::ident]) ->\n    [ast::def] {\n-    ret ivec::map(bind lookup_def(cnum, data, _), resolve_path(path, data));\n+    ret vec::map(bind lookup_def(cnum, data, _), resolve_path(path, data));\n }\n \n \n@@ -213,7 +213,7 @@ fn get_type(data: @[u8], def: ast::def_id, tcx: &ty::ctxt,\n }\n \n fn get_type_param_count(data: @[u8], id: ast::node_id) -> uint {\n-    ret ivec::len(get_type_param_kinds(data, id));\n+    ret vec::len(get_type_param_kinds(data, id));\n }\n \n fn get_type_param_kinds(data: @[u8], id: ast::node_id) -> [ast::kind] {\n@@ -269,7 +269,7 @@ fn family_has_type_params(fam_ch: u8) -> bool {\n fn read_path(d: &ebml::doc) -> {path: str, pos: uint} {\n     let desc = ebml::doc_data(d);\n     let pos = ebml::be_uint_from_bytes(@desc, 0u, 4u);\n-    let pathbytes = ivec::slice[u8](desc, 4u, ivec::len[u8](desc));\n+    let pathbytes = vec::slice[u8](desc, 4u, vec::len[u8](desc));\n     let path = str::unsafe_from_bytes(pathbytes);\n     ret {path: path, pos: pos};\n }\n@@ -331,7 +331,7 @@ fn get_attributes(md: &ebml::doc) -> [ast::attribute] {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n-            assert (ivec::len(meta_items) == 1u);\n+            assert (vec::len(meta_items) == 1u);\n             let meta_item = meta_items.(0);\n             attrs +=\n                 ~[{node: {style: ast::attr_outer, value: *meta_item},"}, {"sha": "8cd1380784e62112fef2da657b9b1bebbbae182b", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,6 +1,6 @@\n // Metadata encoding\n \n-import std::ivec;\n+import std::vec;\n import std::str;\n import std::uint;\n import std::io;\n@@ -176,7 +176,7 @@ fn def_to_str(did: &def_id) -> str { ret #fmt(\"%d:%d\", did.crate, did.node); }\n \n fn encode_type_param_kinds(ebml_w: &ebml::writer, tps: &[ty_param]) {\n     ebml::start_tag(ebml_w, tag_items_data_item_ty_param_kinds);\n-    ebml::write_vint(ebml_w.writer, ivec::len[ty_param](tps));\n+    ebml::write_vint(ebml_w.writer, vec::len[ty_param](tps));\n     for tp: ty_param in tps {\n         let c = alt tp.kind {\n           kind_unique. { 'u' }\n@@ -236,7 +236,7 @@ fn encode_tag_variant_info(ecx: &@encode_ctxt, ebml_w: &ebml::writer,\n         encode_tag_id(ebml_w, local_def(id));\n         encode_type(ecx, ebml_w,\n                     node_id_to_monotype(ecx.ccx.tcx, variant.node.id));\n-        if ivec::len[variant_arg](variant.node.args) > 0u {\n+        if vec::len[variant_arg](variant.node.args) > 0u {\n             encode_symbol(ecx, ebml_w, variant.node.id);\n         }\n         encode_discriminant(ecx, ebml_w, variant.node.id);\n@@ -563,9 +563,9 @@ fn encode_crate_deps(ebml_w: &ebml::writer, cstore: &cstore::cstore) {\n \n         // Return just the names\n         fn name(kv: &numname) -> str { kv.ident }\n-        // mutable -> immutable hack for ivec::map\n-        let immpairs = ivec::slice(pairs, 0u, ivec::len(pairs));\n-        ret ivec::map(name, immpairs);\n+        // mutable -> immutable hack for vec::map\n+        let immpairs = vec::slice(pairs, 0u, vec::len(pairs));\n+        ret vec::map(name, immpairs);\n     }\n \n     // We're just going to write a list of crate names, with the assumption"}, {"sha": "402855e34daedbd3d82e14c6089f8f6964a93f51", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,6 +1,6 @@\n // Type decoding\n \n-import std::ivec;\n+import std::vec;\n import std::str;\n import std::uint;\n import std::option;\n@@ -409,14 +409,14 @@ fn parse_ty_fn(st: @pstate, sd: str_def) ->\n // Rust metadata parsing\n fn parse_def_id(buf: &[u8]) -> ast::def_id {\n     let colon_idx = 0u;\n-    let len = ivec::len[u8](buf);\n+    let len = vec::len[u8](buf);\n     while colon_idx < len && buf.(colon_idx) != ':' as u8 { colon_idx += 1u; }\n     if colon_idx == len {\n         log_err \"didn't find ':' when parsing def id\";\n         fail;\n     }\n-    let crate_part = ivec::slice[u8](buf, 0u, colon_idx);\n-    let def_part = ivec::slice[u8](buf, colon_idx + 1u, len);\n+    let crate_part = vec::slice[u8](buf, 0u, colon_idx);\n+    let def_part = vec::slice[u8](buf, colon_idx + 1u, len);\n \n     let crate_part_vec = ~[];\n     let def_part_vec = ~[];"}, {"sha": "7969977e2b9aaf30fc0ad14cb934cf44df8bffb1", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -7,7 +7,7 @@ import ast::def_id;\n import syntax::codemap::span;\n import syntax::visit;\n import visit::vt;\n-import std::ivec;\n+import std::vec;\n import std::str;\n import std::option;\n import std::option::some;\n@@ -218,7 +218,7 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n         }\n         i += 1u;\n     }\n-    if ivec::len(unsafe_ts) > 0u {\n+    if vec::len(unsafe_ts) > 0u {\n         alt f.node {\n           ast::expr_path(_) {\n             if def_is_local(cx.tcx.def_map.get(f.id), true) {\n@@ -319,9 +319,9 @@ fn check_alt(cx: &ctx, input: &@ast::expr, arms: &[ast::arm], sc: &scope,\n     for a: ast::arm in arms {\n         let dnums = arm_defnums(a);\n         let new_sc = sc;\n-        if ivec::len(dnums) > 0u {\n+        if vec::len(dnums) > 0u {\n             new_sc = @(*sc + ~[@{root_vars: roots,\n-                                 block_defnum: dnums.(ivec::len(dnums) - 1u),\n+                                 block_defnum: dnums.(vec::len(dnums) - 1u),\n                                  bindings: dnums,\n                                  tys: forbidden_tp,\n                                  depends_on: deps(sc, roots),\n@@ -343,7 +343,7 @@ fn check_for_each(cx: &ctx, local: &@ast::local, call: &@ast::expr,\n         let data = check_call(cx, f, args, sc);\n         let bindings = ast::pat_binding_ids(local.node.pat);\n         let new_sc = @{root_vars: data.root_vars,\n-                       block_defnum: bindings.(ivec::len(bindings) - 1u),\n+                       block_defnum: bindings.(vec::len(bindings) - 1u),\n                        bindings: bindings,\n                        tys: data.unsafe_ts,\n                        depends_on: deps(sc, data.root_vars),\n@@ -376,7 +376,7 @@ fn check_for(cx: &ctx, local: &@ast::local, seq: &@ast::expr, blk: &ast::blk,\n     }\n     let bindings = ast::pat_binding_ids(local.node.pat);\n     let new_sc = @{root_vars: root_def,\n-                   block_defnum: bindings.(ivec::len(bindings) - 1u),\n+                   block_defnum: bindings.(vec::len(bindings) - 1u),\n                    bindings: bindings,\n                    tys: unsafe,\n                    depends_on: deps(sc, root_def),\n@@ -399,7 +399,7 @@ fn check_var(cx: &ctx, ex: &@ast::expr, p: &ast::path, id: ast::node_id,\n                     r.ok = val_taken(ex.span, p);\n                 }\n             }\n-        } else if (ivec::member(my_defnum, r.bindings)) {\n+        } else if (vec::member(my_defnum, r.bindings)) {\n             test_scope(cx, sc, r, p);\n         }\n     }\n@@ -416,14 +416,14 @@ fn check_lval(cx: &@ctx, dest: &@ast::expr, sc: &scope, v: &vt[scope]) {\n                                  \"assigning to immutable obj field\");\n         }\n         for r: restrict in *sc {\n-            if ivec::member(dnum, r.root_vars) {\n+            if vec::member(dnum, r.root_vars) {\n                 r.ok = overwritten(dest.span, p);\n             }\n         }\n       }\n       _ {\n         let root = expr_root(*cx, dest, false);\n-        if ivec::len(*root.ds) == 0u {\n+        if vec::len(*root.ds) == 0u {\n             cx.tcx.sess.span_err(dest.span, \"assignment to non-lvalue\");\n         } else if (!root.ds.(0).mut) {\n             let name =\n@@ -456,7 +456,7 @@ fn check_move_rhs(cx: &@ctx, src: &@ast::expr, sc: &scope, v: &vt[scope]) {\n         let root = expr_root(*cx, src, false);\n \n         // Not a path and no-derefs means this is a temporary.\n-        if ivec::len(*root.ds) != 0u {\n+        if vec::len(*root.ds) != 0u {\n             cx.tcx.sess.span_err(src.span, \"moving out of a data structure\");\n         }\n       }\n@@ -476,7 +476,7 @@ fn is_immutable_alias(cx: &ctx, sc: &scope, dnum: node_id) -> bool {\n       _ { }\n     }\n     for r: restrict in *sc {\n-        if ivec::member(dnum, r.bindings) { ret true; }\n+        if vec::member(dnum, r.bindings) { ret true; }\n     }\n     ret false;\n }\n@@ -511,7 +511,7 @@ fn deps(sc: &scope, roots: &[node_id]) -> [uint] {\n     let result = ~[];\n     for r: restrict in *sc {\n         for dn: node_id in roots {\n-            if ivec::member(dn, r.bindings) { result += ~[i]; }\n+            if vec::member(dn, r.bindings) { result += ~[i]; }\n         }\n         i += 1u;\n     }\n@@ -546,8 +546,8 @@ fn expr_root(cx: &ctx, ex: @ast::expr, autoderef: bool) ->\n               }\n               ty::ty_tag(did, tps) {\n                 let variants = ty::tag_variants(cx.tcx, did);\n-                if ivec::len(variants) != 1u ||\n-                       ivec::len(variants.(0).args) != 1u {\n+                if vec::len(variants) != 1u ||\n+                       vec::len(variants.(0).args) != 1u {\n                     break;\n                 }\n                 ds += ~[@{mut: false, kind: unbox, outer_t: t}];"}, {"sha": "630a3d6e1604064b12d80bc80a86afa263bd3535", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -126,7 +126,7 @@ fn is_refutable(tcx: &ty::ctxt, pat: &@pat) -> bool {\n       }\n       pat_tag(_, args) {\n         let vdef = variant_def_ids(tcx.def_map.get(pat.id));\n-        if std::ivec::len(ty::tag_variants(tcx, vdef.tg)) != 1u {\n+        if std::vec::len(ty::tag_variants(tcx, vdef.tg)) != 1u {\n             ret true;\n         }\n         for p: @pat in args {"}, {"sha": "12366d2aacb37979b1f97ae1fe3e52f0b1bed21a", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -3,7 +3,6 @@\n \n import std::map;\n import std::map::*;\n-import std::ivec;\n import std::option;\n import std::int;\n import std::option::*;"}, {"sha": "e4333aab6f517966d7284b6a276b64266e8d9349", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -74,7 +74,7 @@\n import syntax::ast;\n import syntax::visit;\n \n-import std::ivec;\n+import std::vec;\n \n import ast::kind;\n import ast::kind_unique;\n@@ -145,11 +145,11 @@ fn check_expr(tcx: &ty::ctxt, e: &@ast::expr) {\n         // If we have typarams, we're calling an item; we need to check\n         // that all the types we're supplying as typarams conform to the\n         // typaram kind constraints on that item.\n-        if ivec::len(tpt.params) != 0u {\n+        if vec::len(tpt.params) != 0u {\n             let callee_def = ast::def_id_of_def(tcx.def_map.get(callee.id));\n             let item_tk = ty::lookup_item_type(tcx, callee_def);\n             let i = 0;\n-            assert ivec::len(item_tk.kinds) == ivec::len(tpt.params);\n+            assert vec::len(item_tk.kinds) == vec::len(tpt.params);\n             for k_need: ast::kind in item_tk.kinds {\n                 let t = tpt.params.(i);\n                 let k = ty::type_kind(tcx, t);"}, {"sha": "7a9b59357e4411942c03b7e6c0042e309d3699d8", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -19,7 +19,7 @@ import syntax::ast::respan;\n import middle::ty::constr_table;\n import syntax::visit;\n import visit::vt;\n-import std::ivec;\n+import std::vec;\n import std::int;\n import std::map::hashmap;\n import std::list;\n@@ -401,7 +401,7 @@ fn visit_expr_with_scope(x: &@ast::expr, sc: &scopes, v: &vt[scopes]) {\n \n fn follow_import(e: &env, sc: &scopes, path: &[ident], sp: &span) ->\n    option::t[def] {\n-    let path_len = ivec::len(path);\n+    let path_len = vec::len(path);\n     let dcur = lookup_in_scope_strict(e, sc, sp, path.(0), ns_module);\n     let i = 1u;\n     while true && option::is_some(dcur) {\n@@ -455,7 +455,7 @@ fn resolve_import(e: &env, it: &@ast::view_item, sc_in: &scopes) {\n       }\n     }\n     e.imports.insert(defid.node, resolving(it.span));\n-    let n_idents = ivec::len(ids);\n+    let n_idents = vec::len(ids);\n     let end_id = ids.(n_idents - 1u);\n     // Ignore the current scope if this import would shadow itself.\n     let sc =\n@@ -573,7 +573,7 @@ fn mk_unresolved_msg(id: &ident, kind: &str) -> str {\n // Lookup helpers\n fn lookup_path_strict(e: &env, sc: &scopes, sp: &span, pth: &ast::path_,\n                       ns: namespace) -> option::t[def] {\n-    let n_idents = ivec::len(pth.idents);\n+    let n_idents = vec::len(pth.idents);\n     let headns = if n_idents == 1u { ns } else { ns_module };\n \n     let first_scope;\n@@ -783,7 +783,7 @@ fn lookup_in_obj(name: &ident, ob: &ast::_obj, ty_params: &[ast::ty_param],\n \n fn lookup_in_block(name: &ident, b: &ast::blk_, pos: uint, loc_pos: uint,\n                    ns: namespace) -> option::t[def] {\n-    let i = ivec::len(b.stmts);\n+    let i = vec::len(b.stmts);\n     while i > 0u {\n         i -= 1u;\n         let st = b.stmts.(i);\n@@ -792,7 +792,7 @@ fn lookup_in_block(name: &ident, b: &ast::blk_, pos: uint, loc_pos: uint,\n             alt d.node {\n               ast::decl_local(locs) {\n                 if i <= pos {\n-                    let j = ivec::len(locs);\n+                    let j = vec::len(locs);\n                     while j > 0u {\n                         j -= 1u;\n                         let loc = locs.(j);\n@@ -998,11 +998,11 @@ fn lookup_glob_in_mod(e: &env, info: @indexed_mod, sp: &span, id: &ident,\n         }\n \n         let matches =\n-            ivec::filter_map(bind lookup_in_mod_(e, _, sp, id, ns, dr),\n+            vec::filter_map(bind lookup_in_mod_(e, _, sp, id, ns, dr),\n                              { info.glob_imports });\n-        if ivec::len(matches) == 0u {\n+        if vec::len(matches) == 0u {\n             ret none;\n-        } else if (ivec::len(matches) == 1u) {\n+        } else if (vec::len(matches) == 1u) {\n             ret some(matches.(0).def);\n         } else {\n             for match: glob_imp_def in matches {\n@@ -1271,20 +1271,20 @@ fn check_arm(e: &@env, a: &ast::arm, x: &(), v: &vt[()]) {\n     let ch0 = checker(*e, \"binding\");\n     check_pat(ch0, a.pats.(0));\n     let seen0 = ch0.seen;\n-    let i = ivec::len(a.pats);\n+    let i = vec::len(a.pats);\n     while i > 1u {\n         i -= 1u;\n         let ch = checker(*e, \"binding\");\n         check_pat(ch, a.pats.(i));\n \n         // Ensure the bindings introduced in this pattern are the same as in\n         // the first pattern.\n-        if ivec::len(ch.seen) != ivec::len(seen0) {\n+        if vec::len(ch.seen) != vec::len(seen0) {\n             e.sess.span_err(a.pats.(i).span,\n                             \"inconsistent number of bindings\");\n         } else {\n             for name: ident in ch.seen {\n-                if is_none(ivec::find(bind str::eq(name, _), seen0)) {\n+                if is_none(vec::find(bind str::eq(name, _), seen0)) {\n                     // Fight the alias checker\n                     let name_ = name;\n                     e.sess.span_err(a.pats.(i).span,"}, {"sha": "784df07ae4b8b4f731a4318710fb28d6271ccc9d", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -26,7 +26,7 @@ import syntax::codemap::span;\n import syntax::util::interner;\n import util::common;\n \n-import std::ivec;\n+import std::vec;\n import std::map::hashmap;\n import std::option::none;\n import std::option::some;\n@@ -138,10 +138,10 @@ fn largest_variants(ccx : &@crate_ctxt, tag_id : &ast::def_id) -> [uint] {\n     // Throw out any variant that we know has size and alignment at least as\n     // small as some other variant.\n     let i = 0u;\n-    while i < ivec::len(ranges) - 1u {\n+    while i < vec::len(ranges) - 1u {\n         if candidates.(i) {\n             let j = i + 1u;\n-            while (j < ivec::len(ranges)) {\n+            while (j < vec::len(ranges)) {\n                 if candidates.(j) {\n                     if ranges.(i).size.bounded && ranges.(i).align.bounded &&\n                             ranges.(j).size.bounded &&\n@@ -166,7 +166,7 @@ fn largest_variants(ccx : &@crate_ctxt, tag_id : &ast::def_id) -> [uint] {\n     // Return the resulting set.\n     let result = ~[];\n     i = 0u;\n-    while i < ivec::len(candidates) {\n+    while i < vec::len(candidates) {\n         if candidates.(i) { result += ~[i]; }\n         i += 1u;\n     }\n@@ -208,7 +208,7 @@ fn compute_static_tag_size(ccx : &@crate_ctxt, largest_variants : &[uint],\n     // Add space for the tag if applicable.\n     // FIXME (issue #792): This is wrong. If the tag starts with an 8 byte\n     // aligned quantity, we don't align it.\n-    if ivec::len(variants) > 1u {\n+    if vec::len(variants) > 1u {\n         max_size += 4u16;\n         max_align = 4u8;\n     }\n@@ -224,11 +224,11 @@ tag tag_kind {\n \n fn tag_kind(ccx : &@crate_ctxt, did : &ast::def_id) -> tag_kind {\n     let variants = ty::tag_variants(ccx.tcx, did);\n-    if ivec::len(variants) == 0u { ret tk_complex; }\n+    if vec::len(variants) == 0u { ret tk_complex; }\n     for v : ty::variant_info in variants {\n-        if ivec::len(v.args) > 0u { ret tk_complex; }\n+        if vec::len(v.args) > 0u { ret tk_complex; }\n     }\n-    if ivec::len(variants) == 1u { ret tk_unit; }\n+    if vec::len(variants) == 1u { ret tk_unit; }\n     ret tk_enum;\n }\n \n@@ -272,7 +272,7 @@ fn add_u16(dest : &mutable [u8], val : u16) {\n }\n \n fn add_substr(dest : &mutable [u8], src : &[u8]) {\n-    add_u16(dest, ivec::len(src) as u16);\n+    add_u16(dest, vec::len(src) as u16);\n     dest += src;\n }\n \n@@ -326,10 +326,10 @@ fn shape_of(ccx : &@crate_ctxt, t : ty::t) -> [u8] {\n             }\n             add_u16(sub, id as u16);\n \n-            add_u16(sub, ivec::len(tps) as u16);\n+            add_u16(sub, vec::len(tps) as u16);\n             for tp : ty::t in tps {\n                 let subshape = shape_of(ccx, tp);\n-                add_u16(sub, ivec::len(subshape) as u16);\n+                add_u16(sub, vec::len(subshape) as u16);\n                 sub += subshape;\n             }\n \n@@ -388,7 +388,7 @@ fn shape_of(ccx : &@crate_ctxt, t : ty::t) -> [u8] {\n \n         s += ~[shape_res];\n         add_u16(s, id as u16);\n-        add_u16(s, ivec::len(tps) as u16);\n+        add_u16(s, vec::len(tps) as u16);\n \n         let sub = ~[];\n         for tp : ty::t in tps { add_substr(s, sub); }\n@@ -429,12 +429,12 @@ fn gen_tag_shapes(ccx : &@crate_ctxt) -> ValueRef {\n     // must do this first.\n     let i = 0u;\n     let data = ~[]; let offsets = ~[];\n-    while (i < ivec::len(ccx.shape_cx.tag_order)) {\n+    while (i < vec::len(ccx.shape_cx.tag_order)) {\n         let did = ccx.shape_cx.tag_order.(i);\n         let variants = ty::tag_variants(ccx.tcx, did);\n \n         for v : ty::variant_info in variants {\n-            offsets += ~[ivec::len(data) as u16];\n+            offsets += ~[vec::len(data) as u16];\n \n             let variant_shape = shape_of_variant(ccx, v);\n             add_substr(data, variant_shape);\n@@ -449,14 +449,14 @@ fn gen_tag_shapes(ccx : &@crate_ctxt) -> ValueRef {\n \n     let header = ~[]; let info = ~[];\n     let header_sz = 2u16 * ccx.shape_cx.next_tag_id;\n-    let data_sz = ivec::len(data) as u16;\n+    let data_sz = vec::len(data) as u16;\n \n     let info_sz = 0u16;\n     for did_ : ast::def_id in ccx.shape_cx.tag_order {\n         let did = did_;    // Satisfy alias checker.\n         let variants = ty::tag_variants(ccx.tcx, did);\n         add_u16(header, header_sz + info_sz);\n-        info_sz += 2u16 * ((ivec::len(variants) as u16) + 2u16) + 3u16;\n+        info_sz += 2u16 * ((vec::len(variants) as u16) + 2u16) + 3u16;\n     }\n \n     // Construct the info tables, which contain offsets to the shape of each\n@@ -468,14 +468,14 @@ fn gen_tag_shapes(ccx : &@crate_ctxt) -> ValueRef {\n     for did_ : ast::def_id in ccx.shape_cx.tag_order {\n         let did = did_;    // Satisfy alias checker.\n         let variants = ty::tag_variants(ccx.tcx, did);\n-        add_u16(info, ivec::len(variants) as u16);\n+        add_u16(info, vec::len(variants) as u16);\n \n         // Construct the largest-variants table.\n         add_u16(info, header_sz + info_sz + data_sz +\n-                (ivec::len(lv_table) as u16));\n+                (vec::len(lv_table) as u16));\n \n         let lv = largest_variants(ccx, did);\n-        add_u16(lv_table, ivec::len(lv) as u16);\n+        add_u16(lv_table, vec::len(lv) as u16);\n         for v : uint in lv { add_u16(lv_table, v as u16); }\n \n         // Determine whether the tag has dynamic size.\n@@ -504,10 +504,10 @@ fn gen_tag_shapes(ccx : &@crate_ctxt) -> ValueRef {\n         }\n     }\n \n-    assert (i == ivec::len(offsets));\n-    assert (header_sz == (ivec::len(header) as u16));\n-    assert (info_sz == (ivec::len(info) as u16));\n-    assert (data_sz == (ivec::len(data) as u16));\n+    assert (i == vec::len(offsets));\n+    assert (header_sz == (vec::len(header) as u16));\n+    assert (info_sz == (vec::len(info) as u16));\n+    assert (data_sz == (vec::len(data) as u16));\n \n     header += info;\n     header += data;"}, {"sha": "c800b9327b0a24bc9fc017c48730e576964611e6", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -262,7 +262,7 @@ fn type_of_inner(cx: &@crate_ctxt, sp: &span, t: &ty::t) -> TypeRef {\n \n fn type_of_tag(cx: &@crate_ctxt, sp: &span, did: &ast::def_id, t: &ty::t) ->\n    TypeRef {\n-    let degen = std::ivec::len(ty::tag_variants(cx.tcx, did)) == 1u;\n+    let degen = std::vec::len(ty::tag_variants(cx.tcx, did)) == 1u;\n     if ty::type_has_dynamic_size(cx.tcx, t) {\n         if degen { ret T_i8(); } else { ret T_opaque_tag(cx.tn); }\n     } else {\n@@ -279,7 +279,7 @@ fn type_of_ty_param_kinds_and_ty(lcx: @local_ctxt, sp: &span,\n     alt ty::struct(lcx.ccx.tcx, tpt.ty) {\n       ty::ty_fn(_, _, _, _, _) {\n         let llfnty = type_of_fn_from_ty(lcx.ccx, sp, tpt.ty,\n-                                        std::ivec::len(tpt.kinds));\n+                                        std::vec::len(tpt.kinds));\n         ret T_fn_pair(*lcx.ccx, llfnty);\n       }\n       _ {\n@@ -382,7 +382,7 @@ fn get_extern_const(externs: &hashmap[str, ValueRef], llmod: ModuleRef,\n \n fn get_simple_extern_fn(externs: &hashmap[str, ValueRef], llmod: ModuleRef,\n                         name: &str, n_args: int) -> ValueRef {\n-    let inputs = std::ivec::init_elt[TypeRef](T_int(), n_args as uint);\n+    let inputs = std::vec::init_elt[TypeRef](T_int(), n_args as uint);\n     let output = T_int();\n     let t = T_fn(inputs, output);\n     ret get_extern_fn(externs, llmod, name, lib::llvm::LLVMCCallConv, t);\n@@ -392,7 +392,7 @@ fn trans_native_call(b: &builder, glues: @glue_fns, lltaskptr: ValueRef,\n                      externs: &hashmap[str, ValueRef], tn: &type_names,\n                      llmod: ModuleRef, name: &str, pass_task: bool,\n                      args: &[ValueRef]) -> ValueRef {\n-    let n: int = std::ivec::len[ValueRef](args) as int;\n+    let n: int = std::vec::len[ValueRef](args) as int;\n     let llnative: ValueRef = get_simple_extern_fn(externs, llmod, name, n);\n     let call_args: [ValueRef] = ~[];\n     for a: ValueRef in args { call_args += ~[b.ZExtOrBitCast(a, T_int())]; }\n@@ -607,7 +607,7 @@ fn dynamic_size_of(cx: &@block_ctxt, t: ty::t) -> result {\n         }\n         let max_size_val = bcx.build.Load(max_size);\n         let total_size =\n-            if std::ivec::len(variants) != 1u {\n+            if std::vec::len(variants) != 1u {\n                 bcx.build.Add(max_size_val, llsize_of(T_int()))\n             } else { max_size_val };\n         ret rslt(bcx, total_size);\n@@ -715,7 +715,7 @@ fn GEP_tup_like(cx: &@block_ctxt, t: &ty::t, base: ValueRef, ixs: &[int]) ->\n \n     fn split_type(ccx: &@crate_ctxt, t: &ty::t, ixs: &[int], n: uint) ->\n        {prefix: [ty::t], target: ty::t} {\n-        let len: uint = std::ivec::len[int](ixs);\n+        let len: uint = std::vec::len[int](ixs);\n         // We don't support 0-index or 1-index GEPs: The former is nonsense\n         // and the latter would only be meaningful if we supported non-0\n         // values for the 0th index (we don't).\n@@ -957,8 +957,8 @@ fn get_derived_tydesc(cx: &@block_ctxt, t: &ty::t, escapes: bool,\n     let bcx = new_raw_block_ctxt(cx.fcx, cx.fcx.llderivedtydescs);\n     let n_params: uint = ty::count_ty_params(bcx_tcx(bcx), t);\n     let tys = linearize_ty_params(bcx, t);\n-    assert (n_params == std::ivec::len[uint](tys.params));\n-    assert (n_params == std::ivec::len[ValueRef](tys.descs));\n+    assert (n_params == std::vec::len[uint](tys.params));\n+    assert (n_params == std::vec::len[ValueRef](tys.descs));\n     let root_ti = get_static_tydesc(bcx, t, tys.params);\n     static_ti = some[@tydesc_info](root_ti);\n     lazily_emit_all_tydesc_glue(cx, static_ti);\n@@ -1017,7 +1017,7 @@ fn get_tydesc(cx: &@block_ctxt, orig_t: &ty::t, escapes: bool,\n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n     alt ty::type_param(bcx_tcx(cx), t) {\n       some(id) {\n-        if id < std::ivec::len(cx.fcx.lltydescs) {\n+        if id < std::vec::len(cx.fcx.lltydescs) {\n             ret rslt(cx, cx.fcx.lltydescs.(id));\n         }\n         else {\n@@ -1153,15 +1153,15 @@ fn make_generic_glue_inner(cx: &@local_ctxt, sp: &span, t: &ty::t,\n     if ty::type_has_dynamic_size(cx.ccx.tcx, t) {\n         llty = T_ptr(T_i8());\n     } else { llty = T_ptr(type_of(cx.ccx, sp, t)); }\n-    let ty_param_count = std::ivec::len[uint](ty_params);\n+    let ty_param_count = std::vec::len[uint](ty_params);\n     let lltyparams = llvm::LLVMGetParam(llfn, 3u);\n     let copy_args_bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n     let lltydescs = ~[mutable];\n     let p = 0u;\n     while p < ty_param_count {\n         let llparam = copy_args_bcx.build.GEP(lltyparams, ~[C_int(p as int)]);\n         llparam = copy_args_bcx.build.Load(llparam);\n-        std::ivec::grow_set(lltydescs, ty_params.(p), 0 as ValueRef, llparam);\n+        std::vec::grow_set(lltydescs, ty_params.(p), 0 as ValueRef, llparam);\n         p += 1u;\n     }\n \n@@ -1524,7 +1524,7 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: &ast::def_id,\n     let val_llty =\n         lib::llvm::fn_ty_param_tys(llvm::LLVMGetElementType\n                                    (llvm::LLVMTypeOf(dtor_addr)))\n-                                    .(std::ivec::len(args));\n+                                    .(std::vec::len(args));\n     let val_cast = cx.build.BitCast(val.val, val_llty);\n     cx.build.FastCall(dtor_addr, args + ~[val_cast]);\n \n@@ -1800,7 +1800,7 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: &ty::t,\n     fn iter_variant(cx: @block_ctxt, a_tup: ValueRef,\n                     variant: &ty::variant_info, tps: &[ty::t],\n                     tid: &ast::def_id, f: &val_and_ty_fn) -> result {\n-        if std::ivec::len[ty::t](variant.args) == 0u {\n+        if std::vec::len[ty::t](variant.args) == 0u {\n             ret rslt(cx, C_nil());\n         }\n         let fn_ty = variant.ctor_ty;\n@@ -1855,7 +1855,7 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: &ty::t,\n       }\n       ty::ty_tag(tid, tps) {\n         let variants = ty::tag_variants(bcx_tcx(cx), tid);\n-        let n_variants = std::ivec::len(variants);\n+        let n_variants = std::vec::len(variants);\n \n         // Cast the tags to types we can GEP into.\n         if n_variants == 1u {\n@@ -3309,8 +3309,8 @@ fn autoderef(cx: &@block_ctxt, v: ValueRef, t: &ty::t) -> result_t {\n           }\n           ty::ty_tag(did, tps) {\n             let variants = ty::tag_variants(ccx.tcx, did);\n-            if std::ivec::len(variants) != 1u ||\n-                   std::ivec::len(variants.(0).args) != 1u {\n+            if std::vec::len(variants) != 1u ||\n+                   std::vec::len(variants.(0).args) != 1u {\n                 break;\n             }\n             t1 =\n@@ -3387,13 +3387,13 @@ fn join_results(parent_cx: &@block_ctxt, t: TypeRef, ins: &[result]) ->\n             bbs += ~[r.bcx.llbb];\n         }\n     }\n-    alt std::ivec::len[result](live) {\n+    alt std::vec::len[result](live) {\n       0u {\n         // No incoming edges are live, so we're in dead-code-land.\n         // Arbitrarily pick the first dead edge, since the caller\n         // is just going to propagate it outward.\n \n-        assert (std::ivec::len[result](ins) >= 1u);\n+        assert (std::vec::len[result](ins) >= 1u);\n         ret ins.(0);\n       }\n       _ {/* fall through */ }\n@@ -3517,10 +3517,10 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n \n     // Make a vector that contains ty_param_count copies of tydesc_ty.\n     // (We'll need room for that many tydescs in the closure.)\n-    let ty_param_count = std::ivec::len(lltydescs);\n+    let ty_param_count = std::vec::len(lltydescs);\n     let tydesc_ty: ty::t = ty::mk_type(bcx_tcx(bcx));\n     let captured_tys: [ty::t] =\n-        std::ivec::init_elt(tydesc_ty, ty_param_count);\n+        std::vec::init_elt(tydesc_ty, ty_param_count);\n \n     // Get all the types we've got (some of which we synthesized\n     // ourselves) into a vector.  The whole things ends up looking\n@@ -3662,7 +3662,7 @@ fn load_environment(enclosing_cx: &@block_ctxt, fcx: &@fn_ctxt,\n     // Populate the type parameters from the environment. We need to\n     // do this first because the tydescs are needed to index into\n     // the bindings if they are dynamically sized.\n-    let tydesc_count = std::ivec::len(enclosing_cx.fcx.lltydescs);\n+    let tydesc_count = std::vec::len(enclosing_cx.fcx.lltydescs);\n     let lltydescs = find_environment_tydescs(bcx, envty, llclosure);\n     let i = 0u;\n     while i < tydesc_count {\n@@ -3865,7 +3865,7 @@ fn lval_generic_fn(cx: &@block_ctxt, tpt: &ty::ty_param_kinds_and_ty,\n         lv = lval_val(cx, trans_external_path(cx, fn_id, tpt));\n     }\n     let tys = ty::node_id_to_type_params(bcx_tcx(cx), id);\n-    if std::ivec::len[ty::t](tys) != 0u {\n+    if std::vec::len[ty::t](tys) != 0u {\n         let bcx = lv.res.bcx;\n         let tydescs: [ValueRef] = ~[];\n         let tis: [option::t[@tydesc_info]] = ~[];\n@@ -3946,7 +3946,7 @@ fn trans_var(cx: &@block_ctxt, sp: &span, id: ast::node_id) ->\n             let lltagty = type_of_tag(ccx, sp, tid, tag_ty);\n             let bcx = alloc_result.bcx;\n             let lltagptr = bcx.build.PointerCast(lltagblob, T_ptr(lltagty));\n-            if std::ivec::len(ty::tag_variants(ccx.tcx, tid)) != 1u {\n+            if std::vec::len(ty::tag_variants(ccx.tcx, tid)) != 1u {\n                 let lldiscrim_gv = lookup_discriminant(bcx.fcx.lcx, tid, vid);\n                 let lldiscrim = bcx.build.Load(lldiscrim_gv);\n                 let lldiscrimptr =\n@@ -4165,8 +4165,8 @@ fn trans_lval(cx: &@block_ctxt, e: &@ast::expr) -> lval_result {\n     alt lv.generic {\n       some(gi) {\n         let t = ty::expr_ty(bcx_tcx(cx), e);\n-        let n_args = std::ivec::len(ty::ty_fn_args(bcx_tcx(cx), t));\n-        let args = std::ivec::init_elt(none[@ast::expr], n_args);\n+        let n_args = std::vec::len(ty::ty_fn_args(bcx_tcx(cx), t));\n+        let args = std::vec::init_elt(none[@ast::expr], n_args);\n         let bound = trans_bind_1(lv.res.bcx, e, lv, args, e.id);\n         ret lval_val(bound.bcx, bound.val);\n       }\n@@ -4463,8 +4463,8 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n       }\n     }\n \n-    let ty_param_count = std::ivec::len(lltydescs);\n-    if std::ivec::len(bound) == 0u && ty_param_count == 0u {\n+    let ty_param_count = std::vec::len(lltydescs);\n+    if std::vec::len(bound) == 0u && ty_param_count == 0u {\n         // Trivial 'binding': just return the static pair-ptr.\n         ret f_res.res;\n     }\n@@ -4794,7 +4794,7 @@ fn trans_vec(cx: &@block_ctxt, args: &[@ast::expr], id: ast::node_id) ->\n     let unit_sz = size_of(bcx, unit_ty);\n     bcx = unit_sz.bcx;\n     let data_sz =\n-        bcx.build.Mul(C_uint(std::ivec::len[@ast::expr](args)), unit_sz.val);\n+        bcx.build.Mul(C_uint(std::vec::len[@ast::expr](args)), unit_sz.val);\n     // FIXME: pass tydesc properly.\n \n     let vec_val =\n@@ -4807,8 +4807,8 @@ fn trans_vec(cx: &@block_ctxt, args: &[@ast::expr], id: ast::node_id) ->\n     let body = bcx.build.GEP(vec_val, ~[C_int(0), C_int(abi::vec_elt_data)]);\n     let pseudo_tup_ty =\n         ty::mk_tup(bcx_tcx(cx),\n-                       std::ivec::init_elt[ty::t](unit_ty,\n-                                                  std::ivec::len(args)));\n+                       std::vec::init_elt[ty::t](unit_ty,\n+                                                  std::vec::len(args)));\n     let i: int = 0;\n     for e: @ast::expr in args {\n         let src = trans_lval(bcx, e);\n@@ -4860,12 +4860,12 @@ fn trans_ivec(bcx: @block_ctxt, args: &[@ast::expr], id: ast::node_id) ->\n \n     add_clean_temp(bcx, llvecptr, typ);\n \n-    let lllen = bcx.build.Mul(C_uint(std::ivec::len(args)), unit_sz);\n+    let lllen = bcx.build.Mul(C_uint(std::vec::len(args)), unit_sz);\n     // Allocate the vector pieces and store length and allocated length.\n \n     let llfirsteltptr;\n-    if std::ivec::len(args) > 0u &&\n-           std::ivec::len(args) <= abi::ivec_default_length {\n+    if std::vec::len(args) > 0u &&\n+           std::vec::len(args) <= abi::ivec_default_length {\n         // Interior case.\n \n         bcx.build.Store(lllen,\n@@ -4890,7 +4890,7 @@ fn trans_ivec(bcx: @block_ctxt, args: &[@ast::expr], id: ast::node_id) ->\n         let llstubptr = bcx.build.PointerCast(llvecptr, T_ptr(llstubty));\n         bcx.build.Store(C_int(0), bcx.build.InBoundsGEP(llstubptr, stub_z));\n         let llheapty = T_ivec_heap_part(llunitty);\n-        if std::ivec::len(args) == 0u {\n+        if std::vec::len(args) == 0u {\n             // Null heap pointer indicates a zero-length vector.\n \n             bcx.build.Store(llalen, bcx.build.InBoundsGEP(llstubptr, stub_a));\n@@ -5594,9 +5594,9 @@ fn trans_block_cleanups(cx: &@block_ctxt, cleanup_cx: &@block_ctxt) ->\n    @block_ctxt {\n     let bcx = cx;\n     if cleanup_cx.kind == NON_SCOPE_BLOCK {\n-        assert (std::ivec::len[cleanup](cleanup_cx.cleanups) == 0u);\n+        assert (std::vec::len[cleanup](cleanup_cx.cleanups) == 0u);\n     }\n-    let i = std::ivec::len[cleanup](cleanup_cx.cleanups);\n+    let i = std::vec::len[cleanup](cleanup_cx.cleanups);\n     while i > 0u {\n         i -= 1u;\n         let c = cleanup_cx.cleanups.(i);\n@@ -5949,7 +5949,7 @@ fn populate_fn_ctxt_from_llself(fcx: @fn_ctxt, llself: val_self_pair) {\n     // its magic.\n \n     let fields_tup_ty = ty::mk_tup(fcx.lcx.ccx.tcx, field_tys);\n-    let n_typarams = std::ivec::len[ast::ty_param](bcx.fcx.lcx.obj_typarams);\n+    let n_typarams = std::vec::len[ast::ty_param](bcx.fcx.lcx.obj_typarams);\n     let llobj_box_ty: TypeRef = T_obj_ptr(*bcx_ccx(bcx), n_typarams);\n     let box_cell =\n         bcx.build.GEP(llself.v, ~[C_int(0), C_int(abi::obj_field_box)]);\n@@ -6145,7 +6145,7 @@ fn trans_res_ctor(cx: @local_ctxt, sp: &span, dtor: &ast::_fn,\n fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n                      variant: &ast::variant, index: int, is_degen: bool,\n                      ty_params: &[ast::ty_param]) {\n-    if std::ivec::len[ast::variant_arg](variant.node.args) == 0u {\n+    if std::vec::len[ast::variant_arg](variant.node.args) == 0u {\n         ret; // nullary constructors are just constants\n \n     }\n@@ -6298,7 +6298,7 @@ fn trans_item(cx: @local_ctxt, item: &ast::item) {\n       }\n       ast::item_tag(variants, tps) {\n         let sub_cx = extend_path(cx, item.ident);\n-        let degen = std::ivec::len(variants) == 1u;\n+        let degen = std::vec::len(variants) == 1u;\n         let i = 0;\n         for variant: ast::variant in variants {\n             trans_tag_variant(sub_cx, item.id, variant, i, degen, tps);\n@@ -6336,12 +6336,12 @@ fn decl_fn_and_pair_full(ccx: &@crate_ctxt, sp: &span, path: &[str],\n                          flav: str, ty_params: &[ast::ty_param],\n                          node_id: ast::node_id, node_type: ty::t) {\n     let llfty = type_of_fn_from_ty(ccx, sp, node_type,\n-                                   std::ivec::len(ty_params));\n+                                   std::vec::len(ty_params));\n     alt ty::struct(ccx.tcx, node_type) {\n       ty::ty_fn(proto, inputs, output, _, _) {\n         llfty =\n             type_of_fn(ccx, sp, proto, inputs, output,\n-                       std::ivec::len[ast::ty_param](ty_params));\n+                       std::vec::len[ast::ty_param](ty_params));\n       }\n       _ { ccx.sess.bug(\"decl_fn_and_pair(): fn item doesn't have fn type!\"); }\n     }\n@@ -6374,7 +6374,7 @@ fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span,\n \n     let main_mode = alt ty::struct(ccx.tcx, main_node_type) {\n       ty::ty_fn(_, args, _ ,_ ,_) {\n-        if std::ivec::len(args) == 0u {\n+        if std::vec::len(args) == 0u {\n             mm_nil\n         } else {\n             alt ty::struct(ccx.tcx, args.(0).ty) {\n@@ -6550,7 +6550,7 @@ fn native_fn_ty_param_count(cx: &@crate_ctxt, id: ast::node_id) -> uint {\n                         actually a fn\");\n       }\n       ast::native_item_fn(_, _, tps) {\n-        count = std::ivec::len[ast::ty_param](tps);\n+        count = std::vec::len[ast::ty_param](tps);\n       }\n     }\n     ret count;\n@@ -6837,7 +6837,7 @@ fn collect_tag_ctor(ccx: @crate_ctxt, i: &@ast::item, pt: &[str],\n     alt i.node {\n       ast::item_tag(variants, tps) {\n         for variant: ast::variant in variants {\n-            if std::ivec::len(variant.node.args) != 0u {\n+            if std::vec::len(variant.node.args) != 0u {\n                 decl_fn_and_pair(ccx, i.span, new_pt + ~[variant.node.name],\n                                  \"tag\", tps, variant.node.id);\n             }\n@@ -6863,7 +6863,7 @@ fn trans_constant(ccx: @crate_ctxt, it: &@ast::item, pt: &[str],\n     alt it.node {\n       ast::item_tag(variants, _) {\n         let i = 0u;\n-        let n_variants = std::ivec::len[ast::variant](variants);\n+        let n_variants = std::vec::len[ast::variant](variants);\n         while i < n_variants {\n             let variant = variants.(i);\n             let p = new_pt + ~[it.ident, variant.node.name, \"discrim\"];\n@@ -7032,7 +7032,7 @@ fn create_crate_map(ccx: &@crate_ctxt) -> ValueRef {\n         mapname = ccx.link_meta.name;\n     } else { mapname = \"toplevel\"; }\n     let sym_name = \"_rust_crate_map_\" + mapname;\n-    let arrtype = T_array(T_int(), std::ivec::len[ValueRef](subcrates));\n+    let arrtype = T_array(T_int(), std::vec::len[ValueRef](subcrates));\n     let maptype = T_struct(~[T_int(), arrtype]);\n     let map = llvm::LLVMAddGlobal(ccx.llmod, maptype, str::buf(sym_name));\n     llvm::LLVMSetLinkage(map,"}, {"sha": "0f97432b3619503815e755749793d8051d993d51", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,5 +1,5 @@\n import std::str;\n-import std::ivec;\n+import std::vec;\n import std::option;\n import option::some;\n import option::none;\n@@ -85,8 +85,8 @@ fn enter_match(m: &match, col: uint, val: ValueRef, e: &enter_pat) -> match {\n         alt e(br.pats.(col)) {\n           some(sub) {\n             let pats =\n-                ivec::slice(br.pats, 0u, col) + sub +\n-                    ivec::slice(br.pats, col + 1u, ivec::len(br.pats));\n+                vec::slice(br.pats, 0u, col) + sub +\n+                    vec::slice(br.pats, col + 1u, vec::len(br.pats));\n             let new_br = @{pats: pats with *br};\n             result += ~[new_br];\n             bind_for_pat(br.pats.(col), new_br, val);\n@@ -118,7 +118,7 @@ fn enter_opt(ccx: &@crate_ctxt, m: &match, opt: &opt, col: uint,\n           ast::pat_lit(l) {\n             ret if opt_eq(lit(l), opt) { some(~[]) } else { none };\n           }\n-          _ { ret some(ivec::init_elt(dummy, size)); }\n+          _ { ret some(vec::init_elt(dummy, size)); }\n         }\n     }\n     ret enter_match(m, col, val, bind e(ccx, dummy, opt, tag_size, _));\n@@ -141,7 +141,7 @@ fn enter_rec(m: &match, col: uint, fields: &[ast::ident], val: ValueRef) ->\n             }\n             ret some(pats);\n           }\n-          _ { ret some(ivec::init_elt(dummy, ivec::len(fields))); }\n+          _ { ret some(vec::init_elt(dummy, vec::len(fields))); }\n         }\n     }\n     ret enter_match(m, col, val, bind e(dummy, fields, _));\n@@ -153,7 +153,7 @@ fn enter_tup(m: &match, col: uint, val: ValueRef, n_elts: uint) -> match {\n         -> option::t[[@ast::pat]] {\n         alt p.node {\n           ast::pat_tup(elts) { ret some(elts); }\n-          _ { ret some(ivec::init_elt(dummy, n_elts)); }\n+          _ { ret some(vec::init_elt(dummy, n_elts)); }\n         }\n     }\n     ret enter_match(m, col, val, bind e(dummy, n_elts, _));\n@@ -198,8 +198,8 @@ fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n     let variants = ty::tag_variants(ccx.tcx, vdefs.tg);\n     let args = ~[];\n     let size =\n-        ivec::len(ty::tag_variant_with_id(ccx.tcx, vdefs.tg, vdefs.var).args);\n-    if size > 0u && ivec::len(variants) != 1u {\n+        vec::len(ty::tag_variant_with_id(ccx.tcx, vdefs.tg, vdefs.var).args);\n+    if size > 0u && vec::len(variants) != 1u {\n         let tagptr =\n             bcx.build.PointerCast(val,\n                                   trans_common::T_opaque_tag_ptr(ccx.tn));\n@@ -223,7 +223,7 @@ fn collect_record_fields(m: &match, col: uint) -> [ast::ident] {\n         alt br.pats.(col).node {\n           ast::pat_rec(fs, _) {\n             for f: ast::field_pat in fs {\n-                if !ivec::any(bind str::eq(f.ident, _), fields) {\n+                if !vec::any(bind str::eq(f.ident, _), fields) {\n                     fields += ~[f.ident];\n                 }\n             }\n@@ -252,7 +252,7 @@ type exit_node = {bound: bind_map, from: BasicBlockRef, to: BasicBlockRef};\n type mk_fail = fn() -> BasicBlockRef;\n \n fn pick_col(m: &match) -> uint {\n-    let scores = ivec::init_elt_mut(0u, ivec::len(m.(0).pats));\n+    let scores = vec::init_elt_mut(0u, vec::len(m.(0).pats));\n     for br: match_branch in m {\n         let i = 0u;\n         for p: @ast::pat in br.pats {\n@@ -283,17 +283,17 @@ fn pick_col(m: &match) -> uint {\n \n fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n                     f: &mk_fail, exits: &mutable [exit_node]) {\n-    if ivec::len(m) == 0u { bcx.build.Br(f()); ret; }\n-    if ivec::len(m.(0).pats) == 0u {\n+    if vec::len(m) == 0u { bcx.build.Br(f()); ret; }\n+    if vec::len(m.(0).pats) == 0u {\n         exits += ~[{bound: m.(0).bound, from: bcx.llbb, to: m.(0).body}];\n         bcx.build.Br(m.(0).body);\n         ret;\n     }\n \n     let col = pick_col(m);\n     let val = vals.(col);\n-    let vals_left = ivec::slice(vals, 0u, col) +\n-        ivec::slice(vals, col + 1u, ivec::len(vals));\n+    let vals_left = vec::slice(vals, 0u, col) +\n+        vec::slice(vals, col + 1u, vec::len(vals));\n     let ccx = bcx.fcx.lcx.ccx;\n     let pat_id = 0;\n     for br: match_branch in m {\n@@ -304,7 +304,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n \n     let rec_fields = collect_record_fields(m, col);\n     // Separate path for extracting and binding record fields\n-    if ivec::len(rec_fields) > 0u {\n+    if vec::len(rec_fields) > 0u {\n         let rec_ty = ty::node_id_to_monotype(ccx.tcx, pat_id);\n         let fields =\n             alt ty::struct(ccx.tcx, rec_ty) { ty::ty_rec(fields) { fields } };\n@@ -324,7 +324,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n     if any_tup_pat(m, col) {\n         let tup_ty = ty::node_id_to_monotype(ccx.tcx, pat_id);\n         let n_tup_elts = alt ty::struct(ccx.tcx, tup_ty) {\n-          ty::ty_tup(elts) { ivec::len(elts) }\n+          ty::ty_tup(elts) { vec::len(elts) }\n         };\n         let tup_vals = ~[], i = 0u;\n         while i < n_tup_elts {\n@@ -355,10 +355,10 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n     tag branch_kind { no_branch; single; switch; compare; }\n     let kind = no_branch;\n     let test_val = val;\n-    if ivec::len(opts) > 0u {\n+    if vec::len(opts) > 0u {\n         alt opts.(0) {\n           var(_, vdef) {\n-            if ivec::len(ty::tag_variants(ccx.tcx, vdef.tg)) == 1u {\n+            if vec::len(ty::tag_variants(ccx.tcx, vdef.tg)) == 1u {\n                 kind = single;\n             } else {\n                 let tagptr = bcx.build.PointerCast\n@@ -381,7 +381,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n         };\n     let sw =\n         if kind == switch {\n-            bcx.build.Switch(test_val, else_cx.llbb, ivec::len(opts))\n+            bcx.build.Switch(test_val, else_cx.llbb, vec::len(opts))\n         } else { C_int(0) }; // Placeholder for when not using a switch\n \n      // Compile subtrees for each option\n@@ -410,7 +410,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n         alt opt {\n           var(_, vdef) {\n             let args = extract_variant_args(opt_cx, pat_id, vdef, val);\n-            size = ivec::len(args.vals);\n+            size = vec::len(args.vals);\n             unpacked = args.vals;\n             opt_cx = args.bcx;\n           }\n@@ -451,7 +451,7 @@ fn make_phi_bindings(bcx: &@block_ctxt, map: &[exit_node],\n                 }\n             }\n         }\n-        if ivec::len(vals) > 0u {\n+        if vec::len(vals) > 0u {\n             let phi = bcx.build.Phi(val_ty(vals.(0)), vals, llbbs);\n             bcx.fcx.lllocals.insert(item.val, phi);\n         } else { success = false; }\n@@ -537,7 +537,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: &@ast::pat, val: ValueRef,\n         }\n       }\n       ast::pat_tag(_, sub) {\n-        if ivec::len(sub) == 0u { ret bcx; }\n+        if vec::len(sub) == 0u { ret bcx; }\n         let vdefs = ast::variant_def_ids(ccx.tcx.def_map.get(pat.id));\n         let args = extract_variant_args(bcx, pat.id, vdefs, val);\n         let i = 0;"}, {"sha": "5a045e8fc04269b33e166fbd0039a6d8d4452f41", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -4,7 +4,7 @@\n */\n \n import std::int;\n-import std::ivec;\n+import std::vec;\n import std::str;\n import std::uint;\n import std::str::rustrt::sbuf;\n@@ -312,9 +312,9 @@ fn revoke_clean(cx: &@block_ctxt, val: ValueRef) {\n     if found == -1 { ret; }\n     // We found the cleanup and remove it\n     sc_cx.cleanups =\n-        std::ivec::slice(sc_cx.cleanups, 0u, found as uint) +\n-            std::ivec::slice(sc_cx.cleanups, (found as uint) + 1u,\n-                             std::ivec::len(sc_cx.cleanups));\n+        std::vec::slice(sc_cx.cleanups, 0u, found as uint) +\n+            std::vec::slice(sc_cx.cleanups, (found as uint) + 1u,\n+                             std::vec::len(sc_cx.cleanups));\n }\n \n fn get_res_dtor(ccx : &@crate_ctxt, sp : &span, did : &ast::def_id,\n@@ -424,8 +424,8 @@ fn val_str(tn: type_names, v: ValueRef) -> str { ret ty_str(tn, val_ty(v)); }\n fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef {\n     let elt_count = llvm::LLVMCountStructElementTypes(llstructty);\n     assert (n < elt_count);\n-    let elt_tys = std::ivec::init_elt(T_nil(), elt_count);\n-    llvm::LLVMGetStructElementTypes(llstructty, std::ivec::to_ptr(elt_tys));\n+    let elt_tys = std::vec::init_elt(T_nil(), elt_count);\n+    llvm::LLVMGetStructElementTypes(llstructty, std::vec::to_ptr(elt_tys));\n     ret llvm::LLVMGetElementType(elt_tys.(n));\n }\n \n@@ -509,8 +509,8 @@ fn T_size_t() -> TypeRef {\n }\n \n fn T_fn(inputs: &[TypeRef], output: TypeRef) -> TypeRef {\n-    ret llvm::LLVMFunctionType(output, std::ivec::to_ptr(inputs),\n-                               std::ivec::len[TypeRef](inputs), False);\n+    ret llvm::LLVMFunctionType(output, std::vec::to_ptr(inputs),\n+                               std::vec::len[TypeRef](inputs), False);\n }\n \n fn T_fn_pair(cx: &crate_ctxt, tfn: TypeRef) -> TypeRef {\n@@ -520,7 +520,7 @@ fn T_fn_pair(cx: &crate_ctxt, tfn: TypeRef) -> TypeRef {\n fn T_ptr(t: TypeRef) -> TypeRef { ret llvm::LLVMPointerType(t, 0u); }\n \n fn T_struct(elts: &[TypeRef]) -> TypeRef {\n-    ret llvm::LLVMStructType(std::ivec::to_ptr(elts), std::ivec::len(elts),\n+    ret llvm::LLVMStructType(std::vec::to_ptr(elts), std::vec::len(elts),\n                              False);\n }\n \n@@ -530,7 +530,7 @@ fn T_named_struct(name: &str) -> TypeRef {\n }\n \n fn set_struct_body(t: TypeRef, elts: &[TypeRef]) {\n-    llvm::LLVMStructSetBody(t, std::ivec::to_ptr(elts), std::ivec::len(elts),\n+    llvm::LLVMStructSetBody(t, std::vec::to_ptr(elts), std::vec::len(elts),\n                             False);\n }\n \n@@ -570,9 +570,9 @@ fn T_tydesc_field(cx: &crate_ctxt, field: int) -> TypeRef {\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n \n     let tydesc_elts: [TypeRef] =\n-        std::ivec::init_elt[TypeRef](T_nil(), abi::n_tydesc_fields as uint);\n+        std::vec::init_elt[TypeRef](T_nil(), abi::n_tydesc_fields as uint);\n     llvm::LLVMGetStructElementTypes(cx.tydesc_type,\n-                                    std::ivec::to_ptr[TypeRef](tydesc_elts));\n+                                    std::vec::to_ptr[TypeRef](tydesc_elts));\n     let t = llvm::LLVMGetElementType(tydesc_elts.(field));\n     ret t;\n }\n@@ -742,7 +742,7 @@ fn T_opaque_tag_ptr(tn: &type_names) -> TypeRef {\n }\n \n fn T_captured_tydescs(cx: &crate_ctxt, n: uint) -> TypeRef {\n-    ret T_struct(std::ivec::init_elt[TypeRef](T_ptr(cx.tydesc_type), n));\n+    ret T_struct(std::vec::init_elt[TypeRef](T_ptr(cx.tydesc_type), n));\n }\n \n fn T_obj_ptr(cx: &crate_ctxt, n_captured_tydescs: uint) -> TypeRef {\n@@ -845,28 +845,28 @@ fn C_zero_byte_arr(size: uint) -> ValueRef {\n     let i = 0u;\n     let elts: [ValueRef] = ~[];\n     while i < size { elts += ~[C_u8(0u)]; i += 1u; }\n-    ret llvm::LLVMConstArray(T_i8(), std::ivec::to_ptr(elts),\n-                             std::ivec::len(elts));\n+    ret llvm::LLVMConstArray(T_i8(), std::vec::to_ptr(elts),\n+                             std::vec::len(elts));\n }\n \n fn C_struct(elts: &[ValueRef]) -> ValueRef {\n-    ret llvm::LLVMConstStruct(std::ivec::to_ptr(elts), std::ivec::len(elts),\n+    ret llvm::LLVMConstStruct(std::vec::to_ptr(elts), std::vec::len(elts),\n                               False);\n }\n \n fn C_named_struct(T: TypeRef, elts: &[ValueRef]) -> ValueRef {\n-    ret llvm::LLVMConstNamedStruct(T, std::ivec::to_ptr(elts),\n-                                   std::ivec::len(elts));\n+    ret llvm::LLVMConstNamedStruct(T, std::vec::to_ptr(elts),\n+                                   std::vec::len(elts));\n }\n \n fn C_array(ty: TypeRef, elts: &[ValueRef]) -> ValueRef {\n-    ret llvm::LLVMConstArray(ty, std::ivec::to_ptr(elts),\n-                             std::ivec::len(elts));\n+    ret llvm::LLVMConstArray(ty, std::vec::to_ptr(elts),\n+                             std::vec::len(elts));\n }\n \n fn C_bytes(bytes : &[u8]) -> ValueRef {\n-    ret llvm::LLVMConstString(unsafe::reinterpret_cast(ivec::to_ptr(bytes)),\n-                              ivec::len(bytes), False);\n+    ret llvm::LLVMConstString(unsafe::reinterpret_cast(vec::to_ptr(bytes)),\n+                              vec::len(bytes), False);\n }\n \n fn C_shape(ccx : &@crate_ctxt, bytes : &[u8]) -> ValueRef {"}, {"sha": "25897669f5b6691d70f23621c2732ccd53e971ff", "filename": "src/comp/middle/trans_dps.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -12,7 +12,7 @@ import syntax::ast;\n import syntax::codemap::span;\n import util::ppaux;\n import trans_common::*;\n-import std::ivec;\n+import std::vec;\n import std::option::none;\n import std::option::some;\n import std::str;\n@@ -466,7 +466,7 @@ fn trans_lit_str_common(ccx: &@crate_ctxt, s: &str, expand: bool) ->\n         llheappartopt = none;\n     } else if (len < abi::ivec_default_length - 1u)\n      { // minus one for the null\n-        while ivec::len(array) < abi::ivec_default_length {\n+        while vec::len(array) < abi::ivec_default_length {\n             array += ~[tc::C_u8(0u)];\n         }\n "}, {"sha": "f891186934366ea66af09933f46267ddb7777775", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -95,8 +95,8 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n     // typarams, and fields.\n     let llbox_ty: TypeRef = T_ptr(T_empty_struct());\n \n-    if std::ivec::len[ast::ty_param](ty_params) == 0u &&\n-           std::ivec::len[ty::arg](arg_tys) == 0u {\n+    if std::vec::len[ast::ty_param](ty_params) == 0u &&\n+           std::vec::len[ty::arg](arg_tys) == 0u {\n         // If the object we're translating has no fields or type parameters,\n         // there's not much to do.\n \n@@ -235,7 +235,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n     // methods, not inner ones.\n     let wrapper_obj: ast::_obj =\n         {fields:\n-             std::ivec::map(ast::obj_field_from_anon_obj_field,\n+             std::vec::map(ast::obj_field_from_anon_obj_field,\n                             additional_fields),\n          methods: anon_obj.methods};\n \n@@ -295,7 +295,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n     // typarams, fields, and a pointer to our inner_obj.\n     let llbox_ty: TypeRef = T_ptr(T_empty_struct());\n \n-    if std::ivec::len[ast::anon_obj_field](additional_fields) == 0u &&\n+    if std::vec::len[ast::anon_obj_field](additional_fields) == 0u &&\n            anon_obj.inner_obj == none {\n \n         // If the object we're translating has no fields and no inner_obj,\n@@ -496,7 +496,7 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n         // Filter out any methods that we don't need forwarding slots for\n         // because they're being overridden.\n         let f = bind filtering_fn(cx, _, ob.methods);\n-        meths = std::ivec::filter_map[vtbl_mthd, vtbl_mthd](f, meths);\n+        meths = std::vec::filter_map[vtbl_mthd, vtbl_mthd](f, meths);\n \n         // And now add the additional ones, both overriding ones and entirely\n         // new ones.  These will just be normal methods.\n@@ -615,7 +615,7 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // Get the backwarding function's type and declare it.\n     let llbackwarding_fn_ty: TypeRef =\n         type_of_fn_full(cx.ccx, sp, m.proto, true, m.inputs, m.output,\n-                        std::ivec::len[ast::ty_param](ty_params));\n+                        std::vec::len[ast::ty_param](ty_params));\n     let llbackwarding_fn: ValueRef =\n         decl_internal_fastcall_fn(cx.ccx.llmod, s, llbackwarding_fn_ty);\n \n@@ -684,7 +684,7 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n         type_of_fn_full(bcx_ccx(bcx), sp,\n                         ty::ty_fn_proto(bcx_tcx(bcx), outer_mthd_ty), true,\n                         m.inputs, m.output,\n-                        std::ivec::len[ast::ty_param](ty_params));\n+                        std::vec::len[ast::ty_param](ty_params));\n     llouter_mthd =\n         bcx.build.PointerCast(llouter_mthd, T_ptr(T_ptr(llouter_mthd_ty)));\n     llouter_mthd = bcx.build.Load(llouter_mthd);\n@@ -747,7 +747,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // Get the forwarding function's type and declare it.\n     let llforwarding_fn_ty: TypeRef =\n         type_of_fn_full(cx.ccx, sp, m.proto, true, m.inputs, m.output,\n-                        std::ivec::len[ast::ty_param](ty_params));\n+                        std::vec::len[ast::ty_param](ty_params));\n     let llforwarding_fn: ValueRef =\n         decl_internal_fastcall_fn(cx.ccx.llmod, s, llforwarding_fn_ty);\n \n@@ -844,7 +844,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n         type_of_fn_full(bcx_ccx(bcx), sp,\n                         ty::ty_fn_proto(bcx_tcx(bcx), orig_mthd_ty), true,\n                         m.inputs, m.output,\n-                        std::ivec::len[ast::ty_param](ty_params));\n+                        std::vec::len[ast::ty_param](ty_params));\n     llorig_mthd =\n         bcx.build.PointerCast(llorig_mthd, T_ptr(T_ptr(llorig_mthd_ty)));\n     llorig_mthd = bcx.build.Load(llorig_mthd);\n@@ -923,7 +923,7 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n       ty::ty_fn(proto, inputs, output, _, _) {\n         llfnty =\n             type_of_fn_full(cx.ccx, m.span, proto, true, inputs, output,\n-                            std::ivec::len[ast::ty_param](ty_params));\n+                            std::vec::len[ast::ty_param](ty_params));\n       }\n     }\n     let mcx: @local_ctxt ="}, {"sha": "aff695c44b8df75e9dc8c7ba17651282a8bf5c21", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,4 +1,4 @@\n-import std::ivec;\n+import std::vec;\n import std::int::str;\n import std::str;\n import std::option;\n@@ -170,8 +170,8 @@ fn log_states_err(pp: &pre_and_post_state) {\n fn print_ident(i: &ident) { log \" \" + i + \" \"; }\n \n fn print_idents(idents: &mutable [ident]) {\n-    if ivec::len[ident](idents) == 0u { ret; }\n-    log \"an ident: \" + ivec::pop[ident](idents);\n+    if vec::len[ident](idents) == 0u { ret; }\n+    log \"an ident: \" + vec::pop[ident](idents);\n     print_idents(idents);\n }\n \n@@ -311,15 +311,15 @@ fn get_fn_info(ccx: &crate_ctxt, id: node_id) -> fn_info {\n }\n \n fn add_node(ccx: &crate_ctxt, i: node_id, a: &ts_ann) {\n-    let sz = ivec::len(*ccx.node_anns);\n+    let sz = vec::len(*ccx.node_anns);\n     if sz <= i as uint {\n-        ivec::grow_mut(*ccx.node_anns, (i as uint) - sz + 1u, empty_ann(0u));\n+        vec::grow_mut(*ccx.node_anns, (i as uint) - sz + 1u, empty_ann(0u));\n     }\n     ccx.node_anns.(i) = a;\n }\n \n fn get_ts_ann(ccx: &crate_ctxt, i: node_id) -> option::t[ts_ann] {\n-    if i as uint < ivec::len(*ccx.node_anns) {\n+    if i as uint < vec::len(*ccx.node_anns) {\n         ret some[ts_ann](ccx.node_anns.(i));\n     } else { ret none[ts_ann]; }\n }\n@@ -690,7 +690,7 @@ fn substitute_constr_args(cx: &ty::ctxt, actuals: &[@expr], c: &@ty::constr)\n \n fn substitute_arg(cx: &ty::ctxt, actuals: &[@expr], a: @constr_arg) ->\n    @constr_arg_use {\n-    let num_actuals = ivec::len(actuals);\n+    let num_actuals = vec::len(actuals);\n     alt a.node {\n       carg_ident(i) {\n         if i < num_actuals {\n@@ -744,7 +744,7 @@ fn find_instances(fcx: &fn_ctxt, subst: &subst, c: &constraint) ->\n    [{from: uint, to: uint}] {\n \n     let rslt = ~[];\n-    if ivec::len(subst) == 0u { ret rslt; }\n+    if vec::len(subst) == 0u { ret rslt; }\n \n     alt c {\n       cinit(_, _, _) {/* this is dealt with separately */ }\n@@ -822,7 +822,7 @@ fn replace(subst: subst, d: pred_args) -> [constr_arg_general_[inst]] {\n }\n \n fn path_to_ident(cx: &ty::ctxt, p: &path) -> ident {\n-    alt ivec::last(p.node.idents) {\n+    alt vec::last(p.node.idents) {\n       none. { cx.sess.span_fatal(p.span, \"Malformed path\"); }\n       some(i) { ret i; }\n     }\n@@ -1029,7 +1029,7 @@ fn args_mention[T](args: &[@constr_arg_use], q: fn(&[T], node_id) -> bool ,\n             case (_)               { false }\n         }\n     }\n-    ret ivec::any(bind mentions(s,q,_), args);\n+    ret vec::any(bind mentions(s,q,_), args);\n     */\n \n     for a: @constr_arg_use in args {\n@@ -1040,7 +1040,7 @@ fn args_mention[T](args: &[@constr_arg_use], q: fn(&[T], node_id) -> bool ,\n \n fn use_var(fcx: &fn_ctxt, v: &node_id) { *fcx.enclosing.used_vars += ~[v]; }\n \n-// FIXME: This should be a function in std::ivec::.\n+// FIXME: This should be a function in std::vec::.\n fn vec_contains(v: &@mutable [node_id], i: &node_id) -> bool {\n     for d: node_id in *v { if d == i { ret true; } }\n     ret false;\n@@ -1090,7 +1090,7 @@ fn local_to_bindings(loc : &@local) -> binding {\n }\n \n fn locals_to_bindings(locals : &[@local]) -> [binding] {\n-    ivec::map(local_to_bindings, locals)\n+    vec::map(local_to_bindings, locals)\n }\n \n fn callee_modes(fcx: &fn_ctxt, callee: node_id) -> [ty::mode] {\n@@ -1120,7 +1120,7 @@ fn callee_arg_init_ops(fcx: &fn_ctxt, callee: node_id) -> [init_op] {\n           _ { init_assign }\n         }\n     }\n-    ivec::map(mode_to_op, callee_modes(fcx, callee))\n+    vec::map(mode_to_op, callee_modes(fcx, callee))\n }\n \n fn anon_bindings(ops: &[init_op], es : &[@expr]) -> [binding] {"}, {"sha": "3e90c08ec19a5f64359f3e24ada540ef8bffaefa", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,6 +1,6 @@\n import syntax::ast::*;\n import syntax::visit;\n-import std::ivec;\n+import std::vec;\n import std::option::*;\n import aux::*;\n import tstate::ann::pre_and_post;\n@@ -77,10 +77,10 @@ fn seq_tritv(p: &postcond, q: &postcond) {\n }\n \n fn seq_postconds(fcx: &fn_ctxt, ps: &[postcond]) -> postcond {\n-    let sz = ivec::len(ps);\n+    let sz = vec::len(ps);\n     if sz >= 1u {\n         let prev = tritv_clone(ps.(0));\n-        for p: postcond in ivec::slice(ps, 1u, sz) { seq_tritv(prev, p); }\n+        for p: postcond in vec::slice(ps, 1u, sz) { seq_tritv(prev, p); }\n         ret prev;\n     } else { ret ann::empty_poststate(num_constraints(fcx.enclosing)); }\n }\n@@ -90,12 +90,12 @@ fn seq_postconds(fcx: &fn_ctxt, ps: &[postcond]) -> postcond {\n // So, if e0's post is {x} and e1's pre is {x, y, z}, the entire\n // precondition shouldn't include x.\n fn seq_preconds(fcx: &fn_ctxt, pps: &[pre_and_post]) -> precond {\n-    let sz: uint = ivec::len(pps);\n+    let sz: uint = vec::len(pps);\n     let num_vars: uint = num_constraints(fcx.enclosing);\n \n     fn seq_preconds_go(fcx: &fn_ctxt, pps: &[pre_and_post],\n                        first: &pre_and_post) -> precond {\n-        let sz: uint = ivec::len(pps);\n+        let sz: uint = vec::len(pps);\n         if sz >= 1u {\n             let second = pps.(0);\n             assert (pps_len(second) == num_constraints(fcx.enclosing));\n@@ -105,7 +105,7 @@ fn seq_preconds(fcx: &fn_ctxt, pps: &[pre_and_post]) -> precond {\n             union(next_first, second_pre);\n             let next_first_post = clone(first.postcondition);\n             seq_tritv(next_first_post, second.postcondition);\n-            ret seq_preconds_go(fcx, ivec::slice(pps, 1u, sz),\n+            ret seq_preconds_go(fcx, vec::slice(pps, 1u, sz),\n                                 @{precondition: next_first,\n                                   postcondition: next_first_post});\n         } else { ret first.precondition; }\n@@ -115,7 +115,7 @@ fn seq_preconds(fcx: &fn_ctxt, pps: &[pre_and_post]) -> precond {\n     if sz >= 1u {\n         let first = pps.(0);\n         assert (pps_len(first) == num_vars);\n-        ret seq_preconds_go(fcx, ivec::slice(pps, 1u, sz), first);\n+        ret seq_preconds_go(fcx, vec::slice(pps, 1u, sz), first);\n     } else { ret true_precond(num_vars); }\n }\n \n@@ -197,7 +197,7 @@ fn kill_poststate(fcx: &fn_ctxt, id: node_id, c: &tsconstr) -> bool {\n fn clear_in_poststate_expr(fcx: &fn_ctxt, e: &@expr, t: &poststate) {\n     alt e.node {\n       expr_path(p) {\n-        alt ivec::last(p.node.idents) {\n+        alt vec::last(p.node.idents) {\n           some(i) {\n             alt local_node_id_to_def(fcx, e.id) {\n               some(def_local(d_id)) {"}, {"sha": "036c931376da5e8223e1b31bc3353587508197c9", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,6 +1,6 @@\n import std::uint;\n import std::int;\n-import std::ivec;\n+import std::vec;\n import syntax::ast::*;\n import util::ppaux::fn_ident_to_string;\n import std::option::*;\n@@ -127,7 +127,7 @@ fn mk_fn_info(ccx: &crate_ctxt, f: &_fn, tp: &[ty_param], f_sp: &span,\n         {constrs: res_map,\n          num_constraints:\n          // add 2 to account for the i_return and i_diverge constraints\n-             ivec::len(*cx.cs) + ivec::len(f.decl.constraints) + 2u,\n+             vec::len(*cx.cs) + vec::len(f.decl.constraints) + 2u,\n          cf: f.decl.cf,\n          i_return: ninit(id, name),\n          i_diverge: ninit(diverges_id, diverges_name),"}, {"sha": "a6541f43c717913048a237684c459496139d22f9", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,5 +1,5 @@\n \n-import std::ivec;\n+import std::vec;\n import std::option;\n import std::option::none;\n import std::option::some;\n@@ -115,7 +115,7 @@ fn find_pre_post_item(ccx: &crate_ctxt, i: &item) {\n    the preconditions for <args>, and the postcondition in a to\n    be the union of all postconditions for <args> */\n fn find_pre_post_exprs(fcx: &fn_ctxt, args: &[@expr], id: node_id) {\n-    if ivec::len[@expr](args) > 0u {\n+    if vec::len[@expr](args) > 0u {\n         log \"find_pre_post_exprs: oper =\";\n         log_expr(*args.(0));\n     }\n@@ -125,10 +125,10 @@ fn find_pre_post_exprs(fcx: &fn_ctxt, args: &[@expr], id: node_id) {\n     fn get_pp(ccx: crate_ctxt, e: &@expr) -> pre_and_post {\n         ret expr_pp(ccx, e);\n     }\n-    let pps = ivec::map[@expr, pre_and_post](bind get_pp(fcx.ccx, _), args);\n+    let pps = vec::map[@expr, pre_and_post](bind get_pp(fcx.ccx, _), args);\n \n     set_pre_and_post(fcx.ccx, id, seq_preconds(fcx, pps),\n-                     seq_postconds(fcx, ivec::map(get_post, pps)));\n+                     seq_postconds(fcx, vec::map(get_post, pps)));\n }\n \n fn find_pre_post_loop(fcx: &fn_ctxt, l: &@local, index: &@expr, body: &blk,\n@@ -525,7 +525,7 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n               postcondition: false_postcond(num_local_vars)};\n         let g = bind combine_pp(antec_pp, fcx, _, _);\n         let alts_overall_pp =\n-            ivec::foldl[pre_and_post, pre_and_post](g, e_pp, alt_pps);\n+            vec::foldl[pre_and_post, pre_and_post](g, e_pp, alt_pps);\n         set_pre_and_post(fcx.ccx, e.id, alts_overall_pp.precondition,\n                          alts_overall_pp.postcondition);\n       }"}, {"sha": "c990b036cfeb6db8676b87bdbb622f97fdaf4ad2", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,6 +1,6 @@\n import syntax::print::pprust::path_to_str;\n import util::ppaux::ty_to_str;\n-import std::ivec;\n+import std::vec;\n import std::option;\n import std::option::get;\n import std::option::is_none;\n@@ -165,11 +165,11 @@ fn find_pre_post_state_call(fcx: &fn_ctxt, pres: &prestate, a: &@expr,\n                             id: node_id, ops: &[init_op], bs: &[@expr],\n                             cf: controlflow) -> bool {\n     let changed = find_pre_post_state_expr(fcx, pres, a);\n-    if ivec::len(bs) != ivec::len(ops) {\n+    if vec::len(bs) != vec::len(ops) {\n         fcx.ccx.tcx.sess.span_bug(a.span,\n                                   #fmt(\"mismatched arg lengths: \\\n                                         %u exprs vs. %u ops\",\n-                                       ivec::len(bs), ivec::len(ops)));\n+                                       vec::len(bs), vec::len(ops)));\n     }\n     ret find_pre_post_state_exprs(fcx, expr_poststate(fcx.ccx, a), id,\n                                   ops, bs, cf)\n@@ -313,8 +313,8 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n     alt e.node {\n       expr_vec(elts, _, _) {\n         ret find_pre_post_state_exprs(fcx, pres, e.id,\n-                                      ivec::init_elt(init_assign,\n-                                                     ivec::len(elts)),\n+                                      vec::init_elt(init_assign,\n+                                                     vec::len(elts)),\n                                       elts, return);\n       }\n       expr_call(operator, operands) {\n@@ -372,8 +372,8 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n       expr_rec(fields, maybe_base) {\n         let changed =\n             find_pre_post_state_exprs(fcx, pres, e.id,\n-                                      ivec::init_elt(init_assign,\n-                                                     ivec::len(fields)),\n+                                      vec::init_elt(init_assign,\n+                                                     vec::len(fields)),\n                                       field_exprs(fields),\n                                       return);\n         alt maybe_base {\n@@ -389,8 +389,8 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n       }\n       expr_tup(elts) {\n         ret find_pre_post_state_exprs(fcx, pres, e.id,\n-                                      ivec::init_elt(init_assign,\n-                                                     ivec::len(elts)),\n+                                      vec::init_elt(init_assign,\n+                                                     vec::len(elts)),\n                                       elts, return);\n       }\n       expr_copy(a) {\n@@ -554,7 +554,7 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n                 find_pre_post_state_expr(fcx, pres, val);\n         let e_post = expr_poststate(fcx.ccx, val);\n         let a_post;\n-        if ivec::len(alts) > 0u {\n+        if vec::len(alts) > 0u {\n             a_post = false_postcond(num_constrs);\n             for an_alt: arm in alts {\n                 changed |="}, {"sha": "d10ad3d9a087044d355eea2a483ef43e1f281f61", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,5 +1,5 @@\n import std::int;\n-import std::ivec;\n+import std::vec;\n import std::str;\n import std::uint;\n import std::box;\n@@ -393,7 +393,7 @@ fn populate_type_store(cx: &ctxt) {\n     intern(cx, ty_task, none);\n     intern(cx, ty_type, none);\n     intern(cx, ty_bot, none);\n-    assert (ivec::len(cx.ts.vect) == idx_first_others);\n+    assert (vec::len(cx.ts.vect) == idx_first_others);\n }\n \n fn mk_rcache() -> creader_cache {\n@@ -1195,7 +1195,7 @@ fn type_has_dynamic_size(cx: &ctxt, ty: &t) -> bool {\n       ty_istr. { ret false; }\n       ty_tag(_, subtys) {\n         let i = 0u;\n-        while i < ivec::len[t](subtys) {\n+        while i < vec::len[t](subtys) {\n             if type_has_dynamic_size(cx, subtys.(i)) { ret true; }\n             i += 1u;\n         }\n@@ -1210,7 +1210,7 @@ fn type_has_dynamic_size(cx: &ctxt, ty: &t) -> bool {\n       ty_task. { ret false; }\n       ty_rec(fields) {\n         let i = 0u;\n-        while i < ivec::len[field](fields) {\n+        while i < vec::len[field](fields) {\n             if type_has_dynamic_size(cx, fields.(i).mt.ty) { ret true; }\n             i += 1u;\n         }\n@@ -1453,7 +1453,7 @@ fn type_autoderef(cx: &ctxt, t: &ty::t) -> ty::t {\n           }\n           ty::ty_tag(did, tps) {\n             let variants = tag_variants(cx, did);\n-            if ivec::len(variants) != 1u || ivec::len(variants.(0).args) != 1u\n+            if vec::len(variants) != 1u || vec::len(variants.(0).args) != 1u\n                {\n                 break;\n             }\n@@ -1643,7 +1643,7 @@ fn constr_eq(c: &@constr, d: &@constr) -> bool {\n }\n \n fn constrs_eq(cs: &[@constr], ds: &[@constr]) -> bool {\n-    if ivec::len(cs) != ivec::len(ds) { ret false; }\n+    if vec::len(cs) != vec::len(ds) { ret false; }\n     let i = 0u;\n     for c: @constr in cs { if !constr_eq(c, ds.(i)) { ret false; } i += 1u; }\n     ret true;\n@@ -1656,8 +1656,8 @@ fn equal_type_structures(a: &sty, b: &sty) -> bool {\n     fn equal_fn(args_a: &[arg], rty_a: &t, args_b: &[arg], rty_b: &t) ->\n        bool {\n         if !eq_ty(rty_a, rty_b) { ret false; }\n-        let len = ivec::len[arg](args_a);\n-        if len != ivec::len[arg](args_b) { ret false; }\n+        let len = vec::len[arg](args_a);\n+        if len != vec::len[arg](args_b) { ret false; }\n         let i = 0u;\n         while i < len {\n             let arg_a = args_a.(i);\n@@ -1693,8 +1693,8 @@ fn equal_type_structures(a: &sty, b: &sty) -> bool {\n         alt b {\n           ty_tag(id_b, tys_b) {\n             if !equal_def(id_a, id_b) { ret false; }\n-            let len = ivec::len[t](tys_a);\n-            if len != ivec::len[t](tys_b) { ret false; }\n+            let len = vec::len[t](tys_a);\n+            if len != vec::len[t](tys_b) { ret false; }\n             let i = 0u;\n             while i < len {\n                 if !eq_ty(tys_a.(i), tys_b.(i)) { ret false; }\n@@ -1727,8 +1727,8 @@ fn equal_type_structures(a: &sty, b: &sty) -> bool {\n       ty_rec(flds_a) {\n         alt b {\n           ty_rec(flds_b) {\n-            let len = ivec::len[field](flds_a);\n-            if len != ivec::len[field](flds_b) { ret false; }\n+            let len = vec::len[field](flds_a);\n+            if len != vec::len[field](flds_b) { ret false; }\n             let i = 0u;\n             while i < len {\n                 let fld_a = flds_a.(i);\n@@ -1747,8 +1747,8 @@ fn equal_type_structures(a: &sty, b: &sty) -> bool {\n       ty_tup(ts_a) {\n         alt (b) {\n           ty_tup(ts_b) {\n-            let len = ivec::len(ts_a);\n-            if len != ivec::len(ts_b) { ret false; }\n+            let len = vec::len(ts_a);\n+            if len != vec::len(ts_b) { ret false; }\n             let i = 0u;\n             while i < len {\n                 if !eq_ty(ts_a.(i), ts_b.(i)) { ret false; }\n@@ -1780,8 +1780,8 @@ fn equal_type_structures(a: &sty, b: &sty) -> bool {\n       ty_obj(methods_a) {\n         alt b {\n           ty_obj(methods_b) {\n-            let len = ivec::len[method](methods_a);\n-            if len != ivec::len[method](methods_b) { ret false; }\n+            let len = vec::len[method](methods_a);\n+            if len != vec::len[method](methods_b) { ret false; }\n             let i = 0u;\n             while i < len {\n                 let m_a = methods_a.(i);\n@@ -1898,7 +1898,7 @@ fn node_id_to_type_params(cx: &ctxt, id: &ast::node_id) -> [t] {\n }\n \n fn node_id_has_type_params(cx: &ctxt, id: &ast::node_id) -> bool {\n-    ret ivec::len(node_id_to_type_params(cx, id)) > 0u;\n+    ret vec::len(node_id_to_type_params(cx, id)) > 0u;\n }\n \n \n@@ -1938,7 +1938,7 @@ fn count_ty_params(cx: &ctxt, ty: t) -> uint {\n     let param_indices: @mutable [uint] = @mutable ~[];\n     let f = bind counter(cx, param_indices, _);\n     walk_ty(cx, f, ty);\n-    ret ivec::len[uint](*param_indices);\n+    ret vec::len[uint](*param_indices);\n }\n \n fn type_contains_vars(cx: &ctxt, typ: &t) -> bool {\n@@ -2079,7 +2079,7 @@ fn occurs_check_fails(tcx: &ctxt, sp: &option::t[span], vid: int, rt: &t)\n         ret false;\n     }\n     // Occurs check!\n-    if ivec::member(vid, vars_in_type(tcx, rt)) {\n+    if vec::member(vid, vars_in_type(tcx, rt)) {\n         alt sp {\n           some (s) {\n             // Maybe this should be span_err -- however, there's an\n@@ -2211,8 +2211,8 @@ mod unify {\n     // pairwise equal.\n     fn unify_constrs(base_t: &t, expected: [@type_constr],\n                      actual: &[@type_constr]) -> result {\n-        let expected_len = ivec::len(expected);\n-        let actual_len = ivec::len(actual);\n+        let expected_len = vec::len(expected);\n+        let actual_len = vec::len(actual);\n \n         if expected_len != actual_len {\n             ret ures_err(terr_constr_len(expected_len, actual_len));\n@@ -2231,8 +2231,8 @@ mod unify {\n         let ok_res = ures_ok(base_t);\n         let err_res = ures_err(terr_constr_mismatch(expected, actual_constr));\n         if expected.node.id != actual_constr.node.id { ret err_res; }\n-        let expected_arg_len = ivec::len(expected.node.args);\n-        let actual_arg_len = ivec::len(actual_constr.node.args);\n+        let expected_arg_len = vec::len(expected.node.args);\n+        let actual_arg_len = vec::len(actual_constr.node.args);\n         if expected_arg_len != actual_arg_len { ret err_res; }\n         let i = 0u;\n         let actual;\n@@ -2276,8 +2276,8 @@ mod unify {\n                        expected_inputs: &[arg], expected_output: &t,\n                        actual_inputs: &[arg], actual_output: &t) ->\n        fn_common_res {\n-        let expected_len = ivec::len[arg](expected_inputs);\n-        let actual_len = ivec::len[arg](actual_inputs);\n+        let expected_len = vec::len[arg](expected_inputs);\n+        let actual_len = vec::len[arg](actual_inputs);\n         if expected_len != actual_len {\n             ret fn_common_res_err(ures_err(terr_arg_count));\n         }\n@@ -2373,8 +2373,8 @@ mod unify {\n        result {\n         let result_meths: [method] = ~[];\n         let i: uint = 0u;\n-        let expected_len: uint = ivec::len[method](expected_meths);\n-        let actual_len: uint = ivec::len[method](actual_meths);\n+        let expected_len: uint = vec::len[method](expected_meths);\n+        let actual_len: uint = vec::len[method](actual_meths);\n         if expected_len != actual_len { ret ures_err(terr_meth_count); }\n         while i < expected_len {\n             let e_meth = expected_meths.(i);\n@@ -2515,7 +2515,7 @@ mod unify {\n                 // TODO: factor this cruft out\n                 let result_tps: [t] = ~[];\n                 let i = 0u;\n-                let expected_len = ivec::len[t](expected_tps);\n+                let expected_len = vec::len[t](expected_tps);\n                 while i < expected_len {\n                     let expected_tp = expected_tps.(i);\n                     let actual_tp = actual_tps.(i);\n@@ -2684,8 +2684,8 @@ mod unify {\n           ty::ty_rec(expected_fields) {\n             alt struct(cx.tcx, actual) {\n               ty::ty_rec(actual_fields) {\n-                let expected_len = ivec::len[field](expected_fields);\n-                let actual_len = ivec::len[field](actual_fields);\n+                let expected_len = vec::len[field](expected_fields);\n+                let actual_len = vec::len[field](actual_fields);\n                 if expected_len != actual_len {\n                     let err = terr_record_size(expected_len, actual_len);\n                     ret ures_err(err);\n@@ -2730,8 +2730,8 @@ mod unify {\n           ty::ty_tup(expected_elems) {\n             alt struct(cx.tcx, actual) {\n               ty::ty_tup(actual_elems) {\n-                let expected_len = ivec::len(expected_elems);\n-                let actual_len = ivec::len(actual_elems);\n+                let expected_len = vec::len(expected_elems);\n+                let actual_len = vec::len(actual_elems);\n                 if (expected_len != actual_len) {\n                     let err = terr_tuple_size(expected_len, actual_len);\n                     ret ures_err(err);\n@@ -2825,10 +2825,10 @@ mod unify {\n     }\n     fn dump_var_bindings(tcx: ty_ctxt, vb: @var_bindings) {\n         let i = 0u;\n-        while i < ivec::len[ufind::node](vb.sets.nodes) {\n+        while i < vec::len[ufind::node](vb.sets.nodes) {\n             let sets = \"\";\n             let j = 0u;\n-            while j < ivec::len[option::t[uint]](vb.sets.nodes) {\n+            while j < vec::len[option::t[uint]](vb.sets.nodes) {\n                 if ufind::find(vb.sets, j) == i {\n                     sets += #fmt(\" %u\", j);\n                 }\n@@ -2951,7 +2951,7 @@ fn bind_params_in_type(sp: &span, cx: &ctxt, next_ty_var: fn() -> int ,\n     while i < ty_param_count { *param_var_ids += ~[next_ty_var()]; i += 1u; }\n     fn binder(sp: span, cx: ctxt, param_var_ids: @mutable [int],\n               next_ty_var: fn() -> int , index: uint, kind: ast::kind) -> t {\n-        if index < ivec::len(*param_var_ids) {\n+        if index < vec::len(*param_var_ids) {\n             ret mk_var(cx, param_var_ids.(index));\n         } else {\n             cx.sess.span_fatal(sp, \"Unbound type parameter in callee's type\");\n@@ -3015,7 +3015,7 @@ fn tag_variants(cx: &ctxt, id: &ast::def_id) -> [variant_info] {\n             for variant: ast::variant in variants {\n                 let ctor_ty = node_id_to_monotype(cx, variant.node.id);\n                 let arg_tys: [t] = ~[];\n-                if std::ivec::len(variant.node.args) > 0u {\n+                if std::vec::len(variant.node.args) > 0u {\n                     for a: arg in ty_fn_args(cx, ctor_ty) {\n                         arg_tys += ~[a.ty];\n                     }\n@@ -3039,7 +3039,7 @@ fn tag_variant_with_id(cx: &ctxt, tag_id: &ast::def_id,\n                        variant_id: &ast::def_id) -> variant_info {\n     let variants = tag_variants(cx, tag_id);\n     let i = 0u;\n-    while i < ivec::len[variant_info](variants) {\n+    while i < vec::len[variant_info](variants) {\n         let variant = variants.(i);\n         if def_eq(variant.id, variant_id) { ret variant; }\n         i += 1u;"}, {"sha": "f73138b65f1938f19e252ca11edf5b74a816a38d", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -34,7 +34,7 @@ import middle::ty::unify::fixup_result;\n import middle::ty::unify::fix_ok;\n import middle::ty::unify::fix_err;\n import std::int;\n-import std::ivec;\n+import std::vec;\n import std::str;\n import std::uint;\n import std::map;\n@@ -158,15 +158,15 @@ fn ty_param_kinds_and_ty_for_def(fcx: &@fn_ctxt, sp: &span, defn: &ast::def)\n fn instantiate_path(fcx: &@fn_ctxt, pth: &ast::path,\n                     tpt: &ty_param_kinds_and_ty, sp: &span) ->\n    ty_param_substs_opt_and_ty {\n-    let ty_param_count = ivec::len(tpt.kinds);\n+    let ty_param_count = vec::len(tpt.kinds);\n     let bind_result =\n         bind_params_in_type(sp, fcx.ccx.tcx, bind next_ty_var_id(fcx), tpt.ty,\n                             ty_param_count);\n     let ty_param_vars = bind_result.ids;\n     let ty_substs_opt;\n-    let ty_substs_len = ivec::len[@ast::ty](pth.node.types);\n+    let ty_substs_len = vec::len[@ast::ty](pth.node.types);\n     if ty_substs_len > 0u {\n-        let param_var_len = ivec::len(ty_param_vars);\n+        let param_var_len = vec::len(ty_param_vars);\n         if param_var_len == 0u {\n             fcx.ccx.tcx.sess.span_fatal\n                 (sp, \"this item does not take type parameters\");\n@@ -287,7 +287,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n         // \"foo = int\" like OCaml?\n \n         let ty_param_kinds_and_ty = getter(id);\n-        if ivec::len(ty_param_kinds_and_ty.kinds) == 0u {\n+        if vec::len(ty_param_kinds_and_ty.kinds) == 0u {\n             ret ty_param_kinds_and_ty.ty;\n         }\n         // The typedef is type-parametric. Do the type substitution.\n@@ -297,8 +297,8 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n         for ast_ty: @ast::ty in args {\n             param_bindings += ~[ast_ty_to_ty(tcx, getter, ast_ty)];\n         }\n-        if ivec::len(param_bindings) !=\n-            ivec::len(ty_param_kinds_and_ty.kinds) {\n+        if vec::len(param_bindings) !=\n+            vec::len(ty_param_kinds_and_ty.kinds) {\n             tcx.sess.span_fatal(sp,\n                                 \"Wrong number of type arguments for a \\\n                                  polymorphic type\");\n@@ -341,7 +341,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n         typ = ty::mk_chan(tcx, ast_ty_to_ty(tcx, getter, t));\n       }\n       ast::ty_tup(fields) {\n-        let flds = ivec::map(bind ast_ty_to_ty(tcx, getter, _), fields);\n+        let flds = vec::map(bind ast_ty_to_ty(tcx, getter, _), fields);\n         typ = ty::mk_tup(tcx, flds);\n       }\n       ast::ty_rec(fields) {\n@@ -752,7 +752,7 @@ mod collect {\n             // constructors get turned into functions.\n \n             let result_ty;\n-            if ivec::len[ast::variant_arg](variant.node.args) == 0u {\n+            if vec::len[ast::variant_arg](variant.node.args) == 0u {\n                 result_ty = ty::mk_tag(cx.tcx, tag_id, ty_param_tys);\n             } else {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()\n@@ -813,7 +813,7 @@ mod collect {\n             // ty_of_obj().)\n             let method_types = get_obj_method_types(cx, object);\n             let i = 0u;\n-            while i < ivec::len[@ast::method](object.methods) {\n+            while i < vec::len[@ast::method](object.methods) {\n                 write::ty_only(cx.tcx, object.methods.(i).node.id,\n                                ty::method_ty_to_fn_ty(cx.tcx,\n                                                       method_types.(i)));\n@@ -825,7 +825,7 @@ mod collect {\n             // an assertion in trans.\n             let args = ty::ty_fn_args(cx.tcx, tpt.ty);\n             i = 0u;\n-            while i < ivec::len[ty::arg](args) {\n+            while i < vec::len[ty::arg](args) {\n                 let fld = object.fields.(i);\n                 write::ty_only(cx.tcx, fld.id, args.(i).ty);\n                 i += 1u;\n@@ -919,7 +919,7 @@ fn do_autoderef(fcx: &@fn_ctxt, sp: &span, t: &ty::t) -> ty::t {\n           }\n           ty::ty_tag(did, tps) {\n             let variants = ty::tag_variants(fcx.ccx.tcx, did);\n-            if ivec::len(variants) != 1u || ivec::len(variants.(0).args) != 1u\n+            if vec::len(variants) != 1u || vec::len(variants.(0).args) != 1u\n                {\n                 ret t1;\n             }\n@@ -1370,11 +1370,11 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast::pat_id_map, pat: &@ast::pat,\n             let arg_types =\n                 variant_arg_types(fcx.ccx, pat.span, v_def_ids.var,\n                                   expected_tps);\n-            let subpats_len = std::ivec::len[@ast::pat](subpats);\n-            if std::ivec::len[ty::t](arg_types) > 0u {\n+            let subpats_len = std::vec::len[@ast::pat](subpats);\n+            if std::vec::len[ty::t](arg_types) > 0u {\n                 // N-ary variant.\n \n-                let arg_len = ivec::len[ty::t](arg_types);\n+                let arg_len = vec::len[ty::t](arg_types);\n                 if arg_len != subpats_len {\n                     // TODO: note definition of tag variant\n                     // TODO (issue #448): Wrap a #fmt string over multiple\n@@ -1388,7 +1388,7 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast::pat_id_map, pat: &@ast::pat,\n                     fcx.ccx.tcx.sess.span_fatal(pat.span, s);\n                 }\n \n-                // TODO: ivec::iter2\n+                // TODO: vec::iter2\n \n                 let i = 0u;\n                 for subpat: @ast::pat in subpats {\n@@ -1431,8 +1431,8 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast::pat_id_map, pat: &@ast::pat,\n                                                        expected)));\n           }\n         }\n-        let f_count = ivec::len(fields);\n-        let ex_f_count = ivec::len(ex_fields);\n+        let f_count = vec::len(fields);\n+        let ex_f_count = vec::len(ex_fields);\n         if ex_f_count < f_count || !etc && ex_f_count > f_count {\n             fcx.ccx.tcx.sess.span_fatal\n                 (pat.span, #fmt(\"mismatched types: expected a record \\\n@@ -1443,7 +1443,7 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast::pat_id_map, pat: &@ast::pat,\n             ret str::eq(name, f.ident);\n         }\n         for f: ast::field_pat in fields {\n-            alt ivec::find(bind matches(f.ident, _), ex_fields) {\n+            alt vec::find(bind matches(f.ident, _), ex_fields) {\n               some(field) { check_pat(fcx, map, f.pat, field.mt.ty); }\n               none. {\n                 fcx.ccx.tcx.sess.span_fatal(pat.span,\n@@ -1466,12 +1466,12 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast::pat_id_map, pat: &@ast::pat,\n                                                                  expected)));\n           }\n         }\n-        let e_count = ivec::len(elts);\n-        if e_count != ivec::len(ex_elts) {\n+        let e_count = vec::len(elts);\n+        if e_count != vec::len(ex_elts) {\n             fcx.ccx.tcx.sess.span_fatal\n                 (pat.span, #fmt(\"mismatched types: expected a tuple \\\n                                  with %u fields, found one with %u \\\n-                                 fields\", ivec::len(ex_elts), e_count));\n+                                 fields\", vec::len(ex_elts), e_count));\n         }\n         let i = 0u;\n         for elt in elts {\n@@ -1593,8 +1593,8 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         }\n \n         // Check that the correct number of arguments were supplied.\n-        let expected_arg_count = ivec::len[ty::arg](arg_tys);\n-        let supplied_arg_count = ivec::len[option::t[@ast::expr]](args);\n+        let expected_arg_count = vec::len[ty::arg](arg_tys);\n+        let supplied_arg_count = vec::len[option::t[@ast::expr]](args);\n         if expected_arg_count != supplied_arg_count {\n             fcx.ccx.tcx.sess.span_fatal(sp,\n                                         #fmt(\"this function takes %u \\\n@@ -1828,8 +1828,8 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n               ty::ty_res(_, inner, _) { oper_t = inner; }\n               ty::ty_tag(id, tps) {\n                 let variants = ty::tag_variants(tcx, id);\n-                if ivec::len(variants) != 1u ||\n-                       ivec::len(variants.(0).args) != 1u {\n+                if vec::len(variants) != 1u ||\n+                       vec::len(variants.(0).args) != 1u {\n                     tcx.sess.span_fatal\n                         (expr.span, \"can only dereference tags \" +\n                          \"with a single variant which has a \"\n@@ -1877,7 +1877,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         } else {\n             // The definition doesn't take type parameters. If the programmer\n             // supplied some, that's an error.\n-            if ivec::len[@ast::ty](pth.node.types) > 0u {\n+            if vec::len[@ast::ty](pth.node.types) > 0u {\n                 tcx.sess.span_fatal(expr.span,\n                                     \"this kind of value does not \\\n                                      take type parameters\");\n@@ -2116,7 +2116,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n             // For each blank argument, add the type of that argument\n             // to the resulting function type.\n             let i = 0u;\n-            while i < ivec::len[option::t[@ast::expr]](args) {\n+            while i < vec::len[option::t[@ast::expr]](args) {\n                 alt args.(i) {\n                   some(_) {/* no-op */ }\n                   none. { arg_tys_1 += ~[arg_tys.(i)]; }\n@@ -2239,7 +2239,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n       }\n       ast::expr_tup(elts) {\n         let elt_ts = ~[];\n-        ivec::reserve(elt_ts, ivec::len(elts));\n+        vec::reserve(elt_ts, vec::len(elts));\n         for e in elts {\n             check_expr(fcx, e);\n             let ety = expr_ty(fcx.ccx.tcx, e);\n@@ -2264,7 +2264,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         alt base {\n           none. {\n             fn get_node(f: &spanned[field]) -> field { f.node }\n-            let typ = ty::mk_rec(tcx, ivec::map(get_node, fields_t));\n+            let typ = ty::mk_rec(tcx, vec::map(get_node, fields_t));\n             write::ty_only_fixup(fcx, id, typ);\n           }\n           some(bexpr) {\n@@ -2304,15 +2304,15 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n           ty::ty_rec(fields) {\n             let ix: uint =\n                 ty::field_idx(tcx.sess, expr.span, field, fields);\n-            if ix >= ivec::len[ty::field](fields) {\n+            if ix >= vec::len[ty::field](fields) {\n                 tcx.sess.span_fatal(expr.span, \"bad index on record\");\n             }\n             write::ty_only_fixup(fcx, id, fields.(ix).mt.ty);\n           }\n           ty::ty_obj(methods) {\n             let ix: uint =\n                 ty::method_idx(tcx.sess, expr.span, field, methods);\n-            if ix >= ivec::len[ty::method](methods) {\n+            if ix >= vec::len[ty::method](methods) {\n                 tcx.sess.span_fatal(expr.span, \"bad index on obj\");\n             }\n             let meth = methods.(ix);\n@@ -2444,7 +2444,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n             }\n \n             fcx.ccx.obj_infos +=\n-                ~[anon_obj(ivec::map(ast::obj_field_from_anon_obj_field,\n+                ~[anon_obj(vec::map(ast::obj_field_from_anon_obj_field,\n                                      fields), inner_obj_sty)];\n \n             // Whenever an outer method overrides an inner, we need to remove\n@@ -2474,7 +2474,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n \n             let f = bind filtering_fn(fcx.ccx, _, ao.methods);\n             inner_obj_methods =\n-                std::ivec::filter_map[ty::method,\n+                std::vec::filter_map[ty::method,\n                                       ty::method](f, inner_obj_methods);\n \n             method_types += inner_obj_methods;\n@@ -2487,7 +2487,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         // Write the methods into the node type table.  (This happens in\n         // collect::convert for regular objects.)\n         let i = 0u;\n-        while i < ivec::len[@ast::method](ao.methods) {\n+        while i < vec::len[@ast::method](ao.methods) {\n             write::ty_only(tcx, ao.methods.(i).node.id,\n                            ty::method_ty_to_fn_ty(tcx,\n                                                   method_types.(i)));\n@@ -2500,7 +2500,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         }\n \n         // Now remove the info from the stack.\n-        ivec::pop[obj_info](fcx.ccx.obj_infos);\n+        vec::pop[obj_info](fcx.ccx.obj_infos);\n       }\n       ast::expr_uniq(x) {\n         let t = next_ty_var(fcx);\n@@ -2528,7 +2528,7 @@ fn next_ty_var(fcx: &@fn_ctxt) -> ty::t {\n }\n \n fn get_obj_info(ccx: &@crate_ctxt) -> option::t[obj_info] {\n-    ret ivec::last[obj_info](ccx.obj_infos);\n+    ret vec::last[obj_info](ccx.obj_infos);\n }\n \n fn check_decl_initializer(fcx: &@fn_ctxt, nid: ast::node_id,\n@@ -2707,7 +2707,7 @@ fn check_item(ccx: @crate_ctxt, it: &@ast::item) {\n         for method: @ast::method in ob.methods { check_method(ccx, method); }\n \n         // Now remove the info from the stack.\n-        ivec::pop[obj_info](ccx.obj_infos);\n+        vec::pop[obj_info](ccx.obj_infos);\n       }\n       _ {/* nothing to do */ }\n     }\n@@ -2738,9 +2738,9 @@ fn check_main_fn_ty(tcx: &ty::ctxt, main_id: &ast::node_id) {\n     let main_t = ty::node_id_to_monotype(tcx, main_id);\n     alt ty::struct(tcx, main_t) {\n       ty::ty_fn(ast::proto_fn., args, rs, ast::return., constrs) {\n-        let ok = ivec::len(constrs) == 0u;\n+        let ok = vec::len(constrs) == 0u;\n         ok &= ty::type_is_nil(tcx, rs);\n-        let num_args = ivec::len(args);\n+        let num_args = vec::len(args);\n         ok &=\n             num_args == 0u || num_args == 1u && arg_is_argv_ty(tcx, args.(0));\n         if !ok {"}, {"sha": "bed8ce31c4cfdc9df0a47ccd625f6cd08713966b", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,6 +1,5 @@\n // The Rust abstract syntax tree.\n \n-import std::ivec;\n import std::option;\n import std::str;\n import codemap::span;"}, {"sha": "10bf7f478b79ebfc5626c7dfeed28e86a88da183", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,4 +1,4 @@\n-import std::ivec;\n+import std::vec;\n import std::uint;\n import std::str;\n import std::term;\n@@ -40,14 +40,14 @@ type lookup_fn = fn(file_pos) -> uint ;\n \n fn lookup_pos(map: codemap, pos: uint, lookup: lookup_fn) -> loc {\n     let a = 0u;\n-    let b = ivec::len(map.files);\n+    let b = vec::len(map.files);\n     while b - a > 1u {\n         let m = (a + b) / 2u;\n         if lookup(map.files.(m).start_pos) > pos { b = m; } else { a = m; }\n     }\n     let f = map.files.(a);\n     a = 0u;\n-    b = ivec::len(f.lines);\n+    b = vec::len(f.lines);\n     while b - a > 1u {\n         let m = (a + b) / 2u;\n         if lookup(f.lines.(m)) > pos { b = m; } else { a = m; }\n@@ -137,8 +137,8 @@ fn maybe_highlight_lines(sp: &option::t[span], cm: &codemap,\n         let max_lines = 6u;\n         let elided = false;\n         let display_lines = lines.lines;\n-        if ivec::len(display_lines) > max_lines {\n-            display_lines = ivec::slice(display_lines, 0u, max_lines);\n+        if vec::len(display_lines) > max_lines {\n+            display_lines = vec::slice(display_lines, 0u, max_lines);\n             elided = true;\n         }\n         // Print the offending lines\n@@ -149,7 +149,7 @@ fn maybe_highlight_lines(sp: &option::t[span], cm: &codemap,\n             io::stdout().write_str(s);\n         }\n         if elided {\n-            let last_line = display_lines.(ivec::len(display_lines) - 1u);\n+            let last_line = display_lines.(vec::len(display_lines) - 1u);\n             let s = #fmt(\"%s:%u \", fm.name, last_line + 1u);\n             let indent = str::char_len(s);\n             let out = \"\";\n@@ -160,7 +160,7 @@ fn maybe_highlight_lines(sp: &option::t[span], cm: &codemap,\n \n \n         // If there's one line at fault we can easily point to the problem\n-        if ivec::len(lines.lines) == 1u {\n+        if vec::len(lines.lines) == 1u {\n             let lo = lookup_char_pos(cm, option::get(sp).lo);\n             let digits = 0u;\n             let num = lines.lines.(0) / 10u;\n@@ -212,7 +212,7 @@ fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n fn get_line(fm: filemap, line: int, file: &str) -> str {\n     let begin: uint = fm.lines.(line).byte - fm.start_pos.byte;\n     let end: uint;\n-    if line as uint < ivec::len(fm.lines) - 1u {\n+    if line as uint < vec::len(fm.lines) - 1u {\n         end = fm.lines.(line + 1).byte - fm.start_pos.byte;\n     } else {\n         // If we're not done parsing the file, we're at the limit of what's"}, {"sha": "47048ed1951755759e85ab22fdb11925080b561a", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,4 +1,4 @@\n-import std::ivec;\n+import std::vec;\n import std::option;\n import std::map::hashmap;\n import driver::session::session;\n@@ -113,7 +113,7 @@ fn expr_to_str(cx: &ext_ctxt, expr: @ast::expr, error: str) -> str {\n fn expr_to_ident(cx: &ext_ctxt, expr: @ast::expr, error: str) -> ast::ident {\n     alt expr.node {\n       ast::expr_path(p) {\n-        if ivec::len(p.node.types) > 0u || ivec::len(p.node.idents) != 1u {\n+        if vec::len(p.node.types) > 0u || vec::len(p.node.idents) != 1u {\n             cx.span_fatal(expr.span, error);\n         } else { ret p.node.idents.(0); }\n       }"}, {"sha": "f21af93668f302874892a49a878e56927aa18943", "filename": "src/comp/syntax/ext/concat_idents.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,4 +1,3 @@\n-import std::ivec;\n import std::option;\n import base::*;\n import syntax::ast;"}, {"sha": "5a53f26a007bef9464409c5d55ceaccaf7439d27", "filename": "src/comp/syntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -4,7 +4,7 @@\n  * should all get sucked into either the compiler syntax extension plugin\n  * interface.\n  */\n-import std::ivec;\n+import std::vec;\n import std::option;\n import std::generic_os;\n import base::*;\n@@ -16,7 +16,7 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n       ast::expr_vec(elts, _, _) { elts }\n       _ { cx.span_fatal(sp, \"#env requires arguments of the form `[...]`.\") }\n     };\n-    if ivec::len[@ast::expr](args) != 1u {\n+    if vec::len[@ast::expr](args) != 1u {\n         cx.span_fatal(sp, \"malformed #env call\");\n     }\n     // FIXME: if this was more thorough it would manufacture an"}, {"sha": "d5e9fda2c84a3c09624e79af47297016d7d50233", "filename": "src/comp/syntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -4,7 +4,7 @@ import std::option::none;\n import std::option::some;\n \n import std::map::hashmap;\n-import std::ivec;\n+import std::vec;\n \n import syntax::ast::crate;\n import syntax::ast::expr_;\n@@ -21,7 +21,7 @@ fn expand_expr(exts: &hashmap[str, syntax_extension], cx: &ext_ctxt,\n           expr_mac(mac) {\n             alt mac.node {\n               mac_invoc(pth, args, body) {\n-                assert (ivec::len(pth.node.idents) > 0u);\n+                assert (vec::len(pth.node.idents) > 0u);\n                 let extname = pth.node.idents.(0);\n                 alt exts.find(extname) {\n                   none. {"}, {"sha": "b8ab57303df2221fec009999cc44133b4cd6f5ef", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -5,7 +5,7 @@\n  * should all get sucked into either the standard library extfmt module or the\n  * compiler syntax extension plugin interface.\n  */\n-import std::ivec;\n+import std::vec;\n import std::str;\n import std::option;\n import std::option::none;\n@@ -21,7 +21,7 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: span, arg: @ast::expr,\n       ast::expr_vec(elts, _, _) { elts }\n       _ { cx.span_fatal(sp, \"#fmt requires arguments of the form `[...]`.\") }\n     };\n-    if ivec::len[@ast::expr](args) == 0u {\n+    if vec::len[@ast::expr](args) == 0u {\n         cx.span_fatal(sp, \"#fmt requires a format string\");\n     }\n     let fmt =\n@@ -130,7 +130,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n             // through the rec that these flags are a member of, so\n             // this is a hack placeholder flag\n \n-            if ivec::len[@ast::expr](flagexprs) == 0u {\n+            if vec::len[@ast::expr](flagexprs) == 0u {\n                 flagexprs += ~[make_rt_path_expr(cx, sp, \"flag_none\")];\n             }\n             ret make_vec_expr(cx, sp, flagexprs);\n@@ -307,7 +307,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n     let fmt_sp = args.(0).span;\n     let n = 0u;\n     let tmp_expr = make_new_str(cx, sp, \"\");\n-    let nargs = ivec::len[@ast::expr](args);\n+    let nargs = vec::len[@ast::expr](args);\n     for pc: piece in pieces {\n         alt pc {\n           piece_string(s) {"}, {"sha": "c32acaf05b39d5d4a435d38d4d60ce7fab721fd3", "filename": "src/comp/syntax/ext/ident_to_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,4 +1,4 @@\n-import std::ivec;\n+import std::vec;\n import std::option;\n import base::*;\n import syntax::ast;\n@@ -9,7 +9,7 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n       ast::expr_vec(elts, _, _) { elts }\n       _ { cx.span_fatal(sp, \"#ident_to_str requires a vector argument .\") }\n     };\n-    if ivec::len[@ast::expr](args) != 1u {\n+    if vec::len[@ast::expr](args) != 1u {\n         cx.span_fatal(sp, \"malformed #ident_to_str call\");\n     }\n "}, {"sha": "29f474b7878a53724fd77b74e3b3de900f13becb", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,7 +1,7 @@\n use std;\n \n import codemap::span;\n-import std::ivec;\n+import std::vec;\n import std::option;\n import std::map::hashmap;\n import std::map::new_str_hash;\n@@ -33,7 +33,7 @@ import ast::mac_invoc;\n export add_new_extension;\n \n fn path_to_ident(pth: &path) -> option::t[ident] {\n-    if ivec::len(pth.node.idents) == 1u && ivec::len(pth.node.types) == 0u {\n+    if vec::len(pth.node.idents) == 1u && vec::len(pth.node.types) == 0u {\n         ret some(pth.node.idents.(0u));\n     }\n     ret none;\n@@ -103,10 +103,10 @@ fn elts_to_ell(cx: &ext_ctxt, elts: &[@expr])\n                 if res != none {\n                     cx.span_fatal(m.span, \"only one ellipsis allowed\");\n                 }\n-                res = some({pre: ivec::slice(elts, 0u, idx - 1u),\n+                res = some({pre: vec::slice(elts, 0u, idx - 1u),\n                             rep: some(elts.(idx - 1u)),\n-                            post: ivec::slice(elts, idx + 1u,\n-                                              ivec::len(elts))});\n+                            post: vec::slice(elts, idx + 1u,\n+                                              vec::len(elts))});\n               }\n               _ { }\n             }\n@@ -286,7 +286,7 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n     -> [@expr] {\n     alt elts_to_ell(cx, exprs) {\n       {pre: pre, rep: repeat_me_maybe, post: post} {\n-        let res = ivec::map(recur, pre);\n+        let res = vec::map(recur, pre);\n         alt repeat_me_maybe {\n           none. {}\n           some(repeat_me) {\n@@ -300,10 +300,10 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                   seq(ms, _) {\n                     alt repeat {\n                       none. {\n-                        repeat = some({rep_count: ivec::len(*ms), name: fv});\n+                        repeat = some({rep_count: vec::len(*ms), name: fv});\n                       }\n                       some({rep_count: old_len, name: old_name}) {\n-                        let len = ivec::len(*ms);\n+                        let len = vec::len(*ms);\n                         if old_len != len {\n                             let msg = #fmt(\"'%s' occurs %u times, but \", fv,\n                                            len) + #fmt(\"'%s' occurs %u times\",\n@@ -327,14 +327,14 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                 while idx < rc {\n                     *idx_path += ~[idx];\n                     res += ~[recur(repeat_me)]; // whew!\n-                    ivec::pop(*idx_path);\n+                    vec::pop(*idx_path);\n                     idx += 1u;\n                 }\n               }\n             }\n           }\n         }\n-        res += ivec::map(recur, post);\n+        res += vec::map(recur, post);\n         ret res;\n       }\n     }\n@@ -356,7 +356,7 @@ fn transcribe_ident(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n fn transcribe_path(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                    p: &path_, fld: ast_fold) -> path_ {\n     // Don't substitute into qualified names.\n-    if ivec::len(p.types) > 0u || ivec::len(p.idents) != 1u { ret p; }\n+    if vec::len(p.types) > 0u || vec::len(p.idents) != 1u { ret p; }\n     ret alt follow_for_trans(cx, b.find(p.idents.(0)), idx_path) {\n           some(match_ident(id)) {\n             {global: false, idents: ~[id.node], types: ~[]}\n@@ -375,7 +375,7 @@ fn transcribe_expr(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n     ret alt e {\n           expr_path(p) {\n             // Don't substitute into qualified names.\n-            if ivec::len(p.node.types) > 0u || ivec::len(p.node.idents) != 1u\n+            if vec::len(p.node.types) > 0u || vec::len(p.node.idents) != 1u\n                {\n                 e\n             }\n@@ -452,14 +452,14 @@ fn p_t_s_rec(cx: &ext_ctxt, m: &matchable, s: &selector, b: &binders) {\n           expr_vec(p_elts, _, _) {\n             alt elts_to_ell(cx, p_elts) {\n               {pre: pre, rep: some(repeat_me), post: post} {\n-                p_t_s_r_length(cx, ivec::len(pre) + ivec::len(post),\n+                p_t_s_r_length(cx, vec::len(pre) + vec::len(post),\n                                true, s, b);\n-                if(ivec::len(pre) > 0u) {\n+                if(vec::len(pre) > 0u) {\n                     p_t_s_r_actual_vector(cx, pre, true, s, b);\n                 }\n-                p_t_s_r_ellipses(cx, repeat_me, ivec::len(pre), s, b);\n+                p_t_s_r_ellipses(cx, repeat_me, vec::len(pre), s, b);\n \n-                if(ivec::len(post) > 0u) {\n+                if(vec::len(post) > 0u) {\n                     cx.span_unimpl(e.span,\n                                    \"matching after `...` not yet supported\");\n                 }\n@@ -468,7 +468,7 @@ fn p_t_s_rec(cx: &ext_ctxt, m: &matchable, s: &selector, b: &binders) {\n                 if post != ~[] {\n                     cx.bug(\"elts_to_ell provided an invalid result\");\n                 }\n-                p_t_s_r_length(cx, ivec::len(pre), false, s, b);\n+                p_t_s_r_length(cx, vec::len(pre), false, s, b);\n                 p_t_s_r_actual_vector(cx, pre, false, s, b);\n               }\n             }\n@@ -534,7 +534,7 @@ fn p_t_s_r_path(cx: &ext_ctxt, p: &path, s: &selector, b: &binders) {\n }\n \n fn block_to_ident(blk: &blk_) -> option::t[ident] {\n-    if ivec::len(blk.stmts) != 0u { ret none; }\n+    if vec::len(blk.stmts) != 0u { ret none; }\n     ret alt blk.expr {\n           some(expr) {\n             alt expr.node { expr_path(pth) { path_to_ident(pth) } _ { none } }\n@@ -610,7 +610,7 @@ fn p_t_s_r_ellipses(cx: &ext_ctxt, repeat_me: @expr, offset: uint,\n                   expr_vec(arg_elts, _, _) {\n                     let elts = ~[];\n                     let idx = offset;\n-                    while idx < ivec::len(arg_elts) {\n+                    while idx < vec::len(arg_elts) {\n                         elts += ~[leaf(match_expr(arg_elts.(idx)))];\n                         idx += 1u;\n                     }\n@@ -637,7 +637,7 @@ fn p_t_s_r_length(cx: &ext_ctxt, len: uint, at_least: bool, s: selector,\n               match_expr(e) {\n                 alt e.node {\n                   expr_vec(arg_elts, _, _) {\n-                    let actual_len = ivec::len(arg_elts);\n+                    let actual_len = vec::len(arg_elts);\n                     if (at_least && actual_len >= len) || actual_len == len {\n                         some(leaf(match_exact))\n                     } else { none }\n@@ -655,7 +655,7 @@ fn p_t_s_r_length(cx: &ext_ctxt, len: uint, at_least: bool, s: selector,\n fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: [@expr], repeat_after: bool,\n                          s: &selector, b: &binders) {\n     let idx: uint = 0u;\n-    while idx < ivec::len(elts) {\n+    while idx < vec::len(elts) {\n         fn select(cx: &ext_ctxt, m: &matchable, idx: uint) -> match_result {\n             ret alt m {\n                   match_expr(e) {\n@@ -689,7 +689,7 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n     for arg: @expr in args {\n         alt arg.node {\n           expr_vec(elts, mut, seq_kind) {\n-            if ivec::len(elts) != 2u {\n+            if vec::len(elts) != 2u {\n                 cx.span_fatal((*arg).span,\n                               \"extension clause must consist of [\" +\n                                   \"macro invocation, expansion body]\");"}, {"sha": "94dca5ef4cf670e3298d2878f999791a6f88a2eb", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,7 +1,7 @@\n import syntax::codemap::span;\n import ast::*;\n \n-import std::ivec;\n+import std::vec;\n import std::option;\n \n export ast_fold_precursor;\n@@ -111,7 +111,7 @@ fn fold_meta_item_(mi: &@meta_item, fld: ast_fold) -> @meta_item {\n                 meta_word(id) { meta_word(fld.fold_ident(id)) }\n                 meta_list(id, mis) {\n                   let fold_meta_item = bind fold_meta_item_(_, fld);\n-                  meta_list(id, ivec::map(fold_meta_item, mis))\n+                  meta_list(id, vec::map(fold_meta_item, mis))\n                 }\n                 meta_name_value(id, s) {\n                   meta_name_value(fld.fold_ident(id), s)\n@@ -154,10 +154,10 @@ fn noop_fold_crate(c: &crate_, fld: ast_fold) -> crate_ {\n     let fold_meta_item = bind fold_meta_item_(_, fld);\n     let fold_attribute = bind fold_attribute_(_, fold_meta_item);\n \n-    ret {directives: ivec::map(fld.fold_crate_directive, c.directives),\n+    ret {directives: vec::map(fld.fold_crate_directive, c.directives),\n          module: fld.fold_mod(c.module),\n-         attrs: ivec::map(fold_attribute, c.attrs),\n-         config: ivec::map(fold_meta_item, c.config)};\n+         attrs: vec::map(fold_attribute, c.attrs),\n+         config: vec::map(fold_meta_item, c.config)};\n }\n \n fn noop_fold_crate_directive(cd: &crate_directive_, fld: ast_fold) ->\n@@ -168,7 +168,7 @@ fn noop_fold_crate_directive(cd: &crate_directive_, fld: ast_fold) ->\n           }\n           cdir_dir_mod(id, fname, cds, attrs) {\n             cdir_dir_mod(fld.fold_ident(id), fname,\n-                         ivec::map(fld.fold_crate_directive, cds), attrs)\n+                         vec::map(fld.fold_crate_directive, cds), attrs)\n           }\n           cdir_view_item(vi) { cdir_view_item(fld.fold_view_item(vi)) }\n           cdir_syntax(_) { cd }\n@@ -187,19 +187,19 @@ fn noop_fold_native_item(ni: &@native_item, fld: ast_fold) -> @native_item {\n     let fold_attribute = bind fold_attribute_(_, fold_meta_item);\n \n     ret @{ident: fld.fold_ident(ni.ident),\n-          attrs: ivec::map(fold_attribute, ni.attrs),\n+          attrs: vec::map(fold_attribute, ni.attrs),\n           node:\n               alt ni.node {\n                 native_item_ty. { native_item_ty }\n                 native_item_fn(st, fdec, typms) {\n                   native_item_fn(st,\n-                                 {inputs: ivec::map(fold_arg, fdec.inputs),\n+                                 {inputs: vec::map(fold_arg, fdec.inputs),\n                                   output: fld.fold_ty(fdec.output),\n                                   purity: fdec.purity,\n                                   il: fdec.il,\n                                   cf: fdec.cf,\n                                   constraints:\n-                                      ivec::map(fld.fold_constr,\n+                                      vec::map(fld.fold_constr,\n                                                 fdec.constraints)}, typms)\n                 }\n               },\n@@ -212,7 +212,7 @@ fn noop_fold_item(i: &@item, fld: ast_fold) -> @item {\n     let fold_attribute = bind fold_attribute_(_, fold_meta_item);\n \n     ret @{ident: fld.fold_ident(i.ident),\n-          attrs: ivec::map(fold_attribute, i.attrs),\n+          attrs: vec::map(fold_attribute, i.attrs),\n           id: i.id,\n           node: fld.fold_item_underscore(i.node),\n           span: i.span};\n@@ -234,11 +234,11 @@ fn noop_fold_item_underscore(i: &item_, fld: ast_fold) -> item_ {\n           item_native_mod(nm) { item_native_mod(fld.fold_native_mod(nm)) }\n           item_ty(t, typms) { item_ty(fld.fold_ty(t), typms) }\n           item_tag(variants, typms) {\n-            item_tag(ivec::map(fld.fold_variant, variants), typms)\n+            item_tag(vec::map(fld.fold_variant, variants), typms)\n           }\n           item_obj(o, typms, d) {\n-            item_obj({fields: ivec::map(fold_obj_field, o.fields),\n-                      methods: ivec::map(fld.fold_method, o.methods)},\n+            item_obj({fields: vec::map(fold_obj_field, o.fields),\n+                      methods: vec::map(fld.fold_method, o.methods)},\n                      typms, d)\n           }\n           item_res(dtor, did, typms, cid) {\n@@ -253,7 +253,7 @@ fn noop_fold_method(m: &method_, fld: ast_fold) -> method_ {\n \n \n fn noop_fold_block(b: &blk_, fld: ast_fold) -> blk_ {\n-    ret {stmts: ivec::map(fld.fold_stmt, b.stmts),\n+    ret {stmts: vec::map(fld.fold_stmt, b.stmts),\n          expr: option::map(fld.fold_expr, b.expr),\n          id: b.id};\n }\n@@ -269,7 +269,7 @@ fn noop_fold_stmt(s: &stmt_, fld: ast_fold) -> stmt_ {\n }\n \n fn noop_fold_arm(a: &arm, fld: ast_fold) -> arm {\n-    ret {pats: ivec::map(fld.fold_pat, a.pats),\n+    ret {pats: vec::map(fld.fold_pat, a.pats),\n          body: fld.fold_block(a.body)};\n }\n \n@@ -279,7 +279,7 @@ fn noop_fold_pat(p: &pat_, fld: ast_fold) -> pat_ {\n           pat_bind(ident) { pat_bind(fld.fold_ident(ident)) }\n           pat_lit(_) { p }\n           pat_tag(pth, pats) {\n-            pat_tag(fld.fold_path(pth), ivec::map(fld.fold_pat, pats))\n+            pat_tag(fld.fold_path(pth), vec::map(fld.fold_pat, pats))\n           }\n           pat_rec(fields, etc) {\n             let fs = ~[];\n@@ -289,15 +289,15 @@ fn noop_fold_pat(p: &pat_, fld: ast_fold) -> pat_ {\n             pat_rec(fs, etc)\n           }\n           pat_tup(elts) {\n-            pat_tup(ivec::map(fld.fold_pat, elts))\n+            pat_tup(vec::map(fld.fold_pat, elts))\n           }\n           pat_box(inner) { pat_box(fld.fold_pat(inner)) }\n         };\n }\n \n fn noop_fold_decl(d: &decl_, fld: ast_fold) -> decl_ {\n     ret alt d {\n-          decl_local(ls) { decl_local(ivec::map(fld.fold_local, ls)) }\n+          decl_local(ls) { decl_local(vec::map(fld.fold_local, ls)) }\n           decl_item(it) { decl_item(fld.fold_item(it)) }\n         }\n }\n@@ -327,10 +327,10 @@ fn noop_fold_expr(e: &expr_, fld: ast_fold) -> expr_ {\n                  alt ao.fields {\n                    option::none. { ao.fields }\n                    option::some(v) {\n-                     option::some(ivec::map(fold_anon_obj_field, v))\n+                     option::some(vec::map(fold_anon_obj_field, v))\n                    }\n                  },\n-             methods: ivec::map(fld.fold_method, ao.methods),\n+             methods: vec::map(fld.fold_method, ao.methods),\n              inner_obj: option::map(fld.fold_expr, ao.inner_obj)}\n     }\n     let fold_anon_obj = bind fold_anon_obj_(_, fld);\n@@ -343,19 +343,19 @@ fn noop_fold_expr(e: &expr_, fld: ast_fold) -> expr_ {\n             expr_vec(fld.map_exprs(fld.fold_expr, exprs), mut, seq_kind)\n           }\n           expr_rec(fields, maybe_expr) {\n-            expr_rec(ivec::map(fold_field, fields),\n+            expr_rec(vec::map(fold_field, fields),\n                      option::map(fld.fold_expr, maybe_expr))\n           }\n           expr_tup(elts) {\n-            expr_tup(ivec::map(fld.fold_expr, elts))\n+            expr_tup(vec::map(fld.fold_expr, elts))\n           }\n           expr_call(f, args) {\n             expr_call(fld.fold_expr(f), fld.map_exprs(fld.fold_expr, args))\n           }\n           expr_self_method(id) { expr_self_method(fld.fold_ident(id)) }\n           expr_bind(f, args) {\n             let opt_map_se = bind option::map(fld.fold_expr, _);\n-            expr_bind(fld.fold_expr(f), ivec::map(opt_map_se, args))\n+            expr_bind(fld.fold_expr(f), vec::map(opt_map_se, args))\n           }\n           expr_spawn(spawn_dom, name, f, args) {\n             expr_spawn(spawn_dom, name, fld.fold_expr(f),\n@@ -390,7 +390,7 @@ fn noop_fold_expr(e: &expr_, fld: ast_fold) -> expr_ {\n             expr_do_while(fld.fold_block(blk), fld.fold_expr(expr))\n           }\n           expr_alt(expr, arms) {\n-            expr_alt(fld.fold_expr(expr), ivec::map(fld.fold_arm, arms))\n+            expr_alt(fld.fold_expr(expr), vec::map(fld.fold_arm, arms))\n           }\n           expr_fn(f) { expr_fn(fld.fold_fn(f)) }\n           expr_block(blk) { expr_block(fld.fold_block(blk)) }\n@@ -459,43 +459,43 @@ fn noop_fold_fn(f: &_fn, fld: ast_fold) -> _fn {\n     let fold_arg = bind fold_arg_(_, fld);\n \n     ret {decl:\n-             {inputs: ivec::map(fold_arg, f.decl.inputs),\n+             {inputs: vec::map(fold_arg, f.decl.inputs),\n               output: fld.fold_ty(f.decl.output),\n               purity: f.decl.purity,\n               il: f.decl.il,\n               cf: f.decl.cf,\n-              constraints: ivec::map(fld.fold_constr, f.decl.constraints)},\n+              constraints: vec::map(fld.fold_constr, f.decl.constraints)},\n          proto: f.proto,\n          body: fld.fold_block(f.body)};\n }\n \n // ...nor do modules\n fn noop_fold_mod(m: &_mod, fld: ast_fold) -> _mod {\n-    ret {view_items: ivec::map(fld.fold_view_item, m.view_items),\n-         items: ivec::map(fld.fold_item, m.items)};\n+    ret {view_items: vec::map(fld.fold_view_item, m.view_items),\n+         items: vec::map(fld.fold_item, m.items)};\n }\n \n fn noop_fold_native_mod(nm: &native_mod, fld: ast_fold) -> native_mod {\n     ret {native_name: nm.native_name,\n          abi: nm.abi,\n-         view_items: ivec::map(fld.fold_view_item, nm.view_items),\n-         items: ivec::map(fld.fold_native_item, nm.items)}\n+         view_items: vec::map(fld.fold_view_item, nm.view_items),\n+         items: vec::map(fld.fold_native_item, nm.items)}\n }\n \n fn noop_fold_variant(v: &variant_, fld: ast_fold) -> variant_ {\n     fn fold_variant_arg_(va: &variant_arg, fld: ast_fold) -> variant_arg {\n         ret {ty: fld.fold_ty(va.ty), id: va.id};\n     }\n     let fold_variant_arg = bind fold_variant_arg_(_, fld);\n-    ret {name: v.name, args: ivec::map(fold_variant_arg, v.args), id: v.id};\n+    ret {name: v.name, args: vec::map(fold_variant_arg, v.args), id: v.id};\n }\n \n fn noop_fold_ident(i: &ident, fld: ast_fold) -> ident { ret i; }\n \n fn noop_fold_path(p: &path_, fld: ast_fold) -> path_ {\n     ret {global: p.global,\n-         idents: ivec::map(fld.fold_ident, p.idents),\n-         types: ivec::map(fld.fold_ty, p.types)};\n+         idents: vec::map(fld.fold_ident, p.idents),\n+         types: vec::map(fld.fold_ty, p.types)};\n }\n \n fn noop_fold_local(l: &local_, fld: ast_fold) -> local_ {\n@@ -514,7 +514,7 @@ fn noop_fold_local(l: &local_, fld: ast_fold) -> local_ {\n /* temporarily eta-expand because of a compiler bug with using `fn[T]` as a\n    value */\n fn noop_map_exprs(f: fn(&@expr) -> @expr , es: [@expr]) -> [@expr] {\n-    ret ivec::map(f, es);\n+    ret vec::map(f, es);\n }\n \n fn noop_id(i: node_id) -> node_id { ret i; }"}, {"sha": "8b7eaee15349f36bcb814b7ccf26eff5560c39ab", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,7 +1,7 @@\n \n import std::io;\n import std::int;\n-import std::ivec;\n+import std::vec;\n import std::str;\n import std::map;\n import std::map::hashmap;\n@@ -669,7 +669,7 @@ fn read_block_comment(rdr: &reader, code_to_the_left: bool) -> cmnt {\n     }\n     let style = if code_to_the_left { trailing } else { isolated };\n     consume_non_eol_whitespace(rdr);\n-    if !rdr.is_eof() && rdr.curr() != '\\n' && ivec::len(lines) == 1u {\n+    if !rdr.is_eof() && rdr.curr() != '\\n' && vec::len(lines) == 1u {\n         style = mixed;\n     }\n     log \"<<< block comment\";"}, {"sha": "2d61f6b214aef4f6057f276ad5624fb2738ec216", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,6 +1,6 @@\n \n import std::io;\n-import std::ivec;\n+import std::vec;\n import std::str;\n import std::option;\n import std::option::some;\n@@ -87,18 +87,18 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n         fn peek() -> token::token { ret tok; }\n         fn bump() {\n             last_tok_span = tok_span;\n-            if ivec::len(buffer) == 0u {\n+            if vec::len(buffer) == 0u {\n                 let next = lexer::next_token(rdr);\n                 tok = next.tok;\n                 tok_span = ast::mk_sp(next.chpos, rdr.get_chpos());\n             } else {\n-                let next = ivec::pop(buffer);\n+                let next = vec::pop(buffer);\n                 tok = next.tok;\n                 tok_span = next.span;\n             }\n         }\n         fn look_ahead(distance: uint) -> token::token {\n-            while ivec::len(buffer) < distance {\n+            while vec::len(buffer) < distance {\n                 let next = lexer::next_token(rdr);\n                 let sp = ast::mk_sp(next.chpos, rdr.get_chpos());\n                 buffer = ~[{tok: next.tok, span: sp}] + buffer;\n@@ -523,7 +523,7 @@ fn parse_ty(p: &parser, colons_before_params: bool) -> @ast::ty {\n                 p.bump();\n                 ts += ~[parse_ty(p, false)];\n             }\n-            if ivec::len(ts) == 1u {\n+            if vec::len(ts) == 1u {\n                 t = ts.(0).node;\n             } else {\n                 t = ast::ty_tup(ts);\n@@ -791,7 +791,7 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n         }\n         hi = p.get_hi_pos();\n         expect(p, token::RPAREN);\n-        if ivec::len(es) == 1u {\n+        if vec::len(es) == 1u {\n             ret mk_expr(p, lo, hi, es.(0).node);\n         } else {\n             ret mk_expr(p, lo, hi, ast::expr_tup(es));\n@@ -1023,7 +1023,7 @@ fn parse_syntax_ext(p: &parser) -> @ast::expr {\n \n fn parse_syntax_ext_naked(p: &parser, lo: uint) -> @ast::expr {\n     let pth = parse_path(p);\n-    if ivec::len(pth.node.idents) == 0u {\n+    if vec::len(pth.node.idents) == 0u {\n         p.fatal(\"expected a syntax expander name\");\n     }\n     //temporary for a backwards-compatible cycle:\n@@ -1474,7 +1474,7 @@ fn parse_pat(p: &parser) -> @ast::pat {\n                 p.bump();\n                 fields += ~[parse_pat(p)];\n             }\n-            if ivec::len(fields) == 1u { expect(p, token::COMMA); }\n+            if vec::len(fields) == 1u { expect(p, token::COMMA); }\n             hi = p.get_hi_pos();\n             expect(p, token::RPAREN);\n             pat = ast::pat_tup(fields);\n@@ -1570,7 +1570,7 @@ fn parse_source_stmt(p: &parser) -> @ast::stmt {\n         let maybe_item = parse_item(p, item_attrs);\n \n         // If we have attributes then we should have an item\n-        if ivec::len(item_attrs) > 0u {\n+        if vec::len(item_attrs) > 0u {\n             alt maybe_item {\n               some(_) {/* fallthrough */ }\n               _ { ret p.fatal(\"expected item\"); }\n@@ -1899,7 +1899,7 @@ fn parse_mod_items(p: &parser, term: token::token,\n                    first_item_attrs: &[ast::attribute]) -> ast::_mod {\n     // Shouldn't be any view items since we've already parsed an item attr\n     let view_items =\n-        if ivec::len(first_item_attrs) == 0u { parse_view(p) } else { ~[] };\n+        if vec::len(first_item_attrs) == 0u { parse_view(p) } else { ~[] };\n     let items: [@ast::item] = ~[];\n     let initial_attrs = first_item_attrs;\n     while p.peek() != term {\n@@ -1982,7 +1982,7 @@ fn parse_native_mod_items(p: &parser, native_name: &str, abi: ast::native_abi,\n     -> ast::native_mod {\n     // Shouldn't be any view items since we've already parsed an item attr\n     let view_items =\n-        if ivec::len(first_item_attrs) == 0u {\n+        if vec::len(first_item_attrs) == 0u {\n             parse_native_view(p)\n         } else { ~[] };\n     let items: [@ast::native_item] = ~[];\n@@ -2287,7 +2287,7 @@ fn parse_rest_import_name(p: &parser, first: ast::ident,\n         if glob {\n             ret ast::view_item_import_glob(identifiers, p.get_id());\n         } else {\n-            let len = ivec::len(identifiers);\n+            let len = vec::len(identifiers);\n             ret ast::view_item_import(identifiers.(len - 1u), identifiers,\n                                       p.get_id());\n         }\n@@ -2412,7 +2412,7 @@ fn parse_crate_directive(p: &parser, first_outer_attr: &[ast::attribute]) ->\n     // Collect the next attributes\n     let outer_attrs = first_outer_attr + parse_outer_attributes(p);\n     // In a crate file outer attributes are only going to apply to mods\n-    let expect_mod = ivec::len(outer_attrs) > 0u;\n+    let expect_mod = vec::len(outer_attrs) > 0u;\n \n     let lo = p.get_lo_pos();\n     if expect_mod || is_word(p, \"mod\") {\n@@ -2467,7 +2467,7 @@ fn parse_crate_directives(p: &parser, term: token::token,\n     // This is pretty ugly. If we have an outer attribute then we can't accept\n     // seeing the terminator next, so if we do see it then fail the same way\n     // parse_crate_directive would\n-    if ivec::len(first_outer_attr) > 0u && p.peek() == term {\n+    if vec::len(first_outer_attr) > 0u && p.peek() == term {\n         expect_word(p, \"mod\");\n     }\n "}, {"sha": "bd67c552cbb30acce90d150f19fbdddb35e13062", "filename": "src/comp/syntax/print/pp.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,6 +1,6 @@\n \n import std::io;\n-import std::ivec;\n+import std::vec;\n import std::str;\n \n \n@@ -76,8 +76,8 @@ fn tok_str(t: token) -> str {\n \n fn buf_str(toks: &[mutable token], szs: &[mutable int], left: uint,\n            right: uint, lim: uint) -> str {\n-    let n = ivec::len(toks);\n-    assert (n == ivec::len(szs));\n+    let n = vec::len(toks);\n+    assert (n == vec::len(szs));\n     let i = left;\n     let L = lim;\n     let s = \"[\";\n@@ -104,9 +104,9 @@ fn mk_printer(out: io::writer, linewidth: uint) -> printer {\n \n     let n: uint = 3u * linewidth;\n     log #fmt(\"mk_printer %u\", linewidth);\n-    let token: [mutable token] = ivec::init_elt_mut(EOF, n);\n-    let size: [mutable int] = ivec::init_elt_mut(0, n);\n-    let scan_stack: [mutable uint] = ivec::init_elt_mut(0u, n);\n+    let token: [mutable token] = vec::init_elt_mut(EOF, n);\n+    let size: [mutable int] = vec::init_elt_mut(0, n);\n+    let scan_stack: [mutable uint] = vec::init_elt_mut(0u, n);\n     let print_stack: [print_stack_elt] = ~[];\n     ret printer(out, n, linewidth as int, // margin\n                 linewidth as int, // space\n@@ -403,7 +403,7 @@ obj printer(out: io::writer,\n         pending_indentation += amount;\n     }\n     fn top() -> print_stack_elt {\n-        let n = ivec::len(print_stack);\n+        let n = vec::len(print_stack);\n         let top: print_stack_elt = {offset: 0, pbreak: broken(inconsistent)};\n         if n != 0u { top = print_stack.(n - 1u); }\n         ret top;\n@@ -432,8 +432,8 @@ obj printer(out: io::writer,\n           }\n           END. {\n             log \"print END -> pop END\";\n-            assert (ivec::len(print_stack) != 0u);\n-            ivec::pop(print_stack);\n+            assert (vec::len(print_stack) != 0u);\n+            vec::pop(print_stack);\n           }\n           BREAK(b) {\n             let top = self.top();"}, {"sha": "437b965226194dcf9b83e7675c11996cdfb554b5", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,5 +1,5 @@\n \n-import std::ivec;\n+import std::vec;\n import std::int;\n import std::io;\n import std::str;\n@@ -50,7 +50,7 @@ type ps =\n \n fn ibox(s: &ps, u: uint) { s.boxes += ~[pp::inconsistent]; pp::ibox(s.s, u); }\n \n-fn end(s: &ps) { ivec::pop(s.boxes); pp::end(s.s); }\n+fn end(s: &ps) { vec::pop(s.boxes); pp::end(s.s); }\n \n fn rust_printer(writer: io::writer) -> ps {\n     let boxes: [pp::breaks] = ~[];\n@@ -229,7 +229,7 @@ fn commasep[IN](s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN) ) {\n fn commasep_cmnt[IN](s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN) ,\n                      get_span: fn(&IN) -> codemap::span ) {\n     box(s, 0u, b);\n-    let len = ivec::len[IN](elts);\n+    let len = vec::len[IN](elts);\n     let i = 0u;\n     for elt: IN in elts {\n         maybe_print_comment(s, get_span(elt).hi);\n@@ -454,9 +454,9 @@ fn print_item(s: &ps, item: &@ast::item) {\n       }\n       ast::item_tag(variants, params) {\n         let newtype =\n-            ivec::len(variants) == 1u &&\n+            vec::len(variants) == 1u &&\n                 str::eq(item.ident, variants.(0).node.name) &&\n-                ivec::len(variants.(0).node.args) == 1u;\n+                vec::len(variants.(0).node.args) == 1u;\n         if newtype {\n             ibox(s, indent_unit);\n             word_space(s, \"tag\");\n@@ -475,7 +475,7 @@ fn print_item(s: &ps, item: &@ast::item) {\n                 space(s.s);\n                 maybe_print_comment(s, v.span.lo);\n                 word(s.s, v.node.name);\n-                if ivec::len(v.node.args) > 0u {\n+                if vec::len(v.node.args) > 0u {\n                     popen(s);\n                     fn print_variant_arg(s: &ps, arg: &ast::variant_arg) {\n                         print_type(s, arg.ty);\n@@ -725,7 +725,7 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         }\n         if mut == ast::mut {\n             word(s.s, \"mutable\");\n-            if ivec::len(exprs) > 0u { nbsp(s); }\n+            if vec::len(exprs) > 0u { nbsp(s); }\n         }\n         commasep_exprs(s, inconsistent, exprs);\n         word(s.s, \"]\");\n@@ -745,7 +745,7 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         commasep_cmnt(s, consistent, fields, print_field, get_span);\n         alt wth {\n           some(expr) {\n-            if ivec::len(fields) > 0u { space(s.s); }\n+            if vec::len(fields) > 0u { space(s.s); }\n             ibox(s, indent_unit);\n             word_space(s, \"with\");\n             print_expr(s, expr);\n@@ -1130,7 +1130,7 @@ fn print_path(s: &ps, path: &ast::path) {\n         if first { first = false; } else { word(s.s, \"::\"); }\n         word(s.s, id);\n     }\n-    if ivec::len(path.node.types) > 0u {\n+    if vec::len(path.node.types) > 0u {\n         word(s.s, \"[\");\n         commasep(s, inconsistent, path.node.types, print_type);\n         word(s.s, \"]\");\n@@ -1147,7 +1147,7 @@ fn print_pat(s: &ps, pat: &@ast::pat) {\n       ast::pat_lit(lit) { print_literal(s, lit); }\n       ast::pat_tag(path, args) {\n         print_path(s, path);\n-        if ivec::len(args) > 0u {\n+        if vec::len(args) > 0u {\n             popen(s);\n             commasep(s, inconsistent, args, print_pat);\n             pclose(s);\n@@ -1165,7 +1165,7 @@ fn print_pat(s: &ps, pat: &@ast::pat) {\n         fn get_span(f: &ast::field_pat) -> codemap::span { ret f.pat.span; }\n         commasep_cmnt(s, consistent, fields, print_field, get_span);\n         if etc {\n-            if ivec::len(fields) != 0u { word_space(s, \",\"); }\n+            if vec::len(fields) != 0u { word_space(s, \",\"); }\n             word(s.s, \"_\");\n         }\n         word(s.s, \"}\");\n@@ -1243,7 +1243,7 @@ fn print_kind(s: &ps, kind: ast::kind) {\n }\n \n fn print_type_params(s: &ps, params: &[ast::ty_param]) {\n-    if ivec::len(params) > 0u {\n+    if vec::len(params) > 0u {\n         word(s.s, \"[\");\n         fn printParam(s: &ps, param: &ast::ty_param) {\n             print_kind(s, param.kind);\n@@ -1280,15 +1280,15 @@ fn print_view_item(s: &ps, item: &@ast::view_item) {\n       ast::view_item_use(id, mta, _) {\n         head(s, \"use\");\n         word(s.s, id);\n-        if ivec::len(mta) > 0u {\n+        if vec::len(mta) > 0u {\n             popen(s);\n             commasep(s, consistent, mta, print_meta_item);\n             pclose(s);\n         }\n       }\n       ast::view_item_import(id, ids, _) {\n         head(s, \"import\");\n-        if !str::eq(id, ids.(ivec::len(ids) - 1u)) {\n+        if !str::eq(id, ids.(vec::len(ids) - 1u)) {\n             word_space(s, id);\n             word_space(s, \"=\");\n         }\n@@ -1419,7 +1419,7 @@ fn print_remaining_comments(s: &ps) {\n }\n \n fn in_cbox(s: &ps) -> bool {\n-    let len = ivec::len(s.boxes);\n+    let len = vec::len(s.boxes);\n     if len == 0u { ret false; }\n     ret s.boxes.(len - 1u) == pp::consistent;\n }\n@@ -1465,7 +1465,7 @@ fn lit_to_str(l: &@ast::lit) -> str { be to_str(l, print_literal); }\n fn next_lit(s: &ps) -> option::t[lexer::lit] {\n     alt s.literals {\n       some(lits) {\n-        if s.cur_lit < ivec::len(lits) {\n+        if s.cur_lit < vec::len(lits) {\n             ret some(lits.(s.cur_lit));\n         } else { ret none[lexer::lit]; }\n       }\n@@ -1490,7 +1490,7 @@ fn maybe_print_comment(s: &ps, pos: uint) {\n fn print_comment(s: &ps, cmnt: lexer::cmnt) {\n     alt cmnt.style {\n       lexer::mixed. {\n-        assert (ivec::len(cmnt.lines) == 1u);\n+        assert (vec::len(cmnt.lines) == 1u);\n         zerobreak(s.s);\n         word(s.s, cmnt.lines.(0));\n         zerobreak(s.s);\n@@ -1501,7 +1501,7 @@ fn print_comment(s: &ps, cmnt: lexer::cmnt) {\n       }\n       lexer::trailing. {\n         word(s.s, \" \");\n-        if ivec::len(cmnt.lines) == 1u {\n+        if vec::len(cmnt.lines) == 1u {\n             word(s.s, cmnt.lines.(0));\n             hardbreak(s.s);\n         } else {\n@@ -1557,7 +1557,7 @@ fn to_str[T](t: &T, f: fn(&ps, &T) ) -> str {\n fn next_comment(s: &ps) -> option::t[lexer::cmnt] {\n     alt s.comments {\n       some(cmnts) {\n-        if s.cur_cmnt < ivec::len(cmnts) {\n+        if s.cur_cmnt < vec::len(cmnts) {\n             ret some(cmnts.(s.cur_cmnt));\n         } else { ret none[lexer::cmnt]; }\n       }"}, {"sha": "39982ec4ca438fb8cf58233401d7bfa838a1c01a", "filename": "src/comp/syntax/untyped_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Funtyped_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Funtyped_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Funtyped_ast.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,5 +1,5 @@\n import std::ivec;\n-import std::ivec::map;\n+import std::vec::map;\n import std::option;\n import std::option::some;\n import std::option::none;"}, {"sha": "3dbda76f5d940bb678c6f23836a491b7697889ba", "filename": "src/comp/syntax/util/interner.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,7 +1,7 @@\n // An \"interner\" is a data structure that associates values with uint tags and\n // allows bidirectional lookup; i.e. given a value, one can easily find the\n // type, and vice versa.\n-import std::ivec;\n+import std::vec;\n import std::map;\n import std::map::hashmap;\n import std::map::hashfn;\n@@ -25,7 +25,7 @@ fn intern[@T](itr: &interner[T], val: &T) -> uint {\n     alt itr.map.find(val) {\n       some(idx) { ret idx; }\n       none. {\n-        let new_idx = ivec::len[T](itr.vect);\n+        let new_idx = vec::len[T](itr.vect);\n         itr.map.insert(val, new_idx);\n         itr.vect += ~[val];\n         ret new_idx;\n@@ -35,5 +35,5 @@ fn intern[@T](itr: &interner[T], val: &T) -> uint {\n \n fn get[T](itr: &interner[T], idx: uint) -> T { ret itr.vect.(idx); }\n \n-fn len[T](itr : &interner[T]) -> uint { ret ivec::len(itr.vect); }\n+fn len[T](itr : &interner[T]) -> uint { ret vec::len(itr.vect); }\n "}, {"sha": "b61dad50dad4b057b29e4ab887ca62b90fc8d5ed", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -154,7 +154,7 @@ fn call_kind_str(c: call_kind) -> str {\n }\n \n fn is_main_name(path: &[str]) -> bool {\n-    str::eq(option::get(std::ivec::last(path)), \"main\")\n+    str::eq(option::get(std::vec::last(path)), \"main\")\n }\n \n // FIXME mode this to std::float when editing the stdlib no longer"}, {"sha": "016056152a2ddb940be17f0bdf7891e2622a7784", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,4 +1,4 @@\n-import std::ivec;\n+import std::vec;\n import std::str;\n import std::int;\n import std::option;\n@@ -112,7 +112,7 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n         // The user should never see this if the cname is set properly!\n \n         s += \"<tag#\" + int::str(id.crate) + \":\" + int::str(id.node) + \">\";\n-        if ivec::len[t](tps) > 0u {\n+        if vec::len[t](tps) > 0u {\n             let strs: [str] = ~[];\n             for typ: t in tps { strs += ~[ty_to_str(cx, typ)]; }\n             s += \"[\" + str::connect(strs, \",\") + \"]\";"}, {"sha": "0252ecf2a3eeef909f6a08fb333a0f6837a8833b", "filename": "src/fuzzer/ast_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ffuzzer%2Fast_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ffuzzer%2Fast_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fast_match.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,10 +1,10 @@\n use std;\n-import std::ivec;\n+import std::vec;\n \n fn ivec_equal[T](v: &[T], u: &[T], element_equality_test: fn(&T, &T) -> bool )\n    -> bool {\n-    let Lv = ivec::len(v);\n-    if Lv != ivec::len(u) { ret false; }\n+    let Lv = vec::len(v);\n+    if Lv != vec::len(u) { ret false; }\n     let i = 0u;\n     while i < Lv {\n         if !element_equality_test(v.(i), u.(i)) { ret false; }"}, {"sha": "b51ed3926b4b96748e048a208d5faee7459aa254", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -8,7 +8,7 @@ import std::getopts::opt_present;\n import std::getopts::opt_str;\n import std::io;\n import std::io::stdout;\n-import std::ivec;\n+import std::vec;\n import std::str;\n import std::uint;\n import std::option;\n@@ -148,7 +148,7 @@ fn as_str(f: fn(io::writer) ) -> str {\n \n fn check_variants_of_ast(crate: &ast::crate, codemap: &codemap::codemap, filename: &str) {\n     let exprs = steal_exprs(crate);\n-    let exprsL = ivec::len(exprs);\n+    let exprsL = vec::len(exprs);\n     if (exprsL < 100u) {\n         for each i: uint in under(uint::min(exprsL, 20u)) {\n             log_err \"Replacing... \" + pprust::expr_to_str(@exprs.(i));\n@@ -316,7 +316,7 @@ fn check_roundtrip_convergence(code: &str, maxIters: uint) {\n }\n \n fn check_convergence(files: &[str]) {\n-    log_err #fmt(\"pp convergence tests: %u files\", ivec::len(files));\n+    log_err #fmt(\"pp convergence tests: %u files\", vec::len(files));\n     for file in files {\n         if !file_is_confusing(file) {\n             let s = io::read_whole_file_str(file);\n@@ -346,7 +346,7 @@ fn check_variants(files: &[str]) {\n }\n \n fn main(args: [str]) {\n-    if ivec::len(args) != 2u {\n+    if vec::len(args) != 2u {\n         log_err #fmt(\"usage: %s <testdir>\", args.(0));\n         ret;\n     }"}, {"sha": "bb9caf05697e74f5b7ed32b33e2449668923e8fb", "filename": "src/lib/aio.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Faio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Faio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Faio.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,5 +1,5 @@\n import task;\n-import ivec;\n+import vec;\n \n import comm;\n import comm::_chan;\n@@ -55,7 +55,7 @@ tag request {\n type ctx = _chan[request];\n \n fn ip_to_sbuf(ip: net::ip_addr) -> *u8 {\n-    ivec::to_ptr(str::bytes(net::format_addr(ip)))\n+    vec::to_ptr(str::bytes(net::format_addr(ip)))\n }\n \n fn connect_task(ip: net::ip_addr, portnum: int, evt: _chan[socket_event]) {\n@@ -78,8 +78,8 @@ fn new_client(client: client, evt: _chan[socket_event]) {\n         log \"waiting for bytes\";\n         let data: [u8] = reader.recv();\n         log \"got some bytes\";\n-        log ivec::len[u8](data);\n-        if (ivec::len[u8](data) == 0u) {\n+        log vec::len[u8](data);\n+        if (vec::len[u8](data) == 0u) {\n             log \"got empty buffer, bailing\";\n             break;\n         }\n@@ -145,7 +145,7 @@ fn request_task(c: _chan[ctx]) {\n           }\n           write(socket,v,status) {\n             rustrt::aio_writedata(socket,\n-                                  ivec::to_ptr[u8](v), ivec::len[u8](v),\n+                                  vec::to_ptr[u8](v), vec::len[u8](v),\n                                   status);\n           }\n           close_server(server,status) {"}, {"sha": "444d388059e120f75fd642ee6ac5ac76b38b66a1", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -32,13 +32,13 @@ fn uint_bits() -> uint { ret 32u + (1u << 32u >> 27u); }\n \n fn create(nbits: uint, init: bool) -> t {\n     let elt = if init { !0u } else { 0u };\n-    let storage = ivec::init_elt_mut[uint](elt, nbits / uint_bits() + 1u);\n+    let storage = vec::init_elt_mut[uint](elt, nbits / uint_bits() + 1u);\n     ret @{storage: storage, nbits: nbits};\n }\n \n fn process(op: &block(uint, uint) -> uint , v0: &t, v1: &t) -> bool {\n-    let len = ivec::len(v1.storage);\n-    assert (ivec::len(v0.storage) == len);\n+    let len = vec::len(v1.storage);\n+    assert (vec::len(v0.storage) == len);\n     assert (v0.nbits == v1.nbits);\n     let changed = false;\n     for each i: uint in uint::range(0u, len) {\n@@ -69,8 +69,8 @@ fn assign(v0: &t, v1: t) -> bool {\n }\n \n fn clone(v: t) -> t {\n-    let storage = ivec::init_elt_mut[uint](0u, v.nbits / uint_bits() + 1u);\n-    let len = ivec::len(v.storage);\n+    let storage = vec::init_elt_mut[uint](0u, v.nbits / uint_bits() + 1u);\n+    let len = vec::len(v.storage);\n     for each i: uint in uint::range(0u, len) { storage.(i) = v.storage.(i); }\n     ret @{storage: storage, nbits: v.nbits};\n }\n@@ -88,7 +88,7 @@ fn equal(v0: &t, v1: &t) -> bool {\n     // FIXME: when we can break or return from inside an iterator loop,\n     //        we can eliminate this painful while-loop\n \n-    let len = ivec::len(v1.storage);\n+    let len = vec::len(v1.storage);\n     let i = 0u;\n     while i < len {\n         if v0.storage.(i) != v1.storage.(i) { ret false; }\n@@ -98,7 +98,7 @@ fn equal(v0: &t, v1: &t) -> bool {\n }\n \n fn clear(v: &t) {\n-    for each i: uint in uint::range(0u, ivec::len(v.storage)) {\n+    for each i: uint in uint::range(0u, vec::len(v.storage)) {\n         v.storage.(i) = 0u;\n     }\n }\n@@ -108,7 +108,7 @@ fn set_all(v: &t) {\n }\n \n fn invert(v: &t) {\n-    for each i: uint in uint::range(0u, ivec::len(v.storage)) {\n+    for each i: uint in uint::range(0u, vec::len(v.storage)) {\n         v.storage.(i) = !v.storage.(i);\n     }\n }\n@@ -150,7 +150,7 @@ fn init_to_vec(v: t, i: uint) -> uint { ret if get(v, i) { 1u } else { 0u }; }\n \n fn to_vec(v: &t) -> [uint] {\n     let sub = bind init_to_vec(v, _);\n-    ret ivec::init_fn[uint](sub, v.nbits);\n+    ret vec::init_fn[uint](sub, v.nbits);\n }\n \n fn to_str(v: &t) -> str {\n@@ -162,7 +162,7 @@ fn to_str(v: &t) -> str {\n }\n \n fn eq_ivec(v0: &t, v1: &[uint]) -> bool {\n-    assert (v0.nbits == ivec::len[uint](v1));\n+    assert (v0.nbits == vec::len[uint](v1));\n     let len = v0.nbits;\n     let i = 0u;\n     while i < len {"}, {"sha": "65cae49ab16e2a25900b399278ce27d35a40265d", "filename": "src/lib/deque.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -28,7 +28,7 @@ fn create[@T]() -> t[T] {\n \n     fn grow[@T](nelts: uint, lo: uint, elts: &[mutable cell[T]]) ->\n        [mutable cell[T]] {\n-        assert (nelts == ivec::len(elts));\n+        assert (nelts == vec::len(elts));\n         let rv = ~[mutable];\n \n         let i = 0u;\n@@ -53,11 +53,11 @@ fn create[@T]() -> t[T] {\n         fn add_front(t: &T) {\n             let oldlo: uint = lo;\n             if lo == 0u {\n-                lo = ivec::len[cell[T]](elts) - 1u;\n+                lo = vec::len[cell[T]](elts) - 1u;\n             } else { lo -= 1u; }\n             if lo == hi {\n                 elts = grow[T](nelts, oldlo, elts);\n-                lo = ivec::len[cell[T]](elts) - 1u;\n+                lo = vec::len[cell[T]](elts) - 1u;\n                 hi = nelts;\n             }\n             elts.(lo) = option::some[T](t);\n@@ -70,7 +70,7 @@ fn create[@T]() -> t[T] {\n                 hi = nelts;\n             }\n             elts.(hi) = option::some[T](t);\n-            hi = (hi + 1u) % ivec::len[cell[T]](elts);\n+            hi = (hi + 1u) % vec::len[cell[T]](elts);\n             nelts += 1u;\n         }\n \n@@ -81,13 +81,13 @@ fn create[@T]() -> t[T] {\n         fn pop_front() -> T {\n             let t: T = get[T](elts, lo);\n             elts.(lo) = option::none[T];\n-            lo = (lo + 1u) % ivec::len[cell[T]](elts);\n+            lo = (lo + 1u) % vec::len[cell[T]](elts);\n             nelts -= 1u;\n             ret t;\n         }\n         fn pop_back() -> T {\n             if hi == 0u {\n-                hi = ivec::len[cell[T]](elts) - 1u;\n+                hi = vec::len[cell[T]](elts) - 1u;\n             } else { hi -= 1u; }\n             let t: T = get[T](elts, hi);\n             elts.(hi) = option::none[T];\n@@ -97,12 +97,12 @@ fn create[@T]() -> t[T] {\n         fn peek_front() -> T { ret get[T](elts, lo); }\n         fn peek_back() -> T { ret get[T](elts, hi - 1u); }\n         fn get(i: int) -> T {\n-            let idx: uint = (lo + (i as uint)) % ivec::len[cell[T]](elts);\n+            let idx: uint = (lo + (i as uint)) % vec::len[cell[T]](elts);\n             ret get[T](elts, idx);\n         }\n     }\n     let v: [mutable cell[T]] =\n-        ivec::init_elt_mut(option::none, initial_capacity);\n+        vec::init_elt_mut(option::none, initial_capacity);\n     ret deque[T](0u, 0u, 0u, v);\n }\n // Local Variables:"}, {"sha": "b7603affb6ce7c3b8bc9e1afd958d09717f55f44", "filename": "src/lib/ebml.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febml.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -40,7 +40,7 @@ fn vint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n }\n \n fn new_doc(data: &@[u8]) -> doc {\n-    ret {data: data, start: 0u, end: ivec::len[u8](*data)};\n+    ret {data: data, start: 0u, end: vec::len[u8](*data)};\n }\n \n fn doc_at(data: &@[u8], start: uint) -> doc {\n@@ -96,7 +96,7 @@ iter tagged_docs(d: doc, tg: uint) -> doc {\n     }\n }\n \n-fn doc_data(d: doc) -> [u8] { ret ivec::slice[u8](*d.data, d.start, d.end); }\n+fn doc_data(d: doc) -> [u8] { ret vec::slice[u8](*d.data, d.start, d.end); }\n \n fn be_uint_from_bytes(data: &@[u8], start: uint, size: uint) -> uint {\n     let sz = size;\n@@ -167,7 +167,7 @@ fn start_tag(w: &writer, tag_id: uint) {\n }\n \n fn end_tag(w: &writer) {\n-    let last_size_pos = ivec::pop[uint](w.size_positions);\n+    let last_size_pos = vec::pop[uint](w.size_positions);\n     let cur_pos = w.writer.tell();\n     w.writer.seek(last_size_pos as int, io::seek_set);\n     write_sized_vint(w.writer, cur_pos - last_size_pos - 4u, 4u);"}, {"sha": "e188b74ab02bc16c89f8ba29801ef62b90520eca", "filename": "src/lib/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -372,7 +372,7 @@ mod rt {\n \n     // FIXME: This might be useful in str: but needs to be utf8 safe first\n     fn str_init_elt(c: char, n_elts: uint) -> str {\n-        let svec = ivec::init_elt[u8](c as u8, n_elts);\n+        let svec = vec::init_elt[u8](c as u8, n_elts);\n \n         ret str::unsafe_from_bytes(svec);\n     }"}, {"sha": "f7795520ef5d93a506d3f932ae2191af5cc13c8b", "filename": "src/lib/getopts.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgetopts.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -77,7 +77,7 @@ fn name_str(nm: name) -> str {\n \n fn find_opt(opts: &[opt], nm: name) -> option::t[uint] {\n     let i = 0u;\n-    let l = ivec::len[opt](opts);\n+    let l = vec::len[opt](opts);\n     while i < l { if opts.(i).name == nm { ret some[uint](i); } i += 1u; }\n     ret none[uint];\n }\n@@ -107,11 +107,11 @@ fn fail_str(f: fail_) -> str {\n tag result { success(match); failure(fail_); }\n \n fn getopts(args: &[str], opts: &[opt]) -> result {\n-    let n_opts = ivec::len[opt](opts);\n+    let n_opts = vec::len[opt](opts);\n     fn f(x: uint) -> [optval] { ret ~[]; }\n-    let vals = ivec::init_fn_mut[[optval]](f, n_opts);\n+    let vals = vec::init_fn_mut[[optval]](f, n_opts);\n     let free: [str] = ~[];\n-    let l = ivec::len[str](args);\n+    let l = vec::len[str](args);\n     let i = 0u;\n     while i < l {\n         let cur = args.(i);\n@@ -163,7 +163,7 @@ fn getopts(args: &[str], opts: &[opt]) -> result {\n                   maybe. {\n                     if !option::is_none[str](i_arg) {\n                         vals.(optid) += ~[val(option::get(i_arg))];\n-                    } else if (name_pos < ivec::len[name](names) ||\n+                    } else if (name_pos < vec::len[name](names) ||\n                                    i + 1u == l || is_arg(args.(i + 1u))) {\n                         vals.(optid) += ~[given];\n                     } else { i += 1u; vals.(optid) += ~[val(args.(i))]; }\n@@ -182,7 +182,7 @@ fn getopts(args: &[str], opts: &[opt]) -> result {\n     }\n     i = 0u;\n     while i < n_opts {\n-        let n = ivec::len[optval](vals.(i));\n+        let n = vec::len[optval](vals.(i));\n         let occ = opts.(i).occur;\n         if occ == req {\n             if n == 0u {\n@@ -209,7 +209,7 @@ fn opt_vals(m: &match, nm: str) -> [optval] {\n fn opt_val(m: &match, nm: str) -> optval { ret opt_vals(m, nm).(0); }\n \n fn opt_present(m: &match, nm: str) -> bool {\n-    ret ivec::len[optval](opt_vals(m, nm)) > 0u;\n+    ret vec::len[optval](opt_vals(m, nm)) > 0u;\n }\n \n fn opt_str(m: &match, nm: str) -> str {\n@@ -226,7 +226,7 @@ fn opt_strs(m: &match, nm: str) -> [str] {\n \n fn opt_maybe_str(m: &match, nm: str) -> option::t[str] {\n     let vals = opt_vals(m, nm);\n-    if ivec::len[optval](vals) == 0u { ret none[str]; }\n+    if vec::len[optval](vals) == 0u { ret none[str]; }\n     ret alt vals.(0) { val(s) { some[str](s) } _ { none[str] } };\n }\n \n@@ -236,7 +236,7 @@ fn opt_maybe_str(m: &match, nm: str) -> option::t[str] {\n /// present and an argument was provided.\n fn opt_default(m: &match, nm: str, def: str) -> option::t[str] {\n     let vals = opt_vals(m, nm);\n-    if ivec::len[optval](vals) == 0u { ret none[str]; }\n+    if vec::len[optval](vals) == 0u { ret none[str]; }\n     ret alt vals.(0) { val(s) { some[str](s) } _ { some[str](def) } }\n }\n // Local Variables:"}, {"sha": "808c4e84c98220d2f731ba0e4c3e416f08e5b8ea", "filename": "src/lib/io.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -62,9 +62,9 @@ resource FILE_res(f: os::libc::FILE) {\n obj FILE_buf_reader(f: os::libc::FILE, res: option::t[@FILE_res]) {\n     fn read(len: uint) -> [u8] {\n         let buf = ~[];\n-        ivec::reserve[u8](buf, len);\n-        let read = os::libc::fread(ivec::to_ptr[u8](buf), 1u, len, f);\n-        ivec::unsafe::set_len[u8](buf, read);\n+        vec::reserve[u8](buf, len);\n+        let read = os::libc::fread(vec::to_ptr[u8](buf), 1u, len, f);\n+        vec::unsafe::set_len[u8](buf, read);\n         ret buf;\n     }\n     fn read_byte() -> int { ret os::libc::fgetc(f); }\n@@ -196,24 +196,24 @@ type byte_buf = @{buf: [u8], mutable pos: uint};\n \n obj byte_buf_reader(bbuf: byte_buf) {\n     fn read(len: uint) -> [u8] {\n-        let rest = ivec::len[u8](bbuf.buf) - bbuf.pos;\n+        let rest = vec::len[u8](bbuf.buf) - bbuf.pos;\n         let to_read = len;\n         if rest < to_read { to_read = rest; }\n-        let range = ivec::slice[u8](bbuf.buf, bbuf.pos, bbuf.pos + to_read);\n+        let range = vec::slice[u8](bbuf.buf, bbuf.pos, bbuf.pos + to_read);\n         bbuf.pos += to_read;\n         ret range;\n     }\n     fn read_byte() -> int {\n-        if bbuf.pos == ivec::len[u8](bbuf.buf) { ret -1; }\n+        if bbuf.pos == vec::len[u8](bbuf.buf) { ret -1; }\n         let b = bbuf.buf.(bbuf.pos);\n         bbuf.pos += 1u;\n         ret b as int;\n     }\n     fn unread_byte(byte: int) { log_err \"TODO: unread_byte\"; fail; }\n-    fn eof() -> bool { ret bbuf.pos == ivec::len[u8](bbuf.buf); }\n+    fn eof() -> bool { ret bbuf.pos == vec::len[u8](bbuf.buf); }\n     fn seek(offset: int, whence: seek_style) {\n         let pos = bbuf.pos;\n-        let len = ivec::len[u8](bbuf.buf);\n+        let len = vec::len[u8](bbuf.buf);\n         bbuf.pos = seek_in_buf(offset, pos, len, whence);\n     }\n     fn tell() -> uint { ret bbuf.pos; }\n@@ -245,8 +245,8 @@ type buf_writer =\n \n obj FILE_writer(f: os::libc::FILE, res: option::t[@FILE_res]) {\n     fn write(v: &[u8]) {\n-        let len = ivec::len[u8](v);\n-        let vbuf = ivec::to_ptr[u8](v);\n+        let len = vec::len[u8](v);\n+        let vbuf = vec::to_ptr[u8](v);\n         let nout = os::libc::fwrite(vbuf, len, 1u, f);\n         if nout < 1u { log_err \"error dumping buffer\"; }\n     }\n@@ -264,11 +264,11 @@ resource fd_res(fd: int) {\n \n obj fd_buf_writer(fd: int, res: option::t[@fd_res]) {\n     fn write(v: &[u8]) {\n-        let len = ivec::len[u8](v);\n+        let len = vec::len[u8](v);\n         let count = 0u;\n         let vbuf;\n         while count < len {\n-            vbuf = ptr::offset(ivec::to_ptr[u8](v), count);\n+            vbuf = ptr::offset(vec::to_ptr[u8](v), count);\n             let nout = os::libc::write(fd, vbuf, len);\n             if nout < 0 {\n                 log_err \"error dumping buffer\";\n@@ -401,18 +401,18 @@ obj byte_buf_writer(buf: mutable_byte_buf) {\n     fn write(v: &[u8]) {\n         // Fast path.\n \n-        if buf.pos == ivec::len(buf.buf) {\n+        if buf.pos == vec::len(buf.buf) {\n             for b: u8 in v { buf.buf += ~[mutable b]; }\n-            buf.pos += ivec::len[u8](v);\n+            buf.pos += vec::len[u8](v);\n             ret;\n         }\n         // FIXME: Optimize: These should be unique pointers.\n \n-        let vlen = ivec::len[u8](v);\n+        let vlen = vec::len[u8](v);\n         let vpos = 0u;\n         while vpos < vlen {\n             let b = v.(vpos);\n-            if buf.pos == ivec::len(buf.buf) {\n+            if buf.pos == vec::len(buf.buf) {\n                 buf.buf += ~[mutable b];\n             } else { buf.buf.(buf.pos) = b; }\n             buf.pos += 1u;\n@@ -421,7 +421,7 @@ obj byte_buf_writer(buf: mutable_byte_buf) {\n     }\n     fn seek(offset: int, whence: seek_style) {\n         let pos = buf.pos;\n-        let len = ivec::len(buf.buf);\n+        let len = vec::len(buf.buf);\n         buf.pos = seek_in_buf(offset, pos, len, whence);\n     }\n     fn tell() -> uint { ret buf.pos; }\n@@ -431,7 +431,7 @@ fn string_writer() -> str_writer {\n     // FIXME: yikes, this is bad. Needs fixing of mutable syntax.\n \n     let b: [mutable u8] = ~[mutable 0u8];\n-    ivec::pop(b);\n+    vec::pop(b);\n     let buf: mutable_byte_buf = @{mutable buf: b, mutable pos: 0u};\n     obj str_writer_wrap(wr: writer, buf: mutable_byte_buf) {\n         fn get_writer() -> writer { ret wr; }"}, {"sha": "cd379abd7502223ed86ee75aff005c4ff031d22a", "filename": "src/lib/list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -9,7 +9,7 @@ fn from_vec[@T](v: &[T]) -> list[T] {\n     // a reverse vector iterator. Unfortunately generic iterators seem not to\n     // work yet.\n \n-    for item: T in ivec::reversed(v) { l = cons[T](item, @l); }\n+    for item: T in vec::reversed(v) { l = cons[T](item, @l); }\n     ret l;\n }\n "}, {"sha": "3d9c11e90612c6ce69b28bbc06586736ed08f8aa", "filename": "src/lib/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -27,7 +27,7 @@ fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n     let load_factor: util::rational = {num: 3, den: 4};\n     tag bucket[@K, @V] { nil; deleted; some(K, V); }\n     fn make_buckets[@K, @V](nbkts: uint) -> [mutable (bucket[K, V])] {\n-        ret ivec::init_elt_mut[bucket[K, V]](nil[K, V], nbkts);\n+        ret vec::init_elt_mut[bucket[K, V]](nil[K, V], nbkts);\n     }\n     // Derive two hash functions from the one given by taking the upper\n     // half and lower half of the uint bits.  Our bucket probing"}, {"sha": "8b8b8113d8d4c5bc6367105a7026f5d975e9962d", "filename": "src/lib/net.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fnet.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,5 +1,5 @@\n import str;\n-import ivec;\n+import vec;\n import uint;\n \n tag ip_addr {\n@@ -20,8 +20,8 @@ fn format_addr(ip : ip_addr) -> str {\n }\n \n fn parse_addr(ip : str) -> ip_addr {\n-    let parts = ivec::map(uint::from_str, str::split(ip, \".\".(0)));\n-    if ivec::len(parts) != 4u { fail \"Too many dots in IP address\"; }\n+    let parts = vec::map(uint::from_str, str::split(ip, \".\".(0)));\n+    if vec::len(parts) != 4u { fail \"Too many dots in IP address\"; }\n     for i in parts { if i > 255u { fail \"Invalid IP Address part.\"; } }\n     ipv4(parts.(0) as u8,\n          parts.(1) as u8,"}, {"sha": "1a84e0faf5a32505be3269e8a0cd31b19b6b65fa", "filename": "src/lib/posix_fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fposix_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fposix_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fposix_fs.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -24,7 +24,7 @@ fn list_dir(path: str) -> [str] {\n             os::libc::closedir(dir);\n             ret result;\n         }\n-        ivec::push[str](result, rustrt::rust_dirent_filename(ent));\n+        vec::push[str](result, rustrt::rust_dirent_filename(ent));\n     }\n     os::libc::closedir(dir);\n     ret result;"}, {"sha": "5c5f110816bb8b4cd554764ac8adb465cc76821f", "filename": "src/lib/run_program.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frun_program.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -25,7 +25,7 @@ fn spawn_process(prog: str, args: &[str], in_fd: int, out_fd: int,\n     // pointer to its buffer\n     let argv = arg_vec(prog, args);\n     let pid = rustrt::rust_run_program(\n-        ivec::to_ptr(argv), in_fd, out_fd, err_fd);\n+        vec::to_ptr(argv), in_fd, out_fd, err_fd);\n     ret pid;\n }\n "}, {"sha": "dc487180867a325a5f862bbc5fe92463b7ae754e", "filename": "src/lib/sha1.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -82,8 +82,8 @@ fn mk_sha1() -> sha1 {\n     fn process_msg_block(st: &sha1state) {\n         // FIXME: Make precondition\n \n-        assert (ivec::len(st.h) == digest_buf_len);\n-        assert (ivec::len(st.work_buf) == work_buf_len);\n+        assert (vec::len(st.h) == digest_buf_len);\n+        assert (vec::len(st.work_buf) == work_buf_len);\n         let t: int; // Loop counter\n \n         let w = st.work_buf;\n@@ -187,7 +187,7 @@ fn mk_sha1() -> sha1 {\n     fn pad_msg(st: &sha1state) {\n         // FIXME: Should be a precondition\n \n-        assert (ivec::len(st.msg_block) == msg_block_len);\n+        assert (vec::len(st.msg_block) == msg_block_len);\n         /*\n          * Check to see if the current message block is too small to hold\n          * the initial padding bits and length.  If so, we will pad the\n@@ -226,7 +226,7 @@ fn mk_sha1() -> sha1 {\n         fn reset() {\n             // FIXME: Should be typestate precondition\n \n-            assert (ivec::len(st.h) == digest_buf_len);\n+            assert (vec::len(st.h) == digest_buf_len);\n             st.len_low = 0u32;\n             st.len_high = 0u32;\n             st.msg_block_idx = 0u;\n@@ -248,13 +248,13 @@ fn mk_sha1() -> sha1 {\n         }\n     }\n     let st =\n-        {h: ivec::init_elt_mut[u32](0u32, digest_buf_len),\n+        {h: vec::init_elt_mut[u32](0u32, digest_buf_len),\n          mutable len_low: 0u32,\n          mutable len_high: 0u32,\n-         msg_block: ivec::init_elt_mut[u8](0u8, msg_block_len),\n+         msg_block: vec::init_elt_mut[u8](0u8, msg_block_len),\n          mutable msg_block_idx: 0u,\n          mutable computed: false,\n-         work_buf: ivec::init_elt_mut[u32](0u32, work_buf_len)};\n+         work_buf: vec::init_elt_mut[u32](0u32, work_buf_len)};\n     let sh = sha1(st);\n     sh.reset();\n     ret sh;"}, {"sha": "c3da9dfa3663c40d8e1a866f3864fb9d9438212e", "filename": "src/lib/smallintmap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsmallintmap.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -15,11 +15,11 @@ fn mk[@T]() -> smallintmap[T] {\n }\n \n fn insert[@T](m: &smallintmap[T], key: uint, val: &T) {\n-    ivec::grow_set[option::t[T]](m.v, key, none[T], some[T](val));\n+    vec::grow_set[option::t[T]](m.v, key, none[T], some[T](val));\n }\n \n fn find[@T](m: &smallintmap[T], key: uint) -> option::t[T] {\n-    if key < ivec::len[option::t[T]](m.v) { ret m.v.(key); }\n+    if key < vec::len[option::t[T]](m.v) { ret m.v.(key); }\n     ret none[T];\n }\n \n@@ -35,10 +35,10 @@ fn contains_key[@T](m: &smallintmap[T], key: uint) -> bool {\n }\n \n fn truncate[@T](m: &smallintmap[T], len: uint) {\n-    m.v = ivec::slice_mut[option::t[T]](m.v, 0u, len);\n+    m.v = vec::slice_mut[option::t[T]](m.v, 0u, len);\n }\n \n fn max_key[T](m: &smallintmap[T]) -> uint {\n-    ret ivec::len[option::t[T]](m.v);\n+    ret vec::len[option::t[T]](m.v);\n }\n "}, {"sha": "0aa8c5b6d13599d7f793aecbae508ac55d9a6b80", "filename": "src/lib/sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,6 +1,6 @@\n \n-import ivec::len;\n-import ivec::slice;\n+import vec::len;\n+import vec::slice;\n \n export merge_sort;\n export quick_sort;"}, {"sha": "ea70265fc6bbbf1078dfe7489dd579b233164e06", "filename": "src/lib/std.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -14,7 +14,7 @@ mod int;\n mod uint;\n mod u8;\n mod u64;\n-mod ivec;\n+mod vec;\n mod str;\n \n // General io and system-services modules."}, {"sha": "2bf8864bc72bd9fe24aba502f3832ea0ed623b7f", "filename": "src/lib/str.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -132,7 +132,7 @@ const tag_six_b: uint = 252u;\n \n fn is_utf8(v: &[u8]) -> bool {\n     let i = 0u;\n-    let total = ivec::len[u8](v);\n+    let total = vec::len[u8](v);\n     while i < total {\n         let chsize = utf8_char_width(v.(i));\n         if chsize == 0u { ret false; }\n@@ -185,7 +185,7 @@ fn buf(s: &str) -> sbuf { ret rustrt::str_buf(s); }\n fn bytes(s: str) -> [u8] {\n     let sbuffer = buf(s);\n     let ptr = unsafe::reinterpret_cast(sbuffer);\n-    ret ivec::unsafe::from_buf(ptr, byte_len(s));\n+    ret vec::unsafe::from_buf(ptr, byte_len(s));\n }\n \n fn unsafe_from_bytes(v: &[mutable? u8]) -> str {\n@@ -496,13 +496,13 @@ fn replace(s: str, from: str, to: str) : is_not_empty(from) -> str {\n \n // FIXME: Also not efficient\n fn char_slice(s: &str, begin: uint, end: uint) -> str {\n-    from_chars(ivec::slice(to_chars(s), begin, end))\n+    from_chars(vec::slice(to_chars(s), begin, end))\n }\n \n fn trim_left(s: &str) -> str {\n     fn count_whities(s: &[char]) -> uint {\n         let i = 0u;\n-        while i < ivec::len(s) {\n+        while i < vec::len(s) {\n             if !char::is_whitespace(s.(i)) {\n                 break;\n             }\n@@ -512,12 +512,12 @@ fn trim_left(s: &str) -> str {\n     }\n     let chars = to_chars(s);\n     let whities = count_whities(chars);\n-    ret from_chars(ivec::slice(chars, whities, ivec::len(chars)));\n+    ret from_chars(vec::slice(chars, whities, vec::len(chars)));\n }\n \n fn trim_right(s: &str) -> str {\n     fn count_whities(s: &[char]) -> uint {\n-        let i = ivec::len(s);\n+        let i = vec::len(s);\n         while 0u < i {\n             if !char::is_whitespace(s.(i - 1u)) {\n                 break;\n@@ -528,7 +528,7 @@ fn trim_right(s: &str) -> str {\n     }\n     let chars = to_chars(s);\n     let whities = count_whities(chars);\n-    ret from_chars(ivec::slice(chars, 0u, whities));\n+    ret from_chars(vec::slice(chars, 0u, whities));\n }\n \n fn trim(s: &str) -> str {"}, {"sha": "46f166995d6bdf2897ec5d0a741ce65696ea0049", "filename": "src/lib/test.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -50,7 +50,7 @@ type test_desc = {name: test_name, fn: test_fn, ignore: bool};\n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs (generated at compile time).\n fn test_main_ivec(args: &[str], tests: &[test_desc]) {\n-    check (ivec::is_not_empty(args));\n+    check (vec::is_not_empty(args));\n     let opts =\n         alt parse_opts(args) {\n           either::left(o) { o }\n@@ -60,19 +60,19 @@ fn test_main_ivec(args: &[str], tests: &[test_desc]) {\n }\n \n fn test_main(args: &vec[str], tests: &[test_desc]) {\n-    test_main_ivec(ivec::from_vec(args), tests);\n+    test_main_ivec(vec::from_vec(args), tests);\n }\n \n type test_opts = {filter: option::t[str], run_ignored: bool};\n \n type opt_res = either::t[test_opts, str];\n \n // Parses command line arguments into test options\n-fn parse_opts(args: &[str]) : ivec::is_not_empty(args) -> opt_res {\n+fn parse_opts(args: &[str]) : vec::is_not_empty(args) -> opt_res {\n \n     // FIXME (#649): Shouldn't have to check here\n-    check (ivec::is_not_empty(args));\n-    let args_ = ivec::tail(args);\n+    check (vec::is_not_empty(args));\n+    let args_ = vec::tail(args);\n     let opts = ~[getopts::optflag(\"ignored\")];\n     let match =\n         alt getopts::getopts(args_, opts) {\n@@ -81,7 +81,7 @@ fn parse_opts(args: &[str]) : ivec::is_not_empty(args) -> opt_res {\n         };\n \n     let filter =\n-        if ivec::len(match.free) > 0u {\n+        if vec::len(match.free) > 0u {\n             option::some(match.free.(0))\n         } else { option::none };\n \n@@ -121,7 +121,7 @@ fn run_tests_console_(opts: &test_opts, tests: &[test_desc],\n     fn callback(event: testevent, st: test_state) {\n         alt event {\n           te_filtered(filtered_tests) {\n-            st.total = ivec::len(filtered_tests);\n+            st.total = vec::len(filtered_tests);\n             st.out.write_line(#fmt(\"\\nrunning %u tests\", st.total));\n           }\n           te_wait(test) {\n@@ -230,13 +230,13 @@ fn run_tests(opts: &test_opts, tests: &[test_desc],\n     // result of a particular test for an unusually long amount of time.\n     let concurrency = get_concurrency();\n     log #fmt(\"using %u test tasks\", concurrency);\n-    let total = ivec::len(filtered_tests);\n+    let total = vec::len(filtered_tests);\n     let run_idx = 0u;\n     let wait_idx = 0u;\n     let futures = ~[];\n \n     while wait_idx < total {\n-        while ivec::len(futures) < concurrency && run_idx < total {\n+        while vec::len(futures) < concurrency && run_idx < total {\n             futures += ~[run_test(filtered_tests.(run_idx), to_task)];\n             run_idx += 1u;\n         }\n@@ -245,7 +245,7 @@ fn run_tests(opts: &test_opts, tests: &[test_desc],\n         callback(te_wait(future.test));\n         let result = future.wait();\n         callback(te_result(future.test, result));\n-        futures = ivec::slice(futures, 1u, ivec::len(futures));\n+        futures = vec::slice(futures, 1u, vec::len(futures));\n         wait_idx += 1u;\n     }\n }\n@@ -275,7 +275,7 @@ fn filter_tests(opts: &test_opts, tests: &[test_desc]) -> [test_desc] {\n                      }(_, filter_str);\n \n \n-            ivec::filter_map(filter, filtered)\n+            vec::filter_map(filter, filtered)\n         };\n \n     // Maybe pull out the ignored test and unignore them\n@@ -293,7 +293,7 @@ fn filter_tests(opts: &test_opts, tests: &[test_desc]) -> [test_desc] {\n                 };\n \n \n-            ivec::filter_map(filter, filtered)\n+            vec::filter_map(filter, filtered)\n         };\n \n     // Sort the tests alphabetically"}, {"sha": "ecaec5357977de9e249cbab36078bcf6debfeb3f", "filename": "src/lib/ufind.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fufind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fufind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fufind.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -13,7 +13,7 @@ type ufind = {mutable nodes: [mutable node]};\n fn make() -> ufind { ret {mutable nodes: ~[mutable]}; }\n \n fn make_set(ufnd: &ufind) -> uint {\n-    let idx = ivec::len(ufnd.nodes);\n+    let idx = vec::len(ufnd.nodes);\n     ufnd.nodes += ~[mutable none[uint]];\n     ret idx;\n }\n@@ -40,13 +40,13 @@ fn union(ufnd: &ufind, m: uint, n: uint) {\n     } else if (m_root > n_root) { ufnd.nodes.(m_root) = some[uint](n_root); }\n }\n \n-fn set_count(ufnd: &ufind) -> uint { ret ivec::len[node](ufnd.nodes); }\n+fn set_count(ufnd: &ufind) -> uint { ret vec::len[node](ufnd.nodes); }\n \n \n // Removes all sets with IDs greater than or equal to the given value.\n fn prune(ufnd: &ufind, n: uint) {\n     // TODO: Use \"slice\" once we get rid of \"mutable?\"\n \n-    let len = ivec::len[node](ufnd.nodes);\n-    while len != n { ivec::pop[node](ufnd.nodes); len -= 1u; }\n+    let len = vec::len[node](ufnd.nodes);\n+    while len != n { vec::pop[node](ufnd.nodes); len -= 1u; }\n }"}, {"sha": "7925f3ba951236dfae64185a1d1bfb5ec02357f6", "filename": "src/lib/uint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fuint.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -43,8 +43,8 @@ fn next_power_of_two(n: uint) -> uint {\n }\n \n fn parse_buf(buf: &[u8], radix: uint) -> uint {\n-    if ivec::len[u8](buf) == 0u { log_err \"parse_buf(): buf is empty\"; fail; }\n-    let i = ivec::len[u8](buf) - 1u;\n+    if vec::len[u8](buf) == 0u { log_err \"parse_buf(): buf is empty\"; fail; }\n+    let i = vec::len[u8](buf) - 1u;\n     let power = 1u;\n     let n = 0u;\n     while true {"}, {"sha": "be2a1eeea6ffeb93bc51da675b5108b2fb2609d9", "filename": "src/lib/vec.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "previous_filename": "src/lib/ivec.rs"}, {"sha": "344bd6606473d3139161aeecc4f24936efe008a7", "filename": "src/test/bench/shootout-fannkuchredux.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,15 +1,15 @@\n // Based on Isaac Gouy's fannkuchredux.csharp\n use std;\n import std::int;\n-import std::ivec;\n+import std::vec;\n \n fn fannkuch(n: int) -> int {\n     fn perm1init(i: uint) -> int { ret i as int; }\n     let perm1init_ = perm1init; // Rustboot workaround\n \n-    let perm = ivec::init_elt_mut(0, n as uint);\n-    let perm1 = ivec::init_fn_mut(perm1init_, n as uint);\n-    let count = ivec::init_elt_mut(0, n as uint);\n+    let perm = vec::init_elt_mut(0, n as uint);\n+    let perm1 = vec::init_fn_mut(perm1init_, n as uint);\n+    let count = vec::init_elt_mut(0, n as uint);\n     let f = 0;\n     let i = 0;\n     let k = 0;"}, {"sha": "cf83653261f4446039ec9ac13ac6f3e6379676cf", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -6,7 +6,7 @@\n  * http://shootout.alioth.debian.org/\n  */\n use std;\n-import std::ivec;\n+import std::vec;\n import std::str;\n import std::uint;\n import std::int;\n@@ -40,7 +40,7 @@ fn select_random(r: u32, genelist: &[aminoacids]) -> char {\n             } else { be bisect(v, mid, hi, target); }\n         } else { ret v.(hi).ch; }\n     }\n-    ret bisect(genelist, 0u, ivec::len[aminoacids](genelist) - 1u, r);\n+    ret bisect(genelist, 0u, vec::len[aminoacids](genelist) - 1u, r);\n }\n \n fn make_random_fasta(id: str, desc: str, genelist: &[aminoacids], n: int) {"}, {"sha": "72f44507afa58a8770fb96db034457e884aa01d7", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -11,7 +11,7 @@\n \n use std;\n \n-import std::ivec;\n+import std::vec;\n import std::uint;\n import std::time;\n import std::str;\n@@ -52,7 +52,7 @@ type config = {stress: bool};\n fn parse_opts(argv: [str]) -> config {\n     let opts = ~[getopts::optflag(\"stress\")];\n \n-    let opt_args = ivec::slice(argv, 1u, ivec::len(argv));\n+    let opt_args = vec::slice(argv, 1u, vec::len(argv));\n \n \n     alt getopts::getopts(opt_args, opts) {\n@@ -80,7 +80,7 @@ fn stress(num_tasks: int) {\n }\n \n fn main(argv: [str]) {\n-    if ivec::len(argv) == 1u {\n+    if vec::len(argv) == 1u {\n         assert (fib(8) == 21);\n         log fib(8);\n     } else {"}, {"sha": "50182155ad94ad9ec2864424d75645272a4cd88a", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::ivec;\n+import std::vec;\n import std::task;\n import std::uint;\n import std::str;\n@@ -16,7 +16,7 @@ fn g() {}\n \n fn main(args: [str]) {\n \n-    let n = if ivec::len(args) < 2u {\n+    let n = if vec::len(args) < 2u {\n         10u\n     } else {\n         uint::parse_buf(str::bytes(args.(1)), 10u)"}, {"sha": "05d2050abb88b1e9158bd5907b1760fa457d84b3", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -15,7 +15,7 @@ import std::option::some;\n import std::option::none;\n import std::str;\n import std::map;\n-import std::ivec;\n+import std::vec;\n import std::io;\n \n import std::time;\n@@ -158,7 +158,7 @@ mod map_reduce {\n \n         let tasks = start_mappers(ctrl.mk_chan(), inputs);\n \n-        let num_mappers = ivec::len(inputs) as int;\n+        let num_mappers = vec::len(inputs) as int;\n \n         while num_mappers > 0 {\n             alt ctrl.recv() {\n@@ -199,7 +199,7 @@ mod map_reduce {\n }\n \n fn main(argv: [str]) {\n-    if ivec::len(argv) < 2u {\n+    if vec::len(argv) < 2u {\n         let out = io::stdout();\n \n         out.write_line(#fmt(\"Usage: %s <filename> ...\", argv.(0)));\n@@ -216,7 +216,7 @@ fn main(argv: [str]) {\n \n     let start = time::precise_time_ns();\n \n-    map_reduce::map_reduce(ivec::slice(argv, 1u, ivec::len(argv)));\n+    map_reduce::map_reduce(vec::slice(argv, 1u, vec::len(argv)));\n     let stop = time::precise_time_ns();\n \n     let elapsed = stop - start;"}, {"sha": "c25c7229e22160643f9cc8dfaf3eebf1e72d9a0c", "filename": "src/test/compile-fail/alias-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fcompile-fail%2Falias-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fcompile-fail%2Falias-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falias-mismatch.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,6 +1,6 @@\n // error-pattern:expected argument mode\n use std;\n-import std::ivec::map;\n+import std::vec::map;\n \n fn main() {\n     fn f(i: uint) -> bool { true }"}, {"sha": "708db61bda43703a38aa83299b1509b04b808bbc", "filename": "src/test/compile-fail/bad-module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fcompile-fail%2Fbad-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fcompile-fail%2Fbad-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-module.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,4 +1,4 @@\n // error-pattern: unresolved import: ivec\n import ivec;\n \n-fn main() { let foo = ivec::len([]); }\n\\ No newline at end of file\n+fn main() { let foo = vec::len([]); }\n\\ No newline at end of file"}, {"sha": "3771851cfaea727d72dfb94156317ea0fcc6728b", "filename": "src/test/compile-fail/cross-crate-glob-collision.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fcompile-fail%2Fcross-crate-glob-collision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fcompile-fail%2Fcross-crate-glob-collision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcross-crate-glob-collision.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -3,7 +3,7 @@\n \n use std;\n // expecting swap to be defined in vec\n-import std::ivec::*;\n+import std::vec::*;\n import alternate_supplier::*;\n \n mod alternate_supplier {"}, {"sha": "d3d44b007546c587a2cea32e747df7bd1233d31d", "filename": "src/test/compiletest/compiletest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcompiletest.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -3,7 +3,7 @@ import std::getopts;\n import std::test;\n import std::fs;\n import std::str;\n-import std::ivec;\n+import std::vec;\n import std::task;\n import std::task::task_id;\n \n@@ -38,8 +38,8 @@ fn parse_config(args: &[str]) -> config {\n           getopts::optflag(\"ignored\"), getopts::optopt(\"runtool\"),\n           getopts::optopt(\"rustcflags\"), getopts::optflag(\"verbose\")];\n \n-    check (ivec::is_not_empty(args));\n-    let args_ = ivec::tail(args);\n+    check (vec::is_not_empty(args));\n+    let args_ = vec::tail(args);\n     let match =\n         alt getopts::getopts(args_, opts) {\n           getopts::success(m) { m }\n@@ -55,7 +55,7 @@ fn parse_config(args: &[str]) -> config {\n          mode: str_mode(getopts::opt_str(match, \"mode\")),\n          run_ignored: getopts::opt_present(match, \"ignored\"),\n          filter:\n-             if ivec::len(match.free) > 0u {\n+             if vec::len(match.free) > 0u {\n                  option::some(match.free.(0))\n              } else { option::none },\n          runtool: getopts::opt_maybe_str(match, \"runtool\"),"}, {"sha": "2c39ab377ca35fc07aadb52ddf9411dc57c16dc3", "filename": "src/test/compiletest/procsrv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fprocsrv.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -9,7 +9,7 @@ import std::task;\n import std::task::task_id;\n import std::generic_os::setenv;\n import std::generic_os::getenv;\n-import std::ivec;\n+import std::vec;\n import std::os;\n import std::run;\n import std::io;\n@@ -186,15 +186,15 @@ fn export_lib_path(path: &str) { setenv(util::lib_path_env_var(), path); }\n \n fn clone_ivecstr(v: &[str]) -> [[u8]] {\n     let r = ~[];\n-    for t: str in ivec::slice(v, 0u, ivec::len(v)) {\n+    for t: str in vec::slice(v, 0u, vec::len(v)) {\n         r += ~[str::bytes(t)];\n     }\n     ret r;\n }\n \n fn clone_ivecu8str(v: &[[u8]]) -> [str] {\n     let r = ~[];\n-    for t in ivec::slice(v, 0u, ivec::len(v)) {\n+    for t in vec::slice(v, 0u, vec::len(v)) {\n         r += ~[str::unsafe_from_bytes(t)];\n     }\n     ret r;"}, {"sha": "f5bcd8c9623db615faa0abd8148ab9eb5f33b991", "filename": "src/test/compiletest/runtest.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fruntest.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -3,7 +3,7 @@ import std::str;\n import std::option;\n import std::fs;\n import std::os;\n-import std::ivec;\n+import std::vec;\n import std::test;\n \n import common::mode_run_pass;\n@@ -117,10 +117,10 @@ fn run_pretty_test(cx: &cx, props: &test_props, testfile: &str) {\n         io::read_whole_file_str(filepath)\n       }\n       option::none. {\n-        srcs.(ivec::len(srcs) - 2u)\n+        srcs.(vec::len(srcs) - 2u)\n       }\n     };\n-    let actual = srcs.(ivec::len(srcs) - 1u);\n+    let actual = srcs.(vec::len(srcs) - 1u);\n \n     if option::is_some(props.pp_exact) {\n         // Now we have to care about line endings\n@@ -186,7 +186,7 @@ actual:\\n\\\n \n fn check_error_patterns(props: &test_props, testfile: &str,\n                         procres: &procres) {\n-    if ivec::is_empty(props.error_patterns) {\n+    if vec::is_empty(props.error_patterns) {\n         fatal(\"no error pattern specified in \" + testfile);\n     }\n \n@@ -196,7 +196,7 @@ fn check_error_patterns(props: &test_props, testfile: &str,\n         if str::find(line, next_err_pat) > 0 {\n             log #fmt(\"found error pattern %s\", next_err_pat);\n             next_err_idx += 1u;\n-            if next_err_idx == ivec::len(props.error_patterns) {\n+            if next_err_idx == vec::len(props.error_patterns) {\n                 log \"found all error patterns\";\n                 ret;\n             }\n@@ -205,9 +205,9 @@ fn check_error_patterns(props: &test_props, testfile: &str,\n     }\n \n     let missing_patterns =\n-        ivec::slice(props.error_patterns, next_err_idx,\n-                    ivec::len(props.error_patterns));\n-    if ivec::len(missing_patterns) == 1u {\n+        vec::slice(props.error_patterns, next_err_idx,\n+                    vec::len(props.error_patterns));\n+    if vec::len(missing_patterns) == 1u {\n         fatal_procres(#fmt(\"error pattern '%s' not found!\",\n                            missing_patterns.(0)), procres);\n     } else {\n@@ -268,7 +268,7 @@ fn make_run_args(config: &config,\n     };\n \n     let args = toolargs + ~[make_exe_name(config, testfile)];\n-    ret {prog: args.(0), args: ivec::slice(args, 1u, ivec::len(args))};\n+    ret {prog: args.(0), args: vec::slice(args, 1u, vec::len(args))};\n }\n \n fn split_maybe_args(argstr: &option::t[str]) -> [str] {\n@@ -288,7 +288,7 @@ fn split_maybe_args(argstr: &option::t[str]) -> [str] {\n             }\n             ret true;\n         }\n-        ivec::filter_map(flt, v)\n+        vec::filter_map(flt, v)\n     }\n \n     alt argstr {\n@@ -356,7 +356,7 @@ fn output_base_name(config: &config, testfile: &str) -> str {\n     let filename =\n         {\n             let parts = str::split(fs::basename(testfile), '.' as u8);\n-            parts = ivec::slice(parts, 0u, ivec::len(parts) - 1u);\n+            parts = vec::slice(parts, 0u, vec::len(parts) - 1u);\n             str::connect(parts, \".\")\n         };\n     #fmt(\"%s%s.%s\", base, filename, config.stage_id)"}, {"sha": "5153a81d1c77b072109021b9b27ac40149092b10", "filename": "src/test/run-pass/block-vec-map2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Frun-pass%2Fblock-vec-map2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Frun-pass%2Fblock-vec-map2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-vec-map2.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,10 +1,10 @@\n use std;\n-import std::ivec;\n+import std::vec;\n \n fn main() {\n-    let v = std::ivec::map2({|&i, &b| if b { -i } else { i }},\n-                            ~[1, 2, 3, 4, 5],\n-                            ~[true, false, false, true, true]);\n+    let v = std::vec::map2({|&i, &b| if b { -i } else { i }},\n+                           ~[1, 2, 3, 4, 5],\n+                           ~[true, false, false, true, true]);\n     log_err v;\n     assert v == ~[-1, 2, 3, -4, -5];\n }"}, {"sha": "d5e38519e914bff1908714b9c932bf47378a73fc", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -10,7 +10,7 @@ import option = std::option::t;\n import std::option::some;\n import std::option::none;\n import std::str;\n-import std::ivec;\n+import std::vec;\n import std::map;\n import std::task;\n import std::comm::_chan;\n@@ -73,7 +73,7 @@ mod map_reduce {\n \n         start_mappers(ctrl.mk_chan(), inputs);\n \n-        let num_mappers = ivec::len(inputs) as int;\n+        let num_mappers = vec::len(inputs) as int;\n \n         while num_mappers > 0 {\n             alt ctrl.recv() {"}, {"sha": "f1b3bc855cdc89996b756c96f527f5ed65b57556", "filename": "src/test/run-pass/import-glob-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-crate.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,6 +1,6 @@\n \n use std;\n-import std::ivec::*;\n+import std::vec::*;\n \n fn main() {\n     let v = init_elt(0, 0u);"}, {"sha": "b987b11700c0c36905b8ea32e55ab063061a6a73", "filename": "src/test/run-pass/issue-687.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Frun-pass%2Fissue-687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Frun-pass%2Fissue-687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-687.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,5 +1,5 @@\n use std;\n-import std::ivec;\n+import std::vec;\n import std::task;\n import std::comm;\n import std::comm::_chan;\n@@ -22,12 +22,12 @@ fn packager(cb: _chan[_chan[[u8]]], msg: _chan[msg]) {\n         log \"waiting for bytes\";\n         let data = p.recv();\n         log \"got bytes\";\n-        if ivec::len(data) == 0u {\n+        if vec::len(data) == 0u {\n             log \"got empty bytes, quitting\";\n             break;\n         }\n         log \"sending non-empty buffer of length\";\n-        log ivec::len(data);\n+        log vec::len(data);\n         send(msg, received(data));\n         log \"sent non-empty buffer\";\n     }\n@@ -51,7 +51,7 @@ fn main() {\n           closed. { log \"Got close message\"; break; }\n           received(data) {\n             log \"Got data. Length is:\";\n-            log ivec::len[u8](data);\n+            log vec::len[u8](data);\n           }\n         }\n     }"}, {"sha": "ecc636e17add7d92b0bb41ee5d6798750452dddc", "filename": "src/test/run-pass/mod-view-items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Frun-pass%2Fmod-view-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Frun-pass%2Fmod-view-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmod-view-items.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -6,8 +6,8 @@\n \n mod m {\n     use std;\n-    import std::ivec;\n-    fn f() -> [int] { ivec::init_elt(0, 1u) }\n+    import std::vec;\n+    fn f() -> [int] { vec::init_elt(0, 1u) }\n }\n \n fn main() { let x = m::f(); }\n\\ No newline at end of file"}, {"sha": "7d76d4a5d2c4a0ed04b555b802b76f62cce17afb", "filename": "src/test/run-pass/mutable-alias-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -10,7 +10,7 @@ fn main() {\n     grow(v);\n     grow(v);\n     grow(v);\n-    let len = std::ivec::len[int](v);\n+    let len = std::vec::len[int](v);\n     log len;\n     assert (len == 3 as uint);\n }\n\\ No newline at end of file"}, {"sha": "6d88e1a97fdd73beecf90f03fc1aae6a3db452a3", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,6 +1,6 @@\n use std;\n import std::str;\n-import std::ivec;\n+import std::vec;\n \n fn main() {\n     // Chars of 1, 2, 3, and 4 bytes\n@@ -9,7 +9,7 @@ fn main() {\n \n     assert (str::byte_len(s) == 10u);\n     assert (str::char_len(s) == 4u);\n-    assert (ivec::len[char](str::to_chars(s)) == 4u);\n+    assert (vec::len[char](str::to_chars(s)) == 4u);\n     assert (str::eq(str::from_chars(str::to_chars(s)), s));\n     assert (str::char_at(s, 0u) == 'e');\n     assert (str::char_at(s, 1u) == '\u00e9');"}, {"sha": "cdde7f7340ae84b3b7a9e9289aa37bd1f8cf697d", "filename": "src/test/run-pass/vec-append.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Frun-pass%2Fvec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Frun-pass%2Fvec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-append.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -3,7 +3,7 @@\n // -*- rust -*-\n use std;\n import std::str;\n-import std::ivec;\n+import std::vec;\n \n // FIXME: import std::dbg::const_refcount. Currently\n // cross-crate const references don't work.\n@@ -57,9 +57,9 @@ fn slow_growth2_helper(s: str) { // ref up: s\n         assert (str::refcount(s) == const_refcount);\n         assert (str::refcount(mumble) == const_refcount);\n         log v.(0);\n-        log ivec::len[str](v);\n+        log vec::len[str](v);\n         assert (str::eq(v.(0), mumble));\n-        assert (ivec::len[str](v) == 1u);\n+        assert (vec::len[str](v) == 1u);\n     } // ref down: mumble, s,\n \n     log str::refcount(s);"}, {"sha": "323132d19c33c01d962ab32cf98ec3e7705df5b0", "filename": "src/test/run-pass/vec-self-append.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Frun-pass%2Fvec-self-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Frun-pass%2Fvec-self-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-self-append.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -3,16 +3,16 @@\n // xfail-stage3\n \n use std;\n-import std::ivec;\n+import std::vec;\n \n fn main() {\n     // Make sure we properly handle repeated self-appends.\n     let a: [int] = ~[0];\n     let i = 20;\n     let expected_len = 1u;\n     while i > 0 {\n-        log_err ivec::len(a);\n-        assert (ivec::len(a) == expected_len);\n+        log_err vec::len(a);\n+        assert (vec::len(a) == expected_len);\n         a += a;\n         i -= 1;\n         expected_len *= 2u;"}, {"sha": "d95a0cf414a4cef9f309db7d87caec790a11a1d5", "filename": "src/test/stdtest/bitv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fbitv.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,14 +1,14 @@\n \n use std;\n-import std::ivec;\n+import std::vec;\n import std::bitv;\n \n #[test]\n fn test_0_elements() {\n     let act;\n     let exp;\n     act = bitv::create(0u, false);\n-    exp = ivec::init_elt[uint](0u, 0u);\n+    exp = vec::init_elt[uint](0u, 0u);\n     // FIXME: why can't I write vec[uint]()?\n \n     assert (bitv::eq_ivec(act, exp));"}, {"sha": "b4d8d6286ad5fa568aa467ab6d900d15d1cbea05", "filename": "src/test/stdtest/either.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Feither.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,6 +1,6 @@\n use std;\n import std::either::*;\n-import std::ivec::len;\n+import std::vec::len;\n \n #[test]\n fn test_either_left() {"}, {"sha": "10acbafcb12d3f67393bca9d6f09559f4dc3eb81", "filename": "src/test/stdtest/getopts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fgetopts.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,6 +1,6 @@\n \n use std;\n-import std::ivec;\n+import std::vec;\n import std::option;\n import opt = std::getopts;\n "}, {"sha": "0abf551a28f456e9a869a7c74c68ea625c1fa973", "filename": "src/test/stdtest/qsort.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Fqsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Fqsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fqsort.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -2,11 +2,11 @@\n use std;\n \n import std::sort;\n-import std::ivec;\n+import std::vec;\n import std::int;\n \n fn check_sort(v1: &[mutable int], v2: &[mutable int]) {\n-    let len = std::ivec::len[int](v1);\n+    let len = std::vec::len[int](v1);\n     fn ltequal(a: &int, b: &int) -> bool { ret a <= b; }\n     let f = ltequal;\n     std::sort::quick_sort[int](f, v1);\n@@ -49,7 +49,7 @@ fn test_simple() {\n     fn lteq(a: &int, b: &int) -> bool { int::le(a, b) }\n     sort::quick_sort(lteq, names);\n \n-    let pairs = ivec::zip(expected, ivec::from_mut(names));\n+    let pairs = vec::zip(expected, vec::from_mut(names));\n     for (a, b) in pairs {\n         log #fmt(\"%d %d\", a, b);\n         assert (a == b);"}, {"sha": "707e17967cdf942a7fbf813fcfb353bbe2ad76b0", "filename": "src/test/stdtest/qsort3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Fqsort3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Fqsort3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fqsort3.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -2,7 +2,7 @@\n use std;\n \n fn check_sort(v1: &[mutable int], v2: &[mutable int]) {\n-    let len = std::ivec::len[int](v1);\n+    let len = std::vec::len[int](v1);\n     fn lt(a: &int, b: &int) -> bool { ret a < b; }\n     fn equal(a: &int, b: &int) -> bool { ret a == b; }\n     let f1 = lt;"}, {"sha": "7476cb6621bd8b777f8c95aac62853fbc6acad5f", "filename": "src/test/stdtest/run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Frun.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -4,7 +4,7 @@ import std::os;\n import std::io;\n import std::option;\n import std::str;\n-import std::ivec;\n+import std::vec;\n \n // Regression test for memory leaks\n #[cfg(target_os = \"linux\")]"}, {"sha": "ef581d18c693cfd176e66c5f82dafdcdffda8a41", "filename": "src/test/stdtest/sha1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fsha1.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -4,7 +4,7 @@\n \n use std;\n import std::sha1;\n-import std::ivec;\n+import std::vec;\n import std::str;\n \n #[test]\n@@ -61,8 +61,8 @@ fn test() {\n                 0x10u8, 0x0du8, 0xb4u8, 0xb3u8]}];\n     let tests = fips_180_1_tests + wikipedia_tests;\n     fn check_vec_eq(v0: &[u8], v1: &[u8]) {\n-        assert (ivec::len[u8](v0) == ivec::len[u8](v1));\n-        let len = ivec::len[u8](v0);\n+        assert (vec::len[u8](v0) == vec::len[u8](v1));\n+        let len = vec::len[u8](v0);\n         let i = 0u;\n         while i < len {\n             let a = v0.(i);"}, {"sha": "f4f7d5ea75e342c6048aa1d6bec81a1fe008f029", "filename": "src/test/stdtest/sort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fsort.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -2,7 +2,7 @@\n use std;\n \n fn check_sort(v1: &[int], v2: &[int]) {\n-    let len = std::ivec::len[int](v1);\n+    let len = std::vec::len[int](v1);\n     fn lteq(a: &int, b: &int) -> bool { ret a <= b; }\n     let f = lteq;\n     let v3 = std::sort::merge_sort[int](f, v1);"}, {"sha": "dd5ed29a3cff2a3b9097c05476c0253e06b34e60", "filename": "src/test/stdtest/stdtest.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Fstdtest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Fstdtest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstdtest.rc?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -9,7 +9,7 @@ mod fs;\n mod getopts;\n mod int;\n mod io;\n-mod ivec;\n+mod vec;\n mod list;\n mod map;\n mod net;"}, {"sha": "e85829b4477450c55f838f90661cf85fc0aa66ff", "filename": "src/test/stdtest/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftest.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -2,7 +2,7 @@ import std::test;\n import std::str;\n import std::option;\n import std::either;\n-import std::ivec;\n+import std::vec;\n \n #[test]\n fn do_not_run_ignored_tests() {\n@@ -27,15 +27,15 @@ fn ignored_tests_result_in_ignored() {\n #[test]\n fn first_free_arg_should_be_a_filter() {\n     let args = ~[\"progname\", \"filter\"];\n-    check (ivec::is_not_empty(args));\n+    check (vec::is_not_empty(args));\n     let opts = alt test::parse_opts(args) { either::left(o) { o } };\n     assert (str::eq(\"filter\", option::get(opts.filter)));\n }\n \n #[test]\n fn parse_ignored_flag() {\n     let args = ~[\"progname\", \"filter\", \"--ignored\"];\n-    check (ivec::is_not_empty(args));\n+    check (vec::is_not_empty(args));\n     let opts = alt test::parse_opts(args) { either::left(o) { o } };\n     assert (opts.run_ignored);\n }\n@@ -51,7 +51,7 @@ fn filter_for_ignored_option() {\n           {name: \"2\", fn: fn () { }, ignore: false}];\n     let filtered = test::filter_tests(opts, tests);\n \n-    assert (ivec::len(filtered) == 1u);\n+    assert (vec::len(filtered) == 1u);\n     assert (filtered.(0).name == \"1\");\n     assert (filtered.(0).ignore == false);\n }\n@@ -86,7 +86,7 @@ fn sort_tests() {\n           \"test::ignored_tests_result_in_ignored\", \"test::parse_ignored_flag\",\n           \"test::sort_tests\"];\n \n-    let pairs = ivec::zip(expected, filtered);\n+    let pairs = vec::zip(expected, filtered);\n \n \n     for (a, b) in pairs {"}, {"sha": "22f3cef783a54d93d57f159b655ace3bd406cb1e", "filename": "src/test/stdtest/vec.rs", "status": "renamed", "additions": 75, "deletions": 75, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fvec.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -1,7 +1,7 @@\n \n use std;\n-import std::ivec;\n-import std::ivec::*;\n+import std::vec;\n+import std::vec::*;\n import std::option;\n import std::option::none;\n import std::option::some;\n@@ -21,29 +21,29 @@ fn add(x: &uint, y: &uint) -> uint { ret x + y; }\n #[test]\n fn test_reserve_and_on_heap() {\n     let v: [int] = ~[1, 2];\n-    assert (!ivec::on_heap(v));\n-    ivec::reserve(v, 8u);\n-    assert (ivec::on_heap(v));\n+    assert (!vec::on_heap(v));\n+    vec::reserve(v, 8u);\n+    assert (vec::on_heap(v));\n }\n \n #[test]\n fn test_unsafe_ptrs() {\n     // Test on-stack copy-from-buf.\n     let a = ~[1, 2, 3];\n-    let ptr = ivec::to_ptr(a);\n+    let ptr = vec::to_ptr(a);\n     let b = ~[];\n-    ivec::unsafe::copy_from_buf(b, ptr, 3u);\n-    assert (ivec::len(b) == 3u);\n+    vec::unsafe::copy_from_buf(b, ptr, 3u);\n+    assert (vec::len(b) == 3u);\n     assert (b.(0) == 1);\n     assert (b.(1) == 2);\n     assert (b.(2) == 3);\n \n     // Test on-heap copy-from-buf.\n     let c = ~[1, 2, 3, 4, 5];\n-    ptr = ivec::to_ptr(c);\n+    ptr = vec::to_ptr(c);\n     let d = ~[];\n-    ivec::unsafe::copy_from_buf(d, ptr, 5u);\n-    assert (ivec::len(d) == 5u);\n+    vec::unsafe::copy_from_buf(d, ptr, 5u);\n+    assert (vec::len(d) == 5u);\n     assert (d.(0) == 1);\n     assert (d.(1) == 2);\n     assert (d.(2) == 3);\n@@ -54,15 +54,15 @@ fn test_unsafe_ptrs() {\n #[test]\n fn test_init_fn() {\n     // Test on-stack init_fn.\n-    let v = ivec::init_fn(square, 3u);\n-    assert (ivec::len(v) == 3u);\n+    let v = vec::init_fn(square, 3u);\n+    assert (vec::len(v) == 3u);\n     assert (v.(0) == 0u);\n     assert (v.(1) == 1u);\n     assert (v.(2) == 4u);\n \n     // Test on-heap init_fn.\n-    v = ivec::init_fn(square, 5u);\n-    assert (ivec::len(v) == 5u);\n+    v = vec::init_fn(square, 5u);\n+    assert (vec::len(v) == 5u);\n     assert (v.(0) == 0u);\n     assert (v.(1) == 1u);\n     assert (v.(2) == 4u);\n@@ -73,13 +73,13 @@ fn test_init_fn() {\n #[test]\n fn test_init_elt() {\n     // Test on-stack init_elt.\n-    let v = ivec::init_elt(10u, 2u);\n-    assert (ivec::len(v) == 2u);\n+    let v = vec::init_elt(10u, 2u);\n+    assert (vec::len(v) == 2u);\n     assert (v.(0) == 10u);\n     assert (v.(1) == 10u);\n \n     // Test on-heap init_elt.\n-    v = ivec::init_elt(20u, 6u);\n+    v = vec::init_elt(20u, 6u);\n     assert (v.(0) == 20u);\n     assert (v.(1) == 20u);\n     assert (v.(2) == 20u);\n@@ -90,62 +90,62 @@ fn test_init_elt() {\n \n #[test]\n fn test_is_empty() {\n-    assert (ivec::is_empty[int](~[]));\n-    assert (!ivec::is_empty(~[0]));\n+    assert (vec::is_empty[int](~[]));\n+    assert (!vec::is_empty(~[0]));\n }\n \n #[test]\n fn test_is_not_empty() {\n-    assert (ivec::is_not_empty(~[0]));\n-    assert (!ivec::is_not_empty[int](~[]));\n+    assert (vec::is_not_empty(~[0]));\n+    assert (!vec::is_not_empty[int](~[]));\n }\n \n #[test]\n fn test_head() {\n     let a = ~[11, 12];\n-    check (ivec::is_not_empty(a));\n-    assert (ivec::head(a) == 11);\n+    check (vec::is_not_empty(a));\n+    assert (vec::head(a) == 11);\n }\n \n #[test]\n fn test_tail() {\n     let a = ~[11];\n-    check (ivec::is_not_empty(a));\n-    assert (ivec::tail(a) == ~[]);\n+    check (vec::is_not_empty(a));\n+    assert (vec::tail(a) == ~[]);\n \n     a = ~[11, 12];\n-    check (ivec::is_not_empty(a));\n-    assert (ivec::tail(a) == ~[12]);\n+    check (vec::is_not_empty(a));\n+    assert (vec::tail(a) == ~[12]);\n }\n \n #[test]\n fn test_last() {\n-    let n = ivec::last(~[]);\n+    let n = vec::last(~[]);\n     assert (n == none);\n-    n = ivec::last(~[1, 2, 3]);\n+    n = vec::last(~[1, 2, 3]);\n     assert (n == some(3));\n-    n = ivec::last(~[1, 2, 3, 4, 5]);\n+    n = vec::last(~[1, 2, 3, 4, 5]);\n     assert (n == some(5));\n }\n \n #[test]\n fn test_slice() {\n     // Test on-stack -> on-stack slice.\n-    let v = ivec::slice(~[1, 2, 3], 1u, 3u);\n-    assert (ivec::len(v) == 2u);\n+    let v = vec::slice(~[1, 2, 3], 1u, 3u);\n+    assert (vec::len(v) == 2u);\n     assert (v.(0) == 2);\n     assert (v.(1) == 3);\n \n     // Test on-heap -> on-stack slice.\n-    v = ivec::slice(~[1, 2, 3, 4, 5], 0u, 3u);\n-    assert (ivec::len(v) == 3u);\n+    v = vec::slice(~[1, 2, 3, 4, 5], 0u, 3u);\n+    assert (vec::len(v) == 3u);\n     assert (v.(0) == 1);\n     assert (v.(1) == 2);\n     assert (v.(2) == 3);\n \n     // Test on-heap -> on-heap slice.\n-    v = ivec::slice(~[1, 2, 3, 4, 5, 6], 1u, 6u);\n-    assert (ivec::len(v) == 5u);\n+    v = vec::slice(~[1, 2, 3, 4, 5, 6], 1u, 6u);\n+    assert (vec::len(v) == 5u);\n     assert (v.(0) == 2);\n     assert (v.(1) == 3);\n     assert (v.(2) == 4);\n@@ -157,16 +157,16 @@ fn test_slice() {\n fn test_pop() {\n     // Test on-stack pop.\n     let v = ~[1, 2, 3];\n-    let e = ivec::pop(v);\n-    assert (ivec::len(v) == 2u);\n+    let e = vec::pop(v);\n+    assert (vec::len(v) == 2u);\n     assert (v.(0) == 1);\n     assert (v.(1) == 2);\n     assert (e == 3);\n \n     // Test on-heap pop.\n     v = ~[1, 2, 3, 4, 5];\n-    e = ivec::pop(v);\n-    assert (ivec::len(v) == 4u);\n+    e = vec::pop(v);\n+    assert (vec::len(v) == 4u);\n     assert (v.(0) == 1);\n     assert (v.(1) == 2);\n     assert (v.(2) == 3);\n@@ -178,14 +178,14 @@ fn test_pop() {\n fn test_grow() {\n     // Test on-stack grow().\n     let v = ~[];\n-    ivec::grow(v, 2u, 1);\n-    assert (ivec::len(v) == 2u);\n+    vec::grow(v, 2u, 1);\n+    assert (vec::len(v) == 2u);\n     assert (v.(0) == 1);\n     assert (v.(1) == 1);\n \n     // Test on-heap grow().\n-    ivec::grow(v, 3u, 2);\n-    assert (ivec::len(v) == 5u);\n+    vec::grow(v, 3u, 2);\n+    assert (vec::len(v) == 5u);\n     assert (v.(0) == 1);\n     assert (v.(1) == 1);\n     assert (v.(2) == 2);\n@@ -196,8 +196,8 @@ fn test_grow() {\n #[test]\n fn test_grow_fn() {\n     let v = ~[];\n-    ivec::grow_fn(v, 3u, square);\n-    assert (ivec::len(v) == 3u);\n+    vec::grow_fn(v, 3u, square);\n+    assert (vec::len(v) == 3u);\n     assert (v.(0) == 0u);\n     assert (v.(1) == 1u);\n     assert (v.(2) == 4u);\n@@ -206,8 +206,8 @@ fn test_grow_fn() {\n #[test]\n fn test_grow_set() {\n     let v = ~[mutable 1, 2, 3];\n-    ivec::grow_set(v, 4u, 4, 5);\n-    assert (ivec::len(v) == 5u);\n+    vec::grow_set(v, 4u, 4, 5);\n+    assert (vec::len(v) == 5u);\n     assert (v.(0) == 1);\n     assert (v.(1) == 2);\n     assert (v.(2) == 3);\n@@ -219,16 +219,16 @@ fn test_grow_set() {\n fn test_map() {\n     // Test on-stack map.\n     let v = ~[1u, 2u, 3u];\n-    let w = ivec::map(square_alias, v);\n-    assert (ivec::len(w) == 3u);\n+    let w = vec::map(square_alias, v);\n+    assert (vec::len(w) == 3u);\n     assert (w.(0) == 1u);\n     assert (w.(1) == 4u);\n     assert (w.(2) == 9u);\n \n     // Test on-heap map.\n     v = ~[1u, 2u, 3u, 4u, 5u];\n-    w = ivec::map(square_alias, v);\n-    assert (ivec::len(w) == 5u);\n+    w = vec::map(square_alias, v);\n+    assert (vec::len(w) == 5u);\n     assert (w.(0) == 1u);\n     assert (w.(1) == 4u);\n     assert (w.(2) == 9u);\n@@ -242,7 +242,7 @@ fn test_map2() {\n     let f = times;\n     let v0 = ~[1, 2, 3, 4, 5];\n     let v1 = ~[5, 4, 3, 2, 1];\n-    let u = ivec::map2[int, int, int](f, v0, v1);\n+    let u = vec::map2[int, int, int](f, v0, v1);\n     let i = 0;\n     while i < 5 { assert (v0.(i) * v1.(i) == u.(i)); i += 1; }\n }\n@@ -251,15 +251,15 @@ fn test_map2() {\n fn test_filter_map() {\n     // Test on-stack filter-map.\n     let v = ~[1u, 2u, 3u];\n-    let w = ivec::filter_map(square_if_odd, v);\n-    assert (ivec::len(w) == 2u);\n+    let w = vec::filter_map(square_if_odd, v);\n+    assert (vec::len(w) == 2u);\n     assert (w.(0) == 1u);\n     assert (w.(1) == 9u);\n \n     // Test on-heap filter-map.\n     v = ~[1u, 2u, 3u, 4u, 5u];\n-    w = ivec::filter_map(square_if_odd, v);\n-    assert (ivec::len(w) == 3u);\n+    w = vec::filter_map(square_if_odd, v);\n+    assert (vec::len(w) == 3u);\n     assert (w.(0) == 1u);\n     assert (w.(1) == 9u);\n     assert (w.(2) == 25u);\n@@ -286,39 +286,39 @@ fn test_filter_map() {\n fn test_foldl() {\n     // Test on-stack fold.\n     let v = ~[1u, 2u, 3u];\n-    let sum = ivec::foldl(add, 0u, v);\n+    let sum = vec::foldl(add, 0u, v);\n     assert (sum == 6u);\n \n     // Test on-heap fold.\n     v = ~[1u, 2u, 3u, 4u, 5u];\n-    sum = ivec::foldl(add, 0u, v);\n+    sum = vec::foldl(add, 0u, v);\n     assert (sum == 15u);\n }\n \n #[test]\n fn test_any_and_all() {\n-    assert (ivec::any(is_three, ~[1u, 2u, 3u]));\n-    assert (!ivec::any(is_three, ~[0u, 1u, 2u]));\n-    assert (ivec::any(is_three, ~[1u, 2u, 3u, 4u, 5u]));\n-    assert (!ivec::any(is_three, ~[1u, 2u, 4u, 5u, 6u]));\n-\n-    assert (ivec::all(is_three, ~[3u, 3u, 3u]));\n-    assert (!ivec::all(is_three, ~[3u, 3u, 2u]));\n-    assert (ivec::all(is_three, ~[3u, 3u, 3u, 3u, 3u]));\n-    assert (!ivec::all(is_three, ~[3u, 3u, 0u, 1u, 2u]));\n+    assert (vec::any(is_three, ~[1u, 2u, 3u]));\n+    assert (!vec::any(is_three, ~[0u, 1u, 2u]));\n+    assert (vec::any(is_three, ~[1u, 2u, 3u, 4u, 5u]));\n+    assert (!vec::any(is_three, ~[1u, 2u, 4u, 5u, 6u]));\n+\n+    assert (vec::all(is_three, ~[3u, 3u, 3u]));\n+    assert (!vec::all(is_three, ~[3u, 3u, 2u]));\n+    assert (vec::all(is_three, ~[3u, 3u, 3u, 3u, 3u]));\n+    assert (!vec::all(is_three, ~[3u, 3u, 0u, 1u, 2u]));\n }\n \n #[test]\n fn test_zip_unzip() {\n     let v1 = ~[1, 2, 3];\n     let v2 = ~[4, 5, 6];\n-    let z1 = ivec::zip(v1, v2);\n+    let z1 = vec::zip(v1, v2);\n \n     assert ((1, 4) == z1.(0));\n     assert ((2, 5) == z1.(1));\n     assert ((3, 6) == z1.(2));\n \n-    let (left, right) = ivec::unzip(z1);\n+    let (left, right) = vec::unzip(z1);\n \n     assert ((1, 4) == (left.(0), right.(0)));\n     assert ((2, 5) == (left.(1), right.(1)));\n@@ -348,19 +348,19 @@ fn reverse_and_reversed() {\n     let v: [mutable int] = ~[mutable 10, 20];\n     assert (v.(0) == 10);\n     assert (v.(1) == 20);\n-    ivec::reverse(v);\n+    vec::reverse(v);\n     assert (v.(0) == 20);\n     assert (v.(1) == 10);\n-    let v2 = ivec::reversed[int](~[10, 20]);\n+    let v2 = vec::reversed[int](~[10, 20]);\n     assert (v2.(0) == 20);\n     assert (v2.(1) == 10);\n     v.(0) = 30;\n     assert (v2.(0) == 20);\n     // Make sure they work with 0-length vectors too.\n \n-    let v4 = ivec::reversed[int](~[]);\n+    let v4 = vec::reversed[int](~[]);\n     let v3: [mutable int] = ~[mutable];\n-    ivec::reverse[int](v3);\n+    vec::reverse[int](v3);\n }\n \n // Local Variables:", "previous_filename": "src/test/stdtest/ivec.rs"}, {"sha": "bde93afb26d031e5349e6dbd4440a28c0ba79103", "filename": "src/test/stdtest/vec_str_conversions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Fvec_str_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05a91a0dca0bcbb9d9e20584923803df827e35b/src%2Ftest%2Fstdtest%2Fvec_str_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fvec_str_conversions.rs?ref=f05a91a0dca0bcbb9d9e20584923803df827e35b", "patch": "@@ -3,7 +3,7 @@\n // -*- rust -*-\n use std;\n import std::str;\n-import std::ivec;\n+import std::vec;\n \n #[test]\n fn test_simple() {\n@@ -13,7 +13,7 @@ fn test_simple() {\n     let s2: str = str::unsafe_from_bytes(v);\n     let i: uint = 0u;\n     let n1: uint = str::byte_len(s1);\n-    let n2: uint = ivec::len[u8](v);\n+    let n2: uint = vec::len[u8](v);\n     assert (n1 == n2);\n     while i < n1 {\n         let a: u8 = s1.(i);"}]}