{"sha": "7f35493e9964f8d2e62ac127d2d948b60846109b", "node_id": "C_kwDOAAsO6NoAKDdmMzU0OTNlOTk2NGY4ZDJlNjJhYzEyN2QyZDk0OGI2MDg0NjEwOWI", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-11-19T06:24:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-19T06:24:45Z"}, "message": "Rollup merge of #104554 - BoxyUwU:less_unchecked_pls, r=lcnr\n\nUse `ErrorGuaranteed::unchecked_claim_error_was_emitted` less\n\nthere are only like 3 or 4 call sites left after this but it wasnt obvious to me how to remove them", "tree": {"sha": "09a306c507585a00dad3aada2af3429a5848e48c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09a306c507585a00dad3aada2af3429a5848e48c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f35493e9964f8d2e62ac127d2d948b60846109b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjeHatCRBK7hj4Ov3rIwAAymkIAFCe8KRfK4yV8aS7CW0j7rDj\nHo+PGiMun/YEWwtm3CmTx4Yct/c2oSQ0ifuJZ/LThEugPTnCwnAkvYwnKwkW5uzL\ngo0QaKj4cw+nCp7owt3u85QQa9udvfGNtnlrt0WxLwEH/0PUnf9tUf067ky6NAqk\nowBfRU/KUztAmYLMUkrZT11mZWCQ+0aPbUHCys3C1Qw0+leS8/kiB5rY+O1+KW2i\nlDRqhOyjtaPYWspgGPkGMyG/Mwjxkhe1TCyhXXWs/jBGsfYNU9/eufGohgtrD4Nx\nM9j1hfSrraFtY3qZoex9TqCAL6xGT8xtJxGvzaNbuQKsAsR2BlcLgeZ7GPSZP3Q=\n=BE9G\n-----END PGP SIGNATURE-----\n", "payload": "tree 09a306c507585a00dad3aada2af3429a5848e48c\nparent 45bfb1cdf19cf7cfdf1707b6b8da0ff5f79f4222\nparent 45a09a4683f551d96f7e5b16a125c26003beffaf\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1668839085 +0530\ncommitter GitHub <noreply@github.com> 1668839085 +0530\n\nRollup merge of #104554 - BoxyUwU:less_unchecked_pls, r=lcnr\n\nUse `ErrorGuaranteed::unchecked_claim_error_was_emitted` less\n\nthere are only like 3 or 4 call sites left after this but it wasnt obvious to me how to remove them\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f35493e9964f8d2e62ac127d2d948b60846109b", "html_url": "https://github.com/rust-lang/rust/commit/7f35493e9964f8d2e62ac127d2d948b60846109b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f35493e9964f8d2e62ac127d2d948b60846109b/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45bfb1cdf19cf7cfdf1707b6b8da0ff5f79f4222", "url": "https://api.github.com/repos/rust-lang/rust/commits/45bfb1cdf19cf7cfdf1707b6b8da0ff5f79f4222", "html_url": "https://github.com/rust-lang/rust/commit/45bfb1cdf19cf7cfdf1707b6b8da0ff5f79f4222"}, {"sha": "45a09a4683f551d96f7e5b16a125c26003beffaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/45a09a4683f551d96f7e5b16a125c26003beffaf", "html_url": "https://github.com/rust-lang/rust/commit/45a09a4683f551d96f7e5b16a125c26003beffaf"}], "stats": {"total": 297, "additions": 172, "deletions": 125}, "files": [{"sha": "163170a1d1aa0cfda50cdf3a44854d6ac9a1129f", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -19,7 +19,7 @@ extern crate tracing;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_data_structures::vec_map::VecMap;\n-use rustc_errors::{Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{Diagnostic, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_index::bit_set::ChunkedBitSet;\n@@ -192,13 +192,13 @@ fn do_mir_borrowck<'tcx>(\n         }\n     }\n \n-    let mut errors = error::BorrowckErrors::new();\n+    let mut errors = error::BorrowckErrors::new(infcx.tcx);\n \n     // Gather the upvars of a closure, if any.\n     let tables = tcx.typeck_opt_const_arg(def);\n-    if let Some(ErrorGuaranteed { .. }) = tables.tainted_by_errors {\n-        infcx.set_tainted_by_errors();\n-        errors.set_tainted_by_errors();\n+    if let Some(e) = tables.tainted_by_errors {\n+        infcx.set_tainted_by_errors(e);\n+        errors.set_tainted_by_errors(e);\n     }\n     let upvars: Vec<_> = tables\n         .closure_min_captures_flattened(def.did)\n@@ -2260,6 +2260,7 @@ mod error {\n     use super::*;\n \n     pub struct BorrowckErrors<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n         /// This field keeps track of move errors that are to be reported for given move indices.\n         ///\n         /// There are situations where many errors can be reported for a single move out (see #53807)\n@@ -2282,28 +2283,33 @@ mod error {\n         tainted_by_errors: Option<ErrorGuaranteed>,\n     }\n \n-    impl BorrowckErrors<'_> {\n-        pub fn new() -> Self {\n+    impl<'tcx> BorrowckErrors<'tcx> {\n+        pub fn new(tcx: TyCtxt<'tcx>) -> Self {\n             BorrowckErrors {\n+                tcx,\n                 buffered_move_errors: BTreeMap::new(),\n                 buffered: Default::default(),\n                 tainted_by_errors: None,\n             }\n         }\n \n-        // FIXME(eddyb) this is a suboptimal API because `tainted_by_errors` is\n-        // set before any emission actually happens (weakening the guarantee).\n         pub fn buffer_error(&mut self, t: DiagnosticBuilder<'_, ErrorGuaranteed>) {\n-            self.tainted_by_errors = Some(ErrorGuaranteed::unchecked_claim_error_was_emitted());\n+            if let None = self.tainted_by_errors {\n+                self.tainted_by_errors = Some(\n+                    self.tcx\n+                        .sess\n+                        .delay_span_bug(t.span.clone(), \"diagnostic buffered but not emitted\"),\n+                )\n+            }\n             t.buffer(&mut self.buffered);\n         }\n \n         pub fn buffer_non_error_diag(&mut self, t: DiagnosticBuilder<'_, ()>) {\n             t.buffer(&mut self.buffered);\n         }\n \n-        pub fn set_tainted_by_errors(&mut self) {\n-            self.tainted_by_errors = Some(ErrorGuaranteed::unchecked_claim_error_was_emitted());\n+        pub fn set_tainted_by_errors(&mut self, e: ErrorGuaranteed) {\n+            self.tainted_by_errors = Some(e);\n         }\n     }\n "}, {"sha": "4a12e1b1b92e0f22b180dc566f47f9db2bd989b0", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -303,7 +303,10 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n \n     if !nll_errors.is_empty() {\n         // Suppress unhelpful extra errors in `infer_opaque_types`.\n-        infcx.set_tainted_by_errors();\n+        infcx.set_tainted_by_errors(infcx.tcx.sess.delay_span_bug(\n+            body.span,\n+            \"`compute_regions` tainted `infcx` with errors but did not emit any errors\",\n+        ));\n     }\n \n     let remapped_opaque_tys = regioncx.infer_opaque_types(&infcx, opaque_type_values);"}, {"sha": "b9885952a893c55741e6e057f9c703f7adf45353", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -219,8 +219,8 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         instantiated_ty: OpaqueHiddenType<'tcx>,\n         origin: OpaqueTyOrigin,\n     ) -> Ty<'tcx> {\n-        if self.is_tainted_by_errors() {\n-            return self.tcx.ty_error();\n+        if let Some(e) = self.tainted_by_errors() {\n+            return self.tcx.ty_error_with_guaranteed(e);\n         }\n \n         let definition_ty = instantiated_ty"}, {"sha": "83b95fe0e911ec055f08c426b50d498a2f583a66", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -115,7 +115,7 @@ pub trait AstConv<'tcx> {\n     /// (e.g., resolve) that is translated into a ty-error. This is\n     /// used to help suppress derived errors typeck might otherwise\n     /// report.\n-    fn set_tainted_by_errors(&self);\n+    fn set_tainted_by_errors(&self, e: ErrorGuaranteed);\n \n     fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, span: Span);\n }\n@@ -2620,8 +2620,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 }\n             }\n             Res::Err => {\n-                self.set_tainted_by_errors();\n-                self.tcx().ty_error()\n+                let e = self\n+                    .tcx()\n+                    .sess\n+                    .delay_span_bug(path.span, \"path with `Res:Err` but no error emitted\");\n+                self.set_tainted_by_errors(e);\n+                self.tcx().ty_error_with_guaranteed(e)\n             }\n             _ => span_bug!(span, \"unexpected resolution: {:?}\", path.res),\n         }"}, {"sha": "a738ee4a14887ae60c0d41d7e2ff8d98aa429750", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -518,7 +518,7 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n         ty\n     }\n \n-    fn set_tainted_by_errors(&self) {\n+    fn set_tainted_by_errors(&self, _: ErrorGuaranteed) {\n         // There's no obvious place to track this, so just let it go.\n     }\n "}, {"sha": "af0b7f62ae3195f6ce058bde7b0cf97be631efc1", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -1561,7 +1561,9 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 // Mark that we've failed to coerce the types here to suppress\n                 // any superfluous errors we might encounter while trying to\n                 // emit or provide suggestions on how to fix the initial error.\n-                fcx.set_tainted_by_errors();\n+                fcx.set_tainted_by_errors(\n+                    fcx.tcx.sess.delay_span_bug(cause.span, \"coercion error but no error emitted\"),\n+                );\n                 let (expected, found) = if label_expression_as_expected {\n                     // In the case where this is a \"forced unit\", like\n                     // `break`, we want to call the `()` \"expected\""}, {"sha": "5a34ab401749f74491f92a45ec04a1b0786e5434", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -154,7 +154,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Err(e) => e,\n         };\n \n-        self.set_tainted_by_errors();\n+        self.set_tainted_by_errors(self.tcx.sess.delay_span_bug(\n+            expr.span,\n+            \"`TypeError` when attempting coercion but no error emitted\",\n+        ));\n         let expr = expr.peel_drop_temps();\n         let cause = self.misc(expr.span);\n         let expr_ty = self.resolve_vars_with_obligations(checked_ty);"}, {"sha": "752d2e0ff78589046f2c327c51b5bfd0288e60a4", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -527,12 +527,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.resolve_ty_and_res_fully_qualified_call(qpath, expr.hir_id, expr.span);\n         let ty = match res {\n             Res::Err => {\n-                self.set_tainted_by_errors();\n-                tcx.ty_error()\n+                let e =\n+                    self.tcx.sess.delay_span_bug(qpath.span(), \"`Res::Err` but no error emitted\");\n+                self.set_tainted_by_errors(e);\n+                tcx.ty_error_with_guaranteed(e)\n             }\n             Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) => {\n-                report_unexpected_variant_res(tcx, res, qpath, expr.span);\n-                tcx.ty_error()\n+                let e = report_unexpected_variant_res(tcx, res, qpath, expr.span);\n+                tcx.ty_error_with_guaranteed(e)\n             }\n             _ => self.instantiate_value_path(segs, opt_ty, res, expr.span, expr.hir_id).0,\n         };\n@@ -1962,7 +1964,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr_span: Span,\n     ) {\n         if variant.is_recovered() {\n-            self.set_tainted_by_errors();\n+            self.set_tainted_by_errors(\n+                self.tcx\n+                    .sess\n+                    .delay_span_bug(expr_span, \"parser recovered but no error was emitted\"),\n+            );\n             return;\n         }\n         let mut err = self.err_ctxt().type_error_struct_with_diag("}, {"sha": "ac6b0924ab572498a4cc36f9fe8187f1b93b38ed", "filename": "compiler/rustc_hir_typeck/src/fallback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -104,7 +104,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // type, `?T` is not considered unsolved, but `?I` is. The\n         // same is true for float variables.)\n         let fallback = match ty.kind() {\n-            _ if self.is_tainted_by_errors() => self.tcx.ty_error(),\n+            _ if let Some(e) = self.tainted_by_errors() => self.tcx.ty_error_with_guaranteed(e),\n             ty::Infer(ty::IntVar(_)) => self.tcx.types.i32,\n             ty::Infer(ty::FloatVar(_)) => self.tcx.types.f64,\n             _ => match diverging_fallback.get(&ty) {"}, {"sha": "b85a23257286b6ddfad19fffb788d93e567a8001", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -140,8 +140,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"write_ty({:?}, {:?}) in fcx {}\", id, self.resolve_vars_if_possible(ty), self.tag());\n         self.typeck_results.borrow_mut().node_types_mut().insert(id, ty);\n \n-        if ty.references_error() {\n-            self.set_tainted_by_errors();\n+        if let Err(e) = ty.error_reported() {\n+            self.set_tainted_by_errors(e);\n         }\n     }\n \n@@ -528,7 +528,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn node_ty(&self, id: hir::HirId) -> Ty<'tcx> {\n         match self.typeck_results.borrow().node_types().get(id) {\n             Some(&t) => t,\n-            None if self.is_tainted_by_errors() => self.tcx.ty_error(),\n+            None if let Some(e) = self.tainted_by_errors() => self.tcx.ty_error_with_guaranteed(e),\n             None => {\n                 bug!(\n                     \"no type for node {}: {} in fcx {}\",\n@@ -543,7 +543,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn node_ty_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n         match self.typeck_results.borrow().node_types().get(id) {\n             Some(&t) => Some(t),\n-            None if self.is_tainted_by_errors() => Some(self.tcx.ty_error()),\n+            None if let Some(e) = self.tainted_by_errors() => Some(self.tcx.ty_error_with_guaranteed(e)),\n             None => None,\n         }\n     }\n@@ -1148,9 +1148,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 explicit_late_bound = ExplicitLateBound::Yes;\n             }\n \n-            if let Err(GenericArgCountMismatch { reported: Some(_), .. }) = arg_count.correct {\n+            if let Err(GenericArgCountMismatch { reported: Some(e), .. }) = arg_count.correct {\n                 infer_args_for_err.insert(index);\n-                self.set_tainted_by_errors(); // See issue #53251.\n+                self.set_tainted_by_errors(e); // See issue #53251.\n             }\n         }\n \n@@ -1440,12 +1440,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if !ty.is_ty_var() {\n             ty\n         } else {\n-            if !self.is_tainted_by_errors() {\n+            let e = self.tainted_by_errors().unwrap_or_else(|| {\n                 self.err_ctxt()\n                     .emit_inference_failure_err((**self).body_id, sp, ty.into(), E0282, true)\n-                    .emit();\n-            }\n-            let err = self.tcx.ty_error();\n+                    .emit()\n+            });\n+            let err = self.tcx.ty_error_with_guaranteed(e);\n             self.demand_suptype(sp, err, ty);\n             err\n         }"}, {"sha": "a31ab9c8b23b899c00dcad27aad6b7f8816e9a54", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -511,8 +511,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             tys.into_iter().any(|ty| ty.references_error() || ty.is_ty_var())\n         }\n \n-        self.set_tainted_by_errors();\n         let tcx = self.tcx;\n+        // FIXME: taint after emitting errors and pass through an `ErrorGuaranteed`\n+        self.set_tainted_by_errors(\n+            tcx.sess.delay_span_bug(call_span, \"no errors reported for args\"),\n+        );\n \n         // Get the argument span in the context of the call span so that\n         // suggestions and labels are (more) correct when an arg is a\n@@ -1207,7 +1210,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let (def, ty) = self.finish_resolving_struct_path(qpath, path_span, hir_id);\n         let variant = match def {\n             Res::Err => {\n-                self.set_tainted_by_errors();\n+                self.set_tainted_by_errors(\n+                    self.tcx.sess.delay_span_bug(path_span, \"`Res::Err` but no error emitted\"),\n+                );\n                 return None;\n             }\n             Res::Def(DefKind::Variant, _) => match ty.kind() {"}, {"sha": "177d521d2804cd1e1ff08f4e769229b64fd28f4a", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -4,6 +4,7 @@ mod checks;\n mod suggestions;\n \n pub use _impl::*;\n+use rustc_errors::ErrorGuaranteed;\n pub use suggestions::*;\n \n use crate::coercion::DynamicCoerceMany;\n@@ -289,8 +290,8 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn set_tainted_by_errors(&self) {\n-        self.infcx.set_tainted_by_errors()\n+    fn set_tainted_by_errors(&self, e: ErrorGuaranteed) {\n+        self.infcx.set_tainted_by_errors(e)\n     }\n \n     fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, _span: Span) {"}, {"sha": "334d6d0aa6c209838c6a042895e8d94eab3e7742", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -53,7 +53,7 @@ use crate::check::check_fn;\n use crate::coercion::DynamicCoerceMany;\n use crate::gather_locals::GatherLocalsVisitor;\n use rustc_data_structures::unord::UnordSet;\n-use rustc_errors::{struct_span_err, MultiSpan};\n+use rustc_errors::{struct_span_err, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::intravisit::Visitor;\n@@ -344,7 +344,7 @@ fn typeck_with_fallback<'tcx>(\n \n         fcx.select_all_obligations_or_error();\n \n-        if !fcx.infcx.is_tainted_by_errors() {\n+        if let None = fcx.infcx.tainted_by_errors() {\n             fcx.check_transmutes();\n         }\n \n@@ -428,7 +428,12 @@ impl<'tcx> EnclosingBreakables<'tcx> {\n     }\n }\n \n-fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, qpath: &hir::QPath<'_>, span: Span) {\n+fn report_unexpected_variant_res(\n+    tcx: TyCtxt<'_>,\n+    res: Res,\n+    qpath: &hir::QPath<'_>,\n+    span: Span,\n+) -> ErrorGuaranteed {\n     struct_span_err!(\n         tcx.sess,\n         span,\n@@ -437,7 +442,7 @@ fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, qpath: &hir::QPath<'\n         res.descr(),\n         rustc_hir_pretty::qpath_to_string(qpath),\n     )\n-    .emit();\n+    .emit()\n }\n \n /// Controls whether the arguments are tupled. This is used for the call"}, {"sha": "0b5dc946c1deffa589f20f036542cfacc7edd6a8", "filename": "compiler/rustc_hir_typeck/src/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     }\n \n     fn is_tainted_by_errors(&self) -> bool {\n-        self.infcx.is_tainted_by_errors()\n+        self.infcx.tainted_by_errors().is_some()\n     }\n \n     fn resolve_type_vars_or_error("}, {"sha": "a62d43561302bf43d3126b502367f7d21c4c455e", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -839,12 +839,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let (res, opt_ty, segments) = path_resolution;\n         match res {\n             Res::Err => {\n-                self.set_tainted_by_errors();\n-                return tcx.ty_error();\n+                let e = tcx.sess.delay_span_bug(qpath.span(), \"`Res::Err` but no error emitted\");\n+                self.set_tainted_by_errors(e);\n+                return tcx.ty_error_with_guaranteed(e);\n             }\n             Res::Def(DefKind::AssocFn | DefKind::Ctor(_, CtorKind::Fictive | CtorKind::Fn), _) => {\n-                report_unexpected_variant_res(tcx, res, qpath, pat.span);\n-                return tcx.ty_error();\n+                let e = report_unexpected_variant_res(tcx, res, qpath, pat.span);\n+                return tcx.ty_error_with_guaranteed(e);\n             }\n             Res::SelfCtor(..)\n             | Res::Def(\n@@ -985,9 +986,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n-        let on_error = || {\n+        let on_error = |e| {\n             for pat in subpats {\n-                self.check_pat(pat, tcx.ty_error(), def_bm, ti);\n+                self.check_pat(pat, tcx.ty_error_with_guaranteed(e), def_bm, ti);\n             }\n         };\n         let report_unexpected_res = |res: Res| {\n@@ -1014,36 +1015,39 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     err.span_label(pat.span, \"not a tuple variant or struct\");\n                 }\n             }\n-            err.emit();\n-            on_error();\n+            let e = err.emit();\n+            on_error(e);\n+            e\n         };\n \n         // Resolve the path and check the definition for errors.\n         let (res, opt_ty, segments) =\n             self.resolve_ty_and_res_fully_qualified_call(qpath, pat.hir_id, pat.span);\n         if res == Res::Err {\n-            self.set_tainted_by_errors();\n-            on_error();\n-            return self.tcx.ty_error();\n+            let e = tcx.sess.delay_span_bug(pat.span, \"`Res:Err` but no error emitted\");\n+            self.set_tainted_by_errors(e);\n+            on_error(e);\n+            return tcx.ty_error_with_guaranteed(e);\n         }\n \n         // Type-check the path.\n         let (pat_ty, res) =\n             self.instantiate_value_path(segments, opt_ty, res, pat.span, pat.hir_id);\n         if !pat_ty.is_fn() {\n-            report_unexpected_res(res);\n-            return tcx.ty_error();\n+            let e = report_unexpected_res(res);\n+            return tcx.ty_error_with_guaranteed(e);\n         }\n \n         let variant = match res {\n             Res::Err => {\n-                self.set_tainted_by_errors();\n-                on_error();\n-                return tcx.ty_error();\n+                let e = tcx.sess.delay_span_bug(pat.span, \"`Res::Err` but no error emitted\");\n+                self.set_tainted_by_errors(e);\n+                on_error(e);\n+                return tcx.ty_error_with_guaranteed(e);\n             }\n             Res::Def(DefKind::AssocConst | DefKind::AssocFn, _) => {\n-                report_unexpected_res(res);\n-                return tcx.ty_error();\n+                let e = report_unexpected_res(res);\n+                return tcx.ty_error_with_guaranteed(e);\n             }\n             Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => tcx.expect_variant_res(res),\n             _ => bug!(\"unexpected pattern resolution: {:?}\", res),\n@@ -1082,9 +1086,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         } else {\n             // Pattern has wrong number of fields.\n-            self.e0023(pat.span, res, qpath, subpats, &variant.fields, expected, had_err);\n-            on_error();\n-            return tcx.ty_error();\n+            let e = self.e0023(pat.span, res, qpath, subpats, &variant.fields, expected, had_err);\n+            on_error(e);\n+            return tcx.ty_error_with_guaranteed(e);\n         }\n         pat_ty\n     }\n@@ -1098,7 +1102,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         fields: &'tcx [ty::FieldDef],\n         expected: Ty<'tcx>,\n         had_err: bool,\n-    ) {\n+    ) -> ErrorGuaranteed {\n         let subpats_ending = pluralize!(subpats.len());\n         let fields_ending = pluralize!(fields.len());\n \n@@ -1245,7 +1249,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        err.emit();\n+        err.emit()\n     }\n \n     fn check_pat_tuple("}, {"sha": "6c2ee35fa50da5b1daef213e9941db8fc3510113", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -83,10 +83,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         wbcx.typeck_results.treat_byte_string_as_slice =\n             mem::take(&mut self.typeck_results.borrow_mut().treat_byte_string_as_slice);\n \n-        if self.is_tainted_by_errors() {\n-            // FIXME(eddyb) keep track of `ErrorGuaranteed` from where the error was emitted.\n-            wbcx.typeck_results.tainted_by_errors =\n-                Some(ErrorGuaranteed::unchecked_claim_error_was_emitted());\n+        if let Some(e) = self.tainted_by_errors() {\n+            wbcx.typeck_results.tainted_by_errors = Some(e);\n         }\n \n         debug!(\"writeback: typeck results for {:?} are {:#?}\", item_def_id, wbcx.typeck_results);\n@@ -674,10 +672,8 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         // We may have introduced e.g. `ty::Error`, if inference failed, make sure\n         // to mark the `TypeckResults` as tainted in that case, so that downstream\n         // users of the typeck results don't produce extra errors, or worse, ICEs.\n-        if resolver.replaced_with_error {\n-            // FIXME(eddyb) keep track of `ErrorGuaranteed` from where the error was emitted.\n-            self.typeck_results.tainted_by_errors =\n-                Some(ErrorGuaranteed::unchecked_claim_error_was_emitted());\n+        if let Some(e) = resolver.replaced_with_error {\n+            self.typeck_results.tainted_by_errors = Some(e);\n         }\n \n         x\n@@ -708,8 +704,8 @@ struct Resolver<'cx, 'tcx> {\n     span: &'cx dyn Locatable,\n     body: &'tcx hir::Body<'tcx>,\n \n-    /// Set to `true` if any `Ty` or `ty::Const` had to be replaced with an `Error`.\n-    replaced_with_error: bool,\n+    /// Set to `Some` if any `Ty` or `ty::Const` had to be replaced with an `Error`.\n+    replaced_with_error: Option<ErrorGuaranteed>,\n }\n \n impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n@@ -718,12 +714,14 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n         span: &'cx dyn Locatable,\n         body: &'tcx hir::Body<'tcx>,\n     ) -> Resolver<'cx, 'tcx> {\n-        Resolver { tcx: fcx.tcx, infcx: fcx, span, body, replaced_with_error: false }\n+        Resolver { tcx: fcx.tcx, infcx: fcx, span, body, replaced_with_error: None }\n     }\n \n-    fn report_error(&self, p: impl Into<ty::GenericArg<'tcx>>) {\n-        if !self.tcx.sess.has_errors().is_some() {\n-            self.infcx\n+    fn report_error(&self, p: impl Into<ty::GenericArg<'tcx>>) -> ErrorGuaranteed {\n+        match self.tcx.sess.has_errors() {\n+            Some(e) => e,\n+            None => self\n+                .infcx\n                 .err_ctxt()\n                 .emit_inference_failure_err(\n                     Some(self.body.id()),\n@@ -732,7 +730,7 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n                     E0282,\n                     false,\n                 )\n-                .emit();\n+                .emit(),\n         }\n     }\n }\n@@ -773,9 +771,9 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n             }\n             Err(_) => {\n                 debug!(\"Resolver::fold_ty: input type `{:?}` not fully resolvable\", t);\n-                self.report_error(t);\n-                self.replaced_with_error = true;\n-                self.tcx().ty_error()\n+                let e = self.report_error(t);\n+                self.replaced_with_error = Some(e);\n+                self.tcx().ty_error_with_guaranteed(e)\n             }\n         }\n     }\n@@ -790,9 +788,9 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n             Ok(ct) => self.tcx.erase_regions(ct),\n             Err(_) => {\n                 debug!(\"Resolver::fold_const: input const `{:?}` not fully resolvable\", ct);\n-                self.report_error(ct);\n-                self.replaced_with_error = true;\n-                self.tcx().const_error(ct.ty())\n+                let e = self.report_error(ct);\n+                self.replaced_with_error = Some(e);\n+                self.tcx().const_error_with_guaranteed(ct.ty(), e)\n             }\n         }\n     }"}, {"sha": "b9ed6b28c220d1f47172421bedf05f593f661dd9", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -34,7 +34,7 @@ pub use rustc_middle::ty::IntVarValue;\n use rustc_middle::ty::{self, GenericParamDefKind, InferConst, Ty, TyCtxt};\n use rustc_middle::ty::{ConstVid, FloatVid, IntVid, TyVid};\n use rustc_span::symbol::Symbol;\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n \n use std::cell::{Cell, RefCell};\n use std::fmt;\n@@ -1208,7 +1208,8 @@ impl<'tcx> InferCtxt<'tcx> {\n     /// reporting errors that often occur as a result of earlier\n     /// errors, but where it's hard to be 100% sure (e.g., unresolved\n     /// inference variables, regionck errors).\n-    pub fn is_tainted_by_errors(&self) -> bool {\n+    #[must_use = \"this method does not have any side effects\"]\n+    pub fn tainted_by_errors(&self) -> Option<ErrorGuaranteed> {\n         debug!(\n             \"is_tainted_by_errors(err_count={}, err_count_on_creation={}, \\\n              tainted_by_errors={})\",\n@@ -1217,19 +1218,25 @@ impl<'tcx> InferCtxt<'tcx> {\n             self.tainted_by_errors.get().is_some()\n         );\n \n+        if let Some(e) = self.tainted_by_errors.get() {\n+            return Some(e);\n+        }\n+\n         if self.tcx.sess.err_count() > self.err_count_on_creation {\n-            return true; // errors reported since this infcx was made\n+            // errors reported since this infcx was made\n+            let e = self.tcx.sess.has_errors().unwrap();\n+            self.set_tainted_by_errors(e);\n+            return Some(e);\n         }\n-        self.tainted_by_errors.get().is_some()\n+\n+        None\n     }\n \n     /// Set the \"tainted by errors\" flag to true. We call this when we\n     /// observe an error from a prior pass.\n-    pub fn set_tainted_by_errors(&self) {\n-        debug!(\"set_tainted_by_errors()\");\n-        self.tainted_by_errors.set(Some(\n-            self.tcx.sess.delay_span_bug(DUMMY_SP, \"`InferCtxt` incorrectly tainted by errors\"),\n-        ));\n+    pub fn set_tainted_by_errors(&self, e: ErrorGuaranteed) {\n+        debug!(\"set_tainted_by_errors(ErrorGuaranteed)\");\n+        self.tainted_by_errors.set(Some(e));\n     }\n \n     pub fn skip_region_resolution(&self) {\n@@ -1270,7 +1277,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             let mut inner = self.inner.borrow_mut();\n             let inner = &mut *inner;\n             assert!(\n-                self.is_tainted_by_errors() || inner.region_obligations.is_empty(),\n+                self.tainted_by_errors().is_some() || inner.region_obligations.is_empty(),\n                 \"region_obligations not empty: {:#?}\",\n                 inner.region_obligations\n             );\n@@ -1707,7 +1714,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     ) {\n         let errors = self.resolve_regions(outlives_env);\n \n-        if !self.is_tainted_by_errors() {\n+        if let None = self.tainted_by_errors() {\n             // As a heuristic, just skip reporting region errors\n             // altogether if other errors have been reported while\n             // this infcx was in use.  This is totally hokey but"}, {"sha": "bd3c5780b891bb28efae312459722b10febf7e43", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -116,9 +116,9 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n                 Ok(a)\n             }\n \n-            (&ty::Error(_), _) | (_, &ty::Error(_)) => {\n-                infcx.set_tainted_by_errors();\n-                Ok(self.tcx().ty_error())\n+            (&ty::Error(e), _) | (_, &ty::Error(e)) => {\n+                infcx.set_tainted_by_errors(e);\n+                Ok(self.tcx().ty_error_with_guaranteed(e))\n             }\n \n             (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {"}, {"sha": "d602acec53e3214998c52ffa1f52ca334428f916", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -562,7 +562,10 @@ impl Session {\n         if self.err_count() == old_count {\n             Ok(result)\n         } else {\n-            Err(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n+            Err(self.delay_span_bug(\n+                rustc_span::DUMMY_SP,\n+                \"`self.err_count()` changed but an error was not emitted\",\n+            ))\n         }\n     }\n     #[allow(rustc::untranslatable_diagnostic)]"}, {"sha": "ad0785d3817e1cf386a7be5762d429a456e481ea", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -532,9 +532,12 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         root_obligation: &PredicateObligation<'tcx>,\n         error: &SelectionError<'tcx>,\n     ) {\n-        self.set_tainted_by_errors();\n         let tcx = self.tcx;\n         let mut span = obligation.cause.span;\n+        // FIXME: statically guarantee this by tainting after the diagnostic is emitted\n+        self.set_tainted_by_errors(\n+            tcx.sess.delay_span_bug(span, \"`report_selection_error` did not emit an error\"),\n+        );\n \n         let mut err = match *error {\n             SelectionError::Unimplemented => {\n@@ -2060,7 +2063,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 // check upstream for type errors and don't add the obligations to\n                 // begin with in those cases.\n                 if self.tcx.lang_items().sized_trait() == Some(trait_ref.def_id()) {\n-                    if !self.is_tainted_by_errors() {\n+                    if let None = self.tainted_by_errors() {\n                         self.emit_inference_failure_err(\n                             body_id,\n                             span,\n@@ -2115,16 +2118,16 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         if impls.len() > 1 && impls.len() < 5 && has_non_region_infer {\n                             self.annotate_source_of_ambiguity(&mut err, &impls, predicate);\n                         } else {\n-                            if self.is_tainted_by_errors() {\n-                                err.delay_as_bug();\n+                            if self.tainted_by_errors().is_some() {\n+                                err.cancel();\n                                 return;\n                             }\n                             err.note(&format!(\"cannot satisfy `{}`\", predicate));\n                         }\n                     }\n                     _ => {\n-                        if self.is_tainted_by_errors() {\n-                            err.delay_as_bug();\n+                        if self.tainted_by_errors().is_some() {\n+                            err.cancel();\n                             return;\n                         }\n                         err.note(&format!(\"cannot satisfy `{}`\", predicate));\n@@ -2226,7 +2229,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         ] = path.segments\n                         && data.trait_ref.def_id == *trait_id\n                         && self.tcx.trait_of_item(*item_id) == Some(*trait_id)\n-                        && !self.is_tainted_by_errors()\n+                        && let None = self.tainted_by_errors()\n                     {\n                         let (verb, noun) = match self.tcx.associated_item(item_id).kind {\n                             ty::AssocKind::Const => (\"refer to the\", \"constant\"),\n@@ -2295,7 +2298,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 // with error messages.\n                 if arg.references_error()\n                     || self.tcx.sess.has_errors().is_some()\n-                    || self.is_tainted_by_errors()\n+                    || self.tainted_by_errors().is_some()\n                 {\n                     return;\n                 }\n@@ -2306,7 +2309,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             ty::PredicateKind::Subtype(data) => {\n                 if data.references_error()\n                     || self.tcx.sess.has_errors().is_some()\n-                    || self.is_tainted_by_errors()\n+                    || self.tainted_by_errors().is_some()\n                 {\n                     // no need to overload user in such cases\n                     return;\n@@ -2317,7 +2320,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 self.emit_inference_failure_err(body_id, span, a.into(), ErrorCode::E0282, true)\n             }\n             ty::PredicateKind::Projection(data) => {\n-                if predicate.references_error() || self.is_tainted_by_errors() {\n+                if predicate.references_error() || self.tainted_by_errors().is_some() {\n                     return;\n                 }\n                 let subst = data\n@@ -2351,7 +2354,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             }\n \n             ty::PredicateKind::ConstEvaluatable(data) => {\n-                if predicate.references_error() || self.is_tainted_by_errors() {\n+                if predicate.references_error() || self.tainted_by_errors().is_some() {\n                     return;\n                 }\n                 let subst = data.walk().find(|g| g.is_non_region_infer());\n@@ -2378,7 +2381,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 }\n             }\n             _ => {\n-                if self.tcx.sess.has_errors().is_some() || self.is_tainted_by_errors() {\n+                if self.tcx.sess.has_errors().is_some() || self.tainted_by_errors().is_some() {\n                     return;\n                 }\n                 let mut err = struct_span_err!(\n@@ -2422,7 +2425,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         post.sort();\n         post.dedup();\n \n-        if self.is_tainted_by_errors()\n+        if self.tainted_by_errors().is_some()\n             && (crate_names.len() == 1\n                 && spans.len() == 0\n                 && [\"`core`\", \"`alloc`\", \"`std`\"].contains(&crate_names[0].as_str())"}, {"sha": "b05942353a343536100523b245a869ec16b16ccd", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -33,7 +33,7 @@ use crate::traits::ProjectionCacheKey;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_errors::{Diagnostic, ErrorGuaranteed};\n+use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::LateBoundRegionConversionTime;\n@@ -1089,10 +1089,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         if !self.infcx.tcx.recursion_limit().value_within_limit(depth) {\n             match self.query_mode {\n                 TraitQueryMode::Standard => {\n-                    if self.infcx.is_tainted_by_errors() {\n-                        return Err(OverflowError::Error(\n-                            ErrorGuaranteed::unchecked_claim_error_was_emitted(),\n-                        ));\n+                    if let Some(e) = self.infcx.tainted_by_errors() {\n+                        return Err(OverflowError::Error(e));\n                     }\n                     self.infcx.err_ctxt().report_overflow_error(error_obligation, true);\n                 }"}, {"sha": "547643f0d6e203f9644dd410d44deb97d3e7ffac", "filename": "src/test/ui/issues/issue-52262.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/src%2Ftest%2Fui%2Fissues%2Fissue-52262.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/src%2Ftest%2Fui%2Fissues%2Fissue-52262.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52262.rs?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -1,4 +1,3 @@\n-// compile-flags:-Ztreat-err-as-bug=5\n #[derive(Debug)]\n enum MyError {\n     NotFound { key: Vec<u8> },"}, {"sha": "ef41f078b8037d25e1ab892ac182fad9a3656163", "filename": "src/test/ui/issues/issue-52262.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f35493e9964f8d2e62ac127d2d948b60846109b/src%2Ftest%2Fui%2Fissues%2Fissue-52262.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7f35493e9964f8d2e62ac127d2d948b60846109b/src%2Ftest%2Fui%2Fissues%2Fissue-52262.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52262.stderr?ref=7f35493e9964f8d2e62ac127d2d948b60846109b", "patch": "@@ -1,5 +1,5 @@\n error[E0507]: cannot move out of `*key` which is behind a shared reference\n-  --> $DIR/issue-52262.rs:16:35\n+  --> $DIR/issue-52262.rs:15:35\n    |\n LL |                 String::from_utf8(*key).unwrap()\n    |                                   ^^^^ move occurs because `*key` has type `Vec<u8>`, which does not implement the `Copy` trait"}]}