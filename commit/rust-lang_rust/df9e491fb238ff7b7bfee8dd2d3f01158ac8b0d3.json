{"sha": "df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmOWU0OTFmYjIzOGZmN2I3YmZlZThkZDJkM2YwMTE1OGFjOGIwZDM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-13T19:35:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-13T19:35:28Z"}, "message": "Rollup merge of #67026 - Nadrieril:improve-usefulness-empty, r=varkor,Centril,estebank\n\nImprove diagnostics and code for exhaustiveness of empty matches\n\nThere was a completely separate check and diagnostics for the case of an empty match. This led to slightly different error messages and duplicated code.\nThis improves code reuse and generally clarifies what happens for empty matches. This also clarifies the action of the `exhaustive_patterns` feature, and ensures that this feature doesn't change diagnostics in places it doesn't need to.", "tree": {"sha": "40e01a66c07aed56b80b80b010e18bd84d73deaf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40e01a66c07aed56b80b80b010e18bd84d73deaf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd8+gACRBK7hj4Ov3rIwAAdHIIAHPvZ1EIfhDquhrnzaRnlZKx\ndg14fO/+0hvCeq2nZvqmvofaaft2/tHuhnd8lcZM4JhD0S737zZopb7IR5K+ldJq\nSAPkb6OPCqei2jt57da+SuKsuu46P9uxoWk9s3gMKXZ3lW1MioppO2R3DydEWR6x\n0G2M+D9Goj3pYn/QFVRUgHTnHJgf6GL3YkxgR3DjKYC+6rWQXerZQW+hRWjOFWmS\nLJ0PszyKFdSYTH37TgaXpLNSAnYCjYAJYkM4yXYr/eHl41b/H36Ww/X39ewRiIC6\ngKAffLvjeXa4aIHRIsV9e0XPi9Sf/8lhh4g/s32NjAAhHxEyFUTLNDveIkjr6qg=\n=RisE\n-----END PGP SIGNATURE-----\n", "payload": "tree 40e01a66c07aed56b80b80b010e18bd84d73deaf\nparent 3964a55ba59bb6c3d4badcbddc49f6929ef76862\nparent fbd2cd09e6fd044cad02af97e581853f1875ab2a\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1576265728 +0100\ncommitter GitHub <noreply@github.com> 1576265728 +0100\n\nRollup merge of #67026 - Nadrieril:improve-usefulness-empty, r=varkor,Centril,estebank\n\nImprove diagnostics and code for exhaustiveness of empty matches\n\nThere was a completely separate check and diagnostics for the case of an empty match. This led to slightly different error messages and duplicated code.\nThis improves code reuse and generally clarifies what happens for empty matches. This also clarifies the action of the `exhaustive_patterns` feature, and ensures that this feature doesn't change diagnostics in places it doesn't need to.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "html_url": "https://github.com/rust-lang/rust/commit/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3964a55ba59bb6c3d4badcbddc49f6929ef76862", "url": "https://api.github.com/repos/rust-lang/rust/commits/3964a55ba59bb6c3d4badcbddc49f6929ef76862", "html_url": "https://github.com/rust-lang/rust/commit/3964a55ba59bb6c3d4badcbddc49f6929ef76862"}, {"sha": "fbd2cd09e6fd044cad02af97e581853f1875ab2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbd2cd09e6fd044cad02af97e581853f1875ab2a", "html_url": "https://github.com/rust-lang/rust/commit/fbd2cd09e6fd044cad02af97e581853f1875ab2a"}], "stats": {"total": 1071, "additions": 889, "deletions": 182}, "files": [{"sha": "c37203285069573e24cb8819f01613d2d31a2872", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 69, "deletions": 50, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "patch": "@@ -238,7 +238,7 @@ use super::{FieldPat, Pat, PatKind, PatRange};\n use rustc::hir::def_id::DefId;\n use rustc::hir::{HirId, RangeEnd};\n use rustc::ty::layout::{Integer, IntegerExt, Size, VariantIdx};\n-use rustc::ty::{self, Const, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, Const, Ty, TyCtxt, TypeFoldable, VariantDef};\n \n use rustc::lint;\n use rustc::mir::interpret::{truncate, AllocId, ConstValue, Pointer, Scalar};\n@@ -354,7 +354,7 @@ impl PatternFolder<'tcx> for LiteralExpander<'tcx> {\n }\n \n impl<'tcx> Pat<'tcx> {\n-    fn is_wildcard(&self) -> bool {\n+    pub(super) fn is_wildcard(&self) -> bool {\n         match *self.kind {\n             PatKind::Binding { subpattern: None, .. } | PatKind::Wild => true,\n             _ => false,\n@@ -596,9 +596,21 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn is_local(&self, ty: Ty<'tcx>) -> bool {\n+    // Returns whether the given type is an enum from another crate declared `#[non_exhaustive]`.\n+    pub fn is_foreign_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n         match ty.kind {\n-            ty::Adt(adt_def, ..) => adt_def.did.is_local(),\n+            ty::Adt(def, ..) => {\n+                def.is_enum() && def.is_variant_list_non_exhaustive() && !def.did.is_local()\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    // Returns whether the given variant is from another crate and has its fields declared\n+    // `#[non_exhaustive]`.\n+    fn is_foreign_non_exhaustive_variant(&self, ty: Ty<'tcx>, variant: &VariantDef) -> bool {\n+        match ty.kind {\n+            ty::Adt(def, ..) => variant.is_field_list_non_exhaustive() && !def.did.is_local(),\n             _ => false,\n         }\n     }\n@@ -758,6 +770,10 @@ impl<'tcx> Constructor<'tcx> {\n     // Returns the set of constructors covered by `self` but not by\n     // anything in `other_ctors`.\n     fn subtract_ctors(&self, other_ctors: &Vec<Constructor<'tcx>>) -> Vec<Constructor<'tcx>> {\n+        if other_ctors.is_empty() {\n+            return vec![self.clone()];\n+        }\n+\n         match self {\n             // Those constructors can only match themselves.\n             Single | Variant(_) | ConstantValue(..) | FloatRange(..) => {\n@@ -858,8 +874,7 @@ impl<'tcx> Constructor<'tcx> {\n                         vec![Pat::wildcard_from_ty(substs.type_at(0))]\n                     } else {\n                         let variant = &adt.variants[self.variant_index_for_adt(cx, adt)];\n-                        let is_non_exhaustive =\n-                            variant.is_field_list_non_exhaustive() && !cx.is_local(ty);\n+                        let is_non_exhaustive = cx.is_foreign_non_exhaustive_variant(ty, variant);\n                         variant\n                             .fields\n                             .iter()\n@@ -1205,6 +1220,8 @@ impl<'tcx> Witness<'tcx> {\n ///\n /// We make sure to omit constructors that are statically impossible. E.g., for\n /// `Option<!>`, we do not include `Some(_)` in the returned list of constructors.\n+/// Invariant: this returns an empty `Vec` if and only if the type is uninhabited (as determined by\n+/// `cx.is_uninhabited()`).\n fn all_constructors<'a, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     pcx: PatCtxt<'tcx>,\n@@ -1235,47 +1252,45 @@ fn all_constructors<'a, 'tcx>(\n             vec![Slice(Slice { array_len: None, kind })]\n         }\n         ty::Adt(def, substs) if def.is_enum() => {\n-            let ctors: Vec<_> = def\n-                .variants\n-                .iter()\n-                .filter(|v| {\n-                    !cx.tcx.features().exhaustive_patterns\n-                        || !v\n-                            .uninhabited_from(cx.tcx, substs, def.adt_kind())\n+            let ctors: Vec<_> = if cx.tcx.features().exhaustive_patterns {\n+                // If `exhaustive_patterns` is enabled, we exclude variants known to be\n+                // uninhabited.\n+                def.variants\n+                    .iter()\n+                    .filter(|v| {\n+                        !v.uninhabited_from(cx.tcx, substs, def.adt_kind())\n                             .contains(cx.tcx, cx.module)\n-                })\n-                .map(|v| Variant(v.def_id))\n-                .collect();\n-\n-            // If our scrutinee is *privately* an empty enum, we must treat it as though it had an\n-            // \"unknown\" constructor (in that case, all other patterns obviously can't be variants)\n-            // to avoid exposing its emptyness. See the `match_privately_empty` test for details.\n-            // FIXME: currently the only way I know of something can be a privately-empty enum is\n-            // when the exhaustive_patterns feature flag is not present, so this is only needed for\n-            // that case.\n-            let is_privately_empty = ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n-            // If the enum is declared as `#[non_exhaustive]`, we treat it as if it had an\n-            // additionnal \"unknown\" constructor.\n-            let is_declared_nonexhaustive =\n-                def.is_variant_list_non_exhaustive() && !cx.is_local(pcx.ty);\n-\n-            if is_privately_empty || is_declared_nonexhaustive {\n-                // There is no point in enumerating all possible variants, because the user can't\n-                // actually match against them themselves. So we return only the fictitious\n-                // constructor.\n-                // E.g., in an example like:\n-                // ```\n-                //     let err: io::ErrorKind = ...;\n-                //     match err {\n-                //         io::ErrorKind::NotFound => {},\n-                //     }\n-                // ```\n-                // we don't want to show every possible IO error, but instead have only `_` as the\n-                // witness.\n-                vec![NonExhaustive]\n+                    })\n+                    .map(|v| Variant(v.def_id))\n+                    .collect()\n             } else {\n-                ctors\n-            }\n+                def.variants.iter().map(|v| Variant(v.def_id)).collect()\n+            };\n+\n+            // If the enum is declared as `#[non_exhaustive]`, we treat it as if it had an\n+            // additional \"unknown\" constructor.\n+            // There is no point in enumerating all possible variants, because the user can't\n+            // actually match against them all themselves. So we always return only the fictitious\n+            // constructor.\n+            // E.g., in an example like:\n+            // ```\n+            //     let err: io::ErrorKind = ...;\n+            //     match err {\n+            //         io::ErrorKind::NotFound => {},\n+            //     }\n+            // ```\n+            // we don't want to show every possible IO error, but instead have only `_` as the\n+            // witness.\n+            let is_declared_nonexhaustive = cx.is_foreign_non_exhaustive_enum(pcx.ty);\n+\n+            // If `exhaustive_patterns` is disabled and our scrutinee is an empty enum, we treat it\n+            // as though it had an \"unknown\" constructor to avoid exposing its emptyness. Note that\n+            // an empty match will still be considered exhaustive because that case is handled\n+            // separately in `check_match`.\n+            let is_secretly_empty =\n+                def.variants.is_empty() && !cx.tcx.features().exhaustive_patterns;\n+\n+            if is_secretly_empty || is_declared_nonexhaustive { vec![NonExhaustive] } else { ctors }\n         }\n         ty::Char => {\n             vec![\n@@ -1605,6 +1620,7 @@ pub fn is_useful<'p, 'tcx>(\n     v: &PatStack<'p, 'tcx>,\n     witness_preference: WitnessPreference,\n     hir_id: HirId,\n+    is_top_level: bool,\n ) -> Usefulness<'tcx, 'p> {\n     let &Matrix(ref rows) = matrix;\n     debug!(\"is_useful({:#?}, {:#?})\", matrix, v);\n@@ -1632,7 +1648,7 @@ pub fn is_useful<'p, 'tcx>(\n         let mut unreachable_pats = Vec::new();\n         let mut any_is_useful = false;\n         for v in vs {\n-            let res = is_useful(cx, &matrix, &v, witness_preference, hir_id);\n+            let res = is_useful(cx, &matrix, &v, witness_preference, hir_id, false);\n             match res {\n                 Useful(pats) => {\n                     any_is_useful = true;\n@@ -1732,7 +1748,7 @@ pub fn is_useful<'p, 'tcx>(\n         } else {\n             let matrix = matrix.specialize_wildcard();\n             let v = v.to_tail();\n-            let usefulness = is_useful(cx, &matrix, &v, witness_preference, hir_id);\n+            let usefulness = is_useful(cx, &matrix, &v, witness_preference, hir_id, false);\n \n             // In this case, there's at least one \"free\"\n             // constructor that is only matched against by\n@@ -1761,7 +1777,10 @@ pub fn is_useful<'p, 'tcx>(\n             // `(<direction-1>, <direction-2>, true)` - we are\n             // satisfied with `(_, _, true)`. In this case,\n             // `used_ctors` is empty.\n-            if missing_ctors.all_ctors_are_missing() {\n+            // The exception is: if we are at the top-level, for example in an empty match, we\n+            // sometimes prefer reporting the list of constructors instead of just `_`.\n+            let report_ctors_rather_than_wildcard = is_top_level && !IntRange::is_integral(pcx.ty);\n+            if missing_ctors.all_ctors_are_missing() && !report_ctors_rather_than_wildcard {\n                 // All constructors are unused. Add a wild pattern\n                 // rather than each individual constructor.\n                 usefulness.apply_wildcard(pcx.ty)\n@@ -1793,7 +1812,7 @@ fn is_useful_specialized<'p, 'tcx>(\n         cx.pattern_arena.alloc_from_iter(ctor.wildcard_subpatterns(cx, lty));\n     let matrix = matrix.specialize_constructor(cx, &ctor, ctor_wild_subpatterns);\n     v.specialize_constructor(cx, &ctor, ctor_wild_subpatterns)\n-        .map(|v| is_useful(cx, &matrix, &v, witness_preference, hir_id))\n+        .map(|v| is_useful(cx, &matrix, &v, witness_preference, hir_id, false))\n         .map(|u| u.apply_constructor(cx, &ctor, lty))\n         .unwrap_or(NotUseful)\n }\n@@ -2308,7 +2327,7 @@ fn specialize_one_pattern<'p, 'tcx>(\n \n         PatKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let ref variant = adt_def.variants[variant_index];\n-            let is_non_exhaustive = variant.is_field_list_non_exhaustive() && !cx.is_local(pat.ty);\n+            let is_non_exhaustive = cx.is_foreign_non_exhaustive_variant(pat.ty, variant);\n             Some(Variant(variant.def_id))\n                 .filter(|variant_constructor| variant_constructor == constructor)\n                 .map(|_| {"}, {"sha": "8156cfe7ab51d044e4be3a4d85b0782edf957b5f", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 54, "deletions": 79, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "patch": "@@ -148,8 +148,8 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                         self.tables,\n                     );\n                     patcx.include_lint_checks();\n-                    let pattern: &_ =\n-                        cx.pattern_arena.alloc(expand_pattern(cx, patcx.lower_pattern(&arm.pat)));\n+                    let pattern = patcx.lower_pattern(&arm.pat);\n+                    let pattern: &_ = cx.pattern_arena.alloc(expand_pattern(cx, pattern));\n                     if !patcx.errors.is_empty() {\n                         patcx.report_inlining_errors(arm.pat.span);\n                         have_errors = true;\n@@ -166,73 +166,12 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             // Fourth, check for unreachable arms.\n             let matrix = check_arms(cx, &inlined_arms, source);\n \n-            // Then, if the match has no arms, check whether the scrutinee\n-            // is uninhabited.\n-            let pat_ty = self.tables.node_type(scrut.hir_id);\n-            let module = self.tcx.hir().get_module_parent(scrut.hir_id);\n-            let mut def_span = None;\n-            let mut missing_variants = vec![];\n-            if inlined_arms.is_empty() {\n-                let scrutinee_is_uninhabited = if self.tcx.features().exhaustive_patterns {\n-                    self.tcx.is_ty_uninhabited_from(module, pat_ty)\n-                } else {\n-                    match pat_ty.kind {\n-                        ty::Never => true,\n-                        ty::Adt(def, _) => {\n-                            def_span = self.tcx.hir().span_if_local(def.did);\n-                            if def.variants.len() < 4 && !def.variants.is_empty() {\n-                                // keep around to point at the definition of non-covered variants\n-                                missing_variants =\n-                                    def.variants.iter().map(|variant| variant.ident).collect();\n-                            }\n-\n-                            let is_non_exhaustive_and_non_local =\n-                                def.is_variant_list_non_exhaustive() && !def.did.is_local();\n-\n-                            !(is_non_exhaustive_and_non_local) && def.variants.is_empty()\n-                        }\n-                        _ => false,\n-                    }\n-                };\n-                if !scrutinee_is_uninhabited {\n-                    // We know the type is inhabited, so this must be wrong\n-                    let mut err = create_e0004(\n-                        self.tcx.sess,\n-                        scrut.span,\n-                        format!(\n-                            \"non-exhaustive patterns: {}\",\n-                            match missing_variants.len() {\n-                                0 => format!(\"type `{}` is non-empty\", pat_ty),\n-                                1 => format!(\n-                                    \"pattern `{}` of type `{}` is not handled\",\n-                                    missing_variants[0].name, pat_ty,\n-                                ),\n-                                _ => format!(\n-                                    \"multiple patterns of type `{}` are not handled\",\n-                                    pat_ty\n-                                ),\n-                            }\n-                        ),\n-                    );\n-                    err.help(\n-                        \"ensure that all possible cases are being handled, \\\n-                         possibly by adding wildcards or more match arms\",\n-                    );\n-                    if let Some(sp) = def_span {\n-                        err.span_label(sp, format!(\"`{}` defined here\", pat_ty));\n-                    }\n-                    // point at the definition of non-covered enum variants\n-                    for variant in &missing_variants {\n-                        err.span_label(variant.span, \"variant not covered\");\n-                    }\n-                    err.emit();\n-                }\n-                // If the type *is* uninhabited, it's vacuously exhaustive\n-                return;\n-            }\n-\n+            // Fifth, check if the match is exhaustive.\n             let scrut_ty = self.tables.node_type(scrut.hir_id);\n-            check_exhaustive(cx, scrut_ty, scrut.span, &matrix, scrut.hir_id);\n+            // Note: An empty match isn't the same as an empty matrix for diagnostics purposes,\n+            // since an empty matrix can occur when there are arms, if those arms all have guards.\n+            let is_empty_match = inlined_arms.is_empty();\n+            check_exhaustive(cx, scrut_ty, scrut.span, &matrix, scrut.hir_id, is_empty_match);\n         })\n     }\n \n@@ -390,7 +329,7 @@ fn check_arms<'p, 'tcx>(\n     for (arm_index, (pat, hir_pat, has_guard)) in arms.iter().enumerate() {\n         let v = PatStack::from_pattern(pat);\n \n-        match is_useful(cx, &seen, &v, LeaveOutWitness, hir_pat.hir_id) {\n+        match is_useful(cx, &seen, &v, LeaveOutWitness, hir_pat.hir_id, true) {\n             NotUseful => {\n                 match source {\n                     hir::MatchSource::IfDesugar { .. } | hir::MatchSource::WhileDesugar => bug!(),\n@@ -478,7 +417,8 @@ fn check_not_useful<'p, 'tcx>(\n     hir_id: HirId,\n ) -> Result<(), Vec<super::Pat<'tcx>>> {\n     let wild_pattern = cx.pattern_arena.alloc(super::Pat::wildcard_from_ty(ty));\n-    match is_useful(cx, matrix, &PatStack::from_pattern(wild_pattern), ConstructWitness, hir_id) {\n+    let v = PatStack::from_pattern(wild_pattern);\n+    match is_useful(cx, matrix, &v, ConstructWitness, hir_id, true) {\n         NotUseful => Ok(()), // This is good, wildcard pattern isn't reachable.\n         UsefulWithWitness(pats) => Err(if pats.is_empty() {\n             bug!(\"Exhaustiveness check returned no witnesses\")\n@@ -495,25 +435,60 @@ fn check_exhaustive<'p, 'tcx>(\n     sp: Span,\n     matrix: &Matrix<'p, 'tcx>,\n     hir_id: HirId,\n+    is_empty_match: bool,\n ) {\n+    // In the absence of the `exhaustive_patterns` feature, empty matches are not detected by\n+    // `is_useful` to exhaustively match uninhabited types, so we manually check here.\n+    if is_empty_match && !cx.tcx.features().exhaustive_patterns {\n+        let scrutinee_is_visibly_uninhabited = match scrut_ty.kind {\n+            ty::Never => true,\n+            ty::Adt(def, _) => {\n+                def.is_enum()\n+                    && def.variants.is_empty()\n+                    && !cx.is_foreign_non_exhaustive_enum(scrut_ty)\n+            }\n+            _ => false,\n+        };\n+        if scrutinee_is_visibly_uninhabited {\n+            // If the type *is* uninhabited, an empty match is vacuously exhaustive.\n+            return;\n+        }\n+    }\n+\n     let witnesses = match check_not_useful(cx, scrut_ty, matrix, hir_id) {\n         Ok(_) => return,\n         Err(err) => err,\n     };\n \n-    let joined_patterns = joined_uncovered_patterns(&witnesses);\n-    let mut err = create_e0004(\n-        cx.tcx.sess,\n-        sp,\n-        format!(\"non-exhaustive patterns: {} not covered\", joined_patterns),\n-    );\n-    err.span_label(sp, pattern_not_covered_label(&witnesses, &joined_patterns));\n+    let non_empty_enum = match scrut_ty.kind {\n+        ty::Adt(def, _) => def.is_enum() && !def.variants.is_empty(),\n+        _ => false,\n+    };\n+    // In the case of an empty match, replace the '`_` not covered' diagnostic with something more\n+    // informative.\n+    let mut err;\n+    if is_empty_match && !non_empty_enum {\n+        err = create_e0004(\n+            cx.tcx.sess,\n+            sp,\n+            format!(\"non-exhaustive patterns: type `{}` is non-empty\", scrut_ty),\n+        );\n+    } else {\n+        let joined_patterns = joined_uncovered_patterns(&witnesses);\n+        err = create_e0004(\n+            cx.tcx.sess,\n+            sp,\n+            format!(\"non-exhaustive patterns: {} not covered\", joined_patterns),\n+        );\n+        err.span_label(sp, pattern_not_covered_label(&witnesses, &joined_patterns));\n+    };\n+\n     adt_defined_here(cx, &mut err, scrut_ty, &witnesses);\n     err.help(\n         \"ensure that all possible cases are being handled, \\\n          possibly by adding wildcards or more match arms\",\n-    )\n-    .emit();\n+    );\n+    err.emit();\n }\n \n fn joined_uncovered_patterns(witnesses: &[super::Pat<'_>]) -> String {"}, {"sha": "f5b41cd1cc0bbac4366d21566c3639856b8d3e74", "filename": "src/test/ui/error-codes/E0004-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr?ref=df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: multiple patterns of type `std::option::Option<i32>` are not handled\n+error[E0004]: non-exhaustive patterns: `None` and `Some(_)` not covered\n   --> $DIR/E0004-2.rs:4:11\n    |\n LL |     match x { }\n-   |           ^\n+   |           ^ patterns `None` and `Some(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "445eb4107d1dff84342908882432f02017b4f810", "filename": "src/test/ui/issues/issue-3601.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Fissues%2Fissue-3601.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Fissues%2Fissue-3601.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3601.stderr?ref=df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `_` not covered\n+error[E0004]: non-exhaustive patterns: `Box(_)` not covered\n   --> $DIR/issue-3601.rs:30:44\n    |\n LL |         box NodeKind::Element(ed) => match ed.kind {\n-   |                                            ^^^^^^^ pattern `_` not covered\n+   |                                            ^^^^^^^ pattern `Box(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "1b1096c977ad4e915641319ca048c79a9bb57a27", "filename": "src/test/ui/pattern/usefulness/always-inhabited-union-ref.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Falways-inhabited-union-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Falways-inhabited-union-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Falways-inhabited-union-ref.stderr?ref=df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "patch": "@@ -9,8 +9,13 @@ LL |     match uninhab_ref() {\n error[E0004]: non-exhaustive patterns: type `Foo` is non-empty\n   --> $DIR/always-inhabited-union-ref.rs:27:11\n    |\n-LL |     match uninhab_union() {\n-   |           ^^^^^^^^^^^^^^^\n+LL | / pub union Foo {\n+LL | |     foo: !,\n+LL | | }\n+   | |_- `Foo` defined here\n+...\n+LL |       match uninhab_union() {\n+   |             ^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "57b6b910ca1dad857637b5bfafeb26e4608ea7c4", "filename": "src/test/ui/pattern/usefulness/match-empty-exhaustive_patterns.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty-exhaustive_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty-exhaustive_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty-exhaustive_patterns.rs?ref=df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "patch": "@@ -0,0 +1,93 @@\n+#![feature(never_type)]\n+#![feature(exhaustive_patterns)]\n+#![deny(unreachable_patterns)]\n+enum Foo {}\n+\n+struct NonEmptyStruct(bool); //~ `NonEmptyStruct` defined here\n+union NonEmptyUnion1 { //~ `NonEmptyUnion1` defined here\n+    foo: (),\n+}\n+union NonEmptyUnion2 { //~ `NonEmptyUnion2` defined here\n+    foo: (),\n+    bar: (),\n+}\n+enum NonEmptyEnum1 { //~ `NonEmptyEnum1` defined here\n+    Foo(bool),\n+    //~^ not covered\n+    //~| not covered\n+}\n+enum NonEmptyEnum2 { //~ `NonEmptyEnum2` defined here\n+    Foo(bool),\n+    //~^ not covered\n+    //~| not covered\n+    Bar,\n+    //~^ not covered\n+    //~| not covered\n+}\n+enum NonEmptyEnum5 { //~ `NonEmptyEnum5` defined here\n+    V1, V2, V3, V4, V5,\n+}\n+\n+macro_rules! match_empty {\n+    ($e:expr) => {\n+        match $e {}\n+    };\n+}\n+macro_rules! match_false {\n+    ($e:expr) => {\n+        match $e {\n+            _ if false => {}\n+        }\n+    };\n+}\n+\n+fn foo(x: Foo) {\n+    match_empty!(x); // ok\n+    match x {\n+        _ => {}, //~ ERROR unreachable pattern\n+    }\n+    match x {\n+        _ if false => {}, //~ ERROR unreachable pattern\n+    }\n+}\n+\n+fn main() {\n+    match None::<!> {\n+        None => {}\n+        Some(_) => {} //~ ERROR unreachable pattern\n+    }\n+    match None::<Foo> {\n+        None => {}\n+        Some(_) => {} //~ ERROR unreachable pattern\n+    }\n+\n+    match_empty!(0u8);\n+    //~^ ERROR type `u8` is non-empty\n+    match_empty!(NonEmptyStruct(true));\n+    //~^ ERROR type `NonEmptyStruct` is non-empty\n+    match_empty!((NonEmptyUnion1 { foo: () }));\n+    //~^ ERROR type `NonEmptyUnion1` is non-empty\n+    match_empty!((NonEmptyUnion2 { foo: () }));\n+    //~^ ERROR type `NonEmptyUnion2` is non-empty\n+    match_empty!(NonEmptyEnum1::Foo(true));\n+    //~^ ERROR `Foo(_)` not covered\n+    match_empty!(NonEmptyEnum2::Foo(true));\n+    //~^ ERROR `Foo(_)` and `Bar` not covered\n+    match_empty!(NonEmptyEnum5::V1);\n+    //~^ ERROR `V1`, `V2`, `V3` and 2 more not covered\n+\n+    match_false!(0u8);\n+    //~^ ERROR `_` not covered\n+    match_false!(NonEmptyStruct(true));\n+    //~^ ERROR `NonEmptyStruct(_)` not covered\n+    match_false!((NonEmptyUnion1 { foo: () }));\n+    //~^ ERROR `NonEmptyUnion1 { .. }` not covered\n+    match_false!((NonEmptyUnion2 { foo: () }));\n+    //~^ ERROR `NonEmptyUnion2 { .. }` not covered\n+    match_false!(NonEmptyEnum1::Foo(true));\n+    //~^ ERROR `Foo(_)` not covered\n+    match_false!(NonEmptyEnum2::Foo(true));\n+    //~^ ERROR `Foo(_)` and `Bar` not covered\n+    match_false!(NonEmptyEnum5::V1);\n+    //~^ ERROR `V1`, `V2`, `V3` and 2 more not covered\n+}"}, {"sha": "f242ecf2dae4eb37b4ca9c224e1497f09de7658c", "filename": "src/test/ui/pattern/usefulness/match-empty-exhaustive_patterns.stderr", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty-exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty-exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty-exhaustive_patterns.stderr?ref=df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "patch": "@@ -0,0 +1,223 @@\n+error: unreachable pattern\n+  --> $DIR/match-empty-exhaustive_patterns.rs:47:9\n+   |\n+LL |         _ => {},\n+   |         ^\n+   |\n+note: lint level defined here\n+  --> $DIR/match-empty-exhaustive_patterns.rs:3:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/match-empty-exhaustive_patterns.rs:50:9\n+   |\n+LL |         _ if false => {},\n+   |         ^\n+\n+error: unreachable pattern\n+  --> $DIR/match-empty-exhaustive_patterns.rs:57:9\n+   |\n+LL |         Some(_) => {}\n+   |         ^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/match-empty-exhaustive_patterns.rs:61:9\n+   |\n+LL |         Some(_) => {}\n+   |         ^^^^^^^\n+\n+error[E0004]: non-exhaustive patterns: type `u8` is non-empty\n+  --> $DIR/match-empty-exhaustive_patterns.rs:64:18\n+   |\n+LL |     match_empty!(0u8);\n+   |                  ^^^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: type `NonEmptyStruct` is non-empty\n+  --> $DIR/match-empty-exhaustive_patterns.rs:66:18\n+   |\n+LL | struct NonEmptyStruct(bool);\n+   | ---------------------------- `NonEmptyStruct` defined here\n+...\n+LL |     match_empty!(NonEmptyStruct(true));\n+   |                  ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: type `NonEmptyUnion1` is non-empty\n+  --> $DIR/match-empty-exhaustive_patterns.rs:68:18\n+   |\n+LL | / union NonEmptyUnion1 {\n+LL | |     foo: (),\n+LL | | }\n+   | |_- `NonEmptyUnion1` defined here\n+...\n+LL |       match_empty!((NonEmptyUnion1 { foo: () }));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: type `NonEmptyUnion2` is non-empty\n+  --> $DIR/match-empty-exhaustive_patterns.rs:70:18\n+   |\n+LL | / union NonEmptyUnion2 {\n+LL | |     foo: (),\n+LL | |     bar: (),\n+LL | | }\n+   | |_- `NonEmptyUnion2` defined here\n+...\n+LL |       match_empty!((NonEmptyUnion2 { foo: () }));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n+  --> $DIR/match-empty-exhaustive_patterns.rs:72:18\n+   |\n+LL | / enum NonEmptyEnum1 {\n+LL | |     Foo(bool),\n+   | |     --- not covered\n+LL | |\n+LL | |\n+LL | | }\n+   | |_- `NonEmptyEnum1` defined here\n+...\n+LL |       match_empty!(NonEmptyEnum1::Foo(true));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n+  --> $DIR/match-empty-exhaustive_patterns.rs:74:18\n+   |\n+LL | / enum NonEmptyEnum2 {\n+LL | |     Foo(bool),\n+   | |     --- not covered\n+LL | |\n+LL | |\n+LL | |     Bar,\n+   | |     --- not covered\n+LL | |\n+LL | |\n+LL | | }\n+   | |_- `NonEmptyEnum2` defined here\n+...\n+LL |       match_empty!(NonEmptyEnum2::Foo(true));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n+  --> $DIR/match-empty-exhaustive_patterns.rs:76:18\n+   |\n+LL | / enum NonEmptyEnum5 {\n+LL | |     V1, V2, V3, V4, V5,\n+LL | | }\n+   | |_- `NonEmptyEnum5` defined here\n+...\n+LL |       match_empty!(NonEmptyEnum5::V1);\n+   |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `_` not covered\n+  --> $DIR/match-empty-exhaustive_patterns.rs:79:18\n+   |\n+LL |     match_false!(0u8);\n+   |                  ^^^ pattern `_` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `NonEmptyStruct(_)` not covered\n+  --> $DIR/match-empty-exhaustive_patterns.rs:81:18\n+   |\n+LL | struct NonEmptyStruct(bool);\n+   | ---------------------------- `NonEmptyStruct` defined here\n+...\n+LL |     match_false!(NonEmptyStruct(true));\n+   |                  ^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyStruct(_)` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `NonEmptyUnion1 { .. }` not covered\n+  --> $DIR/match-empty-exhaustive_patterns.rs:83:18\n+   |\n+LL | / union NonEmptyUnion1 {\n+LL | |     foo: (),\n+LL | | }\n+   | |_- `NonEmptyUnion1` defined here\n+...\n+LL |       match_false!((NonEmptyUnion1 { foo: () }));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `NonEmptyUnion2 { .. }` not covered\n+  --> $DIR/match-empty-exhaustive_patterns.rs:85:18\n+   |\n+LL | / union NonEmptyUnion2 {\n+LL | |     foo: (),\n+LL | |     bar: (),\n+LL | | }\n+   | |_- `NonEmptyUnion2` defined here\n+...\n+LL |       match_false!((NonEmptyUnion2 { foo: () }));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n+  --> $DIR/match-empty-exhaustive_patterns.rs:87:18\n+   |\n+LL | / enum NonEmptyEnum1 {\n+LL | |     Foo(bool),\n+   | |     --- not covered\n+LL | |\n+LL | |\n+LL | | }\n+   | |_- `NonEmptyEnum1` defined here\n+...\n+LL |       match_false!(NonEmptyEnum1::Foo(true));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n+  --> $DIR/match-empty-exhaustive_patterns.rs:89:18\n+   |\n+LL | / enum NonEmptyEnum2 {\n+LL | |     Foo(bool),\n+   | |     --- not covered\n+LL | |\n+LL | |\n+LL | |     Bar,\n+   | |     --- not covered\n+LL | |\n+LL | |\n+LL | | }\n+   | |_- `NonEmptyEnum2` defined here\n+...\n+LL |       match_false!(NonEmptyEnum2::Foo(true));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n+  --> $DIR/match-empty-exhaustive_patterns.rs:91:18\n+   |\n+LL | / enum NonEmptyEnum5 {\n+LL | |     V1, V2, V3, V4, V5,\n+LL | | }\n+   | |_- `NonEmptyEnum5` defined here\n+...\n+LL |       match_false!(NonEmptyEnum5::V1);\n+   |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error: aborting due to 18 previous errors\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "f7577125d8a3f9739220351bf7ae218a80e58ec8", "filename": "src/test/ui/pattern/usefulness/match-empty.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.rs?ref=df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "patch": "@@ -0,0 +1,92 @@\n+#![feature(never_type)]\n+#![deny(unreachable_patterns)]\n+enum Foo {}\n+\n+struct NonEmptyStruct(bool); //~ `NonEmptyStruct` defined here\n+union NonEmptyUnion1 { //~ `NonEmptyUnion1` defined here\n+    foo: (),\n+}\n+union NonEmptyUnion2 { //~ `NonEmptyUnion2` defined here\n+    foo: (),\n+    bar: (),\n+}\n+enum NonEmptyEnum1 { //~ `NonEmptyEnum1` defined here\n+    Foo(bool),\n+    //~^ not covered\n+    //~| not covered\n+}\n+enum NonEmptyEnum2 { //~ `NonEmptyEnum2` defined here\n+    Foo(bool),\n+    //~^ not covered\n+    //~| not covered\n+    Bar,\n+    //~^ not covered\n+    //~| not covered\n+}\n+enum NonEmptyEnum5 { //~ `NonEmptyEnum5` defined here\n+    V1, V2, V3, V4, V5,\n+}\n+\n+macro_rules! match_empty {\n+    ($e:expr) => {\n+        match $e {}\n+    };\n+}\n+macro_rules! match_false {\n+    ($e:expr) => {\n+        match $e {\n+            _ if false => {}\n+        }\n+    };\n+}\n+\n+fn foo(x: Foo) {\n+    match_empty!(x); // ok\n+    match_false!(x); // Not detected as unreachable nor exhaustive.\n+    //~^ ERROR non-exhaustive patterns: `_` not covered\n+    match x {\n+        _ => {}, // Not detected as unreachable, see #55123.\n+    }\n+}\n+\n+fn main() {\n+    // `exhaustive_patterns` is not on, so uninhabited branches are not detected as unreachable.\n+    match None::<!> {\n+        None => {}\n+        Some(_) => {}\n+    }\n+    match None::<Foo> {\n+        None => {}\n+        Some(_) => {}\n+    }\n+\n+    match_empty!(0u8);\n+    //~^ ERROR type `u8` is non-empty\n+    match_empty!(NonEmptyStruct(true));\n+    //~^ ERROR type `NonEmptyStruct` is non-empty\n+    match_empty!((NonEmptyUnion1 { foo: () }));\n+    //~^ ERROR type `NonEmptyUnion1` is non-empty\n+    match_empty!((NonEmptyUnion2 { foo: () }));\n+    //~^ ERROR type `NonEmptyUnion2` is non-empty\n+    match_empty!(NonEmptyEnum1::Foo(true));\n+    //~^ ERROR `Foo(_)` not covered\n+    match_empty!(NonEmptyEnum2::Foo(true));\n+    //~^ ERROR `Foo(_)` and `Bar` not covered\n+    match_empty!(NonEmptyEnum5::V1);\n+    //~^ ERROR `V1`, `V2`, `V3` and 2 more not covered\n+\n+    match_false!(0u8);\n+    //~^ ERROR `_` not covered\n+    match_false!(NonEmptyStruct(true));\n+    //~^ ERROR `NonEmptyStruct(_)` not covered\n+    match_false!((NonEmptyUnion1 { foo: () }));\n+    //~^ ERROR `NonEmptyUnion1 { .. }` not covered\n+    match_false!((NonEmptyUnion2 { foo: () }));\n+    //~^ ERROR `NonEmptyUnion2 { .. }` not covered\n+    match_false!(NonEmptyEnum1::Foo(true));\n+    //~^ ERROR `Foo(_)` not covered\n+    match_false!(NonEmptyEnum2::Foo(true));\n+    //~^ ERROR `Foo(_)` and `Bar` not covered\n+    match_false!(NonEmptyEnum5::V1);\n+    //~^ ERROR `V1`, `V2`, `V3` and 2 more not covered\n+}"}, {"sha": "72e3fc0a16744986317d1307f3fbf01d21d2b089", "filename": "src/test/ui/pattern/usefulness/match-empty.stderr", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-empty.stderr?ref=df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "patch": "@@ -0,0 +1,204 @@\n+error[E0004]: non-exhaustive patterns: `_` not covered\n+  --> $DIR/match-empty.rs:45:18\n+   |\n+LL | enum Foo {}\n+   | ----------- `Foo` defined here\n+...\n+LL |     match_false!(x); // Not detected as unreachable nor exhaustive.\n+   |                  ^ pattern `_` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: type `u8` is non-empty\n+  --> $DIR/match-empty.rs:63:18\n+   |\n+LL |     match_empty!(0u8);\n+   |                  ^^^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: type `NonEmptyStruct` is non-empty\n+  --> $DIR/match-empty.rs:65:18\n+   |\n+LL | struct NonEmptyStruct(bool);\n+   | ---------------------------- `NonEmptyStruct` defined here\n+...\n+LL |     match_empty!(NonEmptyStruct(true));\n+   |                  ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: type `NonEmptyUnion1` is non-empty\n+  --> $DIR/match-empty.rs:67:18\n+   |\n+LL | / union NonEmptyUnion1 {\n+LL | |     foo: (),\n+LL | | }\n+   | |_- `NonEmptyUnion1` defined here\n+...\n+LL |       match_empty!((NonEmptyUnion1 { foo: () }));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: type `NonEmptyUnion2` is non-empty\n+  --> $DIR/match-empty.rs:69:18\n+   |\n+LL | / union NonEmptyUnion2 {\n+LL | |     foo: (),\n+LL | |     bar: (),\n+LL | | }\n+   | |_- `NonEmptyUnion2` defined here\n+...\n+LL |       match_empty!((NonEmptyUnion2 { foo: () }));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n+  --> $DIR/match-empty.rs:71:18\n+   |\n+LL | / enum NonEmptyEnum1 {\n+LL | |     Foo(bool),\n+   | |     --- not covered\n+LL | |\n+LL | |\n+LL | | }\n+   | |_- `NonEmptyEnum1` defined here\n+...\n+LL |       match_empty!(NonEmptyEnum1::Foo(true));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n+  --> $DIR/match-empty.rs:73:18\n+   |\n+LL | / enum NonEmptyEnum2 {\n+LL | |     Foo(bool),\n+   | |     --- not covered\n+LL | |\n+LL | |\n+LL | |     Bar,\n+   | |     --- not covered\n+LL | |\n+LL | |\n+LL | | }\n+   | |_- `NonEmptyEnum2` defined here\n+...\n+LL |       match_empty!(NonEmptyEnum2::Foo(true));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n+  --> $DIR/match-empty.rs:75:18\n+   |\n+LL | / enum NonEmptyEnum5 {\n+LL | |     V1, V2, V3, V4, V5,\n+LL | | }\n+   | |_- `NonEmptyEnum5` defined here\n+...\n+LL |       match_empty!(NonEmptyEnum5::V1);\n+   |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `_` not covered\n+  --> $DIR/match-empty.rs:78:18\n+   |\n+LL |     match_false!(0u8);\n+   |                  ^^^ pattern `_` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `NonEmptyStruct(_)` not covered\n+  --> $DIR/match-empty.rs:80:18\n+   |\n+LL | struct NonEmptyStruct(bool);\n+   | ---------------------------- `NonEmptyStruct` defined here\n+...\n+LL |     match_false!(NonEmptyStruct(true));\n+   |                  ^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyStruct(_)` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `NonEmptyUnion1 { .. }` not covered\n+  --> $DIR/match-empty.rs:82:18\n+   |\n+LL | / union NonEmptyUnion1 {\n+LL | |     foo: (),\n+LL | | }\n+   | |_- `NonEmptyUnion1` defined here\n+...\n+LL |       match_false!((NonEmptyUnion1 { foo: () }));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `NonEmptyUnion2 { .. }` not covered\n+  --> $DIR/match-empty.rs:84:18\n+   |\n+LL | / union NonEmptyUnion2 {\n+LL | |     foo: (),\n+LL | |     bar: (),\n+LL | | }\n+   | |_- `NonEmptyUnion2` defined here\n+...\n+LL |       match_false!((NonEmptyUnion2 { foo: () }));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n+  --> $DIR/match-empty.rs:86:18\n+   |\n+LL | / enum NonEmptyEnum1 {\n+LL | |     Foo(bool),\n+   | |     --- not covered\n+LL | |\n+LL | |\n+LL | | }\n+   | |_- `NonEmptyEnum1` defined here\n+...\n+LL |       match_false!(NonEmptyEnum1::Foo(true));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n+  --> $DIR/match-empty.rs:88:18\n+   |\n+LL | / enum NonEmptyEnum2 {\n+LL | |     Foo(bool),\n+   | |     --- not covered\n+LL | |\n+LL | |\n+LL | |     Bar,\n+   | |     --- not covered\n+LL | |\n+LL | |\n+LL | | }\n+   | |_- `NonEmptyEnum2` defined here\n+...\n+LL |       match_false!(NonEmptyEnum2::Foo(true));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n+  --> $DIR/match-empty.rs:90:18\n+   |\n+LL | / enum NonEmptyEnum5 {\n+LL | |     V1, V2, V3, V4, V5,\n+LL | | }\n+   | |_- `NonEmptyEnum5` defined here\n+...\n+LL |       match_false!(NonEmptyEnum5::V1);\n+   |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error: aborting due to 15 previous errors\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "8516bafef9bd9e9f45f03e5cb34da55bc92fd71e", "filename": "src/test/ui/rfc-2008-non-exhaustive/auxiliary/enums.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fenums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fenums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fenums.rs?ref=df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "patch": "@@ -6,3 +6,6 @@ pub enum NonExhaustiveEnum {\n     Tuple(u32),\n     Struct { field: u32 }\n }\n+\n+#[non_exhaustive]\n+pub enum EmptyNonExhaustiveEnum {}"}, {"sha": "802f20b4bed602509ddc2648577c289be51a8769", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.rs?ref=df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "patch": "@@ -1,7 +1,14 @@\n // aux-build:enums.rs\n extern crate enums;\n \n-use enums::NonExhaustiveEnum;\n+use enums::{EmptyNonExhaustiveEnum, NonExhaustiveEnum};\n+\n+fn empty(x: EmptyNonExhaustiveEnum) {\n+    match x {} //~ ERROR type `enums::EmptyNonExhaustiveEnum` is non-empty\n+    match x {\n+        _ => {}, // ok\n+    }\n+}\n \n fn main() {\n     let enum_unit = NonExhaustiveEnum::Unit;\n@@ -13,6 +20,9 @@ fn main() {\n         NonExhaustiveEnum::Struct { .. } => \"third\"\n     };\n \n+    match enum_unit {};\n+    //~^ ERROR non-exhaustive patterns: `_` not covered [E0004]\n+\n     // Everything below this is expected to compile successfully.\n \n     let enum_unit = NonExhaustiveEnum::Unit;"}, {"sha": "a2bdcbaa4478dfbeaca8695bfc3fbd6d74a1c82c", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum.stderr", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum.stderr?ref=df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "patch": "@@ -1,11 +1,27 @@\n+error[E0004]: non-exhaustive patterns: type `enums::EmptyNonExhaustiveEnum` is non-empty\n+  --> $DIR/enum.rs:7:11\n+   |\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/enum.rs:9:11\n+  --> $DIR/enum.rs:16:11\n    |\n LL |     match enum_unit {\n    |           ^^^^^^^^^ pattern `_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error: aborting due to previous error\n+error[E0004]: non-exhaustive patterns: `_` not covered\n+  --> $DIR/enum.rs:23:11\n+   |\n+LL |     match enum_unit {};\n+   |           ^^^^^^^^^ pattern `_` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0004`."}, {"sha": "afd6d996c15a8ba01dcdca666ef0fed62bbf47cb", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum_same_crate_empty_match.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.rs?ref=df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "patch": "@@ -0,0 +1,37 @@\n+#![deny(unreachable_patterns)]\n+\n+#[non_exhaustive]\n+pub enum NonExhaustiveEnum {\n+    Unit,\n+    //~^ not covered\n+    Tuple(u32),\n+    //~^ not covered\n+    Struct { field: u32 }\n+    //~^ not covered\n+}\n+\n+pub enum NormalEnum {\n+    Unit,\n+    //~^ not covered\n+    Tuple(u32),\n+    //~^ not covered\n+    Struct { field: u32 }\n+    //~^ not covered\n+}\n+\n+#[non_exhaustive]\n+pub enum EmptyNonExhaustiveEnum {}\n+\n+fn empty_non_exhaustive(x: EmptyNonExhaustiveEnum) {\n+    match x {}\n+    match x {\n+        _ => {} // not detected as unreachable\n+    }\n+}\n+\n+fn main() {\n+    match NonExhaustiveEnum::Unit {}\n+    //~^ ERROR `Unit`, `Tuple(_)` and `Struct { .. }` not covered [E0004]\n+    match NormalEnum::Unit {}\n+    //~^ ERROR `Unit`, `Tuple(_)` and `Struct { .. }` not covered [E0004]\n+}"}, {"sha": "a99a690bc9e5a5a1bc8ddd2b38e8600da47977a8", "filename": "src/test/ui/rfc-2008-non-exhaustive/enum_same_crate_empty_match.stderr", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fenum_same_crate_empty_match.stderr?ref=df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "patch": "@@ -0,0 +1,45 @@\n+error[E0004]: non-exhaustive patterns: `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n+  --> $DIR/enum_same_crate_empty_match.rs:33:11\n+   |\n+LL | / pub enum NonExhaustiveEnum {\n+LL | |     Unit,\n+   | |     ---- not covered\n+LL | |\n+LL | |     Tuple(u32),\n+   | |     ----- not covered\n+LL | |\n+LL | |     Struct { field: u32 }\n+   | |     ------ not covered\n+LL | |\n+LL | | }\n+   | |_- `NonExhaustiveEnum` defined here\n+...\n+LL |       match NonExhaustiveEnum::Unit {}\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ patterns `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n+  --> $DIR/enum_same_crate_empty_match.rs:35:11\n+   |\n+LL | / pub enum NormalEnum {\n+LL | |     Unit,\n+   | |     ---- not covered\n+LL | |\n+LL | |     Tuple(u32),\n+   | |     ----- not covered\n+LL | |\n+LL | |     Struct { field: u32 }\n+   | |     ------ not covered\n+LL | |\n+LL | | }\n+   | |_- `NormalEnum` defined here\n+...\n+LL |       match NormalEnum::Unit {}\n+   |             ^^^^^^^^^^^^^^^^ patterns `Unit`, `Tuple(_)` and `Struct { .. }` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "0d669a9a4e9d906812ef066b3522ea29436a5940", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/indirect_match.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match.stderr?ref=df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "patch": "@@ -1,28 +1,28 @@\n-error[E0004]: non-exhaustive patterns: pattern `IndirectUninhabitedEnum` of type `uninhabited::IndirectUninhabitedEnum` is not handled\n+error[E0004]: non-exhaustive patterns: type `uninhabited::IndirectUninhabitedEnum` is non-empty\n   --> $DIR/indirect_match.rs:18:11\n    |\n LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: pattern `IndirectUninhabitedStruct` of type `uninhabited::IndirectUninhabitedStruct` is not handled\n+error[E0004]: non-exhaustive patterns: type `uninhabited::IndirectUninhabitedStruct` is non-empty\n   --> $DIR/indirect_match.rs:22:11\n    |\n LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: pattern `IndirectUninhabitedTupleStruct` of type `uninhabited::IndirectUninhabitedTupleStruct` is not handled\n+error[E0004]: non-exhaustive patterns: type `uninhabited::IndirectUninhabitedTupleStruct` is non-empty\n   --> $DIR/indirect_match.rs:26:11\n    |\n LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: pattern `IndirectUninhabitedVariants` of type `uninhabited::IndirectUninhabitedVariants` is not handled\n+error[E0004]: non-exhaustive patterns: type `uninhabited::IndirectUninhabitedVariants` is non-empty\n   --> $DIR/indirect_match.rs:32:11\n    |\n LL |     match x {}"}, {"sha": "41a37cf6a036fb708928a36ab9587c2e9315d14b", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/indirect_match_same_crate.stderr", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.stderr?ref=df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "patch": "@@ -1,53 +1,41 @@\n-error[E0004]: non-exhaustive patterns: pattern `IndirectUninhabitedEnum` of type `IndirectUninhabitedEnum` is not handled\n+error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedEnum` is non-empty\n   --> $DIR/indirect_match_same_crate.rs:32:11\n    |\n LL | pub struct IndirectUninhabitedEnum(UninhabitedEnum);\n-   | ----------------------------------------------------\n-   | |          |\n-   | |          variant not covered\n-   | `IndirectUninhabitedEnum` defined here\n+   | ---------------------------------------------------- `IndirectUninhabitedEnum` defined here\n ...\n LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: pattern `IndirectUninhabitedStruct` of type `IndirectUninhabitedStruct` is not handled\n+error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedStruct` is non-empty\n   --> $DIR/indirect_match_same_crate.rs:36:11\n    |\n LL | pub struct IndirectUninhabitedStruct(UninhabitedStruct);\n-   | --------------------------------------------------------\n-   | |          |\n-   | |          variant not covered\n-   | `IndirectUninhabitedStruct` defined here\n+   | -------------------------------------------------------- `IndirectUninhabitedStruct` defined here\n ...\n LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: pattern `IndirectUninhabitedTupleStruct` of type `IndirectUninhabitedTupleStruct` is not handled\n+error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedTupleStruct` is non-empty\n   --> $DIR/indirect_match_same_crate.rs:40:11\n    |\n LL | pub struct IndirectUninhabitedTupleStruct(UninhabitedTupleStruct);\n-   | ------------------------------------------------------------------\n-   | |          |\n-   | |          variant not covered\n-   | `IndirectUninhabitedTupleStruct` defined here\n+   | ------------------------------------------------------------------ `IndirectUninhabitedTupleStruct` defined here\n ...\n LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: pattern `IndirectUninhabitedVariants` of type `IndirectUninhabitedVariants` is not handled\n+error[E0004]: non-exhaustive patterns: type `IndirectUninhabitedVariants` is non-empty\n   --> $DIR/indirect_match_same_crate.rs:46:11\n    |\n LL | pub struct IndirectUninhabitedVariants(UninhabitedVariants);\n-   | ------------------------------------------------------------\n-   | |          |\n-   | |          variant not covered\n-   | `IndirectUninhabitedVariants` defined here\n+   | ------------------------------------------------------------ `IndirectUninhabitedVariants` defined here\n ...\n LL |     match x {}\n    |           ^"}, {"sha": "10a456a5a879ad09249de29f85eab23f5f539f85", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr?ref=df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "patch": "@@ -6,27 +6,27 @@ LL |     match x {}\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: pattern `UninhabitedStruct` of type `uninhabited::UninhabitedStruct` is not handled\n+error[E0004]: non-exhaustive patterns: type `uninhabited::UninhabitedStruct` is non-empty\n   --> $DIR/match.rs:22:11\n    |\n LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: pattern `UninhabitedTupleStruct` of type `uninhabited::UninhabitedTupleStruct` is not handled\n+error[E0004]: non-exhaustive patterns: type `uninhabited::UninhabitedTupleStruct` is non-empty\n   --> $DIR/match.rs:26:11\n    |\n LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: multiple patterns of type `uninhabited::UninhabitedVariants` are not handled\n+error[E0004]: non-exhaustive patterns: `Tuple(_)` and `Struct { .. }` not covered\n   --> $DIR/match.rs:30:11\n    |\n LL |     match x {}\n-   |           ^\n+   |           ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "148af8c07b1c64951ae769bc783e4e4ec86c1fa4", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match_same_crate.stderr", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.stderr?ref=df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "patch": "@@ -1,10 +1,7 @@\n-error[E0004]: non-exhaustive patterns: pattern `UninhabitedStruct` of type `UninhabitedStruct` is not handled\n+error[E0004]: non-exhaustive patterns: type `UninhabitedStruct` is non-empty\n   --> $DIR/match_same_crate.rs:28:11\n    |\n-LL |   pub struct UninhabitedStruct {\n-   |   -          ----------------- variant not covered\n-   |  _|\n-   | |\n+LL | / pub struct UninhabitedStruct {\n LL | |     _priv: !,\n LL | | }\n    | |_- `UninhabitedStruct` defined here\n@@ -14,33 +11,30 @@ LL |       match x {}\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: pattern `UninhabitedTupleStruct` of type `UninhabitedTupleStruct` is not handled\n+error[E0004]: non-exhaustive patterns: type `UninhabitedTupleStruct` is non-empty\n   --> $DIR/match_same_crate.rs:32:11\n    |\n LL | pub struct UninhabitedTupleStruct(!);\n-   | -------------------------------------\n-   | |          |\n-   | |          variant not covered\n-   | `UninhabitedTupleStruct` defined here\n+   | ------------------------------------- `UninhabitedTupleStruct` defined here\n ...\n LL |     match x {}\n    |           ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: multiple patterns of type `UninhabitedVariants` are not handled\n+error[E0004]: non-exhaustive patterns: `Tuple(_)` and `Struct { .. }` not covered\n   --> $DIR/match_same_crate.rs:36:11\n    |\n LL | / pub enum UninhabitedVariants {\n LL | |     #[non_exhaustive] Tuple(!),\n-   | |                       ----- variant not covered\n+   | |                       ----- not covered\n LL | |     #[non_exhaustive] Struct { x: ! }\n-   | |                       ------ variant not covered\n+   | |                       ------ not covered\n LL | | }\n    | |_- `UninhabitedVariants` defined here\n ...\n LL |       match x {}\n-   |             ^\n+   |             ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "2fc09c81ab031915ed1b95b78822ff7feef049de", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match_with_exhaustive_patterns.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr?ref=df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "patch": "@@ -22,11 +22,11 @@ LL |     match x {}\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: type `uninhabited::UninhabitedVariants` is non-empty\n+error[E0004]: non-exhaustive patterns: `Tuple(_)` and `Struct { .. }` not covered\n   --> $DIR/match_with_exhaustive_patterns.rs:33:11\n    |\n LL |     match x {}\n-   |           ^\n+   |           ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "18ffdccb9b2db89ac024975770363525c4e7e70c", "filename": "src/test/ui/uninhabited/uninhabited-matches-feature-gated.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr?ref=df9e491fb238ff7b7bfee8dd2d3f01158ac8b0d3", "patch": "@@ -9,6 +9,9 @@ LL |     let _ = match x {\n error[E0004]: non-exhaustive patterns: type `&Void` is non-empty\n   --> $DIR/uninhabited-matches-feature-gated.rs:12:19\n    |\n+LL | enum Void {}\n+   | ------------ `Void` defined here\n+...\n LL |     let _ = match x {};\n    |                   ^\n    |"}]}