{"sha": "6627ac662386541737ab26e3a1c633dc88185c62", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MjdhYzY2MjM4NjU0MTczN2FiMjZlM2ExYzYzM2RjODgxODVjNjI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-11T02:32:11Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-11T02:32:11Z"}, "message": "Copyedit section 3 of tutorial", "tree": {"sha": "020f4221d2d7b56fbc97b77b4da8d13161ee6f71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/020f4221d2d7b56fbc97b77b4da8d13161ee6f71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6627ac662386541737ab26e3a1c633dc88185c62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6627ac662386541737ab26e3a1c633dc88185c62", "html_url": "https://github.com/rust-lang/rust/commit/6627ac662386541737ab26e3a1c633dc88185c62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6627ac662386541737ab26e3a1c633dc88185c62/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38ccaed4ce0892bfa36c210302c42de1aa4dd584", "url": "https://api.github.com/repos/rust-lang/rust/commits/38ccaed4ce0892bfa36c210302c42de1aa4dd584", "html_url": "https://github.com/rust-lang/rust/commit/38ccaed4ce0892bfa36c210302c42de1aa4dd584"}], "stats": {"total": 98, "additions": 53, "deletions": 45}, "files": [{"sha": "2d43d19deffd2151905c1f26a41902426ef5445e", "filename": "doc/tutorial.md", "status": "modified", "additions": 53, "deletions": 45, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/6627ac662386541737ab26e3a1c633dc88185c62/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/6627ac662386541737ab26e3a1c633dc88185c62/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=6627ac662386541737ab26e3a1c633dc88185c62", "patch": "@@ -184,8 +184,8 @@ and mostly have the same precedence as in C; comments are again like C.\n \n The main surface difference to be aware of is that the condition at\n the head of control structures like `if` and `while` do not require\n-paretheses, while their bodies *must* be wrapped in\n-brackets. Single-statement, bracket-less bodies are not allowed.\n+parentheses, while their bodies *must* be wrapped in\n+braces. Single-statement, unbraced bodies are not allowed.\n \n ~~~~\n # fn recalibrate_universe() -> bool { true }\n@@ -200,9 +200,9 @@ fn main() {\n }\n ~~~~\n \n-The `let` keyword introduces a local variable. Variables are immutable\n-by default, so `let mut` can be used to introduce a local variable\n-that can be reassigned.\n+The `let` keyword introduces a local variable. Variables are immutable by\n+default. To introduce a local variable that you can re-assign later, use `let\n+mut` instead.\n \n ~~~~\n let hi = \"hi\";\n@@ -224,14 +224,14 @@ let imaginary_size = monster_size * 10.0;\n let monster_size: int = 50;\n ~~~~\n \n-Local variables may shadow earlier declarations, as in the previous\n-example in which `monster_size` is first declared as a `float`\n-then a second `monster_size` is declared as an int. If you were to actually\n-compile this example though, the compiler will see that the second\n-`monster_size` is unused, assume that you have made a mistake, and issue\n-a warning. For occasions where unused variables are intentional, their\n-name may be prefixed with an underscore to silence the warning, like\n-`let _monster_size = 50;`.\n+Local variables may shadow earlier declarations, as in the previous example:\n+`monster_size` was first declared as a `float`, and then then a second\n+`monster_size` was declared as an int. If you were to actually compile this\n+example, though, the compiler will determine that the second `monster_size` is\n+unused and issue a warning (because this situation is likely to indicate a\n+programmer error). For occasions where unused variables are intentional, their\n+name may be prefixed with an underscore to silence the warning, like `let\n+_monster_size = 50;`.\n \n Rust identifiers follow the same rules as C; they start with an alphabetic\n character or an underscore, and after that may contain any sequence of\n@@ -278,10 +278,10 @@ let price =\n     };\n ~~~~\n \n-Both pieces of code are exactly equivalent\u2014they assign a value to\n+Both pieces of code are exactly equivalent: they assign a value to\n `price` depending on the condition that holds. Note that there\n-are not semicolons in the blocks of the second snippet. This is\n-important; the lack of a semicolon after the last statement in a\n+are no semicolons in the blocks of the second snippet. This is\n+important: the lack of a semicolon after the last statement in a\n braced block gives the whole block the value of that last expression.\n \n Put another way, the semicolon in Rust *ignores the value of an expression*.\n@@ -290,8 +290,10 @@ would simply assign `()` (nil or void) to `price`. But without the semicolon, ea\n branch has a different value, and `price` gets the value of the branch that\n was taken.\n \n-In short, everything that's not a declaration (`let` for variables,\n-`fn` for functions, et cetera) is an expression, including function bodies.\n+In short, everything that's not a declaration (declarations are `let` for\n+variables, `fn` for functions, and any top-level named items such as\n+[traits](#traits), [enum types](#enums), and [constants](#constants)) is an\n+expression, including function bodies.\n \n ~~~~\n fn is_four(x: int) -> bool {\n@@ -314,7 +316,7 @@ something\u2014in which case you'll have embedded it in a bigger statement.\n # fn foo() -> bool { true }\n # fn bar() -> bool { true }\n # fn baz() -> bool { true }\n-// `let` is not an expression, so it is semi-colon terminated;\n+// `let` is not an expression, so it is semicolon-terminated;\n let x = foo();\n \n // When used in statement position, bracy expressions do not\n@@ -346,7 +348,7 @@ This may sound intricate, but it is super-useful and will grow on you.\n The basic types include the usual boolean, integral, and floating-point types.\n \n ------------------------- -----------------------------------------------\n-`()`                      Nil, the type that has only a single value\n+`()`                      Unit, the type that has only a single value\n `bool`                    Boolean type, with values `true` and `false`\n `int`, `uint`             Machine-pointer-sized signed and unsigned integers\n `i8`, `i16`, `i32`, `i64` Signed integers with a specific size (in bits)\n@@ -394,10 +396,15 @@ type MonsterSize = uint;\n This will provide a synonym, `MonsterSize`, for unsigned integers. It will not\n actually create a new, incompatible type\u2014`MonsterSize` and `uint` can be used\n interchangeably, and using one where the other is expected is not a type\n-error.\n+error. In that sense, types declared with `type` are *structural*: their\n+meaning follows from their structure, and their names are irrelevant in the\n+type system.\n \n-To create data types which are not synonyms, `struct` and `enum`\n-can be used. They're described in more detail below, but they look like this:\n+Sometimes, you want your data types to be *nominal* instead of structural: you\n+want their name to be part of their meaning, so that types with the same\n+structure but different names are not interchangeable. Rust has two ways to\n+create nominal data types: `struct` and `enum`. They're described in more\n+detail below, but they look like this:\n \n ~~~~\n enum HidingPlaces {\n@@ -416,12 +423,12 @@ enum MonsterSize = uint;      // a single-variant enum\n \n ## Literals\n \n-Integers can be written in decimal (`144`), hexadecimal (`0x90`), and\n+Integers can be written in decimal (`144`), hexadecimal (`0x90`), or\n binary (`0b10010000`) base. Each integral type has a corresponding literal\n suffix that can be used to indicate the type of a literal: `i` for `int`,\n `u` for `uint`, and `i8` for the `i8` type, etc.\n \n-In the absense of an integer literal suffix, Rust will infer the\n+In the absence of an integer literal suffix, Rust will infer the\n integer type based on type annotations and function signatures in the\n surrounding program. In the absence of any type information at all,\n Rust will assume that an unsuffixed integer literal has type\n@@ -439,24 +446,24 @@ a suffix, the literal is assumed to be of type `float`. Suffixes `f32`\n (32-bit) and `f64` (64-bit) can be used to create literals of a\n specific type.\n \n-The nil literal is written just like the type: `()`. The keywords\n+The unit literal is written just like the type: `()`. The keywords\n `true` and `false` produce the boolean literals.\n \n-Character literals are written between single quotes, as in `'x'`. Just as in\n+Character literals are written between single quotes, as in `'x'`. Just like\n C, Rust understands a number of character escapes, using the backslash\n character, such as `\\n`, `\\r`, and `\\t`. String literals,\n written between double quotes, allow the same escape sequences. Rust strings\n may contain newlines.\n \n ## Constants\n \n-Compile-time constants are declared with `const`. All scalar types,\n-like integers and floats, may be declared `const`, as well as fixed\n-length vectors, static strings (more on this later), and structs.\n-Constants may be declared in any scope and may refer to other\n-constants. Constant declarations are not type inferred, so must always\n-have a type annotation.  By convention they are written in all capital\n-letters.\n+Compile-time constants are declared with `const`. A constant may have any\n+scalar type (for example, integer or float). Other allowable constant types\n+are fixed-length vectors, static strings (more on this later), and\n+structs. Constants may be declared in any scope and may refer to other\n+constants. The compiler does not infer types for constants, so constants must\n+always be declared with a type annotation. By convention, they are written in\n+all capital letters.\n \n ~~~\n // Scalars can be constants\n@@ -480,7 +487,7 @@ const MY_STRUCTY_PASSWORD: Password = Password { value: MY_PASSWORD };\n \n Rust's set of operators contains very few surprises. Arithmetic is done with\n `*`, `/`, `%`, `+`, and `-` (multiply, divide, remainder, plus, minus). `-` is\n-also a unary prefix operator that does negation. As in C, the bit operators\n+also a unary prefix operator that negates numbers. As in C, the bit operators\n `>>`, `<<`, `&`, `|`, and `^` are also supported.\n \n Note that, if applied to an integer value, `!` flips all the bits (like `~` in\n@@ -502,21 +509,21 @@ assert y == 4u;\n ~~~~\n \n The main difference with C is that `++` and `--` are missing, and that\n-the logical bitwise operators have higher precedence \u2014 in C, `x & 2 > 0`\n+the logical bitwise operators have higher precedence\u2014in C, `x & 2 > 0`\n means `x & (2 > 0)`, but in Rust, it means `(x & 2) > 0`, which is\n-more likely what a novice expects.\n+more likely to be what a novice expects.\n \n ## Syntax extensions\n \n *Syntax extensions* are special forms that are not built into the language,\n but are instead provided by the libraries. To make it clear to the reader when\n-a syntax extension is being used, the names of all syntax extensions end with\n-`!`. The standard library defines a few syntax extensions, the most useful of\n-which is `fmt!`, a `sprintf`-style text formatter that is expanded at compile\n-time.\n+a name refers to a syntax extension, the names of all syntax extensions end\n+with `!`. The standard library defines a few syntax extensions, the most\n+useful of which is `fmt!`, a `sprintf`-style text formatter that an early\n+compiler phase expands statically.\n \n-`fmt!` supports most of the directives that [printf][pf] supports, but\n-will give you a compile-time error when the types of the directives\n+`fmt!` supports most of the directives that [printf][pf] supports, but unlike\n+printf, will give you a compile-time error when the types of the directives\n don't match the types of the arguments.\n \n ~~~~\n@@ -530,8 +537,9 @@ io::println(fmt!(\"what is this thing: %?\", mystery_object));\n \n [pf]: http://en.cppreference.com/w/cpp/io/c/fprintf\n \n-You can define your own syntax extensions with the macro system, which is out\n-of scope of this tutorial.\n+You can define your own syntax extensions with the macro system. For details, see the [macro tutorial][macros].\n+\n+[macros]: tutorial-macros.html\n \n # Control structures\n "}]}