{"sha": "5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlMjNmY2VjMGIwMTE4YWQzMmI3ZDU0NzBlZTQxZjE2NTg3ZTBlNzg=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2018-07-25T04:27:36Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2018-07-25T04:27:36Z"}, "message": "Merge branch 'master' into issue2894", "tree": {"sha": "a3957514ea5282d915e6fef485fcdc4e40d4c6cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3957514ea5282d915e6fef485fcdc4e40d4c6cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "html_url": "https://github.com/rust-lang/rust/commit/5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/comments", "author": null, "committer": null, "parents": [{"sha": "a05c9b63ce49923fba2709ab7e04be7077a01543", "url": "https://api.github.com/repos/rust-lang/rust/commits/a05c9b63ce49923fba2709ab7e04be7077a01543", "html_url": "https://github.com/rust-lang/rust/commit/a05c9b63ce49923fba2709ab7e04be7077a01543"}, {"sha": "b2caf669a8d2fd0bd121c1e898fb2e185a7fa30c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2caf669a8d2fd0bd121c1e898fb2e185a7fa30c", "html_url": "https://github.com/rust-lang/rust/commit/b2caf669a8d2fd0bd121c1e898fb2e185a7fa30c"}], "stats": {"total": 1660, "additions": 873, "deletions": 787}, "files": [{"sha": "c6bd67ae0f3df6ffed8283d7a9f74fa0236f3cbf", "filename": ".travis.yml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -48,8 +48,6 @@ matrix:\n     - env: INTEGRATION=serde-rs/serde\n     - env: INTEGRATION=Geal/nom\n     - env: INTEGRATION=hyperium/hyper\n-    - env: INTEGRATION=rust-lang/cargo\n-    - env: INTEGRATION=rust-lang-nursery/rls\n \n script:\n   - |"}, {"sha": "5c3af20bde87853bae89b434ff73c083dbd0cad0", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -21,8 +21,8 @@ edition = \"2018\"\n [dependencies]\n cargo_metadata = \"0.5\"\n itertools = \"0.7\"\n-lazy_static = \"1.0\"\n-matches = \"0.1.2\"\n+lazy_static = \"1.0.2\"\n+matches = \"0.1.7\"\n quine-mc_cluskey = \"0.2.2\"\n regex-syntax = \"0.6\"\n semver = \"0.9.0\"\n@@ -32,7 +32,7 @@ toml = \"0.4\"\n unicode-normalization = \"0.1\"\n pulldown-cmark = \"0.1\"\n url = \"1.7.0\"\n-if_chain = \"0.1\"\n+if_chain = \"0.1.3\"\n \n [features]\n debugging = []"}, {"sha": "cd2444ff31f0d458cba655975967b1180d7b2d89", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,6 +1,7 @@\n use crate::utils::span_lint;\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use std::f64::consts as f64;\n use syntax::ast::{FloatTy, Lit, LitKind};\n use syntax::symbol;\n@@ -69,7 +70,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn check_lit(cx: &LateContext, lit: &Lit, e: &Expr) {\n+fn check_lit(cx: &LateContext<'_, '_>, lit: &Lit, e: &Expr) {\n     match lit.node {\n         LitKind::Float(s, FloatTy::F32) => check_known_consts(cx, e, s, \"f32\"),\n         LitKind::Float(s, FloatTy::F64) => check_known_consts(cx, e, s, \"f64\"),\n@@ -78,7 +79,7 @@ fn check_lit(cx: &LateContext, lit: &Lit, e: &Expr) {\n     }\n }\n \n-fn check_known_consts(cx: &LateContext, e: &Expr, s: symbol::Symbol, module: &str) {\n+fn check_known_consts(cx: &LateContext<'_, '_>, e: &Expr, s: symbol::Symbol, module: &str) {\n     let s = s.as_str();\n     if s.parse::<f64>().is_ok() {\n         for &(constant, name, min_digits) in KNOWN_CONSTS {"}, {"sha": "b3d78d2d13f7951c3a9eb8138494b8c4dd9fd0f6", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,6 +1,7 @@\n use crate::utils::span_lint;\n use rustc::hir;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::codemap::Span;\n \n /// **What it does:** Checks for plain integer arithmetic."}, {"sha": "1ce690abcfe95d87dd2cd7a3fc1ed964097f0d2b", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -3,6 +3,8 @@ use crate::utils::{higher, sugg};\n use rustc::hir;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use syntax::ast;\n \n /// **What it does:** Checks for compound assignment operations (`+=` and\n@@ -49,8 +51,10 @@ declare_clippy_lint! {\n /// **Why is this bad?** Most likely these are bugs where one meant to write `a\n /// op= b`.\n ///\n-/// **Known problems:** Someone might actually mean `a op= a op b`, but that\n-/// should rather be written as `a = (2 * a) op b` where applicable.\n+/// **Known problems:** Clippy cannot know for sure if `a op= a op b` should have\n+/// been `a = a op a op b` or `a = a op b`/`a op= b`. Therefore it suggests both.\n+/// If `a op= a op b` is really the correct behaviour it should be\n+/// written as `a = a op a op b` as it's less confusing.\n ///\n /// **Example:**\n /// ```rust"}, {"sha": "3d25f524afd87fabcc9e37097b3d731c203d6cdb", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 41, "deletions": 21, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -7,6 +7,8 @@ use crate::utils::{\n };\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::{self, TyCtxt};\n use semver::Version;\n use syntax::ast::{AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n@@ -39,22 +41,31 @@ declare_clippy_lint! {\n }\n \n /// **What it does:** Checks for `extern crate` and `use` items annotated with\n-/// lint attributes\n+/// lint attributes.\n+///\n+/// This lint whitelists `#[allow(unused_imports)]` and `#[allow(deprecated)]` on\n+/// `use` items and `#[allow(unused_imports)]` on `extern crate` items with a\n+/// `#[macro_use]` attribute.\n ///\n /// **Why is this bad?** Lint attributes have no effect on crate imports. Most\n-/// likely a `!` was\n-/// forgotten\n+/// likely a `!` was forgotten.\n ///\n-/// **Known problems:** Technically one might allow `unused_import` on a `use`\n-/// item,\n-/// but it's easier to remove the unused item.\n+/// **Known problems:** None.\n ///\n /// **Example:**\n /// ```rust\n+/// // Bad\n /// #[deny(dead_code)]\n /// extern crate foo;\n-/// #[allow(unused_import)]\n+/// #[forbid(dead_code)]\n /// use foo::bar;\n+///\n+/// // Ok\n+/// #[allow(unused_imports)]\n+/// use foo::baz;\n+/// #[allow(unused_imports)]\n+/// #[macro_use]\n+/// extern crate baz;\n /// ```\n declare_clippy_lint! {\n     pub USELESS_ATTRIBUTE,\n@@ -154,17 +165,26 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n             check_attrs(cx, item.span, item.name, &item.attrs)\n         }\n         match item.node {\n-            ItemKind::ExternCrate(_) | ItemKind::Use(_, _) => {\n+            ItemKind::ExternCrate(..) | ItemKind::Use(..) => {\n+                let skip_unused_imports = item.attrs.iter().any(|attr| attr.name() == \"macro_use\");\n+\n                 for attr in &item.attrs {\n                     if let Some(ref lint_list) = attr.meta_item_list() {\n                         match &*attr.name().as_str() {\n                             \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n-                                // whitelist `unused_imports` and `deprecated`\n+                                // whitelist `unused_imports` and `deprecated` for `use` items\n+                                // and `unused_imports` for `extern crate` items with `macro_use`\n                                 for lint in lint_list {\n-                                    if is_word(lint, \"unused_imports\") || is_word(lint, \"deprecated\") {\n-                                        if let ItemKind::Use(_, _) = item.node {\n-                                            return;\n-                                        }\n+                                    match item.node {\n+                                        ItemKind::Use(..) => if is_word(lint, \"unused_imports\")\n+                                                                || is_word(lint, \"deprecated\") {\n+                                                return\n+                                        },\n+                                        ItemKind::ExternCrate(..) => if is_word(lint, \"unused_imports\")\n+                                                                        && skip_unused_imports {\n+                                                return\n+                                        },\n+                                        _ => {},\n                                     }\n                                 }\n                                 let line_span = last_line_of_span(cx, attr.span);\n@@ -206,22 +226,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n     }\n }\n \n-fn is_relevant_item(tcx: TyCtxt, item: &Item) -> bool {\n+fn is_relevant_item(tcx: TyCtxt<'_, '_, '_>, item: &Item) -> bool {\n     if let ItemKind::Fn(_, _, _, eid) = item.node {\n         is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir.body(eid).value)\n     } else {\n         true\n     }\n }\n \n-fn is_relevant_impl(tcx: TyCtxt, item: &ImplItem) -> bool {\n+fn is_relevant_impl(tcx: TyCtxt<'_, '_, '_>, item: &ImplItem) -> bool {\n     match item.node {\n         ImplItemKind::Method(_, eid) => is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir.body(eid).value),\n         _ => false,\n     }\n }\n \n-fn is_relevant_trait(tcx: TyCtxt, item: &TraitItem) -> bool {\n+fn is_relevant_trait(tcx: TyCtxt<'_, '_, '_>, item: &TraitItem) -> bool {\n     match item.node {\n         TraitItemKind::Method(_, TraitMethod::Required(_)) => true,\n         TraitItemKind::Method(_, TraitMethod::Provided(eid)) => {\n@@ -231,7 +251,7 @@ fn is_relevant_trait(tcx: TyCtxt, item: &TraitItem) -> bool {\n     }\n }\n \n-fn is_relevant_block(tcx: TyCtxt, tables: &ty::TypeckTables, block: &Block) -> bool {\n+fn is_relevant_block(tcx: TyCtxt<'_, '_, '_>, tables: &ty::TypeckTables<'_>, block: &Block) -> bool {\n     if let Some(stmt) = block.stmts.first() {\n         match stmt.node {\n             StmtKind::Decl(_, _) => true,\n@@ -242,7 +262,7 @@ fn is_relevant_block(tcx: TyCtxt, tables: &ty::TypeckTables, block: &Block) -> b\n     }\n }\n \n-fn is_relevant_expr(tcx: TyCtxt, tables: &ty::TypeckTables, expr: &Expr) -> bool {\n+fn is_relevant_expr(tcx: TyCtxt<'_, '_, '_>, tables: &ty::TypeckTables<'_>, expr: &Expr) -> bool {\n     match expr.node {\n         ExprKind::Block(ref block, _) => is_relevant_block(tcx, tables, block),\n         ExprKind::Ret(Some(ref e)) => is_relevant_expr(tcx, tables, e),\n@@ -260,7 +280,7 @@ fn is_relevant_expr(tcx: TyCtxt, tables: &ty::TypeckTables, expr: &Expr) -> bool\n     }\n }\n \n-fn check_attrs(cx: &LateContext, span: Span, name: Name, attrs: &[Attribute]) {\n+fn check_attrs(cx: &LateContext<'_, '_>, span: Span, name: Name, attrs: &[Attribute]) {\n     if in_macro(span) {\n         return;\n     }\n@@ -311,7 +331,7 @@ fn check_attrs(cx: &LateContext, span: Span, name: Name, attrs: &[Attribute]) {\n     }\n }\n \n-fn check_semver(cx: &LateContext, span: Span, lit: &Lit) {\n+fn check_semver(cx: &LateContext<'_, '_>, span: Span, lit: &Lit) {\n     if let LitKind::Str(ref is, _) = lit.node {\n         if Version::parse(&is.as_str()).is_ok() {\n             return;\n@@ -338,7 +358,7 @@ fn is_word(nmi: &NestedMetaItem, expected: &str) -> bool {\n // sources that the user has no control over.\n // For some reason these attributes don't have any expansion info on them, so\n // we have to check it this way until there is a better way.\n-fn is_present_in_source(cx: &LateContext, span: Span) -> bool {\n+fn is_present_in_source(cx: &LateContext<'_, '_>, span: Span) -> bool {\n     if let Some(snippet) = snippet_opt(cx, span) {\n         if snippet.is_empty() {\n             return false;"}, {"sha": "249ebbde2f79fcd1ffa8717fb77c4d88017ccbee", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,5 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use syntax::ast::LitKind;\n use syntax::codemap::Span;\n use crate::utils::{span_lint, span_lint_and_then};\n@@ -156,7 +158,7 @@ fn invert_cmp(cmp: BinOpKind) -> BinOpKind {\n }\n \n \n-fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOpKind, cmp_value: u128, span: Span) {\n+fn check_compare(cx: &LateContext<'_, '_>, bit_op: &Expr, cmp_op: BinOpKind, cmp_value: u128, span: Span) {\n     if let ExprKind::Binary(ref op, ref left, ref right) = bit_op.node {\n         if op.node != BinOpKind::BitAnd && op.node != BinOpKind::BitOr {\n             return;\n@@ -167,7 +169,7 @@ fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOpKind, cmp_value:\n     }\n }\n \n-fn check_bit_mask(cx: &LateContext, bit_op: BinOpKind, cmp_op: BinOpKind, mask_value: u128, cmp_value: u128, span: Span) {\n+fn check_bit_mask(cx: &LateContext<'_, '_>, bit_op: BinOpKind, cmp_op: BinOpKind, mask_value: u128, cmp_value: u128, span: Span) {\n     match cmp_op {\n         BinOpKind::Eq | BinOpKind::Ne => match bit_op {\n             BinOpKind::BitAnd => if mask_value & cmp_value != cmp_value {\n@@ -268,7 +270,7 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOpKind, cmp_op: BinOpKind, mask_v\n     }\n }\n \n-fn check_ineffective_lt(cx: &LateContext, span: Span, m: u128, c: u128, op: &str) {\n+fn check_ineffective_lt(cx: &LateContext<'_, '_>, span: Span, m: u128, c: u128, op: &str) {\n     if c.is_power_of_two() && m < c {\n         span_lint(\n             cx,\n@@ -284,7 +286,7 @@ fn check_ineffective_lt(cx: &LateContext, span: Span, m: u128, c: u128, op: &str\n     }\n }\n \n-fn check_ineffective_gt(cx: &LateContext, span: Span, m: u128, c: u128, op: &str) {\n+fn check_ineffective_gt(cx: &LateContext<'_, '_>, span: Span, m: u128, c: u128, op: &str) {\n     if (c + 1).is_power_of_two() && m <= c {\n         span_lint(\n             cx,\n@@ -300,7 +302,7 @@ fn check_ineffective_gt(cx: &LateContext, span: Span, m: u128, c: u128, op: &str\n     }\n }\n \n-fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u128> {\n+fn fetch_int_literal(cx: &LateContext<'_, '_>, lit: &Expr) -> Option<u128> {\n     match constant(cx, cx.tables, lit)?.0 {\n         Constant::Int(n) => Some(n),\n         _ => None,"}, {"sha": "cfec01d14aed98458942775c2272e9e0c38dceb0", "filename": "clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use crate::utils::span_lint;\n "}, {"sha": "f57a3571b579e7a99dde2f87eaf430ea9116178b", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,6 @@\n+use matches::matches;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use crate::utils::*;"}, {"sha": "f1596476bfda012b65063ec430aa1469c6d9caf0", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use rustc::hir::intravisit::*;\n use syntax::ast::{LitKind, NodeId, DUMMY_NODE_ID};\n@@ -274,7 +275,7 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n }\n \n // The boolean part of the return indicates whether some simplifications have been applied.\n-fn suggest(cx: &LateContext, suggestion: &Bool, terminals: &[&Expr]) -> (String, bool) {\n+fn suggest(cx: &LateContext<'_, '_>, suggestion: &Bool, terminals: &[&Expr]) -> (String, bool) {\n     let mut suggest_context = SuggestContext {\n         terminals,\n         cx,"}, {"sha": "2d4279d3cc19d0dccc0bcb908ed40c1f5846f30d", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,5 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty;\n use syntax::ast::{Name, UintTy};\n use crate::utils::{contains_name, get_pat_name, match_type, paths, single_segment_path, snippet, span_lint_and_sugg,\n@@ -36,7 +38,7 @@ impl LintPass for ByteCount {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr) {\n         if_chain! {\n             if let ExprKind::MethodCall(ref count, _, ref count_args) = expr.node;\n             if count.ident.name == \"count\";"}, {"sha": "2771006aad3b40652dae6e7f4bd8ae932e628661", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -13,6 +13,8 @@\n //! This lint is **warn** by default\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use syntax::ast;\n \n use crate::utils::{in_macro, snippet_block, span_lint_and_sugg, span_lint_and_then};\n@@ -78,14 +80,14 @@ impl LintPass for CollapsibleIf {\n }\n \n impl EarlyLintPass for CollapsibleIf {\n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &ast::Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n         if !in_macro(expr.span) {\n             check_if(cx, expr)\n         }\n     }\n }\n \n-fn check_if(cx: &EarlyContext, expr: &ast::Expr) {\n+fn check_if(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n     match expr.node {\n         ast::ExprKind::If(ref check, ref then, ref else_) => if let Some(ref else_) = *else_ {\n             check_collapsible_maybe_if_let(cx, else_);\n@@ -99,7 +101,7 @@ fn check_if(cx: &EarlyContext, expr: &ast::Expr) {\n     }\n }\n \n-fn check_collapsible_maybe_if_let(cx: &EarlyContext, else_: &ast::Expr) {\n+fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, else_: &ast::Expr) {\n     if_chain! {\n         if let ast::ExprKind::Block(ref block, _) = else_.node;\n         if let Some(else_) = expr_block(block);\n@@ -120,7 +122,7 @@ fn check_collapsible_maybe_if_let(cx: &EarlyContext, else_: &ast::Expr) {\n     }\n }\n \n-fn check_collapsible_no_if_let(cx: &EarlyContext, expr: &ast::Expr, check: &ast::Expr, then: &ast::Block) {\n+fn check_collapsible_no_if_let(cx: &EarlyContext<'_>, expr: &ast::Expr, check: &ast::Expr, then: &ast::Block) {\n     if_chain! {\n         if let Some(inner) = expr_block(then);\n         if let ast::ExprKind::If(ref check_inner, ref content, None) = inner.node;"}, {"sha": "1af0741d67fb193973465e0743ced0b7406be611", "filename": "clippy_lints/src/const_static_lifetime.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fconst_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fconst_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconst_static_lifetime.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,5 +1,6 @@\n use syntax::ast::*;\n use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n+use rustc::{declare_lint, lint_array};\n use crate::utils::{in_macro, snippet, span_lint_and_then};\n \n /// **What it does:** Checks for constants with an explicit `'static` lifetime.\n@@ -34,7 +35,7 @@ impl LintPass for StaticConst {\n \n impl StaticConst {\n     // Recursively visit types\n-    fn visit_type(&mut self, ty: &Ty, cx: &EarlyContext) {\n+    fn visit_type(&mut self, ty: &Ty, cx: &EarlyContext<'_>) {\n         match ty.node {\n             // Be careful of nested structures (arrays and tuples)\n             TyKind::Array(ref ty, _) => {\n@@ -78,7 +79,7 @@ impl StaticConst {\n }\n \n impl EarlyLintPass for StaticConst {\n-    fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n         if !in_macro(item.span) {\n             // Match only constants...\n             if let ItemKind::Const(ref var_type, _) = item.node {"}, {"sha": "84167553a54cd7d302c48f615e02cdc82791162e", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -2,6 +2,7 @@\n #![allow(float_cmp)]\n \n use rustc::lint::LateContext;\n+use rustc::{span_bug, bug};\n use rustc::hir::def::Def;\n use rustc::hir::*;\n use rustc::ty::{self, Ty, TyCtxt, Instance};\n@@ -122,7 +123,7 @@ impl Hash for Constant {\n }\n \n impl Constant {\n-    pub fn partial_cmp(tcx: TyCtxt, cmp_type: &ty::TypeVariants, left: &Self, right: &Self) -> Option<Ordering> {\n+    pub fn partial_cmp(tcx: TyCtxt<'_, '_, '_>, cmp_type: &ty::TypeVariants<'_>, left: &Self, right: &Self) -> Option<Ordering> {\n         match (left, right) {\n             (&Constant::Str(ref ls), &Constant::Str(ref rs)) => Some(ls.cmp(rs)),\n             (&Constant::Char(ref l), &Constant::Char(ref r)) => Some(l.cmp(r)),\n@@ -235,7 +236,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         }\n     }\n \n-    fn constant_not(&self, o: &Constant, ty: ty::Ty) -> Option<Constant> {\n+    fn constant_not(&self, o: &Constant, ty: ty::Ty<'_>) -> Option<Constant> {\n         use self::Constant::*;\n         match *o {\n             Bool(b) => Some(Bool(!b)),\n@@ -251,7 +252,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         }\n     }\n \n-    fn constant_negate(&self, o: &Constant, ty: ty::Ty) -> Option<Constant> {\n+    fn constant_negate(&self, o: &Constant, ty: ty::Ty<'_>) -> Option<Constant> {\n         use self::Constant::*;\n         match *o {\n             Int(value) => {"}, {"sha": "5709526c6007e2c5ae85d9a3ffd74c8ef0b9ca7d", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::ty::Ty;\n use rustc::hir::*;\n use std::collections::HashMap;\n@@ -133,7 +134,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyAndPaste {\n }\n \n /// Implementation of `IF_SAME_THEN_ELSE`.\n-fn lint_same_then_else(cx: &LateContext, blocks: &[&Block]) {\n+fn lint_same_then_else(cx: &LateContext<'_, '_>, blocks: &[&Block]) {\n     let eq: &dyn Fn(&&Block, &&Block) -> bool = &|&lhs, &rhs| -> bool { SpanlessEq::new(cx).eq_block(lhs, rhs) };\n \n     if let Some((i, j)) = search_same_sequenced(blocks, eq) {\n@@ -149,7 +150,7 @@ fn lint_same_then_else(cx: &LateContext, blocks: &[&Block]) {\n }\n \n /// Implementation of `IFS_SAME_COND`.\n-fn lint_same_cond(cx: &LateContext, conds: &[&Expr]) {\n+fn lint_same_cond(cx: &LateContext<'_, '_>, conds: &[&Expr]) {\n     let hash: &dyn Fn(&&Expr) -> u64 = &|expr| -> u64 {\n         let mut h = SpanlessHash::new(cx, cx.tables);\n         h.hash_expr(expr);\n@@ -171,7 +172,7 @@ fn lint_same_cond(cx: &LateContext, conds: &[&Expr]) {\n }\n \n /// Implementation of `MATCH_SAME_ARMS`.\n-fn lint_match_arms(cx: &LateContext, expr: &Expr) {\n+fn lint_match_arms(cx: &LateContext<'_, '_>, expr: &Expr) {\n     if let ExprKind::Match(_, ref arms, MatchSource::Normal) = expr.node {\n         let hash = |&(_, arm): &(usize, &Arm)| -> u64 {\n             let mut h = SpanlessHash::new(cx, cx.tables);"}, {"sha": "d66e6f2849bb694efee3567102051603c37e3afa", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -2,6 +2,7 @@\n \n use rustc::cfg::CFG;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use rustc::ty;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n@@ -186,7 +187,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CCHelper<'a, 'tcx> {\n \n #[cfg(feature = \"debugging\")]\n #[allow(too_many_arguments)]\n-fn report_cc_bug(_: &LateContext, cc: u64, narms: u64, div: u64, shorts: u64, returns: u64, span: Span, _: NodeId) {\n+fn report_cc_bug(_: &LateContext<'_, '_>, cc: u64, narms: u64, div: u64, shorts: u64, returns: u64, span: Span, _: NodeId) {\n     span_bug!(\n         span,\n         \"Clippy encountered a bug calculating cyclomatic complexity: cc = {}, arms = {}, \\\n@@ -200,7 +201,7 @@ fn report_cc_bug(_: &LateContext, cc: u64, narms: u64, div: u64, shorts: u64, re\n }\n #[cfg(not(feature = \"debugging\"))]\n #[allow(too_many_arguments)]\n-fn report_cc_bug(cx: &LateContext, cc: u64, narms: u64, div: u64, shorts: u64, returns: u64, span: Span, id: NodeId) {\n+fn report_cc_bug(cx: &LateContext<'_, '_>, cc: u64, narms: u64, div: u64, shorts: u64, returns: u64, span: Span, id: NodeId) {\n     if !is_allowed(cx, CYCLOMATIC_COMPLEXITY, id) {\n         cx.sess().span_note_without_error(\n             span,"}, {"sha": "4078237e8aa8453ac9f1d65907d5e8fe8f207a80", "filename": "clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,5 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::TypeVariants;\n \n use crate::utils::{any_parent_is_automatically_derived, match_def_path, opt_def_id, paths, span_lint_and_sugg};"}, {"sha": "0689ef25c20715c0fbb8179c05efb6a1070afe94", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::{self, Ty};\n use rustc::hir::*;\n use syntax::codemap::Span;"}, {"sha": "2b11e8fa77d4d6c399d7c92e1cfba61bf2d96234", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,6 +1,7 @@\n use itertools::Itertools;\n use pulldown_cmark;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast;\n use syntax::codemap::{BytePos, Span};\n use syntax_pos::Pos;\n@@ -51,11 +52,11 @@ impl LintPass for Doc {\n }\n \n impl EarlyLintPass for Doc {\n-    fn check_crate(&mut self, cx: &EarlyContext, krate: &ast::Crate) {\n+    fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &ast::Crate) {\n         check_attrs(cx, &self.valid_idents, &krate.attrs);\n     }\n \n-    fn check_item(&mut self, cx: &EarlyContext, item: &ast::Item) {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n         check_attrs(cx, &self.valid_idents, &item.attrs);\n     }\n }\n@@ -138,7 +139,7 @@ pub fn strip_doc_comment_decoration(comment: &str, span: Span) -> (String, Vec<(\n     panic!(\"not a doc-comment: {}\", comment);\n }\n \n-pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [ast::Attribute]) {\n+pub fn check_attrs<'a>(cx: &EarlyContext<'_>, valid_idents: &[String], attrs: &'a [ast::Attribute]) {\n     let mut doc = String::new();\n     let mut spans = vec![];\n \n@@ -185,7 +186,7 @@ pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [a\n }\n \n fn check_doc<'a, Events: Iterator<Item = (usize, pulldown_cmark::Event<'a>)>>(\n-    cx: &EarlyContext,\n+    cx: &EarlyContext<'_>,\n     valid_idents: &[String],\n     docs: Events,\n     spans: &[(usize, Span)],\n@@ -231,7 +232,7 @@ fn check_doc<'a, Events: Iterator<Item = (usize, pulldown_cmark::Event<'a>)>>(\n     }\n }\n \n-fn check_text(cx: &EarlyContext, valid_idents: &[String], text: &str, span: Span) {\n+fn check_text(cx: &EarlyContext<'_>, valid_idents: &[String], text: &str, span: Span) {\n     for word in text.split_whitespace() {\n         // Trim punctuation as in `some comment (see foo::bar).`\n         //                                                   ^^\n@@ -254,7 +255,7 @@ fn check_text(cx: &EarlyContext, valid_idents: &[String], text: &str, span: Span\n     }\n }\n \n-fn check_word(cx: &EarlyContext, word: &str, span: Span) {\n+fn check_word(cx: &EarlyContext<'_>, word: &str, span: Span) {\n     /// Checks if a string is camel-case, ie. contains at least two uppercase\n     /// letter (`Clippy` is\n     /// ok) and one lower-case letter (`NASA` is ok). Plural are also excluded"}, {"sha": "434ccb69921e7d916275350c8019706b3a076dcc", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -2,6 +2,7 @@\n \n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::codemap::Span;\n \n use crate::utils::{snippet, span_lint_and_sugg, SpanlessEq};"}, {"sha": "abd5666385d029dbc710eaffb8e3f092842b6710", "filename": "clippy_lints/src/double_parens.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fdouble_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fdouble_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_parens.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,5 +1,6 @@\n use syntax::ast::*;\n use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass};\n+use rustc::{declare_lint, lint_array};\n \n /// **What it does:** Checks for unnecessary double parentheses.\n ///\n@@ -30,7 +31,7 @@ impl LintPass for DoubleParens {\n }\n \n impl EarlyLintPass for DoubleParens {\n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n         match expr.node {\n             ExprKind::Paren(ref in_paren) => match in_paren.node {\n                 ExprKind::Paren(_) | ExprKind::Tup(_) => {"}, {"sha": "071afde986ad191b90ade8b1a5c4030d9652209e", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty;\n use rustc::hir::*;\n use crate::utils::{is_copy, match_def_path, opt_def_id, paths, span_note_and_lint};"}, {"sha": "517befa7790f9011a735076d6b8422fa839c2c0d", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,5 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use syntax::codemap::Spanned;\n \n use crate::consts::{constant, Constant};"}, {"sha": "39404bbafcca7cc53c608a6304da04ce3d70f8c1", "filename": "clippy_lints/src/else_if_without_else.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Felse_if_without_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Felse_if_without_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Felse_if_without_else.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,9 +1,10 @@\n //! lint on if expressions with an else if, but without a final else branch\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::*;\n \n-use crate::utils::{in_external_macro, span_lint_and_sugg};\n+use crate::utils::span_lint_and_sugg;\n \n /// **What it does:** Checks for usage of if expressions with an `else if` branch,\n /// but without a final `else` branch.\n@@ -48,8 +49,8 @@ impl LintPass for ElseIfWithoutElse {\n }\n \n impl EarlyLintPass for ElseIfWithoutElse {\n-    fn check_expr(&mut self, cx: &EarlyContext, mut item: &Expr) {\n-        if in_external_macro(cx, item.span) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, mut item: &Expr) {\n+        if in_external_macro(cx.sess(), item.span) {\n             return;\n         }\n "}, {"sha": "f95ae32d5611d87dfc9b24f8b0fe08f9a2a7b771", "filename": "clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fempty_enum.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,6 +1,7 @@\n //! lint when there is an enum with no variants\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use crate::utils::span_lint_and_then;\n \n@@ -32,7 +33,7 @@ impl LintPass for EmptyEnum {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EmptyEnum {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item) {\n         let did = cx.tcx.hir.local_def_id(item.id);\n         if let ItemKind::Enum(..) = item.node {\n             let ty = cx.tcx.type_of(did);"}, {"sha": "26ee6be5796ba1a4f3bc4916b414613c4faad732", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,6 +1,8 @@\n use rustc::hir::*;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use syntax::codemap::Span;\n use crate::utils::SpanlessEq;\n use crate::utils::{get_item_name, match_type, paths, snippet, span_lint_and_then, walk_ptrs_ty};"}, {"sha": "62cbead192907d9719f75defc0b99a07348adf1c", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -2,6 +2,7 @@\n //! don't fit into an `i32`\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use rustc::ty;\n use rustc::ty::subst::Substs;"}, {"sha": "6f8afc710de66173be773dc2099cb2c4e7692403", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -3,6 +3,7 @@\n use rustc::hir::*;\n use rustc::hir::def::Def;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n use crate::utils::span_lint;\n@@ -43,7 +44,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EnumGlobUse {\n }\n \n impl EnumGlobUse {\n-    fn lint_item(&self, cx: &LateContext, item: &Item) {\n+    fn lint_item(&self, cx: &LateContext<'_, '_>, item: &Item) {\n         if item.vis.node.is_pub() {\n             return; // re-exports are fine\n         }"}, {"sha": "16c9212e5db86b344402feeb36a9d5abd831ce31", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,6 +1,7 @@\n //! lint on enum variants that are prefixed or suffixed by the same characters\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::*;\n use syntax::codemap::Span;\n use syntax::symbol::LocalInternedString;\n@@ -148,7 +149,7 @@ fn partial_rmatch(post: &str, name: &str) -> usize {\n // FIXME: #600\n #[allow(while_let_on_iterator)]\n fn check_variant(\n-    cx: &EarlyContext,\n+    cx: &EarlyContext<'_>,\n     threshold: u64,\n     def: &EnumDef,\n     item_name: &str,\n@@ -239,12 +240,12 @@ fn to_camel_case(item_name: &str) -> String {\n }\n \n impl EarlyLintPass for EnumVariantNames {\n-    fn check_item_post(&mut self, _cx: &EarlyContext, _item: &Item) {\n+    fn check_item_post(&mut self, _cx: &EarlyContext<'_>, _item: &Item) {\n         let last = self.modules.pop();\n         assert!(last.is_some());\n     }\n \n-    fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n         let item_name = item.ident.as_str();\n         let item_name_chars = item_name.chars().count();\n         let item_camel = to_camel_case(&item_name);"}, {"sha": "dfbc3b126336eb136ed8f867bd4b2758921dad29", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,5 +1,6 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use crate::utils::{in_macro, implements_trait, is_copy, multispan_sugg, snippet, span_lint, span_lint_and_then, SpanlessEq};\n \n /// **What it does:** Checks for equal operands to comparison, logical and"}, {"sha": "4960a48b3c880c804e0f6a46dda160abebdf849b", "filename": "clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ferasing_op.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,6 +1,7 @@\n use crate::consts::{constant_simple, Constant};\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::codemap::Span;\n use crate::utils::{in_macro, span_lint};\n \n@@ -49,7 +50,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ErasingOp {\n     }\n }\n \n-fn check(cx: &LateContext, e: &Expr, span: Span) {\n+fn check(cx: &LateContext<'_, '_>, e: &Expr, span: Span) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, cx.tables, e) {\n         if v == 0 {\n             span_lint("}, {"sha": "ebbc2c34811b51e34c68697174733f7556da5c0b", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -2,6 +2,7 @@ use rustc::hir::*;\n use rustc::hir::intravisit as visit;\n use rustc::hir::map::Node::{NodeExpr, NodeStmt};\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::middle::expr_use_visitor::*;\n use rustc::middle::mem_categorization::{cmt_, Categorization};\n use rustc::ty::{self, Ty};\n@@ -38,7 +39,7 @@ declare_clippy_lint! {\n     \"using `Box<T>` where unnecessary\"\n }\n \n-fn is_non_trait_box(ty: Ty) -> bool {\n+fn is_non_trait_box(ty: Ty<'_>) -> bool {\n     ty.is_box() && !ty.boxed_ty().is_trait()\n }\n \n@@ -136,7 +137,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n             }\n         }\n     }\n-    fn borrow(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region, _: ty::BorrowKind, loan_cause: LoanCause) {\n+    fn borrow(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, _: ty::BorrowKind, loan_cause: LoanCause) {\n         if let Categorization::Local(lid) = cmt.cat {\n             match loan_cause {\n                 // x.foo()"}, {"sha": "2071628a6cfeef18ee4bba432f26ad9b85fa95d3", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::ty;\n use rustc::hir::*;\n use crate::utils::{is_adjusted, iter_input_pats, snippet_opt, span_lint_and_then};\n@@ -45,7 +46,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaPass {\n     }\n }\n \n-fn check_closure(cx: &LateContext, expr: &Expr) {\n+fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr) {\n     if let ExprKind::Closure(_, ref decl, eid, _, _) = expr.node {\n         let body = cx.tcx.hir.body(eid);\n         let ex = &body.value;"}, {"sha": "7ccf8c31569d864c3edfc3a1123a7ef1e917cab6", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -2,6 +2,8 @@ use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::hir::*;\n use rustc::ty;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use syntax::ast;\n use crate::utils::{get_parent_expr, span_lint, span_note_and_lint};\n \n@@ -173,7 +175,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n ///   logical operators are considered to have a defined evaluation order.\n ///\n /// When such a read is found, the lint is triggered.\n-fn check_for_unsequenced_reads(vis: &mut ReadVisitor) {\n+fn check_for_unsequenced_reads(vis: &mut ReadVisitor<'_, '_>) {\n     let map = &vis.cx.tcx.hir;\n     let mut cur_id = vis.write_expr.id;\n     loop {\n@@ -346,7 +348,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n }\n \n /// Returns true if `expr` is the LHS of an assignment, like `expr = ...`.\n-fn is_in_assignment_position(cx: &LateContext, expr: &Expr) -> bool {\n+fn is_in_assignment_position(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n         if let ExprKind::Assign(ref lhs, _) = parent.node {\n             return lhs.id == expr.id;"}, {"sha": "28819077f9bc68f99f6d51288355fa5865e7a114", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,5 +1,7 @@\n use rustc::hir;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::TypeVariants;\n use std::f32;\n use std::f64;"}, {"sha": "22e6834ee884358cb878eebf4d7b4bc257d2c94f", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,5 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use crate::utils::{is_expn_of, match_def_path, resolve_node, span_lint};\n use crate::utils::opt_def_id;\n "}, {"sha": "3db644911d78a75fd1dadb10c53de8ce3b2dd2b0", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir;\n use rustc::ty;\n use syntax_pos::Span;\n@@ -126,7 +128,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n     }\n }\n \n-fn match_type(tcx: ty::TyCtxt, ty: ty::Ty, path: &[&str]) -> bool {\n+fn match_type(tcx: ty::TyCtxt<'_, '_, '_>, ty: ty::Ty<'_>, path: &[&str]) -> bool {\n     match ty.sty {\n         ty::TyAdt(adt, _) => match_def_path(tcx, adt.did, path),\n         _ => false,"}, {"sha": "80fc4c3acfe48be0e728a702d180732b78bd85f7", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,5 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty;\n use syntax::ast::LitKind;\n use syntax_pos::Span;\n@@ -103,7 +105,7 @@ fn check_single_piece(expr: &Expr) -> bool {\n /// ```\n /// and that type of `__arg0` is `&str` or `String`\n /// then returns the span of first element of the matched tuple\n-fn get_single_string_arg(cx: &LateContext, expr: &Expr) -> Option<Span> {\n+fn get_single_string_arg(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<Span> {\n     if_chain! {\n         if let ExprKind::AddrOf(_, ref expr) = expr.node;\n         if let ExprKind::Match(ref match_expr, ref arms, _) = expr.node;"}, {"sha": "60001c792c0b41640ef5e0ededccf247cca773b6", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast;\n use crate::utils::{differing_macro_contexts, in_macro, snippet_opt, span_note_and_lint};\n use syntax::ptr::P;\n@@ -82,7 +83,7 @@ impl LintPass for Formatting {\n }\n \n impl EarlyLintPass for Formatting {\n-    fn check_block(&mut self, cx: &EarlyContext, block: &ast::Block) {\n+    fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n         for w in block.stmts.windows(2) {\n             match (&w[0].node, &w[1].node) {\n                 (&ast::StmtKind::Expr(ref first), &ast::StmtKind::Expr(ref second)) |\n@@ -94,15 +95,15 @@ impl EarlyLintPass for Formatting {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &ast::Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n         check_assign(cx, expr);\n         check_else_if(cx, expr);\n         check_array(cx, expr);\n     }\n }\n \n /// Implementation of the `SUSPICIOUS_ASSIGNMENT_FORMATTING` lint.\n-fn check_assign(cx: &EarlyContext, expr: &ast::Expr) {\n+fn check_assign(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n     if let ast::ExprKind::Assign(ref lhs, ref rhs) = expr.node {\n         if !differing_macro_contexts(lhs.span, rhs.span) && !in_macro(lhs.span) {\n             let eq_span = lhs.span.between(rhs.span);\n@@ -131,7 +132,7 @@ fn check_assign(cx: &EarlyContext, expr: &ast::Expr) {\n }\n \n /// Implementation of the `SUSPICIOUS_ELSE_FORMATTING` lint for weird `else if`.\n-fn check_else_if(cx: &EarlyContext, expr: &ast::Expr) {\n+fn check_else_if(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n     if let Some((then, &Some(ref else_))) = unsugar_if(expr) {\n         if unsugar_if(else_).is_some() && !differing_macro_contexts(then.span, else_.span) && !in_macro(then.span) {\n             // this will be a span from the closing \u2018}\u2019 of the \u201cthen\u201d block (excluding) to\n@@ -163,7 +164,7 @@ fn check_else_if(cx: &EarlyContext, expr: &ast::Expr) {\n }\n \n /// Implementation of the `POSSIBLE_MISSING_COMMA` lint for array\n-fn check_array(cx: &EarlyContext, expr: &ast::Expr) {\n+fn check_array(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n     if let ast::ExprKind::Array(ref array) = expr.node {\n         for element in array {\n             if let ast::ExprKind::Binary(ref op, ref lhs, _) = element.node {\n@@ -189,7 +190,7 @@ fn check_array(cx: &EarlyContext, expr: &ast::Expr) {\n }\n \n /// Implementation of the `SUSPICIOUS_ELSE_FORMATTING` lint for consecutive ifs.\n-fn check_consecutive_ifs(cx: &EarlyContext, first: &ast::Expr, second: &ast::Expr) {\n+fn check_consecutive_ifs(cx: &EarlyContext<'_>, first: &ast::Expr, second: &ast::Expr) {\n     if !differing_macro_contexts(first.span, second.span) && !in_macro(first.span) && unsugar_if(first).is_some()\n         && unsugar_if(second).is_some()\n     {"}, {"sha": "8903766c330b4636dfc488d446ce4856bcd3bb4f", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,6 +1,8 @@\n+use matches::matches;\n use rustc::hir::intravisit;\n use rustc::hir;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::ty;\n use rustc::hir::def::Def;\n use std::collections::HashSet;\n@@ -126,7 +128,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n }\n \n impl<'a, 'tcx> Functions {\n-    fn check_arg_number(self, cx: &LateContext, decl: &hir::FnDecl, span: Span) {\n+    fn check_arg_number(self, cx: &LateContext<'_, '_>, decl: &hir::FnDecl, span: Span) {\n         let args = decl.inputs.len() as u64;\n         if args > self.threshold {\n             span_lint("}, {"sha": "a0705f62544b6483155df66c46cfbddc6d132eea", "filename": "clippy_lints/src/identity_conversion.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_conversion.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use syntax::ast::NodeId;\n use crate::utils::{in_macro, match_def_path, match_trait_method, same_tys, snippet, span_lint_and_then};"}, {"sha": "23b34362171986d2b6ba43e1e432e6e357546841", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,6 +1,7 @@\n use crate::consts::{constant_simple, Constant};\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::codemap::Span;\n use crate::utils::{in_macro, snippet, span_lint, unsext, clip};\n use rustc::ty;\n@@ -59,7 +60,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n }\n \n #[allow(cast_possible_wrap)]\n-fn check(cx: &LateContext, e: &Expr, m: i8, span: Span, arg: Span) {\n+fn check(cx: &LateContext<'_, '_>, e: &Expr, m: i8, span: Span, arg: Span) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, cx.tables, e) {\n         let check = match cx.tables.expr_ty(e).sty {\n             ty::TyInt(ity) => unsext(cx.tcx, -1i128, ity),"}, {"sha": "bc97584a23d867cb80f928d1ab6506e0b07c6074", "filename": "clippy_lints/src/if_let_redundant_pattern_matching.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use crate::utils::{match_qpath, paths, snippet, span_lint_and_then};\n "}, {"sha": "fea3069f37d3a40e7a9810fcfebdfd9284c527d5", "filename": "clippy_lints/src/if_not_else.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fif_not_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fif_not_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_not_else.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -2,9 +2,10 @@\n //! on the condition\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::*;\n \n-use crate::utils::{in_external_macro, span_help_and_lint};\n+use crate::utils::span_help_and_lint;\n \n /// **What it does:** Checks for usage of `!` or `!=` in an if condition with an\n /// else branch.\n@@ -46,8 +47,8 @@ impl LintPass for IfNotElse {\n }\n \n impl EarlyLintPass for IfNotElse {\n-    fn check_expr(&mut self, cx: &EarlyContext, item: &Expr) {\n-        if in_external_macro(cx, item.span) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, item: &Expr) {\n+        if in_external_macro(cx.sess(), item.span) {\n             return;\n         }\n         if let ExprKind::If(ref cond, _, Some(ref els)) = item.node {"}, {"sha": "677f59d32cc5a70170821d490d4be95f498c2707", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -6,6 +6,7 @@ use crate::utils::higher;\n use crate::utils::higher::Range;\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::ty;\n use syntax::ast::RangeLimits;\n \n@@ -154,7 +155,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n /// the range.\n fn to_const_range<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    range: Range,\n+    range: Range<'_>,\n     array_size: u128,\n ) -> Option<(u128, u128)> {\n     let s = range"}, {"sha": "8b8cb32deb1afedcb8aeca0e7bf4eb2831aeb24c", "filename": "clippy_lints/src/infallible_destructuring_match.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,6 +1,8 @@\n use super::utils::{get_arg_name, match_var, remove_blocks, snippet, span_lint_and_sugg};\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n \n /// **What it does:** Checks for matches being used to destructure a single-variant enum\n /// or tuple struct where a `let` will suffice."}, {"sha": "eaa93cb62f8789f0b0209fbd311a198f8fb3fd5b", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,5 +1,6 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use crate::utils::{get_trait_def_id, higher, implements_trait, match_qpath, paths, span_lint};\n \n /// **What it does:** Checks for iteration that is guaranteed to be infinite.\n@@ -139,7 +140,7 @@ static HEURISTICS: &[(&str, usize, Heuristic, Finiteness)] = &[\n     (\"scan\", 3, First, MaybeInfinite),\n ];\n \n-fn is_infinite(cx: &LateContext, expr: &Expr) -> Finiteness {\n+fn is_infinite(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n     match expr.node {\n         ExprKind::MethodCall(ref method, _, ref args) => {\n             for &(name, len, heuristic, cap) in HEURISTICS.iter() {\n@@ -203,7 +204,7 @@ static COMPLETING_METHODS: &[(&str, usize)] = &[\n     (\"product\", 1),\n ];\n \n-fn complete_infinite_iter(cx: &LateContext, expr: &Expr) -> Finiteness {\n+fn complete_infinite_iter(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n     match expr.node {\n         ExprKind::MethodCall(ref method, _, ref args) => {\n             for &(name, len) in COMPLETING_METHODS.iter() {"}, {"sha": "fc06af81574e2de5add72571d07c5498ee2efbf6", "filename": "clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_impl.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -2,6 +2,7 @@\n \n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use std::collections::HashMap;\n use std::default::Default;\n use syntax_pos::Span;"}, {"sha": "70f88a76f45042adc32371566e70f1b215f26578", "filename": "clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,6 +1,7 @@\n //! checks for `#[inline]` on trait methods without bodies\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use syntax::ast::{Attribute, Name};\n use crate::utils::span_lint_and_then;\n@@ -43,7 +44,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn check_attrs(cx: &LateContext, name: Name, attrs: &[Attribute]) {\n+fn check_attrs(cx: &LateContext<'_, '_>, name: Name, attrs: &[Attribute]) {\n     for attr in attrs {\n         if attr.name() != \"inline\" {\n             continue;"}, {"sha": "9b6fc579a31ce8b1085d239ff20580711e43b358", "filename": "clippy_lints/src/int_plus_one.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fint_plus_one.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,6 +1,7 @@\n //! lint on blocks unnecessarily using >= with a + 1 or - 1\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::*;\n \n use crate::utils::{snippet_opt, span_lint_and_then};\n@@ -60,7 +61,7 @@ impl IntPlusOne {\n         false\n     }\n \n-    fn check_binop(&self, cx: &EarlyContext, binop: BinOpKind, lhs: &Expr, rhs: &Expr) -> Option<String> {\n+    fn check_binop(&self, cx: &EarlyContext<'_>, binop: BinOpKind, lhs: &Expr, rhs: &Expr) -> Option<String> {\n         match (binop, &lhs.node, &rhs.node) {\n             // case where `x - 1 >= ...` or `-1 + x >= ...`\n             (BinOpKind::Ge, &ExprKind::Binary(ref lhskind, ref lhslhs, ref lhsrhs), _) => {\n@@ -126,7 +127,7 @@ impl IntPlusOne {\n \n     fn generate_recommendation(\n         &self,\n-        cx: &EarlyContext,\n+        cx: &EarlyContext<'_>,\n         binop: BinOpKind,\n         node: &Expr,\n         other_side: &Expr,\n@@ -149,15 +150,15 @@ impl IntPlusOne {\n         None\n     }\n \n-    fn emit_warning(&self, cx: &EarlyContext, block: &Expr, recommendation: String) {\n+    fn emit_warning(&self, cx: &EarlyContext<'_>, block: &Expr, recommendation: String) {\n         span_lint_and_then(cx, INT_PLUS_ONE, block.span, \"Unnecessary `>= y + 1` or `x - 1 >=`\", |db| {\n             db.span_suggestion(block.span, \"change `>= y + 1` to `> y` as shown\", recommendation);\n         });\n     }\n }\n \n impl EarlyLintPass for IntPlusOne {\n-    fn check_expr(&mut self, cx: &EarlyContext, item: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, item: &Expr) {\n         if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = item.node {\n             if let Some(ref rec) = self.check_binop(cx, kind.node, lhs, rhs) {\n                 self.emit_warning(cx, item, rec.clone());"}, {"sha": "b529cb3ac3813f231c7c18272d93db90621d75f0", "filename": "clippy_lints/src/invalid_ref.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Finvalid_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Finvalid_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finvalid_ref.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty;\n use rustc::hir::*;\n use crate::utils::{match_def_path, opt_def_id, paths, span_help_and_lint};"}, {"sha": "07ef086d694c77603c4af9dfccc817216bf96ee1", "filename": "clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,6 +1,8 @@\n //! lint when items are used after statements\n \n+use matches::matches;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::*;\n use crate::utils::{in_macro, span_lint};\n \n@@ -41,7 +43,7 @@ impl LintPass for ItemsAfterStatements {\n }\n \n impl EarlyLintPass for ItemsAfterStatements {\n-    fn check_block(&mut self, cx: &EarlyContext, item: &Block) {\n+    fn check_block(&mut self, cx: &EarlyContext<'_>, item: &Block) {\n         if in_macro(item.span) {\n             return;\n         }"}, {"sha": "2c03b6b5f682c2ed766d65d849aa2e52bc44f85d", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,6 +1,7 @@\n //! lint when there is a large size difference between variants on an enum\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use crate::utils::{snippet_opt, span_lint_and_then};\n use rustc::ty::layout::LayoutOf;\n@@ -47,7 +48,7 @@ impl LintPass for LargeEnumVariant {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item) {\n         let did = cx.tcx.hir.local_def_id(item.id);\n         if let ItemKind::Enum(ref def, _) = item.node {\n             let ty = cx.tcx.type_of(did);"}, {"sha": "b73f912fad5ec69e56c1f5f13aca018876e53116", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,6 +1,7 @@\n use rustc::hir::def_id::DefId;\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::ty;\n use std::collections::HashSet;\n use syntax::ast::{Lit, LitKind, Name};\n@@ -105,8 +106,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n     }\n }\n \n-fn check_trait_items(cx: &LateContext, visited_trait: &Item, trait_items: &[TraitItemRef]) {\n-    fn is_named_self(cx: &LateContext, item: &TraitItemRef, name: &str) -> bool {\n+fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item, trait_items: &[TraitItemRef]) {\n+    fn is_named_self(cx: &LateContext<'_, '_>, item: &TraitItemRef, name: &str) -> bool {\n         item.ident.name == name && if let AssociatedItemKind::Method { has_self } = item.kind {\n             has_self && {\n                 let did = cx.tcx.hir.local_def_id(item.id.node_id);\n@@ -118,7 +119,7 @@ fn check_trait_items(cx: &LateContext, visited_trait: &Item, trait_items: &[Trai\n     }\n \n     // fill the set with current and super traits\n-    fn fill_trait_set(traitt: DefId, set: &mut HashSet<DefId>, cx: &LateContext) {\n+    fn fill_trait_set(traitt: DefId, set: &mut HashSet<DefId>, cx: &LateContext<'_, '_>) {\n         if set.insert(traitt) {\n             for supertrait in ::rustc::traits::supertrait_def_ids(cx.tcx, traitt) {\n                 fill_trait_set(supertrait, set, cx);\n@@ -153,8 +154,8 @@ fn check_trait_items(cx: &LateContext, visited_trait: &Item, trait_items: &[Trai\n     }\n }\n \n-fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n-    fn is_named_self(cx: &LateContext, item: &ImplItemRef, name: &str) -> bool {\n+fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item, impl_items: &[ImplItemRef]) {\n+    fn is_named_self(cx: &LateContext<'_, '_>, item: &ImplItemRef, name: &str) -> bool {\n         item.ident.name == name && if let AssociatedItemKind::Method { has_self } = item.kind {\n             has_self && {\n                 let did = cx.tcx.hir.local_def_id(item.id.node_id);\n@@ -193,7 +194,7 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n     }\n }\n \n-fn check_cmp(cx: &LateContext, span: Span, method: &Expr, lit: &Expr, op: &str, compare_to: u32) {\n+fn check_cmp(cx: &LateContext<'_, '_>, span: Span, method: &Expr, lit: &Expr, op: &str, compare_to: u32) {\n     if let (&ExprKind::MethodCall(ref method_path, _, ref args), &ExprKind::Lit(ref lit)) = (&method.node, &lit.node) {\n         // check if we are in an is_empty() method\n         if let Some(name) = get_item_name(cx, method) {\n@@ -206,7 +207,7 @@ fn check_cmp(cx: &LateContext, span: Span, method: &Expr, lit: &Expr, op: &str,\n     }\n }\n \n-fn check_len(cx: &LateContext, span: Span, method_name: Name, args: &[Expr], lit: &Lit, op: &str, compare_to: u32) {\n+fn check_len(cx: &LateContext<'_, '_>, span: Span, method_name: Name, args: &[Expr], lit: &Lit, op: &str, compare_to: u32) {\n     if let Spanned {\n         node: LitKind::Int(lit, _),\n         ..\n@@ -231,9 +232,9 @@ fn check_len(cx: &LateContext, span: Span, method_name: Name, args: &[Expr], lit\n }\n \n /// Check if this type has an `is_empty` method.\n-fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n+fn has_is_empty(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     /// Get an `AssociatedItem` and return true if it matches `is_empty(self)`.\n-    fn is_is_empty(cx: &LateContext, item: &ty::AssociatedItem) -> bool {\n+    fn is_is_empty(cx: &LateContext<'_, '_>, item: &ty::AssociatedItem) -> bool {\n         if let ty::AssociatedKind::Method = item.kind {\n             if item.ident.name == \"is_empty\" {\n                 let sig = cx.tcx.fn_sig(item.def_id);\n@@ -248,7 +249,7 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n     }\n \n     /// Check the inherent impl's items for an `is_empty(self)` method.\n-    fn has_is_empty_impl(cx: &LateContext, id: DefId) -> bool {\n+    fn has_is_empty_impl(cx: &LateContext<'_, '_>, id: DefId) -> bool {\n         cx.tcx.inherent_impls(id).iter().any(|imp| {\n             cx.tcx\n                 .associated_items(*imp)"}, {"sha": "57ca5eff95530b8646dc5dd14ac2f0214c9376e4", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir;\n use rustc::hir::BindingAnnotation;\n use rustc::hir::def::Def;"}, {"sha": "b08449d2bebf30ee1d4e6b81189694139cdcd8be", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -14,54 +14,41 @@\n #![feature(rust_2018_preview)]\n #![warn(rust_2018_idioms)]\n \n-#[macro_use]\n-extern crate rustc;\n-\n use toml;\n use rustc_plugin;\n+use rustc;\n \n-#[macro_use]\n-extern crate matches as matches_macro;\n-\n-#[macro_use]\n-extern crate serde_derive;\n-\n-#[macro_use]\n-extern crate lazy_static;\n-\n-#[macro_use]\n-extern crate if_chain;\n \n macro_rules! declare_clippy_lint {\n     { pub $name:tt, style, $description:tt } => {\n-        declare_lint! { pub $name, Warn, $description }\n+        declare_lint! { pub $name, Warn, $description, report_in_external_macro: true }\n     };\n     { pub $name:tt, correctness, $description:tt } => {\n-        declare_lint! { pub $name, Deny, $description }\n+        declare_lint! { pub $name, Deny, $description, report_in_external_macro: true }\n     };\n     { pub $name:tt, complexity, $description:tt } => {\n-        declare_lint! { pub $name, Warn, $description }\n+        declare_lint! { pub $name, Warn, $description, report_in_external_macro: true }\n     };\n     { pub $name:tt, perf, $description:tt } => {\n-        declare_lint! { pub $name, Warn, $description }\n+        declare_lint! { pub $name, Warn, $description, report_in_external_macro: true }\n     };\n     { pub $name:tt, pedantic, $description:tt } => {\n-        declare_lint! { pub $name, Allow, $description }\n+        declare_lint! { pub $name, Allow, $description, report_in_external_macro: true }\n     };\n     { pub $name:tt, restriction, $description:tt } => {\n-        declare_lint! { pub $name, Allow, $description }\n+        declare_lint! { pub $name, Allow, $description, report_in_external_macro: true }\n     };\n     { pub $name:tt, cargo, $description:tt } => {\n-        declare_lint! { pub $name, Allow, $description }\n+        declare_lint! { pub $name, Allow, $description, report_in_external_macro: true }\n     };\n     { pub $name:tt, nursery, $description:tt } => {\n-        declare_lint! { pub $name, Allow, $description }\n+        declare_lint! { pub $name, Allow, $description, report_in_external_macro: true }\n     };\n     { pub $name:tt, internal, $description:tt } => {\n-        declare_lint! { pub $name, Allow, $description }\n+        declare_lint! { pub $name, Allow, $description, report_in_external_macro: true }\n     };\n     { pub $name:tt, internal_warn, $description:tt } => {\n-        declare_lint! { pub $name, Warn, $description }\n+        declare_lint! { pub $name, Warn, $description, report_in_external_macro: true }\n     };\n }\n \n@@ -189,8 +176,12 @@ mod reexport {\n     crate use syntax::ast::{Name, NodeId};\n }\n \n+pub fn register_pre_expansion_lints(session: &rustc::session::Session, store: &mut rustc::lint::LintStore) {\n+    store.register_pre_expansion_pass(Some(session), box write::Pass);\n+}\n+\n #[cfg_attr(rustfmt, rustfmt_skip)]\n-pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n+pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>) {\n     let conf = match utils::conf::file_from_args(reg.args()) {\n         Ok(file_name) => {\n             // if the user specified a file, it must exist, otherwise default to `clippy.toml` but\n@@ -334,7 +325,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box strings::StringLitAsBytes);\n     reg.register_late_lint_pass(box derive::Derive);\n     reg.register_late_lint_pass(box types::CharLitAsU8);\n-    reg.register_late_lint_pass(box write::Pass);\n     reg.register_late_lint_pass(box vec::Pass);\n     reg.register_early_lint_pass(box non_expressive_names::NonExpressiveNames {\n         single_char_binding_names_threshold: conf.single_char_binding_names_threshold,"}, {"sha": "cf7a016231e347f41dfb829918e2d93b405bec9d", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,11 +1,13 @@\n use crate::reexport::*;\n+use matches::matches;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::def::Def;\n use rustc::hir::*;\n use rustc::hir::intravisit::*;\n use std::collections::{HashMap, HashSet};\n use syntax::codemap::Span;\n-use crate::utils::{in_external_macro, last_path_segment, span_lint};\n+use crate::utils::{last_path_segment, span_lint};\n use syntax::symbol::keywords;\n \n /// **What it does:** Checks for lifetime annotations which can be removed by\n@@ -96,7 +98,7 @@ fn check_fn_inner<'a, 'tcx>(\n     generics: &'tcx Generics,\n     span: Span,\n ) {\n-    if in_external_macro(cx, span) || has_where_lifetimes(cx, &generics.where_clause) {\n+    if in_external_macro(cx.sess(), span) || has_where_lifetimes(cx, &generics.where_clause) {\n         return;\n     }\n "}, {"sha": "45f9af49a15fe279cadc8d8211be17272c46ff3e", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -2,9 +2,11 @@\n //! floating-point literal expressions.\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use syntax::ast::*;\n use syntax_pos;\n-use crate::utils::{in_external_macro, snippet_opt, span_lint_and_sugg};\n+use crate::utils::{snippet_opt, span_lint_and_sugg};\n \n /// **What it does:** Warns if a long integral or floating-point constant does\n /// not contain underscores.\n@@ -227,7 +229,7 @@ enum WarningType {\n }\n \n impl WarningType {\n-    crate fn display(&self, grouping_hint: &str, cx: &EarlyContext, span: syntax_pos::Span) {\n+    crate fn display(&self, grouping_hint: &str, cx: &EarlyContext<'_>, span: syntax_pos::Span) {\n         match self {\n             WarningType::UnreadableLiteral => span_lint_and_sugg(\n                 cx,\n@@ -279,8 +281,8 @@ impl LintPass for LiteralDigitGrouping {\n }\n \n impl EarlyLintPass for LiteralDigitGrouping {\n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n-        if in_external_macro(cx, expr.span) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n+        if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n \n@@ -291,7 +293,7 @@ impl EarlyLintPass for LiteralDigitGrouping {\n }\n \n impl LiteralDigitGrouping {\n-    fn check_lit(self, cx: &EarlyContext, lit: &Lit) {\n+    fn check_lit(self, cx: &EarlyContext<'_>, lit: &Lit) {\n         match lit.node {\n             LitKind::Int(..) => {\n                 // Lint integral literals.\n@@ -419,8 +421,8 @@ impl LintPass for LiteralRepresentation {\n }\n \n impl EarlyLintPass for LiteralRepresentation {\n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n-        if in_external_macro(cx, expr.span) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n+        if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n \n@@ -436,7 +438,7 @@ impl LiteralRepresentation {\n             threshold,\n         }\n     }\n-    fn check_lit(self, cx: &EarlyContext, lit: &Lit) {\n+    fn check_lit(self, cx: &EarlyContext<'_>, lit: &Lit) {\n         // Lint integral literals.\n         if_chain! {\n             if let LitKind::Int(..) = lit.node;"}, {"sha": "b95bc01c013daf356a5fe00633f49108656533b9", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -6,6 +6,8 @@ use rustc::hir::def_id;\n use rustc::hir::intravisit::{walk_block, walk_decl, walk_expr, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n use rustc::hir::map::Node::{NodeBlock, NodeExpr, NodeStmt};\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::middle::region;\n // use rustc::middle::region::CodeExtent;\n use rustc::middle::expr_use_visitor::*;\n@@ -21,7 +23,7 @@ use crate::utils::{sugg, sext};\n use crate::utils::usage::mutated_variables;\n use crate::consts::{constant, Constant};\n \n-use crate::utils::{get_enclosing_block, get_parent_expr, higher, in_external_macro, is_integer_literal, is_refutable,\n+use crate::utils::{get_enclosing_block, get_parent_expr, higher, is_integer_literal, is_refutable,\n             last_path_segment, match_trait_method, match_type, match_var, multispan_sugg, snippet, snippet_opt,\n             span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, SpanlessEq};\n use crate::utils::paths;\n@@ -448,7 +450,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                 && arms[1].pats.len() == 1 && arms[1].guard.is_none()\n                                 && is_simple_break_expr(&arms[1].body)\n                             {\n-                                if in_external_macro(cx, expr.span) {\n+                                if in_external_macro(cx.sess(), expr.span) {\n                                     return;\n                                 }\n \n@@ -741,7 +743,7 @@ struct FixedOffsetVar {\n     offset: Offset,\n }\n \n-fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty) -> bool {\n+fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'_>) -> bool {\n     let is_slice = match ty.sty {\n         ty::TyRef(_, subty, _) => is_slice_like(cx, subty),\n         ty::TySlice(..) | ty::TyArray(..) => true,\n@@ -1183,7 +1185,7 @@ fn check_for_loop_reverse_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arg: &'tcx\n     }\n }\n \n-fn lint_iter_method(cx: &LateContext, args: &[Expr], arg: &Expr, method_name: &str) {\n+fn lint_iter_method(cx: &LateContext<'_, '_>, args: &[Expr], arg: &Expr, method_name: &str) {\n     let object = snippet(cx, args[0].span, \"_\");\n     let muta = if method_name == \"iter_mut\" {\n         \"mut \"\n@@ -1201,7 +1203,7 @@ fn lint_iter_method(cx: &LateContext, args: &[Expr], arg: &Expr, method_name: &s\n     )\n }\n \n-fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n+fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr, expr: &Expr) {\n     let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n     if let ExprKind::MethodCall(ref method, _, ref args) = arg.node {\n         // just the receiver, no arguments\n@@ -1256,7 +1258,7 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n }\n \n /// Check for `for` loops over `Option`s and `Results`\n-fn check_arg_type(cx: &LateContext, pat: &Pat, arg: &Expr) {\n+fn check_arg_type(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr) {\n     let ty = cx.tables.expr_ty(arg);\n     if match_type(cx, ty, &paths::OPTION) {\n         span_help_and_lint(\n@@ -1418,7 +1420,7 @@ impl<'tcx> Delegate<'tcx> for MutatePairDelegate {\n \n     fn consume_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: ConsumeMode) {}\n \n-    fn borrow(&mut self, _: NodeId, sp: Span, cmt: &cmt_<'tcx>, _: ty::Region, bk: ty::BorrowKind, _: LoanCause) {\n+    fn borrow(&mut self, _: NodeId, sp: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, bk: ty::BorrowKind, _: LoanCause) {\n         if let ty::BorrowKind::MutBorrow = bk {\n             if let Categorization::Local(id) = cmt.cat {\n                 if Some(id) == self.node_id_low {\n@@ -1451,7 +1453,7 @@ impl<'tcx> MutatePairDelegate {\n     }\n }\n \n-fn check_for_mut_range_bound(cx: &LateContext, arg: &Expr, body: &Expr) {\n+fn check_for_mut_range_bound(cx: &LateContext<'_, '_>, arg: &Expr, body: &Expr) {\n     if let Some(higher::Range {\n         start: Some(start),\n         end: Some(end),\n@@ -1470,7 +1472,7 @@ fn check_for_mut_range_bound(cx: &LateContext, arg: &Expr, body: &Expr) {\n     }\n }\n \n-fn mut_warn_with_span(cx: &LateContext, span: Option<Span>) {\n+fn mut_warn_with_span(cx: &LateContext<'_, '_>, span: Option<Span>) {\n     if let Some(sp) = span {\n         span_lint(\n             cx,\n@@ -1481,7 +1483,7 @@ fn mut_warn_with_span(cx: &LateContext, span: Option<Span>) {\n     }\n }\n \n-fn check_for_mutability(cx: &LateContext, bound: &Expr) -> Option<NodeId> {\n+fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr) -> Option<NodeId> {\n     if_chain! {\n         if let ExprKind::Path(ref qpath) = bound.node;\n         if let QPath::Resolved(None, _) = *qpath;\n@@ -1503,7 +1505,7 @@ fn check_for_mutability(cx: &LateContext, bound: &Expr) -> Option<NodeId> {\n     None\n }\n \n-fn check_for_mutation(cx: &LateContext, body: &Expr, bound_ids: &[Option<NodeId>]) -> (Option<Span>, Option<Span>) {\n+fn check_for_mutation(cx: &LateContext<'_, '_>, body: &Expr, bound_ids: &[Option<NodeId>]) -> (Option<Span>, Option<Span>) {\n     let mut delegate = MutatePairDelegate {\n         node_id_low: bound_ids[0],\n         node_id_high: bound_ids[1],\n@@ -1780,7 +1782,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor<'a, 'tcx> {\n /// Return true if the type of expr is one that provides `IntoIterator` impls\n /// for `&T` and `&mut T`, such as `Vec`.\n #[cfg_attr(rustfmt, rustfmt_skip)]\n-fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {\n+fn is_ref_iterable_type(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n     // no walk_ptrs_ty: calling iter() on a reference can make sense because it\n     // will allow further borrows afterwards\n     let ty = cx.tables.expr_ty(e);\n@@ -1795,7 +1797,7 @@ fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {\n     match_type(cx, ty, &paths::BTREESET)\n }\n \n-fn is_iterable_array(ty: Ty, cx: &LateContext) -> bool {\n+fn is_iterable_array(ty: Ty<'_>, cx: &LateContext<'_, '_>) -> bool {\n     // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n     match ty.sty {\n         ty::TyArray(_, n) => (0..=32).contains(&n.assert_usize(cx.tcx).expect(\"array length\")),\n@@ -2004,7 +2006,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n     }\n }\n \n-fn var_def_id(cx: &LateContext, expr: &Expr) -> Option<NodeId> {\n+fn var_def_id(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<NodeId> {\n     if let ExprKind::Path(ref qpath) = expr.node {\n         let path_res = cx.tables.qpath_def(qpath, expr.hir_id);\n         if let Def::Local(node_id) = path_res {\n@@ -2028,7 +2030,7 @@ fn is_conditional(expr: &Expr) -> bool {\n     }\n }\n \n-fn is_nested(cx: &LateContext, match_expr: &Expr, iter_expr: &Expr) -> bool {\n+fn is_nested(cx: &LateContext<'_, '_>, match_expr: &Expr, iter_expr: &Expr) -> bool {\n     if_chain! {\n         if let Some(loop_block) = get_enclosing_block(cx, match_expr.id);\n         if let Some(map::Node::NodeExpr(loop_expr)) = cx.tcx.hir.find(cx.tcx.hir.get_parent_node(loop_block.id));\n@@ -2039,7 +2041,7 @@ fn is_nested(cx: &LateContext, match_expr: &Expr, iter_expr: &Expr) -> bool {\n     false\n }\n \n-fn is_loop_nested(cx: &LateContext, loop_expr: &Expr, iter_expr: &Expr) -> bool {\n+fn is_loop_nested(cx: &LateContext<'_, '_>, loop_expr: &Expr, iter_expr: &Expr) -> bool {\n     let mut id = loop_expr.id;\n     let iter_name = if let Some(name) = path_name(iter_expr) {\n         name"}, {"sha": "d8b14db605f291c240626e8b10dd6537ddc7ca49", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::ty;\n use syntax::ast;\n@@ -98,7 +100,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn expr_eq_name(cx: &LateContext, expr: &Expr, id: ast::Ident) -> bool {\n+fn expr_eq_name(cx: &LateContext<'_, '_>, expr: &Expr, id: ast::Ident) -> bool {\n     match expr.node {\n         ExprKind::Path(QPath::Resolved(None, ref path)) => {\n             let arg_segment = [\n@@ -114,7 +116,7 @@ fn expr_eq_name(cx: &LateContext, expr: &Expr, id: ast::Ident) -> bool {\n     }\n }\n \n-fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static str> {\n+fn get_type_name(cx: &LateContext<'_, '_>, expr: &Expr, arg: &Expr) -> Option<&'static str> {\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         Some(\"iterator\")\n     } else if match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(arg)), &paths::OPTION) {\n@@ -124,7 +126,7 @@ fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static s\n     }\n }\n \n-fn only_derefs(cx: &LateContext, expr: &Expr, id: ast::Ident) -> bool {\n+fn only_derefs(cx: &LateContext<'_, '_>, expr: &Expr, id: ast::Ident) -> bool {\n     match expr.node {\n         ExprKind::Unary(UnDeref, ref subexpr) if !is_adjusted(cx, subexpr) => only_derefs(cx, subexpr, id),\n         _ => expr_eq_name(cx, expr, id),"}, {"sha": "6ccf8daa71d64cbe7dc45b1f6463e2a37e080032", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,5 +1,7 @@\n use rustc::hir;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty;\n use rustc_errors::Applicability;\n use syntax::codemap::Span;\n@@ -82,15 +84,15 @@ impl LintPass for Pass {\n     }\n }\n \n-fn is_unit_type(ty: ty::Ty) -> bool {\n+fn is_unit_type(ty: ty::Ty<'_>) -> bool {\n     match ty.sty {\n         ty::TyTuple(slice) => slice.is_empty(),\n         ty::TyNever => true,\n         _ => false,\n     }\n }\n \n-fn is_unit_function(cx: &LateContext, expr: &hir::Expr) -> bool {\n+fn is_unit_function(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> bool {\n     let ty = cx.tables.expr_ty(expr);\n \n     if let ty::TyFnDef(id, _) = ty.sty {\n@@ -101,15 +103,15 @@ fn is_unit_function(cx: &LateContext, expr: &hir::Expr) -> bool {\n     false\n }\n \n-fn is_unit_expression(cx: &LateContext, expr: &hir::Expr) -> bool {\n+fn is_unit_expression(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> bool {\n     is_unit_type(cx.tables.expr_ty(expr))\n }\n \n /// The expression inside a closure may or may not have surrounding braces and\n /// semicolons, which causes problems when generating a suggestion. Given an\n /// expression that evaluates to '()' or '!', recursively remove useless braces\n /// and semi-colons until is suitable for including in the suggestion template\n-fn reduce_unit_expression<'a>(cx: &LateContext, expr: &'a hir::Expr) -> Option<Span> {\n+fn reduce_unit_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a hir::Expr) -> Option<Span> {\n     if !is_unit_expression(cx, expr) {\n         return None;\n     }\n@@ -173,7 +175,7 @@ fn unit_closure<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'a hir::Expr) -> Op\n /// `y` => `_y`\n ///\n /// Anything else will return `_`.\n-fn let_binding_name(cx: &LateContext, var_arg: &hir::Expr) -> String {\n+fn let_binding_name(cx: &LateContext<'_, '_>, var_arg: &hir::Expr) -> String {\n     match &var_arg.node {\n         hir::ExprKind::Field(_, _) => snippet(cx, var_arg.span, \"_\").replace(\".\", \"_\"),\n         hir::ExprKind::Path(_) => format!(\"_{}\", snippet(cx, var_arg.span, \"\")),\n@@ -189,7 +191,7 @@ fn suggestion_msg(function_type: &str, map_type: &str) -> String {\n     )\n }\n \n-fn lint_map_unit_fn(cx: &LateContext, stmt: &hir::Stmt, expr: &hir::Expr, map_args: &[hir::Expr]) {\n+fn lint_map_unit_fn(cx: &LateContext<'_, '_>, stmt: &hir::Stmt, expr: &hir::Expr, map_args: &[hir::Expr]) {\n     let var_arg = &map_args[0];\n     let fn_arg = &map_args[1];\n \n@@ -242,7 +244,7 @@ fn lint_map_unit_fn(cx: &LateContext, stmt: &hir::Stmt, expr: &hir::Expr, map_ar\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    fn check_stmt(&mut self, cx: &LateContext, stmt: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, stmt: &hir::Stmt) {\n         if in_macro(stmt.span) {\n             return;\n         }"}, {"sha": "c7452f0027e914eb1debac9fb752d8fc9b8ac84e", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,12 +1,14 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::{self, Ty};\n use std::cmp::Ordering;\n use std::collections::Bound;\n use syntax::ast::LitKind;\n use syntax::codemap::Span;\n use crate::utils::paths;\n-use crate::utils::{expr_block, in_external_macro, is_allowed, is_expn_of, match_qpath, match_type, multispan_sugg,\n+use crate::utils::{expr_block, is_allowed, is_expn_of, match_qpath, match_type, multispan_sugg,\n             remove_blocks, snippet, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty};\n use crate::utils::sugg::Sugg;\n use crate::consts::{constant, Constant};\n@@ -181,7 +183,7 @@ impl LintPass for MatchPass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MatchPass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if in_external_macro(cx, expr.span) {\n+        if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n         if let ExprKind::Match(ref ex, ref arms, MatchSource::Normal) = expr.node {\n@@ -198,7 +200,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MatchPass {\n }\n \n #[cfg_attr(rustfmt, rustfmt_skip)]\n-fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+fn check_single_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     if arms.len() == 2 &&\n       arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n       arms[1].pats.len() == 1 && arms[1].guard.is_none() {\n@@ -220,13 +222,13 @@ fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     }\n }\n \n-fn check_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n+fn check_single_match_single_pattern(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n     if is_wild(&arms[1].pats[0]) {\n         report_single_match_single_pattern(cx, ex, arms, expr, els);\n     }\n }\n \n-fn report_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n+fn report_single_match_single_pattern(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n     let lint = if els.is_some() {\n         SINGLE_MATCH_ELSE\n     } else {\n@@ -250,7 +252,7 @@ fn report_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm],\n     );\n }\n \n-fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, ty: Ty, els: Option<&Expr>) {\n+fn check_single_match_opt_like(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr, ty: Ty<'_>, els: Option<&Expr>) {\n     // list of candidate Enums we know will never get any more members\n     let candidates = &[\n         (&paths::COW, \"Borrowed\"),\n@@ -282,7 +284,7 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n     }\n }\n \n-fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+fn check_match_bool(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     // type of expression == bool\n     if cx.tables.expr_ty(ex).sty == ty::TyBool {\n         span_lint_and_then(\n@@ -363,7 +365,7 @@ fn is_wild(pat: &impl std::ops::Deref<Target = Pat>) -> bool {\n     }\n }\n \n-fn check_wild_err_arm(cx: &LateContext, ex: &Expr, arms: &[Arm]) {\n+fn check_wild_err_arm(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n     let ex_ty = walk_ptrs_ty(cx.tables.expr_ty(ex));\n     if match_type(cx, ex_ty, &paths::RESULT) {\n         for arm in arms {\n@@ -403,7 +405,7 @@ fn is_panic_block(block: &Block) -> bool {\n     }\n }\n \n-fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+fn check_match_ref_pats(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     if has_only_ref_pats(arms) {\n         let mut suggs = Vec::new();\n         let (title, msg) = if let ExprKind::AddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n@@ -434,7 +436,7 @@ fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr)\n     }\n }\n \n-fn check_match_as_ref(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+fn check_match_as_ref(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     if arms.len() == 2 &&\n         arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n         arms[1].pats.len() == 1 && arms[1].guard.is_none() {"}, {"sha": "88c2445864686c080bbaad9cfe548f1f05c11831", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::{Expr, ExprKind};\n use crate::utils::{match_def_path, opt_def_id, paths, span_lint};\n "}, {"sha": "28ff303fc83eb9023c310898b69c07bf29fe46bd", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,13 +1,16 @@\n+use matches::matches;\n use rustc::hir;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::{self, Ty};\n use rustc::hir::def::Def;\n use std::borrow::Cow;\n use std::fmt;\n use std::iter;\n use syntax::ast;\n use syntax::codemap::{Span, BytePos};\n-use crate::utils::{get_arg_name, get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, is_expn_of, is_self,\n+use crate::utils::{get_arg_name, get_trait_def_id, implements_trait, in_macro, is_copy, is_expn_of, is_self,\n             is_self_ty, iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method,\n             match_type, method_chain_args, match_var, return_ty, remove_blocks, same_tys, single_segment_path, snippet,\n             span_lint, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq};\n@@ -803,7 +806,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, implitem: &'tcx hir::ImplItem) {\n-        if in_external_macro(cx, implitem.span) {\n+        if in_external_macro(cx.sess(), implitem.span) {\n             return;\n         }\n         let name = implitem.ident.name;\n@@ -873,10 +876,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n }\n \n /// Checks for the `OR_FUN_CALL` lint.\n-fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n+fn lint_or_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n     /// Check for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n     fn check_unwrap_or_default(\n-        cx: &LateContext,\n+        cx: &LateContext<'_, '_>,\n         name: &str,\n         fun: &hir::Expr,\n         self_expr: &hir::Expr,\n@@ -921,7 +924,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name:\n     /// Check for `*or(foo())`.\n     #[allow(too_many_arguments)]\n     fn check_general_case(\n-        cx: &LateContext,\n+        cx: &LateContext<'_, '_>,\n         name: &str,\n         method_span: Span,\n         fun_span: Span,\n@@ -964,7 +967,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name:\n             return;\n         }\n \n-        let sugg: Cow<_> = match (fn_has_arguments, !or_has_args) {\n+        let sugg: Cow<'_, _> = match (fn_has_arguments, !or_has_args) {\n             (true, _) => format!(\"|_| {}\", snippet(cx, arg.span, \"..\")).into(),\n             (false, false) => format!(\"|| {}\", snippet(cx, arg.span, \"..\")).into(),\n             (false, true) => snippet(cx, fun_span, \"..\"),\n@@ -997,7 +1000,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name:\n }\n \n /// Checks for the `EXPECT_FUN_CALL` lint.\n-fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n+fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n     fn extract_format_args(arg: &hir::Expr) -> Option<&hir::HirVec<hir::Expr>> {\n         if let hir::ExprKind::AddrOf(_, ref addr_of) = arg.node {\n             if let hir::ExprKind::Call(ref inner_fun, ref inner_args) = addr_of.node {\n@@ -1012,7 +1015,7 @@ fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, n\n         None\n     }\n \n-    fn generate_format_arg_snippet(cx: &LateContext, a: &hir::Expr) -> String {\n+    fn generate_format_arg_snippet(cx: &LateContext<'_, '_>, a: &hir::Expr) -> String {\n         if let hir::ExprKind::AddrOf(_, ref format_arg) = a.node {\n             if let hir::ExprKind::Match(ref format_arg_expr, _, _) = format_arg.node {\n                 if let hir::ExprKind::Tup(ref format_arg_expr_tup) = format_arg_expr.node {\n@@ -1025,7 +1028,7 @@ fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, n\n     }\n \n     fn check_general_case(\n-        cx: &LateContext,\n+        cx: &LateContext<'_, '_>,\n         name: &str,\n         method_span: Span,\n         self_expr: &hir::Expr,\n@@ -1076,7 +1079,7 @@ fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, n\n             return;\n         }\n \n-        let sugg: Cow<_> = snippet(cx, arg.span, \"..\");\n+        let sugg: Cow<'_, _> = snippet(cx, arg.span, \"..\");\n \n         span_lint_and_sugg(\n             cx,\n@@ -1097,7 +1100,7 @@ fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, n\n }\n \n /// Checks for the `CLONE_ON_COPY` lint.\n-fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_ty: Ty) {\n+fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Expr, arg_ty: Ty<'_>) {\n     let ty = cx.tables.expr_ty(expr);\n     if let ty::TyRef(_, inner, _) = arg_ty.sty {\n         if let ty::TyRef(_, innermost, _) = inner.sty {\n@@ -1165,7 +1168,7 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_t\n     }\n }\n \n-fn lint_clone_on_ref_ptr(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr) {\n+fn lint_clone_on_ref_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Expr) {\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(arg));\n \n     if let ty::TyAdt(_, subst) = obj_ty.sty {\n@@ -1191,7 +1194,7 @@ fn lint_clone_on_ref_ptr(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr) {\n }\n \n \n-fn lint_string_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n+fn lint_string_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr]) {\n     let arg = &args[1];\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n         let target = &arglists[0][0];\n@@ -1220,14 +1223,14 @@ fn lint_string_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n     }\n }\n \n-fn lint_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n+fn lint_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr]) {\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&args[0]));\n     if match_type(cx, obj_ty, &paths::STRING) {\n         lint_string_extend(cx, expr, args);\n     }\n }\n \n-fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwrap: &hir::Expr) {\n+fn lint_cstring_as_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, new: &hir::Expr, unwrap: &hir::Expr) {\n     if_chain! {\n         if let hir::ExprKind::Call(ref fun, ref args) = new.node;\n         if args.len() == 1;\n@@ -1248,7 +1251,7 @@ fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwr\n     }\n }\n \n-fn lint_iter_cloned_collect(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr]) {\n+fn lint_iter_cloned_collect(cx: &LateContext<'_, '_>, expr: &hir::Expr, iter_args: &[hir::Expr]) {\n     if match_type(cx, cx.tables.expr_ty(expr), &paths::VEC)\n         && derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some()\n     {\n@@ -1262,7 +1265,7 @@ fn lint_iter_cloned_collect(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir\n     }\n }\n \n-fn lint_unnecessary_fold(cx: &LateContext, expr: &hir::Expr, fold_args: &[hir::Expr]) {\n+fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr, fold_args: &[hir::Expr]) {\n     // Check that this is a call to Iterator::fold rather than just some function called fold\n     if !match_trait_method(cx, expr, &paths::ITERATOR) {\n         return;\n@@ -1272,7 +1275,7 @@ fn lint_unnecessary_fold(cx: &LateContext, expr: &hir::Expr, fold_args: &[hir::E\n         \"Expected fold_args to have three entries - the receiver, the initial value and the closure\");\n \n     fn check_fold_with_op(\n-        cx: &LateContext,\n+        cx: &LateContext<'_, '_>,\n         fold_args: &[hir::Expr],\n         op: hir::BinOpKind,\n         replacement_method_name: &str,\n@@ -1350,7 +1353,7 @@ fn lint_unnecessary_fold(cx: &LateContext, expr: &hir::Expr, fold_args: &[hir::E\n     };\n }\n \n-fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr], is_mut: bool) {\n+fn lint_iter_nth(cx: &LateContext<'_, '_>, expr: &hir::Expr, iter_args: &[hir::Expr], is_mut: bool) {\n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n     let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some() {\n         \"slice\"\n@@ -1374,7 +1377,7 @@ fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr], is\n     );\n }\n \n-fn lint_get_unwrap(cx: &LateContext, expr: &hir::Expr, get_args: &[hir::Expr], is_mut: bool) {\n+fn lint_get_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr, get_args: &[hir::Expr], is_mut: bool) {\n     // Note: we don't want to lint `get_mut().unwrap` for HashMap or BTreeMap,\n     // because they do not implement `IndexMut`\n     let expr_ty = cx.tables.expr_ty(&get_args[0]);\n@@ -1413,7 +1416,7 @@ fn lint_get_unwrap(cx: &LateContext, expr: &hir::Expr, get_args: &[hir::Expr], i\n     );\n }\n \n-fn lint_iter_skip_next(cx: &LateContext, expr: &hir::Expr) {\n+fn lint_iter_skip_next(cx: &LateContext<'_, '_>, expr: &hir::Expr) {\n     // lint if caller of skip is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         span_lint(\n@@ -1425,8 +1428,8 @@ fn lint_iter_skip_next(cx: &LateContext, expr: &hir::Expr) {\n     }\n }\n \n-fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: Ty) -> Option<sugg::Sugg<'static>> {\n-    fn may_slice(cx: &LateContext, ty: Ty) -> bool {\n+fn derefs_to_slice(cx: &LateContext<'_, '_>, expr: &hir::Expr, ty: Ty<'_>) -> Option<sugg::Sugg<'static>> {\n+    fn may_slice(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> bool {\n         match ty.sty {\n             ty::TySlice(_) => true,\n             ty::TyAdt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n@@ -1458,7 +1461,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: Ty) -> Option<sugg::S\n }\n \n /// lint use of `unwrap()` for `Option`s and `Result`s\n-fn lint_unwrap(cx: &LateContext, expr: &hir::Expr, unwrap_args: &[hir::Expr]) {\n+fn lint_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr, unwrap_args: &[hir::Expr]) {\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&unwrap_args[0]));\n \n     let mess = if match_type(cx, obj_ty, &paths::OPTION) {\n@@ -1486,7 +1489,7 @@ fn lint_unwrap(cx: &LateContext, expr: &hir::Expr, unwrap_args: &[hir::Expr]) {\n }\n \n /// lint use of `ok().expect()` for `Result`s\n-fn lint_ok_expect(cx: &LateContext, expr: &hir::Expr, ok_args: &[hir::Expr]) {\n+fn lint_ok_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr, ok_args: &[hir::Expr]) {\n     // lint if the caller of `ok()` is a `Result`\n     if match_type(cx, cx.tables.expr_ty(&ok_args[0]), &paths::RESULT) {\n         let result_type = cx.tables.expr_ty(&ok_args[0]);\n@@ -1504,7 +1507,7 @@ fn lint_ok_expect(cx: &LateContext, expr: &hir::Expr, ok_args: &[hir::Expr]) {\n }\n \n /// lint use of `map().unwrap_or()` for `Option`s\n-fn lint_map_unwrap_or(cx: &LateContext, expr: &hir::Expr, map_args: &[hir::Expr], unwrap_args: &[hir::Expr]) {\n+fn lint_map_unwrap_or(cx: &LateContext<'_, '_>, expr: &hir::Expr, map_args: &[hir::Expr], unwrap_args: &[hir::Expr]) {\n     // lint if the caller of `map()` is an `Option`\n     if match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION) {\n         // get snippets for args to map() and unwrap_or()\n@@ -1762,7 +1765,7 @@ struct BinaryExprInfo<'a> {\n }\n \n /// Checks for the `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints.\n-fn lint_binary_expr_with_method_call<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, info: &mut BinaryExprInfo) {\n+fn lint_binary_expr_with_method_call(cx: &LateContext<'_, '_>, info: &mut BinaryExprInfo<'_>) {\n     macro_rules! lint_with_both_lhs_and_rhs {\n         ($func:ident, $cx:expr, $info:ident) => {\n             if !$func($cx, $info) {\n@@ -1781,9 +1784,9 @@ fn lint_binary_expr_with_method_call<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, i\n }\n \n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_NEXT_CMP` lints.\n-fn lint_chars_cmp<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    info: &BinaryExprInfo,\n+fn lint_chars_cmp(\n+    cx: &LateContext<'_, '_>,\n+    info: &BinaryExprInfo<'_>,\n     chain_methods: &[&str],\n     lint: &'static Lint,\n     suggest: &str,\n@@ -1821,12 +1824,12 @@ fn lint_chars_cmp<'a, 'tcx>(\n }\n \n /// Checks for the `CHARS_NEXT_CMP` lint.\n-fn lint_chars_next_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo) -> bool {\n+fn lint_chars_next_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n     lint_chars_cmp(cx, info, &[\"chars\", \"next\"], CHARS_NEXT_CMP, \"starts_with\")\n }\n \n /// Checks for the `CHARS_LAST_CMP` lint.\n-fn lint_chars_last_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo) -> bool {\n+fn lint_chars_last_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n     if lint_chars_cmp(cx, info, &[\"chars\", \"last\"], CHARS_NEXT_CMP, \"ends_with\") {\n         true\n     } else {\n@@ -1837,7 +1840,7 @@ fn lint_chars_last_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprIn\n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints with `unwrap()`.\n fn lint_chars_cmp_with_unwrap<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    info: &BinaryExprInfo,\n+    info: &BinaryExprInfo<'_>,\n     chain_methods: &[&str],\n     lint: &'static Lint,\n     suggest: &str,\n@@ -1868,12 +1871,12 @@ fn lint_chars_cmp_with_unwrap<'a, 'tcx>(\n }\n \n /// Checks for the `CHARS_NEXT_CMP` lint with `unwrap()`.\n-fn lint_chars_next_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo) -> bool {\n+fn lint_chars_next_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n     lint_chars_cmp_with_unwrap(cx, info, &[\"chars\", \"next\", \"unwrap\"], CHARS_NEXT_CMP, \"starts_with\")\n }\n \n /// Checks for the `CHARS_LAST_CMP` lint with `unwrap()`.\n-fn lint_chars_last_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo) -> bool {\n+fn lint_chars_last_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n     if lint_chars_cmp_with_unwrap(cx, info, &[\"chars\", \"last\", \"unwrap\"], CHARS_LAST_CMP, \"ends_with\") {\n         true\n     } else {\n@@ -1904,7 +1907,7 @@ fn lint_single_char_pattern<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hi\n }\n \n /// Checks for the `USELESS_ASREF` lint.\n-fn lint_asref(cx: &LateContext, expr: &hir::Expr, call_name: &str, as_ref_args: &[hir::Expr]) {\n+fn lint_asref(cx: &LateContext<'_, '_>, expr: &hir::Expr, call_name: &str, as_ref_args: &[hir::Expr]) {\n     // when we get here, we've already checked that the call name is \"as_ref\" or \"as_mut\"\n     // check if the call is to the actual `AsRef` or `AsMut` trait\n     if match_trait_method(cx, expr, &paths::ASREF_TRAIT) || match_trait_method(cx, expr, &paths::ASMUT_TRAIT) {\n@@ -1928,7 +1931,7 @@ fn lint_asref(cx: &LateContext, expr: &hir::Expr, call_name: &str, as_ref_args:\n }\n \n /// Given a `Result<T, E>` type, return its error type (`E`).\n-fn get_error_type<'a>(cx: &LateContext, ty: Ty<'a>) -> Option<Ty<'a>> {\n+fn get_error_type<'a>(cx: &LateContext<'_, '_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n     if let ty::TyAdt(_, substs) = ty.sty {\n         if match_type(cx, ty, &paths::RESULT) {\n             substs.types().nth(1)\n@@ -2030,7 +2033,7 @@ enum SelfKind {\n impl SelfKind {\n     fn matches(\n         self,\n-        cx: &LateContext,\n+        cx: &LateContext<'_, '_>,\n         ty: &hir::Ty,\n         arg: &hir::Arg,\n         self_ty: &hir::Ty,\n@@ -2157,7 +2160,7 @@ impl Convention {\n }\n \n impl fmt::Display for Convention {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n         match *self {\n             Convention::Eq(this) => this.fmt(f),\n             Convention::StartsWith(this) => this.fmt(f).and_then(|_| '*'.fmt(f)),\n@@ -2174,7 +2177,7 @@ enum OutType {\n }\n \n impl OutType {\n-    fn matches(self, cx: &LateContext, ty: &hir::FunctionRetTy) -> bool {\n+    fn matches(self, cx: &LateContext<'_, '_>, ty: &hir::FunctionRetTy) -> bool {\n         let is_unit = |ty: &hir::Ty| SpanlessEq::new(cx).eq_ty_kind(&ty.node, &hir::TyKind::Tup(vec![].into()));\n         match (self, ty) {\n             (OutType::Unit, &hir::DefaultReturn(_)) => true,"}, {"sha": "bc573841cc80d0651c6a3ff0c670bb56eba1feeb", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -2,6 +2,7 @@ use crate::consts::{constant_simple, Constant};\n use crate::utils::{match_def_path, opt_def_id, paths, span_lint};\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use std::cmp::Ordering;\n \n /// **What it does:** Checks for expressions where `std::cmp::min` and `max` are\n@@ -65,7 +66,7 @@ enum MinMax {\n     Max,\n }\n \n-fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'a Expr)> {\n+fn min_max<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<(MinMax, Constant, &'a Expr)> {\n     if let ExprKind::Call(ref path, ref args) = expr.node {\n         if let ExprKind::Path(ref qpath) = path.node {\n             opt_def_id(cx.tables.qpath_def(qpath, path.hir_id)).and_then(|def_id| {\n@@ -85,7 +86,7 @@ fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'\n     }\n }\n \n-fn fetch_const<'a>(cx: &LateContext, args: &'a [Expr], m: MinMax) -> Option<(MinMax, Constant, &'a Expr)> {\n+fn fetch_const<'a>(cx: &LateContext<'_, '_>, args: &'a [Expr], m: MinMax) -> Option<(MinMax, Constant, &'a Expr)> {\n     if args.len() != 2 {\n         return None;\n     }"}, {"sha": "b01d24a1ad33143b26535c5fe2515844e71f18da", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,7 +1,10 @@\n use crate::reexport::*;\n+use matches::matches;\n use rustc::hir::*;\n use rustc::hir::intravisit::FnKind;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty;\n use syntax::codemap::{ExpnFormat, Span};\n use crate::utils::{get_item_name, get_parent_expr, implements_trait, in_constant, in_macro, is_integer_literal,\n@@ -430,7 +433,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn check_nan(cx: &LateContext, path: &Path, expr: &Expr) {\n+fn check_nan(cx: &LateContext<'_, '_>, path: &Path, expr: &Expr) {\n     if !in_constant(cx, expr.id) {\n         if let Some(seg) = path.segments.last() {\n             if seg.ident.name == \"NAN\" {\n@@ -461,11 +464,11 @@ fn is_allowed<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> bool {\n     }\n }\n \n-fn is_float(cx: &LateContext, expr: &Expr) -> bool {\n+fn is_float(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     matches!(walk_ptrs_ty(cx.tables.expr_ty(expr)).sty, ty::TyFloat(_))\n }\n \n-fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr) {\n+fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr, other: &Expr) {\n     let (arg_ty, snip) = match expr.node {\n         ExprKind::MethodCall(.., ref args) if args.len() == 1 => {\n             if match_trait_method(cx, expr, &paths::TO_STRING) || match_trait_method(cx, expr, &paths::TO_OWNED) {\n@@ -539,7 +542,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr) {\n /// Heuristic to see if an expression is used. Should be compatible with\n /// `unused_variables`'s idea\n /// of what it means for an expression to be \"used\".\n-fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n+fn is_used(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n         match parent.node {\n             ExprKind::Assign(_, ref rhs) | ExprKind::AssignOp(_, _, ref rhs) => SpanlessEq::new(cx).eq_expr(rhs, expr),\n@@ -562,14 +565,14 @@ fn in_attributes_expansion(expr: &Expr) -> bool {\n }\n \n /// Test whether `def` is a variable defined outside a macro.\n-fn non_macro_local(cx: &LateContext, def: &def::Def) -> bool {\n+fn non_macro_local(cx: &LateContext<'_, '_>, def: &def::Def) -> bool {\n     match *def {\n         def::Def::Local(id) | def::Def::Upvar(id, _, _) => !in_macro(cx.tcx.hir.span(id)),\n         _ => false,\n     }\n }\n \n-fn check_cast(cx: &LateContext, span: Span, e: &Expr, ty: &Ty) {\n+fn check_cast(cx: &LateContext<'_, '_>, span: Span, e: &Expr, ty: &Ty) {\n     if_chain! {\n         if let TyKind::Ptr(MutTy { mutbl, .. }) = ty.node;\n         if let ExprKind::Lit(ref lit) = e.node;"}, {"sha": "9b8e0743f39354895428940acabf2673d4ed1e54", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,10 +1,12 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use std::collections::HashMap;\n use std::char;\n use syntax::ast::*;\n use syntax::codemap::Span;\n use syntax::visit::FnKind;\n-use crate::utils::{constants, in_external_macro, snippet, snippet_opt, span_help_and_lint, span_lint, span_lint_and_then};\n+use crate::utils::{constants, snippet, snippet_opt, span_help_and_lint, span_lint, span_lint_and_then};\n \n /// **What it does:** Checks for structure field patterns bound to wildcards.\n ///\n@@ -187,7 +189,7 @@ impl LintPass for MiscEarly {\n }\n \n impl EarlyLintPass for MiscEarly {\n-    fn check_generics(&mut self, cx: &EarlyContext, gen: &Generics) {\n+    fn check_generics(&mut self, cx: &EarlyContext<'_>, gen: &Generics) {\n         for param in &gen.params {\n             if let GenericParamKind::Type { .. } = param.kind {\n                 let name = param.ident.as_str();\n@@ -203,7 +205,7 @@ impl EarlyLintPass for MiscEarly {\n         }\n     }\n \n-    fn check_pat(&mut self, cx: &EarlyContext, pat: &Pat) {\n+    fn check_pat(&mut self, cx: &EarlyContext<'_>, pat: &Pat) {\n         if let PatKind::Struct(ref npat, ref pfields, _) = pat.node {\n             let mut wilds = 0;\n             let type_name = npat.segments\n@@ -264,7 +266,7 @@ impl EarlyLintPass for MiscEarly {\n         }\n     }\n \n-    fn check_fn(&mut self, cx: &EarlyContext, _: FnKind, decl: &FnDecl, _: Span, _: NodeId) {\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, _: FnKind<'_>, decl: &FnDecl, _: Span, _: NodeId) {\n         let mut registered_names: HashMap<String, Span> = HashMap::new();\n \n         for arg in &decl.inputs {\n@@ -291,8 +293,8 @@ impl EarlyLintPass for MiscEarly {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n-        if in_external_macro(cx, expr.span) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n+        if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n         match expr.node {\n@@ -323,7 +325,7 @@ impl EarlyLintPass for MiscEarly {\n         }\n     }\n \n-    fn check_block(&mut self, cx: &EarlyContext, block: &Block) {\n+    fn check_block(&mut self, cx: &EarlyContext<'_>, block: &Block) {\n         for w in block.stmts.windows(2) {\n             if_chain! {\n                 if let StmtKind::Local(ref local) = w[0].node;\n@@ -350,7 +352,7 @@ impl EarlyLintPass for MiscEarly {\n }\n \n impl MiscEarly {\n-    fn check_lit(self, cx: &EarlyContext, lit: &Lit) {\n+    fn check_lit(self, cx: &EarlyContext<'_>, lit: &Lit) {\n         if_chain! {\n             if let LitKind::Int(value, ..) = lit.node;\n             if let Some(src) = snippet_opt(cx, lit.span);"}, {"sha": "fe2bbbdb9af0b0308fa1bf5e54815cef1ad7aec2", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -20,6 +20,7 @@\n \n use rustc::hir;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::ty;\n use syntax::ast;\n use syntax::attr;\n@@ -66,7 +67,7 @@ impl MissingDoc {\n             .expect(\"empty doc_hidden_stack\")\n     }\n \n-    fn check_missing_docs_attrs(&self, cx: &LateContext, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n+    fn check_missing_docs_attrs(&self, cx: &LateContext<'_, '_>, attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n         // If we're building a test harness, then warning about\n         // documentation is probably not really relevant right now.\n         if cx.sess().opts.test {\n@@ -177,6 +178,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ImplItemKind::Const(..) => \"an associated constant\",\n             hir::ImplItemKind::Method(..) => \"a method\",\n             hir::ImplItemKind::Type(_) => \"an associated type\",\n+            hir::ImplItemKind::Existential(_) => \"an existential type\",\n         };\n         self.check_missing_docs_attrs(cx, &impl_item.attrs, impl_item.span, desc);\n     }"}, {"sha": "e19ec4da67ed29cd4352924181c908dc96e41b9c", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -11,6 +11,7 @@\n \n use rustc::hir;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast;\n use syntax::codemap::Span;\n \n@@ -67,7 +68,7 @@ declare_clippy_lint! {\n \n pub struct MissingInline;\n \n-fn check_missing_inline_attrs(cx: &LateContext,\n+fn check_missing_inline_attrs(cx: &LateContext<'_, '_>,\n                               attrs: &[ast::Attribute], sp: Span, desc: &'static str) {\n     let has_inline = attrs\n         .iter()\n@@ -165,7 +166,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n         let desc = match impl_item.node {\n             hir::ImplItemKind::Method(..) => \"a method\",\n             hir::ImplItemKind::Const(..) |\n-            hir::ImplItemKind::Type(_) => return,\n+            hir::ImplItemKind::Type(_) |\n+            hir::ImplItemKind::Existential(_) => return,\n         };\n \n         let def_id = cx.tcx.hir.local_def_id(impl_item.id);"}, {"sha": "d424604550661c57cc5fad9400dd44caf01fce07", "filename": "clippy_lints/src/multiple_crate_versions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmultiple_crate_versions.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,6 +1,7 @@\n //! lint on multiple versions of a crate being used\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::*;\n \n use cargo_metadata;\n@@ -38,7 +39,7 @@ impl LintPass for Pass {\n }\n \n impl EarlyLintPass for Pass {\n-    fn check_crate(&mut self, cx: &EarlyContext, krate: &Crate) {\n+    fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &Crate) {\n         let metadata = match cargo_metadata::metadata_deps(None, true) {\n             Ok(metadata) => metadata,\n             Err(_) => {"}, {"sha": "0413f1ab603ffa2942fdb820d0b5c94a6cbe0d97", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,8 +1,9 @@\n use rustc::hir;\n use rustc::hir::intravisit;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::ty;\n-use crate::utils::{higher, in_external_macro, span_lint};\n+use crate::utils::{higher, span_lint};\n \n /// **What it does:** Checks for instances of `mut mut` references.\n ///\n@@ -49,7 +50,7 @@ pub struct MutVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if in_external_macro(self.cx, expr.span) {\n+        if in_external_macro(self.cx.sess(), expr.span) {\n             return;\n         }\n "}, {"sha": "de4c54444400b2c606029c65d7f2ef849e8407ba", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::ty::{self, Ty};\n use rustc::ty::subst::Subst;\n use rustc::hir::*;"}, {"sha": "50ef9f268f29ab5b36e09a8a5bbe38821f2afccc", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -3,6 +3,7 @@\n //! This lint is **warn** by default\n \n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::{declare_lint, lint_array};\n use rustc::ty::{self, Ty};\n use rustc::hir::Expr;\n use syntax::ast;\n@@ -79,7 +80,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutexAtomic {\n     }\n }\n \n-fn get_atomic_name(ty: Ty) -> Option<(&'static str)> {\n+fn get_atomic_name(ty: Ty<'_>) -> Option<(&'static str)> {\n     match ty.sty {\n         ty::TyBool => Some(\"AtomicBool\"),\n         ty::TyUint(_) => Some(\"AtomicUsize\"),"}, {"sha": "559aa74f9a22848d61fdfca8afff72107aa3e990", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -3,6 +3,7 @@\n //! This lint is **warn** by default\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use syntax::ast::LitKind;\n use syntax::codemap::Spanned;"}, {"sha": "7986b43919c80fbf70417cffd962eb95967f5dfc", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -3,6 +3,8 @@\n //! This lint is **warn** by default\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir::{BindingAnnotation, Expr, ExprKind, MutImmutable, Pat, PatKind};\n use rustc::ty;\n use rustc::ty::adjustment::{Adjust, Adjustment};"}, {"sha": "1679a9007b462df839d5b22802d60b4081d74699", "filename": "clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -3,6 +3,8 @@\n //! This lint is **warn** by default\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir::{BindingAnnotation, MutImmutable, Pat, PatKind};\n use crate::utils::{in_macro, snippet, span_lint_and_then};\n "}, {"sha": "60ab0eaae02415a7c041d869b6e4da90fe1a15ab", "filename": "clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_continue.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -28,6 +28,7 @@\n //!\n //! This lint is **warn** by default.\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast;\n use syntax::codemap::{original_sp, DUMMY_SP};\n use std::borrow::Cow;\n@@ -109,7 +110,7 @@ impl LintPass for NeedlessContinue {\n }\n \n impl EarlyLintPass for NeedlessContinue {\n-    fn check_expr(&mut self, ctx: &EarlyContext, expr: &ast::Expr) {\n+    fn check_expr(&mut self, ctx: &EarlyContext<'_>, expr: &ast::Expr) {\n         if !in_macro(expr.span) {\n             check_and_warn(ctx, expr);\n         }\n@@ -264,7 +265,7 @@ const DROP_ELSE_BLOCK_MSG: &str = \"Consider dropping the else clause, and moving\n                                    block, like so:\\n\";\n \n \n-fn emit_warning<'a>(ctx: &EarlyContext, data: &'a LintData, header: &str, typ: LintType) {\n+fn emit_warning<'a>(ctx: &EarlyContext<'_>, data: &'a LintData<'_>, header: &str, typ: LintType) {\n     // snip    is the whole *help* message that appears after the warning.\n     // message is the warning message.\n     // expr    is the expression which the lint warning message refers to.\n@@ -283,7 +284,7 @@ fn emit_warning<'a>(ctx: &EarlyContext, data: &'a LintData, header: &str, typ: L\n     span_help_and_lint(ctx, NEEDLESS_CONTINUE, expr.span, message, &snip);\n }\n \n-fn suggestion_snippet_for_continue_inside_if<'a>(ctx: &EarlyContext, data: &'a LintData, header: &str) -> String {\n+fn suggestion_snippet_for_continue_inside_if<'a>(ctx: &EarlyContext<'_>, data: &'a LintData<'_>, header: &str) -> String {\n     let cond_code = snippet(ctx, data.if_cond.span, \"..\");\n \n     let if_code = format!(\"if {} {{\\n    continue;\\n}}\\n\", cond_code);\n@@ -300,7 +301,7 @@ fn suggestion_snippet_for_continue_inside_if<'a>(ctx: &EarlyContext, data: &'a L\n     ret\n }\n \n-fn suggestion_snippet_for_continue_inside_else<'a>(ctx: &EarlyContext, data: &'a LintData, header: &str) -> String {\n+fn suggestion_snippet_for_continue_inside_else<'a>(ctx: &EarlyContext<'_>, data: &'a LintData<'_>, header: &str) -> String {\n     let cond_code = snippet(ctx, data.if_cond.span, \"..\");\n     let mut if_code = format!(\"if {} {{\\n\", cond_code);\n \n@@ -331,7 +332,7 @@ fn suggestion_snippet_for_continue_inside_else<'a>(ctx: &EarlyContext, data: &'a\n     ret\n }\n \n-fn check_and_warn<'a>(ctx: &EarlyContext, expr: &'a ast::Expr) {\n+fn check_and_warn<'a>(ctx: &EarlyContext<'_>, expr: &'a ast::Expr) {\n     with_loop_block(expr, |loop_block| {\n         for (i, stmt) in loop_block.stmts.iter().enumerate() {\n             with_if_expr(stmt, |if_expr, cond, then_block, else_expr| {"}, {"sha": "82e85f3453a1526d5c1ebaaf74c37a2d3cb4feca", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,7 +1,10 @@\n+use matches::matches;\n use rustc::hir::*;\n use rustc::hir::map::*;\n use rustc::hir::intravisit::FnKind;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::{self, RegionKind, TypeFoldable};\n use rustc::traits;\n use rustc::middle::expr_use_visitor as euv;\n@@ -201,7 +204,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                     }\n \n                     // Dereference suggestion\n-                    let sugg = |db: &mut DiagnosticBuilder| {\n+                    let sugg = |db: &mut DiagnosticBuilder<'_>| {\n                         if let ty::TypeVariants::TyAdt(def, ..) = ty.sty {\n                             if let Some(span) = cx.tcx.hir.span_if_local(def.did) {\n                                 if cx.param_env.can_type_implement_copy(cx.tcx, ty).is_ok() {\n@@ -393,7 +396,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn borrow(&mut self, _: NodeId, _: Span, _: &mc::cmt_<'tcx>, _: ty::Region, _: ty::BorrowKind, _: euv::LoanCause) {}\n+    fn borrow(&mut self, _: NodeId, _: Span, _: &mc::cmt_<'tcx>, _: ty::Region<'_>, _: ty::BorrowKind, _: euv::LoanCause) {}\n \n     fn mutate(&mut self, _: NodeId, _: Span, _: &mc::cmt_<'tcx>, _: euv::MutateMode) {}\n "}, {"sha": "52c4c6e52371c749424a32b3d21419b456511ca4", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::{declare_lint, lint_array};\n use rustc::ty;\n use rustc::hir::{Expr, ExprKind};\n use crate::utils::span_lint;"}, {"sha": "42be6ec664e10a9e9c1438e9f4790566650ad025", "filename": "clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,7 +1,9 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n \n-use crate::utils::{self, paths, span_lint, in_external_macro};\n+use crate::utils::{self, paths, span_lint};\n \n /// **What it does:**\n /// Checks for the usage of negated comparision operators on types which only implement\n@@ -53,7 +55,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NoNegCompOpForPartialOrd {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_chain! {\n \n-            if !in_external_macro(cx, expr.span);\n+            if !in_external_macro(cx.sess(), expr.span);\n             if let ExprKind::Unary(UnOp::UnNot, ref inner) = expr.node;\n             if let ExprKind::Binary(ref op, ref left, _) = inner.node;\n             if let BinOpKind::Le | BinOpKind::Ge | BinOpKind::Lt | BinOpKind::Gt = op.node;"}, {"sha": "c056ff46178b6af646d24fd238426227ba693be4", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,5 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use syntax::codemap::{Span, Spanned};\n \n use crate::consts::{self, Constant};\n@@ -44,7 +46,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n     }\n }\n \n-fn check_mul(cx: &LateContext, span: Span, lit: &Expr, exp: &Expr) {\n+fn check_mul(cx: &LateContext<'_, '_>, span: Span, lit: &Expr, exp: &Expr) {\n     if_chain! {\n         if let ExprKind::Lit(ref l) = lit.node;\n         if let Constant::Int(val) = consts::lit_to_constant(&l.node, cx.tables.expr_ty(lit));"}, {"sha": "eeb131959e9a2fc94bf3ecad96cf054f8d584677", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,10 +1,12 @@\n use rustc::hir::def_id::DefId;\n use rustc::hir;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::{self, Ty};\n use syntax::codemap::Span;\n use crate::utils::paths;\n-use crate::utils::{get_trait_def_id, implements_trait, in_external_macro, return_ty, same_tys, span_lint_and_then};\n+use crate::utils::{get_trait_def_id, implements_trait, return_ty, same_tys, span_lint_and_then};\n use crate::utils::sugg::DiagnosticBuilderExt;\n \n /// **What it does:** Checks for types with a `fn new() -> Self` method and no\n@@ -93,7 +95,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n             for assoc_item in items {\n                 if let hir::AssociatedItemKind::Method { has_self: false } = assoc_item.kind {\n                     let impl_item = cx.tcx.hir.impl_item(assoc_item.id);\n-                    if in_external_macro(cx, impl_item.span) {\n+                    if in_external_macro(cx.sess(), impl_item.span) {\n                         return;\n                     }\n                     if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n@@ -155,7 +157,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n     }\n }\n \n-fn create_new_without_default_suggest_msg(ty: Ty) -> String {\n+fn create_new_without_default_suggest_msg(ty: Ty<'_>) -> String {\n     #[cfg_attr(rustfmt, rustfmt_skip)]\n     format!(\n \"impl Default for {} {{"}, {"sha": "cacb5d6a9ffcc31d9749b41a7113c9e24e273ade", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::def::Def;\n use rustc::hir::{BinOpKind, BlockCheckMode, Expr, ExprKind, Stmt, StmtKind, UnsafeSource};\n use crate::utils::{has_drop, in_macro, snippet_opt, span_lint, span_lint_and_sugg};\n@@ -40,7 +41,7 @@ declare_clippy_lint! {\n     \"outer expressions with no effect\"\n }\n \n-fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n+fn has_no_effect(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     if in_macro(expr.span) {\n         return false;\n     }\n@@ -127,7 +128,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n }\n \n \n-fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Expr>> {\n+fn reduce_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<Vec<&'a Expr>> {\n     if in_macro(expr.span) {\n         return None;\n     }"}, {"sha": "f2c9210aae4e0d42dd53d5c4612c46e8273ac69c", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -3,6 +3,7 @@\n //! This lint is **deny** by default.\n \n use rustc::lint::{LateContext, LateLintPass, Lint, LintArray, LintPass};\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use rustc::hir::def::Def;\n use rustc::ty::{self, TypeFlags};"}, {"sha": "e9688262c2a76eeb401771d58c3de37cdec41f35", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::codemap::Span;\n use syntax::symbol::LocalInternedString;\n use syntax::ast::*;\n@@ -311,21 +312,21 @@ impl<'a, 'tcx> Visitor<'tcx> for SimilarNamesLocalVisitor<'a, 'tcx> {\n }\n \n impl EarlyLintPass for NonExpressiveNames {\n-    fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n         if let ItemKind::Fn(ref decl, _, _, ref blk) = item.node {\n             do_check(self, cx, &item.attrs, decl, blk);\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &EarlyContext, item: &ImplItem) {\n+    fn check_impl_item(&mut self, cx: &EarlyContext<'_>, item: &ImplItem) {\n         if let ImplItemKind::Method(ref sig, ref blk) = item.node {\n             do_check(self, cx, &item.attrs, &sig.decl, blk);\n         }\n     }\n \n }\n \n-fn do_check(lint: &mut NonExpressiveNames, cx: &EarlyContext, attrs: &[Attribute], decl: &FnDecl, blk: &Block) {\n+fn do_check(lint: &mut NonExpressiveNames, cx: &EarlyContext<'_>, attrs: &[Attribute], decl: &FnDecl, blk: &Block) {\n     if !attr::contains_name(attrs, \"test\") {\n         let mut visitor = SimilarNamesLocalVisitor {\n             names: Vec::new(),"}, {"sha": "2a7f71c714521cfe721a31057e854c67ebd84e57", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir::*;\n use crate::utils::{match_type, method_chain_args, paths, snippet, span_help_and_lint};\n "}, {"sha": "effeb88d0cf8569d8457067c23846c21d460641f", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,5 +1,6 @@\n use rustc::hir::{Expr, ExprKind};\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::LitKind;\n use syntax::codemap::{Span, Spanned};\n use crate::utils::{match_type, paths, span_lint, walk_ptrs_ty};\n@@ -60,7 +61,7 @@ enum OpenOption {\n     Append,\n }\n \n-fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOption, Argument)>) {\n+fn get_open_options(cx: &LateContext<'_, '_>, argument: &Expr, options: &mut Vec<(OpenOption, Argument)>) {\n     if let ExprKind::MethodCall(ref path, _, ref arguments) = argument.node {\n         let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&arguments[0]));\n \n@@ -111,7 +112,7 @@ fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOp\n     }\n }\n \n-fn check_open_options(cx: &LateContext, options: &[(OpenOption, Argument)], span: Span) {\n+fn check_open_options(cx: &LateContext<'_, '_>, options: &[(OpenOption, Argument)], span: Span) {\n     let (mut create, mut append, mut truncate, mut read, mut write) = (false, false, false, false, false);\n     let (mut create_arg, mut append_arg, mut truncate_arg, mut read_arg, mut write_arg) =\n         (false, false, false, false, false);"}, {"sha": "5714bdb521c83f4df32eab7f415e4af32ae2bcdb", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir::*;\n use crate::utils::{span_lint, SpanlessEq};\n "}, {"sha": "e603773f7ba40155529303f9c362c5a24f2351a5", "filename": "clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,5 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use syntax::ast::LitKind;\n use syntax::ptr::P;\n use syntax::ext::quote::rt::Span;\n@@ -84,7 +86,7 @@ fn get_outer_span(expr: &Expr) -> Span {\n     }\n }\n \n-fn match_panic(params: &P<[Expr]>, expr: &Expr, cx: &LateContext) {\n+fn match_panic(params: &P<[Expr]>, expr: &Expr, cx: &LateContext<'_, '_>) {\n     if_chain! {\n         if let ExprKind::Lit(ref lit) = params[0].node;\n         if is_direct_expn_of(expr.span, \"panic\").is_some();"}, {"sha": "675d014c527a09219b2c1c1ddb89e51207b5ef7d", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir::*;\n use crate::utils::{is_automatically_derived, span_lint};\n "}, {"sha": "6a0f4f147b727b496f0d6b47a84a66b2330d685d", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::*;\n use syntax::codemap::Spanned;\n use crate::utils::{in_macro, snippet, span_lint_and_sugg};\n@@ -36,7 +37,7 @@ impl LintPass for Precedence {\n }\n \n impl EarlyLintPass for Precedence {\n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n         if in_macro(expr.span) {\n             return;\n         }"}, {"sha": "ea2d07df45577a655f0c526bb2f956f2f5c7b646", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -5,6 +5,8 @@ use rustc::hir::*;\n use rustc::hir::map::NodeItem;\n use rustc::hir::QPath;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty;\n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n@@ -144,7 +146,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n     }\n }\n \n-fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<BodyId>) {\n+fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<BodyId>) {\n     let fn_def_id = cx.tcx.hir.local_def_id(fn_id);\n     let sig = cx.tcx.fn_sig(fn_def_id);\n     let fn_ty = sig.skip_binder();"}, {"sha": "630dd1b57be1660cb01c858f71efcd1dd494f93e", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::hir::def::Def;\n use crate::utils::sugg::Sugg;\n@@ -50,7 +52,7 @@ impl QuestionMarkPass {\n     /// ```\n     ///\n     /// If it matches, it will suggest to use the question mark operator instead\n-    fn check_is_none_and_early_return_none(cx: &LateContext, expr: &Expr) {\n+    fn check_is_none_and_early_return_none(cx: &LateContext<'_, '_>, expr: &Expr) {\n         if_chain! {\n             if let ExprKind::If(ref if_expr, ref body, _) = expr.node;\n             if let ExprKind::MethodCall(ref segment, _, ref args) = if_expr.node;\n@@ -79,13 +81,13 @@ impl QuestionMarkPass {\n         }\n     }\n \n-    fn is_option(cx: &LateContext, expression: &Expr) -> bool {\n+    fn is_option(cx: &LateContext<'_, '_>, expression: &Expr) -> bool {\n         let expr_ty = cx.tables.expr_ty(expression);\n \n         match_type(cx, expr_ty, &OPTION)\n     }\n \n-    fn expression_returns_none(cx: &LateContext, expression: &Expr) -> bool {\n+    fn expression_returns_none(cx: &LateContext<'_, '_>, expression: &Expr) -> bool {\n         match expression.node {\n             ExprKind::Block(ref block, _) => {\n                 if let Some(return_expression) = Self::return_expression(block) {"}, {"sha": "fd303bb6ab4f8dd39ebde8de2e3dada1c9b32e5a", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir::*;\n use syntax::ast::RangeLimits;\n use syntax::codemap::Spanned;\n@@ -174,7 +176,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn has_step_by(cx: &LateContext, expr: &Expr) -> bool {\n+fn has_step_by(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     // No need for walk_ptrs_ty here because step_by moves self, so it\n     // can't be called on a borrowed range.\n     let ty = cx.tables.expr_ty_adjusted(expr);"}, {"sha": "4f28d36e2a8f72e66533d11f1ca709be7b937a84", "filename": "clippy_lints/src/redundant_field_names.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fredundant_field_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_field_names.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use crate::utils::{in_macro, is_range_expression, match_var, span_lint_and_sugg};\n "}, {"sha": "f349f46d926e31987f2f8a024c4584e69a1e1424", "filename": "clippy_lints/src/reference.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freference.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,5 +1,7 @@\n use syntax::ast::{Expr, ExprKind, UnOp};\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use crate::utils::{snippet, span_lint_and_sugg};\n \n /// **What it does:** Checks for usage of `*&` and `*&mut` in expressions.\n@@ -37,7 +39,7 @@ fn without_parens(mut e: &Expr) -> &Expr {\n }\n \n impl EarlyLintPass for Pass {\n-    fn check_expr(&mut self, cx: &EarlyContext, e: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &Expr) {\n         if_chain! {\n             if let ExprKind::Unary(UnOp::Deref, ref deref_target) = e.node;\n             if let ExprKind::AddrOf(_, ref addrof_target) = without_parens(deref_target).node;\n@@ -82,7 +84,7 @@ impl LintPass for DerefPass {\n }\n \n impl EarlyLintPass for DerefPass {\n-    fn check_expr(&mut self, cx: &EarlyContext, e: &Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &Expr) {\n         if_chain! {\n             if let ExprKind::Field(ref object, ref field_name) = e.node;\n             if let ExprKind::Paren(ref parened) = object.node;"}, {"sha": "39b7888dcc609b95dfc844e132d610ceceedbfcd", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,6 +1,8 @@\n use regex_syntax;\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use std::collections::HashSet;\n use syntax::ast::{LitKind, NodeId, StrStyle};\n use syntax::codemap::{BytePos, Span};"}, {"sha": "b9a4c6ebb1958d5927bcc4e73920a1b85e920d2b", "filename": "clippy_lints/src/replace_consts.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Freplace_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Freplace_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freplace_consts.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir;\n use rustc::hir::def::Def;\n use crate::utils::{match_def_path, span_lint_and_sugg};"}, {"sha": "0ede1bc972745e7dba3e11b07a31f35d93f4a76c", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,9 +1,11 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::visit::FnKind;\n \n-use crate::utils::{in_external_macro, in_macro, match_path_ast, snippet_opt, span_lint_and_then, span_note_and_lint};\n+use crate::utils::{in_macro, match_path_ast, snippet_opt, span_lint_and_then, span_note_and_lint};\n \n /// **What it does:** Checks for return statements at the end of a block.\n ///\n@@ -47,7 +49,7 @@ pub struct ReturnPass;\n \n impl ReturnPass {\n     // Check the final stmt or expr in a block for unnecessary return.\n-    fn check_block_return(&mut self, cx: &EarlyContext, block: &ast::Block) {\n+    fn check_block_return(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n         if let Some(stmt) = block.stmts.last() {\n             match stmt.node {\n                 ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => {\n@@ -59,7 +61,7 @@ impl ReturnPass {\n     }\n \n     // Check a the final expression in a block if it's a return.\n-    fn check_final_expr(&mut self, cx: &EarlyContext, expr: &ast::Expr, span: Option<Span>) {\n+    fn check_final_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr, span: Option<Span>) {\n         match expr.node {\n             // simple return is always \"bad\"\n             ast::ExprKind::Ret(Some(ref inner)) => {\n@@ -87,8 +89,8 @@ impl ReturnPass {\n         }\n     }\n \n-    fn emit_return_lint(&mut self, cx: &EarlyContext, ret_span: Span, inner_span: Span) {\n-        if in_external_macro(cx, inner_span) || in_macro(inner_span) {\n+    fn emit_return_lint(&mut self, cx: &EarlyContext<'_>, ret_span: Span, inner_span: Span) {\n+        if in_external_macro(cx.sess(), inner_span) || in_macro(inner_span) {\n             return;\n         }\n         span_lint_and_then(cx, NEEDLESS_RETURN, ret_span, \"unneeded return statement\", |db| {\n@@ -99,7 +101,7 @@ impl ReturnPass {\n     }\n \n     // Check for \"let x = EXPR; x\"\n-    fn check_let_return(&mut self, cx: &EarlyContext, block: &ast::Block) {\n+    fn check_let_return(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n         let mut it = block.stmts.iter();\n \n         // we need both a let-binding stmt and an expr\n@@ -115,7 +117,7 @@ impl ReturnPass {\n             if let ast::PatKind::Ident(_, ident, _) = local.pat.node;\n             if let ast::ExprKind::Path(_, ref path) = retexpr.node;\n             if match_path_ast(path, &[&ident.as_str()]);\n-            if !in_external_macro(cx, initexpr.span);\n+            if !in_external_macro(cx.sess(), initexpr.span);\n             then {\n                     span_note_and_lint(cx,\n                                        LET_AND_RETURN,\n@@ -136,14 +138,14 @@ impl LintPass for ReturnPass {\n }\n \n impl EarlyLintPass for ReturnPass {\n-    fn check_fn(&mut self, cx: &EarlyContext, kind: FnKind, _: &ast::FnDecl, _: Span, _: ast::NodeId) {\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, kind: FnKind<'_>, _: &ast::FnDecl, _: Span, _: ast::NodeId) {\n         match kind {\n             FnKind::ItemFn(.., block) | FnKind::Method(.., block) => self.check_block_return(cx, block),\n             FnKind::Closure(body) => self.check_final_expr(cx, body, Some(body.span)),\n         }\n     }\n \n-    fn check_block(&mut self, cx: &EarlyContext, block: &ast::Block) {\n+    fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n         self.check_let_return(cx, block);\n     }\n }"}, {"sha": "ce326ea72ca81619ac01882465453eafa3f4495e", "filename": "clippy_lints/src/serde_api.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fserde_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fserde_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde_api.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use crate::utils::{get_trait_def_id, paths, span_lint};\n "}, {"sha": "aab578d634453f62d06d7128dc269ff8533dfee1", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,10 +1,11 @@\n use crate::reexport::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use rustc::hir::intravisit::FnKind;\n use rustc::ty;\n use syntax::codemap::Span;\n-use crate::utils::{contains_name, higher, in_external_macro, iter_input_pats, snippet, span_lint_and_then};\n+use crate::utils::{contains_name, higher, iter_input_pats, snippet, span_lint_and_then};\n \n /// **What it does:** Checks for bindings that shadow other bindings already in\n /// scope, while just changing reference level or mutability.\n@@ -89,7 +90,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         _: Span,\n         _: NodeId,\n     ) {\n-        if in_external_macro(cx, body.value.span) {\n+        if in_external_macro(cx.sess(), body.value.span) {\n             return;\n         }\n         check_fn(cx, decl, body);\n@@ -121,7 +122,7 @@ fn check_block<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, block: &'tcx Block, binding\n }\n \n fn check_decl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx Decl, bindings: &mut Vec<(Name, Span)>) {\n-    if in_external_macro(cx, decl.span) {\n+    if in_external_macro(cx.sess(), decl.span) {\n         return;\n     }\n     if higher::is_from_for_desugar(decl) {\n@@ -147,7 +148,7 @@ fn check_decl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx Decl, bindings:\n     }\n }\n \n-fn is_binding(cx: &LateContext, pat_id: HirId) -> bool {\n+fn is_binding(cx: &LateContext<'_, '_>, pat_id: HirId) -> bool {\n     let var_ty = cx.tables.node_id_to_type(pat_id);\n     match var_ty.sty {\n         ty::TyAdt(..) => false,\n@@ -302,7 +303,7 @@ fn lint_shadow<'a, 'tcx: 'a>(\n }\n \n fn check_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, bindings: &mut Vec<(Name, Span)>) {\n-    if in_external_macro(cx, expr.span) {\n+    if in_external_macro(cx.sess(), expr.span) {\n         return;\n     }\n     match expr.node {"}, {"sha": "a13f864c5ce7debea72e0c385d1f92c84de45c9e", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,5 +1,6 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::codemap::Spanned;\n use crate::utils::SpanlessEq;\n use crate::utils::{get_parent_expr, is_allowed, match_type, paths, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n@@ -116,11 +117,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n     }\n }\n \n-fn is_string(cx: &LateContext, e: &Expr) -> bool {\n+fn is_string(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n     match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(e)), &paths::STRING)\n }\n \n-fn is_add(cx: &LateContext, src: &Expr, target: &Expr) -> bool {\n+fn is_add(cx: &LateContext<'_, '_>, src: &Expr, target: &Expr) -> bool {\n     match src.node {\n         ExprKind::Binary(Spanned { node: BinOpKind::Add, .. }, ref left, _) => SpanlessEq::new(cx).eq_expr(target, left),\n         ExprKind::Block(ref block, _) => {"}, {"sha": "b0a8a2d00617cff2a85fab7cf07f85dbbe5c6de6", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use syntax::ast;\n@@ -161,7 +163,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n }\n \n fn check_binop<'a>(\n-    cx: &LateContext,\n+    cx: &LateContext<'_, '_>,\n     expr: &hir::Expr,\n     binop: hir::BinOpKind,\n     traits: &[&'a str],"}, {"sha": "38369d05676ca4501dda009231ef92dccacbf784", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,5 +1,8 @@\n+use matches::matches;\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty;\n use crate::utils::{differing_macro_contexts, match_type, paths, snippet, span_lint_and_then, walk_ptrs_ty, SpanlessEq};\n use crate::utils::sugg::Sugg;\n@@ -57,7 +60,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Swap {\n }\n \n /// Implementation of the `MANUAL_SWAP` lint.\n-fn check_manual_swap(cx: &LateContext, block: &Block) {\n+fn check_manual_swap(cx: &LateContext<'_, '_>, block: &Block) {\n     for w in block.stmts.windows(3) {\n         if_chain! {\n             // let t = foo();\n@@ -81,7 +84,7 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n             if SpanlessEq::new(cx).ignore_fn().eq_expr(rhs1, lhs2);\n             then {\n                 fn check_for_slice<'a>(\n-                    cx: &LateContext,\n+                    cx: &LateContext<'_, '_>,\n                     lhs1: &'a Expr,\n                     lhs2: &'a Expr,\n                 ) -> Option<(&'a Expr, &'a Expr, &'a Expr)> {\n@@ -142,7 +145,7 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n }\n \n /// Implementation of the `ALMOST_SWAPPED` lint.\n-fn check_suspicious_swap(cx: &LateContext, block: &Block) {\n+fn check_suspicious_swap(cx: &LateContext<'_, '_>, block: &Block) {\n     for w in block.stmts.windows(2) {\n         if_chain! {\n             if let StmtKind::Semi(ref first, _) = w[0].node;"}, {"sha": "56e705ad0a7217143029d42ff29015f1d4a80ceb", "filename": "clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::{Expr, ExprKind};\n use crate::utils::is_adjusted;\n use crate::utils::span_lint;"}, {"sha": "403aeb47402077d143d7f28a1a3009a1d44f8f77", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::{self, Ty};\n use rustc::hir::*;\n use std::borrow::Cow;\n@@ -452,7 +454,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n /// the type's `ToString` implementation. In weird cases it could lead to types\n /// with invalid `'_`\n /// lifetime, but it should be rare.\n-fn get_type_snippet(cx: &LateContext, path: &QPath, to_ref_ty: Ty) -> String {\n+fn get_type_snippet(cx: &LateContext<'_, '_>, path: &QPath, to_ref_ty: Ty<'_>) -> String {\n     let seg = last_path_segment(path);\n     if_chain! {\n         if let Some(ref params) = seg.args;"}, {"sha": "6a048b1921384b87af6f201cd32d1e132233b2a2", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,9 +1,12 @@\n use std::cmp;\n \n+use matches::matches;\n use rustc::hir::*;\n use rustc::hir::map::*;\n use rustc::hir::intravisit::FnKind;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::TypeVariants;\n use rustc::session::config::Config as SessionConfig;\n use rustc_target::spec::abi::Abi;\n@@ -28,6 +31,12 @@ use crate::utils::{in_macro, is_copy, is_self, span_lint_and_sugg, snippet};\n /// The configuration option `trivial_copy_size_limit` can be set to override\n /// this limit for a project.\n ///\n+/// This lint attempts to allow passing arguments by reference if a reference\n+/// to that argument is returned. This is implemented by comparing the lifetime\n+/// of the argument and return value for equality. However, this can cause\n+/// false positives in cases involving multiple lifetimes that are bounded by\n+/// each other.\n+///\n /// **Example:**\n /// ```rust\n /// fn foo(v: &u32) {\n@@ -112,14 +121,24 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TriviallyCopyPassByRef {\n         let fn_sig = cx.tcx.fn_sig(fn_def_id);\n         let fn_sig = cx.tcx.erase_late_bound_regions(&fn_sig);\n \n+        // Use lifetimes to determine if we're returning a reference to the\n+        // argument. In that case we can't switch to pass-by-value as the\n+        // argument will not live long enough.\n+        let output_lt = if let TypeVariants::TyRef(output_lt, _, _) = fn_sig.output().sty {\n+            Some(output_lt)\n+        } else {\n+            None\n+        };\n+\n         for ((input, &ty), arg) in decl.inputs.iter().zip(fn_sig.inputs()).zip(&body.arguments) {\n             // All spans generated from a proc-macro invocation are the same...\n             if span == input.span {\n                 return;\n             }\n \n             if_chain! {\n-                if let TypeVariants::TyRef(_, ty, Mutability::MutImmutable) = ty.sty;\n+                if let TypeVariants::TyRef(input_lt, ty, Mutability::MutImmutable) = ty.sty;\n+                if Some(input_lt) != output_lt;\n                 if is_copy(cx, ty);\n                 if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n                 if size <= self.limit;"}, {"sha": "d016afb4908cdcc8d0525119e26205e5b37150e0", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -3,6 +3,8 @@ use rustc::hir;\n use rustc::hir::*;\n use rustc::hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::{self, Ty, TyCtxt, TypeckTables};\n use rustc::ty::layout::LayoutOf;\n use rustc_typeck::hir_ty_to_ty;\n@@ -12,7 +14,7 @@ use std::borrow::Cow;\n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::codemap::Span;\n use syntax::errors::DiagnosticBuilder;\n-use crate::utils::{comparisons, differing_macro_contexts, higher, in_constant, in_external_macro, in_macro, last_path_segment, match_def_path, match_path,\n+use crate::utils::{comparisons, differing_macro_contexts, higher, in_constant, in_macro, last_path_segment, match_def_path, match_path,\n             match_type, multispan_sugg, opt_def_id, same_tys, snippet, snippet_opt, span_help_and_lint, span_lint,\n             span_lint_and_sugg, span_lint_and_then, clip, unsext, sext, int_bits};\n use crate::utils::paths;\n@@ -136,7 +138,7 @@ impl LintPass for TypePass {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypePass {\n-    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, _: &Body, _: Span, id: NodeId) {\n+    fn check_fn(&mut self, cx: &LateContext<'_, '_>, _: FnKind<'_>, decl: &FnDecl, _: &Body, _: Span, id: NodeId) {\n         // skip trait implementations, see #605\n         if let Some(map::NodeItem(item)) = cx.tcx.hir.find(cx.tcx.hir.get_parent(id)) {\n             if let ItemKind::Impl(_, _, _, _, Some(..), _, _) = item.node {\n@@ -147,26 +149,26 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypePass {\n         check_fn_decl(cx, decl);\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext, field: &StructField) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'_, '_>, field: &StructField) {\n         check_ty(cx, &field.ty, false);\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, item: &TraitItem) {\n         match item.node {\n             TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => check_ty(cx, ty, false),\n             TraitItemKind::Method(ref sig, _) => check_fn_decl(cx, &sig.decl),\n             _ => (),\n         }\n     }\n \n-    fn check_local(&mut self, cx: &LateContext, local: &Local) {\n+    fn check_local(&mut self, cx: &LateContext<'_, '_>, local: &Local) {\n         if let Some(ref ty) = local.ty {\n             check_ty(cx, ty, true);\n         }\n     }\n }\n \n-fn check_fn_decl(cx: &LateContext, decl: &FnDecl) {\n+fn check_fn_decl(cx: &LateContext<'_, '_>, decl: &FnDecl) {\n     for input in &decl.inputs {\n         check_ty(cx, input, false);\n     }\n@@ -177,7 +179,7 @@ fn check_fn_decl(cx: &LateContext, decl: &FnDecl) {\n }\n \n /// Check if `qpath` has last segment with type parameter matching `path`\n-fn match_type_parameter(cx: &LateContext, qpath: &QPath, path: &[&str]) -> bool {\n+fn match_type_parameter(cx: &LateContext<'_, '_>, qpath: &QPath, path: &[&str]) -> bool {\n     let last = last_path_segment(qpath);\n     if_chain! {\n         if let Some(ref params) = last.args;\n@@ -201,7 +203,7 @@ fn match_type_parameter(cx: &LateContext, qpath: &QPath, path: &[&str]) -> bool\n ///\n /// The parameter `is_local` distinguishes the context of the type; types from\n /// local bindings should only be checked for the `BORROWED_BOX` lint.\n-fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n+fn check_ty(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool) {\n     if in_macro(ast_ty.span) {\n         return;\n     }\n@@ -292,7 +294,7 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n     }\n }\n \n-fn check_ty_rptr(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool, lt: &Lifetime, mut_ty: &MutTy) {\n+fn check_ty_rptr(cx: &LateContext<'_, '_>, ast_ty: &hir::Ty, is_local: bool, lt: &Lifetime, mut_ty: &MutTy) {\n     match mut_ty.ty.node {\n         TyKind::Path(ref qpath) => {\n             let hir_id = cx.tcx.hir.node_to_hir_id(mut_ty.ty.id);\n@@ -376,10 +378,10 @@ declare_clippy_lint! {\n     \"creating a let binding to a value of unit type, which usually can't be used afterwards\"\n }\n \n-fn check_let_unit(cx: &LateContext, decl: &Decl) {\n+fn check_let_unit(cx: &LateContext<'_, '_>, decl: &Decl) {\n     if let DeclKind::Local(ref local) = decl.node {\n         if is_unit(cx.tables.pat_ty(&local.pat)) {\n-            if in_external_macro(cx, decl.span) || in_macro(local.pat.span) {\n+            if in_external_macro(cx.sess(), decl.span) || in_macro(local.pat.span) {\n                 return;\n             }\n             if higher::is_from_for_desugar(decl) {\n@@ -546,7 +548,7 @@ fn is_questionmark_desugar_marked_call(expr: &Expr) -> bool {\n     }\n }\n \n-fn is_unit(ty: Ty) -> bool {\n+fn is_unit(ty: Ty<'_>) -> bool {\n     match ty.sty {\n         ty::TyTuple(slice) if slice.is_empty() => true,\n         _ => false,\n@@ -751,7 +753,7 @@ declare_clippy_lint! {\n \n /// Returns the size in bits of an integral type.\n /// Will return 0 if the type is not an int or uint variant\n-fn int_ty_to_nbits(typ: Ty, tcx: TyCtxt) -> u64 {\n+fn int_ty_to_nbits(typ: Ty<'_>, tcx: TyCtxt<'_, '_, '_>) -> u64 {\n     match typ.sty {\n         ty::TyInt(i) => match i {\n             IntTy::Isize => tcx.data_layout.pointer_size.bits(),\n@@ -773,14 +775,14 @@ fn int_ty_to_nbits(typ: Ty, tcx: TyCtxt) -> u64 {\n     }\n }\n \n-fn is_isize_or_usize(typ: Ty) -> bool {\n+fn is_isize_or_usize(typ: Ty<'_>) -> bool {\n     match typ.sty {\n         ty::TyInt(IntTy::Isize) | ty::TyUint(UintTy::Usize) => true,\n         _ => false,\n     }\n }\n \n-fn span_precision_loss_lint(cx: &LateContext, expr: &Expr, cast_from: Ty, cast_to_f64: bool) {\n+fn span_precision_loss_lint(cx: &LateContext<'_, '_>, expr: &Expr, cast_from: Ty<'_>, cast_to_f64: bool) {\n     let mantissa_nbits = if cast_to_f64 { 52 } else { 23 };\n     let arch_dependent = is_isize_or_usize(cast_from) && cast_to_f64;\n     let arch_dependent_str = \"on targets with 64-bit wide pointers \";\n@@ -820,7 +822,7 @@ fn should_strip_parens(op: &Expr, snip: &str) -> bool {\n     false\n }\n \n-fn span_lossless_lint(cx: &LateContext, expr: &Expr, op: &Expr, cast_from: Ty, cast_to: Ty) {\n+fn span_lossless_lint(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     // Do not suggest using From in consts/statics until it is valid to do so (see #2267).\n     if in_constant(cx, expr.id) { return }\n     // The suggestion is to use a function call, so if the original expression\n@@ -852,7 +854,7 @@ enum ArchSuffix {\n     None,\n }\n \n-fn check_truncation_and_wrapping(cx: &LateContext, expr: &Expr, cast_from: Ty, cast_to: Ty) {\n+fn check_truncation_and_wrapping(cx: &LateContext<'_, '_>, expr: &Expr, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     let arch_64_suffix = \" on targets with 64-bit wide pointers\";\n     let arch_32_suffix = \" on targets with 32-bit wide pointers\";\n     let cast_unsigned_to_signed = !cast_from.is_signed() && cast_to.is_signed();\n@@ -923,7 +925,7 @@ fn check_truncation_and_wrapping(cx: &LateContext, expr: &Expr, cast_from: Ty, c\n     }\n }\n \n-fn check_lossless(cx: &LateContext, expr: &Expr, op: &Expr, cast_from: Ty, cast_to: Ty) {\n+fn check_lossless(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     let cast_signed_to_unsigned = cast_from.is_signed() && !cast_to.is_signed();\n     let from_nbits = int_ty_to_nbits(cast_from, cx.tcx);\n     let to_nbits = int_ty_to_nbits(cast_to, cx.tcx);\n@@ -957,7 +959,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n                 use syntax::ast::{LitIntType, LitKind};\n                 match lit.node {\n                     LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::FloatUnsuffixed(_) => {},\n-                    _ => if cast_from.sty == cast_to.sty && !in_external_macro(cx, expr.span) {\n+                    _ => if cast_from.sty == cast_to.sty && !in_external_macro(cx.sess(), expr.span) {\n                         span_lint(\n                             cx,\n                             UNNECESSARY_CAST,\n@@ -967,7 +969,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n                     },\n                 }\n             }\n-            if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx, expr.span) {\n+            if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx.sess(), expr.span) {\n                 match (cast_from.is_integral(), cast_to.is_integral()) {\n                     (true, false) => {\n                         let from_nbits = int_ty_to_nbits(cast_from, cx.tcx);\n@@ -1181,7 +1183,7 @@ impl<'a, 'tcx> TypeComplexityPass {\n         }\n     }\n \n-    fn check_type(&self, cx: &LateContext, ty: &hir::Ty) {\n+    fn check_type(&self, cx: &LateContext<'_, '_>, ty: &hir::Ty) {\n         if in_macro(ty.span) {\n             return;\n         }\n@@ -1560,7 +1562,7 @@ impl Ord for FullInt {\n }\n \n \n-fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(FullInt, FullInt)> {\n+fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<(FullInt, FullInt)> {\n     use syntax::ast::{IntTy, UintTy};\n     use std::*;\n \n@@ -1626,7 +1628,7 @@ fn node_as_const_fullint<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr)\n     }\n }\n \n-fn err_upcast_comparison(cx: &LateContext, span: Span, expr: &Expr, always: bool) {\n+fn err_upcast_comparison(cx: &LateContext<'_, '_>, span: Span, expr: &Expr, always: bool) {\n     if let ExprKind::Cast(ref cast_val, _) = expr.node {\n         span_lint(\n             cx,\n@@ -1748,11 +1750,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n \n         fn suggestion<'a, 'tcx>(\n             cx: &LateContext<'a, 'tcx>,\n-            db: &mut DiagnosticBuilder,\n+            db: &mut DiagnosticBuilder<'_>,\n             generics_span: Span,\n             generics_suggestion_span: Span,\n-            target: &ImplicitHasherType,\n-            vis: ImplicitHasherConstructorVisitor,\n+            target: &ImplicitHasherType<'_>,\n+            vis: ImplicitHasherConstructorVisitor<'_, '_, '_>,\n         ) {\n             let generics_snip = snippet(cx, generics_span, \"\");\n             // trim `<` `>`"}, {"sha": "0549e774fb55debb70f1c4b6b9408b591c9bf808", "filename": "clippy_lints/src/unicode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funicode.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use syntax::ast::{LitKind, NodeId};\n use syntax::codemap::Span;\n@@ -93,7 +94,7 @@ fn escape<T: Iterator<Item = char>>(s: T) -> String {\n     result\n }\n \n-fn check_str(cx: &LateContext, span: Span, id: NodeId) {\n+fn check_str(cx: &LateContext<'_, '_>, span: Span, id: NodeId) {\n     let string = snippet(cx, span, \"\");\n     if string.contains('\\u{200B}') {\n         span_help_and_lint("}, {"sha": "2f8b3ab836db99ab2c6348d1675b1f922cd358e6", "filename": "clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::*;\n use syntax::codemap::Span;\n use syntax::symbol::LocalInternedString;\n@@ -34,14 +35,14 @@ impl LintPass for UnsafeNameRemoval {\n }\n \n impl EarlyLintPass for UnsafeNameRemoval {\n-    fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n         if let ItemKind::Use(ref use_tree) = item.node {\n             check_use_tree(use_tree, cx, item.span);\n         }\n     }\n }\n \n-fn check_use_tree(use_tree: &UseTree, cx: &EarlyContext, span: Span) {\n+fn check_use_tree(use_tree: &UseTree, cx: &EarlyContext<'_>, span: Span) {\n     match use_tree.kind {\n         UseTreeKind::Simple(Some(new_name), ..) => {\n             let old_name = use_tree\n@@ -62,7 +63,7 @@ fn check_use_tree(use_tree: &UseTree, cx: &EarlyContext, span: Span) {\n     }\n }\n \n-fn unsafe_to_safe_check(old_name: Ident, new_name: Ident, cx: &EarlyContext, span: Span) {\n+fn unsafe_to_safe_check(old_name: Ident, new_name: Ident, cx: &EarlyContext<'_>, span: Span) {\n     let old_str = old_name.name.as_str();\n     let new_str = new_name.name.as_str();\n     if contains_unsafe(&old_str) && !contains_unsafe(&new_str) {"}, {"sha": "a9a7e102ab274bf62554142bd40468c8f3c80926", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir;\n use crate::utils::{is_try, match_qpath, match_trait_method, paths, span_lint};\n \n@@ -38,7 +39,7 @@ impl LintPass for UnusedIoAmount {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n-    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt) {\n         let expr = match s.node {\n             hir::StmtKind::Semi(ref expr, _) | hir::StmtKind::Expr(ref expr, _) => &**expr,\n             _ => return,\n@@ -69,7 +70,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n     }\n }\n \n-fn check_method_call(cx: &LateContext, call: &hir::Expr, expr: &hir::Expr) {\n+fn check_method_call(cx: &LateContext<'_, '_>, call: &hir::Expr, expr: &hir::Expr) {\n     if let hir::ExprKind::MethodCall(ref path, _, _) = call.node {\n         let symbol = &*path.ident.as_str();\n         if match_trait_method(cx, call, &paths::IO_READ) && symbol == \"read\" {"}, {"sha": "1681a303fd37b9fd38bf53708e4ea5560e6c1bf5", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir;\n use rustc::hir::intravisit::{walk_expr, walk_fn, FnKind, NestedVisitorMap, Visitor};\n use std::collections::HashMap;"}, {"sha": "6cafcaeffe9749995d046bec79ffaebca4bcc2c5", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n \n use crate::utils::{in_macro, match_type, paths, span_lint_and_then, usage::is_potentially_mutated};\n use rustc::hir::intravisit::*;"}, {"sha": "82a571b0caf83d1ba21982ca08580f23c6a33f6e", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,8 +1,10 @@\n use crate::utils::{in_macro, span_lint_and_sugg};\n+use if_chain::if_chain;\n use rustc::hir::intravisit::{walk_path, walk_ty, NestedVisitorMap, Visitor};\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::ty;\n+use rustc::{declare_lint, lint_array};\n use syntax::ast::NodeId;\n use syntax_pos::symbol::keywords::SelfType;\n "}, {"sha": "4310325475a3e49ca643b5b5a1083a9920712816", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -4,6 +4,7 @@\n #![allow(print_stdout, use_debug)]\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir;\n use rustc::hir::{Expr, ExprKind, QPath, TyKind, Pat, PatKind, BindingAnnotation, StmtKind, DeclKind, Stmt};\n use rustc::hir::intravisit::{NestedVisitorMap, Visitor};"}, {"sha": "a27013344d8e9586f8eba8a1b1dcd8e34820a0c6", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -2,6 +2,7 @@\n \n #![deny(missing_docs_in_private_items)]\n \n+use lazy_static::lazy_static;\n use std::{env, fmt, fs, io, path};\n use std::io::Read;\n use syntax::{ast, codemap};\n@@ -51,7 +52,7 @@ pub enum Error {\n }\n \n impl fmt::Display for Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n         match *self {\n             Error::Io(ref err) => err.fmt(f),\n             Error::Toml(ref err) => err.fmt(f),\n@@ -86,10 +87,10 @@ macro_rules! define_Conf {\n         //\n         #[allow(rust_2018_idioms)]\n         mod helpers {\n+            use serde_derive::Deserialize;\n             /// Type used to store lint configuration.\n             #[derive(Deserialize)]\n-            #[serde(rename_all=\"kebab-case\")]\n-            #[serde(deny_unknown_fields)]\n+            #[serde(rename_all=\"kebab-case\", deny_unknown_fields)]\n             pub struct Conf {\n                 $(#[$doc] #[serde(default=$rust_name_str)] #[serde(with=$rust_name_str)]\n                           pub $rust_name: define_Conf!(TY $($ty)+),)+"}, {"sha": "3931f6c55f9ed0b9bda60de4be8d1d00602152db", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -3,6 +3,7 @@\n \n #![deny(missing_docs_in_private_items)]\n \n+use if_chain::if_chain;\n use rustc::{hir, ty};\n use rustc::lint::LateContext;\n use syntax::ast;\n@@ -211,7 +212,7 @@ pub enum VecArgs<'a> {\n \n /// Returns the arguments of the `vec!` macro if this expression was expanded\n /// from `vec!`.\n-pub fn vec_macro<'e>(cx: &LateContext, expr: &'e hir::Expr) -> Option<VecArgs<'e>> {\n+pub fn vec_macro<'e>(cx: &LateContext<'_, '_>, expr: &'e hir::Expr) -> Option<VecArgs<'e>> {\n     if_chain! {\n         if let hir::ExprKind::Call(ref fun, ref args) = expr.node;\n         if let hir::ExprKind::Path(ref path) = fun.node;"}, {"sha": "b6c241a682533d9021cf6d6dbfd5ef73e4db5451", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -3,6 +3,7 @@\n //! checks for attributes\n \n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir;\n use rustc::hir::print;\n use syntax::ast::Attribute;\n@@ -70,6 +71,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             },\n             hir::ImplItemKind::Method(..) => println!(\"method\"),\n             hir::ImplItemKind::Type(_) => println!(\"associated type\"),\n+            hir::ImplItemKind::Existential(_) => println!(\"existential type\"),\n         }\n     }\n     // fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx\n@@ -139,7 +141,7 @@ fn has_attr(attrs: &[Attribute]) -> bool {\n     get_attr(attrs, \"dump\").count() > 0\n }\n \n-fn print_decl(cx: &LateContext, decl: &hir::Decl) {\n+fn print_decl(cx: &LateContext<'_, '_>, decl: &hir::Decl) {\n     match decl.node {\n         hir::DeclKind::Local(ref local) => {\n             println!(\"local variable of type {}\", cx.tables.node_id_to_type(local.hir_id));\n@@ -154,7 +156,7 @@ fn print_decl(cx: &LateContext, decl: &hir::Decl) {\n     }\n }\n \n-fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n+fn print_expr(cx: &LateContext<'_, '_>, expr: &hir::Expr, indent: usize) {\n     let ind = \"  \".repeat(indent);\n     println!(\"{}+\", ind);\n     println!(\"{}ty: {}\", ind, cx.tables.expr_ty(expr));\n@@ -340,7 +342,7 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n     }\n }\n \n-fn print_item(cx: &LateContext, item: &hir::Item) {\n+fn print_item(cx: &LateContext<'_, '_>, item: &hir::Item) {\n     let did = cx.tcx.hir.local_def_id(item.id);\n     println!(\"item `{}`\", item.name);\n     match item.vis.node {\n@@ -412,7 +414,7 @@ fn print_item(cx: &LateContext, item: &hir::Item) {\n     }\n }\n \n-fn print_pat(cx: &LateContext, pat: &hir::Pat, indent: usize) {\n+fn print_pat(cx: &LateContext<'_, '_>, pat: &hir::Pat, indent: usize) {\n     let ind = \"  \".repeat(indent);\n     println!(\"{}+\", ind);\n     match pat.node {"}, {"sha": "32aee09917717f48df24064b8028b263d03a8cc6", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,5 @@\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n use rustc::hir::*;\n use rustc::hir;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n@@ -63,7 +64,7 @@ impl LintPass for Clippy {\n }\n \n impl EarlyLintPass for Clippy {\n-    fn check_crate(&mut self, cx: &EarlyContext, krate: &AstCrate) {\n+    fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &AstCrate) {\n         if let Some(utils) = krate\n             .module\n             .items"}, {"sha": "0b2103ca7eaa505ab71a1ebe88189fe6252b4c95", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 31, "deletions": 58, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,4 +1,6 @@\n use crate::reexport::*;\n+use matches::matches;\n+use if_chain::if_chain;\n use rustc::hir;\n use rustc::hir::*;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n@@ -17,7 +19,7 @@ use std::str::FromStr;\n use std::rc::Rc;\n use syntax::ast::{self, LitKind};\n use syntax::attr;\n-use syntax::codemap::{CompilerDesugaringKind, ExpnFormat, ExpnInfo, Span, DUMMY_SP};\n+use syntax::codemap::{CompilerDesugaringKind, ExpnFormat, Span, DUMMY_SP};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n@@ -46,7 +48,7 @@ pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n     rhs.ctxt() != lhs.ctxt()\n }\n \n-pub fn in_constant(cx: &LateContext, id: NodeId) -> bool {\n+pub fn in_constant(cx: &LateContext<'_, '_>, id: NodeId) -> bool {\n     let parent_id = cx.tcx.hir.get_parent(id);\n     match cx.tcx.hir.body_owner_kind(parent_id) {\n         hir::BodyOwnerKind::Fn => false,\n@@ -75,36 +77,6 @@ pub fn is_range_expression(span: Span) -> bool {\n     })\n }\n \n-/// Returns true if the macro that expanded the crate was outside of the\n-/// current crate or was a\n-/// compiler plugin.\n-pub fn in_external_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n-    /// Invokes `in_macro` with the expansion info of the given span slightly\n-    /// heavy, try to use\n-    /// this after other checks have already happened.\n-    fn in_macro_ext<'a, T: LintContext<'a>>(cx: &T, info: &ExpnInfo) -> bool {\n-        // no ExpnInfo = no macro\n-        if let ExpnFormat::MacroAttribute(..) = info.format {\n-            // these are all plugins\n-            return true;\n-        }\n-        // no span for the callee = external macro\n-        info.def_site.map_or(true, |span| {\n-            // no snippet = external macro or compiler-builtin expansion\n-            cx.sess()\n-                .codemap()\n-                .span_to_snippet(span)\n-                .ok()\n-                .map_or(true, |code| !code.starts_with(\"macro_rules\"))\n-        })\n-    }\n-\n-    span.ctxt()\n-        .outer()\n-        .expn_info()\n-        .map_or(false, |info| in_macro_ext(cx, &info))\n-}\n-\n /// Check if a `DefId`'s path matches the given absolute type path usage.\n ///\n /// # Examples\n@@ -113,7 +85,7 @@ pub fn in_external_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n /// ```\n ///\n /// See also the `paths` module.\n-pub fn match_def_path(tcx: TyCtxt, def_id: DefId, path: &[&str]) -> bool {\n+pub fn match_def_path(tcx: TyCtxt<'_, '_, '_>, def_id: DefId, path: &[&str]) -> bool {\n     use syntax::symbol;\n \n     struct AbsolutePathBuffer {\n@@ -143,15 +115,15 @@ pub fn match_def_path(tcx: TyCtxt, def_id: DefId, path: &[&str]) -> bool {\n }\n \n /// Check if type is struct, enum or union type with given def path.\n-pub fn match_type(cx: &LateContext, ty: Ty, path: &[&str]) -> bool {\n+pub fn match_type(cx: &LateContext<'_, '_>, ty: Ty<'_>, path: &[&str]) -> bool {\n     match ty.sty {\n         ty::TyAdt(adt, _) => match_def_path(cx.tcx, adt.did, path),\n         _ => false,\n     }\n }\n \n /// Check if the method call given in `expr` belongs to given type.\n-pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n+pub fn match_impl_method(cx: &LateContext<'_, '_>, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = cx.tables.type_dependent_defs()[expr.hir_id];\n     let trt_id = cx.tcx.impl_of_method(method_call.def_id());\n     if let Some(trt_id) = trt_id {\n@@ -162,7 +134,7 @@ pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n }\n \n /// Check if the method call given in `expr` belongs to given trait.\n-pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n+pub fn match_trait_method(cx: &LateContext<'_, '_>, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = cx.tables.type_dependent_defs()[expr.hir_id];\n     let trt_id = cx.tcx.trait_of_item(method_call.def_id());\n     if let Some(trt_id) = trt_id {\n@@ -242,7 +214,7 @@ pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n }\n \n /// Get the definition associated to a path.\n-pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<def::Def> {\n+pub fn path_to_def(cx: &LateContext<'_, '_>, path: &[&str]) -> Option<def::Def> {\n     let crates = cx.tcx.crates();\n     let krate = crates\n         .iter()\n@@ -278,7 +250,7 @@ pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<def::Def> {\n }\n \n /// Convenience function to get the `DefId` of a trait by path.\n-pub fn get_trait_def_id(cx: &LateContext, path: &[&str]) -> Option<DefId> {\n+pub fn get_trait_def_id(cx: &LateContext<'_, '_>, path: &[&str]) -> Option<DefId> {\n     let def = match path_to_def(cx, path) {\n         Some(def) => def,\n         None => return None,\n@@ -306,7 +278,7 @@ pub fn implements_trait<'a, 'tcx>(\n }\n \n /// Check whether this type implements Drop.\n-pub fn has_drop(cx: &LateContext, expr: &Expr) -> bool {\n+pub fn has_drop(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     let struct_ty = cx.tables.expr_ty(expr);\n     match struct_ty.ty_adt_def() {\n         Some(def) => def.has_dtor(cx.tcx),\n@@ -315,7 +287,7 @@ pub fn has_drop(cx: &LateContext, expr: &Expr) -> bool {\n }\n \n /// Resolve the definition of a node from its `HirId`.\n-pub fn resolve_node(cx: &LateContext, qpath: &QPath, id: HirId) -> def::Def {\n+pub fn resolve_node(cx: &LateContext<'_, '_>, qpath: &QPath, id: HirId) -> def::Def {\n     cx.tables.qpath_def(qpath, id)\n }\n \n@@ -350,7 +322,7 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n \n \n /// Get the name of the item the expression is in, if available.\n-pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n+pub fn get_item_name(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<Name> {\n     let parent_id = cx.tcx.hir.get_parent(expr.id);\n     match cx.tcx.hir.find(parent_id) {\n         Some(Node::NodeItem(&Item { ref name, .. })) => Some(*name),\n@@ -456,13 +428,13 @@ pub fn expr_block<'a, 'b, T: LintContext<'b>>(\n \n /// Trim indentation from a multiline string with possibility of ignoring the\n /// first line.\n-pub fn trim_multiline(s: Cow<str>, ignore_first: bool) -> Cow<str> {\n+pub fn trim_multiline(s: Cow<'_, str>, ignore_first: bool) -> Cow<'_, str> {\n     let s_space = trim_multiline_inner(s, ignore_first, ' ');\n     let s_tab = trim_multiline_inner(s_space, ignore_first, '\\t');\n     trim_multiline_inner(s_tab, ignore_first, ' ')\n }\n \n-fn trim_multiline_inner(s: Cow<str>, ignore_first: bool, ch: char) -> Cow<str> {\n+fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, ch: char) -> Cow<'_, str> {\n     let x = s.lines()\n         .skip(ignore_first as usize)\n         .filter_map(|l| {\n@@ -500,7 +472,7 @@ fn trim_multiline_inner(s: Cow<str>, ignore_first: bool, ch: char) -> Cow<str> {\n }\n \n /// Get a parent expressions if any \u2013 this is useful to constrain a lint.\n-pub fn get_parent_expr<'c>(cx: &'c LateContext, e: &Expr) -> Option<&'c Expr> {\n+pub fn get_parent_expr<'c>(cx: &'c LateContext<'_, '_>, e: &Expr) -> Option<&'c Expr> {\n     let map = &cx.tcx.hir;\n     let node_id: NodeId = e.id;\n     let parent_id: NodeId = map.get_parent_node(node_id);\n@@ -640,7 +612,7 @@ pub fn span_lint_and_sugg<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n /// appear once per\n /// replacement. In human-readable format though, it only appears once before\n /// the whole suggestion.\n-pub fn multispan_sugg<I>(db: &mut DiagnosticBuilder, help_msg: String, sugg: I)\n+pub fn multispan_sugg<I>(db: &mut DiagnosticBuilder<'_>, help_msg: String, sugg: I)\n where\n     I: IntoIterator<Item = (Span, String)>,\n {\n@@ -673,7 +645,7 @@ pub fn walk_ptrs_hir_ty(ty: &hir::Ty) -> &hir::Ty {\n }\n \n /// Return the base type for references and raw pointers.\n-pub fn walk_ptrs_ty(ty: Ty) -> Ty {\n+pub fn walk_ptrs_ty(ty: Ty<'_>) -> Ty<'_> {\n     match ty.sty {\n         ty::TyRef(_, ty, _) => walk_ptrs_ty(ty),\n         _ => ty,\n@@ -682,8 +654,8 @@ pub fn walk_ptrs_ty(ty: Ty) -> Ty {\n \n /// Return the base type for references and raw pointers, and count reference\n /// depth.\n-pub fn walk_ptrs_ty_depth(ty: Ty) -> (Ty, usize) {\n-    fn inner(ty: Ty, depth: usize) -> (Ty, usize) {\n+pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n+    fn inner(ty: Ty<'_>, depth: usize) -> (Ty<'_>, usize) {\n         match ty.sty {\n             ty::TyRef(_, ty, _) => inner(ty, depth + 1),\n             _ => (ty, depth),\n@@ -703,7 +675,7 @@ pub fn is_integer_literal(expr: &Expr, value: u128) -> bool {\n     false\n }\n \n-pub fn is_adjusted(cx: &LateContext, e: &Expr) -> bool {\n+pub fn is_adjusted(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n     cx.tables.adjustments().get(e.hir_id).is_some()\n }\n \n@@ -896,15 +868,15 @@ pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n }\n \n /// Return whether a pattern is refutable.\n-pub fn is_refutable(cx: &LateContext, pat: &Pat) -> bool {\n-    fn is_enum_variant(cx: &LateContext, qpath: &QPath, id: HirId) -> bool {\n+pub fn is_refutable(cx: &LateContext<'_, '_>, pat: &Pat) -> bool {\n+    fn is_enum_variant(cx: &LateContext<'_, '_>, qpath: &QPath, id: HirId) -> bool {\n         matches!(\n             cx.tables.qpath_def(qpath, id),\n             def::Def::Variant(..) | def::Def::VariantCtor(..)\n         )\n     }\n \n-    fn are_refutable<'a, I: Iterator<Item = &'a Pat>>(cx: &LateContext, mut i: I) -> bool {\n+    fn are_refutable<'a, I: Iterator<Item = &'a Pat>>(cx: &LateContext<'_, '_>, mut i: I) -> bool {\n         i.any(|pat| is_refutable(cx, pat))\n     }\n \n@@ -982,6 +954,7 @@ pub fn opt_def_id(def: Def) -> Option<DefId> {\n         Def::AssociatedConst(id) |\n         Def::Macro(id, ..) |\n         Def::Existential(id) |\n+        Def::AssociatedExistential(id) |\n         Def::GlobalAsm(id) => Some(id),\n \n         Def::Upvar(..) | Def::Local(_) | Def::Label(..) | Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => None,\n@@ -1062,7 +1035,7 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n /// Returns true if the lint is allowed in the current context\n ///\n /// Useful for skipping long running code when it's unnecessary\n-pub fn is_allowed(cx: &LateContext, lint: &'static Lint, id: NodeId) -> bool {\n+pub fn is_allowed(cx: &LateContext<'_, '_>, lint: &'static Lint, id: NodeId) -> bool {\n     cx.tcx.lint_level_at_node(lint, id).0 == Level::Allow\n }\n \n@@ -1082,24 +1055,24 @@ pub fn get_arg_ident(pat: &Pat) -> Option<ast::Ident> {\n     }\n }\n \n-pub fn int_bits(tcx: TyCtxt, ity: ast::IntTy) -> u64 {\n+pub fn int_bits(tcx: TyCtxt<'_, '_, '_>, ity: ast::IntTy) -> u64 {\n     layout::Integer::from_attr(tcx, attr::IntType::SignedInt(ity)).size().bits()\n }\n \n /// Turn a constant int byte representation into an i128\n-pub fn sext(tcx: TyCtxt, u: u128, ity: ast::IntTy) -> i128 {\n+pub fn sext(tcx: TyCtxt<'_, '_, '_>, u: u128, ity: ast::IntTy) -> i128 {\n     let amt = 128 - int_bits(tcx, ity);\n     ((u as i128) << amt) >> amt\n }\n \n /// clip unused bytes\n-pub fn unsext(tcx: TyCtxt, u: i128, ity: ast::IntTy) -> u128 {\n+pub fn unsext(tcx: TyCtxt<'_, '_, '_>, u: i128, ity: ast::IntTy) -> u128 {\n     let amt = 128 - int_bits(tcx, ity);\n     ((u as u128) << amt) >> amt\n }\n \n /// clip unused bytes\n-pub fn clip(tcx: TyCtxt, u: u128, ity: ast::UintTy) -> u128 {\n+pub fn clip(tcx: TyCtxt<'_, '_, '_>, u: u128, ity: ast::UintTy) -> u128 {\n     let bits = layout::Integer::from_attr(tcx, attr::IntType::UnsignedInt(ity)).size().bits();\n     let amt = 128 - bits;\n     (u << amt) >> amt\n@@ -1138,7 +1111,7 @@ pub fn without_block_comments(lines: Vec<&str>) -> Vec<&str> {\n     without\n }\n \n-pub fn any_parent_is_automatically_derived(tcx: TyCtxt, node: NodeId) -> bool {\n+pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_, '_, '_>, node: NodeId) -> bool {\n     let map = &tcx.hir;\n     let mut prev_enclosing_node = None;\n     let mut enclosing_node = node;"}, {"sha": "1a20eb0101538b17533cd0916a2445b4fb25bdf0", "filename": "clippy_lints/src/utils/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fptr.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -7,7 +7,7 @@ use syntax::codemap::Span;\n use crate::utils::{get_pat_name, match_var, snippet};\n \n pub fn get_spans(\n-    cx: &LateContext,\n+    cx: &LateContext<'_, '_>,\n     opt_body_id: Option<BodyId>,\n     idx: usize,\n     replacements: &'static [(&'static str, &'static str)],"}, {"sha": "91fd5ec874afda3ffabb3bd402d2ba87f8793aab", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -3,6 +3,7 @@\n // currently ignores lifetimes and generics\n #![allow(use_self)]\n \n+use matches::matches;\n use rustc::hir;\n use rustc::lint::{EarlyContext, LateContext, LintContext};\n use rustc_errors;\n@@ -31,8 +32,8 @@ pub enum Sugg<'a> {\n /// Literal constant `1`, for convenience.\n pub const ONE: Sugg<'static> = Sugg::NonParen(Cow::Borrowed(\"1\"));\n \n-impl<'a> Display for Sugg<'a> {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {\n+impl Display for Sugg<'_> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n         match *self {\n             Sugg::NonParen(ref s) | Sugg::MaybeParen(ref s) | Sugg::BinOp(_, ref s) => s.fmt(f),\n         }\n@@ -42,7 +43,7 @@ impl<'a> Display for Sugg<'a> {\n #[allow(wrong_self_convention)] // ok, because of the function `as_ty` method\n impl<'a> Sugg<'a> {\n     /// Prepare a suggestion from an expression.\n-    pub fn hir_opt(cx: &LateContext, expr: &hir::Expr) -> Option<Self> {\n+    pub fn hir_opt(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> Option<Self> {\n         snippet_opt(cx, expr.span).map(|snippet| {\n             let snippet = Cow::Owned(snippet);\n             match expr.node {\n@@ -81,12 +82,12 @@ impl<'a> Sugg<'a> {\n \n     /// Convenience function around `hir_opt` for suggestions with a default\n     /// text.\n-    pub fn hir(cx: &LateContext, expr: &hir::Expr, default: &'a str) -> Self {\n+    pub fn hir(cx: &LateContext<'_, '_>, expr: &hir::Expr, default: &'a str) -> Self {\n         Self::hir_opt(cx, expr).unwrap_or_else(|| Sugg::NonParen(Cow::Borrowed(default)))\n     }\n \n     /// Prepare a suggestion from an expression.\n-    pub fn ast(cx: &EarlyContext, expr: &ast::Expr, default: &'a str) -> Self {\n+    pub fn ast(cx: &EarlyContext<'_>, expr: &ast::Expr, default: &'a str) -> Self {\n         use syntax::ast::RangeLimits;\n \n         let snippet = snippet(cx, expr.span, default);\n@@ -240,7 +241,7 @@ impl<T> ParenHelper<T> {\n }\n \n impl<T: Display> Display for ParenHelper<T> {\n-    fn fmt(&self, f: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n         if self.paren {\n             write!(f, \"({})\", self.wrapped)\n         } else {\n@@ -254,7 +255,7 @@ impl<T: Display> Display for ParenHelper<T> {\n /// For convenience, the operator is taken as a string because all unary\n /// operators have the same\n /// precedence.\n-pub fn make_unop(op: &str, expr: Sugg) -> Sugg<'static> {\n+pub fn make_unop(op: &str, expr: Sugg<'_>) -> Sugg<'static> {\n     Sugg::MaybeParen(format!(\"{}{}\", op, expr.maybe_par()).into())\n }\n \n@@ -263,7 +264,7 @@ pub fn make_unop(op: &str, expr: Sugg) -> Sugg<'static> {\n /// Precedence of shift operator relative to other arithmetic operation is\n /// often confusing so\n /// parenthesis will always be added for a mix of these.\n-pub fn make_assoc(op: AssocOp, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n+pub fn make_assoc(op: AssocOp, lhs: &Sugg<'_>, rhs: &Sugg<'_>) -> Sugg<'static> {\n     /// Whether the operator is a shift operator `<<` or `>>`.\n     fn is_shift(op: &AssocOp) -> bool {\n         matches!(*op, AssocOp::ShiftLeft | AssocOp::ShiftRight)\n@@ -334,7 +335,7 @@ pub fn make_assoc(op: AssocOp, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n }\n \n /// Convinience wrapper arround `make_assoc` and `AssocOp::from_ast_binop`.\n-pub fn make_binop(op: ast::BinOpKind, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n+pub fn make_binop(op: ast::BinOpKind, lhs: &Sugg<'_>, rhs: &Sugg<'_>) -> Sugg<'static> {\n     make_assoc(AssocOp::from_ast_binop(op), lhs, rhs)\n }\n "}, {"sha": "43e492bfb4e40f70b6fe7a4d1f796deeb6538b70", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -44,7 +44,7 @@ struct MutVarsDelegate {\n }\n \n impl<'tcx> MutVarsDelegate {\n-    fn update(&mut self, cat: &'tcx Categorization) {\n+    fn update(&mut self, cat: &'tcx Categorization<'_>) {\n         match *cat {\n             Categorization::Local(id) => {\n                 self.used_mutably.insert(id);\n@@ -68,7 +68,7 @@ impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n \n     fn consume_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: ConsumeMode) {}\n \n-    fn borrow(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region, bk: ty::BorrowKind, _: LoanCause) {\n+    fn borrow(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, bk: ty::BorrowKind, _: LoanCause) {\n         if let ty::BorrowKind::MutBorrow = bk {\n             self.update(&cmt.cat)\n         }"}, {"sha": "cea3307a8273fcc0280da7da664879b64ee3cf88", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,5 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::ty::{self, Ty};\n use syntax::codemap::Span;\n use crate::utils::{higher, is_copy, snippet, span_lint_and_sugg};\n@@ -92,7 +94,7 @@ fn check_vec_macro<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, vec_args: &higher::VecA\n }\n \n /// Return the item type of the vector (ie. the `T` in `Vec<T>`).\n-fn vec_type(ty: Ty) -> Ty {\n+fn vec_type(ty: Ty<'_>) -> Ty<'_> {\n     if let ty::TyAdt(_, substs) = ty.sty {\n         substs.type_at(0)\n     } else {"}, {"sha": "a019e23a3014f34821d4ac6df525515edd99cae6", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 131, "deletions": 303, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,13 +1,9 @@\n-use rustc::hir::map::Node::{NodeImplItem, NodeItem};\n-use rustc::hir::*;\n use rustc::lint::*;\n-use std::ops::Deref;\n-use syntax::ast::LitKind;\n-use syntax::ptr;\n-use syntax::symbol::LocalInternedString;\n-use syntax_pos::Span;\n-use crate::utils::{is_expn_of, match_def_path, match_path, resolve_node, span_lint, span_lint_and_sugg};\n-use crate::utils::{opt_def_id, paths, last_path_segment};\n+use rustc::{declare_lint, lint_array};\n+use syntax::ast::*;\n+use syntax::tokenstream::{ThinTokenStream, TokenStream};\n+use syntax::parse::{token, parser};\n+use crate::utils::{span_lint, span_lint_and_sugg};\n \n /// **What it does:** This lint warns when you use `println!(\"\")` to\n /// print a newline.\n@@ -171,317 +167,149 @@ impl LintPass for Pass {\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        match expr.node {\n-            // print!()\n-            ExprKind::Call(ref fun, ref args) => {\n-                if_chain! {\n-                    if let ExprKind::Path(ref qpath) = fun.node;\n-                    if let Some(fun_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id));\n-                    then {\n-                        check_print_variants(cx, expr, fun_id, args);\n-                    }\n-                }\n-            },\n-            // write!()\n-            ExprKind::MethodCall(ref fun, _, ref args) => {\n-                if fun.ident.name == \"write_fmt\" {\n-                    check_write_variants(cx, expr, args);\n-                }\n-            },\n-            _ => (),\n-        }\n-    }\n-}\n-\n-fn check_write_variants<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, write_args: &ptr::P<[Expr]>) {\n-    // `writeln!` uses `write!`.\n-    if let Some(span) = is_expn_of(expr.span, \"write\") {\n-        let (span, name) = match is_expn_of(span, \"writeln\") {\n-            Some(span) => (span, \"writeln\"),\n-            None => (span, \"write\"),\n-        };\n-\n-        if_chain! {\n-            // ensure we're calling Arguments::new_v1 or Arguments::new_v1_formatted\n-            if write_args.len() == 2;\n-            if let ExprKind::Call(ref args_fun, ref args_args) = write_args[1].node;\n-            if let ExprKind::Path(ref qpath) = args_fun.node;\n-            if let Some(const_def_id) = opt_def_id(resolve_node(cx, qpath, args_fun.hir_id));\n-            if match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1) ||\n-               match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1FORMATTED);\n-            then {\n-                // Check for literals in the write!/writeln! args\n-                check_fmt_args_for_literal(cx, args_args, |span| {\n-                    span_lint(cx, WRITE_LITERAL, span, \"writing a literal with an empty format string\");\n-                });\n-\n-                if_chain! {\n-                    if args_args.len() >= 2;\n-                    if let ExprKind::AddrOf(_, ref match_expr) = args_args[1].node;\n-                    if let ExprKind::Match(ref args, _, _) = match_expr.node;\n-                    if let ExprKind::Tup(ref args) = args.node;\n-                    if let Some((fmtstr, fmtlen)) = get_argument_fmtstr_parts(&args_args[0]);\n-                    then {\n-                        match name {\n-                            \"write\" => if has_newline_end(args, fmtstr, fmtlen) {\n-                                span_lint(cx, WRITE_WITH_NEWLINE, span,\n-                                        \"using `write!()` with a format string that ends in a \\\n-                                        newline, consider using `writeln!()` instead\");\n-                            },\n-                            \"writeln\" => if let Some(final_span) = has_empty_arg(cx, span, fmtstr, fmtlen) {\n-                                span_lint_and_sugg(\n-                                    cx,\n-                                    WRITE_WITH_NEWLINE,\n-                                    final_span,\n-                                    \"using `writeln!(v, \\\"\\\")`\",\n-                                    \"replace it with\",\n-                                    \"writeln!(v)\".to_string(),\n-                                );\n-                            },\n-                            _ => (),\n-                        }\n-                    }\n+impl EarlyLintPass for Pass {\n+    fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &Mac) {\n+        if mac.node.path == \"println\" {\n+            span_lint(cx, PRINT_STDOUT, mac.span, \"use of `println!`\");\n+            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, false) {\n+                if fmtstr == \"\" {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        PRINTLN_EMPTY_STRING,\n+                        mac.span,\n+                        \"using `println!(\\\"\\\")`\",\n+                        \"replace it with\",\n+                        \"println!()\".to_string(),\n+                    );\n                 }\n             }\n-        }\n-    }\n-}\n-\n-fn check_print_variants<'a, 'tcx>(\n-    cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx Expr,\n-    fun_id: def_id::DefId,\n-    args: &ptr::P<[Expr]>,\n-) {\n-    // Search for `std::io::_print(..)` which is unique in a\n-    // `print!` expansion.\n-    if match_def_path(cx.tcx, fun_id, &paths::IO_PRINT) {\n-        if let Some(span) = is_expn_of(expr.span, \"print\") {\n-            // `println!` uses `print!`.\n-            let (span, name) = match is_expn_of(span, \"println\") {\n-                Some(span) => (span, \"println\"),\n-                None => (span, \"print\"),\n-            };\n-\n-            span_lint(cx, PRINT_STDOUT, span, &format!(\"use of `{}!`\", name));\n-            if_chain! {\n-                // ensure we're calling Arguments::new_v1\n-                if args.len() == 1;\n-                if let ExprKind::Call(ref args_fun, ref args_args) = args[0].node;\n-                then {\n-                    // Check for literals in the print!/println! args\n-                    check_fmt_args_for_literal(cx, args_args, |span| {\n-                        span_lint(cx, PRINT_LITERAL, span, \"printing a literal with an empty format string\");\n-                    });\n-\n-                    if_chain! {\n-                        if let ExprKind::Path(ref qpath) = args_fun.node;\n-                        if let Some(const_def_id) = opt_def_id(resolve_node(cx, qpath, args_fun.hir_id));\n-                        if match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1);\n-                        if args_args.len() == 2;\n-                        if let ExprKind::AddrOf(_, ref match_expr) = args_args[1].node;\n-                        if let ExprKind::Match(ref args, _, _) = match_expr.node;\n-                        if let ExprKind::Tup(ref args) = args.node;\n-                        if let Some((fmtstr, fmtlen)) = get_argument_fmtstr_parts(&args_args[0]);\n-                        then {\n-                            match name {\n-                                \"print\" =>\n-                                    if has_newline_end(args, fmtstr, fmtlen) {\n-                                        span_lint(cx, PRINT_WITH_NEWLINE, span,\n-                                                \"using `print!()` with a format string that ends in a \\\n-                                                newline, consider using `println!()` instead\");\n-                                    },\n-                                \"println\" =>\n-                                    if let Some(final_span) = has_empty_arg(cx, span, fmtstr, fmtlen) {\n-                                        span_lint_and_sugg(\n-                                            cx,\n-                                            PRINT_WITH_NEWLINE,\n-                                            final_span,\n-                                            \"using `println!(\\\"\\\")`\",\n-                                            \"replace it with\",\n-                                            \"println!()\".to_string(),\n-                                        );\n-                                    },\n-                                _ => (),\n-                            }\n-                        }\n-                    }\n+        } else if mac.node.path == \"print\" {\n+            span_lint(cx, PRINT_STDOUT, mac.span, \"use of `print!`\");\n+            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, false) {\n+                if fmtstr.ends_with(\"\\\\n\") {\n+                    span_lint(cx, PRINT_WITH_NEWLINE, mac.span,\n+                            \"using `print!()` with a format string that ends in a \\\n+                            newline, consider using `println!()` instead\");\n                 }\n             }\n-        }\n-    }\n-    // Search for something like\n-    // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n-    else if args.len() == 2 && match_def_path(cx.tcx, fun_id, &paths::FMT_ARGUMENTV1_NEW) {\n-        if let ExprKind::Path(ref qpath) = args[1].node {\n-            if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, args[1].hir_id)) {\n-                if match_def_path(cx.tcx, def_id, &paths::DEBUG_FMT_METHOD) && !is_in_debug_impl(cx, expr)\n-                    && is_expn_of(expr.span, \"panic\").is_none()\n-                {\n-                    span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n+        } else if mac.node.path == \"write\" {\n+            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, true) {\n+                if fmtstr.ends_with(\"\\\\n\") {\n+                    span_lint(cx, WRITE_WITH_NEWLINE, mac.span,\n+                            \"using `write!()` with a format string that ends in a \\\n+                            newline, consider using `writeln!()` instead\");\n                 }\n             }\n-        }\n-    }\n-}\n-\n-// Check for literals in write!/writeln! and print!/println! args\n-// ensuring the format string for the literal is `DISPLAY_FMT_METHOD`\n-// e.g., `writeln!(buf, \"... {} ...\", \"foo\")`\n-//                                    ^ literal in `writeln!`\n-// e.g., `println!(\"... {} ...\", \"foo\")`\n-//                                ^ literal in `println!`\n-fn check_fmt_args_for_literal<'a, 'tcx, F>(cx: &LateContext<'a, 'tcx>, args: &HirVec<Expr>, lint_fn: F)\n-where\n-    F: Fn(Span),\n-{\n-    if_chain! {\n-        if args.len() >= 2;\n-\n-        // the match statement\n-        if let ExprKind::AddrOf(_, ref match_expr) = args[1].node;\n-        if let ExprKind::Match(ref matchee, ref arms, _) = match_expr.node;\n-        if let ExprKind::Tup(ref tup) = matchee.node;\n-        if arms.len() == 1;\n-        if let ExprKind::Array(ref arm_body_exprs) = arms[0].body.node;\n-        then {\n-            // it doesn't matter how many args there are in the `write!`/`writeln!`,\n-            // if there's one literal, we should warn the user\n-            for (idx, tup_arg) in tup.iter().enumerate() {\n-                if_chain! {\n-                    // first, make sure we're dealing with a literal (i.e., an ExprKind::Lit)\n-                    if let ExprKind::AddrOf(_, ref tup_val) = tup_arg.node;\n-                    if let ExprKind::Lit(_) = tup_val.node;\n-\n-                    // next, check the corresponding match arm body to ensure\n-                    // this is DISPLAY_FMT_METHOD\n-                    if let ExprKind::Call(_, ref body_args) = arm_body_exprs[idx].node;\n-                    if body_args.len() == 2;\n-                    if let ExprKind::Path(ref body_qpath) = body_args[1].node;\n-                    if let Some(fun_def_id) = opt_def_id(resolve_node(cx, body_qpath, body_args[1].hir_id));\n-                    if match_def_path(cx.tcx, fun_def_id, &paths::DISPLAY_FMT_METHOD);\n-                    then {\n-                        if args.len() == 2 {\n-                            lint_fn(tup_val.span);\n-                        }\n-\n-                        // ensure the format str has no options (e.g., width, precision, alignment, etc.)\n-                        // and is just \"{}\"\n-                        if_chain! {\n-                            if args.len() == 3;\n-                            if let ExprKind::AddrOf(_, ref format_expr) = args[2].node;\n-                            if let ExprKind::Array(ref format_exprs) = format_expr.node;\n-                            if format_exprs.len() >= 1;\n-                            if let ExprKind::Struct(_, ref fields, _) = format_exprs[idx].node;\n-                            if let Some(format_field) = fields.iter().find(|f| f.ident.name == \"format\");\n-                            if check_unformatted(&format_field.expr);\n-                            then {\n-                                lint_fn(tup_val.span);\n-                            }\n-                        }\n-                    }\n+        } else if mac.node.path == \"writeln\" {\n+            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, true) {\n+                if fmtstr == \"\" {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        WRITELN_EMPTY_STRING,\n+                        mac.span,\n+                        \"using `writeln!(v, \\\"\\\")`\",\n+                        \"replace it with\",\n+                        \"writeln!(v)\".to_string(),\n+                    );\n                 }\n             }\n         }\n     }\n }\n \n-/// Check for fmtstr = \"... \\n\"\n-fn has_newline_end(args: &HirVec<Expr>, fmtstr: LocalInternedString, fmtlen: usize) -> bool {\n-    if_chain! {\n-        // check the final format string part\n-        if let Some('\\n') = fmtstr.chars().last();\n-\n-        // \"foo{}bar\" is made into two strings + one argument,\n-        // if the format string starts with `{}` (eg. \"{}foo\"),\n-        // the string array is prepended an empty string \"\".\n-        // We only want to check the last string after any `{}`:\n-        if args.len() < fmtlen;\n-        then {\n-            return true\n-        }\n+fn check_tts(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -> Option<String> {\n+    let tts = TokenStream::from(tts.clone());\n+    let mut parser = parser::Parser::new(\n+        &cx.sess.parse_sess,\n+        tts,\n+        None,\n+        false,\n+        false,\n+    );\n+    if is_write {\n+        // skip the initial write target\n+        parser.parse_expr().map_err(|mut err| err.cancel()).ok()?;\n+        // might be `writeln!(foo)`\n+        parser.expect(&token::Comma).map_err(|mut err| err.cancel()).ok()?;\n     }\n-    false\n-}\n-\n-/// Check for writeln!(v, \"\") / println!(\"\")\n-fn has_empty_arg<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, fmtstr: LocalInternedString, fmtlen: usize) -> Option<Span> {\n-    if_chain! {\n-        // check that the string is empty\n-        if fmtlen == 1;\n-        if fmtstr.deref() == \"\\n\";\n-\n-        // check the presence of that string\n-        if let Ok(snippet) = cx.sess().codemap().span_to_snippet(span);\n-        if snippet.contains(\"\\\"\\\"\");\n-        then {\n-            if snippet.ends_with(';') {\n-                return Some(cx.sess().codemap().span_until_char(span, ';'));\n-            }\n-            return Some(span)\n+    let fmtstr = parser.parse_str().map_err(|mut err| err.cancel()).ok()?.0.to_string();\n+    use fmt_macros::*;\n+    let tmp = fmtstr.clone();\n+    let mut args = vec![];\n+    let mut fmt_parser = Parser::new(&tmp, None);\n+    while let Some(piece) = fmt_parser.next() {\n+        if !fmt_parser.errors.is_empty() {\n+            return None;\n         }\n-    }\n-    None\n-}\n-\n-/// Returns the slice of format string parts in an `Arguments::new_v1` call.\n-fn get_argument_fmtstr_parts(expr: &Expr) -> Option<(LocalInternedString, usize)> {\n-    if_chain! {\n-        if let ExprKind::AddrOf(_, ref expr) = expr.node; // &[\"\u2026\", \"\u2026\", \u2026]\n-        if let ExprKind::Array(ref exprs) = expr.node;\n-        if let Some(expr) = exprs.last();\n-        if let ExprKind::Lit(ref lit) = expr.node;\n-        if let LitKind::Str(ref lit, _) = lit.node;\n-        then {\n-            return Some((lit.as_str(), exprs.len()));\n-        }\n-    }\n-    None\n-}\n-\n-fn is_in_debug_impl(cx: &LateContext, expr: &Expr) -> bool {\n-    let map = &cx.tcx.hir;\n-\n-    // `fmt` method\n-    if let Some(NodeImplItem(item)) = map.find(map.get_parent(expr.id)) {\n-        // `Debug` impl\n-        if let Some(NodeItem(item)) = map.find(map.get_parent(item.id)) {\n-            if let ItemKind::Impl(_, _, _, _, Some(ref tr), _, _) = item.node {\n-                return match_path(&tr.path, &[\"Debug\"]);\n+        if let Piece::NextArgument(arg) = piece {\n+            if arg.format.ty == \"?\" {\n+                // FIXME: modify rustc's fmt string parser to give us the current span\n+                span_lint(cx, USE_DEBUG, parser.prev_span, \"use of `Debug`-based formatting\");\n             }\n+            args.push(arg);\n         }\n     }\n-    false\n-}\n-\n-/// Checks if the expression matches\n-/// ```rust,ignore\n-/// &[_ {\n-///    format: _ {\n-///         width: _::Implied,\n-///         ...\n-///    },\n-///    ...,\n-/// }]\n-/// ```\n-pub fn check_unformatted(format_field: &Expr) -> bool {\n-    if_chain! {\n-        if let ExprKind::Struct(_, ref fields, _) = format_field.node;\n-        if let Some(width_field) = fields.iter().find(|f| f.ident.name == \"width\");\n-        if let ExprKind::Path(ref qpath) = width_field.expr.node;\n-        if last_path_segment(qpath).ident.name == \"Implied\";\n-        if let Some(align_field) = fields.iter().find(|f| f.ident.name == \"align\");\n-        if let ExprKind::Path(ref qpath) = align_field.expr.node;\n-        if last_path_segment(qpath).ident.name == \"Unknown\";\n-        if let Some(precision_field) = fields.iter().find(|f| f.ident.name == \"precision\");\n-        if let ExprKind::Path(ref qpath_precision) = precision_field.expr.node;\n-        if last_path_segment(qpath_precision).ident.name == \"Implied\";\n-        then {\n-            return true;\n+    let lint = if is_write {\n+        WRITE_LITERAL\n+    } else {\n+        PRINT_LITERAL\n+    };\n+    let mut idx = 0;\n+    loop {\n+        if !parser.eat(&token::Comma) {\n+            assert!(parser.eat(&token::Eof));\n+            return Some(fmtstr);\n+        }\n+        let expr = parser.parse_expr().map_err(|mut err| err.cancel()).ok()?;\n+        const SIMPLE: FormatSpec<'_> = FormatSpec {\n+            fill: None,\n+            align: AlignUnknown,\n+            flags: 0,\n+            precision: CountImplied,\n+            width: CountImplied,\n+            ty: \"\",\n+        };\n+        match &expr.node {\n+            ExprKind::Lit(_) => {\n+                let mut all_simple = true;\n+                let mut seen = false;\n+                for arg in &args {\n+                    match arg.position {\n+                        | ArgumentImplicitlyIs(n)\n+                        | ArgumentIs(n)\n+                        => if n == idx {\n+                            all_simple &= arg.format == SIMPLE;\n+                            seen = true;\n+                        },\n+                        ArgumentNamed(_) => {},\n+                    }\n+                }\n+                if all_simple && seen {\n+                    span_lint(cx, lint, expr.span, \"literal with an empty format string\");\n+                }\n+                idx += 1;\n+            },\n+            ExprKind::Assign(lhs, rhs) => {\n+                if let ExprKind::Path(_, p) = &lhs.node {\n+                    let mut all_simple = true;\n+                    let mut seen = false;\n+                    for arg in &args {\n+                        match arg.position {\n+                            | ArgumentImplicitlyIs(_)\n+                            | ArgumentIs(_)\n+                            => {},\n+                            ArgumentNamed(name) => if *p == name {\n+                                seen = true;\n+                                all_simple &= arg.format == SIMPLE;\n+                            },\n+                        }\n+                    }\n+                    if all_simple && seen {\n+                        span_lint(cx, lint, rhs.span, \"literal with an empty format string\");\n+                    }\n+                }\n+            },\n+            _ => idx += 1,\n         }\n     }\n-\n-    false\n }"}, {"sha": "7c8af7880ba22b7ec5f7cdbfcc118f2ad1f32eb6", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,5 +1,7 @@\n use crate::consts::{constant_simple, Constant};\n use rustc::lint::*;\n+use rustc::{declare_lint, lint_array};\n+use if_chain::if_chain;\n use rustc::hir::*;\n use crate::utils::span_help_and_lint;\n "}, {"sha": "e9e81bb88e3de13e90e2446ababa441147e9e4b4", "filename": "src/driver.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -118,6 +118,7 @@ pub fn main() {\n             for (name, to) in lint_groups {\n                 ls.register_group(Some(sess), true, name, to);\n             }\n+            clippy_lints::register_pre_expansion_lints(sess, &mut ls);\n \n             sess.plugin_llvm_passes.borrow_mut().extend(llvm_passes);\n             sess.plugin_attributes.borrow_mut().extend(attributes);"}, {"sha": "1123c968006ab82f70d370a5aecd55747f0d23e7", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -10,7 +10,7 @@\n use rustc_plugin::Registry;\n \n #[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n+pub fn plugin_registrar(reg: &mut Registry<'_>) {\n     reg.sess.lint_store.with_read_lock(|lint_store| {\n         for (lint, _, _) in lint_store.get_lint_groups() {\n             reg.sess"}, {"sha": "88f24d27dbc4a7d7f1e252009a961aaae2418f7f", "filename": "tests/ui/excessive_precision.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexcessive_precision.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -22,7 +22,7 @@ fn main() {\n     const BAD64_3: f64 = 0.100_000_000_000_000_000_1;\n \n     // Literal as param\n-    println!(\"{}\", 8.888_888_888_888_888_888_888);\n+    println!(\"{:?}\", 8.888_888_888_888_888_888_888);\n \n     // // TODO add inferred type tests for f32\n     // Locals"}, {"sha": "295846e9d7e011cdba69b53308e811658afc8acf", "filename": "tests/ui/excessive_precision.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fexcessive_precision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fexcessive_precision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexcessive_precision.stderr?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -43,10 +43,10 @@ error: float has excessive precision\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `0.1`\n \n error: float has excessive precision\n-  --> $DIR/excessive_precision.rs:25:20\n+  --> $DIR/excessive_precision.rs:25:22\n    |\n-25 |     println!(\"{}\", 8.888_888_888_888_888_888_888);\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `8.888_888_888_888_89`\n+25 |     println!(\"{:?}\", 8.888_888_888_888_888_888_888);\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider changing the type or truncating it to: `8.888_888_888_888_89`\n \n error: float has excessive precision\n   --> $DIR/excessive_precision.rs:36:22"}, {"sha": "6554b6d344929eb9066914100549fed2c9f9b4db", "filename": "tests/ui/matches.stderr", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fmatches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fmatches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatches.stderr?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -26,6 +26,23 @@ help: instead of prefixing all patterns with `&`, you can dereference the expres\n 32 |             None => println!(\"none\"),\n    |\n \n+error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/matches.rs:40:5\n+   |\n+40 | /     match tup {\n+41 | |         &(v, 1) => println!(\"{}\", v),\n+42 | |         _ => println!(\"none\"),\n+43 | |     }\n+   | |_____^\n+help: try this\n+   |\n+40 |     if let &(v, 1) = tup {\n+41 | # [ cfg ( not ( stage0 ) ) ] {\n+42 | ( $ crate :: io :: _print ( format_args_nl ! ( $ ( $ arg ) * ) ) ) ; } # [\n+43 | cfg ( stage0 ) ] { print ! ( \"{}/n\" , format_args ! ( $ ( $ arg ) * ) ) } } else {\n+44 | ( $ crate :: io :: _print ( format_args_nl ! ( $ ( $ arg ) * ) ) ) ; }\n+   |\n+\n error: you don't need to add `&` to all patterns\n   --> $DIR/matches.rs:40:5\n    |\n@@ -350,5 +367,5 @@ error: use as_mut() instead\n 221 | |     };\n     | |_____^ help: try this: `mut_owned.as_mut()`\n \n-error: aborting due to 25 previous errors\n+error: aborting due to 26 previous errors\n "}, {"sha": "c63b493db8d2fe57b2863a8337c044e6431fbfbc", "filename": "tests/ui/non_expressive_names.stderr", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fnon_expressive_names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fnon_expressive_names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnon_expressive_names.stderr?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,3 +1,23 @@\n+error: using `println!(\"\")`\n+  --> $DIR/non_expressive_names.rs:60:14\n+   |\n+60 |         _ => println!(\"\"),\n+   |              ^^^^^^^^^^^^ help: replace it with: `println!()`\n+   |\n+   = note: `-D println-empty-string` implied by `-D warnings`\n+\n+error: using `println!(\"\")`\n+   --> $DIR/non_expressive_names.rs:128:18\n+    |\n+128 |             1 => println!(\"\"),\n+    |                  ^^^^^^^^^^^^ help: replace it with: `println!()`\n+\n+error: using `println!(\"\")`\n+   --> $DIR/non_expressive_names.rs:132:18\n+    |\n+132 |             1 => println!(\"\"),\n+    |                  ^^^^^^^^^^^^ help: replace it with: `println!()`\n+\n error: binding's name is too similar to existing binding\n   --> $DIR/non_expressive_names.rs:18:9\n    |\n@@ -167,5 +187,5 @@ error: consider choosing a more descriptive name\n 151 |         let __1___2 = 12;\n     |             ^^^^^^^\n \n-error: aborting due to 17 previous errors\n+error: aborting due to 20 previous errors\n "}, {"sha": "f2d2afd9bf782d1695e62c94d064c7ac6954ee3f", "filename": "tests/ui/print.stderr", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fprint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fprint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint.stderr?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,54 +1,60 @@\n error: use of `Debug`-based formatting\n-  --> $DIR/print.rs:13:27\n+  --> $DIR/print.rs:13:19\n    |\n 13 |         write!(f, \"{:?}\", 43.1415)\n-   |                           ^^^^^^^\n+   |                   ^^^^^^\n    |\n    = note: `-D use-debug` implied by `-D warnings`\n \n+error: use of `Debug`-based formatting\n+  --> $DIR/print.rs:20:19\n+   |\n+20 |         write!(f, \"{:?}\", 42.718)\n+   |                   ^^^^^^\n+\n error: use of `println!`\n   --> $DIR/print.rs:25:5\n    |\n 25 |     println!(\"Hello\");\n-   |     ^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D print-stdout` implied by `-D warnings`\n \n error: use of `print!`\n   --> $DIR/print.rs:26:5\n    |\n 26 |     print!(\"Hello\");\n-   |     ^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^\n \n error: use of `print!`\n   --> $DIR/print.rs:28:5\n    |\n 28 |     print!(\"Hello {}\", \"World\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of `print!`\n   --> $DIR/print.rs:30:5\n    |\n 30 |     print!(\"Hello {:?}\", \"World\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of `Debug`-based formatting\n-  --> $DIR/print.rs:30:26\n+  --> $DIR/print.rs:30:12\n    |\n 30 |     print!(\"Hello {:?}\", \"World\");\n-   |                          ^^^^^^^\n+   |            ^^^^^^^^^^^^\n \n error: use of `print!`\n   --> $DIR/print.rs:32:5\n    |\n 32 |     print!(\"Hello {:#?}\", \"#orld\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: use of `Debug`-based formatting\n-  --> $DIR/print.rs:32:27\n+  --> $DIR/print.rs:32:12\n    |\n 32 |     print!(\"Hello {:#?}\", \"#orld\");\n-   |                           ^^^^^^^\n+   |            ^^^^^^^^^^^^^\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 9 previous errors\n "}, {"sha": "39e0387cb5ec3ccc8128d6d428c399e01df09ecf", "filename": "tests/ui/print_literal.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fprint_literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fprint_literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_literal.stderr?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,84 +1,84 @@\n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:23:71\n    |\n 23 |     println!(\"{} of {:b} people know binary, the other half doesn't\", 1, 2);\n    |                                                                       ^\n    |\n    = note: `-D print-literal` implied by `-D warnings`\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:24:24\n    |\n 24 |     print!(\"Hello {}\", \"world\");\n    |                        ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:25:36\n    |\n 25 |     println!(\"Hello {} {}\", world, \"world\");\n    |                                    ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:26:26\n    |\n 26 |     println!(\"Hello {}\", \"world\");\n    |                          ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:27:30\n    |\n 27 |     println!(\"10 / 4 is {}\", 2.5);\n    |                              ^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:28:28\n    |\n 28 |     println!(\"2 + 1 = {}\", 3);\n    |                            ^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:33:25\n    |\n 33 |     println!(\"{0} {1}\", \"hello\", \"world\");\n    |                         ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:33:34\n    |\n 33 |     println!(\"{0} {1}\", \"hello\", \"world\");\n    |                                  ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:34:25\n    |\n 34 |     println!(\"{1} {0}\", \"hello\", \"world\");\n    |                         ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:34:34\n    |\n 34 |     println!(\"{1} {0}\", \"hello\", \"world\");\n    |                                  ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:37:33\n    |\n 37 |     println!(\"{foo} {bar}\", foo=\"hello\", bar=\"world\");\n    |                                 ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:37:46\n    |\n 37 |     println!(\"{foo} {bar}\", foo=\"hello\", bar=\"world\");\n    |                                              ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:38:33\n    |\n 38 |     println!(\"{bar} {foo}\", foo=\"hello\", bar=\"world\");\n    |                                 ^^^^^^^\n \n-error: printing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/print_literal.rs:38:46\n    |\n 38 |     println!(\"{bar} {foo}\", foo=\"hello\", bar=\"world\");"}, {"sha": "181f16b5cb71066bb6c80a39181ef0804a850d9a", "filename": "tests/ui/print_with_newline.stderr", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fprint_with_newline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fprint_with_newline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_with_newline.stderr?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -2,9 +2,27 @@ error: using `print!()` with a format string that ends in a newline, consider us\n  --> $DIR/print_with_newline.rs:7:5\n   |\n 7 |     print!(\"Hello/n\");\n-  |     ^^^^^^^^^^^^^^^^^^\n+  |     ^^^^^^^^^^^^^^^^^\n   |\n   = note: `-D print-with-newline` implied by `-D warnings`\n \n-error: aborting due to previous error\n+error: using `print!()` with a format string that ends in a newline, consider using `println!()` instead\n+ --> $DIR/print_with_newline.rs:8:5\n+  |\n+8 |     print!(\"Hello {}/n\", \"world\");\n+  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: using `print!()` with a format string that ends in a newline, consider using `println!()` instead\n+ --> $DIR/print_with_newline.rs:9:5\n+  |\n+9 |     print!(\"Hello {} {}/n/n\", \"world\", \"#2\");\n+  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: using `print!()` with a format string that ends in a newline, consider using `println!()` instead\n+  --> $DIR/print_with_newline.rs:10:5\n+   |\n+10 |     print!(\"{}/n\", 1265);\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "cff3f988052a1dd14a6041510d15c7a7bb5b6c21", "filename": "tests/ui/println_empty_string.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fprintln_empty_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fprintln_empty_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprintln_empty_string.stderr?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -4,7 +4,7 @@ error: using `println!(\"\")`\n 3 |     println!(\"\");\n   |     ^^^^^^^^^^^^ help: replace it with: `println!()`\n   |\n-  = note: `-D print-with-newline` implied by `-D warnings`\n+  = note: `-D println-empty-string` implied by `-D warnings`\n \n error: using `println!(\"\")`\n  --> $DIR/println_empty_string.rs:6:14"}, {"sha": "c6773add244305186f2b8657174633e260464ffe", "filename": "tests/ui/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrivially_copy_pass_by_ref.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -11,6 +11,15 @@ type Baz = u32;\n fn good(a: &mut u32, b: u32, c: &Bar) {\n }\n \n+fn good_return_implicit_lt_ref(foo: &Foo) -> &u32 {\n+    &foo.0\n+}\n+\n+#[allow(needless_lifetimes)]\n+fn good_return_explicit_lt_ref<'a>(foo: &'a Foo) -> &'a u32 {\n+    &foo.0\n+}\n+\n fn bad(x: &u32, y: &Foo, z: &Baz) {\n }\n \n@@ -46,6 +55,8 @@ fn main() {\n     let (mut foo, bar) = (Foo(0), Bar([0; 24]));\n     let (mut a, b, c, x, y, z) = (0, 0, Bar([0; 24]), 0, Foo(0), 0);\n     good(&mut a, b, &c);\n+    good_return_implicit_lt_ref(&y);\n+    good_return_explicit_lt_ref(&y);\n     bad(&x, &y, &z);\n     foo.good(&mut a, b, &c);\n     foo.good2();"}, {"sha": "db25cc5a02011b2a278ef7e580948c88a9dad3ab", "filename": "tests/ui/trivially_copy_pass_by_ref.stderr", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrivially_copy_pass_by_ref.stderr?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,81 +1,81 @@\n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:14:11\n+  --> $DIR/trivially_copy_pass_by_ref.rs:23:11\n    |\n-14 | fn bad(x: &u32, y: &Foo, z: &Baz) {\n+23 | fn bad(x: &u32, y: &Foo, z: &Baz) {\n    |           ^^^^ help: consider passing by value instead: `u32`\n    |\n    = note: `-D trivially-copy-pass-by-ref` implied by `-D warnings`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:14:20\n+  --> $DIR/trivially_copy_pass_by_ref.rs:23:20\n    |\n-14 | fn bad(x: &u32, y: &Foo, z: &Baz) {\n+23 | fn bad(x: &u32, y: &Foo, z: &Baz) {\n    |                    ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:14:29\n+  --> $DIR/trivially_copy_pass_by_ref.rs:23:29\n    |\n-14 | fn bad(x: &u32, y: &Foo, z: &Baz) {\n+23 | fn bad(x: &u32, y: &Foo, z: &Baz) {\n    |                             ^^^^ help: consider passing by value instead: `Baz`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:24:12\n+  --> $DIR/trivially_copy_pass_by_ref.rs:33:12\n    |\n-24 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n+33 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n    |            ^^^^^ help: consider passing by value instead: `self`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:24:22\n+  --> $DIR/trivially_copy_pass_by_ref.rs:33:22\n    |\n-24 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n+33 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n    |                      ^^^^ help: consider passing by value instead: `u32`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:24:31\n+  --> $DIR/trivially_copy_pass_by_ref.rs:33:31\n    |\n-24 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n+33 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n    |                               ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:24:40\n+  --> $DIR/trivially_copy_pass_by_ref.rs:33:40\n    |\n-24 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n+33 |     fn bad(&self, x: &u32, y: &Foo, z: &Baz) {\n    |                                        ^^^^ help: consider passing by value instead: `Baz`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:27:16\n+  --> $DIR/trivially_copy_pass_by_ref.rs:36:16\n    |\n-27 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+36 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n    |                ^^^^ help: consider passing by value instead: `u32`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:27:25\n+  --> $DIR/trivially_copy_pass_by_ref.rs:36:25\n    |\n-27 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+36 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n    |                         ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:27:34\n+  --> $DIR/trivially_copy_pass_by_ref.rs:36:34\n    |\n-27 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+36 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n    |                                  ^^^^ help: consider passing by value instead: `Baz`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:41:16\n+  --> $DIR/trivially_copy_pass_by_ref.rs:50:16\n    |\n-41 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+50 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n    |                ^^^^ help: consider passing by value instead: `u32`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:41:25\n+  --> $DIR/trivially_copy_pass_by_ref.rs:50:25\n    |\n-41 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+50 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n    |                         ^^^^ help: consider passing by value instead: `Foo`\n \n error: this argument is passed by reference, but would be more efficient if passed by value\n-  --> $DIR/trivially_copy_pass_by_ref.rs:41:34\n+  --> $DIR/trivially_copy_pass_by_ref.rs:50:34\n    |\n-41 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n+50 |     fn bad2(x: &u32, y: &Foo, z: &Baz) {\n    |                                  ^^^^ help: consider passing by value instead: `Baz`\n \n error: aborting due to 13 previous errors"}, {"sha": "68c7d2007a6b65bf258cf716a1e693ef365937d2", "filename": "tests/ui/useless_attribute.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fuseless_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fuseless_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_attribute.rs?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -6,6 +6,8 @@\n #[cfg_attr(feature = \"cargo-clippy\", allow(dead_code, unused_extern_crates))]\n #[cfg_attr(feature = \"cargo-clippy\",\n            allow(dead_code, unused_extern_crates))]\n+#[allow(unused_imports)]\n+#[macro_use]\n extern crate clippy_lints;\n \n // don't lint on unused_import for `use` items"}, {"sha": "70855ef8187068b1716eb56c39f2895030d9ccfa", "filename": "tests/ui/write_literal.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fwrite_literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fwrite_literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_literal.stderr?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -1,84 +1,84 @@\n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:26:79\n    |\n 26 |     writeln!(&mut v, \"{} of {:b} people know binary, the other half doesn't\", 1, 2);\n    |                                                                               ^\n    |\n    = note: `-D write-literal` implied by `-D warnings`\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:27:32\n    |\n 27 |     write!(&mut v, \"Hello {}\", \"world\");\n    |                                ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:28:44\n    |\n 28 |     writeln!(&mut v, \"Hello {} {}\", world, \"world\");\n    |                                            ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:29:34\n    |\n 29 |     writeln!(&mut v, \"Hello {}\", \"world\");\n    |                                  ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:30:38\n    |\n 30 |     writeln!(&mut v, \"10 / 4 is {}\", 2.5);\n    |                                      ^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:31:36\n    |\n 31 |     writeln!(&mut v, \"2 + 1 = {}\", 3);\n    |                                    ^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:36:33\n    |\n 36 |     writeln!(&mut v, \"{0} {1}\", \"hello\", \"world\");\n    |                                 ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:36:42\n    |\n 36 |     writeln!(&mut v, \"{0} {1}\", \"hello\", \"world\");\n    |                                          ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:37:33\n    |\n 37 |     writeln!(&mut v, \"{1} {0}\", \"hello\", \"world\");\n    |                                 ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:37:42\n    |\n 37 |     writeln!(&mut v, \"{1} {0}\", \"hello\", \"world\");\n    |                                          ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:40:41\n    |\n 40 |     writeln!(&mut v, \"{foo} {bar}\", foo=\"hello\", bar=\"world\");\n    |                                         ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:40:54\n    |\n 40 |     writeln!(&mut v, \"{foo} {bar}\", foo=\"hello\", bar=\"world\");\n    |                                                      ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:41:41\n    |\n 41 |     writeln!(&mut v, \"{bar} {foo}\", foo=\"hello\", bar=\"world\");\n    |                                         ^^^^^^^\n \n-error: writing a literal with an empty format string\n+error: literal with an empty format string\n   --> $DIR/write_literal.rs:41:54\n    |\n 41 |     writeln!(&mut v, \"{bar} {foo}\", foo=\"hello\", bar=\"world\");"}, {"sha": "7bb9b99731ffb7740a3753ac6c6c73be20174f0f", "filename": "tests/ui/write_with_newline.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fwrite_with_newline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fwrite_with_newline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_with_newline.stderr?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -2,27 +2,27 @@ error: using `write!()` with a format string that ends in a newline, consider us\n   --> $DIR/write_with_newline.rs:10:5\n    |\n 10 |     write!(&mut v, \"Hello/n\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D write-with-newline` implied by `-D warnings`\n \n error: using `write!()` with a format string that ends in a newline, consider using `writeln!()` instead\n   --> $DIR/write_with_newline.rs:11:5\n    |\n 11 |     write!(&mut v, \"Hello {}/n\", \"world\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: using `write!()` with a format string that ends in a newline, consider using `writeln!()` instead\n   --> $DIR/write_with_newline.rs:12:5\n    |\n 12 |     write!(&mut v, \"Hello {} {}/n/n\", \"world\", \"#2\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: using `write!()` with a format string that ends in a newline, consider using `writeln!()` instead\n   --> $DIR/write_with_newline.rs:13:5\n    |\n 13 |     write!(&mut v, \"{}/n\", 1265);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 4 previous errors\n "}, {"sha": "16a8e0a203d3a3f26cea4c32e025710d79015bc7", "filename": "tests/ui/writeln_empty_string.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fwriteln_empty_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/tests%2Fui%2Fwriteln_empty_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwriteln_empty_string.stderr?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -4,7 +4,7 @@ error: using `writeln!(v, \"\")`\n 9 |     writeln!(&mut v, \"\");\n   |     ^^^^^^^^^^^^^^^^^^^^ help: replace it with: `writeln!(v)`\n   |\n-  = note: `-D write-with-newline` implied by `-D warnings`\n+  = note: `-D writeln-empty-string` implied by `-D warnings`\n \n error: aborting due to previous error\n "}, {"sha": "0088ecc3d89ddc699c3a94c711a5526eed998568", "filename": "util/gh-pages/index.html", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/util%2Fgh-pages%2Findex.html", "raw_url": "https://github.com/rust-lang/rust/raw/5e23fcec0b0118ad32b7d5470ee41f16587e0e78/util%2Fgh-pages%2Findex.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fgh-pages%2Findex.html?ref=5e23fcec0b0118ad32b7d5470ee41f16587e0e78", "patch": "@@ -14,6 +14,9 @@\n \n         .form-inline .checkbox { margin-right: 0.6em }\n \n+        .panel-heading { pointer: cursor; }\n+        .panel-heading:hover { background-color: #eee; }\n+\n         .panel-title { display: flex; }\n         .panel-title .label { display: inline-block; }\n "}]}