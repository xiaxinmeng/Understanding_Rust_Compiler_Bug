{"sha": "8fc254597f7351e06b19052933aa01a044583b71", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmYzI1NDU5N2Y3MzUxZTA2YjE5MDUyOTMzYWEwMWEwNDQ1ODNiNzE=", "commit": {"author": {"name": "Armin Sander", "email": "armin@replicator.org", "date": "2020-08-13T23:19:46Z"}, "committer": {"name": "Armin Sander", "email": "armin@replicator.org", "date": "2020-08-14T00:03:54Z"}, "message": "Sophisticate Windows path encoding", "tree": {"sha": "b1c9f3e698780720aa2c92dbfb9c2e3ae07a4bdd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1c9f3e698780720aa2c92dbfb9c2e3ae07a4bdd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fc254597f7351e06b19052933aa01a044583b71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fc254597f7351e06b19052933aa01a044583b71", "html_url": "https://github.com/rust-lang/rust/commit/8fc254597f7351e06b19052933aa01a044583b71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fc254597f7351e06b19052933aa01a044583b71/comments", "author": {"login": "pragmatrix", "id": 1003751, "node_id": "MDQ6VXNlcjEwMDM3NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1003751?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pragmatrix", "html_url": "https://github.com/pragmatrix", "followers_url": "https://api.github.com/users/pragmatrix/followers", "following_url": "https://api.github.com/users/pragmatrix/following{/other_user}", "gists_url": "https://api.github.com/users/pragmatrix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pragmatrix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pragmatrix/subscriptions", "organizations_url": "https://api.github.com/users/pragmatrix/orgs", "repos_url": "https://api.github.com/users/pragmatrix/repos", "events_url": "https://api.github.com/users/pragmatrix/events{/privacy}", "received_events_url": "https://api.github.com/users/pragmatrix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pragmatrix", "id": 1003751, "node_id": "MDQ6VXNlcjEwMDM3NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1003751?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pragmatrix", "html_url": "https://github.com/pragmatrix", "followers_url": "https://api.github.com/users/pragmatrix/followers", "following_url": "https://api.github.com/users/pragmatrix/following{/other_user}", "gists_url": "https://api.github.com/users/pragmatrix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pragmatrix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pragmatrix/subscriptions", "organizations_url": "https://api.github.com/users/pragmatrix/orgs", "repos_url": "https://api.github.com/users/pragmatrix/repos", "events_url": "https://api.github.com/users/pragmatrix/events{/privacy}", "received_events_url": "https://api.github.com/users/pragmatrix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1f73649a686dc6e6449afc35e0fa6fed00e225d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1f73649a686dc6e6449afc35e0fa6fed00e225d", "html_url": "https://github.com/rust-lang/rust/commit/f1f73649a686dc6e6449afc35e0fa6fed00e225d"}], "stats": {"total": 139, "additions": 132, "deletions": 7}, "files": [{"sha": "944a702df0fcd073b9df4356a13d0bbadd77afeb", "filename": "crates/vfs/src/vfs_path.rs", "status": "modified", "additions": 132, "deletions": 7, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/8fc254597f7351e06b19052933aa01a044583b71/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc254597f7351e06b19052933aa01a044583b71/crates%2Fvfs%2Fsrc%2Fvfs_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Fvfs_path.rs?ref=8fc254597f7351e06b19052933aa01a044583b71", "patch": "@@ -57,30 +57,155 @@ impl VfsPath {\n         };\n         buf.push(tag);\n         match &self.0 {\n-            VfsPathRepr::PathBuf(it) => {\n-                let path: &std::ffi::OsStr = it.as_os_str();\n+            VfsPathRepr::PathBuf(path) => {\n                 #[cfg(windows)]\n                 {\n-                    use std::os::windows::ffi::OsStrExt;\n-                    for wchar in path.encode_wide() {\n-                        buf.extend(wchar.to_le_bytes().iter().copied());\n+                    use windows_paths::Encode;\n+                    let components = path.components();\n+                    let mut add_sep = false;\n+                    for component in components {\n+                        if add_sep {\n+                            windows_paths::SEP.encode(buf);\n+                        }\n+                        let len_before = buf.len();\n+                        match component {\n+                            std::path::Component::Prefix(prefix) => {\n+                                // kind() returns a normalized and comparable path prefix.\n+                                prefix.kind().encode(buf);\n+                            }\n+                            std::path::Component::RootDir => {\n+                                if !add_sep {\n+                                    component.as_os_str().encode(buf);\n+                                }\n+                            }\n+                            _ => component.as_os_str().encode(buf),\n+                        }\n+\n+                        // some components may be encoded empty\n+                        add_sep = len_before != buf.len();\n                     }\n                 }\n                 #[cfg(unix)]\n                 {\n                     use std::os::unix::ffi::OsStrExt;\n-                    buf.extend(path.as_bytes());\n+                    buf.extend(path.as_os_str().as_bytes());\n                 }\n                 #[cfg(not(any(windows, unix)))]\n                 {\n-                    buf.extend(path.to_string_lossy().as_bytes());\n+                    buf.extend(path.as_os_str().to_string_lossy().as_bytes());\n                 }\n             }\n             VfsPathRepr::VirtualPath(VirtualPath(s)) => buf.extend(s.as_bytes()),\n         }\n     }\n }\n \n+#[cfg(windows)]\n+mod windows_paths {\n+    pub trait Encode {\n+        fn encode(&self, buf: &mut Vec<u8>);\n+    }\n+\n+    impl Encode for std::ffi::OsStr {\n+        fn encode(&self, buf: &mut Vec<u8>) {\n+            use std::os::windows::ffi::OsStrExt;\n+            for wchar in self.encode_wide() {\n+                buf.extend(wchar.to_le_bytes().iter().copied());\n+            }\n+        }\n+    }\n+\n+    impl Encode for u8 {\n+        fn encode(&self, buf: &mut Vec<u8>) {\n+            let wide = *self as u16;\n+            buf.extend(wide.to_le_bytes().iter().copied())\n+        }\n+    }\n+\n+    impl Encode for &str {\n+        fn encode(&self, buf: &mut Vec<u8>) {\n+            debug_assert!(self.is_ascii());\n+            for b in self.as_bytes() {\n+                b.encode(buf)\n+            }\n+        }\n+    }\n+\n+    pub const SEP: &str = \"\\\\\";\n+    const VERBATIM: &str = \"\\\\\\\\?\\\\\";\n+    const UNC: &str = \"UNC\";\n+    const DEVICE: &str = \"\\\\\\\\.\\\\\";\n+    const COLON: &str = \":\";\n+\n+    impl Encode for std::path::Prefix<'_> {\n+        fn encode(&self, buf: &mut Vec<u8>) {\n+            match self {\n+                std::path::Prefix::Verbatim(c) => {\n+                    VERBATIM.encode(buf);\n+                    c.encode(buf);\n+                }\n+                std::path::Prefix::VerbatimUNC(server, share) => {\n+                    VERBATIM.encode(buf);\n+                    UNC.encode(buf);\n+                    SEP.encode(buf);\n+                    server.encode(buf);\n+                    SEP.encode(buf);\n+                    share.encode(buf);\n+                }\n+                std::path::Prefix::VerbatimDisk(d) => {\n+                    VERBATIM.encode(buf);\n+                    d.encode(buf);\n+                    COLON.encode(buf);\n+                }\n+                std::path::Prefix::DeviceNS(device) => {\n+                    DEVICE.encode(buf);\n+                    device.encode(buf);\n+                }\n+                std::path::Prefix::UNC(server, share) => {\n+                    SEP.encode(buf);\n+                    SEP.encode(buf);\n+                    server.encode(buf);\n+                    SEP.encode(buf);\n+                    share.encode(buf);\n+                }\n+                std::path::Prefix::Disk(d) => {\n+                    d.encode(buf);\n+                    COLON.encode(buf);\n+                }\n+            }\n+        }\n+    }\n+    #[test]\n+    fn paths_encoding() {\n+        // drive letter casing agnostic\n+        test_eq(\"C:/x.rs\", \"c:/x.rs\");\n+        // separator agnostic\n+        test_eq(\"C:/x/y.rs\", \"C:\\\\x\\\\y.rs\");\n+\n+        fn test_eq(a: &str, b: &str) {\n+            let mut b1 = Vec::new();\n+            let mut b2 = Vec::new();\n+            vfs(a).encode(&mut b1);\n+            vfs(b).encode(&mut b2);\n+            assert_eq!(b1, b2);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_sep_root_dir_encoding() {\n+        let mut buf = Vec::new();\n+        vfs(\"C:/x/y\").encode(&mut buf);\n+        assert_eq!(&buf, &[0, 67, 0, 58, 0, 92, 0, 120, 0, 92, 0, 121, 0])\n+    }\n+\n+    #[cfg(test)]\n+    fn vfs(str: &str) -> super::VfsPath {\n+        use super::{AbsPathBuf, VfsPath};\n+        use std::convert::TryFrom;\n+        VfsPath::from(AbsPathBuf::try_from(str).unwrap())\n+    }\n+}\n+\n #[derive(Clone, Ord, PartialOrd, Eq, PartialEq, Hash)]\n enum VfsPathRepr {\n     PathBuf(AbsPathBuf),"}]}