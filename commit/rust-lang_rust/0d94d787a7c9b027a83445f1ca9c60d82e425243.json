{"sha": "0d94d787a7c9b027a83445f1ca9c60d82e425243", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkOTRkNzg3YTdjOWIwMjdhODM0NDVmMWNhOWM2MGQ4MmU0MjUyNDM=", "commit": {"author": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-09-16T15:20:03Z"}, "committer": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-09-17T10:34:20Z"}, "message": "doc: Methods for option::Option", "tree": {"sha": "3f94db8d85c9efd4cfdf5a2672bb99580654ac0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f94db8d85c9efd4cfdf5a2672bb99580654ac0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d94d787a7c9b027a83445f1ca9c60d82e425243", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d94d787a7c9b027a83445f1ca9c60d82e425243", "html_url": "https://github.com/rust-lang/rust/commit/0d94d787a7c9b027a83445f1ca9c60d82e425243", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d94d787a7c9b027a83445f1ca9c60d82e425243/comments", "author": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e53db0b5c90fc43c9a708aaf9cb170305880d35b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e53db0b5c90fc43c9a708aaf9cb170305880d35b", "html_url": "https://github.com/rust-lang/rust/commit/e53db0b5c90fc43c9a708aaf9cb170305880d35b"}], "stats": {"total": 218, "additions": 217, "deletions": 1}, "files": [{"sha": "6020f7ce7f52cc858ec904986658832da735f2ab", "filename": "src/libcore/option.rs", "status": "modified", "additions": 217, "deletions": 1, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/0d94d787a7c9b027a83445f1ca9c60d82e425243/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d94d787a7c9b027a83445f1ca9c60d82e425243/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=0d94d787a7c9b027a83445f1ca9c60d82e425243", "patch": "@@ -175,6 +175,16 @@ impl<T> Option<T> {\n     /////////////////////////////////////////////////////////////////////////\n \n     /// Returns `true` if the option is a `Some` value\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x: Option<uint> = Some(2);\n+    /// assert_eq!(x.is_some(), true);\n+    ///\n+    /// let x: Option<uint> = None;\n+    /// assert_eq!(x.is_some(), false);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn is_some(&self) -> bool {\n@@ -185,6 +195,16 @@ impl<T> Option<T> {\n     }\n \n     /// Returns `true` if the option is a `None` value\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x: Option<uint> = Some(2);\n+    /// assert_eq!(x.is_none(), false);\n+    ///\n+    /// let x: Option<uint> = None;\n+    /// assert_eq!(x.is_none(), true);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn is_none(&self) -> bool {\n@@ -218,13 +238,37 @@ impl<T> Option<T> {\n     }\n \n     /// Convert from `Option<T>` to `Option<&mut T>`\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut x = Some(2u);\n+    /// match x.as_mut() {\n+    ///     Some(&ref mut v) => *v = 42,\n+    ///     None => {},\n+    /// }\n+    /// assert_eq!(x, Some(42u));\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for mut conventions\"]\n     pub fn as_mut<'r>(&'r mut self) -> Option<&'r mut T> {\n         match *self { Some(ref mut x) => Some(x), None => None }\n     }\n \n     /// Convert from `Option<T>` to `&mut [T]` (without copying)\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut x = Some(\"Diamonds\");\n+    /// {\n+    ///     let v = x.as_mut_slice();\n+    ///     assert!(v == [\"Diamonds\"]);\n+    ///     v[0] = \"Dirt\";\n+    ///     assert!(v == [\"Dirt\"]);\n+    /// }\n+    /// assert_eq!(x, Some(\"Dirt\"));\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for mut conventions\"]\n     pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n@@ -250,6 +294,18 @@ impl<T> Option<T> {\n     ///\n     /// Fails if the value is a `None` with a custom failure message provided by\n     /// `msg`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x = Some(\"value\");\n+    /// assert_eq!(x.expect(\"the world is ending\"), \"value\");\n+    /// ```\n+    ///\n+    /// ```{.should_fail}\n+    /// let x: Option<&str> = None;\n+    /// x.expect(\"the world is ending\"); // fails with `world is ending`\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for conventions\"]\n     pub fn expect(self, msg: &str) -> T {\n@@ -270,6 +326,18 @@ impl<T> Option<T> {\n     /// In general, because this function may fail, its use is discouraged.\n     /// Instead, prefer to use pattern matching and handle the `None`\n     /// case explicitly.\n+    ///\n+    /// # Examle\n+    ///\n+    /// ```\n+    /// let x = Some(\"air\");\n+    /// assert_eq!(x.unwrap(), \"air\");\n+    /// ```\n+    ///\n+    /// ```{.should_fail}\n+    /// let x: Option<&str> = None;\n+    /// assert_eq!(x.unwrap(), \"air\"); // fails\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for conventions\"]\n     pub fn unwrap(self) -> T {\n@@ -280,6 +348,13 @@ impl<T> Option<T> {\n     }\n \n     /// Returns the contained value or a default.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// assert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\n+    /// assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_or(self, def: T) -> T {\n@@ -290,6 +365,14 @@ impl<T> Option<T> {\n     }\n \n     /// Returns the contained value or computes it from a closure.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let k = 10u;\n+    /// assert_eq!(Some(4u).unwrap_or_else(|| 2 * k), 4u);\n+    /// assert_eq!(None.unwrap_or_else(|| 2 * k), 20u);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_or_else(self, f: || -> T) -> T {\n@@ -321,13 +404,35 @@ impl<T> Option<T> {\n     }\n \n     /// Applies a function to the contained value or returns a default.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x = Some(\"foo\");\n+    /// assert_eq!(x.map_or(42u, |v| v.len()), 3u);\n+    ///\n+    /// let x: Option<&str> = None;\n+    /// assert_eq!(x.map_or(42u, |v| v.len()), 42u);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n     pub fn map_or<U>(self, def: U, f: |T| -> U) -> U {\n         match self { None => def, Some(t) => f(t) }\n     }\n \n     /// Applies a function to the contained value or computes a default.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let k = 21u;\n+    ///\n+    /// let x = Some(\"foo\");\n+    /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 3u);\n+    ///\n+    /// let x: Option<&str> = None;\n+    /// assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 42u);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n     pub fn map_or_else<U>(self, def: || -> U, f: |T| -> U) -> U {\n@@ -366,6 +471,16 @@ impl<T> Option<T> {\n     /////////////////////////////////////////////////////////////////////////\n \n     /// Returns an iterator over the possibly contained value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x = Some(4u);\n+    /// assert_eq!(x.iter().next(), Some(&4));\n+    ///\n+    /// let x: Option<uint> = None;\n+    /// assert_eq!(x.iter().next(), None);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for iterator conventions\"]\n     pub fn iter<'r>(&'r self) -> Item<&'r T> {\n@@ -379,6 +494,20 @@ impl<T> Option<T> {\n     }\n \n     /// Returns a mutable iterator over the possibly contained value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut x = Some(4u);\n+    /// match x.iter_mut().next() {\n+    ///     Some(&ref mut v) => *v = 42u,\n+    ///     None => {},\n+    /// }\n+    /// assert_eq!(x, Some(42));\n+    ///\n+    /// let mut x: Option<uint> = None;\n+    /// assert_eq!(x.iter_mut().next(), None);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for iterator conventions\"]\n     pub fn iter_mut<'r>(&'r mut self) -> Item<&'r mut T> {\n@@ -392,6 +521,18 @@ impl<T> Option<T> {\n     }\n \n     /// Returns a consuming iterator over the possibly contained value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x = Some(\"string\");\n+    /// let v: Vec<&str> = x.into_iter().collect();\n+    /// assert_eq!(v, vec![\"string\"]);\n+    ///\n+    /// let x = None;\n+    /// let v: Vec<&str> = x.into_iter().collect();\n+    /// assert_eq!(v, vec![]);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for iterator conventions\"]\n     pub fn into_iter(self) -> Item<T> {\n@@ -403,6 +544,26 @@ impl<T> Option<T> {\n     /////////////////////////////////////////////////////////////////////////\n \n     /// Returns `None` if the option is `None`, otherwise returns `optb`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x = Some(2u);\n+    /// let y: Option<&str> = None;\n+    /// assert_eq!(x.and(y), None);\n+    ///\n+    /// let x: Option<uint> = None;\n+    /// let y = Some(\"foo\");\n+    /// assert_eq!(x.and(y), None);\n+    ///\n+    /// let x = Some(2u);\n+    /// let y = Some(\"foo\");\n+    /// assert_eq!(x.and(y), Some(\"foo\"));\n+    ///\n+    /// let x: Option<uint> = None;\n+    /// let y: Option<&str> = None;\n+    /// assert_eq!(x.and(y), None);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn and<U>(self, optb: Option<U>) -> Option<U> {\n@@ -414,6 +575,18 @@ impl<T> Option<T> {\n \n     /// Returns `None` if the option is `None`, otherwise calls `f` with the\n     /// wrapped value and returns the result.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// fn sq(x: uint) -> Option<uint> { Some(x * x) }\n+    /// fn nope(_: uint) -> Option<uint> { None }\n+    ///\n+    /// assert_eq!(Some(2).and_then(sq).and_then(sq), Some(16));\n+    /// assert_eq!(Some(2).and_then(sq).and_then(nope), None);\n+    /// assert_eq!(Some(2).and_then(nope).and_then(sq), None);\n+    /// assert_eq!(None.and_then(sq).and_then(sq), None);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n     pub fn and_then<U>(self, f: |T| -> Option<U>) -> Option<U> {\n@@ -424,6 +597,26 @@ impl<T> Option<T> {\n     }\n \n     /// Returns the option if it contains a value, otherwise returns `optb`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x = Some(2u);\n+    /// let y = None;\n+    /// assert_eq!(x.or(y), Some(2u));\n+    ///\n+    /// let x = None;\n+    /// let y = Some(100u);\n+    /// assert_eq!(x.or(y), Some(100u));\n+    ///\n+    /// let x = Some(2u);\n+    /// let y = Some(100u);\n+    /// assert_eq!(x.or(y), Some(2u));\n+    ///\n+    /// let x: Option<uint> = None;\n+    /// let y = None;\n+    /// assert_eq!(x.or(y), None);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn or(self, optb: Option<T>) -> Option<T> {\n@@ -435,6 +628,17 @@ impl<T> Option<T> {\n \n     /// Returns the option if it contains a value, otherwise calls `f` and\n     /// returns the result.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// fn nobody() -> Option<&'static str> { None }\n+    /// fn vikings() -> Option<&'static str> { Some(\"vikings\") }\n+    ///\n+    /// assert_eq!(Some(\"barbarians\").or_else(vikings), Some(\"barbarians\"));\n+    /// assert_eq!(None.or_else(vikings), Some(\"vikings\"));\n+    /// assert_eq!(None.or_else(nobody), None);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n     pub fn or_else(self, f: || -> Option<T>) -> Option<T> {\n@@ -449,6 +653,18 @@ impl<T> Option<T> {\n     /////////////////////////////////////////////////////////////////////////\n \n     /// Takes the value out of the option, leaving a `None` in its place.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut x = Some(2u);\n+    /// x.take();\n+    /// assert_eq!(x, None);\n+    ///\n+    /// let mut x: Option<uint> = None;\n+    /// x.take();\n+    /// assert_eq!(x, None);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn take(&mut self) -> Option<T> {\n@@ -613,7 +829,7 @@ impl<T> Default for Option<T> {\n \n /// An `Option` iterator that yields either one or zero elements\n ///\n-/// The `Item` iterator is returned by the `iter`, `mut_iter` and `move_iter`\n+/// The `Item` iterator is returned by the `iter`, `iter_mut` and `into_iter`\n /// methods on `Option`.\n #[deriving(Clone)]\n #[unstable = \"waiting for iterator conventions\"]"}]}