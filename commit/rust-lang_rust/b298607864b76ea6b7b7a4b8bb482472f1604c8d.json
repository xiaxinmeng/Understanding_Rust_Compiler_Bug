{"sha": "b298607864b76ea6b7b7a4b8bb482472f1604c8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyOTg2MDc4NjRiNzZlYTZiN2I3YTRiOGJiNDgyNDcyZjE2MDRjOGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-17T11:32:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-17T11:32:16Z"}, "message": "Auto merge of #47956 - retep998:is-nibbles, r=BurntSushi\n\nThis is the ideal FileType on Windows. You may not like it, but this is what peak performance looks like.\n\nTheoretically this would fix https://github.com/rust-lang/rust/issues/46484\n\nThe current iteration of this PR should not cause existing code to break, but instead merely improves handling around reparse points. Specifically...\n\n* Reparse points are considered to be symbolic links if they have the name surrogate bit set. Name surrogates are reparse points that effectively act like symbolic links, redirecting you to a different directory/file. By checking for this bit instead of specific tags, we become much more general in our handling of reparse points, including those added by third parties.\n* If something is a reparse point but does not have the name surrogate bit set, then we ignore the fact that it is a reparse point because it is actually a file or directory directly there, despite having additional handling by drivers due to the reparse point.\n* For everything which is not a symbolic link (including non-surrogate reparse points) we report whether it is a directory or a file based on the presence of the directory attribute bit.\n* Notably this still preserves invariant that when `is_symlink` returns `true`, both `is_dir` and `is_file` will return `false`. The potential for breakage was far too high.\n* Adds an unstable `FileTypeExt` to allow users to determine whether a symbolic link is a directory or a file, since `FileType` by design is incapable of reporting this information.", "tree": {"sha": "157995013480f83a3716e45277bdccad4171f89d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/157995013480f83a3716e45277bdccad4171f89d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b298607864b76ea6b7b7a4b8bb482472f1604c8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b298607864b76ea6b7b7a4b8bb482472f1604c8d", "html_url": "https://github.com/rust-lang/rust/commit/b298607864b76ea6b7b7a4b8bb482472f1604c8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b298607864b76ea6b7b7a4b8bb482472f1604c8d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b85bd51c944f8cbe3a9c4cc95b61e08e5f338052", "url": "https://api.github.com/repos/rust-lang/rust/commits/b85bd51c944f8cbe3a9c4cc95b61e08e5f338052", "html_url": "https://github.com/rust-lang/rust/commit/b85bd51c944f8cbe3a9c4cc95b61e08e5f338052"}, {"sha": "9269e83b37e8e5fd9cef12255fafbc6db6220035", "url": "https://api.github.com/repos/rust-lang/rust/commits/9269e83b37e8e5fd9cef12255fafbc6db6220035", "html_url": "https://github.com/rust-lang/rust/commit/9269e83b37e8e5fd9cef12255fafbc6db6220035"}], "stats": {"total": 65, "additions": 44, "deletions": 21}, "files": [{"sha": "38bf4cca851fe3bfc4395ed7fbd4c13b4ba0ce74", "filename": "src/libstd/sys/windows/ext/fs.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b298607864b76ea6b7b7a4b8bb482472f1604c8d/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b298607864b76ea6b7b7a4b8bb482472f1604c8d/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs?ref=b298607864b76ea6b7b7a4b8bb482472f1604c8d", "patch": "@@ -445,6 +445,24 @@ impl MetadataExt for Metadata {\n     fn file_size(&self) -> u64 { self.as_inner().size() }\n }\n \n+/// Add support for the Windows specific fact that a symbolic link knows whether it is a file\n+/// or directory.\n+#[unstable(feature = \"windows_file_type_ext\", issue = \"0\")]\n+pub trait FileTypeExt {\n+    /// Returns whether this file type is a symbolic link that is also a directory.\n+    #[unstable(feature = \"windows_file_type_ext\", issue = \"0\")]\n+    fn is_symlink_dir(&self) -> bool;\n+    /// Returns whether this file type is a symbolic link that is also a file.\n+    #[unstable(feature = \"windows_file_type_ext\", issue = \"0\")]\n+    fn is_symlink_file(&self) -> bool;\n+}\n+\n+#[unstable(feature = \"windows_file_type_ext\", issue = \"0\")]\n+impl FileTypeExt for fs::FileType {\n+    fn is_symlink_dir(&self) -> bool { self.as_inner().is_symlink_dir() }\n+    fn is_symlink_file(&self) -> bool { self.as_inner().is_symlink_file() }\n+}\n+\n /// Creates a new file symbolic link on the filesystem.\n ///\n /// The `dst` path will be a file symbolic link pointing to the `src`"}, {"sha": "082d4689c7ba8ef16e60f3597d7e263ab40128b4", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b298607864b76ea6b7b7a4b8bb482472f1604c8d/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b298607864b76ea6b7b7a4b8bb482472f1604c8d/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=b298607864b76ea6b7b7a4b8bb482472f1604c8d", "patch": "@@ -38,8 +38,9 @@ pub struct FileAttr {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub enum FileType {\n-    Dir, File, SymlinkFile, SymlinkDir, ReparsePoint, MountPoint,\n+pub struct FileType {\n+    attributes: c::DWORD,\n+    reparse_tag: c::DWORD,\n }\n \n pub struct ReadDir {\n@@ -516,30 +517,34 @@ impl FilePermissions {\n \n impl FileType {\n     fn new(attrs: c::DWORD, reparse_tag: c::DWORD) -> FileType {\n-        match (attrs & c::FILE_ATTRIBUTE_DIRECTORY != 0,\n-               attrs & c::FILE_ATTRIBUTE_REPARSE_POINT != 0,\n-               reparse_tag) {\n-            (false, false, _) => FileType::File,\n-            (true, false, _) => FileType::Dir,\n-            (false, true, c::IO_REPARSE_TAG_SYMLINK) => FileType::SymlinkFile,\n-            (true, true, c::IO_REPARSE_TAG_SYMLINK) => FileType::SymlinkDir,\n-            (true, true, c::IO_REPARSE_TAG_MOUNT_POINT) => FileType::MountPoint,\n-            (_, true, _) => FileType::ReparsePoint,\n-            // Note: if a _file_ has a reparse tag of the type IO_REPARSE_TAG_MOUNT_POINT it is\n-            // invalid, as junctions always have to be dirs. We set the filetype to ReparsePoint\n-            // to indicate it is something symlink-like, but not something you can follow.\n+        FileType {\n+            attributes: attrs,\n+            reparse_tag: reparse_tag,\n         }\n     }\n-\n-    pub fn is_dir(&self) -> bool { *self == FileType::Dir }\n-    pub fn is_file(&self) -> bool { *self == FileType::File }\n+    pub fn is_dir(&self) -> bool {\n+        !self.is_symlink() && self.is_directory()\n+    }\n+    pub fn is_file(&self) -> bool {\n+        !self.is_symlink() && !self.is_directory()\n+    }\n     pub fn is_symlink(&self) -> bool {\n-        *self == FileType::SymlinkFile ||\n-        *self == FileType::SymlinkDir ||\n-        *self == FileType::MountPoint\n+        self.is_reparse_point() && self.is_reparse_tag_name_surrogate()\n     }\n     pub fn is_symlink_dir(&self) -> bool {\n-        *self == FileType::SymlinkDir || *self == FileType::MountPoint\n+        self.is_symlink() && self.is_directory()\n+    }\n+    pub fn is_symlink_file(&self) -> bool {\n+        self.is_symlink() && !self.is_directory()\n+    }\n+    fn is_directory(&self) -> bool {\n+        self.attributes & c::FILE_ATTRIBUTE_DIRECTORY != 0\n+    }\n+    fn is_reparse_point(&self) -> bool {\n+        self.attributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0\n+    }\n+    fn is_reparse_tag_name_surrogate(&self) -> bool {\n+        self.reparse_tag & 0x20000000 != 0\n     }\n }\n "}]}