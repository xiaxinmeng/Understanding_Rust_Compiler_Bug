{"sha": "18d27b2c94cff9a5f6d8e4d2ea45f6f2e434e5f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ZDI3YjJjOTRjZmY5YTVmNmQ4ZTRkMmVhNDVmNmYyZTQzNGU1ZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-01T10:29:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-01T10:29:43Z"}, "message": "Auto merge of #80310 - Manishearth:box-try-alloc, r=kennytm\n\nAdd fallible Box, Arc, and Rc allocator APIs\n\ncc https://github.com/rust-lang/rust/issues/48043\n\nIt was suggested in https://github.com/rust-lang/rust/issues/48043#issuecomment-748008486 that `Box::try_*` follows the spirit of RFC 2116. This PR is an attempt to add the relevant APIs, tied to the same feature gate. Happy to make any changes or turn this into an RFC if necessary.\n\ncc `@rust-lang/wg-allocators`", "tree": {"sha": "58a142b3549def04f6995114fd94f723cd75d8d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58a142b3549def04f6995114fd94f723cd75d8d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18d27b2c94cff9a5f6d8e4d2ea45f6f2e434e5f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18d27b2c94cff9a5f6d8e4d2ea45f6f2e434e5f6", "html_url": "https://github.com/rust-lang/rust/commit/18d27b2c94cff9a5f6d8e4d2ea45f6f2e434e5f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18d27b2c94cff9a5f6d8e4d2ea45f6f2e434e5f6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1fc9ff4a794fb069d670dded1a66f05c86f3555", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1fc9ff4a794fb069d670dded1a66f05c86f3555", "html_url": "https://github.com/rust-lang/rust/commit/e1fc9ff4a794fb069d670dded1a66f05c86f3555"}, {"sha": "375e7c58644d1f7959bfd33caf455d6aa34cc326", "url": "https://api.github.com/repos/rust-lang/rust/commits/375e7c58644d1f7959bfd33caf455d6aa34cc326", "html_url": "https://github.com/rust-lang/rust/commit/375e7c58644d1f7959bfd33caf455d6aa34cc326"}], "stats": {"total": 399, "additions": 389, "deletions": 10}, "files": [{"sha": "8eb2caa60b12679a23baeee0eb7675c9d97172b2", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 160, "deletions": 6, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/18d27b2c94cff9a5f6d8e4d2ea45f6f2e434e5f6/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d27b2c94cff9a5f6d8e4d2ea45f6f2e434e5f6/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=18d27b2c94cff9a5f6d8e4d2ea45f6f2e434e5f6", "patch": "@@ -153,7 +153,7 @@ use core::pin::Pin;\n use core::ptr::{self, Unique};\n use core::task::{Context, Poll};\n \n-use crate::alloc::{handle_alloc_error, Allocator, Global, Layout};\n+use crate::alloc::{handle_alloc_error, AllocError, Allocator, Global, Layout};\n use crate::borrow::Cow;\n use crate::raw_vec::RawVec;\n use crate::str::from_boxed_utf8_unchecked;\n@@ -241,6 +241,78 @@ impl<T> Box<T> {\n     pub fn pin(x: T) -> Pin<Box<T>> {\n         (box x).into()\n     }\n+\n+    /// Allocates memory on the heap then places `x` into it,\n+    /// returning an error if the allocation fails\n+    ///\n+    /// This doesn't actually allocate if `T` is zero-sized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api)]\n+    ///\n+    /// let five = Box::try_new(5)?;\n+    /// # Ok::<(), std::alloc::AllocError>(())\n+    /// ```\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn try_new(x: T) -> Result<Self, AllocError> {\n+        Self::try_new_in(x, Global)\n+    }\n+\n+    /// Constructs a new box with uninitialized contents on the heap,\n+    /// returning an error if the allocation fails\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api, new_uninit)]\n+    ///\n+    /// let mut five = Box::<u32>::try_new_uninit()?;\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     five.as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5);\n+    /// # Ok::<(), std::alloc::AllocError>(())\n+    /// ```\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub fn try_new_uninit() -> Result<Box<mem::MaybeUninit<T>>, AllocError> {\n+        Box::try_new_uninit_in(Global)\n+    }\n+\n+    /// Constructs a new `Box` with uninitialized contents, with the memory\n+    /// being filled with `0` bytes on the heap\n+    ///\n+    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and incorrect usage\n+    /// of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api, new_uninit)]\n+    ///\n+    /// let zero = Box::<u32>::try_new_zeroed()?;\n+    /// let zero = unsafe { zero.assume_init() };\n+    ///\n+    /// assert_eq!(*zero, 0);\n+    /// # Ok::<(), std::alloc::AllocError>(())\n+    /// ```\n+    ///\n+    /// [zeroed]: mem::MaybeUninit::zeroed\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub fn try_new_zeroed() -> Result<Box<mem::MaybeUninit<T>>, AllocError> {\n+        Box::try_new_zeroed_in(Global)\n+    }\n }\n \n impl<T, A: Allocator> Box<T, A> {\n@@ -267,6 +339,31 @@ impl<T, A: Allocator> Box<T, A> {\n         }\n     }\n \n+    /// Allocates memory in the given allocator then places `x` into it,\n+    /// returning an error if the allocation fails\n+    ///\n+    /// This doesn't actually allocate if `T` is zero-sized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api)]\n+    ///\n+    /// use std::alloc::System;\n+    ///\n+    /// let five = Box::try_new_in(5, System)?;\n+    /// # Ok::<(), std::alloc::AllocError>(())\n+    /// ```\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn try_new_in(x: T, alloc: A) -> Result<Self, AllocError> {\n+        let mut boxed = Self::try_new_uninit_in(alloc)?;\n+        unsafe {\n+            boxed.as_mut_ptr().write(x);\n+            Ok(boxed.assume_init())\n+        }\n+    }\n+\n     /// Constructs a new box with uninitialized contents in the provided allocator.\n     ///\n     /// # Examples\n@@ -291,8 +388,37 @@ impl<T, A: Allocator> Box<T, A> {\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A> {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n-        let ptr = alloc.allocate(layout).unwrap_or_else(|_| handle_alloc_error(layout)).cast();\n-        unsafe { Box::from_raw_in(ptr.as_ptr(), alloc) }\n+        Box::try_new_uninit_in(alloc).unwrap_or_else(|_| handle_alloc_error(layout))\n+    }\n+\n+    /// Constructs a new box with uninitialized contents in the provided allocator,\n+    /// returning an error if the allocation fails\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api, new_uninit)]\n+    ///\n+    /// use std::alloc::System;\n+    ///\n+    /// let mut five = Box::<u32, _>::try_new_uninit_in(System)?;\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     five.as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5);\n+    /// # Ok::<(), std::alloc::AllocError>(())\n+    /// ```\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn try_new_uninit_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError> {\n+        let layout = Layout::new::<mem::MaybeUninit<T>>();\n+        let ptr = alloc.allocate(layout)?.cast();\n+        unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }\n     }\n \n     /// Constructs a new `Box` with uninitialized contents, with the memory\n@@ -319,9 +445,37 @@ impl<T, A: Allocator> Box<T, A> {\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_zeroed_in(alloc: A) -> Box<mem::MaybeUninit<T>, A> {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n-        let ptr =\n-            alloc.allocate_zeroed(layout).unwrap_or_else(|_| handle_alloc_error(layout)).cast();\n-        unsafe { Box::from_raw_in(ptr.as_ptr(), alloc) }\n+        Box::try_new_zeroed_in(alloc).unwrap_or_else(|_| handle_alloc_error(layout))\n+    }\n+\n+    /// Constructs a new `Box` with uninitialized contents, with the memory\n+    /// being filled with `0` bytes in the provided allocator,\n+    /// returning an error if the allocation fails,\n+    ///\n+    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and incorrect usage\n+    /// of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api, new_uninit)]\n+    ///\n+    /// use std::alloc::System;\n+    ///\n+    /// let zero = Box::<u32, _>::try_new_zeroed_in(System)?;\n+    /// let zero = unsafe { zero.assume_init() };\n+    ///\n+    /// assert_eq!(*zero, 0);\n+    /// # Ok::<(), std::alloc::AllocError>(())\n+    /// ```\n+    ///\n+    /// [zeroed]: mem::MaybeUninit::zeroed\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn try_new_zeroed_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError> {\n+        let layout = Layout::new::<mem::MaybeUninit<T>>();\n+        let ptr = alloc.allocate_zeroed(layout)?.cast();\n+        unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }\n     }\n \n     /// Constructs a new `Pin<Box<T, A>>`. If `T` does not implement `Unpin`, then"}, {"sha": "3115cc3d002090b6a69bb6e76109f91a62f37bc5", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 114, "deletions": 2, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/18d27b2c94cff9a5f6d8e4d2ea45f6f2e434e5f6/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d27b2c94cff9a5f6d8e4d2ea45f6f2e434e5f6/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=18d27b2c94cff9a5f6d8e4d2ea45f6f2e434e5f6", "patch": "@@ -453,6 +453,95 @@ impl<T> Rc<T> {\n         }\n     }\n \n+    /// Constructs a new `Rc<T>`, returning an error if the allocation fails\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api)]\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::try_new(5);\n+    /// # Ok::<(), std::alloc::AllocError>(())\n+    /// ```\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    pub fn try_new(value: T) -> Result<Rc<T>, AllocError> {\n+        // There is an implicit weak pointer owned by all the strong\n+        // pointers, which ensures that the weak destructor never frees\n+        // the allocation while the strong destructor is running, even\n+        // if the weak pointer is stored inside the strong one.\n+        Ok(Self::from_inner(\n+            Box::leak(Box::try_new(RcBox { strong: Cell::new(1), weak: Cell::new(1), value })?)\n+                .into(),\n+        ))\n+    }\n+\n+    /// Constructs a new `Rc` with uninitialized contents, returning an error if the allocation fails\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api, new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut five = Rc::<u32>::try_new_uninit()?;\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5);\n+    /// # Ok::<(), std::alloc::AllocError>(())\n+    /// ```\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn try_new_uninit() -> Result<Rc<mem::MaybeUninit<T>>, AllocError> {\n+        unsafe {\n+            Ok(Rc::from_ptr(Rc::try_allocate_for_layout(\n+                Layout::new::<T>(),\n+                |layout| Global.allocate(layout),\n+                |mem| mem as *mut RcBox<mem::MaybeUninit<T>>,\n+            )?))\n+        }\n+    }\n+\n+    /// Constructs a new `Rc` with uninitialized contents, with the memory\n+    /// being filled with `0` bytes, returning an error if the allocation fails\n+    ///\n+    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and\n+    /// incorrect usage of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api, new_uninit)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let zero = Rc::<u32>::try_new_zeroed()?;\n+    /// let zero = unsafe { zero.assume_init() };\n+    ///\n+    /// assert_eq!(*zero, 0);\n+    /// # Ok::<(), std::alloc::AllocError>(())\n+    /// ```\n+    ///\n+    /// [zeroed]: mem::MaybeUninit::zeroed\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    //#[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn try_new_zeroed() -> Result<Rc<mem::MaybeUninit<T>>, AllocError> {\n+        unsafe {\n+            Ok(Rc::from_ptr(Rc::try_allocate_for_layout(\n+                Layout::new::<T>(),\n+                |layout| Global.allocate_zeroed(layout),\n+                |mem| mem as *mut RcBox<mem::MaybeUninit<T>>,\n+            )?))\n+        }\n+    }\n     /// Constructs a new `Pin<Rc<T>>`. If `T` does not implement `Unpin`, then\n     /// `value` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -1018,9 +1107,32 @@ impl<T: ?Sized> Rc<T> {\n         // `&*(ptr as *const RcBox<T>)`, but this created a misaligned\n         // reference (see #54908).\n         let layout = Layout::new::<RcBox<()>>().extend(value_layout).unwrap().0.pad_to_align();\n+        unsafe {\n+            Rc::try_allocate_for_layout(value_layout, allocate, mem_to_rcbox)\n+                .unwrap_or_else(|_| handle_alloc_error(layout))\n+        }\n+    }\n+\n+    /// Allocates an `RcBox<T>` with sufficient space for\n+    /// a possibly-unsized inner value where the value has the layout provided,\n+    /// returning an error if allocation fails.\n+    ///\n+    /// The function `mem_to_rcbox` is called with the data pointer\n+    /// and must return back a (potentially fat)-pointer for the `RcBox<T>`.\n+    #[inline]\n+    unsafe fn try_allocate_for_layout(\n+        value_layout: Layout,\n+        allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,\n+        mem_to_rcbox: impl FnOnce(*mut u8) -> *mut RcBox<T>,\n+    ) -> Result<*mut RcBox<T>, AllocError> {\n+        // Calculate layout using the given value layout.\n+        // Previously, layout was calculated on the expression\n+        // `&*(ptr as *const RcBox<T>)`, but this created a misaligned\n+        // reference (see #54908).\n+        let layout = Layout::new::<RcBox<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n         // Allocate for the layout.\n-        let ptr = allocate(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let ptr = allocate(layout)?;\n \n         // Initialize the RcBox\n         let inner = mem_to_rcbox(ptr.as_non_null_ptr().as_ptr());\n@@ -1031,7 +1143,7 @@ impl<T: ?Sized> Rc<T> {\n             ptr::write(&mut (*inner).weak, Cell::new(1));\n         }\n \n-        inner\n+        Ok(inner)\n     }\n \n     /// Allocates an `RcBox<T>` with sufficient space for an unsized inner value"}, {"sha": "06ad621727166b13ac36874f6fe6fe60de91ae97", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 115, "deletions": 2, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/18d27b2c94cff9a5f6d8e4d2ea45f6f2e434e5f6/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18d27b2c94cff9a5f6d8e4d2ea45f6f2e434e5f6/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=18d27b2c94cff9a5f6d8e4d2ea45f6f2e434e5f6", "patch": "@@ -478,6 +478,97 @@ impl<T> Arc<T> {\n         unsafe { Pin::new_unchecked(Arc::new(data)) }\n     }\n \n+    /// Constructs a new `Arc<T>`, returning an error if allocation fails.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api)]\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::try_new(5)?;\n+    /// # Ok::<(), std::alloc::AllocError>(())\n+    /// ```\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[inline]\n+    pub fn try_new(data: T) -> Result<Arc<T>, AllocError> {\n+        // Start the weak pointer count as 1 which is the weak pointer that's\n+        // held by all the strong pointers (kinda), see std/rc.rs for more info\n+        let x: Box<_> = Box::try_new(ArcInner {\n+            strong: atomic::AtomicUsize::new(1),\n+            weak: atomic::AtomicUsize::new(1),\n+            data,\n+        })?;\n+        Ok(Self::from_inner(Box::leak(x).into()))\n+    }\n+\n+    /// Constructs a new `Arc` with uninitialized contents, returning an error\n+    /// if allocation fails.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit, allocator_api)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut five = Arc::<u32>::try_new_uninit()?;\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5);\n+    /// # Ok::<(), std::alloc::AllocError>(())\n+    /// ```\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn try_new_uninit() -> Result<Arc<mem::MaybeUninit<T>>, AllocError> {\n+        unsafe {\n+            Ok(Arc::from_ptr(Arc::try_allocate_for_layout(\n+                Layout::new::<T>(),\n+                |layout| Global.allocate(layout),\n+                |mem| mem as *mut ArcInner<mem::MaybeUninit<T>>,\n+            )?))\n+        }\n+    }\n+\n+    /// Constructs a new `Arc` with uninitialized contents, with the memory\n+    /// being filled with `0` bytes, returning an error if allocation fails.\n+    ///\n+    /// See [`MaybeUninit::zeroed`][zeroed] for examples of correct and incorrect usage\n+    /// of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit, allocator_api)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let zero = Arc::<u32>::try_new_zeroed()?;\n+    /// let zero = unsafe { zero.assume_init() };\n+    ///\n+    /// assert_eq!(*zero, 0);\n+    /// # Ok::<(), std::alloc::AllocError>(())\n+    /// ```\n+    ///\n+    /// [zeroed]: mem::MaybeUninit::zeroed\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn try_new_zeroed() -> Result<Arc<mem::MaybeUninit<T>>, AllocError> {\n+        unsafe {\n+            Ok(Arc::from_ptr(Arc::try_allocate_for_layout(\n+                Layout::new::<T>(),\n+                |layout| Global.allocate_zeroed(layout),\n+                |mem| mem as *mut ArcInner<mem::MaybeUninit<T>>,\n+            )?))\n+        }\n+    }\n     /// Returns the inner value, if the `Arc` has exactly one strong reference.\n     ///\n     /// Otherwise, an [`Err`] is returned with the same `Arc` that was\n@@ -994,8 +1085,30 @@ impl<T: ?Sized> Arc<T> {\n         // `&*(ptr as *const ArcInner<T>)`, but this created a misaligned\n         // reference (see #54908).\n         let layout = Layout::new::<ArcInner<()>>().extend(value_layout).unwrap().0.pad_to_align();\n+        unsafe {\n+            Arc::try_allocate_for_layout(value_layout, allocate, mem_to_arcinner)\n+                .unwrap_or_else(|_| handle_alloc_error(layout))\n+        }\n+    }\n+\n+    /// Allocates an `ArcInner<T>` with sufficient space for\n+    /// a possibly-unsized inner value where the value has the layout provided,\n+    /// returning an error if allocation fails.\n+    ///\n+    /// The function `mem_to_arcinner` is called with the data pointer\n+    /// and must return back a (potentially fat)-pointer for the `ArcInner<T>`.\n+    unsafe fn try_allocate_for_layout(\n+        value_layout: Layout,\n+        allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,\n+        mem_to_arcinner: impl FnOnce(*mut u8) -> *mut ArcInner<T>,\n+    ) -> Result<*mut ArcInner<T>, AllocError> {\n+        // Calculate layout using the given value layout.\n+        // Previously, layout was calculated on the expression\n+        // `&*(ptr as *const ArcInner<T>)`, but this created a misaligned\n+        // reference (see #54908).\n+        let layout = Layout::new::<ArcInner<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n-        let ptr = allocate(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let ptr = allocate(layout)?;\n \n         // Initialize the ArcInner\n         let inner = mem_to_arcinner(ptr.as_non_null_ptr().as_ptr());\n@@ -1006,7 +1119,7 @@ impl<T: ?Sized> Arc<T> {\n             ptr::write(&mut (*inner).weak, atomic::AtomicUsize::new(1));\n         }\n \n-        inner\n+        Ok(inner)\n     }\n \n     /// Allocates an `ArcInner<T>` with sufficient space for an unsized inner value."}]}