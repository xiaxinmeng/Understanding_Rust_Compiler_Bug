{"sha": "fb9104768c0991b935e4b5cbc67180e49d425f2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiOTEwNDc2OGMwOTkxYjkzNWU0YjVjYmM2NzE4MGU0OWQ0MjVmMmM=", "commit": {"author": {"name": "Brian Vincent", "email": "brainn@gmail.com", "date": "2017-02-02T06:58:18Z"}, "committer": {"name": "Brian Vincent", "email": "brainn@gmail.com", "date": "2017-02-10T06:16:04Z"}, "message": "Dont segfault if btree range is not in order", "tree": {"sha": "1342e29e8ffaa3daf9467ed45d7139b96bc1b5ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1342e29e8ffaa3daf9467ed45d7139b96bc1b5ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb9104768c0991b935e4b5cbc67180e49d425f2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb9104768c0991b935e4b5cbc67180e49d425f2c", "html_url": "https://github.com/rust-lang/rust/commit/fb9104768c0991b935e4b5cbc67180e49d425f2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb9104768c0991b935e4b5cbc67180e49d425f2c/comments", "author": {"login": "bvinc", "id": 165166, "node_id": "MDQ6VXNlcjE2NTE2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/165166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bvinc", "html_url": "https://github.com/bvinc", "followers_url": "https://api.github.com/users/bvinc/followers", "following_url": "https://api.github.com/users/bvinc/following{/other_user}", "gists_url": "https://api.github.com/users/bvinc/gists{/gist_id}", "starred_url": "https://api.github.com/users/bvinc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bvinc/subscriptions", "organizations_url": "https://api.github.com/users/bvinc/orgs", "repos_url": "https://api.github.com/users/bvinc/repos", "events_url": "https://api.github.com/users/bvinc/events{/privacy}", "received_events_url": "https://api.github.com/users/bvinc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bvinc", "id": 165166, "node_id": "MDQ6VXNlcjE2NTE2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/165166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bvinc", "html_url": "https://github.com/bvinc", "followers_url": "https://api.github.com/users/bvinc/followers", "following_url": "https://api.github.com/users/bvinc/following{/other_user}", "gists_url": "https://api.github.com/users/bvinc/gists{/gist_id}", "starred_url": "https://api.github.com/users/bvinc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bvinc/subscriptions", "organizations_url": "https://api.github.com/users/bvinc/orgs", "repos_url": "https://api.github.com/users/bvinc/repos", "events_url": "https://api.github.com/users/bvinc/events{/privacy}", "received_events_url": "https://api.github.com/users/bvinc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24a70eb598a76edb0941f628a87946b40f2a1c83", "url": "https://api.github.com/repos/rust-lang/rust/commits/24a70eb598a76edb0941f628a87946b40f2a1c83", "html_url": "https://github.com/rust-lang/rust/commit/24a70eb598a76edb0941f628a87946b40f2a1c83"}], "stats": {"total": 249, "additions": 134, "deletions": 115}, "files": [{"sha": "7218d15ded5f802df0f7b19d926da531d4e8136b", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 91, "deletions": 113, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/fb9104768c0991b935e4b5cbc67180e49d425f2c/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9104768c0991b935e4b5cbc67180e49d425f2c/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=fb9104768c0991b935e4b5cbc67180e49d425f2c", "patch": "@@ -714,6 +714,11 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// `range((Excluded(4), Included(10)))` will yield a left-exclusive, right-inclusive\n     /// range from 4 to 10.\n     ///\n+    /// # Panics\n+    ///\n+    /// Panics if range `start > end`.\n+    /// Panics if range `start == end` and both bounds are `Excluded`.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -739,64 +744,11 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn range<T: ?Sized, R>(&self, range: R) -> Range<K, V>\n         where T: Ord, K: Borrow<T>, R: RangeArgument<T>\n     {\n-        let min = range.start();\n-        let max = range.end();\n-        let front = match min {\n-            Included(key) => {\n-                match search::search_tree(self.root.as_ref(), key) {\n-                    Found(kv_handle) => {\n-                        match kv_handle.left_edge().force() {\n-                            Leaf(bottom) => bottom,\n-                            Internal(internal) => last_leaf_edge(internal.descend()),\n-                        }\n-                    }\n-                    GoDown(bottom) => bottom,\n-                }\n-            }\n-            Excluded(key) => {\n-                match search::search_tree(self.root.as_ref(), key) {\n-                    Found(kv_handle) => {\n-                        match kv_handle.right_edge().force() {\n-                            Leaf(bottom) => bottom,\n-                            Internal(internal) => first_leaf_edge(internal.descend()),\n-                        }\n-                    }\n-                    GoDown(bottom) => bottom,\n-                }\n-            }\n-            Unbounded => first_leaf_edge(self.root.as_ref()),\n-        };\n+        let root1 = self.root.as_ref();\n+        let root2 = self.root.as_ref();\n+        let (f, b) = range_search(root1, root2, range);\n \n-        let back = match max {\n-            Included(key) => {\n-                match search::search_tree(self.root.as_ref(), key) {\n-                    Found(kv_handle) => {\n-                        match kv_handle.right_edge().force() {\n-                            Leaf(bottom) => bottom,\n-                            Internal(internal) => first_leaf_edge(internal.descend()),\n-                        }\n-                    }\n-                    GoDown(bottom) => bottom,\n-                }\n-            }\n-            Excluded(key) => {\n-                match search::search_tree(self.root.as_ref(), key) {\n-                    Found(kv_handle) => {\n-                        match kv_handle.left_edge().force() {\n-                            Leaf(bottom) => bottom,\n-                            Internal(internal) => last_leaf_edge(internal.descend()),\n-                        }\n-                    }\n-                    GoDown(bottom) => bottom,\n-                }\n-            }\n-            Unbounded => last_leaf_edge(self.root.as_ref()),\n-        };\n-\n-        Range {\n-            front: front,\n-            back: back,\n-        }\n+        Range { front: f, back: b}\n     }\n \n     /// Constructs a mutable double-ended iterator over a sub-range of elements in the map.\n@@ -806,6 +758,11 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// `range((Excluded(4), Included(10)))` will yield a left-exclusive, right-inclusive\n     /// range from 4 to 10.\n     ///\n+    /// # Panics\n+    ///\n+    /// Panics if range `start > end`.\n+    /// Panics if range `start == end` and both bounds are `Excluded`.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -831,66 +788,13 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn range_mut<T: ?Sized, R>(&mut self, range: R) -> RangeMut<K, V>\n         where T: Ord, K: Borrow<T>, R: RangeArgument<T>\n     {\n-        let min = range.start();\n-        let max = range.end();\n         let root1 = self.root.as_mut();\n         let root2 = unsafe { ptr::read(&root1) };\n-\n-        let front = match min {\n-            Included(key) => {\n-                match search::search_tree(root1, key) {\n-                    Found(kv_handle) => {\n-                        match kv_handle.left_edge().force() {\n-                            Leaf(bottom) => bottom,\n-                            Internal(internal) => last_leaf_edge(internal.descend()),\n-                        }\n-                    }\n-                    GoDown(bottom) => bottom,\n-                }\n-            }\n-            Excluded(key) => {\n-                match search::search_tree(root1, key) {\n-                    Found(kv_handle) => {\n-                        match kv_handle.right_edge().force() {\n-                            Leaf(bottom) => bottom,\n-                            Internal(internal) => first_leaf_edge(internal.descend()),\n-                        }\n-                    }\n-                    GoDown(bottom) => bottom,\n-                }\n-            }\n-            Unbounded => first_leaf_edge(root1),\n-        };\n-\n-        let back = match max {\n-            Included(key) => {\n-                match search::search_tree(root2, key) {\n-                    Found(kv_handle) => {\n-                        match kv_handle.right_edge().force() {\n-                            Leaf(bottom) => bottom,\n-                            Internal(internal) => first_leaf_edge(internal.descend()),\n-                        }\n-                    }\n-                    GoDown(bottom) => bottom,\n-                }\n-            }\n-            Excluded(key) => {\n-                match search::search_tree(root2, key) {\n-                    Found(kv_handle) => {\n-                        match kv_handle.left_edge().force() {\n-                            Leaf(bottom) => bottom,\n-                            Internal(internal) => last_leaf_edge(internal.descend()),\n-                        }\n-                    }\n-                    GoDown(bottom) => bottom,\n-                }\n-            }\n-            Unbounded => last_leaf_edge(root2),\n-        };\n+        let (f, b) = range_search(root1, root2, range);\n \n         RangeMut {\n-            front: front,\n-            back: back,\n+            front: f,\n+            back: b,\n             _marker: PhantomData,\n         }\n     }\n@@ -1827,6 +1731,80 @@ fn last_leaf_edge<BorrowType, K, V>\n     }\n }\n \n+fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeArgument<Q>>(\n+    root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+    root2: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+    range: R\n+)-> (Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n+     Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>)\n+        where Q: Ord, K: Borrow<Q>\n+{\n+    match (range.start(), range.end()) {\n+        (Excluded(s), Excluded(e)) if s==e =>\n+            panic!(\"range start and end are equal and excluded in BTreeMap\"),\n+        (Included(s), Included(e)) |\n+        (Included(s), Excluded(e)) |\n+        (Excluded(s), Included(e)) |\n+        (Excluded(s), Excluded(e)) if s>e =>\n+            panic!(\"range start is greater than range end in BTreeMap\"),\n+        _ => {},\n+    };\n+\n+    let mut min_node = root1;\n+    let mut max_node = root2;\n+    let mut min_found = false;\n+    let mut max_found = false;\n+    let mut diverged = false;\n+\n+    loop {\n+        let min_edge = match (min_found, range.start()) {\n+            (false, Included(key)) => match search::search_linear(&min_node, key) {\n+                (i, true) => { min_found = true; i },\n+                (i, false) => i,\n+            },\n+            (false, Excluded(key)) => match search::search_linear(&min_node, key) {\n+                (i, true) => { min_found = true; i+1 },\n+                (i, false) => i,\n+            },\n+            (_, Unbounded) => 0,\n+            (true, Included(_)) => min_node.keys().len(),\n+            (true, Excluded(_)) => 0,\n+        };\n+\n+        let max_edge = match (max_found, range.end()) {\n+            (false, Included(key)) => match search::search_linear(&max_node, key) {\n+                (i, true) => { max_found = true; i+1 },\n+                (i, false) => i,\n+            },\n+            (false, Excluded(key)) => match search::search_linear(&max_node, key) {\n+                (i, true) => { max_found = true; i },\n+                (i, false) => i,\n+            },\n+            (_, Unbounded) => max_node.keys().len(),\n+            (true, Included(_)) => 0,\n+            (true, Excluded(_)) => max_node.keys().len(),\n+        };\n+\n+        if !diverged {\n+            if max_edge < min_edge { panic!(\"Ord is ill-defined in BTreeMap range\") }\n+            if min_edge != max_edge { diverged = true; }\n+        }\n+\n+        let front = Handle::new_edge(min_node, min_edge);\n+        let back = Handle::new_edge(max_node, max_edge);\n+        match (front.force(), back.force()) {\n+            (Leaf(f), Leaf(b)) => {\n+                return (f, b);\n+            },\n+            (Internal(min_int), Internal(max_int)) => {\n+                min_node = min_int.descend();\n+                max_node = max_int.descend();\n+            },\n+            _ => unreachable!(\"BTreeMap has different depths\"),\n+        };\n+    }\n+}\n+\n #[inline(always)]\n unsafe fn unwrap_unchecked<T>(val: Option<T>) -> T {\n     val.unwrap_or_else(|| {"}, {"sha": "bc1272fbc786e7aa4c2c9e39e24345c3a84f68a4", "filename": "src/libcollections/btree/search.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb9104768c0991b935e4b5cbc67180e49d425f2c/src%2Flibcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9104768c0991b935e4b5cbc67180e49d425f2c/src%2Flibcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fsearch.rs?ref=fb9104768c0991b935e4b5cbc67180e49d425f2c", "patch": "@@ -58,7 +58,7 @@ pub fn search_node<BorrowType, K, V, Type, Q: ?Sized>(\n     }\n }\n \n-fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n+pub fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n     node: &NodeRef<BorrowType, K, V, Type>,\n     key: &Q\n ) -> (usize, bool)\n@@ -73,4 +73,3 @@ fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n     }\n     (node.keys().len(), false)\n }\n-"}, {"sha": "f33923f99631911fc4752262235314528361a9b9", "filename": "src/libcollectionstest/btree/map.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fb9104768c0991b935e4b5cbc67180e49d425f2c/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9104768c0991b935e4b5cbc67180e49d425f2c/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmap.rs?ref=fb9104768c0991b935e4b5cbc67180e49d425f2c", "patch": "@@ -178,6 +178,48 @@ fn test_range_small() {\n     assert_eq!(j, size - 2);\n }\n \n+#[test]\n+fn test_range_equal_empty_cases() {\n+    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    assert_eq!(map.range((Included(2), Excluded(2))).next(), None);\n+    assert_eq!(map.range((Excluded(2), Included(2))).next(), None);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_range_equal_excluded() {\n+    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    map.range((Excluded(2), Excluded(2)));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_range_backwards_1() {\n+    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    map.range((Included(3), Included(2)));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_range_backwards_2() {\n+    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    map.range((Included(3), Excluded(2)));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_range_backwards_3() {\n+    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    map.range((Excluded(3), Included(2)));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_range_backwards_4() {\n+    let map: BTreeMap<_, _> = (0..5).map(|i| (i, i)).collect();\n+    map.range((Excluded(3), Excluded(2)));\n+}\n+\n #[test]\n fn test_range_1000() {\n     let size = 1000;"}]}