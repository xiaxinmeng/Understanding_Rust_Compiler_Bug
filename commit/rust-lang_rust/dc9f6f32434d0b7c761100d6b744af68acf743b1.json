{"sha": "dc9f6f32434d0b7c761100d6b744af68acf743b1", "node_id": "C_kwDOAAsO6NoAKGRjOWY2ZjMyNDM0ZDBiN2M3NjExMDBkNmI3NDRhZjY4YWNmNzQzYjE", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-10-12T16:43:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-12T16:43:23Z"}, "message": "Rollup merge of #102623 - davidtwco:translation-eager, r=compiler-errors\n\ntranslation: eager translation\n\nPart of #100717. See [Zulip thread](https://rust-lang.zulipchat.com/#narrow/stream/336883-i18n/topic/.23100717.20lists!/near/295010720) for additional context.\n\n- **Store diagnostic arguments in a `HashMap`**: Eager translation will enable subdiagnostics to be translated multiple times with different arguments - this requires the ability to replace the value of one argument with a new value, which is better suited to a `HashMap` than the previous storage, a `Vec`.\n- **Add `AddToDiagnostic::add_to_diagnostic_with`**: `AddToDiagnostic::add_to_diagnostic_with` is similar to the previous `AddToDiagnostic::add_to_diagnostic` but takes a function that can be used by the caller to modify diagnostic messages originating from the subdiagnostic (such as performing translation eagerly). `add_to_diagnostic` now just calls `add_to_diagnostic_with` with an empty closure.\n- **Add `DiagnosticMessage::Eager`**: Add variant of `DiagnosticMessage` for eagerly translated messages\n(messages in the target language which don't need translated by the emitter during emission). Also adds `eager_subdiagnostic` function which is intended to be invoked by the diagnostic derive for subdiagnostic fields which are marked as needing eager translation.\n- **Support `#[subdiagnostic(eager)]`**: Add support for `eager` argument to the `subdiagnostic` attribute which generates a call to `eager_subdiagnostic`.\n- **Finish migrating `rustc_query_system`**: Using eager translation, migrate the remaining repeated cycle stack diagnostic.\n- **Split formatting initialization and use in diagnostic derives**: Diagnostic derives have previously had to take special care when ordering the generated code so that fields were not used after a move.\n\n  This is unlikely for most fields because a field is either annotated with a subdiagnostic attribute and is thus likely a `Span` and copiable, or is a argument, in which case it is only used once by `set_arg`\nanyway.\n\n  However, format strings for code in suggestions can result in fields being used after being moved if not ordered carefully. As a result, the derive currently puts `set_arg` calls last (just before emission), such as:\n\n      let diag = { /* create diagnostic */ };\n\n      diag.span_suggestion_with_style(\n          span,\n          fluent::crate::slug,\n          format!(\"{}\", __binding_0),\n          Applicability::Unknown,\n          SuggestionStyle::ShowAlways\n      );\n      /* + other subdiagnostic additions */\n\n      diag.set_arg(\"foo\", __binding_0);\n      /* + other `set_arg` calls */\n\n      diag.emit();\n\n  For eager translation, this doesn't work, as the message being translated eagerly can assume that all arguments are available - so arguments _must_ be set first.\n\n  Format strings for suggestion code are now separated into two parts - an initialization line that performs the formatting into a variable, and a usage in the subdiagnostic addition.\n\n  By separating these parts, the initialization can happen before arguments are set, preserving the desired order so that code compiles, while still enabling arguments to be set before subdiagnostics are added.\n\n      let diag = { /* create diagnostic */ };\n\n      let __code_0 = format!(\"{}\", __binding_0);\n      /* + other formatting */\n\n      diag.set_arg(\"foo\", __binding_0);\n      /* + other `set_arg` calls */\n\n      diag.span_suggestion_with_style(\n          span,\n          fluent::crate::slug,\n          __code_0,\n          Applicability::Unknown,\n          SuggestionStyle::ShowAlways\n      );\n      /* + other subdiagnostic additions */\n\n      diag.emit();\n\n- **Remove field ordering logic in diagnostic derive:** Following the approach taken in earlier commits to separate formatting initialization from use in the subdiagnostic derive, simplify the diagnostic derive by removing the field-ordering logic that previously solved this problem.\n\nr? ```@compiler-errors```", "tree": {"sha": "a70129d34e6d4851ab10d2bf13eca48cd4772a86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a70129d34e6d4851ab10d2bf13eca48cd4772a86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc9f6f32434d0b7c761100d6b744af68acf743b1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjRu6rCRBK7hj4Ov3rIwAA6/wIAHXhGnw2y3K4fSXn6+zFfJQB\nzmBw7CFQGwiY6vdFWxRV5uKgWSnBKTqXpiiwmB/t/S8hCLnYkVhyCQRWVg15Vw+2\n3phlYNN/EKdHC1e0jIVm8QHavMpyl55g04tyaT5vhnjwVk5uy0Fx4YK1LBC6jGMV\niyzrBUUSfe5E0C9n6P8agBqsHWLuVQxU9VQsgxclGB6Nl1B6/7MHld8QiGohMlvT\nC6vdsUpsX7BHivHv/c5eHqDSp04WLuUN+Zem9OqtGnmxFo2eVb/4Ui7aenhpC5Kk\nIDgRlltJi3LHhuTI5wofQfJZ6xRyjo8ZWI/8KbGdX1lBRIC+L/HB6NrnMo97gqI=\n=evYD\n-----END PGP SIGNATURE-----\n", "payload": "tree a70129d34e6d4851ab10d2bf13eca48cd4772a86\nparent 50f6d337c632cbb5bd1dc3a80b5d428cebd8dce4\nparent fbac1f288bb797ee239f69eafc3dca558f1ea817\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1665593003 +0530\ncommitter GitHub <noreply@github.com> 1665593003 +0530\n\nRollup merge of #102623 - davidtwco:translation-eager, r=compiler-errors\n\ntranslation: eager translation\n\nPart of #100717. See [Zulip thread](https://rust-lang.zulipchat.com/#narrow/stream/336883-i18n/topic/.23100717.20lists!/near/295010720) for additional context.\n\n- **Store diagnostic arguments in a `HashMap`**: Eager translation will enable subdiagnostics to be translated multiple times with different arguments - this requires the ability to replace the value of one argument with a new value, which is better suited to a `HashMap` than the previous storage, a `Vec`.\n- **Add `AddToDiagnostic::add_to_diagnostic_with`**: `AddToDiagnostic::add_to_diagnostic_with` is similar to the previous `AddToDiagnostic::add_to_diagnostic` but takes a function that can be used by the caller to modify diagnostic messages originating from the subdiagnostic (such as performing translation eagerly). `add_to_diagnostic` now just calls `add_to_diagnostic_with` with an empty closure.\n- **Add `DiagnosticMessage::Eager`**: Add variant of `DiagnosticMessage` for eagerly translated messages\n(messages in the target language which don't need translated by the emitter during emission). Also adds `eager_subdiagnostic` function which is intended to be invoked by the diagnostic derive for subdiagnostic fields which are marked as needing eager translation.\n- **Support `#[subdiagnostic(eager)]`**: Add support for `eager` argument to the `subdiagnostic` attribute which generates a call to `eager_subdiagnostic`.\n- **Finish migrating `rustc_query_system`**: Using eager translation, migrate the remaining repeated cycle stack diagnostic.\n- **Split formatting initialization and use in diagnostic derives**: Diagnostic derives have previously had to take special care when ordering the generated code so that fields were not used after a move.\n\n  This is unlikely for most fields because a field is either annotated with a subdiagnostic attribute and is thus likely a `Span` and copiable, or is a argument, in which case it is only used once by `set_arg`\nanyway.\n\n  However, format strings for code in suggestions can result in fields being used after being moved if not ordered carefully. As a result, the derive currently puts `set_arg` calls last (just before emission), such as:\n\n      let diag = { /* create diagnostic */ };\n\n      diag.span_suggestion_with_style(\n          span,\n          fluent::crate::slug,\n          format!(\"{}\", __binding_0),\n          Applicability::Unknown,\n          SuggestionStyle::ShowAlways\n      );\n      /* + other subdiagnostic additions */\n\n      diag.set_arg(\"foo\", __binding_0);\n      /* + other `set_arg` calls */\n\n      diag.emit();\n\n  For eager translation, this doesn't work, as the message being translated eagerly can assume that all arguments are available - so arguments _must_ be set first.\n\n  Format strings for suggestion code are now separated into two parts - an initialization line that performs the formatting into a variable, and a usage in the subdiagnostic addition.\n\n  By separating these parts, the initialization can happen before arguments are set, preserving the desired order so that code compiles, while still enabling arguments to be set before subdiagnostics are added.\n\n      let diag = { /* create diagnostic */ };\n\n      let __code_0 = format!(\"{}\", __binding_0);\n      /* + other formatting */\n\n      diag.set_arg(\"foo\", __binding_0);\n      /* + other `set_arg` calls */\n\n      diag.span_suggestion_with_style(\n          span,\n          fluent::crate::slug,\n          __code_0,\n          Applicability::Unknown,\n          SuggestionStyle::ShowAlways\n      );\n      /* + other subdiagnostic additions */\n\n      diag.emit();\n\n- **Remove field ordering logic in diagnostic derive:** Following the approach taken in earlier commits to separate formatting initialization from use in the subdiagnostic derive, simplify the diagnostic derive by removing the field-ordering logic that previously solved this problem.\n\nr? ```@compiler-errors```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc9f6f32434d0b7c761100d6b744af68acf743b1", "html_url": "https://github.com/rust-lang/rust/commit/dc9f6f32434d0b7c761100d6b744af68acf743b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc9f6f32434d0b7c761100d6b744af68acf743b1/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50f6d337c632cbb5bd1dc3a80b5d428cebd8dce4", "url": "https://api.github.com/repos/rust-lang/rust/commits/50f6d337c632cbb5bd1dc3a80b5d428cebd8dce4", "html_url": "https://github.com/rust-lang/rust/commit/50f6d337c632cbb5bd1dc3a80b5d428cebd8dce4"}, {"sha": "fbac1f288bb797ee239f69eafc3dca558f1ea817", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbac1f288bb797ee239f69eafc3dca558f1ea817", "html_url": "https://github.com/rust-lang/rust/commit/fbac1f288bb797ee239f69eafc3dca558f1ea817"}], "stats": {"total": 774, "additions": 539, "deletions": 235}, "files": [{"sha": "c6c85ffa84dd720a55a51305e9cb4f2e227e3ea0", "filename": "compiler/rustc_ast_lowering/src/errors.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -1,4 +1,7 @@\n-use rustc_errors::{fluent, AddToDiagnostic, Applicability, Diagnostic, DiagnosticArgFromDisplay};\n+use rustc_errors::{\n+    fluent, AddToDiagnostic, Applicability, Diagnostic, DiagnosticArgFromDisplay,\n+    SubdiagnosticMessage,\n+};\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n@@ -19,7 +22,10 @@ pub struct UseAngleBrackets {\n }\n \n impl AddToDiagnostic for UseAngleBrackets {\n-    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         diag.multipart_suggestion(\n             fluent::ast_lowering::use_angle_brackets,\n             vec![(self.open_param, String::from(\"<\")), (self.close_param, String::from(\">\"))],\n@@ -69,7 +75,10 @@ pub enum AssocTyParenthesesSub {\n }\n \n impl AddToDiagnostic for AssocTyParenthesesSub {\n-    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         match self {\n             Self::Empty { parentheses_span } => diag.multipart_suggestion(\n                 fluent::ast_lowering::remove_parentheses,"}, {"sha": "ba2ed24fc08fc08095d240d45d6c90f334c6371c", "filename": "compiler/rustc_ast_passes/src/errors.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -1,6 +1,6 @@\n //! Errors emitted by ast_passes.\n \n-use rustc_errors::{fluent, AddToDiagnostic, Applicability, Diagnostic};\n+use rustc_errors::{fluent, AddToDiagnostic, Applicability, Diagnostic, SubdiagnosticMessage};\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_span::{Span, Symbol};\n \n@@ -17,7 +17,10 @@ pub struct ForbiddenLet {\n }\n \n impl AddToDiagnostic for ForbiddenLetReason {\n-    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         match self {\n             Self::GenericForbidden => {}\n             Self::NotSupportedOr(span) => {\n@@ -228,7 +231,10 @@ pub struct ExternBlockSuggestion {\n }\n \n impl AddToDiagnostic for ExternBlockSuggestion {\n-    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         let start_suggestion = if let Some(abi) = self.abi {\n             format!(\"extern \\\"{}\\\" {{\", abi)\n         } else {"}, {"sha": "a292bfce31eb86a9c15c35d22b04760394b9cc6f", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -15,7 +15,10 @@ use rustc_data_structures::profiling::TimingGuard;\n use rustc_data_structures::profiling::VerboseTimingGuard;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::emitter::Emitter;\n-use rustc_errors::{translation::Translate, DiagnosticId, FatalError, Handler, Level};\n+use rustc_errors::{\n+    translation::{to_fluent_args, Translate},\n+    DiagnosticId, FatalError, Handler, Level,\n+};\n use rustc_fs_util::link_or_copy;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_incremental::{\n@@ -1740,7 +1743,7 @@ impl Translate for SharedEmitter {\n \n impl Emitter for SharedEmitter {\n     fn emit_diagnostic(&mut self, diag: &rustc_errors::Diagnostic) {\n-        let fluent_args = self.to_fluent_args(diag.args());\n+        let fluent_args = to_fluent_args(diag.args());\n         drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n             msg: self.translate_messages(&diag.message, &fluent_args).to_string(),\n             code: diag.code.clone(),"}, {"sha": "870e824039cb6a86abe94b83344c74dd327dbc1c", "filename": "compiler/rustc_error_messages/locales/en-US/query_system.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fquery_system.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fquery_system.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fquery_system.ftl?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -12,6 +12,8 @@ query_system_cycle_usage = cycle used when {$usage}\n \n query_system_cycle_stack_single = ...which immediately requires {$stack_bottom} again\n \n+query_system_cycle_stack_middle = ...which requires {$desc}...\n+\n query_system_cycle_stack_multiple = ...which again requires {$stack_bottom}, completing the cycle\n \n query_system_cycle_recursive_ty_alias = type aliases cannot be recursive"}, {"sha": "ab2dafd828a56390713385ef6945c0a6def0c418", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -277,6 +277,18 @@ pub enum SubdiagnosticMessage {\n     /// Non-translatable diagnostic message.\n     // FIXME(davidtwco): can a `Cow<'static, str>` be used here?\n     Str(String),\n+    /// Translatable message which has already been translated eagerly.\n+    ///\n+    /// Some diagnostics have repeated subdiagnostics where the same interpolated variables would\n+    /// be instantiated multiple times with different values. As translation normally happens\n+    /// immediately prior to emission, after the diagnostic and subdiagnostic derive logic has run,\n+    /// the setting of diagnostic arguments in the derived code will overwrite previous variable\n+    /// values and only the final value will be set when translation occurs - resulting in\n+    /// incorrect diagnostics. Eager translation results in translation for a subdiagnostic\n+    /// happening immediately after the subdiagnostic derive's logic has been run. This variant\n+    /// stores messages which have been translated eagerly.\n+    // FIXME(#100717): can a `Cow<'static, str>` be used here?\n+    Eager(String),\n     /// Identifier of a Fluent message. Instances of this variant are generated by the\n     /// `Subdiagnostic` derive.\n     FluentIdentifier(FluentId),\n@@ -304,8 +316,20 @@ impl<S: Into<String>> From<S> for SubdiagnosticMessage {\n #[rustc_diagnostic_item = \"DiagnosticMessage\"]\n pub enum DiagnosticMessage {\n     /// Non-translatable diagnostic message.\n-    // FIXME(davidtwco): can a `Cow<'static, str>` be used here?\n+    // FIXME(#100717): can a `Cow<'static, str>` be used here?\n     Str(String),\n+    /// Translatable message which has already been translated eagerly.\n+    ///\n+    /// Some diagnostics have repeated subdiagnostics where the same interpolated variables would\n+    /// be instantiated multiple times with different values. As translation normally happens\n+    /// immediately prior to emission, after the diagnostic and subdiagnostic derive logic has run,\n+    /// the setting of diagnostic arguments in the derived code will overwrite previous variable\n+    /// values and only the final value will be set when translation occurs - resulting in\n+    /// incorrect diagnostics. Eager translation results in translation for a subdiagnostic\n+    /// happening immediately after the subdiagnostic derive's logic has been run. This variant\n+    /// stores messages which have been translated eagerly.\n+    // FIXME(#100717): can a `Cow<'static, str>` be used here?\n+    Eager(String),\n     /// Identifier for a Fluent message (with optional attribute) corresponding to the diagnostic\n     /// message.\n     ///\n@@ -324,6 +348,7 @@ impl DiagnosticMessage {\n     pub fn with_subdiagnostic_message(&self, sub: SubdiagnosticMessage) -> Self {\n         let attr = match sub {\n             SubdiagnosticMessage::Str(s) => return DiagnosticMessage::Str(s),\n+            SubdiagnosticMessage::Eager(s) => return DiagnosticMessage::Eager(s),\n             SubdiagnosticMessage::FluentIdentifier(id) => {\n                 return DiagnosticMessage::FluentIdentifier(id, None);\n             }\n@@ -332,6 +357,7 @@ impl DiagnosticMessage {\n \n         match self {\n             DiagnosticMessage::Str(s) => DiagnosticMessage::Str(s.clone()),\n+            DiagnosticMessage::Eager(s) => DiagnosticMessage::Eager(s.clone()),\n             DiagnosticMessage::FluentIdentifier(id, _) => {\n                 DiagnosticMessage::FluentIdentifier(id.clone(), Some(attr))\n             }\n@@ -367,6 +393,7 @@ impl Into<SubdiagnosticMessage> for DiagnosticMessage {\n     fn into(self) -> SubdiagnosticMessage {\n         match self {\n             DiagnosticMessage::Str(s) => SubdiagnosticMessage::Str(s),\n+            DiagnosticMessage::Eager(s) => SubdiagnosticMessage::Eager(s),\n             DiagnosticMessage::FluentIdentifier(id, None) => {\n                 SubdiagnosticMessage::FluentIdentifier(id)\n             }"}, {"sha": "f14b8ee3254f33608b0bbe0b16c6374ec0c5ad9e", "filename": "compiler/rustc_errors/src/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -7,7 +7,7 @@\n \n use crate::emitter::FileWithAnnotatedLines;\n use crate::snippet::Line;\n-use crate::translation::Translate;\n+use crate::translation::{to_fluent_args, Translate};\n use crate::{\n     CodeSuggestion, Diagnostic, DiagnosticId, DiagnosticMessage, Emitter, FluentBundle,\n     LazyFallbackBundle, Level, MultiSpan, Style, SubDiagnostic,\n@@ -46,7 +46,7 @@ impl Translate for AnnotateSnippetEmitterWriter {\n impl Emitter for AnnotateSnippetEmitterWriter {\n     /// The entry point for the diagnostics generation\n     fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n-        let fluent_args = self.to_fluent_args(diag.args());\n+        let fluent_args = to_fluent_args(diag.args());\n \n         let mut children = diag.children.clone();\n         let (mut primary_span, suggestions) = self.primary_span_formatted(&diag, &fluent_args);"}, {"sha": "3e0840caaa6938ee5d6a985a0cc2b636a4aa114e", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 46, "deletions": 11, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -27,7 +27,11 @@ pub struct SuggestionsDisabled;\n /// Simplified version of `FluentArg` that can implement `Encodable` and `Decodable`. Collection of\n /// `DiagnosticArg` are converted to `FluentArgs` (consuming the collection) at the start of\n /// diagnostic emission.\n-pub type DiagnosticArg<'source> = (Cow<'source, str>, DiagnosticArgValue<'source>);\n+pub type DiagnosticArg<'iter, 'source> =\n+    (&'iter DiagnosticArgName<'source>, &'iter DiagnosticArgValue<'source>);\n+\n+/// Name of a diagnostic argument.\n+pub type DiagnosticArgName<'source> = Cow<'source, str>;\n \n /// Simplified version of `FluentValue` that can implement `Encodable` and `Decodable`. Converted\n /// to a `FluentValue` by the emitter to be used in diagnostic translation.\n@@ -199,9 +203,20 @@ impl IntoDiagnosticArg for ast::token::TokenKind {\n /// `#[derive(Subdiagnostic)]` -- see [rustc_macros::Subdiagnostic].\n #[cfg_attr(bootstrap, rustc_diagnostic_item = \"AddSubdiagnostic\")]\n #[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"AddToDiagnostic\")]\n-pub trait AddToDiagnostic {\n+pub trait AddToDiagnostic\n+where\n+    Self: Sized,\n+{\n     /// Add a subdiagnostic to an existing diagnostic.\n-    fn add_to_diagnostic(self, diag: &mut Diagnostic);\n+    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+        self.add_to_diagnostic_with(diag, |_, m| m);\n+    }\n+\n+    /// Add a subdiagnostic to an existing diagnostic where `f` is invoked on every message used\n+    /// (to optionally perform eager translation).\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, f: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage;\n }\n \n /// Trait implemented by lint types. This should not be implemented manually. Instead, use\n@@ -229,7 +244,7 @@ pub struct Diagnostic {\n     pub span: MultiSpan,\n     pub children: Vec<SubDiagnostic>,\n     pub suggestions: Result<Vec<CodeSuggestion>, SuggestionsDisabled>,\n-    args: Vec<DiagnosticArg<'static>>,\n+    args: FxHashMap<DiagnosticArgName<'static>, DiagnosticArgValue<'static>>,\n \n     /// This is not used for highlighting or rendering any error message.  Rather, it can be used\n     /// as a sort key to sort a buffer of diagnostics.  By default, it is the primary span of\n@@ -321,7 +336,7 @@ impl Diagnostic {\n             span: MultiSpan::new(),\n             children: vec![],\n             suggestions: Ok(vec![]),\n-            args: vec![],\n+            args: Default::default(),\n             sort_span: DUMMY_SP,\n             is_lint: false,\n         }\n@@ -917,13 +932,30 @@ impl Diagnostic {\n         self\n     }\n \n-    /// Add a subdiagnostic from a type that implements `Subdiagnostic` - see\n-    /// [rustc_macros::Subdiagnostic].\n+    /// Add a subdiagnostic from a type that implements `Subdiagnostic` (see\n+    /// [rustc_macros::Subdiagnostic]).\n     pub fn subdiagnostic(&mut self, subdiagnostic: impl AddToDiagnostic) -> &mut Self {\n         subdiagnostic.add_to_diagnostic(self);\n         self\n     }\n \n+    /// Add a subdiagnostic from a type that implements `Subdiagnostic` (see\n+    /// [rustc_macros::Subdiagnostic]). Performs eager translation of any translatable messages\n+    /// used in the subdiagnostic, so suitable for use with repeated messages (i.e. re-use of\n+    /// interpolated variables).\n+    pub fn eager_subdiagnostic(\n+        &mut self,\n+        handler: &crate::Handler,\n+        subdiagnostic: impl AddToDiagnostic,\n+    ) -> &mut Self {\n+        subdiagnostic.add_to_diagnostic_with(self, |diag, msg| {\n+            let args = diag.args();\n+            let msg = diag.subdiagnostic_message_to_diagnostic_message(msg);\n+            handler.eagerly_translate(msg, args)\n+        });\n+        self\n+    }\n+\n     pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self {\n         self.span = sp.into();\n         if let Some(span) = self.span.primary_span() {\n@@ -956,16 +988,19 @@ impl Diagnostic {\n         self\n     }\n \n-    pub fn args(&self) -> &[DiagnosticArg<'static>] {\n-        &self.args\n+    // Exact iteration order of diagnostic arguments shouldn't make a difference to output because\n+    // they're only used in interpolation.\n+    #[allow(rustc::potential_query_instability)]\n+    pub fn args<'a>(&'a self) -> impl Iterator<Item = DiagnosticArg<'a, 'static>> {\n+        self.args.iter()\n     }\n \n     pub fn set_arg(\n         &mut self,\n         name: impl Into<Cow<'static, str>>,\n         arg: impl IntoDiagnosticArg,\n     ) -> &mut Self {\n-        self.args.push((name.into(), arg.into_diagnostic_arg()));\n+        self.args.insert(name.into(), arg.into_diagnostic_arg());\n         self\n     }\n \n@@ -976,7 +1011,7 @@ impl Diagnostic {\n     /// Helper function that takes a `SubdiagnosticMessage` and returns a `DiagnosticMessage` by\n     /// combining it with the primary message of the diagnostic (if translatable, otherwise it just\n     /// passes the user's string along).\n-    fn subdiagnostic_message_to_diagnostic_message(\n+    pub(crate) fn subdiagnostic_message_to_diagnostic_message(\n         &self,\n         attr: impl Into<SubdiagnosticMessage>,\n     ) -> DiagnosticMessage {"}, {"sha": "cd6413bc3ec622de739180b0d7a012fa8619ebbb", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -14,7 +14,7 @@ use rustc_span::{FileLines, SourceFile, Span};\n \n use crate::snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, Style, StyledString};\n use crate::styled_buffer::StyledBuffer;\n-use crate::translation::Translate;\n+use crate::translation::{to_fluent_args, Translate};\n use crate::{\n     CodeSuggestion, Diagnostic, DiagnosticId, DiagnosticMessage, FluentBundle, Handler,\n     LazyFallbackBundle, Level, MultiSpan, SubDiagnostic, SubstitutionHighlight, SuggestionStyle,\n@@ -535,7 +535,7 @@ impl Emitter for EmitterWriter {\n     }\n \n     fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n-        let fluent_args = self.to_fluent_args(diag.args());\n+        let fluent_args = to_fluent_args(diag.args());\n \n         let mut children = diag.children.clone();\n         let (mut primary_span, suggestions) = self.primary_span_formatted(&diag, &fluent_args);"}, {"sha": "4cc7be47fc2c69c79d2d53c7f24cae7271cbde3f", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -13,7 +13,7 @@ use rustc_span::source_map::{FilePathMapping, SourceMap};\n \n use crate::emitter::{Emitter, HumanReadableErrorType};\n use crate::registry::Registry;\n-use crate::translation::Translate;\n+use crate::translation::{to_fluent_args, Translate};\n use crate::DiagnosticId;\n use crate::{\n     CodeSuggestion, FluentBundle, LazyFallbackBundle, MultiSpan, SpanLabel, SubDiagnostic,\n@@ -312,7 +312,7 @@ struct UnusedExterns<'a, 'b, 'c> {\n \n impl Diagnostic {\n     fn from_errors_diagnostic(diag: &crate::Diagnostic, je: &JsonEmitter) -> Diagnostic {\n-        let args = je.to_fluent_args(diag.args());\n+        let args = to_fluent_args(diag.args());\n         let sugg = diag.suggestions.iter().flatten().map(|sugg| {\n             let translated_message = je.translate_message(&sugg.msg, &args);\n             Diagnostic {"}, {"sha": "b16c54e0aacaae438dd33ea2ed26c3322d55f5fc", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -598,6 +598,17 @@ impl Handler {\n         }\n     }\n \n+    /// Translate `message` eagerly with `args`.\n+    pub fn eagerly_translate<'a>(\n+        &self,\n+        message: DiagnosticMessage,\n+        args: impl Iterator<Item = DiagnosticArg<'a, 'static>>,\n+    ) -> SubdiagnosticMessage {\n+        let inner = self.inner.borrow();\n+        let args = crate::translation::to_fluent_args(args);\n+        SubdiagnosticMessage::Eager(inner.emitter.translate_message(&message, &args).to_string())\n+    }\n+\n     // This is here to not allow mutation of flags;\n     // as of this writing it's only used in tests in librustc_middle.\n     pub fn can_emit_warnings(&self) -> bool {"}, {"sha": "a7737b467b75bd89dc266a03a78c941b96cb76eb", "filename": "compiler/rustc_errors/src/translation.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -4,6 +4,27 @@ use rustc_data_structures::sync::Lrc;\n use rustc_error_messages::FluentArgs;\n use std::borrow::Cow;\n \n+/// Convert diagnostic arguments (a rustc internal type that exists to implement\n+/// `Encodable`/`Decodable`) into `FluentArgs` which is necessary to perform translation.\n+///\n+/// Typically performed once for each diagnostic at the start of `emit_diagnostic` and then\n+/// passed around as a reference thereafter.\n+pub fn to_fluent_args<'iter, 'arg: 'iter>(\n+    iter: impl Iterator<Item = DiagnosticArg<'iter, 'arg>>,\n+) -> FluentArgs<'arg> {\n+    let mut args = if let Some(size) = iter.size_hint().1 {\n+        FluentArgs::with_capacity(size)\n+    } else {\n+        FluentArgs::new()\n+    };\n+\n+    for (k, v) in iter {\n+        args.set(k.clone(), v.clone());\n+    }\n+\n+    args\n+}\n+\n pub trait Translate {\n     /// Return `FluentBundle` with localized diagnostics for the locale requested by the user. If no\n     /// language was requested by the user then this will be `None` and `fallback_fluent_bundle`\n@@ -15,15 +36,6 @@ pub trait Translate {\n     /// unavailable for the requested locale.\n     fn fallback_fluent_bundle(&self) -> &FluentBundle;\n \n-    /// Convert diagnostic arguments (a rustc internal type that exists to implement\n-    /// `Encodable`/`Decodable`) into `FluentArgs` which is necessary to perform translation.\n-    ///\n-    /// Typically performed once for each diagnostic at the start of `emit_diagnostic` and then\n-    /// passed around as a reference thereafter.\n-    fn to_fluent_args<'arg>(&self, args: &[DiagnosticArg<'arg>]) -> FluentArgs<'arg> {\n-        FromIterator::from_iter(args.iter().cloned())\n-    }\n-\n     /// Convert `DiagnosticMessage`s to a string, performing translation if necessary.\n     fn translate_messages(\n         &self,\n@@ -43,7 +55,9 @@ pub trait Translate {\n     ) -> Cow<'_, str> {\n         trace!(?message, ?args);\n         let (identifier, attr) = match message {\n-            DiagnosticMessage::Str(msg) => return Cow::Borrowed(&msg),\n+            DiagnosticMessage::Str(msg) | DiagnosticMessage::Eager(msg) => {\n+                return Cow::Borrowed(&msg);\n+            }\n             DiagnosticMessage::FluentIdentifier(identifier, attr) => (identifier, attr),\n         };\n "}, {"sha": "500900d3d4a74b7310be4483c3a7a87e01ffff45", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -1,6 +1,7 @@\n use hir::GenericParamKind;\n use rustc_errors::{\n-    fluent, AddToDiagnostic, Applicability, DiagnosticMessage, DiagnosticStyledString, MultiSpan,\n+    fluent, AddToDiagnostic, Applicability, Diagnostic, DiagnosticMessage, DiagnosticStyledString,\n+    MultiSpan, SubdiagnosticMessage,\n };\n use rustc_hir as hir;\n use rustc_hir::{FnRetTy, Ty};\n@@ -229,7 +230,10 @@ pub enum RegionOriginNote<'a> {\n }\n \n impl AddToDiagnostic for RegionOriginNote<'_> {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         let mut label_or_note = |span, msg: DiagnosticMessage| {\n             let sub_count = diag.children.iter().filter(|d| d.span.is_dummy()).count();\n             let expanded_sub_count = diag.children.iter().filter(|d| !d.span.is_dummy()).count();\n@@ -290,7 +294,10 @@ pub enum LifetimeMismatchLabels {\n }\n \n impl AddToDiagnostic for LifetimeMismatchLabels {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         match self {\n             LifetimeMismatchLabels::InRet { param_span, ret_span, span, label_var1 } => {\n                 diag.span_label(param_span, fluent::infer::declared_different);\n@@ -340,7 +347,10 @@ pub struct AddLifetimeParamsSuggestion<'a> {\n }\n \n impl AddToDiagnostic for AddLifetimeParamsSuggestion<'_> {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         let mut mk_suggestion = || {\n             let (\n                 hir::Ty { kind: hir::TyKind::Rptr(lifetime_sub, _), .. },\n@@ -439,7 +449,10 @@ pub struct IntroducesStaticBecauseUnmetLifetimeReq {\n }\n \n impl AddToDiagnostic for IntroducesStaticBecauseUnmetLifetimeReq {\n-    fn add_to_diagnostic(mut self, diag: &mut rustc_errors::Diagnostic) {\n+    fn add_to_diagnostic_with<F>(mut self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         self.unmet_requirements\n             .push_span_label(self.binding_span, fluent::infer::msl_introduces_static);\n         diag.span_note(self.unmet_requirements, fluent::infer::msl_unmet_req);\n@@ -451,7 +464,10 @@ pub struct ImplNote {\n }\n \n impl AddToDiagnostic for ImplNote {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         match self.impl_span {\n             Some(span) => diag.span_note(span, fluent::infer::msl_impl_note),\n             None => diag.note(fluent::infer::msl_impl_note),\n@@ -466,7 +482,10 @@ pub enum TraitSubdiag {\n \n // FIXME(#100717) used in `Vec<TraitSubdiag>` so requires eager translation/list support\n impl AddToDiagnostic for TraitSubdiag {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         match self {\n             TraitSubdiag::Note { span } => {\n                 diag.span_note(span, \"this has an implicit `'static` lifetime requirement\");"}, {"sha": "201a3c7100cc8da1c57654a2d0e208cece4f2dec", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -1,5 +1,7 @@\n use crate::infer::error_reporting::nice_region_error::find_anon_type;\n-use rustc_errors::{self, fluent, AddToDiagnostic, IntoDiagnosticArg};\n+use rustc_errors::{\n+    self, fluent, AddToDiagnostic, Diagnostic, IntoDiagnosticArg, SubdiagnosticMessage,\n+};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::{symbol::kw, Span};\n \n@@ -159,7 +161,10 @@ impl RegionExplanation<'_> {\n }\n \n impl AddToDiagnostic for RegionExplanation<'_> {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         if let Some(span) = self.desc.span {\n             diag.span_note(span, fluent::infer::region_explanation);\n         } else {"}, {"sha": "97d012fb611d036e6eb81b61e728636df73241f3", "filename": "compiler/rustc_lint/src/errors.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -1,4 +1,7 @@\n-use rustc_errors::{fluent, AddToDiagnostic, ErrorGuaranteed, Handler, IntoDiagnostic};\n+use rustc_errors::{\n+    fluent, AddToDiagnostic, Diagnostic, ErrorGuaranteed, Handler, IntoDiagnostic,\n+    SubdiagnosticMessage,\n+};\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_session::lint::Level;\n use rustc_span::{Span, Symbol};\n@@ -23,7 +26,10 @@ pub enum OverruledAttributeSub {\n }\n \n impl AddToDiagnostic for OverruledAttributeSub {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         match self {\n             OverruledAttributeSub::DefaultSource { id } => {\n                 diag.note(fluent::lint::default_source);\n@@ -88,7 +94,10 @@ pub struct RequestedLevel {\n }\n \n impl AddToDiagnostic for RequestedLevel {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         diag.note(fluent::lint::requested_level);\n         diag.set_arg(\n             \"level\","}, {"sha": "8cf307df5a565c47957512832a90d6de06111f79", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -10,27 +10,31 @@ use synstructure::Structure;\n /// The central struct for constructing the `into_diagnostic` method from an annotated struct.\n pub(crate) struct DiagnosticDerive<'a> {\n     structure: Structure<'a>,\n-    handler: syn::Ident,\n     builder: DiagnosticDeriveBuilder,\n }\n \n impl<'a> DiagnosticDerive<'a> {\n     pub(crate) fn new(diag: syn::Ident, handler: syn::Ident, structure: Structure<'a>) -> Self {\n         Self {\n-            builder: DiagnosticDeriveBuilder { diag, kind: DiagnosticDeriveKind::Diagnostic },\n-            handler,\n+            builder: DiagnosticDeriveBuilder {\n+                diag,\n+                kind: DiagnosticDeriveKind::Diagnostic { handler },\n+            },\n             structure,\n         }\n     }\n \n     pub(crate) fn into_tokens(self) -> TokenStream {\n-        let DiagnosticDerive { mut structure, handler, mut builder } = self;\n+        let DiagnosticDerive { mut structure, mut builder } = self;\n \n         let implementation = builder.each_variant(&mut structure, |mut builder, variant| {\n             let preamble = builder.preamble(&variant);\n             let body = builder.body(&variant);\n \n             let diag = &builder.parent.diag;\n+            let DiagnosticDeriveKind::Diagnostic { handler } = &builder.parent.kind else {\n+                unreachable!()\n+            };\n             let init = match builder.slug.value_ref() {\n                 None => {\n                     span_err(builder.span, \"diagnostic slug not specified\")\n@@ -48,14 +52,17 @@ impl<'a> DiagnosticDerive<'a> {\n                 }\n             };\n \n+            let formatting_init = &builder.formatting_init;\n             quote! {\n                 #init\n+                #formatting_init\n                 #preamble\n                 #body\n                 #diag\n             }\n         });\n \n+        let DiagnosticDeriveKind::Diagnostic { handler } = &builder.kind else { unreachable!() };\n         structure.gen_impl(quote! {\n             gen impl<'__diagnostic_handler_sess, G>\n                     rustc_errors::IntoDiagnostic<'__diagnostic_handler_sess, G>\n@@ -96,17 +103,18 @@ impl<'a> LintDiagnosticDerive<'a> {\n             let body = builder.body(&variant);\n \n             let diag = &builder.parent.diag;\n-\n+            let formatting_init = &builder.formatting_init;\n             quote! {\n                 #preamble\n+                #formatting_init\n                 #body\n                 #diag\n             }\n         });\n \n         let msg = builder.each_variant(&mut structure, |mut builder, variant| {\n-            // HACK(wafflelapkin): initialize slug (???)\n-            let _preamble = builder.preamble(&variant);\n+            // Collect the slug by generating the preamble.\n+            let _ = builder.preamble(&variant);\n \n             match builder.slug.value_ref() {\n                 None => {\n@@ -125,7 +133,10 @@ impl<'a> LintDiagnosticDerive<'a> {\n         let diag = &builder.diag;\n         structure.gen_impl(quote! {\n             gen impl<'__a> rustc_errors::DecorateLint<'__a, ()> for @Self {\n-                fn decorate_lint<'__b>(self, #diag: &'__b mut rustc_errors::DiagnosticBuilder<'__a, ()>) -> &'__b mut rustc_errors::DiagnosticBuilder<'__a, ()> {\n+                fn decorate_lint<'__b>(\n+                    self,\n+                    #diag: &'__b mut rustc_errors::DiagnosticBuilder<'__a, ()>\n+                ) -> &'__b mut rustc_errors::DiagnosticBuilder<'__a, ()> {\n                     use rustc_errors::IntoDiagnosticArg;\n                     #implementation\n                 }"}, {"sha": "dcbe89251cb36048705773f90d3cc51e62a3c4d9", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 90, "deletions": 60, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -5,9 +5,9 @@ use crate::diagnostics::error::{\n     DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n-    bind_style_of_field, build_field_mapping, report_error_if_not_applied_to_span,\n-    report_type_error, should_generate_set_arg, type_is_unit, type_matches_path, FieldInfo,\n-    FieldInnerTy, FieldMap, HasFieldMap, SetOnce, SpannedOption, SubdiagnosticKind,\n+    build_field_mapping, report_error_if_not_applied_to_span, report_type_error,\n+    should_generate_set_arg, type_is_unit, type_matches_path, FieldInfo, FieldInnerTy, FieldMap,\n+    HasFieldMap, SetOnce, SpannedOption, SubdiagnosticKind,\n };\n use proc_macro2::{Ident, Span, TokenStream};\n use quote::{format_ident, quote};\n@@ -17,9 +17,9 @@ use syn::{\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n /// What kind of diagnostic is being derived - a fatal/error/warning or a lint?\n-#[derive(Copy, Clone, PartialEq, Eq)]\n+#[derive(Clone, PartialEq, Eq)]\n pub(crate) enum DiagnosticDeriveKind {\n-    Diagnostic,\n+    Diagnostic { handler: syn::Ident },\n     LintDiagnostic,\n }\n \n@@ -40,6 +40,9 @@ pub(crate) struct DiagnosticDeriveVariantBuilder<'parent> {\n     /// The parent builder for the entire type.\n     pub parent: &'parent DiagnosticDeriveBuilder,\n \n+    /// Initialization of format strings for code suggestions.\n+    pub formatting_init: TokenStream,\n+\n     /// Span of the struct or the enum variant.\n     pub span: proc_macro::Span,\n \n@@ -88,19 +91,7 @@ impl DiagnosticDeriveBuilder {\n             }\n         }\n \n-        for variant in structure.variants_mut() {\n-            // First, change the binding style of each field based on the code that will be\n-            // generated for the field - e.g. `set_arg` calls needs by-move bindings, whereas\n-            // `set_primary_span` only needs by-ref.\n-            variant.bind_with(|bi| bind_style_of_field(bi.ast()).0);\n-\n-            // Then, perform a stable sort on bindings which generates code for by-ref bindings\n-            // before code generated for by-move bindings. Any code generated for the by-ref\n-            // bindings which creates a reference to the by-move fields will happen before the\n-            // by-move bindings move those fields and make them inaccessible.\n-            variant.bindings_mut().sort_by_cached_key(|bi| bind_style_of_field(bi.ast()));\n-        }\n-\n+        structure.bind_with(|_| synstructure::BindStyle::Move);\n         let variants = structure.each_variant(|variant| {\n             let span = match structure.ast().data {\n                 syn::Data::Struct(..) => span,\n@@ -112,6 +103,7 @@ impl DiagnosticDeriveBuilder {\n                 parent: &self,\n                 span,\n                 field_map: build_field_mapping(variant),\n+                formatting_init: TokenStream::new(),\n                 slug: None,\n                 code: None,\n             };\n@@ -143,16 +135,14 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n \n     /// Generates calls to `span_label` and similar functions based on the attributes on fields or\n     /// calls to `set_arg` when no attributes are present.\n-    ///\n-    /// Expects use of `Self::each_variant` which will have sorted bindings so that by-ref bindings\n-    /// (which may create references to by-move bindings) have their code generated first -\n-    /// necessary as code for suggestions uses formatting machinery and the value of other fields\n-    /// (any given field can be referenced multiple times, so must be accessed through a borrow);\n-    /// and when passing fields to `add_subdiagnostic` or `set_arg` for Fluent, fields must be\n-    /// accessed by-move.\n     pub fn body<'s>(&mut self, variant: &VariantInfo<'s>) -> TokenStream {\n         let mut body = quote! {};\n-        for binding in variant.bindings() {\n+        // Generate `set_arg` calls first..\n+        for binding in variant.bindings().iter().filter(|bi| should_generate_set_arg(bi.ast())) {\n+            body.extend(self.generate_field_code(binding));\n+        }\n+        // ..and then subdiagnostic additions.\n+        for binding in variant.bindings().iter().filter(|bi| !should_generate_set_arg(bi.ast())) {\n             body.extend(self.generate_field_attrs_code(binding));\n         }\n         body\n@@ -274,24 +264,27 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n         }\n     }\n \n-    fn generate_field_attrs_code(&mut self, binding_info: &BindingInfo<'_>) -> TokenStream {\n+    fn generate_field_code(&mut self, binding_info: &BindingInfo<'_>) -> TokenStream {\n+        let diag = &self.parent.diag;\n+\n         let field = binding_info.ast();\n         let field_binding = &binding_info.binding;\n \n-        if should_generate_set_arg(&field) {\n-            let diag = &self.parent.diag;\n-            let ident = field.ident.as_ref().unwrap();\n-            // strip `r#` prefix, if present\n-            let ident = format_ident!(\"{}\", ident);\n-            return quote! {\n-                #diag.set_arg(\n-                    stringify!(#ident),\n-                    #field_binding\n-                );\n-            };\n+        let ident = field.ident.as_ref().unwrap();\n+        let ident = format_ident!(\"{}\", ident); // strip `r#` prefix, if present\n+\n+        quote! {\n+            #diag.set_arg(\n+                stringify!(#ident),\n+                #field_binding\n+            );\n         }\n+    }\n+\n+    fn generate_field_attrs_code(&mut self, binding_info: &BindingInfo<'_>) -> TokenStream {\n+        let field = binding_info.ast();\n+        let field_binding = &binding_info.binding;\n \n-        let needs_move = bind_style_of_field(&field).is_move();\n         let inner_ty = FieldInnerTy::from_type(&field.ty);\n \n         field\n@@ -304,10 +297,8 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                 let (binding, needs_destructure) = if needs_clone {\n                     // `primary_span` can accept a `Vec<Span>` so don't destructure that.\n                     (quote! { #field_binding.clone() }, false)\n-                } else if needs_move {\n-                    (quote! { #field_binding }, true)\n                 } else {\n-                    (quote! { *#field_binding }, true)\n+                    (quote! { #field_binding }, true)\n                 };\n \n                 let generated_code = self\n@@ -340,18 +331,15 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n         let diag = &self.parent.diag;\n         let meta = attr.parse_meta()?;\n \n-        if let Meta::Path(_) = meta {\n-            let ident = &attr.path.segments.last().unwrap().ident;\n-            let name = ident.to_string();\n-            let name = name.as_str();\n-            match name {\n-                \"skip_arg\" => {\n-                    // Don't need to do anything - by virtue of the attribute existing, the\n-                    // `set_arg` call will not be generated.\n-                    return Ok(quote! {});\n-                }\n-                \"primary_span\" => match self.parent.kind {\n-                    DiagnosticDeriveKind::Diagnostic => {\n+        let ident = &attr.path.segments.last().unwrap().ident;\n+        let name = ident.to_string();\n+        match (&meta, name.as_str()) {\n+            // Don't need to do anything - by virtue of the attribute existing, the\n+            // `set_arg` call will not be generated.\n+            (Meta::Path(_), \"skip_arg\") => return Ok(quote! {}),\n+            (Meta::Path(_), \"primary_span\") => {\n+                match self.parent.kind {\n+                    DiagnosticDeriveKind::Diagnostic { .. } => {\n                         report_error_if_not_applied_to_span(attr, &info)?;\n \n                         return Ok(quote! {\n@@ -363,10 +351,50 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                             diag.help(\"the `primary_span` field attribute is not valid for lint diagnostics\")\n                         })\n                     }\n-                },\n-                \"subdiagnostic\" => return Ok(quote! { #diag.subdiagnostic(#binding); }),\n-                _ => {}\n+                }\n+            }\n+            (Meta::Path(_), \"subdiagnostic\") => {\n+                return Ok(quote! { #diag.subdiagnostic(#binding); });\n+            }\n+            (Meta::NameValue(_), \"subdiagnostic\") => {\n+                throw_invalid_attr!(attr, &meta, |diag| {\n+                    diag.help(\"`eager` is the only supported nested attribute for `subdiagnostic`\")\n+                })\n+            }\n+            (Meta::List(MetaList { ref nested, .. }), \"subdiagnostic\") => {\n+                if nested.len() != 1 {\n+                    throw_invalid_attr!(attr, &meta, |diag| {\n+                        diag.help(\n+                            \"`eager` is the only supported nested attribute for `subdiagnostic`\",\n+                        )\n+                    })\n+                }\n+\n+                let handler = match &self.parent.kind {\n+                    DiagnosticDeriveKind::Diagnostic { handler } => handler,\n+                    DiagnosticDeriveKind::LintDiagnostic => {\n+                        throw_invalid_attr!(attr, &meta, |diag| {\n+                            diag.help(\"eager subdiagnostics are not supported on lints\")\n+                        })\n+                    }\n+                };\n+\n+                let nested_attr = nested.first().expect(\"pop failed for single element list\");\n+                match nested_attr {\n+                    NestedMeta::Meta(meta @ Meta::Path(_))\n+                        if meta.path().segments.last().unwrap().ident.to_string().as_str()\n+                            == \"eager\" =>\n+                    {\n+                        return Ok(quote! { #diag.eager_subdiagnostic(#handler, #binding); });\n+                    }\n+                    _ => {\n+                        throw_invalid_nested_attr!(attr, nested_attr, |diag| {\n+                            diag.help(\"`eager` is the only supported nested attribute for `subdiagnostic`\")\n+                        })\n+                    }\n+                }\n             }\n+            _ => (),\n         }\n \n         let (subdiag, slug) = self.parse_subdiag_attribute(attr)?;\n@@ -389,7 +417,8 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n             SubdiagnosticKind::Suggestion {\n                 suggestion_kind,\n                 applicability: static_applicability,\n-                code,\n+                code_field,\n+                code_init,\n             } => {\n                 let (span_field, mut applicability) = self.span_and_applicability_of_ty(info)?;\n \n@@ -402,11 +431,12 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                     .unwrap_or_else(|| quote! { rustc_errors::Applicability::Unspecified });\n                 let style = suggestion_kind.to_suggestion_style();\n \n+                self.formatting_init.extend(code_init);\n                 Ok(quote! {\n                     #diag.span_suggestion_with_style(\n                         #span_field,\n                         rustc_errors::fluent::#slug,\n-                        #code,\n+                        #code_field,\n                         #applicability,\n                         #style\n                     );\n@@ -451,7 +481,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n             // If `ty` is `Span` w/out applicability, then use `Applicability::Unspecified`.\n             ty @ Type::Path(..) if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) => {\n                 let binding = &info.binding.binding;\n-                Ok((quote!(*#binding), None))\n+                Ok((quote!(#binding), None))\n             }\n             // If `ty` is `(Span, Applicability)` then return tokens accessing those.\n             Type::Tuple(tup) => {"}, {"sha": "f98cc66e9e93e706e68c39263a473b54ace24b70", "filename": "compiler/rustc_macros/src/diagnostics/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -9,7 +9,7 @@ use diagnostic::{DiagnosticDerive, LintDiagnosticDerive};\n pub(crate) use fluent::fluent_messages;\n use proc_macro2::TokenStream;\n use quote::format_ident;\n-use subdiagnostic::SubdiagnosticDerive;\n+use subdiagnostic::SubdiagnosticDeriveBuilder;\n use synstructure::Structure;\n \n /// Implements `#[derive(Diagnostic)]`, which allows for errors to be specified as a struct,\n@@ -155,5 +155,5 @@ pub fn lint_diagnostic_derive(s: Structure<'_>) -> TokenStream {\n /// diag.subdiagnostic(RawIdentifierSuggestion { span, applicability, ident });\n /// ```\n pub fn session_subdiagnostic_derive(s: Structure<'_>) -> TokenStream {\n-    SubdiagnosticDerive::new(s).into_tokens()\n+    SubdiagnosticDeriveBuilder::new().into_tokens(s)\n }"}, {"sha": "3d4c3ab9fd7c9f1db983eed8de0db0f0afdebfe8", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 66, "deletions": 29, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -5,7 +5,7 @@ use crate::diagnostics::error::{\n     DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n-    build_field_mapping, report_error_if_not_applied_to_applicability,\n+    build_field_mapping, new_code_ident, report_error_if_not_applied_to_applicability,\n     report_error_if_not_applied_to_span, FieldInfo, FieldInnerTy, FieldMap, HasFieldMap, SetOnce,\n     SpannedOption, SubdiagnosticKind,\n };\n@@ -15,19 +15,19 @@ use syn::{spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n /// The central struct for constructing the `add_to_diagnostic` method from an annotated struct.\n-pub(crate) struct SubdiagnosticDerive<'a> {\n-    structure: Structure<'a>,\n+pub(crate) struct SubdiagnosticDeriveBuilder {\n     diag: syn::Ident,\n+    f: syn::Ident,\n }\n \n-impl<'a> SubdiagnosticDerive<'a> {\n-    pub(crate) fn new(structure: Structure<'a>) -> Self {\n+impl SubdiagnosticDeriveBuilder {\n+    pub(crate) fn new() -> Self {\n         let diag = format_ident!(\"diag\");\n-        Self { structure, diag }\n+        let f = format_ident!(\"f\");\n+        Self { diag, f }\n     }\n \n-    pub(crate) fn into_tokens(self) -> TokenStream {\n-        let SubdiagnosticDerive { mut structure, diag } = self;\n+    pub(crate) fn into_tokens<'a>(self, mut structure: Structure<'a>) -> TokenStream {\n         let implementation = {\n             let ast = structure.ast();\n             let span = ast.span().unwrap();\n@@ -53,10 +53,11 @@ impl<'a> SubdiagnosticDerive<'a> {\n \n             structure.bind_with(|_| synstructure::BindStyle::Move);\n             let variants_ = structure.each_variant(|variant| {\n-                let mut builder = SubdiagnosticDeriveBuilder {\n-                    diag: &diag,\n+                let mut builder = SubdiagnosticDeriveVariantBuilder {\n+                    parent: &self,\n                     variant,\n                     span,\n+                    formatting_init: TokenStream::new(),\n                     fields: build_field_mapping(variant),\n                     span_field: None,\n                     applicability: None,\n@@ -72,9 +73,17 @@ impl<'a> SubdiagnosticDerive<'a> {\n             }\n         };\n \n+        let diag = &self.diag;\n+        let f = &self.f;\n         let ret = structure.gen_impl(quote! {\n             gen impl rustc_errors::AddToDiagnostic for @Self {\n-                fn add_to_diagnostic(self, #diag: &mut rustc_errors::Diagnostic) {\n+                fn add_to_diagnostic_with<__F>(self, #diag: &mut rustc_errors::Diagnostic, #f: __F)\n+                where\n+                    __F: Fn(\n+                        &mut rustc_errors::Diagnostic,\n+                        rustc_errors::SubdiagnosticMessage\n+                    ) -> rustc_errors::SubdiagnosticMessage,\n+                {\n                     use rustc_errors::{Applicability, IntoDiagnosticArg};\n                     #implementation\n                 }\n@@ -88,15 +97,18 @@ impl<'a> SubdiagnosticDerive<'a> {\n /// for the final generated method. This is a separate struct to `SubdiagnosticDerive`\n /// only to be able to destructure and split `self.builder` and the `self.structure` up to avoid a\n /// double mut borrow later on.\n-struct SubdiagnosticDeriveBuilder<'a> {\n+struct SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n     /// The identifier to use for the generated `DiagnosticBuilder` instance.\n-    diag: &'a syn::Ident,\n+    parent: &'parent SubdiagnosticDeriveBuilder,\n \n     /// Info for the current variant (or the type if not an enum).\n     variant: &'a VariantInfo<'a>,\n     /// Span for the entire type.\n     span: proc_macro::Span,\n \n+    /// Initialization of format strings for code suggestions.\n+    formatting_init: TokenStream,\n+\n     /// Store a map of field name to its corresponding field. This is built on construction of the\n     /// derive builder.\n     fields: FieldMap,\n@@ -112,7 +124,7 @@ struct SubdiagnosticDeriveBuilder<'a> {\n     has_suggestion_parts: bool,\n }\n \n-impl<'a> HasFieldMap for SubdiagnosticDeriveBuilder<'a> {\n+impl<'parent, 'a> HasFieldMap for SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n     fn get_field_binding(&self, field: &String) -> Option<&TokenStream> {\n         self.fields.get(field)\n     }\n@@ -156,7 +168,7 @@ impl<'a> FromIterator<&'a SubdiagnosticKind> for KindsStatistics {\n     }\n }\n \n-impl<'a> SubdiagnosticDeriveBuilder<'a> {\n+impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n     fn identify_kind(&mut self) -> Result<Vec<(SubdiagnosticKind, Path)>, DiagnosticDeriveError> {\n         let mut kind_slugs = vec![];\n \n@@ -187,7 +199,7 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n         let ast = binding.ast();\n         assert_eq!(ast.attrs.len(), 0, \"field with attribute used as diagnostic arg\");\n \n-        let diag = &self.diag;\n+        let diag = &self.parent.diag;\n         let ident = ast.ident.as_ref().unwrap();\n         // strip `r#` prefix, if present\n         let ident = format_ident!(\"{}\", ident);\n@@ -222,7 +234,7 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n                 };\n \n                 let generated = self\n-                    .generate_field_code_inner(kind_stats, attr, info)\n+                    .generate_field_code_inner(kind_stats, attr, info, inner_ty.will_iterate())\n                     .unwrap_or_else(|v| v.to_compile_error());\n \n                 inner_ty.with(binding, generated)\n@@ -235,13 +247,18 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n         kind_stats: KindsStatistics,\n         attr: &Attribute,\n         info: FieldInfo<'_>,\n+        clone_suggestion_code: bool,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n         let meta = attr.parse_meta()?;\n         match meta {\n             Meta::Path(path) => self.generate_field_code_inner_path(kind_stats, attr, info, path),\n-            Meta::List(list @ MetaList { .. }) => {\n-                self.generate_field_code_inner_list(kind_stats, attr, info, list)\n-            }\n+            Meta::List(list @ MetaList { .. }) => self.generate_field_code_inner_list(\n+                kind_stats,\n+                attr,\n+                info,\n+                list,\n+                clone_suggestion_code,\n+            ),\n             _ => throw_invalid_attr!(attr, &meta),\n         }\n     }\n@@ -345,6 +362,7 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n         attr: &Attribute,\n         info: FieldInfo<'_>,\n         list: MetaList,\n+        clone_suggestion_code: bool,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n         let span = attr.span().unwrap();\n         let ident = &list.path.segments.last().unwrap().ident;\n@@ -382,22 +400,29 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n                     match nested_name {\n                         \"code\" => {\n                             let formatted_str = self.build_format(&value.value(), value.span());\n-                            code.set_once(formatted_str, span);\n+                            let code_field = new_code_ident();\n+                            code.set_once((code_field, formatted_str), span);\n                         }\n                         _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n                             diag.help(\"`code` is the only valid nested attribute\")\n                         }),\n                     }\n                 }\n \n-                let Some((code, _)) = code else {\n+                let Some((code_field, formatted_str)) = code.value() else {\n                     span_err(span, \"`#[suggestion_part(...)]` attribute without `code = \\\"...\\\"`\")\n                         .emit();\n                     return Ok(quote! {});\n                 };\n                 let binding = info.binding;\n \n-                Ok(quote! { suggestions.push((#binding, #code)); })\n+                self.formatting_init.extend(quote! { let #code_field = #formatted_str; });\n+                let code_field = if clone_suggestion_code {\n+                    quote! { #code_field.clone() }\n+                } else {\n+                    quote! { #code_field }\n+                };\n+                Ok(quote! { suggestions.push((#binding, #code_field)); })\n             }\n             _ => throw_invalid_attr!(attr, &Meta::List(list), |diag| {\n                 let mut span_attrs = vec![];\n@@ -442,13 +467,23 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n \n         let span_field = self.span_field.value_ref();\n \n-        let diag = &self.diag;\n+        let diag = &self.parent.diag;\n+        let f = &self.parent.f;\n         let mut calls = TokenStream::new();\n         for (kind, slug) in kind_slugs {\n+            let message = format_ident!(\"__message\");\n+            calls.extend(quote! { let #message = #f(#diag, rustc_errors::fluent::#slug.into()); });\n+\n             let name = format_ident!(\"{}{}\", if span_field.is_some() { \"span_\" } else { \"\" }, kind);\n-            let message = quote! { rustc_errors::fluent::#slug };\n             let call = match kind {\n-                SubdiagnosticKind::Suggestion { suggestion_kind, applicability, code } => {\n+                SubdiagnosticKind::Suggestion {\n+                    suggestion_kind,\n+                    applicability,\n+                    code_init,\n+                    code_field,\n+                } => {\n+                    self.formatting_init.extend(code_init);\n+\n                     let applicability = applicability\n                         .value()\n                         .map(|a| quote! { #a })\n@@ -457,8 +492,7 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n \n                     if let Some(span) = span_field {\n                         let style = suggestion_kind.to_suggestion_style();\n-\n-                        quote! { #diag.#name(#span, #message, #code, #applicability, #style); }\n+                        quote! { #diag.#name(#span, #message, #code_field, #applicability, #style); }\n                     } else {\n                         span_err(self.span, \"suggestion without `#[primary_span]` field\").emit();\n                         quote! { unreachable!(); }\n@@ -499,6 +533,7 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n                     }\n                 }\n             };\n+\n             calls.extend(call);\n         }\n \n@@ -510,11 +545,13 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n             .map(|binding| self.generate_field_set_arg(binding))\n             .collect();\n \n+        let formatting_init = &self.formatting_init;\n         Ok(quote! {\n             #init\n+            #formatting_init\n             #attr_args\n-            #calls\n             #plain_args\n+            #calls\n         })\n     }\n }"}, {"sha": "4fd4adc5112679ab7044a252ca2cc0d144a544a6", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 40, "deletions": 68, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -4,16 +4,29 @@ use crate::diagnostics::error::{\n use proc_macro::Span;\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote, ToTokens};\n-use std::cmp::Ordering;\n+use std::cell::RefCell;\n use std::collections::{BTreeSet, HashMap};\n use std::fmt;\n use std::str::FromStr;\n use syn::{spanned::Spanned, Attribute, Field, Meta, Type, TypeTuple};\n use syn::{MetaList, MetaNameValue, NestedMeta, Path};\n-use synstructure::{BindStyle, BindingInfo, VariantInfo};\n+use synstructure::{BindingInfo, VariantInfo};\n \n use super::error::invalid_nested_attr;\n \n+thread_local! {\n+    pub static CODE_IDENT_COUNT: RefCell<u32> = RefCell::new(0);\n+}\n+\n+/// Returns an ident of the form `__code_N` where `N` is incremented once with every call.\n+pub(crate) fn new_code_ident() -> syn::Ident {\n+    CODE_IDENT_COUNT.with(|count| {\n+        let ident = format_ident!(\"__code_{}\", *count.borrow());\n+        *count.borrow_mut() += 1;\n+        ident\n+    })\n+}\n+\n /// Checks whether the type name of `ty` matches `name`.\n ///\n /// Given some struct at `a::b::c::Foo`, this will return true for `c::Foo`, `b::c::Foo`, or\n@@ -142,6 +155,15 @@ impl<'ty> FieldInnerTy<'ty> {\n         unreachable!();\n     }\n \n+    /// Returns `true` if `FieldInnerTy::with` will result in iteration for this inner type (i.e.\n+    /// that cloning might be required for values moved in the loop body).\n+    pub(crate) fn will_iterate(&self) -> bool {\n+        match self {\n+            FieldInnerTy::Vec(..) => true,\n+            FieldInnerTy::Option(..) | FieldInnerTy::None => false,\n+        }\n+    }\n+\n     /// Returns `Option` containing inner type if there is one.\n     pub(crate) fn inner_type(&self) -> Option<&'ty Type> {\n         match self {\n@@ -434,7 +456,12 @@ pub(super) enum SubdiagnosticKind {\n     Suggestion {\n         suggestion_kind: SuggestionKind,\n         applicability: SpannedOption<Applicability>,\n-        code: TokenStream,\n+        /// Identifier for variable used for formatted code, e.g. `___code_0`. Enables separation\n+        /// of formatting and diagnostic emission so that `set_arg` calls can happen in-between..\n+        code_field: syn::Ident,\n+        /// Initialization logic for `code_field`'s variable, e.g.\n+        /// `let __formatted_code = /* whatever */;`\n+        code_init: TokenStream,\n     },\n     /// `#[multipart_suggestion{,_short,_hidden,_verbose}]`\n     MultipartSuggestion {\n@@ -469,7 +496,8 @@ impl SubdiagnosticKind {\n                     SubdiagnosticKind::Suggestion {\n                         suggestion_kind,\n                         applicability: None,\n-                        code: TokenStream::new(),\n+                        code_field: new_code_ident(),\n+                        code_init: TokenStream::new(),\n                     }\n                 } else if let Some(suggestion_kind) =\n                     name.strip_prefix(\"multipart_suggestion\").and_then(|s| s.parse().ok())\n@@ -548,9 +576,10 @@ impl SubdiagnosticKind {\n             };\n \n             match (nested_name, &mut kind) {\n-                (\"code\", SubdiagnosticKind::Suggestion { .. }) => {\n+                (\"code\", SubdiagnosticKind::Suggestion { code_field, .. }) => {\n                     let formatted_str = fields.build_format(&value.value(), value.span());\n-                    code.set_once(formatted_str, span);\n+                    let code_init = quote! { let #code_field = #formatted_str; };\n+                    code.set_once(code_init, span);\n                 }\n                 (\n                     \"applicability\",\n@@ -582,13 +611,13 @@ impl SubdiagnosticKind {\n         }\n \n         match kind {\n-            SubdiagnosticKind::Suggestion { code: ref mut code_field, .. } => {\n-                *code_field = if let Some((code, _)) = code {\n-                    code\n+            SubdiagnosticKind::Suggestion { ref code_field, ref mut code_init, .. } => {\n+                *code_init = if let Some(init) = code.value() {\n+                    init\n                 } else {\n                     span_err(span, \"suggestion without `code = \\\"...\\\"`\").emit();\n-                    quote! { \"\" }\n-                }\n+                    quote! { let #code_field: String = unreachable!(); }\n+                };\n             }\n             SubdiagnosticKind::Label\n             | SubdiagnosticKind::Note\n@@ -620,65 +649,8 @@ impl quote::IdentFragment for SubdiagnosticKind {\n     }\n }\n \n-/// Wrapper around `synstructure::BindStyle` which implements `Ord`.\n-#[derive(PartialEq, Eq)]\n-pub(super) struct OrderedBindStyle(pub(super) BindStyle);\n-\n-impl OrderedBindStyle {\n-    /// Is `BindStyle::Move` or `BindStyle::MoveMut`?\n-    pub(super) fn is_move(&self) -> bool {\n-        matches!(self.0, BindStyle::Move | BindStyle::MoveMut)\n-    }\n-}\n-\n-impl Ord for OrderedBindStyle {\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        match (self.is_move(), other.is_move()) {\n-            // If both `self` and `other` are the same, then ordering is equal.\n-            (true, true) | (false, false) => Ordering::Equal,\n-            // If `self` is not a move then it should be considered less than `other` (so that\n-            // references are sorted first).\n-            (false, _) => Ordering::Less,\n-            // If `self` is a move then it must be greater than `other` (again, so that references\n-            // are sorted first).\n-            (true, _) => Ordering::Greater,\n-        }\n-    }\n-}\n-\n-impl PartialOrd for OrderedBindStyle {\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n /// Returns `true` if `field` should generate a `set_arg` call rather than any other diagnostic\n /// call (like `span_label`).\n pub(super) fn should_generate_set_arg(field: &Field) -> bool {\n     field.attrs.is_empty()\n }\n-\n-/// Returns `true` if `field` needs to have code generated in the by-move branch of the\n-/// generated derive rather than the by-ref branch.\n-pub(super) fn bind_style_of_field(field: &Field) -> OrderedBindStyle {\n-    let generates_set_arg = should_generate_set_arg(field);\n-    let is_multispan = type_matches_path(&field.ty, &[\"rustc_errors\", \"MultiSpan\"]);\n-    // FIXME(davidtwco): better support for one field needing to be in the by-move and\n-    // by-ref branches.\n-    let is_subdiagnostic = field\n-        .attrs\n-        .iter()\n-        .map(|attr| attr.path.segments.last().unwrap().ident.to_string())\n-        .any(|attr| attr == \"subdiagnostic\");\n-\n-    // `set_arg` calls take their argument by-move..\n-    let needs_move = generates_set_arg\n-        // If this is a `MultiSpan` field then it needs to be moved to be used by any\n-        // attribute..\n-        || is_multispan\n-        // If this a `#[subdiagnostic]` then it needs to be moved as the other diagnostic is\n-        // unlikely to be `Copy`..\n-        || is_subdiagnostic;\n-\n-    OrderedBindStyle(if needs_move { BindStyle::Move } else { BindStyle::Ref })\n-}"}, {"sha": "1e74e0e299099728c5997c1621cd51b085679fb3", "filename": "compiler/rustc_query_system/src/error.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_query_system%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_query_system%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Ferror.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -1,19 +1,15 @@\n-use rustc_errors::AddToDiagnostic;\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_session::Limit;\n use rustc_span::{Span, Symbol};\n \n+#[derive(Subdiagnostic)]\n+#[note(query_system::cycle_stack_middle)]\n pub struct CycleStack {\n+    #[primary_span]\n     pub span: Span,\n     pub desc: String,\n }\n \n-impl AddToDiagnostic for CycleStack {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n-        diag.span_note(self.span, &format!(\"...which requires {}...\", self.desc));\n-    }\n-}\n-\n #[derive(Copy, Clone)]\n pub enum HandleCycleError {\n     Error,\n@@ -53,7 +49,7 @@ pub struct Cycle {\n     #[primary_span]\n     pub span: Span,\n     pub stack_bottom: String,\n-    #[subdiagnostic]\n+    #[subdiagnostic(eager)]\n     pub cycle_stack: Vec<CycleStack>,\n     #[subdiagnostic]\n     pub stack_count: StackCount,"}, {"sha": "f47760e9ae6c8aa5818c875f8396ce4a6ff43b1d", "filename": "compiler/rustc_query_system/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Flib.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -4,7 +4,7 @@\n #![feature(min_specialization)]\n #![feature(extern_types)]\n #![allow(rustc::potential_query_instability)]\n-// #![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]"}, {"sha": "2e651b5387419fa2441abbda60e515a66b00e4c1", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -1,8 +1,9 @@\n //! Validates syntax inside Rust code blocks (\\`\\`\\`rust).\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_errors::{\n-    emitter::Emitter, translation::Translate, Applicability, Diagnostic, Handler,\n-    LazyFallbackBundle,\n+    emitter::Emitter,\n+    translation::{to_fluent_args, Translate},\n+    Applicability, Diagnostic, Handler, LazyFallbackBundle,\n };\n use rustc_parse::parse_stream_from_source_str;\n use rustc_session::parse::ParseSess;\n@@ -193,7 +194,7 @@ impl Emitter for BufferEmitter {\n     fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n         let mut buffer = self.buffer.borrow_mut();\n \n-        let fluent_args = self.to_fluent_args(diag.args());\n+        let fluent_args = to_fluent_args(diag.args());\n         let translated_main_message = self.translate_message(&diag.message[0].0, &fluent_args);\n \n         buffer.messages.push(format!(\"error from rustc: {}\", translated_main_message));"}, {"sha": "462f5e78498495503b9ca17e6e4ff3bd773e15ed", "filename": "src/test/ui-fulldeps/internal-lints/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -13,7 +13,7 @@ extern crate rustc_span;\n \n use rustc_errors::{\n     AddToDiagnostic, IntoDiagnostic, Diagnostic, DiagnosticBuilder,\n-    ErrorGuaranteed, Handler, fluent\n+    ErrorGuaranteed, Handler, fluent, SubdiagnosticMessage,\n };\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_span::Span;\n@@ -52,7 +52,10 @@ impl<'a> IntoDiagnostic<'a, ErrorGuaranteed> for TranslatableInIntoDiagnostic {\n pub struct UntranslatableInAddToDiagnostic;\n \n impl AddToDiagnostic for UntranslatableInAddToDiagnostic {\n-    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         diag.note(\"untranslatable diagnostic\");\n         //~^ ERROR diagnostics should be created using translatable messages\n     }\n@@ -61,7 +64,10 @@ impl AddToDiagnostic for UntranslatableInAddToDiagnostic {\n pub struct TranslatableInAddToDiagnostic;\n \n impl AddToDiagnostic for TranslatableInAddToDiagnostic {\n-    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         diag.note(fluent::compiletest::note);\n     }\n }"}, {"sha": "ac820a79db274b8888880b5ddad43cdd79ba8090", "filename": "src/test/ui-fulldeps/internal-lints/diagnostics.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.stderr?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -11,13 +11,13 @@ LL | #![deny(rustc::untranslatable_diagnostic)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostics should be created using translatable messages\n-  --> $DIR/diagnostics.rs:56:14\n+  --> $DIR/diagnostics.rs:59:14\n    |\n LL |         diag.note(\"untranslatable diagnostic\");\n    |              ^^^^\n \n error: diagnostics should only be created in `IntoDiagnostic`/`AddToDiagnostic` impls\n-  --> $DIR/diagnostics.rs:70:25\n+  --> $DIR/diagnostics.rs:76:25\n    |\n LL |     let _diag = handler.struct_err(fluent::compiletest::example);\n    |                         ^^^^^^^^^^\n@@ -29,13 +29,13 @@ LL | #![deny(rustc::diagnostic_outside_of_impl)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostics should only be created in `IntoDiagnostic`/`AddToDiagnostic` impls\n-  --> $DIR/diagnostics.rs:73:25\n+  --> $DIR/diagnostics.rs:79:25\n    |\n LL |     let _diag = handler.struct_err(\"untranslatable diagnostic\");\n    |                         ^^^^^^^^^^\n \n error: diagnostics should be created using translatable messages\n-  --> $DIR/diagnostics.rs:73:25\n+  --> $DIR/diagnostics.rs:79:25\n    |\n LL |     let _diag = handler.struct_err(\"untranslatable diagnostic\");\n    |                         ^^^^^^^^^^"}, {"sha": "e873c36e0b39a14f3adbdd86f9b189df92fd2519", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -678,3 +678,74 @@ enum ExampleEnum {\n struct RawIdentDiagnosticArg {\n     pub r#type: String,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest::example)]\n+struct SubdiagnosticBad {\n+    #[subdiagnostic(bad)]\n+//~^ ERROR `#[subdiagnostic(bad)]` is not a valid attribute\n+    note: Note,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest::example)]\n+struct SubdiagnosticBadStr {\n+    #[subdiagnostic = \"bad\"]\n+//~^ ERROR `#[subdiagnostic = ...]` is not a valid attribute\n+    note: Note,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest::example)]\n+struct SubdiagnosticBadTwice {\n+    #[subdiagnostic(bad, bad)]\n+//~^ ERROR `#[subdiagnostic(...)]` is not a valid attribute\n+    note: Note,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest::example)]\n+struct SubdiagnosticBadLitStr {\n+    #[subdiagnostic(\"bad\")]\n+//~^ ERROR `#[subdiagnostic(\"...\")]` is not a valid attribute\n+    note: Note,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(compiletest::example)]\n+struct SubdiagnosticEagerLint {\n+    #[subdiagnostic(eager)]\n+//~^ ERROR `#[subdiagnostic(...)]` is not a valid attribute\n+    note: Note,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest::example)]\n+struct SubdiagnosticEagerCorrect {\n+    #[subdiagnostic(eager)]\n+    note: Note,\n+}\n+\n+// Check that formatting of `correct` in suggestion doesn't move the binding for that field, making\n+// the `set_arg` call a compile error; and that isn't worked around by moving the `set_arg` call\n+// after the `span_suggestion` call - which breaks eager translation.\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion_short(\n+    parser::use_instead,\n+    applicability = \"machine-applicable\",\n+    code = \"{correct}\"\n+)]\n+pub(crate) struct SubdiagnosticWithSuggestion {\n+    #[primary_span]\n+    span: Span,\n+    invalid: String,\n+    correct: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest::example)]\n+struct SubdiagnosticEagerSuggestion {\n+    #[subdiagnostic(eager)]\n+    sub: SubdiagnosticWithSuggestion,\n+}"}, {"sha": "7a42d618707ad99cbd5ee22390378ca0a8bdc749", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/dc9f6f32434d0b7c761100d6b744af68acf743b1/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc9f6f32434d0b7c761100d6b744af68acf743b1/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=dc9f6f32434d0b7c761100d6b744af68acf743b1", "patch": "@@ -533,6 +533,46 @@ LL | #[label]\n    |\n    = help: `#[label]` and `#[suggestion]` can only be applied to fields\n \n+error: `#[subdiagnostic(bad)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:685:21\n+   |\n+LL |     #[subdiagnostic(bad)]\n+   |                     ^^^\n+   |\n+   = help: `eager` is the only supported nested attribute for `subdiagnostic`\n+\n+error: `#[subdiagnostic = ...]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:693:5\n+   |\n+LL |     #[subdiagnostic = \"bad\"]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: `eager` is the only supported nested attribute for `subdiagnostic`\n+\n+error: `#[subdiagnostic(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:701:5\n+   |\n+LL |     #[subdiagnostic(bad, bad)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: `eager` is the only supported nested attribute for `subdiagnostic`\n+\n+error: `#[subdiagnostic(\"...\")]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:709:21\n+   |\n+LL |     #[subdiagnostic(\"bad\")]\n+   |                     ^^^^^\n+   |\n+   = help: `eager` is the only supported nested attribute for `subdiagnostic`\n+\n+error: `#[subdiagnostic(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:717:5\n+   |\n+LL |     #[subdiagnostic(eager)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: eager subdiagnostics are not supported on lints\n+\n error: cannot find attribute `nonsense` in this scope\n   --> $DIR/diagnostic-derive.rs:55:3\n    |\n@@ -607,7 +647,7 @@ LL |         arg: impl IntoDiagnosticArg,\n    |                   ^^^^^^^^^^^^^^^^^ required by this bound in `DiagnosticBuilder::<'a, G>::set_arg`\n    = note: this error originates in the derive macro `Diagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 75 previous errors\n+error: aborting due to 80 previous errors\n \n Some errors have detailed explanations: E0277, E0425.\n For more information about an error, try `rustc --explain E0277`."}]}