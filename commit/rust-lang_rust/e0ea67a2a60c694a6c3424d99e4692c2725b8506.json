{"sha": "e0ea67a2a60c694a6c3424d99e4692c2725b8506", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwZWE2N2EyYTYwYzY5NGE2YzM0MjRkOTllNDY5MmMyNzI1Yjg1MDY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-18T18:01:54Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-18T18:48:58Z"}, "message": "prevent regions from escaping in ifaces; remove &r.T syntax", "tree": {"sha": "7f18e57c1d8fbceadeae31f2f30afdfce004f32d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f18e57c1d8fbceadeae31f2f30afdfce004f32d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0ea67a2a60c694a6c3424d99e4692c2725b8506", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0ea67a2a60c694a6c3424d99e4692c2725b8506", "html_url": "https://github.com/rust-lang/rust/commit/e0ea67a2a60c694a6c3424d99e4692c2725b8506", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0ea67a2a60c694a6c3424d99e4692c2725b8506/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb0a34c39865d456a776fc8e81ba780dd383f315", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb0a34c39865d456a776fc8e81ba780dd383f315", "html_url": "https://github.com/rust-lang/rust/commit/eb0a34c39865d456a776fc8e81ba780dd383f315"}], "stats": {"total": 541, "additions": 411, "deletions": 130}, "files": [{"sha": "b4377810458753980f1dc61c27e3165a6cc20b4e", "filename": "src/libcore/task.rs", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -832,10 +832,10 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n  * types; arbitrary type coercion is possible this way. The interface is safe\n  * as long as all key functions are monomorphic.\n  */\n-type local_data_key<T> = fn@(+@T);\n+type local_data_key<T: owned> = fn@(+@T);\n \n iface local_data { }\n-impl<T> of local_data for @T { }\n+impl<T: owned> of local_data for @T { }\n \n // We use dvec because it's the best data structure in core. If TLS is used\n // heavily in future, this could be made more efficient with a proper map.\n@@ -852,6 +852,7 @@ extern fn cleanup_task_local_map(map_ptr: *libc::c_void) unsafe {\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n unsafe fn get_task_local_map(task: *rust_task) -> task_local_map {\n+\n     // Relies on the runtime initialising the pointer to null.\n     // NOTE: The map's box lives in TLS invisibly referenced once. Each time\n     // we retrieve it for get/set, we make another reference, which get/set\n@@ -872,16 +873,20 @@ unsafe fn get_task_local_map(task: *rust_task) -> task_local_map {\n     }\n }\n \n-unsafe fn key_to_key_value<T>(key: local_data_key<T>) -> *libc::c_void {\n+unsafe fn key_to_key_value<T: owned>(\n+    key: local_data_key<T>) -> *libc::c_void {\n+\n     // Keys are closures, which are (fnptr,envptr) pairs. Use fnptr.\n     // Use reintepret_cast -- transmute would leak (forget) the closure.\n     let pair: (*libc::c_void, *libc::c_void) = unsafe::reinterpret_cast(key);\n     pair.first()\n }\n \n // If returning some(..), returns with @T with the map's reference. Careful!\n-unsafe fn local_data_lookup<T>(map: task_local_map, key: local_data_key<T>)\n-        -> option<(uint, *libc::c_void)> {\n+unsafe fn local_data_lookup<T: owned>(\n+    map: task_local_map, key: local_data_key<T>)\n+    -> option<(uint, *libc::c_void)> {\n+\n     let key_value = key_to_key_value(key);\n     let map_pos = (*map).position(|entry|\n         alt entry { some((k,_,_)) { k == key_value } none { false } }\n@@ -893,8 +898,10 @@ unsafe fn local_data_lookup<T>(map: task_local_map, key: local_data_key<T>)\n     }\n }\n \n-unsafe fn local_get_helper<T>(task: *rust_task, key: local_data_key<T>,\n-                              do_pop: bool) -> option<@T> {\n+unsafe fn local_get_helper<T: owned>(\n+    task: *rust_task, key: local_data_key<T>,\n+    do_pop: bool) -> option<@T> {\n+\n     let map = get_task_local_map(task);\n     // Interpret our findings from the map\n     do local_data_lookup(map, key).map |result| {\n@@ -912,17 +919,23 @@ unsafe fn local_get_helper<T>(task: *rust_task, key: local_data_key<T>,\n     }\n }\n \n-unsafe fn local_pop<T>(task: *rust_task,\n-                       key: local_data_key<T>) -> option<@T> {\n+unsafe fn local_pop<T: owned>(\n+    task: *rust_task,\n+    key: local_data_key<T>) -> option<@T> {\n+\n     local_get_helper(task, key, true)\n }\n \n-unsafe fn local_get<T>(task: *rust_task,\n-                       key: local_data_key<T>) -> option<@T> {\n+unsafe fn local_get<T: owned>(\n+    task: *rust_task,\n+    key: local_data_key<T>) -> option<@T> {\n+\n     local_get_helper(task, key, false)\n }\n \n-unsafe fn local_set<T>(task: *rust_task, key: local_data_key<T>, +data: @T) {\n+unsafe fn local_set<T: owned>(\n+    task: *rust_task, key: local_data_key<T>, +data: @T) {\n+\n     let map = get_task_local_map(task);\n     // Store key+data as *voids. Data is invisibly referenced once; key isn't.\n     let keyval = key_to_key_value(key);\n@@ -956,8 +969,10 @@ unsafe fn local_set<T>(task: *rust_task, key: local_data_key<T>, +data: @T) {\n     }\n }\n \n-unsafe fn local_modify<T>(task: *rust_task, key: local_data_key<T>,\n-                          modify_fn: fn(option<@T>) -> option<@T>) {\n+unsafe fn local_modify<T: owned>(\n+    task: *rust_task, key: local_data_key<T>,\n+    modify_fn: fn(option<@T>) -> option<@T>) {\n+\n     // Could be more efficient by doing the lookup work, but this is easy.\n     let newdata = modify_fn(local_pop(task, key));\n     if newdata.is_some() {\n@@ -970,29 +985,37 @@ unsafe fn local_modify<T>(task: *rust_task, key: local_data_key<T>,\n  * Remove a task-local data value from the table, returning the\n  * reference that was originally created to insert it.\n  */\n-unsafe fn local_data_pop<T>(key: local_data_key<T>) -> option<@T> {\n+unsafe fn local_data_pop<T: owned>(\n+    key: local_data_key<T>) -> option<@T> {\n+\n     local_pop(rustrt::rust_get_task(), key)\n }\n /**\n  * Retrieve a task-local data value. It will also be kept alive in the\n  * table until explicitly removed.\n  */\n-unsafe fn local_data_get<T>(key: local_data_key<T>) -> option<@T> {\n+unsafe fn local_data_get<T: owned>(\n+    key: local_data_key<T>) -> option<@T> {\n+\n     local_get(rustrt::rust_get_task(), key)\n }\n /**\n  * Store a value in task-local data. If this key already has a value,\n  * that value is overwritten (and its destructor is run).\n  */\n-unsafe fn local_data_set<T>(key: local_data_key<T>, +data: @T) {\n+unsafe fn local_data_set<T: owned>(\n+    key: local_data_key<T>, +data: @T) {\n+\n     local_set(rustrt::rust_get_task(), key, data)\n }\n /**\n  * Modify a task-local data value. If the function returns 'none', the\n  * data is removed (and its reference dropped).\n  */\n-unsafe fn local_data_modify<T>(key: local_data_key<T>,\n-                               modify_fn: fn(option<@T>) -> option<@T>) {\n+unsafe fn local_data_modify<T: owned>(\n+    key: local_data_key<T>,\n+    modify_fn: fn(option<@T>) -> option<@T>) {\n+\n     local_modify(rustrt::rust_get_task(), key, modify_fn)\n }\n "}, {"sha": "610dd43835c2e8f4a8e594e7a1a57cb1e2a0bfbf", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -193,7 +193,9 @@ mod tests {\n \n     type eqfn<T> = fn@(T, T) -> bool;\n \n-    fn test_parameterized<T: copy>(e: eqfn<T>, a: T, b: T, c: T, d: T) {\n+    fn test_parameterized<T: copy owned>(\n+        e: eqfn<T>, a: T, b: T, c: T, d: T) {\n+\n         let deq: deque::t<T> = deque::create::<T>();\n         assert (deq.size() == 0u);\n         deq.add_front(a);"}, {"sha": "8336d6b39abb8d7ec3f7ca32b606b262df3866f7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -383,8 +383,7 @@ class parser {\n         let name =\n             alt copy self.token {\n               token::IDENT(sid, _) => {\n-                if self.look_ahead(1u) == token::DOT || // backwards compat\n-                    self.look_ahead(1u) == token::BINOP(token::SLASH) {\n+                if self.look_ahead(1u) == token::BINOP(token::SLASH) {\n                     self.bump(); self.bump();\n                     some(self.get_str(sid))\n                 } else {"}, {"sha": "2d087d8d9dff1aefc719fe4aca3a29ce9fe6d8d6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -345,7 +345,7 @@ fn print_type_ex(s: ps, &&ty: @ast::ty, print_colons: bool) {\n       ast::ty_rptr(region, mt) {\n         alt region.node {\n           ast::re_anon { word(s.s, ~\"&\"); }\n-          _ { print_region(s, region); word(s.s, ~\".\"); }\n+          _ { print_region(s, region); word(s.s, ~\"/\"); }\n         }\n         print_mt(s, mt);\n       }"}, {"sha": "9547db818dbbcd4e058dd5acedbf42ae903c8245", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -272,7 +272,7 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         w.write_char('I');\n         w.write_uint(id.to_uint());\n       }\n-      ty::ty_param(id, did) {\n+      ty::ty_param({idx: id, def_id: did}) {\n         w.write_char('p');\n         w.write_str(cx.ds(did));\n         w.write_char('|');"}, {"sha": "81d87e9d29113daabfa67893b8186ff307e69989", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 88, "deletions": 5, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -115,7 +115,7 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n     fn check_for_box(cx: ctx, id: node_id, fv: option<@freevar_entry>,\n                      is_move: bool, var_t: ty::t, sp: span) {\n         // all captured data must be owned\n-        if !check_owned(cx, var_t, sp) { ret; }\n+        if !check_owned(cx.tcx, var_t, sp) { ret; }\n \n         // copied in data must be copyable, but moved in data can be anything\n         let is_implicit = fv.is_some();\n@@ -217,7 +217,13 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n     alt e.node {\n       expr_assign(_, ex) |\n       expr_unary(box(_), ex) | expr_unary(uniq(_), ex) |\n-      expr_ret(some(ex)) | expr_cast(ex, _) { maybe_copy(cx, ex); }\n+      expr_ret(some(ex)) {\n+        maybe_copy(cx, ex);\n+      }\n+      expr_cast(source, _) {\n+        maybe_copy(cx, source);\n+        check_cast_for_escaping_regions(cx, source, e);\n+      }\n       expr_copy(expr) { check_copy_ex(cx, expr, false); }\n       // Vector add copies, but not \"implicitly\"\n       expr_assign_op(_, _, ex) { check_copy_ex(cx, ex, false) }\n@@ -440,15 +446,92 @@ fn check_send(cx: ctx, ty: ty::t, sp: span) -> bool {\n     }\n }\n \n-fn check_owned(cx: ctx, ty: ty::t, sp: span) -> bool {\n-    if !ty::kind_is_owned(ty::type_kind(cx.tcx, ty)) {\n-        cx.tcx.sess.span_err(sp, ~\"not an owned value\");\n+// note: also used from middle::typeck::regionck!\n+fn check_owned(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n+    if !ty::kind_is_owned(ty::type_kind(tcx, ty)) {\n+        alt ty::get(ty).struct {\n+          ty::ty_param(*) {\n+            tcx.sess.span_err(sp, ~\"value may contain borrowed \\\n+                                    pointers; use `owned` bound\");\n+          }\n+          _ {\n+            tcx.sess.span_err(sp, ~\"value may contain borrowed \\\n+                                    pointers\");\n+          }\n+        }\n         false\n     } else {\n         true\n     }\n }\n \n+/// This is rather subtle.  When we are casting a value to a\n+/// instantiated iface like `a as iface/&r`, regionck already ensures\n+/// that any borrowed pointers that appear in the type of `a` are\n+/// bounded by `&r`.  However, it is possible that there are *type\n+/// parameters* in the type of `a`, and those *type parameters* may\n+/// have borrowed pointers within them.  We have to guarantee that the\n+/// regions which appear in those type parameters are not obscured.\n+///\n+/// Therefore, we ensure that one of three conditions holds:\n+///\n+/// (1) The iface instance cannot escape the current fn.  This is\n+/// guaranteed if the region bound `&r` is some scope within the fn\n+/// itself.  This case is safe because whatever borrowed pointers are\n+/// found within the type parameter, they must enclose the fn body\n+/// itself.\n+///\n+/// (2) The type parameter appears in the type of the iface.  For\n+/// example, if the type parameter is `T` and the iface type is\n+/// `deque<T>`, then whatever borrowed ptrs may appear in `T` also\n+/// appear in `deque<T>`.\n+///\n+/// (3) The type parameter is owned (and therefore does not contain\n+/// borrowed ptrs).\n+fn check_cast_for_escaping_regions(\n+    cx: ctx,\n+    source: @expr,\n+    target: @expr) {\n+\n+    // Determine what type we are casting to; if it is not an iface, then no\n+    // worries.\n+    let target_ty = ty::expr_ty(cx.tcx, target);\n+    let target_substs = alt ty::get(target_ty).struct {\n+      ty::ty_trait(_, substs) => {substs}\n+      _ => { ret; /* not a cast to a trait */ }\n+    };\n+\n+    // Check, based on the region associated with the iface, whether it can\n+    // possibly escape the enclosing fn item (note that all type parameters\n+    // must have been declared on the enclosing fn item):\n+    alt target_substs.self_r {\n+      some(ty::re_scope(*)) => { ret; /* case (1) */ }\n+      none | some(ty::re_static) | some(ty::re_free(*)) => {}\n+      some(ty::re_bound(*)) | some(ty::re_var(*)) => {\n+        cx.tcx.sess.span_bug(\n+            source.span,\n+            #fmt[\"bad region found in kind: %?\", target_substs.self_r]);\n+      }\n+    }\n+\n+    // Assuming the iface instance can escape, then ensure that each parameter\n+    // either appears in the iface type or is owned:\n+    let target_params = ty::param_tys_in_type(target_ty);\n+    let source_ty = ty::expr_ty(cx.tcx, source);\n+    do ty::walk_ty(source_ty) |ty| {\n+        alt ty::get(ty).struct {\n+          ty::ty_param(source_param) => {\n+            if target_params.contains(source_param) {\n+                /* case (2) */\n+            } else {\n+                check_owned(cx.tcx, ty, source.span); /* case (3) */\n+            }\n+          }\n+          _ => {}\n+        }\n+    }\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "79663a0466c1d2521d837a882da71fc07c1ad90d", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -1317,7 +1317,7 @@ enum copy_action { INIT, DROP_EXISTING, }\n fn type_is_structural_or_param(t: ty::t) -> bool {\n     if ty::type_is_structural(t) { ret true; }\n     alt ty::get(t).struct {\n-      ty::ty_param(_, _) { ret true; }\n+      ty::ty_param(*) { ret true; }\n       _ { ret false; }\n     }\n }"}, {"sha": "56444f1d281312ebdd65078ca7c640b39b729ed8", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -272,7 +272,7 @@ impl methods for reflector {\n           ty::ty_trait(_, _) { self.leaf(~\"trait\") }\n           ty::ty_var(_) { self.leaf(~\"var\") }\n           ty::ty_var_integral(_) { self.leaf(~\"var_integral\") }\n-          ty::ty_param(n, _) { self.visit(~\"param\", ~[self.c_uint(n)]) }\n+          ty::ty_param(p) { self.visit(~\"param\", ~[self.c_uint(p.idx)]) }\n           ty::ty_self { self.leaf(~\"self\") }\n           ty::ty_type { self.leaf(~\"type\") }\n           ty::ty_opaque_box { self.leaf(~\"opaque_box\") }"}, {"sha": "942c1808568af5d53888f40e8b01e605d92804f9", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -137,8 +137,8 @@ fn type_needs_inner(cx: ctx, use: uint, ty: ty::t,\n                 }\n                 false\n               }\n-              ty::ty_param(n, _) {\n-                cx.uses[n] |= use;\n+              ty::ty_param(p) {\n+                cx.uses[p.idx] |= use;\n                 false\n               }\n               _ { true }"}, {"sha": "08ef9fb6bff19a8b4b56447ca3837f6cfc2b5541", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -166,6 +166,7 @@ export terr_regions_differ, terr_mutability, terr_purity_mismatch;\n export terr_proto_mismatch;\n export terr_ret_style_mismatch;\n export purity_to_str;\n+export param_tys_in_type;\n \n // Data types\n \n@@ -312,6 +313,8 @@ type fn_ty = {purity: ast::purity,\n               output: t,\n               ret_style: ret_style};\n \n+type param_ty = {idx: uint, def_id: def_id};\n+\n // See discussion at head of region.rs\n enum region {\n     re_bound(bound_region),\n@@ -370,7 +373,7 @@ enum sty {\n     ty_var(tv_vid), // type variable during typechecking\n     ty_var_integral(tvi_vid), // type variable during typechecking, for\n                               // integral types only\n-    ty_param(uint, def_id), // type parameter\n+    ty_param(param_ty), // type parameter\n     ty_self, // special, implicit `self` type parameter\n \n     // \"Fake\" types, used for trans purposes\n@@ -579,7 +582,7 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) |\n       ty_opaque_box {}\n-      ty_param(_, _) { flags |= has_params as uint; }\n+      ty_param(_) { flags |= has_params as uint; }\n       ty_var(_) | ty_var_integral(_) { flags |= needs_infer as uint; }\n       ty_self { flags |= has_self as uint; }\n       ty_enum(_, substs) | ty_class(_, substs) | ty_trait(_, substs) {\n@@ -713,7 +716,9 @@ fn mk_var_integral(cx: ctxt, v: tvi_vid) -> t {\n \n fn mk_self(cx: ctxt) -> t { mk_t(cx, ty_self) }\n \n-fn mk_param(cx: ctxt, n: uint, k: def_id) -> t { mk_t(cx, ty_param(n, k)) }\n+fn mk_param(cx: ctxt, n: uint, k: def_id) -> t {\n+    mk_t(cx, ty_param({idx: n, def_id: k}))\n+}\n \n fn mk_type(cx: ctxt) -> t { mk_t(cx, ty_type) }\n \n@@ -761,7 +766,7 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_estr(_) | ty_type | ty_opaque_box | ty_self |\n       ty_opaque_closure_ptr(_) | ty_var(_) | ty_var_integral(_) |\n-      ty_param(_, _) {\n+      ty_param(_) {\n       }\n       ty_box(tm) | ty_evec(tm, _) | ty_unboxed_vec(tm) |\n       ty_ptr(tm) | ty_rptr(_, tm) {\n@@ -982,7 +987,7 @@ fn subst_tps(cx: ctxt, tps: ~[t], typ: t) -> t {\n     let tb = ty::get(typ);\n     if !tbox_has_flag(tb, has_params) { ret typ; }\n     alt tb.struct {\n-      ty_param(idx, _) { tps[idx] }\n+      ty_param(p) { tps[p.idx] }\n       sty { fold_sty_to_ty(cx, sty, |t| subst_tps(cx, tps, t)) }\n     }\n }\n@@ -1019,7 +1024,7 @@ fn subst(cx: ctxt,\n         let tb = get(typ);\n         if !tbox_has_flag(tb, needs_subst) { ret typ; }\n         alt tb.struct {\n-          ty_param(idx, _) {substs.tps[idx]}\n+          ty_param(p) {substs.tps[p.idx]}\n           ty_self {substs.self_ty.get()}\n           _ {\n             fold_regions_and_ty(\n@@ -1608,8 +1613,8 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n         lowest\n       }\n \n-      ty_param(_, did) {\n-        param_bounds_to_kind(cx.ty_param_bounds.get(did.node))\n+      ty_param(p) {\n+        param_bounds_to_kind(cx.ty_param_bounds.get(p.def_id.node))\n       }\n \n       // self is a special type parameter that can only appear in ifaces; it\n@@ -1666,7 +1671,7 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n           ty_fn(_) |\n           ty_var(_) |\n           ty_var_integral(_) |\n-          ty_param(_, _) |\n+          ty_param(_) |\n           ty_self |\n           ty_type |\n           ty_opaque_box |\n@@ -1855,7 +1860,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_evec(mt, vstore_fixed(_)) | ty_unboxed_vec(mt) {\n         result = type_is_pod(cx, mt.ty);\n       }\n-      ty_param(_, _) { result = false; }\n+      ty_param(_) { result = false; }\n       ty_opaque_closure_ptr(_) { result = true; }\n       ty_class(did, substs) {\n         result = vec::any(lookup_class_fields(cx, did), |f| {\n@@ -1899,7 +1904,7 @@ fn type_is_c_like_enum(cx: ctxt, ty: t) -> bool {\n \n fn type_param(ty: t) -> option<uint> {\n     alt get(ty).struct {\n-      ty_param(id, _) { ret some(id); }\n+      ty_param(p) { ret some(p.idx); }\n       _ {/* fall through */ }\n     }\n     ret none;\n@@ -2038,7 +2043,7 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_self { 28u }\n       ty_var(v) { hash_uint(29u, v.to_uint()) }\n       ty_var_integral(v) { hash_uint(30u, v.to_uint()) }\n-      ty_param(pid, did) { hash_def(hash_uint(31u, pid), did) }\n+      ty_param(p) { hash_def(hash_uint(31u, p.idx), p.def_id) }\n       ty_type { 32u }\n       ty_bot { 34u }\n       ty_ptr(mt) { hash_subty(35u, mt.ty) }\n@@ -2219,6 +2224,22 @@ fn method_idx(id: ast::ident, meths: ~[method]) -> option<uint> {\n     ret none;\n }\n \n+/// Returns a vector containing the indices of all type parameters that appear\n+/// in `ty`.  The vector may contain duplicates.  Probably should be converted\n+/// to a bitset or some other representation.\n+fn param_tys_in_type(ty: t) -> ~[param_ty] {\n+    let mut rslt = ~[];\n+    do walk_ty(ty) |ty| {\n+        alt get(ty).struct {\n+          ty_param(p) {\n+            vec::push(rslt, p);\n+          }\n+          _ { }\n+        }\n+    }\n+    rslt\n+}\n+\n fn occurs_check(tcx: ctxt, sp: span, vid: tv_vid, rt: t) {\n \n     // Returns a vec of all the type variables occurring in `ty`. It may\n@@ -2341,7 +2362,7 @@ fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n       ty_tup(_) { ~\"tuple\" }\n       ty_var(_) { ~\"variable\" }\n       ty_var_integral(_) { ~\"integral variable\" }\n-      ty_param(_, _) { ~\"type parameter\" }\n+      ty_param(_) { ~\"type parameter\" }\n       ty_self { ~\"self\" }\n     }\n }"}, {"sha": "ebd189a15b71c29d0eeb1e68e3d7375221777a1e", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -68,7 +68,7 @@ fn get_region_reporting_err(tcx: ty::ctxt,\n     }\n }\n \n-fn ast_region_to_region<AC: ast_conv, RS: region_scope>(\n+fn ast_region_to_region<AC: ast_conv, RS: region_scope copy owned>(\n     self: AC, rscope: RS, span: span, a_r: @ast::region) -> ty::region {\n \n     let res = alt a_r.node {\n@@ -79,7 +79,7 @@ fn ast_region_to_region<AC: ast_conv, RS: region_scope>(\n     get_region_reporting_err(self.tcx(), span, res)\n }\n \n-fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope copy>(\n+fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope copy owned>(\n     self: AC, rscope: RS, did: ast::def_id,\n     path: @ast::path) -> ty_param_substs_and_ty {\n \n@@ -128,7 +128,7 @@ fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope copy>(\n     {substs: substs, ty: ty::subst(tcx, substs, decl_ty)}\n }\n \n-fn ast_path_to_ty<AC: ast_conv, RS: region_scope copy>(\n+fn ast_path_to_ty<AC: ast_conv, RS: region_scope copy owned>(\n     self: AC,\n     rscope: RS,\n     did: ast::def_id,\n@@ -151,18 +151,18 @@ const NO_TPS: uint = 2u;\n // Parses the programmer's textual representation of a type into our\n // internal notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n-fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n+fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy owned>(\n     self: AC, rscope: RS, &&ast_ty: @ast::ty) -> ty::t {\n \n-    fn ast_mt_to_mt<AC: ast_conv, RS: region_scope copy>(\n+    fn ast_mt_to_mt<AC: ast_conv, RS: region_scope copy owned>(\n         self: AC, rscope: RS, mt: ast::mt) -> ty::mt {\n \n         ret {ty: ast_ty_to_ty(self, rscope, mt.ty), mutbl: mt.mutbl};\n     }\n \n     // Handle @, ~, and & being able to mean estrs and evecs.\n     // If a_seq_ty is a str or a vec, make it an estr/evec\n-    fn mk_maybe_vstore<AC: ast_conv, RS: region_scope copy>(\n+    fn mk_maybe_vstore<AC: ast_conv, RS: region_scope copy owned>(\n         self: AC, rscope: RS, a_seq_ty: ast::mt, vst: ty::vstore,\n         constr: fn(ty::mt) -> ty::t) -> ty::t {\n \n@@ -351,7 +351,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n     ret typ;\n }\n \n-fn ty_of_arg<AC: ast_conv, RS: region_scope copy>(\n+fn ty_of_arg<AC: ast_conv, RS: region_scope copy owned>(\n     self: AC, rscope: RS, a: ast::arg,\n     expected_ty: option<ty::arg>) -> ty::arg {\n \n@@ -394,7 +394,7 @@ fn ty_of_arg<AC: ast_conv, RS: region_scope copy>(\n type expected_tys = option<{inputs: ~[ty::arg],\n                             output: ty::t}>;\n \n-fn ty_of_fn_decl<AC: ast_conv, RS: region_scope copy>(\n+fn ty_of_fn_decl<AC: ast_conv, RS: region_scope copy owned>(\n     self: AC, rscope: RS,\n     proto: ast::proto,\n     decl: ast::fn_decl,"}, {"sha": "d1d91f9e5b5a7563d16aae2ded054298ccd16163", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -2154,7 +2154,7 @@ fn check_bounds_are_used(ccx: @crate_ctxt,\n         |_r| {},\n         |t| {\n             alt ty::get(t).struct {\n-              ty::ty_param(idx, _) { tps_used[idx] = true; }\n+              ty::ty_param({idx, _}) { tps_used[idx] = true; }\n               _ { }\n             }\n             true"}, {"sha": "c2135249c9c29c3a0b71b31f3e7bef2080c21390", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -87,8 +87,8 @@ class lookup {\n         loop {\n             // First, see whether this is an interface-bounded parameter.\n             alt ty::get(self.self_ty).struct {\n-              ty::ty_param(n, did) {\n-                self.add_candidates_from_param(n, did);\n+              ty::ty_param(p) {\n+                self.add_candidates_from_param(p.idx, p.def_id);\n               }\n               ty::ty_trait(did, substs) {\n                 self.add_candidates_from_trait(did, substs);"}, {"sha": "b307460628a97563d02053425a38c2a29eb8d3be", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 99, "deletions": 44, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -20,23 +20,59 @@ this point a bit better.\n import util::ppaux;\n import syntax::print::pprust;\n import infer::{resolve_type, resolve_all, force_all,\n-               resolve_rvar, force_rvar};\n+               resolve_rvar, force_rvar, fres};\n+import middle::kind::check_owned;\n \n-type rcx = @{fcx: @fn_ctxt, mut errors_reported: uint};\n-type rvt = visit::vt<rcx>;\n+enum rcx { rcx_({fcx: @fn_ctxt, mut errors_reported: uint}) }\n+type rvt = visit::vt<@rcx>;\n+\n+impl methods for @rcx {\n+    /// Try to resolve the type for the given node.\n+    ///\n+    /// Note one important point: we do not attempt to resolve *region\n+    /// variables* here.  This is because regionck is essentially adding\n+    /// constraints to those region variables and so may yet influence\n+    /// how they are resolved.\n+    ///\n+    /// Consider this silly example:\n+    ///\n+    ///     fn borrow(x: &int) -> &int {x}\n+    ///     fn foo(x: @int) -> int {  /* block: B */\n+    ///         let b = borrow(x);    /* region: <R0> */\n+    ///         *b\n+    ///     }\n+    ///\n+    /// Here, the region of `b` will be `<R0>`.  `<R0>` is constrainted\n+    /// to be some subregion of the block B and some superregion of\n+    /// the call.  If we forced it now, we'd choose the smaller region\n+    /// (the call).  But that would make the *b illegal.  Since we don't\n+    /// resolve, the type of b will be `&<R0>.int` and then `*b` will require\n+    /// that `<R0>` be bigger than the let and the `*b` expression, so we\n+    /// will effectively resolve `<R0>` to be the block B.\n+    fn resolve_type(unresolved_ty: ty::t) -> fres<ty::t> {\n+        resolve_type(self.fcx.infcx, unresolved_ty,\n+                     (resolve_all | force_all) -\n+                     (resolve_rvar | force_rvar))\n+    }\n+\n+    /// Try to resolve the type for the given node.\n+    fn resolve_node_type(id: ast::node_id) -> fres<ty::t> {\n+        self.resolve_type(self.fcx.node_ty(id))\n+    }\n+}\n \n fn regionck_expr(fcx: @fn_ctxt, e: @ast::expr) {\n-    let rcx = @{fcx:fcx, mut errors_reported: 0u};\n+    let rcx = rcx_({fcx:fcx, mut errors_reported: 0u});\n     let v = regionck_visitor();\n-    v.visit_expr(e, rcx, v);\n+    v.visit_expr(e, @rcx, v);\n }\n \n fn regionck_fn(fcx: @fn_ctxt,\n                _decl: ast::fn_decl,\n                blk: ast::blk) {\n-    let rcx = @{fcx:fcx, mut errors_reported: 0u};\n+    let rcx = rcx_({fcx:fcx, mut errors_reported: 0u});\n     let v = regionck_visitor();\n-    v.visit_block(blk, rcx, v);\n+    v.visit_block(blk, @rcx, v);\n }\n \n fn regionck_visitor() -> rvt {\n@@ -49,11 +85,11 @@ fn regionck_visitor() -> rvt {\n                    with *visit::default_visitor()})\n }\n \n-fn visit_item(_item: @ast::item, &&_rcx: rcx, _v: rvt) {\n+fn visit_item(_item: @ast::item, &&_rcx: @rcx, _v: rvt) {\n     // Ignore items\n }\n \n-fn visit_local(l: @ast::local, &&rcx: rcx, v: rvt) {\n+fn visit_local(l: @ast::local, &&rcx: @rcx, v: rvt) {\n     let e = rcx.errors_reported;\n     v.visit_pat(l.node.pat, rcx, v);\n     if e != rcx.errors_reported {\n@@ -66,7 +102,7 @@ fn visit_local(l: @ast::local, &&rcx: rcx, v: rvt) {\n     }\n }\n \n-fn visit_pat(p: @ast::pat, &&rcx: rcx, v: rvt) {\n+fn visit_pat(p: @ast::pat, &&rcx: @rcx, v: rvt) {\n     let fcx = rcx.fcx;\n     alt p.node {\n       ast::pat_ident(path, _)\n@@ -80,11 +116,11 @@ fn visit_pat(p: @ast::pat, &&rcx: rcx, v: rvt) {\n     visit::visit_pat(p, rcx, v);\n }\n \n-fn visit_block(b: ast::blk, &&rcx: rcx, v: rvt) {\n+fn visit_block(b: ast::blk, &&rcx: @rcx, v: rvt) {\n     visit::visit_block(b, rcx, v);\n }\n \n-fn visit_expr(e: @ast::expr, &&rcx: rcx, v: rvt) {\n+fn visit_expr(e: @ast::expr, &&rcx: @rcx, v: rvt) {\n     #debug[\"visit_expr(e=%s)\", pprust::expr_to_str(e)];\n \n     alt e.node {\n@@ -99,52 +135,63 @@ fn visit_expr(e: @ast::expr, &&rcx: rcx, v: rvt) {\n           _ { }\n         }\n       }\n+\n+      ast::expr_cast(source, _) {\n+        // Determine if we are casting `source` to an iface instance.\n+        // If so, we have to be sure that the type of the source obeys\n+        // the iface's region bound.\n+        //\n+        // Note: there is a subtle point here concerning type\n+        // parameters.  It is possible that the type of `source`\n+        // contains type parameters, which in turn may contain regions\n+        // that are not visible to us (only the caller knows about\n+        // them).  The kind checker is ultimately responsible for\n+        // guaranteeing region safety in that particular case.  There\n+        // is an extensive comment on the function\n+        // check_cast_for_escaping_regions() in kind.rs explaining how\n+        // it goes about doing that.\n+        alt rcx.resolve_node_type(e.id) {\n+          result::err(_) => { ret; /* typeck will fail anyhow */ }\n+          result::ok(target_ty) => {\n+            alt ty::get(target_ty).struct {\n+              ty::ty_trait(_, substs) {\n+                let iface_region = alt substs.self_r {\n+                  some(r) => {r}\n+                  none => {ty::re_static}\n+                };\n+                let source_ty = rcx.fcx.expr_ty(source);\n+                constrain_regions_in_type(rcx, iface_region,\n+                                          e.span, source_ty);\n+              }\n+              _ { }\n+            }\n+          }\n+        };\n+\n+      }\n+\n       _ { }\n     }\n \n     if !visit_node(e.id, e.span, rcx) { ret; }\n     visit::visit_expr(e, rcx, v);\n }\n \n-fn visit_stmt(s: @ast::stmt, &&rcx: rcx, v: rvt) {\n+fn visit_stmt(s: @ast::stmt, &&rcx: @rcx, v: rvt) {\n     visit::visit_stmt(s, rcx, v);\n }\n \n // checks the type of the node `id` and reports an error if it\n // references a region that is not in scope for that node.  Returns\n // false if an error is reported; this is used to cause us to cut off\n // region checking for that subtree to avoid reporting tons of errors.\n-fn visit_node(id: ast::node_id, span: span, rcx: rcx) -> bool {\n+fn visit_node(id: ast::node_id, span: span, rcx: @rcx) -> bool {\n     let fcx = rcx.fcx;\n \n     // Try to resolve the type.  If we encounter an error, then typeck\n     // is going to fail anyway, so just stop here and let typeck\n     // report errors later on in the writeback phase.\n-    //\n-    // Note one important point: we do not attempt to resolve *region\n-    // variables* here.  This is because regionck is essentially adding\n-    // constraints to those region variables and so may yet influence\n-    // how they are resolved.\n-    //\n-    // Consider this silly example:\n-    //\n-    //     fn borrow(x: &int) -> &int {x}\n-    //     fn foo(x: @int) -> int {  /* block: B */\n-    //         let b = borrow(x);    /* region: <R0> */\n-    //         *b\n-    //     }\n-    //\n-    // Here, the region of `b` will be `<R0>`.  `<R0>` is constrainted\n-    // to be some subregion of the block B and some superregion of\n-    // the call.  If we forced it now, we'd choose the smaller region\n-    // (the call).  But that would make the *b illegal.  Since we don't\n-    // resolve, the type of b will be `&<R0>.int` and then `*b` will require\n-    // that `<R0>` be bigger than the let and the `*b` expression, so we\n-    // will effectively resolve `<R0>` to be the block B.\n-    let ty0 = fcx.node_ty(id);\n-    let ty = alt resolve_type(fcx.infcx, ty0,\n-                              (resolve_all | force_all) -\n-                              (resolve_rvar | force_rvar)) {\n+    let ty = alt rcx.resolve_node_type(id) {\n       result::err(_) { ret true; }\n       result::ok(ty) { ty }\n     };\n@@ -153,21 +200,29 @@ fn visit_node(id: ast::node_id, span: span, rcx: rcx) -> bool {\n     let tcx = fcx.ccx.tcx;\n     let encl_region = ty::encl_region(tcx, id);\n \n-    #debug[\"visit_node(ty=%s, id=%d, encl_region=%s, ty0=%s)\",\n+    #debug[\"visit_node(ty=%s, id=%d, encl_region=%s)\",\n            ppaux::ty_to_str(tcx, ty),\n            id,\n-           ppaux::region_to_str(tcx, encl_region),\n-           ppaux::ty_to_str(tcx, ty0)];\n+           ppaux::region_to_str(tcx, encl_region)];\n \n     // Otherwise, look at the type and see if it is a region pointer.\n+    ret constrain_regions_in_type(rcx, encl_region, span, ty);\n+}\n+\n+fn constrain_regions_in_type(\n+    rcx: @rcx,\n+    encl_region: ty::region,\n+    span: span,\n+    ty: ty::t) -> bool {\n+\n     let e = rcx.errors_reported;\n     ty::walk_regions_and_ty(\n-        tcx, ty,\n+        rcx.fcx.ccx.tcx, ty,\n         |r| constrain_region(rcx, encl_region, span, r),\n         |t| ty::type_has_regions(t));\n     ret (e == rcx.errors_reported);\n \n-    fn constrain_region(rcx: rcx,\n+    fn constrain_region(rcx: @rcx,\n                         encl_region: ty::region,\n                         span: span,\n                         region: ty::region) {"}, {"sha": "ad4a7a46c3c33e72b4f1454f3a845c331d49bfad", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -64,7 +64,7 @@ fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n     };\n     let ty = fixup_ty(fcx, sp, ty);\n     alt ty::get(ty).struct {\n-      ty::ty_param(n, did) {\n+      ty::ty_param({idx: n, def_id: did}) {\n         let mut n_bound = 0u;\n         for vec::each(*tcx.ty_param_bounds.get(did.node)) |bound| {\n             alt bound {"}, {"sha": "44d929a9efc120a9dabfa37bfd0f4b1a3bc2b397", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -69,7 +69,9 @@ fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n }\n \n impl methods for @crate_ctxt {\n-    fn to_ty<RS: region_scope copy>(rs: RS, ast_ty: @ast::ty) -> ty::t {\n+    fn to_ty<RS: region_scope copy owned>(\n+        rs: RS, ast_ty: @ast::ty) -> ty::t {\n+\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n }"}, {"sha": "2bc01839563994ca3c1338d78c709e1478be4b87", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -195,7 +195,7 @@ export resolve_type, resolve_region;\n export resolve_borrowings;\n export methods; // for infer_ctxt\n export unify_methods; // for infer_ctxt\n-export fixup_err, fixup_err_to_str;\n+export fres, fixup_err, fixup_err_to_str;\n export assignment;\n export root, to_str;\n export int_ty_set_all;\n@@ -1789,7 +1789,7 @@ fn super_tys<C:combine>(\n         }\n       }\n \n-      (ty::ty_param(a_n, _), ty::ty_param(b_n, _)) if a_n == b_n {\n+      (ty::ty_param(a_p), ty::ty_param(b_p)) if a_p.idx == b_p.idx {\n         ok(a)\n       }\n "}, {"sha": "2c2db4a9c3c4255147eaa9f0e9b66298033a0a10", "filename": "src/rustc/middle/typeck/rscope.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -38,7 +38,7 @@ impl of region_scope for type_rscope {\n }\n \n enum anon_rscope = {anon: ty::region, base: region_scope};\n-fn in_anon_rscope<RS: region_scope copy>(self: RS, r: ty::region)\n+fn in_anon_rscope<RS: region_scope copy owned>(self: RS, r: ty::region)\n     -> @anon_rscope {\n     @anon_rscope({anon: r, base: self as region_scope})\n }\n@@ -52,7 +52,8 @@ impl of region_scope for @anon_rscope {\n }\n \n enum binding_rscope = {base: region_scope};\n-fn in_binding_rscope<RS: region_scope copy>(self: RS) -> @binding_rscope {\n+fn in_binding_rscope<RS: region_scope copy owned>(self: RS)\n+    -> @binding_rscope {\n     let base = self as region_scope;\n     @binding_rscope({base: base})\n }"}, {"sha": "778884ccaf95fdf068a54325cbc3d22b9868f1a3", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -216,7 +216,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       }\n       ty_var(v) { v.to_str() }\n       ty_var_integral(v) { v.to_str() }\n-      ty_param(id, _) {\n+      ty_param({idx: id, _}) {\n         ~\"'\" + str::from_bytes(~[('a' as u8) + (id as u8)])\n       }\n       ty_self { ~\"self\" }"}, {"sha": "5c9fad50378ee09ae4d9bc004405ef595fe6e3fe", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -13,7 +13,7 @@ fn item_check(t: &tree) -> int {\n     }\n }\n \n-fn bottom_up_tree(arena: &a.arena::arena, item: int, depth: int) -> &a.tree {\n+fn bottom_up_tree(arena: &arena::arena, item: int, depth: int) -> &tree {\n     if depth > 0 {\n         ret new(*arena) node(bottom_up_tree(arena, 2 * item - 1, depth - 1),\n                              bottom_up_tree(arena, 2 * item, depth - 1),"}, {"sha": "2e1d7778a9e08ba74817dbb3b1a0b77640d00236", "filename": "src/test/compile-fail/block-arg-used-as-lambda-with-illegal-cap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Fcompile-fail%2Fblock-arg-used-as-lambda-with-illegal-cap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Fcompile-fail%2Fblock-arg-used-as-lambda-with-illegal-cap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-arg-used-as-lambda-with-illegal-cap.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -3,7 +3,7 @@ fn to_lambda1(f: fn@(uint) -> uint) -> fn@(uint) -> uint {\n }\n \n fn to_lambda2(b: fn(uint) -> uint) -> fn@(uint) -> uint {\n-    ret to_lambda1({|x| b(x)}); //~ ERROR not an owned value\n+    ret to_lambda1({|x| b(x)}); //~ ERROR value may contain borrowed pointers\n }\n \n fn main() {"}, {"sha": "295e1749d4b8c3dcf0909893892d53e2adeb874d", "filename": "src/test/compile-fail/kindck-owned-trait-contains.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -0,0 +1,20 @@\n+iface repeat<A> { fn get() -> A; }\n+\n+impl<A:copy> of repeat<A> for @A {\n+    fn get() -> A { *self }\n+}\n+\n+fn repeater<A:copy>(v: @A) -> repeat<A> {\n+    // Note: owned kind is not necessary as A appears in the iface type\n+    v as repeat::<A> // No\n+}\n+\n+fn main() {\n+    // Here, an error results as the type of y is inferred to\n+    // repeater<&lt/3> where lt is the block.\n+    let y = { //~ ERROR reference is not valid outside of its lifetime\n+        let x = &3;\n+        repeater(@x)\n+    };\n+    assert 3 == *(y.get()); //~ ERROR reference is not valid outside of its lifetime\n+}\n\\ No newline at end of file"}, {"sha": "26570868c5f05948dfc03dd830f2260ed3c452c2", "filename": "src/test/compile-fail/kindck-owned-trait-scoped.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -0,0 +1,35 @@\n+// A dummy iface/impl that work close over any type.  The iface will\n+// be parameterized by a region due to the &self/int constraint.\n+\n+iface foo {\n+    fn foo(i: &self/int) -> int;\n+}\n+\n+impl<T:copy> of foo for T {\n+    fn foo(i: &self/int) -> int {*i}\n+}\n+\n+fn to_foo<T:copy>(t: T) {\n+    // This version is ok because, although T may contain borrowed\n+    // pointers, it never escapes the fn body.  We know this because\n+    // the type of foo includes a region which will be resolved to\n+    // the fn body itself.\n+    let v = &3;\n+    let x = {f:t} as foo;\n+    assert x.foo(v) == 3;\n+}\n+\n+fn to_foo_2<T:copy>(t: T) -> foo {\n+    // Not OK---T may contain borrowed ptrs and it is going to escape\n+    // as part of the returned foo value\n+    {f:t} as foo //~ ERROR value may contain borrowed pointers; use `owned` bound\n+}\n+\n+fn to_foo_3<T:copy owned>(t: T) -> foo {\n+    // OK---T may escape as part of the returned foo value, but it is\n+    // owned and hence does not contain borrowed ptrs\n+    {f:t} as foo\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "e1cebb46c475af6fc75d54f17ef2dd6fd485fa78", "filename": "src/test/compile-fail/kindck-owned-trait.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -0,0 +1,11 @@\n+iface foo { fn foo(); }\n+\n+fn to_foo<T: copy foo>(t: T) -> foo {\n+    t as foo //~ ERROR value may contain borrowed pointers; use `owned` bound\n+}\n+\n+fn to_foo2<T: copy foo owned>(t: T) -> foo {\n+    t as foo\n+}\n+\n+fn main() {}"}, {"sha": "e689292c45ed4558a411f6d5c08f3f23e0b3d0f5", "filename": "src/test/compile-fail/kindck-owned.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -1,5 +1,5 @@\n fn copy1<T: copy>(t: T) -> fn@() -> T {\n-    fn@() -> T { t } //~ ERROR not an owned value\n+    fn@() -> T { t } //~ ERROR value may contain borrowed pointers\n }\n \n fn copy2<T: copy owned>(t: T) -> fn@() -> T {\n@@ -8,12 +8,12 @@ fn copy2<T: copy owned>(t: T) -> fn@() -> T {\n \n fn main() {\n     let x = &3;\n-    copy2(&x); //~ ERROR instantiating a type parameter with an incompatible type\n+    copy2(&x); //~ ERROR missing `owned`\n \n     copy2(@3);\n-    copy2(@&x); //~ ERROR instantiating a type parameter with an incompatible type\n+    copy2(@&x); //~ ERROR missing `owned`\n \n     copy2(fn@() {});\n     copy2(fn~() {}); //~ WARNING instantiating copy type parameter with a not implicitly copyable type\n-    copy2(fn&() {}); //~ ERROR instantiating a type parameter with an incompatible type\n+    copy2(fn&() {}); //~ ERROR missing `copy owned`\n }"}, {"sha": "5d3b21783e5f0695b6326a44fad04817ddd095fb", "filename": "src/test/run-pass/borrowck-borrow-from-at-vec.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-at-vec.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -0,0 +1,10 @@\n+fn sum_slice(x: &[int]) -> int {\n+    let mut sum = 0;\n+    for x.each |i| { sum += i; }\n+    ret sum;\n+}\n+\n+fn main() {\n+    let x = @[1, 2, 3];\n+    assert sum_slice(x) == 6;\n+}\n\\ No newline at end of file"}, {"sha": "9c655c5954abcdded3db4504c0c8807cb5bf5429", "filename": "src/test/run-pass/issue-2734.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Fissue-2734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Fissue-2734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2734.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -1,7 +1,7 @@\n iface hax { } \n impl <A> of hax for A { } \n \n-fn perform_hax<T>(x: @T) -> hax {\n+fn perform_hax<T: owned>(x: @T) -> hax {\n     x as hax \n }\n "}, {"sha": "2ff4aa778565e56108910d5b86bd0897c7a77fab", "filename": "src/test/run-pass/issue-2735.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Fissue-2735.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Fissue-2735.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2735.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -1,7 +1,7 @@\n iface hax { } \n impl <A> of hax for A { } \n \n-fn perform_hax<T>(x: @T) -> hax {\n+fn perform_hax<T: owned>(x: @T) -> hax {\n     x as hax \n }\n "}, {"sha": "4b7f01e39debe77259baf27a5bb2ebe76867ed0e", "filename": "src/test/run-pass/kindck-owned-trait-contains-1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -0,0 +1,16 @@\n+iface repeat<A> { fn get() -> A; }\n+\n+impl<A:copy> of repeat<A> for @A {\n+    fn get() -> A { *self }\n+}\n+\n+fn repeater<A:copy>(v: @A) -> repeat<A> {\n+    // Note: owned kind is not necessary as A appears in the iface type\n+    v as repeat::<A> // No\n+}\n+\n+fn main() {\n+    let x = &3;\n+    let y = repeater(@x);\n+    assert *x == *(y.get());\n+}\n\\ No newline at end of file"}, {"sha": "3dfd78b2025c58828846b2845eac15b6c15e04d5", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -230,9 +230,9 @@ impl ptr_visitor<V: ty_visitor movable_ptr>\n     }\n \n     fn visit_rptr(mtbl: uint, inner: *tydesc) -> bool {\n-        self.align_to::<&static.u8>();\n+        self.align_to::<&static/u8>();\n         if ! self.inner.visit_rptr(mtbl, inner) { ret false; }\n-        self.bump_past::<&static.u8>();\n+        self.bump_past::<&static/u8>();\n         true\n     }\n \n@@ -268,9 +268,9 @@ impl ptr_visitor<V: ty_visitor movable_ptr>\n     }\n \n     fn visit_evec_slice(mtbl: uint, inner: *tydesc) -> bool {\n-        self.align_to::<&static.[u8]>();\n+        self.align_to::<&static/[u8]>();\n         if ! self.inner.visit_evec_slice(mtbl, inner) { ret false; }\n-        self.bump_past::<&static.[u8]>();\n+        self.bump_past::<&static/[u8]>();\n         true\n     }\n \n@@ -427,9 +427,9 @@ impl ptr_visitor<V: ty_visitor movable_ptr>\n     }\n \n     fn visit_self() -> bool {\n-        self.align_to::<&static.u8>();\n+        self.align_to::<&static/u8>();\n         if ! self.inner.visit_self() { ret false; }\n-        self.align_to::<&static.u8>();\n+        self.align_to::<&static/u8>();\n         true\n     }\n "}, {"sha": "d9571ab7c403c00b46d558036730a273e4a651b8", "filename": "src/test/run-pass/regions-addr-of-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Fregions-addr-of-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Fregions-addr-of-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-addr-of-ret.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -1,4 +1,4 @@\n-fn f(x : &a.int) -> &a.int {\n+fn f(x : &a/int) -> &a/int {\n     ret &*x;\n }\n "}, {"sha": "3bcbaa87f4c1d91597e27635486c9c9989b31230", "filename": "src/test/run-pass/regions-bot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Fregions-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Fregions-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-bot.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -1,6 +1,6 @@\n // A very limited test of the \"bottom\" region\n \n-fn produce_static<T>() -> &static.T { fail; }\n+fn produce_static<T>() -> &static/T { fail; }\n \n fn foo<T>(x: &T) -> &uint { produce_static() }\n "}, {"sha": "472edca31ca23d4b22f88bb92b727cec3f48c662", "filename": "src/test/run-pass/regions-fn-subtyping.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Fregions-fn-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Fregions-fn-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-fn-subtyping.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -8,14 +8,14 @@ fn ok(f: fn@(x: &uint)) {\n     // f's type should be a subtype of g's type), because f can be\n     // used in any context that expects g's type.  But this currently\n     // fails.\n-    let mut g: fn@(y: &r.uint) = fn@(x: &r.uint) { };\n+    let mut g: fn@(y: &r/uint) = fn@(x: &r/uint) { };\n     g = f;\n }\n \n // This version is the same as above, except that here, g's type is\n // inferred.\n fn ok_inferred(f: fn@(x: &uint)) {\n-    let mut g = fn@(x: &r.uint) { };\n+    let mut g = fn@(x: &r/uint) { };\n     g = f;\n }\n "}, {"sha": "619d2cdeaeb9fae2cf4e59a0b07734ced5d56753", "filename": "src/test/run-pass/regions-iface.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Fregions-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Fregions-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-iface.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -19,5 +19,8 @@ fn get_v(gc: get_ctxt) -> uint {\n fn main() {\n     let ctxt = { v: 22u };\n     let hc = { c: &ctxt };\n-    assert get_v(hc as get_ctxt) == 22u;\n+\n+    // This no longer works, interestingly, due to the ownership\n+    // requirement.  Perhaps this ownership requirement is too strict.\n+    // assert get_v(hc as get_ctxt) == 22u;\n }"}, {"sha": "15d3b7a4e14d14e29839b4be5b66995cd1d4c955", "filename": "src/test/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -15,12 +15,12 @@ type ccx = {\n     x: int\n };\n \n-fn alloc(_bcx : &a.arena) -> &a.bcx unsafe {\n+fn alloc(_bcx : &arena) -> &bcx unsafe {\n     ret unsafe::reinterpret_cast(\n         libc::malloc(sys::size_of::<bcx/&blk>() as libc::size_t));\n }\n \n-fn h(bcx : &a.bcx) -> &a.bcx {\n+fn h(bcx : &bcx) -> &bcx {\n     ret alloc(bcx.fcx.arena);\n }\n "}, {"sha": "2a4987f8b4557ceebf1c7d97385b9bd581271c20", "filename": "src/test/run-pass/regions-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Fregions-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0ea67a2a60c694a6c3424d99e4692c2725b8506/src%2Ftest%2Frun-pass%2Fregions-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-params.rs?ref=e0ea67a2a60c694a6c3424d99e4692c2725b8506", "patch": "@@ -1,4 +1,4 @@\n-fn region_identity(x: &r.uint) -> &r.uint { x }\n+fn region_identity(x: &uint) -> &uint { x }\n \n fn apply<T>(t: T, f: fn(T) -> T) -> T { f(t) }\n "}]}