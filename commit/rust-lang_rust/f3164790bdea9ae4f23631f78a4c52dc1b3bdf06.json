{"sha": "f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMTY0NzkwYmRlYTlhZTRmMjM2MzFmNzhhNGM1MmRjMWIzYmRmMDY=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-11T20:06:41Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-20T13:44:34Z"}, "message": "introduce newtype'd `Predicate<'tcx>`", "tree": {"sha": "d394c9822b9a506e93500c2e8c3b72668870187b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d394c9822b9a506e93500c2e8c3b72668870187b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "html_url": "https://github.com/rust-lang/rust/commit/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "034c25f33e496f602edebd845ddb4f940ac176cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/034c25f33e496f602edebd845ddb4f940ac176cf", "html_url": "https://github.com/rust-lang/rust/commit/034c25f33e496f602edebd845ddb4f940ac176cf"}], "stats": {"total": 590, "additions": 345, "deletions": 245}, "files": [{"sha": "23c9eeb21bb8dc30c3216edf8d7e28137802c212", "filename": "src/librustc_infer/infer/canonical/query_response.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -25,7 +25,7 @@ use rustc_middle::arena::ArenaAllocatable;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, BoundVar, Const, Ty, TyCtxt};\n+use rustc_middle::ty::{self, BoundVar, Const, ToPredicate, Ty, TyCtxt};\n use std::fmt::Debug;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n@@ -534,10 +534,12 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 match k1.unpack() {\n                     GenericArgKind::Lifetime(r1) => ty::PredicateKind::RegionOutlives(\n                         ty::Binder::bind(ty::OutlivesPredicate(r1, r2)),\n-                    ),\n+                    )\n+                    .to_predicate(self.tcx),\n                     GenericArgKind::Type(t1) => ty::PredicateKind::TypeOutlives(ty::Binder::bind(\n                         ty::OutlivesPredicate(t1, r2),\n-                    )),\n+                    ))\n+                    .to_predicate(self.tcx),\n                     GenericArgKind::Const(..) => {\n                         // Consts cannot outlive one another, so we don't expect to\n                         // ecounter this branch.\n@@ -666,7 +668,8 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n             param_env: self.param_env,\n             predicate: ty::PredicateKind::RegionOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n                 sup, sub,\n-            ))),\n+            )))\n+            .to_predicate(self.infcx.tcx),\n             recursion_depth: 0,\n         });\n     }"}, {"sha": "75f288f1cdcd23a3a16556c64b1cd543c8f8498b", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -39,7 +39,7 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, InferConst, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, InferConst, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use rustc_middle::ty::{IntType, UintType};\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -307,7 +307,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             self.obligations.push(Obligation::new(\n                 self.trace.cause.clone(),\n                 self.param_env,\n-                ty::PredicateKind::WellFormed(b_ty),\n+                ty::PredicateKind::WellFormed(b_ty).to_predicate(self.infcx.tcx),\n             ));\n         }\n \n@@ -398,11 +398,15 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         b: &'tcx ty::Const<'tcx>,\n     ) {\n         let predicate = if a_is_expected {\n-            ty::Predicate::ConstEquate(a, b)\n+            ty::PredicateKind::ConstEquate(a, b)\n         } else {\n-            ty::Predicate::ConstEquate(b, a)\n+            ty::PredicateKind::ConstEquate(b, a)\n         };\n-        self.obligations.push(Obligation::new(self.trace.cause.clone(), self.param_env, predicate));\n+        self.obligations.push(Obligation::new(\n+            self.trace.cause.clone(),\n+            self.param_env,\n+            predicate.to_predicate(self.tcx()),\n+        ));\n     }\n }\n "}, {"sha": "fd3b38e9d67b0e3b670f41c432ed836556d2c87f", "filename": "src/librustc_infer/infer/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -11,7 +11,7 @@ pub fn explicit_outlives_bounds<'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n ) -> impl Iterator<Item = OutlivesBound<'tcx>> + 'tcx {\n     debug!(\"explicit_outlives_bounds()\");\n-    param_env.caller_bounds.into_iter().filter_map(move |predicate| match predicate {\n+    param_env.caller_bounds.into_iter().filter_map(move |predicate| match predicate.kind() {\n         ty::PredicateKind::Projection(..)\n         | ty::PredicateKind::Trait(..)\n         | ty::PredicateKind::Subtype(..)"}, {"sha": "b51af19883fdd82e4be7f0347b052d589e6a2e73", "filename": "src/librustc_infer/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fsub.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -6,7 +6,7 @@ use crate::traits::Obligation;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::TyVar;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt};\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.\n@@ -104,7 +104,8 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n                         a_is_expected: self.a_is_expected,\n                         a,\n                         b,\n-                    })),\n+                    }))\n+                    .to_predicate(self.tcx()),\n                 ));\n \n                 Ok(a)"}, {"sha": "3175ad6c5a44e57c9110c9dc7b1d3165e5d1a20e", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -10,40 +10,49 @@ pub fn anonymize_predicate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     pred: &ty::Predicate<'tcx>,\n ) -> ty::Predicate<'tcx> {\n-    match *pred {\n+    match pred.kind() {\n         ty::PredicateKind::Trait(ref data, constness) => {\n             ty::PredicateKind::Trait(tcx.anonymize_late_bound_regions(data), constness)\n+                .to_predicate(tcx)\n         }\n \n         ty::PredicateKind::RegionOutlives(ref data) => {\n             ty::PredicateKind::RegionOutlives(tcx.anonymize_late_bound_regions(data))\n+                .to_predicate(tcx)\n         }\n \n         ty::PredicateKind::TypeOutlives(ref data) => {\n             ty::PredicateKind::TypeOutlives(tcx.anonymize_late_bound_regions(data))\n+                .to_predicate(tcx)\n         }\n \n         ty::PredicateKind::Projection(ref data) => {\n-            ty::PredicateKind::Projection(tcx.anonymize_late_bound_regions(data))\n+            ty::PredicateKind::Projection(tcx.anonymize_late_bound_regions(data)).to_predicate(tcx)\n         }\n \n-        ty::PredicateKind::WellFormed(data) => ty::PredicateKind::WellFormed(data),\n+        ty::PredicateKind::WellFormed(data) => {\n+            ty::PredicateKind::WellFormed(data).to_predicate(tcx)\n+        }\n \n-        ty::PredicateKind::ObjectSafe(data) => ty::PredicateKind::ObjectSafe(data),\n+        ty::PredicateKind::ObjectSafe(data) => {\n+            ty::PredicateKind::ObjectSafe(data).to_predicate(tcx)\n+        }\n \n         ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n-            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind)\n+            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind).to_predicate(tcx)\n         }\n \n         ty::PredicateKind::Subtype(ref data) => {\n-            ty::PredicateKind::Subtype(tcx.anonymize_late_bound_regions(data))\n+            ty::PredicateKind::Subtype(tcx.anonymize_late_bound_regions(data)).to_predicate(tcx)\n         }\n \n         ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n-            ty::PredicateKind::ConstEvaluatable(def_id, substs)\n+            ty::PredicateKind::ConstEvaluatable(def_id, substs).to_predicate(tcx)\n         }\n \n-        ty::PredicateKind::ConstEquate(c1, c2) => ty::Predicate::ConstEquate(c1, c2),\n+        ty::PredicateKind::ConstEquate(c1, c2) => {\n+            ty::PredicateKind::ConstEquate(c1, c2).to_predicate(tcx)\n+        }\n     }\n }\n \n@@ -145,7 +154,7 @@ impl Elaborator<'tcx> {\n \n     fn elaborate(&mut self, obligation: &PredicateObligation<'tcx>) {\n         let tcx = self.visited.tcx;\n-        match obligation.predicate {\n+        match obligation.predicate.kind() {\n             ty::PredicateKind::Trait(ref data, _) => {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n@@ -250,8 +259,9 @@ impl Elaborator<'tcx> {\n                                 None\n                             }\n                         })\n-                        .filter(|p| visited.insert(p))\n-                        .map(|p| predicate_obligation(p, None)),\n+                        .map(|predicate_kind| predicate_kind.to_predicate(tcx))\n+                        .filter(|predicate| visited.insert(predicate))\n+                        .map(|predicate| predicate_obligation(predicate, None)),\n                 );\n             }\n         }\n@@ -317,7 +327,7 @@ impl<'tcx, I: Iterator<Item = PredicateObligation<'tcx>>> Iterator for FilterToT\n \n     fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n         while let Some(obligation) = self.base_iterator.next() {\n-            if let ty::PredicateKind::Trait(data, _) = obligation.predicate {\n+            if let ty::PredicateKind::Trait(data, _) = obligation.predicate.kind() {\n                 return Some(data.to_poly_trait_ref());\n             }\n         }"}, {"sha": "e17e8b7b9640e8e8dfd334f088859da67a06d1b3", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -1208,7 +1208,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n             let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n             let predicates = cx.tcx.predicates_of(def_id);\n             for &(predicate, span) in predicates.predicates {\n-                let predicate_kind_name = match predicate {\n+                let predicate_kind_name = match predicate.kind() {\n                     Trait(..) => \"Trait\",\n                     TypeOutlives(..) |\n                     RegionOutlives(..) => \"Lifetime\",\n@@ -1497,7 +1497,7 @@ impl ExplicitOutlivesRequirements {\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n-            .filter_map(|(pred, _)| match pred {\n+            .filter_map(|(pred, _)| match pred.kind() {\n                 ty::PredicateKind::RegionOutlives(outlives) => {\n                     let outlives = outlives.skip_binder();\n                     match outlives.0 {\n@@ -1516,7 +1516,7 @@ impl ExplicitOutlivesRequirements {\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n-            .filter_map(|(pred, _)| match pred {\n+            .filter_map(|(pred, _)| match pred.kind() {\n                 ty::PredicateKind::TypeOutlives(outlives) => {\n                     let outlives = outlives.skip_binder();\n                     outlives.0.is_param(index).then_some(outlives.1)"}, {"sha": "dea829343137064da7097f6781cb76c9c859d7e7", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -146,7 +146,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n                 ty::Opaque(def, _) => {\n                     let mut has_emitted = false;\n                     for (predicate, _) in cx.tcx.predicates_of(def).predicates {\n-                        if let ty::PredicateKind::Trait(ref poly_trait_predicate, _) = predicate {\n+                        if let ty::PredicateKind::Trait(ref poly_trait_predicate, _) =\n+                            predicate.kind()\n+                        {\n                             let trait_ref = poly_trait_predicate.skip_binder().trait_ref;\n                             let def_id = trait_ref.def_id;\n                             let descr_pre ="}, {"sha": "68a4ccc3c9e6731fd4a805fe8c4bf1f83ea41626", "filename": "src/librustc_middle/ty/codec.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcodec.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -10,7 +10,7 @@ use crate::arena::ArenaAllocatable;\n use crate::infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n use crate::mir::{self, interpret::Allocation};\n use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, List, Ty, TyCtxt};\n+use crate::ty::{self, List, ToPredicate, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n@@ -196,7 +196,7 @@ where\n         (0..decoder.read_usize()?)\n             .map(|_| {\n                 // Handle shorthands first, if we have an usize > 0x80.\n-                let predicate = if decoder.positioned_at_shorthand() {\n+                let predicate_kind = if decoder.positioned_at_shorthand() {\n                     let pos = decoder.read_usize()?;\n                     assert!(pos >= SHORTHAND_OFFSET);\n                     let shorthand = pos - SHORTHAND_OFFSET;\n@@ -205,6 +205,7 @@ where\n                 } else {\n                     ty::PredicateKind::decode(decoder)\n                 }?;\n+                let predicate = predicate_kind.to_predicate(tcx);\n                 Ok((predicate, Decodable::decode(decoder)?))\n             })\n             .collect::<Result<Vec<_>, _>>()?,"}, {"sha": "4a9175d8c183878247d9e53e1860d98859c44e10", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -29,7 +29,9 @@ use crate::ty::{self, DefIdTree, Ty, TypeAndMut};\n use crate::ty::{AdtDef, AdtKind, Const, Region};\n use crate::ty::{BindingMode, BoundVar};\n use crate::ty::{ConstVid, FloatVar, FloatVid, IntVar, IntVid, TyVar, TyVid};\n-use crate::ty::{ExistentialPredicate, InferTy, ParamTy, PolyFnSig, Predicate, ProjectionTy};\n+use crate::ty::{\n+    ExistentialPredicate, InferTy, ParamTy, PolyFnSig, Predicate, PredicateKind, ProjectionTy,\n+};\n use crate::ty::{InferConst, ParamConst};\n use crate::ty::{List, TyKind, TyS};\n use rustc_ast::ast;\n@@ -2103,6 +2105,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.interners.intern_ty(st)\n     }\n \n+    #[inline]\n+    pub fn mk_predicate(&self, kind: PredicateKind<'tcx>) -> Predicate<'tcx> {\n+        Predicate { kind }\n+    }\n+\n     pub fn mk_mach_int(self, tm: ast::IntTy) -> Ty<'tcx> {\n         match tm {\n             ast::IntTy::Isize => self.types.isize,"}, {"sha": "3c4c4574bfd5493afa1dbf178cd841bc58c1ac1e", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -1016,7 +1016,17 @@ impl<'tcx> GenericPredicates<'tcx> {\n     }\n }\n \n-pub type Predicate<'tcx> = PredicateKind<'tcx>;\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Lift)]\n+#[derive(HashStable, TypeFoldable)]\n+pub struct Predicate<'tcx> {\n+    kind: PredicateKind<'tcx>,\n+}\n+\n+impl Predicate<'tcx> {\n+    pub fn kind(&self) -> PredicateKind<'tcx> {\n+        self.kind\n+    }\n+}\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n #[derive(HashStable, TypeFoldable)]\n@@ -1081,7 +1091,7 @@ impl<'tcx> AsRef<Predicate<'tcx>> for Predicate<'tcx> {\n     }\n }\n \n-impl<'tcx> PredicateKind<'tcx> {\n+impl<'tcx> Predicate<'tcx> {\n     /// Performs a substitution suitable for going from a\n     /// poly-trait-ref to supertraits that must hold if that\n     /// poly-trait-ref holds. This is slightly different from a normal\n@@ -1153,7 +1163,7 @@ impl<'tcx> PredicateKind<'tcx> {\n         // this trick achieves that).\n \n         let substs = &trait_ref.skip_binder().substs;\n-        match *self {\n+        match self.kind() {\n             PredicateKind::Trait(ref binder, constness) => {\n                 PredicateKind::Trait(binder.map_bound(|data| data.subst(tcx, substs)), constness)\n             }\n@@ -1181,6 +1191,7 @@ impl<'tcx> PredicateKind<'tcx> {\n                 PredicateKind::ConstEquate(c1.subst(tcx, substs), c2.subst(tcx, substs))\n             }\n         }\n+        .to_predicate(tcx)\n     }\n }\n \n@@ -1298,57 +1309,67 @@ pub trait ToPredicate<'tcx> {\n     fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx>;\n }\n \n+impl ToPredicate<'tcx> for PredicateKind<'tcx> {\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        tcx.mk_predicate(*self)\n+    }\n+}\n+\n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<TraitRef<'tcx>> {\n-    fn to_predicate(&self, _tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         ty::PredicateKind::Trait(\n             ty::Binder::dummy(ty::TraitPredicate { trait_ref: self.value }),\n             self.constness,\n         )\n+        .to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<&TraitRef<'tcx>> {\n-    fn to_predicate(&self, _tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         ty::PredicateKind::Trait(\n             ty::Binder::dummy(ty::TraitPredicate { trait_ref: *self.value }),\n             self.constness,\n         )\n+        .to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitRef<'tcx>> {\n-    fn to_predicate(&self, _tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         ty::PredicateKind::Trait(self.value.to_poly_trait_predicate(), self.constness)\n+            .to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<&PolyTraitRef<'tcx>> {\n-    fn to_predicate(&self, _tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         ty::PredicateKind::Trait(self.value.to_poly_trait_predicate(), self.constness)\n+            .to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {\n-    fn to_predicate(&self, _tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        PredicateKind::RegionOutlives(*self)\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        PredicateKind::RegionOutlives(*self).to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyTypeOutlivesPredicate<'tcx> {\n-    fn to_predicate(&self, _tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        PredicateKind::TypeOutlives(*self)\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        PredicateKind::TypeOutlives(*self).to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n-    fn to_predicate(&self, _tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        PredicateKind::Projection(*self)\n+    fn to_predicate(&self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        PredicateKind::Projection(*self).to_predicate(tcx)\n     }\n }\n \n-impl<'tcx> PredicateKind<'tcx> {\n+impl<'tcx> Predicate<'tcx> {\n     pub fn to_opt_poly_trait_ref(&self) -> Option<PolyTraitRef<'tcx>> {\n-        match *self {\n+        match self.kind() {\n             PredicateKind::Trait(ref t, _) => Some(t.to_poly_trait_ref()),\n             PredicateKind::Projection(..)\n             | PredicateKind::Subtype(..)\n@@ -1363,7 +1384,7 @@ impl<'tcx> PredicateKind<'tcx> {\n     }\n \n     pub fn to_opt_type_outlives(&self) -> Option<PolyTypeOutlivesPredicate<'tcx>> {\n-        match *self {\n+        match self.kind() {\n             PredicateKind::TypeOutlives(data) => Some(data),\n             PredicateKind::Trait(..)\n             | PredicateKind::Projection(..)"}, {"sha": "786fe55519e7b2e2c2996cd70172342a15ad0cc6", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -2031,7 +2031,7 @@ define_print_and_forward_display! {\n     }\n \n     ty::Predicate<'tcx> {\n-        match *self {\n+        match self.kind() {\n             ty::PredicateKind::Trait(ref data, constness) => {\n                 if let hir::Constness::Const = constness {\n                     p!(write(\"const \"));\n@@ -2058,7 +2058,7 @@ define_print_and_forward_display! {\n                    print_value_path(def_id, substs),\n                    write(\"` can be evaluated\"))\n             }\n-            ty::Predicate::ConstEquate(c1, c2) => {\n+            ty::PredicateKind::ConstEquate(c1, c2) => {\n                 p!(write(\"the constant `\"),\n                    print(c1),\n                    write(\"` equals `\"),"}, {"sha": "ca7cf97f4af349ebdd9c9f8eaeaac1f69e77a240", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -219,6 +219,12 @@ impl fmt::Debug for ty::ProjectionPredicate<'tcx> {\n     }\n }\n \n+impl fmt::Debug for ty::Predicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:?}\", self.kind())\n+    }\n+}\n+\n impl fmt::Debug for ty::PredicateKind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n@@ -242,7 +248,7 @@ impl fmt::Debug for ty::PredicateKind<'tcx> {\n             ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n                 write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n             }\n-            ty::Predicate::ConstEquate(c1, c2) => write!(f, \"ConstEquate({:?}, {:?})\", c1, c2),\n+            ty::PredicateKind::ConstEquate(c1, c2) => write!(f, \"ConstEquate({:?}, {:?})\", c1, c2),\n         }\n     }\n }\n@@ -469,8 +475,8 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialProjection<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n-    type Lifted = ty::Predicate<'tcx>;\n+impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n+    type Lifted = ty::PredicateKind<'tcx>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match *self {\n             ty::PredicateKind::Trait(ref binder, constness) => {\n@@ -500,8 +506,8 @@ impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n             ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n                 tcx.lift(&substs).map(|substs| ty::PredicateKind::ConstEvaluatable(def_id, substs))\n             }\n-            ty::Predicate::ConstEquate(c1, c2) => {\n-                tcx.lift(&(c1, c2)).map(|(c1, c2)| ty::Predicate::ConstEquate(c1, c2))\n+            ty::PredicateKind::ConstEquate(c1, c2) => {\n+                tcx.lift(&(c1, c2)).map(|(c1, c2)| ty::PredicateKind::ConstEquate(c1, c2))\n             }\n         }\n     }"}, {"sha": "0c9eef8093f33da4f16b9efc08597052f5b816f9", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -616,6 +616,7 @@ impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n             }\n             ExistentialPredicate::Projection(p) => {\n                 ty::PredicateKind::Projection(Binder(p.with_self_ty(tcx, self_ty)))\n+                    .to_predicate(tcx)\n             }\n             ExistentialPredicate::AutoTrait(did) => {\n                 let trait_ref ="}, {"sha": "ebc8021a3c577b5d23f1b70cd0509fbc8db72649", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -576,7 +576,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                     let mut found = false;\n                     for predicate in bounds.predicates {\n-                        if let ty::PredicateKind::TypeOutlives(binder) = predicate {\n+                        if let ty::PredicateKind::TypeOutlives(binder) = predicate.kind() {\n                             if let ty::OutlivesPredicate(_, ty::RegionKind::ReStatic) =\n                                 binder.skip_binder()\n                             {"}, {"sha": "bdbce1de745ad11164f44fda7a0f4eacef5af2f1", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -27,8 +27,8 @@ use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef, UserSubsts};\n use rustc_middle::ty::{\n-    self, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, RegionVid, ToPolyTraitRef, Ty,\n-    TyCtxt, UserType, UserTypeAnnotationIndex,\n+    self, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, RegionVid, ToPolyTraitRef,\n+    ToPredicate, Ty, TyCtxt, UserType, UserTypeAnnotationIndex,\n };\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n@@ -1016,7 +1016,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     self.prove_predicate(\n-                        ty::PredicateKind::WellFormed(inferred_ty),\n+                        ty::PredicateKind::WellFormed(inferred_ty).to_predicate(self.tcx()),\n                         Locations::All(span),\n                         ConstraintCategory::TypeAnnotation,\n                     );\n@@ -1268,7 +1268,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     obligations.obligations.push(traits::Obligation::new(\n                         ObligationCause::dummy(),\n                         param_env,\n-                        ty::PredicateKind::WellFormed(revealed_ty),\n+                        ty::PredicateKind::WellFormed(revealed_ty).to_predicate(infcx.tcx),\n                     ));\n                     obligations.add(\n                         infcx\n@@ -2028,7 +2028,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                             ),\n                                         }),\n                                         hir::Constness::NotConst,\n-                                    ),\n+                                    )\n+                                    .to_predicate(self.tcx()),\n                                 ),\n                                 &traits::SelectionError::Unimplemented,\n                                 false,\n@@ -2708,11 +2709,12 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n     fn prove_predicates(\n         &mut self,\n-        predicates: impl IntoIterator<Item = ty::Predicate<'tcx>>,\n+        predicates: impl IntoIterator<Item = impl ToPredicate<'tcx>>,\n         locations: Locations,\n         category: ConstraintCategory,\n     ) {\n         for predicate in predicates {\n+            let predicate = predicate.to_predicate(self.tcx());\n             debug!(\"prove_predicates(predicate={:?}, locations={:?})\", predicate, locations,);\n \n             self.prove_predicate(predicate, locations, category);"}, {"sha": "55be4f55a569c806b54c9c746192bee29f6331b3", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -23,7 +23,7 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n     loop {\n         let predicates = tcx.predicates_of(current);\n         for (predicate, _) in predicates.predicates {\n-            match predicate {\n+            match predicate.kind() {\n                 ty::PredicateKind::RegionOutlives(_)\n                 | ty::PredicateKind::TypeOutlives(_)\n                 | ty::PredicateKind::WellFormed(_)\n@@ -46,7 +46,7 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n                     match pred.skip_binder().self_ty().kind {\n                         ty::Param(ref p) => {\n                             // Allow `T: ?const Trait`\n-                            if *constness == hir::Constness::NotConst\n+                            if constness == hir::Constness::NotConst\n                                 && feature_allowed(tcx, def_id, sym::const_trait_bound_opt_out)\n                             {\n                                 continue;"}, {"sha": "9a63e39f535c12e8af4947a3b21064aec42542b0", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -90,7 +90,7 @@ where\n     fn visit_predicates(&mut self, predicates: ty::GenericPredicates<'tcx>) -> bool {\n         let ty::GenericPredicates { parent: _, predicates } = predicates;\n         for (predicate, _span) in predicates {\n-            match predicate {\n+            match predicate.kind() {\n                 ty::PredicateKind::Trait(poly_predicate, _) => {\n                     let ty::TraitPredicate { trait_ref } = *poly_predicate.skip_binder();\n                     if self.visit_trait(trait_ref) {"}, {"sha": "2544e4ddea2ecf25029a7a86f30ae31c03bb0af1", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -1168,7 +1168,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         debug!(\"instantiate_opaque_types: ty_var={:?}\", ty_var);\n \n         for predicate in &bounds.predicates {\n-            if let ty::PredicateKind::Projection(projection) = &predicate {\n+            if let ty::PredicateKind::Projection(projection) = predicate.kind() {\n                 if projection.skip_binder().ty.references_error() {\n                     // No point on adding these obligations since there's a type error involved.\n                     return ty_var;\n@@ -1269,7 +1269,7 @@ crate fn required_region_bounds(\n     traits::elaborate_predicates(tcx, predicates)\n         .filter_map(|obligation| {\n             debug!(\"required_region_bounds(obligation={:?})\", obligation);\n-            match obligation.predicate {\n+            match obligation.predicate.kind() {\n                 ty::PredicateKind::Projection(..)\n                 | ty::PredicateKind::Trait(..)\n                 | ty::PredicateKind::Subtype(..)"}, {"sha": "bea472522675392be95e9c6deb26049d34d49974", "filename": "src/librustc_trait_selection/traits/auto_trait.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -341,7 +341,8 @@ impl AutoTraitFinder<'tcx> {\n                         already_visited.remove(&pred);\n                         self.add_user_pred(\n                             &mut user_computed_preds,\n-                            ty::PredicateKind::Trait(pred, hir::Constness::NotConst),\n+                            ty::PredicateKind::Trait(pred, hir::Constness::NotConst)\n+                                .to_predicate(self.tcx),\n                         );\n                         predicates.push_back(pred);\n                     } else {\n@@ -412,9 +413,9 @@ impl AutoTraitFinder<'tcx> {\n         let mut should_add_new = true;\n         user_computed_preds.retain(|&old_pred| {\n             if let (\n-                &ty::PredicateKind::Trait(new_trait, _),\n+                ty::PredicateKind::Trait(new_trait, _),\n                 ty::PredicateKind::Trait(old_trait, _),\n-            ) = (&new_pred, old_pred)\n+            ) = (new_pred.kind(), old_pred.kind())\n             {\n                 if new_trait.def_id() == old_trait.def_id() {\n                     let new_substs = new_trait.skip_binder().trait_ref.substs;\n@@ -632,8 +633,8 @@ impl AutoTraitFinder<'tcx> {\n             //\n             // We check this by calling is_of_param on the relevant types\n             // from the various possible predicates\n-            match &predicate {\n-                &ty::PredicateKind::Trait(p, _) => {\n+            match predicate.kind() {\n+                ty::PredicateKind::Trait(p, _) => {\n                     if self.is_param_no_infer(p.skip_binder().trait_ref.substs)\n                         && !only_projections\n                         && is_new_pred\n@@ -642,7 +643,7 @@ impl AutoTraitFinder<'tcx> {\n                     }\n                     predicates.push_back(p);\n                 }\n-                &ty::PredicateKind::Projection(p) => {\n+                ty::PredicateKind::Projection(p) => {\n                     debug!(\n                         \"evaluate_nested_obligations: examining projection predicate {:?}\",\n                         predicate\n@@ -767,12 +768,12 @@ impl AutoTraitFinder<'tcx> {\n                         }\n                     }\n                 }\n-                &ty::PredicateKind::RegionOutlives(ref binder) => {\n+                ty::PredicateKind::RegionOutlives(ref binder) => {\n                     if select.infcx().region_outlives_predicate(&dummy_cause, binder).is_err() {\n                         return false;\n                     }\n                 }\n-                &ty::PredicateKind::TypeOutlives(ref binder) => {\n+                ty::PredicateKind::TypeOutlives(ref binder) => {\n                     match (\n                         binder.no_bound_vars(),\n                         binder.map_bound_ref(|pred| pred.0).no_bound_vars(),"}, {"sha": "f85735064c838be24f61322b5f50a2f8ad207676", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -252,7 +252,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     .emit();\n                     return;\n                 }\n-                match obligation.predicate {\n+                match obligation.predicate.kind() {\n                     ty::PredicateKind::Trait(ref trait_predicate, _) => {\n                         let trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n \n@@ -471,7 +471,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                 predicate: ty::PredicateKind::Trait(\n                                     predicate,\n                                     hir::Constness::NotConst,\n-                                ),\n+                                )\n+                                .to_predicate(self.tcx),\n                                 ..obligation.clone()\n                             };\n                             if self.predicate_may_hold(&unit_obligation) {\n@@ -616,7 +617,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         )\n                     }\n \n-                    ty::Predicate::ConstEquate(..) => {\n+                    ty::PredicateKind::ConstEquate(..) => {\n                         // Errors for `ConstEquate` predicates show up as\n                         // `SelectionError::ConstEvalFailure`,\n                         // not `Unimplemented`.\n@@ -1046,18 +1047,16 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return true;\n         }\n \n-        let (cond, error) = match (cond, error) {\n-            (&ty::PredicateKind::Trait(..), &ty::PredicateKind::Trait(ref error, _)) => {\n-                (cond, error)\n-            }\n+        let (cond, error) = match (cond.kind(), error.kind()) {\n+            (ty::PredicateKind::Trait(..), ty::PredicateKind::Trait(error, _)) => (cond, error),\n             _ => {\n                 // FIXME: make this work in other cases too.\n                 return false;\n             }\n         };\n \n         for obligation in super::elaborate_predicates(self.tcx, std::iter::once(*cond)) {\n-            if let ty::PredicateKind::Trait(implication, _) = obligation.predicate {\n+            if let ty::PredicateKind::Trait(implication, _) = obligation.predicate.kind() {\n                 let error = error.to_poly_trait_ref();\n                 let implication = implication.to_poly_trait_ref();\n                 // FIXME: I'm just not taking associated types at all here.\n@@ -1137,7 +1136,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             //\n             // this can fail if the problem was higher-ranked, in which\n             // cause I have no idea for a good error message.\n-            if let ty::PredicateKind::Projection(ref data) = predicate {\n+            if let ty::PredicateKind::Projection(ref data) = predicate.kind() {\n                 let mut selcx = SelectionContext::new(self);\n                 let (data, _) = self.replace_bound_vars_with_fresh_vars(\n                     obligation.cause.span,\n@@ -1417,7 +1416,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        let mut err = match predicate {\n+        let mut err = match predicate.kind() {\n             ty::PredicateKind::Trait(ref data, _) => {\n                 let trait_ref = data.to_poly_trait_ref();\n                 let self_ty = trait_ref.self_ty();\n@@ -1662,7 +1661,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         if let (\n             ty::PredicateKind::Trait(pred, _),\n             ObligationCauseCode::BindingObligation(item_def_id, span),\n-        ) = (&obligation.predicate, &obligation.cause.code)\n+        ) = (obligation.predicate.kind(), &obligation.cause.code)\n         {\n             if let (Some(generics), true) = (\n                 self.tcx.hir().get_if_local(*item_def_id).as_ref().and_then(|n| n.generics()),"}, {"sha": "6167412642eab20fae0f62888feae7e48bea49a2", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -1242,7 +1242,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // the type. The last generator (`outer_generator` below) has information about where the\n         // bound was introduced. At least one generator should be present for this diagnostic to be\n         // modified.\n-        let (mut trait_ref, mut target_ty) = match obligation.predicate {\n+        let (mut trait_ref, mut target_ty) = match obligation.predicate.kind() {\n             ty::PredicateKind::Trait(p, _) => {\n                 (Some(p.skip_binder().trait_ref), Some(p.skip_binder().self_ty()))\n             }"}, {"sha": "88ff97e793af41c4645d2a3041aa3a1bda38a207", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -322,7 +322,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n \n         let infcx = self.selcx.infcx();\n \n-        match obligation.predicate {\n+        match obligation.predicate.kind() {\n             ty::PredicateKind::Trait(ref data, _) => {\n                 let trait_obligation = obligation.with(*data);\n \n@@ -523,7 +523,7 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::ConstEquate(c1, c2) => {\n+            ty::PredicateKind::ConstEquate(c1, c2) => {\n                 debug!(\"equating consts: c1={:?} c2={:?}\", c1, c2);\n \n                 let stalled_on = &mut pending_obligation.stalled_on;"}, {"sha": "3daa9109aafe8141f02e4051716d551610f89a78", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -333,7 +333,7 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // This works fairly well because trait matching  does not actually care about param-env\n     // TypeOutlives predicates - these are normally used by regionck.\n     let outlives_predicates: Vec<_> = predicates\n-        .drain_filter(|predicate| match predicate {\n+        .drain_filter(|predicate| match predicate.kind() {\n             ty::PredicateKind::TypeOutlives(..) => true,\n             _ => false,\n         })"}, {"sha": "b2d684e674f02ba736b4559559c196acc7c22e9a", "filename": "src/librustc_trait_selection/traits/object_safety.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -245,7 +245,7 @@ fn predicates_reference_self(\n         .iter()\n         .map(|(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), sp))\n         .filter_map(|(predicate, &sp)| {\n-            match predicate {\n+            match predicate.kind() {\n                 ty::PredicateKind::Trait(ref data, _) => {\n                     // In the case of a trait predicate, we can skip the \"self\" type.\n                     if data.skip_binder().trait_ref.substs[1..].iter().any(has_self_ty) {\n@@ -304,19 +304,22 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     // Search for a predicate like `Self : Sized` amongst the trait bounds.\n     let predicates = tcx.predicates_of(def_id);\n     let predicates = predicates.instantiate_identity(tcx).predicates;\n-    elaborate_predicates(tcx, predicates.into_iter()).any(|obligation| match obligation.predicate {\n-        ty::PredicateKind::Trait(ref trait_pred, _) => {\n-            trait_pred.def_id() == sized_def_id && trait_pred.skip_binder().self_ty().is_param(0)\n+    elaborate_predicates(tcx, predicates.into_iter()).any(|obligation| {\n+        match obligation.predicate.kind() {\n+            ty::PredicateKind::Trait(ref trait_pred, _) => {\n+                trait_pred.def_id() == sized_def_id\n+                    && trait_pred.skip_binder().self_ty().is_param(0)\n+            }\n+            ty::PredicateKind::Projection(..)\n+            | ty::PredicateKind::Subtype(..)\n+            | ty::PredicateKind::RegionOutlives(..)\n+            | ty::PredicateKind::WellFormed(..)\n+            | ty::PredicateKind::ObjectSafe(..)\n+            | ty::PredicateKind::ClosureKind(..)\n+            | ty::PredicateKind::TypeOutlives(..)\n+            | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::ConstEquate(..) => false,\n         }\n-        ty::PredicateKind::Projection(..)\n-        | ty::PredicateKind::Subtype(..)\n-        | ty::PredicateKind::RegionOutlives(..)\n-        | ty::PredicateKind::WellFormed(..)\n-        | ty::PredicateKind::ObjectSafe(..)\n-        | ty::PredicateKind::ClosureKind(..)\n-        | ty::PredicateKind::TypeOutlives(..)\n-        | ty::PredicateKind::ConstEvaluatable(..)\n-        | ty::PredicateKind::ConstEquate(..) => false,\n     })\n }\n "}, {"sha": "bcf28cb29cb85ececa0f52faa1745c24091f8105", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -661,7 +661,7 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n     let mut obligations: Vec<_> = result\n         .obligations\n         .iter()\n-        .filter(|obligation| match obligation.predicate {\n+        .filter(|obligation| match obligation.predicate.kind() {\n             // We found a `T: Foo<X = U>` predicate, let's check\n             // if `U` references any unresolved type\n             // variables. In principle, we only care if this\n@@ -930,7 +930,7 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     let infcx = selcx.infcx();\n     for predicate in env_predicates {\n         debug!(\"assemble_candidates_from_predicates: predicate={:?}\", predicate);\n-        if let ty::PredicateKind::Projection(data) = predicate {\n+        if let ty::PredicateKind::Projection(data) = predicate.kind() {\n             let same_def_id = data.projection_def_id() == obligation.predicate.item_def_id;\n \n             let is_match = same_def_id\n@@ -1166,7 +1166,7 @@ fn confirm_object_candidate<'cx, 'tcx>(\n \n         // select only those projections that are actually projecting an\n         // item with the correct name\n-        let env_predicates = env_predicates.filter_map(|o| match o.predicate {\n+        let env_predicates = env_predicates.filter_map(|o| match o.predicate.kind() {\n             ty::PredicateKind::Projection(data) => {\n                 if data.projection_def_id() == obligation.predicate.item_def_id {\n                     Some(data)"}, {"sha": "5c8719da14e6fcabe9eb58520a45458a3535b551", "filename": "src/librustc_trait_selection/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -15,7 +15,7 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n         // `&T`, accounts for about 60% percentage of the predicates\n         // we have to prove. No need to canonicalize and all that for\n         // such cases.\n-        if let ty::PredicateKind::Trait(trait_ref, _) = key.value.predicate {\n+        if let ty::PredicateKind::Trait(trait_ref, _) = key.value.predicate.kind() {\n             if let Some(sized_def_id) = tcx.lang_items().sized_trait() {\n                 if trait_ref.def_id() == sized_def_id {\n                     if trait_ref.skip_binder().self_ty().is_trivially_sized(tcx) {"}, {"sha": "59d85281d633b81233b328d3f3255cf064bac2bc", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -413,7 +413,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             None => self.check_recursion_limit(&obligation, &obligation)?,\n         }\n \n-        match obligation.predicate {\n+        match obligation.predicate.kind() {\n             ty::PredicateKind::Trait(ref t, _) => {\n                 debug_assert!(!t.has_escaping_bound_vars());\n                 let obligation = obligation.with(*t);\n@@ -510,7 +510,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::Predicate::ConstEquate(c1, c2) => {\n+            ty::PredicateKind::ConstEquate(c1, c2) => {\n                 debug!(\"evaluate_predicate_recursively: equating consts c1={:?} c2={:?}\", c1, c2);\n \n                 let evaluate = |c: &'tcx ty::Const<'tcx>| {\n@@ -675,8 +675,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // trait refs. This is important because it's only a cycle\n             // if the regions match exactly.\n             let cycle = stack.iter().skip(1).take_while(|s| s.depth >= cycle_depth);\n+            let tcx = self.tcx();\n             let cycle = cycle.map(|stack| {\n                 ty::PredicateKind::Trait(stack.obligation.predicate, hir::Constness::NotConst)\n+                    .to_predicate(tcx)\n             });\n             if self.coinductive_match(cycle) {\n                 debug!(\"evaluate_stack({:?}) --> recursive, coinductive\", stack.fresh_trait_ref);\n@@ -791,7 +793,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn coinductive_predicate(&self, predicate: ty::Predicate<'tcx>) -> bool {\n-        let result = match predicate {\n+        let result = match predicate.kind() {\n             ty::PredicateKind::Trait(ref data, _) => self.tcx().trait_is_auto(data.def_id()),\n             _ => false,\n         };\n@@ -2921,7 +2923,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             obligations.push(Obligation::new(\n                 obligation.cause.clone(),\n                 obligation.param_env,\n-                ty::PredicateKind::ClosureKind(closure_def_id, substs, kind),\n+                ty::PredicateKind::ClosureKind(closure_def_id, substs, kind)\n+                    .to_predicate(self.tcx()),\n             ));\n         }\n "}, {"sha": "1d89ba4efe0ac2780d90103faf6f332272f8fb55", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -72,7 +72,7 @@ pub fn predicate_obligations<'a, 'tcx>(\n     let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item: None };\n \n     // (*) ok to skip binders, because wf code is prepared for it\n-    match *predicate {\n+    match predicate.kind() {\n         ty::PredicateKind::Trait(ref t, _) => {\n             wf.compute_trait_ref(&t.skip_binder().trait_ref, Elaborate::None); // (*)\n         }\n@@ -102,7 +102,7 @@ pub fn predicate_obligations<'a, 'tcx>(\n                 wf.compute(ty);\n             }\n         }\n-        ty::Predicate::ConstEquate(c1, c2) => {\n+        ty::PredicateKind::ConstEquate(c1, c2) => {\n             wf.compute(c1.ty);\n             wf.compute(c2.ty);\n         }\n@@ -170,7 +170,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n             hir::ImplItemKind::Const(ty, _) | hir::ImplItemKind::TyAlias(ty) => ty.span,\n             _ => impl_item_ref.span,\n         };\n-    match pred {\n+    match pred.kind() {\n         ty::PredicateKind::Projection(proj) => {\n             // The obligation comes not from the current `impl` nor the `trait` being\n             // implemented, but rather from a \"second order\" obligation, like in\n@@ -216,6 +216,10 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n }\n \n impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n     fn cause(&mut self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n         traits::ObligationCause::new(self.span, self.body_id, code)\n     }\n@@ -275,9 +279,14 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n             self.out.extend(obligations);\n         }\n \n+        let tcx = self.tcx();\n         self.out.extend(trait_ref.substs.types().filter(|ty| !ty.has_escaping_bound_vars()).map(\n             |ty| {\n-                traits::Obligation::new(cause.clone(), param_env, ty::PredicateKind::WellFormed(ty))\n+                traits::Obligation::new(\n+                    cause.clone(),\n+                    param_env,\n+                    ty::PredicateKind::WellFormed(ty).to_predicate(tcx),\n+                )\n             },\n         ));\n     }\n@@ -307,7 +316,8 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n             let obligations = self.nominal_obligations(def_id, substs);\n             self.out.extend(obligations);\n \n-            let predicate = ty::PredicateKind::ConstEvaluatable(def_id, substs);\n+            let predicate =\n+                ty::PredicateKind::ConstEvaluatable(def_id, substs).to_predicate(self.tcx());\n             let cause = self.cause(traits::MiscObligation);\n             self.out.push(traits::Obligation::new(cause, self.param_env, predicate));\n         }\n@@ -415,7 +425,8 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                             param_env,\n                             ty::PredicateKind::TypeOutlives(ty::Binder::dummy(\n                                 ty::OutlivesPredicate(rty, r),\n-                            )),\n+                            ))\n+                            .to_predicate(self.tcx()),\n                         ));\n                     }\n                 }\n@@ -495,16 +506,17 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     // obligations that don't refer to Self and\n                     // checking those\n \n-                    let defer_to_coercion = self.infcx.tcx.features().object_safe_for_dispatch;\n+                    let defer_to_coercion = self.tcx().features().object_safe_for_dispatch;\n \n                     if !defer_to_coercion {\n                         let cause = self.cause(traits::MiscObligation);\n                         let component_traits = data.auto_traits().chain(data.principal_def_id());\n+                        let tcx = self.tcx();\n                         self.out.extend(component_traits.map(|did| {\n                             traits::Obligation::new(\n                                 cause.clone(),\n                                 param_env,\n-                                ty::PredicateKind::ObjectSafe(did),\n+                                ty::PredicateKind::ObjectSafe(did).to_predicate(tcx),\n                             )\n                         }));\n                     }\n@@ -530,7 +542,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         self.out.push(traits::Obligation::new(\n                             cause,\n                             param_env,\n-                            ty::PredicateKind::WellFormed(ty),\n+                            ty::PredicateKind::WellFormed(ty).to_predicate(self.tcx()),\n                         ));\n                     } else {\n                         // Yes, resolved, proceed with the result."}, {"sha": "7d48b4575381054392e7adf24a230b038509d6a2", "filename": "src/librustc_traits/chalk/lowering.rs", "status": "modified", "additions": 39, "deletions": 36, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Flowering.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -38,8 +38,7 @@ use rustc_middle::traits::{\n use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n use rustc_middle::ty::{\n-    self, Binder, BoundRegion, Predicate, Region, RegionKind, Ty, TyCtxt, TyKind, TypeFoldable,\n-    TypeVisitor,\n+    self, Binder, BoundRegion, Region, RegionKind, Ty, TyCtxt, TyKind, TypeFoldable, TypeVisitor,\n };\n use rustc_span::def_id::DefId;\n \n@@ -78,8 +77,8 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n     ) -> chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'tcx>>> {\n         let clauses = self.environment.into_iter().filter_map(|clause| match clause {\n             ChalkEnvironmentClause::Predicate(predicate) => {\n-                match predicate {\n-                    ty::Predicate::Trait(predicate, _) => {\n+                match &predicate.kind() {\n+                    ty::PredicateKind::Trait(predicate, _) => {\n                         let (predicate, binders, _named_regions) =\n                             collect_bound_vars(interner, interner.tcx, predicate);\n \n@@ -100,9 +99,9 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                         )\n                     }\n                     // FIXME(chalk): need to add RegionOutlives/TypeOutlives\n-                    ty::Predicate::RegionOutlives(_) => None,\n-                    ty::Predicate::TypeOutlives(_) => None,\n-                    ty::Predicate::Projection(predicate) => {\n+                    ty::PredicateKind::RegionOutlives(_) => None,\n+                    ty::PredicateKind::TypeOutlives(_) => None,\n+                    ty::PredicateKind::Projection(predicate) => {\n                         let (predicate, binders, _named_regions) =\n                             collect_bound_vars(interner, interner.tcx, predicate);\n \n@@ -122,12 +121,14 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                             .intern(interner),\n                         )\n                     }\n-                    ty::Predicate::WellFormed(..)\n-                    | ty::Predicate::ObjectSafe(..)\n-                    | ty::Predicate::ClosureKind(..)\n-                    | ty::Predicate::Subtype(..)\n-                    | ty::Predicate::ConstEvaluatable(..)\n-                    | ty::Predicate::ConstEquate(..) => bug!(\"unexpected predicate {}\", predicate),\n+                    ty::PredicateKind::WellFormed(..)\n+                    | ty::PredicateKind::ObjectSafe(..)\n+                    | ty::PredicateKind::ClosureKind(..)\n+                    | ty::PredicateKind::Subtype(..)\n+                    | ty::PredicateKind::ConstEvaluatable(..)\n+                    | ty::PredicateKind::ConstEquate(..) => {\n+                        bug!(\"unexpected predicate {}\", predicate)\n+                    }\n                 }\n             }\n             ChalkEnvironmentClause::TypeFromEnv(ty) => Some(\n@@ -154,17 +155,17 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n \n impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predicate<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n-        match self {\n-            Predicate::Trait(predicate, _) => predicate.lower_into(interner),\n+        match self.kind() {\n+            ty::PredicateKind::Trait(predicate, _) => predicate.lower_into(interner),\n             // FIXME(chalk): we need to register constraints.\n-            Predicate::RegionOutlives(_predicate) => {\n+            ty::PredicateKind::RegionOutlives(_predicate) => {\n                 chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n             }\n-            Predicate::TypeOutlives(_predicate) => {\n+            ty::PredicateKind::TypeOutlives(_predicate) => {\n                 chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n             }\n-            Predicate::Projection(predicate) => predicate.lower_into(interner),\n-            Predicate::WellFormed(ty) => match ty.kind {\n+            ty::PredicateKind::Projection(predicate) => predicate.lower_into(interner),\n+            ty::PredicateKind::WellFormed(ty) => match ty.kind {\n                 // These types are always WF.\n                 ty::Str | ty::Placeholder(..) | ty::Error | ty::Never => {\n                     chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n@@ -188,11 +189,13 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             //\n             // We can defer this, but ultimately we'll want to express\n             // some of these in terms of chalk operations.\n-            Predicate::ObjectSafe(..)\n-            | Predicate::ClosureKind(..)\n-            | Predicate::Subtype(..)\n-            | Predicate::ConstEvaluatable(..)\n-            | Predicate::ConstEquate(..) => chalk_ir::GoalData::All(chalk_ir::Goals::new(interner)),\n+            ty::PredicateKind::ObjectSafe(..)\n+            | ty::PredicateKind::ClosureKind(..)\n+            | ty::PredicateKind::Subtype(..)\n+            | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::ConstEquate(..) => {\n+                chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n+            }\n         }\n     }\n }\n@@ -439,8 +442,8 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n-        match &self {\n-            Predicate::Trait(predicate, _) => {\n+        match &self.kind() {\n+            ty::PredicateKind::Trait(predicate, _) => {\n                 let (predicate, binders, _named_regions) =\n                     collect_bound_vars(interner, interner.tcx, predicate);\n \n@@ -449,16 +452,16 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n                     chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)),\n                 ))\n             }\n-            Predicate::RegionOutlives(_predicate) => None,\n-            Predicate::TypeOutlives(_predicate) => None,\n-            Predicate::Projection(_predicate) => None,\n-            Predicate::WellFormed(_ty) => None,\n-\n-            Predicate::ObjectSafe(..)\n-            | Predicate::ClosureKind(..)\n-            | Predicate::Subtype(..)\n-            | Predicate::ConstEvaluatable(..)\n-            | Predicate::ConstEquate(..) => bug!(\"unexpected predicate {}\", &self),\n+            ty::PredicateKind::RegionOutlives(_predicate) => None,\n+            ty::PredicateKind::TypeOutlives(_predicate) => None,\n+            ty::PredicateKind::Projection(_predicate) => None,\n+            ty::PredicateKind::WellFormed(_ty) => None,\n+\n+            ty::PredicateKind::ObjectSafe(..)\n+            | ty::PredicateKind::ClosureKind(..)\n+            | ty::PredicateKind::Subtype(..)\n+            | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::ConstEquate(..) => bug!(\"unexpected predicate {}\", &self),\n         }\n     }\n }"}, {"sha": "5dee71a2338ccec8651df4f8fb90cf49eb4e9368", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -94,7 +94,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n         // region relationships.\n         implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n             assert!(!obligation.has_escaping_bound_vars());\n-            match obligation.predicate {\n+            match obligation.predicate.kind() {\n                 ty::PredicateKind::Trait(..)\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Projection(..)"}, {"sha": "fcb75142269df50250985f933087c3093538a7d7", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -40,7 +40,7 @@ fn normalize_generic_arg_after_erasing_regions<'tcx>(\n }\n \n fn not_outlives_predicate(p: &ty::Predicate<'_>) -> bool {\n-    match p {\n+    match p.kind() {\n         ty::PredicateKind::RegionOutlives(..) | ty::PredicateKind::TypeOutlives(..) => false,\n         ty::PredicateKind::Trait(..)\n         | ty::PredicateKind::Projection(..)"}, {"sha": "2a338383c9a0730d0ab06d8034d1a30a29c66db1", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -7,8 +7,8 @@ use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{GenericArg, Subst, UserSelfTy, UserSubsts};\n use rustc_middle::ty::{\n-    self, FnSig, Lift, ParamEnv, ParamEnvAnd, PolyFnSig, Predicate, Ty, TyCtxt, TypeFoldable,\n-    Variance,\n+    self, FnSig, Lift, ParamEnv, ParamEnvAnd, PolyFnSig, Predicate, ToPredicate, Ty, TyCtxt,\n+    TypeFoldable, Variance,\n };\n use rustc_span::DUMMY_SP;\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n@@ -141,7 +141,9 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n \n             self.relate(self_ty, Variance::Invariant, impl_self_ty)?;\n \n-            self.prove_predicate(ty::PredicateKind::WellFormed(impl_self_ty));\n+            self.prove_predicate(\n+                ty::PredicateKind::WellFormed(impl_self_ty).to_predicate(self.tcx()),\n+            );\n         }\n \n         // In addition to proving the predicates, we have to\n@@ -155,7 +157,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n         // them?  This would only be relevant if some input\n         // type were ill-formed but did not appear in `ty`,\n         // which...could happen with normalization...\n-        self.prove_predicate(ty::PredicateKind::WellFormed(ty));\n+        self.prove_predicate(ty::PredicateKind::WellFormed(ty).to_predicate(self.tcx()));\n         Ok(())\n     }\n }"}, {"sha": "3526a1b59f384322ead5b9be714490a7491c2e55", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -1596,7 +1596,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     \"conv_object_ty_poly_trait_ref: observing object predicate `{:?}`\",\n                     obligation.predicate\n                 );\n-                match obligation.predicate {\n+                match obligation.predicate.kind() {\n                     ty::PredicateKind::Trait(pred, _) => {\n                         associated_types.entry(span).or_default().extend(\n                             tcx.associated_items(pred.def_id())"}, {"sha": "f393121a0adb827775f0268981df9c5f54322b41", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -12,7 +12,7 @@ use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::infer::{InferOk, InferResult};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::InternalSubsts;\n-use rustc_middle::ty::{self, GenericParamDefKind, Ty};\n+use rustc_middle::ty::{self, GenericParamDefKind, ToPredicate, Ty};\n use rustc_span::source_map::Span;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::ArgKind;\n@@ -206,7 +206,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     obligation.predicate\n                 );\n \n-                if let ty::PredicateKind::Projection(ref proj_predicate) = obligation.predicate {\n+                if let ty::PredicateKind::Projection(ref proj_predicate) =\n+                    obligation.predicate.kind()\n+                {\n                     // Given a Projection predicate, we can potentially infer\n                     // the complete signature.\n                     self.deduce_sig_from_projection(Some(obligation.cause.span), proj_predicate)\n@@ -529,7 +531,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ty::PredicateKind::TypeOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n                         supplied_ty,\n                         closure_body_region,\n-                    ))),\n+                    )))\n+                    .to_predicate(self.tcx),\n                 ));\n             }\n \n@@ -641,7 +644,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // where R is the return type we are expecting. This type `T`\n         // will be our output.\n         let output_ty = self.obligations_for_self_ty(ret_vid).find_map(|(_, obligation)| {\n-            if let ty::PredicateKind::Projection(ref proj_predicate) = obligation.predicate {\n+            if let ty::PredicateKind::Projection(ref proj_predicate) = obligation.predicate.kind() {\n                 self.deduce_future_output_from_projection(obligation.cause.span, proj_predicate)\n             } else {\n                 None"}, {"sha": "705bace4a9ccc4dbb9d4b13f00c75c45682d46d2", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -596,7 +596,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         while !queue.is_empty() {\n             let obligation = queue.remove(0);\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n-            let trait_pred = match obligation.predicate {\n+            let trait_pred = match obligation.predicate.kind() {\n                 ty::PredicateKind::Trait(trait_pred, _)\n                     if traits.contains(&trait_pred.def_id()) =>\n                 {"}, {"sha": "fc7a9c1d59b76a4ccfd95d7f7d2cafbb3fdfbfee", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -10,7 +10,7 @@ use rustc_hir as hir;\n use rustc_hir::lang_items::{CloneTraitLangItem, DerefTraitLangItem};\n use rustc_hir::{is_range_literal, Node};\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n-use rustc_middle::ty::{self, AssocItem, Ty, TypeAndMut};\n+use rustc_middle::ty::{self, AssocItem, ToPredicate, Ty, TypeAndMut};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n@@ -654,7 +654,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         },\n                         // `U`\n                         ty: expected,\n-                    }));\n+                    }))\n+                    .to_predicate(self.tcx);\n                 let obligation = traits::Obligation::new(self.misc(sp), self.param_env, predicate);\n                 let impls_deref = self.infcx.predicate_may_hold(&obligation);\n "}, {"sha": "3843b97f23d41b7e779830e592c91584b84d4508", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -230,12 +230,12 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         // could be extended easily also to the other `Predicate`.\n         let predicate_matches_closure = |p: &'_ Predicate<'tcx>| {\n             let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n-            match (predicate, p) {\n+            match (predicate.kind(), p.kind()) {\n                 (ty::PredicateKind::Trait(a, _), ty::PredicateKind::Trait(b, _)) => {\n-                    relator.relate(a, b).is_ok()\n+                    relator.relate(&a, &b).is_ok()\n                 }\n                 (ty::PredicateKind::Projection(a), ty::PredicateKind::Projection(b)) => {\n-                    relator.relate(a, b).is_ok()\n+                    relator.relate(&a, &b).is_ok()\n                 }\n                 _ => predicate == p,\n             }"}, {"sha": "410c5efdf37d4ef0e241ddce6762a64e0a290740", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -574,7 +574,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         };\n \n         traits::elaborate_predicates(self.tcx, predicates.predicates.iter().copied())\n-            .filter_map(|obligation| match obligation.predicate {\n+            .filter_map(|obligation| match obligation.predicate.kind() {\n                 ty::PredicateKind::Trait(trait_pred, _) if trait_pred.def_id() == sized_def_id => {\n                     let span = predicates\n                         .predicates"}, {"sha": "aae02ea0273f9a5b15d89bd15202080b6100df88", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -401,7 +401,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         obligations.push(traits::Obligation::new(\n             cause,\n             self.param_env,\n-            ty::PredicateKind::WellFormed(method_ty),\n+            ty::PredicateKind::WellFormed(method_ty).to_predicate(tcx),\n         ));\n \n         let callee = MethodCallee { def_id, substs: trait_ref.substs, sig: fn_sig };"}, {"sha": "91562d576ea809e3d34598fbe5e4b6f531f6d162", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -796,23 +796,26 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     fn assemble_inherent_candidates_from_param(&mut self, param_ty: ty::ParamTy) {\n         // FIXME: do we want to commit to this behavior for param bounds?\n \n-        let bounds = self.param_env.caller_bounds.iter().filter_map(|predicate| match *predicate {\n-            ty::PredicateKind::Trait(ref trait_predicate, _) => {\n-                match trait_predicate.skip_binder().trait_ref.self_ty().kind {\n-                    ty::Param(ref p) if *p == param_ty => Some(trait_predicate.to_poly_trait_ref()),\n-                    _ => None,\n+        let bounds =\n+            self.param_env.caller_bounds.iter().filter_map(|predicate| match predicate.kind() {\n+                ty::PredicateKind::Trait(ref trait_predicate, _) => {\n+                    match trait_predicate.skip_binder().trait_ref.self_ty().kind {\n+                        ty::Param(ref p) if *p == param_ty => {\n+                            Some(trait_predicate.to_poly_trait_ref())\n+                        }\n+                        _ => None,\n+                    }\n                 }\n-            }\n-            ty::PredicateKind::Subtype(..)\n-            | ty::PredicateKind::Projection(..)\n-            | ty::PredicateKind::RegionOutlives(..)\n-            | ty::PredicateKind::WellFormed(..)\n-            | ty::PredicateKind::ObjectSafe(..)\n-            | ty::PredicateKind::ClosureKind(..)\n-            | ty::PredicateKind::TypeOutlives(..)\n-            | ty::PredicateKind::ConstEvaluatable(..)\n-            | ty::PredicateKind::ConstEquate(..) => None,\n-        });\n+                ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::Projection(..)\n+                | ty::PredicateKind::RegionOutlives(..)\n+                | ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::TypeOutlives(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..) => None,\n+            });\n \n         self.elaborate_bounds(bounds, |this, poly_trait_ref, item| {\n             let trait_ref = this.erase_late_bound_regions(&poly_trait_ref);"}, {"sha": "7ca3eb884d88fc5d82eee63b5099f214946dfa39", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -575,7 +575,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let mut collect_type_param_suggestions =\n                         |self_ty: Ty<'_>, parent_pred: &ty::Predicate<'_>, obligation: &str| {\n                             if let (ty::Param(_), ty::PredicateKind::Trait(p, _)) =\n-                                (&self_ty.kind, parent_pred)\n+                                (&self_ty.kind, parent_pred.kind())\n                             {\n                                 if let ty::Adt(def, _) = p.skip_binder().trait_ref.self_ty().kind {\n                                     let node = def.did.as_local().map(|def_id| {\n@@ -626,8 +626,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             _ => {}\n                         }\n                     };\n-                    let mut format_pred = |pred| {\n-                        match pred {\n+                    let mut format_pred = |pred: ty::Predicate<'tcx>| {\n+                        match pred.kind() {\n                             ty::PredicateKind::Projection(pred) => {\n                                 // `<Foo as Iterator>::Item = String`.\n                                 let trait_ref =\n@@ -946,7 +946,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // this isn't perfect (that is, there are cases when\n                 // implementing a trait would be legal but is rejected\n                 // here).\n-                unsatisfied_predicates.iter().all(|(p, _)| match p {\n+                unsatisfied_predicates.iter().all(|(p, _)| match p.kind() {\n                     // Hide traits if they are present in predicates as they can be fixed without\n                     // having to implement them.\n                     ty::PredicateKind::Trait(t, _) => t.def_id() == info.def_id,"}, {"sha": "c452859414cfbdfbfd6e728f606c498c673af675", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -2223,7 +2223,7 @@ fn bounds_from_generic_predicates(\n     let mut projections = vec![];\n     for (predicate, _) in predicates.predicates {\n         debug!(\"predicate {:?}\", predicate);\n-        match predicate {\n+        match predicate.kind() {\n             ty::PredicateKind::Trait(trait_predicate, _) => {\n                 let entry = types.entry(trait_predicate.skip_binder().self_ty()).or_default();\n                 let def_id = trait_predicate.skip_binder().def_id();\n@@ -2769,7 +2769,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         ty::GenericPredicates {\n             parent: None,\n             predicates: tcx.arena.alloc_from_iter(self.param_env.caller_bounds.iter().filter_map(\n-                |&predicate| match predicate {\n+                |&predicate| match predicate.kind() {\n                     ty::PredicateKind::Trait(ref data, _)\n                         if data.skip_binder().self_ty().is_param(index) =>\n                     {\n@@ -3379,7 +3379,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.register_predicate(traits::Obligation::new(\n                 cause,\n                 self.param_env,\n-                ty::PredicateKind::ConstEvaluatable(def_id, substs),\n+                ty::PredicateKind::ConstEvaluatable(def_id, substs).to_predicate(self.tcx),\n             ));\n         }\n \n@@ -3428,7 +3428,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.register_predicate(traits::Obligation::new(\n             cause,\n             self.param_env,\n-            ty::PredicateKind::WellFormed(ty),\n+            ty::PredicateKind::WellFormed(ty).to_predicate(self.tcx),\n         ));\n     }\n \n@@ -3857,7 +3857,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .borrow()\n             .pending_obligations()\n             .into_iter()\n-            .filter_map(move |obligation| match obligation.predicate {\n+            .filter_map(move |obligation| match obligation.predicate.kind() {\n                 ty::PredicateKind::Projection(ref data) => {\n                     Some((data.to_poly_trait_ref(self.tcx), obligation))\n                 }\n@@ -4208,7 +4208,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 continue;\n             }\n \n-            if let ty::PredicateKind::Trait(predicate, _) = error.obligation.predicate {\n+            if let ty::PredicateKind::Trait(predicate, _) = error.obligation.predicate.kind() {\n                 // Collect the argument position for all arguments that could have caused this\n                 // `FulfillmentError`.\n                 let mut referenced_in = final_arg_types\n@@ -4255,7 +4255,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let hir::ExprKind::Path(qpath) = &path.kind {\n                 if let hir::QPath::Resolved(_, path) = &qpath {\n                     for error in errors {\n-                        if let ty::PredicateKind::Trait(predicate, _) = error.obligation.predicate {\n+                        if let ty::PredicateKind::Trait(predicate, _) =\n+                            error.obligation.predicate.kind()\n+                        {\n                             // If any of the type arguments in this path segment caused the\n                             // `FullfillmentError`, point at its span (#61860).\n                             for arg in path\n@@ -5327,7 +5329,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ty::PredicateKind::Projection(ty::Binder::bind(ty::ProjectionPredicate {\n                         projection_ty,\n                         ty: expected,\n-                    }));\n+                    }))\n+                    .to_predicate(self.tcx);\n                 let obligation = traits::Obligation::new(self.misc(sp), self.param_env, predicate);\n \n                 debug!(\"suggest_missing_await: trying obligation {:?}\", obligation);"}, {"sha": "d5db613d9dcad33b03713fcf3d52bda98c4945db", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -425,7 +425,8 @@ fn check_type_defn<'tcx, F>(\n                 fcx.register_predicate(traits::Obligation::new(\n                     cause,\n                     fcx.param_env,\n-                    ty::PredicateKind::ConstEvaluatable(discr_def_id.to_def_id(), discr_substs),\n+                    ty::PredicateKind::ConstEvaluatable(discr_def_id.to_def_id(), discr_substs)\n+                        .to_predicate(fcx.tcx),\n                 ));\n             }\n         }"}, {"sha": "fa4c9edcd218dec27b5498811a3a98ca893a6f3f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -548,7 +548,7 @@ fn type_param_predicates(\n     let extra_predicates = extend.into_iter().chain(\n         icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty, OnlySelfBounds(true))\n             .into_iter()\n-            .filter(|(predicate, _)| match predicate {\n+            .filter(|(predicate, _)| match predicate.kind() {\n                 ty::PredicateKind::Trait(ref data, _) => {\n                     data.skip_binder().self_ty().is_param(index)\n                 }\n@@ -996,7 +996,7 @@ fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredi\n     // which will, in turn, reach indirect supertraits.\n     for &(pred, span) in superbounds {\n         debug!(\"superbound: {:?}\", pred);\n-        if let ty::PredicateKind::Trait(bound, _) = pred {\n+        if let ty::PredicateKind::Trait(bound, _) = pred.kind() {\n             tcx.at(span).super_predicates_of(bound.def_id());\n         }\n     }\n@@ -1901,7 +1901,8 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                         let re_root_empty = tcx.lifetimes.re_root_empty;\n                         let predicate = ty::OutlivesPredicate(ty, re_root_empty);\n                         predicates.push((\n-                            ty::PredicateKind::TypeOutlives(ty::Binder::dummy(predicate)),\n+                            ty::PredicateKind::TypeOutlives(ty::Binder::dummy(predicate))\n+                                .to_predicate(tcx),\n                             span,\n                         ));\n                     }\n@@ -1930,7 +1931,10 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                         &hir::GenericBound::Outlives(ref lifetime) => {\n                             let region = AstConv::ast_region_to_region(&icx, lifetime, None);\n                             let pred = ty::Binder::bind(ty::OutlivesPredicate(ty, region));\n-                            predicates.push((ty::PredicateKind::TypeOutlives(pred), lifetime.span))\n+                            predicates.push((\n+                                ty::PredicateKind::TypeOutlives(pred).to_predicate(tcx),\n+                                lifetime.span,\n+                            ))\n                         }\n                     }\n                 }\n@@ -1947,7 +1951,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                     };\n                     let pred = ty::Binder::bind(ty::OutlivesPredicate(r1, r2));\n \n-                    (ty::PredicateKind::RegionOutlives(pred), span)\n+                    (ty::PredicateKind::RegionOutlives(pred).to_predicate(icx.tcx), span)\n                 }))\n             }\n \n@@ -2118,7 +2122,7 @@ fn predicates_from_bound<'tcx>(\n         hir::GenericBound::Outlives(ref lifetime) => {\n             let region = astconv.ast_region_to_region(lifetime, None);\n             let pred = ty::Binder::bind(ty::OutlivesPredicate(param_ty, region));\n-            vec![(ty::PredicateKind::TypeOutlives(pred), lifetime.span)]\n+            vec![(ty::PredicateKind::TypeOutlives(pred).to_predicate(astconv.tcx()), lifetime.span)]\n         }\n     }\n }"}, {"sha": "34497d12a4ecefec6a8608f34ce5efa9d41286ad", "filename": "src/librustc_typeck/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -180,7 +180,7 @@ pub fn setup_constraining_predicates<'tcx>(\n         changed = false;\n \n         for j in i..predicates.len() {\n-            if let ty::PredicateKind::Projection(ref poly_projection) = predicates[j].0 {\n+            if let ty::PredicateKind::Projection(ref poly_projection) = predicates[j].0.kind() {\n                 // Note that we can skip binder here because the impl\n                 // trait ref never contains any late-bound regions.\n                 let projection = poly_projection.skip_binder();"}, {"sha": "d30dc1b7a475e4aac235c99c62eb65e95ab1e05e", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -204,7 +204,7 @@ fn unconstrained_parent_impl_substs<'tcx>(\n     // the functions in `cgp` add the constrained parameters to a list of\n     // unconstrained parameters.\n     for (predicate, _) in impl_generic_predicates.predicates.iter() {\n-        if let ty::PredicateKind::Projection(proj) = predicate {\n+        if let ty::PredicateKind::Projection(proj) = predicate.kind() {\n             let projection_ty = proj.skip_binder().projection_ty;\n             let projected_ty = proj.skip_binder().ty;\n \n@@ -368,7 +368,7 @@ fn check_predicates<'tcx>(\n \n fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: &ty::Predicate<'tcx>, span: Span) {\n     debug!(\"can_specialize_on(predicate = {:?})\", predicate);\n-    match predicate {\n+    match predicate.kind() {\n         // Global predicates are either always true or always false, so we\n         // are fine to specialize on.\n         _ if predicate.is_global() => (),\n@@ -401,7 +401,7 @@ fn trait_predicate_kind<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     predicate: &ty::Predicate<'tcx>,\n ) -> Option<TraitSpecializationKind> {\n-    match predicate {\n+    match predicate.kind() {\n         ty::PredicateKind::Trait(pred, hir::Constness::NotConst) => {\n             Some(tcx.trait_def(pred.def_id()).specialization_kind)\n         }"}, {"sha": "5740cc224cc572f7615f73845839d82c9cf396ab", "filename": "src/librustc_typeck/outlives/explicit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -29,7 +29,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n \n             // process predicates and convert to `RequiredPredicates` entry, see below\n             for &(predicate, span) in predicates.predicates {\n-                match predicate {\n+                match predicate.kind() {\n                     ty::PredicateKind::TypeOutlives(predicate) => {\n                         let OutlivesPredicate(ref ty, ref reg) = predicate.skip_binder();\n                         insert_outlives_predicate("}, {"sha": "1b2b08a2e62eec6a7351469069bfa92eb2a2bf26", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -3,7 +3,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, CratePredicatesMap, TyCtxt};\n+use rustc_middle::ty::{self, CratePredicatesMap, ToPredicate, TyCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n@@ -30,7 +30,7 @@ fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate\n                 if tcx.has_attr(item_def_id, sym::rustc_outlives) {\n                     let mut pred: Vec<String> = predicates\n                         .iter()\n-                        .map(|(out_pred, _)| match out_pred {\n+                        .map(|(out_pred, _)| match out_pred.kind() {\n                             ty::PredicateKind::RegionOutlives(p) => p.to_string(),\n                             ty::PredicateKind::TypeOutlives(p) => p.to_string(),\n                             err => bug!(\"unexpected predicate {:?}\", err),\n@@ -82,22 +82,26 @@ fn inferred_outlives_crate(tcx: TyCtxt<'_>, crate_num: CrateNum) -> CratePredica\n         .iter()\n         .map(|(&def_id, set)| {\n             let predicates = &*tcx.arena.alloc_from_iter(set.iter().filter_map(\n-                |(ty::OutlivesPredicate(kind1, region2), &span)| match kind1.unpack() {\n-                    GenericArgKind::Type(ty1) => Some((\n-                        ty::PredicateKind::TypeOutlives(ty::Binder::bind(ty::OutlivesPredicate(\n-                            ty1, region2,\n-                        ))),\n-                        span,\n-                    )),\n-                    GenericArgKind::Lifetime(region1) => Some((\n-                        ty::PredicateKind::RegionOutlives(ty::Binder::bind(ty::OutlivesPredicate(\n-                            region1, region2,\n-                        ))),\n-                        span,\n-                    )),\n-                    GenericArgKind::Const(_) => {\n-                        // Generic consts don't impose any constraints.\n-                        None\n+                |(ty::OutlivesPredicate(kind1, region2), &span)| {\n+                    match kind1.unpack() {\n+                        GenericArgKind::Type(ty1) => Some((\n+                            ty::PredicateKind::TypeOutlives(ty::Binder::bind(\n+                                ty::OutlivesPredicate(ty1, region2),\n+                            ))\n+                            .to_predicate(tcx),\n+                            span,\n+                        )),\n+                        GenericArgKind::Lifetime(region1) => Some((\n+                            ty::PredicateKind::RegionOutlives(ty::Binder::bind(\n+                                ty::OutlivesPredicate(region1, region2),\n+                            ))\n+                            .to_predicate(tcx),\n+                            span,\n+                        )),\n+                        GenericArgKind::Const(_) => {\n+                            // Generic consts don't impose any constraints.\n+                            None\n+                        }\n                     }\n                 },\n             ));"}, {"sha": "423160f3a9e01eea1ee1bbb54980e90e696ac0d9", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -315,7 +315,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n         pred: ty::Predicate<'tcx>,\n     ) -> FxHashSet<GenericParamDef> {\n-        let regions = match pred {\n+        let regions = match pred.kind() {\n             ty::PredicateKind::Trait(poly_trait_pred, _) => {\n                 tcx.collect_referenced_late_bound_regions(&poly_trait_pred)\n             }\n@@ -465,7 +465,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             .iter()\n             .filter(|p| {\n                 !orig_bounds.contains(p)\n-                    || match p {\n+                    || match p.kind() {\n                         ty::PredicateKind::Trait(pred, _) => pred.def_id() == sized_trait,\n                         _ => false,\n                     }"}, {"sha": "cf1a39232bc787b98ab119cc96251a3ba30847c7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -481,7 +481,7 @@ impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n \n impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n     fn clean(&self, cx: &DocContext<'_>) -> Option<WherePredicate> {\n-        match *self {\n+        match self.kind() {\n             ty::PredicateKind::Trait(ref pred, _) => Some(pred.clean(cx)),\n             ty::PredicateKind::Subtype(ref pred) => Some(pred.clean(cx)),\n             ty::PredicateKind::RegionOutlives(ref pred) => pred.clean(cx),\n@@ -763,7 +763,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n                         if let ty::Param(param) = outlives.skip_binder().0.kind {\n                             return Some(param.index);\n                         }\n-                    } else if let ty::PredicateKind::Projection(p) = p {\n+                    } else if let ty::PredicateKind::Projection(p) = p.kind() {\n                         if let ty::Param(param) = p.skip_binder().projection_ty.self_ty().kind {\n                             projection = Some(p);\n                             return Some(param.index);\n@@ -1661,7 +1661,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     .filter_map(|predicate| {\n                         let trait_ref = if let Some(tr) = predicate.to_opt_poly_trait_ref() {\n                             tr\n-                        } else if let ty::PredicateKind::TypeOutlives(pred) = *predicate {\n+                        } else if let ty::PredicateKind::TypeOutlives(pred) = predicate.kind() {\n                             // these should turn up at the end\n                             if let Some(r) = pred.skip_binder().1.clean(cx) {\n                                 regions.push(GenericBound::Outlives(r));\n@@ -1682,7 +1682,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                             .predicates\n                             .iter()\n                             .filter_map(|pred| {\n-                                if let ty::PredicateKind::Projection(proj) = *pred {\n+                                if let ty::PredicateKind::Projection(proj) = pred.kind() {\n                                     let proj = proj.skip_binder();\n                                     if proj.projection_ty.trait_ref(cx.tcx)\n                                         == *trait_ref.skip_binder()"}, {"sha": "37c613f41224aad0900bff5ca30fcaeee12e47d8", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -141,7 +141,7 @@ fn trait_is_same_or_supertrait(cx: &DocContext<'_>, child: DefId, trait_: DefId)\n         .predicates\n         .iter()\n         .filter_map(|(pred, _)| {\n-            if let ty::PredicateKind::Trait(ref pred, _) = *pred {\n+            if let ty::PredicateKind::Trait(ref pred, _) = pred.kind() {\n                 if pred.skip_binder().trait_ref.self_ty() == self_ty {\n                     Some(pred.def_id())\n                 } else {"}, {"sha": "0a02aa7533c176e4ebd13ec012f192e379a599f0", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -91,7 +91,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FutureNotSend {\n                             cx.tcx.infer_ctxt().enter(|infcx| {\n                                 for FulfillmentError { obligation, .. } in send_errors {\n                                     infcx.maybe_note_obligation_cause_for_async_await(db, &obligation);\n-                                    if let Trait(trait_pred, _) = obligation.predicate {\n+                                    if let Trait(trait_pred, _) = obligation.predicate.kind() {\n                                         let trait_ref = trait_pred.to_poly_trait_ref();\n                                         db.note(&*format!(\n                                             \"`{}` doesn't implement `{}`\","}, {"sha": "810a226b50d2a1e454834042404d54efce7a7639", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -1496,8 +1496,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n             if let ty::Opaque(def_id, _) = ret_ty.kind {\n                 // one of the associated types must be Self\n                 for predicate in cx.tcx.predicates_of(def_id).predicates {\n-                    match predicate {\n-                        (ty::PredicateKind::Projection(poly_projection_predicate), _) => {\n+                    match predicate.0.kind() {\n+                        ty::PredicateKind::Projection(poly_projection_predicate) => {\n                             let binder = poly_projection_predicate.ty();\n                             let associated_type = binder.skip_binder();\n \n@@ -1506,7 +1506,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n                                 return;\n                             }\n                         },\n-                        (_, _) => {},\n+                        _ => {},\n                     }\n                 }\n             }"}, {"sha": "60c5360054334123628cb87edd9c14ec74b60000", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         let preds = traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds.iter().copied())\n             .filter(|p| !p.is_global())\n             .filter_map(|obligation| {\n-                if let ty::PredicateKind::Trait(poly_trait_ref, _) = obligation.predicate {\n+                if let ty::PredicateKind::Trait(poly_trait_ref, _) = obligation.predicate.kind() {\n                     if poly_trait_ref.def_id() == sized_trait || poly_trait_ref.skip_binder().has_escaping_bound_vars()\n                     {\n                         return None;"}, {"sha": "f22473275c466ea3bb020f3dac3c123150e9ac6b", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3164790bdea9ae4f23631f78a4c52dc1b3bdf06/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=f3164790bdea9ae4f23631f78a4c52dc1b3bdf06", "patch": "@@ -1299,7 +1299,7 @@ pub fn is_must_use_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> boo\n         ty::Tuple(ref substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n         ty::Opaque(ref def_id, _) => {\n             for (predicate, _) in cx.tcx.predicates_of(*def_id).predicates {\n-                if let ty::PredicateKind::Trait(ref poly_trait_predicate, _) = predicate {\n+                if let ty::PredicateKind::Trait(ref poly_trait_predicate, _) = predicate.kind() {\n                     if must_use_attr(&cx.tcx.get_attrs(poly_trait_predicate.skip_binder().trait_ref.def_id)).is_some() {\n                         return true;\n                     }"}]}