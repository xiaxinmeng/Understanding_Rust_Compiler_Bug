{"sha": "fb93f10dac46376b706643a74f3ebbabaf46c48f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiOTNmMTBkYWM0NjM3NmI3MDY2NDNhNzRmM2ViYmFiYWY0NmM0OGY=", "commit": {"author": {"name": "Saleem Jaffer", "email": "saleem@acko.com", "date": "2019-03-24T03:29:11Z"}, "committer": {"name": "Saleem Jaffer", "email": "saleem@acko.com", "date": "2019-03-24T03:29:11Z"}, "message": "code review fixes", "tree": {"sha": "e1185150c3e7ec53c88b8e5a416642d0177b7561", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1185150c3e7ec53c88b8e5a416642d0177b7561"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb93f10dac46376b706643a74f3ebbabaf46c48f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb93f10dac46376b706643a74f3ebbabaf46c48f", "html_url": "https://github.com/rust-lang/rust/commit/fb93f10dac46376b706643a74f3ebbabaf46c48f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb93f10dac46376b706643a74f3ebbabaf46c48f/comments", "author": null, "committer": null, "parents": [{"sha": "752544b28411540d7beb6fe4d1e2f1d8c775e05b", "url": "https://api.github.com/repos/rust-lang/rust/commits/752544b28411540d7beb6fe4d1e2f1d8c775e05b", "html_url": "https://github.com/rust-lang/rust/commit/752544b28411540d7beb6fe4d1e2f1d8c775e05b"}], "stats": {"total": 196, "additions": 81, "deletions": 115}, "files": [{"sha": "54e5bfc4397e8be33144ebceb7d3235c55b30ae1", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb93f10dac46376b706643a74f3ebbabaf46c48f/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb93f10dac46376b706643a74f3ebbabaf46c48f/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=fb93f10dac46376b706643a74f3ebbabaf46c48f", "patch": "@@ -725,17 +725,14 @@ macro_rules! make_mir_visitor {\n                             place: & $($mutability)? Place<'tcx>,\n                             context: PlaceContext<'tcx>,\n                             location: Location) {\n-                use crate::mir::{Static, StaticKind};\n                 match place {\n                     Place::Base(PlaceBase::Local(local)) => {\n                         self.visit_local(local, context, location);\n                     }\n-                    Place::Base(\n-                        PlaceBase::Static(box Static{kind: StaticKind::Static(def_id), ..})\n-                    ) => {\n-                        self.visit_def_id(& $($mutability)? *def_id, location)\n-                    }\n-                    Place::Base(PlaceBase::Static(box Static{ty, ..})) => {\n+                    Place::Base(PlaceBase::Static(box Static { kind, ty })) => {\n+                        if let StaticKind::Static(def_id) = kind {\n+                            self.visit_def_id(& $($mutability)? *def_id, location)\n+                        }\n                         self.visit_ty(& $($mutability)? *ty, TyContext::Location(location));\n                     }\n                     Place::Projection(proj) => {"}, {"sha": "a3909486610e0c12337516ce57e3d1f4d85eb5b6", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb93f10dac46376b706643a74f3ebbabaf46c48f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb93f10dac46376b706643a74f3ebbabaf46c48f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=fb93f10dac46376b706643a74f3ebbabaf46c48f", "patch": "@@ -1313,7 +1313,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) => {\n                 (true, false)\n             }\n-            Place::Base(PlaceBase::Static(box Static{ kind: _, .. })) => {\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(_), .. })) => {\n                 // Thread-locals might be dropped after the function exits, but\n                 // \"true\" statics will never be.\n                 (true, self.is_place_thread_local(&root_place))"}, {"sha": "aab650383cfecff1f00cfc75ad85e8919931922d", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 34, "deletions": 42, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/fb93f10dac46376b706643a74f3ebbabaf46c48f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb93f10dac46376b706643a74f3ebbabaf46c48f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=fb93f10dac46376b706643a74f3ebbabaf46c48f", "patch": "@@ -449,57 +449,49 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         context: PlaceContext<'_>,\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_place: {:?}\", place);\n-        let place_ty = match *place {\n+        let place_ty = match place {\n             Place::Base(PlaceBase::Local(index)) => PlaceTy::Ty {\n-                ty: self.mir.local_decls[index].ty,\n+                ty: self.mir.local_decls[*index].ty,\n             },\n-            Place::Base(\n-                PlaceBase::Static(box Static { kind: StaticKind::Promoted(promoted), ty: sty })\n-            ) => {\n+            Place::Base(PlaceBase::Static(box Static { kind, ty: sty })) => {\n                 let sty = self.sanitize_type(place, sty);\n-\n-                if !self.errors_reported {\n-                    let promoted_mir = &self.mir.promoted[promoted];\n-                    self.sanitize_promoted(promoted_mir, location);\n-\n-                    let promoted_ty = promoted_mir.return_ty();\n-\n-                    if let Err(terr) = self.cx.eq_types(\n-                        sty,\n-                        promoted_ty,\n-                        location.to_locations(),\n-                        ConstraintCategory::Boring,\n-                    ) {\n-                        span_mirbug!(\n-                            self,\n+                let check_err =\n+                    |verifier: &mut TypeVerifier<'a, 'b, 'gcx, 'tcx>,\n+                     place: &Place<'tcx>,\n+                     ty,\n+                     sty| {\n+                        if let Err(terr) = verifier.cx.eq_types(\n+                            sty,\n+                            ty,\n+                            location.to_locations(),\n+                            ConstraintCategory::Boring,\n+                        ) {\n+                            span_mirbug!(\n+                            verifier,\n                             place,\n                             \"bad promoted type ({:?}: {:?}): {:?}\",\n-                            promoted_ty,\n+                            ty,\n                             sty,\n                             terr\n                         );\n+                        };\n                     };\n-                }\n-                PlaceTy::Ty { ty: sty }\n-            }\n-            Place::Base(\n-                PlaceBase::Static(box Static { kind: StaticKind::Static(def_id), ty: sty })\n-            ) => {\n-                let sty = self.sanitize_type(place, sty);\n-                let ty = self.tcx().type_of(def_id);\n-                let ty = self.cx.normalize(ty, location);\n-                if let Err(terr) =\n-                    self.cx\n-                        .eq_types(ty, sty, location.to_locations(), ConstraintCategory::Boring)\n-                {\n-                    span_mirbug!(\n-                        self,\n-                        place,\n-                        \"bad static type ({:?}: {:?}): {:?}\",\n-                        ty,\n-                        sty,\n-                        terr\n-                    );\n+                match kind {\n+                    StaticKind::Promoted(promoted) => {\n+                        if !self.errors_reported {\n+                            let promoted_mir = &self.mir.promoted[*promoted];\n+                            self.sanitize_promoted(promoted_mir, location);\n+\n+                            let promoted_ty = promoted_mir.return_ty();\n+                            check_err(self, place, promoted_ty, sty);\n+                        }\n+                    }\n+                    StaticKind::Static(def_id) => {\n+                        let ty = self.tcx().type_of(*def_id);\n+                        let ty = self.cx.normalize(ty, location);\n+\n+                        check_err(self, place, ty, sty);\n+                    }\n                 }\n                 PlaceTy::Ty { ty: sty }\n             }"}, {"sha": "52119d6b19bc06d5d4dc48cd8f1cf814de9b2548", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 38, "deletions": 62, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/fb93f10dac46376b706643a74f3ebbabaf46c48f/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb93f10dac46376b706643a74f3ebbabaf46c48f/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=fb93f10dac46376b706643a74f3ebbabaf46c48f", "patch": "@@ -2,7 +2,7 @@ use crate::borrow_check::ArtificialField;\n use crate::borrow_check::Overlap;\n use crate::borrow_check::{Deep, Shallow, AccessDepth};\n use rustc::hir;\n-use rustc::mir::{BorrowKind, Mir, Place, PlaceBase, Projection, ProjectionElem, Static, StaticKind};\n+use rustc::mir::{BorrowKind, Mir, Place, PlaceBase, Projection, ProjectionElem, StaticKind};\n use rustc::ty::{self, TyCtxt};\n use std::cmp::max;\n \n@@ -370,71 +370,47 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                 Overlap::Disjoint\n             }\n         }\n-        (\n-            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Static(def_id_1), .. })),\n-            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Static(def_id_2), .. })),\n-        ) => {\n-            if *def_id_1 != *def_id_2 {\n-                debug!(\"place_element_conflict: DISJOINT-STATIC\");\n-                Overlap::Disjoint\n-            } else if tcx.is_static(*def_id_1) == Some(hir::Mutability::MutMutable) {\n-                // We ignore mutable statics - they can only be unsafe code.\n-                debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n-                Overlap::Disjoint\n-            } else {\n-                debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n-                Overlap::EqualOrDisjoint\n-            }\n-        }\n-        (\n-            Place::Base(\n-                PlaceBase::Static(box Static { kind: StaticKind::Promoted(promoted_1), ty })\n-            ),\n-            Place::Base(\n-                PlaceBase::Static(box Static { kind: StaticKind::Promoted(promoted_2), .. })\n-            ),\n-        ) => {\n-            if *promoted_1 == *promoted_2 {\n-                if let ty::Array(_, size) = ty.sty {\n-                    if size.unwrap_usize(tcx) == 0 {\n-                        // Ignore conflicts with promoted [T; 0].\n-                        debug!(\"place_element_conflict: IGNORE-LEN-0-PROMOTED\");\n-                        return Overlap::Disjoint;\n+        (Place::Base(PlaceBase::Static(s1)), Place::Base(PlaceBase::Static(s2))) => {\n+            match (&s1.kind, &s2.kind) {\n+                (StaticKind::Static(def_id_1), StaticKind::Static(def_id_2)) => {\n+                    if def_id_1 != def_id_2 {\n+                        debug!(\"place_element_conflict: DISJOINT-STATIC\");\n+                        Overlap::Disjoint\n+                    } else if tcx.is_static(*def_id_1) == Some(hir::Mutability::MutMutable) {\n+                        // We ignore mutable statics - they can only be unsafe code.\n+                        debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n+                        Overlap::Disjoint\n+                    } else {\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n+                        Overlap::EqualOrDisjoint\n                     }\n+                },\n+                (StaticKind::Promoted(promoted_1), StaticKind::Promoted(promoted_2)) => {\n+                    if promoted_1 == promoted_2 {\n+                        if let ty::Array(_, size) = s1.ty.sty {\n+                            if size.unwrap_usize(tcx) == 0 {\n+                                // Ignore conflicts with promoted [T; 0].\n+                                debug!(\"place_element_conflict: IGNORE-LEN-0-PROMOTED\");\n+                                return Overlap::Disjoint;\n+                            }\n+                        }\n+                        // the same promoted - base case, equal\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-PROMOTED\");\n+                        Overlap::EqualOrDisjoint\n+                    } else {\n+                        // different promoteds - base case, disjoint\n+                        debug!(\"place_element_conflict: DISJOINT-PROMOTED\");\n+                        Overlap::Disjoint\n+                    }\n+                },\n+                (_, _) => {\n+                    debug!(\"place_element_conflict: DISJOINT-STATIC-PROMOTED\");\n+                    Overlap::Disjoint\n                 }\n-                // the same promoted - base case, equal\n-                debug!(\"place_element_conflict: DISJOINT-OR-EQ-PROMOTED\");\n-                Overlap::EqualOrDisjoint\n-            } else {\n-                // different promoteds - base case, disjoint\n-                debug!(\"place_element_conflict: DISJOINT-PROMOTED\");\n-                Overlap::Disjoint\n             }\n         }\n-        (\n-            Place::Base(PlaceBase::Local(_)),\n-            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. }))\n-        ) |\n-        (\n-            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. })),\n-            Place::Base(PlaceBase::Local(_))\n-        ) |\n-        (\n-            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. })),\n-            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Static(_), .. }))\n-        ) |\n-        (\n-            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Static(_), .. })),\n-            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. }))\n-        ) |\n-        (\n-            Place::Base(PlaceBase::Local(_)),\n-            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Static(_), .. }))\n-        ) |\n-        (\n-            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Static(_), .. })),\n-            Place::Base(PlaceBase::Local(_))\n-        ) => {\n+        (Place::Base(PlaceBase::Local(_)), Place::Base(PlaceBase::Static(_))) |\n+        (Place::Base(PlaceBase::Static(_)), Place::Base(PlaceBase::Local(_))) => {\n             debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL-PROMOTED\");\n             Overlap::Disjoint\n         }"}, {"sha": "73b88e9904bf23cbd1a202343eb0d0acf5406faa", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb93f10dac46376b706643a74f3ebbabaf46c48f/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb93f10dac46376b706643a74f3ebbabaf46c48f/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=fb93f10dac46376b706643a74f3ebbabaf46c48f", "patch": "@@ -292,8 +292,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             let promoted_id = Promoted::new(self.source.promoted.len());\n             let mut promoted_place = |ty, span| {\n                 promoted.span = span;\n-                promoted.local_decls[RETURN_PLACE] =\n-                    LocalDecl::new_return_place(ty, span);\n+                promoted.local_decls[RETURN_PLACE] = LocalDecl::new_return_place(ty, span);\n                 Place::Base(\n                     PlaceBase::Static(box Static{ kind: StaticKind::Promoted(promoted_id), ty })\n                 )"}, {"sha": "0b9ad85e6b1c7c3585744e6e29ea0e84535926a0", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb93f10dac46376b706643a74f3ebbabaf46c48f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb93f10dac46376b706643a74f3ebbabaf46c48f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=fb93f10dac46376b706643a74f3ebbabaf46c48f", "patch": "@@ -930,7 +930,9 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         self.super_place(place, context, location);\n         match *place {\n             Place::Base(PlaceBase::Local(_)) => {}\n-            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) => {}\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) => {\n+                unreachable!()\n+            }\n             Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })) => {\n                 if self.tcx\n                        .get_attrs(def_id)"}]}