{"sha": "84aa027888f95c9df3e09d9229424f525b3fcec1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0YWEwMjc4ODhmOTVjOWRmM2UwOWQ5MjI5NDI0ZjUyNWIzZmNlYzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-03T00:12:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-03T00:12:02Z"}, "message": "Auto merge of #3607 - detrumi:limit_infinite_iter_to_known_types, r=phansch\n\nOnly trigger `infinite_iter` lint for infinitely allocating `collect()` calls\n\nFixes  #3538\n\n~Oh, I guess this should actually check other methods like `count` as well, not only `collect()`.~\nNever mind, `collect` is the only of these functions that allocates a data structure.", "tree": {"sha": "041f754424d205817572e7653a681bddabbfae76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/041f754424d205817572e7653a681bddabbfae76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84aa027888f95c9df3e09d9229424f525b3fcec1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84aa027888f95c9df3e09d9229424f525b3fcec1", "html_url": "https://github.com/rust-lang/rust/commit/84aa027888f95c9df3e09d9229424f525b3fcec1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84aa027888f95c9df3e09d9229424f525b3fcec1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fc5857d0b2150e2427f4e76b155e00997d6250c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fc5857d0b2150e2427f4e76b155e00997d6250c", "html_url": "https://github.com/rust-lang/rust/commit/0fc5857d0b2150e2427f4e76b155e00997d6250c"}, {"sha": "f38fb56baf2921ed006a36c54df3add3b7605593", "url": "https://api.github.com/repos/rust-lang/rust/commits/f38fb56baf2921ed006a36c54df3add3b7605593", "html_url": "https://github.com/rust-lang/rust/commit/f38fb56baf2921ed006a36c54df3add3b7605593"}], "stats": {"total": 49, "additions": 46, "deletions": 3}, "files": [{"sha": "e2da8461f4110e9fd11b2354285e811d143c8dac", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/84aa027888f95c9df3e09d9229424f525b3fcec1/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84aa027888f95c9df3e09d9229424f525b3fcec1/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=84aa027888f95c9df3e09d9229424f525b3fcec1", "patch": "@@ -7,7 +7,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use crate::utils::{get_trait_def_id, higher, implements_trait, match_qpath, paths, span_lint};\n+use crate::utils::{get_trait_def_id, higher, implements_trait, match_qpath, match_type, paths, span_lint};\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::{declare_tool_lint, lint_array};\n@@ -200,7 +200,6 @@ static POSSIBLY_COMPLETING_METHODS: &[(&str, usize)] = &[\n /// their iterators\n static COMPLETING_METHODS: &[(&str, usize)] = &[\n     (\"count\", 1),\n-    (\"collect\", 1),\n     (\"fold\", 3),\n     (\"for_each\", 2),\n     (\"partition\", 2),\n@@ -214,6 +213,18 @@ static COMPLETING_METHODS: &[(&str, usize)] = &[\n     (\"product\", 1),\n ];\n \n+/// the paths of types that are known to be infinitely allocating\n+static INFINITE_COLLECTORS: &[&[&str]] = &[\n+    &paths::BINARY_HEAP,\n+    &paths::BTREEMAP,\n+    &paths::BTREESET,\n+    &paths::HASHMAP,\n+    &paths::HASHSET,\n+    &paths::LINKED_LIST,\n+    &paths::VEC,\n+    &paths::VEC_DEQUE,\n+];\n+\n fn complete_infinite_iter(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n     match expr.node {\n         ExprKind::MethodCall(ref method, _, ref args) => {\n@@ -233,6 +244,11 @@ fn complete_infinite_iter(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n                 if not_double_ended {\n                     return is_infinite(cx, &args[0]);\n                 }\n+            } else if method.ident.name == \"collect\" {\n+                let ty = cx.tables.expr_ty(expr);\n+                if INFINITE_COLLECTORS.iter().any(|path| match_type(cx, ty, path)) {\n+                    return is_infinite(cx, &args[0]);\n+                }\n             }\n         },\n         ExprKind::Binary(op, ref l, ref r) => {"}, {"sha": "bd266368dc4b161c0a559240f25aba791d6e67b1", "filename": "tests/ui/infinite_iter.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/84aa027888f95c9df3e09d9229424f525b3fcec1/tests%2Fui%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84aa027888f95c9df3e09d9229424f525b3fcec1/tests%2Fui%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finfinite_iter.rs?ref=84aa027888f95c9df3e09d9229424f525b3fcec1", "patch": "@@ -58,3 +58,22 @@ fn main() {\n     infinite_iters();\n     potential_infinite_iters();\n }\n+\n+mod finite_collect {\n+    use std::collections::HashSet;\n+    use std::iter::FromIterator;\n+\n+    struct C;\n+    impl FromIterator<i32> for C {\n+        fn from_iter<I: IntoIterator<Item = i32>>(iter: I) -> Self {\n+            C\n+        }\n+    }\n+\n+    fn check_collect() {\n+        let _: HashSet<i32> = (0..).collect(); // Infinite iter\n+\n+        // Some data structures don't collect infinitely, such as `ArrayVec`\n+        let _: C = (0..).collect();\n+    }\n+}"}, {"sha": "288285d9aaebaa1a5b869cc22aa5706530f7b905", "filename": "tests/ui/infinite_iter.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/84aa027888f95c9df3e09d9229424f525b3fcec1/tests%2Fui%2Finfinite_iter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84aa027888f95c9df3e09d9229424f525b3fcec1/tests%2Fui%2Finfinite_iter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finfinite_iter.stderr?ref=84aa027888f95c9df3e09d9229424f525b3fcec1", "patch": "@@ -105,5 +105,13 @@ error: possible infinite iteration detected\n LL |     (0..).all(|x| x == 24); // maybe infinite iter\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 14 previous errors\n+error: infinite iteration detected\n+  --> $DIR/infinite_iter.rs:74:31\n+   |\n+LL |         let _: HashSet<i32> = (0..).collect(); // Infinite iter\n+   |                               ^^^^^^^^^^^^^^^\n+   |\n+   = note: #[deny(clippy::infinite_iter)] on by default\n+\n+error: aborting due to 15 previous errors\n "}]}