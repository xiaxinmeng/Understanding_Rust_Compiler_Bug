{"sha": "3c534b2bef5514ebce7acb2c829d7eee58f9bb5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjNTM0YjJiZWY1NTE0ZWJjZTdhY2IyYzgyOWQ3ZWVlNThmOWJiNWU=", "commit": {"author": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-06-23T22:42:55Z"}, "committer": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-06-23T22:42:55Z"}, "message": "Remove parse_str_lit_or_env_ident.\nWe decided to use metadata for the more complex cases, and a simple\nstring is enough for rustc right now.", "tree": {"sha": "9bab6bcf51d216f6f70876d4eda8d183b278ecac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9bab6bcf51d216f6f70876d4eda8d183b278ecac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c534b2bef5514ebce7acb2c829d7eee58f9bb5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c534b2bef5514ebce7acb2c829d7eee58f9bb5e", "html_url": "https://github.com/rust-lang/rust/commit/3c534b2bef5514ebce7acb2c829d7eee58f9bb5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c534b2bef5514ebce7acb2c829d7eee58f9bb5e/comments", "author": null, "committer": null, "parents": [{"sha": "14c31c26c29cba36b336898f1c760e2b61c74d4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/14c31c26c29cba36b336898f1c760e2b61c74d4c", "html_url": "https://github.com/rust-lang/rust/commit/14c31c26c29cba36b336898f1c760e2b61c74d4c"}], "stats": {"total": 42, "additions": 13, "deletions": 29}, "files": [{"sha": "9fc7070e154be30f1dd4690d5adb1cbaffa8d820", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 13, "deletions": 29, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3c534b2bef5514ebce7acb2c829d7eee58f9bb5e/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c534b2bef5514ebce7acb2c829d7eee58f9bb5e/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=3c534b2bef5514ebce7acb2c829d7eee58f9bb5e", "patch": "@@ -195,29 +195,6 @@ fn parse_value_ident(&parser p) -> ast::ident {\n     ret parse_ident(p);\n }\n \n-\n-/* FIXME: gross hack copied from rustboot to make certain configuration-based\n- * decisions work at build-time.  We should probably change it to use a\n- * lexical sytnax-extension or something similar. For now we just imitate\n- * rustboot.\n- */\n-fn parse_str_lit_or_env_ident(&parser p) -> ast::ident {\n-    alt (p.peek()) {\n-        case (token::LIT_STR(?s)) { p.bump(); ret p.get_str(s); }\n-        case (token::IDENT(?i, _)) {\n-            auto v =\n-                eval::lookup(p.get_session(), p.get_env(), p.get_span(),\n-                             p.get_str(i));\n-            if (!eval::val_is_str(v)) {\n-                p.fatal(\"expecting string-valued variable\");\n-            }\n-            p.bump();\n-            ret eval::val_as_str(v);\n-        }\n-        case (_) { p.fatal(\"expecting string literal\"); fail; }\n-    }\n-}\n-\n fn is_word(&parser p, &str word) -> bool {\n     ret alt (p.peek()) {\n             case (token::IDENT(?sid, false)) { str::eq(word, p.get_str(sid)) }\n@@ -1849,7 +1826,7 @@ fn parse_item_native_fn(&parser p) -> @ast::native_item {\n     auto link_name = none;\n     if (p.peek() == token::EQ) {\n         p.bump();\n-        link_name = some(parse_str_lit_or_env_ident(p));\n+        link_name = some(parse_str(p));\n     }\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n@@ -1897,7 +1874,7 @@ fn parse_item_native_mod(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto abi = ast::native_abi_cdecl;\n     if (!is_word(p, \"mod\")) {\n-        auto t = parse_str_lit_or_env_ident(p);\n+        auto t = parse_str(p);\n         if (str::eq(t, \"cdecl\")) {\n         } else if (str::eq(t, \"rust\")) {\n             abi = ast::native_abi_rust;\n@@ -1912,7 +1889,7 @@ fn parse_item_native_mod(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n     auto native_name;\n     if (p.peek() == token::EQ) {\n         expect(p, token::EQ);\n-        native_name = parse_str_lit_or_env_ident(p);\n+        native_name = parse_str(p);\n     } else { native_name = default_native_name(p.get_session(), id); }\n     expect(p, token::LBRACE);\n     auto m = parse_native_mod_items(p, native_name, abi);\n@@ -2297,6 +2274,15 @@ fn parse_crate_from_source_file(&parser p) -> @ast::crate {\n                                          attrs=crate_attrs._0));\n }\n \n+fn parse_str(&parser p) -> ast::ident {\n+    alt (p.peek()) {\n+        case (token::LIT_STR(?s)) {\n+            p.bump();\n+            ret p.get_str(s);\n+        }\n+        case (_) { fail; }\n+    }\n+}\n \n // Logic for parsing crate files (.rc)\n //\n@@ -2318,9 +2304,7 @@ fn parse_crate_directive(&parser p) -> ast::crate_directive {\n             alt (p.peek()) {\n                 case (token::EQ) {\n                     p.bump();\n-\n-                    // FIXME: turn this into parse+eval expr\n-                    some(parse_str_lit_or_env_ident(p))\n+                    some(parse_str(p))\n                 }\n                 case (_) { none }\n             };"}]}