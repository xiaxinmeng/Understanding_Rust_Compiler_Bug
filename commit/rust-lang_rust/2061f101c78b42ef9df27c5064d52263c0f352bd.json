{"sha": "2061f101c78b42ef9df27c5064d52263c0f352bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwNjFmMTAxYzc4YjQyZWY5ZGYyN2M1MDY0ZDUyMjYzYzBmMzUyYmQ=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-06-18T03:29:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-18T03:29:52Z"}, "message": "Merge pull request #1708 from topecongiro/chain-overflow\n\nAllow overflowing the last element of chain if it is originally multi-lined", "tree": {"sha": "945c88ae61a4df550453db8c3e91172acbeb26a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/945c88ae61a4df550453db8c3e91172acbeb26a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2061f101c78b42ef9df27c5064d52263c0f352bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2061f101c78b42ef9df27c5064d52263c0f352bd", "html_url": "https://github.com/rust-lang/rust/commit/2061f101c78b42ef9df27c5064d52263c0f352bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2061f101c78b42ef9df27c5064d52263c0f352bd/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59c0e4c7466cbff56d0db12455c9838717bef19e", "url": "https://api.github.com/repos/rust-lang/rust/commits/59c0e4c7466cbff56d0db12455c9838717bef19e", "html_url": "https://github.com/rust-lang/rust/commit/59c0e4c7466cbff56d0db12455c9838717bef19e"}, {"sha": "0440c2c37723f4fb6f021d49fb17fc011e06f4e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0440c2c37723f4fb6f021d49fb17fc011e06f4e1", "html_url": "https://github.com/rust-lang/rust/commit/0440c2c37723f4fb6f021d49fb17fc011e06f4e1"}], "stats": {"total": 282, "additions": 130, "deletions": 152}, "files": [{"sha": "9b27c92c270a6306d7e0bca1117ca9b7324bf32d", "filename": "src/chains.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2061f101c78b42ef9df27c5064d52263c0f352bd/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2061f101c78b42ef9df27c5064d52263c0f352bd/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=2061f101c78b42ef9df27c5064d52263c0f352bd", "patch": "@@ -124,7 +124,9 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     let first_subexpr_is_try = subexpr_list.last().map_or(false, is_try);\n     let (nested_shape, extend) = if !parent_rewrite_contains_newline && is_continuable(&parent) {\n         let nested_shape = if first_subexpr_is_try {\n-            parent_shape.block_indent(context.config.tab_spaces())\n+            parent_shape\n+                .block_indent(context.config.tab_spaces())\n+                .with_max_width(context.config)\n         } else {\n             chain_indent(context, shape.add_offset(parent_rewrite.len()))\n         };\n@@ -143,7 +145,12 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     } else if parent_rewrite_contains_newline {\n         (chain_indent(context, parent_shape), false)\n     } else {\n-        (shape.block_indent(context.config.tab_spaces()), false)\n+        (\n+            shape\n+                .block_indent(context.config.tab_spaces())\n+                .with_max_width(context.config),\n+            false,\n+        )\n     };\n \n     let other_child_shape = nested_shape.with_max_width(context.config);\n@@ -176,10 +183,9 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n \n     // Total of all items excluding the last.\n     let last_non_try_index = rewrites.len() - (1 + trailing_try_num);\n-    let almost_total = rewrites[..last_non_try_index].iter().fold(\n-        0,\n-        |a, b| a + first_line_width(b),\n-    ) + parent_rewrite.len();\n+    let almost_total = rewrites[..last_non_try_index]\n+        .iter()\n+        .fold(0, |a, b| a + first_line_width(b)) + parent_rewrite.len();\n     let one_line_len = rewrites.iter().fold(0, |a, r| a + first_line_width(r)) +\n         parent_rewrite.len();\n \n@@ -234,11 +240,12 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         }\n     }\n \n-    // Try overflowing the last element if we are using block indent.\n+    // Try overflowing the last element if we are using block indent and it goes multi line\n+    // or it fits in a single line but goes over the max width.\n     if !fits_single_line && context.use_block_indent() {\n         let (init, last) = rewrites.split_at_mut(last_non_try_index);\n         let almost_single_line = init.iter().all(|s| !s.contains('\\n'));\n-        if almost_single_line {\n+        if almost_single_line && last[0].contains('\\n') {\n             let overflow_shape = Shape {\n                 width: one_line_budget,\n                 ..parent_shape"}, {"sha": "d8189df363cbd0597f040f52a0ce1c192bf5cf63", "filename": "src/comment.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2061f101c78b42ef9df27c5064d52263c0f352bd/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2061f101c78b42ef9df27c5064d52263c0f352bd/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=2061f101c78b42ef9df27c5064d52263c0f352bd", "patch": "@@ -45,10 +45,9 @@ pub enum CommentStyle<'a> {\n \n fn custom_opener(s: &str) -> &str {\n     s.lines().next().map_or(\"\", |first_line| {\n-        first_line.find(' ').map_or(\n-            first_line,\n-            |space_index| &first_line[0..space_index + 1],\n-        )\n+        first_line\n+            .find(' ')\n+            .map_or(first_line, |space_index| &first_line[0..space_index + 1])\n     })\n }\n "}, {"sha": "b69e8bbd42eaf4b6b5472b7322c494098429139f", "filename": "src/expr.rs", "status": "modified", "additions": 23, "deletions": 36, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2061f101c78b42ef9df27c5064d52263c0f352bd/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2061f101c78b42ef9df27c5064d52263c0f352bd/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=2061f101c78b42ef9df27c5064d52263c0f352bd", "patch": "@@ -1077,10 +1077,8 @@ impl<'a> ControlFlow<'a> {\n \n             let new_width = try_opt!(new_width.checked_sub(if_str.len()));\n             let else_expr = &else_node.stmts[0];\n-            let else_str = try_opt!(else_expr.rewrite(\n-                context,\n-                Shape::legacy(new_width, Indent::empty()),\n-            ));\n+            let else_str =\n+                try_opt!(else_expr.rewrite(context, Shape::legacy(new_width, Indent::empty())));\n \n             if if_str.contains('\\n') || else_str.contains('\\n') {\n                 return None;\n@@ -1298,19 +1296,17 @@ impl<'a> Rewrite for ControlFlow<'a> {\n \n             let between_kwd_else_block = mk_sp(\n                 self.block.span.hi,\n-                context.codemap.span_before(\n-                    mk_sp(self.block.span.hi, else_block.span.lo),\n-                    \"else\",\n-                ),\n+                context\n+                    .codemap\n+                    .span_before(mk_sp(self.block.span.hi, else_block.span.lo), \"else\"),\n             );\n             let between_kwd_else_block_comment =\n                 extract_comment(between_kwd_else_block, context, shape);\n \n             let after_else = mk_sp(\n-                context.codemap.span_after(\n-                    mk_sp(self.block.span.hi, else_block.span.lo),\n-                    \"else\",\n-                ),\n+                context\n+                    .codemap\n+                    .span_after(mk_sp(self.block.span.hi, else_block.span.lo), \"else\"),\n                 else_block.span.lo,\n             );\n             let after_else_comment = extract_comment(after_else, context, shape);\n@@ -1328,10 +1324,9 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                 write!(\n                     &mut result,\n                     \"{}else{}\",\n-                    between_kwd_else_block_comment.as_ref().map_or(\n-                        between_sep,\n-                        |s| &**s,\n-                    ),\n+                    between_kwd_else_block_comment\n+                        .as_ref()\n+                        .map_or(between_sep, |s| &**s),\n                     after_else_comment.as_ref().map_or(after_sep, |s| &**s)\n                 ).ok()\n             );\n@@ -1478,10 +1473,9 @@ fn rewrite_match(\n \n     let arm_indent_str = arm_shape.indent.to_string(context.config);\n \n-    let open_brace_pos = context.codemap.span_after(\n-        mk_sp(cond.span.hi, arm_start_pos(&arms[0])),\n-        \"{\",\n-    );\n+    let open_brace_pos = context\n+        .codemap\n+        .span_after(mk_sp(cond.span.hi, arm_start_pos(&arms[0])), \"{\");\n \n     for (i, arm) in arms.iter().enumerate() {\n         // Make sure we get the stuff between arms.\n@@ -2051,10 +2045,8 @@ where\n \n fn need_block_indent(s: &str, shape: Shape) -> bool {\n     s.lines().skip(1).any(|s| {\n-        s.find(|c| !char::is_whitespace(c)).map_or(\n-            false,\n-            |w| w + 1 < shape.indent.width(),\n-        )\n+        s.find(|c| !char::is_whitespace(c))\n+            .map_or(false, |w| w + 1 < shape.indent.width())\n     })\n }\n \n@@ -2271,10 +2263,8 @@ fn can_be_overflowed<'a, T>(context: &RewriteContext, args: &[&T]) -> bool\n where\n     T: Rewrite + Spanned + ToExpr + 'a,\n {\n-    args.last().map_or(\n-        false,\n-        |x| x.can_be_overflowed(context, args.len()),\n-    )\n+    args.last()\n+        .map_or(false, |x| x.can_be_overflowed(context, args.len()))\n }\n \n pub fn can_be_overflowed_expr(context: &RewriteContext, expr: &ast::Expr, args_len: usize) -> bool {\n@@ -2541,10 +2531,9 @@ fn rewrite_field(context: &RewriteContext, field: &ast::Field, shape: Shape) ->\n             Some(e) => Some(format!(\"{}{}{}{}\", attrs_str, name, separator, e)),\n             None => {\n                 let expr_offset = shape.indent.block_indent(context.config);\n-                let expr = field.expr.rewrite(\n-                    context,\n-                    Shape::indented(expr_offset, context.config),\n-                );\n+                let expr = field\n+                    .expr\n+                    .rewrite(context, Shape::indented(expr_offset, context.config));\n                 expr.map(|s| {\n                     format!(\n                         \"{}{}:\\n{}{}\",\n@@ -2729,7 +2718,7 @@ pub fn rewrite_assign_rhs<S: Into<String>>(\n             0\n         };\n     // 1 = space between operator and rhs.\n-    let orig_shape = try_opt!(shape.block_indent(0).offset_left(last_line_width + 1));\n+    let orig_shape = try_opt!(shape.offset_left(last_line_width + 1));\n     let rhs = match ex.node {\n         ast::ExprKind::Mac(ref mac) => {\n             match rewrite_macro(mac, None, context, orig_shape, MacroPosition::Expression) {\n@@ -2761,9 +2750,7 @@ pub fn rewrite_assign_rhs<S: Into<String>>(\n             // FIXME: DRY!\n             match (rhs, new_rhs) {\n                 (Some(ref orig_rhs), Some(ref replacement_rhs))\n-                    if count_line_breaks(orig_rhs) > count_line_breaks(replacement_rhs) + 1 ||\n-                           (orig_rhs.rewrite(context, shape).is_none() &&\n-                                replacement_rhs.rewrite(context, new_shape).is_some()) => {\n+                    if count_line_breaks(orig_rhs) > count_line_breaks(replacement_rhs) + 1 => {\n                     result.push_str(&format!(\"\\n{}\", new_shape.indent.to_string(context.config)));\n                     result.push_str(replacement_rhs);\n                 }"}, {"sha": "40d57ac45d7a9e8c42efc71dfcb0ec7c53ba70d5", "filename": "src/items.rs", "status": "modified", "additions": 42, "deletions": 44, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/2061f101c78b42ef9df27c5064d52263c0f352bd/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2061f101c78b42ef9df27c5064d52263c0f352bd/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=2061f101c78b42ef9df27c5064d52263c0f352bd", "patch": "@@ -488,10 +488,12 @@ impl<'a> FmtVisitor<'a> {\n \n         let context = self.get_context();\n         let indent = self.block_indent;\n-        let mut result = try_opt!(field.node.attrs.rewrite(\n-            &context,\n-            Shape::indented(indent, self.config),\n-        ));\n+        let mut result = try_opt!(\n+            field\n+                .node\n+                .attrs\n+                .rewrite(&context, Shape::indented(indent, self.config))\n+        );\n         if !result.is_empty() {\n             let shape = Shape {\n                 width: context.config.max_width(),\n@@ -1436,10 +1438,10 @@ impl Rewrite for ast::StructField {\n \n         let name = self.ident;\n         let vis = format_visibility(&self.vis);\n-        let mut attr_str = try_opt!(self.attrs.rewrite(\n-            context,\n-            Shape::indented(shape.indent, context.config),\n-        ));\n+        let mut attr_str = try_opt!(\n+            self.attrs\n+                .rewrite(context, Shape::indented(shape.indent, context.config))\n+        );\n         // Try format missing comments after attributes\n         let missing_comment = if !self.attrs.is_empty() {\n             rewrite_missing_comment_on_field(\n@@ -1470,10 +1472,8 @@ impl Rewrite for ast::StructField {\n \n         let type_offset = shape.indent.block_indent(context.config);\n         let rewrite_type_in_next_line = || {\n-            self.ty.rewrite(\n-                context,\n-                Shape::indented(type_offset, context.config),\n-            )\n+            self.ty\n+                .rewrite(context, Shape::indented(type_offset, context.config))\n         };\n \n         let last_line_width = last_line_width(&result) + type_annotation_spacing.1.len();\n@@ -1670,10 +1670,10 @@ fn is_empty_infer(context: &RewriteContext, ty: &ast::Ty) -> bool {\n impl Rewrite for ast::Arg {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         if is_named_arg(self) {\n-            let mut result = try_opt!(self.pat.rewrite(\n-                context,\n-                Shape::legacy(shape.width, shape.indent),\n-            ));\n+            let mut result = try_opt!(\n+                self.pat\n+                    .rewrite(context, Shape::legacy(shape.width, shape.indent))\n+            );\n \n             if !is_empty_infer(context, &*self.ty) {\n                 if context.config.space_before_type_annotation() {\n@@ -1872,17 +1872,17 @@ fn rewrite_fn_base(\n     let generics_str = try_opt!(rewrite_generics(context, generics, shape, g_span));\n     result.push_str(&generics_str);\n \n-    let snuggle_angle_bracket = generics_str.lines().last().map_or(\n-        false,\n-        |l| l.trim_left().len() == 1,\n-    );\n+    let snuggle_angle_bracket = generics_str\n+        .lines()\n+        .last()\n+        .map_or(false, |l| l.trim_left().len() == 1);\n \n     // Note that the width and indent don't really matter, we'll re-layout the\n     // return type later anyway.\n-    let ret_str = try_opt!(fd.output.rewrite(\n-        &context,\n-        Shape::indented(indent, context.config),\n-    ));\n+    let ret_str = try_opt!(\n+        fd.output\n+            .rewrite(&context, Shape::indented(indent, context.config))\n+    );\n \n     let multi_line_ret_str = ret_str.contains('\\n');\n     let ret_str_len = if multi_line_ret_str { 0 } else { ret_str.len() };\n@@ -1942,10 +1942,10 @@ fn rewrite_fn_base(\n     }\n \n     // A conservative estimation, to goal is to be over all parens in generics\n-    let args_start = generics.ty_params.last().map_or(\n-        span.lo,\n-        |tp| end_typaram(tp),\n-    );\n+    let args_start = generics\n+        .ty_params\n+        .last()\n+        .map_or(span.lo, |tp| end_typaram(tp));\n     let args_span = mk_sp(\n         context.codemap.span_after(mk_sp(args_start, span.hi), \"(\"),\n         span_for_return(&fd.output).lo,\n@@ -1987,10 +1987,10 @@ fn rewrite_fn_base(\n         }\n         // If the last line of args contains comment, we cannot put the closing paren\n         // on the same line.\n-        if arg_str.lines().last().map_or(\n-            false,\n-            |last_line| last_line.contains(\"//\"),\n-        )\n+        if arg_str\n+            .lines()\n+            .last()\n+            .map_or(false, |last_line| last_line.contains(\"//\"))\n         {\n             args_last_line_contains_comment = true;\n             result.push('\\n');\n@@ -2048,10 +2048,10 @@ fn rewrite_fn_base(\n         if multi_line_ret_str || ret_should_indent {\n             // Now that we know the proper indent and width, we need to\n             // re-layout the return type.\n-            let ret_str = try_opt!(fd.output.rewrite(\n-                context,\n-                Shape::indented(ret_indent, context.config),\n-            ));\n+            let ret_str = try_opt!(\n+                fd.output\n+                    .rewrite(context, Shape::indented(ret_indent, context.config))\n+            );\n             result.push_str(&ret_str);\n         } else {\n             result.push_str(&ret_str);\n@@ -2063,14 +2063,12 @@ fn rewrite_fn_base(\n             let snippet_hi = span.hi;\n             let snippet = context.snippet(mk_sp(snippet_lo, snippet_hi));\n             // Try to preserve the layout of the original snippet.\n-            let original_starts_with_newline = snippet.find(|c| c != ' ').map_or(\n-                false,\n-                |i| snippet[i..].starts_with('\\n'),\n-            );\n-            let original_ends_with_newline = snippet.rfind(|c| c != ' ').map_or(\n-                false,\n-                |i| snippet[i..].ends_with('\\n'),\n-            );\n+            let original_starts_with_newline = snippet\n+                .find(|c| c != ' ')\n+                .map_or(false, |i| snippet[i..].starts_with('\\n'));\n+            let original_ends_with_newline = snippet\n+                .rfind(|c| c != ' ')\n+                .map_or(false, |i| snippet[i..].ends_with('\\n'));\n             let snippet = snippet.trim();\n             if !snippet.is_empty() {\n                 result.push(if original_starts_with_newline {"}, {"sha": "d176ef01f9b57a033dbed7f348a85343a186c40e", "filename": "src/lists.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2061f101c78b42ef9df27c5064d52263c0f352bd/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2061f101c78b42ef9df27c5064d52263c0f352bd/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=2061f101c78b42ef9df27c5064d52263c0f352bd", "patch": "@@ -125,17 +125,15 @@ pub struct ListItem {\n impl ListItem {\n     pub fn is_multiline(&self) -> bool {\n         self.item.as_ref().map_or(false, |s| s.contains('\\n')) || self.pre_comment.is_some() ||\n-            self.post_comment.as_ref().map_or(\n-                false,\n-                |s| s.contains('\\n'),\n-            )\n+            self.post_comment\n+                .as_ref()\n+                .map_or(false, |s| s.contains('\\n'))\n     }\n \n     pub fn has_line_pre_comment(&self) -> bool {\n-        self.pre_comment.as_ref().map_or(\n-            false,\n-            |comment| comment.starts_with(\"//\"),\n-        )\n+        self.pre_comment\n+            .as_ref()\n+            .map_or(false, |comment| comment.starts_with(\"//\"))\n     }\n \n     pub fn from_str<S: Into<String>>(s: S) -> ListItem {"}, {"sha": "419dea87a330ea33bc8a568b33a5b52cfd55022b", "filename": "src/macros.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2061f101c78b42ef9df27c5064d52263c0f352bd/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2061f101c78b42ef9df27c5064d52263c0f352bd/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=2061f101c78b42ef9df27c5064d52263c0f352bd", "patch": "@@ -219,10 +219,9 @@ pub fn rewrite_macro(\n                 let rewrite = try_opt!(rewrite_array(\n                     expr_vec.iter().map(|x| &**x),\n                     mk_sp(\n-                        context.codemap.span_after(\n-                            mac.span,\n-                            original_style.opener(),\n-                        ),\n+                        context\n+                            .codemap\n+                            .span_after(mac.span, original_style.opener()),\n                         mac.span.hi - BytePos(1),\n                     ),\n                     context,"}, {"sha": "fb0e298bbbf42a60c0963f0e963a9b4e9f9a6f4c", "filename": "src/missed_spans.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2061f101c78b42ef9df27c5064d52263c0f352bd/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2061f101c78b42ef9df27c5064d52263c0f352bd/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=2061f101c78b42ef9df27c5064d52263c0f352bd", "patch": "@@ -146,11 +146,9 @@ impl<'a> FmtVisitor<'a> {\n                 let subslice_num_lines = subslice.chars().filter(|c| *c == '\\n').count();\n \n                 if rewrite_next_comment &&\n-                    !self.config.file_lines().intersects_range(\n-                        file_name,\n-                        cur_line,\n-                        cur_line + subslice_num_lines,\n-                    )\n+                    !self.config\n+                        .file_lines()\n+                        .intersects_range(file_name, cur_line, cur_line + subslice_num_lines)\n                 {\n                     rewrite_next_comment = false;\n                 }"}, {"sha": "39b35de20b2130905f1cd533b6bef0f651734e8a", "filename": "src/types.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2061f101c78b42ef9df27c5064d52263c0f352bd/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2061f101c78b42ef9df27c5064d52263c0f352bd/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=2061f101c78b42ef9df27c5064d52263c0f352bd", "patch": "@@ -172,10 +172,11 @@ impl<'a> Rewrite for SegmentParam<'a> {\n                     TypeDensity::Compressed => format!(\"{}=\", binding.ident),\n                 };\n                 let budget = try_opt!(shape.width.checked_sub(result.len()));\n-                let rewrite = try_opt!(binding.ty.rewrite(\n-                    context,\n-                    Shape::legacy(budget, shape.indent + result.len()),\n-                ));\n+                let rewrite = try_opt!(\n+                    binding\n+                        .ty\n+                        .rewrite(context, Shape::legacy(budget, shape.indent + result.len()))\n+                );\n                 result.push_str(&rewrite);\n                 Some(result)\n             }\n@@ -448,10 +449,9 @@ impl Rewrite for ast::WherePredicate {\n                 // 3 = \" = \".len()\n                 let used_width = 3 + lhs_ty_str.len();\n                 let budget = try_opt!(shape.width.checked_sub(used_width));\n-                let rhs_ty_str = try_opt!(rhs_ty.rewrite(\n-                    context,\n-                    Shape::legacy(budget, shape.indent + used_width),\n-                ));\n+                let rhs_ty_str = try_opt!(\n+                    rhs_ty.rewrite(context, Shape::legacy(budget, shape.indent + used_width))\n+                );\n                 format!(\"{} = {}\", lhs_ty_str, rhs_ty_str)\n             }\n         };\n@@ -651,10 +651,12 @@ impl Rewrite for ast::Ty {\n                         format!(\n                             \"&{}{}\",\n                             mut_str,\n-                            try_opt!(mt.ty.rewrite(\n-                                context,\n-                                Shape::legacy(budget, shape.indent + 1 + mut_len),\n-                            ))\n+                            try_opt!(\n+                                mt.ty.rewrite(\n+                                    context,\n+                                    Shape::legacy(budget, shape.indent + 1 + mut_len),\n+                                )\n+                            )\n                         )\n                     }\n                 })"}, {"sha": "9c3d023c2ed88184109186ffbb126e90aa1af332", "filename": "src/utils.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2061f101c78b42ef9df27c5064d52263c0f352bd/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2061f101c78b42ef9df27c5064d52263c0f352bd/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=2061f101c78b42ef9df27c5064d52263c0f352bd", "patch": "@@ -317,10 +317,7 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, shape: Shape) -> Option<S\n             } else {\n                 let mut lines = snippet.lines();\n \n-                // The caller of this function has already placed `shape.offset`\n-                // characters on the first line.\n-                let first_line_max_len = try_opt!(max_width.checked_sub(shape.indent.width()));\n-                if lines.next().unwrap().len() > first_line_max_len {\n+                if lines.next().unwrap().len() > shape.width {\n                     return None;\n                 }\n \n@@ -333,9 +330,7 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, shape: Shape) -> Option<S\n                 // indentation.\n                 // A special check for the last line, since the caller may\n                 // place trailing characters on this line.\n-                if snippet.lines().rev().next().unwrap().len() >\n-                    shape.indent.width() + shape.width\n-                {\n+                if snippet.lines().rev().next().unwrap().len() > shape.used_width() + shape.width {\n                     return None;\n                 }\n             }"}, {"sha": "d20b4e971b54a5ab77b31109a37c8ada8989e13e", "filename": "src/visitor.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2061f101c78b42ef9df27c5064d52263c0f352bd/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2061f101c78b42ef9df27c5064d52263c0f352bd/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=2061f101c78b42ef9df27c5064d52263c0f352bd", "patch": "@@ -290,10 +290,9 @@ impl<'a> FmtVisitor<'a> {\n             ast::ItemKind::Impl(..) => {\n                 self.format_missing_with_indent(source!(self, item.span).lo);\n                 let snippet = self.get_context().snippet(item.span);\n-                let where_span_end =\n-                    snippet\n-                        .find_uncommented(\"{\")\n-                        .map(|x| (BytePos(x as u32)) + source!(self, item.span).lo);\n+                let where_span_end = snippet\n+                    .find_uncommented(\"{\")\n+                    .map(|x| (BytePos(x as u32)) + source!(self, item.span).lo);\n                 if let Some(impl_str) = format_impl(\n                     &self.get_context(),\n                     item,"}, {"sha": "3962bdcbbcd908f8ef62c09a744651be0aedc94a", "filename": "tests/target/chains-visual.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2061f101c78b42ef9df27c5064d52263c0f352bd/tests%2Ftarget%2Fchains-visual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2061f101c78b42ef9df27c5064d52263c0f352bd/tests%2Ftarget%2Fchains-visual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-visual.rs?ref=2061f101c78b42ef9df27c5064d52263c0f352bd", "patch": "@@ -47,10 +47,9 @@ fn main() {\n     });\n \n     let suuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuum =\n-        xxxxxxx.map(|x| x + 5).map(|x| x / 2).fold(\n-            0,\n-            |acc, x| acc + x,\n-        );\n+        xxxxxxx.map(|x| x + 5)\n+               .map(|x| x / 2)\n+               .fold(0, |acc, x| acc + x);\n \n     aaaaaaaaaaaaaaaa.map(|x| {\n         x += 1;"}, {"sha": "55c5ecdf5938551744829cb5ef67bef621403fed", "filename": "tests/target/configs-fn_call_style-block.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2061f101c78b42ef9df27c5064d52263c0f352bd/tests%2Ftarget%2Fconfigs-fn_call_style-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2061f101c78b42ef9df27c5064d52263c0f352bd/tests%2Ftarget%2Fconfigs-fn_call_style-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-fn_call_style-block.rs?ref=2061f101c78b42ef9df27c5064d52263c0f352bd", "patch": "@@ -18,18 +18,15 @@ fn main() {\n     ));\n \n     // chain\n-    let x = yooooooooooooo.fooooooooooooooo.baaaaaaaaaaaaar(\n-        hello,\n-        world,\n-    );\n+    let x = yooooooooooooo\n+        .fooooooooooooooo\n+        .baaaaaaaaaaaaar(hello, world);\n \n     // #1380\n     {\n         {\n-            let creds = self.client.client_credentials(\n-                &self.config.auth.oauth2.id,\n-                &self.config.auth.oauth2.secret,\n-            )?;\n+            let creds = self.client\n+                .client_credentials(&self.config.auth.oauth2.id, &self.config.auth.oauth2.secret)?;\n         }\n     }\n "}, {"sha": "49ba3e7d46c3e5426b95239d0fd33b811a600551", "filename": "tests/target/configs-force_format_strings-true.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2061f101c78b42ef9df27c5064d52263c0f352bd/tests%2Ftarget%2Fconfigs-force_format_strings-true.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2061f101c78b42ef9df27c5064d52263c0f352bd/tests%2Ftarget%2Fconfigs-force_format_strings-true.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-force_format_strings-true.rs?ref=2061f101c78b42ef9df27c5064d52263c0f352bd", "patch": "@@ -4,7 +4,7 @@\n // Force format strings\n \n fn main() {\n-    let lorem =\n-        \"ipsum dolor sit amet consectetur \\\n-         adipiscing elit lorem ipsum dolor sit\";\n+    let lorem = \"ipsum dolor sit amet \\\n+                 consectetur adipiscing elit \\\n+                 lorem ipsum dolor sit\";\n }"}, {"sha": "fdd5ab2c97d1c5ad2f89fb4dbded777cbbc742db", "filename": "tests/target/configs-format_strings-true.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2061f101c78b42ef9df27c5064d52263c0f352bd/tests%2Ftarget%2Fconfigs-format_strings-true.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2061f101c78b42ef9df27c5064d52263c0f352bd/tests%2Ftarget%2Fconfigs-format_strings-true.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-format_strings-true.rs?ref=2061f101c78b42ef9df27c5064d52263c0f352bd", "patch": "@@ -3,7 +3,7 @@\n // Force format strings\n \n fn main() {\n-    let lorem =\n-        \"ipsum dolor sit amet consectetur \\\n-         adipiscing elit lorem ipsum dolor sit\";\n+    let lorem = \"ipsum dolor sit amet \\\n+                 consectetur adipiscing elit \\\n+                 lorem ipsum dolor sit\";\n }"}, {"sha": "e4efd86b7f9e62c2771cf3534a4710af4cdd7ba6", "filename": "tests/target/long_field_access.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2061f101c78b42ef9df27c5064d52263c0f352bd/tests%2Ftarget%2Flong_field_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2061f101c78b42ef9df27c5064d52263c0f352bd/tests%2Ftarget%2Flong_field_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Flong_field_access.rs?ref=2061f101c78b42ef9df27c5064d52263c0f352bd", "patch": "@@ -1,4 +1,4 @@\n fn f() {\n-    block_flow.base.stacking_relative_position_of_display_port =\n-        self.base.stacking_relative_position_of_display_port;\n+    block_flow.base.stacking_relative_position_of_display_port = self.base\n+        .stacking_relative_position_of_display_port;\n }"}]}