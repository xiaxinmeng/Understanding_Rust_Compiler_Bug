{"sha": "506495a4b37f2be981a6a5e7327631dd9589fad8", "node_id": "C_kwDOAAsO6NoAKDUwNjQ5NWE0YjM3ZjJiZTk4MWE2YTVlNzMyNzYzMWRkOTU4OWZhZDg", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-09T11:11:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-09T11:11:54Z"}, "message": "Rollup merge of #108870 - GuillaumeGomez:rustdoc-reexport-of-reexport-of-private, r=notriddle\n\nFix invalid inlining of reexport of reexport of private item\n\nFixes https://github.com/rust-lang/rust/issues/108679.\n\nThe problem is that a reexport is always resolving to the end type, so if the end type is private, the reexport inlines. Except that if you reexport a public reexport (which reexports the private item), then it should not be inlined again.\n\nr? `@notriddle`", "tree": {"sha": "eb9348185b870c5627a34c23b7240e0e82ecd27e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb9348185b870c5627a34c23b7240e0e82ecd27e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/506495a4b37f2be981a6a5e7327631dd9589fad8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkCb76CRBK7hj4Ov3rIwAA6ZQIAE0l3sQtij/o9T6YSkq9GDou\nuUBB1083bmZ+zg+AvMEw7hELoTnd5lGIrG94nu6BnRH8wXXtMB6EGeZdTHnN00RF\nUaxqmQmgvtP3TiTSlQSHsjZsiNtW0e/NuEYjg07ZZQfXqzZk6RGK5nY7+RW6FjXK\nj5xOQFKrUDvYTvcCcFrdCrZ/FW5oWnm4a5XqWAjX22fBs4I4RULETk0r01hru90e\nSH/3uLLeDxRi6WwqFv+pIo0ronUWrwzkLEtSCd+rGlLWPmP3tyKrN3GLt0Oiod6F\nXmkvpiMlnKzzLrn5BTvxF78SYiaEVyKEiXR1jrnfGkCb26TgEyb64v3iQVKHQQI=\n=5kbo\n-----END PGP SIGNATURE-----\n", "payload": "tree eb9348185b870c5627a34c23b7240e0e82ecd27e\nparent bec7011a2c9f16b94d659298cfa38cfd88bcfa1b\nparent c0c93be7ce67a97c6df9d07ab86450218aef374b\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1678360314 +0100\ncommitter GitHub <noreply@github.com> 1678360314 +0100\n\nRollup merge of #108870 - GuillaumeGomez:rustdoc-reexport-of-reexport-of-private, r=notriddle\n\nFix invalid inlining of reexport of reexport of private item\n\nFixes https://github.com/rust-lang/rust/issues/108679.\n\nThe problem is that a reexport is always resolving to the end type, so if the end type is private, the reexport inlines. Except that if you reexport a public reexport (which reexports the private item), then it should not be inlined again.\n\nr? `@notriddle`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/506495a4b37f2be981a6a5e7327631dd9589fad8", "html_url": "https://github.com/rust-lang/rust/commit/506495a4b37f2be981a6a5e7327631dd9589fad8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/506495a4b37f2be981a6a5e7327631dd9589fad8/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bec7011a2c9f16b94d659298cfa38cfd88bcfa1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bec7011a2c9f16b94d659298cfa38cfd88bcfa1b", "html_url": "https://github.com/rust-lang/rust/commit/bec7011a2c9f16b94d659298cfa38cfd88bcfa1b"}, {"sha": "c0c93be7ce67a97c6df9d07ab86450218aef374b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0c93be7ce67a97c6df9d07ab86450218aef374b", "html_url": "https://github.com/rust-lang/rust/commit/c0c93be7ce67a97c6df9d07ab86450218aef374b"}], "stats": {"total": 157, "additions": 114, "deletions": 43}, "files": [{"sha": "29c3afe0d9560d06b363c5846566c5fbc34fd2f4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 66, "deletions": 42, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/506495a4b37f2be981a6a5e7327631dd9589fad8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/506495a4b37f2be981a6a5e7327631dd9589fad8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=506495a4b37f2be981a6a5e7327631dd9589fad8", "patch": "@@ -2065,23 +2065,81 @@ fn clean_bare_fn_ty<'tcx>(\n     BareFunctionDecl { unsafety: bare_fn.unsafety, abi: bare_fn.abi, decl, generic_params }\n }\n \n-/// This visitor is used to go through only the \"top level\" of a item and not enter any sub\n-/// item while looking for a given `Ident` which is stored into `item` if found.\n-struct OneLevelVisitor<'hir> {\n+/// Get DefId of of an item's user-visible parent.\n+///\n+/// \"User-visible\" should account for re-exporting and inlining, which is why this function isn't\n+/// just `tcx.parent(def_id)`. If the provided `path` has more than one path element, the `DefId`\n+/// of the second-to-last will be given.\n+///\n+/// ```text\n+/// use crate::foo::Bar;\n+///            ^^^ DefId of this item will be returned\n+/// ```\n+///\n+/// If the provided path has only one item, `tcx.parent(def_id)` will be returned instead.\n+fn get_path_parent_def_id(\n+    tcx: TyCtxt<'_>,\n+    def_id: DefId,\n+    path: &hir::UsePath<'_>,\n+) -> Option<DefId> {\n+    if let [.., parent_segment, _] = &path.segments {\n+        match parent_segment.res {\n+            hir::def::Res::Def(_, parent_def_id) => Some(parent_def_id),\n+            _ if parent_segment.ident.name == kw::Crate => {\n+                // In case the \"parent\" is the crate, it'll give `Res::Err` so we need to\n+                // circumvent it this way.\n+                Some(tcx.parent(def_id))\n+            }\n+            _ => None,\n+        }\n+    } else {\n+        // If the path doesn't have a parent, then the parent is the current module.\n+        Some(tcx.parent(def_id))\n+    }\n+}\n+\n+/// This visitor is used to find an HIR Item based on its `use` path. This doesn't use the ordinary\n+/// name resolver because it does not walk all the way through a chain of re-exports.\n+pub(crate) struct OneLevelVisitor<'hir> {\n     map: rustc_middle::hir::map::Map<'hir>,\n-    item: Option<&'hir hir::Item<'hir>>,\n+    pub(crate) item: Option<&'hir hir::Item<'hir>>,\n     looking_for: Ident,\n     target_def_id: LocalDefId,\n }\n \n impl<'hir> OneLevelVisitor<'hir> {\n-    fn new(map: rustc_middle::hir::map::Map<'hir>, target_def_id: LocalDefId) -> Self {\n+    pub(crate) fn new(map: rustc_middle::hir::map::Map<'hir>, target_def_id: LocalDefId) -> Self {\n         Self { map, item: None, looking_for: Ident::empty(), target_def_id }\n     }\n \n-    fn reset(&mut self, looking_for: Ident) {\n-        self.looking_for = looking_for;\n+    pub(crate) fn find_target(\n+        &mut self,\n+        tcx: TyCtxt<'_>,\n+        def_id: DefId,\n+        path: &hir::UsePath<'_>,\n+    ) -> Option<&'hir hir::Item<'hir>> {\n+        let parent_def_id = get_path_parent_def_id(tcx, def_id, path)?;\n+        let parent = self.map.get_if_local(parent_def_id)?;\n+\n+        // We get the `Ident` we will be looking for into `item`.\n+        self.looking_for = path.segments[path.segments.len() - 1].ident;\n+        // We reset the `item`.\n         self.item = None;\n+\n+        match parent {\n+            hir::Node::Item(parent_item) => {\n+                hir::intravisit::walk_item(self, parent_item);\n+            }\n+            hir::Node::Crate(m) => {\n+                hir::intravisit::walk_mod(\n+                    self,\n+                    m,\n+                    tcx.local_def_id_to_hir_id(parent_def_id.as_local().unwrap()),\n+                );\n+            }\n+            _ => return None,\n+        }\n+        self.item\n     }\n }\n \n@@ -2129,41 +2187,7 @@ fn get_all_import_attributes<'hir>(\n             add_without_unwanted_attributes(attributes, hir_map.attrs(item.hir_id()), is_inline);\n         }\n \n-        let def_id = if let [.., parent_segment, _] = &path.segments {\n-            match parent_segment.res {\n-                hir::def::Res::Def(_, def_id) => def_id,\n-                _ if parent_segment.ident.name == kw::Crate => {\n-                    // In case the \"parent\" is the crate, it'll give `Res::Err` so we need to\n-                    // circumvent it this way.\n-                    tcx.parent(item.owner_id.def_id.to_def_id())\n-                }\n-                _ => break,\n-            }\n-        } else {\n-            // If the path doesn't have a parent, then the parent is the current module.\n-            tcx.parent(item.owner_id.def_id.to_def_id())\n-        };\n-\n-        let Some(parent) = hir_map.get_if_local(def_id) else { break };\n-\n-        // We get the `Ident` we will be looking for into `item`.\n-        let looking_for = path.segments[path.segments.len() - 1].ident;\n-        visitor.reset(looking_for);\n-\n-        match parent {\n-            hir::Node::Item(parent_item) => {\n-                hir::intravisit::walk_item(&mut visitor, parent_item);\n-            }\n-            hir::Node::Crate(m) => {\n-                hir::intravisit::walk_mod(\n-                    &mut visitor,\n-                    m,\n-                    tcx.local_def_id_to_hir_id(def_id.as_local().unwrap()),\n-                );\n-            }\n-            _ => break,\n-        }\n-        if let Some(i) = visitor.item {\n+        if let Some(i) = visitor.find_target(tcx, item.owner_id.def_id.to_def_id(), path) {\n             item = i;\n         } else {\n             break;"}, {"sha": "44e9b49f82afd5382ac3124fe09526894ed32b96", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/506495a4b37f2be981a6a5e7327631dd9589fad8/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/506495a4b37f2be981a6a5e7327631dd9589fad8/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=506495a4b37f2be981a6a5e7327631dd9589fad8", "patch": "@@ -15,7 +15,7 @@ use rustc_span::Span;\n \n use std::mem;\n \n-use crate::clean::{cfg::Cfg, AttributesExt, NestedAttributesExt};\n+use crate::clean::{cfg::Cfg, AttributesExt, NestedAttributesExt, OneLevelVisitor};\n use crate::core;\n \n /// This module is used to store stuff from Rust's AST in a more convenient\n@@ -220,6 +220,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         renamed: Option<Symbol>,\n         glob: bool,\n         please_inline: bool,\n+        path: &hir::UsePath<'_>,\n     ) -> bool {\n         debug!(\"maybe_inline_local res: {:?}\", res);\n \n@@ -263,6 +264,22 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false;\n         }\n \n+        if !please_inline &&\n+            let mut visitor = OneLevelVisitor::new(self.cx.tcx.hir(), res_did) &&\n+            let Some(item) = visitor.find_target(self.cx.tcx, def_id.to_def_id(), path) &&\n+            let item_def_id = item.owner_id.def_id &&\n+            item_def_id != def_id &&\n+            self\n+                .cx\n+                .cache\n+                .effective_visibilities\n+                .is_directly_public(self.cx.tcx, item_def_id.to_def_id()) &&\n+            !inherits_doc_hidden(self.cx.tcx, item_def_id)\n+        {\n+            // The imported item is public and not `doc(hidden)` so no need to inline it.\n+            return false;\n+        }\n+\n         let ret = match tcx.hir().get_by_def_id(res_did) {\n             Node::Item(&hir::Item { kind: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n@@ -361,6 +378,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                             ident,\n                             is_glob,\n                             please_inline,\n+                            path,\n                         ) {\n                             continue;\n                         }"}, {"sha": "5f977801cfd466acfa00ad3bb960a1d31b124b38", "filename": "tests/rustdoc/issue-108679-reexport-of-reexport.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/506495a4b37f2be981a6a5e7327631dd9589fad8/tests%2Frustdoc%2Fissue-108679-reexport-of-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/506495a4b37f2be981a6a5e7327631dd9589fad8/tests%2Frustdoc%2Fissue-108679-reexport-of-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-108679-reexport-of-reexport.rs?ref=506495a4b37f2be981a6a5e7327631dd9589fad8", "patch": "@@ -0,0 +1,29 @@\n+// This test ensures that the `struct.B.html` only exists in `a`:\n+// since `a::B` is public (and inlined too), `self::a::B` doesn't\n+// need to be inlined as well.\n+\n+#![crate_name = \"foo\"]\n+\n+pub mod a {\n+    // @has 'foo/a/index.html'\n+    // Should only contain \"Structs\".\n+    // @count - '//*[@id=\"main-content\"]//*[@class=\"item-table\"]' 1\n+    // @has - '//*[@id=\"structs\"]' 'Structs'\n+    // @has - '//*[@id=\"main-content\"]//a[@href=\"struct.A.html\"]' 'A'\n+    // @has - '//*[@id=\"main-content\"]//a[@href=\"struct.B.html\"]' 'B'\n+    mod b {\n+        pub struct B;\n+    }\n+    pub use self::b::B;\n+    pub struct A;\n+}\n+\n+// @has 'foo/index.html'\n+// @!has - '//*[@id=\"structs\"]' 'Structs'\n+// @has - '//*[@id=\"reexports\"]' 'Re-exports'\n+// @has - '//*[@id=\"modules\"]' 'Modules'\n+// @has - '//*[@id=\"main-content\"]//*[@id=\"reexport.A\"]' 'pub use self::a::A;'\n+// @has - '//*[@id=\"main-content\"]//*[@id=\"reexport.B\"]' 'pub use self::a::B;'\n+// Should only contain \"Modules\" and \"Re-exports\".\n+// @count - '//*[@id=\"main-content\"]//*[@class=\"item-table\"]' 2\n+pub use self::a::{A, B};"}]}