{"sha": "60560bc2a2c149e179cd7e58a8b48e06c2c4e3f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwNTYwYmMyYTJjMTQ5ZTE3OWNkN2U1OGE4YjQ4ZTA2YzJjNGUzZjQ=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-09-22T00:11:09Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-09-22T00:11:09Z"}, "message": "Parse assoc type bounds in generic params and provide custom diagnostic", "tree": {"sha": "b7acfb3124b7b045a8493f677b7c94a3ec4cc80d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7acfb3124b7b045a8493f677b7c94a3ec4cc80d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60560bc2a2c149e179cd7e58a8b48e06c2c4e3f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60560bc2a2c149e179cd7e58a8b48e06c2c4e3f4", "html_url": "https://github.com/rust-lang/rust/commit/60560bc2a2c149e179cd7e58a8b48e06c2c4e3f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60560bc2a2c149e179cd7e58a8b48e06c2c4e3f4/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ad1e7c46cf690b7ec6953b142430d21ca2d8799", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ad1e7c46cf690b7ec6953b142430d21ca2d8799", "html_url": "https://github.com/rust-lang/rust/commit/9ad1e7c46cf690b7ec6953b142430d21ca2d8799"}], "stats": {"total": 118, "additions": 80, "deletions": 38}, "files": [{"sha": "1ffdda19c80b51ca2d368cb307602c59295736ba", "filename": "src/libsyntax/parse/parser/generics.rs", "status": "modified", "additions": 61, "deletions": 38, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/60560bc2a2c149e179cd7e58a8b48e06c2c4e3f4/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60560bc2a2c149e179cd7e58a8b48e06c2c4e3f4/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs?ref=60560bc2a2c149e179cd7e58a8b48e06c2c4e3f4", "patch": "@@ -100,13 +100,31 @@ impl<'a> Parser<'a> {\n             } else if self.check_ident() {\n                 // Parse type parameter.\n                 params.push(self.parse_ty_param(attrs)?);\n+            } else if self.token.can_begin_type() {\n+                // Trying to write an associated type bound? (#26271)\n+                let snapshot = self.clone();\n+                match self.parse_ty_where_predicate() {\n+                    Ok(where_predicate) => {\n+                        self.struct_span_err(\n+                            where_predicate.span(),\n+                            \"associated type bounds do not belong here\",\n+                        )\n+                        .span_label(where_predicate.span(), \"belongs in `where` clause\")\n+                        .emit();\n+                    }\n+                    Err(mut err) => {\n+                        err.cancel();\n+                        std::mem::replace(self, snapshot);\n+                        break\n+                    }\n+                }\n             } else {\n                 // Check for trailing attributes and stop parsing.\n                 if !attrs.is_empty() {\n                     if !params.is_empty() {\n                         self.struct_span_err(\n                             attrs[0].span,\n-                            &format!(\"trailing attribute after generic parameter\"),\n+                            \"trailing attribute after generic parameter\",\n                         )\n                         .span_label(attrs[0].span, \"attributes must go before parameters\")\n                         .emit();\n@@ -202,43 +220,7 @@ impl<'a> Parser<'a> {\n                     }\n                 ));\n             } else if self.check_type() {\n-                // Parse optional `for<'a, 'b>`.\n-                // This `for` is parsed greedily and applies to the whole predicate,\n-                // the bounded type can have its own `for` applying only to it.\n-                // Examples:\n-                // * `for<'a> Trait1<'a>: Trait2<'a /* ok */>`\n-                // * `(for<'a> Trait1<'a>): Trait2<'a /* not ok */>`\n-                // * `for<'a> for<'b> Trait1<'a, 'b>: Trait2<'a /* ok */, 'b /* not ok */>`\n-                let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n-\n-                // Parse type with mandatory colon and (possibly empty) bounds,\n-                // or with mandatory equality sign and the second type.\n-                let ty = self.parse_ty()?;\n-                if self.eat(&token::Colon) {\n-                    let bounds = self.parse_generic_bounds(Some(self.prev_span))?;\n-                    where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n-                        ast::WhereBoundPredicate {\n-                            span: lo.to(self.prev_span),\n-                            bound_generic_params: lifetime_defs,\n-                            bounded_ty: ty,\n-                            bounds,\n-                        }\n-                    ));\n-                // FIXME: Decide what should be used here, `=` or `==`.\n-                // FIXME: We are just dropping the binders in lifetime_defs on the floor here.\n-                } else if self.eat(&token::Eq) || self.eat(&token::EqEq) {\n-                    let rhs_ty = self.parse_ty()?;\n-                    where_clause.predicates.push(ast::WherePredicate::EqPredicate(\n-                        ast::WhereEqPredicate {\n-                            span: lo.to(self.prev_span),\n-                            lhs_ty: ty,\n-                            rhs_ty,\n-                            id: ast::DUMMY_NODE_ID,\n-                        }\n-                    ));\n-                } else {\n-                    return self.unexpected();\n-                }\n+                where_clause.predicates.push(self.parse_ty_where_predicate()?);\n             } else {\n                 break\n             }\n@@ -252,6 +234,47 @@ impl<'a> Parser<'a> {\n         Ok(where_clause)\n     }\n \n+    fn parse_ty_where_predicate(&mut self) -> PResult<'a, ast::WherePredicate> {\n+        let lo = self.token.span;\n+        // Parse optional `for<'a, 'b>`.\n+        // This `for` is parsed greedily and applies to the whole predicate,\n+        // the bounded type can have its own `for` applying only to it.\n+        // Examples:\n+        // * `for<'a> Trait1<'a>: Trait2<'a /* ok */>`\n+        // * `(for<'a> Trait1<'a>): Trait2<'a /* not ok */>`\n+        // * `for<'a> for<'b> Trait1<'a, 'b>: Trait2<'a /* ok */, 'b /* not ok */>`\n+        let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n+\n+        // Parse type with mandatory colon and (possibly empty) bounds,\n+        // or with mandatory equality sign and the second type.\n+        let ty = self.parse_ty()?;\n+        if self.eat(&token::Colon) {\n+            let bounds = self.parse_generic_bounds(Some(self.prev_span))?;\n+            Ok(ast::WherePredicate::BoundPredicate(\n+                ast::WhereBoundPredicate {\n+                    span: lo.to(self.prev_span),\n+                    bound_generic_params: lifetime_defs,\n+                    bounded_ty: ty,\n+                    bounds,\n+                }\n+            ))\n+        // FIXME: Decide what should be used here, `=` or `==`.\n+        // FIXME: We are just dropping the binders in lifetime_defs on the floor here.\n+        } else if self.eat(&token::Eq) || self.eat(&token::EqEq) {\n+            let rhs_ty = self.parse_ty()?;\n+            Ok(ast::WherePredicate::EqPredicate(\n+                ast::WhereEqPredicate {\n+                    span: lo.to(self.prev_span),\n+                    lhs_ty: ty,\n+                    rhs_ty,\n+                    id: ast::DUMMY_NODE_ID,\n+                }\n+            ))\n+        } else {\n+            self.unexpected()\n+        }\n+    }\n+\n     pub(super) fn choose_generics_over_qpath(&self) -> bool {\n         // There's an ambiguity between generic parameters and qualified paths in impls.\n         // If we see `<` it may start both, so we have to inspect some following tokens."}, {"sha": "09765f01371aa94bbea696a1eb24521e62231faa", "filename": "src/test/ui/parser/assoc-type-in-type-arg.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/60560bc2a2c149e179cd7e58a8b48e06c2c4e3f4/src%2Ftest%2Fui%2Fparser%2Fassoc-type-in-type-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60560bc2a2c149e179cd7e58a8b48e06c2c4e3f4/src%2Ftest%2Fui%2Fparser%2Fassoc-type-in-type-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fassoc-type-in-type-arg.rs?ref=60560bc2a2c149e179cd7e58a8b48e06c2c4e3f4", "patch": "@@ -0,0 +1,11 @@\n+trait Tr {\n+    type TrSubtype;\n+}\n+\n+struct Bar<'a, Item: Tr, <Item as Tr>::TrSubtype: 'a> {\n+    //~^ ERROR associated type bounds do not belong here\n+    item: Item,\n+    item_sub: &'a <Item as Tr>::TrSubtype,\n+}\n+\n+fn main() {}"}, {"sha": "06addb0241725e442f30533ca08c4a41173aaf50", "filename": "src/test/ui/parser/assoc-type-in-type-arg.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/60560bc2a2c149e179cd7e58a8b48e06c2c4e3f4/src%2Ftest%2Fui%2Fparser%2Fassoc-type-in-type-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/60560bc2a2c149e179cd7e58a8b48e06c2c4e3f4/src%2Ftest%2Fui%2Fparser%2Fassoc-type-in-type-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fassoc-type-in-type-arg.stderr?ref=60560bc2a2c149e179cd7e58a8b48e06c2c4e3f4", "patch": "@@ -0,0 +1,8 @@\n+error: associated type bounds do not belong here\n+  --> $DIR/assoc-type-in-type-arg.rs:5:26\n+   |\n+LL | struct Bar<'a, Item: Tr, <Item as Tr>::TrSubtype: 'a> {\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ belongs in `where` clause\n+\n+error: aborting due to previous error\n+"}]}