{"sha": "e7c60c141b6f499ba551b53bc562925269d2f187", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3YzYwYzE0MWI2ZjQ5OWJhNTUxYjUzYmM1NjI5MjUyNjlkMmYxODc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-22T18:09:13Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-22T19:57:27Z"}, "message": "librustc: Remove `pure` from libsyntax and librustc.", "tree": {"sha": "e43edc564d34f7d4f5c9b6e5b9dedfb946230d46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e43edc564d34f7d4f5c9b6e5b9dedfb946230d46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7c60c141b6f499ba551b53bc562925269d2f187", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7c60c141b6f499ba551b53bc562925269d2f187", "html_url": "https://github.com/rust-lang/rust/commit/e7c60c141b6f499ba551b53bc562925269d2f187", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7c60c141b6f499ba551b53bc562925269d2f187/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec59ce5796723ff62c071f7b36577175c6001791", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec59ce5796723ff62c071f7b36577175c6001791", "html_url": "https://github.com/rust-lang/rust/commit/ec59ce5796723ff62c071f7b36577175c6001791"}], "stats": {"total": 503, "additions": 251, "deletions": 252}, "files": [{"sha": "1137b2a2c08a0a4672faab32ab300441525282fc", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -20,7 +20,7 @@ use core::util;\n use core::vec;\n use core::hashmap::linear::LinearSet;\n \n-pure fn not_win32(os: session::os) -> bool {\n+fn not_win32(os: session::os) -> bool {\n   match os {\n       session::os_win32 => false,\n       _ => true"}, {"sha": "b952aff9e1ce15749ad5a841b973773cd4353732", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -872,7 +872,7 @@ pub fn get_item_attrs(cdata: cmd,\n     }\n }\n \n-pure fn struct_field_family_to_visibility(family: Family) -> ast::visibility {\n+fn struct_field_family_to_visibility(family: Family) -> ast::visibility {\n     match family {\n       PublicField => ast::public,\n       PrivateField => ast::private,"}, {"sha": "d5c4b27e6cbb8f084cf9955c198134e59131cd22", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -444,7 +444,7 @@ pub impl LoanKind {\n /// Creates and returns a new root_map\n \n impl to_bytes::IterBytes for root_map_key {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.id, &self.derefs, lsb0, f);\n     }\n }"}, {"sha": "2b16ccdd1d22025bc0ca3ee31c43131d9f4523ef", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -534,7 +534,7 @@ fn check_item_while_true(cx: ty::ctxt, it: @ast::item) {\n }\n \n fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n-    pure fn is_valid<T:cmp::Ord>(binop: ast::binop, v: T,\n+    fn is_valid<T:cmp::Ord>(binop: ast::binop, v: T,\n             min: T, max: T) -> bool {\n         match binop {\n             ast::lt => v <= max,\n@@ -546,7 +546,7 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n         }\n     }\n \n-    pure fn rev_binop(binop: ast::binop) -> ast::binop {\n+    fn rev_binop(binop: ast::binop) -> ast::binop {\n         match binop {\n             ast::lt => ast::gt,\n             ast::le => ast::ge,\n@@ -556,7 +556,7 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n         }\n     }\n \n-    pure fn int_ty_range(int_ty: ast::int_ty) -> (i64, i64) {\n+    fn int_ty_range(int_ty: ast::int_ty) -> (i64, i64) {\n         match int_ty {\n             ast::ty_i =>    (int::min_value as i64, int::max_value as i64),\n             ast::ty_char => (u32::min_value as i64, u32::max_value as i64),\n@@ -567,7 +567,7 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n         }\n     }\n \n-    pure fn uint_ty_range(uint_ty: ast::uint_ty) -> (u64, u64) {\n+    fn uint_ty_range(uint_ty: ast::uint_ty) -> (u64, u64) {\n         match uint_ty {\n             ast::ty_u =>   (uint::min_value as u64, uint::max_value as u64),\n             ast::ty_u8 =>  (u8::min_value   as u64, u8::max_value   as u64),\n@@ -622,7 +622,7 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n         }\n     }\n \n-    pure fn is_comparison(binop: ast::binop) -> bool {\n+    fn is_comparison(binop: ast::binop) -> bool {\n         match binop {\n             ast::eq | ast::lt | ast::le |\n             ast::ne | ast::ge | ast::gt => true,"}, {"sha": "0959e2eb0937ac54a5566e6b7ad7729d1c0fe6f1", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -141,13 +141,13 @@ struct Variable(uint);\n struct LiveNode(uint);\n \n impl cmp::Eq for Variable {\n-    pure fn eq(&self, other: &Variable) -> bool { *(*self) == *(*other) }\n-    pure fn ne(&self, other: &Variable) -> bool { *(*self) != *(*other) }\n+    fn eq(&self, other: &Variable) -> bool { *(*self) == *(*other) }\n+    fn ne(&self, other: &Variable) -> bool { *(*self) != *(*other) }\n }\n \n impl cmp::Eq for LiveNode {\n-    pure fn eq(&self, other: &LiveNode) -> bool { *(*self) == *(*other) }\n-    pure fn ne(&self, other: &LiveNode) -> bool { *(*self) != *(*other) }\n+    fn eq(&self, other: &LiveNode) -> bool { *(*self) == *(*other) }\n+    fn ne(&self, other: &LiveNode) -> bool { *(*self) != *(*other) }\n }\n \n enum LiveNodeKind {\n@@ -158,7 +158,7 @@ enum LiveNodeKind {\n }\n \n impl cmp::Eq for LiveNodeKind {\n-    pure fn eq(&self, other: &LiveNodeKind) -> bool {\n+    fn eq(&self, other: &LiveNodeKind) -> bool {\n         match (*self) {\n             FreeVarNode(e0a) => {\n                 match (*other) {\n@@ -186,7 +186,7 @@ impl cmp::Eq for LiveNodeKind {\n             }\n         }\n     }\n-    pure fn ne(&self, other: &LiveNodeKind) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &LiveNodeKind) -> bool { !(*self).eq(other) }\n }\n \n fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n@@ -224,11 +224,11 @@ pub fn check_crate(tcx: ty::ctxt,\n }\n \n impl to_str::ToStr for LiveNode {\n-    pure fn to_str(&self) -> ~str { fmt!(\"ln(%u)\", **self) }\n+    fn to_str(&self) -> ~str { fmt!(\"ln(%u)\", **self) }\n }\n \n impl to_str::ToStr for Variable {\n-    pure fn to_str(&self) -> ~str { fmt!(\"v(%u)\", **self) }\n+    fn to_str(&self) -> ~str { fmt!(\"v(%u)\", **self) }\n }\n \n // ______________________________________________________________________\n@@ -254,7 +254,7 @@ impl to_str::ToStr for Variable {\n // assignment.  And so forth.\n \n pub impl LiveNode {\n-    pure fn is_valid(&self) -> bool { **self != uint::max_value }\n+    fn is_valid(&self) -> bool { **self != uint::max_value }\n }\n \n fn invalid_node() -> LiveNode { LiveNode(uint::max_value) }"}, {"sha": "e767b0ff812f408c7939fe3dbf74246d6a92d5f6", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -305,7 +305,7 @@ pub struct mem_categorization_ctxt {\n }\n \n impl ToStr for MutabilityCategory {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         fmt!(\"%?\", *self)\n     }\n }"}, {"sha": "9517494e492b842e975bfcda33d4fcfdea26194b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -151,7 +151,7 @@ pub enum NamespaceResult {\n }\n \n pub impl NamespaceResult {\n-    pure fn is_unknown(&self) -> bool {\n+    fn is_unknown(&self) -> bool {\n         match *self {\n             UnknownResult => true,\n             _ => false"}, {"sha": "4d0ad2c19f1159d755732e54b657864124349782", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -41,10 +41,10 @@ enum x86_64_reg_class {\n }\n \n impl cmp::Eq for x86_64_reg_class {\n-    pure fn eq(&self, other: &x86_64_reg_class) -> bool {\n+    fn eq(&self, other: &x86_64_reg_class) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&self, other: &x86_64_reg_class) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &x86_64_reg_class) -> bool { !(*self).eq(other) }\n }\n \n fn is_sse(++c: x86_64_reg_class) -> bool {"}, {"sha": "c220bd23e20f0b84300ff6d048e7342eaad7ba4b", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -678,9 +678,9 @@ pub fn block_parent(cx: block) -> block {\n // Accessors\n \n pub impl block_ {\n-    pure fn ccx(@mut self) -> @CrateContext { *self.fcx.ccx }\n-    pure fn tcx(@mut self) -> ty::ctxt { self.fcx.ccx.tcx }\n-    pure fn sess(@mut self) -> Session { self.fcx.ccx.sess }\n+    fn ccx(@mut self) -> @CrateContext { *self.fcx.ccx }\n+    fn tcx(@mut self) -> ty::ctxt { self.fcx.ccx.tcx }\n+    fn sess(@mut self) -> Session { self.fcx.ccx.sess }\n \n     fn node_id_to_str(@mut self, id: ast::node_id) -> ~str {\n         ast_map::node_id_to_str(self.tcx().items, id, self.sess().intr())\n@@ -1290,7 +1290,7 @@ pub struct mono_id_ {\n pub type mono_id = @mono_id_;\n \n impl to_bytes::IterBytes for mono_param_id {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n             mono_precise(t, ref mids) =>\n                 to_bytes::iter_bytes_3(&0u8, &ty::type_id(t), mids, lsb0, f),\n@@ -1304,7 +1304,7 @@ impl to_bytes::IterBytes for mono_param_id {\n }\n \n impl to_bytes::IterBytes for mono_id_ {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.def, &self.params, lsb0, f);\n     }\n }"}, {"sha": "600f637f72b59cb43c4a2f9c6cbe05662cde4695", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -158,14 +158,14 @@ pub impl DatumMode {\n }\n \n impl cmp::Eq for DatumMode {\n-    pure fn eq(&self, other: &DatumMode) -> bool {\n+    fn eq(&self, other: &DatumMode) -> bool {\n         (*self) as uint == (*other as uint)\n     }\n-    pure fn ne(&self, other: &DatumMode) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &DatumMode) -> bool { !(*self).eq(other) }\n }\n \n impl to_bytes::IterBytes for DatumMode {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }"}, {"sha": "7cfa1ff49292a022d14bbf34f4515e11ddc6fd8d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -175,15 +175,15 @@ pub impl Dest {\n }\n \n impl cmp::Eq for Dest {\n-    pure fn eq(&self, other: &Dest) -> bool {\n+    fn eq(&self, other: &Dest) -> bool {\n         match ((*self), (*other)) {\n             (SaveIn(e0a), SaveIn(e0b)) => e0a == e0b,\n             (Ignore, Ignore) => true,\n             (SaveIn(*), _) => false,\n             (Ignore, _) => false,\n         }\n     }\n-    pure fn ne(&self, other: &Dest) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &Dest) -> bool { !(*self).eq(other) }\n }\n \n fn drop_and_cancel_clean(bcx: block, dat: Datum) -> block {\n@@ -1695,7 +1695,7 @@ pub enum cast_kind {\n }\n \n impl cmp::Eq for cast_kind {\n-    pure fn eq(&self, other: &cast_kind) -> bool {\n+    fn eq(&self, other: &cast_kind) -> bool {\n         match ((*self), (*other)) {\n             (cast_pointer, cast_pointer) => true,\n             (cast_integral, cast_integral) => true,\n@@ -1709,7 +1709,7 @@ impl cmp::Eq for cast_kind {\n             (cast_other, _) => false,\n         }\n     }\n-    pure fn ne(&self, other: &cast_kind) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &cast_kind) -> bool { !(*self).eq(other) }\n }\n \n pub fn cast_type_kind(t: ty::t) -> cast_kind {"}, {"sha": "bf5a699ed8237b8b688a5834dee151c618fc23e7", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -218,8 +218,8 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n     return t;\n }\n \n-pub pure fn cast_glue(ccx: @CrateContext, ti: @mut tydesc_info, v: ValueRef)\n-                   -> ValueRef {\n+pub fn cast_glue(ccx: @CrateContext, ti: @mut tydesc_info, v: ValueRef)\n+              -> ValueRef {\n     unsafe {\n         let llfnty = type_of_glue_fn(ccx, ti.ty);\n         llvm::LLVMConstPointerCast(v, T_ptr(llfnty))"}, {"sha": "08d8a148d6a33224f5fd283c8a55d9603595b57d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 75, "deletions": 75, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -121,7 +121,7 @@ pub struct creader_cache_key {\n type creader_cache = HashMap<creader_cache_key, t>;\n \n impl to_bytes::IterBytes for creader_cache_key {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_3(&self.cnum, &self.pos, &self.len, lsb0, f);\n     }\n }\n@@ -135,18 +135,18 @@ struct intern_key {\n // implementation will not recurse through sty and you will get stack\n // exhaustion.\n impl cmp::Eq for intern_key {\n-    pure fn eq(&self, other: &intern_key) -> bool {\n+    fn eq(&self, other: &intern_key) -> bool {\n         unsafe {\n             *self.sty == *other.sty && self.o_def_id == other.o_def_id\n         }\n     }\n-    pure fn ne(&self, other: &intern_key) -> bool {\n+    fn ne(&self, other: &intern_key) -> bool {\n         !self.eq(other)\n     }\n }\n \n impl to_bytes::IterBytes for intern_key {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         unsafe {\n             to_bytes::iter_bytes_2(&*self.sty, &self.o_def_id, lsb0, f);\n         }\n@@ -165,7 +165,7 @@ pub type opt_region_variance = Option<region_variance>;\n pub enum region_variance { rv_covariant, rv_invariant, rv_contravariant }\n \n impl cmp::Eq for region_variance {\n-    pure fn eq(&self, other: &region_variance) -> bool {\n+    fn eq(&self, other: &region_variance) -> bool {\n         match ((*self), (*other)) {\n             (rv_covariant, rv_covariant) => true,\n             (rv_invariant, rv_invariant) => true,\n@@ -175,7 +175,7 @@ impl cmp::Eq for region_variance {\n             (rv_contravariant, _) => false\n         }\n     }\n-    pure fn ne(&self, other: &region_variance) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &region_variance) -> bool { !(*self).eq(other) }\n }\n \n #[auto_encode]\n@@ -334,7 +334,7 @@ struct t_box_ {\n enum t_opaque {}\n pub type t = *t_opaque;\n \n-pub pure fn get(t: t) -> t_box {\n+pub fn get(t: t) -> t_box {\n     unsafe {\n         let t2 = cast::reinterpret_cast::<t, t_box>(&t);\n         let t3 = t2;\n@@ -343,21 +343,21 @@ pub pure fn get(t: t) -> t_box {\n     }\n }\n \n-pub pure fn tbox_has_flag(tb: t_box, flag: tbox_flag) -> bool {\n+pub fn tbox_has_flag(tb: t_box, flag: tbox_flag) -> bool {\n     (tb.flags & (flag as uint)) != 0u\n }\n-pub pure fn type_has_params(t: t) -> bool {\n+pub fn type_has_params(t: t) -> bool {\n     tbox_has_flag(get(t), has_params)\n }\n-pub pure fn type_has_self(t: t) -> bool { tbox_has_flag(get(t), has_self) }\n-pub pure fn type_needs_infer(t: t) -> bool {\n+pub fn type_has_self(t: t) -> bool { tbox_has_flag(get(t), has_self) }\n+pub fn type_needs_infer(t: t) -> bool {\n     tbox_has_flag(get(t), needs_infer)\n }\n-pub pure fn type_has_regions(t: t) -> bool {\n+pub fn type_has_regions(t: t) -> bool {\n     tbox_has_flag(get(t), has_regions)\n }\n-pub pure fn type_def_id(t: t) -> Option<ast::def_id> { get(t).o_def_id }\n-pub pure fn type_id(t: t) -> uint { get(t).id }\n+pub fn type_def_id(t: t) -> Option<ast::def_id> { get(t).o_def_id }\n+pub fn type_id(t: t) -> uint { get(t).id }\n \n #[deriving(Eq)]\n pub struct BareFnTy {\n@@ -388,13 +388,13 @@ pub struct FnSig {\n }\n \n impl to_bytes::IterBytes for BareFnTy {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_3(&self.purity, &self.abi, &self.sig, lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for ClosureTy {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_5(&self.purity, &self.sigil, &self.onceness,\n                                &self.region, &self.sig, lsb0, f)\n     }\n@@ -407,7 +407,7 @@ pub struct param_ty {\n }\n \n impl to_bytes::IterBytes for param_ty {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.idx, &self.def_id, lsb0, f)\n     }\n }\n@@ -616,7 +616,7 @@ pub enum InferTy {\n }\n \n impl to_bytes::IterBytes for InferTy {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           TyVar(ref tv) => to_bytes::iter_bytes_2(&0u8, tv, lsb0, f),\n           IntVar(ref iv) => to_bytes::iter_bytes_2(&1u8, iv, lsb0, f),\n@@ -633,7 +633,7 @@ pub enum InferRegion {\n }\n \n impl to_bytes::IterBytes for InferRegion {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n             ReVar(ref rv) => to_bytes::iter_bytes_2(&0u8, rv, lsb0, f),\n             ReSkolemized(ref v, _) => to_bytes::iter_bytes_2(&1u8, v, lsb0, f)\n@@ -642,7 +642,7 @@ impl to_bytes::IterBytes for InferRegion {\n }\n \n impl cmp::Eq for InferRegion {\n-    pure fn eq(&self, other: &InferRegion) -> bool {\n+    fn eq(&self, other: &InferRegion) -> bool {\n         match ((*self), *other) {\n             (ReVar(rva), ReVar(rvb)) => {\n                 rva == rvb\n@@ -653,13 +653,13 @@ impl cmp::Eq for InferRegion {\n             _ => false\n         }\n     }\n-    pure fn ne(&self, other: &InferRegion) -> bool {\n+    fn ne(&self, other: &InferRegion) -> bool {\n         !((*self) == (*other))\n     }\n }\n \n impl to_bytes::IterBytes for param_bound {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           bound_copy => 0u8.iter_bytes(lsb0, f),\n           bound_durable => 1u8.iter_bytes(lsb0, f),\n@@ -672,50 +672,50 @@ impl to_bytes::IterBytes for param_bound {\n }\n \n pub trait Vid {\n-    pure fn to_uint(&self) -> uint;\n+    fn to_uint(&self) -> uint;\n }\n \n impl Vid for TyVid {\n-    pure fn to_uint(&self) -> uint { **self }\n+    fn to_uint(&self) -> uint { **self }\n }\n \n impl ToStr for TyVid {\n-    pure fn to_str(&self) -> ~str { fmt!(\"<V%u>\", self.to_uint()) }\n+    fn to_str(&self) -> ~str { fmt!(\"<V%u>\", self.to_uint()) }\n }\n \n impl Vid for IntVid {\n-    pure fn to_uint(&self) -> uint { **self }\n+    fn to_uint(&self) -> uint { **self }\n }\n \n impl ToStr for IntVid {\n-    pure fn to_str(&self) -> ~str { fmt!(\"<VI%u>\", self.to_uint()) }\n+    fn to_str(&self) -> ~str { fmt!(\"<VI%u>\", self.to_uint()) }\n }\n \n impl Vid for FloatVid {\n-    pure fn to_uint(&self) -> uint { **self }\n+    fn to_uint(&self) -> uint { **self }\n }\n \n impl ToStr for FloatVid {\n-    pure fn to_str(&self) -> ~str { fmt!(\"<VF%u>\", self.to_uint()) }\n+    fn to_str(&self) -> ~str { fmt!(\"<VF%u>\", self.to_uint()) }\n }\n \n impl Vid for RegionVid {\n-    pure fn to_uint(&self) -> uint { self.id }\n+    fn to_uint(&self) -> uint { self.id }\n }\n \n impl ToStr for RegionVid {\n-    pure fn to_str(&self) -> ~str { fmt!(\"%?\", self.id) }\n+    fn to_str(&self) -> ~str { fmt!(\"%?\", self.id) }\n }\n \n impl ToStr for FnSig {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         // grr, without tcx not much we can do.\n         return ~\"(...)\";\n     }\n }\n \n impl ToStr for InferTy {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         match *self {\n             TyVar(ref v) => v.to_str(),\n             IntVar(ref v) => v.to_str(),\n@@ -725,7 +725,7 @@ impl ToStr for InferTy {\n }\n \n impl ToStr for IntVarValue {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         match *self {\n             IntType(ref v) => v.to_str(),\n             UintType(ref v) => v.to_str(),\n@@ -734,25 +734,25 @@ impl ToStr for IntVarValue {\n }\n \n impl to_bytes::IterBytes for TyVid {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for IntVid {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for FloatVid {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for RegionVid {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n@@ -1112,7 +1112,7 @@ pub fn mk_with_id(cx: ctxt, base: t, def_id: ast::def_id) -> t {\n }\n \n // Converts s to its machine type equivalent\n-pub pure fn mach_sty(cfg: @session::config, t: t) -> sty {\n+pub fn mach_sty(cfg: @session::config, t: t) -> sty {\n     match get(t).sty {\n       ty_int(ast::ty_i) => ty_int(cfg.int_type),\n       ty_uint(ast::ty_u) => ty_uint(cfg.uint_type),\n@@ -1532,58 +1532,58 @@ pub fn get_element_type(ty: t, i: uint) -> t {\n     }\n }\n \n-pub pure fn type_is_box(ty: t) -> bool {\n+pub fn type_is_box(ty: t) -> bool {\n     match get(ty).sty {\n       ty_box(_) => return true,\n       _ => return false\n     }\n }\n \n-pub pure fn type_is_boxed(ty: t) -> bool {\n+pub fn type_is_boxed(ty: t) -> bool {\n     match get(ty).sty {\n       ty_box(_) | ty_opaque_box |\n       ty_evec(_, vstore_box) | ty_estr(vstore_box) => true,\n       _ => false\n     }\n }\n \n-pub pure fn type_is_region_ptr(ty: t) -> bool {\n+pub fn type_is_region_ptr(ty: t) -> bool {\n     match get(ty).sty {\n       ty_rptr(_, _) => true,\n       _ => false\n     }\n }\n \n-pub pure fn type_is_slice(ty: t) -> bool {\n+pub fn type_is_slice(ty: t) -> bool {\n     match get(ty).sty {\n       ty_evec(_, vstore_slice(_)) | ty_estr(vstore_slice(_)) => true,\n       _ => return false\n     }\n }\n \n-pub pure fn type_is_unique_box(ty: t) -> bool {\n+pub fn type_is_unique_box(ty: t) -> bool {\n     match get(ty).sty {\n       ty_uniq(_) => return true,\n       _ => return false\n     }\n }\n \n-pub pure fn type_is_unsafe_ptr(ty: t) -> bool {\n+pub fn type_is_unsafe_ptr(ty: t) -> bool {\n     match get(ty).sty {\n       ty_ptr(_) => return true,\n       _ => return false\n     }\n }\n \n-pub pure fn type_is_vec(ty: t) -> bool {\n+pub fn type_is_vec(ty: t) -> bool {\n     return match get(ty).sty {\n           ty_evec(_, _) | ty_unboxed_vec(_) => true,\n           ty_estr(_) => true,\n           _ => false\n         };\n }\n \n-pub pure fn type_is_unique(ty: t) -> bool {\n+pub fn type_is_unique(ty: t) -> bool {\n     match get(ty).sty {\n         ty_uniq(_) |\n         ty_evec(_, vstore_uniq) |\n@@ -1598,7 +1598,7 @@ pub pure fn type_is_unique(ty: t) -> bool {\n  (A ty_ptr is scalar because it represents a non-managed pointer, so its\n  contents are abstract to rustc.)\n */\n-pub pure fn type_is_scalar(ty: t) -> bool {\n+pub fn type_is_scalar(ty: t) -> bool {\n     match get(ty).sty {\n       ty_nil | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_infer(IntVar(_)) | ty_infer(FloatVar(_)) | ty_type |\n@@ -1783,19 +1783,19 @@ pub impl TypeContents {\n }\n \n impl ops::Add<TypeContents,TypeContents> for TypeContents {\n-    pure fn add(&self, other: &TypeContents) -> TypeContents {\n+    fn add(&self, other: &TypeContents) -> TypeContents {\n         TypeContents {bits: self.bits | other.bits}\n     }\n }\n \n impl ops::Sub<TypeContents,TypeContents> for TypeContents {\n-    pure fn sub(&self, other: &TypeContents) -> TypeContents {\n+    fn sub(&self, other: &TypeContents) -> TypeContents {\n         TypeContents {bits: self.bits & !other.bits}\n     }\n }\n \n impl ToStr for TypeContents {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         fmt!(\"TypeContents(%s)\", u32::to_str_radix(self.bits, 2))\n     }\n }\n@@ -2534,7 +2534,7 @@ pub fn index_sty(cx: ctxt, sty: &sty) -> Option<mt> {\n }\n \n impl to_bytes::IterBytes for bound_region {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           ty::br_self => 0u8.iter_bytes(lsb0, f),\n \n@@ -2554,7 +2554,7 @@ impl to_bytes::IterBytes for bound_region {\n }\n \n impl to_bytes::IterBytes for Region {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           re_bound(ref br) =>\n           to_bytes::iter_bytes_2(&0u8, br, lsb0, f),\n@@ -2574,7 +2574,7 @@ impl to_bytes::IterBytes for Region {\n }\n \n impl to_bytes::IterBytes for vstore {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           vstore_fixed(ref u) =>\n           to_bytes::iter_bytes_2(&0u8, u, lsb0, f),\n@@ -2589,7 +2589,7 @@ impl to_bytes::IterBytes for vstore {\n }\n \n impl to_bytes::IterBytes for TraitStore {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           BareTraitStore => 0u8.iter_bytes(lsb0, f),\n           UniqTraitStore => 1u8.iter_bytes(lsb0, f),\n@@ -2600,44 +2600,44 @@ impl to_bytes::IterBytes for TraitStore {\n }\n \n impl to_bytes::IterBytes for substs {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_3(&self.self_r,\n                                  &self.self_ty,\n                                  &self.tps, lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for mt {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_2(&self.ty,\n                                  &self.mutbl, lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for field {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n           to_bytes::iter_bytes_2(&self.ident,\n                                  &self.mt, lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for arg {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.mode,\n                                &self.ty, lsb0, f)\n     }\n }\n \n impl to_bytes::IterBytes for FnSig {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.inputs,\n                                &self.output,\n                                lsb0, f);\n     }\n }\n \n impl to_bytes::IterBytes for sty {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           ty_nil => 0u8.iter_bytes(lsb0, f),\n           ty_bool => 1u8.iter_bytes(lsb0, f),\n@@ -2768,7 +2768,7 @@ pub fn ty_fn_purity(fty: t) -> ast::purity {\n     }\n }\n \n-pub pure fn ty_fn_ret(fty: t) -> t {\n+pub fn ty_fn_ret(fty: t) -> t {\n     match get(fty).sty {\n         ty_bare_fn(ref f) => f.sig.output,\n         ty_closure(ref f) => f.sig.output,\n@@ -2786,7 +2786,7 @@ pub fn is_fn_ty(fty: t) -> bool {\n     }\n }\n \n-pub pure fn ty_vstore(ty: t) -> vstore {\n+pub fn ty_vstore(ty: t) -> vstore {\n     match get(ty).sty {\n         ty_evec(_, vstore) => vstore,\n         ty_estr(vstore) => vstore,\n@@ -3716,13 +3716,13 @@ pub enum DtorKind {\n }\n \n pub impl DtorKind {\n-    pure fn is_not_present(&const self) -> bool {\n+    fn is_not_present(&const self) -> bool {\n         match *self {\n             NoDtor => true,\n             _ => false\n         }\n     }\n-    pure fn is_present(&const self) -> bool {\n+    fn is_present(&const self) -> bool {\n         !self.is_not_present()\n     }\n }\n@@ -4000,7 +4000,7 @@ pub fn lookup_struct_field(cx: ctxt,\n     }\n }\n \n-pure fn is_public(f: field_ty) -> bool {\n+fn is_public(f: field_ty) -> bool {\n     // XXX: This is wrong.\n     match f.vis {\n         public | inherited => true,\n@@ -4260,7 +4260,7 @@ pub fn eval_repeat_count(tcx: ctxt, count_expr: @ast::expr) -> uint {\n }\n \n // Determine what purity to check a nested function under\n-pub pure fn determine_inherited_purity(parent_purity: ast::purity,\n+pub fn determine_inherited_purity(parent_purity: ast::purity,\n                                        child_purity: ast::purity,\n                                        child_sigil: ast::Sigil)\n                                     -> ast::purity {\n@@ -4364,14 +4364,14 @@ pub fn get_impl_id(tcx: ctxt, trait_id: def_id, self_ty: t) -> def_id {\n }\n \n impl cmp::Eq for mt {\n-    pure fn eq(&self, other: &mt) -> bool {\n+    fn eq(&self, other: &mt) -> bool {\n         (*self).ty == (*other).ty && (*self).mutbl == (*other).mutbl\n     }\n-    pure fn ne(&self, other: &mt) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &mt) -> bool { !(*self).eq(other) }\n }\n \n impl cmp::Eq for Region {\n-    pure fn eq(&self, other: &Region) -> bool {\n+    fn eq(&self, other: &Region) -> bool {\n         match (*self) {\n             re_bound(e0a) => {\n                 match (*other) {\n@@ -4405,11 +4405,11 @@ impl cmp::Eq for Region {\n             }\n         }\n     }\n-    pure fn ne(&self, other: &Region) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &Region) -> bool { !(*self).eq(other) }\n }\n \n impl cmp::Eq for bound_region {\n-    pure fn eq(&self, other: &bound_region) -> bool {\n+    fn eq(&self, other: &bound_region) -> bool {\n         match (*self) {\n             br_self => {\n                 match (*other) {\n@@ -4443,11 +4443,11 @@ impl cmp::Eq for bound_region {\n             }\n         }\n     }\n-    pure fn ne(&self, other: &bound_region) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &bound_region) -> bool { !(*self).eq(other) }\n }\n \n impl cmp::Eq for param_bound {\n-    pure fn eq(&self, other: &param_bound) -> bool {\n+    fn eq(&self, other: &param_bound) -> bool {\n         match (*self) {\n             bound_copy => {\n                 match (*other) {\n@@ -4481,7 +4481,7 @@ impl cmp::Eq for param_bound {\n             }\n         }\n     }\n-    pure fn ne(&self, other: &param_bound) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &param_bound) -> bool { !self.eq(other) }\n }\n \n // Local Variables:"}, {"sha": "f0b5ce9ff60a5cf02b8f271cf43b4e362d78182f", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -563,7 +563,7 @@ enum Constraint {\n }\n \n impl cmp::Eq for Constraint {\n-    pure fn eq(&self, other: &Constraint) -> bool {\n+    fn eq(&self, other: &Constraint) -> bool {\n         match ((*self), (*other)) {\n             (ConstrainVarSubVar(v0a, v1a), ConstrainVarSubVar(v0b, v1b)) => {\n                 v0a == v0b && v1a == v1b\n@@ -579,11 +579,11 @@ impl cmp::Eq for Constraint {\n             (ConstrainVarSubReg(*), _) => false\n         }\n     }\n-    pure fn ne(&self, other: &Constraint) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &Constraint) -> bool { !(*self).eq(other) }\n }\n \n impl to_bytes::IterBytes for Constraint {\n-   pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+   fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           ConstrainVarSubVar(ref v0, ref v1) =>\n           to_bytes::iter_bytes_3(&0u8, v0, v1, lsb0, f),\n@@ -603,14 +603,14 @@ struct TwoRegions {\n }\n \n impl cmp::Eq for TwoRegions {\n-    pure fn eq(&self, other: &TwoRegions) -> bool {\n+    fn eq(&self, other: &TwoRegions) -> bool {\n         (*self).a == (*other).a && (*self).b == (*other).b\n     }\n-    pure fn ne(&self, other: &TwoRegions) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &TwoRegions) -> bool { !(*self).eq(other) }\n }\n \n impl to_bytes::IterBytes for TwoRegions {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.a, &self.b, lsb0, f)\n     }\n }"}, {"sha": "c37d9d1c1c4f7ff72fc0f1014f52d7282679cfed", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -88,7 +88,7 @@ impl<D:Decoder> Decodable<D> for ident {\n }\n \n impl to_bytes::IterBytes for ident {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         self.repr.iter_bytes(lsb0, f)\n     }\n }\n@@ -274,7 +274,7 @@ pub enum binding_mode {\n }\n \n impl to_bytes::IterBytes for binding_mode {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           bind_by_copy => 0u8.iter_bytes(lsb0, f),\n \n@@ -320,7 +320,7 @@ pub enum pat_ {\n pub enum mutability { m_mutbl, m_imm, m_const, }\n \n impl to_bytes::IterBytes for mutability {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -333,13 +333,13 @@ pub enum Abi {\n }\n \n impl to_bytes::IterBytes for Abi {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n \n impl ToStr for Abi {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         match *self {\n             RustAbi => ~\"\\\"rust\\\"\"\n         }\n@@ -356,13 +356,13 @@ pub enum Sigil {\n }\n \n impl to_bytes::IterBytes for Sigil {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f)\n     }\n }\n \n impl ToStr for Sigil {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         match *self {\n             BorrowedSigil => ~\"&\",\n             OwnedSigil => ~\"~\",\n@@ -440,7 +440,7 @@ pub enum inferable<T> {\n }\n \n impl<T:to_bytes::IterBytes> to_bytes::IterBytes for inferable<T> {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n           expl(ref t) =>\n           to_bytes::iter_bytes_2(&0u8, t, lsb0, f),\n@@ -458,7 +458,7 @@ impl<T:to_bytes::IterBytes> to_bytes::IterBytes for inferable<T> {\n pub enum rmode { by_ref, by_copy }\n \n impl to_bytes::IterBytes for rmode {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -796,13 +796,13 @@ pub enum trait_method {\n pub enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n impl ToStr for int_ty {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         ::ast_util::int_ty_to_str(*self)\n     }\n }\n \n impl to_bytes::IterBytes for int_ty {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -813,13 +813,13 @@ impl to_bytes::IterBytes for int_ty {\n pub enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n impl ToStr for uint_ty {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         ::ast_util::uint_ty_to_str(*self)\n     }\n }\n \n impl to_bytes::IterBytes for uint_ty {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -830,13 +830,13 @@ impl to_bytes::IterBytes for uint_ty {\n pub enum float_ty { ty_f, ty_f32, ty_f64, }\n \n impl ToStr for float_ty {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         ::ast_util::float_ty_to_str(*self)\n     }\n }\n \n impl to_bytes::IterBytes for float_ty {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -872,7 +872,7 @@ pub enum Onceness {\n }\n \n impl ToStr for Onceness {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         match *self {\n             Once => ~\"once\",\n             Many => ~\"many\"\n@@ -881,7 +881,7 @@ impl ToStr for Onceness {\n }\n \n impl to_bytes::IterBytes for Onceness {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n     }\n }\n@@ -930,7 +930,7 @@ pub enum ty_ {\n }\n \n impl to_bytes::IterBytes for Ty {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f);\n     }\n }\n@@ -966,7 +966,7 @@ pub enum purity {\n }\n \n impl ToStr for purity {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         match *self {\n             impure_fn => ~\"impure\",\n             unsafe_fn => ~\"unsafe\",\n@@ -977,7 +977,7 @@ impl ToStr for purity {\n }\n \n impl to_bytes::IterBytes for purity {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -992,7 +992,7 @@ pub enum ret_style {\n }\n \n impl to_bytes::IterBytes for ret_style {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n@@ -1278,7 +1278,7 @@ pub enum item_ {\n pub enum struct_mutability { struct_mutable, struct_immutable }\n \n impl to_bytes::IterBytes for struct_mutability {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }"}, {"sha": "8989bb88cd7f469531186f80ce3a889b0f98a09b", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -33,7 +33,7 @@ pub enum path_elt {\n }\n \n impl cmp::Eq for path_elt {\n-    pure fn eq(&self, other: &path_elt) -> bool {\n+    fn eq(&self, other: &path_elt) -> bool {\n         match (*self) {\n             path_mod(e0a) => {\n                 match (*other) {\n@@ -49,7 +49,7 @@ impl cmp::Eq for path_elt {\n             }\n         }\n     }\n-    pure fn ne(&self, other: &path_elt) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &path_elt) -> bool { !(*self).eq(other) }\n }\n \n pub type path = ~[path_elt];"}, {"sha": "764393e0feb6e0a21adb38cedfdde6fc6fcc7bab", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -24,22 +24,21 @@ use core::str;\n use core::to_bytes;\n use core::vec;\n \n-pub pure fn path_name_i(idents: &[ident], intr: @token::ident_interner)\n-                     -> ~str {\n+pub fn path_name_i(idents: &[ident], intr: @token::ident_interner) -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n     str::connect(idents.map(|i| copy *intr.get(*i)), ~\"::\")\n }\n \n \n-pub pure fn path_to_ident(p: @path) -> ident { copy *p.idents.last() }\n+pub fn path_to_ident(p: @path) -> ident { copy *p.idents.last() }\n \n-pub pure fn local_def(id: node_id) -> def_id {\n+pub fn local_def(id: node_id) -> def_id {\n     ast::def_id { crate: local_crate, node: id }\n }\n \n-pub pure fn is_local(did: ast::def_id) -> bool { did.crate == local_crate }\n+pub fn is_local(did: ast::def_id) -> bool { did.crate == local_crate }\n \n-pub pure fn stmt_id(s: stmt) -> node_id {\n+pub fn stmt_id(s: stmt) -> node_id {\n     match s.node {\n       stmt_decl(_, id) => id,\n       stmt_expr(_, id) => id,\n@@ -57,7 +56,7 @@ pub fn variant_def_ids(d: def) -> (def_id, def_id) {\n     }\n }\n \n-pub pure fn def_id_of_def(d: def) -> def_id {\n+pub fn def_id_of_def(d: def) -> def_id {\n     match d {\n       def_fn(id, _) | def_static_method(id, _, _) | def_mod(id) |\n       def_foreign_mod(id) | def_const(id) |\n@@ -75,7 +74,7 @@ pub pure fn def_id_of_def(d: def) -> def_id {\n     }\n }\n \n-pub pure fn binop_to_str(op: binop) -> ~str {\n+pub fn binop_to_str(op: binop) -> ~str {\n     match op {\n       add => return ~\"+\",\n       subtract => return ~\"-\",\n@@ -98,7 +97,7 @@ pub pure fn binop_to_str(op: binop) -> ~str {\n     }\n }\n \n-pub pure fn binop_to_method_name(op: binop) -> Option<~str> {\n+pub fn binop_to_method_name(op: binop) -> Option<~str> {\n     match op {\n       add => return Some(~\"add\"),\n       subtract => return Some(~\"sub\"),\n@@ -120,23 +119,23 @@ pub pure fn binop_to_method_name(op: binop) -> Option<~str> {\n     }\n }\n \n-pub pure fn lazy_binop(b: binop) -> bool {\n+pub fn lazy_binop(b: binop) -> bool {\n     match b {\n       and => true,\n       or => true,\n       _ => false\n     }\n }\n \n-pub pure fn is_shift_binop(b: binop) -> bool {\n+pub fn is_shift_binop(b: binop) -> bool {\n     match b {\n       shl => true,\n       shr => true,\n       _ => false\n     }\n }\n \n-pub pure fn unop_to_str(op: unop) -> ~str {\n+pub fn unop_to_str(op: unop) -> ~str {\n     match op {\n       box(mt) => if mt == m_mutbl { ~\"@mut \" } else { ~\"@\" },\n       uniq(mt) => if mt == m_mutbl { ~\"~mut \" } else { ~\"~\" },\n@@ -146,11 +145,11 @@ pub pure fn unop_to_str(op: unop) -> ~str {\n     }\n }\n \n-pub pure fn is_path(e: @expr) -> bool {\n+pub fn is_path(e: @expr) -> bool {\n     return match e.node { expr_path(_) => true, _ => false };\n }\n \n-pub pure fn int_ty_to_str(t: int_ty) -> ~str {\n+pub fn int_ty_to_str(t: int_ty) -> ~str {\n     match t {\n       ty_char => ~\"u8\", // ???\n       ty_i => ~\"\",\n@@ -161,7 +160,7 @@ pub pure fn int_ty_to_str(t: int_ty) -> ~str {\n     }\n }\n \n-pub pure fn int_ty_max(t: int_ty) -> u64 {\n+pub fn int_ty_max(t: int_ty) -> u64 {\n     match t {\n       ty_i8 => 0x80u64,\n       ty_i16 => 0x8000u64,\n@@ -170,7 +169,7 @@ pub pure fn int_ty_max(t: int_ty) -> u64 {\n     }\n }\n \n-pub pure fn uint_ty_to_str(t: uint_ty) -> ~str {\n+pub fn uint_ty_to_str(t: uint_ty) -> ~str {\n     match t {\n       ty_u => ~\"u\",\n       ty_u8 => ~\"u8\",\n@@ -180,7 +179,7 @@ pub pure fn uint_ty_to_str(t: uint_ty) -> ~str {\n     }\n }\n \n-pub pure fn uint_ty_max(t: uint_ty) -> u64 {\n+pub fn uint_ty_max(t: uint_ty) -> u64 {\n     match t {\n       ty_u8 => 0xffu64,\n       ty_u16 => 0xffffu64,\n@@ -189,18 +188,18 @@ pub pure fn uint_ty_max(t: uint_ty) -> u64 {\n     }\n }\n \n-pub pure fn float_ty_to_str(t: float_ty) -> ~str {\n+pub fn float_ty_to_str(t: float_ty) -> ~str {\n     match t { ty_f => ~\"f\", ty_f32 => ~\"f32\", ty_f64 => ~\"f64\" }\n }\n \n-pub pure fn is_call_expr(e: @expr) -> bool {\n+pub fn is_call_expr(e: @expr) -> bool {\n     match e.node { expr_call(_, _, _) => true, _ => false }\n }\n \n // This makes def_id hashable\n impl to_bytes::IterBytes for def_id {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.crate, &self.node, lsb0, f);\n     }\n }\n@@ -238,14 +237,14 @@ pub fn ident_to_pat(id: node_id, s: span, +i: ident) -> @pat {\n                 span: s }\n }\n \n-pub pure fn is_unguarded(a: &arm) -> bool {\n+pub fn is_unguarded(a: &arm) -> bool {\n     match a.guard {\n       None => true,\n       _    => false\n     }\n }\n \n-pub pure fn unguarded_pat(a: &arm) -> Option<~[@pat]> {\n+pub fn unguarded_pat(a: &arm) -> Option<~[@pat]> {\n     if is_unguarded(a) { Some(/* FIXME (#2543) */ copy a.pats) } else { None }\n }\n \n@@ -290,7 +289,7 @@ pub fn split_trait_methods(trait_methods: &[trait_method])\n     (reqd, provd)\n }\n \n-pub pure fn struct_field_visibility(field: ast::struct_field) -> visibility {\n+pub fn struct_field_visibility(field: ast::struct_field) -> visibility {\n     match field.node.kind {\n         ast::named_field(_, _, visibility) => visibility,\n         ast::unnamed_field => ast::public\n@@ -509,7 +508,7 @@ pub fn compute_id_range_for_inlined_item(item: inlined_item) -> id_range {\n     compute_id_range(|f| visit_ids_for_inlined_item(item, f))\n }\n \n-pub pure fn is_item_impl(item: @ast::item) -> bool {\n+pub fn is_item_impl(item: @ast::item) -> bool {\n     match item.node {\n        item_impl(*) => true,\n        _            => false"}, {"sha": "b22d71afaed2dc72a485df537d2298c9cf58ee06", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -89,11 +89,11 @@ pub fn desugar_doc_attr(attr: &ast::attribute) -> ast::attribute {\n \n /* Accessors */\n \n-pub pure fn get_attr_name(attr: &ast::attribute) -> @~str {\n+pub fn get_attr_name(attr: &ast::attribute) -> @~str {\n     get_meta_item_name(attr.node.value)\n }\n \n-pub pure fn get_meta_item_name(meta: @ast::meta_item) -> @~str {\n+pub fn get_meta_item_name(meta: @ast::meta_item) -> @~str {\n     match meta.node {\n         ast::meta_word(n) => n,\n         ast::meta_name_value(n, _) => n,\n@@ -333,10 +333,10 @@ pub enum inline_attr {\n }\n \n impl cmp::Eq for inline_attr {\n-    pure fn eq(&self, other: &inline_attr) -> bool {\n+    fn eq(&self, other: &inline_attr) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&self, other: &inline_attr) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &inline_attr) -> bool { !(*self).eq(other) }\n }\n \n /// True if something like #[inline] is found in the list of attrs."}, {"sha": "c082f4c08385038870adbfb1cda01bd4c59173e1", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -30,8 +30,8 @@ use core::uint;\n use std::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n pub trait Pos {\n-    pure fn from_uint(n: uint) -> Self;\n-    pure fn to_uint(&self) -> uint;\n+    fn from_uint(n: uint) -> Self;\n+    fn to_uint(&self) -> uint;\n }\n \n /// A byte offset\n@@ -45,71 +45,71 @@ pub struct CharPos(uint);\n // have been unsuccessful\n \n impl Pos for BytePos {\n-    pure fn from_uint(n: uint) -> BytePos { BytePos(n) }\n-    pure fn to_uint(&self) -> uint { **self }\n+    fn from_uint(n: uint) -> BytePos { BytePos(n) }\n+    fn to_uint(&self) -> uint { **self }\n }\n \n impl cmp::Eq for BytePos {\n-    pure fn eq(&self, other: &BytePos) -> bool { **self == **other }\n-    pure fn ne(&self, other: &BytePos) -> bool { !(*self).eq(other) }\n+    fn eq(&self, other: &BytePos) -> bool { **self == **other }\n+    fn ne(&self, other: &BytePos) -> bool { !(*self).eq(other) }\n }\n \n impl cmp::Ord for BytePos {\n-    pure fn lt(&self, other: &BytePos) -> bool { **self < **other }\n-    pure fn le(&self, other: &BytePos) -> bool { **self <= **other }\n-    pure fn ge(&self, other: &BytePos) -> bool { **self >= **other }\n-    pure fn gt(&self, other: &BytePos) -> bool { **self > **other }\n+    fn lt(&self, other: &BytePos) -> bool { **self < **other }\n+    fn le(&self, other: &BytePos) -> bool { **self <= **other }\n+    fn ge(&self, other: &BytePos) -> bool { **self >= **other }\n+    fn gt(&self, other: &BytePos) -> bool { **self > **other }\n }\n \n impl Add<BytePos, BytePos> for BytePos {\n-    pure fn add(&self, rhs: &BytePos) -> BytePos {\n+    fn add(&self, rhs: &BytePos) -> BytePos {\n         BytePos(**self + **rhs)\n     }\n }\n \n impl Sub<BytePos, BytePos> for BytePos {\n-    pure fn sub(&self, rhs: &BytePos) -> BytePos {\n+    fn sub(&self, rhs: &BytePos) -> BytePos {\n         BytePos(**self - **rhs)\n     }\n }\n \n impl to_bytes::IterBytes for BytePos {\n-    pure fn iter_bytes(&self, +lsb0: bool, &&f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, &&f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n \n impl Pos for CharPos {\n-    pure fn from_uint(n: uint) -> CharPos { CharPos(n) }\n-    pure fn to_uint(&self) -> uint { **self }\n+    fn from_uint(n: uint) -> CharPos { CharPos(n) }\n+    fn to_uint(&self) -> uint { **self }\n }\n \n impl cmp::Eq for CharPos {\n-    pure fn eq(&self, other: &CharPos) -> bool { **self == **other }\n-    pure fn ne(&self, other: &CharPos) -> bool { !(*self).eq(other) }\n+    fn eq(&self, other: &CharPos) -> bool { **self == **other }\n+    fn ne(&self, other: &CharPos) -> bool { !(*self).eq(other) }\n }\n \n impl cmp::Ord for CharPos {\n-    pure fn lt(&self, other: &CharPos) -> bool { **self < **other }\n-    pure fn le(&self, other: &CharPos) -> bool { **self <= **other }\n-    pure fn ge(&self, other: &CharPos) -> bool { **self >= **other }\n-    pure fn gt(&self, other: &CharPos) -> bool { **self > **other }\n+    fn lt(&self, other: &CharPos) -> bool { **self < **other }\n+    fn le(&self, other: &CharPos) -> bool { **self <= **other }\n+    fn ge(&self, other: &CharPos) -> bool { **self >= **other }\n+    fn gt(&self, other: &CharPos) -> bool { **self > **other }\n }\n \n impl to_bytes::IterBytes for CharPos {\n-    pure fn iter_bytes(&self, +lsb0: bool, &&f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, &&f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n \n impl Add<CharPos,CharPos> for CharPos {\n-    pure fn add(&self, rhs: &CharPos) -> CharPos {\n+    fn add(&self, rhs: &CharPos) -> CharPos {\n         CharPos(**self + **rhs)\n     }\n }\n \n impl Sub<CharPos,CharPos> for CharPos {\n-    pure fn sub(&self, rhs: &CharPos) -> CharPos {\n+    fn sub(&self, rhs: &CharPos) -> CharPos {\n         CharPos(**self - **rhs)\n     }\n }\n@@ -132,10 +132,10 @@ pub struct span {\n pub struct spanned<T> { node: T, span: span }\n \n impl cmp::Eq for span {\n-    pure fn eq(&self, other: &span) -> bool {\n+    fn eq(&self, other: &span) -> bool {\n         return (*self).lo == (*other).lo && (*self).hi == (*other).hi;\n     }\n-    pure fn ne(&self, other: &span) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &span) -> bool { !(*self).eq(other) }\n }\n \n impl<S:Encoder> Encodable<S> for span {\n@@ -149,25 +149,25 @@ impl<D:Decoder> Decodable<D> for span {\n     }\n }\n \n-pub pure fn spanned<T>(+lo: BytePos, +hi: BytePos, +t: T) -> spanned<T> {\n+pub fn spanned<T>(+lo: BytePos, +hi: BytePos, +t: T) -> spanned<T> {\n     respan(mk_sp(lo, hi), t)\n }\n \n-pub pure fn respan<T>(sp: span, +t: T) -> spanned<T> {\n+pub fn respan<T>(sp: span, +t: T) -> spanned<T> {\n     spanned {node: t, span: sp}\n }\n \n-pub pure fn dummy_spanned<T>(+t: T) -> spanned<T> {\n+pub fn dummy_spanned<T>(+t: T) -> spanned<T> {\n     respan(dummy_sp(), t)\n }\n \n /* assuming that we're not in macro expansion */\n-pub pure fn mk_sp(+lo: BytePos, +hi: BytePos) -> span {\n+pub fn mk_sp(+lo: BytePos, +hi: BytePos) -> span {\n     span {lo: lo, hi: hi, expn_info: None}\n }\n \n // make this a const, once the compiler supports it\n-pub pure fn dummy_sp() -> span { return mk_sp(BytePos(0), BytePos(0)); }\n+pub fn dummy_sp() -> span { return mk_sp(BytePos(0), BytePos(0)); }\n \n \n "}, {"sha": "d93a997213da20a9a405bc7ed7c67b84eb0e3e41", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -231,7 +231,7 @@ pub trait ext_ctxt {\n     fn span_bug(@mut self, sp: span, msg: &str) -> !;\n     fn bug(@mut self, msg: &str) -> !;\n     fn next_id(@mut self) -> ast::node_id;\n-    pure fn trace_macros(@mut self) -> bool;\n+    fn trace_macros(@mut self) -> bool;\n     fn set_trace_macros(@mut self, x: bool);\n     /* for unhygienic identifier transformation */\n     fn str_of(@mut self, id: ast::ident) -> ~str;\n@@ -310,7 +310,7 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, +cfg: ast::crate_cfg)\n         fn next_id(@mut self) -> ast::node_id {\n             return parse::next_node_id(self.parse_sess);\n         }\n-        pure fn trace_macros(@mut self) -> bool {\n+        fn trace_macros(@mut self) -> bool {\n             self.trace_mac\n         }\n         fn set_trace_macros(@mut self, x: bool) {\n@@ -464,7 +464,7 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n // traits just don't work anywhere...?\n //pub impl Map<Name,SyntaxExtension> for MapChain {\n \n-    pure fn contains_key (&self, key: &K) -> bool {\n+    fn contains_key (&self, key: &K) -> bool {\n         match *self {\n             BaseMapChain (ref map) => map.contains_key(key),\n             ConsMapChain (ref map,ref rest) =>\n@@ -475,11 +475,11 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n     // should each_key and each_value operate on shadowed\n     // names? I think not.\n     // delaying implementing this....\n-    pure fn each_key (&self, _f: &fn (&K)->bool) {\n+    fn each_key (&self, _f: &fn (&K)->bool) {\n         fail!(~\"unimplemented 2013-02-15T10:01\");\n     }\n \n-    pure fn each_value (&self, _f: &fn (&V) -> bool) {\n+    fn each_value (&self, _f: &fn (&V) -> bool) {\n         fail!(~\"unimplemented 2013-02-15T10:02\");\n     }\n "}, {"sha": "4a8ceedc8e3011135619ee6f44de620068a059b9", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -21,7 +21,7 @@ use core::to_str::ToStr;\n pub enum direction { send, recv }\n \n impl ToStr for direction {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         match *self {\n           send => ~\"Send\",\n           recv => ~\"Recv\""}, {"sha": "49076c74972f69cb5e07588614f416d86180dcef", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -79,7 +79,7 @@ pub fn new_tt_reader(sp_diag: @span_handler,\n     return r;\n }\n \n-pure fn dup_tt_frame(f: @mut TtFrame) -> @mut TtFrame {\n+fn dup_tt_frame(f: @mut TtFrame) -> @mut TtFrame {\n     @mut TtFrame {\n         readme: @mut (copy *f.readme),\n         idx: f.idx,\n@@ -92,7 +92,7 @@ pure fn dup_tt_frame(f: @mut TtFrame) -> @mut TtFrame {\n     }\n }\n \n-pub pure fn dup_tt_reader(r: @mut TtReader) -> @mut TtReader {\n+pub fn dup_tt_reader(r: @mut TtReader) -> @mut TtReader {\n     @mut TtReader {\n         sp_diag: r.sp_diag,\n         interner: r.interner,\n@@ -106,10 +106,10 @@ pub pure fn dup_tt_reader(r: @mut TtReader) -> @mut TtReader {\n }\n \n \n-pure fn lookup_cur_matched_by_matched(r: &mut TtReader,\n+fn lookup_cur_matched_by_matched(r: &mut TtReader,\n                                       start: @named_match)\n                                    -> @named_match {\n-    pure fn red(+ad: @named_match, idx: &uint) -> @named_match {\n+    fn red(+ad: @named_match, idx: &uint) -> @named_match {\n         match *ad {\n           matched_nonterminal(_) => {\n             // end of the line; duplicate henceforth"}, {"sha": "67c3d19dd0fb762be17e1cf3212f444cf42aca71", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -61,18 +61,18 @@ impl<T> OptVec<T> {\n         }\n     }\n \n-    pure fn get(&self, i: uint) -> &'self T {\n+    fn get(&self, i: uint) -> &'self T {\n         match *self {\n             Empty => fail!(fmt!(\"Invalid index %u\", i)),\n             Vec(ref v) => &v[i]\n         }\n     }\n \n-    pure fn is_empty(&self) -> bool {\n+    fn is_empty(&self) -> bool {\n         self.len() == 0\n     }\n \n-    pure fn len(&self) -> uint {\n+    fn len(&self) -> uint {\n         match *self {\n             Empty => 0,\n             Vec(ref v) => v.len()\n@@ -105,7 +105,7 @@ impl<T:Copy> OptVec<T> {\n }\n \n impl<A:Eq> Eq for OptVec<A> {\n-    pure fn eq(&self, other: &OptVec<A>) -> bool {\n+    fn eq(&self, other: &OptVec<A>) -> bool {\n         // Note: cannot use #[deriving(Eq)] here because\n         // (Empty, Vec(~[])) ought to be equal.\n         match (self, other) {\n@@ -116,51 +116,51 @@ impl<A:Eq> Eq for OptVec<A> {\n         }\n     }\n \n-    pure fn ne(&self, other: &OptVec<A>) -> bool {\n+    fn ne(&self, other: &OptVec<A>) -> bool {\n         !self.eq(other)\n     }\n }\n \n impl<A> BaseIter<A> for OptVec<A> {\n-    pure fn each(&self, blk: &fn(v: &A) -> bool) {\n+    fn each(&self, blk: &fn(v: &A) -> bool) {\n         match *self {\n             Empty => {}\n             Vec(ref v) => v.each(blk)\n         }\n     }\n \n-    pure fn size_hint(&self) -> Option<uint> {\n+    fn size_hint(&self) -> Option<uint> {\n         Some(self.len())\n     }\n }\n \n impl<A> iter::ExtendedIter<A> for OptVec<A> {\n     #[inline(always)]\n-    pure fn eachi(&self, blk: &fn(+v: uint, v: &A) -> bool) {\n+    fn eachi(&self, blk: &fn(+v: uint, v: &A) -> bool) {\n         iter::eachi(self, blk)\n     }\n     #[inline(always)]\n-    pure fn all(&self, blk: &fn(&A) -> bool) -> bool {\n+    fn all(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::all(self, blk)\n     }\n     #[inline(always)]\n-    pure fn any(&self, blk: &fn(&A) -> bool) -> bool {\n+    fn any(&self, blk: &fn(&A) -> bool) -> bool {\n         iter::any(self, blk)\n     }\n     #[inline(always)]\n-    pure fn foldl<B>(&self, +b0: B, blk: &fn(&B, &A) -> B) -> B {\n+    fn foldl<B>(&self, +b0: B, blk: &fn(&B, &A) -> B) -> B {\n         iter::foldl(self, b0, blk)\n     }\n     #[inline(always)]\n-    pure fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n+    fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n         iter::position(self, f)\n     }\n     #[inline(always)]\n-    pure fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n+    fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n         iter::map_to_vec(self, op)\n     }\n     #[inline(always)]\n-    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n+    fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n         -> ~[B] {\n         iter::flat_map_to_vec(self, op)\n     }\n@@ -169,27 +169,27 @@ impl<A> iter::ExtendedIter<A> for OptVec<A> {\n \n impl<A: Eq> iter::EqIter<A> for OptVec<A> {\n     #[inline(always)]\n-    pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n+    fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n     #[inline(always)]\n-    pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n+    fn count(&self, x: &A) -> uint { iter::count(self, x) }\n }\n \n impl<A: Copy> iter::CopyableIter<A> for OptVec<A> {\n     #[inline(always)]\n-    pure fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n+    fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n     #[inline(always)]\n-    pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n+    fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n     #[inline(always)]\n-    pure fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n+    fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n         iter::find(self, f)\n     }\n }\n \n impl<A: Copy+Ord> iter::CopyableOrderedIter<A> for OptVec<A> {\n     #[inline(always)]\n-    pure fn min(&self) -> A { iter::min(self) }\n+    fn min(&self) -> A { iter::min(self) }\n     #[inline(always)]\n-    pure fn max(&self) -> A { iter::max(self) }\n+    fn max(&self) -> A { iter::max(self) }\n }"}, {"sha": "3f8a5588c7163eca060d2d4d40fd5d2437aeae53", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -35,10 +35,10 @@ pub enum cmnt_style {\n }\n \n impl cmp::Eq for cmnt_style {\n-    pure fn eq(&self, other: &cmnt_style) -> bool {\n+    fn eq(&self, other: &cmnt_style) -> bool {\n         ((*self) as uint) == ((*other) as uint)\n     }\n-    pure fn ne(&self, other: &cmnt_style) -> bool {\n+    fn ne(&self, other: &cmnt_style) -> bool {\n         ((*self) as uint) != ((*other) as uint)\n     }\n }"}, {"sha": "ea599e8290a27c01137bb74311cb980403af3f1c", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -134,7 +134,7 @@ pub impl Parser {\n         }\n     }\n \n-    pure fn token_is_word(&self, word: &~str, tok: &token::Token) -> bool {\n+    fn token_is_word(&self, word: &~str, tok: &token::Token) -> bool {\n         match *tok {\n             token::IDENT(sid, false) => { *self.id_to_str(sid) == *word }\n              _ => { false }"}, {"sha": "ffd2a1d801c960649e8d645c8cac6e227a904a76", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -32,7 +32,7 @@ pub trait reader {\n     fn next_token(@mut self) -> TokenAndSpan;\n     fn fatal(@mut self, ~str) -> !;\n     fn span_diag(@mut self) -> @span_handler;\n-    pure fn interner(@mut self) -> @token::ident_interner;\n+    fn interner(@mut self) -> @token::ident_interner;\n     fn peek(@mut self) -> TokenAndSpan;\n     fn dup(@mut self) -> @reader;\n }\n@@ -122,7 +122,7 @@ impl reader for StringReader {\n         self.span_diagnostic.span_fatal(copy self.peek_span, m)\n     }\n     fn span_diag(@mut self) -> @span_handler { self.span_diagnostic }\n-    pure fn interner(@mut self) -> @token::ident_interner { self.interner }\n+    fn interner(@mut self) -> @token::ident_interner { self.interner }\n     fn peek(@mut self) -> TokenAndSpan {\n         TokenAndSpan {\n             tok: copy self.peek_tok,\n@@ -139,7 +139,7 @@ impl reader for TtReader {\n         self.sp_diag.span_fatal(copy self.cur_span, m);\n     }\n     fn span_diag(@mut self) -> @span_handler { self.sp_diag }\n-    pure fn interner(@mut self) -> @token::ident_interner { self.interner }\n+    fn interner(@mut self) -> @token::ident_interner { self.interner }\n     fn peek(@mut self) -> TokenAndSpan {\n         TokenAndSpan {\n             tok: copy self.cur_tok,\n@@ -261,7 +261,7 @@ fn consume_whitespace_and_comments(rdr: @mut StringReader)\n     return consume_any_line_comment(rdr);\n }\n \n-pub pure fn is_line_non_doc_comment(s: &str) -> bool {\n+pub fn is_line_non_doc_comment(s: &str) -> bool {\n     s.trim_right().all(|ch| ch == '/')\n }\n \n@@ -313,7 +313,7 @@ fn consume_any_line_comment(rdr: @mut StringReader)\n     return None;\n }\n \n-pub pure fn is_block_non_doc_comment(s: &str) -> bool {\n+pub fn is_block_non_doc_comment(s: &str) -> bool {\n     fail_unless!(s.len() >= 1u);\n     str::all_between(s, 1u, s.len() - 1u, |ch| ch == '*')\n }"}, {"sha": "65eb87fb83c05c693bb6bb15eb43b3d30ee2e55a", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -63,7 +63,7 @@ pub enum ObsoleteSyntax {\n \n impl to_bytes::IterBytes for ObsoleteSyntax {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n     }\n }"}, {"sha": "302217c8c9aeafd736612e644c3057475fb08ec7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -196,8 +196,8 @@ macro_rules! maybe_whole (\n )\n \n \n-pure fn maybe_append(+lhs: ~[attribute], rhs: Option<~[attribute]>)\n-                  -> ~[attribute] {\n+fn maybe_append(+lhs: ~[attribute], rhs: Option<~[attribute]>)\n+             -> ~[attribute] {\n     match rhs {\n         None => lhs,\n         Some(ref attrs) => vec::append(lhs, (*attrs))\n@@ -331,7 +331,7 @@ pub impl Parser {\n     }\n     fn get_id(&self) -> node_id { next_node_id(self.sess) }\n \n-    pure fn id_to_str(&self, id: ident) -> @~str {\n+    fn id_to_str(&self, id: ident) -> @~str {\n         self.sess.interner.get(id)\n     }\n "}, {"sha": "f5542fa81a6a988fd7881757be2269edfce6fa36", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -118,7 +118,7 @@ pub enum nonterminal {\n     nt_matchers(~[ast::matcher])\n }\n \n-pub pure fn binop_to_str(o: binop) -> ~str {\n+pub fn binop_to_str(o: binop) -> ~str {\n     match o {\n       PLUS => ~\"+\",\n       MINUS => ~\"-\",\n@@ -228,7 +228,7 @@ pub fn to_str(in: @ident_interner, t: &Token) -> ~str {\n     }\n }\n \n-pub pure fn can_begin_expr(t: &Token) -> bool {\n+pub fn can_begin_expr(t: &Token) -> bool {\n     match *t {\n       LPAREN => true,\n       LBRACE => true,\n@@ -286,22 +286,22 @@ pub fn is_lit(t: &Token) -> bool {\n     }\n }\n \n-pub pure fn is_ident(t: &Token) -> bool {\n+pub fn is_ident(t: &Token) -> bool {\n     match *t { IDENT(_, _) => true, _ => false }\n }\n \n-pub pure fn is_ident_or_path(t: &Token) -> bool {\n+pub fn is_ident_or_path(t: &Token) -> bool {\n     match *t {\n       IDENT(_, _) | INTERPOLATED(nt_path(*)) => true,\n       _ => false\n     }\n }\n \n-pub pure fn is_plain_ident(t: &Token) -> bool {\n+pub fn is_plain_ident(t: &Token) -> bool {\n     match *t { IDENT(_, false) => true, _ => false }\n }\n \n-pub pure fn is_bar(t: &Token) -> bool {\n+pub fn is_bar(t: &Token) -> bool {\n     match *t { BINOP(OR) | OROR => true, _ => false }\n }\n \n@@ -366,7 +366,7 @@ pub impl ident_interner {\n     fn gensym(&self, val: @~str) -> ast::ident {\n         ast::ident { repr: self.interner.gensym(val) }\n     }\n-    pure fn get(&self, idx: ast::ident) -> @~str {\n+    fn get(&self, idx: ast::ident) -> @~str {\n         self.interner.get(idx.repr)\n     }\n     fn len(&self) -> uint {"}, {"sha": "74cce3047f977517674aa7d13f5f33c6a66e8194", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -2214,7 +2214,7 @@ pub fn opt_sigil_to_str(opt_p: Option<ast::Sigil>) -> ~str {\n     }\n }\n \n-pub pure fn purity_to_str(p: ast::purity) -> ~str {\n+pub fn purity_to_str(p: ast::purity) -> ~str {\n     match p {\n       ast::impure_fn => ~\"impure\",\n       ast::unsafe_fn => ~\"unsafe\",\n@@ -2223,7 +2223,7 @@ pub pure fn purity_to_str(p: ast::purity) -> ~str {\n     }\n }\n \n-pub pure fn onceness_to_str(o: ast::Onceness) -> ~str {\n+pub fn onceness_to_str(o: ast::Onceness) -> ~str {\n     match o {\n         ast::Once => ~\"once\",\n         ast::Many => ~\"many\""}, {"sha": "159a205637b59bcfb4db109229e258d1a0f3d939", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c60c141b6f499ba551b53bc562925269d2f187/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=e7c60c141b6f499ba551b53bc562925269d2f187", "patch": "@@ -61,7 +61,7 @@ pub impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n     // this isn't \"pure\" in the traditional sense, because it can go from\n     // failing to returning a value as items are interned. But for typestate,\n     // where we first check a pred and then rely on it, ceasing to fail is ok.\n-    pure fn get(&self, idx: uint) -> T { self.vect[idx] }\n+    fn get(&self, idx: uint) -> T { self.vect[idx] }\n \n     fn len(&self) -> uint { let vect = &*self.vect; vect.len() }\n }"}]}