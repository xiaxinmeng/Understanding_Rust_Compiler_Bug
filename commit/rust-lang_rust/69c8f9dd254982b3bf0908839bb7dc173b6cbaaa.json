{"sha": "69c8f9dd254982b3bf0908839bb7dc173b6cbaaa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5YzhmOWRkMjU0OTgyYjNiZjA5MDg4MzliYjdkYzE3M2I2Y2JhYWE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-02T18:56:26Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-02T20:21:55Z"}, "message": "move `build_mir` into `build` directory", "tree": {"sha": "1aba82b99c08ae68e6ad7ab9de1d717da6324871", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1aba82b99c08ae68e6ad7ab9de1d717da6324871"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69c8f9dd254982b3bf0908839bb7dc173b6cbaaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69c8f9dd254982b3bf0908839bb7dc173b6cbaaa", "html_url": "https://github.com/rust-lang/rust/commit/69c8f9dd254982b3bf0908839bb7dc173b6cbaaa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69c8f9dd254982b3bf0908839bb7dc173b6cbaaa/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2cfdbbdf908de88cf6d306949f81dc487d9e6b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2cfdbbdf908de88cf6d306949f81dc487d9e6b0", "html_url": "https://github.com/rust-lang/rust/commit/c2cfdbbdf908de88cf6d306949f81dc487d9e6b0"}], "stats": {"total": 441, "additions": 217, "deletions": 224}, "files": [{"sha": "f5f6c307b152a1d6a52b8e1628dcd632551c153c", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 213, "deletions": 12, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/69c8f9dd254982b3bf0908839bb7dc173b6cbaaa/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69c8f9dd254982b3bf0908839bb7dc173b6cbaaa/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=69c8f9dd254982b3bf0908839bb7dc173b6cbaaa", "patch": "@@ -8,22 +8,223 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n+use build;\n use hair::cx::Cx;\n use hair::Pattern;\n-\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n use rustc::middle::region::{CodeExtent, CodeExtentData};\n-use rustc::ty::{self, Ty};\n use rustc::mir::*;\n+use rustc::mir::transform::MirSource;\n+use rustc::mir::visit::MutVisitor;\n+use rustc::traits::Reveal;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::steal::Steal;\n+use rustc::ty::subst::Substs;\n use rustc::util::nodemap::NodeMap;\n-use rustc::hir;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use shim;\n+use std::mem;\n+use std::u32;\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n+use util as mir_util;\n \n-use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n+    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let unsupported = || {\n+        span_bug!(tcx.hir.span(id), \"can't build MIR for {:?}\", def_id);\n+    };\n \n-use std::u32;\n+    // Figure out what primary body this item has.\n+    let body_id = match tcx.hir.get(id) {\n+        hir::map::NodeItem(item) => {\n+            match item.node {\n+                hir::ItemConst(_, body) |\n+                hir::ItemStatic(_, _, body) |\n+                hir::ItemFn(.., body) => body,\n+                _ => unsupported()\n+            }\n+        }\n+        hir::map::NodeTraitItem(item) => {\n+            match item.node {\n+                hir::TraitItemKind::Const(_, Some(body)) |\n+                hir::TraitItemKind::Method(_,\n+                    hir::TraitMethod::Provided(body)) => body,\n+                _ => unsupported()\n+            }\n+        }\n+        hir::map::NodeImplItem(item) => {\n+            match item.node {\n+                hir::ImplItemKind::Const(_, body) |\n+                hir::ImplItemKind::Method(_, body) => body,\n+                _ => unsupported()\n+            }\n+        }\n+        hir::map::NodeExpr(expr) => {\n+            // FIXME(eddyb) Closures should have separate\n+            // function definition IDs and expression IDs.\n+            // Type-checking should not let closures get\n+            // this far in a constant position.\n+            // Assume that everything other than closures\n+            // is a constant \"initializer\" expression.\n+            match expr.node {\n+                hir::ExprClosure(_, _, body, _) => body,\n+                _ => hir::BodyId { node_id: expr.id }\n+            }\n+        }\n+        hir::map::NodeVariant(variant) =>\n+            return create_constructor_shim(tcx, id, &variant.node.data),\n+        hir::map::NodeStructCtor(ctor) =>\n+            return create_constructor_shim(tcx, id, ctor),\n+        _ => unsupported()\n+    };\n+\n+    let src = MirSource::from_node(tcx, id);\n+    tcx.infer_ctxt(body_id, Reveal::UserFacing).enter(|infcx| {\n+        let cx = Cx::new(&infcx, src);\n+        let mut mir = if cx.tables().tainted_by_errors {\n+            build::construct_error(cx, body_id)\n+        } else if let MirSource::Fn(id) = src {\n+            // fetch the fully liberated fn signature (that is, all bound\n+            // types/lifetimes replaced)\n+            let fn_sig = cx.tables().liberated_fn_sigs[&id].clone();\n+\n+            let ty = tcx.type_of(tcx.hir.local_def_id(id));\n+            let mut abi = fn_sig.abi;\n+            let implicit_argument = if let ty::TyClosure(..) = ty.sty {\n+                // HACK(eddyb) Avoid having RustCall on closures,\n+                // as it adds unnecessary (and wrong) auto-tupling.\n+                abi = Abi::Rust;\n+                Some((closure_self_ty(tcx, id, body_id), None))\n+            } else {\n+                None\n+            };\n+\n+            let body = tcx.hir.body(body_id);\n+            let explicit_arguments =\n+                body.arguments\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(index, arg)| {\n+                        (fn_sig.inputs()[index], Some(&*arg.pat))\n+                    });\n+\n+            let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n+            build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body)\n+        } else {\n+            build::construct_const(cx, body_id)\n+        };\n+\n+        // Convert the Mir to global types.\n+        let mut globalizer = GlobalizeMir {\n+            tcx: tcx,\n+            span: mir.span\n+        };\n+        globalizer.visit_mir(&mut mir);\n+        let mir = unsafe {\n+            mem::transmute::<Mir, Mir<'tcx>>(mir)\n+        };\n+\n+        mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir);\n+\n+        tcx.alloc_steal_mir(mir)\n+    })\n+}\n+\n+/// A pass to lift all the types and substitutions in a Mir\n+/// to the global tcx. Sadly, we don't have a \"folder\" that\n+/// can change 'tcx so we have to transmute afterwards.\n+struct GlobalizeMir<'a, 'gcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+    span: Span\n+}\n+\n+impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n+    fn visit_ty(&mut self, ty: &mut Ty<'tcx>) {\n+        if let Some(lifted) = self.tcx.lift(ty) {\n+            *ty = lifted;\n+        } else {\n+            span_bug!(self.span,\n+                      \"found type `{:?}` with inference types/regions in MIR\",\n+                      ty);\n+        }\n+    }\n+\n+    fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>) {\n+        if let Some(lifted) = self.tcx.lift(substs) {\n+            *substs = lifted;\n+        } else {\n+            span_bug!(self.span,\n+                      \"found substs `{:?}` with inference types/regions in MIR\",\n+                      substs);\n+        }\n+    }\n+}\n+\n+fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     ctor_id: ast::NodeId,\n+                                     v: &'tcx hir::VariantData)\n+                                     -> &'tcx Steal<Mir<'tcx>>\n+{\n+    let span = tcx.hir.span(ctor_id);\n+    if let hir::VariantData::Tuple(ref fields, ctor_id) = *v {\n+        let pe = ty::ParameterEnvironment::for_item(tcx, ctor_id);\n+        tcx.infer_ctxt(pe, Reveal::UserFacing).enter(|infcx| {\n+            let (mut mir, src) =\n+                shim::build_adt_ctor(&infcx, ctor_id, fields, span);\n+\n+            // Convert the Mir to global types.\n+            let tcx = infcx.tcx.global_tcx();\n+            let mut globalizer = GlobalizeMir {\n+                tcx: tcx,\n+                span: mir.span\n+            };\n+            globalizer.visit_mir(&mut mir);\n+            let mir = unsafe {\n+                mem::transmute::<Mir, Mir<'tcx>>(mir)\n+            };\n+\n+            mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir);\n+\n+            tcx.alloc_steal_mir(mir)\n+        })\n+    } else {\n+        span_bug!(span, \"attempting to create MIR for non-tuple variant {:?}\", v);\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n+\n+fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             closure_expr_id: ast::NodeId,\n+                             body_id: hir::BodyId)\n+                             -> Ty<'tcx> {\n+    let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_id);\n+\n+    let region = ty::ReFree(ty::FreeRegion {\n+        scope: Some(tcx.item_extent(body_id.node_id)),\n+        bound_region: ty::BoundRegion::BrEnv,\n+    });\n+    let region = tcx.mk_region(region);\n+\n+    match tcx.closure_kind(tcx.hir.local_def_id(closure_expr_id)) {\n+        ty::ClosureKind::Fn =>\n+            tcx.mk_ref(region,\n+                       ty::TypeAndMut { ty: closure_ty,\n+                                        mutbl: hir::MutImmutable }),\n+        ty::ClosureKind::FnMut =>\n+            tcx.mk_ref(region,\n+                       ty::TypeAndMut { ty: closure_ty,\n+                                        mutbl: hir::MutMutable }),\n+        ty::ClosureKind::FnOnce =>\n+            closure_ty\n+    }\n+}\n \n struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     hir: Cx<'a, 'gcx, 'tcx>,\n@@ -121,13 +322,13 @@ macro_rules! unpack {\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n-pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n-                                       fn_id: ast::NodeId,\n-                                       arguments: A,\n-                                       abi: Abi,\n-                                       return_ty: Ty<'gcx>,\n-                                       body: &'gcx hir::Body)\n-                                       -> Mir<'tcx>\n+fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n+                                   fn_id: ast::NodeId,\n+                                   arguments: A,\n+                                   abi: Abi,\n+                                   return_ty: Ty<'gcx>,\n+                                   body: &'gcx hir::Body)\n+                                   -> Mir<'tcx>\n     where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n {\n     let arguments: Vec<_> = arguments.collect();"}, {"sha": "ee8547e5dd679f9f4694d8e75e6c8d6cdf37a50c", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69c8f9dd254982b3bf0908839bb7dc173b6cbaaa/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69c8f9dd254982b3bf0908839bb7dc173b6cbaaa/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=69c8f9dd254982b3bf0908839bb7dc173b6cbaaa", "patch": "@@ -26,7 +26,7 @@ use rustc::middle::region::RegionMaps;\n use rustc::infer::InferCtxt;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt};\n-use syntax::symbol::{Symbol, InternedString};\n+use syntax::symbol::Symbol;\n use rustc::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n use std::rc::Rc;\n@@ -103,10 +103,6 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         self.tcx.mk_nil()\n     }\n \n-    pub fn str_literal(&mut self, value: InternedString) -> Literal<'tcx> {\n-        Literal::Value { value: ConstVal::Str(value) }\n-    }\n-\n     pub fn true_literal(&mut self) -> Literal<'tcx> {\n         Literal::Value { value: ConstVal::Bool(true) }\n     }"}, {"sha": "aef637fed5ee0983c3db1ebf231785a2fdd09eed", "filename": "src/librustc_mir/queries.rs", "status": "modified", "additions": 3, "deletions": 207, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/69c8f9dd254982b3bf0908839bb7dc173b6cbaaa/src%2Flibrustc_mir%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69c8f9dd254982b3bf0908839bb7dc173b6cbaaa/src%2Flibrustc_mir%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fqueries.rs?ref=69c8f9dd254982b3bf0908839bb7dc173b6cbaaa", "patch": "@@ -16,31 +16,20 @@\n //! - `#[rustc_mir(graphviz=\"file.gv\")]`\n //! - `#[rustc_mir(pretty=\"file.mir\")]`\n \n-use build;\n-use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use rustc::mir::Mir;\n-use rustc::mir::transform::MirSource;\n-use rustc::mir::visit::MutVisitor;\n-use shim;\n-use hair::cx::Cx;\n-use util as mir_util;\n+use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n \n-use rustc::traits::Reveal;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::TyCtxt;\n use rustc::ty::maps::Providers;\n-use rustc::ty::steal::Steal;\n-use rustc::ty::subst::Substs;\n use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::util::nodemap::DefIdSet;\n-use syntax::abi::Abi;\n use syntax::ast;\n use syntax_pos::Span;\n \n-use std::mem;\n use std::rc::Rc;\n \n pub fn provide(providers: &mut Providers) {\n+    use build::mir_build;\n     *providers = Providers {\n         mir_build,\n         mir_keys,\n@@ -86,196 +75,3 @@ fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n \n     Rc::new(set)\n }\n-\n-fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n-    let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let unsupported = || {\n-        span_bug!(tcx.hir.span(id), \"can't build MIR for {:?}\", def_id);\n-    };\n-\n-    // Figure out what primary body this item has.\n-    let body_id = match tcx.hir.get(id) {\n-        hir::map::NodeItem(item) => {\n-            match item.node {\n-                hir::ItemConst(_, body) |\n-                hir::ItemStatic(_, _, body) |\n-                hir::ItemFn(.., body) => body,\n-                _ => unsupported()\n-            }\n-        }\n-        hir::map::NodeTraitItem(item) => {\n-            match item.node {\n-                hir::TraitItemKind::Const(_, Some(body)) |\n-                hir::TraitItemKind::Method(_,\n-                    hir::TraitMethod::Provided(body)) => body,\n-                _ => unsupported()\n-            }\n-        }\n-        hir::map::NodeImplItem(item) => {\n-            match item.node {\n-                hir::ImplItemKind::Const(_, body) |\n-                hir::ImplItemKind::Method(_, body) => body,\n-                _ => unsupported()\n-            }\n-        }\n-        hir::map::NodeExpr(expr) => {\n-            // FIXME(eddyb) Closures should have separate\n-            // function definition IDs and expression IDs.\n-            // Type-checking should not let closures get\n-            // this far in a constant position.\n-            // Assume that everything other than closures\n-            // is a constant \"initializer\" expression.\n-            match expr.node {\n-                hir::ExprClosure(_, _, body, _) => body,\n-                _ => hir::BodyId { node_id: expr.id }\n-            }\n-        }\n-        hir::map::NodeVariant(variant) =>\n-            return create_constructor_shim(tcx, id, &variant.node.data),\n-        hir::map::NodeStructCtor(ctor) =>\n-            return create_constructor_shim(tcx, id, ctor),\n-        _ => unsupported()\n-    };\n-\n-    let src = MirSource::from_node(tcx, id);\n-    tcx.infer_ctxt(body_id, Reveal::UserFacing).enter(|infcx| {\n-        let cx = Cx::new(&infcx, src);\n-        let mut mir = if cx.tables().tainted_by_errors {\n-            build::construct_error(cx, body_id)\n-        } else if let MirSource::Fn(id) = src {\n-            // fetch the fully liberated fn signature (that is, all bound\n-            // types/lifetimes replaced)\n-            let fn_sig = cx.tables().liberated_fn_sigs[&id].clone();\n-\n-            let ty = tcx.type_of(tcx.hir.local_def_id(id));\n-            let mut abi = fn_sig.abi;\n-            let implicit_argument = if let ty::TyClosure(..) = ty.sty {\n-                // HACK(eddyb) Avoid having RustCall on closures,\n-                // as it adds unnecessary (and wrong) auto-tupling.\n-                abi = Abi::Rust;\n-                Some((closure_self_ty(tcx, id, body_id), None))\n-            } else {\n-                None\n-            };\n-\n-            let body = tcx.hir.body(body_id);\n-            let explicit_arguments =\n-                body.arguments\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(index, arg)| {\n-                        (fn_sig.inputs()[index], Some(&*arg.pat))\n-                    });\n-\n-            let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n-            build::construct_fn(cx, id, arguments, abi, fn_sig.output(), body)\n-        } else {\n-            build::construct_const(cx, body_id)\n-        };\n-\n-        // Convert the Mir to global types.\n-        let mut globalizer = GlobalizeMir {\n-            tcx: tcx,\n-            span: mir.span\n-        };\n-        globalizer.visit_mir(&mut mir);\n-        let mir = unsafe {\n-            mem::transmute::<Mir, Mir<'tcx>>(mir)\n-        };\n-\n-        mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir);\n-\n-        tcx.alloc_steal_mir(mir)\n-    })\n-}\n-\n-/// A pass to lift all the types and substitutions in a Mir\n-/// to the global tcx. Sadly, we don't have a \"folder\" that\n-/// can change 'tcx so we have to transmute afterwards.\n-struct GlobalizeMir<'a, 'gcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-    span: Span\n-}\n-\n-impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n-    fn visit_ty(&mut self, ty: &mut Ty<'tcx>) {\n-        if let Some(lifted) = self.tcx.lift(ty) {\n-            *ty = lifted;\n-        } else {\n-            span_bug!(self.span,\n-                      \"found type `{:?}` with inference types/regions in MIR\",\n-                      ty);\n-        }\n-    }\n-\n-    fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>) {\n-        if let Some(lifted) = self.tcx.lift(substs) {\n-            *substs = lifted;\n-        } else {\n-            span_bug!(self.span,\n-                      \"found substs `{:?}` with inference types/regions in MIR\",\n-                      substs);\n-        }\n-    }\n-}\n-\n-fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     ctor_id: ast::NodeId,\n-                                     v: &'tcx hir::VariantData)\n-                                     -> &'tcx Steal<Mir<'tcx>>\n-{\n-    let span = tcx.hir.span(ctor_id);\n-    if let hir::VariantData::Tuple(ref fields, ctor_id) = *v {\n-        let pe = ty::ParameterEnvironment::for_item(tcx, ctor_id);\n-        tcx.infer_ctxt(pe, Reveal::UserFacing).enter(|infcx| {\n-            let (mut mir, src) =\n-                shim::build_adt_ctor(&infcx, ctor_id, fields, span);\n-\n-            // Convert the Mir to global types.\n-            let tcx = infcx.tcx.global_tcx();\n-            let mut globalizer = GlobalizeMir {\n-                tcx: tcx,\n-                span: mir.span\n-            };\n-            globalizer.visit_mir(&mut mir);\n-            let mir = unsafe {\n-                mem::transmute::<Mir, Mir<'tcx>>(mir)\n-            };\n-\n-            mir_util::dump_mir(tcx, None, \"mir_map\", &0, src, &mir);\n-\n-            tcx.alloc_steal_mir(mir)\n-        })\n-    } else {\n-        span_bug!(span, \"attempting to create MIR for non-tuple variant {:?}\", v);\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n-\n-fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             closure_expr_id: ast::NodeId,\n-                             body_id: hir::BodyId)\n-                             -> Ty<'tcx> {\n-    let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_id);\n-\n-    let region = ty::ReFree(ty::FreeRegion {\n-        scope: Some(tcx.item_extent(body_id.node_id)),\n-        bound_region: ty::BoundRegion::BrEnv,\n-    });\n-    let region = tcx.mk_region(region);\n-\n-    match tcx.closure_kind(tcx.hir.local_def_id(closure_expr_id)) {\n-        ty::ClosureKind::Fn =>\n-            tcx.mk_ref(region,\n-                       ty::TypeAndMut { ty: closure_ty,\n-                                        mutbl: hir::MutImmutable }),\n-        ty::ClosureKind::FnMut =>\n-            tcx.mk_ref(region,\n-                       ty::TypeAndMut { ty: closure_ty,\n-                                        mutbl: hir::MutMutable }),\n-        ty::ClosureKind::FnOnce =>\n-            closure_ty\n-    }\n-}"}]}