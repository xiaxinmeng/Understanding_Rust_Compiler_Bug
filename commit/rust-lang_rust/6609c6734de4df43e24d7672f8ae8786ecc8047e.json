{"sha": "6609c6734de4df43e24d7672f8ae8786ecc8047e", "node_id": "C_kwDOAAsO6NoAKDY2MDljNjczNGRlNGRmNDNlMjRkNzY3MmY4YWU4Nzg2ZWNjODA0N2U", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-06T05:21:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-06T05:21:49Z"}, "message": "Auto merge of #96551 - ferrocene:pa-ignore-paths-when-abbreviating, r=Mark-Simulacrum\n\n[compiletest] Ignore known paths when abbreviating output\n\nTo prevent out of memory conditions, compiletest limits the amount of output a test can generate, abbreviating it if the test emits more than a threshold. While the behavior is desirable, it also causes some issues (like #96229, #94322 and #92211).\n\nThe latest one happened recently, when the `src/test/ui/numeric/numeric-cast.rs` test started to fail on systems where the path of the rust-lang/rust checkout is too long. This includes my own development machine and [LLVM's CI](https://github.com/rust-lang/rust/issues/96362#issuecomment-1108609893). Rust's CI uses a pretty short directory name for the checkout, which hides these sort of problems until someone runs the test suite on their own computer.\n\nWhen developing the fix I tried to find the most targeted fix that would prevent this class of failures from happening in the future, deferring the decision on if/how to redesign abbreviation to a later date. The solution I came up with was to ignore known base paths when calculating whether the output exceeds the abbreviation threshold, which removes this kind of nondeterminism.\n\nThis PR is best reviewed commit-by-commit.", "tree": {"sha": "c2a811e80067397a33d43b596c251b5c56982c1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2a811e80067397a33d43b596c251b5c56982c1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6609c6734de4df43e24d7672f8ae8786ecc8047e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6609c6734de4df43e24d7672f8ae8786ecc8047e", "html_url": "https://github.com/rust-lang/rust/commit/6609c6734de4df43e24d7672f8ae8786ecc8047e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6609c6734de4df43e24d7672f8ae8786ecc8047e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "760237ff785fd14ac7fdab799f4d695d86cf9cbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/760237ff785fd14ac7fdab799f4d695d86cf9cbf", "html_url": "https://github.com/rust-lang/rust/commit/760237ff785fd14ac7fdab799f4d695d86cf9cbf"}, {"sha": "8ea95988df4d493ec3f556ab0de6b0b812ed27be", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ea95988df4d493ec3f556ab0de6b0b812ed27be", "html_url": "https://github.com/rust-lang/rust/commit/8ea95988df4d493ec3f556ab0de6b0b812ed27be"}], "stats": {"total": 309, "additions": 249, "deletions": 60}, "files": [{"sha": "7640e6517442881ca3089c9745b324e9860b1e29", "filename": "src/tools/compiletest/src/read2.rs", "status": "modified", "additions": 101, "deletions": 56, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/6609c6734de4df43e24d7672f8ae8786ecc8047e/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6609c6734de4df43e24d7672f8ae8786ecc8047e/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs?ref=6609c6734de4df43e24d7672f8ae8786ecc8047e", "patch": "@@ -1,71 +1,24 @@\n // FIXME: This is a complete copy of `cargo/src/cargo/util/read2.rs`\n // Consider unify the read2() in libstd, cargo and this to prevent further code duplication.\n \n+#[cfg(test)]\n+mod tests;\n+\n pub use self::imp::read2;\n-use std::io;\n+use std::io::{self, Write};\n+use std::mem::replace;\n use std::process::{Child, Output};\n \n-pub fn read2_abbreviated(mut child: Child) -> io::Result<Output> {\n-    use io::Write;\n-    use std::mem::replace;\n-\n-    const HEAD_LEN: usize = 160 * 1024;\n-    const TAIL_LEN: usize = 256 * 1024;\n-\n-    enum ProcOutput {\n-        Full(Vec<u8>),\n-        Abbreviated { head: Vec<u8>, skipped: usize, tail: Box<[u8]> },\n-    }\n-\n-    impl ProcOutput {\n-        fn extend(&mut self, data: &[u8]) {\n-            let new_self = match *self {\n-                ProcOutput::Full(ref mut bytes) => {\n-                    bytes.extend_from_slice(data);\n-                    let new_len = bytes.len();\n-                    if new_len <= HEAD_LEN + TAIL_LEN {\n-                        return;\n-                    }\n-                    let tail = bytes.split_off(new_len - TAIL_LEN).into_boxed_slice();\n-                    let head = replace(bytes, Vec::new());\n-                    let skipped = new_len - HEAD_LEN - TAIL_LEN;\n-                    ProcOutput::Abbreviated { head, skipped, tail }\n-                }\n-                ProcOutput::Abbreviated { ref mut skipped, ref mut tail, .. } => {\n-                    *skipped += data.len();\n-                    if data.len() <= TAIL_LEN {\n-                        tail[..data.len()].copy_from_slice(data);\n-                        tail.rotate_left(data.len());\n-                    } else {\n-                        tail.copy_from_slice(&data[(data.len() - TAIL_LEN)..]);\n-                    }\n-                    return;\n-                }\n-            };\n-            *self = new_self;\n-        }\n-\n-        fn into_bytes(self) -> Vec<u8> {\n-            match self {\n-                ProcOutput::Full(bytes) => bytes,\n-                ProcOutput::Abbreviated { mut head, skipped, tail } => {\n-                    write!(&mut head, \"\\n\\n<<<<<< SKIPPED {} BYTES >>>>>>\\n\\n\", skipped).unwrap();\n-                    head.extend_from_slice(&tail);\n-                    head\n-                }\n-            }\n-        }\n-    }\n-\n-    let mut stdout = ProcOutput::Full(Vec::new());\n-    let mut stderr = ProcOutput::Full(Vec::new());\n+pub fn read2_abbreviated(mut child: Child, filter_paths_from_len: &[String]) -> io::Result<Output> {\n+    let mut stdout = ProcOutput::new();\n+    let mut stderr = ProcOutput::new();\n \n     drop(child.stdin.take());\n     read2(\n         child.stdout.take().unwrap(),\n         child.stderr.take().unwrap(),\n         &mut |is_stdout, data, _| {\n-            if is_stdout { &mut stdout } else { &mut stderr }.extend(data);\n+            if is_stdout { &mut stdout } else { &mut stderr }.extend(data, filter_paths_from_len);\n             data.clear();\n         },\n     )?;\n@@ -74,6 +27,98 @@ pub fn read2_abbreviated(mut child: Child) -> io::Result<Output> {\n     Ok(Output { status, stdout: stdout.into_bytes(), stderr: stderr.into_bytes() })\n }\n \n+const HEAD_LEN: usize = 160 * 1024;\n+const TAIL_LEN: usize = 256 * 1024;\n+\n+// Whenever a path is filtered when counting the length of the output, we need to add some\n+// placeholder length to ensure a compiler emitting only filtered paths doesn't cause a OOM.\n+//\n+// 32 was chosen semi-arbitrarily: it was the highest power of two that still allowed the test\n+// suite to pass at the moment of implementing path filtering.\n+const FILTERED_PATHS_PLACEHOLDER_LEN: usize = 32;\n+\n+enum ProcOutput {\n+    Full { bytes: Vec<u8>, filtered_len: usize },\n+    Abbreviated { head: Vec<u8>, skipped: usize, tail: Box<[u8]> },\n+}\n+\n+impl ProcOutput {\n+    fn new() -> Self {\n+        ProcOutput::Full { bytes: Vec::new(), filtered_len: 0 }\n+    }\n+\n+    fn extend(&mut self, data: &[u8], filter_paths_from_len: &[String]) {\n+        let new_self = match *self {\n+            ProcOutput::Full { ref mut bytes, ref mut filtered_len } => {\n+                let old_len = bytes.len();\n+                bytes.extend_from_slice(data);\n+                *filtered_len += data.len();\n+\n+                // We had problems in the past with tests failing only in some environments,\n+                // due to the length of the base path pushing the output size over the limit.\n+                //\n+                // To make those failures deterministic across all environments we ignore known\n+                // paths when calculating the string length, while still including the full\n+                // path in the output. This could result in some output being larger than the\n+                // threshold, but it's better than having nondeterministic failures.\n+                //\n+                // The compiler emitting only excluded strings is addressed by adding a\n+                // placeholder size for each excluded segment, which will eventually reach\n+                // the configured threshold.\n+                for path in filter_paths_from_len {\n+                    let path_bytes = path.as_bytes();\n+                    // We start matching `path_bytes - 1` into the previously loaded data,\n+                    // to account for the fact a path_bytes might be included across multiple\n+                    // `extend` calls. Starting from `- 1` avoids double-counting paths.\n+                    let matches = (&bytes[(old_len.saturating_sub(path_bytes.len() - 1))..])\n+                        .windows(path_bytes.len())\n+                        .filter(|window| window == &path_bytes)\n+                        .count();\n+                    *filtered_len -= matches * path_bytes.len();\n+\n+                    // We can't just remove the length of the filtered path from the output lenght,\n+                    // otherwise a compiler emitting only filtered paths would OOM compiletest. Add\n+                    // a fixed placeholder length for each path to prevent that.\n+                    *filtered_len += matches * FILTERED_PATHS_PLACEHOLDER_LEN;\n+                }\n+\n+                let new_len = bytes.len();\n+                if *filtered_len <= HEAD_LEN + TAIL_LEN {\n+                    return;\n+                }\n+\n+                let mut head = replace(bytes, Vec::new());\n+                let mut middle = head.split_off(HEAD_LEN);\n+                let tail = middle.split_off(middle.len() - TAIL_LEN).into_boxed_slice();\n+                let skipped = new_len - HEAD_LEN - TAIL_LEN;\n+                ProcOutput::Abbreviated { head, skipped, tail }\n+            }\n+            ProcOutput::Abbreviated { ref mut skipped, ref mut tail, .. } => {\n+                *skipped += data.len();\n+                if data.len() <= TAIL_LEN {\n+                    tail[..data.len()].copy_from_slice(data);\n+                    tail.rotate_left(data.len());\n+                } else {\n+                    tail.copy_from_slice(&data[(data.len() - TAIL_LEN)..]);\n+                }\n+                return;\n+            }\n+        };\n+        *self = new_self;\n+    }\n+\n+    fn into_bytes(self) -> Vec<u8> {\n+        match self {\n+            ProcOutput::Full { bytes, .. } => bytes,\n+            ProcOutput::Abbreviated { mut head, skipped, tail } => {\n+                write!(&mut head, \"\\n\\n<<<<<< SKIPPED {} BYTES >>>>>>\\n\\n\", skipped).unwrap();\n+                head.extend_from_slice(&tail);\n+                head\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(not(any(unix, windows)))]\n mod imp {\n     use std::io::{self, Read};"}, {"sha": "1ca682a46aaafe2a22c4165a24fe194222ca65e6", "filename": "src/tools/compiletest/src/read2/tests.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/6609c6734de4df43e24d7672f8ae8786ecc8047e/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6609c6734de4df43e24d7672f8ae8786ecc8047e/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2%2Ftests.rs?ref=6609c6734de4df43e24d7672f8ae8786ecc8047e", "patch": "@@ -0,0 +1,123 @@\n+use crate::read2::{ProcOutput, FILTERED_PATHS_PLACEHOLDER_LEN, HEAD_LEN, TAIL_LEN};\n+\n+#[test]\n+fn test_abbreviate_short_string() {\n+    let mut out = ProcOutput::new();\n+    out.extend(b\"Hello world!\", &[]);\n+    assert_eq!(b\"Hello world!\", &*out.into_bytes());\n+}\n+\n+#[test]\n+fn test_abbreviate_short_string_multiple_steps() {\n+    let mut out = ProcOutput::new();\n+\n+    out.extend(b\"Hello \", &[]);\n+    out.extend(b\"world!\", &[]);\n+\n+    assert_eq!(b\"Hello world!\", &*out.into_bytes());\n+}\n+\n+#[test]\n+fn test_abbreviate_long_string() {\n+    let mut out = ProcOutput::new();\n+\n+    let data = vec![b'.'; HEAD_LEN + TAIL_LEN + 16];\n+    out.extend(&data, &[]);\n+\n+    let mut expected = vec![b'.'; HEAD_LEN];\n+    expected.extend_from_slice(b\"\\n\\n<<<<<< SKIPPED 16 BYTES >>>>>>\\n\\n\");\n+    expected.extend_from_slice(&vec![b'.'; TAIL_LEN]);\n+\n+    // We first check the length to avoid endless terminal output if the length differs, since\n+    // `out` is hundreds of KBs in size.\n+    let out = out.into_bytes();\n+    assert_eq!(expected.len(), out.len());\n+    assert_eq!(expected, out);\n+}\n+\n+#[test]\n+fn test_abbreviate_long_string_multiple_steps() {\n+    let mut out = ProcOutput::new();\n+\n+    out.extend(&vec![b'.'; HEAD_LEN], &[]);\n+    out.extend(&vec![b'.'; TAIL_LEN], &[]);\n+    // Also test whether the rotation works\n+    out.extend(&vec![b'!'; 16], &[]);\n+    out.extend(&vec![b'?'; 16], &[]);\n+\n+    let mut expected = vec![b'.'; HEAD_LEN];\n+    expected.extend_from_slice(b\"\\n\\n<<<<<< SKIPPED 32 BYTES >>>>>>\\n\\n\");\n+    expected.extend_from_slice(&vec![b'.'; TAIL_LEN - 32]);\n+    expected.extend_from_slice(&vec![b'!'; 16]);\n+    expected.extend_from_slice(&vec![b'?'; 16]);\n+\n+    // We first check the length to avoid endless terminal output if the length differs, since\n+    // `out` is hundreds of KBs in size.\n+    let out = out.into_bytes();\n+    assert_eq!(expected.len(), out.len());\n+    assert_eq!(expected, out);\n+}\n+\n+#[test]\n+fn test_abbreviate_filterss_are_detected() {\n+    let mut out = ProcOutput::new();\n+    let filters = &[\"foo\".to_string(), \"quux\".to_string()];\n+\n+    out.extend(b\"Hello foo\", filters);\n+    // Check items from a previous extension are not double-counted.\n+    out.extend(b\"! This is a qu\", filters);\n+    // Check items are detected across extensions.\n+    out.extend(b\"ux.\", filters);\n+\n+    match &out {\n+        ProcOutput::Full { bytes, filtered_len } => assert_eq!(\n+            *filtered_len,\n+            bytes.len() + FILTERED_PATHS_PLACEHOLDER_LEN * filters.len()\n+                - filters.iter().map(|i| i.len()).sum::<usize>()\n+        ),\n+        ProcOutput::Abbreviated { .. } => panic!(\"out should not be abbreviated\"),\n+    }\n+\n+    assert_eq!(b\"Hello foo! This is a quux.\", &*out.into_bytes());\n+}\n+\n+#[test]\n+fn test_abbreviate_filters_avoid_abbreviations() {\n+    let mut out = ProcOutput::new();\n+    let filters = &[std::iter::repeat('a').take(64).collect::<String>()];\n+\n+    let mut expected = vec![b'.'; HEAD_LEN - FILTERED_PATHS_PLACEHOLDER_LEN as usize];\n+    expected.extend_from_slice(filters[0].as_bytes());\n+    expected.extend_from_slice(&vec![b'.'; TAIL_LEN]);\n+\n+    out.extend(&expected, filters);\n+\n+    // We first check the length to avoid endless terminal output if the length differs, since\n+    // `out` is hundreds of KBs in size.\n+    let out = out.into_bytes();\n+    assert_eq!(expected.len(), out.len());\n+    assert_eq!(expected, out);\n+}\n+\n+#[test]\n+fn test_abbreviate_filters_can_still_cause_abbreviations() {\n+    let mut out = ProcOutput::new();\n+    let filters = &[std::iter::repeat('a').take(64).collect::<String>()];\n+\n+    let mut input = vec![b'.'; HEAD_LEN];\n+    input.extend_from_slice(&vec![b'.'; TAIL_LEN]);\n+    input.extend_from_slice(filters[0].as_bytes());\n+\n+    let mut expected = vec![b'.'; HEAD_LEN];\n+    expected.extend_from_slice(b\"\\n\\n<<<<<< SKIPPED 64 BYTES >>>>>>\\n\\n\");\n+    expected.extend_from_slice(&vec![b'.'; TAIL_LEN - 64]);\n+    expected.extend_from_slice(&vec![b'a'; 64]);\n+\n+    out.extend(&input, filters);\n+\n+    // We first check the length to avoid endless terminal output if the length differs, since\n+    // `out` is hundreds of KBs in size.\n+    let out = out.into_bytes();\n+    assert_eq!(expected.len(), out.len());\n+    assert_eq!(expected, out);\n+}"}, {"sha": "235919b16fc9c6b8d24aa251af75ccac48931424", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6609c6734de4df43e24d7672f8ae8786ecc8047e/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6609c6734de4df43e24d7672f8ae8786ecc8047e/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=6609c6734de4df43e24d7672f8ae8786ecc8047e", "patch": "@@ -28,7 +28,7 @@ use std::hash::{Hash, Hasher};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::path::{Path, PathBuf};\n-use std::process::{Command, ExitStatus, Output, Stdio};\n+use std::process::{Child, Command, ExitStatus, Output, Stdio};\n use std::str;\n \n use glob::glob;\n@@ -1745,6 +1745,28 @@ impl<'test> TestCx<'test> {\n         dylib\n     }\n \n+    fn read2_abbreviated(&self, child: Child) -> Output {\n+        let mut filter_paths_from_len = Vec::new();\n+        let mut add_path = |path: &Path| {\n+            let path = path.display().to_string();\n+            let windows = path.replace(\"\\\\\", \"\\\\\\\\\");\n+            if windows != path {\n+                filter_paths_from_len.push(windows);\n+            }\n+            filter_paths_from_len.push(path);\n+        };\n+\n+        // List of paths that will not be measured when determining whether the output is larger\n+        // than the output truncation threshold.\n+        //\n+        // Note: avoid adding a subdirectory of an already filtered directory here, otherwise the\n+        // same slice of text will be double counted and the truncation might not happen.\n+        add_path(&self.config.src_base);\n+        add_path(&self.config.build_base);\n+\n+        read2_abbreviated(child, &filter_paths_from_len).expect(\"failed to read output\")\n+    }\n+\n     fn compose_and_run(\n         &self,\n         mut command: Command,\n@@ -1779,8 +1801,7 @@ impl<'test> TestCx<'test> {\n             child.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n         }\n \n-        let Output { status, stdout, stderr } =\n-            read2_abbreviated(child).expect(\"failed to read output\");\n+        let Output { status, stdout, stderr } = self.read2_abbreviated(child);\n \n         let result = ProcRes {\n             status,\n@@ -2969,7 +2990,7 @@ impl<'test> TestCx<'test> {\n             }\n         }\n \n-        let output = cmd.spawn().and_then(read2_abbreviated).expect(\"failed to spawn `make`\");\n+        let output = self.read2_abbreviated(cmd.spawn().expect(\"failed to spawn `make`\"));\n         if !output.status.success() {\n             let res = ProcRes {\n                 status: output.status,"}]}