{"sha": "ae7e62c50fb2974430cf401e24747bafef7f701a", "node_id": "C_kwDOAAsO6NoAKGFlN2U2MmM1MGZiMjk3NDQzMGNmNDAxZTI0NzQ3YmFmZWY3ZjcwMWE", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-02-08T11:11:54Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-02-11T09:19:08Z"}, "message": "Don't expand macros in the same expansion tree after overflow", "tree": {"sha": "cc2205a555f43e195146b7f454378dad629c30e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc2205a555f43e195146b7f454378dad629c30e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae7e62c50fb2974430cf401e24747bafef7f701a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmPnXYwACgkQ4laYqTBY\nYXF87xAAimVG8GXjKOf/927db2UZfZ577OLT61SWjgJyulJgMe7oFWm3ZZp1LlWf\nqSZaqZXfgM5NVIYKw/n8jyvZSt7jhTlfrhGPu7fqtKIcSpf7usGbc5bZQnaXih6e\n0QuDZCOZPNOT79xFKiY/CjLrT3MtUFBapAjciZSwIWBX+GSk07tdNGttjY7vXSFz\n0PKdQqLZTAhGT4E2r+1ZJnO4pw+qCPPlES74FSNalFIa8ls1Jv6xT6OPcXLr2TR0\nqC24rRP5UZznoF+FFdbNe2i+0uYqmE9mMgRFdmjkbqIxj9flxt402pMRgDCKpC7g\n+siXU09XqYXnuSu2dGQayUGhLs/noI9BfFsh21SCXc40gKtBtZ0ViQIZE1+cfHBI\nX6n2oQyifHPRvEv3U+ACxydIOPwFjEIhfwOBWlcsAfSUgYX5atwgkfQ8C1y++1mt\nDjQeYH3RGYZ7ZWqGaB/jfhXnxPTjpNn6PZNhDnFqpdio9KLauJY9FuzXaKEphZ4s\nekGHNyzWzzfWK+jhC9oW1Ry7yilsN7f9QUkqoL0OEtB+x3LigeGSPhHECDHfmEkb\nt+jVC2mc2fNtaLu+4rB84pfTivXtFCiiDo8ibv44PKrWjcl0T2QhBZShzbXehHUY\n1/hhSaqOJNUc2Jy9qnh7Y2UE5uXugePt53GirAG0d5Ec89MNrI8=\n=51I9\n-----END PGP SIGNATURE-----", "payload": "tree cc2205a555f43e195146b7f454378dad629c30e6\nparent 8011029d3a0f4014217e1ade75688c0f3c5305db\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1675854714 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1676107148 +0900\n\nDon't expand macros in the same expansion tree after overflow\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae7e62c50fb2974430cf401e24747bafef7f701a", "html_url": "https://github.com/rust-lang/rust/commit/ae7e62c50fb2974430cf401e24747bafef7f701a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae7e62c50fb2974430cf401e24747bafef7f701a/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8011029d3a0f4014217e1ade75688c0f3c5305db", "url": "https://api.github.com/repos/rust-lang/rust/commits/8011029d3a0f4014217e1ade75688c0f3c5305db", "html_url": "https://github.com/rust-lang/rust/commit/8011029d3a0f4014217e1ade75688c0f3c5305db"}], "stats": {"total": 163, "additions": 114, "deletions": 49}, "files": [{"sha": "8fd9255b8b130e1ea963cfbff333f88d6e462cc7", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 91, "deletions": 49, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/ae7e62c50fb2974430cf401e24747bafef7f701a/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae7e62c50fb2974430cf401e24747bafef7f701a/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=ae7e62c50fb2974430cf401e24747bafef7f701a", "patch": "@@ -19,7 +19,7 @@ use la_arena::{Arena, ArenaMap};\n use limit::Limit;\n use profile::Count;\n use rustc_hash::FxHashMap;\n-use syntax::{ast, AstPtr, SyntaxNodePtr};\n+use syntax::{ast, AstPtr, SyntaxNode, SyntaxNodePtr};\n \n use crate::{\n     attr::Attrs,\n@@ -51,7 +51,8 @@ pub struct Expander {\n     def_map: Arc<DefMap>,\n     current_file_id: HirFileId,\n     module: LocalModuleId,\n-    recursion_limit: usize,\n+    /// `recursion_depth == usize::MAX` indicates that the recursion limit has been reached.\n+    recursion_depth: usize,\n }\n \n impl CfgExpander {\n@@ -84,7 +85,7 @@ impl Expander {\n             def_map,\n             current_file_id,\n             module: module.local_id,\n-            recursion_limit: 0,\n+            recursion_depth: 0,\n         }\n     }\n \n@@ -93,47 +94,52 @@ impl Expander {\n         db: &dyn DefDatabase,\n         macro_call: ast::MacroCall,\n     ) -> Result<ExpandResult<Option<(Mark, T)>>, UnresolvedMacro> {\n-        if self.recursion_limit(db).check(self.recursion_limit + 1).is_err() {\n-            cov_mark::hit!(your_stack_belongs_to_me);\n-            return Ok(ExpandResult::only_err(ExpandError::Other(\n-                \"reached recursion limit during macro expansion\".into(),\n-            )));\n+        let mut unresolved_macro_err = None;\n+\n+        let result = self.within_limit(db, |this| {\n+            let macro_call = InFile::new(this.current_file_id, &macro_call);\n+\n+            let resolver =\n+                |path| this.resolve_path_as_macro(db, &path).map(|it| macro_id_to_def_id(db, it));\n+\n+            let mut err = None;\n+            let call_id = match macro_call.as_call_id_with_errors(\n+                db,\n+                this.def_map.krate(),\n+                resolver,\n+                &mut |e| {\n+                    err.get_or_insert(e);\n+                },\n+            ) {\n+                Ok(call_id) => call_id,\n+                Err(resolve_err) => {\n+                    unresolved_macro_err = Some(resolve_err);\n+                    return ExpandResult { value: None, err: None };\n+                }\n+            };\n+            ExpandResult { value: call_id.ok(), err }\n+        });\n+\n+        if let Some(err) = unresolved_macro_err {\n+            Err(err)\n+        } else {\n+            Ok(result)\n         }\n-\n-        let macro_call = InFile::new(self.current_file_id, &macro_call);\n-\n-        let resolver =\n-            |path| self.resolve_path_as_macro(db, &path).map(|it| macro_id_to_def_id(db, it));\n-\n-        let mut err = None;\n-        let call_id =\n-            macro_call.as_call_id_with_errors(db, self.def_map.krate(), resolver, &mut |e| {\n-                err.get_or_insert(e);\n-            })?;\n-        let call_id = match call_id {\n-            Ok(it) => it,\n-            Err(_) => {\n-                return Ok(ExpandResult { value: None, err });\n-            }\n-        };\n-\n-        Ok(self.enter_expand_inner(db, call_id, err))\n     }\n \n     pub fn enter_expand_id<T: ast::AstNode>(\n         &mut self,\n         db: &dyn DefDatabase,\n         call_id: MacroCallId,\n     ) -> ExpandResult<Option<(Mark, T)>> {\n-        self.enter_expand_inner(db, call_id, None)\n+        self.within_limit(db, |_this| ExpandResult::ok(Some(call_id)))\n     }\n \n-    fn enter_expand_inner<T: ast::AstNode>(\n-        &mut self,\n+    fn enter_expand_inner(\n         db: &dyn DefDatabase,\n         call_id: MacroCallId,\n         mut err: Option<ExpandError>,\n-    ) -> ExpandResult<Option<(Mark, T)>> {\n+    ) -> ExpandResult<Option<(HirFileId, SyntaxNode)>> {\n         if err.is_none() {\n             err = db.macro_expand_error(call_id);\n         }\n@@ -154,29 +160,21 @@ impl Expander {\n             }\n         };\n \n-        let node = match T::cast(raw_node) {\n-            Some(it) => it,\n-            None => {\n-                // This can happen without being an error, so only forward previous errors.\n-                return ExpandResult { value: None, err };\n-            }\n-        };\n-\n-        tracing::debug!(\"macro expansion {:#?}\", node.syntax());\n-\n-        self.recursion_limit += 1;\n-        let mark =\n-            Mark { file_id: self.current_file_id, bomb: DropBomb::new(\"expansion mark dropped\") };\n-        self.cfg_expander.hygiene = Hygiene::new(db.upcast(), file_id);\n-        self.current_file_id = file_id;\n-\n-        ExpandResult { value: Some((mark, node)), err }\n+        ExpandResult { value: Some((file_id, raw_node)), err }\n     }\n \n     pub fn exit(&mut self, db: &dyn DefDatabase, mut mark: Mark) {\n         self.cfg_expander.hygiene = Hygiene::new(db.upcast(), mark.file_id);\n         self.current_file_id = mark.file_id;\n-        self.recursion_limit -= 1;\n+        if self.recursion_depth == usize::MAX {\n+            // Recursion limit has been reached somewhere in the macro expansion tree. Reset the\n+            // depth only when we get out of the tree.\n+            if !self.current_file_id.is_macro() {\n+                self.recursion_depth = 0;\n+            }\n+        } else {\n+            self.recursion_depth -= 1;\n+        }\n         mark.bomb.defuse();\n     }\n \n@@ -215,6 +213,50 @@ impl Expander {\n         #[cfg(test)]\n         return Limit::new(std::cmp::min(32, limit));\n     }\n+\n+    fn within_limit<F, T: ast::AstNode>(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        op: F,\n+    ) -> ExpandResult<Option<(Mark, T)>>\n+    where\n+        F: FnOnce(&mut Self) -> ExpandResult<Option<MacroCallId>>,\n+    {\n+        if self.recursion_depth == usize::MAX {\n+            // Recursion limit has been reached somewhere in the macro expansion tree. We should\n+            // stop expanding other macro calls in this tree, or else this may result in\n+            // exponential number of macro expansions, leading to a hang.\n+            //\n+            // The overflow error should have been reported when it occurred (see the next branch),\n+            // so don't return overflow error here to avoid diagnostics duplication.\n+            cov_mark::hit!(overflow_but_not_me);\n+            return ExpandResult::only_err(ExpandError::RecursionOverflowPosioned);\n+        } else if self.recursion_limit(db).check(self.recursion_depth + 1).is_err() {\n+            self.recursion_depth = usize::MAX;\n+            cov_mark::hit!(your_stack_belongs_to_me);\n+            return ExpandResult::only_err(ExpandError::Other(\n+                \"reached recursion limit during macro expansion\".into(),\n+            ));\n+        }\n+\n+        let ExpandResult { value, err } = op(self);\n+        let Some(call_id) = value else {\n+            return ExpandResult { value: None, err };\n+        };\n+\n+        Self::enter_expand_inner(db, call_id, err).map(|value| {\n+            value.and_then(|(new_file_id, node)| {\n+                let node = T::cast(node)?;\n+\n+                self.recursion_depth += 1;\n+                self.cfg_expander.hygiene = Hygiene::new(db.upcast(), new_file_id);\n+                let old_file_id = std::mem::replace(&mut self.current_file_id, new_file_id);\n+                let mark =\n+                    Mark { file_id: old_file_id, bomb: DropBomb::new(\"expansion mark dropped\") };\n+                Some((mark, node))\n+            })\n+        })\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "04b1c4f01e22a4f0c263d9dc794ae413b986abed", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae7e62c50fb2974430cf401e24747bafef7f701a/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae7e62c50fb2974430cf401e24747bafef7f701a/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=ae7e62c50fb2974430cf401e24747bafef7f701a", "patch": "@@ -624,6 +624,10 @@ impl ExprCollector<'_> {\n                         krate: *krate,\n                     });\n                 }\n+                Some(ExpandError::RecursionOverflowPosioned) => {\n+                    // Recursion limit has been reached in the macro expansion tree, but not in\n+                    // this very macro call. Don't add diagnostics to avoid duplication.\n+                }\n                 Some(err) => {\n                     self.source_map.diagnostics.push(BodyDiagnostic::MacroError {\n                         node: InFile::new(outer_file, syntax_ptr),\n@@ -636,6 +640,8 @@ impl ExprCollector<'_> {\n \n         match res.value {\n             Some((mark, expansion)) => {\n+                // Keep collecting even with expansion errors so we can provide completions and\n+                // other services in incomplete macro expressions.\n                 self.source_map.expansions.insert(macro_call_ptr, self.expander.current_file_id);\n                 let prev_ast_id_map = mem::replace(\n                     &mut self.ast_id_map,"}, {"sha": "edee2c7ff96bfb76809bf91a8a03f77e6bc0234b", "filename": "crates/hir-def/src/body/tests.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ae7e62c50fb2974430cf401e24747bafef7f701a/crates%2Fhir-def%2Fsrc%2Fbody%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae7e62c50fb2974430cf401e24747bafef7f701a/crates%2Fhir-def%2Fsrc%2Fbody%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Ftests.rs?ref=ae7e62c50fb2974430cf401e24747bafef7f701a", "patch": "@@ -61,6 +61,19 @@ fn main() { n_nuple!(1,2,3); }\n     );\n }\n \n+#[test]\n+fn your_stack_belongs_to_me2() {\n+    cov_mark::check!(overflow_but_not_me);\n+    lower(\n+        r#\"\n+macro_rules! foo {\n+    () => {{ foo!(); foo!(); }}\n+}\n+fn main() { foo!(); }\n+\"#,\n+    );\n+}\n+\n #[test]\n fn recursion_limit() {\n     cov_mark::check!(your_stack_belongs_to_me);"}, {"sha": "a52716cc02c2589fa459b1d6015e8b1c59747ed8", "filename": "crates/hir-expand/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae7e62c50fb2974430cf401e24747bafef7f701a/crates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae7e62c50fb2974430cf401e24747bafef7f701a/crates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Flib.rs?ref=ae7e62c50fb2974430cf401e24747bafef7f701a", "patch": "@@ -55,6 +55,7 @@ pub type ExpandResult<T> = ValueResult<T, ExpandError>;\n pub enum ExpandError {\n     UnresolvedProcMacro(CrateId),\n     Mbe(mbe::ExpandError),\n+    RecursionOverflowPosioned,\n     Other(Box<str>),\n }\n \n@@ -69,6 +70,9 @@ impl fmt::Display for ExpandError {\n         match self {\n             ExpandError::UnresolvedProcMacro(_) => f.write_str(\"unresolved proc-macro\"),\n             ExpandError::Mbe(it) => it.fmt(f),\n+            ExpandError::RecursionOverflowPosioned => {\n+                f.write_str(\"overflow expanding the original macro\")\n+            }\n             ExpandError::Other(it) => f.write_str(it),\n         }\n     }"}]}