{"sha": "a32589f773be2c19e6b6307b5302d07ec3ab6db6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzMjU4OWY3NzNiZTJjMTllNmI2MzA3YjUzMDJkMDdlYzNhYjZkYjY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-14T15:54:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-14T15:54:38Z"}, "message": "Merge #8837\n\n8837: internal: rewrite assoc item manipulaion to use mutable trees r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "3a6f291d7396ef77dfe8114a21a749f7dfa96b03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a6f291d7396ef77dfe8114a21a749f7dfa96b03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a32589f773be2c19e6b6307b5302d07ec3ab6db6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgnp0+CRBK7hj4Ov3rIwAA3gIIAGpYGdv3c0gTQHjS86c6FjnB\nbrTUqKnOr+6cTEY1v2VOc5M7D0Q0ZQiTmVmEd05sm4AACOBOInb5ZmChFbxGcRHT\n2DxFulBZeaSpzogY0qnBJjNcXWqlUPYpuSUIhhWB+O2YgrALjNqSSOhhh3ImA5PA\n7MaMFXGuGTgTwyg4nsYnvO4qLrrym3QclciV7Vtb/NJz0YFtzqF4jmI58xDWnPk+\nJboTJZ9/AUpSDzEsnsQrvZOcLLoHgx+J0YfcoalmHSHJNSDJ05nvGKxazNSkTTRQ\n7qxWtXmtEV7eU4mKZPly7pJkFhb9/rT/It5HNTneadsw4FewJbBHQy6rW0xyDjM=\n=53c5\n-----END PGP SIGNATURE-----\n", "payload": "tree 3a6f291d7396ef77dfe8114a21a749f7dfa96b03\nparent 73123a7550a667ebc42be96651a8e36be482a828\nparent 6c21d04307edf130851aefad406bacce9edbde23\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1621007678 +0000\ncommitter GitHub <noreply@github.com> 1621007678 +0000\n\nMerge #8837\n\n8837: internal: rewrite assoc item manipulaion to use mutable trees r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a32589f773be2c19e6b6307b5302d07ec3ab6db6", "html_url": "https://github.com/rust-lang/rust/commit/a32589f773be2c19e6b6307b5302d07ec3ab6db6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a32589f773be2c19e6b6307b5302d07ec3ab6db6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73123a7550a667ebc42be96651a8e36be482a828", "url": "https://api.github.com/repos/rust-lang/rust/commits/73123a7550a667ebc42be96651a8e36be482a828", "html_url": "https://github.com/rust-lang/rust/commit/73123a7550a667ebc42be96651a8e36be482a828"}, {"sha": "6c21d04307edf130851aefad406bacce9edbde23", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c21d04307edf130851aefad406bacce9edbde23", "html_url": "https://github.com/rust-lang/rust/commit/6c21d04307edf130851aefad406bacce9edbde23"}], "stats": {"total": 408, "additions": 187, "deletions": 221}, "files": [{"sha": "8225ae22c6a58b6929ac738b404b958ed0a9933c", "filename": "crates/ide_assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a32589f773be2c19e6b6307b5302d07ec3ab6db6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32589f773be2c19e6b6307b5302d07ec3ab6db6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=a32589f773be2c19e6b6307b5302d07ec3ab6db6", "patch": "@@ -64,7 +64,6 @@ pub(crate) fn add_missing_impl_members(acc: &mut Assists, ctx: &AssistContext) -\n // impl Trait for () {\n //     type X = ();\n //     fn foo(&self) {}$0\n-//\n // }\n // ```\n // ->\n@@ -195,6 +194,7 @@ impl Foo for S {\n     fn baz(&self) {\n         todo!()\n     }\n+\n }\"#,\n         );\n     }\n@@ -231,6 +231,7 @@ impl Foo for S {\n     fn foo(&self) {\n         ${0:todo!()}\n     }\n+\n }\"#,\n         );\n     }"}, {"sha": "959a1f86cb576812ed5d9bb1bd8b2ef5f3f1eee9", "filename": "crates/ide_assists/src/handlers/generate_new.rs", "status": "modified", "additions": 99, "deletions": 54, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/a32589f773be2c19e6b6307b5302d07ec3ab6db6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32589f773be2c19e6b6307b5302d07ec3ab6db6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs?ref=a32589f773be2c19e6b6307b5302d07ec3ab6db6", "patch": "@@ -1,4 +1,3 @@\n-use ast::Adt;\n use itertools::Itertools;\n use stdx::format_to;\n use syntax::ast::{self, AstNode, NameOwner, StructKind, VisibilityOwner};\n@@ -37,7 +36,7 @@ pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     };\n \n     // Return early if we've found an existing new fn\n-    let impl_def = find_struct_impl(&ctx, &Adt::Struct(strukt.clone()), \"new\")?;\n+    let impl_def = find_struct_impl(&ctx, &ast::Adt::Struct(strukt.clone()), \"new\")?;\n \n     let target = strukt.syntax().text_range();\n     acc.add(AssistId(\"generate_new\", AssistKind::Generate), \"Generate `new`\", target, |builder| {\n@@ -60,7 +59,7 @@ pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n         let start_offset = impl_def\n             .and_then(|impl_def| find_impl_block_start(impl_def, &mut buf))\n             .unwrap_or_else(|| {\n-                buf = generate_impl_text(&Adt::Struct(strukt.clone()), &buf);\n+                buf = generate_impl_text(&ast::Adt::Struct(strukt.clone()), &buf);\n                 strukt.syntax().text_range().end()\n             });\n \n@@ -81,110 +80,142 @@ mod tests {\n     use super::*;\n \n     #[test]\n-    #[rustfmt::skip]\n     fn test_generate_new() {\n-        // Check output of generation\n         check_assist(\n             generate_new,\n-\"struct Foo {$0}\",\n-\"struct Foo {}\n+            r#\"\n+struct Foo {$0}\n+\"#,\n+            r#\"\n+struct Foo {}\n \n impl Foo {\n     fn $0new() -> Self { Self {  } }\n-}\",\n+}\n+\"#,\n         );\n         check_assist(\n             generate_new,\n-\"struct Foo<T: Clone> {$0}\",\n-\"struct Foo<T: Clone> {}\n+            r#\"\n+struct Foo<T: Clone> {$0}\n+\"#,\n+            r#\"\n+struct Foo<T: Clone> {}\n \n impl<T: Clone> Foo<T> {\n     fn $0new() -> Self { Self {  } }\n-}\",\n+}\n+\"#,\n         );\n         check_assist(\n             generate_new,\n-\"struct Foo<'a, T: Foo<'a>> {$0}\",\n-\"struct Foo<'a, T: Foo<'a>> {}\n+            r#\"\n+struct Foo<'a, T: Foo<'a>> {$0}\n+\"#,\n+            r#\"\n+struct Foo<'a, T: Foo<'a>> {}\n \n impl<'a, T: Foo<'a>> Foo<'a, T> {\n     fn $0new() -> Self { Self {  } }\n-}\",\n+}\n+\"#,\n         );\n         check_assist(\n             generate_new,\n-\"struct Foo { baz: String $0}\",\n-\"struct Foo { baz: String }\n+            r#\"\n+struct Foo { baz: String $0}\n+\"#,\n+            r#\"\n+struct Foo { baz: String }\n \n impl Foo {\n     fn $0new(baz: String) -> Self { Self { baz } }\n-}\",\n+}\n+\"#,\n         );\n         check_assist(\n             generate_new,\n-\"struct Foo { baz: String, qux: Vec<i32> $0}\",\n-\"struct Foo { baz: String, qux: Vec<i32> }\n+            r#\"\n+struct Foo { baz: String, qux: Vec<i32> $0}\n+\"#,\n+            r#\"\n+struct Foo { baz: String, qux: Vec<i32> }\n \n impl Foo {\n     fn $0new(baz: String, qux: Vec<i32>) -> Self { Self { baz, qux } }\n-}\",\n+}\n+\"#,\n         );\n+    }\n \n-        // Check that visibility modifiers don't get brought in for fields\n+    #[test]\n+    fn check_that_visibility_modifiers_dont_get_brought_in() {\n         check_assist(\n             generate_new,\n-\"struct Foo { pub baz: String, pub qux: Vec<i32> $0}\",\n-\"struct Foo { pub baz: String, pub qux: Vec<i32> }\n+            r#\"\n+struct Foo { pub baz: String, pub qux: Vec<i32> $0}\n+\"#,\n+            r#\"\n+struct Foo { pub baz: String, pub qux: Vec<i32> }\n \n impl Foo {\n     fn $0new(baz: String, qux: Vec<i32>) -> Self { Self { baz, qux } }\n-}\",\n+}\n+\"#,\n         );\n+    }\n \n-        // Check that it reuses existing impls\n+    #[test]\n+    fn check_it_reuses_existing_impls() {\n         check_assist(\n             generate_new,\n-\"struct Foo {$0}\n+            r#\"\n+struct Foo {$0}\n \n impl Foo {}\n-\",\n-\"struct Foo {}\n+\"#,\n+            r#\"\n+struct Foo {}\n \n impl Foo {\n     fn $0new() -> Self { Self {  } }\n }\n-\",\n+\"#,\n         );\n         check_assist(\n             generate_new,\n-\"struct Foo {$0}\n+            r#\"\n+struct Foo {$0}\n \n impl Foo {\n     fn qux(&self) {}\n }\n-\",\n-\"struct Foo {}\n+\"#,\n+            r#\"\n+struct Foo {}\n \n impl Foo {\n     fn $0new() -> Self { Self {  } }\n \n     fn qux(&self) {}\n }\n-\",\n+\"#,\n         );\n \n         check_assist(\n             generate_new,\n-\"struct Foo {$0}\n+            r#\"\n+struct Foo {$0}\n \n impl Foo {\n     fn qux(&self) {}\n     fn baz() -> i32 {\n         5\n     }\n }\n-\",\n-\"struct Foo {}\n+\"#,\n+            r#\"\n+struct Foo {}\n \n impl Foo {\n     fn $0new() -> Self { Self {  } }\n@@ -194,67 +225,79 @@ impl Foo {\n         5\n     }\n }\n-\",\n+\"#,\n         );\n+    }\n \n-        // Check visibility of new fn based on struct\n+    #[test]\n+    fn check_visibility_of_new_fn_based_on_struct() {\n         check_assist(\n             generate_new,\n-\"pub struct Foo {$0}\",\n-\"pub struct Foo {}\n+            r#\"\n+pub struct Foo {$0}\n+\"#,\n+            r#\"\n+pub struct Foo {}\n \n impl Foo {\n     pub fn $0new() -> Self { Self {  } }\n-}\",\n+}\n+\"#,\n         );\n         check_assist(\n             generate_new,\n-\"pub(crate) struct Foo {$0}\",\n-\"pub(crate) struct Foo {}\n+            r#\"\n+pub(crate) struct Foo {$0}\n+\"#,\n+            r#\"\n+pub(crate) struct Foo {}\n \n impl Foo {\n     pub(crate) fn $0new() -> Self { Self {  } }\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn generate_new_not_applicable_if_fn_exists() {\n         check_assist_not_applicable(\n             generate_new,\n-            \"\n+            r#\"\n struct Foo {$0}\n \n impl Foo {\n     fn new() -> Self {\n         Self\n     }\n-}\",\n+}\n+\"#,\n         );\n \n         check_assist_not_applicable(\n             generate_new,\n-            \"\n+            r#\"\n struct Foo {$0}\n \n impl Foo {\n     fn New() -> Self {\n         Self\n     }\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn generate_new_target() {\n         check_assist_target(\n             generate_new,\n-            \"\n+            r#\"\n struct SomeThingIrrelevant;\n /// Has a lifetime parameter\n struct Foo<'a, T: Foo<'a>> {$0}\n struct EvenMoreIrrelevant;\n-\",\n+\"#,\n             \"/// Has a lifetime parameter\n struct Foo<'a, T: Foo<'a>> {}\",\n         );\n@@ -264,7 +307,7 @@ struct Foo<'a, T: Foo<'a>> {}\",\n     fn test_unrelated_new() {\n         check_assist(\n             generate_new,\n-            r##\"\n+            r#\"\n pub struct AstId<N: AstNode> {\n     file_id: HirFileId,\n     file_ast_id: FileAstId<N>,\n@@ -285,8 +328,9 @@ impl<T> Source<T> {\n     pub fn map<F: FnOnce(T) -> U, U>(self, f: F) -> Source<U> {\n         Source { file_id: self.file_id, ast: f(self.ast) }\n     }\n-}\"##,\n-            r##\"\n+}\n+\"#,\n+            r#\"\n pub struct AstId<N: AstNode> {\n     file_id: HirFileId,\n     file_ast_id: FileAstId<N>,\n@@ -309,7 +353,8 @@ impl<T> Source<T> {\n     pub fn map<F: FnOnce(T) -> U, U>(self, f: F) -> Source<U> {\n         Source { file_id: self.file_id, ast: f(self.ast) }\n     }\n-}\"##,\n+}\n+\"#,\n         );\n     }\n }"}, {"sha": "4406406a278f917ccf6e0c589b182a40e70ae949", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a32589f773be2c19e6b6307b5302d07ec3ab6db6/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32589f773be2c19e6b6307b5302d07ec3ab6db6/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=a32589f773be2c19e6b6307b5302d07ec3ab6db6", "patch": "@@ -50,7 +50,6 @@ trait Trait {\n impl Trait for () {\n     type X = ();\n     fn foo(&self) {}$0\n-\n }\n \"#####,\n         r#####\""}, {"sha": "7d562d1d4ed93cec521bd3acc7b99c98058b772e", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a32589f773be2c19e6b6307b5302d07ec3ab6db6/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32589f773be2c19e6b6307b5302d07ec3ab6db6/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=a32589f773be2c19e6b6307b5302d07ec3ab6db6", "patch": "@@ -128,15 +128,12 @@ pub fn add_trait_assoc_items_to_impl(\n     sema: &hir::Semantics<ide_db::RootDatabase>,\n     items: Vec<ast::AssocItem>,\n     trait_: hir::Trait,\n-    impl_def: ast::Impl,\n+    impl_: ast::Impl,\n     target_scope: hir::SemanticsScope,\n ) -> (ast::Impl, ast::AssocItem) {\n-    let impl_item_list = impl_def.assoc_item_list().unwrap_or_else(make::assoc_item_list);\n-\n-    let n_existing_items = impl_item_list.assoc_items().count();\n     let source_scope = sema.scope_for_def(trait_);\n     let ast_transform = QualifyPaths::new(&target_scope, &source_scope)\n-        .or(SubstituteTypeParams::for_trait_impl(&source_scope, trait_, impl_def.clone()));\n+        .or(SubstituteTypeParams::for_trait_impl(&source_scope, trait_, impl_.clone()));\n \n     let items = items\n         .into_iter()\n@@ -147,13 +144,18 @@ pub fn add_trait_assoc_items_to_impl(\n             ast::AssocItem::TypeAlias(def) => ast::AssocItem::TypeAlias(def.remove_bounds()),\n             _ => it,\n         })\n-        .map(|it| edit::remove_attrs_and_docs(&it));\n-\n-    let new_impl_item_list = impl_item_list.append_items(items);\n-    let new_impl_def = impl_def.with_assoc_item_list(new_impl_item_list);\n-    let first_new_item =\n-        new_impl_def.assoc_item_list().unwrap().assoc_items().nth(n_existing_items).unwrap();\n-    return (new_impl_def, first_new_item);\n+        .map(|it| edit::remove_attrs_and_docs(&it).clone_subtree().clone_for_update());\n+\n+    let res = impl_.clone_for_update();\n+    let assoc_item_list = res.get_or_create_assoc_item_list();\n+    let mut first_item = None;\n+    for item in items {\n+        if first_item.is_none() {\n+            first_item = Some(item.clone())\n+        }\n+        assoc_item_list.add_item(item)\n+    }\n+    return (res, first_item.unwrap());\n \n     fn add_body(fn_def: ast::Fn) -> ast::Fn {\n         match fn_def.body() {"}, {"sha": "7e4b8252efb17988317ffc12765e4929a4820772", "filename": "crates/syntax/src/ast/edit.rs", "status": "modified", "additions": 6, "deletions": 145, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/a32589f773be2c19e6b6307b5302d07ec3ab6db6/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32589f773be2c19e6b6307b5302d07ec3ab6db6/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs?ref=a32589f773be2c19e6b6307b5302d07ec3ab6db6", "patch": "@@ -80,81 +80,6 @@ where\n     }\n }\n \n-impl ast::Impl {\n-    #[must_use]\n-    pub fn with_assoc_item_list(&self, items: ast::AssocItemList) -> ast::Impl {\n-        let mut to_insert: ArrayVec<SyntaxElement, 2> = ArrayVec::new();\n-        if let Some(old_items) = self.assoc_item_list() {\n-            let to_replace: SyntaxElement = old_items.syntax().clone().into();\n-            to_insert.push(items.syntax().clone().into());\n-            self.replace_children(single_node(to_replace), to_insert)\n-        } else {\n-            to_insert.push(make::tokens::single_space().into());\n-            to_insert.push(items.syntax().clone().into());\n-            self.insert_children(InsertPosition::Last, to_insert)\n-        }\n-    }\n-}\n-\n-impl ast::AssocItemList {\n-    #[must_use]\n-    pub fn append_items(\n-        &self,\n-        items: impl IntoIterator<Item = ast::AssocItem>,\n-    ) -> ast::AssocItemList {\n-        let mut res = self.clone();\n-        if !self.syntax().text().contains_char('\\n') {\n-            res = make_multiline(res);\n-        }\n-        items.into_iter().for_each(|it| res = res.append_item(it));\n-        res.fixup_trailing_whitespace().unwrap_or(res)\n-    }\n-\n-    #[must_use]\n-    pub fn append_item(&self, item: ast::AssocItem) -> ast::AssocItemList {\n-        let (indent, position, whitespace) = match self.assoc_items().last() {\n-            Some(it) => (\n-                leading_indent(it.syntax()).unwrap_or_default().to_string(),\n-                InsertPosition::After(it.syntax().clone().into()),\n-                \"\\n\\n\",\n-            ),\n-            None => match self.l_curly_token() {\n-                Some(it) => (\n-                    \"    \".to_string() + &leading_indent(self.syntax()).unwrap_or_default(),\n-                    InsertPosition::After(it.into()),\n-                    \"\\n\",\n-                ),\n-                None => return self.clone(),\n-            },\n-        };\n-        let ws = tokens::WsBuilder::new(&format!(\"{}{}\", whitespace, indent));\n-        let to_insert: ArrayVec<SyntaxElement, 2> =\n-            [ws.ws().into(), item.syntax().clone().into()].into();\n-        self.insert_children(position, to_insert)\n-    }\n-\n-    /// Remove extra whitespace between last item and closing curly brace.\n-    fn fixup_trailing_whitespace(&self) -> Option<ast::AssocItemList> {\n-        let first_token_after_items =\n-            self.assoc_items().last()?.syntax().next_sibling_or_token()?;\n-        let last_token_before_curly = self.r_curly_token()?.prev_sibling_or_token()?;\n-        if last_token_before_curly != first_token_after_items {\n-            // there is something more between last item and\n-            // right curly than just whitespace - bail out\n-            return None;\n-        }\n-        let whitespace =\n-            last_token_before_curly.clone().into_token().and_then(ast::Whitespace::cast)?;\n-        let text = whitespace.syntax().text();\n-        let newline = text.rfind('\\n')?;\n-        let keep = tokens::WsBuilder::new(&text[newline..]);\n-        Some(self.replace_children(\n-            first_token_after_items..=last_token_before_curly,\n-            std::iter::once(keep.ws().into()),\n-        ))\n-    }\n-}\n-\n impl ast::RecordExprFieldList {\n     #[must_use]\n     pub fn append_field(&self, field: &ast::RecordExprField) -> ast::RecordExprFieldList {\n@@ -246,21 +171,6 @@ impl ast::TypeAlias {\n     }\n }\n \n-impl ast::TypeParam {\n-    #[must_use]\n-    pub fn remove_bounds(&self) -> ast::TypeParam {\n-        let colon = match self.colon_token() {\n-            Some(it) => it,\n-            None => return self.clone(),\n-        };\n-        let end = match self.type_bound_list() {\n-            Some(it) => it.syntax().clone().into(),\n-            None => colon.clone().into(),\n-        };\n-        self.replace_children(colon.into()..=end, iter::empty())\n-    }\n-}\n-\n impl ast::Path {\n     #[must_use]\n     pub fn with_segment(&self, segment: ast::PathSegment) -> ast::Path {\n@@ -411,61 +321,6 @@ impl ast::MatchArmList {\n     }\n }\n \n-impl ast::GenericParamList {\n-    #[must_use]\n-    pub fn append_params(\n-        &self,\n-        params: impl IntoIterator<Item = ast::GenericParam>,\n-    ) -> ast::GenericParamList {\n-        let mut res = self.clone();\n-        params.into_iter().for_each(|it| res = res.append_param(it));\n-        res\n-    }\n-\n-    #[must_use]\n-    pub fn append_param(&self, item: ast::GenericParam) -> ast::GenericParamList {\n-        let space = tokens::single_space();\n-\n-        let mut to_insert: ArrayVec<SyntaxElement, 4> = ArrayVec::new();\n-        if self.generic_params().next().is_some() {\n-            to_insert.push(space.into());\n-        }\n-        to_insert.push(item.syntax().clone().into());\n-\n-        macro_rules! after_l_angle {\n-            () => {{\n-                let anchor = match self.l_angle_token() {\n-                    Some(it) => it.into(),\n-                    None => return self.clone(),\n-                };\n-                InsertPosition::After(anchor)\n-            }};\n-        }\n-\n-        macro_rules! after_field {\n-            ($anchor:expr) => {\n-                if let Some(comma) = $anchor\n-                    .syntax()\n-                    .siblings_with_tokens(Direction::Next)\n-                    .find(|it| it.kind() == T![,])\n-                {\n-                    InsertPosition::After(comma)\n-                } else {\n-                    to_insert.insert(0, make::token(T![,]).into());\n-                    InsertPosition::After($anchor.syntax().clone().into())\n-                }\n-            };\n-        }\n-\n-        let position = match self.generic_params().last() {\n-            Some(it) => after_field!(it),\n-            None => after_l_angle!(),\n-        };\n-\n-        self.insert_children(position, to_insert)\n-    }\n-}\n-\n #[must_use]\n pub fn remove_attrs_and_docs<N: ast::AttrsOwner>(node: &N) -> N {\n     N::cast(remove_attrs_and_docs_inner(node.syntax().clone())).unwrap()\n@@ -516,6 +371,12 @@ impl ops::Add<u8> for IndentLevel {\n }\n \n impl IndentLevel {\n+    pub fn single() -> IndentLevel {\n+        IndentLevel(0)\n+    }\n+    pub fn is_zero(&self) -> bool {\n+        self.0 == 0\n+    }\n     pub fn from_element(element: &SyntaxElement) -> IndentLevel {\n         match element {\n             rowan::NodeOrToken::Node(it) => IndentLevel::from_node(it),"}, {"sha": "9812e00c9d70b47e3cc95ca9399345ce8f31c146", "filename": "crates/syntax/src/ast/edit_in_place.rs", "status": "modified", "additions": 65, "deletions": 7, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a32589f773be2c19e6b6307b5302d07ec3ab6db6/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32589f773be2c19e6b6307b5302d07ec3ab6db6/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs?ref=a32589f773be2c19e6b6307b5302d07ec3ab6db6", "patch": "@@ -2,11 +2,16 @@\n \n use std::iter::empty;\n \n-use parser::T;\n+use parser::{SyntaxKind, T};\n+use rowan::SyntaxElement;\n \n use crate::{\n     algo::neighbor,\n-    ast::{self, edit::AstNodeEdit, make, GenericParamsOwner, WhereClause},\n+    ast::{\n+        self,\n+        edit::{AstNodeEdit, IndentLevel},\n+        make, GenericParamsOwner,\n+    },\n     ted::{self, Position},\n     AstNode, AstToken, Direction,\n };\n@@ -37,7 +42,7 @@ impl GenericParamsOwnerEdit for ast::Fn {\n         }\n     }\n \n-    fn get_or_create_where_clause(&self) -> WhereClause {\n+    fn get_or_create_where_clause(&self) -> ast::WhereClause {\n         if self.where_clause().is_none() {\n             let position = if let Some(ty) = self.ret_type() {\n                 Position::after(ty.syntax())\n@@ -67,7 +72,7 @@ impl GenericParamsOwnerEdit for ast::Impl {\n         }\n     }\n \n-    fn get_or_create_where_clause(&self) -> WhereClause {\n+    fn get_or_create_where_clause(&self) -> ast::WhereClause {\n         if self.where_clause().is_none() {\n             let position = if let Some(items) = self.assoc_item_list() {\n                 Position::before(items.syntax())\n@@ -97,7 +102,7 @@ impl GenericParamsOwnerEdit for ast::Trait {\n         }\n     }\n \n-    fn get_or_create_where_clause(&self) -> WhereClause {\n+    fn get_or_create_where_clause(&self) -> ast::WhereClause {\n         if self.where_clause().is_none() {\n             let position = if let Some(items) = self.assoc_item_list() {\n                 Position::before(items.syntax())\n@@ -127,7 +132,7 @@ impl GenericParamsOwnerEdit for ast::Struct {\n         }\n     }\n \n-    fn get_or_create_where_clause(&self) -> WhereClause {\n+    fn get_or_create_where_clause(&self) -> ast::WhereClause {\n         if self.where_clause().is_none() {\n             let tfl = self.field_list().and_then(|fl| match fl {\n                 ast::FieldList::RecordFieldList(_) => None,\n@@ -165,7 +170,7 @@ impl GenericParamsOwnerEdit for ast::Enum {\n         }\n     }\n \n-    fn get_or_create_where_clause(&self) -> WhereClause {\n+    fn get_or_create_where_clause(&self) -> ast::WhereClause {\n         if self.where_clause().is_none() {\n             let position = if let Some(gpl) = self.generic_param_list() {\n                 Position::after(gpl.syntax())\n@@ -272,6 +277,59 @@ impl ast::Use {\n     }\n }\n \n+impl ast::Impl {\n+    pub fn get_or_create_assoc_item_list(&self) -> ast::AssocItemList {\n+        if self.assoc_item_list().is_none() {\n+            let assoc_item_list = make::assoc_item_list().clone_for_update();\n+            ted::append_child(self.syntax(), assoc_item_list.syntax());\n+        }\n+        self.assoc_item_list().unwrap()\n+    }\n+}\n+\n+impl ast::AssocItemList {\n+    pub fn add_item(&self, item: ast::AssocItem) {\n+        let (indent, position, whitespace) = match self.assoc_items().last() {\n+            Some(last_item) => (\n+                IndentLevel::from_node(last_item.syntax()),\n+                Position::after(last_item.syntax()),\n+                \"\\n\\n\",\n+            ),\n+            None => match self.l_curly_token() {\n+                Some(l_curly) => {\n+                    self.normalize_ws_between_braces();\n+                    (IndentLevel::from_token(&l_curly) + 1, Position::after(&l_curly), \"\\n\")\n+                }\n+                None => (IndentLevel::single(), Position::last_child_of(self.syntax()), \"\\n\"),\n+            },\n+        };\n+        let elements: Vec<SyntaxElement<_>> = vec![\n+            make::tokens::whitespace(&format!(\"{}{}\", whitespace, indent)).into(),\n+            item.syntax().clone().into(),\n+        ];\n+        ted::insert_all(position, elements);\n+    }\n+\n+    fn normalize_ws_between_braces(&self) -> Option<()> {\n+        let l = self.l_curly_token()?;\n+        let r = self.r_curly_token()?;\n+        let indent = IndentLevel::from_node(self.syntax());\n+\n+        match l.next_sibling_or_token() {\n+            Some(ws) if ws.kind() == SyntaxKind::WHITESPACE => {\n+                if ws.next_sibling_or_token()?.into_token()? == r {\n+                    ted::replace(ws, make::tokens::whitespace(&format!(\"\\n{}\", indent)));\n+                }\n+            }\n+            Some(ws) if ws.kind() == T!['}'] => {\n+                ted::insert(Position::after(l), make::tokens::whitespace(&format!(\"\\n{}\", indent)));\n+            }\n+            _ => (),\n+        }\n+        Some(())\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use std::fmt;"}, {"sha": "d13926deda891291c575773753a5cfa4bc5a9e00", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32589f773be2c19e6b6307b5302d07ec3ab6db6/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32589f773be2c19e6b6307b5302d07ec3ab6db6/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=a32589f773be2c19e6b6307b5302d07ec3ab6db6", "patch": "@@ -99,7 +99,7 @@ fn ty_from_text(text: &str) -> ast::Type {\n }\n \n pub fn assoc_item_list() -> ast::AssocItemList {\n-    ast_from_text(\"impl C for D {};\")\n+    ast_from_text(\"impl C for D {}\")\n }\n \n pub fn impl_trait(trait_: ast::Path, ty: ast::Path) -> ast::Impl {"}]}