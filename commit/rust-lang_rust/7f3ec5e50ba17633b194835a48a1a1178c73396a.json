{"sha": "7f3ec5e50ba17633b194835a48a1a1178c73396a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmM2VjNWU1MGJhMTc2MzNiMTk0ODM1YTQ4YTFhMTE3OGM3MzM5NmE=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-02-17T21:09:01Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-02-19T18:51:40Z"}, "message": "Make lookup of associated item by name O(log n)", "tree": {"sha": "f01475a0fc15806c63a1c7187863b5f401d836ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f01475a0fc15806c63a1c7187863b5f401d836ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f3ec5e50ba17633b194835a48a1a1178c73396a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f3ec5e50ba17633b194835a48a1a1178c73396a", "html_url": "https://github.com/rust-lang/rust/commit/7f3ec5e50ba17633b194835a48a1a1178c73396a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f3ec5e50ba17633b194835a48a1a1178c73396a/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bb7da2e4fa54519069fd110cf665cdf0407f58d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bb7da2e4fa54519069fd110cf665cdf0407f58d", "html_url": "https://github.com/rust-lang/rust/commit/3bb7da2e4fa54519069fd110cf665cdf0407f58d"}], "stats": {"total": 351, "additions": 216, "deletions": 135}, "files": [{"sha": "ca55d410ceba4695e537377243b2e52eb703d9f8", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -48,6 +48,7 @@ macro_rules! arena_types {\n             [] item_local_set: rustc_hir::ItemLocalSet,\n             [decode] mir_const_qualif: rustc_index::bit_set::BitSet<rustc::mir::Local>,\n             [] trait_impls_of: rustc::ty::trait_def::TraitImpls,\n+            [] associated_items: rustc::ty::AssociatedItems,\n             [] dropck_outlives:\n                 rustc::infer::canonical::Canonical<'tcx,\n                     rustc::infer::canonical::QueryResponse<'tcx,"}, {"sha": "06e20d0a2ae3071b4e69c34a79d68f8abd897ff1", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -325,7 +325,7 @@ rustc_queries! {\n         query associated_item(_: DefId) -> ty::AssocItem {}\n \n         /// Collects the associated items defined on a trait or impl.\n-        query associated_items(key: DefId) -> &'tcx [ty::AssocItem] {\n+        query associated_items(key: DefId) -> &'tcx ty::AssociatedItems {\n             desc { |tcx| \"collecting associated items of {}\", tcx.def_path_str(key) }\n         }\n "}, {"sha": "ee813bf606e9728b7ad8e834f405db1fa19613a6", "filename": "src/librustc/traits/specialization_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialization_graph.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -81,8 +81,8 @@ impl<'tcx> Node {\n     }\n \n     /// Iterate over the items defined directly by the given (impl or trait) node.\n-    pub fn items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [ty::AssocItem] {\n-        tcx.associated_items(self.def_id())\n+    pub fn items(&self, tcx: TyCtxt<'tcx>) -> impl 'tcx + Iterator<Item = &'tcx ty::AssocItem> {\n+        tcx.associated_items(self.def_id()).in_definition_order()\n     }\n \n     /// Finds an associated item defined in this node.\n@@ -99,7 +99,7 @@ impl<'tcx> Node {\n         use crate::ty::AssocKind::*;\n \n         tcx.associated_items(self.def_id())\n-            .iter()\n+            .filter_by_name_unhygienic(trait_item_name.name)\n             .find(move |impl_item| {\n                 match (trait_item_kind, impl_item.kind) {\n                 | (Const, Const)"}, {"sha": "851bffc2065c972d89c26a14242faa1a608eb7be", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -122,7 +122,7 @@ impl<'tcx> OverloadedDeref<'tcx> {\n         };\n         let method_def_id = tcx\n             .associated_items(trait_def_id.unwrap())\n-            .iter()\n+            .in_definition_order()\n             .find(|m| m.kind == ty::AssocKind::Method)\n             .unwrap()\n             .def_id;"}, {"sha": "0ec30bc583cf89971a3e1b3a2f9d8e0e8df62483", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -337,7 +337,7 @@ impl<'tcx> Instance<'tcx> {\n         let fn_once = tcx.lang_items().fn_once_trait().unwrap();\n         let call_once = tcx\n             .associated_items(fn_once)\n-            .iter()\n+            .in_definition_order()\n             .find(|it| it.kind == ty::AssocKind::Method)\n             .unwrap()\n             .def_id;"}, {"sha": "fa46f521ba5a7a624b67f3285dc822af8bf840ae", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 79, "deletions": 3, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -30,6 +30,7 @@ use rustc_attr as attr;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::fx::FxIndexMap;\n+use rustc_data_structures::sorted_map::SortedIndexMultiMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{self, par_iter, Lrc, ParallelIterator};\n use rustc_hir as hir;\n@@ -264,6 +265,81 @@ impl AssocItem {\n     }\n }\n \n+/// A list of `ty::AssocItem`s in definition order that allows for efficient lookup by name.\n+///\n+/// When doing lookup by name, we try to postpone hygienic comparison for as long as possible since\n+/// it is relatively expensive. Instead, items are indexed by `Symbol` and hygienic comparison is\n+/// done only on items with the same name.\n+#[derive(Debug, Clone, PartialEq, HashStable)]\n+pub struct AssociatedItems {\n+    items: SortedIndexMultiMap<u32, Symbol, ty::AssocItem>,\n+}\n+\n+impl AssociatedItems {\n+    /// Constructs an `AssociatedItems` map from a series of `ty::AssocItem`s in definition order.\n+    pub fn new(items_in_def_order: Vec<ty::AssocItem>) -> Self {\n+        let items = items_in_def_order.into_iter().map(|item| (item.ident.name, item)).collect();\n+        AssociatedItems { items }\n+    }\n+\n+    /// Returns a slice of associated items in the order they were defined.\n+    ///\n+    /// New code should avoid relying on definition order. If you need a particular associated item\n+    /// for a known trait, make that trait a lang item instead of indexing this array.\n+    pub fn in_definition_order(&self) -> impl '_ + Iterator<Item = &ty::AssocItem> {\n+        self.items.iter().map(|(_, v)| v)\n+    }\n+\n+    /// Returns an iterator over all associated items with the given name, ignoring hygiene.\n+    pub fn filter_by_name_unhygienic(\n+        &self,\n+        name: Symbol,\n+    ) -> impl '_ + Iterator<Item = &ty::AssocItem> {\n+        self.items.get_by_key(&name)\n+    }\n+\n+    /// Returns an iterator over all associated items with the given name.\n+    ///\n+    /// Multiple items may have the same name if they are in different `Namespace`s. For example,\n+    /// an associated type can have the same name as a method. Use one of the `find_by_name_and_*`\n+    /// methods below if you know which item you are looking for.\n+    pub fn filter_by_name(\n+        &'a self,\n+        tcx: TyCtxt<'a>,\n+        ident: Ident,\n+        parent_def_id: DefId,\n+    ) -> impl 'a + Iterator<Item = &'a ty::AssocItem> {\n+        self.filter_by_name_unhygienic(ident.name)\n+            .filter(move |item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n+    }\n+\n+    /// Returns the associated item with the given name and `AssocKind`, if one exists.\n+    pub fn find_by_name_and_kind(\n+        &self,\n+        tcx: TyCtxt<'_>,\n+        ident: Ident,\n+        kind: AssocKind,\n+        parent_def_id: DefId,\n+    ) -> Option<&ty::AssocItem> {\n+        self.filter_by_name_unhygienic(ident.name)\n+            .filter(|item| item.kind == kind)\n+            .find(|item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n+    }\n+\n+    /// Returns the associated item with the given name in the given `Namespace`, if one exists.\n+    pub fn find_by_name_and_namespace(\n+        &self,\n+        tcx: TyCtxt<'_>,\n+        ident: Ident,\n+        ns: Namespace,\n+        parent_def_id: DefId,\n+    ) -> Option<&ty::AssocItem> {\n+        self.filter_by_name_unhygienic(ident.name)\n+            .filter(|item| item.kind.namespace() == ns)\n+            .find(|item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n+    }\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq, Copy, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Visibility {\n     /// Visible everywhere (including in other crates).\n@@ -2738,14 +2814,14 @@ impl<'tcx> TyCtxt<'tcx> {\n             .for_each(|&body_id| f(self.hir().body_owner_def_id(body_id)));\n     }\n \n-    pub fn provided_trait_methods(self, id: DefId) -> impl Iterator<Item = &'tcx AssocItem> {\n+    pub fn provided_trait_methods(self, id: DefId) -> impl 'tcx + Iterator<Item = &'tcx AssocItem> {\n         self.associated_items(id)\n-            .iter()\n+            .in_definition_order()\n             .filter(|item| item.kind == AssocKind::Method && item.defaultness.has_value())\n     }\n \n     pub fn trait_relevant_for_never(self, did: DefId) -> bool {\n-        self.associated_items(did).iter().any(|item| item.relevant_for_never())\n+        self.associated_items(did).in_definition_order().any(|item| item.relevant_for_never())\n     }\n \n     pub fn opt_item_name(self, def_id: DefId) -> Option<Ident> {"}, {"sha": "c3698f402a9d120f520b29d440cbcb05628b79b1", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -1066,11 +1066,7 @@ impl<'tcx> ProjectionTy<'tcx> {\n     ) -> ProjectionTy<'tcx> {\n         let item_def_id = tcx\n             .associated_items(trait_ref.def_id)\n-            .iter()\n-            .find(|item| {\n-                item.kind == ty::AssocKind::Type\n-                    && tcx.hygienic_eq(item_name, item.ident, trait_ref.def_id)\n-            })\n+            .find_by_name_and_kind(tcx, item_name, ty::AssocKind::Type, trait_ref.def_id)\n             .unwrap()\n             .def_id;\n "}, {"sha": "eec6893d357d620838a109d226297531e39ce319", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -357,7 +357,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let mut dtor_did = None;\n         let ty = self.type_of(adt_did);\n         self.for_each_relevant_impl(drop_trait, ty, |impl_did| {\n-            if let Some(item) = self.associated_items(impl_did).first() {\n+            if let Some(item) = self.associated_items(impl_did).in_definition_order().nth(0) {\n                 if validate(self, impl_did).is_ok() {\n                     dtor_did = Some(item.def_id);\n                 }"}, {"sha": "b49f0062a9c91e891d657a532c0c05c7372d0c81", "filename": "src/librustc_infer/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fmod.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -537,7 +537,7 @@ fn vtable_methods<'tcx>(\n     tcx.arena.alloc_from_iter(supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n         let trait_methods = tcx\n             .associated_items(trait_ref.def_id())\n-            .iter()\n+            .in_definition_order()\n             .filter(|item| item.kind == ty::AssocKind::Method);\n \n         // Now list each method's DefId and InternalSubsts (for within its trait)."}, {"sha": "93eeb42a594a4e7348b5fe3194e03f299baeb081", "filename": "src/librustc_infer/traits/object_safety.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_infer%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_infer%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fobject_safety.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -213,7 +213,7 @@ fn object_safety_violations_for_trait(\n     // Check methods for violations.\n     let mut violations: Vec<_> = tcx\n         .associated_items(trait_def_id)\n-        .iter()\n+        .in_definition_order()\n         .filter(|item| item.kind == ty::AssocKind::Method)\n         .filter_map(|item| {\n             object_safety_violation_for_method(tcx, trait_def_id, &item)\n@@ -289,7 +289,7 @@ fn object_safety_violations_for_trait(\n \n     violations.extend(\n         tcx.associated_items(trait_def_id)\n-            .iter()\n+            .in_definition_order()\n             .filter(|item| item.kind == ty::AssocKind::Const)\n             .map(|item| ObjectSafetyViolation::AssocConst(item.ident.name, item.ident.span)),\n     );\n@@ -646,7 +646,7 @@ fn object_ty_for_trait<'tcx>(\n     let mut associated_types = traits::supertraits(tcx, ty::Binder::dummy(trait_ref))\n         .flat_map(|super_trait_ref| {\n             tcx.associated_items(super_trait_ref.def_id())\n-                .iter()\n+                .in_definition_order()\n                 .map(move |item| (super_trait_ref, item))\n         })\n         .filter(|(_, item)| item.kind == ty::AssocKind::Type)"}, {"sha": "1dca01b3468ae2fc4028c598f81cbbd96f4db661", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -586,7 +586,7 @@ pub fn count_own_vtable_entries(tcx: TyCtxt<'tcx>, trait_ref: ty::PolyTraitRef<'\n     let mut entries = 0;\n     // Count number of methods and add them to the total offset.\n     // Skip over associated types and constants.\n-    for trait_item in tcx.associated_items(trait_ref.def_id()) {\n+    for trait_item in tcx.associated_items(trait_ref.def_id()).in_definition_order() {\n         if trait_item.kind == ty::AssocKind::Method {\n             entries += 1;\n         }\n@@ -606,7 +606,7 @@ pub fn get_vtable_index_of_object_method<N>(\n     // add them to the total offset.\n     // Skip over associated types and constants.\n     let mut entries = object.vtable_base;\n-    for trait_item in tcx.associated_items(object.upcast_trait_ref.def_id()) {\n+    for trait_item in tcx.associated_items(object.upcast_trait_ref.def_id()).in_definition_order() {\n         if trait_item.def_id == method_def_id {\n             // The item with the ID we were given really ought to be a method.\n             assert_eq!(trait_item.kind, ty::AssocKind::Method);"}, {"sha": "993eb41b9b1a74c517576a005a8d292e5928c68b", "filename": "src/librustc_infer/traits/wf.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_infer%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_infer%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fwf.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -318,7 +318,10 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n             };\n \n         if let Elaborate::All = elaborate {\n-            let trait_assoc_items = tcx.associated_items(trait_ref.def_id);\n+            // FIXME: Make `extend_cause_with_original_assoc_item_obligation` take an iterator\n+            // instead of a slice.\n+            let trait_assoc_items: Vec<_> =\n+                tcx.associated_items(trait_ref.def_id).in_definition_order().copied().collect();\n \n             let predicates = obligations.iter().map(|obligation| obligation.predicate).collect();\n             let implied_obligations = traits::elaborate_predicates(tcx, predicates);\n@@ -327,7 +330,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 extend_cause_with_original_assoc_item_obligation(\n                     &mut cause,\n                     &pred,\n-                    trait_assoc_items,\n+                    &*trait_assoc_items,\n                 );\n                 traits::Obligation::new(cause, param_env, pred)\n             });"}, {"sha": "1f7db2861a2eb26b47b90c2b716050a1707eced6", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -68,7 +68,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n             let fn_mut = tcx.lang_items().fn_mut_trait().unwrap();\n             let call_mut = tcx\n                 .associated_items(fn_mut)\n-                .iter()\n+                .in_definition_order()\n                 .find(|it| it.kind == ty::AssocKind::Method)\n                 .unwrap()\n                 .def_id;"}, {"sha": "fab64e37cbc5a7cf92ac27af672bf4c537500ffd", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -539,7 +539,7 @@ where\n         debug!(\"destructor_call_block({:?}, {:?})\", self, succ);\n         let tcx = self.tcx();\n         let drop_trait = tcx.lang_items().drop_trait().unwrap();\n-        let drop_fn = tcx.associated_items(drop_trait)[0];\n+        let drop_fn = tcx.associated_items(drop_trait).in_definition_order().nth(0).unwrap();\n         let ty = self.place_ty(self.place);\n         let substs = tcx.mk_substs_trait(ty, &[]);\n "}, {"sha": "f4f7ab4bba65df20824f7be3560f945a9f1bf0e3", "filename": "src/librustc_mir_build/hair/cx/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -167,17 +167,19 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n         params: &[GenericArg<'tcx>],\n     ) -> &'tcx ty::Const<'tcx> {\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n-        for item in self.tcx.associated_items(trait_def_id) {\n-            // The unhygienic comparison here is acceptable because this is only\n-            // used on known traits.\n-            if item.kind == ty::AssocKind::Method && item.ident.name == method_name {\n-                let method_ty = self.tcx.type_of(item.def_id);\n-                let method_ty = method_ty.subst(self.tcx, substs);\n-                return ty::Const::zero_sized(self.tcx, method_ty);\n-            }\n-        }\n \n-        bug!(\"found no method `{}` in `{:?}`\", method_name, trait_def_id);\n+        // The unhygienic comparison here is acceptable because this is only\n+        // used on known traits.\n+        let item = self\n+            .tcx\n+            .associated_items(trait_def_id)\n+            .filter_by_name_unhygienic(method_name)\n+            .find(|item| item.kind == ty::AssocKind::Method)\n+            .expect(\"trait method not found\");\n+\n+        let method_ty = self.tcx.type_of(item.def_id);\n+        let method_ty = method_ty.subst(self.tcx, substs);\n+        ty::Const::zero_sized(self.tcx, method_ty)\n     }\n \n     crate fn all_fields(&mut self, adt_def: &ty::AdtDef, variant_index: VariantIdx) -> Vec<Field> {"}, {"sha": "5c2abb1efa4000ff617ee5e085d6f8a277f1b2a5", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -468,8 +468,8 @@ impl Visitor<'tcx> for Checker<'tcx> {\n                         let trait_item_def_id = self\n                             .tcx\n                             .associated_items(trait_did)\n-                            .iter()\n-                            .find(|item| item.ident.name == impl_item.ident.name)\n+                            .filter_by_name_unhygienic(impl_item.ident.name)\n+                            .next()\n                             .map(|item| item.def_id);\n                         if let Some(def_id) = trait_item_def_id {\n                             // Pass `None` to skip deprecation warnings."}, {"sha": "6e7ecf92441216cc71dd496c4bc46b4c8376da68", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -408,7 +408,6 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                         qualname.push_str(&self.tcx.hir().hir_to_pretty_string(self_ty.hir_id));\n \n                         let trait_id = self.tcx.trait_id_of_impl(impl_id);\n-                        let mut decl_id = None;\n                         let mut docs = String::new();\n                         let mut attrs = vec![];\n                         let hir_id = self.tcx.hir().node_to_hir_id(id);\n@@ -417,15 +416,18 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                             attrs = item.attrs.to_vec();\n                         }\n \n+                        let mut decl_id = None;\n                         if let Some(def_id) = trait_id {\n                             // A method in a trait impl.\n                             qualname.push_str(\" as \");\n                             qualname.push_str(&self.tcx.def_path_str(def_id));\n-                            self.tcx\n+\n+                            decl_id = self\n+                                .tcx\n                                 .associated_items(def_id)\n-                                .iter()\n-                                .find(|item| item.ident.name == ident.name)\n-                                .map(|item| decl_id = Some(item.def_id));\n+                                .filter_by_name_unhygienic(ident.name)\n+                                .next()\n+                                .map(|item| item.def_id);\n                         }\n                         qualname.push_str(\">\");\n \n@@ -716,12 +718,11 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             Res::Def(HirDefKind::Method, decl_id) => {\n                 let def_id = if decl_id.is_local() {\n                     let ti = self.tcx.associated_item(decl_id);\n+\n                     self.tcx\n                         .associated_items(ti.container.id())\n-                        .iter()\n-                        .find(|item| {\n-                            item.ident.name == ti.ident.name && item.defaultness.has_value()\n-                        })\n+                        .filter_by_name_unhygienic(ti.ident.name)\n+                        .find(|item| item.defaultness.has_value())\n                         .map(|item| item.def_id)\n                 } else {\n                     None"}, {"sha": "916a819090c4987f5ad6347793b0de6531a96dec", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -210,10 +210,10 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n     }\n }\n \n-fn associated_items<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx [ty::AssocItem] {\n-    tcx.arena.alloc_from_iter(\n-        tcx.associated_item_def_ids(def_id).iter().map(|did| tcx.associated_item(*did)),\n-    )\n+fn associated_items<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::AssociatedItems {\n+    let items =\n+        tcx.associated_item_def_ids(def_id).iter().map(|did| tcx.associated_item(*did)).collect();\n+    tcx.arena.alloc(ty::AssociatedItems::new(items))\n }\n \n fn def_span(tcx: TyCtxt<'_>, def_id: DefId) -> Span {"}, {"sha": "572d3f3264f9c5144ffc9563a1d35d79ad328d63", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -1108,10 +1108,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         trait_def_id: DefId,\n         assoc_name: ast::Ident,\n     ) -> bool {\n-        self.tcx().associated_items(trait_def_id).iter().any(|item| {\n-            item.kind == ty::AssocKind::Type\n-                && self.tcx().hygienic_eq(assoc_name, item.ident, trait_def_id)\n-        })\n+        self.tcx()\n+            .associated_items(trait_def_id)\n+            .find_by_name_and_kind(self.tcx(), assoc_name, ty::AssocKind::Type, trait_def_id)\n+            .is_some()\n     }\n \n     // Returns `true` if a bounds list includes `?Sized`.\n@@ -1344,9 +1344,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         let (assoc_ident, def_scope) =\n             tcx.adjust_ident_and_get_scope(binding.item_name, candidate.def_id(), hir_ref_id);\n+\n+        // FIXME(ecstaticmorse): Can this use `find_by_name_and_kind` instead?\n         let assoc_ty = tcx\n             .associated_items(candidate.def_id())\n-            .iter()\n+            .filter_by_name_unhygienic(assoc_ident.name)\n             .find(|i| i.kind == ty::AssocKind::Type && i.ident.modern() == assoc_ident)\n             .expect(\"missing associated type\");\n \n@@ -1512,7 +1514,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     ty::Predicate::Trait(pred, _) => {\n                         associated_types.entry(span).or_default().extend(\n                             tcx.associated_items(pred.def_id())\n-                                .iter()\n+                                .in_definition_order()\n                                 .filter(|item| item.kind == ty::AssocKind::Type)\n                                 .map(|item| item.def_id),\n                         );\n@@ -1967,14 +1969,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n             let mut where_bounds = vec![];\n             for bound in bounds {\n+                let bound_id = bound.def_id();\n                 let bound_span = self\n                     .tcx()\n-                    .associated_items(bound.def_id())\n-                    .iter()\n-                    .find(|item| {\n-                        item.kind == ty::AssocKind::Type\n-                            && self.tcx().hygienic_eq(assoc_name, item.ident, bound.def_id())\n-                    })\n+                    .associated_items(bound_id)\n+                    .find_by_name_and_kind(self.tcx(), assoc_name, ty::AssocKind::Type, bound_id)\n                     .and_then(|item| self.tcx().hir().span_if_local(item.def_id));\n \n                 if let Some(bound_span) = bound_span {\n@@ -2052,7 +2051,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         );\n \n         let all_candidate_names: Vec<_> = all_candidates()\n-            .map(|r| self.tcx().associated_items(r.def_id()))\n+            .map(|r| self.tcx().associated_items(r.def_id()).in_definition_order())\n             .flatten()\n             .filter_map(\n                 |item| if item.kind == ty::AssocKind::Type { Some(item.ident.name) } else { None },\n@@ -2198,9 +2197,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let trait_did = bound.def_id();\n         let (assoc_ident, def_scope) =\n             tcx.adjust_ident_and_get_scope(assoc_ident, trait_did, hir_ref_id);\n+\n+        // FIXME(ecstaticmorse): Can this use `find_by_name_and_namespace` instead?\n         let item = tcx\n             .associated_items(trait_did)\n-            .iter()\n+            .in_definition_order()\n             .find(|i| i.kind.namespace() == Namespace::TypeNS && i.ident.modern() == assoc_ident)\n             .expect(\"missing associated type\");\n "}, {"sha": "816de5dadbc1501e62dd0a6022635c95cf738638", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -248,7 +248,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if is_gen {\n             // Check that we deduce the signature from the `<_ as std::ops::Generator>::Return`\n             // associated item and not yield.\n-            let return_assoc_item = self.tcx.associated_items(gen_trait)[1].def_id;\n+            let return_assoc_item =\n+                self.tcx.associated_items(gen_trait).in_definition_order().nth(1).unwrap().def_id;\n             if return_assoc_item != projection.projection_def_id() {\n                 debug!(\"deduce_sig_from_projection: not return assoc item of generator\");\n                 return None;\n@@ -673,7 +674,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // The `Future` trait has only one associted item, `Output`,\n         // so check that this is what we see.\n-        let output_assoc_item = self.tcx.associated_items(future_trait)[0].def_id;\n+        let output_assoc_item =\n+            self.tcx.associated_items(future_trait).in_definition_order().nth(0).unwrap().def_id;\n         if output_assoc_item != predicate.projection_ty.item_def_id {\n             span_bug!(\n                 cause_span,"}, {"sha": "63ebf612964e0326e04e6c28a1460fb519f57732", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -539,7 +539,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let item_def_id = self\n                     .tcx\n                     .associated_items(deref_trait)\n-                    .iter()\n+                    .in_definition_order()\n                     .find(|item| item.kind == ty::AssocKind::Type)\n                     .unwrap()\n                     .def_id;"}, {"sha": "de824648a25d9ec366df0cee0b36eba9a27b0e6f", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -483,11 +483,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Option<ty::AssocItem> {\n         self.tcx\n             .associated_items(def_id)\n-            .iter()\n-            .find(|item| {\n-                Namespace::from(item.kind) == ns\n-                    && self.tcx.hygienic_eq(item_name, item.ident, def_id)\n-            })\n+            .find_by_name_and_namespace(self.tcx, item_name, ns, def_id)\n             .copied()\n     }\n }"}, {"sha": "ea90aef486839d3a8fb8ff8319c809ed9ff6e3f6", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -1696,7 +1696,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 let max_dist = max(name.as_str().len(), 3) / 3;\n                 self.tcx\n                     .associated_items(def_id)\n-                    .iter()\n+                    .in_definition_order()\n                     .filter(|x| {\n                         let dist = lev_distance(&*name.as_str(), &x.ident.as_str());\n                         x.kind.namespace() == Namespace::ValueNS && dist > 0 && dist <= max_dist\n@@ -1709,7 +1709,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     .map_or(Vec::new(), |x| vec![x])\n             }\n         } else {\n-            self.tcx.associated_items(def_id).to_vec()\n+            self.tcx.associated_items(def_id).in_definition_order().copied().collect()\n         }\n     }\n }"}, {"sha": "2f6d8b644c02ddaed4b186c8bc3c99fb315be7ec", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -1975,16 +1975,12 @@ fn check_impl_items_against_trait<'tcx>(\n         let ty_impl_item = tcx.associated_item(tcx.hir().local_def_id(impl_item.hir_id));\n         let ty_trait_item = tcx\n             .associated_items(impl_trait_ref.def_id)\n-            .iter()\n-            .find(|ac| {\n-                Namespace::from(&impl_item.kind) == Namespace::from(ac.kind)\n-                    && tcx.hygienic_eq(ty_impl_item.ident, ac.ident, impl_trait_ref.def_id)\n-            })\n+            .find_by_name_and_namespace(tcx, ty_impl_item.ident, namespace, impl_trait_ref.def_id)\n             .or_else(|| {\n                 // Not compatible, but needed for the error message\n                 tcx.associated_items(impl_trait_ref.def_id)\n-                    .iter()\n-                    .find(|ac| tcx.hygienic_eq(ty_impl_item.ident, ac.ident, impl_trait_ref.def_id))\n+                    .filter_by_name(tcx, ty_impl_item.ident, impl_trait_ref.def_id)\n+                    .next()\n             });\n \n         // Check that impl definition matches trait definition\n@@ -2088,7 +2084,7 @@ fn check_impl_items_against_trait<'tcx>(\n     let mut missing_items = Vec::new();\n     let mut invalidated_items = Vec::new();\n     let associated_type_overridden = overridden_associated_type.is_some();\n-    for trait_item in tcx.associated_items(impl_trait_ref.def_id) {\n+    for trait_item in tcx.associated_items(impl_trait_ref.def_id).in_definition_order() {\n         let is_implemented = trait_def\n             .ancestors(tcx, impl_id)\n             .leaf_def(tcx, trait_item.ident, trait_item.kind)\n@@ -5224,7 +5220,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // Check for `Future` implementations by constructing a predicate to\n                 // prove: `<T as Future>::Output == U`\n                 let future_trait = self.tcx.lang_items().future_trait().unwrap();\n-                let item_def_id = self.tcx.associated_items(future_trait)[0].def_id;\n+                let item_def_id = self\n+                    .tcx\n+                    .associated_items(future_trait)\n+                    .in_definition_order()\n+                    .nth(0)\n+                    .unwrap()\n+                    .def_id;\n                 let predicate =\n                     ty::Predicate::Projection(ty::Binder::bind(ty::ProjectionPredicate {\n                         // `<T as Future>::Output`"}, {"sha": "fcded27463e92d5860107066e8a77c347c78df9a", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -1,4 +1,4 @@\n-use rustc::ty::{AssocItem, TyCtxt};\n+use rustc::ty::TyCtxt;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n@@ -22,18 +22,18 @@ impl InherentOverlapChecker<'tcx> {\n         let impl_items1 = self.tcx.associated_items(impl1);\n         let impl_items2 = self.tcx.associated_items(impl2);\n \n-        for item1 in &impl_items1[..] {\n-            for item2 in &impl_items2[..] {\n-                // Avoid costly `.modern()` calls as much as possible by doing them as late as we\n-                // can. Compare raw symbols first.\n-                if item1.ident.name == item2.ident.name\n-                    && Namespace::from(item1.kind) == Namespace::from(item2.kind)\n-                {\n+        for item1 in impl_items1.in_definition_order() {\n+            let collision = impl_items2\n+                .filter_by_name_unhygienic(item1.ident.name)\n+                .find(|item2| {\n                     // Symbols and namespace match, compare hygienically.\n-                    if item1.ident.modern() == item2.ident.modern() {\n-                        return true;\n-                    }\n-                }\n+                    item1.kind.namespace() == item2.kind.namespace()\n+                        && item1.ident.modern() == item2.ident.modern()\n+                })\n+                .is_some();\n+\n+            if collision {\n+                return true;\n             }\n         }\n \n@@ -46,43 +46,43 @@ impl InherentOverlapChecker<'tcx> {\n         impl2: DefId,\n         overlap: traits::OverlapResult<'_>,\n     ) {\n-        let name_and_namespace =\n-            |assoc: &AssocItem| (assoc.ident.modern(), Namespace::from(assoc.kind));\n-\n         let impl_items1 = self.tcx.associated_items(impl1);\n         let impl_items2 = self.tcx.associated_items(impl2);\n \n-        for item1 in &impl_items1[..] {\n-            let (name, namespace) = name_and_namespace(item1);\n-\n-            for item2 in &impl_items2[..] {\n-                if (name, namespace) == name_and_namespace(item2) {\n-                    let mut err = struct_span_err!(\n-                        self.tcx.sess,\n-                        self.tcx.span_of_impl(item1.def_id).unwrap(),\n-                        E0592,\n-                        \"duplicate definitions with name `{}`\",\n-                        name\n-                    );\n-                    err.span_label(\n-                        self.tcx.span_of_impl(item1.def_id).unwrap(),\n-                        format!(\"duplicate definitions for `{}`\", name),\n-                    );\n-                    err.span_label(\n-                        self.tcx.span_of_impl(item2.def_id).unwrap(),\n-                        format!(\"other definition for `{}`\", name),\n-                    );\n-\n-                    for cause in &overlap.intercrate_ambiguity_causes {\n-                        cause.add_intercrate_ambiguity_hint(&mut err);\n-                    }\n-\n-                    if overlap.involves_placeholder {\n-                        traits::add_placeholder_note(&mut err);\n-                    }\n+        for item1 in impl_items1.in_definition_order() {\n+            let collision = impl_items2.filter_by_name_unhygienic(item1.ident.name).find(|item2| {\n+                // Symbols and namespace match, compare hygienically.\n+                item1.kind.namespace() == item2.kind.namespace()\n+                    && item1.ident.modern() == item2.ident.modern()\n+            });\n+\n+            if let Some(item2) = collision {\n+                let name = item1.ident.modern();\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    self.tcx.span_of_impl(item1.def_id).unwrap(),\n+                    E0592,\n+                    \"duplicate definitions with name `{}`\",\n+                    name\n+                );\n+                err.span_label(\n+                    self.tcx.span_of_impl(item1.def_id).unwrap(),\n+                    format!(\"duplicate definitions for `{}`\", name),\n+                );\n+                err.span_label(\n+                    self.tcx.span_of_impl(item2.def_id).unwrap(),\n+                    format!(\"other definition for `{}`\", name),\n+                );\n+\n+                for cause in &overlap.intercrate_ambiguity_causes {\n+                    cause.add_intercrate_ambiguity_hint(&mut err);\n+                }\n \n-                    err.emit();\n+                if overlap.involves_placeholder {\n+                    traits::add_placeholder_note(&mut err);\n                 }\n+\n+                err.emit();\n             }\n         }\n     }"}, {"sha": "4a1e2570d06c56e6620b2e6624bee7cf0606be0d", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -114,8 +114,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                             .cx\n                             .tcx\n                             .associated_items(impl_def_id)\n-                            .iter()\n-                            .copied()\n+                            .in_definition_order()\n                             .collect::<Vec<_>>()\n                             .clean(self.cx),\n                         polarity: None,"}, {"sha": "78222d21b934af7c153cc2a54578a68b4b9b2f1b", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -190,8 +190,10 @@ pub fn record_extern_fqn(cx: &DocContext<'_>, did: DefId, kind: clean::TypeKind)\n }\n \n pub fn build_external_trait(cx: &DocContext<'_>, did: DefId) -> clean::Trait {\n+    let trait_items =\n+        cx.tcx.associated_items(did).in_definition_order().map(|item| item.clean(cx)).collect();\n+\n     let auto_trait = cx.tcx.trait_def(did).has_auto_impl;\n-    let trait_items = cx.tcx.associated_items(did).iter().map(|item| item.clean(cx)).collect();\n     let predicates = cx.tcx.predicates_of(did);\n     let generics = (cx.tcx.generics_of(did), predicates).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n@@ -376,7 +378,7 @@ pub fn build_impl(\n     } else {\n         (\n             tcx.associated_items(did)\n-                .iter()\n+                .in_definition_order()\n                 .filter_map(|item| {\n                     if associated_trait.is_some() || item.vis == ty::Visibility::Public {\n                         Some(item.clean(cx))"}, {"sha": "0b27e5cf8060fc29b5afa8de440030711825868b", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f3ec5e50ba17633b194835a48a1a1178c73396a/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=7f3ec5e50ba17633b194835a48a1a1178c73396a", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     .tcx\n                     .inherent_impls(did)\n                     .iter()\n-                    .flat_map(|imp| cx.tcx.associated_items(*imp))\n+                    .flat_map(|imp| cx.tcx.associated_items(*imp).in_definition_order())\n                     .any(|item| item.ident.name == variant_name)\n                 {\n                     return Err(ErrorKind::ResolutionFailure);\n@@ -206,8 +206,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 return cx\n                     .tcx\n                     .associated_items(did)\n-                    .iter()\n-                    .find(|item| item.ident.name == item_name)\n+                    .filter_by_name_unhygienic(item_name)\n+                    .next()\n                     .and_then(|item| match item.kind {\n                         ty::AssocKind::Method => Some(\"method\"),\n                         _ => None,\n@@ -234,7 +234,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         .tcx\n                         .inherent_impls(did)\n                         .iter()\n-                        .flat_map(|imp| cx.tcx.associated_items(*imp))\n+                        .flat_map(|imp| cx.tcx.associated_items(*imp).in_definition_order())\n                         .find(|item| item.ident.name == item_name);\n                     if let Some(item) = item {\n                         let out = match item.kind {"}]}