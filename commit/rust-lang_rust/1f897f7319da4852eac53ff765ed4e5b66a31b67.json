{"sha": "1f897f7319da4852eac53ff765ed4e5b66a31b67", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmODk3ZjczMTlkYTQ4NTJlYWM1M2ZmNzY1ZWQ0ZTViNjZhMzFiNjc=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-26T21:46:00Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-26T21:46:00Z"}, "message": "Set `record_pat_syntax` more precisely in CompletionContext", "tree": {"sha": "db7303f0a209234cdaf5c57620175a3576d72c85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db7303f0a209234cdaf5c57620175a3576d72c85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f897f7319da4852eac53ff765ed4e5b66a31b67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f897f7319da4852eac53ff765ed4e5b66a31b67", "html_url": "https://github.com/rust-lang/rust/commit/1f897f7319da4852eac53ff765ed4e5b66a31b67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f897f7319da4852eac53ff765ed4e5b66a31b67/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "666fc1cec10a41f88db56dfb339785eb1e7dd521", "url": "https://api.github.com/repos/rust-lang/rust/commits/666fc1cec10a41f88db56dfb339785eb1e7dd521", "html_url": "https://github.com/rust-lang/rust/commit/666fc1cec10a41f88db56dfb339785eb1e7dd521"}], "stats": {"total": 99, "additions": 58, "deletions": 41}, "files": [{"sha": "b84e9a9674df13f2deb85f140e269678a61b2b96", "filename": "crates/ide_completion/src/completions/pattern.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1f897f7319da4852eac53ff765ed4e5b66a31b67/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f897f7319da4852eac53ff765ed4e5b66a31b67/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=1f897f7319da4852eac53ff765ed4e5b66a31b67", "patch": "@@ -1,17 +1,14 @@\n //! Completes constants and paths in patterns.\n \n-use crate::{context::IsPatOrConst, CompletionContext, Completions};\n+use crate::{context::PatternRefutability, CompletionContext, Completions};\n \n /// Completes constants and paths in patterns.\n pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n-    if ctx.is_pat_or_const == IsPatOrConst::No {\n-        return;\n-    }\n-    if ctx.record_pat_syntax.is_some() {\n-        return;\n-    }\n+    let refutable = match ctx.is_pat_or_const {\n+        Some(it) => it == PatternRefutability::Refutable,\n+        None => return,\n+    };\n \n-    let refutable = ctx.is_pat_or_const == IsPatOrConst::Refutable;\n     if refutable {\n         if let Some(hir::Adt::Enum(e)) =\n             ctx.expected_type.as_ref().and_then(|ty| ty.strip_references().as_adt())\n@@ -403,4 +400,31 @@ impl Foo {\n             \"#]],\n         )\n     }\n+\n+    #[test]\n+    fn completes_in_record_field_pat() {\n+        check_snippet(\n+            r#\"\n+struct Foo { bar: Bar }\n+struct Bar(u32);\n+fn outer(Foo { bar: $0 }: Foo) {}\n+\"#,\n+            expect![[r#\"\n+                bn Foo Foo { bar$1 }$0\n+                bn Bar Bar($1)$0\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn skips_in_record_field_pat_name() {\n+        check_snippet(\n+            r#\"\n+struct Foo { bar: Bar }\n+struct Bar(u32);\n+fn outer(Foo { bar$0 }: Foo) {}\n+\"#,\n+            expect![[r#\"\"#]],\n+        )\n+    }\n }"}, {"sha": "6dc6769df9a0a545f5b3ab855e8483d332cab314", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1f897f7319da4852eac53ff765ed4e5b66a31b67/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f897f7319da4852eac53ff765ed4e5b66a31b67/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=1f897f7319da4852eac53ff765ed4e5b66a31b67", "patch": "@@ -25,9 +25,8 @@ use crate::{\n     CompletionConfig,\n };\n \n-#[derive(Debug, PartialEq, Eq)]\n-pub(crate) enum IsPatOrConst {\n-    No,\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum PatternRefutability {\n     Refutable,\n     Irrefutable,\n }\n@@ -64,7 +63,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) is_label_ref: bool,\n \n     // potentially set if we are completing a name\n-    pub(super) is_pat_or_const: IsPatOrConst,\n+    pub(super) is_pat_or_const: Option<PatternRefutability>,\n     pub(super) is_param: bool,\n \n     /// FIXME: `ActiveParameter` is string-based, which is very very wrong\n@@ -169,7 +168,7 @@ impl<'a> CompletionContext<'a> {\n             active_parameter: ActiveParameter::at(db, position),\n             is_label_ref: false,\n             is_param: false,\n-            is_pat_or_const: IsPatOrConst::No,\n+            is_pat_or_const: None,\n             is_trivial_path: false,\n             path_qual: None,\n             after_if: false,\n@@ -473,19 +472,13 @@ impl<'a> CompletionContext<'a> {\n \n     fn classify_name(&mut self, original_file: &SyntaxNode, name: ast::Name, offset: TextSize) {\n         if let Some(bind_pat) = name.syntax().parent().and_then(ast::IdentPat::cast) {\n-            self.is_pat_or_const = IsPatOrConst::Refutable;\n+            self.is_pat_or_const = Some(PatternRefutability::Refutable);\n             // if any of these is here our bind pat can't be a const pat anymore\n             let complex_ident_pat = bind_pat.at_token().is_some()\n                 || bind_pat.ref_token().is_some()\n                 || bind_pat.mut_token().is_some();\n             if complex_ident_pat {\n-                self.is_pat_or_const = IsPatOrConst::No;\n-            } else if let Some(pat_field) =\n-                bind_pat.syntax().parent().and_then(ast::RecordPatField::cast)\n-            {\n-                if pat_field.name_ref().is_none() {\n-                    self.is_pat_or_const = IsPatOrConst::No;\n-                }\n+                self.is_pat_or_const = None;\n             } else {\n                 let irrefutable_pat = bind_pat.syntax().ancestors().find_map(|node| {\n                     match_ast! {\n@@ -499,19 +492,24 @@ impl<'a> CompletionContext<'a> {\n                 if let Some(Some(pat)) = irrefutable_pat {\n                     // This check is here since we could be inside a pattern in the initializer expression of the let statement.\n                     if pat.syntax().text_range().contains_range(bind_pat.syntax().text_range()) {\n-                        self.is_pat_or_const = IsPatOrConst::Irrefutable;\n+                        self.is_pat_or_const = Some(PatternRefutability::Irrefutable);\n                     }\n                 }\n+\n+                let is_name_in_field_pat = bind_pat\n+                    .syntax()\n+                    .parent()\n+                    .and_then(ast::RecordPatField::cast)\n+                    .map_or(false, |pat_field| pat_field.name_ref().is_none());\n+                if is_name_in_field_pat {\n+                    self.is_pat_or_const = None;\n+                }\n             }\n \n             self.fill_impl_def();\n         }\n-        if is_node::<ast::Param>(name.syntax()) {\n-            self.is_param = true;\n-            return;\n-        }\n-        // FIXME: remove this (V) duplication and make the check more precise\n-        if name.syntax().ancestors().find_map(ast::RecordPatFieldList::cast).is_some() {\n+        self.is_param |= is_node::<ast::Param>(name.syntax());\n+        if ast::RecordPatField::for_field_name(&name).is_some() {\n             self.record_pat_syntax =\n                 self.sema.find_node_at_offset_with_macros(&original_file, offset);\n         }\n@@ -523,22 +521,20 @@ impl<'a> CompletionContext<'a> {\n         name_ref: ast::NameRef,\n         offset: TextSize,\n     ) {\n-        // FIXME: remove this (^) duplication and make the check more precise\n-        if name_ref.syntax().ancestors().find_map(ast::RecordPatFieldList::cast).is_some() {\n+        self.fill_impl_def();\n+        if ast::RecordExprField::for_field_name(&name_ref).is_some() {\n+            self.record_lit_syntax =\n+                self.sema.find_node_at_offset_with_macros(original_file, offset);\n+        }\n+        if ast::RecordPatField::for_field_name_ref(&name_ref).is_some() {\n             self.record_pat_syntax =\n                 self.sema.find_node_at_offset_with_macros(&original_file, offset);\n         }\n \n         self.name_ref_syntax =\n             find_node_at_offset(original_file, name_ref.syntax().text_range().start());\n-        let name_range = name_ref.syntax().text_range();\n-        if ast::RecordExprField::for_field_name(&name_ref).is_some() {\n-            self.record_lit_syntax =\n-                self.sema.find_node_at_offset_with_macros(original_file, offset);\n-        }\n-\n-        self.fill_impl_def();\n \n+        let name_range = name_ref.syntax().text_range();\n         let top_node = name_ref\n             .syntax()\n             .ancestors()"}, {"sha": "91300c56e9379f10713d4e6b932fae1812a0d347", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1f897f7319da4852eac53ff765ed4e5b66a31b67/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f897f7319da4852eac53ff765ed4e5b66a31b67/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=1f897f7319da4852eac53ff765ed4e5b66a31b67", "patch": "@@ -20,7 +20,6 @@ use ide_db::{\n use syntax::TextRange;\n \n use crate::{\n-    context::IsPatOrConst,\n     item::{CompletionRelevanceTypeMatch, ImportEdit},\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, CompletionRelevance,\n };\n@@ -188,9 +187,7 @@ impl<'a> Render<'a> {\n             ScopeDef::ModuleDef(Function(func)) => {\n                 return render_fn(self.ctx, import_to_add, Some(local_name), *func);\n             }\n-            ScopeDef::ModuleDef(Variant(_))\n-                if self.ctx.completion.is_pat_or_const != IsPatOrConst::No =>\n-            {\n+            ScopeDef::ModuleDef(Variant(_)) if self.ctx.completion.is_pat_or_const.is_some() => {\n                 CompletionItemKind::SymbolKind(SymbolKind::Variant)\n             }\n             ScopeDef::ModuleDef(Variant(var)) => {"}]}