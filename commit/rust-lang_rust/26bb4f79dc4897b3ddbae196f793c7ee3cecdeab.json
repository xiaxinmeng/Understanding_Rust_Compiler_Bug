{"sha": "26bb4f79dc4897b3ddbae196f793c7ee3cecdeab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2YmI0Zjc5ZGM0ODk3YjNkZGJhZTE5NmY3OTNjN2VlM2NlY2RlYWI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-22T16:01:32Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-22T16:17:37Z"}, "message": "get rid of implicit Raw at bottom of stack; locals get a uniq at their bottom", "tree": {"sha": "fd7d042f00f54da6c4e5be76d25166db9c536ac1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd7d042f00f54da6c4e5be76d25166db9c536ac1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab", "html_url": "https://github.com/rust-lang/rust/commit/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01828fde5345299636f6c029b333f42e91ffd140", "url": "https://api.github.com/repos/rust-lang/rust/commits/01828fde5345299636f6c029b333f42e91ffd140", "html_url": "https://github.com/rust-lang/rust/commit/01828fde5345299636f6c029b333f42e91ffd140"}], "stats": {"total": 176, "additions": 134, "deletions": 42}, "files": [{"sha": "88c31f63fbb17b337ddf0305ba0fb1cf37644519", "filename": "src/fn_call.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=26bb4f79dc4897b3ddbae196f793c7ee3cecdeab", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 } else {\n                     let align = self.tcx.data_layout.pointer_align;\n                     let ptr = self.memory_mut().allocate(Size::from_bytes(size), align, MiriMemoryKind::C.into())?;\n-                    self.write_scalar(Scalar::Ptr(ptr), dest)?;\n+                    self.write_scalar(Scalar::Ptr(ptr.with_default_tag()), dest)?;\n                 }\n             }\n \n@@ -153,7 +153,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 let ptr = self.memory_mut().allocate(Size::from_bytes(size),\n                                                Align::from_bytes(align, align).unwrap(),\n                                                MiriMemoryKind::Rust.into())?;\n-                self.write_scalar(Scalar::Ptr(ptr), dest)?;\n+                self.write_scalar(Scalar::Ptr(ptr.with_default_tag()), dest)?;\n             }\n             \"__rust_alloc_zeroed\" => {\n                 let size = self.read_scalar(args[0])?.to_usize(&self)?;\n@@ -164,9 +164,11 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = self.memory_mut().allocate(Size::from_bytes(size),\n-                                               Align::from_bytes(align, align).unwrap(),\n-                                               MiriMemoryKind::Rust.into())?;\n+                let ptr = self.memory_mut().allocate(\n+                        Size::from_bytes(size),\n+                        Align::from_bytes(align, align).unwrap(),\n+                        MiriMemoryKind::Rust.into()\n+                    )?.with_default_tag();\n                 self.memory_mut().write_repeat(ptr.into(), 0, Size::from_bytes(size))?;\n                 self.write_scalar(Scalar::Ptr(ptr), dest)?;\n             }\n@@ -205,7 +207,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                     Align::from_bytes(align, align).unwrap(),\n                     MiriMemoryKind::Rust.into(),\n                 )?;\n-                self.write_scalar(Scalar::Ptr(new_ptr), dest)?;\n+                self.write_scalar(Scalar::Ptr(new_ptr.with_default_tag()), dest)?;\n             }\n \n             \"syscall\" => {\n@@ -390,7 +392,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                         Size::from_bytes((value.len() + 1) as u64),\n                         Align::from_bytes(1, 1).unwrap(),\n                         MiriMemoryKind::Env.into(),\n-                    )?;\n+                    )?.with_default_tag();\n                     self.memory_mut().write_bytes(value_copy.into(), &value)?;\n                     let trailing_zero_ptr = value_copy.offset(Size::from_bytes(value.len() as u64), &self)?.into();\n                     self.memory_mut().write_bytes(trailing_zero_ptr, &[0])?;"}, {"sha": "128b338f943dcca49de22b6b8c1dc5ef85310aa9", "filename": "src/lib.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=26bb4f79dc4897b3ddbae196f793c7ee3cecdeab", "patch": "@@ -108,7 +108,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         let mut args = ecx.frame().mir.args_iter();\n \n         // First argument: pointer to main()\n-        let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance);\n+        let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance).with_default_tag();\n         let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n         ecx.write_scalar(Scalar::Ptr(main_ptr), dest)?;\n \n@@ -119,7 +119,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         // FIXME: extract main source file path\n         // Third argument (argv): &[b\"foo\"]\n         let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-        let foo = ecx.memory_mut().allocate_static_bytes(b\"foo\\0\");\n+        let foo = ecx.memory_mut().allocate_static_bytes(b\"foo\\0\").with_default_tag();\n         let foo_ty = ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8);\n         let foo_layout = ecx.layout_of(foo_ty)?;\n         let foo_place = ecx.allocate(foo_layout, MiriMemoryKind::Env.into())?;\n@@ -404,7 +404,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         Ok(())\n     }\n \n-    fn static_with_default_tag(\n+    fn adjust_static_allocation(\n         alloc: &'_ Allocation\n     ) -> Cow<'_, Allocation<Borrow, Self::AllocExtra>> {\n         let alloc: Allocation<Borrow, Self::AllocExtra> = Allocation {\n@@ -477,4 +477,19 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n             Ok(MemPlace { ptr, ..place })\n         }\n     }\n+\n+    #[inline(always)]\n+    fn tag_new_allocation(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ptr: Pointer,\n+        kind: MemoryKind<Self::MemoryKinds>,\n+    ) -> EvalResult<'tcx, Pointer<Borrow>> {\n+        if !ecx.machine.validate {\n+            // No tracking\n+            Ok(ptr.with_default_tag())\n+        } else {\n+            let tag = ecx.tag_new_allocation(ptr.alloc_id, kind);\n+            Ok(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag))\n+        }\n+    }\n }"}, {"sha": "127958476bcb36608d8508eb8fdb350b252716df", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 65, "deletions": 17, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=26bb4f79dc4897b3ddbae196f793c7ee3cecdeab", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::{Ty, layout::Size};\n use rustc::hir;\n \n use super::{\n-    MemoryAccess, RangeMap, EvalResult,\n+    MemoryAccess, MemoryKind, MiriMemoryKind, RangeMap, EvalResult, AllocId,\n     Pointer,\n };\n \n@@ -104,7 +104,7 @@ struct Stack {\n impl Default for Stack {\n     fn default() -> Self {\n         Stack {\n-            borrows: Vec::new(),\n+            borrows: vec![BorStackItem::Mut(Mut::Raw)],\n             frozen_since: None,\n         }\n     }\n@@ -157,8 +157,8 @@ impl<'tcx> Stack {\n                 }\n             }\n         }\n-        // Simulate a \"virtual raw\" element at the bottom of the stack.\n-        acc_m.is_raw()\n+        // Nothing to be found.\n+        false\n     }\n \n     /// Reactive `bor` for this stack.  If `force_mut` is set, we want to aggressively\n@@ -204,12 +204,8 @@ impl<'tcx> Stack {\n                 }\n             }\n         }\n-        // Nothing to be found.  Simulate a \"virtual raw\" element at the bottom of the stack.\n-        if acc_m.is_raw() {\n-            Ok(())\n-        } else {\n-            err!(MachineError(format!(\"Borrow-to-reactivate does not exist on the stack\")))\n-        }\n+        // Nothing to be found.\n+        err!(MachineError(format!(\"Borrow-to-reactivate does not exist on the stack\")))\n     }\n \n     /// Initiate `bor`; mostly this means freezing or pushing.\n@@ -301,14 +297,35 @@ impl<'tcx> Stacks {\n             } else {\n                 // If we are creating a uniq ref, we certainly want to unfreeze.\n                 // Even if we are doing so from a raw.\n-                // FIXME: The blog post says we should `reset` if this is a local.\n+                // Notice that if this is a local, whenever we access it directly the\n+                // tag here will be the bottommost `Uniq` for that local.  That `Uniq`\n+                // never is accessible by the program, so it will not be used by any\n+                // other access.  IOW, whenever we directly use a local this will pop\n+                // everything else off the stack, invalidating all previous pointers\n+                // and, in particular, *all* raw pointers.  This subsumes the explicit\n+                // `reset` which the blog post [1] says to perform when accessing a local.\n+                //\n+                // [1] https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html\n                 stack.reactivate(ptr.tag, /*force_mut*/new_bor.is_uniq())?;\n                 stack.initiate(new_bor)?;\n             }\n         }\n \n         Ok(())\n     }\n+\n+    /// Pushes the first borrow to the stacks, must be a mutable one.\n+    pub fn first_borrow(\n+        &mut self,\n+        r#mut: Mut,\n+        size: Size\n+    ) {\n+        for stack in self.stacks.get_mut().iter_mut(Size::ZERO, size) {\n+            assert!(stack.borrows.len() == 1 && stack.frozen_since.is_none());\n+            assert_eq!(stack.borrows.pop().unwrap(), BorStackItem::Mut(Mut::Raw));\n+            stack.borrows.push(BorStackItem::Mut(r#mut));\n+        }\n+    }\n }\n \n pub trait EvalContextExt<'tcx> {\n@@ -334,6 +351,12 @@ pub trait EvalContextExt<'tcx> {\n         size: Size,\n         ref_kind: RefKind,\n     ) -> EvalResult<'tcx, Borrow>;\n+\n+    fn tag_new_allocation(\n+        &mut self,\n+        id: AllocId,\n+        kind: MemoryKind<MiriMemoryKind>,\n+    ) -> Borrow;\n }\n \n impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n@@ -400,23 +423,25 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         // Notably, the compiler can introduce such transmutes by optimizing away `&[mut]*`.\n         // That can transmute a raw ptr to a (shared/mut) ref, and a mut ref to a shared one.\n         match (ref_kind, ptr.tag) {\n-            (RefKind::Raw, Borrow::Mut(Mut::Raw)) |\n+            (RefKind::Raw, _) => {\n+                // Don't use the tag, this is a raw access!  Even if there is a tag,\n+                // that means transmute happened and we ignore the tag.\n+                // Also don't do any further validation, this is raw after all.\n+                return Ok(Borrow::Mut(Mut::Raw));\n+            }\n             (RefKind::Mut, Borrow::Mut(Mut::Uniq(_))) |\n             (RefKind::Shr, Borrow::Frz(_)) |\n             (RefKind::Shr, Borrow::Mut(Mut::Raw)) => {\n                 // Expected combinations.  Nothing to do.\n                 // FIXME: We probably shouldn't accept this if we got a raw shr without\n                 // interior mutability.\n             }\n-            (_, Borrow::Mut(Mut::Raw)) => {\n-                // Raw transmuted to (shr/mut) ref.  Keep this as raw access.\n+            (RefKind::Mut, Borrow::Mut(Mut::Raw)) => {\n+                // Raw transmuted to mut ref.  Keep this as raw access.\n                 // We cannot reborrow here; there might be a raw in `&(*var).1` where\n                 // `var` is an `&mut`.  The other field of the struct might be already frozen,\n                 // also using `var`, and that would be okay.\n             }\n-            (RefKind::Raw, _) => {\n-                // Someone transmuted a ref to a raw.  Treat this like a ref, their fault.\n-            }\n             (RefKind::Shr, Borrow::Mut(Mut::Uniq(_))) => {\n                 // A mut got transmuted to shr.  High time we freeze this location!\n                 // Make this a delayed reborrow.  Redundant reborows to shr are okay,\n@@ -451,4 +476,27 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         // All is good.\n         Ok(ptr.tag)\n     }\n+\n+    fn tag_new_allocation(\n+        &mut self,\n+        id: AllocId,\n+        kind: MemoryKind<MiriMemoryKind>,\n+    ) -> Borrow {\n+        let r#mut = match kind {\n+            MemoryKind::Stack => {\n+                // New unique borrow\n+                let time = self.machine.stacked_borrows.increment_clock();\n+                Mut::Uniq(time)\n+            }\n+            _ => {\n+                // Raw for everything else\n+                Mut::Raw\n+            }\n+        };\n+        // Make this the active borrow for this allocation\n+        let alloc = self.memory_mut().get_mut(id).expect(\"This is a new allocation, it must still exist\");\n+        let size = Size::from_bytes(alloc.bytes.len() as u64);\n+        alloc.extra.first_borrow(r#mut, size);\n+        Borrow::Mut(r#mut)\n+    }\n }"}, {"sha": "704711640f7d9814af065f51911feb721fecd6d7", "filename": "tests/compile-fail/copy_nonoverlapping.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Fcompile-fail%2Fcopy_nonoverlapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Fcompile-fail%2Fcopy_nonoverlapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopy_nonoverlapping.rs?ref=26bb4f79dc4897b3ddbae196f793c7ee3cecdeab", "patch": "@@ -10,6 +10,10 @@\n \n #![feature(core_intrinsics)]\n \n+// FIXME: Validation disabled because it doesn't let us escape an entire slice\n+// to the raw universe.\n+// compile-flags: -Zmiri-disable-validation\n+\n //error-pattern: copy_nonoverlapping called on overlapping ranges\n \n fn main() {"}, {"sha": "ff3a3cd82245c8a3bf3e942ac310672ebaf7bdc1", "filename": "tests/compile-fail/stacked_borrows/illegal_write1.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs?ref=26bb4f79dc4897b3ddbae196f793c7ee3cecdeab", "patch": "@@ -1,11 +1,12 @@\n fn evil(x: &u32) {\n-    let x : &mut u32 = unsafe { &mut *(x as *const _ as *mut _) };\n-    *x = 42; // mutating shared ref without `UnsafeCell`\n+    // mutating shared ref without `UnsafeCell`\n+    let x : *mut u32 = x as *const _ as *mut _;\n+    unsafe { *x = 42; }\n }\n \n fn main() {\n-    let target = 42;\n-    let ref_ = &target;\n-    evil(ref_); // invalidates shared ref\n+    let target = Box::new(42); // has an implicit raw\n+    let ref_ = &*target;\n+    evil(ref_); // invalidates shared ref, activates raw\n     let _x = *ref_; //~ ERROR Shr reference with non-reactivatable tag Frz\n }"}, {"sha": "f4fefaad5e22ddf82cdfe74b2fc5edbe0ac05a0e", "filename": "tests/compile-fail/stacked_borrows/illegal_write2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs?ref=26bb4f79dc4897b3ddbae196f793c7ee3cecdeab", "patch": "@@ -4,7 +4,7 @@ fn main() {\n     let target = &mut 42;\n     let target2 = target as *mut _;\n     drop(&mut *target); // reborrow\n-    // Now make sure our ref is still the only one\n-    unsafe { *target2 = 13; } // invalidate our ref\n-    let _val = *target; //~ ERROR Mut reference with non-reactivatable tag Mut(Uniq\n+    // Now make sure our ref is still the only one.\n+    unsafe { *target2 = 13; } //~ ERROR does not exist on the stack\n+    let _val = *target;\n }"}, {"sha": "a653aa5003f6d4da712027e3f1abe154941ccffe", "filename": "tests/compile-fail/stacked_borrows/illegal_write3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs?ref=26bb4f79dc4897b3ddbae196f793c7ee3cecdeab", "patch": "@@ -3,6 +3,6 @@ fn main() {\n     // Make sure raw ptr with raw tag cannot mutate frozen location without breaking the shared ref.\n     let r#ref = &target; // freeze\n     let ptr = r#ref as *const _ as *mut _; // raw ptr, with raw tag\n-    unsafe { *ptr = 42; }\n-    let _val = *r#ref; //~ ERROR Shr reference with non-reactivatable tag Frz\n+    unsafe { *ptr = 42; } //~ ERROR does not exist on the stack\n+    let _val = *r#ref;\n }"}, {"sha": "2006d7262f813aef81e7c8dd82c12cfb64d4e5a5", "filename": "tests/compile-fail/stacked_borrows/illegal_write4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write4.rs?ref=26bb4f79dc4897b3ddbae196f793c7ee3cecdeab", "patch": "@@ -26,6 +26,6 @@ fn main() {\n     let _val = *r#ref; // Make sure it is still frozen.\n \n     // We only actually unfreeze once we muteate through the bad pointer.\n-    unsafe { *bad_ptr = 42 };\n-    let _val = *r#ref; //~ ERROR Shr reference with non-reactivatable tag Frz\n+    unsafe { *bad_ptr = 42 }; //~ ERROR does not exist on the stack\n+    let _val = *r#ref;\n }"}, {"sha": "64a8ff69108ec06f75140bb68a00325eebd66bc1", "filename": "tests/compile-fail/stacked_borrows/outdated_local.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Fcompile-fail%2Fstacked_borrows%2Foutdated_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Fcompile-fail%2Fstacked_borrows%2Foutdated_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Foutdated_local.rs?ref=26bb4f79dc4897b3ddbae196f793c7ee3cecdeab", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    let mut x = 0;\n+    let y: *const i32 = &x;\n+    x = 1; // this invalidates y by reactivating the lowermost uniq borrow for this local\n+\n+    assert_eq!(unsafe { *y }, 1); //~ ERROR does not exist on the stack\n+\n+    assert_eq!(x, 1);\n+}"}, {"sha": "68f3d2923b15ff062e9695ec32a42740ef13e6ff", "filename": "tests/compile-fail/stacked_borrows/pointer_smuggling.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Fcompile-fail%2Fstacked_borrows%2Fpointer_smuggling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Fcompile-fail%2Fstacked_borrows%2Fpointer_smuggling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpointer_smuggling.rs?ref=26bb4f79dc4897b3ddbae196f793c7ee3cecdeab", "patch": "@@ -10,13 +10,12 @@ fn fun1(x: &mut u8) {\n \n fn fun2() {\n     // Now we use a pointer we are not allowed to use\n-    let _x = unsafe { *PTR };\n+    let _x = unsafe { *PTR }; //~ ERROR does not exist on the stack\n }\n \n fn main() {\n     let val = &mut 0; // FIXME: This should also work with a local variable, but currently it does not.\n     fun1(val);\n     *val = 2; // this invalidates any raw ptrs `fun1` might have created.\n     fun2(); // if they now use a raw ptr they break our reference\n-    *val = 3; //~ ERROR Mut reference with non-reactivatable tag Mut(Uniq\n }"}, {"sha": "8627cc44c2e5002a0d9a3f1985f57af3853a6240", "filename": "tests/compile-fail/stacked_borrows/unescaped_local.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Fcompile-fail%2Fstacked_borrows%2Funescaped_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Fcompile-fail%2Fstacked_borrows%2Funescaped_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Funescaped_local.rs?ref=26bb4f79dc4897b3ddbae196f793c7ee3cecdeab", "patch": "@@ -0,0 +1,10 @@\n+use std::mem;\n+\n+// Make sure we cannot use raw ptrs to access a local that\n+// has never been escaped to the raw world.\n+fn main() {\n+    let mut x = 42;\n+    let ptr = &mut x;\n+    let raw: *mut i32 = unsafe { mem::transmute(ptr) };\n+    unsafe { *raw = 13; } //~ ERROR does not exist on the stack\n+}"}, {"sha": "544d65a1bffa66fdef177d5814328317d8324096", "filename": "tests/compile-fail/zst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Fcompile-fail%2Fzst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Fcompile-fail%2Fzst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst.rs?ref=26bb4f79dc4897b3ddbae196f793c7ee3cecdeab", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n     let x = &() as *const () as *const i32;\n-    let _ = unsafe { *x }; //~ ERROR outside bounds of allocation\n+    let _ = unsafe { *x }; //~ ERROR access memory with alignment 1, but alignment 4 is required\n }"}, {"sha": "c58e8c84bb2e794b9196ce9b45942feb338a173e", "filename": "tests/run-pass/observed_local_mut.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Frun-pass%2Fobserved_local_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Frun-pass%2Fobserved_local_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fobserved_local_mut.rs?ref=26bb4f79dc4897b3ddbae196f793c7ee3cecdeab", "patch": "@@ -1,3 +1,6 @@\n+// Validation catches this (correctly) as UB.\n+// compile-flags: -Zmiri-disable-validation\n+\n // This test is intended to guard against the problem described in commit\n // 39bb1254d1eaf74f45a4e741097e33fc942168d5.\n //"}, {"sha": "9eabc91426044f80e2b252e1dc6cde629101fee5", "filename": "tests/run-pass/ptr_arith_offset_overflow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Frun-pass%2Fptr_arith_offset_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26bb4f79dc4897b3ddbae196f793c7ee3cecdeab/tests%2Frun-pass%2Fptr_arith_offset_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fptr_arith_offset_overflow.rs?ref=26bb4f79dc4897b3ddbae196f793c7ee3cecdeab", "patch": "@@ -1,6 +1,7 @@\n fn main() {\n     let v = [1i16, 2];\n     let x = &v[1] as *const i16;\n+    let _ = &v[0] as *const i16; // we need to leak the 2nd thing too or it cannot be accessed through a raw ptr\n     // Adding 2*isize::max and then 1 is like substracting 1\n     let x = x.wrapping_offset(isize::max_value());\n     let x = x.wrapping_offset(isize::max_value());"}]}