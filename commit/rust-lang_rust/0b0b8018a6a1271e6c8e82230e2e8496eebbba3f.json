{"sha": "0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiMGI4MDE4YTZhMTI3MWU2YzhlODIyMzBlMmU4NDk2ZWViYmJhM2Y=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-05T16:17:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-05T16:17:59Z"}, "message": "add warning for #6248 and remove instances of it", "tree": {"sha": "a4f6bdc672d069c3454c8e26462d4a4bb3ad9e7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4f6bdc672d069c3454c8e26462d4a4bb3ad9e7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "html_url": "https://github.com/rust-lang/rust/commit/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6806900a7c63950feb2540347fc3f94d83074bbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/6806900a7c63950feb2540347fc3f94d83074bbd", "html_url": "https://github.com/rust-lang/rust/commit/6806900a7c63950feb2540347fc3f94d83074bbd"}], "stats": {"total": 234, "additions": 142, "deletions": 92}, "files": [{"sha": "8ed54741f1276dc7afbc5155657864e1edc3ed1d", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -25,6 +25,7 @@ use rand;\n use uint;\n use vec;\n use util::unreachable;\n+use kinds::Copy;\n \n static INITIAL_CAPACITY: uint = 32u; // 2^5\n \n@@ -529,6 +530,18 @@ pub impl<K: Hash + Eq, V> HashMap<K, V> {\n     }\n }\n \n+pub impl<K: Hash + Eq, V: Copy> HashMap<K, V> {\n+    /// Like `find`, but returns a copy of the value.\n+    fn find_copy(&self, k: &K) -> Option<V> {\n+        self.find(k).map_consume(|v| copy *v)\n+    }\n+\n+    /// Like `get`, but returns a copy of the value.\n+    fn get_copy(&self, k: &K) -> V {\n+        copy *self.get(k)\n+    }\n+}\n+\n impl<K:Hash + Eq,V:Eq> Eq for HashMap<K, V> {\n     fn eq(&self, other: &HashMap<K, V>) -> bool {\n         if self.len() != other.len() { return false; }"}, {"sha": "6d7442b1ed5ee0b55f6a50a2b2c09c11a26837d9", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -190,7 +190,7 @@ fn encode_type_param_bounds(ebml_w: &writer::Encoder,\n                             ecx: @EncodeContext,\n                             params: &OptVec<TyParam>) {\n     let ty_param_defs =\n-        @params.map_to_vec(|param| *ecx.tcx.ty_param_defs.get(&param.id));\n+        @params.map_to_vec(|param| ecx.tcx.ty_param_defs.get_copy(&param.id));\n     encode_ty_type_param_defs(ebml_w, ecx, ty_param_defs,\n                               tag_items_data_item_ty_param_bounds);\n }\n@@ -275,7 +275,7 @@ fn encode_symbol(ecx: @EncodeContext, ebml_w: &writer::Encoder, id: node_id) {\n fn encode_discriminant(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n                        id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n-    ebml_w.writer.write(str::to_bytes(**ecx.discrim_symbols.get(&id)));\n+    ebml_w.writer.write(str::to_bytes(*ecx.discrim_symbols.get_copy(&id)));\n     ebml_w.end_tag();\n }\n \n@@ -1035,7 +1035,7 @@ fn encode_info_for_items(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n             let ebml_w = copy *ebml_w;\n             |i, cx, v| {\n                 visit::visit_item(i, cx, v);\n-                match *ecx.tcx.items.get(&i.id) {\n+                match ecx.tcx.items.get_copy(&i.id) {\n                     ast_map::node_item(_, pt) => {\n                         encode_info_for_item(ecx, &ebml_w, i,\n                                              index, *pt);\n@@ -1048,7 +1048,7 @@ fn encode_info_for_items(ecx: @EncodeContext, ebml_w: &writer::Encoder,\n             let ebml_w = copy *ebml_w;\n             |ni, cx, v| {\n                 visit::visit_foreign_item(ni, cx, v);\n-                match *ecx.tcx.items.get(&ni.id) {\n+                match ecx.tcx.items.get_copy(&ni.id) {\n                     ast_map::node_foreign_item(_, abi, _, pt) => {\n                         encode_info_for_foreign_item(ecx, &ebml_w, ni,\n                                                      index, /*bad*/copy *pt,"}, {"sha": "330d60a59d3ae598bbd347c41732ecafb3b67c42", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -18,6 +18,7 @@ use middle::ty;\n use syntax::ast::{m_const, m_imm, m_mutbl};\n use syntax::ast;\n use syntax::codemap::span;\n+use util::ppaux::{note_and_explain_region};\n \n pub fn guarantee_lifetime(bccx: @BorrowckCtxt,\n                           item_scope_id: ast::node_id,\n@@ -215,13 +216,6 @@ impl GuaranteeLifetimeContext {\n             }\n         };\n \n-        // FIXME(#3511) grow to the nearest cleanup scope---this can\n-        // cause observable errors if freezing!\n-        if !self.bccx.tcx.region_maps.is_cleanup_scope(root_scope) {\n-            debug!(\"%? is not a cleanup scope, adjusting\", root_scope);\n-            root_scope = self.bccx.tcx.region_maps.cleanup_scope(root_scope);\n-        }\n-\n         // If we are borrowing the inside of an `@mut` box,\n         // we need to dynamically mark it to prevent incompatible\n         // borrows from happening later.\n@@ -235,6 +229,34 @@ impl GuaranteeLifetimeContext {\n             }\n         };\n \n+        // FIXME(#3511) grow to the nearest cleanup scope---this can\n+        // cause observable errors if freezing!\n+        if !self.bccx.tcx.region_maps.is_cleanup_scope(root_scope) {\n+            debug!(\"%? is not a cleanup scope, adjusting\", root_scope);\n+\n+            let cleanup_scope =\n+                self.bccx.tcx.region_maps.cleanup_scope(root_scope);\n+\n+            if opt_dyna.is_some() {\n+                self.tcx().sess.span_warn(\n+                    self.span,\n+                    fmt!(\"Dynamic freeze scope artifically extended \\\n+                          (see Issue #6248)\"));\n+                note_and_explain_region(\n+                    self.bccx.tcx,\n+                    \"managed value only needs to be frozen for \",\n+                    ty::re_scope(root_scope),\n+                    \"...\");\n+                note_and_explain_region(\n+                    self.bccx.tcx,\n+                    \"...but due to Issue #6248, it will be frozen for \",\n+                    ty::re_scope(cleanup_scope),\n+                    \"\");\n+            }\n+\n+            root_scope = cleanup_scope;\n+        }\n+\n         // Add a record of what is required\n         let rm_key = root_map_key {id: cmt_deref.id, derefs: derefs};\n         let root_info = RootInfo {scope: root_scope, freeze: opt_dyna};"}, {"sha": "0bb156dd5f642de620425966cc5ef579dc35650f", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -237,7 +237,7 @@ pub fn check_item_recursion(sess: Session,\n             match env.def_map.find(&e.id) {\n               Some(&def_const(def_id)) => {\n                 if ast_util::is_local(def_id) {\n-                  match *env.ast_map.get(&def_id.node) {\n+                  match env.ast_map.get_copy(&def_id.node) {\n                     ast_map::node_item(it, _) => {\n                       (v.visit_item)(it, env, v);\n                     }"}, {"sha": "5be0c09f4ae4aa5320244dcf6697f65a73d2361b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -523,7 +523,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                 }\n             }\n             pat_enum(_, args) => {\n-                match *cx.tcx.def_map.get(&pat_id) {\n+                match cx.tcx.def_map.get_copy(&pat_id) {\n                     def_const(did) => {\n                         let const_expr =\n                             lookup_const_by_id(cx.tcx, did).get();\n@@ -567,7 +567,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n             }\n             pat_struct(_, ref flds, _) => {\n                 // Is this a struct or an enum variant?\n-                match *cx.tcx.def_map.get(&pat_id) {\n+                match cx.tcx.def_map.get_copy(&pat_id) {\n                     def_variant(_, variant_id) => {\n                         if variant(variant_id) == *ctor_id {\n                             // FIXME #4731: Is this right? --pcw"}, {"sha": "3afe8c3b9d68fe1375448ee1a0234bcdba486e07", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -128,7 +128,7 @@ fn check_item(item: @item, cx: Context, visitor: visit::vt<Context>) {\n                             // Yes, it's a destructor.\n                             match self_type.node {\n                                 ty_path(_, path_node_id) => {\n-                                    let struct_def = *cx.tcx.def_map.get(\n+                                    let struct_def = cx.tcx.def_map.get_copy(\n                                         &path_node_id);\n                                     let struct_did =\n                                         ast_util::def_id_of_def(struct_def);\n@@ -272,7 +272,7 @@ pub fn check_expr(e: @expr, cx: Context, v: visit::vt<Context>) {\n         let ts = /*bad*/ copy **ts;\n         let type_param_defs = match e.node {\n           expr_path(_) => {\n-            let did = ast_util::def_id_of_def(*cx.tcx.def_map.get(&e.id));\n+            let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&e.id));\n             ty::lookup_item_type(cx.tcx, did).generics.type_param_defs\n           }\n           _ => {\n@@ -333,7 +333,7 @@ fn check_ty(aty: @Ty, cx: Context, v: visit::vt<Context>) {\n         for cx.tcx.node_type_substs.find(&id).each |ts| {\n             // FIXME(#5562): removing this copy causes a segfault before stage2\n             let ts = /*bad*/ copy **ts;\n-            let did = ast_util::def_id_of_def(*cx.tcx.def_map.get(&id));\n+            let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&id));\n             let type_param_defs =\n                 ty::lookup_item_type(cx.tcx, did).generics.type_param_defs;\n             for vec::each2(ts, *type_param_defs) |&ty, type_param_def| {\n@@ -399,7 +399,7 @@ pub fn check_bounds(cx: Context,\n fn is_nullary_variant(cx: Context, ex: @expr) -> bool {\n     match ex.node {\n       expr_path(_) => {\n-        match *cx.tcx.def_map.get(&ex.id) {\n+        match cx.tcx.def_map.get_copy(&ex.id) {\n           def_variant(edid, vdid) => {\n             vec::len(ty::enum_variant_with_id(cx.tcx, edid, vdid).args) == 0u\n           }"}, {"sha": "c54ff6075faa7823017a1d177fc447ba4f856796", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -696,7 +696,7 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n         for vec::each(vec::append_one(tys, decl.output)) |ty| {\n             match ty.node {\n               ast::ty_path(_, id) => {\n-                match *cx.def_map.get(&id) {\n+                match cx.def_map.get_copy(&id) {\n                   ast::def_prim_ty(ast::ty_int(ast::ty_i)) => {\n                     cx.sess.span_lint(\n                         ctypes, id, fn_id,"}, {"sha": "60ce34c3af271ec55c4cb553a139ba7889759ee3", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -469,7 +469,7 @@ fn visit_expr(expr: @expr, self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       expr_path(_) => {\n-        let def = *self.tcx.def_map.get(&expr.id);\n+        let def = self.tcx.def_map.get_copy(&expr.id);\n         debug!(\"expr %d: path that leads to %?\", expr.id, def);\n         if moves::moved_variable_node_id_from_def(def).is_some() {\n             self.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -616,7 +616,7 @@ pub impl Liveness {\n     fn variable_from_path(&self, expr: @expr) -> Option<Variable> {\n         match expr.node {\n           expr_path(_) => {\n-            let def = *self.tcx.def_map.get(&expr.id);\n+            let def = self.tcx.def_map.get_copy(&expr.id);\n             moves::moved_variable_node_id_from_def(def).map(\n                 |rdef| self.variable(*rdef, expr.span)\n             )\n@@ -1338,7 +1338,7 @@ pub impl Liveness {\n \n     fn access_path(&self, expr: @expr, succ: LiveNode, acc: uint)\n                   -> LiveNode {\n-        let def = *self.tcx.def_map.get(&expr.id);\n+        let def = self.tcx.def_map.get_copy(&expr.id);\n         match moves::moved_variable_node_id_from_def(def) {\n           Some(nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n@@ -1605,7 +1605,7 @@ pub impl Liveness {\n     fn check_lvalue(@self, expr: @expr, vt: vt<@Liveness>) {\n         match expr.node {\n           expr_path(_) => {\n-            match *self.tcx.def_map.get(&expr.id) {\n+            match self.tcx.def_map.get_copy(&expr.id) {\n               def_local(nid, mutbl) => {\n                 // Assignment to an immutable variable or argument: only legal\n                 // if there is no later assignment. If this local is actually"}, {"sha": "da0a3ba25d0716146731f7ad172d64536406fc72", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -409,7 +409,7 @@ pub impl mem_categorization_ctxt {\n           }\n \n           ast::expr_path(_) => {\n-            let def = *self.tcx.def_map.get(&expr.id);\n+            let def = self.tcx.def_map.get_copy(&expr.id);\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n@@ -977,7 +977,7 @@ pub fn field_mutbl(tcx: ty::ctxt,\n         }\n       }\n       ty::ty_enum(*) => {\n-        match *tcx.def_map.get(&node_id) {\n+        match tcx.def_map.get_copy(&node_id) {\n           ast::def_variant(_, variant_id) => {\n             for ty::lookup_struct_fields(tcx, variant_id).each |fld| {\n                 if fld.ident == f_name {"}, {"sha": "58345302d16fbee33aadf2fbcd168aabec185f00", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -441,7 +441,7 @@ pub impl VisitContext {\n                         self.move_maps.variable_moves_map.insert(\n                             expr.id, entire_expr);\n \n-                        let def = *self.tcx.def_map.get(&expr.id);\n+                        let def = self.tcx.def_map.get_copy(&expr.id);\n                         for moved_variable_node_id_from_def(def).each |&id| {\n                             self.move_maps.moved_variables_set.insert(id);\n                         }"}, {"sha": "0df09553ad0145ece067cc87834ccb1fb2ae6560", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -481,7 +481,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                     }\n                 }\n                 expr_path(path) => {\n-                    check_path(expr.span, *tcx.def_map.get(&expr.id), path);\n+                    check_path(expr.span, tcx.def_map.get_copy(&expr.id), path);\n                 }\n                 expr_struct(_, ref fields, _) => {\n                     match ty::get(ty::expr_ty(tcx, expr)).sty {\n@@ -499,7 +499,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                         ty_enum(id, _) => {\n                             if id.crate != local_crate ||\n                                     !privileged_items.contains(&(id.node)) {\n-                                match *tcx.def_map.get(&expr.id) {\n+                                match tcx.def_map.get_copy(&expr.id) {\n                                     def_variant(_, variant_id) => {\n                                         for (*fields).each |field| {\n                                                 debug!(\"(privacy checking) \\"}, {"sha": "d23a798b6239e7252e316474fca69b5142903c97", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -949,7 +949,7 @@ pub fn determine_rp_in_crate(sess: Session,\n         let cx = &mut *cx;\n         while cx.worklist.len() != 0 {\n             let c_id = cx.worklist.pop();\n-            let c_variance = { *cx.region_paramd_items.get(&c_id) };\n+            let c_variance = cx.region_paramd_items.get_copy(&c_id);\n             // NOTE cleanup scopes cause an exaggerated lock here\n             debug!(\"popped %d from worklist\", c_id);\n             match cx.dep_map.find(&c_id) {"}, {"sha": "61a8b367d6cf69dabb53b34ceaac39a88abc44aa", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -280,7 +280,7 @@ pub fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n pub fn variant_opt(bcx: block, pat_id: ast::node_id)\n     -> Opt {\n     let ccx = bcx.ccx();\n-    match *ccx.tcx.def_map.get(&pat_id) {\n+    match ccx.tcx.def_map.get_copy(&pat_id) {\n         ast::def_variant(enum_id, var_id) => {\n             let variants = ty::enum_variants(ccx.tcx, enum_id);\n             for vec::each(*variants) |v| {\n@@ -516,7 +516,7 @@ pub fn enter_opt<'r>(bcx: block,\n         match p.node {\n             ast::pat_enum(*) |\n             ast::pat_ident(_, _, None) if pat_is_const(tcx.def_map, p) => {\n-                let const_def = *tcx.def_map.get(&p.id);\n+                let const_def = tcx.def_map.get_copy(&p.id);\n                 let const_def_id = ast_util::def_id_of_def(const_def);\n                 if opt_eq(tcx, &lit(ConstLit(const_def_id)), opt) {\n                     Some(~[])\n@@ -552,7 +552,7 @@ pub fn enter_opt<'r>(bcx: block,\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n                     // Look up the struct variant ID.\n                     let struct_id;\n-                    match *tcx.def_map.get(&p.id) {\n+                    match tcx.def_map.get_copy(&p.id) {\n                         ast::def_variant(_, found_struct_id) => {\n                             struct_id = found_struct_id;\n                         }"}, {"sha": "5419628cd958a9483402f09fb2e4728aab7656b6", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -2052,7 +2052,7 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n                                              fcx.llretptr.get(),\n                                              0,\n                                              i);\n-        let llarg = match *fcx.llargs.get(&field.node.id) {\n+        let llarg = match fcx.llargs.get_copy(&field.node.id) {\n             local_mem(x) => x,\n             _ => {\n                 ccx.tcx.sess.bug(~\"trans_tuple_struct: llarg wasn't \\\n@@ -2141,7 +2141,7 @@ pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::enum_def,\n \n pub fn trans_item(ccx: @CrateContext, item: &ast::item) {\n     let _icx = ccx.insn_ctxt(\"trans_item\");\n-    let path = match *ccx.tcx.items.get(&item.id) {\n+    let path = match ccx.tcx.items.get_copy(&item.id) {\n         ast_map::node_item(_, p) => p,\n         // tjc: ?\n         _ => fail!(~\"trans_item\"),\n@@ -2443,7 +2443,7 @@ pub fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n }\n \n pub fn item_path(ccx: @CrateContext, i: @ast::item) -> path {\n-    let base = match *ccx.tcx.items.get(&i.id) {\n+    let base = match ccx.tcx.items.get_copy(&i.id) {\n         ast_map::node_item(_, p) => p,\n             // separate map for paths?\n         _ => fail!(~\"item_path\")"}, {"sha": "a2a1f3d8b72fbe5ca7a5925c0136e707e9605e36", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -424,7 +424,7 @@ pub fn trans_expr_fn(bcx: block,\n \n     let Result {bcx: bcx, val: closure} = match sigil {\n         ast::BorrowedSigil | ast::ManagedSigil | ast::OwnedSigil => {\n-            let cap_vars = *ccx.maps.capture_map.get(&user_id);\n+            let cap_vars = ccx.maps.capture_map.get_copy(&user_id);\n             let ret_handle = match is_loop_body {Some(x) => x,\n                                                  None => None};\n             let ClosureResult {llbox, cdata_ty, bcx}"}, {"sha": "dd68670287b7b8c02701655048ffb1617dbb498e", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -158,7 +158,7 @@ pub fn get_const_val(cx: @CrateContext, def_id: ast::def_id) -> ValueRef {\n         if !ast_util::is_local(def_id) {\n             def_id = inline::maybe_instantiate_inline(cx, def_id, true);\n         }\n-        match *cx.tcx.items.get(&def_id.node) {\n+        match cx.tcx.items.get_copy(&def_id.node) {\n             ast_map::node_item(@ast::item {\n                 node: ast::item_const(_, subexpr), _\n             }, _) => {\n@@ -167,7 +167,7 @@ pub fn get_const_val(cx: @CrateContext, def_id: ast::def_id) -> ValueRef {\n             _ => cx.tcx.sess.bug(~\"expected a const to be an item\")\n         }\n     }\n-    *cx.const_values.get(&def_id.node)\n+    cx.const_values.get_copy(&def_id.node)\n }\n \n pub fn const_expr(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n@@ -560,7 +560,7 @@ pub fn trans_const(ccx: @CrateContext, _e: @ast::expr, id: ast::node_id) {\n         let g = base::get_item_val(ccx, id);\n         // At this point, get_item_val has already translated the\n         // constant's initializer to determine its LLVM type.\n-        let v = *ccx.const_values.get(&id);\n+        let v = ccx.const_values.get_copy(&id);\n         llvm::LLVMSetInitializer(g, v);\n         llvm::LLVMSetGlobalConstant(g, True);\n     }"}, {"sha": "b16b77320860cc5e89153fe41531f19dba14c98a", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -193,7 +193,7 @@ pub fn trans_log(log_ex: @ast::expr,\n     };\n \n     let global = if ccx.module_data.contains_key(&modname) {\n-        *ccx.module_data.get(&modname)\n+        ccx.module_data.get_copy(&modname)\n     } else {\n         let s = link::mangle_internal_name_by_path_and_seq(\n             ccx, modpath, ~\"loglevel\");"}, {"sha": "1571fd71152cc31c5f5820d4f23be67644cd9099", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -864,7 +864,7 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n                 something weird\");\n       }\n       option::None => {\n-        match *bcx.fcx.lllocals.get(&local.node.pat.id) {\n+        match bcx.fcx.lllocals.get_copy(&local.node.pat.id) {\n           local_imm(v) => v,\n           _ => bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n                                                      something weird\")\n@@ -917,7 +917,7 @@ pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n             };\n             update_cache(cache, tg, argument_metadata(mdval));\n \n-            let llptr = match *fcx.llargs.get(&arg.id) {\n+            let llptr = match fcx.llargs.get_copy(&arg.id) {\n               local_mem(v) | local_imm(v) => v,\n             };\n             let declargs = ~[llmdnode(~[llptr]), mdnode];\n@@ -960,7 +960,7 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n     let sp = fcx.span.get();\n     debug!(\"%s\", cx.sess.codemap.span_to_str(sp));\n \n-    let (ident, ret_ty, id) = match *cx.tcx.items.get(&fcx.id) {\n+    let (ident, ret_ty, id) = match cx.tcx.items.get_copy(&fcx.id) {\n       ast_map::node_item(item, _) => {\n         match item.node {\n           ast::item_fn(ref decl, _, _, _, _) => {"}, {"sha": "d961c0705e44c3f2101af8e399cd3c273dcb271c", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -1117,7 +1117,7 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n                         ty.repr(tcx)));\n                 }\n                 Some(node_id) => {\n-                    match *tcx.def_map.get(&node_id) {\n+                    match tcx.def_map.get_copy(&node_id) {\n                         ast::def_variant(enum_id, variant_id) => {\n                             let variant_info = ty::enum_variant_with_id(\n                                 tcx, enum_id, variant_id);\n@@ -1536,7 +1536,7 @@ fn trans_overloaded_op(bcx: block,\n                        ret_ty: ty::t,\n                        dest: Dest)\n                        -> block {\n-    let origin = *bcx.ccx().maps.method_map.get(&expr.id);\n+    let origin = bcx.ccx().maps.method_map.get_copy(&expr.id);\n     let fty = node_id_type(bcx, expr.callee_id);\n     callee::trans_call_inner(bcx,\n                              expr.info(),"}, {"sha": "f49a7fb0de41fa60c79d7d3dcaf52d6dd9a53dd1", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -724,7 +724,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let in_type_size = machine::llbitsize_of_real(ccx, llintype);\n             let out_type_size = machine::llbitsize_of_real(ccx, llouttype);\n             if in_type_size != out_type_size {\n-                let sp = match *ccx.tcx.items.get(&ref_id.get()) {\n+                let sp = match ccx.tcx.items.get_copy(&ref_id.get()) {\n                     ast_map::node_expr(e) => e.span,\n                     _ => fail!(~\"transmute has non-expr arg\"),\n                 };"}, {"sha": "73b79fa37e2eeb4ce08cca9411b7f9c8c92e51a8", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -118,7 +118,7 @@ pub fn llalign_of(cx: @CrateContext, t: TypeRef) -> ValueRef {\n // Computes the size of the data part of an enum.\n pub fn static_size_of_enum(cx: @CrateContext, t: ty::t) -> uint {\n     if cx.enum_sizes.contains_key(&t) {\n-        return *cx.enum_sizes.get(&t);\n+        return cx.enum_sizes.get_copy(&t);\n     }\n \n     debug!(\"static_size_of_enum %s\", ty_to_str(cx.tcx, t));"}, {"sha": "693947d7e99bd14497f106dc7fbf1a7ade7b488d", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -312,7 +312,7 @@ pub fn trans_static_method_callee(bcx: block,\n     };\n \n     let mname = if method_id.crate == ast::local_crate {\n-        match *bcx.tcx().items.get(&method_id.node) {\n+        match bcx.tcx().items.get_copy(&method_id.node) {\n             ast_map::node_trait_method(trait_method, _, _) => {\n                 ast_util::trait_method_to_ty_method(trait_method).ident\n             }\n@@ -329,7 +329,7 @@ pub fn trans_static_method_callee(bcx: block,\n             name=%s\", method_id, callee_id, *ccx.sess.str_of(mname));\n \n     let vtbls = resolve_vtables_in_fn_ctxt(\n-        bcx.fcx, *ccx.maps.vtable_map.get(&callee_id));\n+        bcx.fcx, ccx.maps.vtable_map.get_copy(&callee_id));\n \n     match vtbls[bound_index] {\n         typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n@@ -367,7 +367,7 @@ pub fn method_from_methods(ms: &[@ast::method], name: ast::ident)\n pub fn method_with_name(ccx: @CrateContext, impl_id: ast::def_id,\n                         name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n-        match *ccx.tcx.items.get(&impl_id.node) {\n+        match ccx.tcx.items.get_copy(&impl_id.node) {\n           ast_map::node_item(@ast::item {\n                 node: ast::item_impl(_, _, _, ref ms),\n                 _\n@@ -385,7 +385,7 @@ pub fn method_with_name_or_default(ccx: @CrateContext,\n                                    impl_id: ast::def_id,\n                                    name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n-        match *ccx.tcx.items.get(&impl_id.node) {\n+        match ccx.tcx.items.get_copy(&impl_id.node) {\n           ast_map::node_item(@ast::item {\n                 node: ast::item_impl(_, _, _, ref ms), _\n           }, _) => {"}, {"sha": "e1b81933e68818a19178487e7b901a9fa6ea894a", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -101,12 +101,14 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n     let llitem_ty = tpt.ty;\n \n-    let map_node = session::expect(ccx.sess, ccx.tcx.items.find(&fn_id.node),\n-     || fmt!(\"While monomorphizing %?, couldn't find it in the item map \\\n-        (may have attempted to monomorphize an item defined in a different \\\n-        crate?)\", fn_id));\n+    let map_node = session::expect(\n+        ccx.sess,\n+        ccx.tcx.items.find_copy(&fn_id.node),\n+        || fmt!(\"While monomorphizing %?, couldn't find it in the item map \\\n+                 (may have attempted to monomorphize an item \\\n+                 defined in a different crate?)\", fn_id));\n     // Get the path so that we can create a symbol\n-    let (pt, name, span) = match *map_node {\n+    let (pt, name, span) = match map_node {\n       ast_map::node_item(i, pt) => (pt, i.ident, i.span),\n       ast_map::node_variant(ref v, enm, pt) => (pt, (*v).node.name, enm.span),\n       ast_map::node_method(m, _, pt) => (pt, m.ident, m.span),\n@@ -188,7 +190,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         self_ty: impl_ty_opt\n     });\n \n-    let lldecl = match *map_node {\n+    let lldecl = match map_node {\n       ast_map::node_item(i@@ast::item {\n                 node: ast::item_fn(ref decl, _, _, _, ref body),\n                 _"}, {"sha": "058ce638030b9750ef7260c2a5d0526a5c7afa6b", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -109,7 +109,8 @@ fn traverse_public_item(cx: @mut ctx, item: @item) {\n       item_foreign_mod(ref nm) => {\n           if !traverse_exports(cx, item.id) {\n               for nm.items.each |item| {\n-                  (&mut *cx).rmap.insert(item.id); // NOTE reborrow @mut\n+                  let cx = &mut *cx; // NOTE reborrow @mut\n+                  cx.rmap.insert(item.id);\n               }\n           }\n       }\n@@ -125,17 +126,24 @@ fn traverse_public_item(cx: @mut ctx, item: @item) {\n                 m.generics.ty_params.len() > 0u ||\n                 attr::find_inline_attr(m.attrs) != attr::ia_none\n             {\n-                (&mut *cx).rmap.insert(m.id); // NOTE reborrow @mut\n+                {\n+                    let cx = &mut *cx; // NOTE reborrow @mut\n+                    cx.rmap.insert(m.id);\n+                }\n                 traverse_inline_body(cx, &m.body);\n             }\n         }\n       }\n       item_struct(ref struct_def, ref generics) => {\n         for struct_def.ctor_id.each |&ctor_id| {\n-            (&mut *cx).rmap.insert(ctor_id); // NOTE reborrow @mut\n+            let cx = &mut *cx; // NOTE reborrow @mut\n+            cx.rmap.insert(ctor_id);\n         }\n         for struct_def.dtor.each |dtor| {\n-            (&mut *cx).rmap.insert(dtor.node.id);\n+            {\n+                let cx = &mut *cx; // NOTE reborrow @mut\n+                cx.rmap.insert(dtor.node.id);\n+            }\n             if generics.ty_params.len() > 0u ||\n                 attr::find_inline_attr(dtor.node.attrs) != attr::ia_none\n             {\n@@ -156,8 +164,7 @@ fn traverse_public_item(cx: @mut ctx, item: @item) {\n \n fn traverse_ty<'a>(ty: @Ty, cx: @mut ctx<'a>, v: visit::vt<@mut ctx<'a>>) {\n     {\n-        // FIXME #6021: naming rmap shouldn't be necessary\n-        let cx = &mut *cx;\n+        let cx = &mut *cx; // NOTE reborrow @mut\n         if cx.rmap.contains(&ty.id) { return; }\n         cx.rmap.insert(ty.id);\n     }"}, {"sha": "5f77173f5632189416fbd98a455d3a9dc789b439", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -274,8 +274,9 @@ pub impl Reflector {\n             let repr = adt::represent_type(bcx.ccx(), t);\n             let variants = ty::substd_enum_variants(ccx.tcx, did, substs);\n             let llptrty = T_ptr(type_of(ccx, t));\n-            let (_, opaquety) = *(ccx.tcx.intrinsic_defs.find(&ccx.sess.ident_of(~\"Opaque\"))\n-                                      .expect(\"Failed to resolve intrinsic::Opaque\"));\n+            let (_, opaquety) =\n+                ccx.tcx.intrinsic_defs.find_copy(&ccx.sess.ident_of(~\"Opaque\"))\n+                .expect(\"Failed to resolve intrinsic::Opaque\");\n             let opaqueptrty = ty::mk_ptr(ccx.tcx, ty::mt { ty: opaquety, mutbl: ast::m_imm });\n \n             let make_get_disr = || {\n@@ -374,7 +375,7 @@ pub fn emit_calls_to_trait_visit_ty(bcx: block,\n     use syntax::parse::token::special_idents::tydesc;\n     let final = sub_block(bcx, ~\"final\");\n     assert!(bcx.ccx().tcx.intrinsic_defs.contains_key(&tydesc));\n-    let (_, tydesc_ty) = *bcx.ccx().tcx.intrinsic_defs.get(&tydesc);\n+    let (_, tydesc_ty) = bcx.ccx().tcx.intrinsic_defs.get_copy(&tydesc);\n     let tydesc_ty = type_of(bcx.ccx(), tydesc_ty);\n     let mut r = Reflector {\n         visitor_val: visitor_val,"}, {"sha": "fb2358a57e2a75944e75224e207d92c9300f56b5", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -239,18 +239,11 @@ pub fn node_type_needs(cx: Context, use_: uint, id: node_id) {\n }\n \n pub fn mark_for_method_call(cx: Context, e_id: node_id, callee_id: node_id) {\n+    let mut opt_static_did = None;\n     for cx.ccx.maps.method_map.find(&e_id).each |mth| {\n         match mth.origin {\n           typeck::method_static(did) => {\n-            for cx.ccx.tcx.node_type_substs.find(&callee_id).each |ts| {\n-                // FIXME(#5562): removing this copy causes a segfault\n-                //               before stage2\n-                let ts = /*bad*/ copy **ts;\n-                let type_uses = type_uses_for(cx.ccx, did, ts.len());\n-                for vec::each2(*type_uses, ts) |uses, subst| {\n-                    type_needs(cx, *uses, *subst)\n-                }\n-            }\n+              opt_static_did = Some(did);\n           }\n           typeck::method_param(typeck::method_param {\n               param_num: param,\n@@ -262,6 +255,19 @@ pub fn mark_for_method_call(cx: Context, e_id: node_id, callee_id: node_id) {\n               | typeck::method_super(*) => (),\n         }\n     }\n+\n+    // Note: we do not execute this code from within the each() call\n+    // above because the recursive call to `type_needs` can trigger\n+    // inlining and hence can cause `method_map` and\n+    // `node_type_substs` to be modified.\n+    for opt_static_did.each |did| {\n+        for cx.ccx.tcx.node_type_substs.find_copy(&callee_id).each |ts| {\n+            let type_uses = type_uses_for(cx.ccx, did, ts.len());\n+            for vec::each2(*type_uses, ts) |uses, subst| {\n+                type_needs(cx, *uses, *subst)\n+            }\n+        }\n+    }\n }\n \n pub fn mark_for_expr(cx: Context, e: @expr) {\n@@ -291,12 +297,11 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n         }\n       }\n       expr_path(_) => {\n-        for cx.ccx.tcx.node_type_substs.find(&e.id).each |ts| {\n-            // FIXME(#5562): removing this copy causes a segfault before stage2\n-            let ts = copy **ts;\n-            let id = ast_util::def_id_of_def(*cx.ccx.tcx.def_map.get(&e.id));\n+        let opt_ts = cx.ccx.tcx.node_type_substs.find_copy(&e.id);\n+        for opt_ts.each |ts| {\n+            let id = ast_util::def_id_of_def(cx.ccx.tcx.def_map.get_copy(&e.id));\n             let uses_for_ts = type_uses_for(cx.ccx, id, ts.len());\n-            for vec::each2(*uses_for_ts, ts) |uses, subst| {\n+            for vec::each2(*uses_for_ts, *ts) |uses, subst| {\n                 type_needs(cx, *uses, *subst)\n             }\n         }"}, {"sha": "eac73ce1a2e0afa11dcad4a83765b806c717b663", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -3893,7 +3893,7 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n           call eval_const_expr, it should never get called twice for the same\n           expr, since check_enum_variants also updates the enum_var_cache\n          */\n-        match *cx.items.get(&id.node) {\n+        match cx.items.get_copy(&id.node) {\n           ast_map::node_item(@ast::item {\n                     node: ast::item_enum(ref enum_definition, _),\n                     _\n@@ -4424,7 +4424,7 @@ pub fn get_impl_id(tcx: ctxt, trait_id: def_id, self_ty: t) -> def_id {\n pub fn visitor_object_ty(tcx: ctxt) -> (@TraitRef, t) {\n     let ty_visitor_name = special_idents::ty_visitor;\n     assert!(tcx.intrinsic_traits.contains_key(&ty_visitor_name));\n-    let trait_ref = *tcx.intrinsic_traits.get(&ty_visitor_name);\n+    let trait_ref = tcx.intrinsic_traits.get_copy(&ty_visitor_name);\n     (trait_ref,\n      mk_trait(tcx, trait_ref.def_id, copy trait_ref.substs, BoxTraitStore, ast::m_imm))\n }"}, {"sha": "a3bf1a5ef52d45f911186ab648ed7a4058b17ba6", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -404,7 +404,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n       }\n       ast::pat_enum(*) |\n       ast::pat_ident(*) if pat_is_const(tcx.def_map, pat) => {\n-        let const_did = ast_util::def_id_of_def(*tcx.def_map.get(&pat.id));\n+        let const_did = ast_util::def_id_of_def(tcx.def_map.get_copy(&pat.id));\n         let const_tpt = ty::lookup_item_type(tcx, const_did);\n         demand::suptype(fcx, pat.span, expected, const_tpt.ty);\n         fcx.write_ty(pat.id, const_tpt.ty);"}, {"sha": "09022b5829a14f12846582487eb1714c5f0c91cd", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -433,7 +433,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n             assign(self_info.self_id, Some(self_info.self_ty));\n             debug!(\"self is assigned to %s\",\n                    fcx.infcx().ty_to_str(\n-                       *fcx.inh.locals.get(&self_info.self_id)));\n+                       fcx.inh.locals.get_copy(&self_info.self_id)));\n         }\n \n         // Add formal parameters.\n@@ -466,7 +466,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n             debug!(\"Local variable %s is assigned type %s\",\n                    fcx.pat_to_str(local.node.pat),\n                    fcx.infcx().ty_to_str(\n-                       *fcx.inh.locals.get(&local.node.id)));\n+                       fcx.inh.locals.get_copy(&local.node.id)));\n             visit::visit_local(local, e, v);\n         };\n \n@@ -479,7 +479,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                 debug!(\"Pattern binding %s is assigned to %s\",\n                        *tcx.sess.str_of(path.idents[0]),\n                        fcx.infcx().ty_to_str(\n-                           *fcx.inh.locals.get(&p.id)));\n+                           fcx.inh.locals.get_copy(&p.id)));\n               }\n               _ => {}\n             }\n@@ -3492,7 +3492,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n       ~\"visit_tydesc\" => {\n         let tydesc_name = special_idents::tydesc;\n         assert!(tcx.intrinsic_defs.contains_key(&tydesc_name));\n-        let (_, tydesc_ty) = *tcx.intrinsic_defs.get(&tydesc_name);\n+        let (_, tydesc_ty) = tcx.intrinsic_defs.get_copy(&tydesc_name);\n         let (_, visitor_object_ty) = ty::visitor_object_ty(tcx);\n         let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n             ty: tydesc_ty,"}, {"sha": "100e23e024c45b81e13133176b3593cf4feda5b8", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -490,7 +490,7 @@ pub fn early_resolve_expr(ex: @ast::expr,\n         for fcx.opt_node_ty_substs(ex.id) |substs| {\n             debug!(\"vtable resolution on parameter bounds for expr %s\",\n                    ex.repr(fcx.tcx()));\n-            let def = *cx.tcx.def_map.get(&ex.id);\n+            let def = cx.tcx.def_map.get_copy(&ex.id);\n             let did = ast_util::def_id_of_def(def);\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n             debug!(\"early resolve expr: def %? %?, %?, %s\", ex.id, did, def,"}, {"sha": "09f0b83e61689829de15797c55abdd5e87b51ab5", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -651,7 +651,7 @@ pub impl CoherenceChecker {\n \n     fn get_self_type_for_implementation(&self, implementation: @Impl)\n                                      -> ty_param_bounds_and_ty {\n-        return *self.crate_context.tcx.tcache.get(&implementation.did);\n+        return self.crate_context.tcx.tcache.get_copy(&implementation.did);\n     }\n \n     // Privileged scope checking\n@@ -711,7 +711,7 @@ pub impl CoherenceChecker {\n \n     fn trait_ref_to_trait_def_id(&self, trait_ref: @trait_ref) -> def_id {\n         let def_map = self.crate_context.tcx.def_map;\n-        let trait_def = *def_map.get(&trait_ref.ref_id);\n+        let trait_def = def_map.get_copy(&trait_ref.ref_id);\n         let trait_id = def_id_of_def(trait_def);\n         return trait_id;\n     }\n@@ -751,7 +751,7 @@ pub impl CoherenceChecker {\n                                               -> bool {\n         match original_type.node {\n             ty_path(_, path_id) => {\n-                match *self.crate_context.tcx.def_map.get(&path_id) {\n+                match self.crate_context.tcx.def_map.get_copy(&path_id) {\n                     def_ty(def_id) | def_struct(def_id) => {\n                         if def_id.crate != local_crate {\n                             return false;"}, {"sha": "3da6995b4236241df75dbaba1b2a32204b2bbf62", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b0b8018a6a1271e6c8e82230e2e8496eebbba3f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=0b0b8018a6a1271e6c8e82230e2e8496eebbba3f", "patch": "@@ -220,7 +220,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n {\n     let tcx = ccx.tcx;\n     let region_paramd = tcx.region_paramd_items.find(&trait_id).map(|&x| *x);\n-    match *tcx.items.get(&trait_id) {\n+    match tcx.items.get_copy(&trait_id) {\n         ast_map::node_item(@ast::item {\n             node: ast::item_trait(ref generics, _, ref ms),\n             _"}]}