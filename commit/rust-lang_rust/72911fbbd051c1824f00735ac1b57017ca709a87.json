{"sha": "72911fbbd051c1824f00735ac1b57017ca709a87", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyOTExZmJiZDA1MWMxODI0ZjAwNzM1YWMxYjU3MDE3Y2E3MDlhODc=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-10-05T21:31:33Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-10-07T14:14:22Z"}, "message": "Update logic to search for casts.\n\nThis commit updates the captured trait object search logic to look for\nunsized casts to boxed types rather than for functions that returned\ntrait objects.", "tree": {"sha": "001429da9d7ace95c3a2485910595fbe21d037e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/001429da9d7ace95c3a2485910595fbe21d037e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72911fbbd051c1824f00735ac1b57017ca709a87", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlu6FL4ACgkQAXYLT59T\n8VTv6w/+OqexAMcygIghrK9WVPAT1qjNLlBFkQVNR6PsyjS3+h6YIFovtWVnAfss\nlppN8ub22DwT6I6iJs1ZEc6QANhKNlHWY3Q4laVo9Tf/Sai5rqFuZUzI2qGmPdi+\nRH9lKRBqwbYeDTEirsi41aujntIdang0jgd9dGMsXJyOiLIK0ibK+AmKADaEXCYc\nCJFFlCU5DZcgEjYOkXsiyU11/TwedxsEHBYujI2fGd3mITfjdtpaQOpJuNm2V8xT\nUTuz7g2VAg7V/WAoRvWur+nz+1yzHVeFsbhs4jz7/tLvVxNJy42ssoZPQjeFL9xa\nwGXrpMK2Jozkpjit+4P6PQ8+3Z+fXFeR4uBc8ZxKllw9nvB5gZFcdZd6ZTkRb7mK\n5Ik1OVIQGOmV3ViZ1Nc30xBoo78wJ7dXRdeReKF1oYankTAW3Kp/ImqzdhzXdiUg\njT13B8H5x1ix8N7z4iAHQVRychCKFLyGs9tnmUXsfGqO23Bf28dkFaWeWmlcA9VP\ncGeNfxP3aJ84170v2RY+iVs4mBrWWwmiMl1sTtSMot16tLWYw3Sk+GDpzyIEME9H\n0xFVTbmxglYDo+QTafOqPRa/hcsCA9sM/wtpyQQ4nAL7i1O7mGnY+kWQbEkXK/Yk\niQkNXtzQeAk0yH6/NF5QpCk+qwEOWpCEJwAEcmScHVMUBhetWkM=\n=g6rC\n-----END PGP SIGNATURE-----", "payload": "tree 001429da9d7ace95c3a2485910595fbe21d037e0\nparent 91b71f5e9416b570b3e4c1997056c3879e5029af\nauthor David Wood <david@davidtw.co> 1538775093 +0200\ncommitter David Wood <david@davidtw.co> 1538921662 +0200\n\nUpdate logic to search for casts.\n\nThis commit updates the captured trait object search logic to look for\nunsized casts to boxed types rather than for functions that returned\ntrait objects.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72911fbbd051c1824f00735ac1b57017ca709a87", "html_url": "https://github.com/rust-lang/rust/commit/72911fbbd051c1824f00735ac1b57017ca709a87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72911fbbd051c1824f00735ac1b57017ca709a87/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91b71f5e9416b570b3e4c1997056c3879e5029af", "url": "https://api.github.com/repos/rust-lang/rust/commits/91b71f5e9416b570b3e4c1997056c3879e5029af", "html_url": "https://github.com/rust-lang/rust/commit/91b71f5e9416b570b3e4c1997056c3879e5029af"}], "stats": {"total": 210, "additions": 149, "deletions": 61}, "files": [{"sha": "307112f8ba16a26fb17dd4e4a482d4d2b5d96db7", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 109, "deletions": 61, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/72911fbbd051c1824f00735ac1b57017ca709a87/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72911fbbd051c1824f00735ac1b57017ca709a87/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=72911fbbd051c1824f00735ac1b57017ca709a87", "patch": "@@ -14,8 +14,8 @@ use borrow_check::nll::region_infer::Cause;\n use borrow_check::{Context, MirBorrowckCtxt, WriteKind};\n use rustc::ty::{self, Region, TyCtxt};\n use rustc::mir::{\n-    FakeReadCause, Local, Location, Mir, Operand, Place, Rvalue, Statement, StatementKind,\n-    TerminatorKind\n+    CastKind, FakeReadCause, Local, Location, Mir, Operand, Place, Projection, ProjectionElem,\n+    Rvalue, Statement, StatementKind, TerminatorKind\n };\n use rustc_errors::DiagnosticBuilder;\n use syntax_pos::Span;\n@@ -65,7 +65,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n             BorrowExplanation::UsedLaterInLoop(later_use_kind, var_or_use_span) => {\n                 let message = match later_use_kind {\n                     LaterUseKind::TraitCapture =>\n-                        \"borrow later captured here by trait object, in later iteration of loop\",\n+                        \"borrow captured here by trait object, in later iteration of loop\",\n                     LaterUseKind::ClosureCapture =>\n                         \"borrow captured here by closure, in later iteration of loop\",\n                     LaterUseKind::Call =>  \"borrow used by call, in later iteration of loop\",\n@@ -373,20 +373,20 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Check if a borrowed value was captured by a trait object.\n+    /// Check if a borrowed value was captured by a trait object. We do this by\n+    /// looking forward in the MIR from the reserve location and checking if we see\n+    /// a unsized cast to a trait object on our data.\n     fn was_captured_by_trait_object(&self, borrow: &BorrowData<'tcx>) -> bool {\n-        // In order to check if a value was captured by a trait object, we want to look through\n-        // statements after the reserve location in the current block. We expect the reserve\n-        // location to be a statement assigning to a local. We follow that local in the subsequent\n-        // statements, checking for an assignment of our local (or something intermediate that\n-        // it was assigned into) that results in a trait object.\n+        // Start at the reserve location, find the place that we want to see cast to a trait object.\n         let location = borrow.reserve_location;\n         let block = &self.mir[location.block];\n         let stmt = block.statements.get(location.statement_index);\n-        debug!(\n-            \"was_captured_by_trait_object: location={:?} block={:?} stmt={:?}\",\n-            location, block, stmt\n-        );\n+        debug!(\"was_captured_by_trait_object: location={:?} stmt={:?}\", location, stmt);\n+\n+        // We make a `queue` vector that has the locations we want to visit. As of writing, this\n+        // will only ever have one item at any given time, but by using a vector, we can pop from\n+        // it which simplifies the termination logic.\n+        let mut queue = vec![location];\n         let mut target = if let Some(&Statement {\n             kind: StatementKind::Assign(Place::Local(local), _),\n             ..\n@@ -396,61 +396,109 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             return false;\n         };\n \n-        debug!(\"was_captured_by_trait_object: target={:?}\", target);\n-        for stmt in &block.statements[location.statement_index + 1..] {\n-            debug!(\"was_captured_by_trait_object: stmt={:?}\", stmt);\n-            // Simple case where our target is assigned into another local, and we start\n-            // watching that local instead.\n-            if let StatementKind::Assign(\n-                Place::Local(into),\n-                box Rvalue::Use(operand),\n-            ) = &stmt.kind {\n-                debug!(\"was_captured_by_trait_object: target={:?} operand={:?}\", target, operand);\n-                match operand {\n-                    Operand::Copy(Place::Local(from)) |\n-                    Operand::Move(Place::Local(from)) if *from == target => target = *into,\n-                    _ => {},\n-                }\n-            }\n-        }\n-\n-        if let Some(terminator) = &block.terminator {\n-            if let TerminatorKind::Call {\n-                destination: Some((Place::Local(dest), _)),\n-                args,\n-                ..\n-            } = &terminator.kind {\n-                debug!(\n-                    \"was_captured_by_trait_object: target={:?} dest={:?} args={:?}\",\n-                    target, dest, args\n-                );\n-                let mut found_target = false;\n-                for arg in args {\n-                    if let Operand::Move(Place::Local(potential)) = arg {\n-                        if *potential == target {\n-                            found_target = true;\n-                        }\n+        debug!(\"was_captured_by_trait: target={:?} queue={:?}\", target, queue);\n+        while let Some(current_location) = queue.pop() {\n+            debug!(\"was_captured_by_trait: target={:?}\", target);\n+            let block = &self.mir[current_location.block];\n+            // We need to check the current location to find out if it is a terminator.\n+            let is_terminator = current_location.statement_index == block.statements.len();\n+            if !is_terminator {\n+                let stmt = &block.statements[current_location.statement_index];\n+                debug!(\"was_captured_by_trait_object: stmt={:?}\", stmt);\n+\n+                // The only kind of statement that we care about is assignments...\n+                if let StatementKind::Assign(\n+                    place,\n+                    box rvalue,\n+                ) = &stmt.kind {\n+                    let into = match place {\n+                        Place::Local(into) => into,\n+                        Place::Projection(box Projection {\n+                            base: Place::Local(into),\n+                            elem: ProjectionElem::Deref,\n+                        }) => into,\n+                        _ =>  {\n+                            // Continue at the next location.\n+                            queue.push(current_location.successor_within_block());\n+                            continue;\n+                        },\n+                    };\n+\n+                    match rvalue {\n+                        // If we see a use, we should check whether it is our data, and if so\n+                        // update the place that we're looking for to that new place.\n+                        Rvalue::Use(operand) => match operand {\n+                            Operand::Copy(Place::Local(from)) |\n+                            Operand::Move(Place::Local(from)) if *from == target => {\n+                                target = *into;\n+                            },\n+                            _ => {},\n+                        },\n+                        // If we see a unsized cast, then if it is our data we should check\n+                        // whether it is being cast to a trait object.\n+                        Rvalue::Cast(CastKind::Unsize, operand, ty) => match operand {\n+                            Operand::Copy(Place::Local(from)) |\n+                            Operand::Move(Place::Local(from)) if *from == target => {\n+                                debug!(\"was_captured_by_trait_object: ty={:?}\", ty);\n+                                // Check the type for a trait object.\n+                                match ty.sty {\n+                                    // `&dyn Trait`\n+                                    ty::TyKind::Ref(_, ty, _) if ty.is_trait() => return true,\n+                                    // `Box<dyn Trait>`\n+                                    _ if ty.is_box() && ty.boxed_ty().is_trait() =>\n+                                        return true,\n+                                    // `dyn Trait`\n+                                    _ if ty.is_trait() => return true,\n+                                    // Anything else.\n+                                    _ => return false,\n+                                }\n+                            },\n+                            _ => return false,\n+                        },\n+                        _ => {},\n                     }\n                 }\n \n-                if found_target {\n-                    let local_decl_ty = &self.mir.local_decls[*dest].ty;\n-                    debug!(\"was_captured_by_trait_object: local_decl_ty={:?}\", local_decl_ty);\n-                    match local_decl_ty.sty {\n-                        // `&dyn Trait`\n-                        ty::TyKind::Ref(_, ty, _) if ty.is_trait() => return true,\n-                        // `Box<dyn Trait>`\n-                        _ if local_decl_ty.is_box() && local_decl_ty.boxed_ty().is_trait() =>\n-                            return true,\n-                        // `dyn Trait`\n-                        _ if local_decl_ty.is_trait() => return true,\n-                        // Anything else.\n-                        _ => return false,\n-                    }\n+                // Continue at the next location.\n+                queue.push(current_location.successor_within_block());\n+            } else {\n+                // The only thing we need to do for terminators is progress to the next block.\n+                let terminator = block.terminator();\n+                debug!(\"was_captured_by_trait_object: terminator={:?}\", terminator);\n+\n+                match &terminator.kind {\n+                    TerminatorKind::Call {\n+                        destination: Some((Place::Local(dest), block)),\n+                        args,\n+                        ..\n+                    } => {\n+                        debug!(\n+                            \"was_captured_by_trait_object: target={:?} dest={:?} args={:?}\",\n+                            target, dest, args\n+                        );\n+                        // Check if one of the arguments to this function is the target place.\n+                        let found_target = args.iter().any(|arg| {\n+                            if let Operand::Move(Place::Local(potential)) = arg {\n+                                *potential == target\n+                            } else {\n+                                false\n+                            }\n+                        });\n+\n+                        // If it is, follow this to the next block and update the target.\n+                        if found_target {\n+                            target = *dest;\n+                            queue.push(block.start_location());\n+                        }\n+                    },\n+                    _ => {},\n                 }\n             }\n+\n+            debug!(\"was_captured_by_trait: queue={:?}\", queue);\n         }\n \n+        // We didn't find anything and ran out of locations to check.\n         false\n     }\n }"}, {"sha": "65d73eeae67c4609133034a7953ad206e32b2434", "filename": "src/test/ui/nll/issue-52663-trait-object.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/72911fbbd051c1824f00735ac1b57017ca709a87/src%2Ftest%2Fui%2Fnll%2Fissue-52663-trait-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72911fbbd051c1824f00735ac1b57017ca709a87/src%2Ftest%2Fui%2Fnll%2Fissue-52663-trait-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52663-trait-object.rs?ref=72911fbbd051c1824f00735ac1b57017ca709a87", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(box_syntax)]\n+#![feature(nll)]\n+\n+trait Foo { fn get(&self); }\n+\n+impl<A> Foo for A {\n+    fn get(&self) { }\n+}\n+\n+fn main() {\n+    let _ = {\n+        let tmp0 = 3;\n+        let tmp1 = &tmp0;\n+        box tmp1 as Box<Foo + '_>\n+    };\n+    //~^^^ ERROR `tmp0` does not live long enough\n+}"}, {"sha": "035422f245825d28e8852b00d74f3649488eae9b", "filename": "src/test/ui/nll/issue-52663-trait-object.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/72911fbbd051c1824f00735ac1b57017ca709a87/src%2Ftest%2Fui%2Fnll%2Fissue-52663-trait-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/72911fbbd051c1824f00735ac1b57017ca709a87/src%2Ftest%2Fui%2Fnll%2Fissue-52663-trait-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52663-trait-object.stderr?ref=72911fbbd051c1824f00735ac1b57017ca709a87", "patch": "@@ -0,0 +1,13 @@\n+error[E0597]: `tmp0` does not live long enough\n+  --> $DIR/issue-52663-trait-object.rs:23:20\n+   |\n+LL |         let tmp1 = &tmp0;\n+   |                    ^^^^^ borrowed value does not live long enough\n+LL |         box tmp1 as Box<Foo + '_>\n+   |         ------------------------- borrow later captured here by trait object\n+LL |     };\n+   |     - `tmp0` dropped here while still borrowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}]}