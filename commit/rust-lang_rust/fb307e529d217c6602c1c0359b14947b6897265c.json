{"sha": "fb307e529d217c6602c1c0359b14947b6897265c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiMzA3ZTUyOWQyMTdjNjYwMmMxYzAzNTliMTQ5NDdiNjg5NzI2NWM=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-09-04T06:44:04Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-09-04T09:23:14Z"}, "message": "Rewrite `precompute_borrows_out_of_scope` for fewer hash table lookups.\n\nIt now does one hash table lookup per basic block, instead of one per\nstatement. This is worthwhile because this function is hot for NLL\nbuilds of `ucd`.", "tree": {"sha": "c50ac79fdd92fd12376a95f318a8e15e1690d108", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c50ac79fdd92fd12376a95f318a8e15e1690d108"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb307e529d217c6602c1c0359b14947b6897265c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb307e529d217c6602c1c0359b14947b6897265c", "html_url": "https://github.com/rust-lang/rust/commit/fb307e529d217c6602c1c0359b14947b6897265c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb307e529d217c6602c1c0359b14947b6897265c/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "763d91aa124a4278a68207b644df8c48b39fab45", "url": "https://api.github.com/repos/rust-lang/rust/commits/763d91aa124a4278a68207b644df8c48b39fab45", "html_url": "https://github.com/rust-lang/rust/commit/763d91aa124a4278a68207b644df8c48b39fab45"}], "stats": {"total": 120, "additions": 79, "deletions": 41}, "files": [{"sha": "0a6701fc2dbe3deb35449e4702f66b5030062a9e", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 79, "deletions": 41, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/fb307e529d217c6602c1c0359b14947b6897265c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb307e529d217c6602c1c0359b14947b6897265c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=fb307e529d217c6602c1c0359b14947b6897265c", "patch": "@@ -21,7 +21,7 @@ use rustc::ty::{RegionKind, RegionVid};\n use rustc::ty::RegionKind::ReScope;\n \n use rustc_data_structures::bitslice::{BitwiseOperator, Word};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_set::IdxSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::Lrc;\n@@ -53,6 +53,13 @@ pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     _nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n }\n \n+struct StackEntry {\n+    bb: mir::BasicBlock,\n+    lo: usize,\n+    hi: usize,\n+    first_part_only: bool\n+}\n+\n fn precompute_borrows_out_of_scope<'tcx>(\n     mir: &Mir<'tcx>,\n     regioncx: &Rc<RegionInferenceContext<'tcx>>,\n@@ -61,48 +68,79 @@ fn precompute_borrows_out_of_scope<'tcx>(\n     borrow_region: RegionVid,\n     location: Location,\n ) {\n-    // Keep track of places we've locations to check and locations that we have checked.\n-    let mut stack = vec![ location ];\n-    let mut visited = FxHashSet();\n-    visited.insert(location);\n-\n-    debug!(\n-        \"borrow {:?} has region {:?} with value {:?}\",\n-        borrow_index,\n-        borrow_region,\n-        regioncx.region_value_str(borrow_region),\n-    );\n-    debug!(\"borrow {:?} starts at {:?}\", borrow_index, location);\n-    while let Some(location) = stack.pop() {\n-        // If region does not contain a point at the location, then add to list and skip\n-        // successor locations.\n-        if !regioncx.region_contains(borrow_region, location) {\n-            debug!(\"borrow {:?} gets killed at {:?}\", borrow_index, location);\n-            borrows_out_of_scope_at_location\n-                .entry(location)\n-                .or_default()\n-                .push(borrow_index);\n-            continue;\n+    // We visit one BB at a time. The complication is that we may start in the\n+    // middle of the first BB visited (the one containing `location`), in which\n+    // case we may have to later on process the first part of that BB if there\n+    // is a path back to its start.\n+\n+    // For visited BBs, we record the index of the first statement processed.\n+    // (In fully processed BBs this index is 0.) Note also that we add BBs to\n+    // `visited` once they are added to `stack`, before they are actually\n+    // processed, because this avoids the need to look them up again on\n+    // completion.\n+    let mut visited = FxHashMap();\n+    visited.insert(location.block, location.statement_index);\n+\n+    let mut stack = vec![];\n+    stack.push(StackEntry {\n+        bb: location.block,\n+        lo: location.statement_index,\n+        hi: mir[location.block].statements.len(),\n+        first_part_only: false,\n+    });\n+\n+    while let Some(StackEntry { bb, lo, hi, first_part_only }) = stack.pop() {\n+        let mut finished_early = first_part_only;\n+        for i in lo ..= hi {\n+            let location = Location { block: bb, statement_index: i };\n+            // If region does not contain a point at the location, then add to list and skip\n+            // successor locations.\n+            if !regioncx.region_contains(borrow_region, location) {\n+                debug!(\"borrow {:?} gets killed at {:?}\", borrow_index, location);\n+                borrows_out_of_scope_at_location\n+                    .entry(location)\n+                    .or_default()\n+                    .push(borrow_index);\n+                finished_early = true;\n+                break;\n+            }\n         }\n \n-        let bb_data = &mir[location.block];\n-        // If this is the last statement in the block, then add the\n-        // terminator successors next.\n-        if location.statement_index == bb_data.statements.len() {\n-            // Add successors to locations to visit, if not visited before.\n-            if let Some(ref terminator) = bb_data.terminator {\n-                for block in terminator.successors() {\n-                    let loc = block.start_location();\n-                    if visited.insert(loc) {\n-                        stack.push(loc);\n-                    }\n-                }\n-            }\n-        } else {\n-            // Visit next statement in block.\n-            let loc = location.successor_within_block();\n-            if visited.insert(loc) {\n-                stack.push(loc);\n+        if !finished_early {\n+            // Add successor BBs to the work list, if necessary.\n+            let bb_data = &mir[bb];\n+            assert!(hi == bb_data.statements.len());\n+            for &succ_bb in bb_data.terminator.as_ref().unwrap().successors() {\n+                visited.entry(succ_bb)\n+                    .and_modify(|lo| {\n+                        // `succ_bb` has been seen before. If it wasn't\n+                        // fully processed, add its first part to `stack`\n+                        // for processing.\n+                        if *lo > 0 {\n+                            stack.push(StackEntry {\n+                                bb: succ_bb,\n+                                lo: 0,\n+                                hi: *lo - 1,\n+                                first_part_only: true,\n+                            });\n+                        }\n+                        // And update this entry with 0, to represent the\n+                        // whole BB being processed.\n+                        *lo = 0;\n+                    })\n+                    .or_insert_with(|| {\n+                        // succ_bb hasn't been seen before. Add it to\n+                        // `stack` for processing.\n+                        stack.push(StackEntry {\n+                            bb: succ_bb,\n+                            lo: 0,\n+                            hi: mir[succ_bb].statements.len(),\n+                            first_part_only: false,\n+                        });\n+                        // Insert 0 for this BB, to represent the whole BB\n+                        // being processed.\n+                        0\n+                    });\n             }\n         }\n     }"}]}