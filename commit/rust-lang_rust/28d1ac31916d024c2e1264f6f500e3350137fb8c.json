{"sha": "28d1ac31916d024c2e1264f6f500e3350137fb8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ZDFhYzMxOTE2ZDAyNGMyZTEyNjRmNmY1MDBlMzM1MDEzN2ZiOGM=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-01-09T21:42:39Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-01-11T22:26:27Z"}, "message": "Add missing links and examples for path modules and structs", "tree": {"sha": "c3e5ba5a29f406e0a431a53ae47a208ebac8e3a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3e5ba5a29f406e0a431a53ae47a208ebac8e3a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28d1ac31916d024c2e1264f6f500e3350137fb8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28d1ac31916d024c2e1264f6f500e3350137fb8c", "html_url": "https://github.com/rust-lang/rust/commit/28d1ac31916d024c2e1264f6f500e3350137fb8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28d1ac31916d024c2e1264f6f500e3350137fb8c/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd16aa08cdfb89982e3ed2820454769321803c61", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd16aa08cdfb89982e3ed2820454769321803c61", "html_url": "https://github.com/rust-lang/rust/commit/bd16aa08cdfb89982e3ed2820454769321803c61"}], "stats": {"total": 117, "additions": 95, "deletions": 22}, "files": [{"sha": "14323c5203c2f6e8176df8f1a80fd3593a1159cc", "filename": "src/libstd/path.rs", "status": "modified", "additions": 95, "deletions": 22, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/28d1ac31916d024c2e1264f6f500e3350137fb8c/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d1ac31916d024c2e1264f6f500e3350137fb8c/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=28d1ac31916d024c2e1264f6f500e3350137fb8c", "patch": "@@ -10,20 +10,20 @@\n \n //! Cross-platform path manipulation.\n //!\n-//! This module provides two types, `PathBuf` and `Path` (akin to `String` and\n-//! `str`), for working with paths abstractly. These types are thin wrappers\n-//! around `OsString` and `OsStr` respectively, meaning that they work directly\n+//! This module provides two types, [`PathBuf`] and [`Path`][`Path`] (akin to [`String`]\n+//! and [`str`]), for working with paths abstractly. These types are thin wrappers\n+//! around [`OsString`] and [`OsStr`] respectively, meaning that they work directly\n //! on strings according to the local platform's path syntax.\n //!\n //! ## Simple usage\n //!\n //! Path manipulation includes both parsing components from slices and building\n //! new owned paths.\n //!\n-//! To parse a path, you can create a `Path` slice from a `str`\n+//! To parse a path, you can create a [`Path`] slice from a [`str`]\n //! slice and start asking questions:\n //!\n-//! ```rust\n+//! ```\n //! use std::path::Path;\n //! use std::ffi::OsStr;\n //!\n@@ -39,9 +39,9 @@\n //! assert_eq!(extension, Some(OsStr::new(\"txt\")));\n //! ```\n //!\n-//! To build or modify paths, use `PathBuf`:\n+//! To build or modify paths, use [`PathBuf`]:\n //!\n-//! ```rust\n+//! ```\n //! use std::path::PathBuf;\n //!\n //! let mut path = PathBuf::from(\"c:\\\\\");\n@@ -103,6 +103,13 @@\n //! that `b` is a symbolic link (so its parent isn't `a`). Further\n //! normalization is possible to build on top of the components APIs,\n //! and will be included in this library in the near future.\n+//!\n+//! [`PathBuf`]: ../../std/path/struct.PathBuf.html\n+//! [`Path`]: ../../std/path/struct.Path.html\n+//! [`String`]: ../../std/string/struct.String.html\n+//! [`str`]: ../../std/primitive.str.html\n+//! [`OsString`]: ../../std/ffi/struct.OsString.html\n+//! [`OsStr`]: ../../std/ffi/struct.OsStr.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -527,7 +534,9 @@ pub struct Components<'a> {\n     back: State,\n }\n \n-/// An iterator over the components of a path, as `OsStr` slices.\n+/// An iterator over the components of a path, as [`OsStr`] slices.\n+///\n+/// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a> {\n@@ -1089,10 +1098,11 @@ impl PathBuf {\n \n     /// Updates [`self.file_name()`] to `file_name`.\n     ///\n-    /// If [`self.file_name()`] was `None`, this is equivalent to pushing\n+    /// If [`self.file_name()`] was [`None`], this is equivalent to pushing\n     /// `file_name`.\n     ///\n     /// [`self.file_name()`]: struct.PathBuf.html#method.file_name\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -1124,11 +1134,12 @@ impl PathBuf {\n     ///\n     /// If [`self.file_name()`] is `None`, does nothing and returns `false`.\n     ///\n-    /// Otherwise, returns `true`; if [`self.extension()`] is `None`, the\n+    /// Otherwise, returns `true`; if [`self.extension()`] is [`None`], the\n     /// extension is added; otherwise it is replaced.\n     ///\n     /// [`self.file_name()`]: struct.PathBuf.html#method.file_name\n     /// [`self.extension()`]: struct.PathBuf.html#method.extension\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -1356,8 +1367,10 @@ pub struct Path {\n     inner: OsStr,\n }\n \n-/// An error returned from the `Path::strip_prefix` method indicating that the\n+/// An error returned from the [`Path::strip_prefix`] method indicating that the\n /// prefix was not found in `self`.\n+///\n+/// [`Path::strip_prefix`]: struct.Path.html#method.strip_prefix\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[stable(since = \"1.7.0\", feature = \"strip_prefix\")]\n pub struct StripPrefixError(());\n@@ -1534,7 +1547,9 @@ impl Path {\n \n     /// The path without its final component, if any.\n     ///\n-    /// Returns `None` if the path terminates in a root or prefix.\n+    /// Returns [`None`] if the path terminates in a root or prefix.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -1565,7 +1580,9 @@ impl Path {\n \n     /// The final component of the path, if it is a normal file.\n     ///\n-    /// If the path terminates in `..`, `file_name` will return `None`.\n+    /// If the path terminates in `..`, `file_name` will return [`None`].\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -1603,8 +1620,11 @@ impl Path {\n     ///\n     /// # Errors\n     ///\n-    /// If `base` is not a prefix of `self` (i.e. `starts_with`\n-    /// returns `false`), returns `Err`.\n+    /// If `base` is not a prefix of `self` (i.e. [`starts_with`]\n+    /// returns `false`), returns [`Err`].\n+    ///\n+    /// [`starts_with`]: #method.starts_with\n+    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -1684,11 +1704,13 @@ impl Path {\n     ///\n     /// The stem is:\n     ///\n-    /// * None, if there is no file name;\n+    /// * [`None`], if there is no file name;\n     /// * The entire file name if there is no embedded `.`;\n     /// * The entire file name if the file name begins with `.` and has no other `.`s within;\n     /// * Otherwise, the portion of the file name before the final `.`\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1705,15 +1727,16 @@ impl Path {\n \n     /// Extracts the extension of [`self.file_name()`], if possible.\n     ///\n-    /// [`self.file_name()`]: struct.Path.html#method.file_name\n-    ///\n     /// The extension is:\n     ///\n-    /// * None, if there is no file name;\n-    /// * None, if there is no embedded `.`;\n-    /// * None, if the file name begins with `.` and has no other `.`s within;\n+    /// * [`None`], if there is no file name;\n+    /// * [`None`], if there is no embedded `.`;\n+    /// * [`None`], if the file name begins with `.` and has no other `.`s within;\n     /// * Otherwise, the portion of the file name after the final `.`\n     ///\n+    /// [`self.file_name()`]: struct.Path.html#method.file_name\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1872,7 +1895,6 @@ impl Path {\n         Display { path: self }\n     }\n \n-\n     /// Query the file system to get information about a file, directory, etc.\n     ///\n     /// This function will traverse symbolic links to query information about the\n@@ -1881,6 +1903,16 @@ impl Path {\n     /// This is an alias to [`fs::metadata`].\n     ///\n     /// [`fs::metadata`]: ../fs/fn.metadata.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/Minas/tirith\");\n+    /// let metadata = path.metadata().expect(\"metadata call failed\");\n+    /// println!(\"{:?}\", metadata.file_type());\n+    /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn metadata(&self) -> io::Result<fs::Metadata> {\n         fs::metadata(self)\n@@ -1891,6 +1923,16 @@ impl Path {\n     /// This is an alias to [`fs::symlink_metadata`].\n     ///\n     /// [`fs::symlink_metadata`]: ../fs/fn.symlink_metadata.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/Minas/tirith\");\n+    /// let metadata = path.symlink_metadata().expect(\"symlink_metadata call failed\");\n+    /// println!(\"{:?}\", metadata.file_type());\n+    /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn symlink_metadata(&self) -> io::Result<fs::Metadata> {\n         fs::symlink_metadata(self)\n@@ -1902,6 +1944,15 @@ impl Path {\n     /// This is an alias to [`fs::canonicalize`].\n     ///\n     /// [`fs::canonicalize`]: ../fs/fn.canonicalize.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::path::{Path, PathBuf};\n+    ///\n+    /// let path = Path::new(\"/foo/test/../test/bar.rs\");\n+    /// assert_eq!(path.canonicalize().unwrap(), PathBuf::from(\"/foo/test/bar.rs\"));\n+    /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn canonicalize(&self) -> io::Result<PathBuf> {\n         fs::canonicalize(self)\n@@ -1912,6 +1963,15 @@ impl Path {\n     /// This is an alias to [`fs::read_link`].\n     ///\n     /// [`fs::read_link`]: ../fs/fn.read_link.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/laputa/sky_castle.rs\");\n+    /// let path_link = path.read_link().expect(\"read_link call failed\");\n+    /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn read_link(&self) -> io::Result<PathBuf> {\n         fs::read_link(self)\n@@ -1927,6 +1987,19 @@ impl Path {\n     /// [`io::Result`]: ../io/type.Result.html\n     /// [`DirEntry`]: ../fs/struct.DirEntry.html\n     /// [`fs::read_dir`]: ../fs/fn.read_dir.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/laputa\");\n+    /// for entry in path.read_dir().expect(\"read_dir call failed\") {\n+    ///     if let Ok(entry) = entry {\n+    ///         println!(\"{:?}\", entry.path());\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn read_dir(&self) -> io::Result<fs::ReadDir> {\n         fs::read_dir(self)"}]}