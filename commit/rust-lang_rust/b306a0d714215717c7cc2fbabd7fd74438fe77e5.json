{"sha": "b306a0d714215717c7cc2fbabd7fd74438fe77e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMDZhMGQ3MTQyMTU3MTdjN2NjMmZiYWJkN2ZkNzQ0MzhmZTc3ZTU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-29T06:24:07Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-29T21:36:56Z"}, "message": "Get compile tests to run in parallel\n\nTakes a lot of workarounds. The biggest problem is that boxes still don't seem\nto be moved across channels and bad things happen when the receiver destroys\nthem. So there's all sorts of defensive cloning and scoping going on here to\nmake the box lifetimes come out right.", "tree": {"sha": "97cf43ef93337f9d14e283aad658fd7611eaeb70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97cf43ef93337f9d14e283aad658fd7611eaeb70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b306a0d714215717c7cc2fbabd7fd74438fe77e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b306a0d714215717c7cc2fbabd7fd74438fe77e5", "html_url": "https://github.com/rust-lang/rust/commit/b306a0d714215717c7cc2fbabd7fd74438fe77e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b306a0d714215717c7cc2fbabd7fd74438fe77e5/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3df9f50ea8fb136767677821ce433bc7ec188fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3df9f50ea8fb136767677821ce433bc7ec188fb", "html_url": "https://github.com/rust-lang/rust/commit/f3df9f50ea8fb136767677821ce433bc7ec188fb"}], "stats": {"total": 117, "additions": 86, "deletions": 31}, "files": [{"sha": "0c1f85a4d85d289dbe3d7ebda172d441049c3d91", "filename": "src/test/compiletest/compiletest.rs", "status": "modified", "additions": 86, "deletions": 31, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/b306a0d714215717c7cc2fbabd7fd74438fe77e5/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b306a0d714215717c7cc2fbabd7fd74438fe77e5/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcompiletest.rs?ref=b306a0d714215717c7cc2fbabd7fd74438fe77e5", "patch": "@@ -11,6 +11,7 @@ import std::generic_os::getenv;\n import std::os;\n import std::run;\n import std::task;\n+import std::unsafe;\n \n tag mode { mode_compile_fail; mode_run_fail; mode_run_pass; }\n \n@@ -175,7 +176,6 @@ fn make_test(cx: &cx, testfile: &str, configport: &port[str]) ->\n             ignore: header::is_test_ignored(cx.config, testfile)}\n }\n \n-\n /*\n So this is kind of crappy:\n \n@@ -223,7 +223,7 @@ fn closure_to_task(cx: cx, configport: port[str], testfn: &fn() ) -> task {\n                             cx.config.run_ignored, opt_str(cx.config.filter),\n                             opt_str(cx.config.runtool),\n                             opt_str(cx.config.rustcflags), cx.config.verbose,\n-                            procsrv::clone(cx.procsrv).chan, testfile);\n+                            task::clone_chan(cx.procsrv.chan), testfile);\n }\n \n fn run_test_task(compile_lib_path: str, run_lib_path: str, rustc_path: str,\n@@ -304,6 +304,23 @@ fn logv(config: &config, s: &str) {\n     if config.verbose { io::stdout().write_line(s); }\n }\n \n+fn clone_str(s: &str) -> str {\n+    let new = s + \"\";\n+    // new should be a different pointer\n+    let sptr: int = unsafe::reinterpret_cast(s);\n+    let newptr: int = unsafe::reinterpret_cast(new);\n+    assert sptr != newptr;\n+    new\n+}\n+\n+fn clone_ivecstr(v: &str[]) -> str[] {\n+    let r = ~[];\n+    for t: str in ivec::slice(v, 0u, ivec::len(v)) {\n+        r += ~[clone_str(t)];\n+    }\n+    ret r;\n+}\n+\n mod header {\n \n     export test_props;\n@@ -396,10 +413,10 @@ mod runtest {\n         log #fmt(\"running %s\", testfile);\n         let props = load_props(testfile);\n         alt cx.config.mode {\n-                mode_compile_fail. { run_cfail_test(cx, props, testfile); }\n-                mode_run_fail. { run_rfail_test(cx, props, testfile); }\n-                mode_run_pass. { run_rpass_test(cx, props, testfile); }\n-            }\n+          mode_compile_fail. { run_cfail_test(cx, props, testfile); }\n+          mode_run_fail. { run_rfail_test(cx, props, testfile); }\n+          mode_run_pass. { run_rpass_test(cx, props, testfile); }\n+        }\n     }\n \n     fn run_cfail_test(cx: &cx, props: &test_props, testfile: &str) {\n@@ -622,7 +639,7 @@ mod procsrv {\n \n     type handle = {task: option::t[task], chan: reqchan};\n \n-    tag request { exec(str, str, vec[str], chan[response]); stop; }\n+    tag request { exec(str, str, str[], chan[response]); stop; }\n \n     type response = {pid: int, outfd: int, errfd: int};\n \n@@ -631,7 +648,7 @@ mod procsrv {\n         let task = spawn fn(setupchan: chan[chan[request]]) {\n             let reqport = port();\n             let reqchan = chan(reqport);\n-            task::send(setupchan, reqchan);\n+            task::send(setupchan, task::clone_chan(reqchan));\n             worker(reqport);\n         } (chan(setupport));\n         ret {task: option::some(task),\n@@ -657,7 +674,10 @@ mod procsrv {\n         {status: int, out: str, err: str} {\n         let p = port[response]();\n         let ch = chan(p);\n-        task::send(handle.chan, exec(lib_path, prog, args, ch));\n+        task::send(handle.chan, exec(lib_path,\n+                                     prog,\n+                                     clone_ivecstr(ivec::from_vec(args)),\n+                                     task::clone_chan(ch)));\n         let resp = task::recv(p);\n         let output = readclose(resp.outfd);\n         let errput = readclose(resp.errfd);\n@@ -679,29 +699,64 @@ mod procsrv {\n     }\n \n     fn worker(p: port[request]) {\n+\n+        // FIXME: If we declare this inside of the while loop and then\n+        // break out of it before it's ever initialized (i.e. we don't run\n+        // any tests), then the cleanups will puke, so we're initializing it\n+        // here with defaults.\n+        let execparms = {\n+            lib_path: \"\",\n+            prog: \"\",\n+            args: ~[],\n+            // This works because a NULL box is ignored during cleanup\n+            respchan: unsafe::reinterpret_cast(0)\n+        };\n+\n         while true {\n-            alt task::recv(p) {\n-              exec(lib_path, prog, args, respchan) {\n-                // This is copied from run::start_program\n-                let pipe_in = os::pipe();\n-                let pipe_out = os::pipe();\n-                let pipe_err = os::pipe();\n-                let spawnproc =\n-                    bind run::spawn_process(prog, args, pipe_in.in,\n-                                            pipe_out.out, pipe_err.out);\n-                let pid = with_lib_path(lib_path, spawnproc);\n-                if pid == -1 { fail; }\n-                os::libc::close(pipe_in.in);\n-                os::libc::close(pipe_in.out);\n-                os::libc::close(pipe_out.out);\n-                os::libc::close(pipe_err.out);\n-                task::send(respchan,\n-                           {pid: pid,\n-                            outfd: pipe_out.in,\n-                            errfd: pipe_err.in});\n-              }\n-              stop. { ret; }\n-            }\n+            // FIXME: Sending strings across channels seems to still\n+            // leave them refed on the sender's end, which causes problems if\n+            // the receiver's poniters outlive the sender's. Here we clone\n+            // everything and let the originals go out of scope before sending\n+            // a response.\n+            execparms = {\n+                // FIXME: The 'discriminant' of an alt expression has the\n+                // same scope as the alt expression itself, so we have to put\n+                // the entire alt in another block to make sure the exec\n+                // message goes out of scope. Seems like the scoping rules for\n+                // the alt discriminant are wrong.\n+                alt task::recv(p) {\n+                  exec(lib_path, prog, args, respchan) {\n+                    {\n+                        lib_path: clone_str(lib_path),\n+                        prog: clone_str(prog),\n+                        args: clone_ivecstr(args),\n+                        respchan: respchan\n+                    }\n+                  }\n+                  stop. { ret }\n+                }\n+            };\n+\n+            // This is copied from run::start_program\n+            let pipe_in = os::pipe();\n+            let pipe_out = os::pipe();\n+            let pipe_err = os::pipe();\n+            let spawnproc =\n+                bind run::spawn_process(execparms.prog,\n+                                        ivec::to_vec(execparms.args),\n+                                        pipe_in.in,\n+                                        pipe_out.out,\n+                                        pipe_err.out);\n+            let pid = with_lib_path(execparms.lib_path, spawnproc);\n+            if pid == -1 { fail; }\n+            os::libc::close(pipe_in.in);\n+            os::libc::close(pipe_in.out);\n+            os::libc::close(pipe_out.out);\n+            os::libc::close(pipe_err.out);\n+            task::send(execparms.respchan,\n+                       {pid: pid,\n+                        outfd: pipe_out.in,\n+                        errfd: pipe_err.in});\n         }\n     }\n "}]}