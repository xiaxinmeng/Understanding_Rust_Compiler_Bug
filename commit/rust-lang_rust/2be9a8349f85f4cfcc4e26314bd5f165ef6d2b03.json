{"sha": "2be9a8349f85f4cfcc4e26314bd5f165ef6d2b03", "node_id": "C_kwDOAAsO6NoAKDJiZTlhODM0OWY4NWY0Y2ZjYzRlMjYzMTRiZDVmMTY1ZWY2ZDJiMDM", "commit": {"author": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2021-11-25T19:35:28Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2021-11-26T03:52:45Z"}, "message": "Eliminate bunch of copies of error codepath from Utf8LossyChunksIter\n\nUsing a macro to stamp out 7 identical copies of the nontrivial slicing\nlogic to exit this loop didn't seem like a necessary use of a macro. The\nearly return case can be handled by `break` without practically any\nchanges to the logic inside the loop.\n\nAll this code is from early 2014 (7.5 years old, pre-1.0) so it's\npossible there were compiler limitations that forced the macro way at\nthe time.\n\nConfirmed that `x.py bench library/alloc --stage 0 --test-args from_utf8_lossy`\nis unaffected on my machine.", "tree": {"sha": "81277b6b4596887455a01aad52bd55de8e8d4fd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81277b6b4596887455a01aad52bd55de8e8d4fd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2be9a8349f85f4cfcc4e26314bd5f165ef6d2b03", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAmGgWnUACgkQ+boUO5X/\nbYKdbA/9F5vAxA9B1TCiw+Kef9iP8H6OXiQHGzPBcvgfz+F4JdQ73wqgiCGG9Cmb\nxtbJDyWEdusesMcFw/Zofrm1H+yQrIkAJ5TXKdkfDdmWMIsgCpdtmtuM8eMITXJn\nokVEC0dN3FyAbIasEJqYRcbXfI1wUIHl/UE1iZ0I0ZVixgmgqzUdoApOzcsI0cuv\nJYVwA+9Vi0gPk/by8JCpao5tksqfWTqVlHvFXatlzJdvh6dJ7+yGhstLzXEMldX7\nO44rYpIKqixdME/OIMbK56L0wmR+gBVyA2FNuPi7T3X0XleEvlKsDU1Ndgl/v93J\nfRpGZUD01hJB/rEnqnXuohSJJnw8t01mPDIinxCoaiogejjZsQSg0GktliitGaV1\nHxtajSD/uX2qEVFgmZJW+gW0LMaMUIlTdk0j/f04qz3B6ldFkXuzy+60wKDoYk4k\nKFNhS3UfrnQFssFSVpcaNU3W25KFikesxb3qhCy6X3LtYR+W7fuhKkY/d1oMA6+j\nzZ7sZ8/oKi2zynlOu07B0MGIc3K7NeK1qtHnLwe0i1b3ByO8WHwMyBKzBHbfCzTS\nS1YTdyNTP60KcyA7vewP3CTFCPSvQdgMbGPpnteXSHQG2XvGwiqyB/z1/DJ0l5p1\nNUtdAy4xPIioZR4HxTkwWk+f32pjmS45b4H1Zc/jRBP3y5oV/Xg=\n=LPfn\n-----END PGP SIGNATURE-----", "payload": "tree 81277b6b4596887455a01aad52bd55de8e8d4fd0\nparent dd549dcab404ec4c7d07b5a83aca5bdd7171138f\nauthor David Tolnay <dtolnay@gmail.com> 1637868928 -0800\ncommitter David Tolnay <dtolnay@gmail.com> 1637898765 -0800\n\nEliminate bunch of copies of error codepath from Utf8LossyChunksIter\n\nUsing a macro to stamp out 7 identical copies of the nontrivial slicing\nlogic to exit this loop didn't seem like a necessary use of a macro. The\nearly return case can be handled by `break` without practically any\nchanges to the logic inside the loop.\n\nAll this code is from early 2014 (7.5 years old, pre-1.0) so it's\npossible there were compiler limitations that forced the macro way at\nthe time.\n\nConfirmed that `x.py bench library/alloc --stage 0 --test-args from_utf8_lossy`\nis unaffected on my machine.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2be9a8349f85f4cfcc4e26314bd5f165ef6d2b03", "html_url": "https://github.com/rust-lang/rust/commit/2be9a8349f85f4cfcc4e26314bd5f165ef6d2b03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2be9a8349f85f4cfcc4e26314bd5f165ef6d2b03/comments", "author": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd549dcab404ec4c7d07b5a83aca5bdd7171138f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd549dcab404ec4c7d07b5a83aca5bdd7171138f", "html_url": "https://github.com/rust-lang/rust/commit/dd549dcab404ec4c7d07b5a83aca5bdd7171138f"}], "stats": {"total": 69, "additions": 31, "deletions": 38}, "files": [{"sha": "748ee314e73b9585b891f9dfc77ed82428f11cf2", "filename": "library/core/src/str/lossy.rs", "status": "modified", "additions": 31, "deletions": 38, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/2be9a8349f85f4cfcc4e26314bd5f165ef6d2b03/library%2Fcore%2Fsrc%2Fstr%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be9a8349f85f4cfcc4e26314bd5f165ef6d2b03/library%2Fcore%2Fsrc%2Fstr%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Flossy.rs?ref=2be9a8349f85f4cfcc4e26314bd5f165ef6d2b03", "patch": "@@ -61,36 +61,26 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n         }\n \n         let mut i = 0;\n+        let mut valid_up_to = 0;\n         while i < self.source.len() {\n-            let i_ = i;\n-\n-            // SAFETY: `i` starts at `0`, is less than `self.source.len()`, and\n-            // only increases, so `0 <= i < self.source.len()`.\n+            // SAFETY: `i < self.source.len()` per previous line.\n+            // For some reason the following are both significantly slower:\n+            // while let Some(&byte) = self.source.get(i) {\n+            // while let Some(byte) = self.source.get(i).copied() {\n             let byte = unsafe { *self.source.get_unchecked(i) };\n             i += 1;\n \n             if byte < 128 {\n+                // This could be a `1 => ...` case in the match below, but for\n+                // the common case of all-ASCII inputs, we bypass loading the\n+                // sizeable UTF8_CHAR_WIDTH table into cache.\n             } else {\n                 let w = utf8_char_width(byte);\n \n-                macro_rules! error {\n-                    () => {{\n-                        // SAFETY: We have checked up to `i` that source is valid UTF-8.\n-                        unsafe {\n-                            let r = Utf8LossyChunk {\n-                                valid: from_utf8_unchecked(&self.source[0..i_]),\n-                                broken: &self.source[i_..i],\n-                            };\n-                            self.source = &self.source[i..];\n-                            return Some(r);\n-                        }\n-                    }};\n-                }\n-\n                 match w {\n                     2 => {\n                         if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n-                            error!();\n+                            break;\n                         }\n                         i += 1;\n                     }\n@@ -100,13 +90,11 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n                             (0xE1..=0xEC, 0x80..=0xBF) => (),\n                             (0xED, 0x80..=0x9F) => (),\n                             (0xEE..=0xEF, 0x80..=0xBF) => (),\n-                            _ => {\n-                                error!();\n-                            }\n+                            _ => break,\n                         }\n                         i += 1;\n                         if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n-                            error!();\n+                            break;\n                         }\n                         i += 1;\n                     }\n@@ -115,34 +103,39 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n                             (0xF0, 0x90..=0xBF) => (),\n                             (0xF1..=0xF3, 0x80..=0xBF) => (),\n                             (0xF4, 0x80..=0x8F) => (),\n-                            _ => {\n-                                error!();\n-                            }\n+                            _ => break,\n                         }\n                         i += 1;\n                         if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n-                            error!();\n+                            break;\n                         }\n                         i += 1;\n                         if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n-                            error!();\n+                            break;\n                         }\n                         i += 1;\n                     }\n-                    _ => {\n-                        error!();\n-                    }\n+                    _ => break,\n                 }\n             }\n+\n+            valid_up_to = i;\n         }\n \n-        let r = Utf8LossyChunk {\n-            // SAFETY: We have checked that the entire source is valid UTF-8.\n-            valid: unsafe { from_utf8_unchecked(self.source) },\n-            broken: &[],\n-        };\n-        self.source = &[];\n-        Some(r)\n+        // SAFETY: `i <= self.source.len()` because it only ever increments by 1\n+        // and the loop is terminated as soon as that goes beyond bounds.\n+        let (inspected, remaining) = unsafe { self.source.split_at_unchecked(i) };\n+        self.source = remaining;\n+\n+        // SAFETY: `valid_up_to <= i` because it is only ever assigned via\n+        // `valid_up_to = i` and `i` only increases.\n+        let (valid, broken) = unsafe { inspected.split_at_unchecked(valid_up_to) };\n+\n+        Some(Utf8LossyChunk {\n+            // SAFETY: All bytes up to `valid_up_to` are valid UTF-8.\n+            valid: unsafe { from_utf8_unchecked(valid) },\n+            broken,\n+        })\n     }\n }\n "}]}