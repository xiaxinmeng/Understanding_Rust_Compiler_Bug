{"sha": "e9e178a5810a133d759b418f53a43cab1e716cab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5ZTE3OGE1ODEwYTEzM2Q3NTliNDE4ZjUzYTQzY2FiMWU3MTZjYWI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-26T12:21:47Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-29T00:18:39Z"}, "message": "Refactor away `ResolveResult`.", "tree": {"sha": "079de6f127644b2930b1579131195302515f4009", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/079de6f127644b2930b1579131195302515f4009"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9e178a5810a133d759b418f53a43cab1e716cab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9e178a5810a133d759b418f53a43cab1e716cab", "html_url": "https://github.com/rust-lang/rust/commit/e9e178a5810a133d759b418f53a43cab1e716cab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9e178a5810a133d759b418f53a43cab1e716cab/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af2d89c7f64a590b5c9e8445fc03716cf0dcbca1", "url": "https://api.github.com/repos/rust-lang/rust/commits/af2d89c7f64a590b5c9e8445fc03716cf0dcbca1", "html_url": "https://github.com/rust-lang/rust/commit/af2d89c7f64a590b5c9e8445fc03716cf0dcbca1"}], "stats": {"total": 131, "additions": 45, "deletions": 86}, "files": [{"sha": "d90a49213d141444d39442468ac0b59873e4941f", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e9e178a5810a133d759b418f53a43cab1e716cab/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9e178a5810a133d759b418f53a43cab1e716cab/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=e9e178a5810a133d759b418f53a43cab1e716cab", "patch": "@@ -18,7 +18,6 @@ use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n use {Resolver, Module, ModuleS, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n use Namespace::{self, TypeNS, ValueNS, MacroNS};\n-use ResolveResult::Success;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n use rustc::middle::cstore::LoadedMacro;\n@@ -583,7 +582,7 @@ impl<'b> Resolver<'b> {\n         } else {\n             for (name, span) in legacy_imports.imports {\n                 let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n-                if let Success(binding) = result {\n+                if let Ok(binding) = result {\n                     self.legacy_import_macro(name, binding, span, allow_shadowing);\n                 } else {\n                     span_err!(self.session, span, E0469, \"imported macro not found\");\n@@ -595,7 +594,7 @@ impl<'b> Resolver<'b> {\n             self.used_crates.insert(krate);\n             self.session.cstore.export_macros(krate);\n             let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n-            if let Success(binding) = result {\n+            if let Ok(binding) = result {\n                 self.macro_exports.push(Export { name: name, def: binding.def() });\n             } else {\n                 span_err!(self.session, span, E0470, \"reexported macro not found\");"}, {"sha": "18e14c2dc39866de661e7e2bbf9f7765ec4072c1", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e9e178a5810a133d759b418f53a43cab1e716cab/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9e178a5810a133d759b418f53a43cab1e716cab/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e9e178a5810a133d759b418f53a43cab1e716cab", "patch": "@@ -35,7 +35,6 @@ extern crate arena;\n extern crate rustc;\n \n use self::Namespace::*;\n-use self::ResolveResult::*;\n use self::FallbackSuggestion::*;\n use self::TypeParameters::*;\n use self::RibKind::*;\n@@ -668,22 +667,6 @@ impl<'a> Visitor for Resolver<'a> {\n \n pub type ErrorMessage = Option<(Span, String)>;\n \n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum ResolveResult<T> {\n-    Failed(ErrorMessage), // Failed to resolve the name, optional helpful error message.\n-    Indeterminate, // Couldn't determine due to unresolved globs.\n-    Success(T), // Successfully resolved the import.\n-}\n-\n-impl<T> ResolveResult<T> {\n-    fn success(self) -> Option<T> {\n-        match self {\n-            Success(t) => Some(t),\n-            _ => None,\n-        }\n-    }\n-}\n-\n enum FallbackSuggestion {\n     NoSuggestion,\n     Field,\n@@ -1417,15 +1400,15 @@ impl<'a> Resolver<'a> {\n             if let ModuleRibKind(module) = self.ribs[ns][i].kind {\n                 let name = ident.name;\n                 let item = self.resolve_name_in_module(module, name, ns, false, record_used);\n-                if let Success(binding) = item {\n+                if let Ok(binding) = item {\n                     // The ident resolves to an item.\n                     return Some(LexicalScopeBinding::Item(binding));\n                 }\n \n                 if let ModuleKind::Block(..) = module.kind { // We can see through blocks\n                 } else if !module.no_implicit_prelude {\n                     return self.prelude.and_then(|prelude| {\n-                        self.resolve_name_in_module(prelude, name, ns, false, None).success()\n+                        self.resolve_name_in_module(prelude, name, ns, false, None).ok()\n                     }).map(LexicalScopeBinding::Item)\n                 } else {\n                     return None;\n@@ -2398,11 +2381,7 @@ impl<'a> Resolver<'a> {\n             allow_super = false;\n \n             let binding = if let Some(module) = module {\n-                match self.resolve_name_in_module(module, ident.name, ns, false, record_used) {\n-                    Success(binding) => Ok(binding),\n-                    Indeterminate => Err(Undetermined),\n-                    Failed(_) => Err(Determined),\n-                }\n+                self.resolve_name_in_module(module, ident.name, ns, false, record_used)\n             } else {\n                 match self.resolve_ident_in_lexical_scope(ident, ns, record_used) {\n                     Some(LexicalScopeBinding::Item(binding)) => Ok(binding),"}, {"sha": "3b34a60c585255616791a1d0f9d6ed290ddda5af", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e9e178a5810a133d759b418f53a43cab1e716cab/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9e178a5810a133d759b418f53a43cab1e716cab/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=e9e178a5810a133d759b418f53a43cab1e716cab", "patch": "@@ -10,7 +10,6 @@\n \n use {Module, ModuleKind, NameBinding, NameBindingKind, Resolver, AmbiguityError};\n use Namespace::{self, MacroNS};\n-use ResolveResult::{Success, Indeterminate, Failed};\n use build_reduced_graph::BuildReducedGraphVisitor;\n use resolve_imports::ImportResolver;\n use rustc::hir::def_id::{DefId, BUILTIN_MACROS_CRATE, CRATE_DEF_INDEX, DefIndex};\n@@ -254,7 +253,7 @@ impl<'a> Resolver<'a> {\n             // Since expanded macros may not shadow the lexical scope (enforced below),\n             // we can ignore unresolved invocations (indicated by the penultimate argument).\n             match self.resolve_name_in_module(module, name, ns, true, record_used) {\n-                Success(binding) => {\n+                Ok(binding) => {\n                     let span = match record_used {\n                         Some(span) => span,\n                         None => return Some(binding),\n@@ -270,8 +269,8 @@ impl<'a> Resolver<'a> {\n                         potential_expanded_shadower = Some(binding);\n                     }\n                 },\n-                Indeterminate => return None,\n-                Failed(..) => {}\n+                Err(Determinacy::Undetermined) => return None,\n+                Err(Determinacy::Determined) => {}\n             }\n \n             match module.kind {"}, {"sha": "2a803d72fd1bdb720a6bc0390303a46e3faeaafd", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 37, "deletions": 55, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/e9e178a5810a133d759b418f53a43cab1e716cab/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9e178a5810a133d759b418f53a43cab1e716cab/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=e9e178a5810a133d759b418f53a43cab1e716cab", "patch": "@@ -13,8 +13,6 @@ use self::ImportDirectiveSubclass::*;\n use {Module, PerNS};\n use Namespace::{self, TypeNS, MacroNS};\n use {NameBinding, NameBindingKind, PathResult, PathScope, PrivacyError, ToNameBinding};\n-use ResolveResult;\n-use ResolveResult::*;\n use Resolver;\n use {names_to_string, module_to_string};\n use {resolve_error, ResolutionError};\n@@ -142,32 +140,32 @@ impl<'a> Resolver<'a> {\n                                   ns: Namespace,\n                                   ignore_unresolved_invocations: bool,\n                                   record_used: Option<Span>)\n-                                  -> ResolveResult<&'a NameBinding<'a>> {\n+                                  -> Result<&'a NameBinding<'a>, Determinacy> {\n         self.populate_module_if_necessary(module);\n \n         let resolution = self.resolution(module, name, ns);\n         let resolution = match resolution.borrow_state() {\n             ::std::cell::BorrowState::Unused => resolution.borrow_mut(),\n-            _ => return Failed(None), // This happens when there is a cycle of imports\n+            _ => return Err(Determined), // This happens when there is a cycle of imports\n         };\n \n         if let Some(span) = record_used {\n             if let Some(binding) = resolution.binding {\n                 if self.record_use(name, ns, binding, span) {\n-                    return Success(self.dummy_binding);\n+                    return Ok(self.dummy_binding);\n                 }\n                 if !self.is_accessible(binding.vis) {\n                     self.privacy_errors.push(PrivacyError(span, name, binding));\n                 }\n             }\n \n-            return resolution.binding.map(Success).unwrap_or(Failed(None));\n+            return resolution.binding.ok_or(Determined);\n         }\n \n         let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n             // `extern crate` are always usable for backwards compatability, see issue #37020.\n             let usable = this.is_accessible(binding.vis) || binding.is_extern_crate();\n-            if usable { Success(binding) } else { Failed(None) }\n+            if usable { Ok(binding) } else { Err(Determined) }\n         };\n \n         // Items and single imports are not shadowable.\n@@ -179,19 +177,19 @@ impl<'a> Resolver<'a> {\n \n         // Check if a single import can still define the name.\n         match resolution.single_imports {\n-            SingleImports::AtLeastOne => return Indeterminate,\n+            SingleImports::AtLeastOne => return Err(Undetermined),\n             SingleImports::MaybeOne(directive) if self.is_accessible(directive.vis.get()) => {\n                 let module = match directive.imported_module.get() {\n                     Some(module) => module,\n-                    None => return Indeterminate,\n+                    None => return Err(Undetermined),\n                 };\n                 let name = match directive.subclass {\n                     SingleImport { source, .. } => source,\n                     _ => unreachable!(),\n                 };\n                 match self.resolve_name_in_module(module, name, ns, false, None) {\n-                    Failed(_) => {}\n-                    _ => return Indeterminate,\n+                    Err(Determined) => {}\n+                    _ => return Err(Undetermined),\n                 }\n             }\n             SingleImports::MaybeOne(_) | SingleImports::None => {},\n@@ -204,24 +202,24 @@ impl<'a> Resolver<'a> {\n             Some(binding) if no_unresolved_invocations || ns == MacroNS =>\n                 return check_usable(self, binding),\n             None if no_unresolved_invocations => {}\n-            _ => return Indeterminate,\n+            _ => return Err(Undetermined),\n         }\n \n         // Check if the globs are determined\n         for directive in module.globs.borrow().iter() {\n             if self.is_accessible(directive.vis.get()) {\n                 if let Some(module) = directive.imported_module.get() {\n                     let result = self.resolve_name_in_module(module, name, ns, false, None);\n-                    if let Indeterminate = result {\n-                        return Indeterminate;\n+                    if let Err(Undetermined) = result {\n+                        return Err(Undetermined);\n                     }\n                 } else {\n-                    return Indeterminate;\n+                    return Err(Undetermined);\n                 }\n             }\n         }\n \n-        Failed(None)\n+        Err(Determined)\n     }\n \n     // Add an import directive to the current module.\n@@ -421,9 +419,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             prev_num_indeterminates = self.indeterminate_imports.len();\n             for import in mem::replace(&mut self.indeterminate_imports, Vec::new()) {\n                 match self.resolve_import(&import) {\n-                    Failed(_) => self.determined_imports.push(import),\n-                    Indeterminate => self.indeterminate_imports.push(import),\n-                    Success(()) => self.determined_imports.push(import),\n+                    true => self.determined_imports.push(import),\n+                    false => self.indeterminate_imports.push(import),\n                 }\n             }\n         }\n@@ -437,19 +434,15 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let mut errors = false;\n         for i in 0 .. self.determined_imports.len() {\n             let import = self.determined_imports[i];\n-            if let Failed(err) = self.finalize_import(import) {\n+            if let Some(err) = self.finalize_import(import) {\n                 errors = true;\n-                let (span, help) = match err {\n-                    Some((span, msg)) => (span, msg),\n-                    None => continue,\n-                };\n \n                 // If the error is a single failed import then create a \"fake\" import\n                 // resolution for it so that later resolve stages won't complain.\n                 self.import_dummy_binding(import);\n                 let path = import_path_to_string(&import.module_path, &import.subclass);\n-                let error = ResolutionError::UnresolvedImport(Some((&path, &help)));\n-                resolve_error(self.resolver, span, error);\n+                let error = ResolutionError::UnresolvedImport(Some((&path, &err)));\n+                resolve_error(self.resolver, import.span, error);\n             }\n         }\n \n@@ -463,12 +456,9 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }\n     }\n \n-    /// Attempts to resolve the given import. The return value indicates\n-    /// failure if we're certain the name does not exist, indeterminate if we\n-    /// don't know whether the name exists at the moment due to other\n-    /// currently-unresolved imports, or success if we know the name exists.\n+    /// Attempts to resolve the given import, returning true if its resolution is determined.\n     /// If successful, the resolved bindings are written into the module.\n-    fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> ResolveResult<()> {\n+    fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> bool {\n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n                names_to_string(&directive.module_path),\n                module_to_string(self.current_module));\n@@ -487,8 +477,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n             match result {\n                 PathResult::Module(module) => module,\n-                PathResult::Indeterminate => return Indeterminate,\n-                _ => return Failed(None),\n+                PathResult::Indeterminate => return false,\n+                _ => return true,\n             }\n         };\n \n@@ -497,21 +487,15 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             SingleImport { source, target, ref result } => (source, target, result),\n             GlobImport { .. } => {\n                 self.resolve_glob_import(directive);\n-                return Success(());\n+                return true;\n             }\n             _ => unreachable!(),\n         };\n \n         let mut indeterminate = false;\n         self.per_ns(|this, ns| {\n             if let Err(Undetermined) = result[ns].get() {\n-                result[ns].set({\n-                    match this.resolve_name_in_module(module, source, ns, false, None) {\n-                        Success(binding) => Ok(binding),\n-                        Indeterminate => Err(Undetermined),\n-                        Failed(_) => Err(Determined),\n-                    }\n-                });\n+                result[ns].set(this.resolve_name_in_module(module, source, ns, false, None));\n             } else {\n                 return\n             };\n@@ -543,37 +527,35 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             }\n         });\n \n-        if indeterminate { Indeterminate } else { Success(()) }\n+        !indeterminate\n     }\n \n-    fn finalize_import(&mut self, directive: &'b ImportDirective<'b>) -> ResolveResult<()> {\n+    // If appropriate, returns an error to report.\n+    fn finalize_import(&mut self, directive: &'b ImportDirective<'b>) -> Option<String> {\n         self.current_module = directive.parent;\n \n         let ImportDirective { ref module_path, span, .. } = *directive;\n         let module_result = self.resolve_path(&module_path, PathScope::Import, None, Some(span));\n         let module = match module_result {\n             PathResult::Module(module) => module,\n-            PathResult::NonModule(..) => return Success(()),\n-            PathResult::Indeterminate => return Indeterminate,\n             PathResult::Failed(msg, _) => {\n                 let mut path = vec![keywords::SelfValue.ident()];\n                 path.extend(module_path);\n                 let result = self.resolve_path(&path, PathScope::Import, None, None);\n                 return if let PathResult::Module(..) = result {\n-                    let msg = format!(\"Did you mean `self::{}`?\", &names_to_string(module_path));\n-                    Failed(Some((span, msg)))\n+                    Some(format!(\"Did you mean `self::{}`?\", &names_to_string(module_path)))\n                 } else {\n-                    Failed(Some((span, msg)))\n+                    Some(msg)\n                 };\n             },\n+            _ => return None,\n         };\n \n         let (name, result) = match directive.subclass {\n             SingleImport { source, ref result, .. } => (source, result),\n             GlobImport { .. } if module.def_id() == directive.parent.def_id() => {\n                 // Importing a module into itself is not allowed.\n-                let msg = \"Cannot glob-import a module into itself.\".into();\n-                return Failed(Some((directive.span, msg)));\n+                return Some(\"Cannot glob-import a module into itself.\".to_string());\n             }\n             GlobImport { is_prelude, ref max_vis } => {\n                 if !is_prelude &&\n@@ -582,7 +564,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     let msg = \"A non-empty glob must import something with the glob's visibility\";\n                     self.session.span_err(directive.span, msg);\n                 }\n-                return Success(());\n+                return None;\n             }\n             _ => unreachable!(),\n         };\n@@ -602,7 +584,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| {\n                 match this.resolve_name_in_module(module, name, ns, false, Some(span)) {\n-                    Success(_) => all_ns_failed = false,\n+                    Ok(_) => all_ns_failed = false,\n                     _ => {}\n                 }\n             });\n@@ -627,11 +609,11 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 } else {\n                     format!(\"no `{}` in `{}`{}\", name, module_str, lev_suggestion)\n                 };\n-                Failed(Some((directive.span, msg)))\n+                Some(msg)\n             } else {\n                 // `resolve_name_in_module` reported a privacy error.\n                 self.import_dummy_binding(directive);\n-                Success(())\n+                None\n             }\n         }\n \n@@ -680,7 +662,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         });\n \n         debug!(\"(resolving single import) successfully resolved import\");\n-        return Success(());\n+        None\n     }\n \n     fn resolve_glob_import(&mut self, directive: &'b ImportDirective<'b>) {"}]}