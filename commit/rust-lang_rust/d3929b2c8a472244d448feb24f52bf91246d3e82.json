{"sha": "d3929b2c8a472244d448feb24f52bf91246d3e82", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzOTI5YjJjOGE0NzIyNDRkNDQ4ZmViMjRmNTJiZjkxMjQ2ZDNlODI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-22T19:10:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-22T19:10:13Z"}, "message": "Auto merge of #30969 - Amanieu:extended_atomic_cmpxchg, r=alexcrichton\n\nThis is an implementation of rust-lang/rfcs#1443.", "tree": {"sha": "6f0606ae73ab285195dc81dde5ea098c779a5988", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f0606ae73ab285195dc81dde5ea098c779a5988"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3929b2c8a472244d448feb24f52bf91246d3e82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3929b2c8a472244d448feb24f52bf91246d3e82", "html_url": "https://github.com/rust-lang/rust/commit/d3929b2c8a472244d448feb24f52bf91246d3e82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3929b2c8a472244d448feb24f52bf91246d3e82/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1f422ec280b881b8236c5d173103bc799e1590e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1f422ec280b881b8236c5d173103bc799e1590e", "html_url": "https://github.com/rust-lang/rust/commit/d1f422ec280b881b8236c5d173103bc799e1590e"}, {"sha": "4fdbc2f1cb56cf47f535dbe2f250ca387f0278b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fdbc2f1cb56cf47f535dbe2f250ca387f0278b6", "html_url": "https://github.com/rust-lang/rust/commit/4fdbc2f1cb56cf47f535dbe2f250ca387f0278b6"}], "stats": {"total": 626, "additions": 577, "deletions": 49}, "files": [{"sha": "47f5d68f311588d66584dbfbfe846912408face8", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d3929b2c8a472244d448feb24f52bf91246d3e82/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3929b2c8a472244d448feb24f52bf91246d3e82/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=d3929b2c8a472244d448feb24f52bf91246d3e82", "patch": "@@ -58,6 +58,33 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> T;\n     pub fn atomic_cxchg_acqrel<T>(dst: *mut T, old: T, src: T) -> T;\n     pub fn atomic_cxchg_relaxed<T>(dst: *mut T, old: T, src: T) -> T;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchg_failrelaxed<T>(dst: *mut T, old: T, src: T) -> T;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchg_failacq<T>(dst: *mut T, old: T, src: T) -> T;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchg_acq_failrelaxed<T>(dst: *mut T, old: T, src: T) -> T;\n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchg_acqrel_failrelaxed<T>(dst: *mut T, old: T, src: T) -> T;\n+\n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchgweak<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchgweak_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchgweak_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchgweak_acqrel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchgweak_relaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchgweak_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchgweak_failacq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchgweak_acq_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+    #[cfg(not(stage0))]\n+    pub fn atomic_cxchgweak_acqrel_failrelaxed<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     pub fn atomic_load<T>(src: *const T) -> T;\n     pub fn atomic_load_acq<T>(src: *const T) -> T;"}, {"sha": "0c831bff763d0dc22ccb3ea1ecacb9a379ae9dbd", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 426, "deletions": 9, "changes": 435, "blob_url": "https://github.com/rust-lang/rust/blob/d3929b2c8a472244d448feb24f52bf91246d3e82/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3929b2c8a472244d448feb24f52bf91246d3e82/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=d3929b2c8a472244d448feb24f52bf91246d3e82", "patch": "@@ -311,10 +311,101 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {\n+        self.compare_exchange(current, new, order, strongest_failure_ordering(order))\n+    }\n+\n+    /// Stores a value into the `bool` if the current value is the same as the `current` value.\n+    ///\n+    /// The return value is always the previous value. If it is equal to `current`, then the value\n+    /// was updated.\n+    ///\n+    /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n+    /// operation. The first describes the required ordering if the operation succeeds while the\n+    /// second describes the required ordering when the operation fails. The failure ordering can't\n+    /// be `Acquire` or `AcqRel` and must be equivalent or weaker than the success ordering.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(extended_compare_and_swap)]\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n+    ///\n+    /// let some_bool = AtomicBool::new(true);\n+    ///\n+    /// assert_eq!(some_bool.compare_exchange(true,\n+    ///                                       false,\n+    ///                                       Ordering::Acquire,\n+    ///                                       Ordering::Relaxed),\n+    ///            true);\n+    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n+    ///\n+    /// assert_eq!(some_bool.compare_exchange(true, true,\n+    ///                                       Ordering::SeqCst,\n+    ///                                       Ordering::Acquire),\n+    ///            false);\n+    /// assert_eq!(some_bool.load(Ordering::Relaxed), false);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n+    pub fn compare_exchange(&self,\n+                            current: bool,\n+                            new: bool,\n+                            success: Ordering,\n+                            failure: Ordering) -> bool {\n         let current = if current { UINT_TRUE } else { 0 };\n         let new = if new { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_compare_and_swap(self.v.get(), current, new, order) > 0 }\n+        unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) > 0 }\n+    }\n+\n+    /// Stores a value into the `bool` if the current value is the same as the `current` value.\n+    ///\n+    /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n+    /// comparison succeeds, which can result in more efficient code on some platforms. The\n+    /// returned value is a tuple of the existing value and a flag indicating whether the\n+    /// new value was written.\n+    ///\n+    /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n+    /// ordering of this operation. The first describes the required ordering if the operation\n+    /// succeeds while the second describes the required ordering when the operation fails. The\n+    /// failure ordering can't be `Acquire` or `AcqRel` and must be equivalent or weaker than the\n+    /// success ordering.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(extended_compare_and_swap)]\n+    /// use std::sync::atomic::{AtomicBool, Ordering};\n+    ///\n+    /// let val = AtomicBool::new(false);\n+    ///\n+    /// let new = true;\n+    /// let mut old = val.load(Ordering::Relaxed);\n+    /// loop {\n+    ///     let result = val.compare_exchange_weak(old, new,\n+    ///                                            Ordering::SeqCst,\n+    ///                                            Ordering::Relaxed);\n+    ///     if result.1 {\n+    ///         break;\n+    ///     } else {\n+    ///         old = result.0;\n+    ///     }\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n+    pub fn compare_exchange_weak(&self,\n+                                 current: bool,\n+                                 new: bool,\n+                                 success: Ordering,\n+                                 failure: Ordering) -> (bool, bool) {\n+        let current = if current { UINT_TRUE } else { 0 };\n+        let new = if new { UINT_TRUE } else { 0 };\n+\n+        let result = unsafe {\n+            atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n+        };\n+        (result.0 > 0, result.1)\n     }\n \n     /// Logical \"and\" with a boolean value.\n@@ -553,7 +644,91 @@ impl AtomicIsize {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, current: isize, new: isize, order: Ordering) -> isize {\n-        unsafe { atomic_compare_and_swap(self.v.get(), current, new, order) }\n+        self.compare_exchange(current, new, order, strongest_failure_ordering(order))\n+    }\n+\n+    /// Stores a value into the `isize` if the current value is the same as the `current` value.\n+    ///\n+    /// The return value is always the previous value. If it is equal to `current`, then the value\n+    /// was updated.\n+    ///\n+    /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n+    /// operation. The first describes the required ordering if the operation succeeds while the\n+    /// second describes the required ordering when the operation fails. The failure ordering can't\n+    /// be `Acquire` or `AcqRel` and must be equivalent or weaker than the success ordering.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(extended_compare_and_swap)]\n+    /// use std::sync::atomic::{AtomicIsize, Ordering};\n+    ///\n+    /// let some_isize = AtomicIsize::new(5);\n+    ///\n+    /// assert_eq!(some_isize.compare_exchange(5, 10,\n+    ///                                        Ordering::Acquire,\n+    ///                                        Ordering::Relaxed),\n+    ///            5);\n+    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n+    ///\n+    /// assert_eq!(some_isize.compare_exchange(6, 12,\n+    ///                                        Ordering::SeqCst,\n+    ///                                        Ordering::Acquire),\n+    ///            10);\n+    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n+    pub fn compare_exchange(&self,\n+                            current: isize,\n+                            new: isize,\n+                            success: Ordering,\n+                            failure: Ordering) -> isize {\n+        unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n+    }\n+\n+    /// Stores a value into the `isize if the current value is the same as the `current` value.\n+    ///\n+    /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n+    /// comparison succeeds, which can result in more efficient code on some platforms. The\n+    /// returned value is a tuple of the existing value and a flag indicating whether the\n+    /// new value was written.\n+    ///\n+    /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n+    /// ordering of this operation. The first describes the required ordering if the operation\n+    /// succeeds while the second describes the required ordering when the operation fails. The\n+    /// failure ordering can't be `Acquire` or `AcqRel` and must be equivalent or weaker than the\n+    /// success ordering.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(extended_compare_and_swap)]\n+    /// use std::sync::atomic::{AtomicIsize, Ordering};\n+    ///\n+    /// let val = AtomicIsize::new(4);\n+    ///\n+    /// let mut old = val.load(Ordering::Relaxed);\n+    /// loop {\n+    ///     let new = old * 2;\n+    ///     let result = val.compare_exchange_weak(old, new,\n+    ///                                            Ordering::SeqCst,\n+    ///                                            Ordering::Relaxed);\n+    ///     if result.1 {\n+    ///         break;\n+    ///     } else {\n+    ///         old = result.0;\n+    ///     }\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n+    pub fn compare_exchange_weak(&self,\n+                                 current: isize,\n+                                 new: isize,\n+                                 success: Ordering,\n+                                 failure: Ordering) -> (isize, bool) {\n+        unsafe { atomic_compare_exchange_weak(self.v.get(), current, new, success, failure) }\n     }\n \n     /// Add an isize to the current value, returning the previous value.\n@@ -746,7 +921,91 @@ impl AtomicUsize {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, current: usize, new: usize, order: Ordering) -> usize {\n-        unsafe { atomic_compare_and_swap(self.v.get(), current, new, order) }\n+        self.compare_exchange(current, new, order, strongest_failure_ordering(order))\n+    }\n+\n+    /// Stores a value into the `usize` if the current value is the same as the `current` value.\n+    ///\n+    /// The return value is always the previous value. If it is equal to `current`, then the value\n+    /// was updated.\n+    ///\n+    /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n+    /// operation. The first describes the required ordering if the operation succeeds while the\n+    /// second describes the required ordering when the operation fails. The failure ordering can't\n+    /// be `Acquire` or `AcqRel` and must be equivalent or weaker than the success ordering.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(extended_compare_and_swap)]\n+    /// use std::sync::atomic::{AtomicUsize, Ordering};\n+    ///\n+    /// let some_isize = AtomicUsize::new(5);\n+    ///\n+    /// assert_eq!(some_isize.compare_exchange(5, 10,\n+    ///                                        Ordering::Acquire,\n+    ///                                        Ordering::Relaxed),\n+    ///            5);\n+    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n+    ///\n+    /// assert_eq!(some_isize.compare_exchange(6, 12,\n+    ///                                        Ordering::SeqCst,\n+    ///                                        Ordering::Acquire),\n+    ///            10);\n+    /// assert_eq!(some_isize.load(Ordering::Relaxed), 10);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n+    pub fn compare_exchange(&self,\n+                            current: usize,\n+                            new: usize,\n+                            success: Ordering,\n+                            failure: Ordering) -> usize {\n+        unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n+    }\n+\n+    /// Stores a value into the `usize` if the current value is the same as the `current` value.\n+    ///\n+    /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n+    /// comparison succeeds, which can result in more efficient code on some platforms. The\n+    /// returned value is a tuple of the existing value and a flag indicating whether the\n+    /// new value was written.\n+    ///\n+    /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n+    /// ordering of this operation. The first describes the required ordering if the operation\n+    /// succeeds while the second describes the required ordering when the operation fails. The\n+    /// failure ordering can't be `Acquire` or `AcqRel` and must be equivalent or weaker than the\n+    /// success ordering.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(extended_compare_and_swap)]\n+    /// use std::sync::atomic::{AtomicUsize, Ordering};\n+    ///\n+    /// let val = AtomicUsize::new(4);\n+    ///\n+    /// let mut old = val.load(Ordering::Relaxed);\n+    /// loop {\n+    ///     let new = old * 2;\n+    ///     let result = val.compare_exchange_weak(old, new,\n+    ///                                            Ordering::SeqCst,\n+    ///                                            Ordering::Relaxed);\n+    ///     if result.1 {\n+    ///         break;\n+    ///     } else {\n+    ///         old = result.0;\n+    ///     }\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n+    pub fn compare_exchange_weak(&self,\n+                                 current: usize,\n+                                 new: usize,\n+                                 success: Ordering,\n+                                 failure: Ordering) -> (usize, bool) {\n+        unsafe { atomic_compare_exchange_weak(self.v.get(), current, new, success, failure) }\n     }\n \n     /// Add to the current usize, returning the previous value.\n@@ -947,15 +1206,109 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {\n+        self.compare_exchange(current, new, order, strongest_failure_ordering(order))\n+    }\n+\n+    /// Stores a value into the pointer if the current value is the same as the `current` value.\n+    ///\n+    /// The return value is always the previous value. If it is equal to `current`, then the value\n+    /// was updated.\n+    ///\n+    /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n+    /// operation. The first describes the required ordering if the operation succeeds while the\n+    /// second describes the required ordering when the operation fails. The failure ordering can't\n+    /// be `Acquire` or `AcqRel` and must be equivalent or weaker than the success ordering.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(extended_compare_and_swap)]\n+    /// use std::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let ptr = &mut 5;\n+    /// let some_ptr  = AtomicPtr::new(ptr);\n+    ///\n+    /// let other_ptr   = &mut 10;\n+    /// let another_ptr = &mut 10;\n+    ///\n+    /// let value = some_ptr.compare_exchange(other_ptr, another_ptr,\n+    ///                                       Ordering::SeqCst, Ordering::Relaxed);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n+    pub fn compare_exchange(&self,\n+                            current: *mut T,\n+                            new: *mut T,\n+                            success: Ordering,\n+                            failure: Ordering) -> *mut T {\n         unsafe {\n-            atomic_compare_and_swap(self.p.get() as *mut usize, current as usize,\n-                                    new as usize, order) as *mut T\n+            atomic_compare_exchange(self.p.get() as *mut usize, current as usize,\n+                                    new as usize, success, failure) as *mut T\n         }\n     }\n+\n+    /// Stores a value into the pointer if the current value is the same as the `current` value.\n+    ///\n+    /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n+    /// comparison succeeds, which can result in more efficient code on some platforms. The\n+    /// returned value is a tuple of the existing value and a flag indicating whether the\n+    /// new value was written.\n+    ///\n+    /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n+    /// ordering of this operation. The first describes the required ordering if the operation\n+    /// succeeds while the second describes the required ordering when the operation fails. The\n+    /// failure ordering can't be `Acquire` or `AcqRel` and must be equivalent or weaker than the\n+    /// success ordering.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(extended_compare_and_swap)]\n+    /// use std::sync::atomic::{AtomicPtr, Ordering};\n+    ///\n+    /// let some_ptr = AtomicPtr::new(&mut 5);\n+    ///\n+    /// let new = &mut 10;\n+    /// let mut old = some_ptr.load(Ordering::Relaxed);\n+    /// loop {\n+    ///     let result = some_ptr.compare_exchange_weak(old, new,\n+    ///                                                 Ordering::SeqCst,\n+    ///                                                 Ordering::Relaxed);\n+    ///     if result.1 {\n+    ///         break;\n+    ///     } else {\n+    ///         old = result.0;\n+    ///     }\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"extended_compare_and_swap\", reason = \"recently added\", issue = \"31767\")]\n+    pub fn compare_exchange_weak(&self,\n+                                 current: *mut T,\n+                                 new: *mut T,\n+                                 success: Ordering,\n+                                 failure: Ordering) -> (*mut T, bool) {\n+        let result = unsafe {\n+            atomic_compare_exchange_weak(self.p.get() as *mut usize, current as usize,\n+                                         new as usize, success, failure)\n+        };\n+        (result.0 as *mut T, result.1)\n+    }\n }\n \n #[inline]\n-unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) {\n+fn strongest_failure_ordering(order: Ordering) -> Ordering {\n+    match order {\n+        Release => Relaxed,\n+        Relaxed => Relaxed,\n+        SeqCst  => SeqCst,\n+        Acquire => Acquire,\n+        AcqRel  => Acquire,\n+    }\n+}\n+\n+#[inline]\n+unsafe fn atomic_store<T>(dst: *mut T, val: T, order: Ordering) {\n     match order {\n         Release => intrinsics::atomic_store_rel(dst, val),\n         Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n@@ -966,7 +1319,7 @@ unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) {\n }\n \n #[inline]\n-unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T {\n+unsafe fn atomic_load<T>(dst: *const T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_load_acq(dst),\n         Relaxed => intrinsics::atomic_load_relaxed(dst),\n@@ -1012,8 +1365,36 @@ unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering) -> T {\n-    match order {\n+#[cfg(not(stage0))]\n+unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n+                                     old: T,\n+                                     new: T,\n+                                     success: Ordering,\n+                                     failure: Ordering) -> T {\n+    match (success, failure) {\n+        (Acquire, Acquire) => intrinsics::atomic_cxchg_acq(dst, old, new),\n+        (Release, Relaxed) => intrinsics::atomic_cxchg_rel(dst, old, new),\n+        (AcqRel, Acquire)  => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n+        (Relaxed, Relaxed) => intrinsics::atomic_cxchg_relaxed(dst, old, new),\n+        (SeqCst, SeqCst)   => intrinsics::atomic_cxchg(dst, old, new),\n+        (Acquire, Relaxed) => intrinsics::atomic_cxchg_acq_failrelaxed(dst, old, new),\n+        (AcqRel, Relaxed)  => intrinsics::atomic_cxchg_acqrel_failrelaxed(dst, old, new),\n+        (SeqCst, Relaxed)  => intrinsics::atomic_cxchg_failrelaxed(dst, old, new),\n+        (SeqCst, Acquire)  => intrinsics::atomic_cxchg_failacq(dst, old, new),\n+        (_, Release) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n+        (_, AcqRel) => panic!(\"there is no such thing as a release failure ordering\"),\n+        _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n+    }\n+}\n+\n+#[inline]\n+#[cfg(stage0)]\n+unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n+                                     old: T,\n+                                     new: T,\n+                                     success: Ordering,\n+                                     _: Ordering) -> T {\n+    match success {\n         Acquire => intrinsics::atomic_cxchg_acq(dst, old, new),\n         Release => intrinsics::atomic_cxchg_rel(dst, old, new),\n         AcqRel  => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n@@ -1022,6 +1403,42 @@ unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering)\n     }\n }\n \n+#[inline]\n+#[cfg(not(stage0))]\n+unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n+                                          old: T,\n+                                          new: T,\n+                                          success: Ordering,\n+                                          failure: Ordering) -> (T, bool) {\n+    match (success, failure) {\n+        (Acquire, Acquire) => intrinsics::atomic_cxchgweak_acq(dst, old, new),\n+        (Release, Relaxed) => intrinsics::atomic_cxchgweak_rel(dst, old, new),\n+        (AcqRel, Acquire)  => intrinsics::atomic_cxchgweak_acqrel(dst, old, new),\n+        (Relaxed, Relaxed) => intrinsics::atomic_cxchgweak_relaxed(dst, old, new),\n+        (SeqCst, SeqCst)   => intrinsics::atomic_cxchgweak(dst, old, new),\n+        (Acquire, Relaxed) => intrinsics::atomic_cxchgweak_acq_failrelaxed(dst, old, new),\n+        (AcqRel, Relaxed)  => intrinsics::atomic_cxchgweak_acqrel_failrelaxed(dst, old, new),\n+        (SeqCst, Relaxed)  => intrinsics::atomic_cxchgweak_failrelaxed(dst, old, new),\n+        (SeqCst, Acquire)  => intrinsics::atomic_cxchgweak_failacq(dst, old, new),\n+        (_, Release) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n+        (_, AcqRel) => panic!(\"there is no such thing as a release failure ordering\"),\n+        _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n+    }\n+}\n+\n+#[inline]\n+#[cfg(stage0)]\n+unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n+                                          old: T,\n+                                          new: T,\n+                                          success: Ordering,\n+                                          failure: Ordering) -> (T, bool)\n+    where T: ::cmp::Eq + ::marker::Copy\n+{\n+    let result = atomic_compare_exchange(dst, old, new, success, failure);\n+    (result, result == old)\n+}\n+\n #[inline]\n unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {"}, {"sha": "13acf79a0f1d05cd81b058f33855e3f7c6918e12", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3929b2c8a472244d448feb24f52bf91246d3e82/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3929b2c8a472244d448feb24f52bf91246d3e82/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=d3929b2c8a472244d448feb24f52bf91246d3e82", "patch": "@@ -1584,7 +1584,8 @@ extern {\n                                   CMP: ValueRef,\n                                   RHS: ValueRef,\n                                   Order: AtomicOrdering,\n-                                  FailureOrder: AtomicOrdering)\n+                                  FailureOrder: AtomicOrdering,\n+                                  Weak: Bool)\n                                   -> ValueRef;\n     pub fn LLVMBuildAtomicRMW(B: BuilderRef,\n                               Op: AtomicBinOp,"}, {"sha": "2b4fcf436cbc090bca122bf06d3a2139cbb18155", "filename": "src/librustc_trans/trans/build.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d3929b2c8a472244d448feb24f52bf91246d3e82/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3929b2c8a472244d448feb24f52bf91246d3e82/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs?ref=d3929b2c8a472244d448feb24f52bf91246d3e82", "patch": "@@ -1067,8 +1067,9 @@ pub fn Resume(cx: Block, exn: ValueRef) -> ValueRef {\n pub fn AtomicCmpXchg(cx: Block, dst: ValueRef,\n                      cmp: ValueRef, src: ValueRef,\n                      order: AtomicOrdering,\n-                     failure_order: AtomicOrdering) -> ValueRef {\n-    B(cx).atomic_cmpxchg(dst, cmp, src, order, failure_order)\n+                     failure_order: AtomicOrdering,\n+                     weak: llvm::Bool) -> ValueRef {\n+    B(cx).atomic_cmpxchg(dst, cmp, src, order, failure_order, weak)\n }\n pub fn AtomicRMW(cx: Block, op: AtomicBinOp,\n                  dst: ValueRef, src: ValueRef,"}, {"sha": "434fca4168858421bb2b5e220e6a303294886614", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d3929b2c8a472244d448feb24f52bf91246d3e82/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3929b2c8a472244d448feb24f52bf91246d3e82/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=d3929b2c8a472244d448feb24f52bf91246d3e82", "patch": "@@ -1077,10 +1077,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub fn atomic_cmpxchg(&self, dst: ValueRef,\n                          cmp: ValueRef, src: ValueRef,\n                          order: AtomicOrdering,\n-                         failure_order: AtomicOrdering) -> ValueRef {\n+                         failure_order: AtomicOrdering,\n+                         weak: llvm::Bool) -> ValueRef {\n         unsafe {\n             llvm::LLVMBuildAtomicCmpXchg(self.llbuilder, dst, cmp, src,\n-                                         order, failure_order)\n+                                         order, failure_order, weak)\n         }\n     }\n     pub fn atomic_rmw(&self, op: AtomicBinOp,"}, {"sha": "b7b520f6c825913094cee701474669e518d45e76", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 35, "deletions": 30, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d3929b2c8a472244d448feb24f52bf91246d3e82/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3929b2c8a472244d448feb24f52bf91246d3e82/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=d3929b2c8a472244d448feb24f52bf91246d3e82", "patch": "@@ -678,49 +678,54 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         // \"atomic_<operation>[_<ordering>]\", and no ordering means SeqCst\n         (_, name) if name.starts_with(\"atomic_\") => {\n             let split: Vec<&str> = name.split('_').collect();\n-            assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n \n-            let order = if split.len() == 2 {\n-                llvm::SequentiallyConsistent\n-            } else {\n-                match split[2] {\n-                    \"unordered\" => llvm::Unordered,\n-                    \"relaxed\" => llvm::Monotonic,\n-                    \"acq\"     => llvm::Acquire,\n-                    \"rel\"     => llvm::Release,\n-                    \"acqrel\"  => llvm::AcquireRelease,\n+            let (order, failorder) = match split.len() {\n+                2 => (llvm::SequentiallyConsistent, llvm::SequentiallyConsistent),\n+                3 => match split[2] {\n+                    \"unordered\" => (llvm::Unordered, llvm::Unordered),\n+                    \"relaxed\" => (llvm::Monotonic, llvm::Monotonic),\n+                    \"acq\"     => (llvm::Acquire, llvm::Acquire),\n+                    \"rel\"     => (llvm::Release, llvm::Monotonic),\n+                    \"acqrel\"  => (llvm::AcquireRelease, llvm::Acquire),\n+                    \"failrelaxed\" if split[1] == \"cxchg\" || split[1] == \"cxchgweak\" =>\n+                        (llvm::SequentiallyConsistent, llvm::Monotonic),\n+                    \"failacq\" if split[1] == \"cxchg\" || split[1] == \"cxchgweak\" =>\n+                        (llvm::SequentiallyConsistent, llvm::Acquire),\n                     _ => ccx.sess().fatal(\"unknown ordering in atomic intrinsic\")\n-                }\n+                },\n+                4 => match (split[2], split[3]) {\n+                    (\"acq\", \"failrelaxed\") if split[1] == \"cxchg\" || split[1] == \"cxchgweak\" =>\n+                        (llvm::Acquire, llvm::Monotonic),\n+                    (\"acqrel\", \"failrelaxed\") if split[1] == \"cxchg\" || split[1] == \"cxchgweak\" =>\n+                        (llvm::AcquireRelease, llvm::Monotonic),\n+                    _ => ccx.sess().fatal(\"unknown ordering in atomic intrinsic\")\n+                },\n+                _ => ccx.sess().fatal(\"Atomic intrinsic not in correct format\"),\n             };\n \n             match split[1] {\n                 \"cxchg\" => {\n-                    // See include/llvm/IR/Instructions.h for their implementation\n-                    // of this, I assume that it's good enough for us to use for\n-                    // now.\n-                    let strongest_failure_ordering = match order {\n-                        llvm::NotAtomic | llvm::Unordered =>\n-                            ccx.sess().fatal(\"cmpxchg must be atomic\"),\n-\n-                        llvm::Monotonic | llvm::Release =>\n-                            llvm::Monotonic,\n-\n-                        llvm::Acquire | llvm::AcquireRelease =>\n-                            llvm::Acquire,\n-\n-                        llvm::SequentiallyConsistent =>\n-                            llvm::SequentiallyConsistent\n-                    };\n-\n                     let tp_ty = *substs.types.get(FnSpace, 0);\n                     let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n                     let cmp = from_arg_ty(bcx, llargs[1], tp_ty);\n                     let src = from_arg_ty(bcx, llargs[2], tp_ty);\n-                    let res = AtomicCmpXchg(bcx, ptr, cmp, src, order,\n-                                            strongest_failure_ordering);\n+                    let res = AtomicCmpXchg(bcx, ptr, cmp, src, order, failorder, llvm::False);\n                     ExtractValue(bcx, res, 0)\n                 }\n \n+                \"cxchgweak\" => {\n+                    let tp_ty = *substs.types.get(FnSpace, 0);\n+                    let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n+                    let cmp = from_arg_ty(bcx, llargs[1], tp_ty);\n+                    let src = from_arg_ty(bcx, llargs[2], tp_ty);\n+                    let val = AtomicCmpXchg(bcx, ptr, cmp, src, order, failorder, llvm::True);\n+                    let result = ExtractValue(bcx, val, 0);\n+                    let success = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool(bcx.ccx()));\n+                    Store(bcx, result, StructGEP(bcx, llresult, 0));\n+                    Store(bcx, success, StructGEP(bcx, llresult, 1));\n+                    C_nil(ccx)\n+                }\n+\n                 \"load\" => {\n                     let tp_ty = *substs.types.get(FnSpace, 0);\n                     let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);"}, {"sha": "5e1dc35870bb2798dbd73afe5899943e06f26dda", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3929b2c8a472244d448feb24f52bf91246d3e82/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3929b2c8a472244d448feb24f52bf91246d3e82/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=d3929b2c8a472244d448feb24f52bf91246d3e82", "patch": "@@ -83,6 +83,10 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n                                 param(ccx, 0),\n                                 param(ccx, 0)),\n                         param(ccx, 0)),\n+            \"cxchgweak\" => (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)),\n+                                param(ccx, 0),\n+                                param(ccx, 0)),\n+                            tcx.mk_tup(vec!(param(ccx, 0), tcx.types.bool))),\n             \"load\" => (1, vec!(tcx.mk_imm_ptr(param(ccx, 0))),\n                        param(ccx, 0)),\n             \"store\" => (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)),"}, {"sha": "4ebe49512d74b007f8c06fb7dd16672fe3f09a56", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d3929b2c8a472244d448feb24f52bf91246d3e82/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d3929b2c8a472244d448feb24f52bf91246d3e82/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=d3929b2c8a472244d448feb24f52bf91246d3e82", "patch": "@@ -191,11 +191,15 @@ extern \"C\" LLVMValueRef LLVMBuildAtomicCmpXchg(LLVMBuilderRef B,\n                                                LLVMValueRef old,\n                                                LLVMValueRef source,\n                                                AtomicOrdering order,\n-                                               AtomicOrdering failure_order) {\n-    return wrap(unwrap(B)->CreateAtomicCmpXchg(unwrap(target), unwrap(old),\n-                                               unwrap(source), order,\n-                                               failure_order\n-                                               ));\n+                                               AtomicOrdering failure_order,\n+                                               LLVMBool weak) {\n+    AtomicCmpXchgInst* acxi = unwrap(B)->CreateAtomicCmpXchg(unwrap(target),\n+                                                             unwrap(old),\n+                                                             unwrap(source),\n+                                                             order,\n+                                                             failure_order);\n+    acxi->setWeak(weak);\n+    return wrap(acxi);\n }\n extern \"C\" LLVMValueRef LLVMBuildAtomicFence(LLVMBuilderRef B,\n                                              AtomicOrdering order,"}, {"sha": "7946704709ce4124704c51a300299d0ad8e23de6", "filename": "src/test/run-pass/atomic-compare_exchange.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d3929b2c8a472244d448feb24f52bf91246d3e82/src%2Ftest%2Frun-pass%2Fatomic-compare_exchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3929b2c8a472244d448feb24f52bf91246d3e82/src%2Ftest%2Frun-pass%2Fatomic-compare_exchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fatomic-compare_exchange.rs?ref=d3929b2c8a472244d448feb24f52bf91246d3e82", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(extended_compare_and_swap)]\n+use std::sync::atomic::{AtomicIsize, ATOMIC_ISIZE_INIT};\n+use std::sync::atomic::Ordering::*;\n+\n+static ATOMIC: AtomicIsize = ATOMIC_ISIZE_INIT;\n+\n+fn main() {\n+    // Make sure trans can emit all the intrinsics correctly\n+    ATOMIC.compare_exchange(0, 1, Relaxed, Relaxed);\n+    ATOMIC.compare_exchange(0, 1, Acquire, Relaxed);\n+    ATOMIC.compare_exchange(0, 1, Release, Relaxed);\n+    ATOMIC.compare_exchange(0, 1, AcqRel, Relaxed);\n+    ATOMIC.compare_exchange(0, 1, SeqCst, Relaxed);\n+    ATOMIC.compare_exchange(0, 1, Acquire, Acquire);\n+    ATOMIC.compare_exchange(0, 1, AcqRel, Acquire);\n+    ATOMIC.compare_exchange(0, 1, SeqCst, Acquire);\n+    ATOMIC.compare_exchange(0, 1, SeqCst, SeqCst);\n+    ATOMIC.compare_exchange_weak(0, 1, Relaxed, Relaxed);\n+    ATOMIC.compare_exchange_weak(0, 1, Acquire, Relaxed);\n+    ATOMIC.compare_exchange_weak(0, 1, Release, Relaxed);\n+    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Relaxed);\n+    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Relaxed);\n+    ATOMIC.compare_exchange_weak(0, 1, Acquire, Acquire);\n+    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Acquire);\n+    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Acquire);\n+    ATOMIC.compare_exchange_weak(0, 1, SeqCst, SeqCst);\n+}"}, {"sha": "3cc125e95133470e4049e98dd31a0dbd2e14e5da", "filename": "src/test/run-pass/intrinsic-atomics.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d3929b2c8a472244d448feb24f52bf91246d3e82/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3929b2c8a472244d448feb24f52bf91246d3e82/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs?ref=d3929b2c8a472244d448feb24f52bf91246d3e82", "patch": "@@ -19,6 +19,10 @@ mod rusti {\n         pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> T;\n         pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> T;\n \n+        pub fn atomic_cxchgweak<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+        pub fn atomic_cxchgweak_acq<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+        pub fn atomic_cxchgweak_rel<T>(dst: *mut T, old: T, src: T) -> (T, bool);\n+\n         pub fn atomic_load<T>(src: *const T) -> T;\n         pub fn atomic_load_acq<T>(src: *const T) -> T;\n \n@@ -79,5 +83,32 @@ pub fn main() {\n         assert_eq!(rusti::atomic_xsub_acq(&mut *x, 1), 2);\n         assert_eq!(rusti::atomic_xsub_rel(&mut *x, 1), 1);\n         assert_eq!(*x, 0);\n+\n+        loop {\n+            let res = rusti::atomic_cxchgweak(&mut *x, 0, 1);\n+            assert_eq!(res.0, 0);\n+            if res.1 {\n+                break;\n+            }\n+        }\n+        assert_eq!(*x, 1);\n+\n+        loop {\n+            let res = rusti::atomic_cxchgweak_acq(&mut *x, 1, 2);\n+            assert_eq!(res.0, 1);\n+            if res.1 {\n+                break;\n+            }\n+        }\n+        assert_eq!(*x, 2);\n+\n+        loop {\n+            let res = rusti::atomic_cxchgweak_rel(&mut *x, 2, 3);\n+            assert_eq!(res.0, 2);\n+            if res.1 {\n+                break;\n+            }\n+        }\n+        assert_eq!(*x, 3);\n     }\n }"}]}