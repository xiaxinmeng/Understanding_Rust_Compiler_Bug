{"sha": "f6ad065fc8aa80f335eaad4c2f30951716bbb077", "node_id": "C_kwDOAAsO6NoAKGY2YWQwNjVmYzhhYTgwZjMzNWVhYWQ0YzJmMzA5NTE3MTZiYmIwNzc", "commit": {"author": {"name": "antoyo", "email": "antoyo@users.noreply.github.com", "date": "2023-01-14T02:36:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-14T02:36:51Z"}, "message": "Merge pull request #243 from bjorn3/no_codegen_hir\n\nAvoid a hir access inside get_static", "tree": {"sha": "e16e9457dd5477ab5408c7b5f7e45803058a1064", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e16e9457dd5477ab5408c7b5f7e45803058a1064"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6ad065fc8aa80f335eaad4c2f30951716bbb077", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjwhVDCRBK7hj4Ov3rIwAAzocIAAfNn3rIljU8vfshSmowHqsY\no621WudKSgCpoDvJxwvoyN+FH2XREXCHSdXuF6PLQCNPQH7A4ed+KNmREbDKVqFM\nqPEZ7cO+xHgiO9GqCoP/ClsGUVldYQnEhejI3I4mASpLPDtakX+2C9DcAAvNXHr+\n3Szc1LN4N74xRqcO87P1Ju7SHqxVs2MsKZbF80nJWkx3Ty8+pZDfuoKXUO9iyAEj\n+a+735KwWhO8RClKRCHB6ZyXPk695MLAtLTuuA+5Yxd4usBcoLCOti5Q+J3cdQ7z\ngMODttUlmNL0Yj9gYsYeqxexulXNbJbElEPBsbRL9jYVYjy0XFbatVF77fKqpsc=\n=Lu52\n-----END PGP SIGNATURE-----\n", "payload": "tree e16e9457dd5477ab5408c7b5f7e45803058a1064\nparent 6c5a70de207adc466ab0ffd5151fc1c9161c83e7\nparent 7fa06f6b882bd0ee9366f31ccf4ae948a16494f9\nauthor antoyo <antoyo@users.noreply.github.com> 1673663811 -0500\ncommitter GitHub <noreply@github.com> 1673663811 -0500\n\nMerge pull request #243 from bjorn3/no_codegen_hir\n\nAvoid a hir access inside get_static"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6ad065fc8aa80f335eaad4c2f30951716bbb077", "html_url": "https://github.com/rust-lang/rust/commit/f6ad065fc8aa80f335eaad4c2f30951716bbb077", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6ad065fc8aa80f335eaad4c2f30951716bbb077/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "html_url": "https://github.com/rust-lang/rust/commit/6c5a70de207adc466ab0ffd5151fc1c9161c83e7"}, {"sha": "7fa06f6b882bd0ee9366f31ccf4ae948a16494f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fa06f6b882bd0ee9366f31ccf4ae948a16494f9", "html_url": "https://github.com/rust-lang/rust/commit/7fa06f6b882bd0ee9366f31ccf4ae948a16494f9"}], "stats": {"total": 129, "additions": 51, "deletions": 78}, "files": [{"sha": "d70c9076897b849e31708b03d1c6ad6227d291fa", "filename": "src/consts.rs", "status": "modified", "additions": 51, "deletions": 78, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/f6ad065fc8aa80f335eaad4c2f30951716bbb077/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6ad065fc8aa80f335eaad4c2f30951716bbb077/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=f6ad065fc8aa80f335eaad4c2f30951716bbb077", "patch": "@@ -2,9 +2,7 @@\n use gccjit::FnAttribute;\n use gccjit::{Function, GlobalKind, LValue, RValue, ToRValue, Type};\n use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods, DerivedTypeMethods, StaticMethods};\n-use rustc_hir as hir;\n-use rustc_hir::Node;\n-use rustc_middle::{bug, span_bug};\n+use rustc_middle::span_bug;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n@@ -217,84 +215,59 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n         let sym = self.tcx.symbol_name(instance).name;\n \n-        let global =\n-            if let Some(def_id) = def_id.as_local() {\n-                let id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-                let llty = self.layout_of(ty).gcc_type(self);\n-                // FIXME: refactor this to work without accessing the HIR\n-                let global = match self.tcx.hir().get(id) {\n-                    Node::Item(&hir::Item { span, kind: hir::ItemKind::Static(..), .. }) => {\n-                        if let Some(global) = self.get_declared_value(&sym) {\n-                            if self.val_ty(global) != self.type_ptr_to(llty) {\n-                                span_bug!(span, \"Conflicting types for static\");\n-                            }\n-                        }\n-\n-                        let is_tls = fn_attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n-                        let global = self.declare_global(\n-                            &sym,\n-                            llty,\n-                            GlobalKind::Exported,\n-                            is_tls,\n-                            fn_attrs.link_section,\n-                        );\n-\n-                        if !self.tcx.is_reachable_non_generic(def_id) {\n-                            // TODO(antoyo): set visibility.\n-                        }\n-\n-                        global\n-                    }\n-\n-                    Node::ForeignItem(&hir::ForeignItem {\n-                        span,\n-                        kind: hir::ForeignItemKind::Static(..),\n-                        ..\n-                    }) => {\n-                        let fn_attrs = self.tcx.codegen_fn_attrs(def_id);\n-                        check_and_apply_linkage(&self, &fn_attrs, ty, sym, span)\n-                    }\n-\n-                    item => bug!(\"get_static: expected static, found {:?}\", item),\n-                };\n+        let global = if def_id.is_local() && !self.tcx.is_foreign_item(def_id) {\n+            let llty = self.layout_of(ty).gcc_type(self);\n+            if let Some(global) = self.get_declared_value(sym) {\n+                if self.val_ty(global) != self.type_ptr_to(llty) {\n+                    span_bug!(self.tcx.def_span(def_id), \"Conflicting types for static\");\n+                }\n+            }\n \n-                global\n+            let is_tls = fn_attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n+            let global = self.declare_global(\n+                &sym,\n+                llty,\n+                GlobalKind::Exported,\n+                is_tls,\n+                fn_attrs.link_section,\n+            );\n+\n+            if !self.tcx.is_reachable_non_generic(def_id) {\n+                // TODO(antoyo): set visibility.\n             }\n-            else {\n-                // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n-                //debug!(\"get_static: sym={} item_attr={:?}\", sym, self.tcx.item_attrs(def_id));\n-\n-                let attrs = self.tcx.codegen_fn_attrs(def_id);\n-                let span = self.tcx.def_span(def_id);\n-                let global = check_and_apply_linkage(&self, &attrs, ty, sym, span);\n-\n-                let needs_dll_storage_attr = false; // TODO(antoyo)\n-\n-                // If this assertion triggers, there's something wrong with commandline\n-                // argument validation.\n-                debug_assert!(\n-                    !(self.tcx.sess.opts.cg.linker_plugin_lto.enabled()\n-                        && self.tcx.sess.target.options.is_like_msvc\n-                        && self.tcx.sess.opts.cg.prefer_dynamic)\n-                );\n-\n-                if needs_dll_storage_attr {\n-                    // This item is external but not foreign, i.e., it originates from an external Rust\n-                    // crate. Since we don't know whether this crate will be linked dynamically or\n-                    // statically in the final application, we always mark such symbols as 'dllimport'.\n-                    // If final linkage happens to be static, we rely on compiler-emitted __imp_ stubs\n-                    // to make things work.\n-                    //\n-                    // However, in some scenarios we defer emission of statics to downstream\n-                    // crates, so there are cases where a static with an upstream DefId\n-                    // is actually present in the current crate. We can find out via the\n-                    // is_codegened_item query.\n-                    if !self.tcx.is_codegened_item(def_id) {\n-                        unimplemented!();\n-                    }\n+\n+            global\n+        } else {\n+            check_and_apply_linkage(&self, &fn_attrs, ty, sym, self.tcx.def_span(def_id))\n+        };\n+\n+        if !def_id.is_local() {\n+            let needs_dll_storage_attr = false; // TODO(antoyo)\n+\n+            // If this assertion triggers, there's something wrong with commandline\n+            // argument validation.\n+            debug_assert!(\n+                !(self.tcx.sess.opts.cg.linker_plugin_lto.enabled()\n+                    && self.tcx.sess.target.options.is_like_msvc\n+                    && self.tcx.sess.opts.cg.prefer_dynamic)\n+            );\n+\n+            if needs_dll_storage_attr {\n+                // This item is external but not foreign, i.e., it originates from an external Rust\n+                // crate. Since we don't know whether this crate will be linked dynamically or\n+                // statically in the final application, we always mark such symbols as 'dllimport'.\n+                // If final linkage happens to be static, we rely on compiler-emitted __imp_ stubs\n+                // to make things work.\n+                //\n+                // However, in some scenarios we defer emission of statics to downstream\n+                // crates, so there are cases where a static with an upstream DefId\n+                // is actually present in the current crate. We can find out via the\n+                // is_codegened_item query.\n+                if !self.tcx.is_codegened_item(def_id) {\n+                    unimplemented!();\n                 }\n-                global\n-            };\n+            }\n+        }\n \n         // TODO(antoyo): set dll storage class.\n "}]}