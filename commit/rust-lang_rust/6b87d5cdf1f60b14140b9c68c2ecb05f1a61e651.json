{"sha": "6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiODdkNWNkZjFmNjBiMTQxNDBiOWM2OGMyZWNiMDVmMWE2MWU2NTE=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-30T16:46:46Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-12-27T18:20:28Z"}, "message": "Syntax for hir::Ty.", "tree": {"sha": "14f72ed128f3c67d66935e078cd0a1497463cfe7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14f72ed128f3c67d66935e078cd0a1497463cfe7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "html_url": "https://github.com/rust-lang/rust/commit/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66f91980473db385d3560cfa4a1e9f889fb6f906", "url": "https://api.github.com/repos/rust-lang/rust/commits/66f91980473db385d3560cfa4a1e9f889fb6f906", "html_url": "https://github.com/rust-lang/rust/commit/66f91980473db385d3560cfa4a1e9f889fb6f906"}], "stats": {"total": 815, "additions": 429, "deletions": 386}, "files": [{"sha": "1381772d5e86f3d19be3c89e2417de8c1dffebc1", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -132,21 +132,21 @@ macro_rules! arena_types {\n             [] expr: rustc::hir::Expr<$tcx>,\n             [] field: rustc::hir::Field<$tcx>,\n             [] field_pat: rustc::hir::FieldPat<$tcx>,\n-            [] fn_decl: rustc::hir::FnDecl,\n+            [] fn_decl: rustc::hir::FnDecl<$tcx>,\n             [] foreign_item: rustc::hir::ForeignItem<$tcx>,\n-            [] impl_item_ref: rustc::hir::ImplItemRef,\n+            [] impl_item_ref: rustc::hir::ImplItemRef<$tcx>,\n             [] inline_asm: rustc::hir::InlineAsm<$tcx>,\n             [] local: rustc::hir::Local<$tcx>,\n             [few] macro_def: rustc::hir::MacroDef<$tcx>,\n             [] param: rustc::hir::Param<$tcx>,\n             [] pat: rustc::hir::Pat<$tcx>,\n-            [] path: rustc::hir::Path,\n-            [] path_segment: rustc::hir::PathSegment,\n-            [] qpath: rustc::hir::QPath,\n+            [] path: rustc::hir::Path<$tcx>,\n+            [] path_segment: rustc::hir::PathSegment<$tcx>,\n+            [] qpath: rustc::hir::QPath<$tcx>,\n             [] stmt: rustc::hir::Stmt<$tcx>,\n             [] struct_field: rustc::hir::StructField<$tcx>,\n             [] trait_item_ref: rustc::hir::TraitItemRef,\n-            [] ty: rustc::hir::Ty,\n+            [] ty: rustc::hir::Ty<$tcx>,\n             [] variant: rustc::hir::Variant<$tcx>,\n         ], $tcx);\n     )"}, {"sha": "33e636a03bdaef65b49d5cd3c029800b54076092", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 54, "deletions": 43, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -42,10 +42,10 @@ use syntax_pos::Span;\n #[derive(Copy, Clone)]\n pub enum FnKind<'a> {\n     /// `#[xxx] pub async/const/extern \"Abi\" fn foo()`\n-    ItemFn(Ident, &'a Generics, FnHeader, &'a Visibility, &'a [Attribute]),\n+    ItemFn(Ident, &'a Generics<'a>, FnHeader, &'a Visibility<'a>, &'a [Attribute]),\n \n     /// `fn foo(&self)`\n-    Method(Ident, &'a FnSig<'a>, Option<&'a Visibility>, &'a [Attribute]),\n+    Method(Ident, &'a FnSig<'a>, Option<&'a Visibility<'a>>, &'a [Attribute]),\n \n     /// `|x, y| {}`\n     Closure(&'a [Attribute]),\n@@ -274,25 +274,25 @@ pub trait Visitor<'v>: Sized {\n     fn visit_expr(&mut self, ex: &'v Expr<'v>) {\n         walk_expr(self, ex)\n     }\n-    fn visit_ty(&mut self, t: &'v Ty) {\n+    fn visit_ty(&mut self, t: &'v Ty<'v>) {\n         walk_ty(self, t)\n     }\n-    fn visit_generic_param(&mut self, p: &'v GenericParam) {\n+    fn visit_generic_param(&mut self, p: &'v GenericParam<'v>) {\n         walk_generic_param(self, p)\n     }\n-    fn visit_generics(&mut self, g: &'v Generics) {\n+    fn visit_generics(&mut self, g: &'v Generics<'v>) {\n         walk_generics(self, g)\n     }\n-    fn visit_where_predicate(&mut self, predicate: &'v WherePredicate) {\n+    fn visit_where_predicate(&mut self, predicate: &'v WherePredicate<'v>) {\n         walk_where_predicate(self, predicate)\n     }\n-    fn visit_fn_decl(&mut self, fd: &'v FnDecl) {\n+    fn visit_fn_decl(&mut self, fd: &'v FnDecl<'v>) {\n         walk_fn_decl(self, fd)\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: BodyId, s: Span, id: HirId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl<'v>, b: BodyId, s: Span, id: HirId) {\n         walk_fn(self, fk, fd, b, s, id)\n     }\n-    fn visit_use(&mut self, path: &'v Path, hir_id: HirId) {\n+    fn visit_use(&mut self, path: &'v Path<'v>, hir_id: HirId) {\n         walk_use(self, path, hir_id)\n     }\n     fn visit_trait_item(&mut self, ti: &'v TraitItem<'v>) {\n@@ -304,23 +304,23 @@ pub trait Visitor<'v>: Sized {\n     fn visit_impl_item(&mut self, ii: &'v ImplItem<'v>) {\n         walk_impl_item(self, ii)\n     }\n-    fn visit_impl_item_ref(&mut self, ii: &'v ImplItemRef) {\n+    fn visit_impl_item_ref(&mut self, ii: &'v ImplItemRef<'v>) {\n         walk_impl_item_ref(self, ii)\n     }\n-    fn visit_trait_ref(&mut self, t: &'v TraitRef) {\n+    fn visit_trait_ref(&mut self, t: &'v TraitRef<'v>) {\n         walk_trait_ref(self, t)\n     }\n-    fn visit_param_bound(&mut self, bounds: &'v GenericBound) {\n+    fn visit_param_bound(&mut self, bounds: &'v GenericBound<'v>) {\n         walk_param_bound(self, bounds)\n     }\n-    fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef, m: TraitBoundModifier) {\n+    fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef<'v>, m: TraitBoundModifier) {\n         walk_poly_trait_ref(self, t, m)\n     }\n     fn visit_variant_data(\n         &mut self,\n         s: &'v VariantData<'v>,\n         _: Name,\n-        _: &'v Generics,\n+        _: &'v Generics<'v>,\n         _parent_id: HirId,\n         _: Span,\n     ) {\n@@ -332,19 +332,19 @@ pub trait Visitor<'v>: Sized {\n     fn visit_enum_def(\n         &mut self,\n         enum_definition: &'v EnumDef<'v>,\n-        generics: &'v Generics,\n+        generics: &'v Generics<'v>,\n         item_id: HirId,\n         _: Span,\n     ) {\n         walk_enum_def(self, enum_definition, generics, item_id)\n     }\n-    fn visit_variant(&mut self, v: &'v Variant<'v>, g: &'v Generics, item_id: HirId) {\n+    fn visit_variant(&mut self, v: &'v Variant<'v>, g: &'v Generics<'v>, item_id: HirId) {\n         walk_variant(self, v, g, item_id)\n     }\n     fn visit_label(&mut self, label: &'v Label) {\n         walk_label(self, label)\n     }\n-    fn visit_generic_arg(&mut self, generic_arg: &'v GenericArg) {\n+    fn visit_generic_arg(&mut self, generic_arg: &'v GenericArg<'v>) {\n         match generic_arg {\n             GenericArg::Lifetime(lt) => self.visit_lifetime(lt),\n             GenericArg::Type(ty) => self.visit_ty(ty),\n@@ -354,26 +354,26 @@ pub trait Visitor<'v>: Sized {\n     fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n         walk_lifetime(self, lifetime)\n     }\n-    fn visit_qpath(&mut self, qpath: &'v QPath, id: HirId, span: Span) {\n+    fn visit_qpath(&mut self, qpath: &'v QPath<'v>, id: HirId, span: Span) {\n         walk_qpath(self, qpath, id, span)\n     }\n-    fn visit_path(&mut self, path: &'v Path, _id: HirId) {\n+    fn visit_path(&mut self, path: &'v Path<'v>, _id: HirId) {\n         walk_path(self, path)\n     }\n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v PathSegment) {\n+    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v PathSegment<'v>) {\n         walk_path_segment(self, path_span, path_segment)\n     }\n-    fn visit_generic_args(&mut self, path_span: Span, generic_args: &'v GenericArgs) {\n+    fn visit_generic_args(&mut self, path_span: Span, generic_args: &'v GenericArgs<'v>) {\n         walk_generic_args(self, path_span, generic_args)\n     }\n-    fn visit_assoc_type_binding(&mut self, type_binding: &'v TypeBinding) {\n+    fn visit_assoc_type_binding(&mut self, type_binding: &'v TypeBinding<'v>) {\n         walk_assoc_type_binding(self, type_binding)\n     }\n     fn visit_attribute(&mut self, _attr: &'v Attribute) {}\n     fn visit_macro_def(&mut self, macro_def: &'v MacroDef<'v>) {\n         walk_macro_def(self, macro_def)\n     }\n-    fn visit_vis(&mut self, vis: &'v Visibility) {\n+    fn visit_vis(&mut self, vis: &'v Visibility<'v>) {\n         walk_vis(self, vis)\n     }\n     fn visit_associated_item_kind(&mut self, kind: &'v AssocItemKind) {\n@@ -445,7 +445,7 @@ pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime\n \n pub fn walk_poly_trait_ref<'v, V>(\n     visitor: &mut V,\n-    trait_ref: &'v PolyTraitRef,\n+    trait_ref: &'v PolyTraitRef<'v>,\n     _modifier: TraitBoundModifier,\n ) where\n     V: Visitor<'v>,\n@@ -454,7 +454,7 @@ pub fn walk_poly_trait_ref<'v, V>(\n     visitor.visit_trait_ref(&trait_ref.trait_ref);\n }\n \n-pub fn walk_trait_ref<'v, V>(visitor: &mut V, trait_ref: &'v TraitRef)\n+pub fn walk_trait_ref<'v, V>(visitor: &mut V, trait_ref: &'v TraitRef<'v>)\n where\n     V: Visitor<'v>,\n {\n@@ -553,15 +553,15 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n     walk_list!(visitor, visit_attribute, item.attrs);\n }\n \n-pub fn walk_use<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path, hir_id: HirId) {\n+pub fn walk_use<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>, hir_id: HirId) {\n     visitor.visit_id(hir_id);\n     visitor.visit_path(path, hir_id);\n }\n \n pub fn walk_enum_def<'v, V: Visitor<'v>>(\n     visitor: &mut V,\n     enum_definition: &'v EnumDef<'v>,\n-    generics: &'v Generics,\n+    generics: &'v Generics<'v>,\n     item_id: HirId,\n ) {\n     visitor.visit_id(item_id);\n@@ -571,7 +571,7 @@ pub fn walk_enum_def<'v, V: Visitor<'v>>(\n pub fn walk_variant<'v, V: Visitor<'v>>(\n     visitor: &mut V,\n     variant: &'v Variant<'v>,\n-    generics: &'v Generics,\n+    generics: &'v Generics<'v>,\n     parent_item_id: HirId,\n ) {\n     visitor.visit_ident(variant.ident);\n@@ -587,7 +587,7 @@ pub fn walk_variant<'v, V: Visitor<'v>>(\n     walk_list!(visitor, visit_attribute, variant.attrs);\n }\n \n-pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n+pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty<'v>) {\n     visitor.visit_id(typ.hir_id);\n \n     match typ.kind {\n@@ -627,7 +627,12 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     }\n }\n \n-pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath, id: HirId, span: Span) {\n+pub fn walk_qpath<'v, V: Visitor<'v>>(\n+    visitor: &mut V,\n+    qpath: &'v QPath<'v>,\n+    id: HirId,\n+    span: Span,\n+) {\n     match *qpath {\n         QPath::Resolved(ref maybe_qself, ref path) => {\n             if let Some(ref qself) = *maybe_qself {\n@@ -642,7 +647,7 @@ pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath, id: Hir\n     }\n }\n \n-pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n+pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>) {\n     for segment in &path.segments {\n         visitor.visit_path_segment(path.span, segment);\n     }\n@@ -651,7 +656,7 @@ pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n pub fn walk_path_segment<'v, V: Visitor<'v>>(\n     visitor: &mut V,\n     path_span: Span,\n-    segment: &'v PathSegment,\n+    segment: &'v PathSegment<'v>,\n ) {\n     visitor.visit_ident(segment.ident);\n     if let Some(id) = segment.hir_id {\n@@ -665,13 +670,16 @@ pub fn walk_path_segment<'v, V: Visitor<'v>>(\n pub fn walk_generic_args<'v, V: Visitor<'v>>(\n     visitor: &mut V,\n     _path_span: Span,\n-    generic_args: &'v GenericArgs,\n+    generic_args: &'v GenericArgs<'v>,\n ) {\n     walk_list!(visitor, visit_generic_arg, &generic_args.args);\n     walk_list!(visitor, visit_assoc_type_binding, &generic_args.bindings);\n }\n \n-pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V, type_binding: &'v TypeBinding) {\n+pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(\n+    visitor: &mut V,\n+    type_binding: &'v TypeBinding<'v>,\n+) {\n     visitor.visit_id(type_binding.hir_id);\n     visitor.visit_ident(type_binding.ident);\n     match type_binding.kind {\n@@ -747,7 +755,7 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v\n     walk_list!(visitor, visit_attribute, foreign_item.attrs);\n }\n \n-pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericBound) {\n+pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericBound<'v>) {\n     match *bound {\n         GenericBound::Trait(ref typ, modifier) => {\n             visitor.visit_poly_trait_ref(typ, modifier);\n@@ -756,7 +764,7 @@ pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericB\n     }\n }\n \n-pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v GenericParam) {\n+pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v GenericParam<'v>) {\n     visitor.visit_id(param.hir_id);\n     walk_list!(visitor, visit_attribute, &param.attrs);\n     match param.name {\n@@ -771,12 +779,15 @@ pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Generi\n     walk_list!(visitor, visit_param_bound, &param.bounds);\n }\n \n-pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n+pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics<'v>) {\n     walk_list!(visitor, visit_generic_param, &generics.params);\n     walk_list!(visitor, visit_where_predicate, &generics.where_clause.predicates);\n }\n \n-pub fn walk_where_predicate<'v, V: Visitor<'v>>(visitor: &mut V, predicate: &'v WherePredicate) {\n+pub fn walk_where_predicate<'v, V: Visitor<'v>>(\n+    visitor: &mut V,\n+    predicate: &'v WherePredicate<'v>,\n+) {\n     match predicate {\n         &WherePredicate::BoundPredicate(WhereBoundPredicate {\n             ref bounded_ty,\n@@ -804,13 +815,13 @@ pub fn walk_where_predicate<'v, V: Visitor<'v>>(visitor: &mut V, predicate: &'v\n     }\n }\n \n-pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FunctionRetTy) {\n+pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FunctionRetTy<'v>) {\n     if let Return(ref output_ty) = *ret_ty {\n         visitor.visit_ty(output_ty)\n     }\n }\n \n-pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl) {\n+pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl<'v>) {\n     for ty in &function_declaration.inputs {\n         visitor.visit_ty(ty)\n     }\n@@ -829,7 +840,7 @@ pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'\n pub fn walk_fn<'v, V: Visitor<'v>>(\n     visitor: &mut V,\n     function_kind: FnKind<'v>,\n-    function_declaration: &'v FnDecl,\n+    function_declaration: &'v FnDecl<'v>,\n     body_id: BodyId,\n     _span: Span,\n     id: HirId,\n@@ -927,7 +938,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n     }\n }\n \n-pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'v ImplItemRef) {\n+pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'v ImplItemRef<'v>) {\n     // N.B., deliberately force a compilation error if/when new fields are added.\n     let ImplItemRef { id, ident, ref kind, span: _, ref vis, ref defaultness } = *impl_item_ref;\n     visitor.visit_nested_impl_item(id);\n@@ -1099,7 +1110,7 @@ pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm<'v>) {\n     walk_list!(visitor, visit_attribute, arm.attrs);\n }\n \n-pub fn walk_vis<'v, V: Visitor<'v>>(visitor: &mut V, vis: &'v Visibility) {\n+pub fn walk_vis<'v, V: Visitor<'v>>(visitor: &mut V, vis: &'v Visibility<'v>) {\n     if let VisibilityKind::Restricted { ref path, hir_id } = vis.node {\n         visitor.visit_id(hir_id);\n         visitor.visit_path(path, hir_id)"}, {"sha": "e58485fe3187f1798a61a3e8fd123129bde739ac", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 53, "deletions": 44, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -212,7 +212,7 @@ enum ImplTraitContext<'a> {\n     /// equivalent to a fresh universal parameter like `fn foo<T: Debug>(x: T)`.\n     ///\n     /// Newly generated parameters should be inserted into the given `Vec`.\n-    Universal(&'a mut Vec<hir::GenericParam>),\n+    Universal(&'a mut Vec<hir::GenericParam<'a>>),\n \n     /// Treat `impl Trait` as shorthand for a new opaque type.\n     /// Example: `fn foo() -> impl Debug`, where `impl Debug` is conceptually\n@@ -739,9 +739,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         parent_id: DefId,\n         anonymous_lifetime_mode: AnonymousLifetimeMode,\n         f: F,\n-    ) -> (Vec<hir::GenericParam>, T)\n+    ) -> (Vec<hir::GenericParam<'hir>>, T)\n     where\n-        F: FnOnce(&mut LoweringContext<'_, '_>) -> (Vec<hir::GenericParam>, T),\n+        F: FnOnce(&mut LoweringContext<'_, '_>) -> (Vec<hir::GenericParam<'hir>>, T),\n     {\n         assert!(!self.is_collecting_in_band_lifetimes);\n         assert!(self.lifetimes_to_define.is_empty());\n@@ -772,7 +772,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         span: Span,\n         hir_name: ParamName,\n         parent_index: DefIndex,\n-    ) -> hir::GenericParam {\n+    ) -> hir::GenericParam<'hir> {\n         let node_id = self.resolver.next_node_id();\n \n         // Get the name we'll use to make the def-path. Note\n@@ -874,9 +874,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         parent_id: DefId,\n         anonymous_lifetime_mode: AnonymousLifetimeMode,\n         f: F,\n-    ) -> (hir::Generics, T)\n+    ) -> (hir::Generics<'hir>, T)\n     where\n-        F: FnOnce(&mut LoweringContext<'_, '_>, &mut Vec<hir::GenericParam>) -> T,\n+        F: FnOnce(&mut LoweringContext<'_, '_>, &mut Vec<hir::GenericParam<'hir>>) -> T,\n     {\n         let (in_band_defs, (mut lowered_generics, res)) =\n             self.with_in_scope_lifetime_defs(&generics.params, |this| {\n@@ -1026,7 +1026,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         constraint: &AssocTyConstraint,\n         itctx: ImplTraitContext<'_>,\n-    ) -> hir::TypeBinding {\n+    ) -> hir::TypeBinding<'hir> {\n         debug!(\"lower_assoc_ty_constraint(constraint={:?}, itctx={:?})\", constraint, itctx);\n \n         let kind = match constraint.kind {\n@@ -1123,7 +1123,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         arg: &ast::GenericArg,\n         itctx: ImplTraitContext<'_>,\n-    ) -> hir::GenericArg {\n+    ) -> hir::GenericArg<'hir> {\n         match arg {\n             ast::GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.lower_lifetime(&lt)),\n             ast::GenericArg::Type(ty) => {\n@@ -1178,7 +1178,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn lower_ty(&mut self, t: &Ty, itctx: ImplTraitContext<'_>) -> P<hir::Ty> {\n+    fn lower_ty(&mut self, t: &Ty, itctx: ImplTraitContext<'_>) -> P<hir::Ty<'hir>> {\n         P(self.lower_ty_direct(t, itctx))\n     }\n \n@@ -1189,7 +1189,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         path: &Path,\n         param_mode: ParamMode,\n         itctx: ImplTraitContext<'_>,\n-    ) -> hir::Ty {\n+    ) -> hir::Ty<'hir> {\n         let id = self.lower_node_id(t.id);\n         let qpath = self.lower_qpath(t.id, qself, path, param_mode, itctx);\n         let ty = self.ty_path(id, t.span, qpath);\n@@ -1199,15 +1199,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         ty\n     }\n \n-    fn ty(&mut self, span: Span, kind: hir::TyKind) -> hir::Ty {\n+    fn ty(&mut self, span: Span, kind: hir::TyKind<'hir>) -> hir::Ty<'hir> {\n         hir::Ty { hir_id: self.next_id(), kind, span }\n     }\n \n-    fn ty_tup(&mut self, span: Span, tys: HirVec<hir::Ty>) -> hir::Ty {\n+    fn ty_tup(&mut self, span: Span, tys: HirVec<hir::Ty<'hir>>) -> hir::Ty<'hir> {\n         self.ty(span, hir::TyKind::Tup(tys))\n     }\n \n-    fn lower_ty_direct(&mut self, t: &Ty, mut itctx: ImplTraitContext<'_>) -> hir::Ty {\n+    fn lower_ty_direct(&mut self, t: &Ty, mut itctx: ImplTraitContext<'_>) -> hir::Ty<'hir> {\n         let kind = match t.kind {\n             TyKind::Infer => hir::TyKind::Infer,\n             TyKind::Err => hir::TyKind::Err,\n@@ -1376,8 +1376,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         span: Span,\n         fn_def_id: Option<DefId>,\n         opaque_ty_node_id: NodeId,\n-        lower_bounds: impl FnOnce(&mut LoweringContext<'_, '_>) -> hir::GenericBounds,\n-    ) -> hir::TyKind {\n+        lower_bounds: impl FnOnce(&mut LoweringContext<'_, '_>) -> hir::GenericBounds<'hir>,\n+    ) -> hir::TyKind<'hir> {\n         debug!(\n             \"lower_opaque_impl_trait(fn_def_id={:?}, opaque_ty_node_id={:?}, span={:?})\",\n             fn_def_id, opaque_ty_node_id, span,\n@@ -1433,7 +1433,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn generate_opaque_type(\n         &mut self,\n         opaque_ty_node_id: NodeId,\n-        opaque_ty_item: hir::OpaqueTy,\n+        opaque_ty_item: hir::OpaqueTy<'hir>,\n         span: Span,\n         opaque_ty_span: Span,\n     ) -> hir::HirId {\n@@ -1461,8 +1461,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         opaque_ty_id: NodeId,\n         parent_index: DefIndex,\n-        bounds: &hir::GenericBounds,\n-    ) -> (HirVec<hir::GenericArg>, HirVec<hir::GenericParam>) {\n+        bounds: &hir::GenericBounds<'hir>,\n+    ) -> (HirVec<hir::GenericArg<'hir>>, HirVec<hir::GenericParam<'hir>>) {\n         debug!(\n             \"lifetimes_from_impl_trait_bounds(opaque_ty_id={:?}, \\\n              parent_index={:?}, \\\n@@ -1480,8 +1480,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             collect_elided_lifetimes: bool,\n             currently_bound_lifetimes: Vec<hir::LifetimeName>,\n             already_defined_lifetimes: FxHashSet<hir::LifetimeName>,\n-            output_lifetimes: Vec<hir::GenericArg>,\n-            output_lifetime_params: Vec<hir::GenericParam>,\n+            output_lifetimes: Vec<hir::GenericArg<'hir>>,\n+            output_lifetime_params: Vec<hir::GenericParam<'hir>>,\n         }\n \n         impl<'r, 'a, 'v, 'hir> hir::intravisit::Visitor<'v> for ImplTraitLifetimeCollector<'r, 'a, 'hir> {\n@@ -1491,7 +1491,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 hir::intravisit::NestedVisitorMap::None\n             }\n \n-            fn visit_generic_args(&mut self, span: Span, parameters: &'v hir::GenericArgs) {\n+            fn visit_generic_args(&mut self, span: Span, parameters: &'v hir::GenericArgs<'v>) {\n                 // Don't collect elided lifetimes used inside of `Fn()` syntax.\n                 if parameters.parenthesized {\n                     let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n@@ -1503,7 +1503,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 }\n             }\n \n-            fn visit_ty(&mut self, t: &'v hir::Ty) {\n+            fn visit_ty(&mut self, t: &'v hir::Ty<'v>) {\n                 // Don't collect elided lifetimes used inside of `fn()` syntax.\n                 if let hir::TyKind::BareFn(_) = t.kind {\n                     let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n@@ -1523,7 +1523,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n             fn visit_poly_trait_ref(\n                 &mut self,\n-                trait_ref: &'v hir::PolyTraitRef,\n+                trait_ref: &'v hir::PolyTraitRef<'v>,\n                 modifier: hir::TraitBoundModifier,\n             ) {\n                 // Record the \"stack height\" of `for<'a>` lifetime bindings\n@@ -1533,7 +1533,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 self.currently_bound_lifetimes.truncate(old_len);\n             }\n \n-            fn visit_generic_param(&mut self, param: &'v hir::GenericParam) {\n+            fn visit_generic_param(&mut self, param: &'v hir::GenericParam<'v>) {\n                 // Record the introduction of 'a in `for<'a> ...`.\n                 if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n                     // Introduce lifetimes one at a time so that we can handle\n@@ -1639,7 +1639,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         p: &Path,\n         param_mode: ParamMode,\n         mut itctx: ImplTraitContext<'_>,\n-    ) -> hir::QPath {\n+    ) -> hir::QPath<'hir> {\n         let qself_position = qself.as_ref().map(|q| q.position);\n         let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty, itctx.reborrow()));\n \n@@ -1799,7 +1799,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         p: &Path,\n         param_mode: ParamMode,\n         explicit_owner: Option<NodeId>,\n-    ) -> hir::Path {\n+    ) -> hir::Path<'hir> {\n         hir::Path {\n             res,\n             segments: p\n@@ -1821,7 +1821,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn lower_path(&mut self, id: NodeId, p: &Path, param_mode: ParamMode) -> hir::Path {\n+    fn lower_path(&mut self, id: NodeId, p: &Path, param_mode: ParamMode) -> hir::Path<'hir> {\n         let res = self.expect_full_res(id);\n         let res = self.lower_res(res);\n         self.lower_path_extra(res, p, param_mode, None)\n@@ -1836,7 +1836,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         parenthesized_generic_args: ParenthesizedGenericArgs,\n         itctx: ImplTraitContext<'_>,\n         explicit_owner: Option<NodeId>,\n-    ) -> hir::PathSegment {\n+    ) -> hir::PathSegment<'hir> {\n         let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n             let msg = \"parenthesized type parameters may only be used with a `Fn` trait\";\n             match **generic_args {\n@@ -1981,7 +1981,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         data: &AngleBracketedArgs,\n         param_mode: ParamMode,\n         mut itctx: ImplTraitContext<'_>,\n-    ) -> (hir::GenericArgs, bool) {\n+    ) -> (hir::GenericArgs<'hir>, bool) {\n         let &AngleBracketedArgs { ref args, ref constraints, .. } = data;\n         let has_non_lt_args = args.iter().any(|arg| match arg {\n             ast::GenericArg::Lifetime(_) => false,\n@@ -2004,7 +2004,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_parenthesized_parameter_data(\n         &mut self,\n         data: &ParenthesizedArgs,\n-    ) -> (hir::GenericArgs, bool) {\n+    ) -> (hir::GenericArgs<'hir>, bool) {\n         // Switch to `PassThrough` mode for anonymous lifetimes; this\n         // means that we permit things like `&Ref<T>`, where `Ref` has\n         // a hidden lifetime parameter. This is needed for backwards\n@@ -2098,10 +2098,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_fn_decl(\n         &mut self,\n         decl: &FnDecl,\n-        mut in_band_ty_params: Option<(DefId, &mut Vec<hir::GenericParam>)>,\n+        mut in_band_ty_params: Option<(DefId, &mut Vec<hir::GenericParam<'hir>>)>,\n         impl_trait_return_allow: bool,\n         make_ret_async: Option<NodeId>,\n-    ) -> P<hir::FnDecl> {\n+    ) -> P<hir::FnDecl<'hir>> {\n         debug!(\n             \"lower_fn_decl(\\\n             fn_decl: {:?}, \\\n@@ -2207,7 +2207,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         output: &FunctionRetTy,\n         fn_def_id: DefId,\n         opaque_ty_node_id: NodeId,\n-    ) -> hir::FunctionRetTy {\n+    ) -> hir::FunctionRetTy<'hir> {\n         debug!(\n             \"lower_async_fn_ret_ty(\\\n              output={:?}, \\\n@@ -2384,7 +2384,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         output: &FunctionRetTy,\n         fn_def_id: DefId,\n         span: Span,\n-    ) -> hir::GenericBound {\n+    ) -> hir::GenericBound<'hir> {\n         // Compute the `T` in `Future<Output = T>` from the return type.\n         let output_ty = match output {\n             FunctionRetTy::Ty(ty) => self.lower_ty(ty, ImplTraitContext::OpaqueTy(Some(fn_def_id))),\n@@ -2421,7 +2421,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         tpb: &GenericBound,\n         itctx: ImplTraitContext<'_>,\n-    ) -> hir::GenericBound {\n+    ) -> hir::GenericBound<'hir> {\n         match *tpb {\n             GenericBound::Trait(ref ty, modifier) => hir::GenericBound::Trait(\n                 self.lower_poly_trait_ref(ty, itctx),\n@@ -2473,7 +2473,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         params: &[GenericParam],\n         add_bounds: &NodeMap<Vec<GenericBound>>,\n         mut itctx: ImplTraitContext<'_>,\n-    ) -> hir::HirVec<hir::GenericParam> {\n+    ) -> hir::HirVec<hir::GenericParam<'hir>> {\n         params\n             .iter()\n             .map(|param| self.lower_generic_param(param, add_bounds, itctx.reborrow()))\n@@ -2485,7 +2485,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         param: &GenericParam,\n         add_bounds: &NodeMap<Vec<GenericBound>>,\n         mut itctx: ImplTraitContext<'_>,\n-    ) -> hir::GenericParam {\n+    ) -> hir::GenericParam<'hir> {\n         let mut bounds = self\n             .with_anonymous_lifetime_mode(AnonymousLifetimeMode::ReportError, |this| {\n                 this.lower_param_bounds(&param.bounds, itctx.reborrow())\n@@ -2561,7 +2561,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn lower_trait_ref(&mut self, p: &TraitRef, itctx: ImplTraitContext<'_>) -> hir::TraitRef {\n+    fn lower_trait_ref(\n+        &mut self,\n+        p: &TraitRef,\n+        itctx: ImplTraitContext<'_>,\n+    ) -> hir::TraitRef<'hir> {\n         let path = match self.lower_qpath(p.ref_id, &None, &p.path, ParamMode::Explicit, itctx) {\n             hir::QPath::Resolved(None, path) => path,\n             qpath => bug!(\"lower_trait_ref: unexpected QPath `{:?}`\", qpath),\n@@ -2573,7 +2577,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         p: &PolyTraitRef,\n         mut itctx: ImplTraitContext<'_>,\n-    ) -> hir::PolyTraitRef {\n+    ) -> hir::PolyTraitRef<'hir> {\n         let bound_generic_params = self.lower_generic_params(\n             &p.bound_generic_params,\n             &NodeMap::default(),\n@@ -2586,15 +2590,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::PolyTraitRef { bound_generic_params, trait_ref, span: p.span }\n     }\n \n-    fn lower_mt(&mut self, mt: &MutTy, itctx: ImplTraitContext<'_>) -> hir::MutTy {\n+    fn lower_mt(&mut self, mt: &MutTy, itctx: ImplTraitContext<'_>) -> hir::MutTy<'hir> {\n         hir::MutTy { ty: self.lower_ty(&mt.ty, itctx), mutbl: mt.mutbl }\n     }\n \n     fn lower_param_bounds(\n         &mut self,\n         bounds: &[GenericBound],\n         mut itctx: ImplTraitContext<'_>,\n-    ) -> hir::GenericBounds {\n+    ) -> hir::GenericBounds<'hir> {\n         bounds.iter().map(|bound| self.lower_param_bound(bound, itctx.reborrow())).collect()\n     }\n \n@@ -3077,9 +3081,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         span: Span,\n         components: &[Symbol],\n-        params: Option<P<hir::GenericArgs>>,\n+        params: Option<P<hir::GenericArgs<'hir>>>,\n         is_value: bool,\n-    ) -> hir::Path {\n+    ) -> hir::Path<'hir> {\n         let ns = if is_value { Namespace::ValueNS } else { Namespace::TypeNS };\n         let (path, res) = self.resolver.resolve_str_path(span, self.crate_root, components, ns);\n \n@@ -3106,7 +3110,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn ty_path(&mut self, mut hir_id: hir::HirId, span: Span, qpath: hir::QPath) -> hir::Ty {\n+    fn ty_path(\n+        &mut self,\n+        mut hir_id: hir::HirId,\n+        span: Span,\n+        qpath: hir::QPath<'hir>,\n+    ) -> hir::Ty<'hir> {\n         let kind = match qpath {\n             hir::QPath::Resolved(None, path) => {\n                 // Turn trait object paths into `TyKind::TraitObject` instead."}, {"sha": "a5871e02dd0b9a12c26e36f8545b6a411cc8f621", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -1338,7 +1338,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         span: Span,\n         components: &[Symbol],\n-        params: Option<P<hir::GenericArgs>>,\n+        params: Option<P<hir::GenericArgs<'hir>>>,\n         attrs: AttrVec,\n     ) -> hir::Expr<'hir> {\n         let path = self.std_path(span, components, params, true);"}, {"sha": "d4705e9795c87ed1f309d2367186a095aaac8621", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -258,7 +258,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         id: NodeId,\n         ident: &mut Ident,\n         attrs: &'hir [Attribute],\n-        vis: &mut hir::Visibility,\n+        vis: &mut hir::Visibility<'hir>,\n         i: &ItemKind,\n     ) -> hir::ItemKind<'hir> {\n         match *i {\n@@ -466,7 +466,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         tree: &UseTree,\n         prefix: &Path,\n         id: NodeId,\n-        vis: &mut hir::Visibility,\n+        vis: &mut hir::Visibility<'hir>,\n         ident: &mut Ident,\n         attrs: &'hir [Attribute],\n     ) -> hir::ItemKind<'hir> {\n@@ -635,7 +635,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     /// Paths like the visibility path in `pub(super) use foo::{bar, baz}` are repeated\n     /// many times in the HIR tree; for each occurrence, we need to assign distinct\n     /// `NodeId`s. (See, e.g., #56128.)\n-    fn rebuild_use_path(&mut self, path: &hir::Path) -> hir::Path {\n+    fn rebuild_use_path(&mut self, path: &hir::Path<'hir>) -> hir::Path<'hir> {\n         debug!(\"rebuild_use_path(path = {:?})\", path);\n         let segments = path\n             .segments\n@@ -651,7 +651,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         hir::Path { span: path.span, res: path.res, segments }\n     }\n \n-    fn rebuild_vis(&mut self, vis: &hir::Visibility) -> hir::Visibility {\n+    fn rebuild_vis(&mut self, vis: &hir::Visibility<'hir>) -> hir::Visibility<'hir> {\n         let vis_kind = match vis.node {\n             hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n             hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n@@ -918,7 +918,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // [1] since `default impl` is not yet implemented, this is always true in impls\n     }\n \n-    fn lower_impl_item_ref(&mut self, i: &AssocItem) -> hir::ImplItemRef {\n+    fn lower_impl_item_ref(&mut self, i: &AssocItem) -> hir::ImplItemRef<'hir> {\n         hir::ImplItemRef {\n             id: hir::ImplItemId { hir_id: self.lower_node_id(i.id) },\n             ident: i.ident,\n@@ -952,7 +952,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         v: &Visibility,\n         explicit_owner: Option<NodeId>,\n-    ) -> hir::Visibility {\n+    ) -> hir::Visibility<'hir> {\n         let node = match v.node {\n             VisibilityKind::Public => hir::VisibilityKind::Public,\n             VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n@@ -1255,7 +1255,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         fn_def_id: DefId,\n         impl_trait_return_allow: bool,\n         is_async: Option<NodeId>,\n-    ) -> (hir::Generics, hir::FnSig<'hir>) {\n+    ) -> (hir::Generics<'hir>, hir::FnSig<'hir>) {\n         let header = self.lower_fn_header(sig.header);\n         let (generics, decl) = self.add_in_band_defs(\n             generics,\n@@ -1316,7 +1316,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         generics: &Generics,\n         itctx: ImplTraitContext<'_>,\n-    ) -> hir::Generics {\n+    ) -> hir::Generics<'hir> {\n         // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n         // FIXME: this could probably be done with less rightward drift. It also looks like two\n         // control paths where `report_error` is called are the only paths that advance to after the\n@@ -1379,7 +1379,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    fn lower_where_clause(&mut self, wc: &WhereClause) -> hir::WhereClause {\n+    fn lower_where_clause(&mut self, wc: &WhereClause) -> hir::WhereClause<'hir> {\n         self.with_anonymous_lifetime_mode(AnonymousLifetimeMode::ReportError, |this| {\n             hir::WhereClause {\n                 predicates: wc\n@@ -1392,7 +1392,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         })\n     }\n \n-    fn lower_where_predicate(&mut self, pred: &WherePredicate) -> hir::WherePredicate {\n+    fn lower_where_predicate(&mut self, pred: &WherePredicate) -> hir::WherePredicate<'hir> {\n         match *pred {\n             WherePredicate::BoundPredicate(WhereBoundPredicate {\n                 ref bound_generic_params,"}, {"sha": "1267de4d9786c494c815d42bca7e975977608a8a", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -109,10 +109,10 @@ impl<'a> Code<'a> {\n /// use when implementing FnLikeNode operations.\n struct ItemFnParts<'a> {\n     ident: Ident,\n-    decl: &'a ast::FnDecl,\n+    decl: &'a ast::FnDecl<'a>,\n     header: ast::FnHeader,\n-    vis: &'a ast::Visibility,\n-    generics: &'a ast::Generics,\n+    vis: &'a ast::Visibility<'a>,\n+    generics: &'a ast::Generics<'a>,\n     body: ast::BodyId,\n     id: ast::HirId,\n     span: Span,\n@@ -122,15 +122,21 @@ struct ItemFnParts<'a> {\n /// These are all the components one can extract from a closure expr\n /// for use when implementing FnLikeNode operations.\n struct ClosureParts<'a> {\n-    decl: &'a FnDecl,\n+    decl: &'a FnDecl<'a>,\n     body: ast::BodyId,\n     id: ast::HirId,\n     span: Span,\n     attrs: &'a [Attribute],\n }\n \n impl<'a> ClosureParts<'a> {\n-    fn new(d: &'a FnDecl, b: ast::BodyId, id: ast::HirId, s: Span, attrs: &'a [Attribute]) -> Self {\n+    fn new(\n+        d: &'a FnDecl<'a>,\n+        b: ast::BodyId,\n+        id: ast::HirId,\n+        s: Span,\n+        attrs: &'a [Attribute],\n+    ) -> Self {\n         ClosureParts { decl: d, body: b, id, span: s, attrs }\n     }\n }\n@@ -156,7 +162,7 @@ impl<'a> FnLikeNode<'a> {\n         )\n     }\n \n-    pub fn decl(self) -> &'a FnDecl {\n+    pub fn decl(self) -> &'a FnDecl<'a> {\n         self.handle(\n             |i: ItemFnParts<'a>| &*i.decl,\n             |_, _, sig: &'a ast::FnSig<'a>, _, _, _, _| &sig.decl,\n@@ -210,7 +216,7 @@ impl<'a> FnLikeNode<'a> {\n             ast::HirId,\n             Ident,\n             &'a ast::FnSig<'a>,\n-            Option<&'a ast::Visibility>,\n+            Option<&'a ast::Visibility<'a>>,\n             ast::BodyId,\n             Span,\n             &'a [Attribute],"}, {"sha": "28eff07a494d51a1a28b6e5c7b8969db4e31a5bd", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -401,7 +401,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    fn visit_generic_param(&mut self, param: &'hir GenericParam) {\n+    fn visit_generic_param(&mut self, param: &'hir GenericParam<'hir>) {\n         self.insert(param.span, param.hir_id, Node::GenericParam(param));\n         intravisit::walk_generic_param(self, param);\n     }\n@@ -478,22 +478,22 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'hir PathSegment) {\n+    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'hir PathSegment<'hir>) {\n         if let Some(hir_id) = path_segment.hir_id {\n             self.insert(path_span, hir_id, Node::PathSegment(path_segment));\n         }\n         intravisit::walk_path_segment(self, path_span, path_segment);\n     }\n \n-    fn visit_ty(&mut self, ty: &'hir Ty) {\n+    fn visit_ty(&mut self, ty: &'hir Ty<'hir>) {\n         self.insert(ty.span, ty.hir_id, Node::Ty(ty));\n \n         self.with_parent(ty.hir_id, |this| {\n             intravisit::walk_ty(this, ty);\n         });\n     }\n \n-    fn visit_trait_ref(&mut self, tr: &'hir TraitRef) {\n+    fn visit_trait_ref(&mut self, tr: &'hir TraitRef<'hir>) {\n         self.insert(tr.path.span, tr.hir_ref_id, Node::TraitRef(tr));\n \n         self.with_parent(tr.hir_ref_id, |this| {\n@@ -504,7 +504,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_fn(\n         &mut self,\n         fk: intravisit::FnKind<'hir>,\n-        fd: &'hir FnDecl,\n+        fd: &'hir FnDecl<'hir>,\n         b: BodyId,\n         s: Span,\n         id: HirId,\n@@ -529,7 +529,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         self.insert(lifetime.span, lifetime.hir_id, Node::Lifetime(lifetime));\n     }\n \n-    fn visit_vis(&mut self, visibility: &'hir Visibility) {\n+    fn visit_vis(&mut self, visibility: &'hir Visibility<'hir>) {\n         match visibility.node {\n             VisibilityKind::Public | VisibilityKind::Crate(_) | VisibilityKind::Inherited => {}\n             VisibilityKind::Restricted { hir_id, .. } => {\n@@ -550,7 +550,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n-    fn visit_variant(&mut self, v: &'hir Variant<'hir>, g: &'hir Generics, item_id: HirId) {\n+    fn visit_variant(&mut self, v: &'hir Variant<'hir>, g: &'hir Generics<'hir>, item_id: HirId) {\n         self.insert(v.span, v.id, Node::Variant(v));\n         self.with_parent(v.id, |this| {\n             // Register the constructor of this variant.\n@@ -576,7 +576,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         self.visit_nested_trait_item(id);\n     }\n \n-    fn visit_impl_item_ref(&mut self, ii: &'hir ImplItemRef) {\n+    fn visit_impl_item_ref(&mut self, ii: &'hir ImplItemRef<'hir>) {\n         // Do not visit the duplicate information in ImplItemRef. We want to\n         // map the actual nodes, not the duplicate ones in the *Ref.\n         let ImplItemRef { id, ident: _, kind: _, span: _, vis: _, defaultness: _ } = *ii;"}, {"sha": "a04fc8a562ffa59dd1bd747ebf55044045c310a3", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -161,7 +161,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n         self.hir_ids_seen.insert(hir_id.local_id);\n     }\n \n-    fn visit_impl_item_ref(&mut self, _: &'hir hir::ImplItemRef) {\n+    fn visit_impl_item_ref(&mut self, _: &'hir hir::ImplItemRef<'hir>) {\n         // Explicitly do nothing here. ImplItemRefs contain hir::Visibility\n         // values that actually belong to an ImplItem instead of the ItemKind::Impl\n         // we are currently in. So for those it's correct that they have a"}, {"sha": "7f7af331b3c301866128ba950037911392ce94a4", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -43,7 +43,7 @@ impl<'hir> Entry<'hir> {\n         }\n     }\n \n-    fn fn_decl(&self) -> Option<&'hir FnDecl> {\n+    fn fn_decl(&self) -> Option<&'hir FnDecl<'hir>> {\n         match self.node {\n             Node::Item(ref item) => match item.kind {\n                 ItemKind::Fn(ref sig, _, _) => Some(&sig.decl),\n@@ -429,7 +429,7 @@ impl<'hir> Map<'hir> {\n         self.forest.krate.body(id)\n     }\n \n-    pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<&'hir FnDecl> {\n+    pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<&'hir FnDecl<'hir>> {\n         if let Some(entry) = self.find_entry(hir_id) {\n             entry.fn_decl()\n         } else {\n@@ -584,7 +584,7 @@ impl<'hir> Map<'hir> {\n         self.as_local_hir_id(id).map(|id| self.get(id)) // read recorded by `get`\n     }\n \n-    pub fn get_generics(&self, id: DefId) -> Option<&'hir Generics> {\n+    pub fn get_generics(&self, id: DefId) -> Option<&'hir Generics<'hir>> {\n         self.get_if_local(id).and_then(|node| match node {\n             Node::ImplItem(ref impl_item) => Some(&impl_item.generics),\n             Node::TraitItem(ref trait_item) => Some(&trait_item.generics),"}, {"sha": "3c6513a137f5c4818f23f28a01cfcc2689fe263a", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 153, "deletions": 153, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -303,27 +303,27 @@ impl Lifetime {\n /// `std::cmp::PartialEq`. It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n #[derive(RustcEncodable, RustcDecodable, HashStable)]\n-pub struct Path {\n+pub struct Path<'hir> {\n     pub span: Span,\n     /// The resolution for the path.\n     pub res: Res,\n     /// The segments in the path: the things separated by `::`.\n-    pub segments: HirVec<PathSegment>,\n+    pub segments: &'hir [PathSegment<'hir>],\n }\n \n-impl Path {\n+impl Path<'_> {\n     pub fn is_global(&self) -> bool {\n         !self.segments.is_empty() && self.segments[0].ident.name == kw::PathRoot\n     }\n }\n \n-impl fmt::Debug for Path {\n+impl fmt::Debug for Path<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"path({})\", self)\n     }\n }\n \n-impl fmt::Display for Path {\n+impl fmt::Display for Path<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{}\", print::to_string(print::NO_ANN, |s| s.print_path(self, false)))\n     }\n@@ -332,7 +332,7 @@ impl fmt::Display for Path {\n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct PathSegment {\n+pub struct PathSegment<'hir> {\n     /// The identifier portion of this path segment.\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n@@ -349,7 +349,7 @@ pub struct PathSegment {\n     /// this is more than just simple syntactic sugar; the use of\n     /// parens affects the region binding rules, so we preserve the\n     /// distinction.\n-    pub args: Option<P<GenericArgs>>,\n+    pub args: Option<&'hir GenericArgs<'hir>>,\n \n     /// Whether to infer remaining type parameters, if any.\n     /// This only applies to expression and pattern paths, and\n@@ -358,17 +358,17 @@ pub struct PathSegment {\n     pub infer_args: bool,\n }\n \n-impl PathSegment {\n+impl<'hir> PathSegment<'hir> {\n     /// Converts an identifier to the corresponding segment.\n-    pub fn from_ident(ident: Ident) -> PathSegment {\n+    pub fn from_ident(ident: Ident) -> PathSegment<'hir> {\n         PathSegment { ident, hir_id: None, res: None, infer_args: true, args: None }\n     }\n \n     pub fn new(\n         ident: Ident,\n         hir_id: Option<HirId>,\n         res: Option<Res>,\n-        args: GenericArgs,\n+        args: GenericArgs<'_>,\n         infer_args: bool,\n     ) -> Self {\n         PathSegment {\n@@ -380,11 +380,11 @@ impl PathSegment {\n         }\n     }\n \n-    pub fn generic_args(&self) -> &GenericArgs {\n+    pub fn generic_args(&self) -> &GenericArgs<'hir> {\n         if let Some(ref args) = self.args {\n             args\n         } else {\n-            const DUMMY: &GenericArgs = &GenericArgs::none();\n+            const DUMMY: &GenericArgs<'_> = &GenericArgs::none();\n             DUMMY\n         }\n     }\n@@ -397,13 +397,13 @@ pub struct ConstArg {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum GenericArg {\n+pub enum GenericArg<'hir> {\n     Lifetime(Lifetime),\n-    Type(Ty),\n+    Type(Ty<'hir>),\n     Const(ConstArg),\n }\n \n-impl GenericArg {\n+impl GenericArg<'_> {\n     pub fn span(&self) -> Span {\n         match self {\n             GenericArg::Lifetime(l) => l.span,\n@@ -429,19 +429,19 @@ impl GenericArg {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct GenericArgs {\n+pub struct GenericArgs<'hir> {\n     /// The generic arguments for this path segment.\n-    pub args: HirVec<GenericArg>,\n+    pub args: HirVec<GenericArg<'hir>>,\n     /// Bindings (equality constraints) on associated types, if present.\n     /// E.g., `Foo<A = Bar>`.\n-    pub bindings: HirVec<TypeBinding>,\n+    pub bindings: &'hir [TypeBinding<'hir>],\n     /// Were arguments written in parenthesized form `Fn(T) -> U`?\n     /// This is required mostly for pretty-printing and diagnostics,\n     /// but also for changing lifetime elision rules to be \"function-like\".\n     pub parenthesized: bool,\n }\n \n-impl GenericArgs {\n+impl GenericArgs<'_> {\n     pub const fn none() -> Self {\n         Self { args: HirVec::new(), bindings: HirVec::new(), parenthesized: false }\n     }\n@@ -450,7 +450,7 @@ impl GenericArgs {\n         self.args.is_empty() && self.bindings.is_empty() && !self.parenthesized\n     }\n \n-    pub fn inputs(&self) -> &[Ty] {\n+    pub fn inputs(&self) -> &[Ty<'_>] {\n         if self.parenthesized {\n             for arg in &self.args {\n                 match arg {\n@@ -499,12 +499,12 @@ pub enum TraitBoundModifier {\n /// the \"special\" built-in traits (see `middle::lang_items`) and\n /// detects `Copy`, `Send` and `Sync`.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum GenericBound {\n-    Trait(PolyTraitRef, TraitBoundModifier),\n+pub enum GenericBound<'hir> {\n+    Trait(PolyTraitRef<'hir>, TraitBoundModifier),\n     Outlives(Lifetime),\n }\n \n-impl GenericBound {\n+impl GenericBound<'_> {\n     pub fn span(&self) -> Span {\n         match self {\n             &GenericBound::Trait(ref t, ..) => t.span,\n@@ -513,7 +513,7 @@ impl GenericBound {\n     }\n }\n \n-pub type GenericBounds = HirVec<GenericBound>;\n+pub type GenericBounds<'hir> = &'hir [GenericBound<'hir>];\n \n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum LifetimeParamKind {\n@@ -535,29 +535,29 @@ pub enum LifetimeParamKind {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum GenericParamKind {\n+pub enum GenericParamKind<'hir> {\n     /// A lifetime definition (e.g., `'a: 'b + 'c + 'd`).\n     Lifetime {\n         kind: LifetimeParamKind,\n     },\n     Type {\n-        default: Option<P<Ty>>,\n+        default: Option<&'hir Ty<'hir>>,\n         synthetic: Option<SyntheticTyParamKind>,\n     },\n     Const {\n-        ty: P<Ty>,\n+        ty: &'hir Ty<'hir>,\n     },\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct GenericParam {\n+pub struct GenericParam<'hir> {\n     pub hir_id: HirId,\n     pub name: ParamName,\n-    pub attrs: HirVec<Attribute>,\n-    pub bounds: GenericBounds,\n+    pub attrs: &'hir [Attribute],\n+    pub bounds: GenericBounds<'hir>,\n     pub span: Span,\n     pub pure_wrt_drop: bool,\n-    pub kind: GenericParamKind,\n+    pub kind: GenericParamKind<'hir>,\n }\n \n #[derive(Default)]\n@@ -570,14 +570,14 @@ pub struct GenericParamCount {\n /// Represents lifetimes and type parameters attached to a declaration\n /// of a function, enum, trait, etc.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct Generics {\n-    pub params: HirVec<GenericParam>,\n-    pub where_clause: WhereClause,\n+pub struct Generics<'hir> {\n+    pub params: HirVec<GenericParam<'hir>>,\n+    pub where_clause: WhereClause<'hir>,\n     pub span: Span,\n }\n \n-impl Generics {\n-    pub const fn empty() -> Generics {\n+impl Generics<'hir> {\n+    pub const fn empty() -> Generics<'hir> {\n         Generics {\n             params: HirVec::new(),\n             where_clause: WhereClause { predicates: HirVec::new(), span: DUMMY_SP },\n@@ -602,7 +602,7 @@ impl Generics {\n         own_counts\n     }\n \n-    pub fn get_named(&self, name: Symbol) -> Option<&GenericParam> {\n+    pub fn get_named(&self, name: Symbol) -> Option<&GenericParam<'_>> {\n         for param in &self.params {\n             if name == param.name.ident().name {\n                 return Some(param);\n@@ -629,13 +629,13 @@ pub enum SyntheticTyParamKind {\n \n /// A where-clause in a definition.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct WhereClause {\n-    pub predicates: HirVec<WherePredicate>,\n+pub struct WhereClause<'hir> {\n+    pub predicates: &'hir [WherePredicate<'hir>],\n     // Only valid if predicates isn't empty.\n     span: Span,\n }\n \n-impl WhereClause {\n+impl WhereClause<'_> {\n     pub fn span(&self) -> Option<Span> {\n         if self.predicates.is_empty() { None } else { Some(self.span) }\n     }\n@@ -649,16 +649,16 @@ impl WhereClause {\n \n /// A single predicate in a where-clause.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum WherePredicate {\n+pub enum WherePredicate<'hir> {\n     /// A type binding (e.g., `for<'c> Foo: Send + Clone + 'c`).\n-    BoundPredicate(WhereBoundPredicate),\n+    BoundPredicate(WhereBoundPredicate<'hir>),\n     /// A lifetime predicate (e.g., `'a: 'b + 'c`).\n-    RegionPredicate(WhereRegionPredicate),\n+    RegionPredicate(WhereRegionPredicate<'hir>),\n     /// An equality predicate (unsupported).\n-    EqPredicate(WhereEqPredicate),\n+    EqPredicate(WhereEqPredicate<'hir>),\n }\n \n-impl WherePredicate {\n+impl WherePredicate<'_> {\n     pub fn span(&self) -> Span {\n         match self {\n             &WherePredicate::BoundPredicate(ref p) => p.span,\n@@ -670,31 +670,31 @@ impl WherePredicate {\n \n /// A type bound (e.g., `for<'c> Foo: Send + Clone + 'c`).\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct WhereBoundPredicate {\n+pub struct WhereBoundPredicate<'hir> {\n     pub span: Span,\n     /// Any generics from a `for` binding.\n-    pub bound_generic_params: HirVec<GenericParam>,\n+    pub bound_generic_params: &'hir [GenericParam<'hir>],\n     /// The type being bounded.\n-    pub bounded_ty: P<Ty>,\n+    pub bounded_ty: &'hir Ty<'hir>,\n     /// Trait and lifetime bounds (e.g., `Clone + Send + 'static`).\n-    pub bounds: GenericBounds,\n+    pub bounds: GenericBounds<'hir>,\n }\n \n /// A lifetime predicate (e.g., `'a: 'b + 'c`).\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct WhereRegionPredicate {\n+pub struct WhereRegionPredicate<'hir> {\n     pub span: Span,\n     pub lifetime: Lifetime,\n-    pub bounds: GenericBounds,\n+    pub bounds: GenericBounds<'hir>,\n }\n \n /// An equality predicate (e.g., `T = int`); currently unsupported.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct WhereEqPredicate {\n+pub struct WhereEqPredicate<'hir> {\n     pub hir_id: HirId,\n     pub span: Span,\n-    pub lhs_ty: P<Ty>,\n-    pub rhs_ty: P<Ty>,\n+    pub lhs_ty: &'hir Ty<'hir>,\n+    pub rhs_ty: &'hir Ty<'hir>,\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug)]\n@@ -820,7 +820,7 @@ impl Crate<'_> {\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct MacroDef<'hir> {\n     pub name: Name,\n-    pub vis: Visibility,\n+    pub vis: Visibility<'hir>,\n     pub attrs: &'hir [Attribute],\n     pub hir_id: HirId,\n     pub span: Span,\n@@ -1003,19 +1003,19 @@ pub enum PatKind<'hir> {\n \n     /// A struct or struct variant pattern (e.g., `Variant {x, y, ..}`).\n     /// The `bool` is `true` in the presence of a `..`.\n-    Struct(QPath, &'hir [FieldPat<'hir>], bool),\n+    Struct(QPath<'hir>, &'hir [FieldPat<'hir>], bool),\n \n     /// A tuple struct/variant pattern `Variant(x, y, .., z)`.\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n     /// `0 <= position <= subpats.len()`\n-    TupleStruct(QPath, &'hir [&'hir Pat<'hir>], Option<usize>),\n+    TupleStruct(QPath<'hir>, &'hir [&'hir Pat<'hir>], Option<usize>),\n \n     /// An or-pattern `A | B | C`.\n     /// Invariant: `pats.len() >= 2`.\n     Or(&'hir [&'hir Pat<'hir>]),\n \n     /// A path pattern for an unit struct/variant or a (maybe-associated) constant.\n-    Path(QPath),\n+    Path(QPath<'hir>),\n \n     /// A tuple pattern (e.g., `(a, b)`).\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n@@ -1258,7 +1258,7 @@ impl StmtKind<'hir> {\n pub struct Local<'hir> {\n     pub pat: &'hir Pat<'hir>,\n     /// Type annotation, if any (otherwise the type will be inferred).\n-    pub ty: Option<&'hir Ty>,\n+    pub ty: Option<&'hir Ty<'hir>>,\n     /// Initializer expression to set the value, if any.\n     pub init: Option<&'hir Expr<'hir>>,\n     pub hir_id: HirId,\n@@ -1583,7 +1583,7 @@ pub fn is_range_literal(sm: &SourceMap, expr: &Expr<'_>) -> bool {\n     // Returns whether the given path represents a (desugared) range,\n     // either in std or core, i.e. has either a `::std::ops::Range` or\n     // `::core::ops::Range` prefix.\n-    fn is_range_path(path: &Path) -> bool {\n+    fn is_range_path(path: &Path<'_>) -> bool {\n         let segs: Vec<_> = path.segments.iter().map(|seg| seg.ident.to_string()).collect();\n         let segs: Vec<_> = segs.iter().map(|seg| &**seg).collect();\n \n@@ -1663,7 +1663,7 @@ pub enum ExprKind<'hir> {\n     /// the `hir_id` of the `MethodCall` node itself.\n     ///\n     /// [`type_dependent_def_id`]: ../ty/struct.TypeckTables.html#method.type_dependent_def_id\n-    MethodCall(&'hir PathSegment, Span, &'hir [Expr<'hir>]),\n+    MethodCall(&'hir PathSegment<'hir>, Span, &'hir [Expr<'hir>]),\n     /// A tuple (e.g., `(a, b, c, d)`).\n     Tup(&'hir [Expr<'hir>]),\n     /// A binary operation (e.g., `a + b`, `a * b`).\n@@ -1673,9 +1673,9 @@ pub enum ExprKind<'hir> {\n     /// A literal (e.g., `1`, `\"foo\"`).\n     Lit(Lit),\n     /// A cast (e.g., `foo as f64`).\n-    Cast(&'hir Expr<'hir>, &'hir Ty),\n+    Cast(&'hir Expr<'hir>, &'hir Ty<'hir>),\n     /// A type reference (e.g., `Foo`).\n-    Type(&'hir Expr<'hir>, &'hir Ty),\n+    Type(&'hir Expr<'hir>, &'hir Ty<'hir>),\n     /// Wraps the expression in a terminating scope.\n     /// This makes it semantically equivalent to `{ let _t = expr; _t }`.\n     ///\n@@ -1695,7 +1695,7 @@ pub enum ExprKind<'hir> {\n     ///\n     /// This may also be a generator literal or an `async block` as indicated by the\n     /// `Option<Movability>`.\n-    Closure(CaptureBy, &'hir FnDecl, BodyId, Span, Option<Movability>),\n+    Closure(CaptureBy, &'hir FnDecl<'hir>, BodyId, Span, Option<Movability>),\n     /// A block (e.g., `'label: { ... }`).\n     Block(&'hir Block<'hir>, Option<Label>),\n \n@@ -1711,7 +1711,7 @@ pub enum ExprKind<'hir> {\n     Index(&'hir Expr<'hir>, &'hir Expr<'hir>),\n \n     /// Path to a definition, possibly containing lifetime or type parameters.\n-    Path(QPath),\n+    Path(QPath<'hir>),\n \n     /// A referencing operation (i.e., `&a` or `&mut a`).\n     AddrOf(BorrowKind, Mutability, &'hir Expr<'hir>),\n@@ -1729,7 +1729,7 @@ pub enum ExprKind<'hir> {\n     ///\n     /// E.g., `Foo {x: 1, y: 2}`, or `Foo {x: 1, .. base}`,\n     /// where `base` is the `Option<Expr>`.\n-    Struct(&'hir QPath, &'hir [Field<'hir>], Option<&'hir Expr<'hir>>),\n+    Struct(&'hir QPath<'hir>, &'hir [Field<'hir>], Option<&'hir Expr<'hir>>),\n \n     /// An array literal constructed from one repeated element.\n     ///\n@@ -1750,22 +1750,22 @@ pub enum ExprKind<'hir> {\n ///\n /// [`qpath_res`]: ../ty/struct.TypeckTables.html#method.qpath_res\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum QPath {\n+pub enum QPath<'hir> {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n     /// type, if the path points to an associated item in a trait.\n     ///\n     /// E.g., an unqualified path like `Clone::clone` has `None` for `Self`,\n     /// while `<Vec<T> as Clone>::clone` has `Some(Vec<T>)` for `Self`,\n     /// even though they both have the same two-segment `Clone::clone` `Path`.\n-    Resolved(Option<P<Ty>>, P<Path>),\n+    Resolved(Option<&'hir Ty<'hir>>, &'hir Path<'hir>),\n \n     /// Type-related paths (e.g., `<T>::default` or `<T>::Output`).\n     /// Will be resolved by type-checking to an associated item.\n     ///\n     /// UFCS source paths can desugar into this, with `Vec::new` turning into\n     /// `<Vec>::new`, and `T::X::Y::method` into `<<<T>::X>::Y>::method`,\n     /// the `X` and `Y` nodes each being a `TyKind::Path(QPath::TypeRelative(..))`.\n-    TypeRelative(P<Ty>, P<PathSegment>),\n+    TypeRelative(&'hir Ty<'hir>, &'hir PathSegment<'hir>),\n }\n \n /// Hints at the original code for a let statement.\n@@ -1909,8 +1909,8 @@ impl From<GeneratorKind> for YieldSource {\n // N.B., if you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct MutTy {\n-    pub ty: P<Ty>,\n+pub struct MutTy<'hir> {\n+    pub ty: &'hir Ty<'hir>,\n     pub mutbl: Mutability,\n }\n \n@@ -1919,7 +1919,7 @@ pub struct MutTy {\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct FnSig<'hir> {\n     pub header: FnHeader,\n-    pub decl: &'hir FnDecl,\n+    pub decl: &'hir FnDecl<'hir>,\n }\n \n // The bodies for items are stored \"out of line\", in a separate\n@@ -1939,7 +1939,7 @@ pub struct TraitItem<'hir> {\n     pub ident: Ident,\n     pub hir_id: HirId,\n     pub attrs: &'hir [Attribute],\n-    pub generics: Generics,\n+    pub generics: Generics<'hir>,\n     pub kind: TraitItemKind<'hir>,\n     pub span: Span,\n }\n@@ -1958,12 +1958,12 @@ pub enum TraitMethod<'hir> {\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum TraitItemKind<'hir> {\n     /// An associated constant with an optional value (otherwise `impl`s must contain a value).\n-    Const(&'hir Ty, Option<BodyId>),\n+    Const(&'hir Ty<'hir>, Option<BodyId>),\n     /// A method with an optional body.\n     Method(FnSig<'hir>, TraitMethod<'hir>),\n     /// An associated type with (possibly empty) bounds and optional concrete\n     /// type.\n-    Type(GenericBounds, Option<&'hir Ty>),\n+    Type(GenericBounds<'hir>, Option<&'hir Ty<'hir>>),\n }\n \n // The bodies for items are stored \"out of line\", in a separate\n@@ -1979,10 +1979,10 @@ pub struct ImplItemId {\n pub struct ImplItem<'hir> {\n     pub ident: Ident,\n     pub hir_id: HirId,\n-    pub vis: Visibility,\n+    pub vis: Visibility<'hir>,\n     pub defaultness: Defaultness,\n     pub attrs: &'hir [Attribute],\n-    pub generics: Generics,\n+    pub generics: Generics<'hir>,\n     pub kind: ImplItemKind<'hir>,\n     pub span: Span,\n }\n@@ -1992,13 +1992,13 @@ pub struct ImplItem<'hir> {\n pub enum ImplItemKind<'hir> {\n     /// An associated constant of the given type, set to the constant result\n     /// of the expression.\n-    Const(&'hir Ty, BodyId),\n+    Const(&'hir Ty<'hir>, BodyId),\n     /// A method implementation with the given signature and body.\n     Method(FnSig<'hir>, BodyId),\n     /// An associated type.\n-    TyAlias(&'hir Ty),\n+    TyAlias(&'hir Ty<'hir>),\n     /// An associated `type = impl Trait`.\n-    OpaqueTy(GenericBounds),\n+    OpaqueTy(GenericBounds<'hir>),\n }\n \n /// Bind a type to an associated type (i.e., `A = Foo`).\n@@ -2017,25 +2017,25 @@ pub enum ImplItemKind<'hir> {\n /// }\n /// ```\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct TypeBinding {\n+pub struct TypeBinding<'hir> {\n     pub hir_id: HirId,\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n-    pub kind: TypeBindingKind,\n+    pub kind: TypeBindingKind<'hir>,\n     pub span: Span,\n }\n \n // Represents the two kinds of type bindings.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum TypeBindingKind {\n+pub enum TypeBindingKind<'hir> {\n     /// E.g., `Foo<Bar: Send>`.\n-    Constraint { bounds: HirVec<GenericBound> },\n+    Constraint { bounds: &'hir [GenericBound<'hir>] },\n     /// E.g., `Foo<Bar = ()>`.\n-    Equality { ty: P<Ty> },\n+    Equality { ty: &'hir Ty<'hir> },\n }\n \n-impl TypeBinding {\n-    pub fn ty(&self) -> &Ty {\n+impl TypeBinding<'_> {\n+    pub fn ty(&self) -> &Ty<'_> {\n         match self.kind {\n             TypeBindingKind::Equality { ref ty } => ty,\n             _ => bug!(\"expected equality type binding for parenthesized generic args\"),\n@@ -2044,13 +2044,13 @@ impl TypeBinding {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct Ty {\n+pub struct Ty<'hir> {\n     pub hir_id: HirId,\n-    pub kind: TyKind,\n+    pub kind: TyKind<'hir>,\n     pub span: Span,\n }\n \n-impl fmt::Debug for Ty {\n+impl fmt::Debug for Ty<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"type({})\", print::to_string(print::NO_ANN, |s| s.print_type(self)))\n     }\n@@ -2068,18 +2068,18 @@ pub enum PrimTy {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct BareFnTy {\n+pub struct BareFnTy<'hir> {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n-    pub generic_params: HirVec<GenericParam>,\n-    pub decl: P<FnDecl>,\n-    pub param_names: HirVec<Ident>,\n+    pub generic_params: &'hir [GenericParam<'hir>],\n+    pub decl: &'hir FnDecl<'hir>,\n+    pub param_names: &'hir [Ident],\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct OpaqueTy {\n-    pub generics: Generics,\n-    pub bounds: GenericBounds,\n+pub struct OpaqueTy<'hir> {\n+    pub generics: Generics<'hir>,\n+    pub bounds: GenericBounds<'hir>,\n     pub impl_trait_fn: Option<DefId>,\n     pub origin: OpaqueTyOrigin,\n }\n@@ -2097,35 +2097,35 @@ pub enum OpaqueTyOrigin {\n \n /// The various kinds of types recognized by the compiler.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum TyKind {\n+pub enum TyKind<'hir> {\n     /// A variable length slice (i.e., `[T]`).\n-    Slice(P<Ty>),\n+    Slice(&'hir Ty<'hir>),\n     /// A fixed length array (i.e., `[T; n]`).\n-    Array(P<Ty>, AnonConst),\n+    Array(&'hir Ty<'hir>, AnonConst),\n     /// A raw pointer (i.e., `*const T` or `*mut T`).\n-    Ptr(MutTy),\n+    Ptr(MutTy<'hir>),\n     /// A reference (i.e., `&'a T` or `&'a mut T`).\n-    Rptr(Lifetime, MutTy),\n+    Rptr(Lifetime, MutTy<'hir>),\n     /// A bare function (e.g., `fn(usize) -> bool`).\n-    BareFn(P<BareFnTy>),\n+    BareFn(&'hir BareFnTy<'hir>),\n     /// The never type (`!`).\n     Never,\n     /// A tuple (`(A, B, C, D, ...)`).\n-    Tup(HirVec<Ty>),\n+    Tup(&'hir [Ty<'hir>]),\n     /// A path to a type definition (`module::module::...::Type`), or an\n     /// associated type (e.g., `<Vec<T> as Trait>::Type` or `<T>::Target`).\n     ///\n     /// Type parameters may be stored in each `PathSegment`.\n-    Path(QPath),\n+    Path(QPath<'hir>),\n     /// A type definition itself. This is currently only used for the `type Foo = impl Trait`\n     /// item that `impl Trait` in return position desugars to.\n     ///\n     /// The generic argument list contains the lifetimes (and in the future possibly parameters)\n     /// that are actually bound on the `impl Trait`.\n-    Def(ItemId, HirVec<GenericArg>),\n+    Def(ItemId, &'hir [GenericArg<'hir>]),\n     /// A trait object type `Bound1 + Bound2 + Bound3`\n     /// where `Bound` is a trait or a lifetime.\n-    TraitObject(HirVec<PolyTraitRef>, Lifetime),\n+    TraitObject(&'hir [PolyTraitRef<'hir>], Lifetime),\n     /// Unused for now.\n     Typeof(AnonConst),\n     /// `TyKind::Infer` means the type should be inferred instead of it having been\n@@ -2175,12 +2175,12 @@ pub struct Param<'hir> {\n \n /// Represents the header (not the body) of a function declaration.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct FnDecl {\n+pub struct FnDecl<'hir> {\n     /// The types of the function's parameters.\n     ///\n     /// Additional argument data is stored in the function's [body](Body::parameters).\n-    pub inputs: HirVec<Ty>,\n-    pub output: FunctionRetTy,\n+    pub inputs: &'hir [Ty<'hir>],\n+    pub output: FunctionRetTy<'hir>,\n     pub c_variadic: bool,\n     /// Does the function have an implicit self?\n     pub implicit_self: ImplicitSelfKind,\n@@ -2256,18 +2256,18 @@ impl Defaultness {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub enum FunctionRetTy {\n+pub enum FunctionRetTy<'hir> {\n     /// Return type is not specified.\n     ///\n     /// Functions default to `()` and\n     /// closures default to inference. Span points to where return\n     /// type would be inserted.\n     DefaultReturn(Span),\n     /// Everything else.\n-    Return(P<Ty>),\n+    Return(&'hir Ty<'hir>),\n }\n \n-impl fmt::Display for FunctionRetTy {\n+impl fmt::Display for FunctionRetTy<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Return(ref ty) => print::to_string(print::NO_ANN, |s| s.print_type(ty)).fmt(f),\n@@ -2276,7 +2276,7 @@ impl fmt::Display for FunctionRetTy {\n     }\n }\n \n-impl FunctionRetTy {\n+impl FunctionRetTy<'_> {\n     pub fn span(&self) -> Span {\n         match *self {\n             DefaultReturn(span) => span,\n@@ -2350,14 +2350,14 @@ pub enum UseKind {\n /// trait being referred to but just a unique `HirId` that serves as a key\n /// within the resolution map.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct TraitRef {\n-    pub path: P<Path>,\n+pub struct TraitRef<'hir> {\n+    pub path: &'hir Path<'hir>,\n     // Don't hash the `ref_id`. It is tracked via the thing it is used to access.\n     #[stable_hasher(ignore)]\n     pub hir_ref_id: HirId,\n }\n \n-impl TraitRef {\n+impl TraitRef<'_> {\n     /// Gets the `DefId` of the referenced trait. It _must_ actually be a trait or trait alias.\n     pub fn trait_def_id(&self) -> DefId {\n         match self.path.res {\n@@ -2372,27 +2372,27 @@ impl TraitRef {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct PolyTraitRef {\n+pub struct PolyTraitRef<'hir> {\n     /// The `'a` in `<'a> Foo<&'a T>`.\n-    pub bound_generic_params: HirVec<GenericParam>,\n+    pub bound_generic_params: &'hir [GenericParam<'hir>],\n \n     /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`.\n-    pub trait_ref: TraitRef,\n+    pub trait_ref: TraitRef<'hir>,\n \n     pub span: Span,\n }\n \n-pub type Visibility = Spanned<VisibilityKind>;\n+pub type Visibility<'hir> = Spanned<VisibilityKind<'hir>>;\n \n #[derive(RustcEncodable, RustcDecodable, Debug)]\n-pub enum VisibilityKind {\n+pub enum VisibilityKind<'hir> {\n     Public,\n     Crate(CrateSugar),\n-    Restricted { path: P<Path>, hir_id: HirId },\n+    Restricted { path: &'hir Path<'hir>, hir_id: HirId },\n     Inherited,\n }\n \n-impl VisibilityKind {\n+impl VisibilityKind<'_> {\n     pub fn is_pub(&self) -> bool {\n         match *self {\n             VisibilityKind::Public => true,\n@@ -2422,9 +2422,9 @@ pub struct StructField<'hir> {\n     pub span: Span,\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n-    pub vis: Visibility,\n+    pub vis: Visibility<'hir>,\n     pub hir_id: HirId,\n-    pub ty: &'hir Ty,\n+    pub ty: &'hir Ty<'hir>,\n     pub attrs: &'hir [Attribute],\n }\n \n@@ -2488,7 +2488,7 @@ pub struct Item<'hir> {\n     pub hir_id: HirId,\n     pub attrs: &'hir [Attribute],\n     pub kind: ItemKind<'hir>,\n-    pub vis: Visibility,\n+    pub vis: Visibility<'hir>,\n     pub span: Span,\n }\n \n@@ -2521,44 +2521,44 @@ pub enum ItemKind<'hir> {\n     /// or just\n     ///\n     /// `use foo::bar::baz;` (with `as baz` implicitly on the right).\n-    Use(&'hir Path, UseKind),\n+    Use(&'hir Path<'hir>, UseKind),\n \n     /// A `static` item.\n-    Static(&'hir Ty, Mutability, BodyId),\n+    Static(&'hir Ty<'hir>, Mutability, BodyId),\n     /// A `const` item.\n-    Const(&'hir Ty, BodyId),\n+    Const(&'hir Ty<'hir>, BodyId),\n     /// A function declaration.\n-    Fn(FnSig<'hir>, Generics, BodyId),\n+    Fn(FnSig<'hir>, Generics<'hir>, BodyId),\n     /// A module.\n     Mod(Mod<'hir>),\n     /// An external module, e.g. `extern { .. }`.\n     ForeignMod(ForeignMod<'hir>),\n     /// Module-level inline assembly (from `global_asm!`).\n     GlobalAsm(&'hir GlobalAsm),\n     /// A type alias, e.g., `type Foo = Bar<u8>`.\n-    TyAlias(&'hir Ty, Generics),\n+    TyAlias(&'hir Ty<'hir>, Generics<'hir>),\n     /// An opaque `impl Trait` type alias, e.g., `type Foo = impl Bar;`.\n-    OpaqueTy(OpaqueTy),\n+    OpaqueTy(OpaqueTy<'hir>),\n     /// An enum definition, e.g., `enum Foo<A, B> {C<A>, D<B>}`.\n-    Enum(EnumDef<'hir>, Generics),\n+    Enum(EnumDef<'hir>, Generics<'hir>),\n     /// A struct definition, e.g., `struct Foo<A> {x: A}`.\n-    Struct(VariantData<'hir>, Generics),\n+    Struct(VariantData<'hir>, Generics<'hir>),\n     /// A union definition, e.g., `union Foo<A, B> {x: A, y: B}`.\n-    Union(VariantData<'hir>, Generics),\n+    Union(VariantData<'hir>, Generics<'hir>),\n     /// A trait definition.\n-    Trait(IsAuto, Unsafety, Generics, GenericBounds, &'hir [TraitItemRef]),\n+    Trait(IsAuto, Unsafety, Generics<'hir>, GenericBounds<'hir>, &'hir [TraitItemRef]),\n     /// A trait alias.\n-    TraitAlias(Generics, GenericBounds),\n+    TraitAlias(Generics<'hir>, GenericBounds<'hir>),\n \n     /// An implementation, e.g., `impl<A> Trait for Foo { .. }`.\n     Impl(\n         Unsafety,\n         ImplPolarity,\n         Defaultness,\n-        Generics,\n-        Option<TraitRef>, // (optional) trait this impl implements\n-        &'hir Ty,         // self\n-        &'hir [ImplItemRef],\n+        Generics<'hir>,\n+        Option<TraitRef<'hir>>, // (optional) trait this impl implements\n+        &'hir Ty<'hir>,         // self\n+        &'hir [ImplItemRef<'hir>],\n     ),\n }\n \n@@ -2593,7 +2593,7 @@ impl ItemKind<'_> {\n         }\n     }\n \n-    pub fn generics(&self) -> Option<&Generics> {\n+    pub fn generics(&self) -> Option<&Generics<'_>> {\n         Some(match *self {\n             ItemKind::Fn(_, ref generics, _)\n             | ItemKind::TyAlias(_, ref generics)\n@@ -2631,13 +2631,13 @@ pub struct TraitItemRef {\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct ImplItemRef {\n+pub struct ImplItemRef<'hir> {\n     pub id: ImplItemId,\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n     pub kind: AssocItemKind,\n     pub span: Span,\n-    pub vis: Visibility,\n+    pub vis: Visibility<'hir>,\n     pub defaultness: Defaultness,\n }\n \n@@ -2657,16 +2657,16 @@ pub struct ForeignItem<'hir> {\n     pub kind: ForeignItemKind<'hir>,\n     pub hir_id: HirId,\n     pub span: Span,\n-    pub vis: Visibility,\n+    pub vis: Visibility<'hir>,\n }\n \n /// An item within an `extern` block.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ForeignItemKind<'hir> {\n     /// A foreign function.\n-    Fn(&'hir FnDecl, &'hir [Ident], Generics),\n+    Fn(&'hir FnDecl<'hir>, &'hir [Ident], Generics<'hir>),\n     /// A foreign static item (`static ext: u8`).\n-    Static(&'hir Ty, Mutability),\n+    Static(&'hir Ty<'hir>, Mutability),\n     /// A foreign type.\n     Type,\n }\n@@ -2837,9 +2837,9 @@ pub enum Node<'hir> {\n     AnonConst(&'hir AnonConst),\n     Expr(&'hir Expr<'hir>),\n     Stmt(&'hir Stmt<'hir>),\n-    PathSegment(&'hir PathSegment),\n-    Ty(&'hir Ty),\n-    TraitRef(&'hir TraitRef),\n+    PathSegment(&'hir PathSegment<'hir>),\n+    Ty(&'hir Ty<'hir>),\n+    TraitRef(&'hir TraitRef<'hir>),\n     Binding(&'hir Pat<'hir>),\n     Pat(&'hir Pat<'hir>),\n     Arm(&'hir Arm<'hir>),\n@@ -2852,8 +2852,8 @@ pub enum Node<'hir> {\n     Ctor(&'hir VariantData<'hir>),\n \n     Lifetime(&'hir Lifetime),\n-    GenericParam(&'hir GenericParam),\n-    Visibility(&'hir Visibility),\n+    GenericParam(&'hir GenericParam<'hir>),\n+    Visibility(&'hir Visibility<'hir>),\n \n     Crate,\n }"}, {"sha": "84e824f64df93536eafc8de5be02b7ca015b8e70", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -140,7 +140,7 @@ where\n     printer.s.eof()\n }\n \n-pub fn visibility_qualified<S: Into<Cow<'static, str>>>(vis: &hir::Visibility, w: S) -> String {\n+pub fn visibility_qualified<S: Into<Cow<'static, str>>>(vis: &hir::Visibility<'_>, w: S) -> String {\n     to_string(NO_ANN, |s| {\n         s.print_visibility(vis);\n         s.s.word(w)\n@@ -266,7 +266,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_type(&mut self, ty: &hir::Ty) {\n+    pub fn print_type(&mut self, ty: &hir::Ty<'_>) {\n         self.maybe_print_comment(ty.span.lo());\n         self.ibox(0);\n         match ty.kind {\n@@ -398,9 +398,9 @@ impl<'a> State<'a> {\n     fn print_associated_const(\n         &mut self,\n         ident: ast::Ident,\n-        ty: &hir::Ty,\n+        ty: &hir::Ty<'_>,\n         default: Option<hir::BodyId>,\n-        vis: &hir::Visibility,\n+        vis: &hir::Visibility<'_>,\n     ) {\n         self.s.word(visibility_qualified(vis, \"\"));\n         self.word_space(\"const\");\n@@ -418,8 +418,8 @@ impl<'a> State<'a> {\n     fn print_associated_type(\n         &mut self,\n         ident: ast::Ident,\n-        bounds: Option<&hir::GenericBounds>,\n-        ty: Option<&hir::Ty>,\n+        bounds: Option<&hir::GenericBounds<'_>>,\n+        ty: Option<&hir::Ty<'_>>,\n     ) {\n         self.word_space(\"type\");\n         self.print_ident(ident);\n@@ -437,7 +437,7 @@ impl<'a> State<'a> {\n     fn print_item_type(\n         &mut self,\n         item: &hir::Item<'_>,\n-        generics: &hir::Generics,\n+        generics: &hir::Generics<'_>,\n         inner: impl Fn(&mut Self),\n     ) {\n         self.head(visibility_qualified(&item.vis, \"type\"));\n@@ -682,30 +682,30 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Item(item))\n     }\n \n-    pub fn print_trait_ref(&mut self, t: &hir::TraitRef) {\n+    pub fn print_trait_ref(&mut self, t: &hir::TraitRef<'_>) {\n         self.print_path(&t.path, false)\n     }\n \n-    fn print_formal_generic_params(&mut self, generic_params: &[hir::GenericParam]) {\n+    fn print_formal_generic_params(&mut self, generic_params: &[hir::GenericParam<'_>]) {\n         if !generic_params.is_empty() {\n             self.s.word(\"for\");\n             self.print_generic_params(generic_params);\n             self.nbsp();\n         }\n     }\n \n-    fn print_poly_trait_ref(&mut self, t: &hir::PolyTraitRef) {\n+    fn print_poly_trait_ref(&mut self, t: &hir::PolyTraitRef<'_>) {\n         self.print_formal_generic_params(&t.bound_generic_params);\n         self.print_trait_ref(&t.trait_ref)\n     }\n \n     pub fn print_enum_def(\n         &mut self,\n         enum_definition: &hir::EnumDef<'_>,\n-        generics: &hir::Generics,\n+        generics: &hir::Generics<'_>,\n         name: ast::Name,\n         span: syntax_pos::Span,\n-        visibility: &hir::Visibility,\n+        visibility: &hir::Visibility<'_>,\n     ) {\n         self.head(visibility_qualified(visibility, \"enum\"));\n         self.print_name(name);\n@@ -730,7 +730,7 @@ impl<'a> State<'a> {\n         self.bclose(span)\n     }\n \n-    pub fn print_visibility(&mut self, vis: &hir::Visibility) {\n+    pub fn print_visibility(&mut self, vis: &hir::Visibility<'_>) {\n         match vis.node {\n             hir::VisibilityKind::Public => self.word_nbsp(\"pub\"),\n             hir::VisibilityKind::Crate(ast::CrateSugar::JustCrate) => self.word_nbsp(\"crate\"),\n@@ -761,7 +761,7 @@ impl<'a> State<'a> {\n     pub fn print_struct(\n         &mut self,\n         struct_def: &hir::VariantData<'_>,\n-        generics: &hir::Generics,\n+        generics: &hir::Generics<'_>,\n         name: ast::Name,\n         span: syntax_pos::Span,\n         print_finalizer: bool,\n@@ -823,8 +823,8 @@ impl<'a> State<'a> {\n         &mut self,\n         ident: ast::Ident,\n         m: &hir::FnSig<'_>,\n-        generics: &hir::Generics,\n-        vis: &hir::Visibility,\n+        generics: &hir::Generics<'_>,\n+        vis: &hir::Visibility<'_>,\n         arg_names: &[ast::Ident],\n         body_id: Option<hir::BodyId>,\n     ) {\n@@ -1044,7 +1044,7 @@ impl<'a> State<'a> {\n \n     fn print_expr_struct(\n         &mut self,\n-        qpath: &hir::QPath,\n+        qpath: &hir::QPath<'_>,\n         fields: &[hir::Field<'_>],\n         wth: &Option<&'hir hir::Expr<'_>>,\n     ) {\n@@ -1103,7 +1103,7 @@ impl<'a> State<'a> {\n         self.print_call_post(args)\n     }\n \n-    fn print_expr_method_call(&mut self, segment: &hir::PathSegment, args: &[hir::Expr<'_>]) {\n+    fn print_expr_method_call(&mut self, segment: &hir::PathSegment<'_>, args: &[hir::Expr<'_>]) {\n         let base_args = &args[1..];\n         self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX);\n         self.s.word(\".\");\n@@ -1440,7 +1440,7 @@ impl<'a> State<'a> {\n         self.print_expr(coll)\n     }\n \n-    pub fn print_path(&mut self, path: &hir::Path, colons_before_params: bool) {\n+    pub fn print_path(&mut self, path: &hir::Path<'_>, colons_before_params: bool) {\n         self.maybe_print_comment(path.span.lo());\n \n         for (i, segment) in path.segments.iter().enumerate() {\n@@ -1458,14 +1458,14 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_path_segment(&mut self, segment: &hir::PathSegment) {\n+    pub fn print_path_segment(&mut self, segment: &hir::PathSegment<'_>) {\n         if segment.ident.name != kw::PathRoot {\n             self.print_ident(segment.ident);\n             self.print_generic_args(segment.generic_args(), segment.infer_args, false);\n         }\n     }\n \n-    pub fn print_qpath(&mut self, qpath: &hir::QPath, colons_before_params: bool) {\n+    pub fn print_qpath(&mut self, qpath: &hir::QPath<'_>, colons_before_params: bool) {\n         match *qpath {\n             hir::QPath::Resolved(None, ref path) => self.print_path(path, colons_before_params),\n             hir::QPath::Resolved(Some(ref qself), ref path) => {\n@@ -1523,7 +1523,7 @@ impl<'a> State<'a> {\n \n     fn print_generic_args(\n         &mut self,\n-        generic_args: &hir::GenericArgs,\n+        generic_args: &hir::GenericArgs<'_>,\n         infer_args: bool,\n         colons_before_params: bool,\n     ) {\n@@ -1814,11 +1814,11 @@ impl<'a> State<'a> {\n \n     pub fn print_fn(\n         &mut self,\n-        decl: &hir::FnDecl,\n+        decl: &hir::FnDecl<'_>,\n         header: hir::FnHeader,\n         name: Option<ast::Name>,\n-        generics: &hir::Generics,\n-        vis: &hir::Visibility,\n+        generics: &hir::Generics<'_>,\n+        vis: &hir::Visibility<'_>,\n         arg_names: &[ast::Ident],\n         body_id: Option<hir::BodyId>,\n     ) {\n@@ -1858,7 +1858,7 @@ impl<'a> State<'a> {\n         self.print_where_clause(&generics.where_clause)\n     }\n \n-    fn print_closure_params(&mut self, decl: &hir::FnDecl, body_id: hir::BodyId) {\n+    fn print_closure_params(&mut self, decl: &hir::FnDecl<'_>, body_id: hir::BodyId) {\n         self.s.word(\"|\");\n         let mut i = 0;\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n@@ -1903,7 +1903,7 @@ impl<'a> State<'a> {\n     pub fn print_bounds<'b>(\n         &mut self,\n         prefix: &'static str,\n-        bounds: impl IntoIterator<Item = &'b hir::GenericBound>,\n+        bounds: impl IntoIterator<Item = &'b hir::GenericBound<'b>>,\n     ) {\n         let mut first = true;\n         for bound in bounds {\n@@ -1933,7 +1933,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_generic_params(&mut self, generic_params: &[GenericParam]) {\n+    pub fn print_generic_params(&mut self, generic_params: &[GenericParam<'_>]) {\n         if !generic_params.is_empty() {\n             self.s.word(\"<\");\n \n@@ -1943,7 +1943,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_generic_param(&mut self, param: &GenericParam) {\n+    pub fn print_generic_param(&mut self, param: &GenericParam<'_>) {\n         if let GenericParamKind::Const { .. } = param.kind {\n             self.word_space(\"const\");\n         }\n@@ -1986,7 +1986,7 @@ impl<'a> State<'a> {\n         self.print_ident(lifetime.name.ident())\n     }\n \n-    pub fn print_where_clause(&mut self, where_clause: &hir::WhereClause) {\n+    pub fn print_where_clause(&mut self, where_clause: &hir::WhereClause<'_>) {\n         if where_clause.predicates.is_empty() {\n             return;\n         }\n@@ -2056,12 +2056,12 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_mt(&mut self, mt: &hir::MutTy, print_const: bool) {\n+    pub fn print_mt(&mut self, mt: &hir::MutTy<'_>, print_const: bool) {\n         self.print_mutability(mt.mutbl, print_const);\n         self.print_type(&mt.ty)\n     }\n \n-    pub fn print_fn_output(&mut self, decl: &hir::FnDecl) {\n+    pub fn print_fn_output(&mut self, decl: &hir::FnDecl<'_>) {\n         if let hir::DefaultReturn(..) = decl.output {\n             return;\n         }\n@@ -2085,9 +2085,9 @@ impl<'a> State<'a> {\n         &mut self,\n         abi: Abi,\n         unsafety: hir::Unsafety,\n-        decl: &hir::FnDecl,\n+        decl: &hir::FnDecl<'_>,\n         name: Option<ast::Name>,\n-        generic_params: &[hir::GenericParam],\n+        generic_params: &[hir::GenericParam<'_>],\n         arg_names: &[ast::Ident],\n     ) {\n         self.ibox(INDENT_UNIT);\n@@ -2164,7 +2164,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_fn_header_info(&mut self, header: hir::FnHeader, vis: &hir::Visibility) {\n+    pub fn print_fn_header_info(&mut self, header: hir::FnHeader, vis: &hir::Visibility<'_>) {\n         self.s.word(visibility_qualified(vis, \"\"));\n \n         match header.constness {"}, {"sha": "827cf7513944fa235951c3e4af73036faa21eabe", "filename": "src/librustc/hir/upvars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fhir%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fupvars.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -73,7 +73,7 @@ impl Visitor<'tcx> for CaptureCollector<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_path(&mut self, path: &'tcx hir::Path, _: hir::HirId) {\n+    fn visit_path(&mut self, path: &'tcx hir::Path<'tcx>, _: hir::HirId) {\n         if let Res::Local(var_id) = path.res {\n             self.visit_local_use(var_id, path.span);\n         }"}, {"sha": "214a50456d57609a48e1354fa156d448a93e4a6d", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -106,7 +106,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItemId {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty<'_> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Ty { hir_id: _, ref kind, ref span } = *self;\n@@ -168,7 +168,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem<'_> {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::VisibilityKind {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::VisibilityKind<'_> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {"}, {"sha": "5a6d336ee1b926524bad39b46cafdc9e4a537b9e", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n fn closure_return_type_suggestion(\n     span: Span,\n     err: &mut DiagnosticBuilder<'_>,\n-    output: &FunctionRetTy,\n+    output: &FunctionRetTy<'_>,\n     body: &Body<'_>,\n     descr: &str,\n     name: &str,\n@@ -460,7 +460,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// needed, suggest annotating the call, otherwise point out the resulting type of the call.\n     fn annotate_method_call(\n         &self,\n-        segment: &hir::PathSegment,\n+        segment: &hir::PathSegment<'_>,\n         e: &Expr<'_>,\n         err: &mut DiagnosticBuilder<'_>,\n     ) {"}, {"sha": "9077a48f850367475a4d4031070bb9ab5a22f8d8", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -25,7 +25,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         &self,\n         region: Region<'tcx>,\n         br: &ty::BoundRegion,\n-    ) -> Option<(&hir::Ty, &hir::FnDecl)> {\n+    ) -> Option<(&hir::Ty<'_>, &hir::FnDecl<'_>)> {\n         if let Some(anon_reg) = self.tcx().is_suitable_region(region) {\n             let def_id = anon_reg.def_id;\n             if let Some(hir_id) = self.tcx().hir().as_local_hir_id(def_id) {\n@@ -57,9 +57,9 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     // to the anonymous region.\n     fn find_component_for_bound_region(\n         &self,\n-        arg: &'tcx hir::Ty,\n+        arg: &'tcx hir::Ty<'tcx>,\n         br: &ty::BoundRegion,\n-    ) -> Option<&'tcx hir::Ty> {\n+    ) -> Option<&'tcx hir::Ty<'tcx>> {\n         let mut nested_visitor = FindNestedTypeVisitor {\n             tcx: self.tcx(),\n             bound_region: *br,\n@@ -85,7 +85,7 @@ struct FindNestedTypeVisitor<'tcx> {\n     bound_region: ty::BoundRegion,\n     // The type where the anonymous lifetime appears\n     // for e.g., Vec<`&u8`> and <`&u8`>\n-    found_type: Option<&'tcx hir::Ty>,\n+    found_type: Option<&'tcx hir::Ty<'tcx>>,\n     current_index: ty::DebruijnIndex,\n }\n \n@@ -94,7 +94,7 @@ impl Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n         NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n     }\n \n-    fn visit_ty(&mut self, arg: &'tcx hir::Ty) {\n+    fn visit_ty(&mut self, arg: &'tcx hir::Ty<'tcx>) {\n         match arg.kind {\n             hir::TyKind::BareFn(_) => {\n                 self.current_index.shift_in(1);\n@@ -250,7 +250,7 @@ impl Visitor<'tcx> for TyPathVisitor<'tcx> {\n         }\n     }\n \n-    fn visit_ty(&mut self, arg: &'tcx hir::Ty) {\n+    fn visit_ty(&mut self, arg: &'tcx hir::Ty<'tcx>) {\n         // ignore nested types\n         //\n         // If you have a type like `Foo<'a, &Ty>` we"}, {"sha": "95feef313c07abbb312b0378fb59eabff7d1d585", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -106,7 +106,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         &self,\n         scope_def_id: DefId,\n         br: ty::BoundRegion,\n-        decl: &hir::FnDecl,\n+        decl: &hir::FnDecl<'_>,\n     ) -> Option<Span> {\n         let ret_ty = self.tcx().type_of(scope_def_id);\n         if let ty::FnDef(_, _) = ret_ty.kind {"}, {"sha": "44258b62ca32f2c2f9bc22052bdf77e93892fe1e", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -452,7 +452,7 @@ pub struct LateContext<'a, 'tcx> {\n     last_node_with_lint_attrs: hir::HirId,\n \n     /// Generic type parameters in scope for the item we are in.\n-    pub generics: Option<&'tcx hir::Generics>,\n+    pub generics: Option<&'tcx hir::Generics<'tcx>>,\n \n     /// We are only looking at one module\n     only_module: bool,\n@@ -956,7 +956,7 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n     fn visit_fn(\n         &mut self,\n         fk: hir_visit::FnKind<'tcx>,\n-        decl: &'tcx hir::FnDecl,\n+        decl: &'tcx hir::FnDecl<'tcx>,\n         body_id: hir::BodyId,\n         span: Span,\n         id: hir::HirId,\n@@ -976,7 +976,7 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n         &mut self,\n         s: &'tcx hir::VariantData<'tcx>,\n         _: ast::Name,\n-        _: &'tcx hir::Generics,\n+        _: &'tcx hir::Generics<'tcx>,\n         _: hir::HirId,\n         _: Span,\n     ) {\n@@ -995,7 +995,7 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n     fn visit_variant(\n         &mut self,\n         v: &'tcx hir::Variant<'tcx>,\n-        g: &'tcx hir::Generics,\n+        g: &'tcx hir::Generics<'tcx>,\n         item_id: hir::HirId,\n     ) {\n         self.with_lint_attrs(v.id, &v.attrs, |cx| {\n@@ -1005,7 +1005,7 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n         })\n     }\n \n-    fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n+    fn visit_ty(&mut self, t: &'tcx hir::Ty<'tcx>) {\n         lint_callback!(self, check_ty, t);\n         hir_visit::walk_ty(self, t);\n     }\n@@ -1038,22 +1038,26 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n         hir_visit::walk_arm(self, a);\n     }\n \n-    fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam) {\n+    fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam<'tcx>) {\n         lint_callback!(self, check_generic_param, p);\n         hir_visit::walk_generic_param(self, p);\n     }\n \n-    fn visit_generics(&mut self, g: &'tcx hir::Generics) {\n+    fn visit_generics(&mut self, g: &'tcx hir::Generics<'tcx>) {\n         lint_callback!(self, check_generics, g);\n         hir_visit::walk_generics(self, g);\n     }\n \n-    fn visit_where_predicate(&mut self, p: &'tcx hir::WherePredicate) {\n+    fn visit_where_predicate(&mut self, p: &'tcx hir::WherePredicate<'tcx>) {\n         lint_callback!(self, check_where_predicate, p);\n         hir_visit::walk_where_predicate(self, p);\n     }\n \n-    fn visit_poly_trait_ref(&mut self, t: &'tcx hir::PolyTraitRef, m: hir::TraitBoundModifier) {\n+    fn visit_poly_trait_ref(\n+        &mut self,\n+        t: &'tcx hir::PolyTraitRef<'tcx>,\n+        m: hir::TraitBoundModifier,\n+    ) {\n         lint_callback!(self, check_poly_trait_ref, t, m);\n         hir_visit::walk_poly_trait_ref(self, t, m);\n     }\n@@ -1089,7 +1093,7 @@ impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n         hir_visit::walk_lifetime(self, lt);\n     }\n \n-    fn visit_path(&mut self, p: &'tcx hir::Path, id: hir::HirId) {\n+    fn visit_path(&mut self, p: &'tcx hir::Path<'tcx>, id: hir::HirId) {\n         lint_callback!(self, check_path, p, id);\n         hir_visit::walk_path(self, p);\n     }"}, {"sha": "bd75eda1879b19b35d78efbba5d554aa89e9ca0a", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -76,7 +76,7 @@ declare_lint_pass!(TyTyKind => [\n ]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n-    fn check_path(&mut self, cx: &LateContext<'_, '_>, path: &'tcx Path, _: HirId) {\n+    fn check_path(&mut self, cx: &LateContext<'_, '_>, path: &'tcx Path<'tcx>, _: HirId) {\n         let segments = path.segments.iter().rev().skip(1).rev();\n \n         if let Some(last) = segments.last() {\n@@ -94,7 +94,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n         }\n     }\n \n-    fn check_ty(&mut self, cx: &LateContext<'_, '_>, ty: &'tcx Ty) {\n+    fn check_ty(&mut self, cx: &LateContext<'_, '_>, ty: &'tcx Ty<'tcx>) {\n         match &ty.kind {\n             TyKind::Path(qpath) => {\n                 if let QPath::Resolved(_, path) = qpath {\n@@ -159,7 +159,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n     }\n }\n \n-fn lint_ty_kind_usage(cx: &LateContext<'_, '_>, segment: &PathSegment) -> bool {\n+fn lint_ty_kind_usage(cx: &LateContext<'_, '_>, segment: &PathSegment<'_>) -> bool {\n     if let Some(res) = segment.res {\n         if let Some(did) = res.opt_def_id() {\n             return cx.tcx.is_diagnostic_item(sym::TyKind, did);\n@@ -169,7 +169,7 @@ fn lint_ty_kind_usage(cx: &LateContext<'_, '_>, segment: &PathSegment) -> bool {\n     false\n }\n \n-fn is_ty_or_ty_ctxt(cx: &LateContext<'_, '_>, ty: &Ty) -> Option<String> {\n+fn is_ty_or_ty_ctxt(cx: &LateContext<'_, '_>, ty: &Ty<'_>) -> Option<String> {\n     match &ty.kind {\n         TyKind::Path(qpath) => {\n             if let QPath::Resolved(_, path) = qpath {\n@@ -187,7 +187,7 @@ fn is_ty_or_ty_ctxt(cx: &LateContext<'_, '_>, ty: &Ty) -> Option<String> {\n     None\n }\n \n-fn gen_args(segment: &PathSegment) -> String {\n+fn gen_args(segment: &PathSegment<'_>) -> String {\n     if let Some(args) = &segment.args {\n         let lifetimes = args\n             .args"}, {"sha": "f4684bd52224f1a6a73662609dfe275f8a79c4d5", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -107,20 +107,20 @@ macro_rules! late_lint_methods {\n             fn check_pat(a: &$hir hir::Pat<$hir>);\n             fn check_expr(a: &$hir hir::Expr<$hir>);\n             fn check_expr_post(a: &$hir hir::Expr<$hir>);\n-            fn check_ty(a: &$hir hir::Ty);\n-            fn check_generic_param(a: &$hir hir::GenericParam);\n-            fn check_generics(a: &$hir hir::Generics);\n-            fn check_where_predicate(a: &$hir hir::WherePredicate);\n-            fn check_poly_trait_ref(a: &$hir hir::PolyTraitRef, b: hir::TraitBoundModifier);\n+            fn check_ty(a: &$hir hir::Ty<$hir>);\n+            fn check_generic_param(a: &$hir hir::GenericParam<$hir>);\n+            fn check_generics(a: &$hir hir::Generics<$hir>);\n+            fn check_where_predicate(a: &$hir hir::WherePredicate<$hir>);\n+            fn check_poly_trait_ref(a: &$hir hir::PolyTraitRef<$hir>, b: hir::TraitBoundModifier);\n             fn check_fn(\n                 a: hir::intravisit::FnKind<$hir>,\n-                b: &$hir hir::FnDecl,\n+                b: &$hir hir::FnDecl<$hir>,\n                 c: &$hir hir::Body<$hir>,\n                 d: Span,\n                 e: hir::HirId);\n             fn check_fn_post(\n                 a: hir::intravisit::FnKind<$hir>,\n-                b: &$hir hir::FnDecl,\n+                b: &$hir hir::FnDecl<$hir>,\n                 c: &$hir hir::Body<$hir>,\n                 d: Span,\n                 e: hir::HirId\n@@ -135,7 +135,7 @@ macro_rules! late_lint_methods {\n             fn check_variant(a: &$hir hir::Variant<$hir>);\n             fn check_variant_post(a: &$hir hir::Variant<$hir>);\n             fn check_lifetime(a: &$hir hir::Lifetime);\n-            fn check_path(a: &$hir hir::Path, b: hir::HirId);\n+            fn check_path(a: &$hir hir::Path<$hir>, b: hir::HirId);\n             fn check_attribute(a: &$hir ast::Attribute);\n \n             /// Called when entering a syntax node that can have lint attributes such\n@@ -643,7 +643,7 @@ impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n     fn visit_variant(\n         &mut self,\n         v: &'tcx hir::Variant<'tcx>,\n-        g: &'tcx hir::Generics,\n+        g: &'tcx hir::Generics<'tcx>,\n         item_id: hir::HirId,\n     ) {\n         self.with_lint_attrs(v.id, &v.attrs, |builder| {"}, {"sha": "82f19478b94e664fc31321e91d7873d658568abc", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 41, "deletions": 28, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -44,7 +44,7 @@ pub enum LifetimeDefOrigin {\n }\n \n impl LifetimeDefOrigin {\n-    fn from_param(param: &GenericParam) -> Self {\n+    fn from_param(param: &GenericParam<'_>) -> Self {\n         match param.kind {\n             GenericParamKind::Lifetime { kind } => match kind {\n                 LifetimeParamKind::InBand => LifetimeDefOrigin::InBand,\n@@ -74,7 +74,7 @@ pub enum Region {\n }\n \n impl Region {\n-    fn early(hir_map: &Map<'_>, index: &mut u32, param: &GenericParam) -> (ParamName, Region) {\n+    fn early(hir_map: &Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (ParamName, Region) {\n         let i = *index;\n         *index += 1;\n         let def_id = hir_map.local_def_id(param.hir_id);\n@@ -83,7 +83,7 @@ impl Region {\n         (param.name.modern(), Region::EarlyBound(i, def_id, origin))\n     }\n \n-    fn late(hir_map: &Map<'_>, param: &GenericParam) -> (ParamName, Region) {\n+    fn late(hir_map: &Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region) {\n         let depth = ty::INNERMOST;\n         let def_id = hir_map.local_def_id(param.hir_id);\n         let origin = LifetimeDefOrigin::from_param(param);\n@@ -517,7 +517,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n         debug!(\"visit_ty: id={:?} ty={:?}\", ty.hir_id, ty);\n         debug!(\"visit_ty: ty.kind={:?}\", ty.kind);\n         match ty.kind {\n@@ -881,7 +881,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         self.resolve_lifetime_ref(lifetime_ref);\n     }\n \n-    fn visit_path(&mut self, path: &'tcx hir::Path, _: hir::HirId) {\n+    fn visit_path(&mut self, path: &'tcx hir::Path<'tcx>, _: hir::HirId) {\n         for (i, segment) in path.segments.iter().enumerate() {\n             let depth = path.segments.len() - i - 1;\n             if let Some(ref args) = segment.args {\n@@ -890,15 +890,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_fn_decl(&mut self, fd: &'tcx hir::FnDecl) {\n+    fn visit_fn_decl(&mut self, fd: &'tcx hir::FnDecl<'tcx>) {\n         let output = match fd.output {\n             hir::DefaultReturn(_) => None,\n             hir::Return(ref ty) => Some(&**ty),\n         };\n         self.visit_fn_like_elision(&fd.inputs, output);\n     }\n \n-    fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n+    fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n         check_mixed_explicit_and_in_band_defs(self.tcx, &generics.params);\n         for param in &generics.params {\n             match param.kind {\n@@ -976,7 +976,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_poly_trait_ref(\n         &mut self,\n-        trait_ref: &'tcx hir::PolyTraitRef,\n+        trait_ref: &'tcx hir::PolyTraitRef<'tcx>,\n         _modifier: hir::TraitBoundModifier,\n     ) {\n         debug!(\"visit_poly_trait_ref(trait_ref={:?})\", trait_ref);\n@@ -1046,7 +1046,7 @@ fn shadower_label(span: Span) -> Shadower {\n fn original_lifetime(span: Span) -> Original {\n     Original { kind: ShadowKind::Lifetime, span: span }\n }\n-fn shadower_lifetime(param: &hir::GenericParam) -> Shadower {\n+fn shadower_lifetime(param: &hir::GenericParam<'_>) -> Shadower {\n     Shadower { kind: ShadowKind::Lifetime, span: param.span }\n }\n \n@@ -1059,7 +1059,7 @@ impl ShadowKind {\n     }\n }\n \n-fn check_mixed_explicit_and_in_band_defs(tcx: TyCtxt<'_>, params: &P<[hir::GenericParam]>) {\n+fn check_mixed_explicit_and_in_band_defs(tcx: TyCtxt<'_>, params: &P<[hir::GenericParam<'_>]>) {\n     let lifetime_params: Vec<_> = params\n         .iter()\n         .filter_map(|param| match param.kind {\n@@ -1252,9 +1252,9 @@ fn compute_object_lifetime_defaults(tcx: TyCtxt<'_>) -> HirIdMap<Vec<ObjectLifet\n /// for each type parameter.\n fn object_lifetime_defaults_for_item(\n     tcx: TyCtxt<'_>,\n-    generics: &hir::Generics,\n+    generics: &hir::Generics<'_>,\n ) -> Vec<ObjectLifetimeDefault> {\n-    fn add_bounds(set: &mut Set1<hir::LifetimeName>, bounds: &[hir::GenericBound]) {\n+    fn add_bounds(set: &mut Set1<hir::LifetimeName>, bounds: &[hir::GenericBound<'_>]) {\n         for bound in bounds {\n             if let hir::GenericBound::Outlives(ref lifetime) = *bound {\n                 set.insert(lifetime.name.modern());\n@@ -1368,7 +1368,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n     /// helper method to determine the span to remove when suggesting the\n     /// deletion of a lifetime\n-    fn lifetime_deletion_span(&self, name: ast::Ident, generics: &hir::Generics) -> Option<Span> {\n+    fn lifetime_deletion_span(\n+        &self,\n+        name: ast::Ident,\n+        generics: &hir::Generics<'_>,\n+    ) -> Option<Span> {\n         generics.params.iter().enumerate().find_map(|(i, param)| {\n             if param.name.ident() == name {\n                 let mut in_band = false;\n@@ -1417,7 +1421,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let mut remove_use = None;\n         let mut elide_use = None;\n-        let mut find_arg_use_span = |inputs: &hir::HirVec<hir::Ty>| {\n+        let mut find_arg_use_span = |inputs: &hir::HirVec<hir::Ty<'_>>| {\n             for input in inputs {\n                 match input.kind {\n                     hir::TyKind::Rptr(lt, _) => {\n@@ -1656,8 +1660,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn visit_early_late<F>(\n         &mut self,\n         parent_id: Option<hir::HirId>,\n-        decl: &'tcx hir::FnDecl,\n-        generics: &'tcx hir::Generics,\n+        decl: &'tcx hir::FnDecl<'tcx>,\n+        generics: &'tcx hir::Generics<'tcx>,\n         walk: F,\n     ) where\n         F: for<'b, 'c> FnOnce(&'b mut LifetimeContext<'c, 'tcx>),\n@@ -1854,7 +1858,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_segment_args(&mut self, res: Res, depth: usize, generic_args: &'tcx hir::GenericArgs) {\n+    fn visit_segment_args(\n+        &mut self,\n+        res: Res,\n+        depth: usize,\n+        generic_args: &'tcx hir::GenericArgs<'tcx>,\n+    ) {\n         debug!(\n             \"visit_segment_args(res={:?}, depth={:?}, generic_args={:?})\",\n             res, depth, generic_args,\n@@ -2045,7 +2054,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_fn_like_elision(&mut self, inputs: &'tcx [hir::Ty], output: Option<&'tcx hir::Ty>) {\n+    fn visit_fn_like_elision(\n+        &mut self,\n+        inputs: &'tcx [hir::Ty<'tcx>],\n+        output: Option<&'tcx hir::Ty<'tcx>>,\n+    ) {\n         debug!(\"visit_fn_like_elision: enter\");\n         let mut arg_elide = Elide::FreshLateAnon(Cell::new(0));\n         let arg_scope = Scope::Elision { elide: arg_elide.clone(), s: self.scope };\n@@ -2125,7 +2138,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         if has_self {\n             struct SelfVisitor<'a> {\n                 map: &'a NamedRegionMap,\n-                impl_self: Option<&'a hir::TyKind>,\n+                impl_self: Option<&'a hir::TyKind<'a>>,\n                 lifetime: Set1<Region>,\n             }\n \n@@ -2163,7 +2176,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     NestedVisitorMap::None\n                 }\n \n-                fn visit_ty(&mut self, ty: &'a hir::Ty) {\n+                fn visit_ty(&mut self, ty: &'a hir::Ty<'a>) {\n                     if let hir::TyKind::Rptr(lifetime_ref, ref mt) = ty.kind {\n                         if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = mt.ty.kind\n                         {\n@@ -2251,7 +2264,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 NestedVisitorMap::None\n             }\n \n-            fn visit_ty(&mut self, ty: &hir::Ty) {\n+            fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n                 if let hir::TyKind::BareFn(_) = ty.kind {\n                     self.outer_index.shift_in(1);\n                 }\n@@ -2276,7 +2289,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n             }\n \n-            fn visit_generic_param(&mut self, param: &hir::GenericParam) {\n+            fn visit_generic_param(&mut self, param: &hir::GenericParam<'_>) {\n                 if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n                     // FIXME(eddyb) Do we want this? It only makes a difference\n                     // if this `for<'a>` lifetime parameter is never used.\n@@ -2288,7 +2301,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             fn visit_poly_trait_ref(\n                 &mut self,\n-                trait_ref: &hir::PolyTraitRef,\n+                trait_ref: &hir::PolyTraitRef<'_>,\n                 modifier: hir::TraitBoundModifier,\n             ) {\n                 self.outer_index.shift_in(1);\n@@ -2523,7 +2536,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn check_lifetime_params(\n         &mut self,\n         old_scope: ScopeRef<'_>,\n-        params: &'tcx [hir::GenericParam],\n+        params: &'tcx [hir::GenericParam<'tcx>],\n     ) {\n         let lifetimes: Vec<_> = params\n             .iter()\n@@ -2617,7 +2630,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn check_lifetime_param_for_shadowing(\n         &self,\n         mut old_scope: ScopeRef<'_>,\n-        param: &'tcx hir::GenericParam,\n+        param: &'tcx hir::GenericParam<'tcx>,\n     ) {\n         for label in &self.labels_in_fn {\n             // FIXME (#24278): non-hygienic comparison\n@@ -2755,8 +2768,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n /// T as Trait<''b>>::Foo` does not constrain `'a` or `'b`.\n fn insert_late_bound_lifetimes(\n     map: &mut NamedRegionMap,\n-    decl: &hir::FnDecl,\n-    generics: &hir::Generics,\n+    decl: &hir::FnDecl<'_>,\n+    generics: &hir::Generics<'_>,\n ) {\n     debug!(\"insert_late_bound_lifetimes(decl={:?}, generics={:?})\", decl, generics);\n \n@@ -2840,7 +2853,7 @@ fn insert_late_bound_lifetimes(\n             NestedVisitorMap::None\n         }\n \n-        fn visit_ty(&mut self, ty: &'v hir::Ty) {\n+        fn visit_ty(&mut self, ty: &'v hir::Ty<'v>) {\n             match ty.kind {\n                 hir::TyKind::Path(hir::QPath::Resolved(Some(_), _))\n                 | hir::TyKind::Path(hir::QPath::TypeRelative(..)) => {"}, {"sha": "b692459eb517f2dd707fc5ceebb73b8e6f74c68f", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -306,7 +306,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         });\n     }\n \n-    fn visit_variant(&mut self, var: &'tcx Variant<'tcx>, g: &'tcx Generics, item_id: HirId) {\n+    fn visit_variant(&mut self, var: &'tcx Variant<'tcx>, g: &'tcx Generics<'tcx>, item_id: HirId) {\n         self.annotate(var.id, &var.attrs, var.span, AnnotationKind::Required, |v| {\n             if let Some(ctor_hir_id) = var.data.ctor_hir_id() {\n                 v.annotate(ctor_hir_id, &var.attrs, var.span, AnnotationKind::Required, |_| {});\n@@ -381,7 +381,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n         intravisit::walk_impl_item(self, ii);\n     }\n \n-    fn visit_variant(&mut self, var: &'tcx Variant<'tcx>, g: &'tcx Generics, item_id: HirId) {\n+    fn visit_variant(&mut self, var: &'tcx Variant<'tcx>, g: &'tcx Generics<'tcx>, item_id: HirId) {\n         self.check_missing_stability(var.id, var.span, \"variant\");\n         intravisit::walk_variant(self, var, g, item_id);\n     }\n@@ -886,7 +886,7 @@ impl Visitor<'tcx> for Checker<'tcx> {\n         intravisit::walk_item(self, item);\n     }\n \n-    fn visit_path(&mut self, path: &'tcx hir::Path, id: hir::HirId) {\n+    fn visit_path(&mut self, path: &'tcx hir::Path<'tcx>, id: hir::HirId) {\n         if let Some(def_id) = path.res.opt_def_id() {\n             self.tcx.check_stability(def_id, Some(id), path.span)\n         }"}, {"sha": "878675f981259069f6694dfcc91dc87475310e28", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -1154,7 +1154,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         };\n \n         let suggest_restriction =\n-            |generics: &hir::Generics, msg, err: &mut DiagnosticBuilder<'_>| {\n+            |generics: &hir::Generics<'_>, msg, err: &mut DiagnosticBuilder<'_>| {\n                 let span = generics.where_clause.span_for_predicates_or_empty_place();\n                 if !span.from_expansion() && span.desugaring_kind().is_none() {\n                     err.span_suggestion(\n@@ -2851,7 +2851,7 @@ impl ArgKind {\n \n /// Suggest restricting a type param with a new bound.\n pub fn suggest_constraining_type_param(\n-    generics: &hir::Generics,\n+    generics: &hir::Generics<'_>,\n     err: &mut DiagnosticBuilder<'_>,\n     param_name: &str,\n     constraint: &str,"}, {"sha": "d92fd34d7e4c515b961fe6b5ca50158aa8a966cd", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -464,7 +464,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n \n     /// Returns the final resolution of a `QPath` in an `Expr` or `Pat` node.\n-    pub fn qpath_res(&self, qpath: &hir::QPath, id: hir::HirId) -> Res {\n+    pub fn qpath_res(&self, qpath: &hir::QPath<'_>, id: hir::HirId) -> Res {\n         match *qpath {\n             hir::QPath::Resolved(_, ref path) => path.res,\n             hir::QPath::TypeRelative(..) => self"}, {"sha": "2c40c9dc9efbbb7a51df7e4d5b6f605f6a1a78fb", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -298,7 +298,7 @@ impl<'tcx> DefIdTree for TyCtxt<'tcx> {\n }\n \n impl Visibility {\n-    pub fn from_hir(visibility: &hir::Visibility, id: hir::HirId, tcx: TyCtxt<'_>) -> Self {\n+    pub fn from_hir(visibility: &hir::Visibility<'_>, id: hir::HirId, tcx: TyCtxt<'_>) -> Self {\n         match visibility.node {\n             hir::VisibilityKind::Public => Visibility::Public,\n             hir::VisibilityKind::Crate(_) => Visibility::Restricted(DefId::local(CRATE_DEF_INDEX)),\n@@ -2757,7 +2757,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     fn associated_item_from_trait_item_ref(\n         self,\n         parent_def_id: DefId,\n-        parent_vis: &hir::Visibility,\n+        parent_vis: &hir::Visibility<'_>,\n         trait_item_ref: &hir::TraitItemRef,\n     ) -> AssocItem {\n         let def_id = self.hir().local_def_id(trait_item_ref.id.hir_id);\n@@ -2783,7 +2783,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     fn associated_item_from_impl_item_ref(\n         self,\n         parent_def_id: DefId,\n-        impl_item_ref: &hir::ImplItemRef,\n+        impl_item_ref: &hir::ImplItemRef<'_>,\n     ) -> AssocItem {\n         let def_id = self.hir().local_def_id(impl_item_ref.id.hir_id);\n         let (kind, has_self) = match impl_item_ref.kind {"}, {"sha": "afd1b690232e78ebd6e2261ae969fdd8544bbaaa", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=6b87d5cdf1f60b14140b9c68c2ecb05f1a61e651", "patch": "@@ -694,7 +694,7 @@ pub fn object_region_bounds<'tcx>(\n \n /// Find the span of a generic bound affecting an associated type.\n fn get_generic_bound_spans(\n-    generics: &hir::Generics,\n+    generics: &hir::Generics<'_>,\n     trait_name: Option<&Ident>,\n     assoc_item_name: Ident,\n ) -> Vec<Span> {\n@@ -729,7 +729,7 @@ fn get_generic_bound_spans(\n     bounds\n }\n \n-fn is_self_path(kind: &hir::TyKind) -> bool {\n+fn is_self_path(kind: &hir::TyKind<'_>) -> bool {\n     match kind {\n         hir::TyKind::Path(hir::QPath::Resolved(None, path)) => {\n             let mut s = path.segments.iter();"}]}