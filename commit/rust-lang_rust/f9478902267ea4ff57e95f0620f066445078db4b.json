{"sha": "f9478902267ea4ff57e95f0620f066445078db4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5NDc4OTAyMjY3ZWE0ZmY1N2U5NWYwNjIwZjA2NjQ0NTA3OGRiNGI=", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-12-31T00:51:25Z"}, "committer": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2017-01-03T07:54:23Z"}, "message": "Change file structure, add comments for inhabitedness.rs", "tree": {"sha": "88ae93ffa5880c3a687d04dc50d9643b82947784", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88ae93ffa5880c3a687d04dc50d9643b82947784"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9478902267ea4ff57e95f0620f066445078db4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9478902267ea4ff57e95f0620f066445078db4b", "html_url": "https://github.com/rust-lang/rust/commit/f9478902267ea4ff57e95f0620f066445078db4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9478902267ea4ff57e95f0620f066445078db4b/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9ffc409bc7a8a8b11c326136209d720671a8dcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9ffc409bc7a8a8b11c326136209d720671a8dcd", "html_url": "https://github.com/rust-lang/rust/commit/e9ffc409bc7a8a8b11c326136209d720671a8dcd"}], "stats": {"total": 345, "additions": 222, "deletions": 123}, "files": [{"sha": "16bc65603f1353188b082cf02114d4f45fef31ee", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/f9478902267ea4ff57e95f0620f066445078db4b/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9478902267ea4ff57e95f0620f066445078db4b/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=f9478902267ea4ff57e95f0620f066445078db4b", "patch": "@@ -0,0 +1,133 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem;\n+use rustc_data_structures::small_vec::SmallVec;\n+use syntax::ast::CRATE_NODE_ID;\n+use ty::context::TyCtxt;\n+use ty::{DefId, DefIdTree};\n+\n+/// Represents a forest of DefIds closed under the ancestor relation. That is,\n+/// if a DefId representing a module is contained in the forest then all\n+/// DefIds defined in that module or submodules are also implicitly contained\n+/// in the forest.\n+///\n+/// This is used to represent a set of modules in which a type is visibly\n+/// uninhabited.\n+#[derive(Clone)]\n+pub struct DefIdForest {\n+    /// The minimal set of DefIds required to represent the whole set.\n+    /// If A and B are DefIds in the DefIdForest, and A is a desecendant\n+    /// of B, then only B will be in root_ids.\n+    /// We use a SmallVec here because (for its use for cacheing inhabitedness)\n+    /// its rare that this will contain even two ids.\n+    root_ids: SmallVec<[DefId; 1]>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> DefIdForest {\n+    /// Create an empty forest.\n+    pub fn empty() -> DefIdForest {\n+        DefIdForest {\n+            root_ids: SmallVec::new(),\n+        }\n+    }\n+\n+    /// Create a forest consisting of a single tree representing the entire\n+    /// crate.\n+    #[inline]\n+    pub fn full(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest {\n+        let crate_id = tcx.map.local_def_id(CRATE_NODE_ID);\n+        DefIdForest::from_id(crate_id)\n+    }\n+\n+    /// Create a forest containing a DefId and all its descendants.\n+    pub fn from_id(id: DefId) -> DefIdForest {\n+        let mut root_ids = SmallVec::new();\n+        root_ids.push(id);\n+        DefIdForest {\n+            root_ids: root_ids,\n+        }\n+    }\n+\n+    /// Test whether the forest is empty.\n+    pub fn is_empty(&self) -> bool {\n+        self.root_ids.is_empty()\n+    }\n+\n+    /// Test whether the forest conains a given DefId.\n+    pub fn contains(&self,\n+                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                    id: DefId) -> bool\n+    {\n+        for root_id in self.root_ids.iter() {\n+            if tcx.is_descendant_of(id, *root_id) {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n+    /// Calculate the intersection of a collection of forests.\n+    pub fn intersection<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                           iter: I) -> DefIdForest\n+            where I: IntoIterator<Item=DefIdForest>\n+    {\n+        let mut ret = DefIdForest::full(tcx);\n+        let mut next_ret = SmallVec::new();\n+        let mut old_ret: SmallVec<[DefId; 1]> = SmallVec::new();\n+        for next_forest in iter {\n+            for id in ret.root_ids.drain(..) {\n+                if next_forest.contains(tcx, id) {\n+                    next_ret.push(id);\n+                } else {\n+                    old_ret.push(id);\n+                }\n+            }\n+            ret.root_ids.extend(old_ret.drain(..));\n+\n+            for id in next_forest.root_ids {\n+                if ret.contains(tcx, id) {\n+                    next_ret.push(id);\n+                }\n+            }\n+\n+            mem::swap(&mut next_ret, &mut ret.root_ids);\n+            next_ret.drain(..);\n+        }\n+        ret\n+    }\n+\n+    /// Calculate the union of a collection of forests.\n+    pub fn union<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                    iter: I) -> DefIdForest\n+            where I: IntoIterator<Item=DefIdForest>\n+    {\n+        let mut ret = DefIdForest::empty();\n+        let mut next_ret = SmallVec::new();\n+        for next_forest in iter {\n+            for id in ret.root_ids.drain(..) {\n+                if !next_forest.contains(tcx, id) {\n+                    next_ret.push(id);\n+                }\n+            }\n+\n+            for id in next_forest.root_ids {\n+                if !next_ret.contains(&id) {\n+                    next_ret.push(id);\n+                }\n+            }\n+\n+            mem::swap(&mut next_ret, &mut ret.root_ids);\n+            next_ret.drain(..);\n+        }\n+        ret\n+    }\n+}\n+"}, {"sha": "1cc31b20ba95df204a7d1a30f2ca7ae8de1de4dc", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "renamed", "additions": 48, "deletions": 113, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/f9478902267ea4ff57e95f0620f066445078db4b/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9478902267ea4ff57e95f0620f066445078db4b/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=f9478902267ea4ff57e95f0620f066445078db4b", "patch": "@@ -8,127 +8,59 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::mem;\n-use rustc_data_structures::small_vec::SmallVec;\n-use syntax::ast::CRATE_NODE_ID;\n use util::nodemap::FxHashSet;\n use ty::context::TyCtxt;\n use ty::{AdtDef, VariantDef, FieldDef, TyS};\n use ty::{DefId, Substs};\n-use ty::{AdtKind, Visibility, DefIdTree};\n+use ty::{AdtKind, Visibility};\n use ty::TypeVariants::*;\n \n-/// Represents a set of DefIds closed under the ancestor relation. That is, if\n-/// a DefId is in this set then so are all its descendants.\n-#[derive(Clone)]\n-pub struct DefIdForest {\n-    /// The minimal set of DefIds required to represent the whole set.\n-    /// If A and B are DefIds in the DefIdForest, and A is a desecendant\n-    /// of B, then only B will be in root_ids.\n-    /// We use a SmallVec here because (for its use in this module) its rare\n-    /// that this will contain even two ids.\n-    root_ids: SmallVec<[DefId; 1]>,\n-}\n-\n-impl<'a, 'gcx, 'tcx> DefIdForest {\n-    /// Create an empty forest.\n-    pub fn empty() -> DefIdForest {\n-        DefIdForest {\n-            root_ids: SmallVec::new(),\n-        }\n-    }\n-\n-    /// Create a forest consisting of a single tree representing the entire\n-    /// crate.\n-    #[inline]\n-    pub fn full(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest {\n-        let crate_id = tcx.map.local_def_id(CRATE_NODE_ID);\n-        DefIdForest::from_id(crate_id)\n-    }\n-\n-    /// Create a forest containing a DefId and all its descendants.\n-    pub fn from_id(id: DefId) -> DefIdForest {\n-        let mut root_ids = SmallVec::new();\n-        root_ids.push(id);\n-        DefIdForest {\n-            root_ids: root_ids,\n-        }\n-    }\n-\n-    /// Test whether the forest is empty.\n-    pub fn is_empty(&self) -> bool {\n-        self.root_ids.is_empty()\n-    }\n-\n-    /// Test whether the forest conains a given DefId.\n-    pub fn contains(&self,\n-                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                    id: DefId) -> bool\n-    {\n-        for root_id in self.root_ids.iter() {\n-            if tcx.is_descendant_of(id, *root_id) {\n-                return true;\n-            }\n-        }\n-        false\n-    }\n-\n-    /// Calculate the intersection of a collection of forests.\n-    pub fn intersection<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                           iter: I) -> DefIdForest\n-            where I: IntoIterator<Item=DefIdForest>\n-    {\n-        let mut ret = DefIdForest::full(tcx);\n-        let mut next_ret = SmallVec::new();\n-        let mut old_ret: SmallVec<[DefId; 1]> = SmallVec::new();\n-        for next_forest in iter {\n-            for id in ret.root_ids.drain(..) {\n-                if next_forest.contains(tcx, id) {\n-                    next_ret.push(id);\n-                } else {\n-                    old_ret.push(id);\n-                }\n-            }\n-            ret.root_ids.extend(old_ret.drain(..));\n+pub use self::def_id_forest::DefIdForest;\n \n-            for id in next_forest.root_ids {\n-                if ret.contains(tcx, id) {\n-                    next_ret.push(id);\n-                }\n-            }\n-\n-            mem::swap(&mut next_ret, &mut ret.root_ids);\n-            next_ret.drain(..);\n-        }\n-        ret\n-    }\n+mod def_id_forest;\n \n-    /// Calculate the union of a collection of forests.\n-    pub fn union<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                    iter: I) -> DefIdForest\n-            where I: IntoIterator<Item=DefIdForest>\n-    {\n-        let mut ret = DefIdForest::empty();\n-        let mut next_ret = SmallVec::new();\n-        for next_forest in iter {\n-            for id in ret.root_ids.drain(..) {\n-                if !next_forest.contains(tcx, id) {\n-                    next_ret.push(id);\n-                }\n-            }\n-\n-            for id in next_forest.root_ids {\n-                if !next_ret.contains(&id) {\n-                    next_ret.push(id);\n-                }\n-            }\n-\n-            mem::swap(&mut next_ret, &mut ret.root_ids);\n-            next_ret.drain(..);\n-        }\n-        ret\n-    }\n-}\n+// The methods in this module calculate DefIdForests of modules in which a\n+// AdtDef/VariantDef/FieldDef is visibly uninhabited.\n+//\n+// # Example\n+// ```rust\n+// enum Void {}\n+// mod a {\n+//     pub mod b {\n+//         pub struct SecretlyUninhabited {\n+//             _priv: !,\n+//         }\n+//     }\n+// }\n+//\n+// mod c {\n+//     pub struct AlsoSecretlyUninhabited {\n+//         _priv: Void,\n+//     }\n+//     mod d {\n+//     }\n+// }\n+//\n+// struct Foo {\n+//     x: a::b::SecretlyUninhabited,\n+//     y: c::AlsoSecretlyUninhabited,\n+// }\n+// ```\n+// In this code, the type Foo will only be visibly uninhabited inside the\n+// modules b, c and d. Calling uninhabited_from on Foo or its AdtDef will\n+// return the forest of modules {b, c->d} (represented in a DefIdForest by the\n+// set {b, c})\n+//\n+// We need this information for pattern-matching on Foo or types that contain\n+// Foo.\n+// \n+// # Example\n+// ```rust\n+// let foo_result: Result<T, Foo> = ... ;\n+// let Ok(t) = foo_result;\n+// ```\n+// This code should only compile in modules where the uninhabitedness of Foo is\n+// visible.\n \n impl<'a, 'gcx, 'tcx> AdtDef {\n     /// Calculate the forest of DefIds from which this adt is visibly uninhabited.\n@@ -189,6 +121,9 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n                 is_enum: bool) -> DefIdForest\n     {\n         let mut data_uninhabitedness = move || self.ty(tcx, substs).uninhabited_from(visited, tcx);\n+        // FIXME(canndrew): Currently enum fields are (incorrectly) stored with\n+        // Visibility::Invisible so we need to override self.vis if we're\n+        // dealing with an enum.\n         if is_enum {\n             data_uninhabitedness()\n         } else {", "previous_filename": "src/librustc/ty/inhabitedness.rs"}, {"sha": "319b11d8031e9823906fe0a536dfed197f81b9b9", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f9478902267ea4ff57e95f0620f066445078db4b/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9478902267ea4ff57e95f0620f066445078db4b/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=f9478902267ea4ff57e95f0620f066445078db4b", "patch": "@@ -980,20 +980,51 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     }\n \n     /// Checks whether a type is visibly uninhabited from a particular module.\n+    /// # Example\n+    /// ```rust\n+    /// enum Void {}\n+    /// mod a {\n+    ///     pub mod b {\n+    ///         pub struct SecretlyUninhabited {\n+    ///             _priv: !,\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// mod c {\n+    ///     pub struct AlsoSecretlyUninhabited {\n+    ///         _priv: Void,\n+    ///     }\n+    ///     mod d {\n+    ///     }\n+    /// }\n+    ///\n+    /// struct Foo {\n+    ///     x: a::b::SecretlyUninhabited,\n+    ///     y: c::AlsoSecretlyUninhabited,\n+    /// }\n+    /// ```\n+    /// In this code, the type `Foo` will only be visibly uninhabited inside the\n+    /// modules b, c and d. This effects pattern-matching on `Foo` or types that\n+    /// contain `Foo`.\n+    /// \n+    /// # Example\n+    /// ```rust\n+    /// let foo_result: Result<T, Foo> = ... ;\n+    /// let Ok(t) = foo_result;\n+    /// ```\n+    /// This code should only compile in modules where the uninhabitedness of Foo is\n+    /// visible.\n     pub fn is_uninhabited_from(&self, module: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n         let mut visited = FxHashSet::default();\n         let forest = self.uninhabited_from(&mut visited, tcx);\n-        forest.contains(tcx, module)\n-    }\n \n-    /// Checks whether a type is uninhabited.\n-    /// Note: just because a type is uninhabited, that doesn't mean that it's\n-    /// *visibly* uninhabited outside its module. You sometimes may want\n-    /// `is_uninhabited_from` instead.\n-    pub fn is_uninhabited_anywhere(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n-        let mut visited = FxHashSet::default();\n-        let node_set = self.uninhabited_from(&mut visited, tcx);\n-        !node_set.is_empty()\n+        // To check whether this type is uninhabited at all (not just from the\n+        // given node) you could check whether the forest is empty.\n+        // ```\n+        // forest.is_empty()\n+        // ```\n+        forest.contains(tcx, module)\n     }\n \n     pub fn is_primitive(&self) -> bool {"}]}