{"sha": "fba2f883f39332f43d9cd8f69ebc720076e64e0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYTJmODgzZjM5MzMyZjQzZDljZDhmNjllYmM3MjAwNzZlNjRlMGQ=", "commit": {"author": {"name": "Kevin Per", "email": "kevin.per@protonmail.com", "date": "2021-02-10T15:49:23Z"}, "committer": {"name": "Kevin Per", "email": "kevin.per@protonmail.com", "date": "2021-02-12T09:18:03Z"}, "message": "Implementing more sophisticated filter for fn in const or static", "tree": {"sha": "4f39fbe2b1fc09643d04c2ceba87cf617154587b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f39fbe2b1fc09643d04c2ceba87cf617154587b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fba2f883f39332f43d9cd8f69ebc720076e64e0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fba2f883f39332f43d9cd8f69ebc720076e64e0d", "html_url": "https://github.com/rust-lang/rust/commit/fba2f883f39332f43d9cd8f69ebc720076e64e0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fba2f883f39332f43d9cd8f69ebc720076e64e0d/comments", "author": {"login": "kper", "id": 10795807, "node_id": "MDQ6VXNlcjEwNzk1ODA3", "avatar_url": "https://avatars.githubusercontent.com/u/10795807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kper", "html_url": "https://github.com/kper", "followers_url": "https://api.github.com/users/kper/followers", "following_url": "https://api.github.com/users/kper/following{/other_user}", "gists_url": "https://api.github.com/users/kper/gists{/gist_id}", "starred_url": "https://api.github.com/users/kper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kper/subscriptions", "organizations_url": "https://api.github.com/users/kper/orgs", "repos_url": "https://api.github.com/users/kper/repos", "events_url": "https://api.github.com/users/kper/events{/privacy}", "received_events_url": "https://api.github.com/users/kper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kper", "id": 10795807, "node_id": "MDQ6VXNlcjEwNzk1ODA3", "avatar_url": "https://avatars.githubusercontent.com/u/10795807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kper", "html_url": "https://github.com/kper", "followers_url": "https://api.github.com/users/kper/followers", "following_url": "https://api.github.com/users/kper/following{/other_user}", "gists_url": "https://api.github.com/users/kper/gists{/gist_id}", "starred_url": "https://api.github.com/users/kper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kper/subscriptions", "organizations_url": "https://api.github.com/users/kper/orgs", "repos_url": "https://api.github.com/users/kper/repos", "events_url": "https://api.github.com/users/kper/events{/privacy}", "received_events_url": "https://api.github.com/users/kper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49fc41f047dbb961427e1f2421e36a1cacc799dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/49fc41f047dbb961427e1f2421e36a1cacc799dd", "html_url": "https://github.com/rust-lang/rust/commit/49fc41f047dbb961427e1f2421e36a1cacc799dd"}], "stats": {"total": 76, "additions": 59, "deletions": 17}, "files": [{"sha": "120a59aa9d252134802d53a618f710fc267bca58", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fba2f883f39332f43d9cd8f69ebc720076e64e0d/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba2f883f39332f43d9cd8f69ebc720076e64e0d/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=fba2f883f39332f43d9cd8f69ebc720076e64e0d", "patch": "@@ -2145,12 +2145,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             hir::TyKind::BareFn(ref bf) => {\n                 require_c_abi_if_c_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n+\n                 tcx.mk_fn_ptr(self.ty_of_fn(\n                     bf.unsafety,\n                     bf.abi,\n                     &bf.decl,\n                     &hir::Generics::empty(),\n                     None,\n+                    Some(ast_ty),\n                 ))\n             }\n             hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n@@ -2290,6 +2292,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         decl: &hir::FnDecl<'_>,\n         generics: &hir::Generics<'_>,\n         ident_span: Option<Span>,\n+        hir_ty: Option<&hir::Ty<'_>>,\n     ) -> ty::PolyFnSig<'tcx> {\n         debug!(\"ty_of_fn\");\n \n@@ -2321,13 +2324,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             // only want to emit an error complaining about them if infer types (`_`) are not\n             // allowed. `allow_ty_infer` gates this behavior. We check for the presence of\n             // `ident_span` to not emit an error twice when we have `fn foo(_: fn() -> _)`.\n+\n             crate::collect::placeholder_type_error(\n                 tcx,\n                 ident_span.map(|sp| sp.shrink_to_hi()),\n                 &generics.params[..],\n                 visitor.0,\n                 true,\n-                true,\n+                hir_ty,\n             );\n         }\n "}, {"sha": "fce7ae8119e17a55efd888adcaae97ae87b5ee7d", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fba2f883f39332f43d9cd8f69ebc720076e64e0d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba2f883f39332f43d9cd8f69ebc720076e64e0d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=fba2f883f39332f43d9cd8f69ebc720076e64e0d", "patch": "@@ -502,6 +502,7 @@ fn typeck_with_fallback<'tcx>(\n                     decl,\n                     &hir::Generics::empty(),\n                     None,\n+                    None,\n                 )\n             } else {\n                 tcx.fn_sig(def_id)"}, {"sha": "754fc6a9c7b219dc5c5988f36e242a4c46528844", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 53, "deletions": 16, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fba2f883f39332f43d9cd8f69ebc720076e64e0d/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba2f883f39332f43d9cd8f69ebc720076e64e0d/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=fba2f883f39332f43d9cd8f69ebc720076e64e0d", "patch": "@@ -141,7 +141,7 @@ crate fn placeholder_type_error(\n     generics: &[hir::GenericParam<'_>],\n     placeholder_types: Vec<Span>,\n     suggest: bool,\n-    is_fn: bool,\n+    hir_ty: Option<&hir::Ty<'_>>,\n ) {\n     if placeholder_types.is_empty() {\n         return;\n@@ -173,13 +173,39 @@ crate fn placeholder_type_error(\n \n     let mut err = bad_placeholder_type(tcx, placeholder_types);\n \n-    // Suggest, but only if it is not a function\n-    if suggest && !is_fn {\n-        err.multipart_suggestion(\n-            \"use type parameters instead\",\n-            sugg,\n-            Applicability::HasPlaceholders,\n-        );\n+    // Suggest, but only if it is not a function in const or static\n+    if suggest {\n+        let mut is_fn = false;\n+        let mut is_const = false;\n+        let mut is_static = false;\n+\n+        if let Some(hir_ty) = hir_ty {\n+            if let hir::TyKind::BareFn(_) = hir_ty.kind {\n+                is_fn = true;\n+\n+                // Check if parent is const or static\n+                let parent_id = tcx.hir().get_parent_node(hir_ty.hir_id);\n+                let parent_node = tcx.hir().get(parent_id);\n+\n+                if let hir::Node::Item(item) = parent_node {\n+                    if let hir::ItemKind::Const(_, _) = item.kind {\n+                        is_const = true;\n+                    } else if let hir::ItemKind::Static(_, _, _) = item.kind {\n+                        is_static = true;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // if function is wrapped around a const or static,\n+        // then don't show the suggestion\n+        if !(is_fn && (is_const || is_static)) {\n+            err.multipart_suggestion(\n+                \"use type parameters instead\",\n+                sugg,\n+                Applicability::HasPlaceholders,\n+            );\n+        }\n     }\n     err.emit();\n }\n@@ -207,7 +233,7 @@ fn reject_placeholder_type_signatures_in_item(tcx: TyCtxt<'tcx>, item: &'tcx hir\n         &generics.params[..],\n         visitor.0,\n         suggest,\n-        false,\n+        None,\n     );\n }\n \n@@ -648,6 +674,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n     let it = tcx.hir().expect_item(item_id);\n     debug!(\"convert: item {} with id {}\", it.ident, it.hir_id);\n     let def_id = tcx.hir().local_def_id(item_id);\n+\n     match it.kind {\n         // These don't define types.\n         hir::ItemKind::ExternCrate(_)\n@@ -753,7 +780,7 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::HirId) {\n             // Account for `const C: _;`.\n             let mut visitor = PlaceholderHirTyCollector::default();\n             visitor.visit_trait_item(trait_item);\n-            placeholder_type_error(tcx, None, &[], visitor.0, false, false);\n+            placeholder_type_error(tcx, None, &[], visitor.0, false, None);\n         }\n \n         hir::TraitItemKind::Type(_, Some(_)) => {\n@@ -762,7 +789,7 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::HirId) {\n             // Account for `type T = _;`.\n             let mut visitor = PlaceholderHirTyCollector::default();\n             visitor.visit_trait_item(trait_item);\n-            placeholder_type_error(tcx, None, &[], visitor.0, false, false);\n+            placeholder_type_error(tcx, None, &[], visitor.0, false, None);\n         }\n \n         hir::TraitItemKind::Type(_, None) => {\n@@ -771,7 +798,8 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::HirId) {\n             // even if there is no concrete type.\n             let mut visitor = PlaceholderHirTyCollector::default();\n             visitor.visit_trait_item(trait_item);\n-            placeholder_type_error(tcx, None, &[], visitor.0, false, false);\n+\n+            placeholder_type_error(tcx, None, &[], visitor.0, false, None);\n         }\n     };\n \n@@ -792,7 +820,8 @@ fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::HirId) {\n             // Account for `type T = _;`\n             let mut visitor = PlaceholderHirTyCollector::default();\n             visitor.visit_impl_item(impl_item);\n-            placeholder_type_error(tcx, None, &[], visitor.0, false, false);\n+\n+            placeholder_type_error(tcx, None, &[], visitor.0, false, None);\n         }\n         hir::ImplItemKind::Const(..) => {}\n     }\n@@ -1583,6 +1612,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n                     &sig.decl,\n                     &generics,\n                     Some(ident.span),\n+                    None,\n                 ),\n             }\n         }\n@@ -1592,9 +1622,15 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             ident,\n             generics,\n             ..\n-        }) => {\n-            AstConv::ty_of_fn(&icx, header.unsafety, header.abi, decl, &generics, Some(ident.span))\n-        }\n+        }) => AstConv::ty_of_fn(\n+            &icx,\n+            header.unsafety,\n+            header.abi,\n+            decl,\n+            &generics,\n+            Some(ident.span),\n+            None,\n+        ),\n \n         ForeignItem(&hir::ForeignItem {\n             kind: ForeignItemKind::Fn(ref fn_decl, _, _),\n@@ -2264,6 +2300,7 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n         decl,\n         &hir::Generics::empty(),\n         Some(ident.span),\n+        None,\n     );\n \n     // Feature gate SIMD types in FFI, since I am not sure that the"}]}