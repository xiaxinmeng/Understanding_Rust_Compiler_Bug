{"sha": "8c538f7d833daa83dc07e59718cfc61ba8bdda10", "node_id": "C_kwDOAAsO6NoAKDhjNTM4ZjdkODMzZGFhODNkYzA3ZTU5NzE4Y2ZjNjFiYThiZGRhMTA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-14T12:04:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-14T12:04:26Z"}, "message": "Rollup merge of #106788 - estebank:elaborate_pred_E0599, r=compiler-errors\n\nTweak E0599 and elaborate_predicates\n\nCC https://github.com/rust-lang/rust/issues/86377.", "tree": {"sha": "d6775e435b877e9b4c607745ecc43ec31abf7a5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6775e435b877e9b4c607745ecc43ec31abf7a5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c538f7d833daa83dc07e59718cfc61ba8bdda10", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjwppKCRBK7hj4Ov3rIwAAkGQIAEfaXXQp8xN5WjuxplgJIeD4\nPXC5r07pP4F23/O9z6+aZxhT9kTxa6BwDxZfyTxTBv4TBWqCcSy42s9sIStmoaXi\nO8wfh4tXp1XYzxH0P8qYHrEFiBcajY9sIJpiH+/bD2vjYwqmJ1xw/dQf45i8IScW\nWXV8iiVJ5FBwyz0beTKv1pu+dRrSwhIwh2PabJsPEcZ0oaqp5CAWNSX8ad+iWBGG\nrqgchtYPrh/P0S9+gJMy7S5nPbFSLq096vCkuqsy9kXDM1gOYXyAydjyccijiKvl\nNkWwwPJnmPx3uem+V+kWGDX7yhY3A51Kq2+dThuzshsWdL3G7/afJgpz8jluMCw=\n=78+q\n-----END PGP SIGNATURE-----\n", "payload": "tree d6775e435b877e9b4c607745ecc43ec31abf7a5f\nparent 108b5f462b0c1845253002c3d4b615a11a844cb8\nparent 22a0e4fa6e08acf2de50ed87cfb909092ab0459d\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1673697866 +0100\ncommitter GitHub <noreply@github.com> 1673697866 +0100\n\nRollup merge of #106788 - estebank:elaborate_pred_E0599, r=compiler-errors\n\nTweak E0599 and elaborate_predicates\n\nCC https://github.com/rust-lang/rust/issues/86377.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c538f7d833daa83dc07e59718cfc61ba8bdda10", "html_url": "https://github.com/rust-lang/rust/commit/8c538f7d833daa83dc07e59718cfc61ba8bdda10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c538f7d833daa83dc07e59718cfc61ba8bdda10/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "108b5f462b0c1845253002c3d4b615a11a844cb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/108b5f462b0c1845253002c3d4b615a11a844cb8", "html_url": "https://github.com/rust-lang/rust/commit/108b5f462b0c1845253002c3d4b615a11a844cb8"}, {"sha": "22a0e4fa6e08acf2de50ed87cfb909092ab0459d", "url": "https://api.github.com/repos/rust-lang/rust/commits/22a0e4fa6e08acf2de50ed87cfb909092ab0459d", "html_url": "https://github.com/rust-lang/rust/commit/22a0e4fa6e08acf2de50ed87cfb909092ab0459d"}], "stats": {"total": 320, "additions": 296, "deletions": 24}, "files": [{"sha": "15f6e11717768cfd11ec078f0d620cc451c20897", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8c538f7d833daa83dc07e59718cfc61ba8bdda10/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c538f7d833daa83dc07e59718cfc61ba8bdda10/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=8c538f7d833daa83dc07e59718cfc61ba8bdda10", "patch": "@@ -1587,11 +1587,29 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         let o = self.resolve_vars_if_possible(o);\n                         if !self.predicate_may_hold(&o) {\n                             result = ProbeResult::NoMatch;\n-                            possibly_unsatisfied_predicates.push((\n-                                o.predicate,\n-                                None,\n-                                Some(o.cause),\n-                            ));\n+                            let parent_o = o.clone();\n+                            let implied_obligations =\n+                                traits::elaborate_obligations(self.tcx, vec![o]);\n+                            for o in implied_obligations {\n+                                let parent = if o == parent_o {\n+                                    None\n+                                } else {\n+                                    if o.predicate.to_opt_poly_trait_pred().map(|p| p.def_id())\n+                                        == self.tcx.lang_items().sized_trait()\n+                                    {\n+                                        // We don't care to talk about implicit `Sized` bounds.\n+                                        continue;\n+                                    }\n+                                    Some(parent_o.predicate)\n+                                };\n+                                if !self.predicate_may_hold(&o) {\n+                                    possibly_unsatisfied_predicates.push((\n+                                        o.predicate,\n+                                        parent,\n+                                        Some(o.cause),\n+                                    ));\n+                                }\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "f49fde04e8444f0b0ac09600d3c9ea31fad1691a", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 49, "deletions": 14, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8c538f7d833daa83dc07e59718cfc61ba8bdda10/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c538f7d833daa83dc07e59718cfc61ba8bdda10/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=8c538f7d833daa83dc07e59718cfc61ba8bdda10", "patch": "@@ -505,19 +505,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             }\n                             _ => None,\n                         };\n-                        if let Some(hir::Node::Item(hir::Item { kind, .. })) = node {\n-                            if let Some(g) = kind.generics() {\n-                                let key = (\n-                                    g.tail_span_for_predicate_suggestion(),\n-                                    g.add_where_or_trailing_comma(),\n-                                );\n-                                type_params\n-                                    .entry(key)\n-                                    .or_insert_with(FxHashSet::default)\n-                                    .insert(obligation.to_owned());\n-                            }\n+                        if let Some(hir::Node::Item(hir::Item { kind, .. })) = node\n+                            && let Some(g) = kind.generics()\n+                        {\n+                            let key = (\n+                                g.tail_span_for_predicate_suggestion(),\n+                                g.add_where_or_trailing_comma(),\n+                            );\n+                            type_params\n+                                .entry(key)\n+                                .or_insert_with(FxHashSet::default)\n+                                .insert(obligation.to_owned());\n+                            return true;\n                         }\n                     }\n+                    false\n                 };\n             let mut bound_span_label = |self_ty: Ty<'_>, obligation: &str, quiet: &str| {\n                 let msg = format!(\n@@ -692,7 +694,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             \"auto trait is invoked with no method error, but no error reported?\",\n                         );\n                     }\n-                    Some(_) => unreachable!(),\n+                    Some(Node::Item(hir::Item {\n+                        ident, kind: hir::ItemKind::Trait(..), ..\n+                    })) => {\n+                        skip_list.insert(p);\n+                        let entry = spanned_predicates.entry(ident.span);\n+                        let entry = entry.or_insert_with(|| {\n+                            (FxHashSet::default(), FxHashSet::default(), Vec::new())\n+                        });\n+                        entry.0.insert(cause.span);\n+                        entry.1.insert((ident.span, \"\"));\n+                        entry.1.insert((cause.span, \"unsatisfied trait bound introduced here\"));\n+                        entry.2.push(p);\n+                    }\n+                    Some(node) => unreachable!(\"encountered `{node:?}`\"),\n                     None => (),\n                 }\n             }\n@@ -719,19 +734,39 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 unsatisfied_bounds = true;\n             }\n \n+            let mut suggested_bounds = FxHashSet::default();\n             // The requirements that didn't have an `impl` span to show.\n             let mut bound_list = unsatisfied_predicates\n                 .iter()\n                 .filter_map(|(pred, parent_pred, _cause)| {\n+                    let mut suggested = false;\n                     format_pred(*pred).map(|(p, self_ty)| {\n-                        collect_type_param_suggestions(self_ty, *pred, &p);\n+                        if let Some(parent) = parent_pred && suggested_bounds.contains(parent) {\n+                            // We don't suggest `PartialEq` when we already suggest `Eq`.\n+                        } else if !suggested_bounds.contains(pred) {\n+                            if collect_type_param_suggestions(self_ty, *pred, &p) {\n+                                suggested = true;\n+                                suggested_bounds.insert(pred);\n+                            }\n+                        }\n                         (\n                             match parent_pred {\n                                 None => format!(\"`{}`\", &p),\n                                 Some(parent_pred) => match format_pred(*parent_pred) {\n                                     None => format!(\"`{}`\", &p),\n                                     Some((parent_p, _)) => {\n-                                        collect_type_param_suggestions(self_ty, *parent_pred, &p);\n+                                        if !suggested\n+                                            && !suggested_bounds.contains(pred)\n+                                            && !suggested_bounds.contains(parent_pred)\n+                                        {\n+                                            if collect_type_param_suggestions(\n+                                                self_ty,\n+                                                *parent_pred,\n+                                                &p,\n+                                            ) {\n+                                                suggested_bounds.insert(pred);\n+                                            }\n+                                        }\n                                         format!(\"`{}`\\nwhich is required by `{}`\", p, parent_p)\n                                     }\n                                 },"}, {"sha": "1817bbf92285476c0b0b3d9fde2353304033cbf8", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c538f7d833daa83dc07e59718cfc61ba8bdda10/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c538f7d833daa83dc07e59718cfc61ba8bdda10/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=8c538f7d833daa83dc07e59718cfc61ba8bdda10", "patch": "@@ -1,7 +1,7 @@\n use smallvec::smallvec;\n \n use crate::infer::outlives::components::{push_outlives_components, Component};\n-use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n+use crate::traits::{self, Obligation, ObligationCause, PredicateObligation};\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_middle::ty::{self, ToPredicate, TyCtxt};\n use rustc_span::symbol::Ident;\n@@ -145,16 +145,28 @@ impl<'tcx> Elaborator<'tcx> {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n-                let obligations = predicates.predicates.iter().map(|&(mut pred, _)| {\n+                let obligations = predicates.predicates.iter().map(|&(mut pred, span)| {\n                     // when parent predicate is non-const, elaborate it to non-const predicates.\n                     if data.constness == ty::BoundConstness::NotConst {\n                         pred = pred.without_const(tcx);\n                     }\n \n+                    let cause = obligation.cause.clone().derived_cause(\n+                        bound_predicate.rebind(data),\n+                        |derived| {\n+                            traits::ImplDerivedObligation(Box::new(\n+                                traits::ImplDerivedObligationCause {\n+                                    derived,\n+                                    impl_def_id: data.def_id(),\n+                                    span,\n+                                },\n+                            ))\n+                        },\n+                    );\n                     predicate_obligation(\n                         pred.subst_supertrait(tcx, &bound_predicate.rebind(data.trait_ref)),\n                         obligation.param_env,\n-                        obligation.cause.clone(),\n+                        cause,\n                     )\n                 });\n                 debug!(?data, ?obligations, \"super_predicates\");"}, {"sha": "50fa7d1ac4d43635cdefc031274550538bd3e8c7", "filename": "tests/ui/associated-types/issue-43784-associated-type.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c538f7d833daa83dc07e59718cfc61ba8bdda10/tests%2Fui%2Fassociated-types%2Fissue-43784-associated-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c538f7d833daa83dc07e59718cfc61ba8bdda10/tests%2Fui%2Fassociated-types%2Fissue-43784-associated-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-types%2Fissue-43784-associated-type.stderr?ref=8c538f7d833daa83dc07e59718cfc61ba8bdda10", "patch": "@@ -4,6 +4,11 @@ error[E0277]: the trait bound `T: Copy` is not satisfied\n LL |     type Assoc = T;\n    |                  ^ the trait `Copy` is not implemented for `T`\n    |\n+note: required for `<T as Complete>::Assoc` to implement `Partial<T>`\n+  --> $DIR/issue-43784-associated-type.rs:1:11\n+   |\n+LL | pub trait Partial<X: ?Sized>: Copy {\n+   |           ^^^^^^^\n note: required by a bound in `Complete::Assoc`\n   --> $DIR/issue-43784-associated-type.rs:5:17\n    |"}, {"sha": "af03f0e5e5f430ca1bbefa70b91c941ee1038600", "filename": "tests/ui/derives/issue-91550.stderr", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8c538f7d833daa83dc07e59718cfc61ba8bdda10/tests%2Fui%2Fderives%2Fissue-91550.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c538f7d833daa83dc07e59718cfc61ba8bdda10/tests%2Fui%2Fderives%2Fissue-91550.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderives%2Fissue-91550.stderr?ref=8c538f7d833daa83dc07e59718cfc61ba8bdda10", "patch": "@@ -6,12 +6,15 @@ LL | struct Value(u32);\n    | |\n    | doesn't satisfy `Value: Eq`\n    | doesn't satisfy `Value: Hash`\n+   | doesn't satisfy `Value: PartialEq`\n ...\n LL |     hs.insert(Value(0));\n    |        ^^^^^^\n    |\n    = note: the following trait bounds were not satisfied:\n            `Value: Eq`\n+           `Value: PartialEq`\n+           which is required by `Value: Eq`\n            `Value: Hash`\n help: consider annotating `Value` with `#[derive(Eq, Hash, PartialEq)]`\n    |\n@@ -22,7 +25,10 @@ error[E0599]: the method `use_eq` exists for struct `Object<NoDerives>`, but its\n   --> $DIR/issue-91550.rs:26:9\n    |\n LL | pub struct NoDerives;\n-   | -------------------- doesn't satisfy `NoDerives: Eq`\n+   | --------------------\n+   | |\n+   | doesn't satisfy `NoDerives: Eq`\n+   | doesn't satisfy `NoDerives: PartialEq`\n LL |\n LL | struct Object<T>(T);\n    | ---------------- method `use_eq` not found for this struct\n@@ -37,6 +43,9 @@ LL | impl<T: Eq> Object<T> {\n    |         ^^  ---------\n    |         |\n    |         unsatisfied trait bound introduced here\n+   = note: the following trait bounds were not satisfied:\n+           `NoDerives: PartialEq`\n+           which is required by `NoDerives: Eq`\n help: consider annotating `NoDerives` with `#[derive(Eq, PartialEq)]`\n    |\n LL | #[derive(Eq, PartialEq)]\n@@ -46,7 +55,12 @@ error[E0599]: the method `use_ord` exists for struct `Object<NoDerives>`, but it\n   --> $DIR/issue-91550.rs:27:9\n    |\n LL | pub struct NoDerives;\n-   | -------------------- doesn't satisfy `NoDerives: Ord`\n+   | --------------------\n+   | |\n+   | doesn't satisfy `NoDerives: Eq`\n+   | doesn't satisfy `NoDerives: Ord`\n+   | doesn't satisfy `NoDerives: PartialEq`\n+   | doesn't satisfy `NoDerives: PartialOrd`\n LL |\n LL | struct Object<T>(T);\n    | ---------------- method `use_ord` not found for this struct\n@@ -61,6 +75,13 @@ LL | impl<T: Ord> Object<T> {\n    |         ^^^  ---------\n    |         |\n    |         unsatisfied trait bound introduced here\n+   = note: the following trait bounds were not satisfied:\n+           `NoDerives: PartialOrd`\n+           which is required by `NoDerives: Ord`\n+           `NoDerives: PartialEq`\n+           which is required by `NoDerives: Ord`\n+           `NoDerives: Eq`\n+           which is required by `NoDerives: Ord`\n help: consider annotating `NoDerives` with `#[derive(Eq, Ord, PartialEq, PartialOrd)]`\n    |\n LL | #[derive(Eq, Ord, PartialEq, PartialOrd)]\n@@ -72,7 +93,9 @@ error[E0599]: the method `use_ord_and_partial_ord` exists for struct `Object<NoD\n LL | pub struct NoDerives;\n    | --------------------\n    | |\n+   | doesn't satisfy `NoDerives: Eq`\n    | doesn't satisfy `NoDerives: Ord`\n+   | doesn't satisfy `NoDerives: PartialEq`\n    | doesn't satisfy `NoDerives: PartialOrd`\n LL |\n LL | struct Object<T>(T);\n@@ -91,6 +114,13 @@ LL | impl<T: Ord + PartialOrd> Object<T> {\n    |         |     |\n    |         |     unsatisfied trait bound introduced here\n    |         unsatisfied trait bound introduced here\n+   = note: the following trait bounds were not satisfied:\n+           `NoDerives: PartialEq`\n+           which is required by `NoDerives: Ord`\n+           `NoDerives: Eq`\n+           which is required by `NoDerives: Ord`\n+           `NoDerives: PartialEq`\n+           which is required by `NoDerives: PartialOrd`\n help: consider annotating `NoDerives` with `#[derive(Eq, Ord, PartialEq, PartialOrd)]`\n    |\n LL | #[derive(Eq, Ord, PartialEq, PartialOrd)]"}, {"sha": "e5638d90ee8e7a90b7ece6292c4b5627bf1d9a7d", "filename": "tests/ui/generic-associated-types/issue-74824.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c538f7d833daa83dc07e59718cfc61ba8bdda10/tests%2Fui%2Fgeneric-associated-types%2Fissue-74824.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c538f7d833daa83dc07e59718cfc61ba8bdda10/tests%2Fui%2Fgeneric-associated-types%2Fissue-74824.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fissue-74824.stderr?ref=8c538f7d833daa83dc07e59718cfc61ba8bdda10", "patch": "@@ -17,6 +17,7 @@ LL |     type Copy<T>: Copy = Box<T>;\n    |                          ^^^^^^ the trait `Clone` is not implemented for `T`\n    |\n    = note: required for `Box<T>` to implement `Clone`\n+   = note: required for `<Self as UnsafeCopy>::Copy<T>` to implement `Copy`\n note: required by a bound in `UnsafeCopy::Copy`\n   --> $DIR/issue-74824.rs:6:19\n    |"}, {"sha": "05d3de80d8449b4b8e7da07684b29174989854a5", "filename": "tests/ui/missing-trait-bounds/issue-35677.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c538f7d833daa83dc07e59718cfc61ba8bdda10/tests%2Fui%2Fmissing-trait-bounds%2Fissue-35677.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c538f7d833daa83dc07e59718cfc61ba8bdda10/tests%2Fui%2Fmissing-trait-bounds%2Fissue-35677.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmissing-trait-bounds%2Fissue-35677.stderr?ref=8c538f7d833daa83dc07e59718cfc61ba8bdda10", "patch": "@@ -6,6 +6,8 @@ LL |     this.is_subset(other)\n    |\n    = note: the following trait bounds were not satisfied:\n            `T: Eq`\n+           `T: PartialEq`\n+           which is required by `T: Eq`\n            `T: Hash`\n help: consider restricting the type parameters to satisfy the trait bounds\n    |"}, {"sha": "6b5b721384cbbebb622b4cdaaee0b356c35e5e45", "filename": "tests/ui/traits/issue-43784-supertrait.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c538f7d833daa83dc07e59718cfc61ba8bdda10/tests%2Fui%2Ftraits%2Fissue-43784-supertrait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c538f7d833daa83dc07e59718cfc61ba8bdda10/tests%2Fui%2Ftraits%2Fissue-43784-supertrait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fissue-43784-supertrait.stderr?ref=8c538f7d833daa83dc07e59718cfc61ba8bdda10", "patch": "@@ -4,6 +4,11 @@ error[E0277]: the trait bound `T: Copy` is not satisfied\n LL | impl<T> Complete for T {}\n    |                      ^ the trait `Copy` is not implemented for `T`\n    |\n+note: required for `T` to implement `Partial`\n+  --> $DIR/issue-43784-supertrait.rs:1:11\n+   |\n+LL | pub trait Partial: Copy {\n+   |           ^^^^^^^\n note: required by a bound in `Complete`\n   --> $DIR/issue-43784-supertrait.rs:4:21\n    |"}, {"sha": "77e753c13f7397aa70b99acb85eec0ca34bd5ff5", "filename": "tests/ui/traits/track-obligations.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8c538f7d833daa83dc07e59718cfc61ba8bdda10/tests%2Fui%2Ftraits%2Ftrack-obligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c538f7d833daa83dc07e59718cfc61ba8bdda10/tests%2Fui%2Ftraits%2Ftrack-obligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Ftrack-obligations.rs?ref=8c538f7d833daa83dc07e59718cfc61ba8bdda10", "patch": "@@ -0,0 +1,88 @@\n+// These are simplifications of the tower traits by the same name:\n+\n+pub trait Service<Request> {\n+    type Response;\n+}\n+\n+pub trait Layer<C> {\n+    type Service;\n+}\n+\n+// Any type will do here:\n+\n+pub struct Req;\n+pub struct Res;\n+\n+// This is encoding a trait alias.\n+\n+pub trait ParticularService:\n+    Service<Req, Response = Res> {\n+}\n+\n+impl<T> ParticularService for T\n+where\n+    T: Service<Req, Response = Res>,\n+{\n+}\n+\n+// This is also a trait alias.\n+// The weird = <Self as ...> bound is there so that users of the trait do not\n+// need to repeat the bounds. See https://github.com/rust-lang/rust/issues/20671\n+// for context, and in particular the workaround in:\n+// https://github.com/rust-lang/rust/issues/20671#issuecomment-529752828\n+\n+pub trait ParticularServiceLayer<C>:\n+    Layer<C, Service = <Self as ParticularServiceLayer<C>>::Service>\n+{\n+    type Service: ParticularService;\n+}\n+\n+impl<T, C> ParticularServiceLayer<C> for T\n+where\n+    T: Layer<C>,\n+    T::Service: ParticularService,\n+{\n+    type Service = T::Service;\n+}\n+\n+// These are types that implement the traits that the trait aliases refer to.\n+// They should also implement the alias traits due to the blanket impls.\n+\n+struct ALayer<C>(C);\n+impl<C> Layer<C> for ALayer<C> {\n+    type Service = AService;\n+}\n+\n+struct AService;\n+impl Service<Req> for AService {\n+    // However, AService does _not_ meet the blanket implementation,\n+    // since its Response type is bool, not Res as it should be.\n+    type Response = bool;\n+}\n+\n+// This is a wrapper type around ALayer that uses the trait alias\n+// as a way to communicate the requirements of the provided types.\n+struct Client<C>(C);\n+\n+// The method and the free-standing function below both have the same bounds.\n+\n+impl<C> Client<C>\n+where\n+    ALayer<C>: ParticularServiceLayer<C>,\n+{\n+    fn check(&self) {}\n+}\n+\n+fn check<C>(_: C) where ALayer<C>: ParticularServiceLayer<C> {}\n+\n+// But, they give very different error messages.\n+\n+fn main() {\n+    // This gives a very poor error message that does nothing to point the user\n+    // at the underlying cause of why the types involved do not meet the bounds.\n+    Client(()).check(); //~ ERROR E0599\n+\n+    // This gives a good(ish) error message that points the user at _why_ the\n+    // bound isn't met, and thus how they might fix it.\n+    check(()); //~ ERROR E0271\n+}"}, {"sha": "89477475970f4af442946c74452c241dc3989ade", "filename": "tests/ui/traits/track-obligations.stderr", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/8c538f7d833daa83dc07e59718cfc61ba8bdda10/tests%2Fui%2Ftraits%2Ftrack-obligations.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c538f7d833daa83dc07e59718cfc61ba8bdda10/tests%2Fui%2Ftraits%2Ftrack-obligations.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Ftrack-obligations.stderr?ref=8c538f7d833daa83dc07e59718cfc61ba8bdda10", "patch": "@@ -0,0 +1,76 @@\n+error[E0599]: the method `check` exists for struct `Client<()>`, but its trait bounds were not satisfied\n+  --> $DIR/track-obligations.rs:83:16\n+   |\n+LL | struct ALayer<C>(C);\n+   | ----------------\n+   | |\n+   | doesn't satisfy `<_ as Layer<()>>::Service = <ALayer<()> as ParticularServiceLayer<()>>::Service`\n+   | doesn't satisfy `ALayer<()>: ParticularServiceLayer<()>`\n+...\n+LL | struct Client<C>(C);\n+   | ---------------- method `check` not found for this struct\n+...\n+LL |     Client(()).check();\n+   |                ^^^^^ method cannot be called on `Client<()>` due to unsatisfied trait bounds\n+   |\n+note: trait bound `<ALayer<()> as Layer<()>>::Service = <ALayer<()> as ParticularServiceLayer<()>>::Service` was not satisfied\n+  --> $DIR/track-obligations.rs:35:14\n+   |\n+LL | pub trait ParticularServiceLayer<C>:\n+   |           ----------------------\n+LL |     Layer<C, Service = <Self as ParticularServiceLayer<C>>::Service>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unsatisfied trait bound introduced here\n+note: trait bound `ALayer<()>: ParticularServiceLayer<()>` was not satisfied\n+  --> $DIR/track-obligations.rs:71:16\n+   |\n+LL | impl<C> Client<C>\n+   |         ---------\n+LL | where\n+LL |     ALayer<C>: ParticularServiceLayer<C>,\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^ unsatisfied trait bound introduced here\n+note: the trait `ParticularServiceLayer` must be implemented\n+  --> $DIR/track-obligations.rs:34:1\n+   |\n+LL | / pub trait ParticularServiceLayer<C>:\n+LL | |     Layer<C, Service = <Self as ParticularServiceLayer<C>>::Service>\n+   | |____________________________________________________________________^\n+\n+error[E0271]: type mismatch resolving `<AService as Service<Req>>::Response == Res`\n+  --> $DIR/track-obligations.rs:87:11\n+   |\n+LL |     check(());\n+   |     ----- ^^ type mismatch resolving `<AService as Service<Req>>::Response == Res`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: expected this to be `Res`\n+  --> $DIR/track-obligations.rs:60:21\n+   |\n+LL |     type Response = bool;\n+   |                     ^^^^\n+note: required for `AService` to implement `ParticularService`\n+  --> $DIR/track-obligations.rs:22:9\n+   |\n+LL | impl<T> ParticularService for T\n+   |         ^^^^^^^^^^^^^^^^^     ^\n+LL | where\n+LL |     T: Service<Req, Response = Res>,\n+   |                     -------------- unsatisfied trait bound introduced here\n+note: required for `ALayer<_>` to implement `ParticularServiceLayer<_>`\n+  --> $DIR/track-obligations.rs:40:12\n+   |\n+LL | impl<T, C> ParticularServiceLayer<C> for T\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^     ^\n+...\n+LL |     T::Service: ParticularService,\n+   |                 ----------------- unsatisfied trait bound introduced here\n+note: required by a bound in `check`\n+  --> $DIR/track-obligations.rs:76:36\n+   |\n+LL | fn check<C>(_: C) where ALayer<C>: ParticularServiceLayer<C> {}\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `check`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0271, E0599.\n+For more information about an error, try `rustc --explain E0271`."}]}