{"sha": "ff8cd2e42836bc1ccf6fabcec9847e018126128a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmOGNkMmU0MjgzNmJjMWNjZjZmYWJjZWM5ODQ3ZTAxODEyNjEyOGE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-08T08:52:27Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-17T15:32:15Z"}, "message": "strip old lub-glb tests from `librustc_driver`\n\nGood riddance.", "tree": {"sha": "1ee7a13ade82a0cfb8d4f7a32b2ea587260e1a17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ee7a13ade82a0cfb8d4f7a32b2ea587260e1a17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff8cd2e42836bc1ccf6fabcec9847e018126128a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff8cd2e42836bc1ccf6fabcec9847e018126128a", "html_url": "https://github.com/rust-lang/rust/commit/ff8cd2e42836bc1ccf6fabcec9847e018126128a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff8cd2e42836bc1ccf6fabcec9847e018126128a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b224397b7cb54e8c25e2285e38432db58790016e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b224397b7cb54e8c25e2285e38432db58790016e", "html_url": "https://github.com/rust-lang/rust/commit/b224397b7cb54e8c25e2285e38432db58790016e"}], "stats": {"total": 212, "additions": 0, "deletions": 212}, "files": [{"sha": "78ce959e5c94e03e1e1f5c3e01cf39291f196c64", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 0, "deletions": 212, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/ff8cd2e42836bc1ccf6fabcec9847e018126128a/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8cd2e42836bc1ccf6fabcec9847e018126128a/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=ff8cd2e42836bc1ccf6fabcec9847e018126128a", "patch": "@@ -353,28 +353,10 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n-    pub fn t_rptr_static(&self) -> Ty<'tcx> {\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.types.re_static,\n-                                  self.tcx().types.isize)\n-    }\n-\n-    pub fn t_rptr_empty(&self) -> Ty<'tcx> {\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.types.re_empty,\n-                                  self.tcx().types.isize)\n-    }\n-\n     pub fn sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> InferResult<'tcx, ()> {\n         self.infcx.at(&ObligationCause::dummy(), self.param_env).sub(t1, t2)\n     }\n \n-    pub fn lub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n-        self.infcx.at(&ObligationCause::dummy(), self.param_env).lub(t1, t2)\n-    }\n-\n-    pub fn glb(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n-        self.infcx.at(&ObligationCause::dummy(), self.param_env).glb(t1, t2)\n-    }\n-\n     /// Checks that `t1 <: t2` is true (this may register additional\n     /// region checks).\n     pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n@@ -399,37 +381,6 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n             }\n         }\n     }\n-\n-    /// Checks that `LUB(t1,t2) == t_lub`\n-    pub fn check_lub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_lub: Ty<'tcx>) {\n-        match self.lub(t1, t2) {\n-            Ok(InferOk { obligations, value: t }) => {\n-                // None of these tests should require nested obligations:\n-                assert!(obligations.is_empty());\n-\n-                self.assert_eq(t, t_lub);\n-            }\n-            Err(ref e) => panic!(\"unexpected error in LUB: {}\", e),\n-        }\n-    }\n-\n-    /// Checks that `GLB(t1,t2) == t_glb`\n-    pub fn check_glb(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_glb: Ty<'tcx>) {\n-        debug!(\"check_glb(t1={}, t2={}, t_glb={})\", t1, t2, t_glb);\n-        match self.glb(t1, t2) {\n-            Err(e) => panic!(\"unexpected error computing LUB: {:?}\", e),\n-            Ok(InferOk { obligations, value: t }) => {\n-                // None of these tests should require nested obligations:\n-                assert!(obligations.is_empty());\n-\n-                self.assert_eq(t, t_glb);\n-\n-                // sanity check for good measure:\n-                self.assert_subtype(t, t1);\n-                self.assert_subtype(t, t2);\n-            }\n-        }\n-    }\n }\n \n #[test]\n@@ -508,169 +459,6 @@ fn sub_free_bound_false_infer() {\n     })\n }\n \n-#[test]\n-fn lub_free_bound_infer() {\n-    //! Test result of:\n-    //!\n-    //!     LUB(fn(_#1), for<'b> fn(&'b isize))\n-    //!\n-    //! This should yield `fn(&'_ isize)`. We check\n-    //! that it yields `fn(&'x isize)` for some free `'x`,\n-    //! anyhow.\n-\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n-        env.create_simple_region_hierarchy();\n-        let t_infer1 = env.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(1);\n-        env.check_lub(env.t_fn(&[t_infer1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n-    });\n-}\n-\n-#[test]\n-fn lub_bound_bound() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_bound2 = env.t_rptr_late_bound(2);\n-        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_bound2], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n-    })\n-}\n-\n-#[test]\n-fn lub_bound_free() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n-        env.create_simple_region_hierarchy();\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(1);\n-        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n-    })\n-}\n-\n-#[test]\n-fn lub_bound_static() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_static = env.t_rptr_static();\n-        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_static], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_static], env.tcx().types.isize));\n-    })\n-}\n-\n-#[test]\n-fn lub_bound_bound_inverse_order() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_bound2 = env.t_rptr_late_bound(2);\n-        env.check_lub(env.t_fn(&[t_rptr_bound1, t_rptr_bound2], t_rptr_bound1),\n-                      env.t_fn(&[t_rptr_bound2, t_rptr_bound1], t_rptr_bound1),\n-                      env.t_fn(&[t_rptr_bound1, t_rptr_bound1], t_rptr_bound1));\n-    })\n-}\n-\n-#[test]\n-fn lub_free_free() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n-        env.create_simple_region_hierarchy();\n-        let t_rptr_free1 = env.t_rptr_free(1);\n-        let t_rptr_free2 = env.t_rptr_free(2);\n-        let t_rptr_static = env.t_rptr_static();\n-        env.check_lub(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_free2], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_static], env.tcx().types.isize));\n-    })\n-}\n-\n-#[test]\n-fn lub_returning_scope() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n-        env.create_simple_region_hierarchy();\n-        let t_rptr_scope10 = env.t_rptr_scope(10);\n-        let t_rptr_scope11 = env.t_rptr_scope(11);\n-        let t_rptr_empty = env.t_rptr_empty();\n-        env.check_lub(env.t_fn(&[t_rptr_scope10], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_scope11], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_empty], env.tcx().types.isize));\n-    });\n-}\n-\n-#[test]\n-fn glb_free_free_with_common_scope() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n-        env.create_simple_region_hierarchy();\n-        let t_rptr_free1 = env.t_rptr_free(1);\n-        let t_rptr_free2 = env.t_rptr_free(2);\n-        let t_rptr_scope = env.t_rptr_scope(1);\n-        env.check_glb(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_free2], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_scope], env.tcx().types.isize));\n-    })\n-}\n-\n-#[test]\n-fn glb_bound_bound() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_bound2 = env.t_rptr_late_bound(2);\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_bound2], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n-    })\n-}\n-\n-#[test]\n-fn glb_bound_free() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n-        env.create_simple_region_hierarchy();\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(1);\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n-    })\n-}\n-\n-#[test]\n-fn glb_bound_free_infer() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_infer1 = env.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n-\n-        // compute GLB(fn(_) -> isize, for<'b> fn(&'b isize) -> isize),\n-        // which should yield for<'b> fn(&'b isize) -> isize\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-                      env.t_fn(&[t_infer1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n-\n-        // as a side-effect, computing GLB should unify `_` with\n-        // `&'_ isize`\n-        let t_resolve1 = env.infcx.shallow_resolve(t_infer1);\n-        match t_resolve1.sty {\n-            ty::TyRef(..) => {}\n-            _ => {\n-                panic!(\"t_resolve1={:?}\", t_resolve1);\n-            }\n-        }\n-    })\n-}\n-\n-#[test]\n-fn glb_bound_static() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_static = env.t_rptr_static();\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_static], env.tcx().types.isize),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n-    })\n-}\n-\n /// Test substituting a bound region into a function, which introduces another level of binding.\n /// This requires adjusting the Debruijn index.\n #[test]"}]}