{"sha": "5a7e0f8764b13156634cf84caa2bd4b9997fe7d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhN2UwZjg3NjRiMTMxNTY2MzRjZjg0Y2FhMmJkNGI5OTk3ZmU3ZDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-07T09:09:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-07T09:09:43Z"}, "message": "Auto merge of #51993 - TheDarkula:master, r=oli-obk\n\nOmitted the walks in visit_expr() and visit_stmt()\n\n@oli-obk", "tree": {"sha": "5b3edc152b41910c867889102c107cdcc2e1f159", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b3edc152b41910c867889102c107cdcc2e1f159"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a7e0f8764b13156634cf84caa2bd4b9997fe7d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a7e0f8764b13156634cf84caa2bd4b9997fe7d8", "html_url": "https://github.com/rust-lang/rust/commit/5a7e0f8764b13156634cf84caa2bd4b9997fe7d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a7e0f8764b13156634cf84caa2bd4b9997fe7d8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "599d2c01e023bda2a0d861d1faaab178f33d19b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/599d2c01e023bda2a0d861d1faaab178f33d19b2", "html_url": "https://github.com/rust-lang/rust/commit/599d2c01e023bda2a0d861d1faaab178f33d19b2"}, {"sha": "f629eb35950ef32a909a98548840f4645bb0f862", "url": "https://api.github.com/repos/rust-lang/rust/commits/f629eb35950ef32a909a98548840f4645bb0f862", "html_url": "https://github.com/rust-lang/rust/commit/f629eb35950ef32a909a98548840f4645bb0f862"}], "stats": {"total": 248, "additions": 175, "deletions": 73}, "files": [{"sha": "c3ee98039f3f6fb197d959b07dcf9ba9f905f27f", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 175, "deletions": 73, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e0f8764b13156634cf84caa2bd4b9997fe7d8/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e0f8764b13156634cf84caa2bd4b9997fe7d8/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=5a7e0f8764b13156634cf84caa2bd4b9997fe7d8", "patch": "@@ -40,7 +40,6 @@ use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax::attr;\n use syntax_pos::{Span, DUMMY_SP};\n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n@@ -65,7 +64,7 @@ fn const_is_rvalue_promotable_to_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     assert!(def_id.is_local());\n \n     let node_id = tcx.hir.as_local_node_id(def_id)\n-                     .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n+        .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n     let body_id = tcx.hir.body_owned_by(node_id);\n     let body_hir_id = tcx.hir.node_to_hir_id(body_id.node_id);\n     tcx.rvalue_promotable_map(def_id).contains(&body_hir_id.local_id)\n@@ -94,7 +93,7 @@ fn rvalue_promotable_map<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // `def_id` should be a `Body` owner\n     let node_id = tcx.hir.as_local_node_id(def_id)\n-                     .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n+        .expect(\"rvalue_promotable_map invoked with non-local def-id\");\n     let body_id = tcx.hir.body_owned_by(node_id);\n     visitor.visit_nested_body(body_id);\n \n@@ -117,7 +116,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     // Returns true iff all the values of the type are promotable.\n     fn type_has_only_promotable_values(&mut self, ty: Ty<'gcx>) -> bool {\n         ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) &&\n-        !ty.needs_drop(self.tcx, self.param_env)\n+            !ty.needs_drop(self.tcx, self.param_env)\n     }\n \n     fn handle_const_fn_call(&mut self, def_id: DefId, ret_ty: Ty<'gcx>, span: Span) {\n@@ -133,21 +132,21 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n \n         if let Some(&attr::Stability {\n             rustc_const_unstable: Some(attr::RustcConstUnstable {\n-                feature: ref feature_name\n-            }),\n-        .. }) = self.tcx.lookup_stability(def_id) {\n+                                           feature: ref feature_name\n+                                       }),\n+            .. }) = self.tcx.lookup_stability(def_id) {\n             self.promotable &=\n                 // feature-gate is enabled,\n                 self.tcx.features()\n                     .declared_lib_features\n                     .iter()\n                     .any(|&(ref sym, _)| sym == feature_name) ||\n \n-                // this comes from a crate with the feature-gate enabled,\n-                !def_id.is_local() ||\n+                    // this comes from a crate with the feature-gate enabled,\n+                    !def_id.is_local() ||\n \n-                // this comes from a macro that has #[allow_internal_unstable]\n-                span.allows_unstable();\n+                    // this comes from a macro that has #[allow_internal_unstable]\n+                    span.allows_unstable();\n         }\n     }\n \n@@ -169,12 +168,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        // note that we *do* visit nested bodies, because we override `visit_nested_body` below\n-        NestedVisitorMap::None\n-    }\n-\n+impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n         let item_id = self.tcx.hir.body_owner(body_id);\n         let item_def_id = self.tcx.hir.local_def_id(item_id);\n@@ -206,8 +200,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         euv::ExprUseVisitor::new(self, tcx, param_env, &region_scope_tree, self.tables, None)\n             .consume_body(body);\n \n-        self.visit_body(body);\n-\n+        self.visit_expr(&body.value);\n         self.in_fn = outer_in_fn;\n         self.tables = outer_tables;\n         self.param_env = outer_param_env;\n@@ -216,27 +209,31 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n \n     fn visit_stmt(&mut self, stmt: &'tcx hir::Stmt) {\n         match stmt.node {\n-            hir::StmtDecl(ref decl, _) => {\n+            hir::StmtDecl(ref decl, _node_id) => {\n                 match &decl.node {\n                     hir::DeclLocal(local) => {\n                         self.promotable = false;\n-\n                         if self.remove_mut_rvalue_borrow(&local.pat) {\n                             if let Some(init) = &local.init {\n                                 self.mut_rvalue_borrows.insert(init.id);\n                             }\n                         }\n+\n+                        match local.init {\n+                            Some(ref expr) => self.visit_expr(&expr),\n+                            None => {},\n+                        }\n                     }\n                     // Item statements are allowed\n                     hir::DeclItem(_) => {}\n                 }\n             }\n-            hir::StmtExpr(..) |\n-            hir::StmtSemi(..) => {\n+            hir::StmtExpr(ref box_expr, _node_id) |\n+            hir::StmtSemi(ref box_expr, _node_id) => {\n+                self.visit_expr(box_expr);\n                 self.promotable = false;\n             }\n         }\n-        intravisit::walk_stmt(self, stmt);\n     }\n \n     fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n@@ -247,20 +244,6 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         check_expr(self, ex, node_ty);\n         check_adjustments(self, ex);\n \n-        if let hir::ExprMatch(ref discr, ref arms, _) = ex.node {\n-            // Compute the most demanding borrow from all the arms'\n-            // patterns and set that on the discriminator.\n-            let mut mut_borrow = false;\n-            for pat in arms.iter().flat_map(|arm| &arm.pats) {\n-                mut_borrow = self.remove_mut_rvalue_borrow(pat);\n-            }\n-            if mut_borrow {\n-                self.mut_rvalue_borrows.insert(discr.id);\n-            }\n-        }\n-\n-        intravisit::walk_expr(self, ex);\n-\n         // Handle borrows on (or inside the autorefs of) this expression.\n         if self.mut_rvalue_borrows.remove(&ex.id) {\n             self.promotable = false;\n@@ -271,6 +254,16 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         }\n         self.promotable &= outer;\n     }\n+\n+    fn visit_block(&mut self, block: &'tcx hir::Block) {\n+        for index in block.stmts.iter() {\n+            self.visit_stmt(index)\n+        }\n+        match block.expr {\n+            Some(ref box_expr) => { self.visit_expr(&*box_expr) },\n+            None => {},\n+        }\n+    }\n }\n \n /// This function is used to enforce the constraints on\n@@ -279,7 +272,9 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n /// every nested expression. If the expression is not part\n /// of a const/static item, it is qualified for promotion\n /// instead of producing errors.\n-fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node_ty: Ty<'tcx>) {\n+fn check_expr<'a, 'tcx>(\n+    v: &mut CheckCrateVisitor<'a, 'tcx>,\n+    e: &'tcx hir::Expr, node_ty: Ty<'tcx>) {\n     match node_ty.sty {\n         ty::TyAdt(def, _) if def.has_dtor(v.tcx) => {\n             v.promotable = false;\n@@ -288,32 +283,38 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n     }\n \n     match e.node {\n-        hir::ExprUnary(..) |\n-        hir::ExprBinary(..) |\n-        hir::ExprIndex(..) if v.tables.is_method_call(e) => {\n+        hir::ExprBox(ref expr) => {\n+            v.visit_expr(&expr);\n             v.promotable = false;\n         }\n-        hir::ExprBox(_) => {\n-            v.promotable = false;\n-        }\n-        hir::ExprUnary(op, _) => {\n+        hir::ExprUnary(op, ref expr) => {\n+            if v.tables.is_method_call(e) {\n+                v.promotable = false;\n+            }\n             if op == hir::UnDeref {\n                 v.promotable = false;\n             }\n+            v.visit_expr(expr);\n         }\n-        hir::ExprBinary(op, ref lhs, _) => {\n+        hir::ExprBinary(op, ref lhs, ref rhs) => {\n+            if v.tables.is_method_call(e) {\n+                v.promotable = false;\n+            }\n+            v.visit_expr(lhs);\n+            v.visit_expr(rhs);\n             match v.tables.node_id_to_type(lhs.hir_id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op.node == hir::BiEq || op.node == hir::BiNe ||\n-                            op.node == hir::BiLe || op.node == hir::BiLt ||\n-                            op.node == hir::BiGe || op.node == hir::BiGt);\n+                        op.node == hir::BiLe || op.node == hir::BiLt ||\n+                        op.node == hir::BiGe || op.node == hir::BiGt);\n \n                     v.promotable = false;\n                 }\n                 _ => {}\n             }\n         }\n         hir::ExprCast(ref from, _) => {\n+            v.visit_expr(from);\n             debug!(\"Checking const cast(id={})\", from.id);\n             match v.tables.cast_kinds().get(from.hir_id) {\n                 None => v.tcx.sess.delay_span_bug(e.span, \"no kind for cast\"),\n@@ -379,7 +380,11 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                 }\n             }\n         }\n-        hir::ExprCall(ref callee, _) => {\n+        hir::ExprCall(ref callee, ref hirvec) => {\n+            v.visit_expr(callee);\n+            for index in hirvec.iter() {\n+                v.visit_expr(index)\n+            }\n             let mut callee = &**callee;\n             loop {\n                 callee = match callee.node {\n@@ -413,7 +418,10 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                 _ => v.promotable = false\n             }\n         }\n-        hir::ExprMethodCall(..) => {\n+        hir::ExprMethodCall(ref _pathsegment, ref _span, ref hirvec) => {\n+            for index in hirvec.iter() {\n+                v.visit_expr(index)\n+            }\n             if let Some(def) = v.tables.type_dependent_defs().get(e.hir_id) {\n                 let def_id = def.def_id();\n                 match v.tcx.associated_item(def_id).container {\n@@ -424,7 +432,14 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                 v.tcx.sess.delay_span_bug(e.span, \"no type-dependent def for method call\");\n             }\n         }\n-        hir::ExprStruct(..) => {\n+        hir::ExprStruct(ref _qpath, ref hirvec, ref option_expr) => {\n+            for index in hirvec.iter() {\n+                v.visit_expr(&index.expr);\n+            }\n+            match *option_expr {\n+                Some(ref expr) => { v.visit_expr(&expr) },\n+                None => {},\n+            }\n             if let ty::TyAdt(adt, ..) = v.tables.expr_ty(e).sty {\n                 // unsafe_cell_type doesn't necessarily exist with no_core\n                 if Some(adt.did) == v.tcx.lang_items().unsafe_cell_type() {\n@@ -433,52 +448,139 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n \n-        hir::ExprLit(_) |\n-        hir::ExprAddrOf(..) |\n-        hir::ExprRepeat(..) => {}\n+        hir::ExprLit(_) => {}\n \n-        hir::ExprClosure(..) => {\n+        hir::ExprAddrOf(_, ref expr) |\n+        hir::ExprRepeat(ref expr, _) => {\n+            v.visit_expr(expr);\n+        }\n+\n+        hir::ExprClosure(_capture_clause, ref _box_fn_decl,\n+                         body_id, _span, _option_generator_movability) => {\n+            v.visit_nested_body(body_id);\n             // Paths in constant contexts cannot refer to local variables,\n             // as there are none, and thus closures can't have upvars there.\n             if v.tcx.with_freevars(e.id, |fv| !fv.is_empty()) {\n                 v.promotable = false;\n             }\n         }\n \n-        hir::ExprField(ref expr, _) => {\n+        hir::ExprField(ref expr, _ident) => {\n+            v.visit_expr(expr);\n             if let Some(def) = v.tables.expr_ty(expr).ty_adt_def() {\n                 if def.is_union() {\n                     v.promotable = false\n                 }\n             }\n         }\n \n-        hir::ExprBlock(..) |\n-        hir::ExprIndex(..) |\n-        hir::ExprArray(_) |\n-        hir::ExprType(..) |\n-        hir::ExprTup(..) => {}\n+        hir::ExprBlock(ref box_block, ref _option_label) => {\n+            v.visit_block(box_block);\n+        }\n+\n+        hir::ExprIndex(ref lhs, ref rhs) => {\n+            if v.tables.is_method_call(e) {\n+                v.promotable = false;\n+            }\n+            v.visit_expr(lhs);\n+            v.visit_expr(rhs);\n+        }\n+\n+        hir::ExprArray(ref hirvec) => {\n+            for index in hirvec.iter() {\n+                v.visit_expr(index)\n+            }\n+        }\n+\n+        hir::ExprType(ref expr, ref _ty) => {\n+            v.visit_expr(expr);\n+        }\n+\n+        hir::ExprTup(ref hirvec) => {\n+            for index in hirvec.iter() {\n+                v.visit_expr(index)\n+            }\n+        }\n+\n \n         // Conditional control flow (possible to implement).\n-        hir::ExprMatch(..) |\n-        hir::ExprIf(..) |\n+        hir::ExprMatch(ref expr, ref hirvec_arm, ref _match_source) => {\n+            // Compute the most demanding borrow from all the arms'\n+            // patterns and set that on the discriminator.\n+            let mut mut_borrow = false;\n+            for pat in hirvec_arm.iter().flat_map(|arm| &arm.pats) {\n+                mut_borrow = v.remove_mut_rvalue_borrow(pat);\n+            }\n+            if mut_borrow {\n+                v.mut_rvalue_borrows.insert(expr.id);\n+            }\n+\n+            v.visit_expr(expr);\n+            for index in hirvec_arm.iter() {\n+                v.visit_expr(&*index.body);\n+                match index.guard {\n+                    Some(ref expr) => v.visit_expr(&expr),\n+                    None => {},\n+                }\n+            }\n+            v.promotable = false;\n+        }\n+\n+        hir::ExprIf(ref lhs, ref rhs, ref option_expr) => {\n+            v.visit_expr(lhs);\n+            v.visit_expr(rhs);\n+            match option_expr {\n+                Some(ref expr) => v.visit_expr(&expr),\n+                None => {},\n+            }\n+            v.promotable = false;\n+        }\n \n         // Loops (not very meaningful in constants).\n-        hir::ExprWhile(..) |\n-        hir::ExprLoop(..) |\n+        hir::ExprWhile(ref expr, ref box_block, ref _option_label) => {\n+            v.visit_expr(expr);\n+            v.visit_block(box_block);\n+            v.promotable = false;\n+        }\n+\n+        hir::ExprLoop(ref box_block, ref _option_label, ref _loop_source) => {\n+            v.visit_block(box_block);\n+            v.promotable = false;\n+        }\n \n         // More control flow (also not very meaningful).\n-        hir::ExprBreak(..) |\n-        hir::ExprContinue(_) |\n-        hir::ExprRet(_) |\n+        hir::ExprBreak(_, ref option_expr) | hir::ExprRet(ref option_expr) => {\n+            match *option_expr {\n+                Some(ref expr) => { v.visit_expr(&expr) },\n+                None => {},\n+            }\n+            v.promotable = false;\n+        }\n+\n+        hir::ExprContinue(_) => {\n+            v.promotable = false;\n+        }\n \n         // Generator expressions\n-        hir::ExprYield(_) |\n+        hir::ExprYield(ref expr) => {\n+            v.visit_expr(&expr);\n+            v.promotable = false;\n+        }\n \n         // Expressions with side-effects.\n-        hir::ExprAssign(..) |\n-        hir::ExprAssignOp(..) |\n-        hir::ExprInlineAsm(..) => {\n+        hir::ExprAssignOp(_, ref lhs, ref rhs) | hir::ExprAssign(ref lhs, ref rhs) => {\n+            v.visit_expr(lhs);\n+            v.visit_expr(rhs);\n+            v.promotable = false;\n+        }\n+\n+        hir::ExprInlineAsm(ref _inline_asm, ref hirvec_lhs, ref hirvec_rhs) => {\n+            for index in hirvec_lhs.iter() {\n+                v.visit_expr(index)\n+            }\n+            for index in hirvec_rhs.iter() {\n+                v.visit_expr(index)\n+            }\n             v.promotable = false;\n         }\n     }"}]}