{"sha": "afb4514c099fde6e3102373602bea9e6dacd4f88", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmYjQ1MTRjMDk5ZmRlNmUzMTAyMzczNjAyYmVhOWU2ZGFjZDRmODg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-13T00:57:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-13T00:57:03Z"}, "message": "Auto merge of #77796 - jonas-schievink:switchint-refactor, r=oli-obk\n\nRefactor how SwitchInt stores jump targets\n\nCloses https://github.com/rust-lang/rust/issues/65693", "tree": {"sha": "ba74e724f123847c8ce045f7e378e5ddd357dda3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba74e724f123847c8ce045f7e378e5ddd357dda3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afb4514c099fde6e3102373602bea9e6dacd4f88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afb4514c099fde6e3102373602bea9e6dacd4f88", "html_url": "https://github.com/rust-lang/rust/commit/afb4514c099fde6e3102373602bea9e6dacd4f88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afb4514c099fde6e3102373602bea9e6dacd4f88/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abbdec3be6cfce1175d0dc6737a2999cf43b530d", "url": "https://api.github.com/repos/rust-lang/rust/commits/abbdec3be6cfce1175d0dc6737a2999cf43b530d", "html_url": "https://github.com/rust-lang/rust/commit/abbdec3be6cfce1175d0dc6737a2999cf43b530d"}, {"sha": "9a47f74bfe0276fdac849da8d71aa9378ed9affb", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a47f74bfe0276fdac849da8d71aa9378ed9affb", "html_url": "https://github.com/rust-lang/rust/commit/9a47f74bfe0276fdac849da8d71aa9378ed9affb"}], "stats": {"total": 454, "additions": 247, "deletions": 207}, "files": [{"sha": "353189ae1f0d46172ae5e5f11cdad1acc002b273", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 19, "deletions": 26, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -12,9 +12,9 @@ use crate::MemFlags;\n use rustc_ast as ast;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::Idx;\n-use rustc_middle::mir;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::mir::AssertKind;\n+use rustc_middle::mir::{self, SwitchTargets};\n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n@@ -24,8 +24,6 @@ use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n use rustc_target::abi::{self, LayoutOf};\n use rustc_target::spec::abi::Abi;\n \n-use std::borrow::Cow;\n-\n /// Used by `FunctionCx::codegen_terminator` for emitting common patterns\n /// e.g., creating a basic block, calling a function, etc.\n struct TerminatorCodegenHelper<'tcx> {\n@@ -198,42 +196,37 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         mut bx: Bx,\n         discr: &mir::Operand<'tcx>,\n         switch_ty: Ty<'tcx>,\n-        values: &Cow<'tcx, [u128]>,\n-        targets: &Vec<mir::BasicBlock>,\n+        targets: &SwitchTargets,\n     ) {\n         let discr = self.codegen_operand(&mut bx, &discr);\n         // `switch_ty` is redundant, sanity-check that.\n         assert_eq!(discr.layout.ty, switch_ty);\n-        if targets.len() == 2 {\n-            // If there are two targets, emit br instead of switch\n-            let lltrue = helper.llblock(self, targets[0]);\n-            let llfalse = helper.llblock(self, targets[1]);\n+        helper.maybe_sideeffect(self.mir, &mut bx, targets.all_targets());\n+\n+        let mut target_iter = targets.iter();\n+        if target_iter.len() == 1 {\n+            // If there are two targets (one conditional, one fallback), emit br instead of switch\n+            let (test_value, target) = target_iter.next().unwrap();\n+            let lltrue = helper.llblock(self, target);\n+            let llfalse = helper.llblock(self, targets.otherwise());\n             if switch_ty == bx.tcx().types.bool {\n-                helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n                 // Don't generate trivial icmps when switching on bool\n-                if let [0] = values[..] {\n-                    bx.cond_br(discr.immediate(), llfalse, lltrue);\n-                } else {\n-                    assert_eq!(&values[..], &[1]);\n-                    bx.cond_br(discr.immediate(), lltrue, llfalse);\n+                match test_value {\n+                    0 => bx.cond_br(discr.immediate(), llfalse, lltrue),\n+                    1 => bx.cond_br(discr.immediate(), lltrue, llfalse),\n+                    _ => bug!(),\n                 }\n             } else {\n                 let switch_llty = bx.immediate_backend_type(bx.layout_of(switch_ty));\n-                let llval = bx.const_uint_big(switch_llty, values[0]);\n+                let llval = bx.const_uint_big(switch_llty, test_value);\n                 let cmp = bx.icmp(IntPredicate::IntEQ, discr.immediate(), llval);\n-                helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n                 bx.cond_br(cmp, lltrue, llfalse);\n             }\n         } else {\n-            helper.maybe_sideeffect(self.mir, &mut bx, targets.as_slice());\n-            let (otherwise, targets) = targets.split_last().unwrap();\n             bx.switch(\n                 discr.immediate(),\n-                helper.llblock(self, *otherwise),\n-                values\n-                    .iter()\n-                    .zip(targets)\n-                    .map(|(&value, target)| (value, helper.llblock(self, *target))),\n+                helper.llblock(self, targets.otherwise()),\n+                target_iter.map(|(value, target)| (value, helper.llblock(self, target))),\n             );\n         }\n     }\n@@ -975,8 +968,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 helper.funclet_br(self, &mut bx, target);\n             }\n \n-            mir::TerminatorKind::SwitchInt { ref discr, switch_ty, ref values, ref targets } => {\n-                self.codegen_switchint_terminator(helper, bx, discr, switch_ty, values, targets);\n+            mir::TerminatorKind::SwitchInt { ref discr, switch_ty, ref targets } => {\n+                self.codegen_switchint_terminator(helper, bx, discr, switch_ty, targets);\n             }\n \n             mir::TerminatorKind::Return => {"}, {"sha": "e1071454e6501444f6d05f103f054f3d32a1c935", "filename": "compiler/rustc_middle/src/mir/terminator/mod.rs", "status": "modified", "additions": 89, "deletions": 24, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator%2Fmod.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -1,6 +1,7 @@\n use crate::mir::interpret::Scalar;\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n+use smallvec::{smallvec, SmallVec};\n \n use super::{\n     AssertMessage, BasicBlock, InlineAsmOperand, Operand, Place, SourceInfo, Successors,\n@@ -16,6 +17,87 @@ use std::slice;\n \n pub use super::query::*;\n \n+#[derive(Debug, Clone, TyEncodable, TyDecodable, HashStable, PartialEq)]\n+pub struct SwitchTargets {\n+    /// Possible values. The locations to branch to in each case\n+    /// are found in the corresponding indices from the `targets` vector.\n+    values: SmallVec<[u128; 1]>,\n+\n+    /// Possible branch sites. The last element of this vector is used\n+    /// for the otherwise branch, so targets.len() == values.len() + 1\n+    /// should hold.\n+    //\n+    // This invariant is quite non-obvious and also could be improved.\n+    // One way to make this invariant is to have something like this instead:\n+    //\n+    // branches: Vec<(ConstInt, BasicBlock)>,\n+    // otherwise: Option<BasicBlock> // exhaustive if None\n+    //\n+    // However we\u2019ve decided to keep this as-is until we figure a case\n+    // where some other approach seems to be strictly better than other.\n+    targets: SmallVec<[BasicBlock; 2]>,\n+}\n+\n+impl SwitchTargets {\n+    /// Creates switch targets from an iterator of values and target blocks.\n+    ///\n+    /// The iterator may be empty, in which case the `SwitchInt` instruction is equivalent to\n+    /// `goto otherwise;`.\n+    pub fn new(targets: impl Iterator<Item = (u128, BasicBlock)>, otherwise: BasicBlock) -> Self {\n+        let (values, mut targets): (SmallVec<_>, SmallVec<_>) = targets.unzip();\n+        targets.push(otherwise);\n+        Self { values: values.into(), targets }\n+    }\n+\n+    /// Builds a switch targets definition that jumps to `then` if the tested value equals `value`,\n+    /// and to `else_` if not.\n+    pub fn static_if(value: u128, then: BasicBlock, else_: BasicBlock) -> Self {\n+        Self { values: smallvec![value], targets: smallvec![then, else_] }\n+    }\n+\n+    /// Returns the fallback target that is jumped to when none of the values match the operand.\n+    pub fn otherwise(&self) -> BasicBlock {\n+        *self.targets.last().unwrap()\n+    }\n+\n+    /// Returns an iterator over the switch targets.\n+    ///\n+    /// The iterator will yield tuples containing the value and corresponding target to jump to, not\n+    /// including the `otherwise` fallback target.\n+    ///\n+    /// Note that this may yield 0 elements. Only the `otherwise` branch is mandatory.\n+    pub fn iter(&self) -> SwitchTargetsIter<'_> {\n+        SwitchTargetsIter { inner: self.values.iter().zip(self.targets.iter()) }\n+    }\n+\n+    /// Returns a slice with all possible jump targets (including the fallback target).\n+    pub fn all_targets(&self) -> &[BasicBlock] {\n+        &self.targets\n+    }\n+\n+    pub fn all_targets_mut(&mut self) -> &mut [BasicBlock] {\n+        &mut self.targets\n+    }\n+}\n+\n+pub struct SwitchTargetsIter<'a> {\n+    inner: iter::Zip<slice::Iter<'a, u128>, slice::Iter<'a, BasicBlock>>,\n+}\n+\n+impl<'a> Iterator for SwitchTargetsIter<'a> {\n+    type Item = (u128, BasicBlock);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.inner.next().map(|(val, bb)| (*val, *bb))\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+impl<'a> ExactSizeIterator for SwitchTargetsIter<'a> {}\n+\n #[derive(Clone, TyEncodable, TyDecodable, HashStable, PartialEq)]\n pub enum TerminatorKind<'tcx> {\n     /// Block should have one successor in the graph; we jump there.\n@@ -32,23 +114,7 @@ pub enum TerminatorKind<'tcx> {\n         /// FIXME: remove this redundant information. Currently, it is relied on by pretty-printing.\n         switch_ty: Ty<'tcx>,\n \n-        /// Possible values. The locations to branch to in each case\n-        /// are found in the corresponding indices from the `targets` vector.\n-        values: Cow<'tcx, [u128]>,\n-\n-        /// Possible branch sites. The last element of this vector is used\n-        /// for the otherwise branch, so targets.len() == values.len() + 1\n-        /// should hold.\n-        //\n-        // This invariant is quite non-obvious and also could be improved.\n-        // One way to make this invariant is to have something like this instead:\n-        //\n-        // branches: Vec<(ConstInt, BasicBlock)>,\n-        // otherwise: Option<BasicBlock> // exhaustive if None\n-        //\n-        // However we\u2019ve decided to keep this as-is until we figure a case\n-        // where some other approach seems to be strictly better than other.\n-        targets: Vec<BasicBlock>,\n+        targets: SwitchTargets,\n     },\n \n     /// Indicates that the landing pad is finished and unwinding should\n@@ -227,12 +293,10 @@ impl<'tcx> TerminatorKind<'tcx> {\n         t: BasicBlock,\n         f: BasicBlock,\n     ) -> TerminatorKind<'tcx> {\n-        static BOOL_SWITCH_FALSE: &[u128] = &[0];\n         TerminatorKind::SwitchInt {\n             discr: cond,\n             switch_ty: tcx.types.bool,\n-            values: From::from(BOOL_SWITCH_FALSE),\n-            targets: vec![f, t],\n+            targets: SwitchTargets::static_if(0, f, t),\n         }\n     }\n \n@@ -263,7 +327,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | FalseUnwind { real_target: ref t, unwind: Some(ref u) } => {\n                 Some(t).into_iter().chain(slice::from_ref(u))\n             }\n-            SwitchInt { ref targets, .. } => None.into_iter().chain(&targets[..]),\n+            SwitchInt { ref targets, .. } => None.into_iter().chain(&targets.targets[..]),\n             FalseEdge { ref real_target, ref imaginary_target } => {\n                 Some(real_target).into_iter().chain(slice::from_ref(imaginary_target))\n             }\n@@ -297,7 +361,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n             | FalseUnwind { real_target: ref mut t, unwind: Some(ref mut u) } => {\n                 Some(t).into_iter().chain(slice::from_mut(u))\n             }\n-            SwitchInt { ref mut targets, .. } => None.into_iter().chain(&mut targets[..]),\n+            SwitchInt { ref mut targets, .. } => None.into_iter().chain(&mut targets.targets[..]),\n             FalseEdge { ref mut real_target, ref mut imaginary_target } => {\n                 Some(real_target).into_iter().chain(slice::from_mut(imaginary_target))\n             }\n@@ -469,11 +533,12 @@ impl<'tcx> TerminatorKind<'tcx> {\n         match *self {\n             Return | Resume | Abort | Unreachable | GeneratorDrop => vec![],\n             Goto { .. } => vec![\"\".into()],\n-            SwitchInt { ref values, switch_ty, .. } => ty::tls::with(|tcx| {\n+            SwitchInt { ref targets, switch_ty, .. } => ty::tls::with(|tcx| {\n                 let param_env = ty::ParamEnv::empty();\n                 let switch_ty = tcx.lift(&switch_ty).unwrap();\n                 let size = tcx.layout_of(param_env.and(switch_ty)).unwrap().size;\n-                values\n+                targets\n+                    .values\n                     .iter()\n                     .map(|&u| {\n                         ty::Const::from_scalar(tcx, Scalar::from_uint(u, size), switch_ty)"}, {"sha": "9297aed66a459e3c1248bf64c650b2b91c180749", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -21,10 +21,9 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n \n         let kind = match self.kind {\n             Goto { target } => Goto { target },\n-            SwitchInt { ref discr, switch_ty, ref values, ref targets } => SwitchInt {\n+            SwitchInt { ref discr, switch_ty, ref targets } => SwitchInt {\n                 discr: discr.fold_with(folder),\n                 switch_ty: switch_ty.fold_with(folder),\n-                values: values.clone(),\n                 targets: targets.clone(),\n             },\n             Drop { ref place, target, unwind } => {"}, {"sha": "1adebe30b5ea9e8eafaed90c8fe91051face263d", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -453,7 +453,6 @@ macro_rules! make_mir_visitor {\n                     TerminatorKind::SwitchInt {\n                         discr,\n                         switch_ty,\n-                        values: _,\n                         targets: _\n                     } => {\n                         self.visit_operand(discr, location);"}, {"sha": "8c05e6fd5d0e4bf32bba4987f59b123241efa96b", "filename": "compiler/rustc_mir/src/borrow_check/invalidation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Finvalidation.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -117,7 +117,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n         self.check_activations(location);\n \n         match &terminator.kind {\n-            TerminatorKind::SwitchInt { ref discr, switch_ty: _, values: _, targets: _ } => {\n+            TerminatorKind::SwitchInt { ref discr, switch_ty: _, targets: _ } => {\n                 self.consume_operand(location, discr);\n             }\n             TerminatorKind::Drop { place: drop_place, target: _, unwind: _ } => {"}, {"sha": "4b7af271baef046467f84542839f78ecf5ff71a2", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -671,7 +671,7 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n         self.check_activations(loc, span, flow_state);\n \n         match term.kind {\n-            TerminatorKind::SwitchInt { ref discr, switch_ty: _, values: _, targets: _ } => {\n+            TerminatorKind::SwitchInt { ref discr, switch_ty: _, targets: _ } => {\n                 self.consume_operand(loc, (discr, span), flow_state);\n             }\n             TerminatorKind::Drop { place: ref drop_place, target: _, unwind: _ } => {"}, {"sha": "4fc1c570e4602fbad802d6aa4556b777a4204603", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -1777,7 +1777,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 self.assert_iscleanup(body, block_data, target, is_cleanup)\n             }\n             TerminatorKind::SwitchInt { ref targets, .. } => {\n-                for target in targets {\n+                for target in targets.all_targets() {\n                     self.assert_iscleanup(body, block_data, *target, is_cleanup);\n                 }\n             }"}, {"sha": "8a9ced91eb3763c66d15f6799f6c7a78e1408526", "filename": "compiler/rustc_mir/src/dataflow/framework/direction.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -1,5 +1,5 @@\n use rustc_index::bit_set::BitSet;\n-use rustc_middle::mir::{self, BasicBlock, Location};\n+use rustc_middle::mir::{self, BasicBlock, Location, SwitchTargets};\n use rustc_middle::ty::TyCtxt;\n use std::ops::RangeInclusive;\n \n@@ -488,11 +488,10 @@ impl Direction for Forward {\n                 }\n             }\n \n-            SwitchInt { ref targets, ref values, ref discr, switch_ty: _ } => {\n+            SwitchInt { ref targets, ref discr, switch_ty: _ } => {\n                 let mut applier = SwitchIntEdgeEffectApplier {\n                     exit_state,\n-                    targets: targets.as_ref(),\n-                    values: values.as_ref(),\n+                    targets,\n                     propagate,\n                     effects_applied: false,\n                 };\n@@ -504,8 +503,8 @@ impl Direction for Forward {\n                 } = applier;\n \n                 if !effects_applied {\n-                    for &target in targets.iter() {\n-                        propagate(target, exit_state);\n+                    for target in targets.all_targets() {\n+                        propagate(*target, exit_state);\n                     }\n                 }\n             }\n@@ -515,8 +514,7 @@ impl Direction for Forward {\n \n struct SwitchIntEdgeEffectApplier<'a, D, F> {\n     exit_state: &'a mut D,\n-    values: &'a [u128],\n-    targets: &'a [BasicBlock],\n+    targets: &'a SwitchTargets,\n     propagate: F,\n \n     effects_applied: bool,\n@@ -531,15 +529,15 @@ where\n         assert!(!self.effects_applied);\n \n         let mut tmp = None;\n-        for (&value, &target) in self.values.iter().zip(self.targets.iter()) {\n+        for (value, target) in self.targets.iter() {\n             let tmp = opt_clone_from_or_clone(&mut tmp, self.exit_state);\n             apply_edge_effect(tmp, SwitchIntTarget { value: Some(value), target });\n             (self.propagate)(target, tmp);\n         }\n \n         // Once we get to the final, \"otherwise\" branch, there is no need to preserve `exit_state`,\n         // so pass it directly to `apply_edge_effect` to save a clone of the dataflow state.\n-        let otherwise = self.targets.last().copied().unwrap();\n+        let otherwise = self.targets.otherwise();\n         apply_edge_effect(self.exit_state, SwitchIntTarget { value: None, target: otherwise });\n         (self.propagate)(otherwise, self.exit_state);\n "}, {"sha": "bb11c2a23bd813c230c94b9dfe0640ffed35701e", "filename": "compiler/rustc_mir/src/interpret/terminator.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -24,16 +24,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Goto { target } => self.go_to_block(target),\n \n-            SwitchInt { ref discr, ref values, ref targets, switch_ty } => {\n+            SwitchInt { ref discr, ref targets, switch_ty } => {\n                 let discr = self.read_immediate(self.eval_operand(discr, None)?)?;\n                 trace!(\"SwitchInt({:?})\", *discr);\n                 assert_eq!(discr.layout.ty, switch_ty);\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n-                assert!(!targets.is_empty());\n-                let mut target_block = targets[targets.len() - 1];\n+                assert!(!targets.iter().is_empty());\n+                let mut target_block = targets.otherwise();\n \n-                for (index, &const_int) in values.iter().enumerate() {\n+                for (const_int, target) in targets.iter() {\n                     // Compare using binary_op, to also support pointer values\n                     let res = self\n                         .overflowing_binary_op(\n@@ -43,7 +43,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         )?\n                         .0;\n                     if res.to_bool()? {\n-                        target_block = targets[index];\n+                        target_block = target;\n                         break;\n                     }\n                 }"}, {"sha": "f97dcf4852df477a398485fce1207949200a4329", "filename": "compiler/rustc_mir/src/transform/early_otherwise_branch.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fearly_otherwise_branch.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -1,7 +1,7 @@\n use crate::{transform::MirPass, util::patch::MirPatch};\n use rustc_middle::mir::*;\n use rustc_middle::ty::{Ty, TyCtxt};\n-use std::{borrow::Cow, fmt::Debug};\n+use std::fmt::Debug;\n \n use super::simplify::simplify_cfg;\n \n@@ -95,24 +95,25 @@ impl<'tcx> MirPass<'tcx> for EarlyOtherwiseBranch {\n                 StatementKind::Assign(box (Place::from(not_equal_temp), not_equal_rvalue)),\n             );\n \n-            let (mut targets_to_jump_to, values_to_jump_to): (Vec<_>, Vec<_>) = opt_to_apply\n+            let new_targets = opt_to_apply\n                 .infos\n                 .iter()\n                 .flat_map(|x| x.second_switch_info.targets_with_values.iter())\n-                .cloned()\n-                .unzip();\n+                .cloned();\n+\n+            let targets = SwitchTargets::new(\n+                new_targets,\n+                opt_to_apply.infos[0].first_switch_info.otherwise_bb,\n+            );\n \n-            // add otherwise case in the end\n-            targets_to_jump_to.push(opt_to_apply.infos[0].first_switch_info.otherwise_bb);\n             // new block that jumps to the correct discriminant case. This block is switched to if the discriminants are equal\n             let new_switch_data = BasicBlockData::new(Some(Terminator {\n                 source_info: opt_to_apply.infos[0].second_switch_info.discr_source_info,\n                 kind: TerminatorKind::SwitchInt {\n                     // the first and second discriminants are equal, so just pick one\n                     discr: Operand::Copy(first_descriminant_place),\n                     switch_ty: discr_type,\n-                    values: Cow::from(values_to_jump_to),\n-                    targets: targets_to_jump_to,\n+                    targets,\n                 },\n             }));\n \n@@ -176,7 +177,7 @@ struct SwitchDiscriminantInfo<'tcx> {\n     /// The basic block that the otherwise branch points to\n     otherwise_bb: BasicBlock,\n     /// Target along with the value being branched from. Otherwise is not included\n-    targets_with_values: Vec<(BasicBlock, u128)>,\n+    targets_with_values: Vec<(u128, BasicBlock)>,\n     discr_source_info: SourceInfo,\n     /// The place of the discriminant used in the switch\n     discr_used_in_switch: Place<'tcx>,\n@@ -211,7 +212,7 @@ impl<'a, 'tcx> Helper<'a, 'tcx> {\n         let discr = self.find_switch_discriminant_info(bb, switch)?;\n \n         // go through each target, finding a discriminant read, and a switch\n-        let results = discr.targets_with_values.iter().map(|(target, value)| {\n+        let results = discr.targets_with_values.iter().map(|(value, target)| {\n             self.find_discriminant_switch_pairing(&discr, target.clone(), value.clone())\n         });\n \n@@ -253,7 +254,7 @@ impl<'a, 'tcx> Helper<'a, 'tcx> {\n             }\n \n             // check that the value being matched on is the same. The\n-            if this_bb_discr_info.targets_with_values.iter().find(|x| x.1 == value).is_none() {\n+            if this_bb_discr_info.targets_with_values.iter().find(|x| x.0 == value).is_none() {\n                 trace!(\"NO: values being matched on are not the same\");\n                 return None;\n             }\n@@ -270,7 +271,7 @@ impl<'a, 'tcx> Helper<'a, 'tcx> {\n             //  ```\n             // We check this by seeing that the value of the first discriminant is the only other discriminant value being used as a target in the second switch\n             if !(this_bb_discr_info.targets_with_values.len() == 1\n-                && this_bb_discr_info.targets_with_values[0].1 == value)\n+                && this_bb_discr_info.targets_with_values[0].0 == value)\n             {\n                 trace!(\n                     \"NO: The second switch did not have only 1 target (besides otherwise) that had the same value as the value from the first switch that got us here\"\n@@ -296,18 +297,14 @@ impl<'a, 'tcx> Helper<'a, 'tcx> {\n         switch: &Terminator<'tcx>,\n     ) -> Option<SwitchDiscriminantInfo<'tcx>> {\n         match &switch.kind {\n-            TerminatorKind::SwitchInt { discr, targets, values, .. } => {\n+            TerminatorKind::SwitchInt { discr, targets, .. } => {\n                 let discr_local = discr.place()?.as_local()?;\n                 // the declaration of the discriminant read. Place of this read is being used in the switch\n                 let discr_decl = &self.body.local_decls()[discr_local];\n                 let discr_ty = discr_decl.ty;\n                 // the otherwise target lies as the last element\n-                let otherwise_bb = targets.get(values.len())?.clone();\n-                let targets_with_values = targets\n-                    .iter()\n-                    .zip(values.iter())\n-                    .map(|(t, v)| (t.clone(), v.clone()))\n-                    .collect();\n+                let otherwise_bb = targets.otherwise();\n+                let targets_with_values = targets.iter().collect();\n \n                 // find the place of the adt where the discriminant is being read from\n                 // assume this is the last statement of the block"}, {"sha": "039d4753a8c2da96b4e3015e876e8a7f8a3cfd9a", "filename": "compiler/rustc_mir/src/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -71,7 +71,6 @@ use rustc_middle::ty::GeneratorSubsts;\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::PanicStrategy;\n-use std::borrow::Cow;\n use std::{iter, ops};\n \n pub struct StateTransform;\n@@ -839,11 +838,12 @@ fn insert_switch<'tcx>(\n ) {\n     let default_block = insert_term_block(body, default);\n     let (assign, discr) = transform.get_discr(body);\n+    let switch_targets =\n+        SwitchTargets::new(cases.iter().map(|(i, bb)| ((*i) as u128, *bb)), default_block);\n     let switch = TerminatorKind::SwitchInt {\n         discr: Operand::Move(discr),\n         switch_ty: transform.discr_ty,\n-        values: Cow::from(cases.iter().map(|&(i, _)| i as u128).collect::<Vec<_>>()),\n-        targets: cases.iter().map(|&(_, d)| d).chain(iter::once(default_block)).collect(),\n+        targets: switch_targets,\n     };\n \n     let source_info = SourceInfo::outermost(body.span);"}, {"sha": "34aaefdcbeab60415679f88d7c6edc71203c3cd6", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -771,7 +771,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n                 *target = self.update_target(*target);\n             }\n             TerminatorKind::SwitchInt { ref mut targets, .. } => {\n-                for tgt in targets {\n+                for tgt in targets.all_targets_mut() {\n                     *tgt = self.update_target(*tgt);\n                 }\n             }"}, {"sha": "8b2d6b09aa83082d81958ee2dc5e5abbdd03a222", "filename": "compiler/rustc_mir/src/transform/match_branches.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -46,10 +46,13 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n                     discr: Operand::Copy(ref place) | Operand::Move(ref place),\n                     switch_ty,\n                     ref targets,\n-                    ref values,\n                     ..\n-                } if targets.len() == 2 && values.len() == 1 && targets[0] != targets[1] => {\n-                    (place, values[0], switch_ty, targets[0], targets[1])\n+                } if targets.iter().len() == 1 => {\n+                    let (value, target) = targets.iter().next().unwrap();\n+                    if target == targets.otherwise() {\n+                        continue;\n+                    }\n+                    (place, value, switch_ty, target, targets.otherwise())\n                 }\n                 // Only optimize switch int statements\n                 _ => continue,"}, {"sha": "5f63c03993d3a7d56a718ed0665961198b840cf1", "filename": "compiler/rustc_mir/src/transform/simplify_branches.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_branches.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -29,17 +29,16 @@ impl<'tcx> MirPass<'tcx> for SimplifyBranches {\n                 TerminatorKind::SwitchInt {\n                     discr: Operand::Constant(ref c),\n                     switch_ty,\n-                    ref values,\n                     ref targets,\n                     ..\n                 } => {\n                     let constant = c.literal.try_eval_bits(tcx, param_env, switch_ty);\n                     if let Some(constant) = constant {\n-                        let (otherwise, targets) = targets.split_last().unwrap();\n-                        let mut ret = TerminatorKind::Goto { target: *otherwise };\n-                        for (&v, t) in values.iter().zip(targets.iter()) {\n+                        let otherwise = targets.otherwise();\n+                        let mut ret = TerminatorKind::Goto { target: otherwise };\n+                        for (v, t) in targets.iter() {\n                             if v == constant {\n-                                ret = TerminatorKind::Goto { target: *t };\n+                                ret = TerminatorKind::Goto { target: t };\n                                 break;\n                             }\n                         }"}, {"sha": "6372f8960ddb66f8f0aa64cbd4b03b6f1cf3adbe", "filename": "compiler/rustc_mir/src/transform/simplify_comparison_integral.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -1,8 +1,10 @@\n+use std::iter;\n+\n use super::MirPass;\n use rustc_middle::{\n     mir::{\n         interpret::Scalar, BasicBlock, BinOp, Body, Operand, Place, Rvalue, Statement,\n-        StatementKind, TerminatorKind,\n+        StatementKind, SwitchTargets, TerminatorKind,\n     },\n     ty::{Ty, TyCtxt},\n };\n@@ -43,19 +45,21 @@ impl<'tcx> MirPass<'tcx> for SimplifyComparisonIntegral {\n                 Scalar::Ptr(_) => continue,\n             };\n             const FALSE: u128 = 0;\n-            let mut new_targets = opt.targets.clone();\n-            let first_is_false_target = opt.values[0] == FALSE;\n+\n+            let mut new_targets = opt.targets;\n+            let first_value = new_targets.iter().next().unwrap().0;\n+            let first_is_false_target = first_value == FALSE;\n             match opt.op {\n                 BinOp::Eq => {\n                     // if the assignment was Eq we want the true case to be first\n                     if first_is_false_target {\n-                        new_targets.swap(0, 1);\n+                        new_targets.all_targets_mut().swap(0, 1);\n                     }\n                 }\n                 BinOp::Ne => {\n                     // if the assignment was Ne we want the false case to be first\n                     if !first_is_false_target {\n-                        new_targets.swap(0, 1);\n+                        new_targets.all_targets_mut().swap(0, 1);\n                     }\n                 }\n                 _ => unreachable!(),\n@@ -96,7 +100,7 @@ impl<'tcx> MirPass<'tcx> for SimplifyComparisonIntegral {\n                 }\n                 storage_deads_to_remove.push((stmt_idx, opt.bb_idx));\n                 // if we have StorageDeads to remove then make sure to insert them at the top of each target\n-                for bb_idx in new_targets.iter() {\n+                for bb_idx in new_targets.all_targets() {\n                     storage_deads_to_insert.push((\n                         *bb_idx,\n                         Statement {\n@@ -107,13 +111,18 @@ impl<'tcx> MirPass<'tcx> for SimplifyComparisonIntegral {\n                 }\n             }\n \n-            let terminator = bb.terminator_mut();\n+            let [bb_cond, bb_otherwise] = match new_targets.all_targets() {\n+                [a, b] => [*a, *b],\n+                e => bug!(\"expected 2 switch targets, got: {:?}\", e),\n+            };\n+\n+            let targets = SwitchTargets::new(iter::once((new_value, bb_cond)), bb_otherwise);\n \n+            let terminator = bb.terminator_mut();\n             terminator.kind = TerminatorKind::SwitchInt {\n                 discr: Operand::Move(opt.to_switch_on),\n                 switch_ty: opt.branch_value_ty,\n-                values: vec![new_value].into(),\n-                targets: new_targets,\n+                targets,\n             };\n         }\n \n@@ -138,15 +147,13 @@ impl<'a, 'tcx> OptimizationFinder<'a, 'tcx> {\n             .iter_enumerated()\n             .filter_map(|(bb_idx, bb)| {\n                 // find switch\n-                let (place_switched_on, values, targets, place_switched_on_moved) = match &bb\n-                    .terminator()\n-                    .kind\n-                {\n-                    rustc_middle::mir::TerminatorKind::SwitchInt {\n-                        discr, values, targets, ..\n-                    } => Some((discr.place()?, values, targets, discr.is_move())),\n-                    _ => None,\n-                }?;\n+                let (place_switched_on, targets, place_switched_on_moved) =\n+                    match &bb.terminator().kind {\n+                        rustc_middle::mir::TerminatorKind::SwitchInt { discr, targets, .. } => {\n+                            Some((discr.place()?, targets, discr.is_move()))\n+                        }\n+                        _ => None,\n+                    }?;\n \n                 // find the statement that assigns the place being switched on\n                 bb.statements.iter().enumerate().rev().find_map(|(stmt_idx, stmt)| {\n@@ -167,7 +174,6 @@ impl<'a, 'tcx> OptimizationFinder<'a, 'tcx> {\n                                         branch_value_scalar,\n                                         branch_value_ty,\n                                         op: *op,\n-                                        values: values.clone().into_owned(),\n                                         targets: targets.clone(),\n                                     })\n                                 }\n@@ -220,8 +226,6 @@ struct OptimizationInfo<'tcx> {\n     branch_value_ty: Ty<'tcx>,\n     /// Either Eq or Ne\n     op: BinOp,\n-    /// Current values used in the switch target. This needs to be replaced with the branch_value\n-    values: Vec<u128>,\n     /// Current targets used in the switch\n-    targets: Vec<BasicBlock>,\n+    targets: SwitchTargets,\n }"}, {"sha": "27bb1def726e1a51ed5cf6f68e3ea848c29f2e84", "filename": "compiler/rustc_mir/src/transform/simplify_try.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -576,15 +576,13 @@ impl<'a, 'tcx> SimplifyBranchSameOptimizationFinder<'a, 'tcx> {\n             .iter_enumerated()\n             .filter_map(|(bb_idx, bb)| {\n                 let (discr_switched_on, targets_and_values) = match &bb.terminator().kind {\n-                    TerminatorKind::SwitchInt { targets, discr, values, .. } => {\n-                        // if values.len() == targets.len() - 1, we need to include None where no value is present\n-                        // such that the zip does not throw away targets. If no `otherwise` case is in targets, the zip will simply throw away the added None\n-                        let values_extended = values.iter().map(|x|Some(*x)).chain(once(None));\n-                        let targets_and_values:Vec<_> = targets.iter().zip(values_extended)\n-                            .map(|(target, value)| SwitchTargetAndValue{target:*target, value})\n+                    TerminatorKind::SwitchInt { targets, discr, .. } => {\n+                        let targets_and_values: Vec<_> = targets.iter()\n+                            .map(|(val, target)| SwitchTargetAndValue { target, value: Some(val) })\n+                            .chain(once(SwitchTargetAndValue { target: targets.otherwise(), value: None }))\n                             .collect();\n-                        assert_eq!(targets.len(), targets_and_values.len());\n-                        (discr, targets_and_values)},\n+                        (discr, targets_and_values)\n+                    },\n                     _ => return None,\n                 };\n "}, {"sha": "465832c89fd00871b7f7117c0d28ee196152efc4", "filename": "compiler/rustc_mir/src/transform/uninhabited_enum_branching.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Funinhabited_enum_branching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Funinhabited_enum_branching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Funinhabited_enum_branching.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -3,7 +3,8 @@\n use crate::transform::MirPass;\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_middle::mir::{\n-    BasicBlock, BasicBlockData, Body, Local, Operand, Rvalue, StatementKind, TerminatorKind,\n+    BasicBlock, BasicBlockData, Body, Local, Operand, Rvalue, StatementKind, SwitchTargets,\n+    TerminatorKind,\n };\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::{Ty, TyCtxt};\n@@ -101,21 +102,15 @@ impl<'tcx> MirPass<'tcx> for UninhabitedEnumBranching {\n \n             trace!(\"allowed_variants = {:?}\", allowed_variants);\n \n-            if let TerminatorKind::SwitchInt { values, targets, .. } =\n+            if let TerminatorKind::SwitchInt { targets, .. } =\n                 &mut body.basic_blocks_mut()[bb].terminator_mut().kind\n             {\n-                // take otherwise out early\n-                let otherwise = targets.pop().unwrap();\n-                assert_eq!(targets.len(), values.len());\n-                let mut i = 0;\n-                targets.retain(|_| {\n-                    let keep = allowed_variants.contains(&values[i]);\n-                    i += 1;\n-                    keep\n-                });\n-                targets.push(otherwise);\n-\n-                values.to_mut().retain(|var| allowed_variants.contains(var));\n+                let new_targets = SwitchTargets::new(\n+                    targets.iter().filter(|(val, _)| allowed_variants.contains(val)),\n+                    targets.otherwise(),\n+                );\n+\n+                *targets = new_targets;\n             } else {\n                 unreachable!()\n             }"}, {"sha": "f6d39dae3429e18b2651c73abeedb3b38e5454b6", "filename": "compiler/rustc_mir/src/transform/unreachable_prop.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Funreachable_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Funreachable_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Funreachable_prop.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -7,7 +7,6 @@ use crate::transform::MirPass;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n-use std::borrow::Cow;\n \n pub struct UnreachablePropagation;\n \n@@ -69,14 +68,15 @@ where\n {\n     let terminator = match *terminator_kind {\n         TerminatorKind::Goto { target } if predicate(target) => TerminatorKind::Unreachable,\n-        TerminatorKind::SwitchInt { ref discr, switch_ty, ref values, ref targets } => {\n-            let original_targets_len = targets.len();\n-            let (otherwise, targets) = targets.split_last().unwrap();\n+        TerminatorKind::SwitchInt { ref discr, switch_ty, ref targets } => {\n+            let otherwise = targets.otherwise();\n+\n+            let original_targets_len = targets.iter().len() + 1;\n             let (mut values, mut targets): (Vec<_>, Vec<_>) =\n-                values.iter().zip(targets.iter()).filter(|(_, &t)| !predicate(t)).unzip();\n+                targets.iter().filter(|(_, bb)| !predicate(*bb)).unzip();\n \n-            if !predicate(*otherwise) {\n-                targets.push(*otherwise);\n+            if !predicate(otherwise) {\n+                targets.push(otherwise);\n             } else {\n                 values.pop();\n             }\n@@ -91,8 +91,10 @@ where\n                 TerminatorKind::SwitchInt {\n                     discr: discr.clone(),\n                     switch_ty,\n-                    values: Cow::from(values),\n-                    targets,\n+                    targets: SwitchTargets::new(\n+                        values.iter().copied().zip(targets.iter().copied()),\n+                        *targets.last().unwrap(),\n+                    ),\n                 }\n             } else {\n                 return None;"}, {"sha": "48477f60ef72e779ec9b6de46cab3d3cfd829970", "filename": "compiler/rustc_mir/src/transform/validate.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -334,7 +334,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             TerminatorKind::Goto { target } => {\n                 self.check_edge(location, *target, EdgeKind::Normal);\n             }\n-            TerminatorKind::SwitchInt { targets, values, switch_ty, discr } => {\n+            TerminatorKind::SwitchInt { targets, switch_ty, discr } => {\n                 let ty = discr.ty(&self.body.local_decls, self.tcx);\n                 if ty != *switch_ty {\n                     self.fail(\n@@ -345,19 +345,10 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                         ),\n                     );\n                 }\n-                if targets.len() != values.len() + 1 {\n-                    self.fail(\n-                        location,\n-                        format!(\n-                            \"encountered `SwitchInt` terminator with {} values, but {} targets (should be values+1)\",\n-                            values.len(),\n-                            targets.len(),\n-                        ),\n-                    );\n-                }\n-                for target in targets {\n-                    self.check_edge(location, *target, EdgeKind::Normal);\n+                for (_, target) in targets.iter() {\n+                    self.check_edge(location, target, EdgeKind::Normal);\n                 }\n+                self.check_edge(location, targets.otherwise(), EdgeKind::Normal);\n             }\n             TerminatorKind::Drop { target, unwind, .. } => {\n                 self.check_edge(location, *target, EdgeKind::Normal);"}, {"sha": "0e2d8e5495b72590f535884e2a5a75a1c6300ffc", "filename": "compiler/rustc_mir/src/util/elaborate_drops.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir%2Fsrc%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Felaborate_drops.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -588,8 +588,10 @@ where\n                 kind: TerminatorKind::SwitchInt {\n                     discr: Operand::Move(discr),\n                     switch_ty: discr_ty,\n-                    values: From::from(values.to_owned()),\n-                    targets: blocks,\n+                    targets: SwitchTargets::new(\n+                        values.iter().copied().zip(blocks.iter().copied()),\n+                        *blocks.last().unwrap(),\n+                    ),\n                 },\n             }),\n             is_cleanup: unwind.is_cleanup(),\n@@ -758,8 +760,6 @@ where\n         let elem_size = Place::from(self.new_temp(tcx.types.usize));\n         let len = Place::from(self.new_temp(tcx.types.usize));\n \n-        static USIZE_SWITCH_ZERO: &[u128] = &[0];\n-\n         let base_block = BasicBlockData {\n             statements: vec![\n                 self.assign(elem_size, Rvalue::NullaryOp(NullOp::SizeOf, ety)),\n@@ -771,11 +771,11 @@ where\n                 kind: TerminatorKind::SwitchInt {\n                     discr: move_(elem_size),\n                     switch_ty: tcx.types.usize,\n-                    values: From::from(USIZE_SWITCH_ZERO),\n-                    targets: vec![\n+                    targets: SwitchTargets::static_if(\n+                        0,\n                         self.drop_loop_pair(ety, false, len),\n                         self.drop_loop_pair(ety, true, len),\n-                    ],\n+                    ),\n                 },\n             }),\n         };"}, {"sha": "c41919001477e7408d33dad9a317d87ac443a855", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -167,48 +167,42 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let target_blocks = make_target_blocks(self);\n                 // Variants is a BitVec of indexes into adt_def.variants.\n                 let num_enum_variants = adt_def.variants.len();\n-                let used_variants = variants.count();\n                 debug_assert_eq!(target_blocks.len(), num_enum_variants + 1);\n                 let otherwise_block = *target_blocks.last().unwrap();\n-                let mut targets = Vec::with_capacity(used_variants + 1);\n-                let mut values = Vec::with_capacity(used_variants);\n                 let tcx = self.hir.tcx();\n-                for (idx, discr) in adt_def.discriminants(tcx) {\n-                    if variants.contains(idx) {\n-                        debug_assert_ne!(\n-                            target_blocks[idx.index()],\n-                            otherwise_block,\n-                            \"no canididates for tested discriminant: {:?}\",\n-                            discr,\n-                        );\n-                        values.push(discr.val);\n-                        targets.push(target_blocks[idx.index()]);\n-                    } else {\n-                        debug_assert_eq!(\n-                            target_blocks[idx.index()],\n-                            otherwise_block,\n-                            \"found canididates for untested discriminant: {:?}\",\n-                            discr,\n-                        );\n-                    }\n-                }\n-                targets.push(otherwise_block);\n-                debug!(\n-                    \"num_enum_variants: {}, tested variants: {:?}, variants: {:?}\",\n-                    num_enum_variants, values, variants\n+                let switch_targets = SwitchTargets::new(\n+                    adt_def.discriminants(tcx).filter_map(|(idx, discr)| {\n+                        if variants.contains(idx) {\n+                            debug_assert_ne!(\n+                                target_blocks[idx.index()],\n+                                otherwise_block,\n+                                \"no canididates for tested discriminant: {:?}\",\n+                                discr,\n+                            );\n+                            Some((discr.val, target_blocks[idx.index()]))\n+                        } else {\n+                            debug_assert_eq!(\n+                                target_blocks[idx.index()],\n+                                otherwise_block,\n+                                \"found canididates for untested discriminant: {:?}\",\n+                                discr,\n+                            );\n+                            None\n+                        }\n+                    }),\n+                    otherwise_block,\n                 );\n+                debug!(\"num_enum_variants: {}, variants: {:?}\", num_enum_variants, variants);\n                 let discr_ty = adt_def.repr.discr_type().to_ty(tcx);\n                 let discr = self.temp(discr_ty, test.span);\n                 self.cfg.push_assign(block, source_info, discr, Rvalue::Discriminant(place));\n-                assert_eq!(values.len() + 1, targets.len());\n                 self.cfg.terminate(\n                     block,\n                     source_info,\n                     TerminatorKind::SwitchInt {\n                         discr: Operand::Move(discr),\n                         switch_ty: discr_ty,\n-                        values: From::from(values),\n-                        targets,\n+                        targets: switch_targets,\n                     },\n                 );\n             }\n@@ -230,11 +224,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 } else {\n                     // The switch may be inexhaustive so we have a catch all block\n                     debug_assert_eq!(options.len() + 1, target_blocks.len());\n+                    let otherwise_block = *target_blocks.last().unwrap();\n+                    let switch_targets = SwitchTargets::new(\n+                        options.values().copied().zip(target_blocks),\n+                        otherwise_block,\n+                    );\n                     TerminatorKind::SwitchInt {\n                         discr: Operand::Copy(place),\n                         switch_ty,\n-                        values: options.values().copied().collect(),\n-                        targets: target_blocks,\n+                        targets: switch_targets,\n                     }\n                 };\n                 self.cfg.terminate(block, source_info, terminator);"}, {"sha": "7cb7d0a26b65eb0d6cf3be4e011f0204fdd92fde", "filename": "src/tools/clippy/clippy_lints/src/utils/qualify_min_const_fn.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/afb4514c099fde6e3102373602bea9e6dacd4f88/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afb4514c099fde6e3102373602bea9e6dacd4f88/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fqualify_min_const_fn.rs?ref=afb4514c099fde6e3102373602bea9e6dacd4f88", "patch": "@@ -282,7 +282,6 @@ fn check_terminator(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, terminator: &Termin\n         TerminatorKind::SwitchInt {\n             discr,\n             switch_ty: _,\n-            values: _,\n             targets: _,\n         } => check_operand(tcx, discr, span, body),\n "}]}