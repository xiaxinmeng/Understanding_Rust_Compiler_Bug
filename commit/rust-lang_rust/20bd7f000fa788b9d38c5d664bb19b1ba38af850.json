{"sha": "20bd7f000fa788b9d38c5d664bb19b1ba38af850", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwYmQ3ZjAwMGZhNzg4YjlkMzhjNWQ2NjRiYjE5YjFiYTM4YWY4NTA=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2016-11-21T22:26:31Z"}, "committer": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2016-11-21T22:26:31Z"}, "message": "utf8 validation: Compute block end upfront\n\nSimplify the conditional used for ensuring that the whole word loop is\nonly used if there are at least two whole words left to read.\n\nThis makes the function slightly smaller and simpler, a 0-5% reduction\nin runtime for various test cases.", "tree": {"sha": "2256c777d7d36306c60b23b1f47e34fa0a72072d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2256c777d7d36306c60b23b1f47e34fa0a72072d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20bd7f000fa788b9d38c5d664bb19b1ba38af850", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20bd7f000fa788b9d38c5d664bb19b1ba38af850", "html_url": "https://github.com/rust-lang/rust/commit/20bd7f000fa788b9d38c5d664bb19b1ba38af850", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20bd7f000fa788b9d38c5d664bb19b1ba38af850/comments", "author": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a3aa2f73cbb08c6e41418c5378791fa24a66146", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a3aa2f73cbb08c6e41418c5378791fa24a66146", "html_url": "https://github.com/rust-lang/rust/commit/5a3aa2f73cbb08c6e41418c5378791fa24a66146"}], "stats": {"total": 31, "additions": 16, "deletions": 15}, "files": [{"sha": "48c0f0b27087fe924cea5205089ac391937c485f", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/20bd7f000fa788b9d38c5d664bb19b1ba38af850/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20bd7f000fa788b9d38c5d664bb19b1ba38af850/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=20bd7f000fa788b9d38c5d664bb19b1ba38af850", "patch": "@@ -1217,6 +1217,11 @@ fn contains_nonascii(x: usize) -> bool {\n fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n     let mut offset = 0;\n     let len = v.len();\n+\n+    let usize_bytes = mem::size_of::<usize>();\n+    let ascii_block_size = 2 * usize_bytes;\n+    let blocks_end = if len >= ascii_block_size { len - ascii_block_size + 1 } else { 0 };\n+\n     while offset < len {\n         let old_offset = offset;\n         macro_rules! err { () => {{\n@@ -1282,26 +1287,22 @@ fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n             // Ascii case, try to skip forward quickly.\n             // When the pointer is aligned, read 2 words of data per iteration\n             // until we find a word containing a non-ascii byte.\n-            let usize_bytes = mem::size_of::<usize>();\n-            let bytes_per_iteration = 2 * usize_bytes;\n             let ptr = v.as_ptr();\n             let align = (ptr as usize + offset) & (usize_bytes - 1);\n             if align == 0 {\n-                if len >= bytes_per_iteration {\n-                    while offset <= len - bytes_per_iteration {\n-                        unsafe {\n-                            let u = *(ptr.offset(offset as isize) as *const usize);\n-                            let v = *(ptr.offset((offset + usize_bytes) as isize) as *const usize);\n-\n-                            // break if there is a nonascii byte\n-                            let zu = contains_nonascii(u);\n-                            let zv = contains_nonascii(v);\n-                            if zu || zv {\n-                                break;\n-                            }\n+                while offset < blocks_end {\n+                    unsafe {\n+                        let u = *(ptr.offset(offset as isize) as *const usize);\n+                        let v = *(ptr.offset((offset + usize_bytes) as isize) as *const usize);\n+\n+                        // break if there is a nonascii byte\n+                        let zu = contains_nonascii(u);\n+                        let zv = contains_nonascii(v);\n+                        if zu || zv {\n+                            break;\n                         }\n-                        offset += bytes_per_iteration;\n                     }\n+                    offset += ascii_block_size;\n                 }\n                 // step from the point where the wordwise loop stopped\n                 while offset < len && v[offset] < 128 {"}]}