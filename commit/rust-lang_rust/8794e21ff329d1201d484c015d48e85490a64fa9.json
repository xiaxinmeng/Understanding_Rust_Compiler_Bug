{"sha": "8794e21ff329d1201d484c015d48e85490a64fa9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3OTRlMjFmZjMyOWQxMjAxZDQ4NGMwMTVkNDhlODU0OTBhNjRmYTk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-03-29T01:40:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-29T01:40:45Z"}, "message": "Rollup merge of #58019 - Zoxc:combine-late-lints, r=estebank\n\nCombine all builtin late lints and make lint checking parallel\n\nBlocked on https://github.com/rust-lang/rust/pull/57293.\n\nCuts runtime of late lint checking from 3.222s to 0.546s with 8 threads on `winapi` (@retep998 ;) )\n\nr? @estebank", "tree": {"sha": "14d0851349b8fafed78520525bb9751746f458fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14d0851349b8fafed78520525bb9751746f458fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8794e21ff329d1201d484c015d48e85490a64fa9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcnXedCRBK7hj4Ov3rIwAAdHIIAJwICuHaIb1B751HvQxSJvFM\nPexfNNK/EF9Km9LpjK5O+JY0geSS/ck/hj7pp86emx/2K3vJiK6herHip0tEJMAn\nITCnQ5iW7RvLBIFamjrD32XMJRZZ+eoVWdBuEDq1lpzESE11MS9+y6yopDncysmx\ndxLzr9JVa3DS+fc+g5EakqgQMdgRx6OefsA4e1kU+7047gPS7knkxbxX+kMSu9NZ\nH86YBi3RSvKcSIU2Sb+kz5mIW8Unve9eSTMujo+sox0fpyzrieNtApAKdH1mrW6v\n4kjWASOexh3AgZ6GHgo71Apw5fKDsqDbKTAJimqUl56w7Ox8pyA8lF2LDNUCBQA=\n=qHIE\n-----END PGP SIGNATURE-----\n", "payload": "tree 14d0851349b8fafed78520525bb9751746f458fc\nparent 70a497a43794f0da5610c6da835ed3e02cd9af4d\nparent dee389f749ebe2b6a80e08550ccd8aa8e5a1f019\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1553823645 +0100\ncommitter GitHub <noreply@github.com> 1553823645 +0100\n\nRollup merge of #58019 - Zoxc:combine-late-lints, r=estebank\n\nCombine all builtin late lints and make lint checking parallel\n\nBlocked on https://github.com/rust-lang/rust/pull/57293.\n\nCuts runtime of late lint checking from 3.222s to 0.546s with 8 threads on `winapi` (@retep998 ;) )\n\nr? @estebank\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8794e21ff329d1201d484c015d48e85490a64fa9", "html_url": "https://github.com/rust-lang/rust/commit/8794e21ff329d1201d484c015d48e85490a64fa9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8794e21ff329d1201d484c015d48e85490a64fa9/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70a497a43794f0da5610c6da835ed3e02cd9af4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/70a497a43794f0da5610c6da835ed3e02cd9af4d", "html_url": "https://github.com/rust-lang/rust/commit/70a497a43794f0da5610c6da835ed3e02cd9af4d"}, {"sha": "dee389f749ebe2b6a80e08550ccd8aa8e5a1f019", "url": "https://api.github.com/repos/rust-lang/rust/commits/dee389f749ebe2b6a80e08550ccd8aa8e5a1f019", "html_url": "https://github.com/rust-lang/rust/commit/dee389f749ebe2b6a80e08550ccd8aa8e5a1f019"}], "stats": {"total": 655, "additions": 382, "deletions": 273}, "files": [{"sha": "e5eafd768bb0b5d5abdffa7a11512eaa3a0e70a6", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 255, "deletions": 194, "changes": 449, "blob_url": "https://github.com/rust-lang/rust/blob/8794e21ff329d1201d484c015d48e85490a64fa9/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8794e21ff329d1201d484c015d48e85490a64fa9/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=8794e21ff329d1201d484c015d48e85490a64fa9", "patch": "@@ -17,8 +17,8 @@\n use self::TargetLint::*;\n \n use std::slice;\n-use rustc_data_structures::sync::ReadGuard;\n-use crate::lint::{EarlyLintPass, EarlyLintPassObject, LateLintPassObject};\n+use rustc_data_structures::sync::{ReadGuard, Lock, ParallelIterator, join, par_iter};\n+use crate::lint::{EarlyLintPass, LateLintPass, EarlyLintPassObject, LateLintPassObject};\n use crate::lint::{LintArray, Level, Lint, LintId, LintPass, LintBuffer};\n use crate::lint::builtin::BuiltinLintDiagnostics;\n use crate::lint::levels::{LintLevelSets, LintLevelsBuilder};\n@@ -27,7 +27,6 @@ use crate::rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use crate::session::{config, early_error, Session};\n use crate::ty::{self, TyCtxt, Ty};\n use crate::ty::layout::{LayoutError, LayoutOf, TyLayout};\n-use crate::ty::query::Providers;\n use crate::util::nodemap::FxHashMap;\n use crate::util::common::time;\n \n@@ -56,8 +55,8 @@ pub struct LintStore {\n     /// This is only `None` while performing a lint pass.\n     pre_expansion_passes: Option<Vec<EarlyLintPassObject>>,\n     early_passes: Option<Vec<EarlyLintPassObject>>,\n-    late_passes: Option<Vec<LateLintPassObject>>,\n-    late_module_passes: Option<Vec<LateLintPassObject>>,\n+    late_passes: Lock<Option<Vec<LateLintPassObject>>>,\n+    late_module_passes: Vec<LateLintPassObject>,\n \n     /// Lints indexed by name.\n     by_name: FxHashMap<String, TargetLint>,\n@@ -70,14 +69,6 @@ pub struct LintStore {\n     future_incompatible: FxHashMap<LintId, FutureIncompatibleInfo>,\n }\n \n-pub struct LintSession<'a, PassObject> {\n-    /// Reference to the store of registered lints.\n-    lints: ReadGuard<'a, LintStore>,\n-\n-    /// Trait objects for each lint pass.\n-    passes: Option<Vec<PassObject>>,\n-}\n-\n /// Lints that are buffered up early on in the `Session` before the\n /// `LintLevels` is calculated\n #[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n@@ -152,8 +143,8 @@ impl LintStore {\n             lints: vec![],\n             pre_expansion_passes: Some(vec![]),\n             early_passes: Some(vec![]),\n-            late_passes: Some(vec![]),\n-            late_module_passes: Some(vec![]),\n+            late_passes: Lock::new(Some(vec![])),\n+            late_module_passes: vec![],\n             by_name: Default::default(),\n             future_incompatible: Default::default(),\n             lint_groups: Default::default(),\n@@ -203,13 +194,16 @@ impl LintStore {\n     pub fn register_late_pass(&mut self,\n                               sess: Option<&Session>,\n                               from_plugin: bool,\n+                              register_only: bool,\n                               per_module: bool,\n                               pass: LateLintPassObject) {\n         self.push_pass(sess, from_plugin, &pass);\n-        if per_module {\n-            self.late_module_passes.as_mut().unwrap().push(pass);\n-        } else {\n-            self.late_passes.as_mut().unwrap().push(pass);\n+        if !register_only {\n+            if per_module {\n+                self.late_module_passes.push(pass);\n+            } else {\n+                self.late_passes.lock().as_mut().unwrap().push(pass);\n+            }\n         }\n     }\n \n@@ -527,7 +521,7 @@ pub struct LateContext<'a, 'tcx: 'a> {\n     pub access_levels: &'a AccessLevels,\n \n     /// The store of registered lints and the lint levels.\n-    lint_sess: LintSession<'tcx, LateLintPassObject>,\n+    lint_store: ReadGuard<'a, LintStore>,\n \n     last_node_with_lint_attrs: hir::HirId,\n \n@@ -538,6 +532,11 @@ pub struct LateContext<'a, 'tcx: 'a> {\n     only_module: bool,\n }\n \n+pub struct LateContextAndPass<'a, 'tcx: 'a, T: LateLintPass<'a, 'tcx>> {\n+    context: LateContext<'a, 'tcx>,\n+    pass: T,\n+}\n+\n /// Context for lint checking of the AST, after expansion, before lowering to\n /// HIR.\n pub struct EarlyContext<'a> {\n@@ -550,7 +549,7 @@ pub struct EarlyContext<'a> {\n     builder: LintLevelsBuilder<'a>,\n \n     /// The store of registered lints and the lint levels.\n-    lint_sess: LintSession<'a, EarlyLintPassObject>,\n+    lint_store: ReadGuard<'a, LintStore>,\n \n     buffered: LintBuffer,\n }\n@@ -560,17 +559,6 @@ pub struct EarlyContextAndPass<'a, T: EarlyLintPass> {\n     pass: T,\n }\n \n-/// Convenience macro for calling a `LintPass` method on every pass in the context.\n-macro_rules! run_lints { ($cx:expr, $f:ident, $($args:expr),*) => ({\n-    // Move the vector of passes out of `$cx` so that we can\n-    // iterate over it mutably while passing `$cx` to the methods.\n-    let mut passes = $cx.lint_sess_mut().passes.take().unwrap();\n-    for obj in &mut passes {\n-        obj.$f($cx, $($args),*);\n-    }\n-    $cx.lint_sess_mut().passes = Some(passes);\n-}) }\n-\n pub trait LintPassObject: Sized {}\n \n impl LintPassObject for EarlyLintPassObject {}\n@@ -582,8 +570,6 @@ pub trait LintContext<'tcx>: Sized {\n \n     fn sess(&self) -> &Session;\n     fn lints(&self) -> &LintStore;\n-    fn lint_sess(&self) -> &LintSession<'tcx, Self::PassObject>;\n-    fn lint_sess_mut(&mut self) -> &mut LintSession<'tcx, Self::PassObject>;\n \n     fn lookup_and_emit<S: Into<MultiSpan>>(&self,\n                                            lint: &'static Lint,\n@@ -658,16 +644,17 @@ impl<'a> EarlyContext<'a> {\n         EarlyContext {\n             sess,\n             krate,\n-            lint_sess: LintSession {\n-                lints: sess.lint_store.borrow(),\n-                passes: None,\n-            },\n+            lint_store: sess.lint_store.borrow(),\n             builder: LintLevelSets::builder(sess),\n             buffered,\n         }\n     }\n }\n \n+macro_rules! lint_callback { ($cx:expr, $f:ident, $($args:expr),*) => ({\n+    $cx.pass.$f(&$cx.context, $($args),*);\n+}) }\n+\n macro_rules! run_early_pass { ($cx:expr, $f:ident, $($args:expr),*) => ({\n     $cx.pass.$f(&$cx.context, $($args),*);\n }) }\n@@ -721,15 +708,7 @@ impl<'a, 'tcx> LintContext<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn lints(&self) -> &LintStore {\n-        &*self.lint_sess.lints\n-    }\n-\n-    fn lint_sess(&self) -> &LintSession<'tcx, Self::PassObject> {\n-        &self.lint_sess\n-    }\n-\n-    fn lint_sess_mut(&mut self) -> &mut LintSession<'tcx, Self::PassObject> {\n-        &mut self.lint_sess\n+        &*self.lint_store\n     }\n \n     fn lookup<S: Into<MultiSpan>>(&self,\n@@ -757,15 +736,7 @@ impl<'a> LintContext<'a> for EarlyContext<'a> {\n     }\n \n     fn lints(&self) -> &LintStore {\n-        &*self.lint_sess.lints\n-    }\n-\n-    fn lint_sess(&self) -> &LintSession<'a, Self::PassObject> {\n-        &self.lint_sess\n-    }\n-\n-    fn lint_sess_mut(&mut self) -> &mut LintSession<'a, Self::PassObject> {\n-        &mut self.lint_sess\n+        &*self.lint_store\n     }\n \n     fn lookup<S: Into<MultiSpan>>(&self,\n@@ -778,6 +749,21 @@ impl<'a> LintContext<'a> for EarlyContext<'a> {\n }\n \n impl<'a, 'tcx> LateContext<'a, 'tcx> {\n+    pub fn current_lint_root(&self) -> hir::HirId {\n+        self.last_node_with_lint_attrs\n+    }\n+}\n+\n+impl<'a, 'tcx> LayoutOf for LateContext<'a, 'tcx> {\n+    type Ty = Ty<'tcx>;\n+    type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n+\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n+        self.tcx.layout_of(self.param_env.and(ty))\n+    }\n+}\n+\n+impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> LateContextAndPass<'a, 'tcx, T> {\n     /// Merge the lints specified by any lint attributes into the\n     /// current lint context, call the provided function, then reset the\n     /// lints in effect to their previous state.\n@@ -787,107 +773,98 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n                           f: F)\n         where F: FnOnce(&mut Self)\n     {\n-        let prev = self.last_node_with_lint_attrs;\n-        self.last_node_with_lint_attrs = id;\n+        let prev = self.context.last_node_with_lint_attrs;\n+        self.context.last_node_with_lint_attrs = id;\n         self.enter_attrs(attrs);\n         f(self);\n         self.exit_attrs(attrs);\n-        self.last_node_with_lint_attrs = prev;\n-    }\n-\n-    fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n-        debug!(\"late context: enter_attrs({:?})\", attrs);\n-        run_lints!(self, enter_lint_attrs, attrs);\n-    }\n-\n-    fn exit_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n-        debug!(\"late context: exit_attrs({:?})\", attrs);\n-        run_lints!(self, exit_lint_attrs, attrs);\n+        self.context.last_node_with_lint_attrs = prev;\n     }\n \n     fn with_param_env<F>(&mut self, id: hir::HirId, f: F)\n         where F: FnOnce(&mut Self),\n     {\n-        let old_param_env = self.param_env;\n-        self.param_env = self.tcx.param_env(self.tcx.hir().local_def_id_from_hir_id(id));\n+        let old_param_env = self.context.param_env;\n+        self.context.param_env = self.context.tcx.param_env(\n+            self.context.tcx.hir().local_def_id_from_hir_id(id)\n+        );\n         f(self);\n-        self.param_env = old_param_env;\n-    }\n-    pub fn current_lint_root(&self) -> hir::HirId {\n-        self.last_node_with_lint_attrs\n+        self.context.param_env = old_param_env;\n     }\n \n     fn process_mod(&mut self, m: &'tcx hir::Mod, s: Span, n: hir::HirId) {\n-        run_lints!(self, check_mod, m, s, n);\n+        lint_callback!(self, check_mod, m, s, n);\n         hir_visit::walk_mod(self, m, n);\n-        run_lints!(self, check_mod_post, m, s, n);\n+        lint_callback!(self, check_mod_post, m, s, n);\n     }\n-}\n \n-impl<'a, 'tcx> LayoutOf for LateContext<'a, 'tcx> {\n-    type Ty = Ty<'tcx>;\n-    type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n+    fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n+        debug!(\"late context: enter_attrs({:?})\", attrs);\n+        lint_callback!(self, enter_lint_attrs, attrs);\n+    }\n \n-    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n-        self.tcx.layout_of(self.param_env.and(ty))\n+    fn exit_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n+        debug!(\"late context: exit_attrs({:?})\", attrs);\n+        lint_callback!(self, exit_lint_attrs, attrs);\n     }\n }\n \n-impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n+impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n+for LateContextAndPass<'a, 'tcx, T> {\n     /// Because lints are scoped lexically, we want to walk nested\n     /// items in the context of the outer item, so enable\n     /// deep-walking.\n     fn nested_visit_map<'this>(&'this mut self) -> hir_visit::NestedVisitorMap<'this, 'tcx> {\n-        hir_visit::NestedVisitorMap::All(&self.tcx.hir())\n+        hir_visit::NestedVisitorMap::All(&self.context.tcx.hir())\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let old_tables = self.tables;\n-        self.tables = self.tcx.body_tables(body);\n-        let body = self.tcx.hir().body(body);\n+        let old_tables = self.context.tables;\n+        self.context.tables = self.context.tcx.body_tables(body);\n+        let body = self.context.tcx.hir().body(body);\n         self.visit_body(body);\n-        self.tables = old_tables;\n+        self.context.tables = old_tables;\n     }\n \n     fn visit_body(&mut self, body: &'tcx hir::Body) {\n-        run_lints!(self, check_body, body);\n+        lint_callback!(self, check_body, body);\n         hir_visit::walk_body(self, body);\n-        run_lints!(self, check_body_post, body);\n+        lint_callback!(self, check_body_post, body);\n     }\n \n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n-        let generics = self.generics.take();\n-        self.generics = it.node.generics();\n+        let generics = self.context.generics.take();\n+        self.context.generics = it.node.generics();\n         self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n             cx.with_param_env(it.hir_id, |cx| {\n-                run_lints!(cx, check_item, it);\n+                lint_callback!(cx, check_item, it);\n                 hir_visit::walk_item(cx, it);\n-                run_lints!(cx, check_item_post, it);\n+                lint_callback!(cx, check_item_post, it);\n             });\n         });\n-        self.generics = generics;\n+        self.context.generics = generics;\n     }\n \n     fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem) {\n         self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n             cx.with_param_env(it.hir_id, |cx| {\n-                run_lints!(cx, check_foreign_item, it);\n+                lint_callback!(cx, check_foreign_item, it);\n                 hir_visit::walk_foreign_item(cx, it);\n-                run_lints!(cx, check_foreign_item_post, it);\n+                lint_callback!(cx, check_foreign_item_post, it);\n             });\n         })\n     }\n \n     fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n-        run_lints!(self, check_pat, p);\n+        lint_callback!(self, check_pat, p);\n         hir_visit::walk_pat(self, p);\n     }\n \n     fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n         self.with_lint_attrs(e.hir_id, &e.attrs, |cx| {\n-            run_lints!(cx, check_expr, e);\n+            lint_callback!(cx, check_expr, e);\n             hir_visit::walk_expr(cx, e);\n-            run_lints!(cx, check_expr_post, e);\n+            lint_callback!(cx, check_expr_post, e);\n         })\n     }\n \n@@ -897,21 +874,21 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         // - local\n         // - expression\n         // so we keep track of lint levels there\n-        run_lints!(self, check_stmt, s);\n+        lint_callback!(self, check_stmt, s);\n         hir_visit::walk_stmt(self, s);\n     }\n \n     fn visit_fn(&mut self, fk: hir_visit::FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n                 body_id: hir::BodyId, span: Span, id: hir::HirId) {\n         // Wrap in tables here, not just in visit_nested_body,\n         // in order for `check_fn` to be able to use them.\n-        let old_tables = self.tables;\n-        self.tables = self.tcx.body_tables(body_id);\n-        let body = self.tcx.hir().body(body_id);\n-        run_lints!(self, check_fn, fk, decl, body, span, id);\n+        let old_tables = self.context.tables;\n+        self.context.tables = self.context.tcx.body_tables(body_id);\n+        let body = self.context.tcx.hir().body(body_id);\n+        lint_callback!(self, check_fn, fk, decl, body, span, id);\n         hir_visit::walk_fn(self, fk, decl, body_id, span, id);\n-        run_lints!(self, check_fn_post, fk, decl, body, span, id);\n-        self.tables = old_tables;\n+        lint_callback!(self, check_fn_post, fk, decl, body, span, id);\n+        self.context.tables = old_tables;\n     }\n \n     fn visit_variant_data(&mut self,\n@@ -920,14 +897,14 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n                         g: &'tcx hir::Generics,\n                         item_id: hir::HirId,\n                         _: Span) {\n-        run_lints!(self, check_struct_def, s, name, g, item_id);\n+        lint_callback!(self, check_struct_def, s, name, g, item_id);\n         hir_visit::walk_struct_def(self, s);\n-        run_lints!(self, check_struct_def_post, s, name, g, item_id);\n+        lint_callback!(self, check_struct_def_post, s, name, g, item_id);\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n         self.with_lint_attrs(s.hir_id, &s.attrs, |cx| {\n-            run_lints!(cx, check_struct_field, s);\n+            lint_callback!(cx, check_struct_field, s);\n             hir_visit::walk_struct_field(cx, s);\n         })\n     }\n@@ -937,104 +914,104 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n         self.with_lint_attrs(v.node.id, &v.node.attrs, |cx| {\n-            run_lints!(cx, check_variant, v, g);\n+            lint_callback!(cx, check_variant, v, g);\n             hir_visit::walk_variant(cx, v, g, item_id);\n-            run_lints!(cx, check_variant_post, v, g);\n+            lint_callback!(cx, check_variant_post, v, g);\n         })\n     }\n \n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n-        run_lints!(self, check_ty, t);\n+        lint_callback!(self, check_ty, t);\n         hir_visit::walk_ty(self, t);\n     }\n \n     fn visit_name(&mut self, sp: Span, name: ast::Name) {\n-        run_lints!(self, check_name, sp, name);\n+        lint_callback!(self, check_name, sp, name);\n     }\n \n     fn visit_mod(&mut self, m: &'tcx hir::Mod, s: Span, n: hir::HirId) {\n-        if !self.only_module {\n+        if !self.context.only_module {\n             self.process_mod(m, s, n);\n         }\n     }\n \n     fn visit_local(&mut self, l: &'tcx hir::Local) {\n         self.with_lint_attrs(l.hir_id, &l.attrs, |cx| {\n-            run_lints!(cx, check_local, l);\n+            lint_callback!(cx, check_local, l);\n             hir_visit::walk_local(cx, l);\n         })\n     }\n \n     fn visit_block(&mut self, b: &'tcx hir::Block) {\n-        run_lints!(self, check_block, b);\n+        lint_callback!(self, check_block, b);\n         hir_visit::walk_block(self, b);\n-        run_lints!(self, check_block_post, b);\n+        lint_callback!(self, check_block_post, b);\n     }\n \n     fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n-        run_lints!(self, check_arm, a);\n+        lint_callback!(self, check_arm, a);\n         hir_visit::walk_arm(self, a);\n     }\n \n     fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam) {\n-        run_lints!(self, check_generic_param, p);\n+        lint_callback!(self, check_generic_param, p);\n         hir_visit::walk_generic_param(self, p);\n     }\n \n     fn visit_generics(&mut self, g: &'tcx hir::Generics) {\n-        run_lints!(self, check_generics, g);\n+        lint_callback!(self, check_generics, g);\n         hir_visit::walk_generics(self, g);\n     }\n \n     fn visit_where_predicate(&mut self, p: &'tcx hir::WherePredicate) {\n-        run_lints!(self, check_where_predicate, p);\n+        lint_callback!(self, check_where_predicate, p);\n         hir_visit::walk_where_predicate(self, p);\n     }\n \n     fn visit_poly_trait_ref(&mut self, t: &'tcx hir::PolyTraitRef,\n                             m: hir::TraitBoundModifier) {\n-        run_lints!(self, check_poly_trait_ref, t, m);\n+        lint_callback!(self, check_poly_trait_ref, t, m);\n         hir_visit::walk_poly_trait_ref(self, t, m);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        let generics = self.generics.take();\n-        self.generics = Some(&trait_item.generics);\n+        let generics = self.context.generics.take();\n+        self.context.generics = Some(&trait_item.generics);\n         self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |cx| {\n             cx.with_param_env(trait_item.hir_id, |cx| {\n-                run_lints!(cx, check_trait_item, trait_item);\n+                lint_callback!(cx, check_trait_item, trait_item);\n                 hir_visit::walk_trait_item(cx, trait_item);\n-                run_lints!(cx, check_trait_item_post, trait_item);\n+                lint_callback!(cx, check_trait_item_post, trait_item);\n             });\n         });\n-        self.generics = generics;\n+        self.context.generics = generics;\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        let generics = self.generics.take();\n-        self.generics = Some(&impl_item.generics);\n+        let generics = self.context.generics.take();\n+        self.context.generics = Some(&impl_item.generics);\n         self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |cx| {\n             cx.with_param_env(impl_item.hir_id, |cx| {\n-                run_lints!(cx, check_impl_item, impl_item);\n+                lint_callback!(cx, check_impl_item, impl_item);\n                 hir_visit::walk_impl_item(cx, impl_item);\n-                run_lints!(cx, check_impl_item_post, impl_item);\n+                lint_callback!(cx, check_impl_item_post, impl_item);\n             });\n         });\n-        self.generics = generics;\n+        self.context.generics = generics;\n     }\n \n     fn visit_lifetime(&mut self, lt: &'tcx hir::Lifetime) {\n-        run_lints!(self, check_lifetime, lt);\n+        lint_callback!(self, check_lifetime, lt);\n         hir_visit::walk_lifetime(self, lt);\n     }\n \n     fn visit_path(&mut self, p: &'tcx hir::Path, id: hir::HirId) {\n-        run_lints!(self, check_path, p, id);\n+        lint_callback!(self, check_path, p, id);\n         hir_visit::walk_path(self, p);\n     }\n \n     fn visit_attribute(&mut self, attr: &'tcx ast::Attribute) {\n-        run_lints!(self, check_attribute, attr);\n+        lint_callback!(self, check_attribute, attr);\n     }\n }\n \n@@ -1222,94 +1199,179 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n     }\n }\n \n-pub fn lint_mod<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n-    let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n+struct LateLintPassObjects<'a> {\n+    lints: &'a mut [LateLintPassObject],\n+}\n \n-    let store = &tcx.sess.lint_store;\n-    let passes = store.borrow_mut().late_module_passes.take();\n+impl LintPass for LateLintPassObjects<'_> {\n+    fn name(&self) -> &'static str {\n+        panic!()\n+    }\n \n-    let mut cx = LateContext {\n+    fn get_lints(&self) -> LintArray {\n+        panic!()\n+    }\n+}\n+\n+macro_rules! expand_late_lint_pass_impl_methods {\n+    ([$a:tt, $hir:tt], [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n+        $(fn $name(&mut self, context: &LateContext<$a, $hir>, $($param: $arg),*) {\n+            for obj in self.lints.iter_mut() {\n+                obj.$name(context, $($param),*);\n+            }\n+        })*\n+    )\n+}\n+\n+macro_rules! late_lint_pass_impl {\n+    ([], [$hir:tt], $methods:tt) => (\n+        impl LateLintPass<'a, $hir> for LateLintPassObjects<'_> {\n+            expand_late_lint_pass_impl_methods!(['a, $hir], $methods);\n+        }\n+    )\n+}\n+\n+late_lint_methods!(late_lint_pass_impl, [], ['tcx]);\n+\n+fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    module_def_id: DefId,\n+    pass: T,\n+) {\n+    let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n+\n+    let context = LateContext {\n         tcx,\n         tables: &ty::TypeckTables::empty(None),\n         param_env: ty::ParamEnv::empty(),\n         access_levels,\n-        lint_sess: LintSession {\n-            lints: store.borrow(),\n-            passes,\n-        },\n+        lint_store: tcx.sess.lint_store.borrow(),\n         last_node_with_lint_attrs: tcx.hir().as_local_hir_id(module_def_id).unwrap(),\n         generics: None,\n         only_module: true,\n     };\n \n+    let mut cx = LateContextAndPass {\n+        context,\n+        pass\n+    };\n+\n     let (module, span, hir_id) = tcx.hir().get_module(module_def_id);\n     cx.process_mod(module, span, hir_id);\n \n     // Visit the crate attributes\n     if hir_id == hir::CRATE_HIR_ID {\n-        walk_list!(cx, visit_attribute, cx.tcx.hir().attrs_by_hir_id(hir::CRATE_HIR_ID));\n+        walk_list!(cx, visit_attribute, tcx.hir().attrs_by_hir_id(hir::CRATE_HIR_ID));\n     }\n-\n-    // Put the lint store levels and passes back in the session.\n-    let passes = cx.lint_sess.passes;\n-    drop(cx.lint_sess.lints);\n-    store.borrow_mut().late_module_passes = passes;\n }\n \n-pub(crate) fn provide(providers: &mut Providers<'_>) {\n-    *providers = Providers {\n-        lint_mod,\n-        ..*providers\n-    };\n+pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    module_def_id: DefId,\n+    builtin_lints: T,\n+) {\n+    if tcx.sess.opts.debugging_opts.no_interleave_lints {\n+        // These passes runs in late_lint_crate with -Z no_interleave_lints\n+        return;\n+    }\n+\n+    late_lint_mod_pass(tcx, module_def_id, builtin_lints);\n+\n+    let mut passes: Vec<_> = tcx.sess.lint_store.borrow().late_module_passes\n+                                .iter().map(|pass| pass.fresh_late_pass()).collect();\n+\n+    if !passes.is_empty() {\n+        late_lint_mod_pass(tcx, module_def_id, LateLintPassObjects { lints: &mut passes[..] });\n+    }\n }\n \n-fn lint_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    pass: T\n+) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n     let krate = tcx.hir().krate();\n-    let passes = tcx.sess.lint_store.borrow_mut().late_passes.take();\n-\n-    let passes = {\n-        let mut cx = LateContext {\n-            tcx,\n-            tables: &ty::TypeckTables::empty(None),\n-            param_env: ty::ParamEnv::empty(),\n-            access_levels,\n-            lint_sess: LintSession {\n-                passes,\n-                lints: tcx.sess.lint_store.borrow(),\n-            },\n-            last_node_with_lint_attrs: hir::CRATE_HIR_ID,\n-            generics: None,\n-            only_module: false,\n-        };\n-\n-        // Visit the whole crate.\n-        cx.with_lint_attrs(hir::CRATE_HIR_ID, &krate.attrs, |cx| {\n-            // since the root module isn't visited as an item (because it isn't an\n-            // item), warn for it here.\n-            run_lints!(cx, check_crate, krate);\n \n-            hir_visit::walk_crate(cx, krate);\n+    let context = LateContext {\n+        tcx,\n+        tables: &ty::TypeckTables::empty(None),\n+        param_env: ty::ParamEnv::empty(),\n+        access_levels,\n+        lint_store: tcx.sess.lint_store.borrow(),\n+        last_node_with_lint_attrs: hir::CRATE_HIR_ID,\n+        generics: None,\n+        only_module: false,\n+    };\n \n-            run_lints!(cx, check_crate_post, krate);\n-        });\n-        cx.lint_sess.passes\n+    let mut cx = LateContextAndPass {\n+        context,\n+        pass\n     };\n \n-    // Put the lint store levels and passes back in the session.\n-    tcx.sess.lint_store.borrow_mut().late_passes = passes;\n+    // Visit the whole crate.\n+    cx.with_lint_attrs(hir::CRATE_HIR_ID, &krate.attrs, |cx| {\n+        // since the root module isn't visited as an item (because it isn't an\n+        // item), warn for it here.\n+        lint_callback!(cx, check_crate, krate);\n+\n+        hir_visit::walk_crate(cx, krate);\n+\n+        lint_callback!(cx, check_crate_post, krate);\n+    })\n }\n \n-/// Performs lint checking on a crate.\n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    // Run per-module lints\n-    for &module in tcx.hir().krate().modules.keys() {\n-        tcx.ensure().lint_mod(tcx.hir().local_def_id(module));\n+fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    builtin_lints: T\n+) {\n+    let mut passes = tcx.sess.lint_store.borrow().late_passes.lock().take().unwrap();\n+\n+    if !tcx.sess.opts.debugging_opts.no_interleave_lints {\n+        if !passes.is_empty() {\n+            late_lint_pass_crate(tcx, LateLintPassObjects { lints: &mut passes[..] });\n+        }\n+\n+        late_lint_pass_crate(tcx, builtin_lints);\n+    } else {\n+        for pass in &mut passes {\n+            time(tcx.sess, &format!(\"running late lint: {}\", pass.name()), || {\n+                late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n+            });\n+        }\n+\n+        let mut passes: Vec<_> = tcx.sess.lint_store.borrow().late_module_passes\n+                                    .iter().map(|pass| pass.fresh_late_pass()).collect();\n+\n+        for pass in &mut passes {\n+            time(tcx.sess, &format!(\"running late module lint: {}\", pass.name()), || {\n+                late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n+            });\n+        }\n     }\n \n-    // Run whole crate non-incremental lints\n-    lint_crate(tcx);\n+    // Put the passes back in the session.\n+    *tcx.sess.lint_store.borrow().late_passes.lock() = Some(passes);\n+}\n+\n+/// Performs lint checking on a crate.\n+pub fn check_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    builtin_lints: impl FnOnce() -> T + Send,\n+) {\n+    join(|| {\n+        time(tcx.sess, \"crate lints\", || {\n+            // Run whole crate non-incremental lints\n+            late_lint_crate(tcx, builtin_lints());\n+        });\n+    }, || {\n+        time(tcx.sess, \"module lints\", || {\n+            // Run per-module lints\n+            par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n+                tcx.ensure().lint_mod(tcx.hir().local_def_id(module));\n+            });\n+        });\n+    });\n }\n \n struct EarlyLintPassObjects<'a> {\n@@ -1346,7 +1408,6 @@ macro_rules! early_lint_pass_impl {\n \n early_lint_methods!(early_lint_pass_impl, []);\n \n-\n fn early_lint_crate<T: EarlyLintPass>(\n     sess: &Session,\n     krate: &ast::Crate,"}, {"sha": "a5506bb8f59f4b442e479a3dc85856e5f39a3a28", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8794e21ff329d1201d484c015d48e85490a64fa9/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8794e21ff329d1201d484c015d48e85490a64fa9/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=8794e21ff329d1201d484c015d48e85490a64fa9", "patch": "@@ -42,8 +42,8 @@ use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub use crate::lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n-                        check_crate, check_ast_crate, CheckLintNameResult,\n-                        FutureIncompatibleInfo, BufferedEarlyLint};\n+                        check_crate, check_ast_crate, late_lint_mod, CheckLintNameResult,\n+                        FutureIncompatibleInfo, BufferedEarlyLint,};\n \n /// Specification of a single lint.\n #[derive(Copy, Clone, Debug)]\n@@ -273,6 +273,9 @@ macro_rules! expand_lint_pass_methods {\n macro_rules! declare_late_lint_pass {\n     ([], [$hir:tt], [$($methods:tt)*]) => (\n         pub trait LateLintPass<'a, $hir>: LintPass {\n+            fn fresh_late_pass(&self) -> LateLintPassObject {\n+                panic!()\n+            }\n             expand_lint_pass_methods!(&LateContext<'a, $hir>, [$($methods)*]);\n         }\n     )\n@@ -298,14 +301,14 @@ macro_rules! expand_combined_late_lint_pass_methods {\n \n #[macro_export]\n macro_rules! declare_combined_late_lint_pass {\n-    ([$name:ident, [$($passes:ident: $constructor:expr,)*]], [$hir:tt], $methods:tt) => (\n+    ([$v:vis $name:ident, [$($passes:ident: $constructor:expr,)*]], [$hir:tt], $methods:tt) => (\n         #[allow(non_snake_case)]\n-        struct $name {\n+        $v struct $name {\n             $($passes: $passes,)*\n         }\n \n         impl $name {\n-            fn new() -> Self {\n+            $v fn new() -> Self {\n                 Self {\n                     $($passes: $constructor,)*\n                 }\n@@ -824,7 +827,6 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'a, 'tcx> {\n \n pub fn provide(providers: &mut Providers<'_>) {\n     providers.lint_levels = lint_levels;\n-    context::provide(providers);\n }\n \n /// Returns whether `span` originates in a foreign crate's external macro."}, {"sha": "1547e15fd48c579733e8d0ed9828100496a5c312", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8794e21ff329d1201d484c015d48e85490a64fa9/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8794e21ff329d1201d484c015d48e85490a64fa9/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=8794e21ff329d1201d484c015d48e85490a64fa9", "patch": "@@ -330,7 +330,7 @@ pub fn register_plugins<'a>(\n         ls.register_early_pass(Some(sess), true, false, pass);\n     }\n     for pass in late_lint_passes {\n-        ls.register_late_pass(Some(sess), true, false, pass);\n+        ls.register_late_pass(Some(sess), true, false, false, pass);\n     }\n \n     for (name, (to, deprecated_name)) in lint_groups {\n@@ -783,6 +783,7 @@ pub fn default_provide(providers: &mut ty::query::Providers<'_>) {\n     middle::entry::provide(providers);\n     cstore::provide(providers);\n     lint::provide(providers);\n+    rustc_lint::provide(providers);\n }\n \n pub fn default_provide_extern(providers: &mut ty::query::Providers<'_>) {\n@@ -988,7 +989,9 @@ fn analysis<'tcx>(\n                     stability::check_unused_or_stable_features(tcx)\n                 });\n             }, {\n-                time(sess, \"lint checking\", || lint::check_crate(tcx));\n+                time(sess, \"lint checking\", || {\n+                    lint::check_crate(tcx, || rustc_lint::BuiltinCombinedLateLintPass::new());\n+                });\n             });\n         }, {\n             time(sess, \"privacy checking modules\", || {"}, {"sha": "c9301a32d83c4f747978ddff1e189a94ef382da8", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 114, "deletions": 71, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/8794e21ff329d1201d484c015d48e85490a64fa9/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8794e21ff329d1201d484c015d48e85490a64fa9/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=8794e21ff329d1201d484c015d48e85490a64fa9", "patch": "@@ -45,6 +45,9 @@ use rustc::lint::builtin::{\n };\n use rustc::session;\n use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::ty::query::Providers;\n+use rustc::ty::TyCtxt;\n \n use syntax::ast;\n use syntax::edition::Edition;\n@@ -62,6 +65,17 @@ use unused::*;\n /// Useful for other parts of the compiler.\n pub use builtin::SoftLints;\n \n+pub fn provide(providers: &mut Providers<'_>) {\n+    *providers = Providers {\n+        lint_mod,\n+        ..*providers\n+    };\n+}\n+\n+fn lint_mod<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+    lint::late_lint_mod(tcx, module_def_id, BuiltinCombinedModuleLateLintPass::new());\n+}\n+\n macro_rules! pre_expansion_lint_passes {\n     ($macro:path, $args:tt) => (\n         $macro!($args, [\n@@ -94,6 +108,88 @@ macro_rules! declare_combined_early_pass {\n pre_expansion_lint_passes!(declare_combined_early_pass, [BuiltinCombinedPreExpansionLintPass]);\n early_lint_passes!(declare_combined_early_pass, [BuiltinCombinedEarlyLintPass]);\n \n+macro_rules! late_lint_passes {\n+    ($macro:path, $args:tt) => (\n+        $macro!($args, [\n+            // FIXME: Look into regression when this is used as a module lint\n+            // May Depend on constants elsewhere\n+            UnusedBrokenConst: UnusedBrokenConst,\n+\n+            // Uses attr::is_used which is untracked, can't be an incremental module pass.\n+            UnusedAttributes: UnusedAttributes,\n+\n+            // Needs to run after UnusedAttributes as it marks all `feature` attributes as used.\n+            UnstableFeatures: UnstableFeatures,\n+\n+            // Tracks state across modules\n+            UnnameableTestItems: UnnameableTestItems::new(),\n+\n+            // Tracks attributes of parents\n+            MissingDoc: MissingDoc::new(),\n+\n+            // Depends on access levels\n+            // FIXME: Turn the computation of types which implement Debug into a query\n+            // and change this to a module lint pass\n+            MissingDebugImplementations: MissingDebugImplementations::new(),\n+        ]);\n+    )\n+}\n+\n+macro_rules! late_lint_mod_passes {\n+    ($macro:path, $args:tt) => (\n+        $macro!($args, [\n+            HardwiredLints: HardwiredLints,\n+            WhileTrue: WhileTrue,\n+            ImproperCTypes: ImproperCTypes,\n+            VariantSizeDifferences: VariantSizeDifferences,\n+            BoxPointers: BoxPointers,\n+            PathStatements: PathStatements,\n+\n+            // Depends on referenced function signatures in expressions\n+            UnusedResults: UnusedResults,\n+\n+            NonUpperCaseGlobals: NonUpperCaseGlobals,\n+            NonShorthandFieldPatterns: NonShorthandFieldPatterns,\n+            UnusedAllocation: UnusedAllocation,\n+\n+            // Depends on types used in type definitions\n+            MissingCopyImplementations: MissingCopyImplementations,\n+\n+            PluginAsLibrary: PluginAsLibrary,\n+\n+            // Depends on referenced function signatures in expressions\n+            MutableTransmutes: MutableTransmutes,\n+\n+            // Depends on types of fields, checks if they implement Drop\n+            UnionsWithDropFields: UnionsWithDropFields,\n+\n+            TypeAliasBounds: TypeAliasBounds,\n+\n+            TrivialConstraints: TrivialConstraints,\n+            TypeLimits: TypeLimits::new(),\n+\n+            NonSnakeCase: NonSnakeCase,\n+            InvalidNoMangleItems: InvalidNoMangleItems,\n+\n+            // Depends on access levels\n+            UnreachablePub: UnreachablePub,\n+\n+            ExplicitOutlivesRequirements: ExplicitOutlivesRequirements,\n+        ]);\n+    )\n+}\n+\n+macro_rules! declare_combined_late_pass {\n+    ([$v:vis $name:ident], $passes:tt) => (\n+        late_lint_methods!(declare_combined_late_lint_pass, [$v $name, $passes], ['tcx]);\n+    )\n+}\n+\n+// FIXME: Make a separate lint type which do not require typeck tables\n+late_lint_passes!(declare_combined_late_pass, [pub BuiltinCombinedLateLintPass]);\n+\n+late_lint_mod_passes!(declare_combined_late_pass, [BuiltinCombinedModuleLateLintPass]);\n+\n /// Tell the `LintStore` about all the built-in lints (the ones\n /// defined in this crate and the ones defined in\n /// `rustc::lint::builtin`).\n@@ -104,17 +200,25 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n         )\n     }\n \n+    macro_rules! register_pass {\n+        ($method:ident, $constructor:expr, [$($args:expr),*]) => (\n+            store.$method(sess, false, false, $($args,)* box $constructor);\n+        )\n+    }\n+\n     macro_rules! register_passes {\n-        ([$method:ident], [$($passes:ident: $constructor:expr,)*]) => (\n+        ([$method:ident, $args:tt], [$($passes:ident: $constructor:expr,)*]) => (\n             $(\n-                store.$method(sess, false, false, box $constructor);\n+                register_pass!($method, $constructor, $args);\n             )*\n         )\n     }\n \n     if sess.map(|sess| sess.opts.debugging_opts.no_interleave_lints).unwrap_or(false) {\n-        pre_expansion_lint_passes!(register_passes, [register_pre_expansion_pass]);\n-        early_lint_passes!(register_passes, [register_early_pass]);\n+        pre_expansion_lint_passes!(register_passes, [register_pre_expansion_pass, []]);\n+        early_lint_passes!(register_passes, [register_early_pass, []]);\n+        late_lint_passes!(register_passes, [register_late_pass, [false]]);\n+        late_lint_mod_passes!(register_passes, [register_late_pass, [true]]);\n     } else {\n         store.register_pre_expansion_pass(\n             sess,\n@@ -123,75 +227,14 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             box BuiltinCombinedPreExpansionLintPass::new()\n         );\n         store.register_early_pass(sess, false, true, box BuiltinCombinedEarlyLintPass::new());\n+        store.register_late_pass(\n+            sess, false, true, true, box BuiltinCombinedModuleLateLintPass::new()\n+        );\n+        store.register_late_pass(\n+            sess, false, true, false, box BuiltinCombinedLateLintPass::new()\n+        );\n     }\n \n-    late_lint_methods!(declare_combined_late_lint_pass, [BuiltinCombinedModuleLateLintPass, [\n-        HardwiredLints: HardwiredLints,\n-        WhileTrue: WhileTrue,\n-        ImproperCTypes: ImproperCTypes,\n-        VariantSizeDifferences: VariantSizeDifferences,\n-        BoxPointers: BoxPointers,\n-        PathStatements: PathStatements,\n-\n-        // Depends on referenced function signatures in expressions\n-        UnusedResults: UnusedResults,\n-\n-        NonUpperCaseGlobals: NonUpperCaseGlobals,\n-        NonShorthandFieldPatterns: NonShorthandFieldPatterns,\n-        UnusedAllocation: UnusedAllocation,\n-\n-        // Depends on types used in type definitions\n-        MissingCopyImplementations: MissingCopyImplementations,\n-\n-        PluginAsLibrary: PluginAsLibrary,\n-\n-        // Depends on referenced function signatures in expressions\n-        MutableTransmutes: MutableTransmutes,\n-\n-        // Depends on types of fields, checks if they implement Drop\n-        UnionsWithDropFields: UnionsWithDropFields,\n-\n-        TypeAliasBounds: TypeAliasBounds,\n-\n-        TrivialConstraints: TrivialConstraints,\n-        TypeLimits: TypeLimits::new(),\n-\n-        NonSnakeCase: NonSnakeCase,\n-        InvalidNoMangleItems: InvalidNoMangleItems,\n-\n-        // Depends on access levels\n-        UnreachablePub: UnreachablePub,\n-\n-        ExplicitOutlivesRequirements: ExplicitOutlivesRequirements,\n-    ]], ['tcx]);\n-\n-    store.register_late_pass(sess, false, true, box BuiltinCombinedModuleLateLintPass::new());\n-\n-    late_lint_methods!(declare_combined_late_lint_pass, [BuiltinCombinedLateLintPass, [\n-        // FIXME: Look into regression when this is used as a module lint\n-        // May Depend on constants elsewhere\n-        UnusedBrokenConst: UnusedBrokenConst,\n-\n-        // Uses attr::is_used which is untracked, can't be an incremental module pass.\n-        UnusedAttributes: UnusedAttributes,\n-\n-        // Needs to run after UnusedAttributes as it marks all `feature` attributes as used.\n-        UnstableFeatures: UnstableFeatures,\n-\n-        // Tracks state across modules\n-        UnnameableTestItems: UnnameableTestItems::new(),\n-\n-        // Tracks attributes of parents\n-        MissingDoc: MissingDoc::new(),\n-\n-        // Depends on access levels\n-        // FIXME: Turn the computation of types which implement Debug into a query\n-        // and change this to a module lint pass\n-        MissingDebugImplementations: MissingDebugImplementations::new(),\n-    ]], ['tcx]);\n-\n-    store.register_late_pass(sess, false, false, box BuiltinCombinedLateLintPass::new());\n-\n     add_lint_group!(sess,\n                     \"nonstandard_style\",\n                     NON_CAMEL_CASE_TYPES,"}]}