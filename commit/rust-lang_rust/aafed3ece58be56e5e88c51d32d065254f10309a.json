{"sha": "aafed3ece58be56e5e88c51d32d065254f10309a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhZmVkM2VjZTU4YmU1NmU1ZTg4YzUxZDMyZDA2NTI1NGYxMDMwOWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-14T20:56:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-14T20:56:22Z"}, "message": "auto merge of #10936 : cadencemarseille/rust/issue-10754-std-run-unwrap-on-None, r=alexcrichton\n\nThe problem was that std::run::Process::new() was unwrap()ing the result\r\nof std::io::process::Process::new(), which returns None in the case\r\nwhere the io_error condition is raised to signal failure to start the\r\nprocess.\r\n\r\nHave std::run::Process::new() similarly return an Option\\<run::Process\\>\r\nto reflect the fact that a subprocess might have failed to start. Update\r\nutility functions run::process_status() and run::process_output() to\r\nreturn Option\\<ProcessExit\\> and Option\\<ProcessOutput\\>, respectively.\r\n\r\nVarious parts of librustc and librustpkg needed to be updated to reflect\r\nthese API changes.\r\n\r\ncloses #10754", "tree": {"sha": "21d55824a8a38d055f478c1abf5c962787113c87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21d55824a8a38d055f478c1abf5c962787113c87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aafed3ece58be56e5e88c51d32d065254f10309a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aafed3ece58be56e5e88c51d32d065254f10309a", "html_url": "https://github.com/rust-lang/rust/commit/aafed3ece58be56e5e88c51d32d065254f10309a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aafed3ece58be56e5e88c51d32d065254f10309a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d3a663d2530dd49fee235667e98f2767dfd1b57", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d3a663d2530dd49fee235667e98f2767dfd1b57", "html_url": "https://github.com/rust-lang/rust/commit/3d3a663d2530dd49fee235667e98f2767dfd1b57"}, {"sha": "5de42701a87cb0e517921cce7bc3a512e513301c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5de42701a87cb0e517921cce7bc3a512e513301c", "html_url": "https://github.com/rust-lang/rust/commit/5de42701a87cb0e517921cce7bc3a512e513301c"}], "stats": {"total": 428, "additions": 275, "deletions": 153}, "files": [{"sha": "f919274f2ed18a396811a23a4713a1dc9b7e1c14", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=aafed3ece58be56e5e88c51d32d065254f10309a", "patch": "@@ -46,47 +46,57 @@ pub fn run(lib_path: &str,\n            prog: &str,\n            args: &[~str],\n            env: ~[(~str, ~str)],\n-           input: Option<~str>) -> Result {\n+           input: Option<~str>) -> Option<Result> {\n \n     let env = env + target_env(lib_path, prog);\n-    let mut process = run::Process::new(prog, args, run::ProcessOptions {\n+    let mut opt_process = run::Process::new(prog, args, run::ProcessOptions {\n         env: Some(env),\n         dir: None,\n         in_fd: None,\n         out_fd: None,\n         err_fd: None\n     });\n \n-    for input in input.iter() {\n-        process.input().write(input.as_bytes());\n-    }\n-    let run::ProcessOutput { status, output, error } = process.finish_with_output();\n+    match opt_process {\n+        Some(ref mut process) => {\n+            for input in input.iter() {\n+                process.input().write(input.as_bytes());\n+            }\n+            let run::ProcessOutput { status, output, error } = process.finish_with_output();\n \n-    Result {\n-        status: status,\n-        out: str::from_utf8_owned(output),\n-        err: str::from_utf8_owned(error)\n+            Some(Result {\n+                status: status,\n+                out: str::from_utf8_owned(output),\n+                err: str::from_utf8_owned(error)\n+            })\n+        },\n+        None => None\n     }\n }\n \n pub fn run_background(lib_path: &str,\n            prog: &str,\n            args: &[~str],\n            env: ~[(~str, ~str)],\n-           input: Option<~str>) -> run::Process {\n+           input: Option<~str>) -> Option<run::Process> {\n \n     let env = env + target_env(lib_path, prog);\n-    let mut process = run::Process::new(prog, args, run::ProcessOptions {\n+    let opt_process = run::Process::new(prog, args, run::ProcessOptions {\n         env: Some(env),\n         dir: None,\n         in_fd: None,\n         out_fd: None,\n         err_fd: None\n     });\n \n-    for input in input.iter() {\n-        process.input().write(input.as_bytes());\n-    }\n+    match opt_process {\n+        Some(mut process) => {\n+            for input in input.iter() {\n+                process.input().write(input.as_bytes());\n+            }\n \n-    return process;\n+            Some(process)\n+        },\n+        None => None\n+    }\n }"}, {"sha": "136f29765eac726dc25924f71c0560bf443a9fef", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=aafed3ece58be56e5e88c51d32d065254f10309a", "patch": "@@ -289,20 +289,23 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n                 dump_output_file(config, testfile, script_str, \"debugger.script\");\n \n \n-                procsrv::run(\"\", config.adb_path.clone(),\n+                procsrv::run(\"\", config.adb_path,\n                     [~\"push\", exe_file.as_str().unwrap().to_owned(), config.adb_test_dir.clone()],\n-                    ~[(~\"\",~\"\")], Some(~\"\"));\n+                    ~[(~\"\",~\"\")], Some(~\"\"))\n+                    .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n                 procsrv::run(\"\", config.adb_path,\n                     [~\"forward\", ~\"tcp:5039\", ~\"tcp:5039\"],\n-                    ~[(~\"\",~\"\")], Some(~\"\"));\n+                    ~[(~\"\",~\"\")], Some(~\"\"))\n+                    .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n                 let adb_arg = format!(\"export LD_LIBRARY_PATH={}; gdbserver :5039 {}/{}\",\n                          config.adb_test_dir.clone(), config.adb_test_dir.clone(),\n                          str::from_utf8(exe_file.filename().unwrap()));\n \n-                let mut process = procsrv::run_background(\"\", config.adb_path.clone(),\n-                        [~\"shell\",adb_arg.clone()],~[(~\"\",~\"\")], Some(~\"\"));\n+                let mut process = procsrv::run_background(\"\", config.adb_path,\n+                        [~\"shell\",adb_arg.clone()],~[(~\"\",~\"\")], Some(~\"\"))\n+                        .expect(format!(\"failed to exec `{}`\", config.adb_path));\n                 loop {\n                     //waiting 1 second for gdbserver start\n                     timer::sleep(1000);\n@@ -334,10 +337,12 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n                 let debugger_opts = ~[~\"-quiet\", ~\"-batch\", ~\"-nx\",\n                     \"-command=\" + debugger_script.as_str().unwrap().to_owned()];\n \n+                let gdb_path = tool_path.append(\"/bin/arm-linux-androideabi-gdb\");\n                 let procsrv::Result{ out, err, status }=\n                     procsrv::run(\"\",\n-                            tool_path.append(\"/bin/arm-linux-androideabi-gdb\"),\n-                            debugger_opts, ~[(~\"\",~\"\")], None);\n+                            gdb_path,\n+                            debugger_opts, ~[(~\"\",~\"\")], None)\n+                    .expect(format!(\"failed to exec `{}`\", gdb_path));\n                 let cmdline = {\n                     let cmdline = make_cmdline(\"\", \"arm-linux-androideabi-gdb\", debugger_opts);\n                     logv(config, format!(\"executing {}\", cmdline));\n@@ -800,7 +805,8 @@ fn program_output(config: &config, testfile: &Path, lib_path: &str, prog: ~str,\n             cmdline\n         };\n     let procsrv::Result{ out, err, status } =\n-            procsrv::run(lib_path, prog, args, env, input);\n+            procsrv::run(lib_path, prog, args, env, input)\n+            .expect(format!(\"failed to exec `{}`\", prog));\n     dump_output(config, testfile, out, err);\n     return ProcRes {status: status,\n          stdout: out,\n@@ -908,7 +914,8 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     // copy to target\n     let copy_result = procsrv::run(\"\", config.adb_path,\n         [~\"push\", args.prog.clone(), config.adb_test_dir.clone()],\n-        ~[(~\"\",~\"\")], Some(~\"\"));\n+        ~[(~\"\",~\"\")], Some(~\"\"))\n+        .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n     if config.verbose {\n         println!(\"push ({}) {} {} {}\",\n@@ -932,7 +939,8 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     for tv in args.args.iter() {\n         runargs.push(tv.to_owned());\n     }\n-    procsrv::run(\"\", config.adb_path, runargs, ~[(~\"\",~\"\")], Some(~\"\"));\n+    procsrv::run(\"\", config.adb_path, runargs, ~[(~\"\",~\"\")], Some(~\"\"))\n+        .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n     // get exitcode of result\n     runargs = ~[];\n@@ -942,7 +950,8 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n \n     let procsrv::Result{ out: exitcode_out, err: _, status: _ } =\n         procsrv::run(\"\", config.adb_path, runargs, ~[(~\"\",~\"\")],\n-                     Some(~\"\"));\n+                     Some(~\"\"))\n+        .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n     let mut exitcode : int = 0;\n     for c in exitcode_out.chars() {\n@@ -960,7 +969,8 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     runargs.push(format!(\"{}/{}.stdout\", config.adb_test_dir, prog_short));\n \n     let procsrv::Result{ out: stdout_out, err: _, status: _ } =\n-        procsrv::run(\"\", config.adb_path, runargs, ~[(~\"\",~\"\")], Some(~\"\"));\n+        procsrv::run(\"\", config.adb_path, runargs, ~[(~\"\",~\"\")], Some(~\"\"))\n+        .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n     // get stderr of result\n     runargs = ~[];\n@@ -969,7 +979,8 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     runargs.push(format!(\"{}/{}.stderr\", config.adb_test_dir, prog_short));\n \n     let procsrv::Result{ out: stderr_out, err: _, status: _ } =\n-        procsrv::run(\"\", config.adb_path, runargs, ~[(~\"\",~\"\")], Some(~\"\"));\n+        procsrv::run(\"\", config.adb_path, runargs, ~[(~\"\",~\"\")], Some(~\"\"))\n+        .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n     dump_output(config, testfile, stdout_out, stderr_out);\n \n@@ -1004,7 +1015,8 @@ fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             let copy_result = procsrv::run(\"\", config.adb_path,\n                 [~\"push\", file.as_str().unwrap().to_owned(), config.adb_test_dir.clone()],\n-                ~[(~\"\",~\"\")], Some(~\"\"));\n+                ~[(~\"\",~\"\")], Some(~\"\"))\n+                .expect(format!(\"failed to exec `{}`\", config.adb_path));\n \n             if config.verbose {\n                 println!(\"push ({}) {} {} {}\","}, {"sha": "9cb73ecb07bbb48c92b7f3a1620c95c956d319c1", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=aafed3ece58be56e5e88c51d32d065254f10309a", "patch": "@@ -40,15 +40,25 @@ fn run_ar(sess: Session, args: &str, cwd: Option<&Path>,\n         Some(p) => { debug!(\"inside {}\", p.display()); }\n         None => {}\n     }\n-    let o = Process::new(ar, args.as_slice(), opts).finish_with_output();\n-    if !o.status.success() {\n-        sess.err(format!(\"{} {} failed with: {}\", ar, args.connect(\" \"),\n-                         o.status));\n-        sess.note(format!(\"stdout ---\\n{}\", str::from_utf8(o.output)));\n-        sess.note(format!(\"stderr ---\\n{}\", str::from_utf8(o.error)));\n-        sess.abort_if_errors();\n+    let mut opt_prog = Process::new(ar, args.as_slice(), opts);\n+    match opt_prog {\n+        Some(ref mut prog) => {\n+            let o = prog.finish_with_output();\n+            if !o.status.success() {\n+                sess.err(format!(\"{} {} failed with: {}\", ar, args.connect(\" \"),\n+                                 o.status));\n+                sess.note(format!(\"stdout ---\\n{}\", str::from_utf8(o.output)));\n+                sess.note(format!(\"stderr ---\\n{}\", str::from_utf8(o.error)));\n+                sess.abort_if_errors();\n+            }\n+            o\n+        },\n+        None => {\n+            sess.err(format!(\"could not exec `{}`\", ar));\n+            sess.abort_if_errors();\n+            fail!(\"rustc::back::archive::run_ar() should not reach this point\");\n+        }\n     }\n-    o\n }\n \n impl Archive {"}, {"sha": "d67277289d431670519d040e9260c87c0cbe1d3d", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=aafed3ece58be56e5e88c51d32d065254f10309a", "patch": "@@ -310,13 +310,19 @@ pub mod write {\n             assembly.as_str().unwrap().to_owned()];\n \n         debug!(\"{} '{}'\", cc, args.connect(\"' '\"));\n-        let prog = run::process_output(cc, args);\n-\n-        if !prog.status.success() {\n-            sess.err(format!(\"linking with `{}` failed: {}\", cc, prog.status));\n-            sess.note(format!(\"{} arguments: '{}'\", cc, args.connect(\"' '\")));\n-            sess.note(str::from_utf8_owned(prog.error + prog.output));\n-            sess.abort_if_errors();\n+        match run::process_output(cc, args) {\n+            Some(prog) => {\n+                if !prog.status.success() {\n+                    sess.err(format!(\"linking with `{}` failed: {}\", cc, prog.status));\n+                    sess.note(format!(\"{} arguments: '{}'\", cc, args.connect(\"' '\")));\n+                    sess.note(str::from_utf8_owned(prog.error + prog.output));\n+                    sess.abort_if_errors();\n+                }\n+            },\n+            None => {\n+                sess.err(format!(\"could not exec `{}`\", cc));\n+                sess.abort_if_errors();\n+            }\n         }\n     }\n \n@@ -949,14 +955,22 @@ fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n \n     // Invoke the system linker\n     debug!(\"{} {}\", cc_prog, cc_args.connect(\" \"));\n-    let prog = time(sess.time_passes(), \"running linker\", (), |()|\n-                    run::process_output(cc_prog, cc_args));\n-\n-    if !prog.status.success() {\n-        sess.err(format!(\"linking with `{}` failed: {}\", cc_prog, prog.status));\n-        sess.note(format!(\"{} arguments: '{}'\", cc_prog, cc_args.connect(\"' '\")));\n-        sess.note(str::from_utf8_owned(prog.error + prog.output));\n-        sess.abort_if_errors();\n+    let opt_prog = time(sess.time_passes(), \"running linker\", (), |()|\n+                        run::process_output(cc_prog, cc_args));\n+\n+    match opt_prog {\n+        Some(prog) => {\n+            if !prog.status.success() {\n+                sess.err(format!(\"linking with `{}` failed: {}\", cc_prog, prog.status));\n+                sess.note(format!(\"{} arguments: '{}'\", cc_prog, cc_args.connect(\"' '\")));\n+                sess.note(str::from_utf8_owned(prog.error + prog.output));\n+                sess.abort_if_errors();\n+            }\n+        },\n+        None => {\n+            sess.err(format!(\"could not exec `{}`\", cc_prog));\n+            sess.abort_if_errors();\n+        }\n     }\n \n "}, {"sha": "8e4216562c0a5deada1c265d3cc3f74c62dc925e", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=aafed3ece58be56e5e88c51d32d065254f10309a", "patch": "@@ -142,14 +142,14 @@ pub fn install_pkg(cx: &BuildContext,\n /// Builds an arbitrary library whose short name is `output`,\n /// by invoking `tool` with arguments `args` plus \"-o %s\", where %s\n /// is the platform-specific library name for `output`.\n-/// Returns that platform-specific name.\n+/// Returns that platform-specific name, or None if `tool` could not be started.\n pub fn build_library_in_workspace(exec: &mut workcache::Exec,\n                                   context: &mut Context,\n                                   package_name: &str,\n                                   tool: &str,\n                                   flags: &[~str],\n                                   paths: &[~str],\n-                                  output: &str) -> ~str {\n+                                  output: &str) -> Option<~str> {\n     use command_failed = conditions::command_failed::cond;\n \n     let workspace = my_workspace(context, package_name);\n@@ -169,16 +169,20 @@ pub fn build_library_in_workspace(exec: &mut workcache::Exec,\n \n     let all_args = flags + absolute_paths + cc_args +\n          ~[~\"-o\", out_name.as_str().unwrap().to_owned()];\n-    let exit_process = run::process_status(tool, all_args);\n-    if exit_process.success() {\n-        let out_name_str = out_name.as_str().unwrap().to_owned();\n-        exec.discover_output(\"binary\",\n-                             out_name_str,\n-                             digest_only_date(&out_name));\n-        context.add_library_path(out_name.dir_path());\n-        out_name_str\n-    } else {\n-        command_failed.raise((tool.to_owned(), all_args, exit_process))\n+    match run::process_status(tool, all_args) {\n+        Some(exit_process) => {\n+            if exit_process.success() {\n+                let out_name_str = out_name.as_str().unwrap().to_owned();\n+                exec.discover_output(\"binary\",\n+                                     out_name_str,\n+                                     digest_only_date(&out_name));\n+                context.add_library_path(out_name.dir_path());\n+                Some(out_name_str)\n+            } else {\n+                Some(command_failed.raise((tool.to_owned(), all_args, exit_process)))\n+            }\n+        },\n+        None => None\n     }\n }\n "}, {"sha": "76d2db0a587e6aaa75448db51a28da9edd83ac47", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 58, "deletions": 29, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=aafed3ece58be56e5e88c51d32d065254f10309a", "patch": "@@ -166,29 +166,47 @@ impl<'a> PkgScript<'a> {\n     /// Run the contents of this package script, where <what>\n     /// is the command to pass to it (e.g., \"build\", \"clean\", \"install\")\n     /// Returns a pair of an exit code and list of configs (obtained by\n-    /// calling the package script's configs() function if it exists\n-    fn run_custom(exe: &Path, sysroot: &Path) -> (~[~str], process::ProcessExit) {\n+    /// calling the package script's configs() function if it exists, or\n+    /// None if `exe` could not be started.\n+    fn run_custom(exe: &Path, sysroot: &Path) -> Option<(~[~str], process::ProcessExit)> {\n         debug!(\"Running program: {} {} {}\", exe.as_str().unwrap().to_owned(),\n                sysroot.display(), \"install\");\n         // FIXME #7401 should support commands besides `install`\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let status = run::process_status(exe.as_str().unwrap(),\n-                                         [sysroot.as_str().unwrap().to_owned(), ~\"install\"]);\n-        if !status.success() {\n-            debug!(\"run_custom: first pkg command failed with {:?}\", status);\n-            (~[], status)\n-        }\n-        else {\n-            debug!(\"Running program (configs): {} {} {}\",\n-                   exe.display(), sysroot.display(), \"configs\");\n-            // FIXME (#9639): This needs to handle non-utf8 paths\n-            let output = run::process_output(exe.as_str().unwrap(),\n-                                             [sysroot.as_str().unwrap().to_owned(), ~\"configs\"]);\n-            debug!(\"run_custom: second pkg command did {:?}\", output.status);\n-            // Run the configs() function to get the configs\n-            let cfgs = str::from_utf8(output.output).words()\n-                .map(|w| w.to_owned()).collect();\n-            (cfgs, output.status)\n+        let opt_status = run::process_status(exe.as_str().unwrap(),\n+                                             [sysroot.as_str().unwrap().to_owned(), ~\"install\"]);\n+        match opt_status {\n+            Some(status) => {\n+                if !status.success() {\n+                    debug!(\"run_custom: first pkg command failed with {:?}\", status);\n+                    Some((~[], status))\n+                }\n+                else {\n+                    debug!(\"Running program (configs): {} {} {}\",\n+                           exe.display(), sysroot.display(), \"configs\");\n+                    // FIXME (#9639): This needs to handle non-utf8 paths\n+                    let opt_output = run::process_output(exe.as_str().unwrap(),\n+                                                         [sysroot.as_str().unwrap().to_owned(),\n+                                                          ~\"configs\"]);\n+                    match opt_output {\n+                        Some(output) => {\n+                            debug!(\"run_custom: second pkg command did {:?}\", output.status);\n+                            // Run the configs() function to get the configs\n+                            let cfgs = str::from_utf8(output.output).words()\n+                                .map(|w| w.to_owned()).collect();\n+                            Some((cfgs, output.status))\n+                        },\n+                        None => {\n+                            debug!(\"run_custom: second pkg command failed to start\");\n+                            Some((~[], status))\n+                        }\n+                    }\n+                }\n+            },\n+            None => {\n+                debug!(\"run_custom: first pkg command failed to start\");\n+                None\n+            }\n         }\n     }\n }\n@@ -481,14 +499,20 @@ impl CtxMethods for BuildContext {\n                     })\n                 });\n                 // We always *run* the package script\n-                let (cfgs, hook_result) = PkgScript::run_custom(&Path::new(pkg_exe), &sysroot);\n-                debug!(\"Command return code = {:?}\", hook_result);\n-                if !hook_result.success() {\n-                    fail!(\"Error running custom build command\")\n+                match PkgScript::run_custom(&Path::new(pkg_exe), &sysroot) {\n+                    Some((cfgs, hook_result)) => {\n+                        debug!(\"Command return code = {:?}\", hook_result);\n+                        if !hook_result.success() {\n+                            fail!(\"Error running custom build command\")\n+                        }\n+                        custom = true;\n+                        // otherwise, the package script succeeded\n+                        cfgs\n+                    },\n+                    None => {\n+                        fail!(\"Error starting custom build command\")\n+                    }\n                 }\n-                custom = true;\n-                // otherwise, the package script succeeded\n-                cfgs\n             }\n             (Some(_), Inferred) => {\n                 debug!(\"There is a package script, but we're ignoring it\");\n@@ -693,9 +717,14 @@ impl CtxMethods for BuildContext {\n             Some(test_exec) => {\n                 debug!(\"test: test_exec = {}\", test_exec.display());\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n-                let status = run::process_status(test_exec.as_str().unwrap(), [~\"--test\"]);\n-                if !status.success() {\n-                    fail!(\"Some tests failed\");\n+                let opt_status = run::process_status(test_exec.as_str().unwrap(), [~\"--test\"]);\n+                match opt_status {\n+                    Some(status) => {\n+                        if !status.success() {\n+                            fail!(\"Some tests failed\");\n+                        }\n+                    },\n+                    None => fail!(\"Could not exec `{}`\", test_exec.display())\n                 }\n             }\n             None => {"}, {"sha": "cbb550302317526af80aa345a7c16b3987258d3a", "filename": "src/librustpkg/source_control.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Flibrustpkg%2Fsource_control.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Flibrustpkg%2Fsource_control.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsource_control.rs?ref=aafed3ece58be56e5e88c51d32d065254f10309a", "patch": "@@ -33,15 +33,16 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n         if !target.exists() {\n             debug!(\"Running: git clone {} {}\", source.display(), target.display());\n             // FIXME (#9639): This needs to handle non-utf8 paths\n-            let outp = run::process_output(\"git\", [~\"clone\",\n-                                                   source.as_str().unwrap().to_owned(),\n-                                                   target.as_str().unwrap().to_owned()]);\n+            let opt_outp = run::process_output(\"git\", [~\"clone\",\n+                                                       source.as_str().unwrap().to_owned(),\n+                                                       target.as_str().unwrap().to_owned()]);\n+            let outp = opt_outp.expect(\"Failed to exec `git`\");\n             if !outp.status.success() {\n                 println(str::from_utf8_owned(outp.output.clone()));\n                 println(str::from_utf8_owned(outp.error));\n                 return DirToUse(target.clone());\n             }\n-                else {\n+            else {\n                 match v {\n                     &ExactRevision(ref s) => {\n                         let git_dir = target.join(\".git\");\n@@ -51,7 +52,7 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n                         let outp = run::process_output(\"git\",\n                             [format!(\"--work-tree={}\", target.as_str().unwrap().to_owned()),\n                              format!(\"--git-dir={}\", git_dir.as_str().unwrap().to_owned()),\n-                             ~\"checkout\", format!(\"{}\", *s)]);\n+                             ~\"checkout\", format!(\"{}\", *s)]).expect(\"Failed to exec `git`\");\n                         if !outp.status.success() {\n                             println(str::from_utf8_owned(outp.output.clone()));\n                             println(str::from_utf8_owned(outp.error));\n@@ -72,7 +73,8 @@ pub fn safe_git_clone(source: &Path, v: &Version, target: &Path) -> CloneResult\n             let args = [format!(\"--work-tree={}\", target.as_str().unwrap().to_owned()),\n                         format!(\"--git-dir={}\", git_dir.as_str().unwrap().to_owned()),\n                         ~\"pull\", ~\"--no-edit\", source.as_str().unwrap().to_owned()];\n-            let outp = run::process_output(\"git\", args);\n+            let opt_outp = run::process_output(\"git\", args);\n+            let outp = opt_outp.expect(\"Failed to exec `git`\");\n             assert!(outp.status.success());\n         }\n         CheckedOutSources\n@@ -108,8 +110,9 @@ pub fn git_clone_url(source: &str, target: &Path, v: &Version) {\n     use conditions::git_checkout_failed::cond;\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let outp = run::process_output(\"git\", [~\"clone\", source.to_owned(),\n-                                           target.as_str().unwrap().to_owned()]);\n+    let opt_outp = run::process_output(\"git\", [~\"clone\", source.to_owned(),\n+                                               target.as_str().unwrap().to_owned()]);\n+    let outp = opt_outp.expect(\"Failed to exec `git`\");\n     if !outp.status.success() {\n          debug!(\"{}\", str::from_utf8_owned(outp.output.clone()));\n          debug!(\"{}\", str::from_utf8_owned(outp.error));\n@@ -118,8 +121,9 @@ pub fn git_clone_url(source: &str, target: &Path, v: &Version) {\n     else {\n         match v {\n             &ExactRevision(ref s) | &Tagged(ref s) => {\n-                    let outp = process_output_in_cwd(\"git\", [~\"checkout\", s.to_owned()],\n+                    let opt_outp = process_output_in_cwd(\"git\", [~\"checkout\", s.to_owned()],\n                                                          target);\n+                    let outp = opt_outp.expect(\"Failed to exec `git`\");\n                     if !outp.status.success() {\n                         debug!(\"{}\", str::from_utf8_owned(outp.output.clone()));\n                         debug!(\"{}\", str::from_utf8_owned(outp.error));\n@@ -131,10 +135,13 @@ pub fn git_clone_url(source: &str, target: &Path, v: &Version) {\n     }\n }\n \n-fn process_output_in_cwd(prog: &str, args: &[~str], cwd: &Path) -> ProcessOutput {\n-    let mut prog = Process::new(prog, args, ProcessOptions{ dir: Some(cwd)\n-                                ,..ProcessOptions::new()});\n-    prog.finish_with_output()\n+fn process_output_in_cwd(prog: &str, args: &[~str], cwd: &Path) -> Option<ProcessOutput> {\n+    let mut opt_prog = Process::new(prog, args, ProcessOptions{ dir: Some(cwd)\n+                                    ,..ProcessOptions::new()});\n+    match opt_prog {\n+        Some(ref mut prog) => Some(prog.finish_with_output()),\n+        None => None\n+    }\n }\n \n pub fn is_git_dir(p: &Path) -> bool {"}, {"sha": "28bf8deb5a7d9b8e4afc848084e6acc4213986d5", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=aafed3ece58be56e5e88c51d32d065254f10309a", "patch": "@@ -148,7 +148,7 @@ fn run_git(args: &[~str], env: Option<~[(~str, ~str)]>, cwd: &Path, err_msg: &st\n         in_fd: None,\n         out_fd: None,\n         err_fd: None\n-    });\n+    }).expect(\"failed to exec `git`\");\n     let rslt = prog.finish_with_output();\n     if !rslt.status.success() {\n         fail!(\"{} [git returned {:?}, output = {}, error = {}]\", err_msg,\n@@ -285,7 +285,7 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n         in_fd: None,\n         out_fd: None,\n         err_fd: None\n-    });\n+    }).expect(format!(\"failed to exec `{}`\", cmd));\n     let output = prog.finish_with_output();\n     debug!(\"Output from command {} with args {:?} was {} \\\\{{}\\\\}[{:?}]\",\n            cmd, args, str::from_utf8(output.output),\n@@ -503,7 +503,8 @@ fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n             // n.b. Bumps time up by 2 seconds to get around granularity issues\n             if !run::process_output(\"touch\", [~\"--date\",\n                                              ~\"+2 seconds\",\n-                                             p.as_str().unwrap().to_owned()]).status.success() {\n+                                             p.as_str().unwrap().to_owned()])\n+                .expect(\"failed to exec `touch`\").status.success() {\n                 let _ = cond.raise((pkg_src_dir.clone(), ~\"Bad path\"));\n             }\n         }\n@@ -521,7 +522,8 @@ fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             // n.b. Bumps time up by 2 seconds to get around granularity issues\n             if !run::process_output(\"touch\", [~\"-A02\",\n-                                             p.as_str().unwrap().to_owned()]).status.success() {\n+                                             p.as_str().unwrap().to_owned()])\n+                .expect(\"failed to exec `touch`\").status.success() {\n                 let _ = cond.raise((pkg_src_dir.clone(), ~\"Bad path\"));\n             }\n         }\n@@ -1276,7 +1278,7 @@ fn test_extern_mod() {\n         in_fd: None,\n         out_fd: None,\n         err_fd: None\n-    });\n+    }).expect(format!(\"failed to exec `{}`\", rustc.as_str().unwrap()));\n     let outp = prog.finish_with_output();\n     if !outp.status.success() {\n         fail!(\"output was {}, error was {}\",\n@@ -1331,7 +1333,7 @@ fn test_extern_mod_simpler() {\n         in_fd: None,\n         out_fd: None,\n         err_fd: None\n-    });\n+    }).expect(format!(\"failed to exec `{}`\", rustc.as_str().unwrap()));\n     let outp = prog.finish_with_output();\n     if !outp.status.success() {\n         fail!(\"output was {}, error was {}\","}, {"sha": "e9ccfccb126a1b3a71893f8a92d15efe18eebe9d", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=aafed3ece58be56e5e88c51d32d065254f10309a", "patch": "@@ -104,8 +104,9 @@ pub fn try_getting_local_version(local_path: &Path) -> Option<Version> {\n             continue;\n         }\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let outp = run::process_output(\"git\",\n+        let opt_outp = run::process_output(\"git\",\n                                    [\"--git-dir=\" + git_dir.as_str().unwrap(), ~\"tag\", ~\"-l\"]);\n+        let outp = opt_outp.expect(\"Failed to exec `git`\");\n \n         debug!(\"git --git-dir={} tag -l ~~~> {:?}\", git_dir.display(), outp.status);\n \n@@ -140,9 +141,10 @@ pub fn try_getting_version(remote_path: &Path) -> Option<Version> {\n                remote_path.display(),\n                tmp_dir.display());\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        let outp  = run::process_output(\"git\", [~\"clone\", format!(\"https://{}\",\n-                                                                  remote_path.as_str().unwrap()),\n-                                                tmp_dir.as_str().unwrap().to_owned()]);\n+        let opt_outp = run::process_output(\"git\", [~\"clone\", format!(\"https://{}\",\n+                                                                     remote_path.as_str().unwrap()),\n+                                                   tmp_dir.as_str().unwrap().to_owned()]);\n+        let outp = opt_outp.expect(\"Failed to exec `git`\");\n         if outp.status.success() {\n             debug!(\"Cloned it... ( {}, {} )\",\n                    str::from_utf8(outp.output),\n@@ -152,9 +154,10 @@ pub fn try_getting_version(remote_path: &Path) -> Option<Version> {\n             debug!(\"(getting version, now getting tags) executing \\\\{git --git-dir={} tag -l\\\\}\",\n                    git_dir.display());\n             // FIXME (#9639): This needs to handle non-utf8 paths\n-            let outp = run::process_output(\"git\",\n-                                           [\"--git-dir=\" + git_dir.as_str().unwrap(),\n-                                            ~\"tag\", ~\"-l\"]);\n+            let opt_outp = run::process_output(\"git\",\n+                                               [\"--git-dir=\" + git_dir.as_str().unwrap(),\n+                                                ~\"tag\", ~\"-l\"]);\n+            let outp = opt_outp.expect(\"Failed to exec `git`\");\n             let output_text = str::from_utf8(outp.output);\n             debug!(\"Full output: ( {} ) [{:?}]\", output_text, outp.status);\n             for l in output_text.lines() {"}, {"sha": "14d49df59a4c66f06c229d9792a51d804c542e1c", "filename": "src/libstd/run.rs", "status": "modified", "additions": 52, "deletions": 27, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=aafed3ece58be56e5e88c51d32d065254f10309a", "patch": "@@ -119,7 +119,7 @@ impl Process {\n      * * options - Options to configure the environment of the process,\n      *             the working directory and the standard IO streams.\n      */\n-    pub fn new(prog: &str, args: &[~str], options: ProcessOptions) -> Process {\n+    pub fn new(prog: &str, args: &[~str], options: ProcessOptions) -> Option<Process> {\n         let ProcessOptions { env, dir, in_fd, out_fd, err_fd } = options;\n         let env = env.as_ref().map(|a| a.as_slice());\n         let cwd = dir.as_ref().map(|a| a.as_str().unwrap());\n@@ -138,8 +138,10 @@ impl Process {\n             cwd: cwd,\n             io: rtio,\n         };\n-        let inner = process::Process::new(rtconfig).unwrap();\n-        Process { inner: inner }\n+        match process::Process::new(rtconfig) {\n+            Some(inner) => Some(Process { inner: inner }),\n+            None => None\n+        }\n     }\n \n     /// Returns the unique id of the process\n@@ -290,17 +292,20 @@ impl Process {\n  *\n  * # Return value\n  *\n- * The process's exit code\n+ * The process's exit code, or None if the child process could not be started\n  */\n-pub fn process_status(prog: &str, args: &[~str]) -> ProcessExit {\n-    let mut prog = Process::new(prog, args, ProcessOptions {\n+pub fn process_status(prog: &str, args: &[~str]) -> Option<ProcessExit> {\n+    let mut opt_prog = Process::new(prog, args, ProcessOptions {\n         env: None,\n         dir: None,\n         in_fd: Some(unsafe { libc::dup(libc::STDIN_FILENO) }),\n         out_fd: Some(unsafe { libc::dup(libc::STDOUT_FILENO) }),\n         err_fd: Some(unsafe { libc::dup(libc::STDERR_FILENO) })\n     });\n-    prog.finish()\n+    match opt_prog {\n+        Some(ref mut prog) => Some(prog.finish()),\n+        None => None\n+    }\n }\n \n /**\n@@ -313,11 +318,15 @@ pub fn process_status(prog: &str, args: &[~str]) -> ProcessExit {\n  *\n  * # Return value\n  *\n- * The process's stdout/stderr output and exit code.\n+ * The process's stdout/stderr output and exit code, or None if the child process could not be\n+ * started.\n  */\n-pub fn process_output(prog: &str, args: &[~str]) -> ProcessOutput {\n-    let mut prog = Process::new(prog, args, ProcessOptions::new());\n-    prog.finish_with_output()\n+pub fn process_output(prog: &str, args: &[~str]) -> Option<ProcessOutput> {\n+    let mut opt_prog = Process::new(prog, args, ProcessOptions::new());\n+    match opt_prog {\n+        Some(ref mut prog) => Some(prog.finish_with_output()),\n+        None => None\n+    }\n }\n \n #[cfg(test)]\n@@ -331,24 +340,36 @@ mod tests {\n     use task::spawn;\n     use unstable::running_on_valgrind;\n     use io::native::file;\n-    use io::{Writer, Reader};\n+    use io::{Writer, Reader, io_error};\n \n     #[test]\n     #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n     fn test_process_status() {\n-        let mut status = run::process_status(\"false\", []);\n+        let mut status = run::process_status(\"false\", []).expect(\"failed to exec `false`\");\n         assert!(status.matches_exit_status(1));\n \n-        status = run::process_status(\"true\", []);\n+        status = run::process_status(\"true\", []).expect(\"failed to exec `true`\");\n         assert!(status.success());\n     }\n \n+    #[test]\n+    fn test_process_output_fail_to_start() {\n+        let mut trapped_io_error = false;\n+        let opt_outp = io_error::cond.trap(|_| {\n+            trapped_io_error = true;\n+        }).inside(|| -> Option<run::ProcessOutput> {\n+            run::process_output(\"no-binary-by-this-name-should-exist\", [])\n+        });\n+        assert!(trapped_io_error);\n+        assert!(opt_outp.is_none());\n+    }\n+\n     #[test]\n     #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n     fn test_process_output_output() {\n \n         let run::ProcessOutput {status, output, error}\n-             = run::process_output(\"echo\", [~\"hello\"]);\n+             = run::process_output(\"echo\", [~\"hello\"]).expect(\"failed to exec `echo`\");\n         let output_str = str::from_utf8_owned(output);\n \n         assert!(status.success());\n@@ -364,7 +385,7 @@ mod tests {\n     fn test_process_output_error() {\n \n         let run::ProcessOutput {status, output, error}\n-             = run::process_output(\"mkdir\", [~\".\"]);\n+             = run::process_output(\"mkdir\", [~\".\"]).expect(\"failed to exec `mkdir`\");\n \n         assert!(status.matches_exit_status(1));\n         assert_eq!(output, ~[]);\n@@ -385,7 +406,7 @@ mod tests {\n             in_fd: Some(pipe_in.input),\n             out_fd: Some(pipe_out.out),\n             err_fd: Some(pipe_err.out)\n-        });\n+        }).expect(\"failed to exec `cat`\");\n \n         os::close(pipe_in.input);\n         os::close(pipe_out.out);\n@@ -422,14 +443,16 @@ mod tests {\n     #[test]\n     #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n     fn test_finish_once() {\n-        let mut prog = run::Process::new(\"false\", [], run::ProcessOptions::new());\n+        let mut prog = run::Process::new(\"false\", [], run::ProcessOptions::new())\n+            .expect(\"failed to exec `false`\");\n         assert!(prog.finish().matches_exit_status(1));\n     }\n \n     #[test]\n     #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n     fn test_finish_twice() {\n-        let mut prog = run::Process::new(\"false\", [], run::ProcessOptions::new());\n+        let mut prog = run::Process::new(\"false\", [], run::ProcessOptions::new())\n+            .expect(\"failed to exec `false`\");\n         assert!(prog.finish().matches_exit_status(1));\n         assert!(prog.finish().matches_exit_status(1));\n     }\n@@ -438,7 +461,8 @@ mod tests {\n     #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n     fn test_finish_with_output_once() {\n \n-        let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions::new());\n+        let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions::new())\n+            .expect(\"failed to exec `echo`\");\n         let run::ProcessOutput {status, output, error}\n             = prog.finish_with_output();\n         let output_str = str::from_utf8_owned(output);\n@@ -455,7 +479,8 @@ mod tests {\n     #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n     fn test_finish_with_output_twice() {\n \n-        let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions::new());\n+        let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions::new())\n+            .expect(\"failed to exec `echo`\");\n         let run::ProcessOutput {status, output, error}\n             = prog.finish_with_output();\n \n@@ -484,22 +509,22 @@ mod tests {\n         run::Process::new(\"pwd\", [], run::ProcessOptions {\n             dir: dir,\n             .. run::ProcessOptions::new()\n-        })\n+        }).expect(\"failed to exec `pwd`\")\n     }\n     #[cfg(unix,target_os=\"android\")]\n     fn run_pwd(dir: Option<&Path>) -> run::Process {\n         run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"pwd\"], run::ProcessOptions {\n             dir: dir,\n             .. run::ProcessOptions::new()\n-        })\n+        }).expect(\"failed to exec `/system/bin/sh`\")\n     }\n \n     #[cfg(windows)]\n     fn run_pwd(dir: Option<&Path>) -> run::Process {\n         run::Process::new(\"cmd\", [~\"/c\", ~\"cd\"], run::ProcessOptions {\n             dir: dir,\n             .. run::ProcessOptions::new()\n-        })\n+        }).expect(\"failed to run `cmd`\")\n     }\n \n     #[test]\n@@ -539,22 +564,22 @@ mod tests {\n         run::Process::new(\"env\", [], run::ProcessOptions {\n             env: env,\n             .. run::ProcessOptions::new()\n-        })\n+        }).expect(\"failed to exec `env`\")\n     }\n     #[cfg(unix,target_os=\"android\")]\n     fn run_env(env: Option<~[(~str, ~str)]>) -> run::Process {\n         run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"set\"], run::ProcessOptions {\n             env: env,\n             .. run::ProcessOptions::new()\n-        })\n+        }).expect(\"failed to exec `/system/bin/sh`\")\n     }\n \n     #[cfg(windows)]\n     fn run_env(env: Option<~[(~str, ~str)]>) -> run::Process {\n         run::Process::new(\"cmd\", [~\"/c\", ~\"set\"], run::ProcessOptions {\n             env: env,\n             .. run::ProcessOptions::new()\n-        })\n+        }).expect(\"failed to run `cmd`\")\n     }\n \n     #[test]"}, {"sha": "4b7ab09e152b0388cdef9670074856949725e13b", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=aafed3ece58be56e5e88c51d32d065254f10309a", "patch": "@@ -27,7 +27,8 @@ fn test_destroy_once() {\n     #[cfg(target_os=\"android\")]\n     static PROG: &'static str = \"ls\"; // android don't have echo binary\n \n-    let mut p = run::Process::new(PROG, [], run::ProcessOptions::new());\n+    let mut p = run::Process::new(PROG, [], run::ProcessOptions::new())\n+        .expect(format!(\"failed to exec `{}`\", PROG));\n     p.destroy(); // this shouldn't crash (and nor should the destructor)\n }\n \n@@ -38,7 +39,8 @@ fn test_destroy_twice() {\n     #[cfg(target_os=\"android\")]\n     static PROG: &'static str = \"ls\"; // android don't have echo binary\n \n-    let mut p = run::Process::new(PROG, [], run::ProcessOptions::new());\n+    let mut p = run::Process::new(PROG, [], run::ProcessOptions::new())\n+        .expect(format!(\"failed to exec `{}`\", PROG));\n     p.destroy(); // this shouldnt crash...\n     io::io_error::cond.trap(|_| {}).inside(|| {\n         p.destroy(); // ...and nor should this (and nor should the destructor)\n@@ -58,13 +60,15 @@ fn test_destroy_actually_kills(force: bool) {\n \n     #[cfg(unix,not(target_os=\"android\"))]\n     fn process_exists(pid: libc::pid_t) -> bool {\n-        let run::ProcessOutput {output, ..} = run::process_output(\"ps\", [~\"-p\", pid.to_str()]);\n+        let run::ProcessOutput {output, ..} = run::process_output(\"ps\", [~\"-p\", pid.to_str()])\n+            .expect(\"failed to exec `ps`\");\n         str::from_utf8_owned(output).contains(pid.to_str())\n     }\n \n     #[cfg(unix,target_os=\"android\")]\n     fn process_exists(pid: libc::pid_t) -> bool {\n-        let run::ProcessOutput {output, ..} = run::process_output(\"/system/bin/ps\", [pid.to_str()]);\n+        let run::ProcessOutput {output, ..} = run::process_output(\"/system/bin/ps\", [pid.to_str()])\n+            .expect(\"failed to exec `/system/bin/ps`\");\n         str::from_utf8_owned(output).contains(~\"root\")\n     }\n \n@@ -88,7 +92,8 @@ fn test_destroy_actually_kills(force: bool) {\n     }\n \n     // this process will stay alive indefinitely trying to read from stdin\n-    let mut p = run::Process::new(BLOCK_COMMAND, [], run::ProcessOptions::new());\n+    let mut p = run::Process::new(BLOCK_COMMAND, [], run::ProcessOptions::new())\n+        .expect(format!(\"failed to exec `{}`\", BLOCK_COMMAND));\n \n     assert!(process_exists(p.get_id()));\n "}, {"sha": "c26c79112fe59fc724d516a53964c2c45ac0ea42", "filename": "src/test/run-pass/signal-exit-status.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aafed3ece58be56e5e88c51d32d065254f10309a/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs?ref=aafed3ece58be56e5e88c51d32d065254f10309a", "patch": "@@ -19,7 +19,8 @@ fn main() {\n         // Raise a segfault.\n         unsafe { *(0 as *mut int) = 0; }\n     } else {\n-        let status = run::process_status(args[0], [~\"signal\"]);\n+        let status = run::process_status(args[0], [~\"signal\"])\n+            .expect(\"failed to exec `signal`\");\n         // Windows does not have signal, so we get exit status 0xC0000028 (STATUS_BAD_STACK).\n         match status {\n             process::ExitSignal(_) if cfg!(unix) => {},"}]}