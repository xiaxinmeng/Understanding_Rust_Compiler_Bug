{"sha": "76ba3f0dd91719e15cdce8e90aa45f19215a3a3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2YmEzZjBkZDkxNzE5ZTE1Y2RjZThlOTBhYTQ1ZjE5MjE1YTNhM2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-03T14:16:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-03T14:16:52Z"}, "message": "Auto merge of #27488 - Gankro:uninit-docs, r=bluss\n\nInspired by https://github.com/rust-lang/rust/issues/27484", "tree": {"sha": "7ea9d88cc6dd6be20456f932eb3386f2daa9e56a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ea9d88cc6dd6be20456f932eb3386f2daa9e56a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76ba3f0dd91719e15cdce8e90aa45f19215a3a3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76ba3f0dd91719e15cdce8e90aa45f19215a3a3b", "html_url": "https://github.com/rust-lang/rust/commit/76ba3f0dd91719e15cdce8e90aa45f19215a3a3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76ba3f0dd91719e15cdce8e90aa45f19215a3a3b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea5cc76aac7094abfe01657db8312c8450b15200", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea5cc76aac7094abfe01657db8312c8450b15200", "html_url": "https://github.com/rust-lang/rust/commit/ea5cc76aac7094abfe01657db8312c8450b15200"}, {"sha": "5e6973ddc5ba311ece0e2399eb2c2a49ef0d3620", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e6973ddc5ba311ece0e2399eb2c2a49ef0d3620", "html_url": "https://github.com/rust-lang/rust/commit/5e6973ddc5ba311ece0e2399eb2c2a49ef0d3620"}], "stats": {"total": 80, "additions": 74, "deletions": 6}, "files": [{"sha": "3b321d43b3d119676481ad751805fd5daa863bed", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 74, "deletions": 6, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/76ba3f0dd91719e15cdce8e90aa45f19215a3a3b/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76ba3f0dd91719e15cdce8e90aa45f19215a3a3b/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=76ba3f0dd91719e15cdce8e90aa45f19215a3a3b", "patch": "@@ -253,21 +253,89 @@ pub unsafe fn dropped<T>() -> T {\n     dropped_impl()\n }\n \n-/// Creates an uninitialized value.\n+/// Bypasses Rust's normal memory-initialization checks by pretending to\n+/// produce a value of type T, while doing nothing at all.\n ///\n-/// Care must be taken when using this function, if the type `T` has a destructor and the value\n-/// falls out of scope (due to unwinding or returning) before being initialized, then the\n-/// destructor will run on uninitialized data, likely leading to crashes.\n+/// **This is incredibly dangerous, and should not be done lightly. Deeply\n+/// consider initializing your memory with a default value instead.**\n ///\n-/// This is useful for FFI functions sometimes, but should generally be avoided.\n+/// This is useful for FFI functions and initializing arrays sometimes,\n+/// but should generally be avoided.\n+///\n+/// # Undefined Behaviour\n+///\n+/// It is Undefined Behaviour to read uninitialized memory. Even just an\n+/// uninitialized boolean. For instance, if you branch on the value of such\n+/// a boolean your program may take one, both, or neither of the branches.\n+///\n+/// Note that this often also includes *writing* to the uninitialized value.\n+/// Rust believes the value is initialized, and will therefore try to Drop\n+/// the uninitialized value and its fields if you try to overwrite the memory\n+/// in a normal manner. The only way to safely initialize an arbitrary\n+/// uninitialized value is with one of the `ptr` functions: `write`, `copy`, or\n+/// `copy_nonoverlapping`. This isn't necessary if `T` is a primitive\n+/// or otherwise only contains types that don't implement Drop.\n+///\n+/// If this value *does* need some kind of Drop, it must be initialized before\n+/// it goes out of scope (and therefore would be dropped). Note that this\n+/// includes a `panic` occurring and unwinding the stack suddenly.\n ///\n /// # Examples\n ///\n+/// Here's how to safely initialize an array of `Vec`s.\n+///\n /// ```\n /// use std::mem;\n+/// use std::ptr;\n ///\n-/// let x: i32 = unsafe { mem::uninitialized() };\n+/// // Only declare the array. This safely leaves it\n+/// // uninitialized in a way that Rust will track for us.\n+/// // However we can't initialize it element-by-element\n+/// // safely, and we can't use the `[value; 1000]`\n+/// // constructor because it only works with `Copy` data.\n+/// let mut data: [Vec<u32>; 1000];\n+///\n+/// unsafe {\n+///     // So we need to do this to initialize it.\n+///     data = mem::uninitialized();\n+///\n+///     // DANGER ZONE: if anything panics or otherwise\n+///     // incorrectly reads the array here, we will have\n+///     // Undefined Behaviour.\n+///\n+///     // It's ok to mutably iterate the data, since this\n+///     // doesn't involve reading it at all.\n+///     // (ptr and len are statically known for arrays)\n+///     for elem in &mut data[..] {\n+///         // *elem = Vec::new() would try to drop the\n+///         // uninitialized memory at `elem` -- bad!\n+///         //\n+///         // Vec::new doesn't allocate or do really\n+///         // anything. It's only safe to call here\n+///         // because we know it won't panic.\n+///         ptr::write(elem, Vec::new());\n+///     }\n+///\n+///     // SAFE ZONE: everything is initialized.\n+/// }\n+///\n+/// println!(\"{:?}\", &data[0]);\n /// ```\n+///\n+/// Hopefully this example emphasizes to you exactly how delicate\n+/// and dangerous doing this is. Note that the `vec!` macro\n+/// *does* let you initialize every element with a value that\n+/// is only `Clone`, so the following is equivalent and vastly\n+/// less dangerous, as long as you can live with an extra heap\n+/// allocation:\n+///\n+/// ```\n+/// let data: Vec<Vec<u32>> = vec![Vec::new(); 1000];\n+/// println!(\"{:?}\", &data[0]);\n+/// ```\n+///\n+/// For large arrays this is probably advisable\n+/// anyway to avoid blowing the stack.\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn uninitialized<T>() -> T {"}]}