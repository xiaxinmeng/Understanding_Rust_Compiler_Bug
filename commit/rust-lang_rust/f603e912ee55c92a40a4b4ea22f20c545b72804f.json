{"sha": "f603e912ee55c92a40a4b4ea22f20c545b72804f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2MDNlOTEyZWU1NWM5MmE0MGE0YjRlYTIyZjIwYzU0NWI3MjgwNGY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T01:25:46Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T22:54:45Z"}, "message": "Convert local_ctxt to istrs. Issue #855", "tree": {"sha": "d4edd97c190f7ce86749d161755052482b85d364", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4edd97c190f7ce86749d161755052482b85d364"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f603e912ee55c92a40a4b4ea22f20c545b72804f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f603e912ee55c92a40a4b4ea22f20c545b72804f", "html_url": "https://github.com/rust-lang/rust/commit/f603e912ee55c92a40a4b4ea22f20c545b72804f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f603e912ee55c92a40a4b4ea22f20c545b72804f/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afe27d461cd78372f5c40f64de6a32a2011d0d9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/afe27d461cd78372f5c40f64de6a32a2011d0d9c", "html_url": "https://github.com/rust-lang/rust/commit/afe27d461cd78372f5c40f64de6a32a2011d0d9c"}], "stats": {"total": 55, "additions": 28, "deletions": 27}, "files": [{"sha": "3b4764b7aa7eb3accd4d0f2fa764de92edd3844c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f603e912ee55c92a40a4b4ea22f20c545b72804f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f603e912ee55c92a40a4b4ea22f20c545b72804f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=f603e912ee55c92a40a4b4ea22f20c545b72804f", "patch": "@@ -3169,7 +3169,7 @@ fn trans_for_each(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n     // Step 2: Declare foreach body function.\n     let s: istr =\n         mangle_internal_name_by_path_and_seq(lcx.ccx,\n-                                             istr::from_estrs(lcx.path),\n+                                             lcx.path,\n                                              ~\"foreach\");\n \n     // The 'env' arg entering the body function is a fake env member (as in\n@@ -3718,7 +3718,7 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: ty::t,\n     // Give the thunk a name, type, and value.\n     let s: istr =\n         mangle_internal_name_by_path_and_seq(cx.ccx,\n-                                             istr::from_estrs(cx.path),\n+                                             cx.path,\n                                              ~\"thunk\");\n     let llthunk_ty: TypeRef =\n         get_pair_fn_ty(type_of(cx.ccx, sp, incoming_fty));\n@@ -4318,9 +4318,9 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n         let llfnty: TypeRef =\n             type_of_fn_from_ty(ccx, e.span, node_id_type(ccx, e.id), 0u);\n         let sub_cx = extend_path(cx.fcx.lcx,\n-                                 istr::to_estr(ccx.names.next(~\"anon\")));\n+                                 ccx.names.next(~\"anon\"));\n         let s = mangle_internal_name_by_path(ccx,\n-                                             istr::from_estrs(sub_cx.path));\n+                                             sub_cx.path);\n         let llfn = decl_internal_fastcall_fn(ccx.llmod,\n                                              istr::to_estr(s), llfnty);\n \n@@ -4550,15 +4550,15 @@ fn load_if_immediate(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> ValueRef {\n \n fn trans_log(lvl: int, cx: &@block_ctxt, e: &@ast::expr) -> result {\n     let lcx = cx.fcx.lcx;\n-    let modname = str::connect(lcx.module_path, \"::\");\n+    let modname = istr::connect(lcx.module_path, ~\"::\");\n     let global;\n-    if lcx.ccx.module_data.contains_key(istr::from_estr(modname)) {\n-        global = lcx.ccx.module_data.get(istr::from_estr(modname));\n+    if lcx.ccx.module_data.contains_key(modname) {\n+        global = lcx.ccx.module_data.get(modname);\n     } else {\n         let s =\n             link::mangle_internal_name_by_path_and_seq(\n                 lcx.ccx,\n-                istr::from_estrs(lcx.module_path),\n+                lcx.module_path,\n                 ~\"loglevel\");\n         global = istr::as_buf(s, { |buf|\n             llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(), buf)\n@@ -4567,7 +4567,7 @@ fn trans_log(lvl: int, cx: &@block_ctxt, e: &@ast::expr) -> result {\n         llvm::LLVMSetInitializer(global, C_null(T_int()));\n         llvm::LLVMSetLinkage(global,\n                              lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n-        lcx.ccx.module_data.insert(istr::from_estr(modname), global);\n+        lcx.ccx.module_data.insert(modname, global);\n     }\n     let log_cx = new_scope_block_ctxt(cx, \"log\");\n     let after_cx = new_sub_block_ctxt(cx, \"after\");\n@@ -5156,9 +5156,9 @@ fn trans_block(cx: &@block_ctxt, b: &ast::blk, output: &out_method) ->\n }\n \n fn new_local_ctxt(ccx: &@crate_ctxt) -> @local_ctxt {\n-    let pth: [str] = [];\n+    let pth: [istr] = [];\n     ret @{path: pth,\n-          module_path: [istr::to_estr(ccx.link_meta.name)],\n+          module_path: [ccx.link_meta.name],\n           obj_typarams: [],\n           obj_fields: [],\n           ccx: ccx};\n@@ -5506,7 +5506,8 @@ fn trans_fn(cx: @local_ctxt, sp: &span, f: &ast::_fn, llfndecl: ValueRef,\n     let start = time::get_time();\n     trans_fn_inner(cx, sp, f, llfndecl, ty_self, ty_params, id);\n     let end = time::get_time();\n-    log_fn_time(cx.ccx, str::connect(cx.path, \"::\"), start, end);\n+    log_fn_time(cx.ccx, istr::to_estr(istr::connect(cx.path, ~\"::\")),\n+                start, end);\n }\n \n fn trans_res_ctor(cx: @local_ctxt, sp: &span, dtor: &ast::_fn,\n@@ -5664,7 +5665,7 @@ fn trans_const(cx: &@crate_ctxt, e: @ast::expr, id: ast::node_id) {\n fn trans_item(cx: @local_ctxt, item: &ast::item) {\n     alt item.node {\n       ast::item_fn(f, tps) {\n-        let sub_cx = extend_path(cx, istr::to_estr(item.ident));\n+        let sub_cx = extend_path(cx, item.ident);\n         alt cx.ccx.item_ids.find(item.id) {\n           some(llfndecl) {\n             trans_fn(sub_cx, item.span, f, llfndecl, none, tps, item.id);\n@@ -5678,7 +5679,7 @@ fn trans_item(cx: @local_ctxt, item: &ast::item) {\n       ast::item_obj(ob, tps, ctor_id) {\n         let sub_cx =\n             @{obj_typarams: tps, obj_fields: ob.fields\n-                 with *extend_path(cx, istr::to_estr(item.ident))};\n+                 with *extend_path(cx, item.ident)};\n         trans_obj(sub_cx, item.span, ob, ctor_id, tps);\n       }\n       ast::item_res(dtor, dtor_id, tps, ctor_id) {\n@@ -5696,13 +5697,13 @@ fn trans_item(cx: @local_ctxt, item: &ast::item) {\n       }\n       ast::item_mod(m) {\n         let sub_cx =\n-            @{path: cx.path + [istr::to_estr(item.ident)],\n+            @{path: cx.path + [item.ident],\n               module_path: cx.module_path\n-                  + [istr::to_estr(item.ident)] with *cx};\n+                  + [item.ident] with *cx};\n         trans_mod(sub_cx, m);\n       }\n       ast::item_tag(variants, tps) {\n-        let sub_cx = extend_path(cx, istr::to_estr(item.ident));\n+        let sub_cx = extend_path(cx, item.ident);\n         let degen = std::vec::len(variants) == 1u;\n         let i = 0;\n         for variant: ast::variant in variants {"}, {"sha": "b84ca8c3ea8e2e43e09b390e8bd3f0a62216feab", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f603e912ee55c92a40a4b4ea22f20c545b72804f/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f603e912ee55c92a40a4b4ea22f20c545b72804f/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=f603e912ee55c92a40a4b4ea22f20c545b72804f", "patch": "@@ -160,8 +160,8 @@ type crate_ctxt =\n      gc_cx: gc::ctxt};\n \n type local_ctxt =\n-    {path: [str],\n-     module_path: [str],\n+    {path: [istr],\n+     module_path: [istr],\n      obj_typarams: [ast::ty_param],\n      obj_fields: [ast::obj_field],\n      ccx: @crate_ctxt};\n@@ -430,7 +430,7 @@ tag block_parent { parent_none; parent_some(@block_ctxt); }\n type result = {bcx: @block_ctxt, val: ValueRef};\n type result_t = {bcx: @block_ctxt, val: ValueRef, ty: ty::t};\n \n-fn extend_path(cx: @local_ctxt, name: &str) -> @local_ctxt {\n+fn extend_path(cx: @local_ctxt, name: &istr) -> @local_ctxt {\n     ret @{path: cx.path + [name] with *cx};\n }\n "}, {"sha": "c3c17c2d1e54315e2911951fb264eac465ea4509", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f603e912ee55c92a40a4b4ea22f20c545b72804f/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f603e912ee55c92a40a4b4ea22f20c545b72804f/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=f603e912ee55c92a40a4b4ea22f20c545b72804f", "patch": "@@ -570,7 +570,7 @@ fn finish_vtbl(cx: @local_ctxt, llmethods: [ValueRef], name: str) ->\n    ValueRef {\n     let vtbl = C_struct(llmethods);\n     let vtbl_name = mangle_internal_name_by_path(\n-        cx.ccx, istr::from_estrs(cx.path + [name]));\n+        cx.ccx, cx.path + [istr::from_estr(name)]);\n     let gvar = istr::as_buf(vtbl_name, { |buf|\n         llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl), buf)\n     });\n@@ -602,13 +602,13 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // Create a local context that's aware of the name of the method we're\n     // creating.\n     let mcx: @local_ctxt = @{path: cx.path\n-        + [\"method\", istr::to_estr(m.ident)] with *cx};\n+        + [~\"method\", m.ident] with *cx};\n \n     // Make up a name for the backwarding function.\n     let fn_name: istr = ~\"backwarding_fn\";\n     let s: istr =\n         mangle_internal_name_by_path_and_seq(\n-            mcx.ccx, istr::from_estrs(mcx.path), fn_name);\n+            mcx.ccx, mcx.path, fn_name);\n \n     // Get the backwarding function's type and declare it.\n     let llbackwarding_fn_ty: TypeRef =\n@@ -733,13 +733,13 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // Create a local context that's aware of the name of the method we're\n     // creating.\n     let mcx: @local_ctxt = @{path: cx.path\n-        + [\"method\", istr::to_estr(m.ident)] with *cx};\n+        + [~\"method\", m.ident] with *cx};\n \n     // Make up a name for the forwarding function.\n     let fn_name: istr = ~\"forwarding_fn\";\n     let s: istr =\n         mangle_internal_name_by_path_and_seq(\n-            mcx.ccx, istr::from_estrs(mcx.path), fn_name);\n+            mcx.ccx, mcx.path, fn_name);\n \n     // Get the forwarding function's type and declare it.\n     let llforwarding_fn_ty: TypeRef =\n@@ -926,9 +926,9 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n       }\n     }\n     let mcx: @local_ctxt =\n-        @{path: cx.path + [\"method\", istr::to_estr(m.node.ident)] with *cx};\n+        @{path: cx.path + [~\"method\", m.node.ident] with *cx};\n     let s: istr = mangle_internal_name_by_path(mcx.ccx,\n-                                               istr::from_estrs(mcx.path));\n+                                               mcx.path);\n     let llfn: ValueRef = decl_internal_fastcall_fn(\n         cx.ccx.llmod, istr::to_estr(s), llfnty);\n "}]}