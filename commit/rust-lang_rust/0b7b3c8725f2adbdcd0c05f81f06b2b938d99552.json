{"sha": "0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiN2IzYzg3MjVmMmFkYmRjZDBjMDVmODFmMDZiMmI5MzhkOTk1NTI=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-09-10T22:56:14Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-09-10T22:56:14Z"}, "message": "Merge pull request #216 from marcusklaas/format-fields\n\nWIP: Format expression chains", "tree": {"sha": "3ed01a4ac586c7c4cb3528d7532fc9a4dd22701f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ed01a4ac586c7c4cb3528d7532fc9a4dd22701f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "html_url": "https://github.com/rust-lang/rust/commit/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1af301c33d1886a4e037f6ddb1ce495aa8d0573b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1af301c33d1886a4e037f6ddb1ce495aa8d0573b", "html_url": "https://github.com/rust-lang/rust/commit/1af301c33d1886a4e037f6ddb1ce495aa8d0573b"}, {"sha": "7f576b06022357672eb24d6103673f982a6ba817", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f576b06022357672eb24d6103673f982a6ba817", "html_url": "https://github.com/rust-lang/rust/commit/7f576b06022357672eb24d6103673f982a6ba817"}], "stats": {"total": 1100, "additions": 740, "deletions": 360}, "files": [{"sha": "9913c68cdfa9845d4563eb9bf27e8d9bb6c44575", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -82,7 +82,9 @@ fn main() {\n }\n \n fn print_usage<S: Into<String>>(reason: S) {\n-    println!(\"{}\\n\\r usage: rustfmt [-h Help] [--write-mode=[replace|overwrite|display|diff]] <file_name>\", reason.into());\n+    println!(\"{}\\n\\r usage: rustfmt [-h Help] [--write-mode=[replace|overwrite|display|diff]] \\\n+              <file_name>\",\n+             reason.into());\n }\n \n fn determine_params<I>(args: I) -> Option<(Vec<String>, WriteMode)>\n@@ -123,6 +125,5 @@ fn determine_params<I>(args: I) -> Option<(Vec<String>, WriteMode)>\n         return None;\n     }\n \n-\n     Some((rustc_args, write_mode))\n }"}, {"sha": "bd9f302824bed9d17352ffef4f0913faec92369e", "filename": "src/chains.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -0,0 +1,195 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Formatting of chained expressions, i.e. expressions which are chained by\n+// dots: struct and enum field access and method calls.\n+//\n+// Instead of walking these subexpressions one-by-one, as is our usual strategy\n+// for expression formatting, we collect maximal sequences of these expressions\n+// and handle them simultaneously.\n+//\n+// Whenever possible, the entire chain is put on a single line. If that fails,\n+// we put each subexpression on a separate, much like the (default) function\n+// argument function argument strategy.\n+\n+use rewrite::{Rewrite, RewriteContext};\n+use utils::{first_line_width, make_indent};\n+use expr::rewrite_call;\n+\n+use syntax::{ast, ptr};\n+use syntax::codemap::{mk_sp, Span};\n+use syntax::print::pprust;\n+\n+pub fn rewrite_chain(mut expr: &ast::Expr,\n+                     context: &RewriteContext,\n+                     width: usize,\n+                     offset: usize)\n+                     -> Option<String> {\n+    let total_span = expr.span;\n+    let mut subexpr_list = vec![expr];\n+\n+    while let Some(subexpr) = pop_expr_chain(expr) {\n+        subexpr_list.push(subexpr);\n+        expr = subexpr;\n+    }\n+\n+    let parent = subexpr_list.pop().unwrap();\n+    let parent_rewrite = try_opt!(expr.rewrite(context, width, offset));\n+    let (extra_indent, extend) = if !parent_rewrite.contains('\\n') && is_continuable(parent) ||\n+                                    parent_rewrite.len() <= context.config.tab_spaces {\n+        (parent_rewrite.len(), true)\n+    } else {\n+        (context.config.tab_spaces, false)\n+    };\n+    let indent = offset + extra_indent;\n+\n+    let max_width = try_opt!(width.checked_sub(extra_indent));\n+    let mut rewrites = try_opt!(subexpr_list.iter()\n+                                            .rev()\n+                                            .map(|e| {\n+                                                rewrite_chain_expr(e,\n+                                                                   total_span,\n+                                                                   context,\n+                                                                   max_width,\n+                                                                   indent)\n+                                            })\n+                                            .collect::<Option<Vec<_>>>());\n+\n+    // Total of all items excluding the last.\n+    let almost_total = rewrites.split_last()\n+                               .unwrap()\n+                               .1\n+                               .iter()\n+                               .fold(0, |a, b| a + first_line_width(b)) +\n+                       parent_rewrite.len();\n+    let total_width = almost_total + first_line_width(rewrites.last().unwrap());\n+    let veto_single_line = if context.config.take_source_hints && subexpr_list.len() > 1 {\n+        // Look at the source code. Unless all chain elements start on the same\n+        // line, we won't consider putting them on a single line either.\n+        let first_line_no = context.codemap.lookup_char_pos(subexpr_list[0].span.lo).line;\n+\n+        subexpr_list[1..]\n+            .iter()\n+            .any(|ex| context.codemap.lookup_char_pos(ex.span.hi).line != first_line_no)\n+    } else {\n+        false\n+    };\n+\n+    let fits_single_line = !veto_single_line &&\n+                           match subexpr_list[0].node {\n+        ast::Expr_::ExprMethodCall(ref method_name, ref types, ref expressions)\n+            if context.config.chains_overflow_last => {\n+            let (last, init) = rewrites.split_last_mut().unwrap();\n+\n+            if init.iter().all(|s| !s.contains('\\n')) && total_width <= width {\n+                let last_rewrite = width.checked_sub(almost_total)\n+                                        .and_then(|inner_width| {\n+                                            rewrite_method_call(method_name.node,\n+                                                                types,\n+                                                                expressions,\n+                                                                total_span,\n+                                                                context,\n+                                                                inner_width,\n+                                                                offset + almost_total)\n+                                        });\n+                match last_rewrite {\n+                    Some(mut string) => {\n+                        ::std::mem::swap(&mut string, last);\n+                        true\n+                    }\n+                    None => false,\n+                }\n+            } else {\n+                false\n+            }\n+        }\n+        _ => total_width <= width && rewrites.iter().all(|s| !s.contains('\\n')),\n+    };\n+\n+    let connector = if fits_single_line {\n+        String::new()\n+    } else {\n+        format!(\"\\n{}\", make_indent(indent))\n+    };\n+\n+    let first_connector = if extend {\n+        \"\"\n+    } else {\n+        &connector[..]\n+    };\n+\n+    Some(format!(\"{}{}{}\", parent_rewrite, first_connector, rewrites.join(&connector)))\n+}\n+\n+fn pop_expr_chain<'a>(expr: &'a ast::Expr) -> Option<&'a ast::Expr> {\n+    match expr.node {\n+        ast::Expr_::ExprMethodCall(_, _, ref expressions) => {\n+            Some(&expressions[0])\n+        }\n+        ast::Expr_::ExprTupField(ref subexpr, _) |\n+        ast::Expr_::ExprField(ref subexpr, _) => {\n+            Some(subexpr)\n+        }\n+        _ => None,\n+    }\n+}\n+\n+fn rewrite_chain_expr(expr: &ast::Expr,\n+                      span: Span,\n+                      context: &RewriteContext,\n+                      width: usize,\n+                      offset: usize)\n+                      -> Option<String> {\n+    match expr.node {\n+        ast::Expr_::ExprMethodCall(ref method_name, ref types, ref expressions) => {\n+            let inner = &RewriteContext {\n+                block_indent: offset,\n+                ..*context\n+            };\n+            rewrite_method_call(method_name.node, types, expressions, span, inner, width, offset)\n+        }\n+        ast::Expr_::ExprField(_, ref field) => {\n+            Some(format!(\".{}\", field.node))\n+        }\n+        ast::Expr_::ExprTupField(_, ref field) => {\n+            Some(format!(\".{}\", field.node))\n+        }\n+        _ => unreachable!(),\n+    }\n+}\n+\n+// Determines we can continue formatting a given expression on the same line.\n+fn is_continuable(expr: &ast::Expr) -> bool {\n+    match expr.node {\n+        ast::Expr_::ExprPath(..) => true,\n+        _ => false,\n+    }\n+}\n+\n+fn rewrite_method_call(method_name: ast::Ident,\n+                       types: &[ptr::P<ast::Ty>],\n+                       args: &[ptr::P<ast::Expr>],\n+                       span: Span,\n+                       context: &RewriteContext,\n+                       width: usize,\n+                       offset: usize)\n+                       -> Option<String> {\n+    let type_str = if types.is_empty() {\n+        String::new()\n+    } else {\n+        let type_list = types.iter().map(|ty| pprust::ty_to_string(ty)).collect::<Vec<_>>();\n+        format!(\"::<{}>\", type_list.join(\", \"))\n+    };\n+\n+    let callee_str = format!(\".{}{}\", method_name, type_str);\n+    let span = mk_sp(args[0].span.hi, span.hi);\n+\n+    rewrite_call(context, &callee_str, &args[1..], span, width, offset)\n+}"}, {"sha": "ff7558131d209501aaac92b7b5ebdfe9fee22258", "filename": "src/comment.rs", "status": "modified", "additions": 49, "deletions": 58, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -25,8 +25,7 @@ pub fn rewrite_comment(orig: &str, block_style: bool, width: usize, offset: usiz\n         (\"// \", \"\", \"// \")\n     };\n \n-    let max_chars = width.checked_sub(closer.len()).unwrap_or(1)\n-                         .checked_sub(opener.len()).unwrap_or(1);\n+    let max_chars = width.checked_sub(closer.len() + opener.len()).unwrap_or(1);\n \n     let fmt = StringFormat {\n         opener: \"\",\n@@ -41,44 +40,45 @@ pub fn rewrite_comment(orig: &str, block_style: bool, width: usize, offset: usiz\n     let indent_str = make_indent(offset);\n     let line_breaks = s.chars().filter(|&c| c == '\\n').count();\n \n-    let (_, mut s) = s.lines().enumerate()\n-        .map(|(i, mut line)| {\n-            line = line.trim();\n-\n-            // Drop old closer.\n-            if i == line_breaks && line.ends_with(\"*/\") && !line.starts_with(\"//\") {\n-                line = &line[..(line.len() - 2)];\n-            }\n-\n-            line.trim_right()\n-        })\n-        .map(left_trim_comment_line)\n-        .map(|line| {\n-            if line_breaks == 0 {\n-                line.trim_left()\n-            } else {\n-                line\n-            }\n-        })\n-        .fold((true, opener.to_owned()), |(first, mut acc), line| {\n-            if !first {\n-                acc.push('\\n');\n-                acc.push_str(&indent_str);\n-                acc.push_str(line_start);\n-            }\n-\n-            if line.len() > max_chars {\n-                acc.push_str(&rewrite_string(line, &fmt));\n-            } else {\n-                if line.len() == 0 {\n-                    acc.pop(); // Remove space if this is an empty comment.\n-                } else {\n-                    acc.push_str(line);\n-                }\n-            }\n-\n-            (false, acc)\n-        });\n+    let (_, mut s) = s.lines()\n+                      .enumerate()\n+                      .map(|(i, mut line)| {\n+                          line = line.trim();\n+                          // Drop old closer.\n+                          if i == line_breaks && line.ends_with(\"*/\") && !line.starts_with(\"//\") {\n+                              line = &line[..(line.len() - 2)];\n+                          }\n+\n+                          line.trim_right()\n+                      })\n+                      .map(left_trim_comment_line)\n+                      .map(|line| {\n+                          if line_breaks == 0 {\n+                              line.trim_left()\n+                          } else {\n+                              line\n+                          }\n+                      })\n+                      .fold((true, opener.to_owned()),\n+                            |(first, mut acc), line| {\n+                                if !first {\n+                                    acc.push('\\n');\n+                                    acc.push_str(&indent_str);\n+                                    acc.push_str(line_start);\n+                                }\n+\n+                                if line.len() > max_chars {\n+                                    acc.push_str(&rewrite_string(line, &fmt));\n+                                } else {\n+                                    if line.len() == 0 {\n+                                        acc.pop(); // Remove space if this is an empty comment.\n+                                    } else {\n+                                        acc.push_str(line);\n+                                    }\n+                                }\n+\n+                                (false, acc)\n+                            });\n \n     s.push_str(closer);\n \n@@ -146,24 +146,11 @@ pub fn find_comment_end(s: &str) -> Option<usize> {\n     }\n }\n \n-#[test]\n-fn comment_end() {\n-    assert_eq!(Some(6), find_comment_end(\"// hi\\n\"));\n-    assert_eq!(Some(9), find_comment_end(\"/* sup */ \"));\n-    assert_eq!(Some(9), find_comment_end(\"/*/**/ */ \"));\n-    assert_eq!(Some(6), find_comment_end(\"/*/ */ weird!\"));\n-    assert_eq!(None, find_comment_end(\"/* hi /* test */\"));\n-    assert_eq!(None, find_comment_end(\"// hi /* test */\"));\n-    assert_eq!(Some(9), find_comment_end(\"// hi /*\\n.\"));\n-}\n-\n-\n /// Returns true if text contains any comment.\n pub fn contains_comment(text: &str) -> bool {\n-    CharClasses::new(text.chars()).any(|(kind, _)| kind == CodeCharKind::Comment )\n+    CharClasses::new(text.chars()).any(|(kind, _)| kind == CodeCharKind::Comment)\n }\n \n-\n struct CharClasses<T>\n     where T: Iterator,\n           T::Item: RichChar\n@@ -324,10 +311,14 @@ mod test {\n     // This is probably intended to be a non-test fn, but it is not used. I'm\n     // keeping it around unless it helps us test stuff.\n     fn uncommented(text: &str) -> String {\n-        CharClasses::new(text.chars()).filter_map(|(s, c)| match s {\n-            CodeCharKind::Normal => Some(c),\n-            CodeCharKind::Comment => None\n-        }).collect()\n+        CharClasses::new(text.chars())\n+            .filter_map(|(s, c)| {\n+                match s {\n+                    CodeCharKind::Normal => Some(c),\n+                    CodeCharKind::Comment => None,\n+                }\n+            })\n+            .collect()\n     }\n \n     #[test]"}, {"sha": "d45f184051fc003a9f371b4f8892f7ace6dde37f", "filename": "src/config.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -133,8 +133,8 @@ create_config! {\n     fn_args_density: Density,\n     fn_args_layout: StructLitStyle,\n     fn_arg_indent: BlockIndentStyle,\n-    where_density: Density, // Should we at least try to put the where clause on the same line as\n-                            // the rest of the function decl?\n+    where_density: Density, // Should we at least try to put the where clause on\n+                            // the same line as the rest of the function decl?\n     where_indent: BlockIndentStyle, // Visual will be treated like Tabbed\n     where_layout: ListTactic,\n     where_pred_indent: BlockIndentStyle,\n@@ -147,14 +147,14 @@ create_config! {\n     report_todo: ReportTactic,\n     report_fixme: ReportTactic,\n     reorder_imports: bool, // Alphabetically, case sensitive.\n-    expr_indent_style: BlockIndentStyle,\n-    closure_indent_style: BlockIndentStyle,\n     single_line_if_else: bool,\n     format_strings: bool,\n+    chains_overflow_last: bool,\n+    take_source_hints: bool, // Retain some formatting characteristics from\n+                             // the source code.\n }\n \n impl Default for Config {\n-\n     fn default() -> Config {\n         Config {\n             max_width: 100,\n@@ -181,11 +181,10 @@ impl Default for Config {\n             report_todo: ReportTactic::Always,\n             report_fixme: ReportTactic::Never,\n             reorder_imports: false,\n-            expr_indent_style: BlockIndentStyle::Tabbed,\n-            closure_indent_style: BlockIndentStyle::Visual,\n             single_line_if_else: false,\n             format_strings: true,\n+            chains_overflow_last: true,\n+            take_source_hints: true,\n         }\n     }\n-\n }"}, {"sha": "c7dad3d2ccff0c8cccd12c7384e745ba3ebf64f2", "filename": "src/expr.rs", "status": "modified", "additions": 71, "deletions": 84, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::cmp::Ordering;\n+use std::borrow::Borrow;\n \n use rewrite::{Rewrite, RewriteContext};\n use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTactic};\n@@ -17,10 +18,11 @@ use StructLitStyle;\n use utils::{span_after, make_indent, extra_offset, first_line_width, last_line_width, wrap_str,\n             binary_search};\n use visitor::FmtVisitor;\n-use config::{BlockIndentStyle, MultilineStyle};\n+use config::MultilineStyle;\n use comment::{FindUncommented, rewrite_comment, contains_comment};\n use types::rewrite_path;\n use items::{span_lo_for_arg, span_hi_for_arg, rewrite_fn_input};\n+use chains::rewrite_chain;\n \n use syntax::{ast, ptr};\n use syntax::codemap::{CodeMap, Span, BytePos, mk_sp};\n@@ -38,7 +40,7 @@ impl Rewrite for ast::Expr {\n                 }\n             }\n             ast::Expr_::ExprCall(ref callee, ref args) => {\n-                rewrite_call(context, callee, args, self.span, width, offset)\n+                rewrite_call(context, &**callee, args, self.span, width, offset)\n             }\n             ast::Expr_::ExprParen(ref subexpr) => {\n                 rewrite_paren(context, subexpr, width, offset)\n@@ -137,6 +139,11 @@ impl Rewrite for ast::Expr {\n             ast::Expr_::ExprClosure(capture, ref fn_decl, ref body) => {\n                 rewrite_closure(capture, fn_decl, body, self.span, context, width, offset)\n             }\n+            ast::Expr_::ExprField(..) |\n+            ast::Expr_::ExprTupField(..) |\n+            ast::Expr_::ExprMethodCall(..) => {\n+                rewrite_chain(self, context, width, offset)\n+            }\n             // We do not format these expressions yet, but they should still\n             // satisfy our width restrictions.\n             _ => wrap_str(context.snippet(self.span), context.config.max_width, width, offset),\n@@ -201,8 +208,6 @@ fn rewrite_closure(capture: ast::CaptureClause,\n         prefix.push_str(&ret_str);\n     }\n \n-    let closure_indent = closure_indent(context, offset);\n-\n     // Try to format closure body as a single line expression without braces.\n     if is_simple_block(body, context.codemap) && !prefix.contains('\\n') {\n         let (spacer, closer) = if ret_str.is_empty() {\n@@ -233,17 +238,16 @@ fn rewrite_closure(capture: ast::CaptureClause,\n \n     // We couldn't format the closure body as a single line expression; fall\n     // back to block formatting.\n-    let inner_context = context.overflow_context(closure_indent - context.block_indent);\n     let body_rewrite = body.expr\n                            .as_ref()\n                            .and_then(|body_expr| {\n                                if let ast::Expr_::ExprBlock(ref inner) = body_expr.node {\n-                                   Some(inner.rewrite(&inner_context, 2, 0))\n+                                   Some(inner.rewrite(&context, 2, 0))\n                                } else {\n                                    None\n                                }\n                            })\n-                           .unwrap_or_else(|| body.rewrite(&inner_context, 2, 0));\n+                           .unwrap_or_else(|| body.rewrite(&context, 2, 0));\n \n     Some(format!(\"{} {}\", prefix, try_opt!(body_rewrite)))\n }\n@@ -277,8 +281,10 @@ impl Rewrite for ast::Block {\n                 };\n \n                 if is_simple_block(self, context.codemap) && prefix.len() < width {\n-                    let body =\n-                        self.expr.as_ref().unwrap().rewrite(context, width - prefix.len(), offset);\n+                    let body = self.expr\n+                                   .as_ref()\n+                                   .unwrap()\n+                                   .rewrite(context, width - prefix.len(), offset);\n                     if let Some(ref expr_str) = body {\n                         let result = format!(\"{}{{ {} }}\", prefix, expr_str);\n                         if result.len() <= width && !result.contains('\\n') {\n@@ -393,9 +399,9 @@ impl<'a> Rewrite for Loop<'a> {\n         };\n \n         // FIXME: this drops any comment between \"loop\" and the block.\n-        self.block.rewrite(context, width, offset).map(|result| {\n-            format!(\"{}{}{} {}\", label_string, self.keyword, pat_expr_string, result)\n-        })\n+        self.block\n+            .rewrite(context, width, offset)\n+            .map(|result| format!(\"{}{}{} {}\", label_string, self.keyword, pat_expr_string, result))\n     }\n }\n \n@@ -670,15 +676,13 @@ impl Rewrite for ast::Arm {\n         total_width += (pat_strs.len() - 1) * 3;\n \n         let mut vertical = total_width > pat_budget || pat_strs.iter().any(|p| p.contains('\\n'));\n-        if !vertical {\n+        if !vertical && context.config.take_source_hints {\n             // If the patterns were previously stacked, keep them stacked.\n-            // FIXME should be an option.\n             let pat_span = mk_sp(pats[0].span.lo, pats[pats.len() - 1].span.hi);\n             let pat_str = context.snippet(pat_span);\n             vertical = pat_str.find('\\n').is_some();\n         }\n \n-\n         let pats_width = if vertical {\n             pat_strs[pat_strs.len() - 1].len()\n         } else {\n@@ -717,9 +721,7 @@ impl Rewrite for ast::Arm {\n         // 4 = ` => `.len()\n         if context.config.max_width > line_start + comma.len() + 4 {\n             let budget = context.config.max_width - line_start - comma.len() - 4;\n-            if let Some(ref body_str) = body.rewrite(context,\n-                                                     budget,\n-                                                     line_start + 4) {\n+            if let Some(ref body_str) = body.rewrite(context, budget, line_start + 4) {\n                 if first_line_width(body_str) <= budget {\n                     return Some(format!(\"{}{} => {}{}\",\n                                         attr_str.trim_left(),\n@@ -762,9 +764,7 @@ fn rewrite_guard(context: &RewriteContext,\n         // 4 = ` if `, 5 = ` => {`\n         let overhead = pattern_width + 4 + 5;\n         if overhead < width {\n-            let cond_str = guard.rewrite(context,\n-                                         width - overhead,\n-                                         offset + pattern_width + 4);\n+            let cond_str = guard.rewrite(context, width - overhead, offset + pattern_width + 4);\n             if let Some(cond_str) = cond_str {\n                 return Some(format!(\" if {}\", cond_str));\n             }\n@@ -866,36 +866,35 @@ fn rewrite_string_lit(context: &RewriteContext,\n     Some(rewrite_string(str_lit, &fmt))\n }\n \n-fn rewrite_call(context: &RewriteContext,\n-                callee: &ast::Expr,\n-                args: &[ptr::P<ast::Expr>],\n-                span: Span,\n-                width: usize,\n-                offset: usize)\n-                -> Option<String> {\n-    let callback = |callee_max_width| {\n-                       rewrite_call_inner(context,\n-                                          callee,\n-                                          callee_max_width,\n-                                          args,\n-                                          span,\n-                                          width,\n-                                          offset)\n-                   };\n+pub fn rewrite_call<R>(context: &RewriteContext,\n+                       callee: &R,\n+                       args: &[ptr::P<ast::Expr>],\n+                       span: Span,\n+                       width: usize,\n+                       offset: usize)\n+                       -> Option<String>\n+    where R: Rewrite\n+{\n+    let closure = |callee_max_width| {\n+        rewrite_call_inner(context, callee, callee_max_width, args, span, width, offset)\n+    };\n \n     // 2 is for parens\n     let max_width = try_opt!(width.checked_sub(2));\n-    binary_search(1, max_width, callback)\n+    binary_search(1, max_width, closure)\n }\n \n-fn rewrite_call_inner(context: &RewriteContext,\n-                      callee: &ast::Expr,\n-                      max_callee_width: usize,\n-                      args: &[ptr::P<ast::Expr>],\n-                      span: Span,\n-                      width: usize,\n-                      offset: usize)\n-                      -> Result<String, Ordering> {\n+fn rewrite_call_inner<R>(context: &RewriteContext,\n+                         callee: &R,\n+                         max_callee_width: usize,\n+                         args: &[ptr::P<ast::Expr>],\n+                         span: Span,\n+                         width: usize,\n+                         offset: usize)\n+                         -> Result<String, Ordering>\n+    where R: Rewrite\n+{\n+    let callee = callee.borrow();\n     // FIXME using byte lens instead of char lens (and probably all over the\n     // place too)\n     let callee_str = match callee.rewrite(context, max_callee_width, offset) {\n@@ -909,15 +908,22 @@ fn rewrite_call_inner(context: &RewriteContext,\n         None => return Err(Ordering::Greater),\n     };\n \n+    let span_lo = span_after(span, \"(\", context.codemap);\n+    let span = mk_sp(span_lo, span.hi);\n+\n     let extra_offset = extra_offset(&callee_str, offset);\n     // 2 is for parens.\n     let remaining_width = match width.checked_sub(extra_offset + 2) {\n         Some(str) => str,\n         None => return Err(Ordering::Greater),\n     };\n     let offset = offset + extra_offset + 1;\n-    let inner_indent = expr_indent(context, offset);\n-    let inner_context = context.overflow_context(inner_indent - context.block_indent);\n+    let block_indent = if args.len() == 1 {\n+        context.block_indent\n+    } else {\n+        offset\n+    };\n+    let inner_context = &RewriteContext { block_indent: block_indent, ..*context };\n \n     let items = itemize_list(context.codemap,\n                              args.iter(),\n@@ -929,7 +935,7 @@ fn rewrite_call_inner(context: &RewriteContext,\n                                  item.rewrite(&inner_context, remaining_width, offset)\n                                      .unwrap_or(context.snippet(item.span))\n                              },\n-                             callee.span.hi + BytePos(1),\n+                             span.lo,\n                              span.hi);\n \n     let fmt = ListFormatting::for_fn(remaining_width, offset);\n@@ -941,21 +947,6 @@ fn rewrite_call_inner(context: &RewriteContext,\n     Ok(format!(\"{}({})\", callee_str, list_str))\n }\n \n-macro_rules! block_indent_helper {\n-    ($name:ident, $option:ident) => (\n-        fn $name(context: &RewriteContext, offset: usize) -> usize {\n-            match context.config.$option {\n-                BlockIndentStyle::Inherit => context.block_indent,\n-                BlockIndentStyle::Tabbed => context.block_indent + context.config.tab_spaces,\n-                BlockIndentStyle::Visual => offset,\n-            }\n-        }\n-    );\n-}\n-\n-block_indent_helper!(expr_indent, expr_indent_style);\n-block_indent_helper!(closure_indent, closure_indent_style);\n-\n fn rewrite_paren(context: &RewriteContext,\n                  subexpr: &ast::Expr,\n                  width: usize,\n@@ -1004,7 +995,8 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n         }\n     };\n \n-    let field_iter = fields.into_iter().map(StructLitField::Regular)\n+    let field_iter = fields.into_iter()\n+                           .map(StructLitField::Regular)\n                            .chain(base.into_iter().map(StructLitField::Base));\n \n     let inner_context = &RewriteContext { block_indent: indent, ..*context };\n@@ -1016,10 +1008,11 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                                  match *item {\n                                      StructLitField::Regular(ref field) => field.span.lo,\n                                      StructLitField::Base(ref expr) => {\n-                                         let last_field_hi =\n-                                             fields.last().map_or(span.lo, |field| field.span.hi);\n-                                         let snippet =\n-                                             context.snippet(mk_sp(last_field_hi, expr.span.lo));\n+                                         let last_field_hi = fields.last()\n+                                                                   .map_or(span.lo,\n+                                                                           |field| field.span.hi);\n+                                         let snippet = context.snippet(mk_sp(last_field_hi,\n+                                                                             expr.span.lo));\n                                          let pos = snippet.find_uncommented(\"..\").unwrap();\n                                          last_field_hi + BytePos(pos as u32)\n                                      }\n@@ -1035,7 +1028,7 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                                  match *item {\n                                      StructLitField::Regular(ref field) => {\n                                          rewrite_field(inner_context, &field, h_budget, indent)\n-                                            .unwrap_or(context.snippet(field.span))\n+                                             .unwrap_or(context.snippet(field.span))\n                                      }\n                                      StructLitField::Base(ref expr) => {\n                                          // 2 = ..\n@@ -1067,11 +1060,10 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n     let fields_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n \n     let format_on_newline = || {\n-                                let inner_indent = make_indent(context.block_indent +\n-                                                               context.config.tab_spaces);\n-                                let outer_indent = make_indent(context.block_indent);\n-                                Some(format!(\"{} {{\\n{}{}\\n{}}}\", path_str, inner_indent, fields_str, outer_indent))\n-                            };\n+        let inner_indent = make_indent(context.block_indent + context.config.tab_spaces);\n+        let outer_indent = make_indent(context.block_indent);\n+        Some(format!(\"{} {{\\n{}{}\\n{}}}\", path_str, inner_indent, fields_str, outer_indent))\n+    };\n \n     match (context.config.struct_lit_style, context.config.struct_lit_multiline_style) {\n         (StructLitStyle::Block, _) if fields_str.contains('\\n') => format_on_newline(),\n@@ -1090,8 +1082,8 @@ fn rewrite_field(context: &RewriteContext,\n                  -> Option<String> {\n     let name = &field.ident.node.to_string();\n     let overhead = name.len() + 2;\n-    let expr =\n-        field.expr.rewrite(context, try_opt!(width.checked_sub(overhead)), offset + overhead);\n+    let expr = field.expr\n+                    .rewrite(context, try_opt!(width.checked_sub(overhead)), offset + overhead);\n     expr.map(|s| format!(\"{}: {}\", name, s))\n }\n \n@@ -1152,10 +1144,7 @@ fn rewrite_binary_op(context: &RewriteContext,\n     // worth trying to put everything on one line.\n     if rhs_result.len() + 2 + operator_str.len() < width && !rhs_result.contains('\\n') {\n         // 1 = space between lhs expr and operator\n-        if let Some(mut result) = lhs.rewrite(context,\n-                                              width - 1 - operator_str.len(),\n-                                              offset) {\n-\n+        if let Some(mut result) = lhs.rewrite(context, width - 1 - operator_str.len(), offset) {\n             result.push(' ');\n             result.push_str(&operator_str);\n             result.push(' ');\n@@ -1167,9 +1156,7 @@ fn rewrite_binary_op(context: &RewriteContext,\n                 return Some(result);\n             }\n \n-            if let Some(rhs_result) = rhs.rewrite(context,\n-                                                  remaining_width,\n-                                                  offset + result.len()) {\n+            if let Some(rhs_result) = rhs.rewrite(context, remaining_width, offset + result.len()) {\n                 if rhs_result.len() <= remaining_width {\n                     result.push_str(&rhs_result);\n                     return Some(result);"}, {"sha": "1d215d022d12e6f54652d49c08bf6a9c4b6f8b4d", "filename": "src/imports.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -38,10 +38,10 @@ impl Rewrite for ast::ViewPath {\n                 let path_str = try_opt!(path.rewrite(context, width - ident_str.len() - 4, offset));\n \n                 Some(if path.segments.last().unwrap().identifier == ident {\n-                        path_str\n-                    } else {\n-                        format!(\"{} as {}\", path_str, ident_str)\n-                    })\n+                    path_str\n+                } else {\n+                    format!(\"{} as {}\", path_str, ident_str)\n+                })\n             }\n         }\n     }\n@@ -150,10 +150,10 @@ pub fn rewrite_use_list(width: usize,\n     let list_str = try_opt!(write_list(&items[first_index..], &fmt));\n \n     Some(if path_str.is_empty() {\n-            format!(\"{{{}}}\", list_str)\n-        } else {\n-            format!(\"{}::{{{}}}\", path_str, list_str)\n-        })\n+        format!(\"{{{}}}\", list_str)\n+    } else {\n+        format!(\"{}::{{{}}}\", path_str, list_str)\n+    })\n }\n \n // Returns true when self item was found."}, {"sha": "958dbb20df048349e5c1d0e7cc44ebe4a0d790b6", "filename": "src/items.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -334,11 +334,13 @@ impl<'a> FmtVisitor<'a> {\n         // FIXME: the comment for the self argument is dropped. This is blocked\n         // on rust issue #27522.\n         let min_args = explicit_self.and_then(|explicit_self| {\n-                           rewrite_explicit_self(explicit_self, args)\n-                       }).map(|self_str| {\n-                           arg_item_strs[0] = self_str;\n-                           2\n-                       }).unwrap_or(1);\n+                                        rewrite_explicit_self(explicit_self, args)\n+                                    })\n+                                    .map(|self_str| {\n+                                        arg_item_strs[0] = self_str;\n+                                        2\n+                                    })\n+                                    .unwrap_or(1);\n \n         // Comments between args\n         let mut arg_items = Vec::new();\n@@ -511,8 +513,9 @@ impl<'a> FmtVisitor<'a> {\n                                              |arg| arg.ty.span.hi,\n                                              |arg| {\n                                                  // FIXME silly width, indent\n-                                                 arg.ty.rewrite(&self.get_context(), 1000, 0)\n-                                                       .unwrap()\n+                                                 arg.ty\n+                                                    .rewrite(&self.get_context(), 1000, 0)\n+                                                    .unwrap()\n                                              },\n                                              span_after(field.span, \"(\", self.codemap),\n                                              next_span_start);\n@@ -760,11 +763,12 @@ impl<'a> FmtVisitor<'a> {\n         let typ = field.node.ty.rewrite(&self.get_context(), 1000, 0).unwrap();\n \n         let indent = self.block_indent + self.config.tab_spaces;\n-        let mut attr_str = field.node.attrs\n-                                     .rewrite(&self.get_context(),\n-                                              self.config.max_width - indent,\n-                                              indent)\n-                                     .unwrap();\n+        let mut attr_str = field.node\n+                                .attrs\n+                                .rewrite(&self.get_context(),\n+                                         self.config.max_width - indent,\n+                                         indent)\n+                                .unwrap();\n         if !attr_str.is_empty() {\n             attr_str.push('\\n');\n             attr_str.push_str(&make_indent(indent));\n@@ -803,12 +807,9 @@ impl<'a> FmtVisitor<'a> {\n         // Strings for the generics.\n         let context = self.get_context();\n         // FIXME: don't unwrap\n-        let lt_strs = lifetimes.iter().map(|lt| {\n-            lt.rewrite(&context, h_budget, offset).unwrap()\n-        });\n-        let ty_strs = tys.iter().map(|ty_param| {\n-            ty_param.rewrite(&context, h_budget, offset).unwrap()\n-        });\n+        let lt_strs = lifetimes.iter().map(|lt| lt.rewrite(&context, h_budget, offset).unwrap());\n+        let ty_strs = tys.iter()\n+                         .map(|ty_param| ty_param.rewrite(&context, h_budget, offset).unwrap());\n \n         // Extract comments between generics.\n         let lt_spans = lifetimes.iter().map(|l| {"}, {"sha": "3f8900d67134c8464ab8b142aef9a92fa2c7124b", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -10,6 +10,7 @@\n \n #![feature(rustc_private)]\n #![feature(custom_attribute)]\n+#![feature(slice_splits)]\n #![allow(unused_attributes)]\n \n // TODO we're going to allocate a whole bunch of temp Strings, is it worth\n@@ -70,6 +71,7 @@ mod string;\n mod comment;\n mod modules;\n pub mod rustfmt_diff;\n+mod chains;\n \n const MIN_STRING: usize = 10;\n // When we get scoped annotations, we should have rustfmt::skip."}, {"sha": "678c84c199a75bb5416e606747d81b558bdfbc54", "filename": "src/lists.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -272,9 +272,10 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n         self.inner.next().map(|item| {\n             let mut new_lines = false;\n             // Pre-comment\n-            let pre_snippet = self.codemap.span_to_snippet(codemap::mk_sp(self.prev_span_end,\n-                                                                          (self.get_lo)(&item)))\n-                                          .unwrap();\n+            let pre_snippet = self.codemap\n+                                  .span_to_snippet(codemap::mk_sp(self.prev_span_end,\n+                                                                  (self.get_lo)(&item)))\n+                                  .unwrap();\n             let trimmed_pre_snippet = pre_snippet.trim();\n             let pre_comment = if !trimmed_pre_snippet.is_empty() {\n                 Some(trimmed_pre_snippet.to_owned())\n@@ -285,11 +286,12 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n             // Post-comment\n             let next_start = match self.inner.peek() {\n                 Some(ref next_item) => (self.get_lo)(next_item),\n-                None => self.next_span_start\n+                None => self.next_span_start,\n             };\n-            let post_snippet = self.codemap.span_to_snippet(codemap::mk_sp((self.get_hi)(&item),\n-                                                                           next_start))\n-                                           .unwrap();\n+            let post_snippet = self.codemap\n+                                   .span_to_snippet(codemap::mk_sp((self.get_hi)(&item),\n+                                                                   next_start))\n+                                   .unwrap();\n \n             let comment_end = match self.inner.peek() {\n                 Some(..) => {\n@@ -315,12 +317,11 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n                         }\n                         // Potential *single* line comment.\n                         (_, Some(j)) => j + 1,\n-                        _ => post_snippet.len()\n+                        _ => post_snippet.len(),\n                     }\n-                },\n+                }\n                 None => {\n-                    post_snippet.find_uncommented(self.terminator)\n-                                .unwrap_or(post_snippet.len())\n+                    post_snippet.find_uncommented(self.terminator).unwrap_or(post_snippet.len())\n                 }\n             };\n "}, {"sha": "535fc4c8ad90135360fcf159b765a676ff0e0b6c", "filename": "src/missed_spans.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -17,21 +17,20 @@ impl<'a> FmtVisitor<'a> {\n     // TODO these format_missing methods are ugly. Refactor and add unit tests\n     // for the central whitespace stripping loop.\n     pub fn format_missing(&mut self, end: BytePos) {\n-        self.format_missing_inner(end, |this, last_snippet, _| {\n-            this.buffer.push_str(last_snippet)\n-        })\n+        self.format_missing_inner(end, |this, last_snippet, _| this.buffer.push_str(last_snippet))\n     }\n \n     pub fn format_missing_with_indent(&mut self, end: BytePos) {\n-        self.format_missing_inner(end, |this, last_snippet, snippet| {\n-            this.buffer.push_str(last_snippet.trim_right());\n-            if last_snippet == snippet {\n+        self.format_missing_inner(end,\n+                                  |this, last_snippet, snippet| {\n+                                      this.buffer.push_str(last_snippet.trim_right());\n+                                      if last_snippet == snippet {\n                 // No new lines in the snippet.\n-                this.buffer.push_str(\"\\n\");\n-            }\n-            let indent = make_indent(this.block_indent);\n-            this.buffer.push_str(&indent);\n-        })\n+                                          this.buffer.push_str(\"\\n\");\n+                                      }\n+                                      let indent = make_indent(this.block_indent);\n+                                      this.buffer.push_str(&indent);\n+                                  })\n     }\n \n     fn format_missing_inner<F: Fn(&mut FmtVisitor, &str, &str)>(&mut self,\n@@ -60,9 +59,7 @@ impl<'a> FmtVisitor<'a> {\n         let span = codemap::mk_sp(start, end);\n         let snippet = self.snippet(span);\n \n-        self.write_snippet(&snippet,\n-                           true,\n-                           &process_last_snippet);\n+        self.write_snippet(&snippet, true, &process_last_snippet);\n     }\n \n     fn write_snippet<F: Fn(&mut FmtVisitor, &str, &str)>(&mut self,"}, {"sha": "5e5af61faf565e4e1ab0b4208f17ef341dfda5a3", "filename": "src/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -44,8 +44,8 @@ pub fn rewrite_string<'a>(s: &str, fmt: &StringFormat<'a>) -> String {\n     result.push_str(fmt.opener);\n \n     let ender_length = fmt.line_end.len();\n-    let max_chars = fmt.width.checked_sub(fmt.opener.len()).unwrap_or(0)\n-                             .checked_sub(ender_length).unwrap_or(1);\n+    let max_chars = fmt.width.checked_sub(fmt.opener.len() + ender_length).unwrap_or(1);\n+\n     loop {\n         let mut cur_end = cur_start + max_chars;\n "}, {"sha": "e0f3140d4d919b14bdef14efadb56cf01d05f561", "filename": "src/types.rs", "status": "modified", "additions": 81, "deletions": 67, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -130,16 +130,16 @@ impl<'a> Rewrite for SegmentParam<'a> {\n     // FIXME doesn't always use width, offset\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n         Some(match *self {\n-                SegmentParam::LifeTime(ref lt) => {\n-                    pprust::lifetime_to_string(lt)\n-                }\n-                SegmentParam::Type(ref ty) => {\n-                    try_opt!(ty.rewrite(context, width, offset))\n-                }\n-                SegmentParam::Binding(ref binding) => {\n-                    format!(\"{} = {}\", binding.ident, try_opt!(binding.ty.rewrite(context, width, offset)))\n-                }\n-            })\n+            SegmentParam::LifeTime(ref lt) => {\n+                pprust::lifetime_to_string(lt)\n+            }\n+            SegmentParam::Type(ref ty) => {\n+                try_opt!(ty.rewrite(context, width, offset))\n+            }\n+            SegmentParam::Binding(ref binding) => {\n+                format!(\"{} = {}\", binding.ident, try_opt!(binding.ty.rewrite(context, width, offset)))\n+            }\n+        })\n     }\n }\n \n@@ -196,13 +196,12 @@ fn rewrite_segment(segment: &ast::PathSegment,\n         ast::PathParameters::AngleBracketedParameters(ref data) if !data.lifetimes.is_empty() ||\n                                                                    !data.types.is_empty() ||\n                                                                    !data.bindings.is_empty() => {\n-            let param_list = data.lifetimes.iter()\n-                                           .map(SegmentParam::LifeTime)\n-                                           .chain(data.types.iter()\n-                                                      .map(|x| SegmentParam::Type(&*x)))\n-                                           .chain(data.bindings.iter()\n-                                                      .map(|x| SegmentParam::Binding(&*x)))\n-                                           .collect::<Vec<_>>();\n+            let param_list = data.lifetimes\n+                                 .iter()\n+                                 .map(SegmentParam::LifeTime)\n+                                 .chain(data.types.iter().map(|x| SegmentParam::Type(&*x)))\n+                                 .chain(data.bindings.iter().map(|x| SegmentParam::Binding(&*x)))\n+                                 .collect::<Vec<_>>();\n \n             let next_span_lo = param_list.last().unwrap().get_span().hi + BytePos(1);\n             let list_lo = span_after(codemap::mk_sp(*span_lo, span_hi), \"<\", context.codemap);\n@@ -274,57 +273,67 @@ impl Rewrite for ast::WherePredicate {\n         // TODO dead spans?\n         // TODO assumes we'll always fit on one line...\n         Some(match *self {\n-                ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bound_lifetimes,\n-                                                                          ref bounded_ty,\n-                                                                          ref bounds,\n-                                                                          ..}) => {\n-                    if !bound_lifetimes.is_empty() {\n-                        let lifetime_str = bound_lifetimes.iter().map(|lt| {\n-                                           lt.rewrite(context, width, offset).unwrap()\n-                                       }).collect::<Vec<_>>().join(\", \");\n-                        let type_str = pprust::ty_to_string(bounded_ty);\n+            ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate { ref bound_lifetimes,\n+                                                                           ref bounded_ty,\n+                                                                           ref bounds,\n+                                                                           .. }) => {\n+                if !bound_lifetimes.is_empty() {\n+                    let lifetime_str = bound_lifetimes.iter()\n+                                                      .map(|lt| {\n+                                                          lt.rewrite(context, width, offset)\n+                                                            .unwrap()\n+                                                      })\n+                                                      .collect::<Vec<_>>()\n+                                                      .join(\", \");\n+                    let type_str = pprust::ty_to_string(bounded_ty);\n                     // 8 = \"for<> : \".len()\n-                        let used_width = lifetime_str.len() + type_str.len() + 8;\n-                        let bounds_str = bounds.iter().map(|ty_bound| {\n-                                         ty_bound.rewrite(context,\n-                                                          width - used_width,\n-                                                          offset + used_width)\n-                                                 .unwrap()\n-                                     }).collect::<Vec<_>>().join(\" + \");\n-\n-                        format!(\"for<{}> {}: {}\", lifetime_str, type_str, bounds_str)\n-                    } else {\n-                        let type_str = pprust::ty_to_string(bounded_ty);\n+                    let used_width = lifetime_str.len() + type_str.len() + 8;\n+                    let bounds_str = bounds.iter()\n+                                           .map(|ty_bound| {\n+                                               ty_bound.rewrite(context,\n+                                                                width - used_width,\n+                                                                offset + used_width)\n+                                                       .unwrap()\n+                                           })\n+                                           .collect::<Vec<_>>()\n+                                           .join(\" + \");\n+\n+                    format!(\"for<{}> {}: {}\", lifetime_str, type_str, bounds_str)\n+                } else {\n+                    let type_str = pprust::ty_to_string(bounded_ty);\n                     // 2 = \": \".len()\n-                        let used_width = type_str.len() + 2;\n-                        let bounds_str = bounds.iter().map(|ty_bound| {\n-                                         ty_bound.rewrite(context,\n-                                                          width - used_width,\n-                                                          offset + used_width)\n-                                                 .unwrap()\n-                                     }).collect::<Vec<_>>().join(\" + \");\n-\n-                        format!(\"{}: {}\", type_str, bounds_str)\n-                    }\n+                    let used_width = type_str.len() + 2;\n+                    let bounds_str = bounds.iter()\n+                                           .map(|ty_bound| {\n+                                               ty_bound.rewrite(context,\n+                                                                width - used_width,\n+                                                                offset + used_width)\n+                                                       .unwrap()\n+                                           })\n+                                           .collect::<Vec<_>>()\n+                                           .join(\" + \");\n+\n+                    format!(\"{}: {}\", type_str, bounds_str)\n                 }\n-                ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n-                                                                            ref bounds,\n-                                                                            ..}) => {\n-                    format!(\"{}: {}\",\n+            }\n+            ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate { ref lifetime,\n+                                                                             ref bounds,\n+                                                                             .. }) => {\n+                format!(\"{}: {}\",\n                         pprust::lifetime_to_string(lifetime),\n                         bounds.iter().map(pprust::lifetime_to_string)\n                               .collect::<Vec<_>>().join(\" + \"))\n-                }\n-                ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{ref path, ref ty, ..}) => {\n-                    let ty_str = pprust::ty_to_string(ty);\n+            }\n+            ast::WherePredicate::EqPredicate(ast::WhereEqPredicate { ref path, ref ty, .. }) => {\n+                let ty_str = pprust::ty_to_string(ty);\n                 // 3 = \" = \".len()\n-                    let used_width = 3 + ty_str.len();\n-                    let path_str = try_opt!(path.rewrite(context,\n+                let used_width = 3 + ty_str.len();\n+                let path_str = try_opt!(path.rewrite(context,\n                                                      width - used_width,\n                                                      offset + used_width));\n-                    format!(\"{} = {}\", path_str, ty_str)\n-                }\n-            })\n+                format!(\"{} = {}\", path_str, ty_str)\n+            }\n+        })\n     }\n }\n \n@@ -359,8 +368,9 @@ impl Rewrite for ast::TyParamBound {\n \n impl Rewrite for ast::TyParamBounds {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n-        let strs: Vec<_> =\n-            self.iter().map(|b| b.rewrite(context, width, offset).unwrap()).collect();\n+        let strs: Vec<_> = self.iter()\n+                               .map(|b| b.rewrite(context, width, offset).unwrap())\n+                               .collect();\n         Some(strs.join(\" + \"))\n     }\n }\n@@ -373,9 +383,11 @@ impl Rewrite for ast::TyParam {\n         if !self.bounds.is_empty() {\n             result.push_str(\": \");\n \n-            let bounds = self.bounds.iter().map(|ty_bound| {\n-                ty_bound.rewrite(context, width, offset).unwrap()\n-            }).collect::<Vec<_>>().join(\" + \");\n+            let bounds = self.bounds\n+                             .iter()\n+                             .map(|ty_bound| ty_bound.rewrite(context, width, offset).unwrap())\n+                             .collect::<Vec<_>>()\n+                             .join(\" + \");\n \n             result.push_str(&bounds);\n         }\n@@ -392,9 +404,11 @@ impl Rewrite for ast::TyParam {\n impl Rewrite for ast::PolyTraitRef {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n         if !self.bound_lifetimes.is_empty() {\n-            let lifetime_str = self.bound_lifetimes.iter().map(|lt| {\n-                lt.rewrite(context, width, offset).unwrap()\n-            }).collect::<Vec<_>>().join(\", \");\n+            let lifetime_str = self.bound_lifetimes\n+                                   .iter()\n+                                   .map(|lt| lt.rewrite(context, width, offset).unwrap())\n+                                   .collect::<Vec<_>>()\n+                                   .join(\", \");\n             // 6 is \"for<> \".len()\n             let extra_offset = lifetime_str.len() + 6;\n             let max_path_width = try_opt!(width.checked_sub(extra_offset));"}, {"sha": "973f0fa56ab4d50ba8264884384cd429a41af940", "filename": "src/utils.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -14,6 +14,7 @@ use syntax::ast::{self, Visibility, Attribute, MetaItem, MetaItem_};\n use syntax::codemap::{CodeMap, Span, BytePos};\n \n use comment::FindUncommented;\n+use rewrite::{Rewrite, RewriteContext};\n \n use SKIP_ANNOTATION;\n \n@@ -93,10 +94,16 @@ pub fn contains_skip(attrs: &[Attribute]) -> bool {\n // Find the end of a TyParam\n #[inline]\n pub fn end_typaram(typaram: &ast::TyParam) -> BytePos {\n-    typaram.bounds.last().map(|bound| match *bound {\n-        ast::RegionTyParamBound(ref lt) => lt.span,\n-        ast::TraitTyParamBound(ref prt, _) => prt.span,\n-    }).unwrap_or(typaram.span).hi\n+    typaram.bounds\n+           .last()\n+           .map(|bound| {\n+               match *bound {\n+                   ast::RegionTyParamBound(ref lt) => lt.span,\n+                   ast::TraitTyParamBound(ref prt, _) => prt.span,\n+               }\n+           })\n+           .unwrap_or(typaram.span)\n+           .hi\n }\n \n #[inline]\n@@ -202,6 +209,12 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, width: usize, offset: usi\n     Some(s)\n }\n \n+impl Rewrite for String {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+        wrap_str(self, context.config.max_width, width, offset).map(ToOwned::to_owned)\n+    }\n+}\n+\n // Binary search in integer range. Returns the first Ok value returned by the\n // callback.\n // The callback takes an integer and returns either an Ok, or an Err indicating\n@@ -231,13 +244,13 @@ pub fn binary_search<C, T>(mut lo: usize, mut hi: usize, callback: C) -> Option<\n #[test]\n fn bin_search_test() {\n     let closure = |i| {\n-                      match i {\n-                          4 => Ok(()),\n-                          j if j > 4 => Err(Ordering::Less),\n-                          j if j < 4 => Err(Ordering::Greater),\n-                          _ => unreachable!(),\n-                      }\n-                  };\n+        match i {\n+            4 => Ok(()),\n+            j if j > 4 => Err(Ordering::Less),\n+            j if j < 4 => Err(Ordering::Greater),\n+            _ => unreachable!(),\n+        }\n+    };\n \n     assert_eq!(Some(()), binary_search(1, 10, &closure));\n     assert_eq!(None, binary_search(1, 3, &closure));"}, {"sha": "54ada1b7455b8367a3c99238ae0284c798d75c60", "filename": "src/visitor.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -202,19 +202,11 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n             }\n             ast::Item_::ItemStruct(ref def, ref generics) => {\n                 self.format_missing_with_indent(item.span.lo);\n-                self.visit_struct(item.ident,\n-                                  item.vis,\n-                                  def,\n-                                  generics,\n-                                  item.span);\n+                self.visit_struct(item.ident, item.vis, def, generics, item.span);\n             }\n             ast::Item_::ItemEnum(ref def, ref generics) => {\n                 self.format_missing_with_indent(item.span.lo);\n-                self.visit_enum(item.ident,\n-                                item.vis,\n-                                def,\n-                                generics,\n-                                item.span);\n+                self.visit_enum(item.ident, item.vis, def, generics, item.span);\n                 self.last_pos = item.span.hi;\n             }\n             ast::Item_::ItemMod(ref module) => {\n@@ -236,10 +228,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n             self.format_missing_with_indent(ti.span.lo);\n \n             let indent = self.block_indent;\n-            let new_fn = self.rewrite_required_fn(indent,\n-                                                  ti.ident,\n-                                                  sig,\n-                                                  ti.span);\n+            let new_fn = self.rewrite_required_fn(indent, ti.ident, sig, ti.span);\n \n \n             if let Some(fn_str) = new_fn {"}, {"sha": "754cde57cd9c91e41ccec0f334b7b6a884505c6c", "filename": "tests/config/small_tabs.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Fconfig%2Fsmall_tabs.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Fconfig%2Fsmall_tabs.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconfig%2Fsmall_tabs.toml?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -21,7 +21,7 @@ enum_trailing_comma = true\n report_todo = \"Always\"\n report_fixme = \"Never\"\n reorder_imports = false\n-expr_indent_style = \"Tabbed\"\n-closure_indent_style = \"Visual\"\n single_line_if_else = false\n format_strings = true\n+chains_overflow_last = true\n+take_source_hints = true"}, {"sha": "b94ca21b2588a069a4ff25319938ec32095c2d09", "filename": "tests/source/chains-no-overflow.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Fsource%2Fchains-no-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Fsource%2Fchains-no-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fchains-no-overflow.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -0,0 +1,37 @@\n+// rustfmt-chains_overflow_last: false\n+// Test chain formatting without overflowing the last item.\n+\n+fn main() {\n+    bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc\n+                       .ddddddddddddddddddddddddddd();\n+\n+    bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc.ddddddddddddddddddddddddddd.eeeeeeee();\n+\n+    x()\n+        .y(|| match cond() { true => (), false => () });\n+\n+    loong_func()\n+        .quux(move || if true {\n+            1\n+        } else {\n+            2\n+        });\n+\n+    fffffffffffffffffffffffffffffffffff(a,\n+                                        {\n+                                            SCRIPT_TASK_ROOT\n+                                            .with(|root| {\n+                                                        *root.borrow_mut()  =   Some(&script_task);\n+                                                    });\n+                                        });                                        \n+\n+    let suuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuum = xxxxxxx\n+        .map(|x| x + 5)\n+        .map(|x| x / 2)\n+        .fold(0, |acc, x| acc + x);\n+\n+    aaaaaaaaaaaaaaaa.map(|x| {\n+                         x += 1;\n+                         x\n+                     }).filter(some_mod::some_filter)\n+}"}, {"sha": "f53afaa0c286f30716404348dba24ea7999f2304", "filename": "tests/source/chains.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Fsource%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Fsource%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fchains.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -0,0 +1,43 @@\n+// Test chain formatting.\n+\n+fn main() {\n+    // Don't put chains on a single line if it wasn't so in source.\n+    let a = b .c\n+    .d.1\n+                .foo(|x| x + 1);\n+\n+    bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc\n+                       .ddddddddddddddddddddddddddd();\n+\n+    bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc.ddddddddddddddddddddddddddd.eeeeeeee();\n+\n+    // Test case where first chain element isn't a path, but is shorter than\n+    // the size of a tab.\n+    x()\n+        .y(|| match cond() { true => (), false => () });\n+\n+    loong_func()\n+        .quux(move || if true {\n+            1\n+        } else {\n+            2\n+        });\n+\n+    fffffffffffffffffffffffffffffffffff(a,\n+                                        {\n+                                            SCRIPT_TASK_ROOT\n+                                            .with(|root| {\n+                                                *root.borrow_mut()  =   Some(&script_task);\n+                                            });\n+                                        });                                        \n+\n+    let suuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuum = xxxxxxx\n+        .map(|x| x + 5)\n+        .map(|x| x / 2)\n+        .fold(0, |acc, x| acc + x);\n+\n+    aaaaaaaaaaaaaaaa.map(|x| {\n+                         x += 1;\n+                         x\n+                     }).filter(some_mod::some_filter)\n+}"}, {"sha": "7329a742bac1277a8f602c1b520eea0cda03f2a4", "filename": "tests/source/expr-no-hints.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Fsource%2Fexpr-no-hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Fsource%2Fexpr-no-hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fexpr-no-hints.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -0,0 +1,8 @@\n+// rustfmt-take_source_hints: false\n+// We know best!\n+\n+fn main() {\n+    a.b\n+     .c\n+     .d();\n+}"}, {"sha": "3d7c1b92be8030a4be6f0293dd9ed4aa033eacd3", "filename": "tests/source/expr-visual-indent.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1af301c33d1886a4e037f6ddb1ce495aa8d0573b/tests%2Fsource%2Fexpr-visual-indent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af301c33d1886a4e037f6ddb1ce495aa8d0573b/tests%2Fsource%2Fexpr-visual-indent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fexpr-visual-indent.rs?ref=1af301c33d1886a4e037f6ddb1ce495aa8d0573b", "patch": "@@ -1,9 +0,0 @@\n-// rustfmt-expr_indent_style: Visual\n-\n-// Visual level block indentation.\n-\n-fn matcher() {\n-    Some(while true {\n-        test();\n-    })\n-}\n\\ No newline at end of file"}, {"sha": "35d8ec072c2a8765fc2ffb37379837f45413b75d", "filename": "tests/source/string-lit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Fsource%2Fstring-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Fsource%2Fstring-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fstring-lit.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -30,5 +30,5 @@ formatting\"#;\n     let unicode3 = \"\u4e2d\u534eVi\u1ec7t Nam\";\n     let unicode4 = \"\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\";\n \n-    \"stuff\"\n+    \"stuffin'\"\n }"}, {"sha": "9086697978ed393db14e0ed34c6fe562a2e7903d", "filename": "tests/system.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -121,9 +121,8 @@ pub fn idempotent_check(filename: String) -> Result<(), HashMap<String, Vec<Mism\n     // multithreaded rustfmt\n     thread::catch_panic(move || {\n         run(args, WriteMode::Return(HANDLE_RESULT), config);\n-    }).map_err(|any|\n-        *any.downcast().ok().expect(\"Downcast failed.\")\n-    )\n+    })\n+        .map_err(|any| *any.downcast().ok().expect(\"Downcast failed.\"))\n }\n \n \n@@ -138,7 +137,9 @@ fn get_config(config_file: Option<&str>) -> Box<Config> {\n         }\n     };\n \n-    let mut def_config_file = fs::File::open(config_file_name).ok().expect(\"Couldn't open config.\");\n+    let mut def_config_file = fs::File::open(config_file_name)\n+                                  .ok()\n+                                  .expect(\"Couldn't open config.\");\n     let mut def_config = String::new();\n     def_config_file.read_to_string(&mut def_config).ok().expect(\"Couldn't read config.\");\n \n@@ -148,14 +149,17 @@ fn get_config(config_file: Option<&str>) -> Box<Config> {\n // Reads significant comments of the form: // rustfmt-key: value\n // into a hash map.\n fn read_significant_comments(file_name: &str) -> HashMap<String, String> {\n-    let file = fs::File::open(file_name).ok().expect(&format!(\"Couldn't read file {}.\", file_name));\n+    let file = fs::File::open(file_name)\n+                   .ok()\n+                   .expect(&format!(\"Couldn't read file {}.\", file_name));\n     let reader = BufReader::new(file);\n     let pattern = r\"^\\s*//\\s*rustfmt-([^:]+):\\s*(\\S+)\";\n     let regex = regex::Regex::new(&pattern).ok().expect(\"Failed creating pattern 1.\");\n \n     // Matches lines containing significant comments or whitespace.\n     let line_regex = regex::Regex::new(r\"(^\\s*$)|(^\\s*//\\s*rustfmt-[^:]+:\\s*\\S+)\")\n-        .ok().expect(\"Failed creating pattern 2.\");\n+                         .ok()\n+                         .expect(\"Failed creating pattern 2.\");\n \n     reader.lines()\n           .map(|line| line.ok().expect(\"Failed getting line.\"))"}, {"sha": "9b1f244637dd48558146b4a36202e9758e78aa6a", "filename": "tests/target/chains-no-overflow.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Ftarget%2Fchains-no-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Ftarget%2Fchains-no-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-no-overflow.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -0,0 +1,45 @@\n+// rustfmt-chains_overflow_last: false\n+// Test chain formatting without overflowing the last item.\n+\n+fn main() {\n+    bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc.ddddddddddddddddddddddddddd();\n+\n+    bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc\n+                       .ddddddddddddddddddddddddddd\n+                       .eeeeeeee();\n+\n+    x().y(|| {\n+           match cond() {\n+               true => (),\n+               false => (),\n+           }\n+       });\n+\n+    loong_func()\n+        .quux(move || {\n+            if true {\n+                1\n+            } else {\n+                2\n+            }\n+        });\n+\n+    fffffffffffffffffffffffffffffffffff(a,\n+                                        {\n+                                            SCRIPT_TASK_ROOT.with(|root| {\n+                                                                *root.borrow_mut() =\n+                                                                    Some(&script_task);\n+                                                            });\n+                                        });\n+\n+    let suuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuum = xxxxxxx.map(|x| x + 5)\n+                                                                          .map(|x| x / 2)\n+                                                                          .fold(0,\n+                                                                                |acc, x| acc + x);\n+\n+    aaaaaaaaaaaaaaaa.map(|x| {\n+                        x += 1;\n+                        x\n+                    })\n+                    .filter(some_mod::some_filter)\n+}"}, {"sha": "d795fa2f961a8928645814938651e56ed7c680cb", "filename": "tests/target/chains-no-overlow-2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Ftarget%2Fchains-no-overlow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Ftarget%2Fchains-no-overlow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-no-overlow-2.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -0,0 +1,16 @@\n+// rustfmt-chains_overflow_last: false\n+\n+fn main() {\n+    reader.lines()\n+          .map(|line| line.ok().expect(\"Failed getting line.\"))\n+          .take_while(|line| line_regex.is_match(&line))\n+          .filter_map(|line| {\n+              regex.captures_iter(&line)\n+                   .next()\n+                   .map(|capture| {\n+                       (capture.at(1).expect(\"Couldn\\'t unwrap capture.\").to_owned(),\n+                        capture.at(2).expect(\"Couldn\\'t unwrap capture.\").to_owned())\n+                   })\n+          })\n+          .collect();\n+}"}, {"sha": "590f0a5b1569d9237fac7cb6a2bc3ace0b5a8383", "filename": "tests/target/chains.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Ftarget%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Ftarget%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -0,0 +1,50 @@\n+// Test chain formatting.\n+\n+fn main() {\n+    // Don't put chains on a single line if it wasn't so in source.\n+    let a = b.c\n+             .d\n+             .1\n+             .foo(|x| x + 1);\n+\n+    bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc.ddddddddddddddddddddddddddd();\n+\n+    bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc\n+                       .ddddddddddddddddddddddddddd\n+                       .eeeeeeee();\n+\n+    // Test case where first chain element isn't a path, but is shorter than\n+    // the size of a tab.\n+    x().y(|| {\n+        match cond() {\n+            true => (),\n+            false => (),\n+        }\n+    });\n+\n+    loong_func().quux(move || {\n+        if true {\n+            1\n+        } else {\n+            2\n+        }\n+    });\n+\n+    fffffffffffffffffffffffffffffffffff(a,\n+                                        {\n+                                            SCRIPT_TASK_ROOT.with(|root| {\n+                                                *root.borrow_mut() = Some(&script_task);\n+                                            });\n+                                        });\n+\n+    let suuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuum = xxxxxxx.map(|x| x + 5)\n+                                                                          .map(|x| x / 2)\n+                                                                          .fold(0,\n+                                                                                |acc, x| acc + x);\n+\n+    aaaaaaaaaaaaaaaa.map(|x| {\n+                        x += 1;\n+                        x\n+                    })\n+                    .filter(some_mod::some_filter)\n+}"}, {"sha": "b42296487bede1b00820c7b7abdd5b5fc0de7192", "filename": "tests/target/closure.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Ftarget%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Ftarget%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fclosure.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -9,52 +9,51 @@ fn main() {\n                      b: WithType, // argument\n                      // ignored\n                      _| {\n-                        (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n-                         bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb)\n-                    };\n+        (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb)\n+    };\n \n     let block_body = move |xxxxxxxxxxxxxxxxxxxxxxxxxxxxx,\n                            ref yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy| {\n-                              xxxxxxxxxxxxxxxxxxxxxxxxxxxxx + yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\n-                          };\n+        xxxxxxxxxxxxxxxxxxxxxxxxxxxxx + yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\n+    };\n \n     let loooooooooooooong_name = |field| {\n              // TODO(#27): format comments.\n-                                     if field.node.attrs.len() > 0 {\n-                                         field.node.attrs[0].span.lo\n-                                     } else {\n-                                         field.span.lo\n-                                     }\n-                                 };\n+        if field.node.attrs.len() > 0 {\n+            field.node.attrs[0].span.lo\n+        } else {\n+            field.span.lo\n+        }\n+    };\n \n     let block_me = |field| {\n-                       if true_story() {\n-                           1\n-                       } else {\n-                           2\n-                       }\n-                   };\n+        if true_story() {\n+            1\n+        } else {\n+            2\n+        }\n+    };\n \n     let unblock_me = |trivial| closure();\n \n     let empty = |arg| {};\n \n     let simple = |arg| { /* TODO(#27): comment formatting */\n-                     foo(arg)\n-                 };\n+        foo(arg)\n+    };\n \n     let test = || {\n-                   do_something();\n-                   do_something_else();\n-               };\n+        do_something();\n+        do_something_else();\n+    };\n \n     let arg_test = |big_argument_name, test123| {\n-                       looooooooooooooooooong_function_naaaaaaaaaaaaaaaaame()\n-                   };\n+        looooooooooooooooooong_function_naaaaaaaaaaaaaaaaame()\n+    };\n \n     let arg_test = |big_argument_name, test123| {\n-                       looooooooooooooooooong_function_naaaaaaaaaaaaaaaaame()\n-                   };\n+        looooooooooooooooooong_function_naaaaaaaaaaaaaaaaame()\n+    };\n \n     let simple_closure = move || -> () {};\n \n@@ -63,8 +62,8 @@ fn main() {\n     let closure_with_return_type = |aaaaaaaaaaaaaaaaaaaaaaarg1,\n                                     aaaaaaaaaaaaaaaaaaaaaaarg2|\n                                     -> Strong {\n-                                       \"sup\".to_owned()\n-                                   };\n+        \"sup\".to_owned()\n+    };\n \n     |arg1, arg2, _, _, arg3, arg4| {\n         let temp = arg4 + arg3;"}, {"sha": "62dd64c28a610b6087aa58b0aca3986a4a8a6819", "filename": "tests/target/expr-no-hints.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Ftarget%2Fexpr-no-hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Ftarget%2Fexpr-no-hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr-no-hints.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -0,0 +1,6 @@\n+// rustfmt-take_source_hints: false\n+// We know best!\n+\n+fn main() {\n+    a.b.c.d();\n+}"}, {"sha": "d74b5aae93c13183c59b75f0904f1c8fe1f7dd4e", "filename": "tests/target/expr-visual-indent.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1af301c33d1886a4e037f6ddb1ce495aa8d0573b/tests%2Ftarget%2Fexpr-visual-indent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1af301c33d1886a4e037f6ddb1ce495aa8d0573b/tests%2Ftarget%2Fexpr-visual-indent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr-visual-indent.rs?ref=1af301c33d1886a4e037f6ddb1ce495aa8d0573b", "patch": "@@ -1,9 +0,0 @@\n-// rustfmt-expr_indent_style: Visual\n-\n-// Visual level block indentation.\n-\n-fn matcher() {\n-    Some(while true {\n-             test();\n-         })\n-}"}, {"sha": "d24d463c2c2500f11dd0b1a4fd097230d7d49bd1", "filename": "tests/target/expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Ftarget%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Ftarget%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -89,13 +89,13 @@ fn bar() {\n     }\n \n     syntactically_correct(loop {\n-            sup('?');\n-        },\n+                              sup('?');\n+                          },\n                           if cond {\n-            0\n-        } else {\n-            1\n-        });\n+                              0\n+                          } else {\n+                              1\n+                          });\n \n     let third = ..10;\n     let infi_range = ..;"}, {"sha": "5cfbb5a70728160897064d281ead78dac1fc7c18", "filename": "tests/target/match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -57,7 +57,7 @@ fn foo() {\n // Test that a match on an overflow line is laid out properly.\n fn main() {\n     let sub_span =\n-        match self.span.sub_span_after_keywooooooooooooooooooooord(use_item.span, keywords::As) {\n+        match xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx {\n             Some(sub_span) => Some(sub_span),\n             None => sub_span,\n         };"}, {"sha": "36f8f6a48f9307518168ac162c1afe8d85f50037", "filename": "tests/target/string-lit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Ftarget%2Fstring-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b7b3c8725f2adbdcd0c05f81f06b2b938d99552/tests%2Ftarget%2Fstring-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstring-lit.rs?ref=0b7b3c8725f2adbdcd0c05f81f06b2b938d99552", "patch": "@@ -36,5 +36,5 @@ formatting\"#;\n     let unicode4 = \"\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\\\n                     \u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\u2603\";\n \n-    \"stuff\"\n+    \"stuffin'\"\n }"}]}