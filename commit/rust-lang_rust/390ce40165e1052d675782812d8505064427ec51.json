{"sha": "390ce40165e1052d675782812d8505064427ec51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5MGNlNDAxNjVlMTA1MmQ2NzU3ODI4MTJkODUwNTA2NDQyN2VjNTE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-11T00:58:22Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-11T01:07:40Z"}, "message": "Begin alias-ifying trans.", "tree": {"sha": "221083ecb38db4460fcaed9d4f96ee747c7e5fd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/221083ecb38db4460fcaed9d4f96ee747c7e5fd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/390ce40165e1052d675782812d8505064427ec51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/390ce40165e1052d675782812d8505064427ec51", "html_url": "https://github.com/rust-lang/rust/commit/390ce40165e1052d675782812d8505064427ec51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/390ce40165e1052d675782812d8505064427ec51/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf3e737eeeabb26ca555fd8ed85f4df7317e992a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf3e737eeeabb26ca555fd8ed85f4df7317e992a", "html_url": "https://github.com/rust-lang/rust/commit/cf3e737eeeabb26ca555fd8ed85f4df7317e992a"}], "stats": {"total": 164, "additions": 82, "deletions": 82}, "files": [{"sha": "808378eacd7455de009243a5232020e66a8b7786", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 82, "deletions": 82, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/390ce40165e1052d675782812d8505064427ec51/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390ce40165e1052d675782812d8505064427ec51/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=390ce40165e1052d675782812d8505064427ec51", "patch": "@@ -3117,7 +3117,7 @@ fn node_type(@crate_ctxt cx, &ast.ann a) -> TypeRef {\n     ret type_of(cx, node_ann_type(cx, a));\n }\n \n-fn trans_unary(@block_ctxt cx, ast.unop op,\n+fn trans_unary(&@block_ctxt cx, ast.unop op,\n                @ast.expr e, &ast.ann a) -> result {\n \n     auto sub = trans_expr(cx, e);\n@@ -3181,7 +3181,7 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n     fail;\n }\n \n-fn trans_compare(@block_ctxt cx0, ast.binop op, ty.t t0,\n+fn trans_compare(&@block_ctxt cx0, ast.binop op, ty.t t0,\n                  ValueRef lhs0, ValueRef rhs0) -> result {\n     // Autoderef both sides.\n     auto cx = cx0;\n@@ -3222,7 +3222,7 @@ fn trans_compare(@block_ctxt cx0, ast.binop op, ty.t t0,\n     }\n }\n \n-fn trans_vec_append(@block_ctxt cx, ty.t t,\n+fn trans_vec_append(&@block_ctxt cx, ty.t t,\n                     ValueRef lhs, ValueRef rhs) -> result {\n \n     auto elt_ty = ty.sequence_element_type(cx.fcx.lcx.ccx.tcx, t);\n@@ -3251,7 +3251,7 @@ fn trans_vec_append(@block_ctxt cx, ty.t t,\n                                         dst, src, skip_null)));\n }\n \n-fn trans_vec_add(@block_ctxt cx, ty.t t,\n+fn trans_vec_add(&@block_ctxt cx, ty.t t,\n                  ValueRef lhs, ValueRef rhs) -> result {\n     auto r = alloc_ty(cx, t);\n     auto tmp = r.val;\n@@ -3264,7 +3264,7 @@ fn trans_vec_add(@block_ctxt cx, ty.t t,\n }\n \n \n-fn trans_eager_binop(@block_ctxt cx, ast.binop op, ty.t intype,\n+fn trans_eager_binop(&@block_ctxt cx, ast.binop op, ty.t intype,\n                      ValueRef lhs, ValueRef rhs) -> result {\n \n     auto is_float = false;\n@@ -3341,7 +3341,7 @@ fn trans_eager_binop(@block_ctxt cx, ast.binop op, ty.t intype,\n     fail;\n }\n \n-fn autoderef(@block_ctxt cx, ValueRef v, ty.t t) -> result {\n+fn autoderef(&@block_ctxt cx, ValueRef v, ty.t t) -> result {\n     let ValueRef v1 = v;\n     let ty.t t1 = t;\n \n@@ -3388,7 +3388,7 @@ fn autoderefed_ty(@crate_ctxt ccx, ty.t t) -> ty.t {\n     }\n }\n \n-fn trans_binary(@block_ctxt cx, ast.binop op,\n+fn trans_binary(&@block_ctxt cx, ast.binop op,\n                 @ast.expr a, @ast.expr b) -> result {\n \n     // First couple cases are lazy:\n@@ -3453,7 +3453,7 @@ fn trans_binary(@block_ctxt cx, ast.binop op,\n     fail;\n }\n \n-fn join_results(@block_ctxt parent_cx,\n+fn join_results(&@block_ctxt parent_cx,\n                 TypeRef t,\n                 vec[result] ins)\n     -> result {\n@@ -3491,7 +3491,7 @@ fn join_results(@block_ctxt parent_cx,\n     ret res(join_cx, phi);\n }\n \n-fn trans_if(@block_ctxt cx, @ast.expr cond,\n+fn trans_if(&@block_ctxt cx, @ast.expr cond,\n             &ast.block thn, &Option.t[@ast.expr] els) -> result {\n \n     auto cond_res = trans_expr(cx, cond);\n@@ -3545,7 +3545,7 @@ fn trans_if(@block_ctxt cx, @ast.expr cond,\n                      vec(then_res, else_res));\n }\n \n-fn trans_for(@block_ctxt cx,\n+fn trans_for(&@block_ctxt cx,\n              @ast.decl decl,\n              @ast.expr seq,\n              &ast.block body) -> result {\n@@ -3591,7 +3591,7 @@ fn trans_for(@block_ctxt cx,\n \n // Searches through a block for all references to locals or upvars in this\n // frame and returns the list of definition IDs thus found.\n-fn collect_upvars(@block_ctxt cx, &ast.block bloc, &ast.def_id initial_decl)\n+fn collect_upvars(&@block_ctxt cx, &ast.block bloc, &ast.def_id initial_decl)\n         -> vec[ast.def_id] {\n     type env = @rec(\n         mutable vec[ast.def_id] refs,\n@@ -3648,7 +3648,7 @@ fn collect_upvars(@block_ctxt cx, &ast.block bloc, &ast.def_id initial_decl)\n     ret result;\n }\n \n-fn trans_for_each(@block_ctxt cx,\n+fn trans_for_each(&@block_ctxt cx,\n                   @ast.decl decl,\n                   @ast.expr seq,\n                   &ast.block body) -> result {\n@@ -3855,7 +3855,7 @@ fn trans_for_each(@block_ctxt cx,\n }\n \n \n-fn trans_while(@block_ctxt cx, @ast.expr cond,\n+fn trans_while(&@block_ctxt cx, @ast.expr cond,\n                &ast.block body) -> result {\n \n     auto cond_cx = new_scope_block_ctxt(cx, \"while cond\");\n@@ -3875,7 +3875,7 @@ fn trans_while(@block_ctxt cx, @ast.expr cond,\n     ret res(next_cx, C_nil());\n }\n \n-fn trans_do_while(@block_ctxt cx, &ast.block body,\n+fn trans_do_while(&@block_ctxt cx, &ast.block body,\n                   @ast.expr cond) -> result {\n \n     auto next_cx = new_sub_block_ctxt(cx, \"next\");\n@@ -3894,8 +3894,8 @@ fn trans_do_while(@block_ctxt cx, &ast.block body,\n \n // Pattern matching translation\n \n-fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n-                   @block_ctxt next_cx) -> result {\n+fn trans_pat_match(&@block_ctxt cx, @ast.pat pat, ValueRef llval,\n+                   &@block_ctxt next_cx) -> result {\n     alt (pat.node) {\n         case (ast.pat_wild(_)) { ret res(cx, llval); }\n         case (ast.pat_bind(_, _, _)) { ret res(cx, llval); }\n@@ -3968,7 +3968,7 @@ fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n     fail;\n }\n \n-fn trans_pat_binding(@block_ctxt cx, @ast.pat pat,\n+fn trans_pat_binding(&@block_ctxt cx, @ast.pat pat,\n                      ValueRef llval, bool bind_alias)\n     -> result {\n     alt (pat.node) {\n@@ -4019,7 +4019,7 @@ fn trans_pat_binding(@block_ctxt cx, @ast.pat pat,\n     }\n }\n \n-fn trans_alt(@block_ctxt cx, @ast.expr expr,\n+fn trans_alt(&@block_ctxt cx, @ast.expr expr,\n              vec[ast.arm] arms, ast.ann ann) -> result {\n     auto expr_res = trans_expr(cx, expr);\n \n@@ -4070,23 +4070,23 @@ type lval_result = rec(result res,\n                        Option.t[ValueRef] llobj,\n                        Option.t[ty.t] method_ty);\n \n-fn lval_mem(@block_ctxt cx, ValueRef val) -> lval_result {\n+fn lval_mem(&@block_ctxt cx, ValueRef val) -> lval_result {\n     ret rec(res=res(cx, val),\n             is_mem=true,\n             generic=none[generic_info],\n             llobj=none[ValueRef],\n             method_ty=none[ty.t]);\n }\n \n-fn lval_val(@block_ctxt cx, ValueRef val) -> lval_result {\n+fn lval_val(&@block_ctxt cx, ValueRef val) -> lval_result {\n     ret rec(res=res(cx, val),\n             is_mem=false,\n             generic=none[generic_info],\n             llobj=none[ValueRef],\n             method_ty=none[ty.t]);\n }\n \n-fn trans_external_path(@block_ctxt cx, ast.def_id did,\n+fn trans_external_path(&@block_ctxt cx, ast.def_id did,\n                        ty.ty_param_count_and_ty tpt) -> lval_result {\n     auto lcx = cx.fcx.lcx;\n     auto name = creader.get_symbol(lcx.ccx.sess, did);\n@@ -4095,7 +4095,7 @@ fn trans_external_path(@block_ctxt cx, ast.def_id did,\n     ret lval_val(cx, v);\n }\n \n-fn lval_generic_fn(@block_ctxt cx,\n+fn lval_generic_fn(&@block_ctxt cx,\n                    ty.ty_param_count_and_ty tpt,\n                    ast.def_id fn_id,\n                    &ast.ann ann)\n@@ -4160,7 +4160,7 @@ fn lookup_discriminant(@local_ctxt lcx, ast.def_id tid, ast.def_id vid)\n     }\n }\n \n-fn trans_path(@block_ctxt cx, &ast.path p, &Option.t[ast.def] dopt,\n+fn trans_path(&@block_ctxt cx, &ast.path p, &Option.t[ast.def] dopt,\n               &ast.ann ann) -> lval_result {\n     alt (dopt) {\n         case (some[ast.def](?def)) {\n@@ -4265,7 +4265,7 @@ fn trans_path(@block_ctxt cx, &ast.path p, &Option.t[ast.def] dopt,\n     fail;\n }\n \n-fn trans_field(@block_ctxt cx, &ast.span sp, ValueRef v, ty.t t0,\n+fn trans_field(&@block_ctxt cx, &ast.span sp, ValueRef v, ty.t t0,\n                &ast.ident field, &ast.ann ann) -> lval_result {\n \n     auto r = autoderef(cx, v, t0);\n@@ -4306,7 +4306,7 @@ fn trans_field(@block_ctxt cx, &ast.span sp, ValueRef v, ty.t t0,\n     fail;\n }\n \n-fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n+fn trans_index(&@block_ctxt cx, &ast.span sp, @ast.expr base,\n                @ast.expr idx, &ast.ann ann) -> lval_result {\n \n     auto lv = trans_expr(cx, base);\n@@ -4369,7 +4369,7 @@ fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n // represented as an alloca or heap, hence needs a 'load' to be used as an\n // immediate).\n \n-fn trans_lval(@block_ctxt cx, @ast.expr e) -> lval_result {\n+fn trans_lval(&@block_ctxt cx, @ast.expr e) -> lval_result {\n     alt (e.node) {\n         case (ast.expr_path(?p, ?dopt, ?ann)) {\n             ret trans_path(cx, p, dopt, ann);\n@@ -4413,7 +4413,7 @@ fn trans_lval(@block_ctxt cx, @ast.expr e) -> lval_result {\n     fail;\n }\n \n-fn int_cast(@block_ctxt bcx, TypeRef lldsttype, TypeRef llsrctype,\n+fn int_cast(&@block_ctxt bcx, TypeRef lldsttype, TypeRef llsrctype,\n             ValueRef llsrc, bool signed) -> ValueRef {\n     if (llvm.LLVMGetIntTypeWidth(lldsttype) >\n             llvm.LLVMGetIntTypeWidth(llsrctype)) {\n@@ -4429,7 +4429,7 @@ fn int_cast(@block_ctxt bcx, TypeRef lldsttype, TypeRef llsrctype,\n     ret bcx.build.TruncOrBitCast(llsrc, lldsttype);\n }\n \n-fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n+fn trans_cast(&@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n     auto e_res = trans_expr(cx, e);\n     auto llsrctype = val_ty(e_res.val);\n     auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n@@ -4600,7 +4600,7 @@ fn trans_bind_thunk(@local_ctxt cx,\n     ret llthunk;\n }\n \n-fn trans_bind(@block_ctxt cx, @ast.expr f,\n+fn trans_bind(&@block_ctxt cx, @ast.expr f,\n               vec[Option.t[@ast.expr]] args,\n               &ast.ann ann) -> result {\n     auto f_res = trans_lval(cx, f);\n@@ -4788,7 +4788,7 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n     }\n }\n \n-fn trans_arg_expr(@block_ctxt cx,\n+fn trans_arg_expr(&@block_ctxt cx,\n                   ty.arg arg,\n                   TypeRef lldestty0,\n                   @ast.expr e) -> result {\n@@ -4861,7 +4861,7 @@ fn trans_arg_expr(@block_ctxt cx,\n //  - new_fn_ctxt\n //  - trans_args\n \n-fn trans_args(@block_ctxt cx,\n+fn trans_args(&@block_ctxt cx,\n               ValueRef llenv,\n               Option.t[ValueRef] llobj,\n               Option.t[generic_info] gen,\n@@ -4953,7 +4953,7 @@ fn trans_args(@block_ctxt cx,\n     ret tup(bcx, llargs, llretslot);\n }\n \n-fn trans_call(@block_ctxt cx, @ast.expr f,\n+fn trans_call(&@block_ctxt cx, @ast.expr f,\n               Option.t[ValueRef] lliterbody,\n               vec[@ast.expr] args,\n               &ast.ann ann) -> result {\n@@ -5042,7 +5042,7 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n     ret res(bcx, retval);\n }\n \n-fn trans_tup(@block_ctxt cx, vec[ast.elt] elts,\n+fn trans_tup(&@block_ctxt cx, vec[ast.elt] elts,\n              &ast.ann ann) -> result {\n     auto bcx = cx;\n     auto t = node_ann_type(bcx.fcx.lcx.ccx, ann);\n@@ -5066,7 +5066,7 @@ fn trans_tup(@block_ctxt cx, vec[ast.elt] elts,\n     ret res(bcx, tup_val);\n }\n \n-fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n+fn trans_vec(&@block_ctxt cx, vec[@ast.expr] args,\n              &ast.ann ann) -> result {\n     auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n     auto unit_ty = t;\n@@ -5140,7 +5140,7 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n     ret res(bcx, vec_val);\n }\n \n-fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n+fn trans_rec(&@block_ctxt cx, vec[ast.field] fields,\n              Option.t[@ast.expr] base, &ast.ann ann) -> result {\n \n     auto bcx = cx;\n@@ -5198,7 +5198,7 @@ fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n \n \n \n-fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n+fn trans_expr(&@block_ctxt cx, @ast.expr e) -> result {\n     alt (e.node) {\n         case (ast.expr_lit(?lit, ?ann)) {\n             ret res(cx, trans_lit(cx.fcx.lcx.ccx, *lit, ann));\n@@ -5388,28 +5388,28 @@ fn type_is_immediate(@crate_ctxt ccx, ty.t t) -> bool {\n         ty.type_is_native(ccx.tcx, t);\n }\n \n-fn do_spill(@block_ctxt cx, ValueRef v) -> ValueRef {\n+fn do_spill(&@block_ctxt cx, ValueRef v) -> ValueRef {\n     // We have a value but we have to spill it to pass by alias.\n     auto llptr = alloca(cx, val_ty(v));\n     cx.build.Store(v, llptr);\n     ret llptr;\n }\n \n-fn spill_if_immediate(@block_ctxt cx, ValueRef v, ty.t t) -> ValueRef {\n+fn spill_if_immediate(&@block_ctxt cx, ValueRef v, ty.t t) -> ValueRef {\n     if (type_is_immediate(cx.fcx.lcx.ccx, t)) {\n         ret do_spill(cx, v);\n     }\n     ret v;\n }\n \n-fn load_if_immediate(@block_ctxt cx, ValueRef v, ty.t t) -> ValueRef {\n+fn load_if_immediate(&@block_ctxt cx, ValueRef v, ty.t t) -> ValueRef {\n     if (type_is_immediate(cx.fcx.lcx.ccx, t)) {\n         ret cx.build.Load(v);\n     }\n     ret v;\n }\n \n-fn trans_log(int lvl, @block_ctxt cx, @ast.expr e) -> result {\n+fn trans_log(int lvl, &@block_ctxt cx, @ast.expr e) -> result {\n     auto lcx = cx.fcx.lcx;\n     auto modname = Str.connect(lcx.module_path, \".\");\n     auto global;\n@@ -5485,7 +5485,7 @@ fn trans_log(int lvl, @block_ctxt cx, @ast.expr e) -> result {\n     ret res(after_cx, C_nil());\n }\n \n-fn trans_check_expr(@block_ctxt cx, @ast.expr e) -> result {\n+fn trans_check_expr(&@block_ctxt cx, @ast.expr e) -> result {\n     auto cond_res = trans_expr(cx, e);\n \n     auto expr_str = util.common.expr_to_str(e);\n@@ -5499,7 +5499,7 @@ fn trans_check_expr(@block_ctxt cx, @ast.expr e) -> result {\n     ret res(next_cx, C_nil());\n }\n \n-fn trans_fail(@block_ctxt cx, Option.t[common.span] sp_opt, str fail_str)\n+fn trans_fail(&@block_ctxt cx, Option.t[common.span] sp_opt, str fail_str)\n         -> result {\n     auto V_fail_str = C_cstr(cx.fcx.lcx.ccx, fail_str);\n \n@@ -5526,7 +5526,7 @@ fn trans_fail(@block_ctxt cx, Option.t[common.span] sp_opt, str fail_str)\n     ret res(cx, C_nil());\n }\n \n-fn trans_put(@block_ctxt cx, &Option.t[@ast.expr] e) -> result {\n+fn trans_put(&@block_ctxt cx, &Option.t[@ast.expr] e) -> result {\n     auto llcallee = C_nil();\n     auto llenv = C_nil();\n \n@@ -5562,7 +5562,7 @@ fn trans_put(@block_ctxt cx, &Option.t[@ast.expr] e) -> result {\n     ret res(bcx, bcx.build.FastCall(llcallee, llargs));\n }\n \n-fn trans_break_cont(@block_ctxt cx, bool to_end) -> result {\n+fn trans_break_cont(&@block_ctxt cx, bool to_end) -> result {\n     auto bcx = cx;\n     // Locate closest loop block, outputting cleanup as we go.\n     auto cleanup_cx = cx;\n@@ -5595,16 +5595,16 @@ fn trans_break_cont(@block_ctxt cx, bool to_end) -> result {\n     fail;\n }\n \n-fn trans_break(@block_ctxt cx) -> result {\n+fn trans_break(&@block_ctxt cx) -> result {\n     ret trans_break_cont(cx, true);\n }\n \n-fn trans_cont(@block_ctxt cx) -> result {\n+fn trans_cont(&@block_ctxt cx) -> result {\n     ret trans_break_cont(cx, false);\n }\n \n \n-fn trans_ret(@block_ctxt cx, &Option.t[@ast.expr] e) -> result {\n+fn trans_ret(&@block_ctxt cx, &Option.t[@ast.expr] e) -> result {\n     auto bcx = cx;\n     auto val = C_nil();\n \n@@ -5642,15 +5642,15 @@ fn trans_ret(@block_ctxt cx, &Option.t[@ast.expr] e) -> result {\n     ret res(new_sub_block_ctxt(bcx, \"ret.unreachable\"), C_nil());\n }\n \n-fn trans_be(@block_ctxt cx, @ast.expr e) -> result {\n+fn trans_be(&@block_ctxt cx, @ast.expr e) -> result {\n     // FIXME: This should be a typestate precondition\n     assert (ast.is_call_expr(e));\n     // FIXME: Turn this into a real tail call once\n     // calling convention issues are settled\n     ret trans_ret(cx, some(e));\n }\n \n-fn trans_port(@block_ctxt cx, ast.ann ann) -> result {\n+fn trans_port(&@block_ctxt cx, ast.ann ann) -> result {\n \n     auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n     auto unit_ty;\n@@ -5679,7 +5679,7 @@ fn trans_port(@block_ctxt cx, ast.ann ann) -> result {\n     ret res(bcx, port_val);\n }\n \n-fn trans_chan(@block_ctxt cx, @ast.expr e, ast.ann ann) -> result {\n+fn trans_chan(&@block_ctxt cx, @ast.expr e, ast.ann ann) -> result {\n \n     auto bcx = cx;\n     auto prt = trans_expr(bcx, e);\n@@ -5698,7 +5698,7 @@ fn trans_chan(@block_ctxt cx, @ast.expr e, ast.ann ann) -> result {\n     ret res(bcx, chan_val);\n }\n \n-fn trans_send(@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n+fn trans_send(&@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n               ast.ann ann) -> result {\n \n     auto bcx = cx;\n@@ -5735,7 +5735,7 @@ fn trans_send(@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n     ret res(bcx, chn.val);\n }\n \n-fn trans_recv(@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n+fn trans_recv(&@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n               ast.ann ann) -> result {\n \n     auto bcx = cx;\n@@ -5748,7 +5748,7 @@ fn trans_recv(@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n     ret recv_val(bcx, data.res.val, rhs, unit_ty, DROP_EXISTING);\n  }\n \n-fn recv_val(@block_ctxt cx, ValueRef lhs, @ast.expr rhs,\n+fn recv_val(&@block_ctxt cx, ValueRef lhs, @ast.expr rhs,\n             ty.t unit_ty, copy_action action) -> result {\n \n     auto bcx = cx;\n@@ -5769,7 +5769,7 @@ fn recv_val(@block_ctxt cx, ValueRef lhs, @ast.expr rhs,\n     ret res(bcx, lhs);\n }\n \n-fn init_local(@block_ctxt cx, @ast.local local) -> result {\n+fn init_local(&@block_ctxt cx, @ast.local local) -> result {\n \n     // Make a note to drop this slot on the way out.\n     assert (cx.fcx.lllocals.contains_key(local.id));\n@@ -5799,7 +5799,7 @@ fn init_local(@block_ctxt cx, @ast.local local) -> result {\n     ret res(bcx, llptr);\n }\n \n-fn zero_alloca(@block_ctxt cx, ValueRef llptr, ty.t t) -> result {\n+fn zero_alloca(&@block_ctxt cx, ValueRef llptr, ty.t t) -> result {\n     auto bcx = cx;\n     if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n         auto llsz = size_of(bcx, t);\n@@ -5814,7 +5814,7 @@ fn zero_alloca(@block_ctxt cx, ValueRef llptr, ty.t t) -> result {\n     ret res(bcx, llptr);\n  }\n \n-fn trans_stmt(@block_ctxt cx, &ast.stmt s) -> result {\n+fn trans_stmt(&@block_ctxt cx, &ast.stmt s) -> result {\n     auto bcx = cx;\n     alt (s.node) {\n         case (ast.stmt_expr(?e,_)) {\n@@ -5870,24 +5870,24 @@ fn new_top_block_ctxt(@fn_ctxt fcx) -> @block_ctxt {\n }\n \n // Use this when you're at a curly-brace or similar lexical scope.\n-fn new_scope_block_ctxt(@block_ctxt bcx, str n) -> @block_ctxt {\n+fn new_scope_block_ctxt(&@block_ctxt bcx, str n) -> @block_ctxt {\n     ret new_block_ctxt(bcx.fcx, parent_some(bcx), SCOPE_BLOCK, n);\n }\n \n-fn new_loop_scope_block_ctxt(@block_ctxt bcx, Option.t[@block_ctxt] _cont,\n-                             @block_ctxt _break, str n) -> @block_ctxt {\n+fn new_loop_scope_block_ctxt(&@block_ctxt bcx, Option.t[@block_ctxt] _cont,\n+                             &@block_ctxt _break, str n) -> @block_ctxt {\n     ret new_block_ctxt(bcx.fcx, parent_some(bcx),\n                        LOOP_SCOPE_BLOCK(_cont, _break), n);\n }\n \n // Use this when you're making a general CFG BB within a scope.\n-fn new_sub_block_ctxt(@block_ctxt bcx, str n) -> @block_ctxt {\n+fn new_sub_block_ctxt(&@block_ctxt bcx, str n) -> @block_ctxt {\n     ret new_block_ctxt(bcx.fcx, parent_some(bcx), NON_SCOPE_BLOCK, n);\n }\n \n \n-fn trans_block_cleanups(@block_ctxt cx,\n-                        @block_ctxt cleanup_cx) -> @block_ctxt {\n+fn trans_block_cleanups(&@block_ctxt cx,\n+                        &@block_ctxt cleanup_cx) -> @block_ctxt {\n     auto bcx = cx;\n \n     if (cleanup_cx.kind == NON_SCOPE_BLOCK) {\n@@ -5935,7 +5935,7 @@ fn llallocas_block_ctxt(@fn_ctxt fcx) -> @block_ctxt {\n              fcx=fcx);\n }\n \n-fn alloc_ty(@block_ctxt cx, ty.t t) -> result {\n+fn alloc_ty(&@block_ctxt cx, ty.t t) -> result {\n     auto val = C_int(0);\n     if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n \n@@ -5959,14 +5959,14 @@ fn alloc_ty(@block_ctxt cx, ty.t t) -> result {\n     ret res(cx, val);\n }\n \n-fn alloc_local(@block_ctxt cx, @ast.local local) -> result {\n+fn alloc_local(&@block_ctxt cx, @ast.local local) -> result {\n     auto t = node_ann_type(cx.fcx.lcx.ccx, local.ann);\n     auto r = alloc_ty(cx, t);\n     r.bcx.fcx.lllocals.insert(local.id, r.val);\n     ret r;\n }\n \n-fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n+fn trans_block(&@block_ctxt cx, &ast.block b) -> result {\n     auto bcx = cx;\n \n     for each (@ast.local local in block_locals(b)) {\n@@ -6184,7 +6184,7 @@ fn copy_args_to_allocas(@fn_ctxt fcx,\n     fcx.llallocas = bcx.llbb;\n }\n \n-fn add_cleanups_for_args(@block_ctxt bcx,\n+fn add_cleanups_for_args(&@block_ctxt bcx,\n                          vec[ast.arg] args,\n                          vec[ty.arg] arg_tys) {\n     let uint arg_n = 0u;\n@@ -6199,7 +6199,7 @@ fn add_cleanups_for_args(@block_ctxt bcx,\n }\n \n \n-fn is_terminated(@block_ctxt cx) -> bool {\n+fn is_terminated(&@block_ctxt cx) -> bool {\n     auto inst = llvm.LLVMGetLastInstruction(cx.llbb);\n     ret llvm.LLVMIsATerminatorInst(inst) as int != 0;\n }\n@@ -6867,7 +6867,7 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n         arg_n += 1u;\n     }\n \n-    fn convert_arg_to_i32(@block_ctxt cx,\n+    fn convert_arg_to_i32(&@block_ctxt cx,\n                           ValueRef v,\n                           ty.t t,\n                           ty.mode mode) -> ValueRef {\n@@ -6889,7 +6889,7 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n         ret vp2i(cx, v);\n     }\n \n-    fn trans_simple_native_abi(@block_ctxt bcx,\n+    fn trans_simple_native_abi(&@block_ctxt bcx,\n                                str name,\n                                &mutable vec[ValueRef] call_args,\n                                ty.t fn_type,\n@@ -7167,12 +7167,12 @@ fn trans_constants(@crate_ctxt ccx, @ast.crate crate) {\n }\n \n \n-fn vp2i(@block_ctxt cx, ValueRef v) -> ValueRef {\n+fn vp2i(&@block_ctxt cx, ValueRef v) -> ValueRef {\n     ret cx.build.PtrToInt(v, T_int());\n }\n \n \n-fn vi2p(@block_ctxt cx, ValueRef v, TypeRef t) -> ValueRef {\n+fn vi2p(&@block_ctxt cx, ValueRef v, TypeRef t) -> ValueRef {\n     ret cx.build.IntToPtr(v, t);\n }\n \n@@ -7353,21 +7353,21 @@ fn declare_intrinsics(ModuleRef llmod) -> hashmap[str,ValueRef] {\n }\n \n \n-fn trace_str(@block_ctxt cx, str s) {\n+fn trace_str(&@block_ctxt cx, str s) {\n     cx.build.Call(cx.fcx.lcx.ccx.upcalls.trace_str,\n                   vec(cx.fcx.lltaskptr, C_cstr(cx.fcx.lcx.ccx, s)));\n }\n \n-fn trace_word(@block_ctxt cx, ValueRef v) {\n+fn trace_word(&@block_ctxt cx, ValueRef v) {\n     cx.build.Call(cx.fcx.lcx.ccx.upcalls.trace_word,\n                   vec(cx.fcx.lltaskptr, v));\n }\n \n-fn trace_ptr(@block_ctxt cx, ValueRef v) {\n+fn trace_ptr(&@block_ctxt cx, ValueRef v) {\n     trace_word(cx, cx.build.PtrToInt(v, T_int()));\n }\n \n-fn trap(@block_ctxt bcx) {\n+fn trap(&@block_ctxt bcx) {\n     let vec[ValueRef] v = vec();\n     bcx.build.Call(bcx.fcx.lcx.ccx.intrinsics.get(\"llvm.trap\"), v);\n }\n@@ -7416,39 +7416,39 @@ fn make_vec_append_glue(ModuleRef llmod, type_names tn) -> ValueRef {\n }\n \n \n-fn vec_fill(@block_ctxt bcx, ValueRef v) -> ValueRef {\n+fn vec_fill(&@block_ctxt bcx, ValueRef v) -> ValueRef {\n     ret bcx.build.Load(bcx.build.GEP(v, vec(C_int(0),\n                                             C_int(abi.vec_elt_fill))));\n }\n \n-fn put_vec_fill(@block_ctxt bcx, ValueRef v, ValueRef fill) -> ValueRef {\n+fn put_vec_fill(&@block_ctxt bcx, ValueRef v, ValueRef fill) -> ValueRef {\n     ret bcx.build.Store(fill,\n                         bcx.build.GEP(v,\n                                       vec(C_int(0),\n                                           C_int(abi.vec_elt_fill))));\n }\n \n-fn vec_fill_adjusted(@block_ctxt bcx, ValueRef v,\n+fn vec_fill_adjusted(&@block_ctxt bcx, ValueRef v,\n                      ValueRef skipnull) -> ValueRef {\n     auto f = bcx.build.Load(bcx.build.GEP(v,\n                                           vec(C_int(0),\n                                               C_int(abi.vec_elt_fill))));\n     ret bcx.build.Select(skipnull, bcx.build.Sub(f, C_int(1)), f);\n }\n \n-fn vec_p0(@block_ctxt bcx, ValueRef v) -> ValueRef {\n+fn vec_p0(&@block_ctxt bcx, ValueRef v) -> ValueRef {\n     auto p = bcx.build.GEP(v, vec(C_int(0),\n                                   C_int(abi.vec_elt_data)));\n     ret bcx.build.PointerCast(p, T_ptr(T_i8()));\n }\n \n \n-fn vec_p1(@block_ctxt bcx, ValueRef v) -> ValueRef {\n+fn vec_p1(&@block_ctxt bcx, ValueRef v) -> ValueRef {\n     auto len = vec_fill(bcx, v);\n     ret bcx.build.GEP(vec_p0(bcx, v), vec(len));\n }\n \n-fn vec_p1_adjusted(@block_ctxt bcx, ValueRef v,\n+fn vec_p1_adjusted(&@block_ctxt bcx, ValueRef v,\n                    ValueRef skipnull) -> ValueRef {\n     auto len = vec_fill_adjusted(bcx, v, skipnull);\n     ret bcx.build.GEP(vec_p0(bcx, v), vec(len));\n@@ -7511,7 +7511,7 @@ fn trans_vec_append_glue(@local_ctxt cx) {\n                      copy_src_cx.llbb);\n \n \n-    fn copy_elts(@block_ctxt cx,\n+    fn copy_elts(&@block_ctxt cx,\n                  ValueRef elt_tydesc,\n                  ValueRef dst,\n                  ValueRef src,"}]}