{"sha": "5f57a508af9c43adc03a4edd575ceae41cc8cd3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmNTdhNTA4YWY5YzQzYWRjMDNhNGVkZDU3NWNlYWU0MWNjOGNkM2E=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-28T01:01:52Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-28T01:05:59Z"}, "message": "Convert misc compiler bits to istrs. Issue #855", "tree": {"sha": "4f5675666fd7cd9b99cb8ddae0db687858dcd1e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f5675666fd7cd9b99cb8ddae0db687858dcd1e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f57a508af9c43adc03a4edd575ceae41cc8cd3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f57a508af9c43adc03a4edd575ceae41cc8cd3a", "html_url": "https://github.com/rust-lang/rust/commit/5f57a508af9c43adc03a4edd575ceae41cc8cd3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cffd9b8044cd4792d281c9129c5a6edc16edd0d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/cffd9b8044cd4792d281c9129c5a6edc16edd0d5", "html_url": "https://github.com/rust-lang/rust/commit/cffd9b8044cd4792d281c9129c5a6edc16edd0d5"}], "stats": {"total": 184, "additions": 93, "deletions": 91}, "files": [{"sha": "fffdcc75bf30edec39a194a37eed438e3c52d531", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=5f57a508af9c43adc03a4edd575ceae41cc8cd3a", "patch": "@@ -47,21 +47,21 @@ fn default_configuration(sess: session::session,\n    ast::crate_cfg {\n     let libc =\n         alt sess.get_targ_cfg().os {\n-          session::os_win32. { \"msvcrt.dll\" }\n-          session::os_macos. { \"libc.dylib\" }\n-          session::os_linux. { \"libc.so.6\" }\n-          _ { \"libc.so\" }\n+          session::os_win32. { ~\"msvcrt.dll\" }\n+          session::os_macos. { ~\"libc.dylib\" }\n+          session::os_linux. { ~\"libc.so.6\" }\n+          _ { ~\"libc.so\" }\n         };\n \n     let mk = attr::mk_name_value_item_str;\n \n     ret [ // Target bindings.\n-         mk(~\"target_os\", istr::to_estr(std::os::target_os())),\n-        mk(~\"target_arch\", \"x86\"),\n+         mk(~\"target_os\", std::os::target_os()),\n+        mk(~\"target_arch\", ~\"x86\"),\n          mk(~\"target_libc\", libc),\n          // Build bindings.\n-         mk(~\"build_compiler\", istr::to_estr(argv0)),\n-        mk(~\"build_input\", istr::to_estr(input))];\n+         mk(~\"build_compiler\", argv0),\n+        mk(~\"build_input\", input)];\n }\n \n fn build_configuration(sess: session::session, argv0: &istr, input: &istr) ->"}, {"sha": "0d85a083554e8d5b8bdc6c4b634c34848df25421", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=5f57a508af9c43adc03a4edd575ceae41cc8cd3a", "patch": "@@ -197,8 +197,9 @@ fn span<@T>(item: &T) -> ast::spanned<T> {\n     ret {node: item, span: ast_util::dummy_sp()};\n }\n \n-fn mk_name_value_item_str(name: ast::ident, value: str) -> @ast::meta_item {\n-    let value_lit = span(ast::lit_str(istr::from_estr(value), ast::sk_rc));\n+fn mk_name_value_item_str(name: ast::ident,\n+                          value: &istr) -> @ast::meta_item {\n+    let value_lit = span(ast::lit_str(value, ast::sk_rc));\n     ret mk_name_value_item(name, value_lit);\n }\n "}, {"sha": "92247cb55a84c18dff80f96753a76a23351f1201", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=5f57a508af9c43adc03a4edd575ceae41cc8cd3a", "patch": "@@ -310,7 +310,7 @@ fn get_meta_items(md: &ebml::doc) -> [@ast::meta_item] {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let vd = ebml::get_doc(meta_item_doc, tag_meta_item_value);\n         let n = istr::unsafe_from_bytes(ebml::doc_data(nd));\n-        let v = str::unsafe_from_bytes(ebml::doc_data(vd));\n+        let v = istr::unsafe_from_bytes(ebml::doc_data(vd));\n         // FIXME (#611): Should be able to decode meta_name_value variants,\n         // but currently they can't be encoded\n         items += [attr::mk_name_value_item_str(n, v)];"}, {"sha": "269a49acbe6aa3b460472d871457a9d5835a748a", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=5f57a508af9c43adc03a4edd575ceae41cc8cd3a", "patch": "@@ -511,10 +511,10 @@ fn synthesize_crate_attrs(ecx: &@encode_ctxt, crate: &@crate) -> [attribute] {\n \n         let name_item =\n             attr::mk_name_value_item_str(\n-                ~\"name\", istr::to_estr(ecx.ccx.link_meta.name));\n+                ~\"name\", ecx.ccx.link_meta.name);\n         let vers_item =\n             attr::mk_name_value_item_str(\n-                ~\"vers\", istr::to_estr(ecx.ccx.link_meta.vers));\n+                ~\"vers\", ecx.ccx.link_meta.vers);\n \n         let other_items =\n             {"}, {"sha": "74cc3b4cada5570e0a39ceb11fad69127a5c34e5", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=5f57a508af9c43adc03a4edd575ceae41cc8cd3a", "patch": "@@ -112,44 +112,45 @@ fn type_and_kind(tcx: &ty::ctxt, e: &@ast::expr) ->\n }\n \n fn need_expr_kind(tcx: &ty::ctxt, e: &@ast::expr, k_need: ast::kind,\n-                  descr: &str) {\n+                  descr: &istr) {\n     let tk = type_and_kind(tcx, e);\n-    log #fmt[\"for %s: want %s type, got %s type %s\", descr,\n+    log #fmt[\"for %s: want %s type, got %s type %s\", istr::to_estr(descr),\n              kind_to_str(k_need), kind_to_str(tk.kind),\n              istr::to_estr(util::ppaux::ty_to_str(tcx, tk.ty))];\n \n     if !kind_lteq(k_need, tk.kind) {\n         let s =\n             #fmt[\"mismatched kinds for %s: needed %s type, got %s type %s\",\n-                 descr, kind_to_str(k_need), kind_to_str(tk.kind),\n+                 istr::to_estr(descr), kind_to_str(k_need),\n+                 kind_to_str(tk.kind),\n                  istr::to_estr(util::ppaux::ty_to_str(tcx, tk.ty))];\n         tcx.sess.span_err(e.span, istr::from_estr(s));\n     }\n }\n \n fn need_shared_lhs_rhs(tcx: &ty::ctxt, a: &@ast::expr, b: &@ast::expr,\n-                       op: &str) {\n-    need_expr_kind(tcx, a, ast::kind_shared, op + \" lhs\");\n-    need_expr_kind(tcx, b, ast::kind_shared, op + \" rhs\");\n+                       op: &istr) {\n+    need_expr_kind(tcx, a, ast::kind_shared, op + ~\" lhs\");\n+    need_expr_kind(tcx, b, ast::kind_shared, op + ~\" rhs\");\n }\n \n fn check_expr(tcx: &ty::ctxt, e: &@ast::expr) {\n     alt e.node {\n-      ast::expr_move(a, b) { need_shared_lhs_rhs(tcx, a, b, \"<-\"); }\n-      ast::expr_assign(a, b) { need_shared_lhs_rhs(tcx, a, b, \"=\"); }\n-      ast::expr_assign_op(_, a, b) { need_shared_lhs_rhs(tcx, a, b, \"op=\"); }\n-      ast::expr_swap(a, b) { need_shared_lhs_rhs(tcx, a, b, \"<->\"); }\n+      ast::expr_move(a, b) { need_shared_lhs_rhs(tcx, a, b, ~\"<-\"); }\n+      ast::expr_assign(a, b) { need_shared_lhs_rhs(tcx, a, b, ~\"=\"); }\n+      ast::expr_assign_op(_, a, b) { need_shared_lhs_rhs(tcx, a, b, ~\"op=\"); }\n+      ast::expr_swap(a, b) { need_shared_lhs_rhs(tcx, a, b, ~\"<->\"); }\n       ast::expr_copy(a) {\n-        need_expr_kind(tcx, a, ast::kind_shared, \"'copy' operand\");\n+        need_expr_kind(tcx, a, ast::kind_shared, ~\"'copy' operand\");\n       }\n       ast::expr_ret(option::some(a)) {\n-        need_expr_kind(tcx, a, ast::kind_shared, \"'ret' operand\");\n+        need_expr_kind(tcx, a, ast::kind_shared, ~\"'ret' operand\");\n       }\n       ast::expr_be(a) {\n-        need_expr_kind(tcx, a, ast::kind_shared, \"'be' operand\");\n+        need_expr_kind(tcx, a, ast::kind_shared, ~\"'be' operand\");\n       }\n       ast::expr_fail(option::some(a)) {\n-        need_expr_kind(tcx, a, ast::kind_shared, \"'fail' operand\");\n+        need_expr_kind(tcx, a, ast::kind_shared, ~\"'fail' operand\");\n       }\n       ast::expr_call(callee, _) {\n         let tpt = ty::expr_ty_params_and_ty(tcx, callee);"}, {"sha": "53193ad98beb6a3b9905cccb0165d16a87785102", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=5f57a508af9c43adc03a4edd575ceae41cc8cd3a", "patch": "@@ -58,9 +58,9 @@ fn variant_opt(ccx: &@crate_ctxt, pat_id: ast::node_id) -> opt {\n }\n \n type bind_map = [{ident: ast::ident, val: ValueRef}];\n-fn assoc(key: str, list: &bind_map) -> option::t<ValueRef> {\n+fn assoc(key: &istr, list: &bind_map) -> option::t<ValueRef> {\n     for elt: {ident: ast::ident, val: ValueRef} in list {\n-        if istr::eq(elt.ident, istr::from_estr(key)) { ret some(elt.val); }\n+        if istr::eq(elt.ident, key) { ret some(elt.val); }\n     }\n     ret none;\n }\n@@ -304,7 +304,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n             // the actual arm block.\n             for each @{key, val} in data.id_map.items() {\n                 bcx.fcx.lllocals.insert\n-                    (val, option::get(assoc(istr::to_estr(key),\n+                    (val, option::get(assoc(key,\n                                             m[0].bound)));\n             }\n             let {bcx: guard_bcx, val: guard_val} =\n@@ -474,7 +474,7 @@ fn make_phi_bindings(bcx: &@block_ctxt, map: &[exit_node],\n         let vals = [];\n         for ex: exit_node in map {\n             if ex.to as uint == our_block {\n-                alt assoc(istr::to_estr(item.key), ex.bound) {\n+                alt assoc(item.key, ex.bound) {\n                   some(val) { llbbs += [ex.from]; vals += [val]; }\n                   none. { }\n                 }"}, {"sha": "eec50b5f454ceecf90a8c3f635520cf78b307b3f", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=5f57a508af9c43adc03a4edd575ceae41cc8cd3a", "patch": "@@ -243,7 +243,7 @@ fn method_ty_to_fn_ty(cx: &ctxt, m: method) -> t {\n // Never construct these manually. These are interned.\n type raw_t =\n     {struct: sty,\n-     cname: option::t<str>,\n+     cname: option::t<istr>,\n      hash: uint,\n      has_params: bool,\n      has_vars: bool};\n@@ -427,8 +427,8 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map,\n \n \n // Type constructors\n-fn mk_raw_ty(cx: &ctxt, st: &sty, _in_cname: &option::t<str>) -> @raw_t {\n-    let cname = none;\n+fn mk_raw_ty(cx: &ctxt, st: &sty, _in_cname: &option::t<istr>) -> @raw_t {\n+    let cname: option::t<istr> = none;\n     let h = hash_type_info(st, cname);\n     let has_params: bool = false;\n     let has_vars: bool = false;\n@@ -505,11 +505,11 @@ fn mk_raw_ty(cx: &ctxt, st: &sty, _in_cname: &option::t<str>) -> @raw_t {\n           has_vars: has_vars};\n }\n \n-fn intern(cx: &ctxt, st: &sty, cname: &option::t<str>) {\n+fn intern(cx: &ctxt, st: &sty, cname: &option::t<istr>) {\n     interner::intern(*cx.ts, mk_raw_ty(cx, st, cname));\n }\n \n-fn gen_ty_full(cx: &ctxt, st: &sty, cname: &option::t<str>) -> t {\n+fn gen_ty_full(cx: &ctxt, st: &sty, cname: &option::t<istr>) -> t {\n     let raw_type = mk_raw_ty(cx, st, cname);\n     ret interner::intern(*cx.ts, raw_type);\n }\n@@ -617,7 +617,7 @@ fn struct(cx: &ctxt, typ: t) -> sty {\n \n \n // Returns the canonical name of the given type.\n-fn cname(cx: &ctxt, typ: t) -> option::t<str> {\n+fn cname(cx: &ctxt, typ: t) -> option::t<istr> {\n     ret interner::get(*cx.ts, typ).cname;\n }\n \n@@ -794,7 +794,7 @@ fn fold_ty(cx: &ctxt, fld: fold_mode, ty_0: t) -> t {\n \n // Type utilities\n \n-fn rename(cx: &ctxt, typ: t, new_cname: str) -> t {\n+fn rename(cx: &ctxt, typ: t, new_cname: &istr) -> t {\n     ret gen_ty_full(cx, struct(cx, typ), some(new_cname));\n }\n \n@@ -1538,11 +1538,11 @@ fn hash_type_structure(st: &sty) -> uint {\n     }\n }\n \n-fn hash_type_info(st: &sty, cname_opt: &option::t<str>) -> uint {\n+fn hash_type_info(st: &sty, cname_opt: &option::t<istr>) -> uint {\n     let h = hash_type_structure(st);\n     alt cname_opt {\n       none. {/* no-op */ }\n-      some(s) { h += h << 5u + str::hash(s); }\n+      some(s) { h += h << 5u + istr::hash(s); }\n     }\n     ret h;\n }\n@@ -1606,7 +1606,7 @@ fn eq_raw_ty(a: &@raw_t, b: &@raw_t) -> bool {\n       none. { alt b.cname { none. {/* ok */ } _ { ret false; } } }\n       some(s_a) {\n         alt b.cname {\n-          some(s_b) { if !str::eq(s_a, s_b) { ret false; } }\n+          some(s_b) { if !istr::eq(s_a, s_b) { ret false; } }\n           _ { ret false; }\n         }\n       }"}, {"sha": "57baf194938dd64ed2d55a86c445a0e9035ea184", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=5f57a508af9c43adc03a4edd575ceae41cc8cd3a", "patch": "@@ -417,7 +417,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n     alt cname {\n       none. {/* no-op */ }\n       some(cname_str) {\n-        typ = ty::rename(tcx, typ, istr::to_estr(cname_str));\n+        typ = ty::rename(tcx, typ, cname_str);\n       }\n     }\n     tcx.ast_ty_to_ty_cache.insert(ast_ty, some(typ));\n@@ -629,7 +629,7 @@ mod collect {\n                  ty_params: &[ast::ty_param]) -> ty::ty_param_kinds_and_ty {\n         let methods = get_obj_method_types(cx, ob);\n         let t_obj = ty::mk_obj(cx.tcx, ty::sort_methods(methods));\n-        t_obj = ty::rename(cx.tcx, t_obj, istr::to_estr(id));\n+        t_obj = ty::rename(cx.tcx, t_obj, id);\n         ret {kinds: ty_param_kinds(ty_params), ty: t_obj};\n     }\n     fn ty_of_obj_ctor(cx: @ctxt, id: &ast::ident, ob: &ast::_obj,"}, {"sha": "23feb43d817d30bfffa62050dc5ed41146d9efca", "filename": "src/comp/syntax/ext/env.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs?ref=5f57a508af9c43adc03a4edd575ceae41cc8cd3a", "patch": "@@ -28,15 +28,15 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n \n     let var = expr_to_str(cx, args[0], ~\"#env requires a string\");\n     alt generic_os::getenv(var) {\n-      option::none. { ret make_new_str(cx, sp, \"\"); }\n+      option::none. { ret make_new_str(cx, sp, ~\"\"); }\n       option::some(s) {\n-        ret make_new_str(cx, sp, istr::to_estr(s));\n+        ret make_new_str(cx, sp, s);\n       }\n     }\n }\n \n-fn make_new_str(cx: &ext_ctxt, sp: codemap::span, s: str) -> @ast::expr {\n-    ret make_new_lit(cx, sp, ast::lit_str(istr::from_estr(s), ast::sk_rc));\n+fn make_new_str(cx: &ext_ctxt, sp: codemap::span, s: &istr) -> @ast::expr {\n+    ret make_new_lit(cx, sp, ast::lit_str(s, ast::sk_rc));\n }\n //\n // Local Variables:"}, {"sha": "121300f6490259472d65166f1951828fb839b89d", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=5f57a508af9c43adc03a4edd575ceae41cc8cd3a", "patch": "@@ -52,8 +52,8 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n         let sp_lit = @{node: lit, span: sp};\n         ret @{id: cx.next_id(), node: ast::expr_lit(sp_lit), span: sp};\n     }\n-    fn make_new_str(cx: &ext_ctxt, sp: span, s: str) -> @ast::expr {\n-        let lit = ast::lit_str(istr::from_estr(s), ast::sk_rc);\n+    fn make_new_str(cx: &ext_ctxt, sp: span, s: &istr) -> @ast::expr {\n+        let lit = ast::lit_str(s, ast::sk_rc);\n         ret make_new_lit(cx, sp, lit);\n     }\n     fn make_new_int(cx: &ext_ctxt, sp: span, i: int) -> @ast::expr {\n@@ -109,8 +109,9 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n             ret [~\"extfmt\", ~\"rt\", ident];\n         } else { ret [~\"std\", ~\"extfmt\", ~\"rt\", ident]; }\n     }\n-    fn make_rt_path_expr(cx: &ext_ctxt, sp: span, ident: str) -> @ast::expr {\n-        let path = make_path_vec(cx, istr::from_estr(ident));\n+    fn make_rt_path_expr(cx: &ext_ctxt, sp: span,\n+                         ident: &istr) -> @ast::expr {\n+        let path = make_path_vec(cx, ident);\n         ret make_path_expr(cx, sp, path);\n     }\n     // Produces an AST expression that represents a RT::conv record,\n@@ -122,11 +123,11 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n             for f: flag in flags {\n                 let fstr;\n                 alt f {\n-                  flag_left_justify. { fstr = \"flag_left_justify\"; }\n-                  flag_left_zero_pad. { fstr = \"flag_left_zero_pad\"; }\n-                  flag_space_for_sign. { fstr = \"flag_space_for_sign\"; }\n-                  flag_sign_always. { fstr = \"flag_sign_always\"; }\n-                  flag_alternate. { fstr = \"flag_alternate\"; }\n+                  flag_left_justify. { fstr = ~\"flag_left_justify\"; }\n+                  flag_left_zero_pad. { fstr = ~\"flag_left_zero_pad\"; }\n+                  flag_space_for_sign. { fstr = ~\"flag_space_for_sign\"; }\n+                  flag_sign_always. { fstr = ~\"flag_sign_always\"; }\n+                  flag_alternate. { fstr = ~\"flag_alternate\"; }\n                 }\n                 flagexprs += [make_rt_path_expr(cx, sp, fstr)];\n             }\n@@ -135,14 +136,14 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n             // this is a hack placeholder flag\n \n             if vec::len::<@ast::expr>(flagexprs) == 0u {\n-                flagexprs += [make_rt_path_expr(cx, sp, \"flag_none\")];\n+                flagexprs += [make_rt_path_expr(cx, sp, ~\"flag_none\")];\n             }\n             ret make_vec_expr(cx, sp, flagexprs);\n         }\n         fn make_count(cx: &ext_ctxt, sp: span, cnt: &count) -> @ast::expr {\n             alt cnt {\n               count_implied. {\n-                ret make_rt_path_expr(cx, sp, \"count_implied\");\n+                ret make_rt_path_expr(cx, sp, ~\"count_implied\");\n               }\n               count_is(c) {\n                 let count_lit = make_new_int(cx, sp, c);\n@@ -158,13 +159,13 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n             alt t {\n               ty_hex(c) {\n                 alt c {\n-                  case_upper. { rt_type = \"ty_hex_upper\"; }\n-                  case_lower. { rt_type = \"ty_hex_lower\"; }\n+                  case_upper. { rt_type = ~\"ty_hex_upper\"; }\n+                  case_lower. { rt_type = ~\"ty_hex_lower\"; }\n                 }\n               }\n-              ty_bits. { rt_type = \"ty_bits\"; }\n-              ty_octal. { rt_type = \"ty_octal\"; }\n-              _ { rt_type = \"ty_default\"; }\n+              ty_bits. { rt_type = ~\"ty_bits\"; }\n+              ty_octal. { rt_type = ~\"ty_octal\"; }\n+              _ { rt_type = ~\"ty_default\"; }\n             }\n             ret make_rt_path_expr(cx, sp, rt_type);\n         }\n@@ -184,9 +185,9 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n         ret make_conv_rec(cx, sp, rt_conv_flags, rt_conv_width,\n                           rt_conv_precision, rt_conv_ty);\n     }\n-    fn make_conv_call(cx: &ext_ctxt, sp: span, conv_type: str, cnv: &conv,\n-                      arg: @ast::expr) -> @ast::expr {\n-        let fname = ~\"conv_\" + istr::from_estr(conv_type);\n+    fn make_conv_call(cx: &ext_ctxt, sp: span, conv_type: &istr,\n+                      cnv: &conv, arg: @ast::expr) -> @ast::expr {\n+        let fname = ~\"conv_\" + conv_type;\n         let path = make_path_vec(cx, fname);\n         let cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n         let args = [cnv_expr, arg];\n@@ -241,21 +242,21 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n           _ { cx.span_unimpl(sp, unsupported); }\n         }\n         alt cnv.ty {\n-          ty_str. { ret make_conv_call(cx, arg.span, \"str\", cnv, arg); }\n-          ty_istr. { ret make_conv_call(cx, arg.span, \"istr\", cnv, arg); }\n+          ty_str. { ret make_conv_call(cx, arg.span, ~\"str\", cnv, arg); }\n+          ty_istr. { ret make_conv_call(cx, arg.span, ~\"istr\", cnv, arg); }\n           ty_int(sign) {\n             alt sign {\n-              signed. { ret make_conv_call(cx, arg.span, \"int\", cnv, arg); }\n+              signed. { ret make_conv_call(cx, arg.span, ~\"int\", cnv, arg); }\n               unsigned. {\n-                ret make_conv_call(cx, arg.span, \"uint\", cnv, arg);\n+                ret make_conv_call(cx, arg.span, ~\"uint\", cnv, arg);\n               }\n             }\n           }\n-          ty_bool. { ret make_conv_call(cx, arg.span, \"bool\", cnv, arg); }\n-          ty_char. { ret make_conv_call(cx, arg.span, \"char\", cnv, arg); }\n-          ty_hex(_) { ret make_conv_call(cx, arg.span, \"uint\", cnv, arg); }\n-          ty_bits. { ret make_conv_call(cx, arg.span, \"uint\", cnv, arg); }\n-          ty_octal. { ret make_conv_call(cx, arg.span, \"uint\", cnv, arg); }\n+          ty_bool. { ret make_conv_call(cx, arg.span, ~\"bool\", cnv, arg); }\n+          ty_char. { ret make_conv_call(cx, arg.span, ~\"char\", cnv, arg); }\n+          ty_hex(_) { ret make_conv_call(cx, arg.span, ~\"uint\", cnv, arg); }\n+          ty_bits. { ret make_conv_call(cx, arg.span, ~\"uint\", cnv, arg); }\n+          ty_octal. { ret make_conv_call(cx, arg.span, ~\"uint\", cnv, arg); }\n           _ { cx.span_unimpl(sp, unsupported); }\n         }\n     }\n@@ -319,12 +320,12 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n     }\n     let fmt_sp = args[0].span;\n     let n = 0u;\n-    let tmp_expr = make_new_str(cx, sp, \"\");\n+    let tmp_expr = make_new_str(cx, sp, ~\"\");\n     let nargs = vec::len::<@ast::expr>(args);\n     for pc: piece in pieces {\n         alt pc {\n           piece_string(s) {\n-            let s_expr = make_new_str(cx, fmt_sp, s);\n+            let s_expr = make_new_str(cx, fmt_sp, istr::from_estr(s));\n             tmp_expr = make_add_expr(cx, fmt_sp, tmp_expr, s_expr);\n           }\n           piece_conv(conv) {"}, {"sha": "ccd792d78f57a0af39c58c80b4da91aa492d830d", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=5f57a508af9c43adc03a4edd575ceae41cc8cd3a", "patch": "@@ -57,8 +57,7 @@ tag matchable {\n }\n \n /* for when given an incompatible bit of AST */\n-fn match_error(cx: &ext_ctxt, m: &matchable, expected: &str) -> ! {\n-    let expected = istr::from_estr(expected);\n+fn match_error(cx: &ext_ctxt, m: &matchable, expected: &istr) -> ! {\n     alt m {\n       match_expr(x) {\n         cx.span_fatal(x.span,\n@@ -355,7 +354,7 @@ fn transcribe_ident(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n                     i: &ident, _fld: ast_fold) -> ident {\n     ret alt follow_for_trans(cx, b.find(i), idx_path) {\n           some(match_ident(a_id)) { a_id.node }\n-          some(m) { match_error(cx, m, \"an identifier\") }\n+          some(m) { match_error(cx, m, ~\"an identifier\") }\n           none. { i }\n         }\n }\n@@ -370,7 +369,7 @@ fn transcribe_path(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n             {global: false, idents: [id.node], types: []}\n           }\n           some(match_path(a_pth)) { a_pth.node }\n-          some(m) { match_error(cx, m, \"a path\") }\n+          some(m) { match_error(cx, m, ~\"a path\") }\n           none. { p }\n         }\n }\n@@ -395,7 +394,7 @@ fn transcribe_expr(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n               }\n               some(match_path(a_pth)) { expr_path(a_pth) }\n               some(match_expr(a_exp)) { a_exp.node }\n-              some(m) { match_error(cx, m, \"an expression\") }\n+              some(m) { match_error(cx, m, ~\"an expression\") }\n               none. { orig(e, fld) }\n             }\n           }\n@@ -412,7 +411,7 @@ fn transcribe_type(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n               some(id) {\n                 alt follow_for_trans(cx, b.find(id), idx_path) {\n                   some(match_ty(ty)) { ty.node }\n-                  some(m) { match_error(cx, m, \"a type\") }\n+                  some(m) { match_error(cx, m, ~\"a type\") }\n                   none. { orig(t, fld) }\n                 }\n               }\n@@ -439,7 +438,7 @@ fn transcribe_block(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n \n               // possibly allow promotion of ident/path/expr to blocks?\n               some(m) {\n-                match_error(cx, m, \"a block\")\n+                match_error(cx, m, ~\"a block\")\n               }\n               none. { orig(blk, fld) }\n             }\n@@ -564,13 +563,13 @@ fn p_t_s_r_mac(cx: &ext_ctxt, mac: &ast::mac, s: &selector, b: &binders) {\n               _ { cx.bug(~\"broken traversal in p_t_s_r\") }\n             }\n     }\n-    fn no_des(cx: &ext_ctxt, sp: &span, syn: &str) -> ! {\n+    fn no_des(cx: &ext_ctxt, sp: &span, syn: &istr) -> ! {\n         cx.span_fatal(sp, ~\"destructuring \"\n-                      + istr::from_estr(syn) + ~\" is not yet supported\");\n+                      + syn + ~\" is not yet supported\");\n     }\n     alt mac.node {\n       ast::mac_ellipsis. { cx.span_fatal(mac.span, ~\"misused `...`\"); }\n-      ast::mac_invoc(_, _, _) { no_des(cx, mac.span, \"macro calls\"); }\n+      ast::mac_invoc(_, _, _) { no_des(cx, mac.span, ~\"macro calls\"); }\n       ast::mac_embed_type(ty) {\n         alt ty.node {\n           ast::ty_path(pth, _) {\n@@ -587,10 +586,10 @@ fn p_t_s_r_mac(cx: &ext_ctxt, mac: &ast::mac, s: &selector, b: &binders) {\n                 b.real_binders.insert(\n                     id, compose_sels(s, final_step));\n               }\n-              none. { no_des(cx, pth.span, \"under `#<>`\"); }\n+              none. { no_des(cx, pth.span, ~\"under `#<>`\"); }\n             }\n           }\n-          _ { no_des(cx, ty.span, \"under `#<>`\"); }\n+          _ { no_des(cx, ty.span, ~\"under `#<>`\"); }\n         }\n       }\n       ast::mac_embed_block(blk) {\n@@ -608,7 +607,7 @@ fn p_t_s_r_mac(cx: &ext_ctxt, mac: &ast::mac, s: &selector, b: &binders) {\n             b.real_binders.insert(id,\n                                   compose_sels(s, final_step));\n           }\n-          none. { no_des(cx, blk.span, \"under `#{}`\"); }\n+          none. { no_des(cx, blk.span, ~\"under `#{}`\"); }\n         }\n       }\n     }"}, {"sha": "667a0f27fb8b8374c5d9edcac190d59f5a7ca49a", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f57a508af9c43adc03a4edd575ceae41cc8cd3a/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=5f57a508af9c43adc03a4edd575ceae41cc8cd3a", "patch": "@@ -102,7 +102,7 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> istr {\n     }\n     alt cname(cx, typ) {\n       some(cs) {\n-        ret istr::from_estr(cs);\n+        ret cs;\n       }\n       _ { }\n     }"}]}