{"sha": "d6e3fa8f4947b6b0a93f098c277731a42d452d7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZTNmYThmNDk0N2I2YjBhOTNmMDk4YzI3NzczMWE0MmQ0NTJkN2U=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-06-29T18:41:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-29T18:41:03Z"}, "message": "Merge pull request #1032 from Manishearth/mut_mut\n\nImprove `mut_mut` and `collapsible_if`", "tree": {"sha": "bd9b52fc6dc4c5f385644c1383c5d2842f31c126", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd9b52fc6dc4c5f385644c1383c5d2842f31c126"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6e3fa8f4947b6b0a93f098c277731a42d452d7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6e3fa8f4947b6b0a93f098c277731a42d452d7e", "html_url": "https://github.com/rust-lang/rust/commit/d6e3fa8f4947b6b0a93f098c277731a42d452d7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6e3fa8f4947b6b0a93f098c277731a42d452d7e/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f6b982bc945ae2f2ee9f8d2629c5efb18f7daf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f6b982bc945ae2f2ee9f8d2629c5efb18f7daf1", "html_url": "https://github.com/rust-lang/rust/commit/5f6b982bc945ae2f2ee9f8d2629c5efb18f7daf1"}, {"sha": "9e76bcee5dd40ecc012ba3ad2b42fd6bc4f22fa8", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e76bcee5dd40ecc012ba3ad2b42fd6bc4f22fa8", "html_url": "https://github.com/rust-lang/rust/commit/9e76bcee5dd40ecc012ba3ad2b42fd6bc4f22fa8"}], "stats": {"total": 349, "additions": 251, "deletions": 98}, "files": [{"sha": "cfcc2d6bc328b62e1ca13e166ea0dc9b99edec8a", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6e3fa8f4947b6b0a93f098c277731a42d452d7e/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/d6e3fa8f4947b6b0a93f098c277731a42d452d7e/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=d6e3fa8f4947b6b0a93f098c277731a42d452d7e", "patch": "@@ -5,6 +5,7 @@ All notable changes to this project will be documented in this file.\n * New lints: [`wrong_transmute`]\n * For compatibility, `cargo clippy` does not defines the `clippy` feature\n   introduced in 0.0.76 anymore\n+* [`collapsible_if`] now considers `if let`\n \n ## 0.0.77 \u2014 2016-06-21\n * Rustup to *rustc 1.11.0-nightly (5522e678b 2016-06-20)*"}, {"sha": "2921bc2769c25f1da6f148dbafa439b54d35fa71", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 60, "deletions": 34, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/d6e3fa8f4947b6b0a93f098c277731a42d452d7e/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e3fa8f4947b6b0a93f098c277731a42d452d7e/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=d6e3fa8f4947b6b0a93f098c277731a42d452d7e", "patch": "@@ -13,9 +13,9 @@\n //! This lint is **warn** by default\n \n use rustc::lint::*;\n-use rustc::hir::*;\n use std::borrow::Cow;\n use syntax::codemap::Spanned;\n+use syntax::ast;\n \n use utils::{in_macro, snippet, snippet_block, span_lint_and_then};\n \n@@ -45,66 +45,92 @@ impl LintPass for CollapsibleIf {\n     }\n }\n \n-impl LateLintPass for CollapsibleIf {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl EarlyLintPass for CollapsibleIf {\n+    fn check_expr(&mut self, cx: &EarlyContext, expr: &ast::Expr) {\n         if !in_macro(cx, expr.span) {\n             check_if(cx, expr)\n         }\n     }\n }\n \n-fn check_if(cx: &LateContext, e: &Expr) {\n-    if let ExprIf(ref check, ref then, ref else_) = e.node {\n-        if let Some(ref else_) = *else_ {\n-            if_let_chain! {[\n-                let ExprBlock(ref block) = else_.node,\n-                block.stmts.is_empty(),\n-                block.rules == BlockCheckMode::DefaultBlock,\n-                let Some(ref else_) = block.expr,\n-                let ExprIf(_, _, _) = else_.node\n-            ], {\n+fn check_if(cx: &EarlyContext, expr: &ast::Expr) {\n+    match expr.node {\n+        ast::ExprKind::If(ref check, ref then, ref else_) => {\n+            if let Some(ref else_) = *else_ {\n+                check_collapsible_maybe_if_let(cx, else_);\n+            } else {\n+                check_collapsible_no_if_let(cx, expr, check, then);\n+            }\n+        }\n+        ast::ExprKind::IfLet(_, _, _, Some(ref else_)) => {\n+            check_collapsible_maybe_if_let(cx, else_);\n+        }\n+        _ => (),\n+    }\n+}\n+\n+fn check_collapsible_maybe_if_let(cx: &EarlyContext, else_: &ast::Expr) {\n+    if_let_chain! {[\n+        let ast::ExprKind::Block(ref block) = else_.node,\n+        block.stmts.is_empty(),\n+        let Some(ref else_) = block.expr,\n+    ], {\n+        match else_.node {\n+            ast::ExprKind::If(..) | ast::ExprKind::IfLet(..) => {\n                 span_lint_and_then(cx,\n                                    COLLAPSIBLE_IF,\n                                    block.span,\n                                    \"this `else { if .. }` block can be collapsed\", |db| {\n                     db.span_suggestion(block.span, \"try\", snippet_block(cx, else_.span, \"..\").into_owned());\n                 });\n-            }}\n-        } else if let Some(&Expr { node: ExprIf(ref check_inner, ref content, None), span: sp, .. }) =\n-               single_stmt_of_block(then) {\n-            if e.span.expn_id != sp.expn_id {\n-                return;\n             }\n-            span_lint_and_then(cx, COLLAPSIBLE_IF, e.span, \"this if statement can be collapsed\", |db| {\n-                db.span_suggestion(e.span,\n-                                   \"try\",\n-                                   format!(\"if {} && {} {}\",\n-                                           check_to_string(cx, check),\n-                                           check_to_string(cx, check_inner),\n-                                           snippet_block(cx, content.span, \"..\")));\n-            });\n+            _ => (),\n         }\n-    }\n+    }}\n+}\n+\n+fn check_collapsible_no_if_let(\n+    cx: &EarlyContext,\n+    expr: &ast::Expr,\n+    check: &ast::Expr,\n+    then: &ast::Block,\n+) {\n+    if_let_chain! {[\n+        let Some(inner) = single_stmt_of_block(then),\n+        let ast::ExprKind::If(ref check_inner, ref content, None) = inner.node,\n+    ], {\n+        if expr.span.expn_id != inner.span.expn_id {\n+            return;\n+        }\n+        span_lint_and_then(cx, COLLAPSIBLE_IF, expr.span, \"this if statement can be collapsed\", |db| {\n+            db.span_suggestion(expr.span,\n+                               \"try\",\n+                               format!(\"if {} && {} {}\",\n+                                       check_to_string(cx, check),\n+                                       check_to_string(cx, check_inner),\n+                                       snippet_block(cx, content.span, \"..\")));\n+        });\n+    }}\n }\n \n-fn requires_brackets(e: &Expr) -> bool {\n+fn requires_brackets(e: &ast::Expr) -> bool {\n     match e.node {\n-        ExprBinary(Spanned { node: n, .. }, _, _) if n == BiEq => false,\n+        ast::ExprKind::Binary(Spanned { node: n, .. }, _, _) if n == ast::BinOpKind::Eq => false,\n         _ => true,\n     }\n }\n \n-fn check_to_string(cx: &LateContext, e: &Expr) -> Cow<'static, str> {\n+fn check_to_string(cx: &EarlyContext, e: &ast::Expr) -> Cow<'static, str> {\n     if requires_brackets(e) {\n         format!(\"({})\", snippet(cx, e.span, \"..\")).into()\n     } else {\n         snippet(cx, e.span, \"..\")\n     }\n }\n \n-fn single_stmt_of_block(block: &Block) -> Option<&Expr> {\n+fn single_stmt_of_block(block: &ast::Block) -> Option<&ast::Expr> {\n     if block.stmts.len() == 1 && block.expr.is_none() {\n-        if let StmtExpr(ref expr, _) = block.stmts[0].node {\n+        if let ast::StmtKind::Expr(ref expr, _) = block.stmts[0].node {\n             single_stmt_of_expr(expr)\n         } else {\n             None\n@@ -120,8 +146,8 @@ fn single_stmt_of_block(block: &Block) -> Option<&Expr> {\n     }\n }\n \n-fn single_stmt_of_expr(expr: &Expr) -> Option<&Expr> {\n-    if let ExprBlock(ref block) = expr.node {\n+fn single_stmt_of_expr(expr: &ast::Expr) -> Option<&ast::Expr> {\n+    if let ast::ExprKind::Block(ref block) = expr.node {\n         single_stmt_of_block(block)\n     } else {\n         Some(expr)"}, {"sha": "e980f4d081dfd0deaf1c4334ddba5089f40a3177", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6e3fa8f4947b6b0a93f098c277731a42d452d7e/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e3fa8f4947b6b0a93f098c277731a42d452d7e/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=d6e3fa8f4947b6b0a93f098c277731a42d452d7e", "patch": "@@ -189,7 +189,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box len_zero::LenZero);\n     reg.register_late_lint_pass(box misc::CmpOwned);\n     reg.register_late_lint_pass(box attrs::AttrPass);\n-    reg.register_late_lint_pass(box collapsible_if::CollapsibleIf);\n+    reg.register_early_lint_pass(box collapsible_if::CollapsibleIf);\n     reg.register_late_lint_pass(box block_in_if_condition::BlockInIfCondition);\n     reg.register_late_lint_pass(box misc::ModuloOne);\n     reg.register_late_lint_pass(box unicode::Unicode);"}, {"sha": "8d3af7742a94b599ab4ab89da517d7254999a72e", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6e3fa8f4947b6b0a93f098c277731a42d452d7e/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e3fa8f4947b6b0a93f098c277731a42d452d7e/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=d6e3fa8f4947b6b0a93f098c277731a42d452d7e", "patch": "@@ -83,11 +83,9 @@ fn fetch_const(args: &[P<Expr>], m: MinMax) -> Option<(MinMax, Constant, &Expr)>\n         } else {\n             None\n         }\n+    } else if let Some(c) = constant_simple(&args[1]) {\n+        Some((m, c, &args[0]))\n     } else {\n-        if let Some(c) = constant_simple(&args[1]) {\n-            Some((m, c, &args[0]))\n-        } else {\n-            None\n-        }\n+        None\n     }\n }"}, {"sha": "8a5439fb11e316d05101dec89bc21c9e2857800f", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 45, "deletions": 18, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d6e3fa8f4947b6b0a93f098c277731a42d452d7e/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e3fa8f4947b6b0a93f098c277731a42d452d7e/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=d6e3fa8f4947b6b0a93f098c277731a42d452d7e", "patch": "@@ -1,7 +1,8 @@\n+use rustc::hir;\n+use rustc::hir::intravisit;\n use rustc::lint::*;\n use rustc::ty::{TypeAndMut, TyRef};\n-use rustc::hir::*;\n-use utils::{in_external_macro, span_lint};\n+use utils::{in_external_macro, recover_for_loop, span_lint};\n \n /// **What it does:** This lint checks for instances of `mut mut` references.\n ///\n@@ -27,30 +28,56 @@ impl LintPass for MutMut {\n }\n \n impl LateLintPass for MutMut {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if in_external_macro(cx, expr.span) {\n+    fn check_block(&mut self, cx: &LateContext, block: &hir::Block) {\n+        intravisit::walk_block(&mut MutVisitor { cx: cx }, block);\n+    }\n+\n+    fn check_ty(&mut self, cx: &LateContext, ty: &hir::Ty) {\n+        use rustc::hir::intravisit::Visitor;\n+\n+        MutVisitor { cx: cx }.visit_ty(ty);\n+    }\n+}\n+\n+pub struct MutVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+}\n+\n+impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for MutVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'v hir::Expr) {\n+        if in_external_macro(self.cx, expr.span) {\n             return;\n         }\n \n-        if let ExprAddrOf(MutMutable, ref e) = expr.node {\n-            if let ExprAddrOf(MutMutable, _) = e.node {\n-                span_lint(cx, MUT_MUT, expr.span, \"generally you want to avoid `&mut &mut _` if possible\");\n-            } else {\n-                if let TyRef(_, TypeAndMut { mutbl: MutMutable, .. }) = cx.tcx.expr_ty(e).sty {\n-                    span_lint(cx,\n-                              MUT_MUT,\n-                              expr.span,\n-                              \"this expression mutably borrows a mutable reference. Consider reborrowing\");\n-                }\n+        if let Some((_, arg, body)) = recover_for_loop(expr) {\n+            // A `for` loop lowers to:\n+            // ```rust\n+            // match ::std::iter::Iterator::next(&mut iter) {\n+            // //                                ^^^^\n+            // ```\n+            // Let's ignore the generated code.\n+            intravisit::walk_expr(self, arg);\n+            intravisit::walk_expr(self, body);\n+        } else if let hir::ExprAddrOf(hir::MutMutable, ref e) = expr.node {\n+            if let hir::ExprAddrOf(hir::MutMutable, _) = e.node {\n+                span_lint(self.cx, MUT_MUT, expr.span, \"generally you want to avoid `&mut &mut _` if possible\");\n+            } else if let TyRef(_, TypeAndMut { mutbl: hir::MutMutable, .. }) = self.cx.tcx.expr_ty(e).sty {\n+                span_lint(self.cx,\n+                          MUT_MUT,\n+                          expr.span,\n+                          \"this expression mutably borrows a mutable reference. Consider reborrowing\");\n             }\n         }\n     }\n \n-    fn check_ty(&mut self, cx: &LateContext, ty: &Ty) {\n-        if let TyRptr(_, MutTy { ty: ref pty, mutbl: MutMutable }) = ty.node {\n-            if let TyRptr(_, MutTy { mutbl: MutMutable, .. }) = pty.node {\n-                span_lint(cx, MUT_MUT, ty.span, \"generally you want to avoid `&mut &mut _` if possible\");\n+    fn visit_ty(&mut self, ty: &hir::Ty) {\n+        if let hir::TyRptr(_, hir::MutTy { ty: ref pty, mutbl: hir::MutMutable }) = ty.node {\n+            if let hir::TyRptr(_, hir::MutTy { mutbl: hir::MutMutable, .. }) = pty.node {\n+                span_lint(self.cx, MUT_MUT, ty.span, \"generally you want to avoid `&mut &mut _` if possible\");\n             }\n+\n         }\n+\n+        intravisit::walk_ty(self, ty);\n     }\n }"}, {"sha": "ea2ef284f38fd82524e872172e210f3f3490c2de", "filename": "tests/compile-fail/collapsible_if.rs", "status": "modified", "additions": 75, "deletions": 6, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d6e3fa8f4947b6b0a93f098c277731a42d452d7e/tests%2Fcompile-fail%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e3fa8f4947b6b0a93f098c277731a42d452d7e/tests%2Fcompile-fail%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcollapsible_if.rs?ref=d6e3fa8f4947b6b0a93f098c277731a42d452d7e", "patch": "@@ -26,19 +26,32 @@ fn main() {\n     // Collaspe `else { if .. }` to `else if ..`\n     if x == \"hello\" {\n         print!(\"Hello \");\n-    } else { //~ERROR: this `else { if .. }`\n-             //~| HELP try\n-             //~| SUGGESTION } else if y == \"world\"\n+    } else {\n+        //~^ ERROR: this `else { if .. }`\n+        //~| HELP try\n+        //~| SUGGESTION } else if y == \"world\"\n         if y == \"world\" {\n             println!(\"world!\")\n         }\n     }\n \n     if x == \"hello\" {\n         print!(\"Hello \");\n-    } else { //~ERROR this `else { if .. }`\n-             //~| HELP try\n-             //~| SUGGESTION } else if y == \"world\"\n+    } else {\n+        //~^ ERROR: this `else { if .. }`\n+        //~| HELP try\n+        //~| SUGGESTION } else if let Some(42)\n+        if let Some(42) = Some(42) {\n+            println!(\"world!\")\n+        }\n+    }\n+\n+    if x == \"hello\" {\n+        print!(\"Hello \");\n+    } else {\n+        //~^ ERROR this `else { if .. }`\n+        //~| HELP try\n+        //~| SUGGESTION } else if y == \"world\"\n         if y == \"world\" {\n             println!(\"world\")\n         }\n@@ -47,6 +60,62 @@ fn main() {\n         }\n     }\n \n+    if x == \"hello\" {\n+        print!(\"Hello \");\n+    } else {\n+        //~^ ERROR this `else { if .. }`\n+        //~| HELP try\n+        //~| SUGGESTION } else if let Some(42)\n+        if let Some(42) = Some(42) {\n+            println!(\"world\")\n+        }\n+        else {\n+            println!(\"!\")\n+        }\n+    }\n+\n+    if let Some(42) = Some(42) {\n+        print!(\"Hello \");\n+    } else {\n+        //~^ ERROR this `else { if .. }`\n+        //~| HELP try\n+        //~| SUGGESTION } else if let Some(42)\n+        if let Some(42) = Some(42) {\n+            println!(\"world\")\n+        }\n+        else {\n+            println!(\"!\")\n+        }\n+    }\n+\n+    if let Some(42) = Some(42) {\n+        print!(\"Hello \");\n+    } else {\n+        //~^ ERROR this `else { if .. }`\n+        //~| HELP try\n+        //~| SUGGESTION } else if x == \"hello\"\n+        if x == \"hello\" {\n+            println!(\"world\")\n+        }\n+        else {\n+            println!(\"!\")\n+        }\n+    }\n+\n+    if let Some(42) = Some(42) {\n+        print!(\"Hello \");\n+    } else {\n+        //~^ ERROR this `else { if .. }`\n+        //~| HELP try\n+        //~| SUGGESTION } else if let Some(42)\n+        if let Some(42) = Some(42) {\n+            println!(\"world\")\n+        }\n+        else {\n+            println!(\"!\")\n+        }\n+    }\n+\n     // Works because any if with an else statement cannot be collapsed.\n     if x == \"hello\" {\n         if y == \"world\" {"}, {"sha": "2fd8c766d92886c11100d7b8571d82fed8eb049c", "filename": "tests/compile-fail/copies.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6e3fa8f4947b6b0a93f098c277731a42d452d7e/tests%2Fcompile-fail%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e3fa8f4947b6b0a93f098c277731a42d452d7e/tests%2Fcompile-fail%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopies.rs?ref=d6e3fa8f4947b6b0a93f098c277731a42d452d7e", "patch": "@@ -8,6 +8,7 @@\n #![allow(unused_variables)]\n #![allow(cyclomatic_complexity)]\n #![allow(blacklisted_name)]\n+#![allow(collapsible_if)]\n \n fn bar<T>(_: T) {}\n fn foo() -> bool { unimplemented!() }"}, {"sha": "989106a5a16efb8d410090c0499b779f90ef81a0", "filename": "tests/compile-fail/matches.rs", "status": "modified", "additions": 41, "deletions": 31, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d6e3fa8f4947b6b0a93f098c277731a42d452d7e/tests%2Fcompile-fail%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e3fa8f4947b6b0a93f098c277731a42d452d7e/tests%2Fcompile-fail%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatches.rs?ref=d6e3fa8f4947b6b0a93f098c277731a42d452d7e", "patch": "@@ -18,34 +18,38 @@ enum ExprNode {\n \n static NODE: ExprNode = ExprNode::Unicorns;\n \n+fn dummy() {\n+}\n+\n fn unwrap_addr() -> Option<&'static ExprNode> {\n-    match ExprNode::Butterflies {   //~ ERROR you seem to be trying to use match\n-                                    //~^ HELP try\n+    match ExprNode::Butterflies {\n+        //~^ ERROR you seem to be trying to use match\n+        //~| HELP try\n+        //~| SUGGESTION if let ExprNode::ExprAddrOf = ExprNode::Butterflies { Some(&NODE) } else { let x = 5; None }\n         ExprNode::ExprAddrOf => Some(&NODE),\n-        _ => {\n-            let x = 5;\n-            None\n-        },\n+        _ => { let x = 5; None },\n     }\n }\n \n fn single_match(){\n     let x = Some(1u8);\n \n-    match x {  //~ ERROR you seem to be trying to use match\n-               //~^ HELP try\n-        Some(y) => {\n-            println!(\"{:?}\", y);\n-        }\n+    match x {\n+        //~^ ERROR you seem to be trying to use match\n+        //~| HELP try\n+        //~| SUGGESTION if let Some(y) = x { println!(\"{:?}\", y); };\n+        Some(y) => { println!(\"{:?}\", y); }\n         _ => ()\n-    }\n+    };\n \n     let z = (1u8,1u8);\n-    match z { //~ ERROR you seem to be trying to use match\n-              //~^ HELP try\n-        (2...3, 7...9) => println!(\"{:?}\", z),\n+    match z {\n+        //~^ ERROR you seem to be trying to use match\n+        //~| HELP try\n+        //~| SUGGESTION if let (2...3, 7...9) = z { dummy() };\n+        (2...3, 7...9) => dummy(),\n         _ => {}\n-    }\n+    };\n \n     // Not linted (pattern guards used)\n     match x {\n@@ -64,25 +68,31 @@ fn single_match_know_enum() {\n     let x = Some(1u8);\n     let y : Result<_, i8> = Ok(1i8);\n \n-    match x { //~ ERROR you seem to be trying to use match\n-              //~^ HELP try\n-        Some(y) => println!(\"{:?}\", y),\n+    match x {\n+        //~^ ERROR you seem to be trying to use match\n+        //~| HELP try\n+        //~| SUGGESTION if let Some(y) = x { dummy() };\n+        Some(y) => dummy(),\n         None => ()\n-    }\n+    };\n \n-    match y { //~ ERROR you seem to be trying to use match\n-              //~^ HELP try\n-        Ok(y) => println!(\"{:?}\", y),\n+    match y {\n+        //~^ ERROR you seem to be trying to use match\n+        //~| HELP try\n+        //~| SUGGESTION if let Ok(y) = y { dummy() };\n+        Ok(y) => dummy(),\n         Err(..) => ()\n-    }\n+    };\n \n     let c = Cow::Borrowed(\"\");\n \n-    match c { //~ ERROR you seem to be trying to use match\n-              //~^ HELP try\n-        Cow::Borrowed(..) => println!(\"42\"),\n+    match c {\n+        //~^ ERROR you seem to be trying to use match\n+        //~| HELP try\n+        //~| SUGGESTION if let Cow::Borrowed(..) = c { dummy() };\n+        Cow::Borrowed(..) => dummy(),\n         Cow::Owned(..) => (),\n-    }\n+    };\n \n     let z = Foo::Bar;\n     // no warning\n@@ -209,19 +219,19 @@ fn overlapping() {\n \n     match 42 {\n         0 ... 10 => println!(\"0 ... 10\"), //~ERROR: some ranges overlap\n-        0 ... 11 => println!(\"0 ... 10\"),\n+        0 ... 11 => println!(\"0 ... 10\"), //~NOTE overlaps with this\n         _ => (),\n     }\n \n     match 42 {\n         0 ... 5 => println!(\"0 ... 5\"), //~ERROR: some ranges overlap\n         6 ... 7 => println!(\"6 ... 7\"),\n-        FOO ... 11 => println!(\"0 ... 10\"),\n+        FOO ... 11 => println!(\"0 ... 10\"), //~NOTE overlaps with this\n         _ => (),\n     }\n \n     match 42 {\n-        2 => println!(\"2\"),\n+        2 => println!(\"2\"), //~NOTE overlaps with this\n         0 ... 5 => println!(\"0 ... 5\"), //~ERROR: some ranges overlap\n         _ => (),\n     }"}, {"sha": "edcc6906f082827a702f9583479e40198ef92bfc", "filename": "tests/compile-fail/mut_mut.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d6e3fa8f4947b6b0a93f098c277731a42d452d7e/tests%2Fcompile-fail%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6e3fa8f4947b6b0a93f098c277731a42d452d7e/tests%2Fcompile-fail%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmut_mut.rs?ref=d6e3fa8f4947b6b0a93f098c277731a42d452d7e", "patch": "@@ -2,16 +2,15 @@\n #![plugin(clippy)]\n \n #![allow(unused, no_effect, unnecessary_operation)]\n+#![deny(mut_mut)]\n \n //#![plugin(regex_macros)]\n //extern crate regex;\n \n-#[deny(mut_mut)]\n fn fun(x : &mut &mut u32) -> bool { //~ERROR generally you want to avoid `&mut &mut\n     **x > 0\n }\n \n-#[deny(mut_mut)]\n fn less_fun(x : *mut *mut u32) {\n   let y = x;\n }\n@@ -21,23 +20,45 @@ macro_rules! mut_ptr {\n     //~^ ERROR generally you want to avoid `&mut &mut\n }\n \n-#[deny(mut_mut)]\n #[allow(unused_mut, unused_variables)]\n fn main() {\n     let mut x = &mut &mut 1u32; //~ERROR generally you want to avoid `&mut &mut\n     {\n         let mut y = &mut x; //~ERROR this expression mutably borrows a mutable reference\n     }\n \n+    if fun(x) {\n+        let y : &mut &mut u32 = &mut &mut 2;\n+        //~^ ERROR generally you want to avoid `&mut &mut\n+        //~| ERROR generally you want to avoid `&mut &mut\n+        //~| ERROR generally you want to avoid `&mut &mut\n+        **y + **x;\n+    }\n+\n     if fun(x) {\n         let y : &mut &mut &mut u32 = &mut &mut &mut 2;\n         //~^ ERROR generally you want to avoid `&mut &mut\n         //~| ERROR generally you want to avoid `&mut &mut\n         //~| ERROR generally you want to avoid `&mut &mut\n         //~| ERROR generally you want to avoid `&mut &mut\n+        //~| ERROR generally you want to avoid `&mut &mut\n+        //~| ERROR generally you want to avoid `&mut &mut\n         ***y + **x;\n     }\n \n     let mut z = mut_ptr!(&mut 3u32);\n     //~^ NOTE in this expansion of mut_ptr!\n }\n+\n+fn issue939() {\n+    let array = [5, 6, 7, 8, 9];\n+    let mut args = array.iter().skip(2);\n+    for &arg in &mut args {\n+        println!(\"{}\", arg);\n+    }\n+\n+    let args = &mut args;\n+    for arg in args {\n+        println!(\":{}\", arg);\n+    }\n+}"}]}