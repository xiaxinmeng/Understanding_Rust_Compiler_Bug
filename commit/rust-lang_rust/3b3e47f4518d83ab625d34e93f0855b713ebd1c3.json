{"sha": "3b3e47f4518d83ab625d34e93f0855b713ebd1c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiM2U0N2Y0NTE4ZDgzYWI2MjVkMzRlOTNmMDg1NWI3MTNlYmQxYzM=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-05-10T06:55:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-10T06:55:36Z"}, "message": "Merge pull request #1738 from Manishearth/serde\n\nUpdate serde to 1.0", "tree": {"sha": "e86d1e3a290d0413bf0908129705c337fce30ce6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e86d1e3a290d0413bf0908129705c337fce30ce6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b3e47f4518d83ab625d34e93f0855b713ebd1c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b3e47f4518d83ab625d34e93f0855b713ebd1c3", "html_url": "https://github.com/rust-lang/rust/commit/3b3e47f4518d83ab625d34e93f0855b713ebd1c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dee53fa1e2881a8e461c39176318b62dac7045a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/dee53fa1e2881a8e461c39176318b62dac7045a1", "html_url": "https://github.com/rust-lang/rust/commit/dee53fa1e2881a8e461c39176318b62dac7045a1"}, {"sha": "f48281b6322bda4e10dbd249ae6f89280ab71b13", "url": "https://api.github.com/repos/rust-lang/rust/commits/f48281b6322bda4e10dbd249ae6f89280ab71b13", "html_url": "https://github.com/rust-lang/rust/commit/f48281b6322bda4e10dbd249ae6f89280ab71b13"}], "stats": {"total": 348, "additions": 169, "deletions": 179}, "files": [{"sha": "f830aeabe6f7402a61f0963efd1a8ba79ee3429b", "filename": "Cargo.toml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=3b3e47f4518d83ab625d34e93f0855b713ebd1c3", "patch": "@@ -32,15 +32,15 @@ test = false\n # begin automatic update\n clippy_lints = { version = \"0.0.131\", path = \"clippy_lints\" }\n # end automatic update\n-cargo_metadata = \"0.1.1\"\n+cargo_metadata = \"0.2\"\n \n [dev-dependencies]\n compiletest_rs = \"0.2.5\"\n-lazy_static = \"0.1.15\"\n+lazy_static = \"0.2\"\n regex = \"0.2\"\n-serde_derive = \"0.9.1\"\n+serde_derive = \"1.0\"\n clippy-mini-macro-test = { version = \"0.1\", path = \"mini-macro\" }\n-serde = \"0.9.1\"\n+serde = \"1.0\"\n \n [features]\n debugging = []"}, {"sha": "ed5b1e61b923ec300263641a1f15cb7df95fdf5f", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=3b3e47f4518d83ab625d34e93f0855b713ebd1c3", "patch": "@@ -19,9 +19,12 @@ keywords = [\"clippy\", \"lint\", \"plugin\"]\n matches = \"0.1.2\"\n regex-syntax = \"0.4.0\"\n semver = \"0.6.0\"\n-toml = \"0.2\"\n+toml = \"0.4\"\n unicode-normalization = \"0.1\"\n quine-mc_cluskey = \"0.2.2\"\n+serde = \"1.0\"\n+serde_derive = \"1.0\"\n+lazy_static = \"0.2.8\"\n \n [features]\n debugging = []"}, {"sha": "fb0114f8f683ae0e1fffac08763de6fac8921c7d", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=3b3e47f4518d83ab625d34e93f0855b713ebd1c3", "patch": "@@ -44,6 +44,13 @@ extern crate rustc_const_math;\n #[macro_use]\n extern crate matches as matches_macro;\n \n+#[macro_use]\n+extern crate serde_derive;\n+extern crate serde;\n+\n+#[macro_use]\n+extern crate lazy_static;\n+\n macro_rules! declare_restriction_lint {\n     { pub $name:tt, $description:tt } => {\n         declare_lint! { pub $name, Allow, $description }\n@@ -124,7 +131,7 @@ pub mod ranges;\n pub mod reference;\n pub mod regex;\n pub mod returns;\n-pub mod serde;\n+pub mod serde_api;\n pub mod shadow;\n pub mod should_assert_eq;\n pub mod strings;\n@@ -175,7 +182,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n             reg.sess.struct_span_err(span, err)\n                     .span_note(span, \"Clippy will use default configuration\")\n                     .emit();\n-            utils::conf::Conf::default()\n+            toml::from_str(\"\").expect(\"we never error on empty config files\")\n         }\n     };\n \n@@ -202,7 +209,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     );\n     // end deprecated lints, do not remove this comment, it\u2019s used in `update_lints`\n \n-    reg.register_late_lint_pass(box serde::Serde);\n+    reg.register_late_lint_pass(box serde_api::Serde);\n     reg.register_early_lint_pass(box utils::internal_lints::Clippy);\n     reg.register_late_lint_pass(box utils::internal_lints::LintWithoutLintPass::default());\n     reg.register_late_lint_pass(box utils::inspector::Pass);\n@@ -266,7 +273,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box print::Pass);\n     reg.register_late_lint_pass(box vec::Pass);\n     reg.register_early_lint_pass(box non_expressive_names::NonExpressiveNames {\n-        max_single_char_names: conf.max_single_char_names,\n+        single_char_binding_names_threshold: conf.single_char_binding_names_threshold,\n     });\n     reg.register_late_lint_pass(box drop_forget_ref::Pass);\n     reg.register_late_lint_pass(box empty_enum::EmptyEnum);\n@@ -488,7 +495,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         regex::TRIVIAL_REGEX,\n         returns::LET_AND_RETURN,\n         returns::NEEDLESS_RETURN,\n-        serde::SERDE_API_MISUSE,\n+        serde_api::SERDE_API_MISUSE,\n         should_assert_eq::SHOULD_ASSERT_EQ,\n         strings::STRING_LIT_AS_BYTES,\n         swap::ALMOST_SWAPPED,"}, {"sha": "dc5c34e33ebc80690ca260fa74042b2e214ebcd1", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 80, "deletions": 73, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=3b3e47f4518d83ab625d34e93f0855b713ebd1c3", "patch": "@@ -4,7 +4,7 @@ use std::char;\n use syntax::ast::*;\n use syntax::codemap::Span;\n use syntax::visit::FnKind;\n-use utils::{constants, span_lint, span_help_and_lint, snippet, snippet_opt, span_lint_and_then};\n+use utils::{constants, span_lint, span_help_and_lint, snippet, snippet_opt, span_lint_and_then, in_external_macro};\n \n /// **What it does:** Checks for structure field patterns bound to wildcards.\n ///\n@@ -267,6 +267,9 @@ impl EarlyLintPass for MiscEarly {\n     }\n \n     fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n+        if in_external_macro(cx, expr.span) {\n+            return;\n+        }\n         match expr.node {\n             ExprKind::Call(ref paren, _) => {\n                 if let ExprKind::Paren(ref closure) = paren.node {\n@@ -290,78 +293,7 @@ impl EarlyLintPass for MiscEarly {\n                               \"`--x` could be misinterpreted as pre-decrement by C programmers, is usually a no-op\");\n                 }\n             },\n-            ExprKind::Lit(ref lit) => {\n-                if_let_chain! {[\n-                    let LitKind::Int(value, ..) = lit.node,\n-                    let Some(src) = snippet_opt(cx, lit.span),\n-                    let Some(firstch) = src.chars().next(),\n-                    char::to_digit(firstch, 10).is_some()\n-                ], {\n-                    let mut prev = '\\0';\n-                    for ch in src.chars() {\n-                        if ch == 'i' || ch == 'u' {\n-                            if prev != '_' {\n-                                span_lint(cx, UNSEPARATED_LITERAL_SUFFIX, lit.span,\n-                                          \"integer type suffix should be separated by an underscore\");\n-                            }\n-                            break;\n-                        }\n-                        prev = ch;\n-                    }\n-                    if src.starts_with(\"0x\") {\n-                        let mut seen = (false, false);\n-                        for ch in src.chars() {\n-                            match ch {\n-                                'a' ... 'f' => seen.0 = true,\n-                                'A' ... 'F' => seen.1 = true,\n-                                'i' | 'u'   => break,   // start of suffix already\n-                                _ => ()\n-                            }\n-                        }\n-                        if seen.0 && seen.1 {\n-                            span_lint(cx, MIXED_CASE_HEX_LITERALS, lit.span,\n-                                      \"inconsistent casing in hexadecimal literal\");\n-                        }\n-                    } else if src.starts_with(\"0b\") || src.starts_with(\"0o\") {\n-                        /* nothing to do */\n-                    } else if value != 0 && src.starts_with('0') {\n-                        span_lint_and_then(cx,\n-                                           ZERO_PREFIXED_LITERAL,\n-                                           lit.span,\n-                                           \"this is a decimal constant\",\n-                                           |db| {\n-                            db.span_suggestion(\n-                                lit.span,\n-                                \"if you mean to use a decimal constant, remove the `0` to remove confusion:\",\n-                                src[1..].to_string(),\n-                            );\n-                            /*db.span_suggestion(\n-                                lit.span,\n-                                \"if you mean to use an octal constant, use `0o`:\",\n-                                format!(\"0o{}\", &src[1..]),\n-                            ); FIXME: rustc doesn't support multiple suggestions anymore */\n-                        });\n-                    }\n-                }}\n-                if_let_chain! {[\n-                    let LitKind::Float(..) = lit.node,\n-                    let Some(src) = snippet_opt(cx, lit.span),\n-                    let Some(firstch) = src.chars().next(),\n-                    char::to_digit(firstch, 10).is_some()\n-                ], {\n-                    let mut prev = '\\0';\n-                    for ch in src.chars() {\n-                        if ch == 'f' {\n-                            if prev != '_' {\n-                                span_lint(cx, UNSEPARATED_LITERAL_SUFFIX, lit.span,\n-                                          \"float type suffix should be separated by an underscore\");\n-                            }\n-                            break;\n-                        }\n-                        prev = ch;\n-                    }\n-                }}\n-            },\n+            ExprKind::Lit(ref lit) => self.check_lit(cx, lit),\n             _ => (),\n         }\n     }\n@@ -390,3 +322,78 @@ impl EarlyLintPass for MiscEarly {\n         }\n     }\n }\n+\n+impl MiscEarly {\n+    fn check_lit(&self, cx: &EarlyContext, lit: &Lit) {\n+        if_let_chain! {[\n+            let LitKind::Int(value, ..) = lit.node,\n+            let Some(src) = snippet_opt(cx, lit.span),\n+            let Some(firstch) = src.chars().next(),\n+            char::to_digit(firstch, 10).is_some()\n+        ], {\n+            let mut prev = '\\0';\n+            for ch in src.chars() {\n+                if ch == 'i' || ch == 'u' {\n+                    if prev != '_' {\n+                        span_lint(cx, UNSEPARATED_LITERAL_SUFFIX, lit.span,\n+                                    \"integer type suffix should be separated by an underscore\");\n+                    }\n+                    break;\n+                }\n+                prev = ch;\n+            }\n+            if src.starts_with(\"0x\") {\n+                let mut seen = (false, false);\n+                for ch in src.chars() {\n+                    match ch {\n+                        'a' ... 'f' => seen.0 = true,\n+                        'A' ... 'F' => seen.1 = true,\n+                        'i' | 'u'   => break,   // start of suffix already\n+                        _ => ()\n+                    }\n+                }\n+                if seen.0 && seen.1 {\n+                    span_lint(cx, MIXED_CASE_HEX_LITERALS, lit.span,\n+                                \"inconsistent casing in hexadecimal literal\");\n+                }\n+            } else if src.starts_with(\"0b\") || src.starts_with(\"0o\") {\n+                /* nothing to do */\n+            } else if value != 0 && src.starts_with('0') {\n+                span_lint_and_then(cx,\n+                                    ZERO_PREFIXED_LITERAL,\n+                                    lit.span,\n+                                    \"this is a decimal constant\",\n+                                    |db| {\n+                    db.span_suggestion(\n+                        lit.span,\n+                        \"if you mean to use a decimal constant, remove the `0` to remove confusion:\",\n+                        src[1..].to_string(),\n+                    );\n+                    /*db.span_suggestion(\n+                        lit.span,\n+                        \"if you mean to use an octal constant, use `0o`:\",\n+                        format!(\"0o{}\", &src[1..]),\n+                    ); FIXME: rustc doesn't support multiple suggestions anymore */\n+                });\n+            }\n+        }}\n+        if_let_chain! {[\n+            let LitKind::Float(..) = lit.node,\n+            let Some(src) = snippet_opt(cx, lit.span),\n+            let Some(firstch) = src.chars().next(),\n+            char::to_digit(firstch, 10).is_some()\n+        ], {\n+            let mut prev = '\\0';\n+            for ch in src.chars() {\n+                if ch == 'f' {\n+                    if prev != '_' {\n+                        span_lint(cx, UNSEPARATED_LITERAL_SUFFIX, lit.span,\n+                                    \"float type suffix should be separated by an underscore\");\n+                    }\n+                    break;\n+                }\n+                prev = ch;\n+            }\n+        }}\n+    }\n+}"}, {"sha": "6b97ffee6dbcb2dd0001c094f24b383b199a00f7", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=3b3e47f4518d83ab625d34e93f0855b713ebd1c3", "patch": "@@ -43,7 +43,7 @@ declare_lint! {\n }\n \n pub struct NonExpressiveNames {\n-    pub max_single_char_names: u64,\n+    pub single_char_binding_names_threshold: u64,\n }\n \n impl LintPass for NonExpressiveNames {\n@@ -127,7 +127,7 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n             return;\n         }\n         self.0.single_char_names.push(c);\n-        if self.0.single_char_names.len() as u64 >= self.0.lint.max_single_char_names {\n+        if self.0.single_char_names.len() as u64 >= self.0.lint.single_char_binding_names_threshold {\n             span_lint(self.0.cx,\n                       MANY_SINGLE_CHAR_NAMES,\n                       span,"}, {"sha": "df803473a2a588e1a6d1a43e751973f85cfeba2e", "filename": "clippy_lints/src/serde_api.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/clippy_lints%2Fsrc%2Fserde_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/clippy_lints%2Fsrc%2Fserde_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde_api.rs?ref=3b3e47f4518d83ab625d34e93f0855b713ebd1c3", "previous_filename": "clippy_lints/src/serde.rs"}, {"sha": "772f7f6ad451fdd47d76764a9ee4f4ea625f3ec7", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 62, "deletions": 89, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=3b3e47f4518d83ab625d34e93f0855b713ebd1c3", "patch": "@@ -6,6 +6,7 @@ use std::{env, fmt, fs, io, path};\n use std::io::Read;\n use syntax::{ast, codemap};\n use toml;\n+use std::sync::Mutex;\n \n /// Get the configuration file from arguments.\n pub fn file_from_args(args: &[codemap::Spanned<ast::NestedMetaItemKind>])\n@@ -34,8 +35,8 @@ pub fn file_from_args(args: &[codemap::Spanned<ast::NestedMetaItemKind>])\n pub enum Error {\n     /// An I/O error.\n     Io(io::Error),\n-    /// The file is not valid TOML.\n-    Toml(Vec<toml::ParserError>),\n+    /// Not valid toml or doesn't fit the expected conf format\n+    Toml(String),\n     /// Type error.\n     Type(/// The name of the key.\n          &'static str,\n@@ -51,19 +52,7 @@ impl fmt::Display for Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n         match *self {\n             Error::Io(ref err) => err.fmt(f),\n-            Error::Toml(ref errs) => {\n-                let mut first = true;\n-                for err in errs {\n-                    if !first {\n-                        try!(\", \".fmt(f));\n-                        first = false;\n-                    }\n-\n-                    try!(err.fmt(f));\n-                }\n-\n-                Ok(())\n-            },\n+            Error::Toml(ref err) => err.fmt(f),\n             Error::Type(key, expected, got) => {\n                 write!(f, \"`{}` is expected to be a `{}` but is a `{}`\", key, expected, got)\n             },\n@@ -78,55 +67,45 @@ impl From<io::Error> for Error {\n     }\n }\n \n-macro_rules! define_Conf {\n-    ($(#[$doc: meta] ($toml_name: tt, $rust_name: ident, $default: expr => $($ty: tt)+),)+) => {\n-        /// Type used to store lint configuration.\n-        pub struct Conf {\n-            $(#[$doc] pub $rust_name: define_Conf!(TY $($ty)+),)+\n-        }\n+lazy_static! {\n+    static ref ERRORS: Mutex<Vec<Error>> = Mutex::new(Vec::new());\n+}\n \n-        impl Default for Conf {\n-            fn default() -> Conf {\n-                Conf {\n-                    $($rust_name: define_Conf!(DEFAULT $($ty)+, $default),)+\n-                }\n+macro_rules! define_Conf {\n+    ($(#[$doc: meta] ($rust_name: ident, $rust_name_str: expr, $default: expr => $($ty: tt)+),)+) => {\n+        pub use self::helpers::Conf;\n+        mod helpers {\n+            /// Type used to store lint configuration.\n+            #[derive(Deserialize)]\n+            #[serde(rename_all=\"kebab-case\")]\n+            #[serde(deny_unknown_fields)]\n+            pub struct Conf {\n+                $(#[$doc] #[serde(default=$rust_name_str)] #[serde(with=$rust_name_str)] pub $rust_name: define_Conf!(TY $($ty)+),)+\n+                #[allow(dead_code)]\n+                #[serde(default)]\n+                third_party: Option<::toml::Value>,\n             }\n-        }\n-\n-        impl Conf {\n-            /// Set the property `name` (which must be the `toml` name) to the given value\n-            #[allow(cast_sign_loss)]\n-            fn set(&mut self, name: String, value: toml::Value) -> Result<(), Error> {\n-                match name.as_str() {\n-                    $(\n-                        define_Conf!(PAT $toml_name) => {\n-                            if let Some(value) = define_Conf!(CONV $($ty)+, value) {\n-                                self.$rust_name = value;\n-                            }\n-                            else {\n-                                return Err(Error::Type(define_Conf!(EXPR $toml_name),\n-                                                       stringify!($($ty)+),\n-                                                       value.type_str()));\n-                            }\n-                        },\n-                    )+\n-                    \"third-party\" => {\n-                        // for external tools such as clippy-service\n-                        return Ok(());\n-                    }\n-                    _ => {\n-                        return Err(Error::UnknownKey(name));\n+            $(\n+                mod $rust_name {\n+                    use serde;\n+                    use serde::Deserialize;\n+                    pub fn deserialize<'de, D: serde::Deserializer<'de>>(deserializer: D) -> Result<define_Conf!(TY $($ty)+), D::Error> {\n+                        type T = define_Conf!(TY $($ty)+);\n+                        Ok(T::deserialize(deserializer).unwrap_or_else(|e| {\n+                            ::utils::conf::ERRORS.lock().expect(\"no threading here\").push(::utils::conf::Error::Toml(e.to_string()));\n+                            super::$rust_name()\n+                        }))\n                     }\n                 }\n \n-                Ok(())\n-            }\n+                fn $rust_name() -> define_Conf!(TY $($ty)+) {\n+                    define_Conf!(DEFAULT $($ty)+, $default)\n+                }\n+            )+\n         }\n     };\n \n     // hack to convert tts\n-    (PAT $pat: pat) => { $pat };\n-    (EXPR $e: expr) => { $e };\n     (TY $ty: ty) => { $ty };\n \n     // how to read the value?\n@@ -139,7 +118,7 @@ macro_rules! define_Conf {\n     };\n     (CONV String, $value: expr) => { $value.as_str().map(Into::into) };\n     (CONV Vec<String>, $value: expr) => {{\n-        let slice = $value.as_slice();\n+        let slice = $value.as_array();\n \n         if let Some(slice) = slice {\n             if slice.iter().any(|v| v.as_str().is_none()) {\n@@ -159,11 +138,11 @@ macro_rules! define_Conf {\n \n define_Conf! {\n     /// Lint: BLACKLISTED_NAME. The list of blacklisted names to lint about\n-    (\"blacklisted-names\", blacklisted_names, [\"foo\", \"bar\", \"baz\", \"quux\"] => Vec<String>),\n+    (blacklisted_names, \"blacklisted_names\", [\"foo\", \"bar\", \"baz\", \"quux\"] => Vec<String>),\n     /// Lint: CYCLOMATIC_COMPLEXITY. The maximum cyclomatic complexity a function can have\n-    (\"cyclomatic-complexity-threshold\", cyclomatic_complexity_threshold, 25 => u64),\n+    (cyclomatic_complexity_threshold, \"cyclomatic_complexity_threshold\", 25 => u64),\n     /// Lint: DOC_MARKDOWN. The list of words this lint should not consider as identifiers needing ticks\n-    (\"doc-valid-idents\", doc_valid_idents, [\n+    (doc_valid_idents, \"doc_valid_idents\", [\n         \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\",\n         \"DirectX\",\n         \"ECMAScript\",\n@@ -180,17 +159,17 @@ define_Conf! {\n         \"MinGW\",\n     ] => Vec<String>),\n     /// Lint: TOO_MANY_ARGUMENTS. The maximum number of argument a function or method can have\n-    (\"too-many-arguments-threshold\", too_many_arguments_threshold, 7 => u64),\n+    (too_many_arguments_threshold, \"too_many_arguments_threshold\", 7 => u64),\n     /// Lint: TYPE_COMPLEXITY. The maximum complexity a type can have\n-    (\"type-complexity-threshold\", type_complexity_threshold, 250 => u64),\n+    (type_complexity_threshold, \"type_complexity_threshold\", 250 => u64),\n     /// Lint: MANY_SINGLE_CHAR_NAMES. The maximum number of single char bindings a scope may have\n-    (\"single-char-binding-names-threshold\", max_single_char_names, 5 => u64),\n+    (single_char_binding_names_threshold, \"single_char_binding_names_threshold\", 5 => u64),\n     /// Lint: BOXED_LOCAL. The maximum size of objects (in bytes) that will be linted. Larger objects are ok on the heap\n-    (\"too-large-for-stack\", too_large_for_stack, 200 => u64),\n+    (too_large_for_stack, \"too_large_for_stack\", 200 => u64),\n     /// Lint: ENUM_VARIANT_NAMES. The minimum number of enum variants for the lints about variant names to trigger\n-    (\"enum-variant-name-threshold\", enum_variant_name_threshold, 3 => u64),\n+    (enum_variant_name_threshold, \"enum_variant_name_threshold\", 3 => u64),\n     /// Lint: LARGE_ENUM_VARIANT. The maximum size of a emum's variant to avoid box suggestion\n-    (\"enum-variant-size-threshold\", enum_variant_size_threshold, 200 => u64),\n+    (enum_variant_size_threshold, \"enum_variant_size_threshold\", 200 => u64),\n }\n \n /// Search for the configuration file.\n@@ -225,49 +204,43 @@ pub fn lookup_conf_file() -> io::Result<Option<path::PathBuf>> {\n     }\n }\n \n+/// Produces a `Conf` filled with the default values and forwards the errors\n+///\n+/// Used internally for convenience\n+fn default(errors: Vec<Error>) -> (Conf, Vec<Error>) {\n+    (toml::from_str(\"\").expect(\"we never error on empty config files\"), errors)\n+}\n+\n /// Read the `toml` configuration file.\n ///\n /// In case of error, the function tries to continue as much as possible.\n pub fn read(path: Option<&path::Path>) -> (Conf, Vec<Error>) {\n-    let mut conf = Conf::default();\n-    let mut errors = Vec::new();\n-\n     let path = if let Some(path) = path {\n         path\n     } else {\n-        return (conf, errors);\n+        return default(Vec::new())\n     };\n \n     let file = match fs::File::open(path) {\n         Ok(mut file) => {\n             let mut buf = String::new();\n \n             if let Err(err) = file.read_to_string(&mut buf) {\n-                errors.push(err.into());\n-                return (conf, errors);\n+                return default(vec![err.into()])\n             }\n \n             buf\n         },\n-        Err(err) => {\n-            errors.push(err.into());\n-            return (conf, errors);\n-        },\n+        Err(err) => return default(vec![err.into()]),\n     };\n \n-    let mut parser = toml::Parser::new(&file);\n-    let toml = if let Some(toml) = parser.parse() {\n-        toml\n-    } else {\n-        errors.push(Error::Toml(parser.errors));\n-        return (conf, errors);\n-    };\n-\n-    for (key, value) in toml {\n-        if let Err(err) = conf.set(key, value) {\n-            errors.push(err);\n-        }\n+    assert!(ERRORS.lock().expect(\"no threading -> mutex always safe\").is_empty());\n+    match toml::from_str(&file) {\n+        Ok(toml) => (toml, ERRORS.lock().expect(\"no threading -> mutex always safe\").split_off(0)),\n+        Err(e) => {\n+            let mut errors = ERRORS.lock().expect(\"no threading -> mutex always safe\").split_off(0);\n+            errors.push(Error::Toml(e.to_string()));\n+            default(errors)\n+        },\n     }\n-\n-    (conf, errors)\n }"}, {"sha": "8ee392f8924820f46a2ef6edb6d2a1c6340153d5", "filename": "tests/ui/conf_bad_toml.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/tests%2Fui%2Fconf_bad_toml.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/tests%2Fui%2Fconf_bad_toml.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconf_bad_toml.stderr?ref=3b3e47f4518d83ab625d34e93f0855b713ebd1c3", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file: expected `=`, but found `t`\n+error: error reading Clippy's configuration file: expected an equals, found an identifier at line 1\n \n error: aborting due to previous error\n "}, {"sha": "5cb4d05afef2770fa0e343af07e503b8e40c047f", "filename": "tests/ui/conf_bad_type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/tests%2Fui%2Fconf_bad_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/tests%2Fui%2Fconf_bad_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconf_bad_type.stderr?ref=3b3e47f4518d83ab625d34e93f0855b713ebd1c3", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file: `blacklisted-names` is expected to be a `Vec < String >` but is a `integer`\n+error: error reading Clippy's configuration file: invalid type: integer `42`, expected a sequence\n \n error: aborting due to previous error\n "}, {"sha": "bd16dfd47da9e195f10a5bc48260b055e60f03ed", "filename": "tests/ui/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/tests%2Fui%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/tests%2Fui%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconf_unknown_key.stderr?ref=3b3e47f4518d83ab625d34e93f0855b713ebd1c3", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file: unknown key `foobar`\n+error: error reading Clippy's configuration file: unknown field `foobar`, expected one of `blacklisted-names`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `third-party`\n \n error: aborting due to previous error\n "}, {"sha": "83150638ac1044229c99f4321b7af2de41f86bd4", "filename": "tests/ui/serde.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/tests%2Fui%2Fserde.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3e47f4518d83ab625d34e93f0855b713ebd1c3/tests%2Fui%2Fserde.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fserde.rs?ref=3b3e47f4518d83ab625d34e93f0855b713ebd1c3", "patch": "@@ -7,7 +7,7 @@ extern crate serde;\n \n struct A;\n \n-impl serde::de::Visitor for A {\n+impl<'de> serde::de::Visitor<'de> for A {\n     type Value = ();\n \n     fn expecting(&self, _: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n@@ -29,7 +29,7 @@ impl serde::de::Visitor for A {\n \n struct B;\n \n-impl serde::de::Visitor for B {\n+impl<'de> serde::de::Visitor<'de> for B {\n     type Value = ();\n \n     fn expecting(&self, _: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {"}]}