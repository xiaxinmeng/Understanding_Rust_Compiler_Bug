{"sha": "87b3afcd71c8c253196a503275be04856374ba4a", "node_id": "C_kwDOAAsO6NoAKDg3YjNhZmNkNzFjOGMyNTMxOTZhNTAzMjc1YmUwNDg1NjM3NGJhNGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-21T08:32:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-21T08:32:44Z"}, "message": "Auto merge of #8696 - J-ZhengLi:issue8492, r=flip1995\n\ncheck for if-some-or-ok-else-none-or-err\n\nfixes: #8492\n\n---\n\nchangelog: make [`option_if_let_else`] to check for match expression with both Option and Result; **TODO: Change lint name? Add new lint with similar functionality?**", "tree": {"sha": "ce805629f29f4fdf0e99272e612d95ebfb19115e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce805629f29f4fdf0e99272e612d95ebfb19115e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87b3afcd71c8c253196a503275be04856374ba4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87b3afcd71c8c253196a503275be04856374ba4a", "html_url": "https://github.com/rust-lang/rust/commit/87b3afcd71c8c253196a503275be04856374ba4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87b3afcd71c8c253196a503275be04856374ba4a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41309df8efe99848a79782ae98ad73638668381c", "url": "https://api.github.com/repos/rust-lang/rust/commits/41309df8efe99848a79782ae98ad73638668381c", "html_url": "https://github.com/rust-lang/rust/commit/41309df8efe99848a79782ae98ad73638668381c"}, {"sha": "1f75845a8f3318fba32aeb2f443f37aabdcc86f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f75845a8f3318fba32aeb2f443f37aabdcc86f0", "html_url": "https://github.com/rust-lang/rust/commit/1f75845a8f3318fba32aeb2f443f37aabdcc86f0"}], "stats": {"total": 245, "additions": 198, "deletions": 47}, "files": [{"sha": "9602d0d1d2ea1a725963b38f8762a4744c2c4328", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 121, "deletions": 46, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/87b3afcd71c8c253196a503275be04856374ba4a/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b3afcd71c8c253196a503275be04856374ba4a/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=87b3afcd71c8c253196a503275be04856374ba4a", "patch": "@@ -1,21 +1,22 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{\n     can_move_expr_to_closure, eager_or_lazy, higher, in_constant, is_else_clause, is_lang_ctor, peel_blocks,\n     peel_hir_expr_while, CaptureKind,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::OptionSome;\n-use rustc_hir::{def::Res, BindingAnnotation, Expr, ExprKind, Mutability, PatKind, Path, QPath, UnOp};\n+use rustc_hir::LangItem::{OptionNone, OptionSome, ResultErr, ResultOk};\n+use rustc_hir::{\n+    def::Res, Arm, BindingAnnotation, Expr, ExprKind, MatchSource, Mutability, Pat, PatKind, Path, QPath, UnOp,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Lints usage of `if let Some(v) = ... { y } else { x }` which is more\n+    /// Lints usage of `if let Some(v) = ... { y } else { x }` and\n+    /// `match .. { Some(v) => y, None/_ => x }` which are more\n     /// idiomatically done with `Option::map_or` (if the else bit is a pure\n     /// expression) or `Option::map_or_else` (if the else bit is an impure\n     /// expression).\n@@ -39,6 +40,10 @@ declare_clippy_lint! {\n     /// } else {\n     ///     5\n     /// };\n+    /// let _ = match optional {\n+    ///     Some(val) => val + 1,\n+    ///     None => 5\n+    /// };\n     /// let _ = if let Some(foo) = optional {\n     ///     foo\n     /// } else {\n@@ -53,11 +58,14 @@ declare_clippy_lint! {\n     /// # let optional: Option<u32> = Some(0);\n     /// # fn do_complicated_function() -> u32 { 5 };\n     /// let _ = optional.map_or(5, |foo| foo);\n+    /// let _ = optional.map_or(5, |val| val + 1);\n     /// let _ = optional.map_or_else(||{\n     ///     let y = do_complicated_function();\n     ///     y*y\n     /// }, |foo| foo);\n     /// ```\n+    // FIXME: Before moving this lint out of nursery, the lint name needs to be updated. It now also\n+    // covers matches and `Result`.\n     #[clippy::version = \"1.47.0\"]\n     pub OPTION_IF_LET_ELSE,\n     nursery,\n@@ -66,19 +74,21 @@ declare_clippy_lint! {\n \n declare_lint_pass!(OptionIfLetElse => [OPTION_IF_LET_ELSE]);\n \n-/// Returns true iff the given expression is the result of calling `Result::ok`\n-fn is_result_ok(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n-    if let ExprKind::MethodCall(path, &[ref receiver], _) = &expr.kind {\n-        path.ident.name.as_str() == \"ok\"\n-            && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(receiver), sym::Result)\n-    } else {\n-        false\n-    }\n-}\n-\n-/// A struct containing information about occurrences of the\n-/// `if let Some(..) = .. else` construct that this lint detects.\n-struct OptionIfLetElseOccurrence {\n+/// A struct containing information about occurrences of construct that this lint detects\n+///\n+/// Such as:\n+///\n+/// ```ignore\n+/// if let Some(..) = {..} else {..}\n+/// ```\n+/// or\n+/// ```ignore\n+/// match x {\n+///     Some(..) => {..},\n+///     None/_ => {..}\n+/// }\n+/// ```\n+struct OptionOccurence {\n     option: String,\n     method_sugg: String,\n     some_expr: String,\n@@ -99,43 +109,38 @@ fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: boo\n     )\n }\n \n-/// If this expression is the option if let/else construct we're detecting, then\n-/// this function returns an `OptionIfLetElseOccurrence` struct with details if\n-/// this construct is found, or None if this construct is not found.\n-fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionIfLetElseOccurrence> {\n+fn try_get_option_occurence<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &Pat<'tcx>,\n+    expr: &Expr<'_>,\n+    if_then: &'tcx Expr<'_>,\n+    if_else: &'tcx Expr<'_>,\n+) -> Option<OptionOccurence> {\n+    let cond_expr = match expr.kind {\n+        ExprKind::Unary(UnOp::Deref, inner_expr) | ExprKind::AddrOf(_, _, inner_expr) => inner_expr,\n+        _ => expr,\n+    };\n+    let inner_pat = try_get_inner_pat(cx, pat)?;\n     if_chain! {\n-        if !expr.span.from_expansion(); // Don't lint macros, because it behaves weirdly\n-        if !in_constant(cx, expr.hir_id);\n-        if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) })\n-            = higher::IfLet::hir(cx, expr);\n-        if !is_else_clause(cx.tcx, expr);\n-        if !is_result_ok(cx, let_expr); // Don't lint on Result::ok because a different lint does it already\n-        if let PatKind::TupleStruct(struct_qpath, [inner_pat], _) = &let_pat.kind;\n-        if is_lang_ctor(cx, struct_qpath, OptionSome);\n-        if let PatKind::Binding(bind_annotation, _, id, None) = &inner_pat.kind;\n+        if let PatKind::Binding(bind_annotation, _, id, None) = inner_pat.kind;\n         if let Some(some_captures) = can_move_expr_to_closure(cx, if_then);\n         if let Some(none_captures) = can_move_expr_to_closure(cx, if_else);\n         if some_captures\n             .iter()\n             .filter_map(|(id, &c)| none_captures.get(id).map(|&c2| (c, c2)))\n             .all(|(x, y)| x.is_imm_ref() && y.is_imm_ref());\n-\n         then {\n-            let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n+            let capture_mut = if bind_annotation == BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n             let some_body = peel_blocks(if_then);\n             let none_body = peel_blocks(if_else);\n             let method_sugg = if eager_or_lazy::switch_to_eager_eval(cx, none_body) { \"map_or\" } else { \"map_or_else\" };\n             let capture_name = id.name.to_ident_string();\n-            let (as_ref, as_mut) = match &let_expr.kind {\n+            let (as_ref, as_mut) = match &expr.kind {\n                 ExprKind::AddrOf(_, Mutability::Not, _) => (true, false),\n                 ExprKind::AddrOf(_, Mutability::Mut, _) => (false, true),\n-                _ => (bind_annotation == &BindingAnnotation::Ref, bind_annotation == &BindingAnnotation::RefMut),\n-            };\n-            let cond_expr = match let_expr.kind {\n-                // Pointer dereferencing happens automatically, so we can omit it in the suggestion\n-                ExprKind::Unary(UnOp::Deref, expr) | ExprKind::AddrOf(_, _, expr) => expr,\n-                _ => let_expr,\n+                _ => (bind_annotation == BindingAnnotation::Ref, bind_annotation == BindingAnnotation::RefMut),\n             };\n+\n             // Check if captures the closure will need conflict with borrows made in the scrutinee.\n             // TODO: check all the references made in the scrutinee expression. This will require interacting\n             // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n@@ -154,30 +159,100 @@ fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) ->\n                     }\n                 }\n             }\n-            Some(OptionIfLetElseOccurrence {\n+\n+            return Some(OptionOccurence {\n                 option: format_option_in_sugg(cx, cond_expr, as_ref, as_mut),\n                 method_sugg: method_sugg.to_string(),\n                 some_expr: format!(\"|{}{}| {}\", capture_mut, capture_name, Sugg::hir_with_macro_callsite(cx, some_body, \"..\")),\n                 none_expr: format!(\"{}{}\", if method_sugg == \"map_or\" { \"\" } else { \"|| \" }, Sugg::hir_with_macro_callsite(cx, none_body, \"..\")),\n-            })\n+            });\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn try_get_inner_pat<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'tcx>) -> Option<&'tcx Pat<'tcx>> {\n+    if let PatKind::TupleStruct(ref qpath, [inner_pat], ..) = pat.kind {\n+        if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk) {\n+            return Some(inner_pat);\n+        }\n+    }\n+    None\n+}\n+\n+/// If this expression is the option if let/else construct we're detecting, then\n+/// this function returns an `OptionOccurence` struct with details if\n+/// this construct is found, or None if this construct is not found.\n+fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionOccurence> {\n+    if let Some(higher::IfLet {\n+        let_pat,\n+        let_expr,\n+        if_then,\n+        if_else: Some(if_else),\n+    }) = higher::IfLet::hir(cx, expr)\n+    {\n+        if !is_else_clause(cx.tcx, expr) {\n+            return try_get_option_occurence(cx, let_pat, let_expr, if_then, if_else);\n+        }\n+    }\n+    None\n+}\n+\n+fn detect_option_match<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionOccurence> {\n+    if let ExprKind::Match(ex, arms, MatchSource::Normal) = expr.kind {\n+        if let Some((let_pat, if_then, if_else)) = try_convert_match(cx, arms) {\n+            return try_get_option_occurence(cx, let_pat, ex, if_then, if_else);\n+        }\n+    }\n+    None\n+}\n+\n+fn try_convert_match<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    arms: &[Arm<'tcx>],\n+) -> Option<(&'tcx Pat<'tcx>, &'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n+    if arms.len() == 2 {\n+        return if is_none_or_err_arm(cx, &arms[1]) {\n+            Some((arms[0].pat, arms[0].body, arms[1].body))\n+        } else if is_none_or_err_arm(cx, &arms[0]) {\n+            Some((arms[1].pat, arms[1].body, arms[0].body))\n         } else {\n             None\n-        }\n+        };\n+    }\n+    None\n+}\n+\n+fn is_none_or_err_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n+    match arm.pat.kind {\n+        PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+        PatKind::TupleStruct(ref qpath, [first_pat], _) => {\n+            is_lang_ctor(cx, qpath, ResultErr) && matches!(first_pat.kind, PatKind::Wild)\n+        },\n+        PatKind::Wild => true,\n+        _ => false,\n     }\n }\n \n impl<'tcx> LateLintPass<'tcx> for OptionIfLetElse {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n-        if let Some(detection) = detect_option_if_let_else(cx, expr) {\n+        // Don't lint macros and constants\n+        if expr.span.from_expansion() || in_constant(cx, expr.hir_id) {\n+            return;\n+        }\n+\n+        let detection = detect_option_if_let_else(cx, expr).or_else(|| detect_option_match(cx, expr));\n+        if let Some(det) = detection {\n             span_lint_and_sugg(\n                 cx,\n                 OPTION_IF_LET_ELSE,\n                 expr.span,\n-                format!(\"use Option::{} instead of an if let/else\", detection.method_sugg).as_str(),\n+                format!(\"use Option::{} instead of an if let/else\", det.method_sugg).as_str(),\n                 \"try\",\n                 format!(\n                     \"{}.{}({}, {})\",\n-                    detection.option, detection.method_sugg, detection.none_expr, detection.some_expr,\n+                    det.option, det.method_sugg, det.none_expr, det.some_expr\n                 ),\n                 Applicability::MaybeIncorrect,\n             );"}, {"sha": "f15ac551bb3ccfeefa774ae183e91f98a66f6ce0", "filename": "tests/ui/option_if_let_else.fixed", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/87b3afcd71c8c253196a503275be04856374ba4a/tests%2Fui%2Foption_if_let_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/87b3afcd71c8c253196a503275be04856374ba4a/tests%2Fui%2Foption_if_let_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.fixed?ref=87b3afcd71c8c253196a503275be04856374ba4a", "patch": "@@ -179,4 +179,13 @@ fn main() {\n \n     let _ = pattern_to_vec(\"hello world\");\n     let _ = complex_subpat();\n+\n+    // issue #8492\n+    let _ = s.map_or(1, |string| string.len());\n+    let _ = Some(10).map_or(5, |a| a + 1);\n+\n+    let res: Result<i32, i32> = Ok(5);\n+    let _ = res.map_or(1, |a| a + 1);\n+    let _ = res.map_or(1, |a| a + 1);\n+    let _ = res.map_or(5, |a| a + 1);\n }"}, {"sha": "9eeaea12d3bc91e615cb2fac5f3d3b10c0ffd0c9", "filename": "tests/ui/option_if_let_else.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/87b3afcd71c8c253196a503275be04856374ba4a/tests%2Fui%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b3afcd71c8c253196a503275be04856374ba4a/tests%2Fui%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.rs?ref=87b3afcd71c8c253196a503275be04856374ba4a", "patch": "@@ -208,4 +208,25 @@ fn main() {\n \n     let _ = pattern_to_vec(\"hello world\");\n     let _ = complex_subpat();\n+\n+    // issue #8492\n+    let _ = match s {\n+        Some(string) => string.len(),\n+        None => 1,\n+    };\n+    let _ = match Some(10) {\n+        Some(a) => a + 1,\n+        None => 5,\n+    };\n+\n+    let res: Result<i32, i32> = Ok(5);\n+    let _ = match res {\n+        Ok(a) => a + 1,\n+        _ => 1,\n+    };\n+    let _ = match res {\n+        Err(_) => 1,\n+        Ok(a) => a + 1,\n+    };\n+    let _ = if let Ok(a) = res { a + 1 } else { 5 };\n }"}, {"sha": "a5dbf6e1f2218020a7439059f9a59f5dba493fde", "filename": "tests/ui/option_if_let_else.stderr", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/87b3afcd71c8c253196a503275be04856374ba4a/tests%2Fui%2Foption_if_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/87b3afcd71c8c253196a503275be04856374ba4a/tests%2Fui%2Foption_if_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.stderr?ref=87b3afcd71c8c253196a503275be04856374ba4a", "patch": "@@ -206,5 +206,51 @@ LL +         s.len() + x\n LL ~     });\n    |\n \n-error: aborting due to 15 previous errors\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:213:13\n+   |\n+LL |       let _ = match s {\n+   |  _____________^\n+LL | |         Some(string) => string.len(),\n+LL | |         None => 1,\n+LL | |     };\n+   | |_____^ help: try: `s.map_or(1, |string| string.len())`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:217:13\n+   |\n+LL |       let _ = match Some(10) {\n+   |  _____________^\n+LL | |         Some(a) => a + 1,\n+LL | |         None => 5,\n+LL | |     };\n+   | |_____^ help: try: `Some(10).map_or(5, |a| a + 1)`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:223:13\n+   |\n+LL |       let _ = match res {\n+   |  _____________^\n+LL | |         Ok(a) => a + 1,\n+LL | |         _ => 1,\n+LL | |     };\n+   | |_____^ help: try: `res.map_or(1, |a| a + 1)`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:227:13\n+   |\n+LL |       let _ = match res {\n+   |  _____________^\n+LL | |         Err(_) => 1,\n+LL | |         Ok(a) => a + 1,\n+LL | |     };\n+   | |_____^ help: try: `res.map_or(1, |a| a + 1)`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:231:13\n+   |\n+LL |     let _ = if let Ok(a) = res { a + 1 } else { 5 };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `res.map_or(5, |a| a + 1)`\n+\n+error: aborting due to 20 previous errors\n "}]}