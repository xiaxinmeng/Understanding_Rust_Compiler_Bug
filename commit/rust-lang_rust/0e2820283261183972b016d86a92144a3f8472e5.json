{"sha": "0e2820283261183972b016d86a92144a3f8472e5", "node_id": "C_kwDOAAsO6NoAKDBlMjgyMDI4MzI2MTE4Mzk3MmIwMTZkODZhOTIxNDRhM2Y4NDcyZTU", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-06-01T06:56:40Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-06-01T06:56:40Z"}, "message": "Insert missing expr/pat for leading comma tuples", "tree": {"sha": "68be4d9f8e9f3c0c72956cb75e790a73c5ad79dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68be4d9f8e9f3c0c72956cb75e790a73c5ad79dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e2820283261183972b016d86a92144a3f8472e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e2820283261183972b016d86a92144a3f8472e5", "html_url": "https://github.com/rust-lang/rust/commit/0e2820283261183972b016d86a92144a3f8472e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e2820283261183972b016d86a92144a3f8472e5/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d1bf7023d7c11c20bfc35c9b9f4bfa027858d65", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d1bf7023d7c11c20bfc35c9b9f4bfa027858d65", "html_url": "https://github.com/rust-lang/rust/commit/7d1bf7023d7c11c20bfc35c9b9f4bfa027858d65"}], "stats": {"total": 75, "additions": 56, "deletions": 19}, "files": [{"sha": "ebe05afca6a81fd31ab23123567a42fb595329ce", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0e2820283261183972b016d86a92144a3f8472e5/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2820283261183972b016d86a92144a3f8472e5/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=0e2820283261183972b016d86a92144a3f8472e5", "patch": "@@ -542,9 +542,18 @@ impl ExprCollector<'_> {\n                 self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n             }\n             ast::Expr::TupleExpr(e) => {\n-                let exprs = e.fields().map(|expr| self.collect_expr(expr)).collect();\n+                let mut exprs: Vec<_> = e.fields().map(|expr| self.collect_expr(expr)).collect();\n+                // if there is a leading comma, the user is most likely to type out a leading expression\n+                // so we insert a missing expression at the beginning for IDE features\n+                if comma_follows_token(e.l_paren_token()) {\n+                    exprs.insert(0, self.missing_expr());\n+                }\n+\n                 self.alloc_expr(\n-                    Expr::Tuple { exprs, is_assignee_expr: self.is_lowering_assignee_expr },\n+                    Expr::Tuple {\n+                        exprs: exprs.into_boxed_slice(),\n+                        is_assignee_expr: self.is_lowering_assignee_expr,\n+                    },\n                     syntax_ptr,\n                 )\n             }\n@@ -1180,7 +1189,11 @@ impl ExprCollector<'_> {\n             ast::Pat::TupleStructPat(p) => {\n                 let path =\n                     p.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);\n-                let (args, ellipsis) = self.collect_tuple_pat(p.fields(), binding_list);\n+                let (args, ellipsis) = self.collect_tuple_pat(\n+                    p.fields(),\n+                    comma_follows_token(p.l_paren_token()),\n+                    binding_list,\n+                );\n                 Pat::TupleStruct { path, args, ellipsis }\n             }\n             ast::Pat::RefPat(p) => {\n@@ -1199,7 +1212,11 @@ impl ExprCollector<'_> {\n             }\n             ast::Pat::ParenPat(p) => return self.collect_pat_opt(p.pat(), binding_list),\n             ast::Pat::TuplePat(p) => {\n-                let (args, ellipsis) = self.collect_tuple_pat(p.fields(), binding_list);\n+                let (args, ellipsis) = self.collect_tuple_pat(\n+                    p.fields(),\n+                    comma_follows_token(p.l_paren_token()),\n+                    binding_list,\n+                );\n                 Pat::Tuple { args, ellipsis }\n             }\n             ast::Pat::WildcardPat(_) => Pat::Wild,\n@@ -1323,18 +1340,24 @@ impl ExprCollector<'_> {\n     fn collect_tuple_pat(\n         &mut self,\n         args: AstChildren<ast::Pat>,\n+        has_leading_comma: bool,\n         binding_list: &mut BindingList,\n     ) -> (Box<[PatId]>, Option<usize>) {\n         // Find the location of the `..`, if there is one. Note that we do not\n         // consider the possibility of there being multiple `..` here.\n         let ellipsis = args.clone().position(|p| matches!(p, ast::Pat::RestPat(_)));\n         // We want to skip the `..` pattern here, since we account for it above.\n-        let args = args\n+        let mut args: Vec<_> = args\n             .filter(|p| !matches!(p, ast::Pat::RestPat(_)))\n             .map(|p| self.collect_pat(p, binding_list))\n             .collect();\n+        // if there is a leading comma, the user is most likely to type out a leading pattern\n+        // so we insert a missing pattern at the beginning for IDE features\n+        if has_leading_comma {\n+            args.insert(0, self.missing_pat());\n+        }\n \n-        (args, ellipsis)\n+        (args.into_boxed_slice(), ellipsis)\n     }\n \n     // endregion: patterns\n@@ -1493,3 +1516,8 @@ impl ExprCollector<'_> {\n         self.body.labels.alloc(label)\n     }\n }\n+\n+fn comma_follows_token(t: Option<syntax::SyntaxToken>) -> bool {\n+    (|| syntax::algo::skip_trivia_token(t?.next_token()?, syntax::Direction::Next))()\n+        .map_or(false, |it| it.kind() == syntax::T![,])\n+}"}, {"sha": "7795be54e264c6ca24015c89d2110335c996a6c9", "filename": "crates/ide/src/signature_help.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0e2820283261183972b016d86a92144a3f8472e5/crates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e2820283261183972b016d86a92144a3f8472e5/crates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsignature_help.rs?ref=0e2820283261183972b016d86a92144a3f8472e5", "patch": "@@ -1996,27 +1996,27 @@ fn main() {\n \n     #[test]\n     fn test_tuple_expr_expected() {\n-        // FIXME: Seems like we discard valuable results in typeck here\n         check(\n             r#\"\n fn main() {\n     let _: (&str, u32, u32)= ($0, 1, 3);\n }\n \"#,\n             expect![[r#\"\n-                (&str, u32)\n-                 ^^^^  ---\n+                (&str, u32, u32)\n+                 ^^^^  ---  ---\n             \"#]],\n         );\n+        // FIXME: Should typeck report a 4-ary tuple for the expression here?\n         check(\n             r#\"\n fn main() {\n-    let _: (&str, u32, u32, u32)= ($0, 1, 3);\n+    let _: (&str, u32, u32, u32) = ($0, 1, 3);\n }\n \"#,\n             expect![[r#\"\n-                (&str, u32)\n-                 ^^^^  ---\n+                (&str, u32, u32)\n+                 ^^^^  ---  ---\n             \"#]],\n         );\n         check(\n@@ -2026,15 +2026,25 @@ fn main() {\n }\n \"#,\n             expect![[r#\"\n-                (&str, u32, u32)\n-                 ^^^^  ---  ---\n+                (&str, u32, u32, i32)\n+                 ^^^^  ---  ---  ---\n             \"#]],\n         );\n     }\n \n     #[test]\n     fn test_tuple_pat_free() {\n-        // FIXME: Seems like we discard valuable results in typeck here\n+        check(\n+            r#\"\n+fn main() {\n+    let ($0, 1, 3);\n+}\n+\"#,\n+            expect![[r#\"\n+                ({unknown}, i32, i32)\n+                 ^^^^^^^^^  ---  ---\n+            \"#]],\n+        );\n         check(\n             r#\"\n fn main() {\n@@ -2123,10 +2133,9 @@ fn main() {\n     let ($0, 1, 3): (i32, i32, i32);\n }\n \"#,\n-            // FIXME: tuple pat should be of size 3 ideally\n             expect![[r#\"\n-                (i32, i32)\n-                 ^^^  ---\n+                (i32, i32, i32)\n+                 ^^^  ---  ---\n             \"#]],\n         );\n         check(\n@@ -2182,7 +2191,7 @@ fn main() {\n     let ($0 1, 3) = (1, 2, 3);\n }\n \"#,\n-            // FIXME: tuple pat should be of size 3 ideally\n+            // FIXME: Should typeck report a 3-ary tuple for the pattern here?\n             expect![[r#\"\n                 (i32, i32)\n                  ^^^  ---"}]}