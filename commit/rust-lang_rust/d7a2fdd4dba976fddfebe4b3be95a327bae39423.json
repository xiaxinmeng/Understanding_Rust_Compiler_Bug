{"sha": "d7a2fdd4dba976fddfebe4b3be95a327bae39423", "node_id": "C_kwDOAAsO6NoAKGQ3YTJmZGQ0ZGJhOTc2ZmRkZmViZTRiM2JlOTVhMzI3YmFlMzk0MjM", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-25T18:25:44Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-27T04:13:44Z"}, "message": "Uplift complex type ops back into typeck so we can call them locally", "tree": {"sha": "06ef3a90e5e1797e1b6e9e2143bc7b25a032c066", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06ef3a90e5e1797e1b6e9e2143bc7b25a032c066"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7a2fdd4dba976fddfebe4b3be95a327bae39423", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7a2fdd4dba976fddfebe4b3be95a327bae39423", "html_url": "https://github.com/rust-lang/rust/commit/d7a2fdd4dba976fddfebe4b3be95a327bae39423", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7a2fdd4dba976fddfebe4b3be95a327bae39423/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a25aee19575d59709e51b5c214fe49af7090e69d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a25aee19575d59709e51b5c214fe49af7090e69d", "html_url": "https://github.com/rust-lang/rust/commit/a25aee19575d59709e51b5c214fe49af7090e69d"}], "stats": {"total": 1132, "additions": 574, "deletions": 558}, "files": [{"sha": "eb02604b9d925e4b4a076da6eac89ad8a3c623ff", "filename": "compiler/rustc_borrowck/src/type_check/liveness/trace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7a2fdd4dba976fddfebe4b3be95a327bae39423/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a2fdd4dba976fddfebe4b3be95a327bae39423/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs?ref=d7a2fdd4dba976fddfebe4b3be95a327bae39423", "patch": "@@ -3,9 +3,9 @@ use rustc_index::bit_set::HybridBitSet;\n use rustc_index::interval::IntervalSet;\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_middle::mir::{BasicBlock, Body, ConstraintCategory, Local, Location};\n+use rustc_middle::traits::query::DropckOutlivesResult;\n use rustc_middle::ty::{Ty, TyCtxt, TypeVisitable, TypeVisitableExt};\n use rustc_span::DUMMY_SP;\n-use rustc_trait_selection::traits::query::dropck_outlives::DropckOutlivesResult;\n use rustc_trait_selection::traits::query::type_op::outlives::DropckOutlives;\n use rustc_trait_selection::traits::query::type_op::{TypeOp, TypeOpOutput};\n use std::rc::Rc;"}, {"sha": "4e4172e7f41ec62bf4a4b55b2b92467cf9219f35", "filename": "compiler/rustc_trait_selection/src/traits/query/dropck_outlives.rs", "status": "modified", "additions": 267, "deletions": 2, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/d7a2fdd4dba976fddfebe4b3be95a327bae39423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a2fdd4dba976fddfebe4b3be95a327bae39423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=d7a2fdd4dba976fddfebe4b3be95a327bae39423", "patch": "@@ -1,6 +1,11 @@\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use crate::traits::query::normalize::QueryNormalizeExt;\n+use crate::traits::query::NoSolution;\n+use crate::traits::{Normalized, ObligationCause, ObligationCtxt};\n \n-pub use rustc_middle::traits::query::{DropckConstraint, DropckOutlivesResult};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_middle::traits::query::{DropckConstraint, DropckOutlivesResult};\n+use rustc_middle::ty::{self, EarlyBinder, ParamEnvAnd, Ty, TyCtxt};\n+use rustc_span::source_map::{Span, DUMMY_SP};\n \n /// This returns true if the type `ty` is \"trivial\" for\n /// dropck-outlives -- that is, if it doesn't require any types to\n@@ -71,3 +76,263 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         | ty::Generator(..) => false,\n     }\n }\n+\n+pub fn compute_dropck_outlives_inner<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n+    goal: ParamEnvAnd<'tcx, Ty<'tcx>>,\n+) -> Result<DropckOutlivesResult<'tcx>, NoSolution> {\n+    let tcx = ocx.infcx.tcx;\n+    let ParamEnvAnd { param_env, value: for_ty } = goal;\n+\n+    let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n+\n+    // A stack of types left to process. Each round, we pop\n+    // something from the stack and invoke\n+    // `dtorck_constraint_for_ty_inner`. This may produce new types that\n+    // have to be pushed on the stack. This continues until we have explored\n+    // all the reachable types from the type `for_ty`.\n+    //\n+    // Example: Imagine that we have the following code:\n+    //\n+    // ```rust\n+    // struct A {\n+    //     value: B,\n+    //     children: Vec<A>,\n+    // }\n+    //\n+    // struct B {\n+    //     value: u32\n+    // }\n+    //\n+    // fn f() {\n+    //   let a: A = ...;\n+    //   ..\n+    // } // here, `a` is dropped\n+    // ```\n+    //\n+    // at the point where `a` is dropped, we need to figure out\n+    // which types inside of `a` contain region data that may be\n+    // accessed by any destructors in `a`. We begin by pushing `A`\n+    // onto the stack, as that is the type of `a`. We will then\n+    // invoke `dtorck_constraint_for_ty_inner` which will expand `A`\n+    // into the types of its fields `(B, Vec<A>)`. These will get\n+    // pushed onto the stack. Eventually, expanding `Vec<A>` will\n+    // lead to us trying to push `A` a second time -- to prevent\n+    // infinite recursion, we notice that `A` was already pushed\n+    // once and stop.\n+    let mut ty_stack = vec![(for_ty, 0)];\n+\n+    // Set used to detect infinite recursion.\n+    let mut ty_set = FxHashSet::default();\n+\n+    let cause = ObligationCause::dummy();\n+    let mut constraints = DropckConstraint::empty();\n+    while let Some((ty, depth)) = ty_stack.pop() {\n+        debug!(\n+            \"{} kinds, {} overflows, {} ty_stack\",\n+            result.kinds.len(),\n+            result.overflows.len(),\n+            ty_stack.len()\n+        );\n+        dtorck_constraint_for_ty_inner(tcx, DUMMY_SP, for_ty, depth, ty, &mut constraints)?;\n+\n+        // \"outlives\" represent types/regions that may be touched\n+        // by a destructor.\n+        result.kinds.append(&mut constraints.outlives);\n+        result.overflows.append(&mut constraints.overflows);\n+\n+        // If we have even one overflow, we should stop trying to evaluate further --\n+        // chances are, the subsequent overflows for this evaluation won't provide useful\n+        // information and will just decrease the speed at which we can emit these errors\n+        // (since we'll be printing for just that much longer for the often enormous types\n+        // that result here).\n+        if !result.overflows.is_empty() {\n+            break;\n+        }\n+\n+        // dtorck types are \"types that will get dropped but which\n+        // do not themselves define a destructor\", more or less. We have\n+        // to push them onto the stack to be expanded.\n+        for ty in constraints.dtorck_types.drain(..) {\n+            let Normalized { value: ty, obligations } =\n+                ocx.infcx.at(&cause, param_env).query_normalize(ty)?;\n+            ocx.register_obligations(obligations);\n+\n+            debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n+\n+            match ty.kind() {\n+                // All parameters live for the duration of the\n+                // function.\n+                ty::Param(..) => {}\n+\n+                // A projection that we couldn't resolve - it\n+                // might have a destructor.\n+                ty::Alias(..) => {\n+                    result.kinds.push(ty.into());\n+                }\n+\n+                _ => {\n+                    if ty_set.insert(ty) {\n+                        ty_stack.push((ty, depth + 1));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    debug!(\"dropck_outlives: result = {:#?}\", result);\n+    Ok(result)\n+}\n+\n+/// Returns a set of constraints that needs to be satisfied in\n+/// order for `ty` to be valid for destruction.\n+pub fn dtorck_constraint_for_ty_inner<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    span: Span,\n+    for_ty: Ty<'tcx>,\n+    depth: usize,\n+    ty: Ty<'tcx>,\n+    constraints: &mut DropckConstraint<'tcx>,\n+) -> Result<(), NoSolution> {\n+    debug!(\"dtorck_constraint_for_ty_inner({:?}, {:?}, {:?}, {:?})\", span, for_ty, depth, ty);\n+\n+    if !tcx.recursion_limit().value_within_limit(depth) {\n+        constraints.overflows.push(ty);\n+        return Ok(());\n+    }\n+\n+    if trivial_dropck_outlives(tcx, ty) {\n+        return Ok(());\n+    }\n+\n+    match ty.kind() {\n+        ty::Bool\n+        | ty::Char\n+        | ty::Int(_)\n+        | ty::Uint(_)\n+        | ty::Float(_)\n+        | ty::Str\n+        | ty::Never\n+        | ty::Foreign(..)\n+        | ty::RawPtr(..)\n+        | ty::Ref(..)\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::GeneratorWitness(..)\n+        | ty::GeneratorWitnessMIR(..) => {\n+            // these types never have a destructor\n+        }\n+\n+        ty::Array(ety, _) | ty::Slice(ety) => {\n+            // single-element containers, behave like their element\n+            rustc_data_structures::stack::ensure_sufficient_stack(|| {\n+                dtorck_constraint_for_ty_inner(tcx, span, for_ty, depth + 1, *ety, constraints)\n+            })?;\n+        }\n+\n+        ty::Tuple(tys) => rustc_data_structures::stack::ensure_sufficient_stack(|| {\n+            for ty in tys.iter() {\n+                dtorck_constraint_for_ty_inner(tcx, span, for_ty, depth + 1, ty, constraints)?;\n+            }\n+            Ok::<_, NoSolution>(())\n+        })?,\n+\n+        ty::Closure(_, substs) => {\n+            if !substs.as_closure().is_valid() {\n+                // By the time this code runs, all type variables ought to\n+                // be fully resolved.\n+\n+                tcx.sess.delay_span_bug(\n+                    span,\n+                    format!(\"upvar_tys for closure not found. Expected capture information for closure {ty}\",),\n+                );\n+                return Err(NoSolution);\n+            }\n+\n+            rustc_data_structures::stack::ensure_sufficient_stack(|| {\n+                for ty in substs.as_closure().upvar_tys() {\n+                    dtorck_constraint_for_ty_inner(tcx, span, for_ty, depth + 1, ty, constraints)?;\n+                }\n+                Ok::<_, NoSolution>(())\n+            })?\n+        }\n+\n+        ty::Generator(_, substs, _movability) => {\n+            // rust-lang/rust#49918: types can be constructed, stored\n+            // in the interior, and sit idle when generator yields\n+            // (and is subsequently dropped).\n+            //\n+            // It would be nice to descend into interior of a\n+            // generator to determine what effects dropping it might\n+            // have (by looking at any drop effects associated with\n+            // its interior).\n+            //\n+            // However, the interior's representation uses things like\n+            // GeneratorWitness that explicitly assume they are not\n+            // traversed in such a manner. So instead, we will\n+            // simplify things for now by treating all generators as\n+            // if they were like trait objects, where its upvars must\n+            // all be alive for the generator's (potential)\n+            // destructor.\n+            //\n+            // In particular, skipping over `_interior` is safe\n+            // because any side-effects from dropping `_interior` can\n+            // only take place through references with lifetimes\n+            // derived from lifetimes attached to the upvars and resume\n+            // argument, and we *do* incorporate those here.\n+\n+            if !substs.as_generator().is_valid() {\n+                // By the time this code runs, all type variables ought to\n+                // be fully resolved.\n+                tcx.sess.delay_span_bug(\n+                    span,\n+                    format!(\"upvar_tys for generator not found. Expected capture information for generator {ty}\",),\n+                );\n+                return Err(NoSolution);\n+            }\n+\n+            constraints.outlives.extend(\n+                substs\n+                    .as_generator()\n+                    .upvar_tys()\n+                    .map(|t| -> ty::subst::GenericArg<'tcx> { t.into() }),\n+            );\n+            constraints.outlives.push(substs.as_generator().resume_ty().into());\n+        }\n+\n+        ty::Adt(def, substs) => {\n+            let DropckConstraint { dtorck_types, outlives, overflows } =\n+                tcx.at(span).adt_dtorck_constraint(def.did())?;\n+            // FIXME: we can try to recursively `dtorck_constraint_on_ty`\n+            // there, but that needs some way to handle cycles.\n+            constraints\n+                .dtorck_types\n+                .extend(dtorck_types.iter().map(|t| EarlyBinder(*t).subst(tcx, substs)));\n+            constraints\n+                .outlives\n+                .extend(outlives.iter().map(|t| EarlyBinder(*t).subst(tcx, substs)));\n+            constraints\n+                .overflows\n+                .extend(overflows.iter().map(|t| EarlyBinder(*t).subst(tcx, substs)));\n+        }\n+\n+        // Objects must be alive in order for their destructor\n+        // to be called.\n+        ty::Dynamic(..) => {\n+            constraints.outlives.push(ty.into());\n+        }\n+\n+        // Types that can't be resolved. Pass them forward.\n+        ty::Alias(..) | ty::Param(..) => {\n+            constraints.dtorck_types.push(ty);\n+        }\n+\n+        ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error(_) => {\n+            // By the time this code runs, all type variables ought to\n+            // be fully resolved.\n+            return Err(NoSolution);\n+        }\n+    }\n+\n+    Ok(())\n+}"}, {"sha": "01d7a1e7913b554850666bf0dcffc249d6d0e752", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 113, "deletions": 4, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/d7a2fdd4dba976fddfebe4b3be95a327bae39423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a2fdd4dba976fddfebe4b3be95a327bae39423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=d7a2fdd4dba976fddfebe4b3be95a327bae39423", "patch": "@@ -1,9 +1,13 @@\n use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n use crate::traits::ObligationCtxt;\n+use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n+use rustc_infer::traits::Obligation;\n use rustc_middle::traits::query::NoSolution;\n-use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n+use rustc_middle::traits::{ObligationCause, ObligationCauseCode};\n+use rustc_middle::ty::{self, ParamEnvAnd, Ty, TyCtxt, UserSelfTy, UserSubsts, UserType};\n \n pub use rustc_middle::traits::query::type_op::AscribeUserType;\n+use rustc_span::{Span, DUMMY_SP};\n \n impl<'tcx> super::QueryTypeOp<'tcx> for AscribeUserType<'tcx> {\n     type QueryResponse = ();\n@@ -23,9 +27,114 @@ impl<'tcx> super::QueryTypeOp<'tcx> for AscribeUserType<'tcx> {\n     }\n \n     fn perform_locally_in_new_solver(\n-        _ocx: &ObligationCtxt<'_, 'tcx>,\n-        _key: ParamEnvAnd<'tcx, Self>,\n+        ocx: &ObligationCtxt<'_, 'tcx>,\n+        key: ParamEnvAnd<'tcx, Self>,\n     ) -> Result<Self::QueryResponse, NoSolution> {\n-        todo!()\n+        type_op_ascribe_user_type_with_span(ocx, key, None)\n     }\n }\n+\n+/// The core of the `type_op_ascribe_user_type` query: for diagnostics purposes in NLL HRTB errors,\n+/// this query can be re-run to better track the span of the obligation cause, and improve the error\n+/// message. Do not call directly unless you're in that very specific context.\n+pub fn type_op_ascribe_user_type_with_span<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n+    key: ParamEnvAnd<'tcx, AscribeUserType<'tcx>>,\n+    span: Option<Span>,\n+) -> Result<(), NoSolution> {\n+    let (param_env, AscribeUserType { mir_ty, user_ty }) = key.into_parts();\n+    debug!(\"type_op_ascribe_user_type: mir_ty={:?} user_ty={:?}\", mir_ty, user_ty);\n+    let span = span.unwrap_or(DUMMY_SP);\n+    match user_ty {\n+        UserType::Ty(user_ty) => relate_mir_and_user_ty(ocx, param_env, span, mir_ty, user_ty)?,\n+        UserType::TypeOf(def_id, user_substs) => {\n+            relate_mir_and_user_substs(ocx, param_env, span, mir_ty, def_id, user_substs)?\n+        }\n+    };\n+    Ok(())\n+}\n+\n+#[instrument(level = \"debug\", skip(ocx, param_env, span))]\n+fn relate_mir_and_user_ty<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    span: Span,\n+    mir_ty: Ty<'tcx>,\n+    user_ty: Ty<'tcx>,\n+) -> Result<(), NoSolution> {\n+    let cause = ObligationCause::dummy_with_span(span);\n+    let user_ty = ocx.normalize(&cause, param_env, user_ty);\n+    ocx.eq(&cause, param_env, mir_ty, user_ty)?;\n+\n+    // FIXME(#104764): We should check well-formedness before normalization.\n+    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(user_ty.into()));\n+    ocx.register_obligation(Obligation::new(ocx.infcx.tcx, cause, param_env, predicate));\n+    Ok(())\n+}\n+\n+#[instrument(level = \"debug\", skip(ocx, param_env, span))]\n+fn relate_mir_and_user_substs<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    span: Span,\n+    mir_ty: Ty<'tcx>,\n+    def_id: DefId,\n+    user_substs: UserSubsts<'tcx>,\n+) -> Result<(), NoSolution> {\n+    let param_env = param_env.without_const();\n+    let UserSubsts { user_self_ty, substs } = user_substs;\n+    let tcx = ocx.infcx.tcx;\n+    let cause = ObligationCause::dummy_with_span(span);\n+\n+    let ty = tcx.type_of(def_id).subst(tcx, substs);\n+    let ty = ocx.normalize(&cause, param_env, ty);\n+    debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n+\n+    ocx.eq(&cause, param_env, mir_ty, ty)?;\n+\n+    // Prove the predicates coming along with `def_id`.\n+    //\n+    // Also, normalize the `instantiated_predicates`\n+    // because otherwise we wind up with duplicate \"type\n+    // outlives\" error messages.\n+    let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n+\n+    debug!(?instantiated_predicates);\n+    for (instantiated_predicate, predicate_span) in instantiated_predicates {\n+        let span = if span == DUMMY_SP { predicate_span } else { span };\n+        let cause = ObligationCause::new(\n+            span,\n+            CRATE_DEF_ID,\n+            ObligationCauseCode::AscribeUserTypeProvePredicate(predicate_span),\n+        );\n+        let instantiated_predicate =\n+            ocx.normalize(&cause.clone(), param_env, instantiated_predicate);\n+\n+        ocx.register_obligation(Obligation::new(tcx, cause, param_env, instantiated_predicate));\n+    }\n+\n+    if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n+        let self_ty = ocx.normalize(&cause, param_env, self_ty);\n+        let impl_self_ty = tcx.type_of(impl_def_id).subst(tcx, substs);\n+        let impl_self_ty = ocx.normalize(&cause, param_env, impl_self_ty);\n+\n+        ocx.eq(&cause, param_env, self_ty, impl_self_ty)?;\n+        let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into()));\n+        ocx.register_obligation(Obligation::new(tcx, cause.clone(), param_env, predicate));\n+    }\n+\n+    // In addition to proving the predicates, we have to\n+    // prove that `ty` is well-formed -- this is because\n+    // the WF of `ty` is predicated on the substs being\n+    // well-formed, and we haven't proven *that*. We don't\n+    // want to prove the WF of types from  `substs` directly because they\n+    // haven't been normalized.\n+    //\n+    // FIXME(nmatsakis): Well, perhaps we should normalize\n+    // them?  This would only be relevant if some input\n+    // type were ill-formed but did not appear in `ty`,\n+    // which...could happen with normalization...\n+    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into()));\n+    ocx.register_obligation(Obligation::new(tcx, cause, param_env, predicate));\n+    Ok(())\n+}"}, {"sha": "9989fc9c479a38da498f29d3192b86a004d712aa", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 171, "deletions": 6, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/d7a2fdd4dba976fddfebe4b3be95a327bae39423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a2fdd4dba976fddfebe4b3be95a327bae39423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=d7a2fdd4dba976fddfebe4b3be95a327bae39423", "patch": "@@ -1,8 +1,15 @@\n-use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n+use crate::traits::query::NoSolution;\n+use crate::traits::wf;\n use crate::traits::ObligationCtxt;\n+\n+use rustc_infer::infer::canonical::Canonical;\n+use rustc_infer::infer::outlives::components::{push_outlives_components, Component};\n use rustc_infer::traits::query::OutlivesBound;\n-use rustc_middle::traits::query::NoSolution;\n-use rustc_middle::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n+use rustc_middle::infer::canonical::CanonicalQueryResponse;\n+use rustc_middle::ty::{self, ParamEnvAnd, Ty, TyCtxt, TypeVisitableExt};\n+use rustc_span::def_id::CRATE_DEF_ID;\n+use rustc_span::source_map::DUMMY_SP;\n+use smallvec::{smallvec, SmallVec};\n \n #[derive(Copy, Clone, Debug, HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct ImpliedOutlivesBounds<'tcx> {\n@@ -42,9 +49,167 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ImpliedOutlivesBounds<'tcx> {\n     }\n \n     fn perform_locally_in_new_solver(\n-        _ocx: &ObligationCtxt<'_, 'tcx>,\n-        _key: ParamEnvAnd<'tcx, Self>,\n+        ocx: &ObligationCtxt<'_, 'tcx>,\n+        key: ParamEnvAnd<'tcx, Self>,\n     ) -> Result<Self::QueryResponse, NoSolution> {\n-        todo!()\n+        compute_implied_outlives_bounds_inner(ocx, key.param_env, key.value.ty)\n+    }\n+}\n+\n+pub fn compute_implied_outlives_bounds_inner<'tcx>(\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Result<Vec<OutlivesBound<'tcx>>, NoSolution> {\n+    let tcx = ocx.infcx.tcx;\n+\n+    // Sometimes when we ask what it takes for T: WF, we get back that\n+    // U: WF is required; in that case, we push U onto this stack and\n+    // process it next. Because the resulting predicates aren't always\n+    // guaranteed to be a subset of the original type, so we need to store the\n+    // WF args we've computed in a set.\n+    let mut checked_wf_args = rustc_data_structures::fx::FxHashSet::default();\n+    let mut wf_args = vec![ty.into()];\n+\n+    let mut outlives_bounds: Vec<ty::OutlivesPredicate<ty::GenericArg<'tcx>, ty::Region<'tcx>>> =\n+        vec![];\n+\n+    while let Some(arg) = wf_args.pop() {\n+        if !checked_wf_args.insert(arg) {\n+            continue;\n+        }\n+\n+        // Compute the obligations for `arg` to be well-formed. If `arg` is\n+        // an unresolved inference variable, just substituted an empty set\n+        // -- because the return type here is going to be things we *add*\n+        // to the environment, it's always ok for this set to be smaller\n+        // than the ultimate set. (Note: normally there won't be\n+        // unresolved inference variables here anyway, but there might be\n+        // during typeck under some circumstances.)\n+        //\n+        // FIXME(@lcnr): It's not really \"always fine\", having fewer implied\n+        // bounds can be backward incompatible, e.g. #101951 was caused by\n+        // us not dealing with inference vars in `TypeOutlives` predicates.\n+        let obligations = wf::obligations(ocx.infcx, param_env, CRATE_DEF_ID, 0, arg, DUMMY_SP)\n+            .unwrap_or_default();\n+\n+        for obligation in obligations {\n+            debug!(?obligation);\n+            assert!(!obligation.has_escaping_bound_vars());\n+\n+            // While these predicates should all be implied by other parts of\n+            // the program, they are still relevant as they may constrain\n+            // inference variables, which is necessary to add the correct\n+            // implied bounds in some cases, mostly when dealing with projections.\n+            //\n+            // Another important point here: we only register `Projection`\n+            // predicates, since otherwise we might register outlives\n+            // predicates containing inference variables, and we don't\n+            // learn anything new from those.\n+            if obligation.predicate.has_non_region_infer() {\n+                match obligation.predicate.kind().skip_binder() {\n+                    ty::PredicateKind::Clause(ty::Clause::Projection(..))\n+                    | ty::PredicateKind::AliasRelate(..) => {\n+                        ocx.register_obligation(obligation.clone());\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            let pred = match obligation.predicate.kind().no_bound_vars() {\n+                None => continue,\n+                Some(pred) => pred,\n+            };\n+            match pred {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(..))\n+                // FIXME(const_generics): Make sure that `<'a, 'b, const N: &'a &'b u32>` is sound\n+                // if we ever support that\n+                | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n+                | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::Coerce(..)\n+                | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..)\n+                | ty::PredicateKind::Ambiguous\n+                | ty::PredicateKind::AliasRelate(..)\n+                | ty::PredicateKind::TypeWellFormedFromEnv(..) => {}\n+\n+                // We need to search through *all* WellFormed predicates\n+                ty::PredicateKind::WellFormed(arg) => {\n+                    wf_args.push(arg);\n+                }\n+\n+                // We need to register region relationships\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n+                    r_a,\n+                    r_b,\n+                ))) => outlives_bounds.push(ty::OutlivesPredicate(r_a.into(), r_b)),\n+\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n+                    ty_a,\n+                    r_b,\n+                ))) => outlives_bounds.push(ty::OutlivesPredicate(ty_a.into(), r_b)),\n+            }\n+        }\n+    }\n+\n+    // This call to `select_all_or_error` is necessary to constrain inference variables, which we\n+    // use further down when computing the implied bounds.\n+    match ocx.select_all_or_error().as_slice() {\n+        [] => (),\n+        _ => return Err(NoSolution),\n     }\n+\n+    // We lazily compute the outlives components as\n+    // `select_all_or_error` constrains inference variables.\n+    let implied_bounds = outlives_bounds\n+        .into_iter()\n+        .flat_map(|ty::OutlivesPredicate(a, r_b)| match a.unpack() {\n+            ty::GenericArgKind::Lifetime(r_a) => vec![OutlivesBound::RegionSubRegion(r_b, r_a)],\n+            ty::GenericArgKind::Type(ty_a) => {\n+                let ty_a = ocx.infcx.resolve_vars_if_possible(ty_a);\n+                let mut components = smallvec![];\n+                push_outlives_components(tcx, ty_a, &mut components);\n+                implied_bounds_from_components(r_b, components)\n+            }\n+            ty::GenericArgKind::Const(_) => unreachable!(),\n+        })\n+        .collect();\n+\n+    Ok(implied_bounds)\n+}\n+\n+/// When we have an implied bound that `T: 'a`, we can further break\n+/// this down to determine what relationships would have to hold for\n+/// `T: 'a` to hold. We get to assume that the caller has validated\n+/// those relationships.\n+fn implied_bounds_from_components<'tcx>(\n+    sub_region: ty::Region<'tcx>,\n+    sup_components: SmallVec<[Component<'tcx>; 4]>,\n+) -> Vec<OutlivesBound<'tcx>> {\n+    sup_components\n+        .into_iter()\n+        .filter_map(|component| {\n+            match component {\n+                Component::Region(r) => Some(OutlivesBound::RegionSubRegion(sub_region, r)),\n+                Component::Param(p) => Some(OutlivesBound::RegionSubParam(sub_region, p)),\n+                Component::Alias(p) => Some(OutlivesBound::RegionSubAlias(sub_region, p)),\n+                Component::EscapingAlias(_) =>\n+                // If the projection has escaping regions, don't\n+                // try to infer any implied bounds even for its\n+                // free components. This is conservative, because\n+                // the caller will still have to prove that those\n+                // free components outlive `sub_region`. But the\n+                // idea is that the WAY that the caller proves\n+                // that may change in the future and we want to\n+                // give ourselves room to get smarter here.\n+                {\n+                    None\n+                }\n+                Component::UnresolvedInferenceVariable(..) => None,\n+            }\n+        })\n+        .collect()\n }"}, {"sha": "9889426337476ff87ae2d15ef67c586abe6bf9c9", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/outlives.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7a2fdd4dba976fddfebe4b3be95a327bae39423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a2fdd4dba976fddfebe4b3be95a327bae39423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=d7a2fdd4dba976fddfebe4b3be95a327bae39423", "patch": "@@ -1,7 +1,9 @@\n use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n-use crate::traits::query::dropck_outlives::{trivial_dropck_outlives, DropckOutlivesResult};\n+use crate::traits::query::dropck_outlives::{\n+    compute_dropck_outlives_inner, trivial_dropck_outlives,\n+};\n use crate::traits::ObligationCtxt;\n-use rustc_middle::traits::query::NoSolution;\n+use rustc_middle::traits::query::{DropckOutlivesResult, NoSolution};\n use rustc_middle::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n #[derive(Copy, Clone, Debug, HashStable, TypeFoldable, TypeVisitable, Lift)]\n@@ -51,9 +53,9 @@ impl<'tcx> super::QueryTypeOp<'tcx> for DropckOutlives<'tcx> {\n     }\n \n     fn perform_locally_in_new_solver(\n-        _ocx: &ObligationCtxt<'_, 'tcx>,\n-        _key: ParamEnvAnd<'tcx, Self>,\n+        ocx: &ObligationCtxt<'_, 'tcx>,\n+        key: ParamEnvAnd<'tcx, Self>,\n     ) -> Result<Self::QueryResponse, NoSolution> {\n-        todo!()\n+        compute_dropck_outlives_inner(ocx, key.param_env.and(key.value.dropped_ty))\n     }\n }"}, {"sha": "f35c14eeac80139ecb2c29c56094a30de8648972", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 5, "deletions": 261, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/d7a2fdd4dba976fddfebe4b3be95a327bae39423/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a2fdd4dba976fddfebe4b3be95a327bae39423/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=d7a2fdd4dba976fddfebe4b3be95a327bae39423", "patch": "@@ -3,17 +3,14 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::query::Providers;\n+use rustc_middle::traits::query::{DropckConstraint, DropckOutlivesResult};\n use rustc_middle::ty::InternalSubsts;\n-use rustc_middle::ty::{self, EarlyBinder, ParamEnvAnd, Ty, TyCtxt};\n-use rustc_span::source_map::{Span, DUMMY_SP};\n+use rustc_middle::ty::TyCtxt;\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n-use rustc_trait_selection::traits::query::dropck_outlives::trivial_dropck_outlives;\n use rustc_trait_selection::traits::query::dropck_outlives::{\n-    DropckConstraint, DropckOutlivesResult,\n+    compute_dropck_outlives_inner, dtorck_constraint_for_ty_inner,\n };\n-use rustc_trait_selection::traits::query::normalize::QueryNormalizeExt;\n use rustc_trait_selection::traits::query::{CanonicalTyGoal, NoSolution};\n-use rustc_trait_selection::traits::{Normalized, ObligationCause};\n \n pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers { dropck_outlives, adt_dtorck_constraint, ..*p };\n@@ -26,263 +23,10 @@ fn dropck_outlives<'tcx>(\n     debug!(\"dropck_outlives(goal={:#?})\", canonical_goal);\n \n     tcx.infer_ctxt().enter_canonical_trait_query(&canonical_goal, |ocx, goal| {\n-        let tcx = ocx.infcx.tcx;\n-        let ParamEnvAnd { param_env, value: for_ty } = goal;\n-\n-        let mut result = DropckOutlivesResult { kinds: vec![], overflows: vec![] };\n-\n-        // A stack of types left to process. Each round, we pop\n-        // something from the stack and invoke\n-        // `dtorck_constraint_for_ty`. This may produce new types that\n-        // have to be pushed on the stack. This continues until we have explored\n-        // all the reachable types from the type `for_ty`.\n-        //\n-        // Example: Imagine that we have the following code:\n-        //\n-        // ```rust\n-        // struct A {\n-        //     value: B,\n-        //     children: Vec<A>,\n-        // }\n-        //\n-        // struct B {\n-        //     value: u32\n-        // }\n-        //\n-        // fn f() {\n-        //   let a: A = ...;\n-        //   ..\n-        // } // here, `a` is dropped\n-        // ```\n-        //\n-        // at the point where `a` is dropped, we need to figure out\n-        // which types inside of `a` contain region data that may be\n-        // accessed by any destructors in `a`. We begin by pushing `A`\n-        // onto the stack, as that is the type of `a`. We will then\n-        // invoke `dtorck_constraint_for_ty` which will expand `A`\n-        // into the types of its fields `(B, Vec<A>)`. These will get\n-        // pushed onto the stack. Eventually, expanding `Vec<A>` will\n-        // lead to us trying to push `A` a second time -- to prevent\n-        // infinite recursion, we notice that `A` was already pushed\n-        // once and stop.\n-        let mut ty_stack = vec![(for_ty, 0)];\n-\n-        // Set used to detect infinite recursion.\n-        let mut ty_set = FxHashSet::default();\n-\n-        let cause = ObligationCause::dummy();\n-        let mut constraints = DropckConstraint::empty();\n-        while let Some((ty, depth)) = ty_stack.pop() {\n-            debug!(\n-                \"{} kinds, {} overflows, {} ty_stack\",\n-                result.kinds.len(),\n-                result.overflows.len(),\n-                ty_stack.len()\n-            );\n-            dtorck_constraint_for_ty(tcx, DUMMY_SP, for_ty, depth, ty, &mut constraints)?;\n-\n-            // \"outlives\" represent types/regions that may be touched\n-            // by a destructor.\n-            result.kinds.append(&mut constraints.outlives);\n-            result.overflows.append(&mut constraints.overflows);\n-\n-            // If we have even one overflow, we should stop trying to evaluate further --\n-            // chances are, the subsequent overflows for this evaluation won't provide useful\n-            // information and will just decrease the speed at which we can emit these errors\n-            // (since we'll be printing for just that much longer for the often enormous types\n-            // that result here).\n-            if !result.overflows.is_empty() {\n-                break;\n-            }\n-\n-            // dtorck types are \"types that will get dropped but which\n-            // do not themselves define a destructor\", more or less. We have\n-            // to push them onto the stack to be expanded.\n-            for ty in constraints.dtorck_types.drain(..) {\n-                let Normalized { value: ty, obligations } =\n-                    ocx.infcx.at(&cause, param_env).query_normalize(ty)?;\n-                ocx.register_obligations(obligations);\n-\n-                debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n-\n-                match ty.kind() {\n-                    // All parameters live for the duration of the\n-                    // function.\n-                    ty::Param(..) => {}\n-\n-                    // A projection that we couldn't resolve - it\n-                    // might have a destructor.\n-                    ty::Alias(..) => {\n-                        result.kinds.push(ty.into());\n-                    }\n-\n-                    _ => {\n-                        if ty_set.insert(ty) {\n-                            ty_stack.push((ty, depth + 1));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        debug!(\"dropck_outlives: result = {:#?}\", result);\n-        Ok(result)\n+        compute_dropck_outlives_inner(ocx, goal)\n     })\n }\n \n-/// Returns a set of constraints that needs to be satisfied in\n-/// order for `ty` to be valid for destruction.\n-fn dtorck_constraint_for_ty<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    span: Span,\n-    for_ty: Ty<'tcx>,\n-    depth: usize,\n-    ty: Ty<'tcx>,\n-    constraints: &mut DropckConstraint<'tcx>,\n-) -> Result<(), NoSolution> {\n-    debug!(\"dtorck_constraint_for_ty({:?}, {:?}, {:?}, {:?})\", span, for_ty, depth, ty);\n-\n-    if !tcx.recursion_limit().value_within_limit(depth) {\n-        constraints.overflows.push(ty);\n-        return Ok(());\n-    }\n-\n-    if trivial_dropck_outlives(tcx, ty) {\n-        return Ok(());\n-    }\n-\n-    match ty.kind() {\n-        ty::Bool\n-        | ty::Char\n-        | ty::Int(_)\n-        | ty::Uint(_)\n-        | ty::Float(_)\n-        | ty::Str\n-        | ty::Never\n-        | ty::Foreign(..)\n-        | ty::RawPtr(..)\n-        | ty::Ref(..)\n-        | ty::FnDef(..)\n-        | ty::FnPtr(_)\n-        | ty::GeneratorWitness(..)\n-        | ty::GeneratorWitnessMIR(..) => {\n-            // these types never have a destructor\n-        }\n-\n-        ty::Array(ety, _) | ty::Slice(ety) => {\n-            // single-element containers, behave like their element\n-            rustc_data_structures::stack::ensure_sufficient_stack(|| {\n-                dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, *ety, constraints)\n-            })?;\n-        }\n-\n-        ty::Tuple(tys) => rustc_data_structures::stack::ensure_sufficient_stack(|| {\n-            for ty in tys.iter() {\n-                dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty, constraints)?;\n-            }\n-            Ok::<_, NoSolution>(())\n-        })?,\n-\n-        ty::Closure(_, substs) => {\n-            if !substs.as_closure().is_valid() {\n-                // By the time this code runs, all type variables ought to\n-                // be fully resolved.\n-\n-                tcx.sess.delay_span_bug(\n-                    span,\n-                    format!(\"upvar_tys for closure not found. Expected capture information for closure {ty}\",),\n-                );\n-                return Err(NoSolution);\n-            }\n-\n-            rustc_data_structures::stack::ensure_sufficient_stack(|| {\n-                for ty in substs.as_closure().upvar_tys() {\n-                    dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty, constraints)?;\n-                }\n-                Ok::<_, NoSolution>(())\n-            })?\n-        }\n-\n-        ty::Generator(_, substs, _movability) => {\n-            // rust-lang/rust#49918: types can be constructed, stored\n-            // in the interior, and sit idle when generator yields\n-            // (and is subsequently dropped).\n-            //\n-            // It would be nice to descend into interior of a\n-            // generator to determine what effects dropping it might\n-            // have (by looking at any drop effects associated with\n-            // its interior).\n-            //\n-            // However, the interior's representation uses things like\n-            // GeneratorWitness that explicitly assume they are not\n-            // traversed in such a manner. So instead, we will\n-            // simplify things for now by treating all generators as\n-            // if they were like trait objects, where its upvars must\n-            // all be alive for the generator's (potential)\n-            // destructor.\n-            //\n-            // In particular, skipping over `_interior` is safe\n-            // because any side-effects from dropping `_interior` can\n-            // only take place through references with lifetimes\n-            // derived from lifetimes attached to the upvars and resume\n-            // argument, and we *do* incorporate those here.\n-\n-            if !substs.as_generator().is_valid() {\n-                // By the time this code runs, all type variables ought to\n-                // be fully resolved.\n-                tcx.sess.delay_span_bug(\n-                    span,\n-                    format!(\"upvar_tys for generator not found. Expected capture information for generator {ty}\",),\n-                );\n-                return Err(NoSolution);\n-            }\n-\n-            constraints.outlives.extend(\n-                substs\n-                    .as_generator()\n-                    .upvar_tys()\n-                    .map(|t| -> ty::subst::GenericArg<'tcx> { t.into() }),\n-            );\n-            constraints.outlives.push(substs.as_generator().resume_ty().into());\n-        }\n-\n-        ty::Adt(def, substs) => {\n-            let DropckConstraint { dtorck_types, outlives, overflows } =\n-                tcx.at(span).adt_dtorck_constraint(def.did())?;\n-            // FIXME: we can try to recursively `dtorck_constraint_on_ty`\n-            // there, but that needs some way to handle cycles.\n-            constraints\n-                .dtorck_types\n-                .extend(dtorck_types.iter().map(|t| EarlyBinder(*t).subst(tcx, substs)));\n-            constraints\n-                .outlives\n-                .extend(outlives.iter().map(|t| EarlyBinder(*t).subst(tcx, substs)));\n-            constraints\n-                .overflows\n-                .extend(overflows.iter().map(|t| EarlyBinder(*t).subst(tcx, substs)));\n-        }\n-\n-        // Objects must be alive in order for their destructor\n-        // to be called.\n-        ty::Dynamic(..) => {\n-            constraints.outlives.push(ty.into());\n-        }\n-\n-        // Types that can't be resolved. Pass them forward.\n-        ty::Alias(..) | ty::Param(..) => {\n-            constraints.dtorck_types.push(ty);\n-        }\n-\n-        ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error(_) => {\n-            // By the time this code runs, all type variables ought to\n-            // be fully resolved.\n-            return Err(NoSolution);\n-        }\n-    }\n-\n-    Ok(())\n-}\n-\n /// Calculates the dtorck constraint for a type.\n pub(crate) fn adt_dtorck_constraint(\n     tcx: TyCtxt<'_>,\n@@ -311,7 +55,7 @@ pub(crate) fn adt_dtorck_constraint(\n     let mut result = DropckConstraint::empty();\n     for field in def.all_fields() {\n         let fty = tcx.type_of(field.did).subst_identity();\n-        dtorck_constraint_for_ty(tcx, span, fty, 0, fty, &mut result)?;\n+        dtorck_constraint_for_ty_inner(tcx, span, fty, 0, fty, &mut result)?;\n     }\n     result.outlives.extend(tcx.destructor_constraints(def));\n     dedup_dtorck_constraint(&mut result);"}, {"sha": "959838ab348fd0026585d3bda06f1569dd847327", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 3, "deletions": 166, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/d7a2fdd4dba976fddfebe4b3be95a327bae39423/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a2fdd4dba976fddfebe4b3be95a327bae39423/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=d7a2fdd4dba976fddfebe4b3be95a327bae39423", "patch": "@@ -3,18 +3,13 @@\n //! [`rustc_trait_selection::traits::query::type_op::implied_outlives_bounds`].\n \n use rustc_infer::infer::canonical::{self, Canonical};\n-use rustc_infer::infer::outlives::components::{push_outlives_components, Component};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::query::OutlivesBound;\n use rustc_middle::query::Providers;\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n-use rustc_span::def_id::CRATE_DEF_ID;\n-use rustc_span::source_map::DUMMY_SP;\n+use rustc_middle::ty::TyCtxt;\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n+use rustc_trait_selection::traits::query::type_op::implied_outlives_bounds::compute_implied_outlives_bounds_inner;\n use rustc_trait_selection::traits::query::{CanonicalTyGoal, NoSolution};\n-use rustc_trait_selection::traits::wf;\n-use rustc_trait_selection::traits::ObligationCtxt;\n-use smallvec::{smallvec, SmallVec};\n \n pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers { implied_outlives_bounds, ..*p };\n@@ -29,164 +24,6 @@ fn implied_outlives_bounds<'tcx>(\n > {\n     tcx.infer_ctxt().enter_canonical_trait_query(&goal, |ocx, key| {\n         let (param_env, ty) = key.into_parts();\n-        compute_implied_outlives_bounds(ocx, param_env, ty)\n+        compute_implied_outlives_bounds_inner(ocx, param_env, ty)\n     })\n }\n-\n-fn compute_implied_outlives_bounds<'tcx>(\n-    ocx: &ObligationCtxt<'_, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> Result<Vec<OutlivesBound<'tcx>>, NoSolution> {\n-    let tcx = ocx.infcx.tcx;\n-\n-    // Sometimes when we ask what it takes for T: WF, we get back that\n-    // U: WF is required; in that case, we push U onto this stack and\n-    // process it next. Because the resulting predicates aren't always\n-    // guaranteed to be a subset of the original type, so we need to store the\n-    // WF args we've computed in a set.\n-    let mut checked_wf_args = rustc_data_structures::fx::FxHashSet::default();\n-    let mut wf_args = vec![ty.into()];\n-\n-    let mut outlives_bounds: Vec<ty::OutlivesPredicate<ty::GenericArg<'tcx>, ty::Region<'tcx>>> =\n-        vec![];\n-\n-    while let Some(arg) = wf_args.pop() {\n-        if !checked_wf_args.insert(arg) {\n-            continue;\n-        }\n-\n-        // Compute the obligations for `arg` to be well-formed. If `arg` is\n-        // an unresolved inference variable, just substituted an empty set\n-        // -- because the return type here is going to be things we *add*\n-        // to the environment, it's always ok for this set to be smaller\n-        // than the ultimate set. (Note: normally there won't be\n-        // unresolved inference variables here anyway, but there might be\n-        // during typeck under some circumstances.)\n-        //\n-        // FIXME(@lcnr): It's not really \"always fine\", having fewer implied\n-        // bounds can be backward incompatible, e.g. #101951 was caused by\n-        // us not dealing with inference vars in `TypeOutlives` predicates.\n-        let obligations = wf::obligations(ocx.infcx, param_env, CRATE_DEF_ID, 0, arg, DUMMY_SP)\n-            .unwrap_or_default();\n-\n-        for obligation in obligations {\n-            debug!(?obligation);\n-            assert!(!obligation.has_escaping_bound_vars());\n-\n-            // While these predicates should all be implied by other parts of\n-            // the program, they are still relevant as they may constrain\n-            // inference variables, which is necessary to add the correct\n-            // implied bounds in some cases, mostly when dealing with projections.\n-            //\n-            // Another important point here: we only register `Projection`\n-            // predicates, since otherwise we might register outlives\n-            // predicates containing inference variables, and we don't\n-            // learn anything new from those.\n-            if obligation.predicate.has_non_region_infer() {\n-                match obligation.predicate.kind().skip_binder() {\n-                    ty::PredicateKind::Clause(ty::Clause::Projection(..))\n-                    | ty::PredicateKind::AliasRelate(..) => {\n-                        ocx.register_obligation(obligation.clone());\n-                    }\n-                    _ => {}\n-                }\n-            }\n-\n-            let pred = match obligation.predicate.kind().no_bound_vars() {\n-                None => continue,\n-                Some(pred) => pred,\n-            };\n-            match pred {\n-                ty::PredicateKind::Clause(ty::Clause::Trait(..))\n-                // FIXME(const_generics): Make sure that `<'a, 'b, const N: &'a &'b u32>` is sound\n-                // if we ever support that\n-                | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n-                | ty::PredicateKind::Subtype(..)\n-                | ty::PredicateKind::Coerce(..)\n-                | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n-                | ty::PredicateKind::ClosureKind(..)\n-                | ty::PredicateKind::ObjectSafe(..)\n-                | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::ConstEquate(..)\n-                | ty::PredicateKind::Ambiguous\n-                | ty::PredicateKind::AliasRelate(..)\n-                | ty::PredicateKind::TypeWellFormedFromEnv(..) => {}\n-\n-                // We need to search through *all* WellFormed predicates\n-                ty::PredicateKind::WellFormed(arg) => {\n-                    wf_args.push(arg);\n-                }\n-\n-                // We need to register region relationships\n-                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(ty::OutlivesPredicate(\n-                    r_a,\n-                    r_b,\n-                ))) => outlives_bounds.push(ty::OutlivesPredicate(r_a.into(), r_b)),\n-\n-                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n-                    ty_a,\n-                    r_b,\n-                ))) => outlives_bounds.push(ty::OutlivesPredicate(ty_a.into(), r_b)),\n-            }\n-        }\n-    }\n-\n-    // This call to `select_all_or_error` is necessary to constrain inference variables, which we\n-    // use further down when computing the implied bounds.\n-    match ocx.select_all_or_error().as_slice() {\n-        [] => (),\n-        _ => return Err(NoSolution),\n-    }\n-\n-    // We lazily compute the outlives components as\n-    // `select_all_or_error` constrains inference variables.\n-    let implied_bounds = outlives_bounds\n-        .into_iter()\n-        .flat_map(|ty::OutlivesPredicate(a, r_b)| match a.unpack() {\n-            ty::GenericArgKind::Lifetime(r_a) => vec![OutlivesBound::RegionSubRegion(r_b, r_a)],\n-            ty::GenericArgKind::Type(ty_a) => {\n-                let ty_a = ocx.infcx.resolve_vars_if_possible(ty_a);\n-                let mut components = smallvec![];\n-                push_outlives_components(tcx, ty_a, &mut components);\n-                implied_bounds_from_components(r_b, components)\n-            }\n-            ty::GenericArgKind::Const(_) => unreachable!(),\n-        })\n-        .collect();\n-\n-    Ok(implied_bounds)\n-}\n-\n-/// When we have an implied bound that `T: 'a`, we can further break\n-/// this down to determine what relationships would have to hold for\n-/// `T: 'a` to hold. We get to assume that the caller has validated\n-/// those relationships.\n-fn implied_bounds_from_components<'tcx>(\n-    sub_region: ty::Region<'tcx>,\n-    sup_components: SmallVec<[Component<'tcx>; 4]>,\n-) -> Vec<OutlivesBound<'tcx>> {\n-    sup_components\n-        .into_iter()\n-        .filter_map(|component| {\n-            match component {\n-                Component::Region(r) => Some(OutlivesBound::RegionSubRegion(sub_region, r)),\n-                Component::Param(p) => Some(OutlivesBound::RegionSubParam(sub_region, p)),\n-                Component::Alias(p) => Some(OutlivesBound::RegionSubAlias(sub_region, p)),\n-                Component::EscapingAlias(_) =>\n-                // If the projection has escaping regions, don't\n-                // try to infer any implied bounds even for its\n-                // free components. This is conservative, because\n-                // the caller will still have to prove that those\n-                // free components outlive `sub_region`. But the\n-                // idea is that the WAY that the caller proves\n-                // that may change in the future and we want to\n-                // give ourselves room to get smarter here.\n-                {\n-                    None\n-                }\n-                Component::UnresolvedInferenceVariable(..) => None,\n-            }\n-        })\n-        .collect()\n-}"}, {"sha": "907e2d39c518f057f3c33ddd503eaa16d95c68ed", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d7a2fdd4dba976fddfebe4b3be95a327bae39423/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a2fdd4dba976fddfebe4b3be95a327bae39423/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=d7a2fdd4dba976fddfebe4b3be95a327bae39423", "patch": "@@ -21,7 +21,8 @@ mod normalize_erasing_regions;\n mod normalize_projection_ty;\n mod type_op;\n \n-pub use type_op::{type_op_ascribe_user_type_with_span, type_op_prove_predicate_with_cause};\n+pub use rustc_trait_selection::traits::query::type_op::ascribe_user_type::type_op_ascribe_user_type_with_span;\n+pub use type_op::type_op_prove_predicate_with_cause;\n \n use rustc_middle::query::Providers;\n "}, {"sha": "9904acb1c0d516ab2b56364ccb9ad3ea6bb565e9", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 5, "deletions": 112, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/d7a2fdd4dba976fddfebe4b3be95a327bae39423/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a2fdd4dba976fddfebe4b3be95a327bae39423/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=d7a2fdd4dba976fddfebe4b3be95a327bae39423", "patch": "@@ -1,17 +1,15 @@\n-use rustc_hir as hir;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::query::Providers;\n use rustc_middle::traits::query::NoSolution;\n-use rustc_middle::traits::{DefiningAnchor, ObligationCauseCode};\n-use rustc_middle::ty::{self, FnSig, Lift, PolyFnSig, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::traits::DefiningAnchor;\n+use rustc_middle::ty::{FnSig, Lift, PolyFnSig, Ty, TyCtxt, TypeFoldable};\n use rustc_middle::ty::{ParamEnvAnd, Predicate};\n-use rustc_middle::ty::{UserSelfTy, UserSubsts, UserType};\n-use rustc_span::def_id::CRATE_DEF_ID;\n-use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n use rustc_trait_selection::traits::query::normalize::QueryNormalizeExt;\n-use rustc_trait_selection::traits::query::type_op::ascribe_user_type::AscribeUserType;\n+use rustc_trait_selection::traits::query::type_op::ascribe_user_type::{\n+    type_op_ascribe_user_type_with_span, AscribeUserType,\n+};\n use rustc_trait_selection::traits::query::type_op::eq::Eq;\n use rustc_trait_selection::traits::query::type_op::normalize::Normalize;\n use rustc_trait_selection::traits::query::type_op::prove_predicate::ProvePredicate;\n@@ -42,111 +40,6 @@ fn type_op_ascribe_user_type<'tcx>(\n     })\n }\n \n-/// The core of the `type_op_ascribe_user_type` query: for diagnostics purposes in NLL HRTB errors,\n-/// this query can be re-run to better track the span of the obligation cause, and improve the error\n-/// message. Do not call directly unless you're in that very specific context.\n-pub fn type_op_ascribe_user_type_with_span<'tcx>(\n-    ocx: &ObligationCtxt<'_, 'tcx>,\n-    key: ParamEnvAnd<'tcx, AscribeUserType<'tcx>>,\n-    span: Option<Span>,\n-) -> Result<(), NoSolution> {\n-    let (param_env, AscribeUserType { mir_ty, user_ty }) = key.into_parts();\n-    debug!(\"type_op_ascribe_user_type: mir_ty={:?} user_ty={:?}\", mir_ty, user_ty);\n-    let span = span.unwrap_or(DUMMY_SP);\n-    match user_ty {\n-        UserType::Ty(user_ty) => relate_mir_and_user_ty(ocx, param_env, span, mir_ty, user_ty)?,\n-        UserType::TypeOf(def_id, user_substs) => {\n-            relate_mir_and_user_substs(ocx, param_env, span, mir_ty, def_id, user_substs)?\n-        }\n-    };\n-    Ok(())\n-}\n-\n-#[instrument(level = \"debug\", skip(ocx, param_env, span))]\n-fn relate_mir_and_user_ty<'tcx>(\n-    ocx: &ObligationCtxt<'_, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    span: Span,\n-    mir_ty: Ty<'tcx>,\n-    user_ty: Ty<'tcx>,\n-) -> Result<(), NoSolution> {\n-    let cause = ObligationCause::dummy_with_span(span);\n-    let user_ty = ocx.normalize(&cause, param_env, user_ty);\n-    ocx.eq(&cause, param_env, mir_ty, user_ty)?;\n-\n-    // FIXME(#104764): We should check well-formedness before normalization.\n-    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(user_ty.into()));\n-    ocx.register_obligation(Obligation::new(ocx.infcx.tcx, cause, param_env, predicate));\n-    Ok(())\n-}\n-\n-#[instrument(level = \"debug\", skip(ocx, param_env, span))]\n-fn relate_mir_and_user_substs<'tcx>(\n-    ocx: &ObligationCtxt<'_, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    span: Span,\n-    mir_ty: Ty<'tcx>,\n-    def_id: hir::def_id::DefId,\n-    user_substs: UserSubsts<'tcx>,\n-) -> Result<(), NoSolution> {\n-    let param_env = param_env.without_const();\n-    let UserSubsts { user_self_ty, substs } = user_substs;\n-    let tcx = ocx.infcx.tcx;\n-    let cause = ObligationCause::dummy_with_span(span);\n-\n-    let ty = tcx.type_of(def_id).subst(tcx, substs);\n-    let ty = ocx.normalize(&cause, param_env, ty);\n-    debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n-\n-    ocx.eq(&cause, param_env, mir_ty, ty)?;\n-\n-    // Prove the predicates coming along with `def_id`.\n-    //\n-    // Also, normalize the `instantiated_predicates`\n-    // because otherwise we wind up with duplicate \"type\n-    // outlives\" error messages.\n-    let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n-\n-    debug!(?instantiated_predicates);\n-    for (instantiated_predicate, predicate_span) in instantiated_predicates {\n-        let span = if span == DUMMY_SP { predicate_span } else { span };\n-        let cause = ObligationCause::new(\n-            span,\n-            CRATE_DEF_ID,\n-            ObligationCauseCode::AscribeUserTypeProvePredicate(predicate_span),\n-        );\n-        let instantiated_predicate =\n-            ocx.normalize(&cause.clone(), param_env, instantiated_predicate);\n-\n-        ocx.register_obligation(Obligation::new(tcx, cause, param_env, instantiated_predicate));\n-    }\n-\n-    if let Some(UserSelfTy { impl_def_id, self_ty }) = user_self_ty {\n-        let self_ty = ocx.normalize(&cause, param_env, self_ty);\n-        let impl_self_ty = tcx.type_of(impl_def_id).subst(tcx, substs);\n-        let impl_self_ty = ocx.normalize(&cause, param_env, impl_self_ty);\n-\n-        ocx.eq(&cause, param_env, self_ty, impl_self_ty)?;\n-        let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(impl_self_ty.into()));\n-        ocx.register_obligation(Obligation::new(tcx, cause.clone(), param_env, predicate));\n-    }\n-\n-    // In addition to proving the predicates, we have to\n-    // prove that `ty` is well-formed -- this is because\n-    // the WF of `ty` is predicated on the substs being\n-    // well-formed, and we haven't proven *that*. We don't\n-    // want to prove the WF of types from  `substs` directly because they\n-    // haven't been normalized.\n-    //\n-    // FIXME(nmatsakis): Well, perhaps we should normalize\n-    // them?  This would only be relevant if some input\n-    // type were ill-formed but did not appear in `ty`,\n-    // which...could happen with normalization...\n-    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into()));\n-    ocx.register_obligation(Obligation::new(tcx, cause, param_env, predicate));\n-    Ok(())\n-}\n-\n fn type_op_eq<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Eq<'tcx>>>,"}]}