{"sha": "23f2c78d21440a8699cfa917b422795b5ec4adc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzZjJjNzhkMjE0NDBhODY5OWNmYTkxN2I0MjI3OTViNWVjNGFkYzc=", "commit": {"author": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2014-08-03T12:16:10Z"}, "committer": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2014-09-14T19:35:48Z"}, "message": "Fix some of the issues mentioned in the PR on Github\n\nThis specifically includes:\n- Fix of the tests\n- Remove `transmute` between `Vec`s of different types", "tree": {"sha": "595b85c541772a551315fa8a3c7e04bf73242821", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/595b85c541772a551315fa8a3c7e04bf73242821"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23f2c78d21440a8699cfa917b422795b5ec4adc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23f2c78d21440a8699cfa917b422795b5ec4adc7", "html_url": "https://github.com/rust-lang/rust/commit/23f2c78d21440a8699cfa917b422795b5ec4adc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23f2c78d21440a8699cfa917b422795b5ec4adc7/comments", "author": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af293372e4ea9578840338bdd1b765bfc3c80352", "url": "https://api.github.com/repos/rust-lang/rust/commits/af293372e4ea9578840338bdd1b765bfc3c80352", "html_url": "https://github.com/rust-lang/rust/commit/af293372e4ea9578840338bdd1b765bfc3c80352"}], "stats": {"total": 65, "additions": 43, "deletions": 22}, "files": [{"sha": "e04eadb084fb0519b6ed8c8848676cebfc0726c4", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/23f2c78d21440a8699cfa917b422795b5ec4adc7/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23f2c78d21440a8699cfa917b422795b5ec4adc7/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=23f2c78d21440a8699cfa917b422795b5ec4adc7", "patch": "@@ -1712,6 +1712,9 @@ pub mod raw {\n \n /// An owned, partially type-converted vector.\n ///\n+/// This struct takes two type parameters `T` and `U` which must be of the\n+/// same, non-zero size.\n+///\n /// No allocations are performed by usage, only a deallocation happens in the\n /// destructor which should only run when unwinding.\n ///\n@@ -1725,13 +1728,13 @@ pub mod raw {\n /// # Example\n ///\n /// ```rust\n-/// let pv = PartialVec::new(vec![0u, 1]);\n+/// let pv = PartialVec::from_vec(vec![0u, 1]);\n /// assert_eq!(pv.pop(), Some(0));\n /// assert_eq!(pv.pop(), Some(1));\n /// assert_eq!(pv.pop(), None);\n /// pv.push(2u);\n /// pv.push(3);\n-/// assert_eq!(pv.into_vec(), vec![2, 3]);\n+/// assert_eq!(pv.into_vec().as_slice(), &[2, 3]);\n /// ```\n //\n // Upheld invariants:\n@@ -1751,6 +1754,8 @@ pub mod raw {\n //\n // (f) From `start_t` (incl.) to `end_t` (excl.) there are sequential instances\n //     of type `T`.\n+//\n+// (g) The size of `T` and `U` is equal and non-zero.\n \n pub struct PartialVec<T,U> {\n     vec: Vec<T>,\n@@ -1763,8 +1768,14 @@ pub struct PartialVec<T,U> {\n \n impl<T,U> PartialVec<T,U> {\n     /// Creates a `PartialVec` from a `Vec`.\n-    pub fn new(mut vec: Vec<T>) -> PartialVec<T,U> {\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if `T` and `U` have differing sizes or are zero-sized.\n+    pub fn from_vec(mut vec: Vec<T>) -> PartialVec<T,U> {\n         // FIXME: Assert that the types `T` and `U` have the same size.\n+        //\n+        // These asserts make sure (g) is satisfied.\n         assert!(mem::size_of::<T>() != 0);\n         assert!(mem::size_of::<U>() != 0);\n         assert!(mem::size_of::<T>() == mem::size_of::<U>());\n@@ -1793,24 +1804,24 @@ impl<T,U> PartialVec<T,U> {\n         let start_u = start as *mut U;\n         let end_u = start as *mut U;\n         let start_t = start;\n+\n+        // This points inside the vector, as the vector has length `offset`.\n         let end_t = unsafe { start_t.offset(offset) };\n \n         // (b) is satisfied, `start_u` points to the start of `vec`.\n-\n+        //\n         // (c) is also satisfied, `end_t` points to the end of `vec`.\n-\n+        //\n         // `start_u == end_u == start_t <= end_t`, so also `start_u <= end_u <=\n         // start_t <= end_t`, thus (b).\n-\n+        //\n         // As `start_u == end_u`, it is represented correctly that there are no\n         // instances of `U` in `vec`, thus (e) is satisfied.\n-\n+        //\n         // At start, there are only elements of type `T` in `vec`, so (f) is\n         // satisfied, as `start_t` points to the start of `vec` and `end_t` to\n         // the end of it.\n \n-        // This points inside the vector, as the vector has length `offset`.\n-\n         PartialVec {\n             // (a) is satisfied, `vec` isn't modified in the function.\n             vec: vec,\n@@ -1823,8 +1834,8 @@ impl<T,U> PartialVec<T,U> {\n \n     /// Pops a `T` from the `PartialVec`.\n     ///\n-    /// Returns `Some(t)` if there are more `T`s in the vector, otherwise\n-    /// `None`.\n+    /// Removes the next `T` from the vector and returns it as `Some(T)`, or\n+    /// `None` if there are none left.\n     fn pop(&mut self) -> Option<T> {\n         // The `if` ensures that there are more `T`s in `vec`.\n         if self.start_t < self.end_t {\n@@ -1869,21 +1880,26 @@ impl<T,U> PartialVec<T,U> {\n     ///\n     /// Fails if not all `T`s were popped, also fails if not the same amount of\n     /// `U`s was pushed before calling `unwrap`.\n-    pub fn into_vec(self) -> Vec<U> {\n+    pub fn into_vec(mut self) -> Vec<U> {\n         // If `self.end_u == self.end_t`, we know from (e) that there are no\n         // more `T`s in `vec`, we also know that the whole length of `vec` is\n-        // now used by `U`s, thus we can just transmute `vec` from a vector of\n-        // `T`s to a vector of `U`s safely.\n+        // now used by `U`s, thus we can just interpret `vec` as a vector of\n+        // `U` safely.\n \n         assert!(self.end_u as *const () == self.end_t as *const (),\n             \"trying to unwrap a PartialVec before completing the writes to it\");\n \n         // Extract `vec` and prevent the destructor of `PartialVec` from\n-        // running.\n+        // running. Note that none of the function calls can fail, thus no\n+        // resources can be leaked (as the `vec` member of `PartialVec` is the\n+        // only one which holds allocations -- and it is returned from this\n+        // function.\n         unsafe {\n-            let vec = ptr::read(&self.vec);\n+            let vec_len = self.vec.len();\n+            let vec_cap = self.vec.capacity();\n+            let vec_ptr = self.vec.as_mut_ptr() as *mut U;\n             mem::forget(self);\n-            mem::transmute(vec)\n+            Vec::from_raw_parts(vec_len, vec_cap, vec_ptr)\n         }\n     }\n }\n@@ -1923,24 +1939,29 @@ impl<T,U> Iterator<T> for PartialVec<T,U> {\n }\n \n impl<T> Vec<T> {\n-    /// Converts a `Vec<T>` to a `Vec<U>` where `T` and `U` have the same size.\n+    /// Converts a `Vec<T>` to a `Vec<U>` where `T` and `U` have the same\n+    /// non-zero size.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if `T` and `U` have differing sizes or are zero-sized.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n     /// let v = vec![0u, 1, 2];\n     /// let w = v.map_inplace(|i| i + 3);\n-    /// assert_eq!(w.as_slice() == &[3, 4, 5]);\n+    /// assert_eq!(w.as_slice(), &[3, 4, 5]);\n     ///\n     /// let big_endian_u16s = vec![0x1122u16, 0x3344];\n     /// let u8s = big_endian_u16s.map_inplace(|x| [\n     ///     ((x >> 8) & 0xff) as u8,\n     ///     (x & 0xff) as u8\n     /// ]);\n-    /// assert_eq!(u8s.as_slice() == &[[0x11, 0x22], [0x33, 0x44]]);\n+    /// assert_eq!(u8s.as_slice(), &[[0x11, 0x22], [0x33, 0x44]]);\n     /// ```\n     pub fn map_inplace<U>(self, f: |T| -> U) -> Vec<U> {\n-        let mut pv = PartialVec::new(self);\n+        let mut pv = PartialVec::from_vec(self);\n         loop {\n             let maybe_t = pv.pop();\n             match maybe_t {\n@@ -2292,7 +2313,7 @@ mod tests {\n     #[test]\n     fn test_map_inplace() {\n         let v = vec![0u, 1, 2];\n-        assert_eq!(v.map_inplace(|i: uint| i as int - 1).as_slice, &[-1i, 0, 1]);\n+        assert_eq!(v.map_inplace(|i: uint| i as int - 1).as_slice(), &[-1i, 0, 1]);\n     }\n \n     #[bench]"}]}