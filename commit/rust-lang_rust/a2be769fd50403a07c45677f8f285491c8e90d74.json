{"sha": "a2be769fd50403a07c45677f8f285491c8e90d74", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyYmU3NjlmZDUwNDAzYTA3YzQ1Njc3ZjhmMjg1NDkxYzhlOTBkNzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-01T18:43:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-01T18:43:41Z"}, "message": "Auto merge of #51833 - wesleywiser:faster_large_constant_arrays, r=oli-obk\n\nSpeed up compilation of large constant arrays\n\nThis is a different approach to #51672 as suggested by @oli-obk. Rather\nthan write each repeated value one-by-one, we write the first one and\nthen copy its value directly into the remaining memory.\n\nWith this change, the [toy program](https://github.com/rust-lang/rust/blob/c2f4744d2db4e162df824d0bd0b093ba4b351545/src/test/run-pass/mir_heavy_promoted.rs) goes from 63 seconds to 19 seconds on my machine.\n\nEdit: Inlining `Size::bytes()` saves an additional 6 seconds dropping the total time to 13 seconds on my machine.\n\nEdit2: Now down to 2.8 seconds.\n\nr? @oli-obk\n\ncc @nnethercote @eddyb", "tree": {"sha": "898d003c54271e6be9ca89de25668091d9f3336d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/898d003c54271e6be9ca89de25668091d9f3336d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2be769fd50403a07c45677f8f285491c8e90d74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2be769fd50403a07c45677f8f285491c8e90d74", "html_url": "https://github.com/rust-lang/rust/commit/a2be769fd50403a07c45677f8f285491c8e90d74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2be769fd50403a07c45677f8f285491c8e90d74/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6af9f91a170d33550e8f5922cdb728384ec9c7eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6af9f91a170d33550e8f5922cdb728384ec9c7eb", "html_url": "https://github.com/rust-lang/rust/commit/6af9f91a170d33550e8f5922cdb728384ec9c7eb"}, {"sha": "46512e09c9f97a68a36e2d72e3be766b1e76a1a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/46512e09c9f97a68a36e2d72e3be766b1e76a1a0", "html_url": "https://github.com/rust-lang/rust/commit/46512e09c9f97a68a36e2d72e3be766b1e76a1a0"}], "stats": {"total": 143, "additions": 118, "deletions": 25}, "files": [{"sha": "f5b449d68e78fc843cece246c5cab247833a1793", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2be769fd50403a07c45677f8f285491c8e90d74/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2be769fd50403a07c45677f8f285491c8e90d74/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=a2be769fd50403a07c45677f8f285491c8e90d74", "patch": "@@ -638,11 +638,13 @@ impl UndefMask {\n         }\n     }\n \n+    #[inline]\n     pub fn get(&self, i: Size) -> bool {\n         let (block, bit) = bit_index(i);\n         (self.blocks[block] & 1 << bit) != 0\n     }\n \n+    #[inline]\n     pub fn set(&mut self, i: Size, new_state: bool) {\n         let (block, bit) = bit_index(i);\n         if new_state {\n@@ -667,6 +669,7 @@ impl UndefMask {\n     }\n }\n \n+#[inline]\n fn bit_index(bits: Size) -> (usize, usize) {\n     let bits = bits.bytes();\n     let a = bits / BLOCK_SIZE;"}, {"sha": "15d8b9c36215a990ece3e7f18108a1f925b81ead", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a2be769fd50403a07c45677f8f285491c8e90d74/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2be769fd50403a07c45677f8f285491c8e90d74/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=a2be769fd50403a07c45677f8f285491c8e90d74", "patch": "@@ -579,10 +579,14 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n                 let (dest, dest_align) = self.force_allocation(dest)?.to_ptr_align();\n \n-                // FIXME: speed up repeat filling\n-                for i in 0..length {\n-                    let elem_dest = dest.ptr_offset(elem_size * i as u64, &self)?;\n-                    self.write_value_to_ptr(value, elem_dest, dest_align, elem_ty)?;\n+                if length > 0 {\n+                    //write the first value\n+                    self.write_value_to_ptr(value, dest, dest_align, elem_ty)?;\n+\n+                    if length > 1 {\n+                        let rest = dest.ptr_offset(elem_size * 1 as u64, &self)?;\n+                        self.memory.copy_repeatedly(dest, dest_align, rest, dest_align, elem_size, length - 1, false)?;\n+                    }\n                 }\n             }\n "}, {"sha": "3cd492c50eeca0d0febb6a0dd0061fde35255fa7", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 51, "deletions": 21, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a2be769fd50403a07c45677f8f285491c8e90d74/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2be769fd50403a07c45677f8f285491c8e90d74/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=a2be769fd50403a07c45677f8f285491c8e90d74", "patch": "@@ -589,6 +589,19 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         dest_align: Align,\n         size: Size,\n         nonoverlapping: bool,\n+    ) -> EvalResult<'tcx> {\n+        self.copy_repeatedly(src, src_align, dest, dest_align, size, 1, nonoverlapping)\n+    }\n+\n+    pub fn copy_repeatedly(\n+        &mut self,\n+        src: Scalar,\n+        src_align: Align,\n+        dest: Scalar,\n+        dest_align: Align,\n+        size: Size,\n+        length: u64,\n+        nonoverlapping: bool,\n     ) -> EvalResult<'tcx> {\n         // Empty accesses don't need to be valid pointers, but they should still be aligned\n         self.check_align(src, src_align)?;\n@@ -603,16 +616,24 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         // first copy the relocations to a temporary buffer, because\n         // `get_bytes_mut` will clear the relocations, which is correct,\n         // since we don't want to keep any relocations at the target.\n-        let relocations: Vec<_> = self.relocations(src, size)?\n-            .iter()\n-            .map(|&(offset, alloc_id)| {\n-                // Update relocation offsets for the new positions in the destination allocation.\n-                (offset + dest.offset - src.offset, alloc_id)\n-            })\n-            .collect();\n+        let relocations = {\n+            let relocations = self.relocations(src, size)?;\n+            let mut new_relocations = Vec::with_capacity(relocations.len() * (length as usize));\n+            for i in 0..length {\n+                new_relocations.extend(\n+                    relocations\n+                    .iter()\n+                    .map(|&(offset, alloc_id)| {\n+                    (offset + dest.offset - src.offset + (i * size * relocations.len() as u64), alloc_id)\n+                    })\n+                );\n+            }\n+\n+            new_relocations\n+        };\n \n         let src_bytes = self.get_bytes_unchecked(src, size, src_align)?.as_ptr();\n-        let dest_bytes = self.get_bytes_mut(dest, size, dest_align)?.as_mut_ptr();\n+        let dest_bytes = self.get_bytes_mut(dest, size * length, dest_align)?.as_mut_ptr();\n \n         // SAFE: The above indexing would have panicked if there weren't at least `size` bytes\n         // behind `src` and `dest`. Also, we use the overlapping-safe `ptr::copy` if `src` and\n@@ -629,13 +650,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                         ));\n                     }\n                 }\n-                ptr::copy(src_bytes, dest_bytes, size.bytes() as usize);\n+\n+                for i in 0..length {\n+                    ptr::copy(src_bytes, dest_bytes.offset((size.bytes() * i) as isize), size.bytes() as usize);\n+                }\n             } else {\n-                ptr::copy_nonoverlapping(src_bytes, dest_bytes, size.bytes() as usize);\n+                for i in 0..length {\n+                    ptr::copy_nonoverlapping(src_bytes, dest_bytes.offset((size.bytes() * i) as isize), size.bytes() as usize);\n+                }\n             }\n         }\n \n-        self.copy_undef_mask(src, dest, size)?;\n+        self.copy_undef_mask(src, dest, size, length)?;\n         // copy back the relocations\n         self.get_mut(dest.alloc_id)?.relocations.insert_presorted(relocations);\n \n@@ -856,21 +882,25 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         src: Pointer,\n         dest: Pointer,\n         size: Size,\n+        repeat: u64,\n     ) -> EvalResult<'tcx> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n-        let mut v = Vec::with_capacity(size.bytes() as usize);\n+\n+        let undef_mask = self.get(src.alloc_id)?.undef_mask.clone();\n+        let dest_allocation = self.get_mut(dest.alloc_id)?;\n+\n         for i in 0..size.bytes() {\n-            let defined = self.get(src.alloc_id)?.undef_mask.get(src.offset + Size::from_bytes(i));\n-            v.push(defined);\n-        }\n-        for (i, defined) in v.into_iter().enumerate() {\n-            self.get_mut(dest.alloc_id)?.undef_mask.set(\n-                dest.offset +\n-                    Size::from_bytes(i as u64),\n-                defined,\n-            );\n+            let defined = undef_mask.get(src.offset + Size::from_bytes(i));\n+            \n+            for j in 0..repeat {\n+                dest_allocation.undef_mask.set(\n+                    dest.offset + Size::from_bytes(i + (size.bytes() * j)),\n+                    defined\n+                );\n+            }\n         }\n+\n         Ok(())\n     }\n "}, {"sha": "57622692426636bc6562d57a8ba07e7fd24544fe", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a2be769fd50403a07c45677f8f285491c8e90d74/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2be769fd50403a07c45677f8f285491c8e90d74/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=a2be769fd50403a07c45677f8f285491c8e90d74", "patch": "@@ -229,37 +229,44 @@ pub struct Size {\n impl Size {\n     pub const ZERO: Size = Self::from_bytes(0);\n \n+    #[inline]\n     pub fn from_bits(bits: u64) -> Size {\n         // Avoid potential overflow from `bits + 7`.\n         Size::from_bytes(bits / 8 + ((bits % 8) + 7) / 8)\n     }\n \n+    #[inline]\n     pub const fn from_bytes(bytes: u64) -> Size {\n         Size {\n             raw: bytes\n         }\n     }\n \n+    #[inline]\n     pub fn bytes(self) -> u64 {\n         self.raw\n     }\n \n+    #[inline]\n     pub fn bits(self) -> u64 {\n         self.bytes().checked_mul(8).unwrap_or_else(|| {\n             panic!(\"Size::bits: {} bytes in bits doesn't fit in u64\", self.bytes())\n         })\n     }\n \n+    #[inline]\n     pub fn abi_align(self, align: Align) -> Size {\n         let mask = align.abi() - 1;\n         Size::from_bytes((self.bytes() + mask) & !mask)\n     }\n \n+    #[inline]\n     pub fn is_abi_aligned(self, align: Align) -> bool {\n         let mask = align.abi() - 1;\n         self.bytes() & mask == 0\n     }\n \n+    #[inline]\n     pub fn checked_add<C: HasDataLayout>(self, offset: Size, cx: C) -> Option<Size> {\n         let dl = cx.data_layout();\n \n@@ -272,6 +279,7 @@ impl Size {\n         }\n     }\n \n+    #[inline]\n     pub fn checked_mul<C: HasDataLayout>(self, count: u64, cx: C) -> Option<Size> {\n         let dl = cx.data_layout();\n \n@@ -289,6 +297,7 @@ impl Size {\n \n impl Add for Size {\n     type Output = Size;\n+    #[inline]\n     fn add(self, other: Size) -> Size {\n         Size::from_bytes(self.bytes().checked_add(other.bytes()).unwrap_or_else(|| {\n             panic!(\"Size::add: {} + {} doesn't fit in u64\", self.bytes(), other.bytes())\n@@ -298,6 +307,7 @@ impl Add for Size {\n \n impl Sub for Size {\n     type Output = Size;\n+    #[inline]\n     fn sub(self, other: Size) -> Size {\n         Size::from_bytes(self.bytes().checked_sub(other.bytes()).unwrap_or_else(|| {\n             panic!(\"Size::sub: {} - {} would result in negative size\", self.bytes(), other.bytes())\n@@ -307,13 +317,15 @@ impl Sub for Size {\n \n impl Mul<Size> for u64 {\n     type Output = Size;\n+    #[inline]\n     fn mul(self, size: Size) -> Size {\n         size * self\n     }\n }\n \n impl Mul<u64> for Size {\n     type Output = Size;\n+    #[inline]\n     fn mul(self, count: u64) -> Size {\n         match self.bytes().checked_mul(count) {\n             Some(bytes) => Size::from_bytes(bytes),\n@@ -325,6 +337,7 @@ impl Mul<u64> for Size {\n }\n \n impl AddAssign for Size {\n+    #[inline]\n     fn add_assign(&mut self, other: Size) {\n         *self = *self + other;\n     }"}, {"sha": "09ebf1681c5e04540f1e2114ee38b26af06f68a4", "filename": "src/test/compile-fail/const-err4.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a2be769fd50403a07c45677f8f285491c8e90d74/src%2Ftest%2Fcompile-fail%2Fconst-err4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2be769fd50403a07c45677f8f285491c8e90d74/src%2Ftest%2Fcompile-fail%2Fconst-err4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err4.rs?ref=a2be769fd50403a07c45677f8f285491c8e90d74", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[derive(Copy, Clone)]\n+union Foo {\n+    a: isize,\n+    b: (),\n+}\n+\n+enum Bar {\n+    Boo = [unsafe { Foo { b: () }.a }; 4][3],\n+    //~^ ERROR constant evaluation of enum discriminant resulted in non-integer\n+}\n+\n+fn main() {\n+    assert_ne!(Bar::Boo as isize, 0);\n+}"}, {"sha": "1d749a2626e9f994aa60a7b975712feb67b6f3ae", "filename": "src/test/run-pass/const-repeated-values.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a2be769fd50403a07c45677f8f285491c8e90d74/src%2Ftest%2Frun-pass%2Fconst-repeated-values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2be769fd50403a07c45677f8f285491c8e90d74/src%2Ftest%2Frun-pass%2Fconst-repeated-values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-repeated-values.rs?ref=a2be769fd50403a07c45677f8f285491c8e90d74", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const FOO: isize = 42;\n+\n+enum Bar {\n+    Boo = *[&FOO; 4][3],\n+}\n+\n+fn main() {\n+    assert_eq!(Bar::Boo as isize, 42);\n+}"}]}