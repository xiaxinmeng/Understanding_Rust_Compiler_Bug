{"sha": "f547a671dcc64530f0cf07f39698d63174f37733", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1NDdhNjcxZGNjNjQ1MzBmMGNmMDdmMzk2OThkNjMxNzRmMzc3MzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-09T20:45:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-09T20:45:49Z"}, "message": "auto merge of #6373 : nikomatsakis/rust/issue-6355-perf-regression, r=graydon\n\nFix #6355 and #6272---we were not giving the correct index to the derefs that occur as part of the rooting process, resulting in extra copies and generally bogus behavior. Haven't quite produced the right test for this, but I thought I'd push the fix in the meantime. Test will follow shortly.\r\n\r\nr? @graydon", "tree": {"sha": "7922bd8d928f079555c6c0681ac2d38bca6a6a6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7922bd8d928f079555c6c0681ac2d38bca6a6a6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f547a671dcc64530f0cf07f39698d63174f37733", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f547a671dcc64530f0cf07f39698d63174f37733", "html_url": "https://github.com/rust-lang/rust/commit/f547a671dcc64530f0cf07f39698d63174f37733", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f547a671dcc64530f0cf07f39698d63174f37733/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76758562539ef3c439dd28ad53636f6b70382e7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/76758562539ef3c439dd28ad53636f6b70382e7b", "html_url": "https://github.com/rust-lang/rust/commit/76758562539ef3c439dd28ad53636f6b70382e7b"}, {"sha": "e18ed77b720b46cc8ae0e6754698c47f51bed9a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e18ed77b720b46cc8ae0e6754698c47f51bed9a0", "html_url": "https://github.com/rust-lang/rust/commit/e18ed77b720b46cc8ae0e6754698c47f51bed9a0"}], "stats": {"total": 111, "additions": 76, "deletions": 35}, "files": [{"sha": "94a029911a87a7c1b0a63876cfdbd95598337d36", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f547a671dcc64530f0cf07f39698d63174f37733/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f547a671dcc64530f0cf07f39698d63174f37733/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=f547a671dcc64530f0cf07f39698d63174f37733", "patch": "@@ -260,7 +260,7 @@ pub impl GatherLoanCtxt {\n                                              r)\n                     }\n                     ty::AutoBorrowVec(r, m) | ty::AutoBorrowVecRef(r, m) => {\n-                        let cmt_index = mcx.cat_index(expr, cmt);\n+                        let cmt_index = mcx.cat_index(expr, cmt, autoderefs+1);\n                         self.guarantee_valid(expr.id,\n                                              expr.span,\n                                              cmt_index,\n@@ -574,7 +574,7 @@ pub impl GatherLoanCtxt {\n                   let (slice_mutbl, slice_r) =\n                       self.vec_slice_info(slice_pat, slice_ty);\n                   let mcx = self.bccx.mc_ctxt();\n-                  let cmt_index = mcx.cat_index(slice_pat, cmt);\n+                  let cmt_index = mcx.cat_index(slice_pat, cmt, 0);\n                   self.guarantee_valid(pat.id, pat.span,\n                                        cmt_index, slice_mutbl, slice_r);\n               }"}, {"sha": "75acc2d95113831d95f707ea9a3a1e80ac74f232", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f547a671dcc64530f0cf07f39698d63174f37733/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f547a671dcc64530f0cf07f39698d63174f37733/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=f547a671dcc64530f0cf07f39698d63174f37733", "patch": "@@ -184,6 +184,16 @@ pub type LoanMap = @mut HashMap<ast::node_id, @Loan>;\n //\n // Note that there is no entry with derefs:3---the type of that expression\n // is T, which is not a box.\n+//\n+// Note that implicit dereferences also occur with indexing of `@[]`,\n+// `@str`, etc.  The same rules apply. So, for example, given a\n+// variable `x` of type `@[@[...]]`, if I have an instance of the\n+// expression `x[0]` which is then auto-slice'd, there would be two\n+// potential entries in the root map, both with the id of the `x[0]`\n+// expression. The entry with `derefs==0` refers to the deref of `x`\n+// used as part of evaluating `x[0]`. The entry with `derefs==1`\n+// refers to the deref of the `x[0]` that occurs as part of the\n+// auto-slice.\n #[deriving(Eq, IterBytes)]\n pub struct root_map_key {\n     id: ast::node_id,\n@@ -605,7 +615,7 @@ pub impl BorrowckCtxt {\n                 }\n             }\n \n-            LpExtend(lp_base, _, LpInterior(mc::interior_field(fld, _))) => {\n+            LpExtend(lp_base, _, LpInterior(mc::interior_field(fld))) => {\n                 self.append_loan_path_to_str_from_interior(lp_base, out);\n                 str::push_char(out, '.');\n                 str::push_str(out, *self.tcx.sess.intr().get(fld));"}, {"sha": "0e819c66f094d1a4594fcde57afa6a9ff213c631", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 44, "deletions": 20, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f547a671dcc64530f0cf07f39698d63174f37733/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f547a671dcc64530f0cf07f39698d63174f37733/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f547a671dcc64530f0cf07f39698d63174f37733", "patch": "@@ -66,7 +66,7 @@ pub enum categorization {\n     cat_local(ast::node_id),           // local variable\n     cat_arg(ast::node_id),             // formal argument\n     cat_deref(cmt, uint, ptr_kind),    // deref of a ptr\n-    cat_interior(cmt, interior_kind),          // something interior\n+    cat_interior(cmt, interior_kind),  // something interior\n     cat_discr(cmt, ast::node_id),      // match discriminant (see preserve())\n     cat_self(ast::node_id),            // explicit `self`\n }\n@@ -94,8 +94,7 @@ pub enum interior_kind {\n     interior_anon_field,             // anonymous field (in e.g.\n                                      // struct Foo(int, int);\n     interior_variant(ast::def_id),   // internals to a variant of given enum\n-    interior_field(ast::ident,       // name of field\n-                   ast::mutability), // declared mutability of field\n+    interior_field(ast::ident),      // name of field\n     interior_index(ty::t,            // type of vec/str/etc being deref'd\n                    ast::mutability)  // mutability of vec content\n }\n@@ -395,8 +394,7 @@ pub impl mem_categorization_ctxt {\n             assert!(!self.method_map.contains_key(&expr.id));\n \n             let base_cmt = self.cat_expr(base);\n-            self.cat_field(expr, base_cmt, f_name,\n-                           self.expr_ty(expr), expr.id)\n+            self.cat_field(expr, base_cmt, f_name, self.expr_ty(expr))\n           }\n \n           ast::expr_index(base, _) => {\n@@ -405,7 +403,7 @@ pub impl mem_categorization_ctxt {\n             }\n \n             let base_cmt = self.cat_expr(base);\n-            self.cat_index(expr, base_cmt)\n+            self.cat_index(expr, base_cmt, 0)\n           }\n \n           ast::expr_path(_) => {\n@@ -579,16 +577,12 @@ pub impl mem_categorization_ctxt {\n                              node: N,\n                              base_cmt: cmt,\n                              f_name: ast::ident,\n-                             f_ty: ty::t,\n-                             field_id: ast::node_id) -> cmt {\n-        let f_mutbl = m_imm;\n-        let m = self.inherited_mutability(base_cmt.mutbl, f_mutbl);\n-        let f_interior = interior_field(f_name, f_mutbl);\n+                             f_ty: ty::t) -> cmt {\n         @cmt_ {\n             id: node.id(),\n             span: node.span(),\n-            cat: cat_interior(base_cmt, f_interior),\n-            mutbl: m,\n+            cat: cat_interior(base_cmt, interior_field(f_name)),\n+            mutbl: base_cmt.mutbl.inherit(),\n             ty: f_ty\n         }\n     }\n@@ -670,7 +664,39 @@ pub impl mem_categorization_ctxt {\n \n     fn cat_index<N:ast_node>(&self,\n                              elt: N,\n-                             base_cmt: cmt) -> cmt {\n+                             base_cmt: cmt,\n+                             derefs: uint) -> cmt {\n+        //! Creates a cmt for an indexing operation (`[]`); this\n+        //! indexing operation may occurs as part of an\n+        //! AutoBorrowVec, which when converting a `~[]` to an `&[]`\n+        //! effectively takes the address of the 0th element.\n+        //!\n+        //! One subtle aspect of indexing that may not be\n+        //! immediately obvious: for anything other than a fixed-length\n+        //! vector, an operation like `x[y]` actually consists of two\n+        //! disjoint (from the point of view of borrowck) operations.\n+        //! The first is a deref of `x` to create a pointer `p` that points\n+        //! at the first element in the array. The second operation is\n+        //! an index which adds `y*sizeof(T)` to `p` to obtain the\n+        //! pointer to `x[y]`. `cat_index` will produce a resulting\n+        //! cmt containing both this deref and the indexing,\n+        //! presuming that `base_cmt` is not of fixed-length type.\n+        //!\n+        //! In the event that a deref is needed, the \"deref count\"\n+        //! is taken from the parameter `derefs`. See the comment\n+        //! on the def'n of `root_map_key` in borrowck/mod.rs\n+        //! for more details about deref counts; the summary is\n+        //! that `derefs` should be 0 for an explicit indexing\n+        //! operation and N+1 for an indexing that is part of\n+        //! an auto-adjustment, where N is the number of autoderefs\n+        //! in that adjustment.\n+        //!\n+        //! # Parameters\n+        //! - `elt`: the AST node being indexed\n+        //! - `base_cmt`: the cmt of `elt`\n+        //! - `derefs`: the deref number to be used for\n+        //!   the implicit index deref, if any (see above)\n+\n         let mt = match ty::index(base_cmt.ty) {\n           Some(mt) => mt,\n           None => {\n@@ -698,7 +724,7 @@ pub impl mem_categorization_ctxt {\n             let deref_cmt = @cmt_ {\n                 id:elt.id(),\n                 span:elt.span(),\n-                cat:cat_deref(base_cmt, 0u, ptr),\n+                cat:cat_deref(base_cmt, derefs, ptr),\n                 mutbl:m,\n                 ty:mt.ty\n             };\n@@ -854,8 +880,7 @@ pub impl mem_categorization_ctxt {\n             // {f1: p1, ..., fN: pN}\n             for field_pats.each |fp| {\n                 let field_ty = self.pat_ty(fp.pat); // see (*)\n-                let cmt_field = self.cat_field(pat, cmt, fp.ident,\n-                                               field_ty, pat.id);\n+                let cmt_field = self.cat_field(pat, cmt, fp.ident, field_ty);\n                 self.cat_pattern(cmt_field, fp.pat, op);\n             }\n           }\n@@ -878,8 +903,8 @@ pub impl mem_categorization_ctxt {\n           }\n \n           ast::pat_vec(ref before, slice, ref after) => {\n+              let elt_cmt = self.cat_index(pat, cmt, 0);\n               for before.each |&before_pat| {\n-                  let elt_cmt = self.cat_index(pat, cmt);\n                   self.cat_pattern(elt_cmt, before_pat, op);\n               }\n               for slice.each |&slice_pat| {\n@@ -888,7 +913,6 @@ pub impl mem_categorization_ctxt {\n                   self.cat_pattern(slice_cmt, slice_pat, op);\n               }\n               for after.each |&after_pat| {\n-                  let elt_cmt = self.cat_index(pat, cmt);\n                   self.cat_pattern(elt_cmt, after_pat, op);\n               }\n           }\n@@ -1110,7 +1134,7 @@ pub fn ptr_sigil(ptr: ptr_kind) -> ~str {\n impl Repr for interior_kind {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n-            interior_field(fld, _) => copy *tcx.sess.str_of(fld),\n+            interior_field(fld) => copy *tcx.sess.str_of(fld),\n             interior_index(*) => ~\"[]\",\n             interior_tuple => ~\"()\",\n             interior_anon_field => ~\"<anonymous field>\","}, {"sha": "f94e646d3e25c9a0fcfe42bd5e07e6129f94cf01", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f547a671dcc64530f0cf07f39698d63174f37733/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f547a671dcc64530f0cf07f39698d63174f37733/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=f547a671dcc64530f0cf07f39698d63174f37733", "patch": "@@ -885,7 +885,8 @@ pub fn extract_vec_elems(bcx: block,\n                       -> ExtractedBlock {\n     let _icx = bcx.insn_ctxt(\"match::extract_vec_elems\");\n     let vec_datum = match_datum(bcx, val, pat_id);\n-    let (bcx, base, len) = vec_datum.get_vec_base_and_len(bcx, pat_span, pat_id);\n+    let (bcx, base, len) = vec_datum.get_vec_base_and_len(bcx, pat_span,\n+                                                          pat_id, 0);\n     let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n \n     let mut elems = do vec::from_fn(elem_count) |i| {"}, {"sha": "64b29fd8573d290f6ce74f768510437763c1acda", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f547a671dcc64530f0cf07f39698d63174f37733/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f547a671dcc64530f0cf07f39698d63174f37733/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=f547a671dcc64530f0cf07f39698d63174f37733", "patch": "@@ -735,13 +735,14 @@ pub impl Datum {\n     fn get_vec_base_and_len(&self,\n                             mut bcx: block,\n                             span: span,\n-                            expr_id: ast::node_id)\n+                            expr_id: ast::node_id,\n+                            derefs: uint)\n                             -> (block, ValueRef, ValueRef) {\n         //! Converts a vector into the slice pair. Performs rooting\n         //! and write guards checks.\n \n         // only imp't for @[] and @str, but harmless\n-        bcx = write_guard::root_and_write_guard(self, bcx, span, expr_id, 0);\n+        bcx = write_guard::root_and_write_guard(self, bcx, span, expr_id, derefs);\n         let (base, len) = self.get_vec_base_and_len_no_root(bcx);\n         (bcx, base, len)\n     }"}, {"sha": "698c30a6a42ff8168cf722488f606f74726f757d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f547a671dcc64530f0cf07f39698d63174f37733/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f547a671dcc64530f0cf07f39698d63174f37733/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=f547a671dcc64530f0cf07f39698d63174f37733", "patch": "@@ -144,10 +144,9 @@ use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::ty::struct_fields;\n use middle::ty::{AutoDerefRef, AutoAddEnv};\n-use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn};\n-use middle::ty;\n use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn,\n                  AutoDerefRef, AutoAddEnv, AutoUnsafe};\n+use middle::ty;\n use util::common::indenter;\n use util::ppaux::Repr;\n \n@@ -215,10 +214,12 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n                     unpack_datum!(bcx, auto_ref(bcx, datum))\n                 }\n                 Some(AutoBorrowVec(*)) => {\n-                    unpack_datum!(bcx, auto_slice(bcx, expr, datum))\n+                    unpack_datum!(bcx, auto_slice(bcx, adj.autoderefs,\n+                                                  expr, datum))\n                 }\n                 Some(AutoBorrowVecRef(*)) => {\n-                    unpack_datum!(bcx, auto_slice_and_ref(bcx, expr, datum))\n+                    unpack_datum!(bcx, auto_slice_and_ref(bcx, adj.autoderefs,\n+                                                          expr, datum))\n                 }\n                 Some(AutoBorrowFn(*)) => {\n                     let adjusted_ty = ty::adjust_ty(bcx.tcx(), expr.span,\n@@ -246,7 +247,10 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n                                   mode: datum.mode, source: datum.source}}\n     }\n \n-    fn auto_slice(bcx: block, expr: @ast::expr, datum: Datum) -> DatumBlock {\n+    fn auto_slice(bcx: block,\n+                  autoderefs: uint,\n+                  expr: @ast::expr,\n+                  datum: Datum) -> DatumBlock {\n         // This is not the most efficient thing possible; since slices\n         // are two words it'd be better if this were compiled in\n         // 'dest' mode, but I can't find a nice way to structure the\n@@ -256,9 +260,8 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         let tcx = bcx.tcx();\n         let unit_ty = ty::sequence_element_type(tcx, datum.ty);\n \n-        // FIXME(#6272) need to distinguish \"auto-slice\" from explicit index?\n         let (bcx, base, len) =\n-            datum.get_vec_base_and_len(bcx, expr.span, expr.id);\n+            datum.get_vec_base_and_len(bcx, expr.span, expr.id, autoderefs+1);\n \n         // this type may have a different region/mutability than the\n         // real one, but it will have the same runtime representation\n@@ -292,9 +295,10 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n     }\n \n     fn auto_slice_and_ref(bcx: block,\n+                          autoderefs: uint,\n                           expr: @ast::expr,\n                           datum: Datum) -> DatumBlock {\n-        let DatumBlock { bcx, datum } = auto_slice(bcx, expr, datum);\n+        let DatumBlock { bcx, datum } = auto_slice(bcx, autoderefs, expr, datum);\n         auto_ref(bcx, datum)\n     }\n }\n@@ -913,7 +917,8 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         base::maybe_name_value(bcx.ccx(), scaled_ix, ~\"scaled_ix\");\n \n         let mut (bcx, base, len) =\n-            base_datum.get_vec_base_and_len(bcx, index_expr.span, index_expr.id);\n+            base_datum.get_vec_base_and_len(bcx, index_expr.span,\n+                                            index_expr.id, 0);\n \n         if ty::type_is_str(base_ty) {\n             // acccount for null terminator in the case of string"}]}