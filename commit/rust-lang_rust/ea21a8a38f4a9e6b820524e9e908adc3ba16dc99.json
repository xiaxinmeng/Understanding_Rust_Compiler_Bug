{"sha": "ea21a8a38f4a9e6b820524e9e908adc3ba16dc99", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhMjFhOGEzOGY0YTllNmI4MjA1MjRlOWU5MDhhZGMzYmExNmRjOTk=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-03T15:34:41Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-10T11:06:49Z"}, "message": "some more comments for const_qualif", "tree": {"sha": "469a31ec9bed0ce99304515cd6174d65689361b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/469a31ec9bed0ce99304515cd6174d65689361b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea21a8a38f4a9e6b820524e9e908adc3ba16dc99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea21a8a38f4a9e6b820524e9e908adc3ba16dc99", "html_url": "https://github.com/rust-lang/rust/commit/ea21a8a38f4a9e6b820524e9e908adc3ba16dc99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea21a8a38f4a9e6b820524e9e908adc3ba16dc99/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cbd8a4d686d1411105f26cddf876c5994e69593", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cbd8a4d686d1411105f26cddf876c5994e69593", "html_url": "https://github.com/rust-lang/rust/commit/1cbd8a4d686d1411105f26cddf876c5994e69593"}], "stats": {"total": 43, "additions": 28, "deletions": 15}, "files": [{"sha": "26a24d4e36b4c15771e6125b4d8ed0c869511ac9", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ea21a8a38f4a9e6b820524e9e908adc3ba16dc99/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea21a8a38f4a9e6b820524e9e908adc3ba16dc99/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=ea21a8a38f4a9e6b820524e9e908adc3ba16dc99", "patch": "@@ -135,6 +135,12 @@ enum ValueSource<'a, 'tcx> {\n     },\n }\n \n+/// A \"qualif\" is a way to lookg for something \"bad\" in the MIR that would prevent\n+/// proper const evaluation.  So `return true` means \"I found something bad, no reason\n+/// to go on searching\".  `false` is only returned if we definitely cannot find anything\n+/// bad anywhere.\n+///\n+/// The default implementations proceed structurally.\n trait Qualif {\n     const IDX: usize;\n \n@@ -285,7 +291,9 @@ trait Qualif {\n     }\n }\n \n-// Constant containing interior mutability (UnsafeCell).\n+/// Constant containing interior mutability (UnsafeCell).\n+/// This must be ruled out to make sure that evaluating the constant at compile-time\n+/// and run-time would produce the same result.\n struct HasMutInterior;\n \n impl Qualif for HasMutInterior {\n@@ -343,7 +351,9 @@ impl Qualif for HasMutInterior {\n     }\n }\n \n-// Constant containing an ADT that implements Drop.\n+/// Constant containing an ADT that implements Drop.\n+/// This must be ruled out because we cannot run `Drop` during compile-time\n+/// as that might not be a `const fn`.\n struct NeedsDrop;\n \n impl Qualif for NeedsDrop {\n@@ -366,8 +376,11 @@ impl Qualif for NeedsDrop {\n     }\n }\n \n-// Not promotable at all - non-`const fn` calls, asm!,\n-// pointer comparisons, ptr-to-int casts, etc.\n+/// Not promotable at all - non-`const fn` calls, asm!,\n+/// pointer comparisons, ptr-to-int casts, etc.\n+/// Inside a const context all constness rules apply, so promotion simply has to follow the regular\n+/// constant rules (modulo interior mutability or `Drop` rules which are handled `HasMutInterior`\n+/// and `NeedsDrop` respectively).\n struct IsNotPromotable;\n \n impl Qualif for IsNotPromotable {\n@@ -511,12 +524,9 @@ impl Qualif for IsNotPromotable {\n \n /// Refers to temporaries which cannot be promoted *implicitly*.\n /// Explicit promotion happens e.g. for constant arguments declared via `rustc_args_required_const`.\n-/// Inside a const context all constness rules\n-/// apply, so implicit promotion simply has to follow the regular constant rules (modulo interior\n-/// mutability or `Drop` rules which are handled `HasMutInterior` and `NeedsDrop` respectively).\n-/// Implicit promotion inside regular functions does not happen if `const fn` calls are involved,\n-/// as the call may be perfectly alright at runtime, but fail at compile time e.g. due to addresses\n-/// being compared inside the function.\n+/// Implicit promotion has almost the same rules, except that it does not happen if `const fn`\n+/// calls are involved. The call may be perfectly alright at runtime, but fail at compile time\n+/// e.g. due to addresses being compared inside the function.\n struct IsNotImplicitlyPromotable;\n \n impl Qualif for IsNotImplicitlyPromotable {\n@@ -589,6 +599,11 @@ impl ConstCx<'_, 'tcx> {\n     }\n }\n \n+/// Checks MIR for const-correctness, using `ConstCx`\n+/// for value qualifications, and accumulates writes of\n+/// rvalue/call results to locals, in `local_qualif`.\n+/// For functions (constant or not), it also records\n+/// candidates for promotion in `promotion_candidates`.\n struct Checker<'a, 'tcx> {\n     cx: ConstCx<'a, 'tcx>,\n \n@@ -757,6 +772,9 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                         // `let _: &'static _ = &(Cell::new(1), 2).1;`\n                         let mut local_qualifs = self.qualifs_in_local(local);\n                         local_qualifs[HasMutInterior] = false;\n+                        // Make sure there is no reason to prevent promotion.\n+                        // This is, in particular, the \"implicit promotion\" version of\n+                        // the check making sure that we don't run drop glue during const-eval.\n                         if !local_qualifs.0.iter().any(|&qualif| qualif) {\n                             debug!(\"qualify_consts: promotion candidate: {:?}\", candidate);\n                             self.promotion_candidates.push(candidate);\n@@ -920,11 +938,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n     }\n }\n \n-/// Checks MIR for const-correctness, using `ConstCx`\n-/// for value qualifications, and accumulates writes of\n-/// rvalue/call results to locals, in `local_qualif`.\n-/// For functions (constant or not), it also records\n-/// candidates for promotion in `promotion_candidates`.\n impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n     fn visit_place_base(\n         &mut self,"}]}