{"sha": "1799d31847294d6e3816c17679247a5c206e809a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3OTlkMzE4NDcyOTRkNmUzODE2YzE3Njc5MjQ3YTVjMjA2ZTgwOWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-30T03:54:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-30T03:54:05Z"}, "message": "Auto merge of #74876 - oli-obk:lumberjack_disable, r=RalfJung\n\nReplace all uses of `log::log_enabled` with `Debug` printers\n\ncc @RalfJung this touches a bunch of logging in the miri engine. There are some visual changes, mainly that in several cases we stop prepending lines with the module path and just have a newline.", "tree": {"sha": "65a135afde7d7d814c20e3a124341ea1110483fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65a135afde7d7d814c20e3a124341ea1110483fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1799d31847294d6e3816c17679247a5c206e809a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1799d31847294d6e3816c17679247a5c206e809a", "html_url": "https://github.com/rust-lang/rust/commit/1799d31847294d6e3816c17679247a5c206e809a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1799d31847294d6e3816c17679247a5c206e809a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e50a225fd67576e43bab1d4dfa3c97f310786a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e50a225fd67576e43bab1d4dfa3c97f310786a8", "html_url": "https://github.com/rust-lang/rust/commit/6e50a225fd67576e43bab1d4dfa3c97f310786a8"}, {"sha": "b81d164f61804764c9e7f8f670bb7a79644c4c1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b81d164f61804764c9e7f8f670bb7a79644c4c1a", "html_url": "https://github.com/rust-lang/rust/commit/b81d164f61804764c9e7f8f670bb7a79644c4c1a"}], "stats": {"total": 466, "additions": 266, "deletions": 200}, "files": [{"sha": "125a020de37b7bcc845a222faa66a72a87ed877e", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=1799d31847294d6e3816c17679247a5c206e809a", "patch": "@@ -2,7 +2,7 @@ use crate::interface::{Compiler, Result};\n use crate::proc_macro_decls;\n use crate::util;\n \n-use log::{info, log_enabled, warn};\n+use log::{info, warn};\n use once_cell::sync::Lazy;\n use rustc_ast::mut_visit::MutVisitor;\n use rustc_ast::{self, ast, visit};\n@@ -1015,21 +1015,15 @@ pub fn start_codegen<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     outputs: &OutputFilenames,\n ) -> Box<dyn Any> {\n-    if log_enabled!(::log::Level::Info) {\n-        println!(\"Pre-codegen\");\n-        tcx.print_debug_stats();\n-    }\n+    info!(\"Pre-codegen\\n{:?}\", tcx.debug_stats());\n \n     let (metadata, need_metadata_module) = encode_and_write_metadata(tcx, outputs);\n \n     let codegen = tcx.sess.time(\"codegen_crate\", move || {\n         codegen_backend.codegen_crate(tcx, metadata, need_metadata_module)\n     });\n \n-    if log_enabled!(::log::Level::Info) {\n-        println!(\"Post-codegen\");\n-        tcx.print_debug_stats();\n-    }\n+    info!(\"Post-codegen\\n{:?}\", tcx.debug_stats());\n \n     if tcx.sess.opts.output_types.contains_key(&OutputType::Mir) {\n         if let Err(e) = mir::transform::dump_mir::emit_mir(tcx, outputs) {"}, {"sha": "25320a8d6a7858f1dd242be3959b44686b9a21c7", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=1799d31847294d6e3816c17679247a5c206e809a", "patch": "@@ -26,7 +26,7 @@ use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n \n-use log::{debug, info, log_enabled};\n+use log::{debug, info};\n use proc_macro::bridge::client::ProcMacro;\n use std::path::Path;\n use std::{cmp, env, fs};\n@@ -82,24 +82,36 @@ impl std::ops::Deref for CrateMetadataRef<'_> {\n     }\n }\n \n-fn dump_crates(cstore: &CStore) {\n-    info!(\"resolved crates:\");\n-    cstore.iter_crate_data(|cnum, data| {\n-        info!(\"  name: {}\", data.name());\n-        info!(\"  cnum: {}\", cnum);\n-        info!(\"  hash: {}\", data.hash());\n-        info!(\"  reqd: {:?}\", data.dep_kind());\n-        let CrateSource { dylib, rlib, rmeta } = data.source();\n-        if let Some(dylib) = dylib {\n-            info!(\"  dylib: {}\", dylib.0.display());\n-        }\n-        if let Some(rlib) = rlib {\n-            info!(\"   rlib: {}\", rlib.0.display());\n-        }\n-        if let Some(rmeta) = rmeta {\n-            info!(\"   rmeta: {}\", rmeta.0.display());\n-        }\n-    });\n+struct CrateDump<'a>(&'a CStore);\n+\n+impl<'a> std::fmt::Debug for CrateDump<'a> {\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        writeln!(fmt, \"resolved crates:\")?;\n+        // `iter_crate_data` does not allow returning values. Thus we use a mutable variable here\n+        // that aggregates the value (and any errors that could happen).\n+        let mut res = Ok(());\n+        self.0.iter_crate_data(|cnum, data| {\n+            res = res.and(\n+                try {\n+                    writeln!(fmt, \"  name: {}\", data.name())?;\n+                    writeln!(fmt, \"  cnum: {}\", cnum)?;\n+                    writeln!(fmt, \"  hash: {}\", data.hash())?;\n+                    writeln!(fmt, \"  reqd: {:?}\", data.dep_kind())?;\n+                    let CrateSource { dylib, rlib, rmeta } = data.source();\n+                    if let Some(dylib) = dylib {\n+                        writeln!(fmt, \"  dylib: {}\", dylib.0.display())?;\n+                    }\n+                    if let Some(rlib) = rlib {\n+                        writeln!(fmt, \"   rlib: {}\", rlib.0.display())?;\n+                    }\n+                    if let Some(rmeta) = rmeta {\n+                        writeln!(fmt, \"   rmeta: {}\", rmeta.0.display())?;\n+                    }\n+                },\n+            );\n+        });\n+        res\n+    }\n }\n \n impl CStore {\n@@ -864,9 +876,7 @@ impl<'a> CrateLoader<'a> {\n         self.inject_allocator_crate(krate);\n         self.inject_panic_runtime(krate);\n \n-        if log_enabled!(log::Level::Info) {\n-            dump_crates(&self.cstore);\n-        }\n+        info!(\"{:?}\", CrateDump(&self.cstore));\n \n         self.report_unused_deps(krate);\n     }"}, {"sha": "059ae340bcfe968821f5f36d99a46165a365a837", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=1799d31847294d6e3816c17679247a5c206e809a", "patch": "@@ -9,6 +9,7 @@\n #![feature(proc_macro_internals)]\n #![feature(min_specialization)]\n #![feature(stmt_expr_attributes)]\n+#![feature(try_blocks)]\n #![feature(never_type)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "d307131a99036970d8e35d6e47db505cd6e32403", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 52, "deletions": 37, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=1799d31847294d6e3816c17679247a5c206e809a", "patch": "@@ -1831,7 +1831,7 @@ pub mod tls {\n }\n \n macro_rules! sty_debug_print {\n-    ($ctxt: expr, $($variant: ident),*) => {{\n+    ($fmt: expr, $ctxt: expr, $($variant: ident),*) => {{\n         // Curious inner module to allow variant names to be used as\n         // variable names.\n         #[allow(non_snake_case)]\n@@ -1848,7 +1848,7 @@ macro_rules! sty_debug_print {\n                 all_infer: usize,\n             }\n \n-            pub fn go(tcx: TyCtxt<'_>) {\n+            pub fn go(fmt: &mut std::fmt::Formatter<'_>, tcx: TyCtxt<'_>) -> std::fmt::Result {\n                 let mut total = DebugStat {\n                     total: 0,\n                     lt_infer: 0,\n@@ -1878,18 +1878,18 @@ macro_rules! sty_debug_print {\n                     if ct { total.ct_infer += 1; variant.ct_infer += 1 }\n                     if lt && ty && ct { total.all_infer += 1; variant.all_infer += 1 }\n                 }\n-                println!(\"Ty interner             total           ty lt ct all\");\n-                $(println!(\"    {:18}: {uses:6} {usespc:4.1}%, \\\n+                writeln!(fmt, \"Ty interner             total           ty lt ct all\")?;\n+                $(writeln!(fmt, \"    {:18}: {uses:6} {usespc:4.1}%, \\\n                             {ty:4.1}% {lt:5.1}% {ct:4.1}% {all:4.1}%\",\n                     stringify!($variant),\n                     uses = $variant.total,\n                     usespc = $variant.total as f64 * 100.0 / total.total as f64,\n                     ty = $variant.ty_infer as f64 * 100.0  / total.total as f64,\n                     lt = $variant.lt_infer as f64 * 100.0  / total.total as f64,\n                     ct = $variant.ct_infer as f64 * 100.0  / total.total as f64,\n-                    all = $variant.all_infer as f64 * 100.0  / total.total as f64);\n+                    all = $variant.all_infer as f64 * 100.0  / total.total as f64)?;\n                 )*\n-                println!(\"                  total {uses:6}        \\\n+                writeln!(fmt, \"                  total {uses:6}        \\\n                           {ty:4.1}% {lt:5.1}% {ct:4.1}% {all:4.1}%\",\n                     uses = total.total,\n                     ty = total.ty_infer as f64 * 100.0  / total.total as f64,\n@@ -1899,41 +1899,56 @@ macro_rules! sty_debug_print {\n             }\n         }\n \n-        inner::go($ctxt)\n+        inner::go($fmt, $ctxt)\n     }}\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    pub fn print_debug_stats(self) {\n-        sty_debug_print!(\n-            self,\n-            Adt,\n-            Array,\n-            Slice,\n-            RawPtr,\n-            Ref,\n-            FnDef,\n-            FnPtr,\n-            Placeholder,\n-            Generator,\n-            GeneratorWitness,\n-            Dynamic,\n-            Closure,\n-            Tuple,\n-            Bound,\n-            Param,\n-            Infer,\n-            Projection,\n-            Opaque,\n-            Foreign\n-        );\n-\n-        println!(\"InternalSubsts interner: #{}\", self.interners.substs.len());\n-        println!(\"Region interner: #{}\", self.interners.region.len());\n-        println!(\"Stability interner: #{}\", self.stability_interner.len());\n-        println!(\"Const Stability interner: #{}\", self.const_stability_interner.len());\n-        println!(\"Allocation interner: #{}\", self.allocation_interner.len());\n-        println!(\"Layout interner: #{}\", self.layout_interner.len());\n+    pub fn debug_stats(self) -> impl std::fmt::Debug + 'tcx {\n+        struct DebugStats<'tcx>(TyCtxt<'tcx>);\n+\n+        impl std::fmt::Debug for DebugStats<'tcx> {\n+            fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+                sty_debug_print!(\n+                    fmt,\n+                    self.0,\n+                    Adt,\n+                    Array,\n+                    Slice,\n+                    RawPtr,\n+                    Ref,\n+                    FnDef,\n+                    FnPtr,\n+                    Placeholder,\n+                    Generator,\n+                    GeneratorWitness,\n+                    Dynamic,\n+                    Closure,\n+                    Tuple,\n+                    Bound,\n+                    Param,\n+                    Infer,\n+                    Projection,\n+                    Opaque,\n+                    Foreign\n+                )?;\n+\n+                writeln!(fmt, \"InternalSubsts interner: #{}\", self.0.interners.substs.len())?;\n+                writeln!(fmt, \"Region interner: #{}\", self.0.interners.region.len())?;\n+                writeln!(fmt, \"Stability interner: #{}\", self.0.stability_interner.len())?;\n+                writeln!(\n+                    fmt,\n+                    \"Const Stability interner: #{}\",\n+                    self.0.const_stability_interner.len()\n+                )?;\n+                writeln!(fmt, \"Allocation interner: #{}\", self.0.allocation_interner.len())?;\n+                writeln!(fmt, \"Layout interner: #{}\", self.0.layout_interner.len())?;\n+\n+                Ok(())\n+            }\n+        }\n+\n+        DebugStats(self)\n     }\n }\n "}, {"sha": "0dac8b64910114fb58ddebb45323fc301061eda4", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=1799d31847294d6e3816c17679247a5c206e809a", "patch": "@@ -56,7 +56,7 @@ impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n         self.copy_op(place.into(), dest)?;\n \n         self.return_to_block(ret.map(|r| r.1))?;\n-        self.dump_place(*dest);\n+        trace!(\"{:?}\", self.dump_place(*dest));\n         Ok(true)\n     }\n "}, {"sha": "630b2890835da86feab408c66fd5f9dc2ea3d339", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 58, "deletions": 48, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=1799d31847294d6e3816c17679247a5c206e809a", "patch": "@@ -1,5 +1,4 @@\n use std::cell::Cell;\n-use std::fmt::Write;\n use std::mem;\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -728,7 +727,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             if let Some(return_place) = frame.return_place {\n                 let op = self.access_local(&frame, mir::RETURN_PLACE, None)?;\n                 self.copy_op_transmute(op, return_place)?;\n-                self.dump_place(*return_place);\n+                trace!(\"{:?}\", self.dump_place(*return_place));\n             } else {\n                 throw_ub!(Unreachable);\n             }\n@@ -823,9 +822,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // All locals have a backing allocation, even if the allocation is empty\n             // due to the local having ZST type.\n             let ptr = ptr.assert_ptr();\n-            if log_enabled!(::log::Level::Trace) {\n-                self.memory.dump_alloc(ptr.alloc_id);\n-            }\n+            trace!(\"{:?}\", self.memory.dump_alloc(ptr.alloc_id));\n             self.memory.deallocate_local(ptr)?;\n         };\n         Ok(())\n@@ -881,47 +878,77 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.raw_const_to_mplace(val)\n     }\n \n-    pub fn dump_place(&self, place: Place<M::PointerTag>) {\n-        // Debug output\n-        if !log_enabled!(::log::Level::Trace) {\n-            return;\n+    #[must_use]\n+    pub fn dump_place(&'a self, place: Place<M::PointerTag>) -> PlacePrinter<'a, 'mir, 'tcx, M> {\n+        PlacePrinter { ecx: self, place }\n+    }\n+\n+    #[must_use]\n+    pub fn generate_stacktrace(&self) -> Vec<FrameInfo<'tcx>> {\n+        let mut frames = Vec::new();\n+        for frame in self.stack().iter().rev() {\n+            let source_info = frame.current_source_info();\n+            let lint_root = source_info.and_then(|source_info| {\n+                match &frame.body.source_scopes[source_info.scope].local_data {\n+                    mir::ClearCrossCrate::Set(data) => Some(data.lint_root),\n+                    mir::ClearCrossCrate::Clear => None,\n+                }\n+            });\n+            let span = source_info.map_or(DUMMY_SP, |source_info| source_info.span);\n+\n+            frames.push(FrameInfo { span, instance: frame.instance, lint_root });\n         }\n-        match place {\n+        trace!(\"generate stacktrace: {:#?}\", frames);\n+        frames\n+    }\n+}\n+\n+#[doc(hidden)]\n+/// Helper struct for the `dump_place` function.\n+pub struct PlacePrinter<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n+    ecx: &'a InterpCx<'mir, 'tcx, M>,\n+    place: Place<M::PointerTag>,\n+}\n+\n+impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> std::fmt::Debug\n+    for PlacePrinter<'a, 'mir, 'tcx, M>\n+{\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self.place {\n             Place::Local { frame, local } => {\n                 let mut allocs = Vec::new();\n-                let mut msg = format!(\"{:?}\", local);\n-                if frame != self.frame_idx() {\n-                    write!(msg, \" ({} frames up)\", self.frame_idx() - frame).unwrap();\n+                write!(fmt, \"{:?}\", local)?;\n+                if frame != self.ecx.frame_idx() {\n+                    write!(fmt, \" ({} frames up)\", self.ecx.frame_idx() - frame)?;\n                 }\n-                write!(msg, \":\").unwrap();\n+                write!(fmt, \":\")?;\n \n-                match self.stack()[frame].locals[local].value {\n-                    LocalValue::Dead => write!(msg, \" is dead\").unwrap(),\n-                    LocalValue::Uninitialized => write!(msg, \" is uninitialized\").unwrap(),\n+                match self.ecx.stack()[frame].locals[local].value {\n+                    LocalValue::Dead => write!(fmt, \" is dead\")?,\n+                    LocalValue::Uninitialized => write!(fmt, \" is uninitialized\")?,\n                     LocalValue::Live(Operand::Indirect(mplace)) => match mplace.ptr {\n                         Scalar::Ptr(ptr) => {\n                             write!(\n-                                msg,\n+                                fmt,\n                                 \" by align({}){} ref:\",\n                                 mplace.align.bytes(),\n                                 match mplace.meta {\n                                     MemPlaceMeta::Meta(meta) => format!(\" meta({:?})\", meta),\n                                     MemPlaceMeta::Poison | MemPlaceMeta::None => String::new(),\n                                 }\n-                            )\n-                            .unwrap();\n+                            )?;\n                             allocs.push(ptr.alloc_id);\n                         }\n-                        ptr => write!(msg, \" by integral ref: {:?}\", ptr).unwrap(),\n+                        ptr => write!(fmt, \" by integral ref: {:?}\", ptr)?,\n                     },\n                     LocalValue::Live(Operand::Immediate(Immediate::Scalar(val))) => {\n-                        write!(msg, \" {:?}\", val).unwrap();\n+                        write!(fmt, \" {:?}\", val)?;\n                         if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr)) = val {\n                             allocs.push(ptr.alloc_id);\n                         }\n                     }\n                     LocalValue::Live(Operand::Immediate(Immediate::ScalarPair(val1, val2))) => {\n-                        write!(msg, \" ({:?}, {:?})\", val1, val2).unwrap();\n+                        write!(fmt, \" ({:?}, {:?})\", val1, val2)?;\n                         if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr)) = val1 {\n                             allocs.push(ptr.alloc_id);\n                         }\n@@ -931,36 +958,19 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                 }\n \n-                trace!(\"{}\", msg);\n-                self.memory.dump_allocs(allocs);\n+                write!(fmt, \": {:?}\", self.ecx.memory.dump_allocs(allocs))\n             }\n             Place::Ptr(mplace) => match mplace.ptr {\n-                Scalar::Ptr(ptr) => {\n-                    trace!(\"by align({}) ref:\", mplace.align.bytes());\n-                    self.memory.dump_alloc(ptr.alloc_id);\n-                }\n-                ptr => trace!(\" integral by ref: {:?}\", ptr),\n+                Scalar::Ptr(ptr) => write!(\n+                    fmt,\n+                    \"by align({}) ref: {:?}\",\n+                    mplace.align.bytes(),\n+                    self.ecx.memory.dump_alloc(ptr.alloc_id)\n+                ),\n+                ptr => write!(fmt, \" integral by ref: {:?}\", ptr),\n             },\n         }\n     }\n-\n-    pub fn generate_stacktrace(&self) -> Vec<FrameInfo<'tcx>> {\n-        let mut frames = Vec::new();\n-        for frame in self.stack().iter().rev() {\n-            let source_info = frame.current_source_info();\n-            let lint_root = source_info.and_then(|source_info| {\n-                match &frame.body.source_scopes[source_info.scope].local_data {\n-                    mir::ClearCrossCrate::Set(data) => Some(data.lint_root),\n-                    mir::ClearCrossCrate::Clear => None,\n-                }\n-            });\n-            let span = source_info.map_or(DUMMY_SP, |source_info| source_info.span);\n-\n-            frames.push(FrameInfo { span, instance: frame.instance, lint_root });\n-        }\n-        trace!(\"generate stacktrace: {:#?}\", frames);\n-        frames\n-    }\n }\n \n impl<'ctx, 'mir, 'tcx, Tag, Extra> HashStable<StableHashingContext<'ctx>>"}, {"sha": "6681c4c7b8202bc59260f5804aede587959bdc06", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=1799d31847294d6e3816c17679247a5c206e809a", "patch": "@@ -430,7 +430,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             _ => return Ok(false),\n         }\n \n-        self.dump_place(*dest);\n+        trace!(\"{:?}\", self.dump_place(*dest));\n         self.go_to_block(ret);\n         Ok(true)\n     }"}, {"sha": "a9e6e324eb23a7a26b126741aec7db673f7c6bd0", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 85, "deletions": 61, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=1799d31847294d6e3816c17679247a5c206e809a", "patch": "@@ -667,69 +667,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    /// Print an allocation and all allocations it points to, recursively.\n-    /// This prints directly to stderr, ignoring RUSTC_LOG! It is up to the caller to\n-    /// control for this.\n-    pub fn dump_alloc(&self, id: AllocId) {\n-        self.dump_allocs(vec![id]);\n+    /// Create a lazy debug printer that prints the given allocation and all allocations it points\n+    /// to, recursively.\n+    #[must_use]\n+    pub fn dump_alloc<'a>(&'a self, id: AllocId) -> DumpAllocs<'a, 'mir, 'tcx, M> {\n+        self.dump_allocs(vec![id])\n     }\n \n-    /// Print a list of allocations and all allocations they point to, recursively.\n-    /// This prints directly to stderr, ignoring RUSTC_LOG! It is up to the caller to\n-    /// control for this.\n-    pub fn dump_allocs(&self, mut allocs: Vec<AllocId>) {\n-        // Cannot be a closure because it is generic in `Tag`, `Extra`.\n-        fn write_allocation_track_relocs<'tcx, Tag: Copy + fmt::Debug, Extra>(\n-            tcx: TyCtxt<'tcx>,\n-            allocs_to_print: &mut VecDeque<AllocId>,\n-            alloc: &Allocation<Tag, Extra>,\n-        ) {\n-            for &(_, target_id) in alloc.relocations().values() {\n-                allocs_to_print.push_back(target_id);\n-            }\n-            pretty::write_allocation(tcx, alloc, &mut std::io::stderr()).unwrap();\n-        }\n-\n+    /// Create a lazy debug printer for a list of allocations and all allocations they point to,\n+    /// recursively.\n+    #[must_use]\n+    pub fn dump_allocs<'a>(&'a self, mut allocs: Vec<AllocId>) -> DumpAllocs<'a, 'mir, 'tcx, M> {\n         allocs.sort();\n         allocs.dedup();\n-        let mut allocs_to_print = VecDeque::from(allocs);\n-        // `allocs_printed` contains all allocations that we have already printed.\n-        let mut allocs_printed = FxHashSet::default();\n-\n-        while let Some(id) = allocs_to_print.pop_front() {\n-            if !allocs_printed.insert(id) {\n-                // Already printed, so skip this.\n-                continue;\n-            }\n-\n-            eprint!(\"{}\", id);\n-            match self.alloc_map.get(id) {\n-                Some(&(kind, ref alloc)) => {\n-                    // normal alloc\n-                    eprint!(\" ({}, \", kind);\n-                    write_allocation_track_relocs(self.tcx, &mut allocs_to_print, alloc);\n-                }\n-                None => {\n-                    // global alloc\n-                    match self.tcx.get_global_alloc(id) {\n-                        Some(GlobalAlloc::Memory(alloc)) => {\n-                            eprint!(\" (unchanged global, \");\n-                            write_allocation_track_relocs(self.tcx, &mut allocs_to_print, alloc);\n-                        }\n-                        Some(GlobalAlloc::Function(func)) => {\n-                            eprint!(\" (fn: {})\", func);\n-                        }\n-                        Some(GlobalAlloc::Static(did)) => {\n-                            eprint!(\" (static: {})\", self.tcx.def_path_str(did));\n-                        }\n-                        None => {\n-                            eprint!(\" (deallocated)\");\n-                        }\n-                    }\n-                }\n-            }\n-            eprintln!();\n-        }\n+        DumpAllocs { mem: self, allocs }\n     }\n \n     /// Print leaked memory. Allocations reachable from `static_roots` or a `Global` allocation\n@@ -760,8 +711,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         });\n         let n = leaks.len();\n         if n > 0 {\n-            eprintln!(\"The following memory was leaked:\");\n-            self.dump_allocs(leaks);\n+            eprintln!(\"The following memory was leaked: {:?}\", self.dump_allocs(leaks));\n         }\n         n\n     }\n@@ -772,6 +722,80 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n }\n \n+#[doc(hidden)]\n+/// There's no way to use this directly, it's just a helper struct for the `dump_alloc(s)` methods.\n+pub struct DumpAllocs<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n+    mem: &'a Memory<'mir, 'tcx, M>,\n+    allocs: Vec<AllocId>,\n+}\n+\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a, 'mir, 'tcx, M> {\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        // Cannot be a closure because it is generic in `Tag`, `Extra`.\n+        fn write_allocation_track_relocs<'tcx, Tag: Copy + fmt::Debug, Extra>(\n+            fmt: &mut std::fmt::Formatter<'_>,\n+            tcx: TyCtxt<'tcx>,\n+            allocs_to_print: &mut VecDeque<AllocId>,\n+            alloc: &Allocation<Tag, Extra>,\n+        ) -> std::fmt::Result {\n+            for &(_, target_id) in alloc.relocations().values() {\n+                allocs_to_print.push_back(target_id);\n+            }\n+            write!(fmt, \"{}\", pretty::display_allocation(tcx, alloc))\n+        }\n+\n+        let mut allocs_to_print: VecDeque<_> = self.allocs.iter().copied().collect();\n+        // `allocs_printed` contains all allocations that we have already printed.\n+        let mut allocs_printed = FxHashSet::default();\n+\n+        while let Some(id) = allocs_to_print.pop_front() {\n+            if !allocs_printed.insert(id) {\n+                // Already printed, so skip this.\n+                continue;\n+            }\n+\n+            write!(fmt, \"{}\", id)?;\n+            match self.mem.alloc_map.get(id) {\n+                Some(&(kind, ref alloc)) => {\n+                    // normal alloc\n+                    write!(fmt, \" ({}, \", kind)?;\n+                    write_allocation_track_relocs(\n+                        &mut *fmt,\n+                        self.mem.tcx,\n+                        &mut allocs_to_print,\n+                        alloc,\n+                    )?;\n+                }\n+                None => {\n+                    // global alloc\n+                    match self.mem.tcx.get_global_alloc(id) {\n+                        Some(GlobalAlloc::Memory(alloc)) => {\n+                            write!(fmt, \" (unchanged global, \")?;\n+                            write_allocation_track_relocs(\n+                                &mut *fmt,\n+                                self.mem.tcx,\n+                                &mut allocs_to_print,\n+                                alloc,\n+                            )?;\n+                        }\n+                        Some(GlobalAlloc::Function(func)) => {\n+                            write!(fmt, \" (fn: {})\", func)?;\n+                        }\n+                        Some(GlobalAlloc::Static(did)) => {\n+                            write!(fmt, \" (static: {})\", self.mem.tcx.def_path_str(did))?;\n+                        }\n+                        None => {\n+                            write!(fmt, \" (deallocated)\")?;\n+                        }\n+                    }\n+                }\n+            }\n+            writeln!(fmt)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n /// Reading and writing.\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// Reads the given number of bytes from memory. Returns them as a slice."}, {"sha": "15e341d9c4c01380cd6a1d6844327e630c939afb", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=1799d31847294d6e3816c17679247a5c206e809a", "patch": "@@ -648,7 +648,7 @@ where\n             place_ty = self.place_projection(place_ty, &elem)?\n         }\n \n-        self.dump_place(place_ty.place);\n+        trace!(\"{:?}\", self.dump_place(place_ty.place));\n         // Sanity-check the type we ended up with.\n         debug_assert!(mir_assign_valid_types(\n             *self.tcx,"}, {"sha": "fcd26c86c473d62b3ebf0e04ae276f96ac50e9c5", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=1799d31847294d6e3816c17679247a5c206e809a", "patch": "@@ -271,7 +271,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         }\n \n-        self.dump_place(*dest);\n+        trace!(\"{:?}\", self.dump_place(*dest));\n \n         Ok(())\n     }"}, {"sha": "25657ba98b8936342d94f98f791fc5879adac221", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1799d31847294d6e3816c17679247a5c206e809a/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=1799d31847294d6e3816c17679247a5c206e809a", "patch": "@@ -596,7 +596,7 @@ pub fn write_allocations<'tcx>(\n                         todo.push(id);\n                     }\n                 }\n-                write_allocation(tcx, alloc, w)\n+                write!(w, \"{}\", display_allocation(tcx, alloc))\n             };\n         write!(w, \"\\n{}\", id)?;\n         match tcx.get_global_alloc(id) {\n@@ -648,24 +648,36 @@ pub fn write_allocations<'tcx>(\n /// After the hex dump, an ascii dump follows, replacing all unprintable characters (control\n /// characters or characters whose value is larger than 127) with a `.`\n /// This also prints relocations adequately.\n-pub fn write_allocation<Tag: Copy + Debug, Extra>(\n+pub fn display_allocation<Tag: Copy + Debug, Extra>(\n     tcx: TyCtxt<'tcx>,\n-    alloc: &Allocation<Tag, Extra>,\n-    w: &mut dyn Write,\n-) -> io::Result<()> {\n-    write!(w, \"size: {}, align: {})\", alloc.size.bytes(), alloc.align.bytes())?;\n-    if alloc.size == Size::ZERO {\n-        // We are done.\n-        return write!(w, \" {{}}\");\n+    alloc: &'a Allocation<Tag, Extra>,\n+) -> RenderAllocation<'a, 'tcx, Tag, Extra> {\n+    RenderAllocation { tcx, alloc }\n+}\n+\n+#[doc(hidden)]\n+pub struct RenderAllocation<'a, 'tcx, Tag, Extra> {\n+    tcx: TyCtxt<'tcx>,\n+    alloc: &'a Allocation<Tag, Extra>,\n+}\n+\n+impl<Tag: Copy + Debug, Extra> std::fmt::Display for RenderAllocation<'a, 'tcx, Tag, Extra> {\n+    fn fmt(&self, w: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        let RenderAllocation { tcx, alloc } = *self;\n+        write!(w, \"size: {}, align: {})\", alloc.size.bytes(), alloc.align.bytes())?;\n+        if alloc.size == Size::ZERO {\n+            // We are done.\n+            return write!(w, \" {{}}\");\n+        }\n+        // Write allocation bytes.\n+        writeln!(w, \" {{\")?;\n+        write_allocation_bytes(tcx, alloc, w, \"    \")?;\n+        write!(w, \"}}\")?;\n+        Ok(())\n     }\n-    // Write allocation bytes.\n-    writeln!(w, \" {{\")?;\n-    write_allocation_bytes(tcx, alloc, w, \"    \")?;\n-    write!(w, \"}}\")?;\n-    Ok(())\n }\n \n-fn write_allocation_endline(w: &mut dyn Write, ascii: &str) -> io::Result<()> {\n+fn write_allocation_endline(w: &mut dyn std::fmt::Write, ascii: &str) -> std::fmt::Result {\n     for _ in 0..(BYTES_PER_LINE - ascii.chars().count()) {\n         write!(w, \"   \")?;\n     }\n@@ -677,12 +689,12 @@ const BYTES_PER_LINE: usize = 16;\n \n /// Prints the line start address and returns the new line start address.\n fn write_allocation_newline(\n-    w: &mut dyn Write,\n+    w: &mut dyn std::fmt::Write,\n     mut line_start: Size,\n     ascii: &str,\n     pos_width: usize,\n     prefix: &str,\n-) -> io::Result<Size> {\n+) -> Result<Size, std::fmt::Error> {\n     write_allocation_endline(w, ascii)?;\n     line_start += Size::from_bytes(BYTES_PER_LINE);\n     write!(w, \"{}0x{:02$x} \u2502 \", prefix, line_start.bytes(), pos_width)?;\n@@ -695,9 +707,9 @@ fn write_allocation_newline(\n fn write_allocation_bytes<Tag: Copy + Debug, Extra>(\n     tcx: TyCtxt<'tcx>,\n     alloc: &Allocation<Tag, Extra>,\n-    w: &mut dyn Write,\n+    w: &mut dyn std::fmt::Write,\n     prefix: &str,\n-) -> io::Result<()> {\n+) -> std::fmt::Result {\n     let num_lines = alloc.size.bytes_usize().saturating_sub(BYTES_PER_LINE);\n     // Number of chars needed to represent all line numbers.\n     let pos_width = format!(\"{:x}\", alloc.size.bytes()).len();"}]}