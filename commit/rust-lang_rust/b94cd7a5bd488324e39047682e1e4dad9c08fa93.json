{"sha": "b94cd7a5bd488324e39047682e1e4dad9c08fa93", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NGNkN2E1YmQ0ODgzMjRlMzkwNDc2ODJlMWU0ZGFkOWMwOGZhOTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-01T21:22:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-01T21:22:59Z"}, "message": "Auto merge of #31250 - nrc:more-aborts, r=@nikomatsakis\n\nWith this PR we can save-analysis on code with errors, essential foundation work for IDE support.", "tree": {"sha": "4a9351d73ca37c55b9b73e81aa1aee40974eccb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a9351d73ca37c55b9b73e81aa1aee40974eccb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b94cd7a5bd488324e39047682e1e4dad9c08fa93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b94cd7a5bd488324e39047682e1e4dad9c08fa93", "html_url": "https://github.com/rust-lang/rust/commit/b94cd7a5bd488324e39047682e1e4dad9c08fa93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b94cd7a5bd488324e39047682e1e4dad9c08fa93/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cae6b59b41d69773a0e02bce5da6d8d4313a9c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cae6b59b41d69773a0e02bce5da6d8d4313a9c4", "html_url": "https://github.com/rust-lang/rust/commit/7cae6b59b41d69773a0e02bce5da6d8d4313a9c4"}, {"sha": "185a0e51bf3d08963440d240862daeb927f113e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/185a0e51bf3d08963440d240862daeb927f113e8", "html_url": "https://github.com/rust-lang/rust/commit/185a0e51bf3d08963440d240862daeb927f113e8"}], "stats": {"total": 380, "additions": 210, "deletions": 170}, "files": [{"sha": "48955bd9a15af5278179897dbbc9fe255f1bb931", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=b94cd7a5bd488324e39047682e1e4dad9c08fa93", "patch": "@@ -93,9 +93,12 @@ type Scope<'a> = &'a ScopeChain<'a>;\n \n static ROOT_SCOPE: ScopeChain<'static> = RootScope;\n \n-pub fn krate(sess: &Session, krate: &hir::Crate, def_map: &DefMap) -> NamedRegionMap {\n+pub fn krate(sess: &Session,\n+             krate: &hir::Crate,\n+             def_map: &DefMap)\n+             -> Result<NamedRegionMap, usize> {\n     let mut named_region_map = NodeMap();\n-    sess.abort_if_new_errors(|| {\n+    try!(sess.track_errors(|| {\n         krate.visit_all_items(&mut LifetimeContext {\n             sess: sess,\n             named_region_map: &mut named_region_map,\n@@ -104,8 +107,8 @@ pub fn krate(sess: &Session, krate: &hir::Crate, def_map: &DefMap) -> NamedRegio\n             trait_ref_hack: false,\n             labels_in_fn: vec![],\n         });\n-    });\n-    named_region_map\n+    }));\n+    Ok(named_region_map)\n }\n \n impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {"}, {"sha": "3a57474c30322435157d69761469714f2a9ad316", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=b94cd7a5bd488324e39047682e1e4dad9c08fa93", "patch": "@@ -1915,6 +1915,16 @@ impl<'tcx> ctxt<'tcx> {\n         })\n     }\n \n+    pub fn expr_ty_adjusted_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n+        self.expr_ty_opt(expr).map(|t| t.adjust(self,\n+                                                expr.span,\n+                                                expr.id,\n+                                                self.tables.borrow().adjustments.get(&expr.id),\n+                                                |method_call| {\n+            self.tables.borrow().method_map.get(&method_call).map(|method| method.ty)\n+        }))\n+    }\n+\n     pub fn expr_span(&self, id: NodeId) -> Span {\n         match self.map.find(id) {\n             Some(ast_map::NodeExpr(e)) => {"}, {"sha": "3cb4597e2dd8c204f706c3d7950ff36bd3cd2d47", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=b94cd7a5bd488324e39047682e1e4dad9c08fa93", "patch": "@@ -179,24 +179,13 @@ impl Session {\n     pub fn track_errors<F, T>(&self, f: F) -> Result<T, usize>\n         where F: FnOnce() -> T\n     {\n-        let count = self.err_count();\n+        let old_count = self.err_count();\n         let result = f();\n-        let count = self.err_count() - count;\n-        if count == 0 {\n+        let errors = self.err_count() - old_count;\n+        if errors == 0 {\n             Ok(result)\n         } else {\n-            Err(count)\n-        }\n-    }\n-    pub fn abort_if_new_errors<F, T>(&self, f: F) -> T\n-        where F: FnOnce() -> T\n-    {\n-        match self.track_errors(f) {\n-            Ok(result) => result,\n-            Err(_) => {\n-                self.abort_if_errors();\n-                unreachable!();\n-            }\n+            Err(errors)\n         }\n     }\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n@@ -515,3 +504,15 @@ pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n     };\n     emitter.emit(None, msg, None, errors::Level::Warning);\n }\n+\n+// Err(0) means compilation was stopped, but no errors were found.\n+// This would be better as a dedicated enum, but using try! is so convenient.\n+pub type CompileResult = Result<(), usize>;\n+\n+pub fn compile_result_from_err_count(err_count: usize) -> CompileResult {\n+    if err_count == 0 {\n+        Ok(())\n+    } else {\n+        Err(err_count)\n+    }\n+}"}, {"sha": "c189df18a82e1ab93ec205a81ba33f4df04519eb", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 106, "deletions": 78, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=b94cd7a5bd488324e39047682e1e4dad9c08fa93", "patch": "@@ -12,14 +12,15 @@ use rustc::front;\n use rustc::front::map as hir_map;\n use rustc_mir as mir;\n use rustc_mir::mir_map::MirMap;\n-use rustc::session::Session;\n+use rustc::session::{Session, CompileResult, compile_result_from_err_count};\n use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n use rustc::session::search_paths::PathKind;\n use rustc::lint;\n-use rustc::middle::{stability, ty, reachable};\n-use rustc::middle::dependency_format;\n+use rustc::middle::{dependency_format, stability, ty, reachable};\n+use rustc::middle::privacy::AccessLevels;\n use rustc::middle;\n use rustc::util::common::time;\n+use rustc::util::nodemap::NodeSet;\n use rustc_borrowck as borrowck;\n use rustc_resolve as resolve;\n use rustc_metadata::macro_import;\n@@ -35,7 +36,7 @@ use rustc_plugin as plugin;\n use rustc_front::hir;\n use rustc_front::lowering::{lower_crate, LoweringContext};\n use rustc_passes::{no_asm, loops, consts, const_fn, rvalues, static_recursion};\n-use super::{Compilation, CompileResult, compile_result_from_err_count};\n+use super::Compilation;\n \n use serialize::json;\n \n@@ -57,15 +58,6 @@ use syntax::visit;\n use syntax;\n use syntax_ext;\n \n-macro_rules! throw_if_errors {\n-    ($tsess: expr) => {{\n-        let err_count = $tsess.err_count();\n-        if err_count > 0 {\n-            return Err(err_count);\n-        }\n-    }}\n-}\n-\n pub fn compile_input(sess: &Session,\n                      cstore: &CStore,\n                      cfg: ast::CrateConfig,\n@@ -74,14 +66,19 @@ pub fn compile_input(sess: &Session,\n                      output: &Option<PathBuf>,\n                      addl_plugins: Option<Vec<String>>,\n                      control: CompileController) -> CompileResult {\n-    macro_rules! controller_entry_point{($point: ident, $tsess: expr, $make_state: expr) => ({\n-        let state = $make_state;\n-        (control.$point.callback)(state);\n+    macro_rules! controller_entry_point {\n+        ($point: ident, $tsess: expr, $make_state: expr, $phase_result: expr) => {{\n+            let state = $make_state;\n+            let phase_result: &CompileResult = &$phase_result;\n+            if phase_result.is_ok() || control.$point.run_callback_on_error {\n+                (control.$point.callback)(state);\n+            }\n \n-        if control.$point.stop == Compilation::Stop {\n-            return compile_result_from_err_count($tsess.err_count());\n-        }\n-    })}\n+            if control.$point.stop == Compilation::Stop {\n+                return compile_result_from_err_count($tsess.err_count());\n+            }\n+        }}\n+    }\n \n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n@@ -92,7 +89,8 @@ pub fn compile_input(sess: &Session,\n \n             controller_entry_point!(after_parse,\n                                     sess,\n-                                    CompileState::state_after_parse(input, sess, outdir, &krate));\n+                                    CompileState::state_after_parse(input, sess, outdir, &krate),\n+                                    Ok(()));\n \n             let outputs = build_output_filenames(input, outdir, output, &krate.attrs, sess);\n             let id = link::find_crate_name(Some(sess), &krate.attrs, input);\n@@ -111,7 +109,8 @@ pub fn compile_input(sess: &Session,\n                                                                  sess,\n                                                                  outdir,\n                                                                  &expanded_crate,\n-                                                                 &id[..]));\n+                                                                 &id[..]),\n+                                Ok(()));\n \n         let expanded_crate = assign_node_ids(sess, expanded_crate);\n         // Lower ast -> hir.\n@@ -140,7 +139,8 @@ pub fn compile_input(sess: &Session,\n                                                                      &expanded_crate,\n                                                                      &hir_map.krate(),\n                                                                      &id[..],\n-                                                                     &lcx));\n+                                                                     &lcx),\n+                                Ok(()));\n \n         time(sess.time_passes(), \"attribute checking\", || {\n             front::check_attr::check_crate(sess, &expanded_crate);\n@@ -159,38 +159,38 @@ pub fn compile_input(sess: &Session,\n         };\n \n         try!(try!(phase_3_run_analysis_passes(sess,\n-                                         &cstore,\n-                                         hir_map,\n-                                         &arenas,\n-                                         &id,\n-                                         control.make_glob_map,\n-                                         |tcx, mir_map, analysis| {\n+                                              &cstore,\n+                                              hir_map,\n+                                              &arenas,\n+                                              &id,\n+                                              control.make_glob_map,\n+                                              |tcx, mir_map, analysis, result| {\n             {\n-                let state =\n-                    CompileState::state_after_analysis(input,\n-                                                       &tcx.sess,\n-                                                       outdir,\n-                                                       opt_crate,\n-                                                       tcx.map.krate(),\n-                                                       &analysis,\n-                                                       &mir_map,\n-                                                       tcx,\n-                                                       &lcx,\n-                                                       &id);\n+                let state = CompileState::state_after_analysis(input,\n+                                                               &tcx.sess,\n+                                                               outdir,\n+                                                               opt_crate,\n+                                                               tcx.map.krate(),\n+                                                               &analysis,\n+                                                               mir_map.as_ref(),\n+                                                               tcx,\n+                                                               &lcx,\n+                                                               &id);\n                 (control.after_analysis.callback)(state);\n \n-                throw_if_errors!(tcx.sess);\n                 if control.after_analysis.stop == Compilation::Stop {\n                     return Err(0usize);\n                 }\n             }\n \n+            try!(result);\n+\n             if log_enabled!(::log::INFO) {\n                 println!(\"Pre-trans\");\n                 tcx.print_debug_stats();\n             }\n             let trans = phase_4_translate_to_llvm(tcx,\n-                                                  mir_map,\n+                                                  mir_map.unwrap(),\n                                                   analysis);\n \n             if log_enabled!(::log::INFO) {\n@@ -205,17 +205,20 @@ pub fn compile_input(sess: &Session,\n         })))\n     };\n \n-    try!(phase_5_run_llvm_passes(sess, &trans, &outputs));\n+    let phase5_result = phase_5_run_llvm_passes(sess, &trans, &outputs);\n \n     controller_entry_point!(after_llvm,\n                             sess,\n-                            CompileState::state_after_llvm(input, sess, outdir, &trans));\n+                            CompileState::state_after_llvm(input, sess, outdir, &trans),\n+                            phase5_result);\n+    try!(phase5_result);\n \n     phase_6_link_output(sess, &trans, &outputs);\n \n     Ok(())\n }\n \n+\n /// The name used for source code that doesn't originate in a file\n /// (e.g. source from stdin or a string)\n pub fn anon_src() -> String {\n@@ -269,13 +272,17 @@ impl<'a> CompileController<'a> {\n \n pub struct PhaseController<'a> {\n     pub stop: Compilation,\n+    // If true then the compiler will try to run the callback even if the phase\n+    // ends with an error. Note that this is not always possible.\n+    pub run_callback_on_error: bool,\n     pub callback: Box<Fn(CompileState) -> () + 'a>,\n }\n \n impl<'a> PhaseController<'a> {\n     pub fn basic() -> PhaseController<'a> {\n         PhaseController {\n             stop: Compilation::Continue,\n+            run_callback_on_error: false,\n             callback: box |_| {},\n         }\n     }\n@@ -372,14 +379,14 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n                             krate: Option<&'a ast::Crate>,\n                             hir_crate: &'a hir::Crate,\n                             analysis: &'a ty::CrateAnalysis,\n-                            mir_map: &'a MirMap<'tcx>,\n+                            mir_map: Option<&'a MirMap<'tcx>>,\n                             tcx: &'a ty::ctxt<'tcx>,\n                             lcx: &'a LoweringContext<'a>,\n                             crate_name: &'a str)\n                             -> CompileState<'a, 'ast, 'tcx> {\n         CompileState {\n             analysis: Some(analysis),\n-            mir_map: Some(mir_map),\n+            mir_map: mir_map,\n             tcx: Some(tcx),\n             krate: krate,\n             hir_crate: Some(hir_crate),\n@@ -659,9 +666,9 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         })\n     }));\n \n-    time(time_passes,\n-         \"const fn bodies and arguments\",\n-         || const_fn::check_crate(sess, &krate));\n+    try!(time(time_passes,\n+              \"const fn bodies and arguments\",\n+              || const_fn::check_crate(sess, &krate)));\n \n     if sess.opts.debugging_opts.input_stats {\n         println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n@@ -713,8 +720,20 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                make_glob_map: resolve::MakeGlobMap,\n                                                f: F)\n                                                -> Result<R, usize>\n-    where F: for<'a> FnOnce(&'a ty::ctxt<'tcx>, MirMap<'tcx>, ty::CrateAnalysis) -> R\n+    where F: FnOnce(&ty::ctxt<'tcx>, Option<MirMap<'tcx>>, ty::CrateAnalysis, CompileResult) -> R\n {\n+    macro_rules! try_with_f {\n+        ($e: expr, ($t: expr, $m: expr, $a: expr)) => {\n+            match $e {\n+                Ok(x) => x,\n+                Err(x) => {\n+                    f($t, $m, $a, Err(x));\n+                    return Err(x);\n+                }\n+            }\n+        }\n+    }\n+\n     let time_passes = sess.time_passes();\n     let krate = hir_map.krate();\n \n@@ -739,9 +758,19 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"resolution\",\n              || resolve::resolve_crate(sess, &hir_map, make_glob_map));\n \n-    let named_region_map = time(time_passes,\n-                                \"lifetime resolution\",\n-                                || middle::resolve_lifetime::krate(sess, krate, &def_map.borrow()));\n+    let mut analysis = ty::CrateAnalysis {\n+        export_map: export_map,\n+        access_levels: AccessLevels::default(),\n+        reachable: NodeSet(),\n+        name: name,\n+        glob_map: glob_map,\n+    };\n+\n+    let named_region_map = try!(time(time_passes,\n+                                     \"lifetime resolution\",\n+                                     || middle::resolve_lifetime::krate(sess,\n+                                                                        krate,\n+                                                                        &def_map.borrow())));\n \n     time(time_passes,\n          \"looking for entry point\",\n@@ -759,9 +788,9 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n          \"loop checking\",\n          || loops::check_crate(sess, krate));\n \n-    time(time_passes,\n-         \"static item recursion checking\",\n-         || static_recursion::check_crate(sess, krate, &def_map.borrow(), &hir_map));\n+    try!(time(time_passes,\n+              \"static item recursion checking\",\n+              || static_recursion::check_crate(sess, krate, &def_map.borrow(), &hir_map)));\n \n     ty::ctxt::create_and_enter(sess,\n                                arenas,\n@@ -774,22 +803,22 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                stability::Index::new(krate),\n                                |tcx| {\n         // passes are timed inside typeck\n-        typeck::check_crate(tcx, trait_map);\n+        try_with_f!(typeck::check_crate(tcx, trait_map), (tcx, None, analysis));\n \n         time(time_passes,\n              \"const checking\",\n              || consts::check_crate(tcx));\n \n-        let access_levels =\n+        analysis.access_levels =\n             time(time_passes, \"privacy checking\", || {\n                 rustc_privacy::check_crate(tcx,\n-                                           &export_map,\n+                                           &analysis.export_map,\n                                            external_exports)\n             });\n \n         // Do not move this check past lint\n         time(time_passes, \"stability index\", || {\n-            tcx.stability.borrow_mut().build(tcx, krate, &access_levels)\n+            tcx.stability.borrow_mut().build(tcx, krate, &analysis.access_levels)\n         });\n \n         time(time_passes,\n@@ -827,15 +856,17 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         // lot of annoying errors in the compile-fail tests (basically,\n         // lint warnings and so on -- kindck used to do this abort, but\n         // kindck is gone now). -nmatsakis\n-        throw_if_errors!(tcx.sess);\n+        if sess.err_count() > 0 {\n+            return Ok(f(tcx, Some(mir_map), analysis, Err(sess.err_count())));\n+        }\n \n-        let reachable_map =\n+        analysis.reachable =\n             time(time_passes,\n                  \"reachability checking\",\n-                 || reachable::find_reachable(tcx, &access_levels));\n+                 || reachable::find_reachable(tcx, &analysis.access_levels));\n \n         time(time_passes, \"death checking\", || {\n-            middle::dead::check_crate(tcx, &access_levels);\n+            middle::dead::check_crate(tcx, &analysis.access_levels);\n         });\n \n         let ref lib_features_used =\n@@ -850,20 +881,14 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n         time(time_passes,\n              \"lint checking\",\n-             || lint::check_crate(tcx, &access_levels));\n+             || lint::check_crate(tcx, &analysis.access_levels));\n \n         // The above three passes generate errors w/o aborting\n-        throw_if_errors!(tcx.sess);\n-\n-        Ok(f(tcx,\n-          mir_map,\n-          ty::CrateAnalysis {\n-              export_map: export_map,\n-              access_levels: access_levels,\n-              reachable: reachable_map,\n-              name: name,\n-              glob_map: glob_map,\n-          }))\n+        if sess.err_count() > 0 {\n+            return Ok(f(tcx, Some(mir_map), analysis, Err(sess.err_count())));\n+        }\n+\n+        Ok(f(tcx, Some(mir_map), analysis, Ok(())))\n     })\n }\n \n@@ -913,8 +938,11 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n              || write::run_passes(sess, trans, &sess.opts.output_types, outputs));\n     }\n \n-    throw_if_errors!(sess);\n-    Ok(())\n+    if sess.err_count() > 0 {\n+        Err(sess.err_count())\n+    } else {\n+        Ok(())\n+    }\n }\n \n /// Run the linker on any artifacts that resulted from the LLVM run."}, {"sha": "70bd938321a8e70250ebed79c08188ad570e4610", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=b94cd7a5bd488324e39047682e1e4dad9c08fa93", "patch": "@@ -63,7 +63,7 @@ use pretty::{PpMode, UserIdentifiedItem};\n use rustc_resolve as resolve;\n use rustc_trans::back::link;\n use rustc_trans::save;\n-use rustc::session::{config, Session, build_session};\n+use rustc::session::{config, Session, build_session, CompileResult};\n use rustc::session::config::{Input, PrintRequest, OutputType, ErrorOutputType};\n use rustc::middle::cstore::CrateStore;\n use rustc::lint::Lint;\n@@ -105,18 +105,6 @@ pub mod target_features;\n const BUG_REPORT_URL: &'static str = \"https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.\\\n                                       md#bug-reports\";\n \n-// Err(0) means compilation was stopped, but no errors were found.\n-// This would be better as a dedicated enum, but using try! is so convenient.\n-pub type CompileResult = Result<(), usize>;\n-\n-pub fn compile_result_from_err_count(err_count: usize) -> CompileResult {\n-    if err_count == 0 {\n-        Ok(())\n-    } else {\n-        Err(err_count)\n-    }\n-}\n-\n #[inline]\n fn abort_msg(err_count: usize) -> String {\n     match err_count {\n@@ -146,7 +134,7 @@ pub fn run(args: Vec<String>) -> isize {\n                         let mut emitter =\n                             errors::emitter::BasicEmitter::stderr(errors::ColorConfig::Auto);\n                         emitter.emit(None, &abort_msg(err_count), None, errors::Level::Fatal);\n-                        panic!(errors::FatalError);\n+                        exit_on_err();\n                     }\n                 }\n             }\n@@ -462,6 +450,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                                         state.out_dir)\n                 });\n             };\n+            control.after_analysis.run_callback_on_error = true;\n             control.make_glob_map = resolve::MakeGlobMap::Yes;\n         }\n \n@@ -947,15 +936,19 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n                 println!(\"{}\", str::from_utf8(&data.lock().unwrap()).unwrap());\n             }\n \n-            // Panic so the process returns a failure code, but don't pollute the\n-            // output with some unnecessary panic messages, we've already\n-            // printed everything that we needed to.\n-            io::set_panic(box io::sink());\n-            panic!();\n+            exit_on_err();\n         }\n     }\n }\n \n+fn exit_on_err() -> ! {\n+    // Panic so the process returns a failure code, but don't pollute the\n+    // output with some unnecessary panic messages, we've already\n+    // printed everything that we needed to.\n+    io::set_panic(box io::sink());\n+    panic!();\n+}\n+\n pub fn diagnostics_registry() -> diagnostics::registry::Registry {\n     use syntax::diagnostics::registry::Registry;\n "}, {"sha": "91af78a5bd4fbaaf92ac171aec970f67cb98bbde", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=b94cd7a5bd488324e39047682e1e4dad9c08fa93", "patch": "@@ -200,7 +200,7 @@ impl PpSourceMode {\n                                                                  arenas,\n                                                                  id,\n                                                                  resolve::MakeGlobMap::No,\n-                                                                 |tcx, _, _| {\n+                                                                 |tcx, _, _, _| {\n                     let annotation = TypedAnnotation {\n                         tcx: tcx,\n                     };\n@@ -824,7 +824,7 @@ pub fn pretty_print_input(sess: Session,\n                                                                      &arenas,\n                                                                      &id,\n                                                                      resolve::MakeGlobMap::No,\n-                                                                     |tcx, _, _| {\n+                                                                     |tcx, _, _, _| {\n                         print_flowgraph(variants,\n                                         tcx,\n                                         code,"}, {"sha": "3389992ebb860653726af14c478e0cced049fb04", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=b94cd7a5bd488324e39047682e1e4dad9c08fa93", "patch": "@@ -132,7 +132,7 @@ fn test_env<F>(source_string: &str,\n     ty::ctxt::create_and_enter(&sess,\n                                &arenas,\n                                def_map,\n-                               named_region_map,\n+                               named_region_map.unwrap(),\n                                ast_map,\n                                freevars,\n                                region_map,"}, {"sha": "f924210da9f460658b479b57bb2b6fd5c0925ce1", "filename": "src/librustc_passes/const_fn.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc_passes%2Fconst_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc_passes%2Fconst_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconst_fn.rs?ref=b94cd7a5bd488324e39047682e1e4dad9c08fa93", "patch": "@@ -11,16 +11,16 @@\n //! Verifies that const fn arguments are immutable by value bindings\n //! and the const fn body doesn't contain any statements\n \n-use rustc::session::Session;\n+use rustc::session::{Session, CompileResult};\n \n use syntax::ast;\n use syntax::visit::{self, Visitor, FnKind};\n use syntax::codemap::Span;\n \n-pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n-    sess.abort_if_new_errors(|| {\n+pub fn check_crate(sess: &Session, krate: &ast::Crate) -> CompileResult {\n+    sess.track_errors(|| {\n         visit::walk_crate(&mut CheckConstFn{ sess: sess }, krate);\n-    });\n+    })\n }\n \n struct CheckConstFn<'a> {"}, {"sha": "2d81354495d54567e57da17466f134a76837ec99", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=b94cd7a5bd488324e39047682e1e4dad9c08fa93", "patch": "@@ -12,7 +12,7 @@\n // recursively.\n \n use rustc::front::map as ast_map;\n-use rustc::session::Session;\n+use rustc::session::{Session, CompileResult};\n use rustc::middle::def::{Def, DefMap};\n use rustc::util::nodemap::NodeMap;\n \n@@ -92,16 +92,16 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n pub fn check_crate<'ast>(sess: &Session,\n                          krate: &'ast hir::Crate,\n                          def_map: &DefMap,\n-                         ast_map: &ast_map::Map<'ast>) {\n+                         ast_map: &ast_map::Map<'ast>) -> CompileResult {\n     let mut visitor = CheckCrateVisitor {\n         sess: sess,\n         def_map: def_map,\n         ast_map: ast_map,\n         discriminant_map: RefCell::new(NodeMap()),\n     };\n-    sess.abort_if_new_errors(|| {\n+    sess.track_errors(|| {\n         krate.visit_all_items(&mut visitor);\n-    });\n+    })\n }\n \n struct CheckItemRecursionVisitor<'a, 'ast: 'a> {"}, {"sha": "21d536667e5a0425f10283e925ededf4eca3fecc", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=b94cd7a5bd488324e39047682e1e4dad9c08fa93", "patch": "@@ -801,7 +801,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                 \"<mutable>\".to_string()\n             };\n             let types = self.tcx.node_types();\n-            let typ = types.get(&id).unwrap().to_string();\n+            let typ = types.get(&id).map(|t| t.to_string()).unwrap_or(String::new());\n             // Get the span only for the name of the variable (I hope the path\n             // is only ever a variable name, but who knows?).\n             let sub_span = self.span.span_for_last_ident(p.span);"}, {"sha": "05b012d55a07e85586263e196264df454f46e42e", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=b94cd7a5bd488324e39047682e1e4dad9c08fa93", "patch": "@@ -463,11 +463,15 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n+        let hir_node = lowering::lower_expr(self.lcx, expr);\n+        let ty = self.tcx.expr_ty_adjusted_opt(&hir_node);\n+        if ty.is_none() || ty.unwrap().sty == ty::TyError {\n+            return None;\n+        }\n         match expr.node {\n             ast::ExprField(ref sub_ex, ident) => {\n                 let hir_node = lowering::lower_expr(self.lcx, sub_ex);\n-                let ty = &self.tcx.expr_ty_adjusted(&hir_node).sty;\n-                match *ty {\n+                match self.tcx.expr_ty_adjusted(&hir_node).sty {\n                     ty::TyStruct(def, _) => {\n                         let f = def.struct_variant().field_named(ident.node.name);\n                         let sub_span = self.span_utils.span_for_last_ident(expr.span);\n@@ -487,8 +491,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             ast::ExprStruct(ref path, _, _) => {\n                 let hir_node = lowering::lower_expr(self.lcx, expr);\n-                let ty = &self.tcx.expr_ty_adjusted(&hir_node).sty;\n-                match *ty {\n+                match self.tcx.expr_ty_adjusted(&hir_node).sty {\n                     ty::TyStruct(def, _) => {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n                         filter!(self.span_utils, sub_span, path.span, None);"}, {"sha": "dc93320285ae746bfd86bedbefa4c70dfbbc3106", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b94cd7a5bd488324e39047682e1e4dad9c08fa93", "patch": "@@ -105,7 +105,7 @@ use middle::ty::fold::{TypeFolder, TypeFoldable};\n use middle::ty::util::Representability;\n use require_c_abi_if_variadic;\n use rscope::{ElisionFailureInfo, RegionScope};\n-use session::Session;\n+use session::{Session, CompileResult};\n use {CrateCtxt, lookup_full_def};\n use TypeAndSubsts;\n use lint;\n@@ -383,29 +383,29 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_wf_new(ccx: &CrateCtxt) {\n-    ccx.tcx.sess.abort_if_new_errors(|| {\n+pub fn check_wf_new(ccx: &CrateCtxt) -> CompileResult {\n+    ccx.tcx.sess.track_errors(|| {\n         let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(ccx);\n         ccx.tcx.visit_all_items_in_krate(DepNode::WfCheck, &mut visit);\n-    });\n+    })\n }\n \n-pub fn check_item_types(ccx: &CrateCtxt) {\n-    ccx.tcx.sess.abort_if_new_errors(|| {\n+pub fn check_item_types(ccx: &CrateCtxt) -> CompileResult {\n+    ccx.tcx.sess.track_errors(|| {\n         let mut visit = CheckItemTypesVisitor { ccx: ccx };\n         ccx.tcx.visit_all_items_in_krate(DepNode::TypeckItemType, &mut visit);\n-    });\n+    })\n }\n \n-pub fn check_item_bodies(ccx: &CrateCtxt) {\n-    ccx.tcx.sess.abort_if_new_errors(|| {\n+pub fn check_item_bodies(ccx: &CrateCtxt) -> CompileResult {\n+    ccx.tcx.sess.track_errors(|| {\n         let mut visit = CheckItemBodiesVisitor { ccx: ccx };\n         ccx.tcx.visit_all_items_in_krate(DepNode::TypeckItemBody, &mut visit);\n-    });\n+    })\n }\n \n-pub fn check_drop_impls(ccx: &CrateCtxt) {\n-    ccx.tcx.sess.abort_if_new_errors(|| {\n+pub fn check_drop_impls(ccx: &CrateCtxt) -> CompileResult {\n+    ccx.tcx.sess.track_errors(|| {\n         let _task = ccx.tcx.dep_graph.in_task(DepNode::Dropck);\n         let drop_trait = match ccx.tcx.lang_items.drop_trait() {\n             Some(id) => ccx.tcx.lookup_trait_def(id), None => { return }\n@@ -421,7 +421,7 @@ pub fn check_drop_impls(ccx: &CrateCtxt) {\n                 }\n             }\n         });\n-    });\n+    })\n }\n \n fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,"}, {"sha": "cb0b4d0902c7ce4fc68469cbd04a6865be7ff52f", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=b94cd7a5bd488324e39047682e1e4dad9c08fa93", "patch": "@@ -105,7 +105,7 @@ use middle::def::Def;\n use middle::infer::{self, TypeOrigin};\n use middle::subst;\n use middle::ty::{self, Ty, TypeFoldable};\n-use session::config;\n+use session::{config, CompileResult};\n use util::common::time;\n use rustc_front::hir;\n \n@@ -323,7 +323,7 @@ fn check_for_entry_fn(ccx: &CrateCtxt) {\n     }\n }\n \n-pub fn check_crate(tcx: &ty::ctxt, trait_map: ty::TraitMap) {\n+pub fn check_crate(tcx: &ty::ctxt, trait_map: ty::TraitMap) -> CompileResult {\n     let time_passes = tcx.sess.time_passes();\n     let ccx = CrateCtxt {\n         trait_map: trait_map,\n@@ -333,34 +333,40 @@ pub fn check_crate(tcx: &ty::ctxt, trait_map: ty::TraitMap) {\n \n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n-    tcx.sess.abort_if_new_errors(|| {\n+    try!(tcx.sess.track_errors(|| {\n         time(time_passes, \"type collecting\", ||\n              collect::collect_item_types(tcx));\n \n-    });\n+    }));\n \n     time(time_passes, \"variance inference\", ||\n          variance::infer_variance(tcx));\n \n-    tcx.sess.abort_if_new_errors(|| {\n+    try!(tcx.sess.track_errors(|| {\n       time(time_passes, \"coherence checking\", ||\n           coherence::check_coherence(&ccx));\n-    });\n+    }));\n \n-    time(time_passes, \"wf checking\", ||\n-        check::check_wf_new(&ccx));\n+    try!(time(time_passes, \"wf checking\", ||\n+        check::check_wf_new(&ccx)));\n \n-    time(time_passes, \"item-types checking\", ||\n-        check::check_item_types(&ccx));\n+    try!(time(time_passes, \"item-types checking\", ||\n+        check::check_item_types(&ccx)));\n \n-    time(time_passes, \"item-bodies checking\", ||\n-        check::check_item_bodies(&ccx));\n+    try!(time(time_passes, \"item-bodies checking\", ||\n+        check::check_item_bodies(&ccx)));\n \n-    time(time_passes, \"drop-impl checking\", ||\n-        check::check_drop_impls(&ccx));\n+    try!(time(time_passes, \"drop-impl checking\", ||\n+        check::check_drop_impls(&ccx)));\n \n     check_for_entry_fn(&ccx);\n-    tcx.sess.abort_if_errors();\n+\n+    let err_count = tcx.sess.err_count();\n+    if err_count == 0 {\n+        Ok(())\n+    } else {\n+        Err(err_count)\n+    }\n }\n \n __build_diagnostic_array! { librustc_typeck, DIAGNOSTICS }"}, {"sha": "3e8457069d2db89051e87fac99c1a1aa9c8a3711", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=b94cd7a5bd488324e39047682e1e4dad9c08fa93", "patch": "@@ -153,7 +153,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n                                                      &arenas,\n                                                      &name,\n                                                      resolve::MakeGlobMap::No,\n-                                                     |tcx, _, analysis| {\n+                                                     |tcx, _, analysis, _| {\n         let _ignore = tcx.dep_graph.in_ignore();\n         let ty::CrateAnalysis { access_levels, .. } = analysis;\n "}, {"sha": "bff5071b8ec10104bafa1b4dc2026f98db75a8b7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b94cd7a5bd488324e39047682e1e4dad9c08fa93", "patch": "@@ -2483,8 +2483,7 @@ impl<'a> Parser<'a> {\n                                     float.trunc() as usize,\n                                     format!(\".{}\", fstr.splitn(2, \".\").last().unwrap())));\n                     }\n-                    err.emit();\n-                    self.abort_if_errors();\n+                    return Err(err);\n \n                   }\n                   _ => {\n@@ -4117,9 +4116,7 @@ impl<'a> Parser<'a> {\n                               or did you mean the comma-separated arguments \\\n                               'a, Type?\");\n             err.span_note(mk_sp(span_lo, span_hi), &msg);\n-            err.emit();\n-\n-            self.abort_if_errors()\n+            return Err(err);\n         }\n \n         // First parse types.\n@@ -5189,8 +5186,7 @@ impl<'a> Parser<'a> {\n                                         of possibly redeclaring it\",\n                                        paths.name));\n             }\n-            err.emit();\n-            self.abort_if_errors();\n+            return Err(err);\n         }\n \n         match paths.result {"}, {"sha": "3f9c81eac0b25e49549df6fbaf5f5d7ed636b134", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94cd7a5bd488324e39047682e1e4dad9c08fa93/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=b94cd7a5bd488324e39047682e1e4dad9c08fa93", "patch": "@@ -242,9 +242,9 @@ fn compile_program(input: &str, sysroot: PathBuf)\n \n         abort_on_err(driver::phase_3_run_analysis_passes(\n             &sess, &cstore, ast_map, &arenas, &id,\n-            MakeGlobMap::No, |tcx, mir_map, analysis| {\n+            MakeGlobMap::No, |tcx, mir_map, analysis, _| {\n \n-            let trans = driver::phase_4_translate_to_llvm(tcx, mir_map, analysis);\n+            let trans = driver::phase_4_translate_to_llvm(tcx, mir_map.unwrap(), analysis);\n \n             let crates = tcx.sess.cstore.used_crates(LinkagePreference::RequireDynamic);\n "}]}