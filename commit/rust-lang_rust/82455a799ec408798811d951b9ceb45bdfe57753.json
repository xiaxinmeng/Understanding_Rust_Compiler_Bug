{"sha": "82455a799ec408798811d951b9ceb45bdfe57753", "node_id": "C_kwDOAAsO6NoAKDgyNDU1YTc5OWVjNDA4Nzk4ODExZDk1MWI5Y2ViNDViZGZlNTc3NTM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-26T14:02:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-26T14:02:21Z"}, "message": "Rollup merge of #107189 - cjgillot:meta-adt, r=compiler-errors\n\nEncode info for Adt in a single place.\n\nSplit from https://github.com/rust-lang/rust/pull/98867", "tree": {"sha": "f59982dc93d057d595e14f554ee4cdb5d895d762", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f59982dc93d057d595e14f554ee4cdb5d895d762"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82455a799ec408798811d951b9ceb45bdfe57753", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj0oftCRBK7hj4Ov3rIwAAPJcIAEh13MlHSu61BRT8mUb5xftX\nnpHXrSSFnJAVjyunHiJ/WOc2+ne1e6LzmTBg7uyACHFjI4IfBWR2aC8l2RSORbkH\n32eGkd0wJxTfrNCycliWdh5/Pc8PpYhlwUCElJpmnIvwaIiaOlkkWnSBcNBmKTfz\natfaP00CNlX0esESsUcLENgitRp7ZotlCVyj/SA4bynvg7fHor+M44zHbQAC+80b\nqf0KCAR3rgirTyZCVPr9JjeRbGT1eLuvIlhB4zb4OZK7TlnnXw623NvE2UPh4OQ3\nAb8g4UcxM8Mq9Ao0FunGK9mCJm9B+ss8xvR1WQBOZcGvrHq7TEYp1H8Dc/iDl0A=\n=R7uf\n-----END PGP SIGNATURE-----\n", "payload": "tree f59982dc93d057d595e14f554ee4cdb5d895d762\nparent 3c145ff283bf24efe499bbf37327fbc3fbc28a07\nparent 4d11206ee78cd53bfd104c6073f3c8169da8828d\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1674741741 +0100\ncommitter GitHub <noreply@github.com> 1674741741 +0100\n\nRollup merge of #107189 - cjgillot:meta-adt, r=compiler-errors\n\nEncode info for Adt in a single place.\n\nSplit from https://github.com/rust-lang/rust/pull/98867\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82455a799ec408798811d951b9ceb45bdfe57753", "html_url": "https://github.com/rust-lang/rust/commit/82455a799ec408798811d951b9ceb45bdfe57753", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82455a799ec408798811d951b9ceb45bdfe57753/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c145ff283bf24efe499bbf37327fbc3fbc28a07", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c145ff283bf24efe499bbf37327fbc3fbc28a07", "html_url": "https://github.com/rust-lang/rust/commit/3c145ff283bf24efe499bbf37327fbc3fbc28a07"}, {"sha": "4d11206ee78cd53bfd104c6073f3c8169da8828d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d11206ee78cd53bfd104c6073f3c8169da8828d", "html_url": "https://github.com/rust-lang/rust/commit/4d11206ee78cd53bfd104c6073f3c8169da8828d"}], "stats": {"total": 158, "additions": 45, "deletions": 113}, "files": [{"sha": "29eba278750b1299c434d73570f05c518aab76eb", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 45, "deletions": 113, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/82455a799ec408798811d951b9ceb45bdfe57753/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82455a799ec408798811d951b9ceb45bdfe57753/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=82455a799ec408798811d951b9ceb45bdfe57753", "patch": "@@ -38,7 +38,6 @@ use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{\n     self, DebuggerVisualizerFile, ExternalSource, FileName, SourceFile, Span, SyntaxContext,\n };\n-use rustc_target::abi::VariantIdx;\n use std::borrow::Borrow;\n use std::collections::hash_map::Entry;\n use std::hash::Hash;\n@@ -1189,8 +1188,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.super_predicates_of[def_id] <- self.tcx.super_predicates_of(def_id));\n             }\n             if let DefKind::Enum | DefKind::Struct | DefKind::Union = def_kind {\n-                let params_in_repr = self.tcx.params_in_repr(def_id);\n-                record!(self.tables.params_in_repr[def_id] <- params_in_repr);\n+                self.encode_info_for_adt(def_id);\n             }\n             if should_encode_trait_impl_trait_tys(tcx, def_id)\n                 && let Ok(table) = self.tcx.collect_return_position_impl_trait_in_trait_tys(def_id)\n@@ -1213,46 +1211,53 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_enum_variant_info(&mut self, def: ty::AdtDef<'tcx>, index: VariantIdx) {\n+    #[instrument(level = \"trace\", skip(self))]\n+    fn encode_info_for_adt(&mut self, def_id: DefId) {\n         let tcx = self.tcx;\n-        let variant = &def.variant(index);\n-        let def_id = variant.def_id;\n-        debug!(\"EncodeContext::encode_enum_variant_info({:?})\", def_id);\n-\n-        let data = VariantData {\n-            discr: variant.discr,\n-            ctor: variant.ctor.map(|(kind, def_id)| (kind, def_id.index)),\n-            is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-        };\n+        let adt_def = tcx.adt_def(def_id);\n+        record!(self.tables.repr_options[def_id] <- adt_def.repr());\n \n-        record!(self.tables.variant_data[def_id] <- data);\n-        self.tables.constness.set(def_id.index, hir::Constness::Const);\n-        record_array!(self.tables.children[def_id] <- variant.fields.iter().map(|f| {\n-            assert!(f.did.is_local());\n-            f.did.index\n-        }));\n-        if let Some((CtorKind::Fn, ctor_def_id)) = variant.ctor {\n-            // FIXME(eddyb) encode signature only in `encode_enum_variant_ctor`.\n-            record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(ctor_def_id));\n+        let params_in_repr = self.tcx.params_in_repr(def_id);\n+        record!(self.tables.params_in_repr[def_id] <- params_in_repr);\n+\n+        if adt_def.is_enum() {\n+            record_array!(self.tables.children[def_id] <- iter::from_generator(||\n+                for variant in tcx.adt_def(def_id).variants() {\n+                    yield variant.def_id.index;\n+                    // Encode constructors which take a separate slot in value namespace.\n+                    if let Some(ctor_def_id) = variant.ctor_def_id() {\n+                        yield ctor_def_id.index;\n+                    }\n+                }\n+            ));\n+        } else {\n+            // For non-enum, there is only one variant, and its def_id is the adt's.\n+            debug_assert_eq!(adt_def.variants().len(), 1);\n+            debug_assert_eq!(adt_def.non_enum_variant().def_id, def_id);\n+            // Therefore, the loop over variants will encode its fields as the adt's children.\n         }\n-    }\n \n-    fn encode_enum_variant_ctor(&mut self, def: ty::AdtDef<'tcx>, index: VariantIdx) {\n-        let variant = &def.variant(index);\n-        let Some((ctor_kind, def_id)) = variant.ctor else { return };\n-        debug!(\"EncodeContext::encode_enum_variant_ctor({:?})\", def_id);\n+        for variant in adt_def.variants().iter() {\n+            let data = VariantData {\n+                discr: variant.discr,\n+                ctor: variant.ctor.map(|(kind, def_id)| (kind, def_id.index)),\n+                is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n+            };\n+            record!(self.tables.variant_data[variant.def_id] <- data);\n \n-        // FIXME(eddyb) encode only the `CtorKind` for constructors.\n-        let data = VariantData {\n-            discr: variant.discr,\n-            ctor: Some((ctor_kind, def_id.index)),\n-            is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-        };\n+            self.tables.constness.set(variant.def_id.index, hir::Constness::Const);\n+            record_array!(self.tables.children[variant.def_id] <- variant.fields.iter().map(|f| {\n+                assert!(f.did.is_local());\n+                f.did.index\n+            }));\n \n-        record!(self.tables.variant_data[def_id] <- data);\n-        self.tables.constness.set(def_id.index, hir::Constness::Const);\n-        if ctor_kind == CtorKind::Fn {\n-            record!(self.tables.fn_sig[def_id] <- self.tcx.fn_sig(def_id));\n+            if let Some((CtorKind::Fn, ctor_def_id)) = variant.ctor {\n+                self.tables.constness.set(ctor_def_id.index, hir::Constness::Const);\n+                let fn_sig = tcx.fn_sig(ctor_def_id);\n+                record!(self.tables.fn_sig[ctor_def_id] <- fn_sig);\n+                // FIXME only encode signature for ctor_def_id\n+                record!(self.tables.fn_sig[variant.def_id] <- fn_sig);\n+            }\n         }\n     }\n \n@@ -1305,25 +1310,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_struct_ctor(&mut self, adt_def: ty::AdtDef<'tcx>) {\n-        let variant = adt_def.non_enum_variant();\n-        let Some((ctor_kind, def_id)) = variant.ctor else { return };\n-        debug!(\"EncodeContext::encode_struct_ctor({:?})\", def_id);\n-\n-        let data = VariantData {\n-            discr: variant.discr,\n-            ctor: Some((ctor_kind, def_id.index)),\n-            is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-        };\n-\n-        record!(self.tables.repr_options[def_id] <- adt_def.repr());\n-        record!(self.tables.variant_data[def_id] <- data);\n-        self.tables.constness.set(def_id.index, hir::Constness::Const);\n-        if ctor_kind == CtorKind::Fn {\n-            record!(self.tables.fn_sig[def_id] <- self.tcx.fn_sig(def_id));\n-        }\n-    }\n-\n     fn encode_explicit_item_bounds(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_explicit_item_bounds({:?})\", def_id);\n         let bounds = self.tcx.explicit_item_bounds(def_id);\n@@ -1532,33 +1518,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     self.tables.is_type_alias_impl_trait.set_nullable(def_id.index, true);\n                 }\n             }\n-            hir::ItemKind::Enum(..) => {\n-                let adt_def = self.tcx.adt_def(def_id);\n-                record!(self.tables.repr_options[def_id] <- adt_def.repr());\n-            }\n-            hir::ItemKind::Struct(..) => {\n-                let adt_def = self.tcx.adt_def(def_id);\n-                record!(self.tables.repr_options[def_id] <- adt_def.repr());\n-                self.tables.constness.set(def_id.index, hir::Constness::Const);\n-\n-                let variant = adt_def.non_enum_variant();\n-                record!(self.tables.variant_data[def_id] <- VariantData {\n-                    discr: variant.discr,\n-                    ctor: variant.ctor.map(|(kind, def_id)| (kind, def_id.index)),\n-                    is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-                });\n-            }\n-            hir::ItemKind::Union(..) => {\n-                let adt_def = self.tcx.adt_def(def_id);\n-                record!(self.tables.repr_options[def_id] <- adt_def.repr());\n-\n-                let variant = adt_def.non_enum_variant();\n-                record!(self.tables.variant_data[def_id] <- VariantData {\n-                    discr: variant.discr,\n-                    ctor: variant.ctor.map(|(kind, def_id)| (kind, def_id.index)),\n-                    is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-                });\n-            }\n             hir::ItemKind::Impl(hir::Impl { defaultness, constness, .. }) => {\n                 self.tables.impl_defaultness.set(def_id.index, *defaultness);\n                 self.tables.constness.set(def_id.index, *constness);\n@@ -1597,31 +1556,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             hir::ItemKind::Static(..)\n             | hir::ItemKind::Const(..)\n+            | hir::ItemKind::Enum(..)\n+            | hir::ItemKind::Struct(..)\n+            | hir::ItemKind::Union(..)\n             | hir::ItemKind::ForeignMod { .. }\n             | hir::ItemKind::GlobalAsm(..)\n             | hir::ItemKind::TyAlias(..) => {}\n         };\n         // FIXME(eddyb) there should be a nicer way to do this.\n         match item.kind {\n-            hir::ItemKind::Enum(..) => {\n-                record_array!(self.tables.children[def_id] <- iter::from_generator(||\n-                    for variant in tcx.adt_def(def_id).variants() {\n-                        yield variant.def_id.index;\n-                        // Encode constructors which take a separate slot in value namespace.\n-                        if let Some(ctor_def_id) = variant.ctor_def_id() {\n-                            yield ctor_def_id.index;\n-                        }\n-                    }\n-                ))\n-            }\n-            hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n-                record_array!(self.tables.children[def_id] <-\n-                    self.tcx.adt_def(def_id).non_enum_variant().fields.iter().map(|f| {\n-                        assert!(f.did.is_local());\n-                        f.did.index\n-                    })\n-                )\n-            }\n             hir::ItemKind::Impl { .. } | hir::ItemKind::Trait(..) => {\n                 let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n                 record_array!(self.tables.children[def_id] <-\n@@ -1649,17 +1592,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // so it's easier to do that here then to wait until we would encounter\n         // normally in the visitor walk.\n         match item.kind {\n-            hir::ItemKind::Enum(..) => {\n-                let def = self.tcx.adt_def(item.owner_id.to_def_id());\n-                for (i, _) in def.variants().iter_enumerated() {\n-                    self.encode_enum_variant_info(def, i);\n-                    self.encode_enum_variant_ctor(def, i);\n-                }\n-            }\n-            hir::ItemKind::Struct(..) => {\n-                let def = self.tcx.adt_def(item.owner_id.to_def_id());\n-                self.encode_struct_ctor(def);\n-            }\n             hir::ItemKind::Impl { .. } => {\n                 for &trait_item_def_id in\n                     self.tcx.associated_item_def_ids(item.owner_id.to_def_id()).iter()"}]}