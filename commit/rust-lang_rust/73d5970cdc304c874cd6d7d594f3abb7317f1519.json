{"sha": "73d5970cdc304c874cd6d7d594f3abb7317f1519", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczZDU5NzBjZGMzMDRjODc0Y2Q2ZDdkNTk0ZjNhYmI3MzE3ZjE1MTk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-31T07:37:09Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-02-13T14:16:36Z"}, "message": "parser: introduce `parse_item_kind` as central `ItemInfo` logic.\n\nthis also extracts macro item parsers.", "tree": {"sha": "bbbf208a589c1cd28659fa7d0cf8070d728e74bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbbf208a589c1cd28659fa7d0cf8070d728e74bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73d5970cdc304c874cd6d7d594f3abb7317f1519", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73d5970cdc304c874cd6d7d594f3abb7317f1519", "html_url": "https://github.com/rust-lang/rust/commit/73d5970cdc304c874cd6d7d594f3abb7317f1519", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73d5970cdc304c874cd6d7d594f3abb7317f1519/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "511dfdb8b3d8c6d395b1b5a205c3464ae802509f", "url": "https://api.github.com/repos/rust-lang/rust/commits/511dfdb8b3d8c6d395b1b5a205c3464ae802509f", "html_url": "https://github.com/rust-lang/rust/commit/511dfdb8b3d8c6d395b1b5a205c3464ae802509f"}], "stats": {"total": 365, "additions": 168, "deletions": 197}, "files": [{"sha": "9ba3be041b5e6be1235f476284822e534fbb49ab", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 156, "deletions": 192, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/73d5970cdc304c874cd6d7d594f3abb7317f1519/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d5970cdc304c874cd6d7d594f3abb7317f1519/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=73d5970cdc304c874cd6d7d594f3abb7317f1519", "patch": "@@ -11,7 +11,7 @@ use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::BytePos;\n use syntax::ast::{self, AttrKind, AttrStyle, AttrVec, Attribute, Ident, DUMMY_NODE_ID};\n use syntax::ast::{AssocItem, AssocItemKind, Item, ItemKind, UseTree, UseTreeKind};\n-use syntax::ast::{Async, Const, Defaultness, IsAuto, PathSegment, StrLit, Unsafe};\n+use syntax::ast::{Async, Const, Defaultness, IsAuto, PathSegment, Unsafe};\n use syntax::ast::{BindingMode, Block, FnDecl, FnSig, Mac, MacArgs, MacDelimiter, Param, SelfKind};\n use syntax::ast::{EnumDef, Generics, StructField, TraitRef, Ty, TyKind, Variant, VariantData};\n use syntax::ast::{FnHeader, ForeignItem, ForeignItemKind, Mutability, Visibility, VisibilityKind};\n@@ -83,45 +83,60 @@ impl<'a> Parser<'a> {\n         });\n \n         let lo = self.token.span;\n-\n         let vis = self.parse_visibility(FollowedByType::No)?;\n \n-        if self.eat_keyword(kw::Use) {\n-            // USE ITEM\n-            let item_ = ItemKind::Use(P(self.parse_use_tree()?));\n-            self.expect_semi()?;\n+        if let Some(info) = self.parse_item_kind(&mut attrs, macros_allowed, lo, &vis)? {\n+            return Ok(Some(self.mk_item_with_info(attrs, lo, vis, info)));\n+        }\n \n-            let span = lo.to(self.prev_span);\n-            let item = self.mk_item(span, Ident::invalid(), item_, vis, attrs);\n-            return Ok(Some(item));\n+        // FAILURE TO PARSE ITEM\n+        match vis.node {\n+            VisibilityKind::Inherited => {}\n+            _ => {\n+                self.struct_span_err(vis.span, \"unmatched visibility `pub`\")\n+                    .span_label(vis.span, \"the unmatched visibility\")\n+                    .help(\"you likely meant to define an item, e.g., `pub fn foo() {}`\")\n+                    .emit();\n+            }\n         }\n \n-        if self.check_fn_front_matter() {\n-            // FUNCTION ITEM\n-            let (ident, sig, generics, body) = self.parse_fn(&mut false, &mut attrs, |_| true)?;\n-            let kind = ItemKind::Fn(sig, generics, body);\n-            return self.mk_item_with_info(attrs, lo, vis, (ident, kind, None));\n+        if !attributes_allowed && !attrs.is_empty() {\n+            self.expected_item_err(&attrs)?;\n         }\n+        Ok(None)\n+    }\n \n-        if self.eat_keyword(kw::Extern) {\n+    /// Parses one of the items allowed by the flags.\n+    fn parse_item_kind(\n+        &mut self,\n+        attrs: &mut Vec<Attribute>,\n+        macros_allowed: bool,\n+        lo: Span,\n+        vis: &Visibility,\n+    ) -> PResult<'a, Option<ItemInfo>> {\n+        let info = if self.eat_keyword(kw::Use) {\n+            // USE ITEM\n+            let tree = self.parse_use_tree()?;\n+            self.expect_semi()?;\n+            (Ident::invalid(), ItemKind::Use(P(tree)), None)\n+        } else if self.check_fn_front_matter() {\n+            // FUNCTION ITEM\n+            let (ident, sig, generics, body) = self.parse_fn(&mut false, attrs, |_| true)?;\n+            (ident, ItemKind::Fn(sig, generics, body), None)\n+        } else if self.eat_keyword(kw::Extern) {\n             if self.eat_keyword(kw::Crate) {\n                 // EXTERN CRATE\n-                return Ok(Some(self.parse_item_extern_crate(lo, vis, attrs)?));\n+                self.parse_item_extern_crate()?\n+            } else {\n+                // EXTERN BLOCK\n+                self.parse_item_foreign_mod()?\n             }\n-            // EXTERN BLOCK\n-            let abi = self.parse_abi();\n-            return Ok(Some(self.parse_item_foreign_mod(lo, abi, vis, attrs)?));\n-        }\n-\n-        if self.is_static_global() {\n+        } else if self.is_static_global() {\n             // STATIC ITEM\n-            self.bump();\n+            self.bump(); // `static`\n             let m = self.parse_mutability();\n-            let info = self.parse_item_const(Some(m))?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if let Const::Yes(const_span) = self.parse_constness() {\n+            self.parse_item_const(Some(m))?\n+        } else if let Const::Yes(const_span) = self.parse_constness() {\n             // CONST ITEM\n             if self.eat_keyword(kw::Mut) {\n                 let prev_span = self.prev_span;\n@@ -136,77 +151,62 @@ impl<'a> Parser<'a> {\n                     .emit();\n             }\n \n-            let info = self.parse_item_const(None)?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if self.check_keyword(kw::Unsafe) && self.is_keyword_ahead(1, &[kw::Trait, kw::Auto]) {\n+            self.parse_item_const(None)?\n+        } else if self.check_keyword(kw::Unsafe) && self.is_keyword_ahead(1, &[kw::Trait, kw::Auto])\n+        {\n             // UNSAFE TRAIT ITEM\n             let unsafety = self.parse_unsafety();\n-            let info = self.parse_item_trait(lo, unsafety)?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if self.check_keyword(kw::Impl)\n+            self.parse_item_trait(lo, unsafety)?\n+        } else if self.check_keyword(kw::Impl)\n             || self.check_keyword(kw::Unsafe) && self.is_keyword_ahead(1, &[kw::Impl])\n             || self.check_keyword(kw::Default) && self.is_keyword_ahead(1, &[kw::Impl, kw::Unsafe])\n         {\n             // IMPL ITEM\n             let defaultness = self.parse_defaultness();\n             let unsafety = self.parse_unsafety();\n             self.expect_keyword(kw::Impl)?;\n-            let info = self.parse_item_impl(unsafety, defaultness)?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if self.eat_keyword(kw::Mod) {\n+            self.parse_item_impl(unsafety, defaultness)?\n+        } else if self.eat_keyword(kw::Mod) {\n             // MODULE ITEM\n-            let info = self.parse_item_mod(&attrs[..])?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if self.eat_keyword(kw::Type) {\n+            self.parse_item_mod(&attrs[..])?\n+        } else if self.eat_keyword(kw::Type) {\n             // TYPE ITEM\n             let (ident, ty, generics) = self.parse_type_alias()?;\n-            let kind = ItemKind::TyAlias(ty, generics);\n-            return self.mk_item_with_info(attrs, lo, vis, (ident, kind, None));\n-        }\n-\n-        if self.eat_keyword(kw::Enum) {\n+            (ident, ItemKind::TyAlias(ty, generics), None)\n+        } else if self.eat_keyword(kw::Enum) {\n             // ENUM ITEM\n-            let info = self.parse_item_enum()?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if self.check_keyword(kw::Trait)\n+            self.parse_item_enum()?\n+        } else if self.check_keyword(kw::Trait)\n             || (self.check_keyword(kw::Auto) && self.is_keyword_ahead(1, &[kw::Trait]))\n         {\n             // TRAIT ITEM\n-            let info = self.parse_item_trait(lo, Unsafe::No)?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if self.eat_keyword(kw::Struct) {\n+            self.parse_item_trait(lo, Unsafe::No)?\n+        } else if self.eat_keyword(kw::Struct) {\n             // STRUCT ITEM\n-            let info = self.parse_item_struct()?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if self.is_union_item() {\n+            self.parse_item_struct()?\n+        } else if self.is_union_item() {\n             // UNION ITEM\n-            self.bump();\n-            let info = self.parse_item_union()?;\n-            return self.mk_item_with_info(attrs, lo, vis, info);\n-        }\n-\n-        if let Some(macro_def) = self.eat_macro_def(&attrs, &vis, lo)? {\n-            return Ok(Some(macro_def));\n-        }\n-\n-        if vis.node.is_pub() && self.check_ident() && self.look_ahead(1, |t| *t != token::Not) {\n+            self.bump(); // `union`\n+            self.parse_item_union()?\n+        } else if self.eat_keyword(kw::Macro) {\n+            // MACROS 2.0 ITEM\n+            self.parse_item_decl_macro(lo)?\n+        } else if self.is_macro_rules_item() {\n+            // MACRO_RULES ITEM\n+            self.parse_item_macro_rules(vis)?\n+        } else if vis.node.is_pub()\n+            && self.check_ident()\n+            && self.look_ahead(1, |t| *t != token::Not)\n+        {\n             self.recover_missing_kw_before_item()?;\n-        }\n-        self.parse_macro_use_or_failure(attrs, macros_allowed, attributes_allowed, lo, vis)\n+            return Ok(None);\n+        } else if macros_allowed && self.token.is_path_start() {\n+            // MACRO INVOCATION ITEM\n+            self.parse_item_macro(vis)?\n+        } else {\n+            return Ok(None);\n+        };\n+        Ok(Some(info))\n     }\n \n     /// Recover on encountering a struct or method definition where the user\n@@ -312,11 +312,11 @@ impl<'a> Parser<'a> {\n         lo: Span,\n         vis: Visibility,\n         info: ItemInfo,\n-    ) -> PResult<'a, Option<P<Item>>> {\n+    ) -> P<Item> {\n         let (ident, item, extra_attrs) = info;\n         let span = lo.to(self.prev_span);\n         let attrs = Self::maybe_append(attrs, extra_attrs);\n-        Ok(Some(self.mk_item(span, ident, item, vis, attrs)))\n+        self.mk_item(span, ident, item, vis, attrs)\n     }\n \n     fn maybe_append<T>(mut lhs: Vec<T>, mut rhs: Option<Vec<T>>) -> Vec<T> {\n@@ -326,49 +326,20 @@ impl<'a> Parser<'a> {\n         lhs\n     }\n \n-    /// This is the fall-through for parsing items.\n-    fn parse_macro_use_or_failure(\n-        &mut self,\n-        attrs: Vec<Attribute>,\n-        macros_allowed: bool,\n-        attributes_allowed: bool,\n-        lo: Span,\n-        visibility: Visibility,\n-    ) -> PResult<'a, Option<P<Item>>> {\n-        if macros_allowed\n-            && self.token.is_path_start()\n-            && !(self.is_async_fn() && self.token.span.rust_2015())\n-        {\n-            // MACRO INVOCATION ITEM\n-\n-            let prev_span = self.prev_span;\n-            self.complain_if_pub_macro(&visibility.node, prev_span);\n-\n-            // Item macro\n-            let path = self.parse_path(PathStyle::Mod)?;\n-            self.expect(&token::Not)?;\n-            let args = self.parse_mac_args()?;\n-            if args.need_semicolon() && !self.eat(&token::Semi) {\n-                self.report_invalid_macro_expansion_item();\n-            }\n-\n-            let hi = self.prev_span;\n-            let mac = Mac { path, args, prior_type_ascription: self.last_type_ascription };\n-            let item =\n-                self.mk_item(lo.to(hi), Ident::invalid(), ItemKind::Mac(mac), visibility, attrs);\n-            return Ok(Some(item));\n-        }\n+    /// Parses an item macro, e.g., `item!();`.\n+    fn parse_item_macro(&mut self, vis: &Visibility) -> PResult<'a, ItemInfo> {\n+        self.complain_if_pub_macro(&vis.node, vis.span);\n \n-        // FAILURE TO PARSE ITEM\n-        match visibility.node {\n-            VisibilityKind::Inherited => {}\n-            _ => return Err(self.struct_span_err(self.prev_span, \"unmatched visibility `pub`\")),\n+        // Item macro\n+        let path = self.parse_path(PathStyle::Mod)?;\n+        self.expect(&token::Not)?;\n+        let args = self.parse_mac_args()?;\n+        if args.need_semicolon() && !self.eat(&token::Semi) {\n+            self.report_invalid_macro_expansion_item();\n         }\n \n-        if !attributes_allowed && !attrs.is_empty() {\n-            self.expected_item_err(&attrs)?;\n-        }\n-        Ok(None)\n+        let mac = Mac { path, args, prior_type_ascription: self.last_type_ascription };\n+        Ok((Ident::invalid(), ItemKind::Mac(mac), None))\n     }\n \n     /// Emits an expected-item-after-attributes error.\n@@ -874,12 +845,7 @@ impl<'a> Parser<'a> {\n     /// extern crate foo;\n     /// extern crate bar as foo;\n     /// ```\n-    fn parse_item_extern_crate(\n-        &mut self,\n-        lo: Span,\n-        visibility: Visibility,\n-        attrs: Vec<Attribute>,\n-    ) -> PResult<'a, P<Item>> {\n+    fn parse_item_extern_crate(&mut self) -> PResult<'a, ItemInfo> {\n         // Accept `extern crate name-like-this` for better diagnostics\n         let orig_name = self.parse_crate_name_with_dashes()?;\n         let (item_name, orig_name) = if let Some(rename) = self.parse_rename()? {\n@@ -888,9 +854,7 @@ impl<'a> Parser<'a> {\n             (orig_name, None)\n         };\n         self.expect_semi()?;\n-\n-        let span = lo.to(self.prev_span);\n-        Ok(self.mk_item(span, item_name, ItemKind::ExternCrate(orig_name), visibility, attrs))\n+        Ok((item_name, ItemKind::ExternCrate(orig_name), None))\n     }\n \n     fn parse_crate_name_with_dashes(&mut self) -> PResult<'a, ast::Ident> {\n@@ -933,27 +897,19 @@ impl<'a> Parser<'a> {\n \n     /// Parses `extern` for foreign ABIs modules.\n     ///\n-    /// `extern` is expected to have been\n-    /// consumed before calling this method.\n+    /// `extern` is expected to have been consumed before calling this method.\n     ///\n     /// # Examples\n     ///\n     /// ```ignore (only-for-syntax-highlight)\n     /// extern \"C\" {}\n     /// extern {}\n     /// ```\n-    fn parse_item_foreign_mod(\n-        &mut self,\n-        lo: Span,\n-        abi: Option<StrLit>,\n-        vis: Visibility,\n-        mut attrs: Vec<Attribute>,\n-    ) -> PResult<'a, P<Item>> {\n-        let (items, iattrs) = self.parse_item_list(|p, at_end| p.parse_foreign_item(at_end))?;\n-        attrs.extend(iattrs);\n-        let span = lo.to(self.prev_span);\n-        let m = ast::ForeignMod { abi, items };\n-        Ok(self.mk_item(span, Ident::invalid(), ItemKind::ForeignMod(m), vis, attrs))\n+    fn parse_item_foreign_mod(&mut self) -> PResult<'a, ItemInfo> {\n+        let abi = self.parse_abi(); // ABI?\n+        let (items, attrs) = self.parse_item_list(|p, at_end| p.parse_foreign_item(at_end))?;\n+        let module = ast::ForeignMod { abi, items };\n+        Ok((Ident::invalid(), ItemKind::ForeignMod(module), Some(attrs)))\n     }\n \n     /// Parses a foreign item (one in an `extern { ... }` block).\n@@ -1386,64 +1342,72 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    pub(super) fn eat_macro_def(\n-        &mut self,\n-        attrs: &[Attribute],\n-        vis: &Visibility,\n-        lo: Span,\n-    ) -> PResult<'a, Option<P<Item>>> {\n-        let (ident, def) = if self.eat_keyword(kw::Macro) {\n-            let ident = self.parse_ident()?;\n+    /// Parses a declarative macro 2.0 definition.\n+    /// The `macro` keyword has already been parsed.\n+    fn parse_item_decl_macro(&mut self, lo: Span) -> PResult<'a, ItemInfo> {\n+        let ident = self.parse_ident()?;\n+        let body = if self.check(&token::OpenDelim(token::Brace)) {\n+            self.parse_mac_args()?\n+        } else if self.check(&token::OpenDelim(token::Paren)) {\n+            let params = self.parse_token_tree();\n+            let pspan = params.span();\n             let body = if self.check(&token::OpenDelim(token::Brace)) {\n-                self.parse_mac_args()?\n-            } else if self.check(&token::OpenDelim(token::Paren)) {\n-                let params = self.parse_token_tree();\n-                let pspan = params.span();\n-                let body = if self.check(&token::OpenDelim(token::Brace)) {\n-                    self.parse_token_tree()\n-                } else {\n-                    return self.unexpected();\n-                };\n-                let bspan = body.span();\n-                let tokens = TokenStream::new(vec![\n-                    params.into(),\n-                    TokenTree::token(token::FatArrow, pspan.between(bspan)).into(),\n-                    body.into(),\n-                ]);\n-                let dspan = DelimSpan::from_pair(pspan.shrink_to_lo(), bspan.shrink_to_hi());\n-                P(MacArgs::Delimited(dspan, MacDelimiter::Brace, tokens))\n+                self.parse_token_tree()\n             } else {\n                 return self.unexpected();\n             };\n+            let bspan = body.span();\n+            let tokens = TokenStream::new(vec![\n+                params.into(),\n+                TokenTree::token(token::FatArrow, pspan.between(bspan)).into(),\n+                body.into(),\n+            ]);\n+            let dspan = DelimSpan::from_pair(pspan.shrink_to_lo(), bspan.shrink_to_hi());\n+            P(MacArgs::Delimited(dspan, MacDelimiter::Brace, tokens))\n+        } else {\n+            return self.unexpected();\n+        };\n+\n+        self.sess.gated_spans.gate(sym::decl_macro, lo.to(self.prev_span));\n+        Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, legacy: false }), None))\n+    }\n \n-            (ident, ast::MacroDef { body, legacy: false })\n-        } else if self.check_keyword(sym::macro_rules)\n+    /// Is this unambiguously the start of a `macro_rules! foo` item defnition?\n+    fn is_macro_rules_item(&mut self) -> bool {\n+        self.check_keyword(sym::macro_rules)\n             && self.look_ahead(1, |t| *t == token::Not)\n             && self.look_ahead(2, |t| t.is_ident())\n-        {\n-            let prev_span = self.prev_span;\n-            self.complain_if_pub_macro(&vis.node, prev_span);\n-            self.bump();\n-            self.bump();\n-\n-            let ident = self.parse_ident()?;\n-            let body = self.parse_mac_args()?;\n-            if body.need_semicolon() && !self.eat(&token::Semi) {\n-                self.report_invalid_macro_expansion_item();\n-            }\n-\n-            (ident, ast::MacroDef { body, legacy: true })\n-        } else {\n-            return Ok(None);\n-        };\n+    }\n \n-        let span = lo.to(self.prev_span);\n+    /// Parses a legacy `macro_rules! foo { ... }` declarative macro.\n+    fn parse_item_macro_rules(&mut self, vis: &Visibility) -> PResult<'a, ItemInfo> {\n+        self.complain_if_pub_macro(&vis.node, vis.span);\n+        self.expect_keyword(sym::macro_rules)?; // `macro_rules`\n+        self.expect(&token::Not)?; // `!`\n \n-        if !def.legacy {\n-            self.sess.gated_spans.gate(sym::decl_macro, span);\n+        let ident = self.parse_ident()?;\n+        let body = self.parse_mac_args()?;\n+        if body.need_semicolon() && !self.eat(&token::Semi) {\n+            self.report_invalid_macro_expansion_item();\n         }\n \n-        Ok(Some(self.mk_item(span, ident, ItemKind::MacroDef(def), vis.clone(), attrs.to_vec())))\n+        Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, legacy: true }), None))\n+    }\n+\n+    pub(super) fn eat_macro_def(\n+        &mut self,\n+        attrs: &[Attribute],\n+        vis: &Visibility,\n+        lo: Span,\n+    ) -> PResult<'a, Option<P<Item>>> {\n+        let info = if self.eat_keyword(kw::Macro) {\n+            self.parse_item_decl_macro(lo)?\n+        } else if self.is_macro_rules_item() {\n+            self.parse_item_macro_rules(vis)?\n+        } else {\n+            return Ok(None);\n+        };\n+        Ok(Some(self.mk_item_with_info(attrs.to_vec(), lo, vis.clone(), info)))\n     }\n \n     fn complain_if_pub_macro(&self, vis: &VisibilityKind, sp: Span) {"}, {"sha": "3f8904fbe79d878e1fc261ea4162b1fd00ad5f4d", "filename": "src/test/ui/pub/pub-restricted-error-fn.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/73d5970cdc304c874cd6d7d594f3abb7317f1519/src%2Ftest%2Fui%2Fpub%2Fpub-restricted-error-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d5970cdc304c874cd6d7d594f3abb7317f1519/src%2Ftest%2Fui%2Fpub%2Fpub-restricted-error-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpub%2Fpub-restricted-error-fn.rs?ref=73d5970cdc304c874cd6d7d594f3abb7317f1519", "patch": "@@ -1,3 +1,2 @@\n-#![feature(pub_restricted)]\n-\n pub(crate) () fn foo() {} //~ unmatched visibility\n+//~^ ERROR expected item, found `(`"}, {"sha": "c5acb92dcd4364d905f4c24c445c7131944e5e16", "filename": "src/test/ui/pub/pub-restricted-error-fn.stderr", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/73d5970cdc304c874cd6d7d594f3abb7317f1519/src%2Ftest%2Fui%2Fpub%2Fpub-restricted-error-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/73d5970cdc304c874cd6d7d594f3abb7317f1519/src%2Ftest%2Fui%2Fpub%2Fpub-restricted-error-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpub%2Fpub-restricted-error-fn.stderr?ref=73d5970cdc304c874cd6d7d594f3abb7317f1519", "patch": "@@ -1,8 +1,16 @@\n error: unmatched visibility `pub`\n-  --> $DIR/pub-restricted-error-fn.rs:3:10\n+  --> $DIR/pub-restricted-error-fn.rs:1:1\n    |\n LL | pub(crate) () fn foo() {}\n-   |          ^\n+   | ^^^^^^^^^^ the unmatched visibility\n+   |\n+   = help: you likely meant to define an item, e.g., `pub fn foo() {}`\n+\n+error: expected item, found `(`\n+  --> $DIR/pub-restricted-error-fn.rs:1:12\n+   |\n+LL | pub(crate) () fn foo() {}\n+   |            ^ expected item\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n "}]}