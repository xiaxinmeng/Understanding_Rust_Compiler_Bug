{"sha": "6c43bd3c8334c0b8edf1c15e20bbd8daa877481a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNDNiZDNjODMzNGMwYjhlZGYxYzE1ZTIwYmJkOGRhYTg3NzQ4MWE=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2017-10-13T15:37:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-10-13T15:37:51Z"}, "message": "Rollup merge of #44855 - federicomenaquintero:master, r=steveklabnik\n\nImproved docs for CStr, CString, OsStr, OsString\n\nThis expands the documentation for those structs and their corresponding traits, per https://github.com/rust-lang/rust/issues/29354", "tree": {"sha": "ef346b46eb247ff901bb5754c7dce48dde643f85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef346b46eb247ff901bb5754c7dce48dde643f85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c43bd3c8334c0b8edf1c15e20bbd8daa877481a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c43bd3c8334c0b8edf1c15e20bbd8daa877481a", "html_url": "https://github.com/rust-lang/rust/commit/6c43bd3c8334c0b8edf1c15e20bbd8daa877481a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c43bd3c8334c0b8edf1c15e20bbd8daa877481a/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d21c02396419d905344baeeb6186343d8038c5ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/d21c02396419d905344baeeb6186343d8038c5ef", "html_url": "https://github.com/rust-lang/rust/commit/d21c02396419d905344baeeb6186343d8038c5ef"}, {"sha": "5fb8e3d829e77643e9c153172fb3a67f85eebe81", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fb8e3d829e77643e9c153172fb3a67f85eebe81", "html_url": "https://github.com/rust-lang/rust/commit/5fb8e3d829e77643e9c153172fb3a67f85eebe81"}], "stats": {"total": 509, "additions": 442, "deletions": 67}, "files": [{"sha": "b54603919427c33bb812fa4f56e55061cf05a001", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 186, "deletions": 65, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/6c43bd3c8334c0b8edf1c15e20bbd8daa877481a/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c43bd3c8334c0b8edf1c15e20bbd8daa877481a/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=6c43bd3c8334c0b8edf1c15e20bbd8daa877481a", "patch": "@@ -23,19 +23,69 @@ use ptr;\n use slice;\n use str::{self, Utf8Error};\n \n-/// A type representing an owned C-compatible string.\n+/// A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the\n+/// middle.\n ///\n-/// This type serves the primary purpose of being able to safely generate a\n+/// This type serves the purpose of being able to safely generate a\n /// C-compatible string from a Rust byte slice or vector. An instance of this\n /// type is a static guarantee that the underlying bytes contain no interior 0\n-/// bytes and the final byte is 0.\n+/// bytes (\"nul characters\") and that the final byte is 0 (\"nul terminator\").\n ///\n-/// A `CString` is created from either a byte slice or a byte vector. A [`u8`]\n-/// slice can be obtained with the `as_bytes` method. Slices produced from a\n-/// `CString` do *not* contain the trailing nul terminator unless otherwise\n-/// specified.\n+/// `CString` is to [`CStr`] as [`String`] is to [`&str`]: the former\n+/// in each pair are owned strings; the latter are borrowed\n+/// references.\n ///\n+/// # Creating a `CString`\n+///\n+/// A `CString` is created from either a byte slice or a byte vector,\n+/// or anything that implements [`Into`]`<`[`Vec`]`<`[`u8`]`>>` (for\n+/// example, you can build a `CString` straight out of a [`String`] or\n+/// a [`&str`], since both implement that trait).\n+///\n+/// The [`new`] method will actually check that the provided `&[u8]`\n+/// does not have 0 bytes in the middle, and return an error if it\n+/// finds one.\n+///\n+/// # Extracting a raw pointer to the whole C string\n+///\n+/// `CString` implements a [`as_ptr`] method through the [`Deref`]\n+/// trait. This method will give you a `*const c_char` which you can\n+/// feed directly to extern functions that expect a nul-terminated\n+/// string, like C's `strdup()`.\n+///\n+/// # Extracting a slice of the whole C string\n+///\n+/// Alternatively, you can obtain a `&[`[`u8`]`]` slice from a\n+/// `CString` with the [`as_bytes`] method. Slices produced in this\n+/// way do *not* contain the trailing nul terminator. This is useful\n+/// when you will be calling an extern function that takes a `*const\n+/// u8` argument which is not necessarily nul-terminated, plus another\n+/// argument with the length of the string \u2014 like C's `strndup()`.\n+/// You can of course get the slice's length with its\n+/// [`len`][slice.len] method.\n+///\n+/// If you need a `&[`[`u8`]`]` slice *with* the nul terminator, you\n+/// can use [`as_bytes_with_nul`] instead.\n+///\n+/// Once you have the kind of slice you need (with or without a nul\n+/// terminator), you can call the slice's own\n+/// [`as_ptr`][slice.as_ptr] method to get a raw pointer to pass to\n+/// extern functions. See the documentation for that function for a\n+/// discussion on ensuring the lifetime of the raw pointer.\n+///\n+/// [`Into`]: ../convert/trait.Into.html\n+/// [`Vec`]: ../vec/struct.Vec.html\n+/// [`String`]: ../string/struct.String.html\n+/// [`&str`]: ../primitive.str.html\n /// [`u8`]: ../primitive.u8.html\n+/// [`new`]: #method.new\n+/// [`as_bytes`]: #method.as_bytes\n+/// [`as_bytes_with_nul`]: #method.as_bytes_with_nul\n+/// [`as_ptr`]: #method.as_ptr\n+/// [slice.as_ptr]: ../primitive.slice.html#method.as_ptr\n+/// [slice.len]: ../primitive.slice.html#method.len\n+/// [`Deref`]: ../ops/trait.Deref.html\n+/// [`CStr`]: struct.CStr.html\n ///\n /// # Examples\n ///\n@@ -48,6 +98,8 @@ use str::{self, Utf8Error};\n ///     fn my_printer(s: *const c_char);\n /// }\n ///\n+/// // We are certain that our string doesn't have 0 bytes in the middle,\n+/// // so we can .unwrap()\n /// let c_to_print = CString::new(\"Hello, world!\").unwrap();\n /// unsafe {\n ///     my_printer(c_to_print.as_ptr());\n@@ -58,7 +110,7 @@ use str::{self, Utf8Error};\n /// # Safety\n ///\n /// `CString` is intended for working with traditional C-style strings\n-/// (a sequence of non-null bytes terminated by a single null byte); the\n+/// (a sequence of non-nul bytes terminated by a single nul byte); the\n /// primary use case for these kinds of strings is interoperating with C-like\n /// code. Often you will need to transfer ownership to/from that external\n /// code. It is strongly recommended that you thoroughly read through the\n@@ -77,17 +129,21 @@ pub struct CString {\n \n /// Representation of a borrowed C string.\n ///\n-/// This dynamically sized type is only safely constructed via a borrowed\n-/// version of an instance of `CString`. This type can be constructed from a raw\n-/// C string as well and represents a C string borrowed from another location.\n+/// This type represents a borrowed reference to a nul-terminated\n+/// array of bytes. It can be constructed safely from a `&[`[`u8`]`]`\n+/// slice, or unsafely from a raw `*const c_char`. It can then be\n+/// converted to a Rust [`&str`] by performing UTF-8 validation, or\n+/// into an owned [`CString`].\n+///\n+/// `CStr` is to [`CString`] as [`&str`] is to [`String`]: the former\n+/// in each pair are borrowed references; the latter are owned\n+/// strings.\n ///\n /// Note that this structure is **not** `repr(C)` and is not recommended to be\n-/// placed in the signatures of FFI functions. Instead safe wrappers of FFI\n+/// placed in the signatures of FFI functions. Instead, safe wrappers of FFI\n /// functions may leverage the unsafe [`from_ptr`] constructor to provide a safe\n /// interface to other consumers.\n ///\n-/// [`from_ptr`]: #method.from_ptr\n-///\n /// # Examples\n ///\n /// Inspecting a foreign C string:\n@@ -100,7 +156,7 @@ pub struct CString {\n ///\n /// unsafe {\n ///     let slice = CStr::from_ptr(my_string());\n-///     println!(\"string length: {}\", slice.to_bytes().len());\n+///     println!(\"string buffer size without nul terminator: {}\", slice.to_bytes().len());\n /// }\n /// ```\n ///\n@@ -122,8 +178,6 @@ pub struct CString {\n ///\n /// Converting a foreign C string into a Rust [`String`]:\n ///\n-/// [`String`]: ../string/struct.String.html\n-///\n /// ```no_run\n /// use std::ffi::CStr;\n /// use std::os::raw::c_char;\n@@ -138,6 +192,12 @@ pub struct CString {\n ///\n /// println!(\"string: {}\", my_string_safe());\n /// ```\n+///\n+/// [`u8`]: ../primitive.u8.html\n+/// [`&str`]: ../primitive.str.html\n+/// [`String`]: ../string/struct.String.html\n+/// [`CString`]: struct.CString.html\n+/// [`from_ptr`]: #method.from_ptr\n #[derive(Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CStr {\n@@ -148,9 +208,15 @@ pub struct CStr {\n     inner: [c_char]\n }\n \n-/// An error returned from [`CString::new`] to indicate that a nul byte was found\n-/// in the vector provided.\n+/// An error indicating that an interior nul byte was found.\n+///\n+/// While Rust strings may contain nul bytes in the middle, C strings\n+/// can't, as that byte would effectively truncate the string.\n ///\n+/// This error is created by the [`new`][`CString::new`] method on\n+/// [`CString`]. See its documentation for more.\n+///\n+/// [`CString`]: struct.CString.html\n /// [`CString::new`]: struct.CString.html#method.new\n ///\n /// # Examples\n@@ -164,9 +230,16 @@ pub struct CStr {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct NulError(usize, Vec<u8>);\n \n-/// An error returned from [`CStr::from_bytes_with_nul`] to indicate that a nul\n-/// byte was found too early in the slice provided or one wasn't found at all.\n+/// An error indicating that a nul byte was not in the expected position.\n+///\n+/// The slice used to create a [`CStr`] must have one and only one nul\n+/// byte at the end of the slice.\n ///\n+/// This error is created by the\n+/// [`from_bytes_with_nul`][`CStr::from_bytes_with_nul`] method on\n+/// [`CStr`]. See its documentation for more.\n+///\n+/// [`CStr`]: struct.CStr.html\n /// [`CStr::from_bytes_with_nul`]: struct.CStr.html#method.from_bytes_with_nul\n ///\n /// # Examples\n@@ -201,9 +274,18 @@ impl FromBytesWithNulError {\n     }\n }\n \n-/// An error returned from [`CString::into_string`] to indicate that a UTF-8 error\n-/// was encountered during the conversion.\n+/// An error indicating invalid UTF-8 when converting a [`CString`] into a [`String`].\n+///\n+/// `CString` is just a wrapper over a buffer of bytes with a nul\n+/// terminator; [`into_string`][`CString::into_string`] performs UTF-8\n+/// validation on those bytes and may return this error.\n+///\n+/// This `struct` is created by the\n+/// [`into_string`][`CString::into_string`] method on [`CString`]. See\n+/// its documentation for more.\n ///\n+/// [`String`]: ../string/struct.String.html\n+/// [`CString`]: struct.CString.html\n /// [`CString::into_string`]: struct.CString.html#method.into_string\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n@@ -215,8 +297,11 @@ pub struct IntoStringError {\n impl CString {\n     /// Creates a new C-compatible string from a container of bytes.\n     ///\n-    /// This method will consume the provided data and use the underlying bytes\n-    /// to construct a new string, ensuring that there is a trailing 0 byte.\n+    /// This function will consume the provided data and use the\n+    /// underlying bytes to construct a new string, ensuring that\n+    /// there is a trailing 0 byte. This trailing 0 byte will be\n+    /// appended by this function; the provided data should *not*\n+    /// contain any 0 bytes in it.\n     ///\n     /// # Examples\n     ///\n@@ -234,9 +319,11 @@ impl CString {\n     ///\n     /// # Errors\n     ///\n-    /// This function will return an error if the bytes yielded contain an\n-    /// internal 0 byte. The error returned will contain the bytes as well as\n+    /// This function will return an error if the supplied bytes contain an\n+    /// internal 0 byte. The [`NulError`] returned will contain the bytes as well as\n     /// the position of the nul byte.\n+    ///\n+    /// [`NulError`]: struct.NulError.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new<T: Into<Vec<u8>>>(t: T) -> Result<CString, NulError> {\n         Self::_new(t.into())\n@@ -249,8 +336,8 @@ impl CString {\n         }\n     }\n \n-    /// Creates a C-compatible string from a byte vector without checking for\n-    /// interior 0 bytes.\n+    /// Creates a C-compatible string by consuming a byte vector,\n+    /// without checking for interior 0 bytes.\n     ///\n     /// This method is equivalent to [`new`] except that no runtime assertion\n     /// is made that `v` contains no 0 bytes, and it requires an actual\n@@ -275,7 +362,7 @@ impl CString {\n         CString { inner: v.into_boxed_slice() }\n     }\n \n-    /// Retakes ownership of a `CString` that was transferred to C.\n+    /// Retakes ownership of a `CString` that was transferred to C via [`into_raw`].\n     ///\n     /// Additionally, the length of the string will be recalculated from the pointer.\n     ///\n@@ -286,7 +373,14 @@ impl CString {\n     /// ownership of a string that was allocated by foreign code) is likely to lead\n     /// to undefined behavior or allocator corruption.\n     ///\n+    /// > **Note:** If you need to borrow a string that was allocated by\n+    /// > foreign code, use [`CStr`]. If you need to take ownership of\n+    /// > a string that was allocated by foreign code, you will need to\n+    /// > make your own provisions for freeing it appropriately, likely\n+    /// > with the foreign code's API to do that.\n+    ///\n     /// [`into_raw`]: #method.into_raw\n+    /// [`CStr`]: struct.CStr.html\n     ///\n     /// # Examples\n     ///\n@@ -315,11 +409,11 @@ impl CString {\n         CString { inner: Box::from_raw(slice as *mut [c_char] as *mut [u8]) }\n     }\n \n-    /// Transfers ownership of the string to a C caller.\n+    /// Consumes the `CString` and transfers ownership of the string to a C caller.\n     ///\n-    /// The pointer must be returned to Rust and reconstituted using\n+    /// The pointer which this function returns must be returned to Rust and reconstituted using\n     /// [`from_raw`] to be properly deallocated. Specifically, one\n-    /// should *not* use the standard C `free` function to deallocate\n+    /// should *not* use the standard C `free()` function to deallocate\n     /// this string.\n     ///\n     /// Failure to call [`from_raw`] will lead to a memory leak.\n@@ -351,11 +445,27 @@ impl CString {\n         Box::into_raw(self.into_inner()) as *mut c_char\n     }\n \n-    /// Converts the `CString` into a [`String`] if it contains valid Unicode data.\n+    /// Converts the `CString` into a [`String`] if it contains valid UTF-8 data.\n     ///\n     /// On failure, ownership of the original `CString` is returned.\n     ///\n     /// [`String`]: ../string/struct.String.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::CString;\n+    ///\n+    /// let valid_utf8 = vec![b'f', b'o', b'o'];\n+    /// let cstring = CString::new(valid_utf8).unwrap();\n+    /// assert_eq!(cstring.into_string().unwrap(), \"foo\");\n+    ///\n+    /// let invalid_utf8 = vec![b'f', 0xff, b'o', b'o'];\n+    /// let cstring = CString::new(invalid_utf8).unwrap();\n+    /// let err = cstring.into_string().err().unwrap();\n+    /// assert_eq!(err.utf8_error().valid_up_to(), 1);\n+    /// ```\n+\n     #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n     pub fn into_string(self) -> Result<String, IntoStringError> {\n         String::from_utf8(self.into_bytes())\n@@ -365,10 +475,11 @@ impl CString {\n             })\n     }\n \n-    /// Returns the underlying byte buffer.\n+    /// Consumes the `CString` and returns the underlying byte buffer.\n     ///\n-    /// The returned buffer does **not** contain the trailing nul separator and\n-    /// it is guaranteed to not have any interior nul bytes.\n+    /// The returned buffer does **not** contain the trailing nul\n+    /// terminator, and it is guaranteed to not have any interior nul\n+    /// bytes.\n     ///\n     /// # Examples\n     ///\n@@ -388,7 +499,7 @@ impl CString {\n     }\n \n     /// Equivalent to the [`into_bytes`] function except that the returned vector\n-    /// includes the trailing nul byte.\n+    /// includes the trailing nul terminator.\n     ///\n     /// [`into_bytes`]: #method.into_bytes\n     ///\n@@ -408,8 +519,12 @@ impl CString {\n \n     /// Returns the contents of this `CString` as a slice of bytes.\n     ///\n-    /// The returned slice does **not** contain the trailing nul separator and\n-    /// it is guaranteed to not have any interior nul bytes.\n+    /// The returned slice does **not** contain the trailing nul\n+    /// terminator, and it is guaranteed to not have any interior nul\n+    /// bytes. If you need the nul terminator, use\n+    /// [`as_bytes_with_nul`] instead.\n+    ///\n+    /// [`as_bytes_with_nul`]: #method.as_bytes_with_nul\n     ///\n     /// # Examples\n     ///\n@@ -427,7 +542,7 @@ impl CString {\n     }\n \n     /// Equivalent to the [`as_bytes`] function except that the returned slice\n-    /// includes the trailing nul byte.\n+    /// includes the trailing nul terminator.\n     ///\n     /// [`as_bytes`]: #method.as_bytes\n     ///\n@@ -598,8 +713,8 @@ impl Default for Box<CStr> {\n }\n \n impl NulError {\n-    /// Returns the position of the nul byte in the slice that was provided to\n-    /// [`CString::new`].\n+    /// Returns the position of the nul byte in the slice that caused\n+    /// [`CString::new`] to fail.\n     ///\n     /// [`CString::new`]: struct.CString.html#method.new\n     ///\n@@ -711,9 +826,9 @@ impl fmt::Display for IntoStringError {\n }\n \n impl CStr {\n-    /// Casts a raw C string to a safe C string wrapper.\n+    /// Wraps a raw C string with a safe C string wrapper.\n     ///\n-    /// This function will cast the provided `ptr` to the `CStr` wrapper which\n+    /// This function will wrap the provided `ptr` with a `CStr` wrapper, which\n     /// allows inspection and interoperation of non-owned C strings. This method\n     /// is unsafe for a number of reasons:\n     ///\n@@ -753,9 +868,9 @@ impl CStr {\n \n     /// Creates a C string wrapper from a byte slice.\n     ///\n-    /// This function will cast the provided `bytes` to a `CStr` wrapper after\n-    /// ensuring that it is null terminated and does not contain any interior\n-    /// nul bytes.\n+    /// This function will cast the provided `bytes` to a `CStr`\n+    /// wrapper after ensuring that the byte slice is nul-terminated\n+    /// and does not contain any interior nul bytes.\n     ///\n     /// # Examples\n     ///\n@@ -766,7 +881,7 @@ impl CStr {\n     /// assert!(cstr.is_ok());\n     /// ```\n     ///\n-    /// Creating a `CStr` without a trailing nul byte is an error:\n+    /// Creating a `CStr` without a trailing nul terminator is an error:\n     ///\n     /// ```\n     /// use std::ffi::CStr;\n@@ -800,7 +915,7 @@ impl CStr {\n     /// Unsafely creates a C string wrapper from a byte slice.\n     ///\n     /// This function will cast the provided `bytes` to a `CStr` wrapper without\n-    /// performing any sanity checks. The provided slice must be null terminated\n+    /// performing any sanity checks. The provided slice **must** be nul-terminated\n     /// and not contain any interior nul bytes.\n     ///\n     /// # Examples\n@@ -822,7 +937,7 @@ impl CStr {\n \n     /// Returns the inner pointer to this C string.\n     ///\n-    /// The returned pointer will be valid for as long as `self` is and points\n+    /// The returned pointer will be valid for as long as `self` is, and points\n     /// to a contiguous region of memory terminated with a 0 byte to represent\n     /// the end of the string.\n     ///\n@@ -843,9 +958,9 @@ impl CStr {\n     /// ```\n     ///\n     /// This happens because the pointer returned by `as_ptr` does not carry any\n-    /// lifetime information and the string is deallocated immediately after\n+    /// lifetime information and the [`CString`] is deallocated immediately after\n     /// the `CString::new(\"Hello\").unwrap().as_ptr()` expression is evaluated.\n-    /// To fix the problem, bind the string to a local variable:\n+    /// To fix the problem, bind the `CString` to a local variable:\n     ///\n     /// ```no_run\n     /// use std::ffi::{CString};\n@@ -857,6 +972,11 @@ impl CStr {\n     ///     *ptr;\n     /// }\n     /// ```\n+    ///\n+    /// This way, the lifetime of the `CString` in `hello` encompasses\n+    /// the lifetime of `ptr` and the `unsafe` block.\n+    ///\n+    /// [`CString`]: struct.CString.html\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_ptr(&self) -> *const c_char {\n@@ -865,11 +985,7 @@ impl CStr {\n \n     /// Converts this C string to a byte slice.\n     ///\n-    /// This function will calculate the length of this string (which normally\n-    /// requires a linear amount of work to be done) and then return the\n-    /// resulting slice of `u8` elements.\n-    ///\n-    /// The returned slice will **not** contain the trailing nul that this C\n+    /// The returned slice will **not** contain the trailing nul terminator that this C\n     /// string has.\n     ///\n     /// > **Note**: This method is currently implemented as a 0-cost cast, but\n@@ -894,7 +1010,7 @@ impl CStr {\n     /// Converts this C string to a byte slice containing the trailing 0 byte.\n     ///\n     /// This function is the equivalent of [`to_bytes`] except that it will retain\n-    /// the trailing nul instead of chopping it off.\n+    /// the trailing nul terminator instead of chopping it off.\n     ///\n     /// > **Note**: This method is currently implemented as a 0-cost cast, but\n     /// > it is planned to alter its definition in the future to perform the\n@@ -918,8 +1034,9 @@ impl CStr {\n \n     /// Yields a [`&str`] slice if the `CStr` contains valid UTF-8.\n     ///\n-    /// This function will calculate the length of this string and check for\n-    /// UTF-8 validity, and then return the [`&str`] if it's valid.\n+    /// If the contents of the `CStr` are valid UTF-8 data, this\n+    /// function will return the corresponding [`&str`] slice. Otherwise,\n+    /// it will return an error with details of where UTF-8 validation failed.\n     ///\n     /// > **Note**: This method is currently implemented to check for validity\n     /// > after a 0-cost cast, but it is planned to alter its definition in the\n@@ -947,18 +1064,22 @@ impl CStr {\n \n     /// Converts a `CStr` into a [`Cow`]`<`[`str`]`>`.\n     ///\n-    /// This function will calculate the length of this string (which normally\n-    /// requires a linear amount of work to be done) and then return the\n-    /// resulting slice as a [`Cow`]`<`[`str`]`>`, replacing any invalid UTF-8 sequences\n-    /// with `U+FFFD REPLACEMENT CHARACTER`.\n+    /// If the contents of the `CStr` are valid UTF-8 data, this\n+    /// function will return a [`Cow`]`::`[`Borrowed`]`(`[`&str`]`)`\n+    /// with the the corresponding [`&str`] slice. Otherwise, it will\n+    /// replace any invalid UTF-8 sequences with `U+FFFD REPLACEMENT\n+    /// CHARACTER` and return a [`Cow`]`::`[`Owned`]`(`[`String`]`)`\n+    /// with the result.\n     ///\n     /// > **Note**: This method is currently implemented to check for validity\n     /// > after a 0-cost cast, but it is planned to alter its definition in the\n     /// > future to perform the length calculation in addition to the UTF-8\n     /// > check whenever this method is called.\n     ///\n     /// [`Cow`]: ../borrow/enum.Cow.html\n+    /// [`Borrowed`]: ../borrow/enum.Cow.html#variant.Borrowed\n     /// [`str`]: ../primitive.str.html\n+    /// [`String`]: ../string/struct.String.html\n     ///\n     /// # Examples\n     ///"}, {"sha": "a75596351e4cf3ec073fa809c29847b2e179969e", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/6c43bd3c8334c0b8edf1c15e20bbd8daa877481a/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c43bd3c8334c0b8edf1c15e20bbd8daa877481a/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=6c43bd3c8334c0b8edf1c15e20bbd8daa877481a", "patch": "@@ -9,6 +9,157 @@\n // except according to those terms.\n \n //! Utilities related to FFI bindings.\n+//!\n+//! This module provides utilities to handle data across non-Rust\n+//! interfaces, like other programming languages and the underlying\n+//! operating system. It is mainly of use for FFI (Foreign Function\n+//! Interface) bindings and code that needs to exchange C-like strings\n+//! with other languages.\n+//!\n+//! # Overview\n+//!\n+//! Rust represents owned strings with the [`String`] type, and\n+//! borrowed slices of strings with the [`str`] primitive. Both are\n+//! always in UTF-8 encoding, and may contain nul bytes in the middle,\n+//! i.e. if you look at the bytes that make up the string, there may\n+//! be a `\\0` among them. Both `String` and `str` store their length\n+//! explicitly; there are no nul terminators at the end of strings\n+//! like in C.\n+//!\n+//! C strings are different from Rust strings:\n+//!\n+//! * **Encodings** - Rust strings are UTF-8, but C strings may use\n+//! other encodings. If you are using a string from C, you should\n+//! check its encoding explicitly, rather than just assuming that it\n+//! is UTF-8 like you can do in Rust.\n+//!\n+//! * **Character size** - C strings may use `char` or `wchar_t`-sized\n+//! characters; please **note** that C's `char` is different from Rust's.\n+//! The C standard leaves the actual sizes of those types open to\n+//! interpretation, but defines different APIs for strings made up of\n+//! each character type. Rust strings are always UTF-8, so different\n+//! Unicode characters will be encoded in a variable number of bytes\n+//! each. The Rust type [`char`] represents a '[Unicode scalar\n+//! value]', which is similar to, but not the same as, a '[Unicode\n+//! code point]'.\n+//!\n+//! * **Nul terminators and implicit string lengths** - Often, C\n+//! strings are nul-terminated, i.e. they have a `\\0` character at the\n+//! end. The length of a string buffer is not stored, but has to be\n+//! calculated; to compute the length of a string, C code must\n+//! manually call a function like `strlen()` for `char`-based strings,\n+//! or `wcslen()` for `wchar_t`-based ones. Those functions return\n+//! the number of characters in the string excluding the nul\n+//! terminator, so the buffer length is really `len+1` characters.\n+//! Rust strings don't have a nul terminator; their length is always\n+//! stored and does not need to be calculated. While in Rust\n+//! accessing a string's length is a O(1) operation (becasue the\n+//! length is stored); in C it is an O(length) operation because the\n+//! length needs to be computed by scanning the string for the nul\n+//! terminator.\n+//!\n+//! * **Internal nul characters** - When C strings have a nul\n+//! terminator character, this usually means that they cannot have nul\n+//! characters in the middle \u2014 a nul character would essentially\n+//! truncate the string. Rust strings *can* have nul characters in\n+//! the middle, because nul does not have to mark the end of the\n+//! string in Rust.\n+//!\n+//! # Representations of non-Rust strings\n+//!\n+//! [`CString`] and [`CStr`] are useful when you need to transfer\n+//! UTF-8 strings to and from languages with a C ABI, like Python.\n+//!\n+//! * **From Rust to C:** [`CString`] represents an owned, C-friendly\n+//! string: it is nul-terminated, and has no internal nul characters.\n+//! Rust code can create a `CString` out of a normal string (provided\n+//! that the string doesn't have nul characters in the middle), and\n+//! then use a variety of methods to obtain a raw `*mut u8` that can\n+//! then be passed as an argument to functions which use the C\n+//! conventions for strings.\n+//!\n+//! * **From C to Rust:** [`CStr`] represents a borrowed C string; it\n+//! is what you would use to wrap a raw `*const u8` that you got from\n+//! a C function. A `CStr` is guaranteed to be a nul-terminated array\n+//! of bytes. Once you have a `CStr`, you can convert it to a Rust\n+//! `&str` if it's valid UTF-8, or lossily convert it by adding\n+//! replacement characters.\n+//!\n+//! [`OsString`] and [`OsStr`] are useful when you need to transfer\n+//! strings to and from the operating system itself, or when capturing\n+//! the output of external commands. Conversions between `OsString`,\n+//! `OsStr` and Rust strings work similarly to those for [`CString`]\n+//! and [`CStr`].\n+//!\n+//! * [`OsString`] represents an owned string in whatever\n+//! representation the operating system prefers. In the Rust standard\n+//! library, various APIs that transfer strings to/from the operating\n+//! system use `OsString` instead of plain strings. For example,\n+//! [`env::var_os()`] is used to query environment variables; it\n+//! returns an `Option<OsString>`. If the environment variable exists\n+//! you will get a `Some(os_string)`, which you can *then* try to\n+//! convert to a Rust string. This yields a [`Result<>`], so that\n+//! your code can detect errors in case the environment variable did\n+//! not in fact contain valid Unicode data.\n+//!\n+//! * [`OsStr`] represents a borrowed reference to a string in a\n+//! format that can be passed to the operating system. It can be\n+//! converted into an UTF-8 Rust string slice in a similar way to\n+//! `OsString`.\n+//!\n+//! # Conversions\n+//!\n+//! ## On Unix\n+//!\n+//! On Unix, [`OsStr`] implements the\n+//! `std::os::unix:ffi::`[`OsStrExt`][unix.OsStrExt] trait, which\n+//! augments it with two methods, [`from_bytes`] and [`as_bytes`].\n+//! These do inexpensive conversions from and to UTF-8 byte slices.\n+//!\n+//! Additionally, on Unix [`OsString`] implements the\n+//! `std::os::unix:ffi::`[`OsStringExt`][unix.OsStringExt] trait,\n+//! which provides [`from_vec`] and [`into_vec`] methods that consume\n+//! their arguments, and take or produce vectors of [`u8`].\n+//!\n+//! ## On Windows\n+//!\n+//! On Windows, [`OsStr`] implements the\n+//! `std::os::windows::ffi::`[`OsStrExt`][windows.OsStrExt] trait,\n+//! which provides an [`encode_wide`] method. This provides an\n+//! iterator that can be [`collect`]ed into a vector of [`u16`].\n+//!\n+//! Additionally, on Windows [`OsString`] implements the\n+//! `std::os::windows:ffi::`[`OsStringExt`][windows.OsStringExt]\n+//! trait, which provides a [`from_wide`] method. The result of this\n+//! method is an `OsString` which can be round-tripped to a Windows\n+//! string losslessly.\n+//!\n+//! [`String`]: ../string/struct.String.html\n+//! [`str`]: ../primitive.str.html\n+//! [`char`]: ../primitive.char.html\n+//! [`u8`]: ../primitive.u8.html\n+//! [`u16`]: ../primitive.u16.html\n+//! [Unicode scalar value]: http://www.unicode.org/glossary/#unicode_scalar_value\n+//! [Unicode code point]: http://www.unicode.org/glossary/#code_point\n+//! [`CString`]: struct.CString.html\n+//! [`CStr`]: struct.CStr.html\n+//! [`OsString`]: struct.OsString.html\n+//! [`OsStr`]: struct.OsStr.html\n+//! [`env::set_var()`]: ../env/fn.set_var.html\n+//! [`env::var_os()`]: ../env/fn.var_os.html\n+//! [`Result<>`]: ../result/enum.Result.html\n+//! [unix.OsStringExt]: ../os/unix/ffi/trait.OsStringExt.html\n+//! [`from_vec`]: ../os/unix/ffi/trait.OsStringExt.html#tymethod.from_vec\n+//! [`into_vec`]: ../os/unix/ffi/trait.OsStringExt.html#tymethod.into_vec\n+//! [unix.OsStrExt]: ../os/unix/ffi/trait.OsStrExt.html\n+//! [`from_bytes`]: ../os/unix/ffi/trait.OsStrExt.html#tymethod.from_bytes\n+//! [`as_bytes`]: ../os/unix/ffi/trait.OsStrExt.html#tymethod.as_bytes\n+//! [`OsStrExt`]: ../os/unix/ffi/trait.OsStrExt.html\n+//! [windows.OsStrExt]: ../os/windows/ffi/trait.OsStrExt.html\n+//! [`encode_wide`]: ../os/windows/ffi/trait.OsStrExt.html#tymethod.encode_wide\n+//! [`collect`]: ../iter/trait.Iterator.html#method.collect\n+//! [windows.OsStringExt]: ../os/windows/ffi/trait.OsStringExt.html\n+//! [`from_wide`]: ../os/windows/ffi/trait.OsStringExt.html#tymethod.from_wide\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "a97075ff8d8cd7f966dbd9298202e8f79a8a7661", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6c43bd3c8334c0b8edf1c15e20bbd8daa877481a/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c43bd3c8334c0b8edf1c15e20bbd8daa877481a/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=6c43bd3c8334c0b8edf1c15e20bbd8daa877481a", "patch": "@@ -32,18 +32,65 @@ use sys_common::{AsInner, IntoInner, FromInner};\n ///\n /// `OsString` and [`OsStr`] bridge this gap by simultaneously representing Rust\n /// and platform-native string values, and in particular allowing a Rust string\n-/// to be converted into an \"OS\" string with no cost.\n+/// to be converted into an \"OS\" string with no cost if possible.\n+///\n+/// `OsString` is to [`OsStr`] as [`String`] is to [`&str`]: the former\n+/// in each pair are owned strings; the latter are borrowed\n+/// references.\n+///\n+/// # Creating an `OsString`\n+///\n+/// **From a Rust string**: `OsString` implements\n+/// [`From`]`<`[`String`]`>`, so you can use `my_string.`[`from`] to\n+/// create an `OsString` from a normal Rust string.\n+///\n+/// **From slices:** Just like you can start with an empty Rust\n+/// [`String`] and then [`push_str`][String.push_str] `&str`\n+/// sub-string slices into it, you can create an empty `OsString` with\n+/// the [`new`] method and then push string slices into it with the\n+/// [`push`] method.\n+///\n+/// # Extracting a borrowed reference to the whole OS string\n+///\n+/// You can use the [`as_os_str`] method to get an `&`[`OsStr`] from\n+/// an `OsString`; this is effectively a borrowed reference to the\n+/// whole string.\n+///\n+/// # Conversions\n+///\n+/// See the [module's toplevel documentation about conversions][conversions] for a discussion on\n+/// the traits which `OsString` implements for conversions from/to native representations.\n ///\n /// [`OsStr`]: struct.OsStr.html\n+/// [`From`]: ../convert/trait.From.html\n+/// [`from`]: ../convert/trait.From.html#tymethod.from\n+/// [`String`]: ../string/struct.String.html\n+/// [`&str`]: ../primitive.str.html\n+/// [`u8`]: ../primitive.u8.html\n+/// [`u16`]: ../primitive.u16.html\n+/// [String.push_str]: ../string/struct.String.html#method.push_str\n+/// [`new`]: #method.new\n+/// [`push`]: #method.push\n+/// [`as_os_str`]: #method.as_os_str\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OsString {\n     inner: Buf\n }\n \n-/// Slices into OS strings (see [`OsString`]).\n+/// Borrowed reference to an OS string (see [`OsString`]).\n+///\n+/// This type represents a borrowed reference to a string in the operating system's preferred\n+/// representation.\n+///\n+/// `OsStr` is to [`OsString`] as [`String`] is to [`&str`]: the former in each pair are borrowed\n+/// references; the latter are owned strings.\n+///\n+/// See the [module's toplevel documentation about conversions][conversions] for a discussion on\n+/// the traits which `OsStr` implements for conversions from/to native representations.\n ///\n /// [`OsString`]: struct.OsString.html\n+/// [conversions]: index.html#conversions\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OsStr {\n     inner: Slice"}, {"sha": "d6b8896ac096d2e8caf3594a9b6459dfae69e8cb", "filename": "src/libstd/sys/windows/ext/ffi.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6c43bd3c8334c0b8edf1c15e20bbd8daa877481a/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c43bd3c8334c0b8edf1c15e20bbd8daa877481a/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs?ref=6c43bd3c8334c0b8edf1c15e20bbd8daa877481a", "patch": "@@ -9,6 +9,62 @@\n // except according to those terms.\n \n //! Windows-specific extensions to the primitives in the `std::ffi` module.\n+//!\n+//! # Overview\n+//!\n+//! For historical reasons, the Windows API uses a form of potentially\n+//! ill-formed UTF-16 encoding for strings.  Specifically, the 16-bit\n+//! code units in Windows strings may contain [isolated surrogate code\n+//! points which are not paired together][ill-formed-utf-16].  The\n+//! Unicode standard requires that surrogate code points (those in the\n+//! range U+D800 to U+DFFF) always be *paired*, because in the UTF-16\n+//! encoding a *surrogate code unit pair* is used to encode a single\n+//! character.  For compatibility with code that does not enforce\n+//! these pairings, Windows does not enforce them, either.\n+//!\n+//! While it is not always possible to convert such a string losslessly into\n+//! a valid UTF-16 string (or even UTF-8), it is often desirable to be\n+//! able to round-trip such a string from and to Windows APIs\n+//! losslessly.  For example, some Rust code may be \"bridging\" some\n+//! Windows APIs together, just passing `WCHAR` strings among those\n+//! APIs without ever really looking into the strings.\n+//!\n+//! If Rust code *does* need to look into those strings, it can\n+//! convert them to valid UTF-8, possibly lossily, by substituting\n+//! invalid sequences with U+FFFD REPLACEMENT CHARACTER, as is\n+//! conventionally done in other Rust APIs that deal with string\n+//! encodings.\n+//!\n+//! # `OsStringExt` and `OsStrExt`\n+//!\n+//! [`OsString`] is the Rust wrapper for owned strings in the\n+//! preferred representation of the operating system.  On Windows,\n+//! this struct gets augmented with an implementation of the\n+//! [`OsStringExt`] trait, which has a [`from_wide`] method.  This\n+//! lets you create an [`OsString`] from a `&[u16]` slice; presumably\n+//! you get such a slice out of a `WCHAR` Windows API.\n+//!\n+//! Similarly, [`OsStr`] is the Rust wrapper for borrowed strings from\n+//! preferred representation of the operating system.  On Windows, the\n+//! [`OsStrExt`] trait provides the [`encode_wide`] method, which\n+//! outputs an [`EncodeWide`] iterator.  You can [`collect`] this\n+//! iterator, for example, to obtain a `Vec<u16>`; you can later get a\n+//! pointer to this vector's contents and feed it to Windows APIs.\n+//!\n+//! These traits, along with [`OsString`] and [`OsStr`], work in\n+//! conjunction so that it is possible to **round-trip** strings from\n+//! Windows and back, with no loss of data, even if the strings are\n+//! ill-formed UTF-16.\n+//!\n+//! [ill-formed-utf-16]: https://simonsapin.github.io/wtf-8/#ill-formed-utf-16\n+//! [`OsString`]: ../../../ffi/struct.OsString.html\n+//! [`OsStr`]: ../../../ffi/struct.OsStr.html\n+//! [`OsStringExt`]: trait.OsStringExt.html\n+//! [`OsStrExt`]: trait.OsStrExt.html\n+//! [`EncodeWide`]: struct.EncodeWide.html\n+//! [`from_wide`]: trait.OsStringExt.html#tymethod.from_wide\n+//! [`encode_wide`]: trait.OsStrExt.html#tymethod.encode_wide\n+//! [`collect`]: ../../../iter/trait.Iterator.html#method.collect\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}]}