{"sha": "30896536f3901c9bf78a437f8d58a8a137758529", "node_id": "C_kwDOAAsO6NoAKDMwODk2NTM2ZjM5MDFjOWJmNzhhNDM3ZjhkNThhOGExMzc3NTg1Mjk", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2023-05-27T11:38:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-27T11:38:33Z"}, "message": "Rollup merge of #112014 - notriddle:notriddle/intra-doc-weird-syntax, r=GuillaumeGomez,fmease\n\nrustdoc: get unnormalized link destination for suggestions\n\nFixes #110111\n\nThis bug, and the workaround in this PR, is closely linked to [raphlinus/pulldown-cmark#441], getting offsets of link components. In particular, pulldown-cmark doesn't provide the offsets of the contents of a link.\n\nTo work around this, rustdoc parser parts of a link definition itself.\n\n[raphlinus/pulldown-cmark#441]: https://github.com/raphlinus/pulldown-cmark/issues/441", "tree": {"sha": "a2e3ea66878a412b5de3174d218964139674d787", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2e3ea66878a412b5de3174d218964139674d787"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30896536f3901c9bf78a437f8d58a8a137758529", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkceu5CRBK7hj4Ov3rIwAAYY4IAH5actdq5A5rIoJWBfCI8xfN\nE0jZKJuwJwM45fo6Uk/HTPNvc7vWdDFueVnTHC6aS18k31H6AyYNQcT+Bk+umibN\nkS/opzvsVbIkL6/oYvwoQ7/JhBrf/NKXGQpHAB/h0MvLUYTlikQv3VV+WRqD6HJN\nV+UjTl3J8mr28Vu91Ocz6ry1NfSs1jBt6zrMJfYuN9blad3wpy2YjWaa3ajPkgT1\nk1MaVrQia1mR0FjAf/1dVQCQFi+X5C+q2qhz6LjwebRRXSPNR1DwLWIVQ51wz1rg\ns6CeTfAF3xsM7A3iMA6aonUTCDIDPKmXcpoSV/xy4KU5N+FzhHRV21nYBTpl9TU=\n=wRv9\n-----END PGP SIGNATURE-----\n", "payload": "tree a2e3ea66878a412b5de3174d218964139674d787\nparent 480ac69a4c338d93d367a4afcba02caaf8843895\nparent 1a77d9a54d1fcf8b2a7aa339fb861d642ad4ff5a\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1685187513 +0200\ncommitter GitHub <noreply@github.com> 1685187513 +0200\n\nRollup merge of #112014 - notriddle:notriddle/intra-doc-weird-syntax, r=GuillaumeGomez,fmease\n\nrustdoc: get unnormalized link destination for suggestions\n\nFixes #110111\n\nThis bug, and the workaround in this PR, is closely linked to [raphlinus/pulldown-cmark#441], getting offsets of link components. In particular, pulldown-cmark doesn't provide the offsets of the contents of a link.\n\nTo work around this, rustdoc parser parts of a link definition itself.\n\n[raphlinus/pulldown-cmark#441]: https://github.com/raphlinus/pulldown-cmark/issues/441\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30896536f3901c9bf78a437f8d58a8a137758529", "html_url": "https://github.com/rust-lang/rust/commit/30896536f3901c9bf78a437f8d58a8a137758529", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30896536f3901c9bf78a437f8d58a8a137758529/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "480ac69a4c338d93d367a4afcba02caaf8843895", "url": "https://api.github.com/repos/rust-lang/rust/commits/480ac69a4c338d93d367a4afcba02caaf8843895", "html_url": "https://github.com/rust-lang/rust/commit/480ac69a4c338d93d367a4afcba02caaf8843895"}, {"sha": "1a77d9a54d1fcf8b2a7aa339fb861d642ad4ff5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a77d9a54d1fcf8b2a7aa339fb861d642ad4ff5a", "html_url": "https://github.com/rust-lang/rust/commit/1a77d9a54d1fcf8b2a7aa339fb861d642ad4ff5a"}], "stats": {"total": 713, "additions": 639, "deletions": 74}, "files": [{"sha": "9bb20022cfd4c612acaa92e90c5b7dab3691a95a", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 111, "deletions": 9, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/30896536f3901c9bf78a437f8d58a8a137758529/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30896536f3901c9bf78a437f8d58a8a137758529/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=30896536f3901c9bf78a437f8d58a8a137758529", "patch": "@@ -1237,7 +1237,27 @@ pub(crate) fn plain_text_summary(md: &str, link_names: &[RenderedLink]) -> Strin\n pub(crate) struct MarkdownLink {\n     pub kind: LinkType,\n     pub link: String,\n-    pub range: Range<usize>,\n+    pub range: MarkdownLinkRange,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub(crate) enum MarkdownLinkRange {\n+    /// Normally, markdown link warnings point only at the destination.\n+    Destination(Range<usize>),\n+    /// In some cases, it's not possible to point at the destination.\n+    /// Usually, this happens because backslashes `\\\\` are used.\n+    /// When that happens, point at the whole link, and don't provide structured suggestions.\n+    WholeLink(Range<usize>),\n+}\n+\n+impl MarkdownLinkRange {\n+    /// Extracts the inner range.\n+    pub fn inner_range(&self) -> &Range<usize> {\n+        match self {\n+            MarkdownLinkRange::Destination(range) => range,\n+            MarkdownLinkRange::WholeLink(range) => range,\n+        }\n+    }\n }\n \n pub(crate) fn markdown_links<R>(\n@@ -1257,16 +1277,17 @@ pub(crate) fn markdown_links<R>(\n         if md_start <= s_start && s_end <= md_end {\n             let start = s_start.offset_from(md_start) as usize;\n             let end = s_end.offset_from(md_start) as usize;\n-            start..end\n+            MarkdownLinkRange::Destination(start..end)\n         } else {\n-            fallback\n+            MarkdownLinkRange::WholeLink(fallback)\n         }\n     };\n \n     let span_for_link = |link: &CowStr<'_>, span: Range<usize>| {\n         // For diagnostics, we want to underline the link's definition but `span` will point at\n         // where the link is used. This is a problem for reference-style links, where the definition\n         // is separate from the usage.\n+\n         match link {\n             // `Borrowed` variant means the string (the link's destination) may come directly from\n             // the markdown text and we can locate the original link destination.\n@@ -1275,8 +1296,80 @@ pub(crate) fn markdown_links<R>(\n             CowStr::Borrowed(s) => locate(s, span),\n \n             // For anything else, we can only use the provided range.\n-            CowStr::Boxed(_) | CowStr::Inlined(_) => span,\n+            CowStr::Boxed(_) | CowStr::Inlined(_) => MarkdownLinkRange::WholeLink(span),\n+        }\n+    };\n+\n+    let span_for_offset_backward = |span: Range<usize>, open: u8, close: u8| {\n+        let mut open_brace = !0;\n+        let mut close_brace = !0;\n+        for (i, b) in md.as_bytes()[span.clone()].iter().copied().enumerate().rev() {\n+            let i = i + span.start;\n+            if b == close {\n+                close_brace = i;\n+                break;\n+            }\n+        }\n+        if close_brace < span.start || close_brace >= span.end {\n+            return MarkdownLinkRange::WholeLink(span);\n+        }\n+        let mut nesting = 1;\n+        for (i, b) in md.as_bytes()[span.start..close_brace].iter().copied().enumerate().rev() {\n+            let i = i + span.start;\n+            if b == close {\n+                nesting += 1;\n+            }\n+            if b == open {\n+                nesting -= 1;\n+            }\n+            if nesting == 0 {\n+                open_brace = i;\n+                break;\n+            }\n+        }\n+        assert!(open_brace != close_brace);\n+        if open_brace < span.start || open_brace >= span.end {\n+            return MarkdownLinkRange::WholeLink(span);\n+        }\n+        // do not actually include braces in the span\n+        let range = (open_brace + 1)..close_brace;\n+        MarkdownLinkRange::Destination(range.clone())\n+    };\n+\n+    let span_for_offset_forward = |span: Range<usize>, open: u8, close: u8| {\n+        let mut open_brace = !0;\n+        let mut close_brace = !0;\n+        for (i, b) in md.as_bytes()[span.clone()].iter().copied().enumerate() {\n+            let i = i + span.start;\n+            if b == open {\n+                open_brace = i;\n+                break;\n+            }\n+        }\n+        if open_brace < span.start || open_brace >= span.end {\n+            return MarkdownLinkRange::WholeLink(span);\n         }\n+        let mut nesting = 0;\n+        for (i, b) in md.as_bytes()[open_brace..span.end].iter().copied().enumerate() {\n+            let i = i + open_brace;\n+            if b == close {\n+                nesting -= 1;\n+            }\n+            if b == open {\n+                nesting += 1;\n+            }\n+            if nesting == 0 {\n+                close_brace = i;\n+                break;\n+            }\n+        }\n+        assert!(open_brace != close_brace);\n+        if open_brace < span.start || open_brace >= span.end {\n+            return MarkdownLinkRange::WholeLink(span);\n+        }\n+        // do not actually include braces in the span\n+        let range = (open_brace + 1)..close_brace;\n+        MarkdownLinkRange::Destination(range.clone())\n     };\n \n     Parser::new_with_broken_link_callback(\n@@ -1287,11 +1380,20 @@ pub(crate) fn markdown_links<R>(\n     .into_offset_iter()\n     .filter_map(|(event, span)| match event {\n         Event::Start(Tag::Link(link_type, dest, _)) if may_be_doc_link(link_type) => {\n-            preprocess_link(MarkdownLink {\n-                kind: link_type,\n-                range: span_for_link(&dest, span),\n-                link: dest.into_string(),\n-            })\n+            let range = match link_type {\n+                // Link is pulled from the link itself.\n+                LinkType::ReferenceUnknown | LinkType::ShortcutUnknown => {\n+                    span_for_offset_backward(span, b'[', b']')\n+                }\n+                LinkType::CollapsedUnknown => span_for_offset_forward(span, b'[', b']'),\n+                LinkType::Inline => span_for_offset_backward(span, b'(', b')'),\n+                // Link is pulled from elsewhere in the document.\n+                LinkType::Reference | LinkType::Collapsed | LinkType::Shortcut => {\n+                    span_for_link(&dest, span)\n+                }\n+                LinkType::Autolink | LinkType::Email => unreachable!(),\n+            };\n+            preprocess_link(MarkdownLink { kind: link_type, range, link: dest.into_string() })\n         }\n         _ => None,\n     })"}, {"sha": "417bdd58ad45ac1336558f3116e8588ed57ffb14", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 112, "deletions": 62, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/30896536f3901c9bf78a437f8d58a8a137758529/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30896536f3901c9bf78a437f8d58a8a137758529/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=30896536f3901c9bf78a437f8d58a8a137758529", "patch": "@@ -31,7 +31,7 @@ use std::ops::Range;\n use crate::clean::{self, utils::find_nearest_parent_module};\n use crate::clean::{Crate, Item, ItemLink, PrimitiveType};\n use crate::core::DocContext;\n-use crate::html::markdown::{markdown_links, MarkdownLink};\n+use crate::html::markdown::{markdown_links, MarkdownLink, MarkdownLinkRange};\n use crate::lint::{BROKEN_INTRA_DOC_LINKS, PRIVATE_INTRA_DOC_LINKS};\n use crate::passes::Pass;\n use crate::visit::DocVisitor;\n@@ -248,7 +248,7 @@ struct DiagnosticInfo<'a> {\n     item: &'a Item,\n     dox: &'a str,\n     ori_link: &'a str,\n-    link_range: Range<usize>,\n+    link_range: MarkdownLinkRange,\n }\n \n struct LinkCollector<'a, 'tcx> {\n@@ -833,7 +833,7 @@ impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n enum PreprocessingError {\n     /// User error: `[std#x#y]` is not valid\n     MultipleAnchors,\n-    Disambiguator(Range<usize>, String),\n+    Disambiguator(MarkdownLinkRange, String),\n     MalformedGenerics(MalformedGenerics, String),\n }\n \n@@ -873,6 +873,7 @@ pub(crate) struct PreprocessedMarkdownLink(\n /// `link_buffer` is needed for lifetime reasons; it will always be overwritten and the contents ignored.\n fn preprocess_link(\n     ori_link: &MarkdownLink,\n+    dox: &str,\n ) -> Option<Result<PreprocessingInfo, PreprocessingError>> {\n     // [] is mostly likely not supposed to be a link\n     if ori_link.link.is_empty() {\n@@ -906,9 +907,15 @@ fn preprocess_link(\n         Err((err_msg, relative_range)) => {\n             // Only report error if we would not have ignored this link. See issue #83859.\n             if !should_ignore_link_with_disambiguators(link) {\n-                let no_backticks_range = range_between_backticks(ori_link);\n-                let disambiguator_range = (no_backticks_range.start + relative_range.start)\n-                    ..(no_backticks_range.start + relative_range.end);\n+                let disambiguator_range = match range_between_backticks(&ori_link.range, dox) {\n+                    MarkdownLinkRange::Destination(no_backticks_range) => {\n+                        MarkdownLinkRange::Destination(\n+                            (no_backticks_range.start + relative_range.start)\n+                                ..(no_backticks_range.start + relative_range.end),\n+                        )\n+                    }\n+                    mdlr @ MarkdownLinkRange::WholeLink(_) => mdlr,\n+                };\n                 return Some(Err(PreprocessingError::Disambiguator(disambiguator_range, err_msg)));\n             } else {\n                 return None;\n@@ -947,7 +954,7 @@ fn preprocess_link(\n \n fn preprocessed_markdown_links(s: &str) -> Vec<PreprocessedMarkdownLink> {\n     markdown_links(s, |link| {\n-        preprocess_link(&link).map(|pp_link| PreprocessedMarkdownLink(pp_link, link))\n+        preprocess_link(&link, s).map(|pp_link| PreprocessedMarkdownLink(pp_link, link))\n     })\n }\n \n@@ -1060,22 +1067,12 @@ impl LinkCollector<'_, '_> {\n                     // valid omission. See https://github.com/rust-lang/rust/pull/80660#discussion_r551585677\n                     // for discussion on the matter.\n                     let kind = self.cx.tcx.def_kind(id);\n-                    self.verify_disambiguator(\n-                        path_str,\n-                        ori_link,\n-                        kind,\n-                        id,\n-                        disambiguator,\n-                        item,\n-                        &diag_info,\n-                    )?;\n+                    self.verify_disambiguator(path_str, kind, id, disambiguator, item, &diag_info)?;\n                 } else {\n                     match disambiguator {\n                         Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {}\n                         Some(other) => {\n-                            self.report_disambiguator_mismatch(\n-                                path_str, ori_link, other, res, &diag_info,\n-                            );\n+                            self.report_disambiguator_mismatch(path_str, other, res, &diag_info);\n                             return None;\n                         }\n                     }\n@@ -1096,7 +1093,6 @@ impl LinkCollector<'_, '_> {\n                 };\n                 self.verify_disambiguator(\n                     path_str,\n-                    ori_link,\n                     kind_for_dis,\n                     id_for_dis,\n                     disambiguator,\n@@ -1118,7 +1114,6 @@ impl LinkCollector<'_, '_> {\n     fn verify_disambiguator(\n         &self,\n         path_str: &str,\n-        ori_link: &MarkdownLink,\n         kind: DefKind,\n         id: DefId,\n         disambiguator: Option<Disambiguator>,\n@@ -1142,7 +1137,7 @@ impl LinkCollector<'_, '_> {\n                 => {}\n                 (actual, Some(Disambiguator::Kind(expected))) if actual == expected => {}\n                 (_, Some(specified @ Disambiguator::Kind(_) | specified @ Disambiguator::Primitive)) => {\n-                    self.report_disambiguator_mismatch(path_str,ori_link,specified, Res::Def(kind, id),diag_info);\n+                    self.report_disambiguator_mismatch(path_str, specified, Res::Def(kind, id), diag_info);\n                     return None;\n                 }\n             }\n@@ -1164,14 +1159,13 @@ impl LinkCollector<'_, '_> {\n     fn report_disambiguator_mismatch(\n         &self,\n         path_str: &str,\n-        ori_link: &MarkdownLink,\n         specified: Disambiguator,\n         resolved: Res,\n         diag_info: &DiagnosticInfo<'_>,\n     ) {\n         // The resolved item did not match the disambiguator; give a better error than 'not found'\n         let msg = format!(\"incompatible link kind for `{}`\", path_str);\n-        let callback = |diag: &mut Diagnostic, sp: Option<rustc_span::Span>| {\n+        let callback = |diag: &mut Diagnostic, sp: Option<rustc_span::Span>, link_range| {\n             let note = format!(\n                 \"this link resolved to {} {}, which is not {} {}\",\n                 resolved.article(),\n@@ -1184,14 +1178,24 @@ impl LinkCollector<'_, '_> {\n             } else {\n                 diag.note(note);\n             }\n-            suggest_disambiguator(resolved, diag, path_str, &ori_link.link, sp);\n+            suggest_disambiguator(resolved, diag, path_str, link_range, sp, diag_info);\n         };\n         report_diagnostic(self.cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, diag_info, callback);\n     }\n \n-    fn report_rawptr_assoc_feature_gate(&self, dox: &str, ori_link: &Range<usize>, item: &Item) {\n-        let span = super::source_span_for_markdown_range(self.cx.tcx, dox, ori_link, &item.attrs)\n-            .unwrap_or_else(|| item.attr_span(self.cx.tcx));\n+    fn report_rawptr_assoc_feature_gate(\n+        &self,\n+        dox: &str,\n+        ori_link: &MarkdownLinkRange,\n+        item: &Item,\n+    ) {\n+        let span = super::source_span_for_markdown_range(\n+            self.cx.tcx,\n+            dox,\n+            ori_link.inner_range(),\n+            &item.attrs,\n+        )\n+        .unwrap_or_else(|| item.attr_span(self.cx.tcx));\n         rustc_session::parse::feature_err(\n             &self.cx.tcx.sess.parse_sess,\n             sym::intra_doc_pointers,\n@@ -1371,16 +1375,23 @@ impl LinkCollector<'_, '_> {\n /// [`Foo`]\n ///   ^^^\n /// ```\n-fn range_between_backticks(ori_link: &MarkdownLink) -> Range<usize> {\n-    let after_first_backtick_group = ori_link.link.bytes().position(|b| b != b'`').unwrap_or(0);\n-    let before_second_backtick_group = ori_link\n-        .link\n+///\n+/// This function does nothing if `ori_link.range` is a `MarkdownLinkRange::WholeLink`.\n+fn range_between_backticks(ori_link_range: &MarkdownLinkRange, dox: &str) -> MarkdownLinkRange {\n+    let range = match ori_link_range {\n+        mdlr @ MarkdownLinkRange::WholeLink(_) => return mdlr.clone(),\n+        MarkdownLinkRange::Destination(inner) => inner.clone(),\n+    };\n+    let ori_link_text = &dox[range.clone()];\n+    let after_first_backtick_group = ori_link_text.bytes().position(|b| b != b'`').unwrap_or(0);\n+    let before_second_backtick_group = ori_link_text\n         .bytes()\n         .skip(after_first_backtick_group)\n         .position(|b| b == b'`')\n-        .unwrap_or(ori_link.link.len());\n-    (ori_link.range.start + after_first_backtick_group)\n-        ..(ori_link.range.start + before_second_backtick_group)\n+        .unwrap_or(ori_link_text.len());\n+    MarkdownLinkRange::Destination(\n+        (range.start + after_first_backtick_group)..(range.start + before_second_backtick_group),\n+    )\n }\n \n /// Returns true if we should ignore `link` due to it being unlikely\n@@ -1530,14 +1541,23 @@ impl Suggestion {\n         sp: rustc_span::Span,\n     ) -> Vec<(rustc_span::Span, String)> {\n         let inner_sp = match ori_link.find('(') {\n+            Some(index) if index != 0 && ori_link.as_bytes()[index - 1] == b'\\\\' => {\n+                sp.with_hi(sp.lo() + BytePos((index - 1) as _))\n+            }\n             Some(index) => sp.with_hi(sp.lo() + BytePos(index as _)),\n             None => sp,\n         };\n         let inner_sp = match ori_link.find('!') {\n+            Some(index) if index != 0 && ori_link.as_bytes()[index - 1] == b'\\\\' => {\n+                sp.with_hi(sp.lo() + BytePos((index - 1) as _))\n+            }\n             Some(index) => inner_sp.with_hi(inner_sp.lo() + BytePos(index as _)),\n             None => inner_sp,\n         };\n         let inner_sp = match ori_link.find('@') {\n+            Some(index) if index != 0 && ori_link.as_bytes()[index - 1] == b'\\\\' => {\n+                sp.with_hi(sp.lo() + BytePos((index - 1) as _))\n+            }\n             Some(index) => inner_sp.with_lo(inner_sp.lo() + BytePos(index as u32 + 1)),\n             None => inner_sp,\n         };\n@@ -1584,7 +1604,7 @@ fn report_diagnostic(\n     lint: &'static Lint,\n     msg: impl Into<DiagnosticMessage> + Display,\n     DiagnosticInfo { item, ori_link: _, dox, link_range }: &DiagnosticInfo<'_>,\n-    decorate: impl FnOnce(&mut Diagnostic, Option<rustc_span::Span>),\n+    decorate: impl FnOnce(&mut Diagnostic, Option<rustc_span::Span>, MarkdownLinkRange),\n ) {\n     let Some(hir_id) = DocContext::as_local_hir_id(tcx, item.item_id)\n     else {\n@@ -1596,16 +1616,32 @@ fn report_diagnostic(\n     let sp = item.attr_span(tcx);\n \n     tcx.struct_span_lint_hir(lint, hir_id, sp, msg, |lint| {\n-        let span =\n-            super::source_span_for_markdown_range(tcx, dox, link_range, &item.attrs).map(|sp| {\n-                if dox.as_bytes().get(link_range.start) == Some(&b'`')\n-                    && dox.as_bytes().get(link_range.end - 1) == Some(&b'`')\n-                {\n-                    sp.with_lo(sp.lo() + BytePos(1)).with_hi(sp.hi() - BytePos(1))\n-                } else {\n-                    sp\n-                }\n-            });\n+        let (span, link_range) = match link_range {\n+            MarkdownLinkRange::Destination(md_range) => {\n+                let mut md_range = md_range.clone();\n+                let sp = super::source_span_for_markdown_range(tcx, dox, &md_range, &item.attrs)\n+                    .map(|mut sp| {\n+                        while dox.as_bytes().get(md_range.start) == Some(&b' ')\n+                            || dox.as_bytes().get(md_range.start) == Some(&b'`')\n+                        {\n+                            md_range.start += 1;\n+                            sp = sp.with_lo(sp.lo() + BytePos(1));\n+                        }\n+                        while dox.as_bytes().get(md_range.end - 1) == Some(&b' ')\n+                            || dox.as_bytes().get(md_range.end - 1) == Some(&b'`')\n+                        {\n+                            md_range.end -= 1;\n+                            sp = sp.with_hi(sp.hi() - BytePos(1));\n+                        }\n+                        sp\n+                    });\n+                (sp, MarkdownLinkRange::Destination(md_range))\n+            }\n+            MarkdownLinkRange::WholeLink(md_range) => (\n+                super::source_span_for_markdown_range(tcx, dox, &md_range, &item.attrs),\n+                link_range.clone(),\n+            ),\n+        };\n \n         if let Some(sp) = span {\n             lint.set_span(sp);\n@@ -1614,21 +1650,22 @@ fn report_diagnostic(\n             //                       ^     ~~~~\n             //                       |     link_range\n             //                       last_new_line_offset\n-            let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n+            let md_range = link_range.inner_range().clone();\n+            let last_new_line_offset = dox[..md_range.start].rfind('\\n').map_or(0, |n| n + 1);\n             let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n \n-            // Print the line containing the `link_range` and manually mark it with '^'s.\n+            // Print the line containing the `md_range` and manually mark it with '^'s.\n             lint.note(format!(\n                 \"the link appears in this line:\\n\\n{line}\\n\\\n                      {indicator: <before$}{indicator:^<found$}\",\n                 line = line,\n                 indicator = \"\",\n-                before = link_range.start - last_new_line_offset,\n-                found = link_range.len(),\n+                before = md_range.start - last_new_line_offset,\n+                found = md_range.len(),\n             ));\n         }\n \n-        decorate(lint, span);\n+        decorate(lint, span, link_range);\n \n         lint\n     });\n@@ -1652,7 +1689,7 @@ fn resolution_failure(\n         BROKEN_INTRA_DOC_LINKS,\n         format!(\"unresolved link to `{}`\", path_str),\n         &diag_info,\n-        |diag, sp| {\n+        |diag, sp, link_range| {\n             let item = |res: Res| format!(\"the {} `{}`\", res.descr(), res.name(tcx),);\n             let assoc_item_not_allowed = |res: Res| {\n                 let name = res.name(tcx);\n@@ -1845,7 +1882,14 @@ fn resolution_failure(\n                 let note = match failure {\n                     ResolutionFailure::NotResolved { .. } => unreachable!(\"handled above\"),\n                     ResolutionFailure::WrongNamespace { res, expected_ns } => {\n-                        suggest_disambiguator(res, diag, path_str, diag_info.ori_link, sp);\n+                        suggest_disambiguator(\n+                            res,\n+                            diag,\n+                            path_str,\n+                            link_range.clone(),\n+                            sp,\n+                            &diag_info,\n+                        );\n \n                         format!(\n                             \"this link resolves to {}, which is not in the {} namespace\",\n@@ -1882,7 +1926,7 @@ fn anchor_failure(\n     msg: String,\n     anchor_idx: usize,\n ) {\n-    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, &diag_info, |diag, sp| {\n+    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, &diag_info, |diag, sp, _link_range| {\n         if let Some(mut sp) = sp {\n             if let Some((fragment_offset, _)) =\n                 diag_info.ori_link.char_indices().filter(|(_, x)| *x == '#').nth(anchor_idx)\n@@ -1898,11 +1942,11 @@ fn anchor_failure(\n fn disambiguator_error(\n     cx: &DocContext<'_>,\n     mut diag_info: DiagnosticInfo<'_>,\n-    disambiguator_range: Range<usize>,\n+    disambiguator_range: MarkdownLinkRange,\n     msg: impl Into<DiagnosticMessage> + Display,\n ) {\n     diag_info.link_range = disambiguator_range;\n-    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, &diag_info, |diag, _sp| {\n+    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, &diag_info, |diag, _sp, _link_range| {\n         let msg = format!(\n             \"see {}/rustdoc/write-documentation/linking-to-items-by-name.html#namespaces-and-disambiguators for more info about disambiguators\",\n             crate::DOC_RUST_LANG_ORG_CHANNEL\n@@ -1922,7 +1966,7 @@ fn report_malformed_generics(\n         BROKEN_INTRA_DOC_LINKS,\n         format!(\"unresolved link to `{}`\", path_str),\n         &diag_info,\n-        |diag, sp| {\n+        |diag, sp, _link_range| {\n             let note = match err {\n                 MalformedGenerics::UnbalancedAngleBrackets => \"unbalanced angle brackets\",\n                 MalformedGenerics::MissingType => \"missing type for generic parameters\",\n@@ -1995,15 +2039,15 @@ fn ambiguity_error(\n         }\n     }\n \n-    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, diag_info, |diag, sp| {\n+    report_diagnostic(cx.tcx, BROKEN_INTRA_DOC_LINKS, msg, diag_info, |diag, sp, link_range| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"ambiguous link\");\n         } else {\n             diag.note(\"ambiguous link\");\n         }\n \n         for res in kinds {\n-            suggest_disambiguator(res, diag, path_str, diag_info.ori_link, sp);\n+            suggest_disambiguator(res, diag, path_str, link_range.clone(), sp, diag_info);\n         }\n     });\n     true\n@@ -2015,13 +2059,19 @@ fn suggest_disambiguator(\n     res: Res,\n     diag: &mut Diagnostic,\n     path_str: &str,\n-    ori_link: &str,\n+    link_range: MarkdownLinkRange,\n     sp: Option<rustc_span::Span>,\n+    diag_info: &DiagnosticInfo<'_>,\n ) {\n     let suggestion = res.disambiguator_suggestion();\n     let help = format!(\"to link to the {}, {}\", res.descr(), suggestion.descr());\n \n-    if let Some(sp) = sp {\n+    let ori_link = match link_range {\n+        MarkdownLinkRange::Destination(range) => Some(&diag_info.dox[range]),\n+        MarkdownLinkRange::WholeLink(_) => None,\n+    };\n+\n+    if let (Some(sp), Some(ori_link)) = (sp, ori_link) {\n         let mut spans = suggestion.as_help_span(path_str, ori_link, sp);\n         if spans.len() > 1 {\n             diag.multipart_suggestion(help, spans, Applicability::MaybeIncorrect);\n@@ -2047,7 +2097,7 @@ fn privacy_error(cx: &DocContext<'_>, diag_info: &DiagnosticInfo<'_>, path_str:\n     let msg =\n         format!(\"public documentation for `{}` links to private item `{}`\", item_name, path_str);\n \n-    report_diagnostic(cx.tcx, PRIVATE_INTRA_DOC_LINKS, msg, diag_info, |diag, sp| {\n+    report_diagnostic(cx.tcx, PRIVATE_INTRA_DOC_LINKS, msg, diag_info, |diag, sp, _link_range| {\n         if let Some(sp) = sp {\n             diag.span_label(sp, \"this item is private\");\n         }"}, {"sha": "6c834fd0a1b617ba9c4a5f2a0640f992a2b5bc92", "filename": "tests/rustdoc-ui/intra-doc/issue-110495-suffix-with-space.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/30896536f3901c9bf78a437f8d58a8a137758529/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-110495-suffix-with-space.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30896536f3901c9bf78a437f8d58a8a137758529/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-110495-suffix-with-space.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fissue-110495-suffix-with-space.stderr?ref=30896536f3901c9bf78a437f8d58a8a137758529", "patch": "@@ -36,7 +36,7 @@ LL | //! [`Clone ()`].\n help: to link to the trait, prefix with `trait@`\n    |\n LL - //! [`Clone ()`].\n-LL + //! [`trait@Clone (`].\n+LL + //! [`trait@Clone `].\n    |\n \n error: incompatible link kind for `Clone`\n@@ -47,8 +47,9 @@ LL | //! [`Clone !`].\n    |\n help: to link to the derive macro, prefix with `derive@`\n    |\n-LL | //! [`derive@Clone !`].\n-   |       +++++++\n+LL - //! [`Clone !`].\n+LL + //! [`derive@Clone `].\n+   |\n \n error: aborting due to 4 previous errors\n "}, {"sha": "ca18842fb21c5e8199205c80919f7b6f9fa8aaef", "filename": "tests/rustdoc-ui/intra-doc/weird-syntax.rs", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/30896536f3901c9bf78a437f8d58a8a137758529/tests%2Frustdoc-ui%2Fintra-doc%2Fweird-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30896536f3901c9bf78a437f8d58a8a137758529/tests%2Frustdoc-ui%2Fintra-doc%2Fweird-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fweird-syntax.rs?ref=30896536f3901c9bf78a437f8d58a8a137758529", "patch": "@@ -0,0 +1,140 @@\n+// Many examples are from\n+// https://github.com/rust-lang/rust/issues/110111#issuecomment-1517800781\n+#![deny(rustdoc::broken_intra_doc_links)]\n+\n+//! This test case is closely linked to [raphlinus/pulldown-cmark#441], getting offsets of\n+//! link components. In particular, pulldown-cmark doesn't provide the offsets of the contents\n+//! of a link.\n+//!\n+//! To work around this, rustdoc parses parts of a link definition itself. This is basically a\n+//! test suite for that link syntax parser.\n+//!\n+//! [raphlinus/pulldown-cmark#441]: https://github.com/raphlinus/pulldown-cmark/issues/441\n+\n+use std::clone::Clone;\n+\n+// Basic version //\n+\n+/// [`struct@Clone`] //~ERROR link\n+pub struct LinkToCloneWithBackquotes;\n+\n+/// [```struct@Clone```] //~ERROR link\n+pub struct LinkToCloneWithMultipleBackquotes;\n+\n+/// [  `  struct@Clone  `  ] //~ERROR link\n+pub struct LinkToCloneWithSpacesAndBackquotes;\n+\n+/// [  `Clone ()`  ] //~ERROR link\n+pub struct LinkToCloneWithSpacesBackquotesAndParens;\n+\n+/// [`Clone ()`  ] //~ERROR link\n+pub struct LinkToCloneWithSpacesEndBackquotesAndParens;\n+\n+/// [  `Clone ()`] //~ERROR link\n+pub struct LinkToCloneWithSpacesStartBackquotesAndParens;\n+\n+/// [```Clone ()```] //~ERROR link\n+pub struct LinkToCloneWithMultipleBackquotesAndParens;\n+\n+/// [```Clone \\(\\)```] // not URL-shaped enough\n+pub struct LinkToCloneWithMultipleBackquotesAndEscapedParens;\n+\n+/// [  ```  Clone ()  ```  ] //~ERROR link\n+pub struct LinkToCloneWithSpacesMultipleBackquotesAndParens;\n+\n+/// [ x \\] ] // not URL-shaped enough\n+pub struct LinkWithEscapedCloseBrace;\n+\n+/// [ x \\[ ] // not URL-shaped enough\n+pub struct LinkWithEscapedOpenBrace;\n+\n+/// [ x \\( ] // not URL-shaped enough\n+pub struct LinkWithEscapedCloseParen;\n+\n+/// [ x \\) ] // not URL-shaped enough\n+pub struct LinkWithEscapedOpenParen;\n+\n+/// [ Clone \\(\\) ] // not URL-shaped enough\n+pub struct LinkWithEscapedParens;\n+\n+// [][] version //\n+\n+/// [x][ struct@Clone] //~ERROR link\n+pub struct XLinkToCloneWithStartSpace;\n+\n+/// [x][struct@Clone ] //~ERROR link\n+pub struct XLinkToCloneWithEndSpace;\n+\n+/// [x][Clone\\(\\)] not URL-shaped enough\n+pub struct XLinkToCloneWithEscapedParens;\n+\n+/// [x][`Clone`] not URL-shaped enough\n+pub struct XLinkToCloneWithBackquotes;\n+\n+/// [x][Clone()] //~ERROR link\n+pub struct XLinkToCloneWithUnescapedParens;\n+\n+/// [x][Clone  ()] //~ERROR link\n+pub struct XLinkToCloneWithUnescapedParensAndDoubleSpace;\n+\n+/// [x][Clone  [] //~ERROR unresolved link to `x`\n+pub struct XLinkToCloneWithUnmatchedOpenParenAndDoubleSpace;\n+\n+/// [x][Clone  \\[] // not URL-shaped enough\n+pub struct XLinkToCloneWithUnmatchedEscapedOpenParenAndDoubleSpace;\n+\n+/// [x][Clone  \\]] // not URL-shaped enough\n+pub struct XLinkToCloneWithUnmatchedEscapedCloseParenAndDoubleSpace;\n+\n+// []() version //\n+\n+/// [w]( struct@Clone) //~ERROR link\n+pub struct WLinkToCloneWithStartSpace;\n+\n+/// [w](struct@Clone ) //~ERROR link\n+pub struct WLinkToCloneWithEndSpace;\n+\n+/// [w](Clone\\(\\)) //~ERROR link\n+pub struct WLinkToCloneWithEscapedParens;\n+\n+/// [w](`Clone`) not URL-shaped enough\n+pub struct WLinkToCloneWithBackquotes;\n+\n+/// [w](Clone()) //~ERROR link\n+pub struct WLinkToCloneWithUnescapedParens;\n+\n+/// [w](Clone  ()) not URL-shaped enough\n+pub struct WLinkToCloneWithUnescapedParensAndDoubleSpace;\n+\n+/// [w](Clone  () //~ERROR unresolved link to `w`\n+pub struct WLinkToCloneWithUnmatchedOpenParenAndDoubleSpace;\n+\n+/// [w](Clone  \\() //~ERROR unresolved link to `w`\n+pub struct WLinkToCloneWithUnmatchedEscapedOpenParenAndDoubleSpace;\n+\n+/// [w](Clone  \\)) //~ERROR unresolved link to `w`\n+pub struct WLinkToCloneWithUnmatchedEscapedCloseParenAndDoubleSpace;\n+\n+// References\n+\n+/// The [cln][] link here is going to be unresolved, because `Clone()` gets rejected //~ERROR link\n+/// in Markdown for not being URL-shaped enough.\n+///\n+/// [cln]: Clone() //~ERROR link\n+pub struct LinkToCloneWithParensInReference;\n+\n+/// The [cln][] link here is going to be unresolved, because `struct@Clone` gets //~ERROR link\n+/// rejected in Markdown for not being URL-shaped enough.\n+///\n+/// [cln]: struct@Clone //~ERROR link\n+pub struct LinkToCloneWithWrongPrefix;\n+\n+/// The [cln][] link here will produce a plain text suggestion //~ERROR link\n+///\n+/// [cln]: Clone\\(\\)\n+pub struct LinkToCloneWithEscapedParensInReference;\n+\n+/// The [cln][] link here will produce a plain text suggestion //~ERROR link\n+///\n+/// [cln]: struct\\@Clone\n+pub struct LinkToCloneWithEscapedAtsInReference;"}, {"sha": "f50feb57fccf2729d043a5e69ba13f3fe0958398", "filename": "tests/rustdoc-ui/intra-doc/weird-syntax.stderr", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/30896536f3901c9bf78a437f8d58a8a137758529/tests%2Frustdoc-ui%2Fintra-doc%2Fweird-syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30896536f3901c9bf78a437f8d58a8a137758529/tests%2Frustdoc-ui%2Fintra-doc%2Fweird-syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fweird-syntax.stderr?ref=30896536f3901c9bf78a437f8d58a8a137758529", "patch": "@@ -0,0 +1,272 @@\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:18:7\n+   |\n+LL | /// [`struct@Clone`]\n+   |       ^^^^^^^^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+note: the lint level is defined here\n+  --> $DIR/weird-syntax.rs:3:9\n+   |\n+LL | #![deny(rustdoc::broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [`trait@Clone`]\n+   |       ~~~~~~\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:21:9\n+   |\n+LL | /// [```struct@Clone```]\n+   |         ^^^^^^^^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [```trait@Clone```]\n+   |         ~~~~~~\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:24:11\n+   |\n+LL | /// [  `  struct@Clone  `  ]\n+   |           ^^^^^^^^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [  `  trait@Clone  `  ]\n+   |           ~~~~~~\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:27:9\n+   |\n+LL | /// [  `Clone ()`  ]\n+   |         ^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [  `Clone ()`  ]\n+LL + /// [  `trait@Clone `  ]\n+   |\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:30:7\n+   |\n+LL | /// [`Clone ()`  ]\n+   |       ^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [`Clone ()`  ]\n+LL + /// [`trait@Clone `  ]\n+   |\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:33:9\n+   |\n+LL | /// [  `Clone ()`]\n+   |         ^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [  `Clone ()`]\n+LL + /// [  `trait@Clone `]\n+   |\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:36:9\n+   |\n+LL | /// [```Clone ()```]\n+   |         ^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [```Clone ()```]\n+LL + /// [```trait@Clone ```]\n+   |\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:42:13\n+   |\n+LL | /// [  ```  Clone ()  ```  ]\n+   |             ^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [  ```  Clone ()  ```  ]\n+LL + /// [  ```  trait@Clone   ```  ]\n+   |\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:62:10\n+   |\n+LL | /// [x][ struct@Clone]\n+   |          ^^^^^^^^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [x][ trait@Clone]\n+   |          ~~~~~~\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:65:9\n+   |\n+LL | /// [x][struct@Clone ]\n+   |         ^^^^^^^^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [x][trait@Clone ]\n+   |         ~~~~~~\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:74:9\n+   |\n+LL | /// [x][Clone()]\n+   |         ^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [x][Clone()]\n+LL + /// [x][trait@Clone]\n+   |\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:77:9\n+   |\n+LL | /// [x][Clone  ()]\n+   |         ^^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [x][Clone  ()]\n+LL + /// [x][trait@Clone  ]\n+   |\n+\n+error: unresolved link to `x`\n+  --> $DIR/weird-syntax.rs:80:6\n+   |\n+LL | /// [x][Clone  []\n+   |      ^ no item named `x` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:91:10\n+   |\n+LL | /// [w]( struct@Clone)\n+   |          ^^^^^^^^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [w]( trait@Clone)\n+   |          ~~~~~~\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:94:9\n+   |\n+LL | /// [w](struct@Clone )\n+   |         ^^^^^^^^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL | /// [w](trait@Clone )\n+   |         ~~~~~~\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:97:9\n+   |\n+LL | /// [w](Clone\\(\\))\n+   |         ^^^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [w](Clone\\(\\))\n+LL + /// [w](trait@Clone)\n+   |\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:103:9\n+   |\n+LL | /// [w](Clone())\n+   |         ^^^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+help: to link to the trait, prefix with `trait@`\n+   |\n+LL - /// [w](Clone())\n+LL + /// [w](trait@Clone)\n+   |\n+\n+error: unresolved link to `w`\n+  --> $DIR/weird-syntax.rs:109:6\n+   |\n+LL | /// [w](Clone  ()\n+   |      ^ no item named `w` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `w`\n+  --> $DIR/weird-syntax.rs:112:6\n+   |\n+LL | /// [w](Clone  \\()\n+   |      ^ no item named `w` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `w`\n+  --> $DIR/weird-syntax.rs:115:6\n+   |\n+LL | /// [w](Clone  \\))\n+   |      ^ no item named `w` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `cln`\n+  --> $DIR/weird-syntax.rs:120:10\n+   |\n+LL | /// The [cln][] link here is going to be unresolved, because `Clone()` gets rejected\n+   |          ^^^ no item named `cln` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `cln`\n+  --> $DIR/weird-syntax.rs:123:6\n+   |\n+LL | /// [cln]: Clone()\n+   |      ^^^ no item named `cln` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `cln`\n+  --> $DIR/weird-syntax.rs:126:10\n+   |\n+LL | /// The [cln][] link here is going to be unresolved, because `struct@Clone` gets\n+   |          ^^^ no item named `cln` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `cln`\n+  --> $DIR/weird-syntax.rs:129:6\n+   |\n+LL | /// [cln]: struct@Clone\n+   |      ^^^ no item named `cln` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: unresolved link to `Clone`\n+  --> $DIR/weird-syntax.rs:132:9\n+   |\n+LL | /// The [cln][] link here will produce a plain text suggestion\n+   |         ^^^^^ this link resolves to the trait `Clone`, which is not in the value namespace\n+   |\n+   = help: to link to the trait, prefix with `trait@`: trait@Clone\n+\n+error: incompatible link kind for `Clone`\n+  --> $DIR/weird-syntax.rs:137:9\n+   |\n+LL | /// The [cln][] link here will produce a plain text suggestion\n+   |         ^^^^^ this link resolved to a trait, which is not a struct\n+   |\n+   = help: to link to the trait, prefix with `trait@`: trait@Clone\n+\n+error: aborting due to 26 previous errors\n+"}]}