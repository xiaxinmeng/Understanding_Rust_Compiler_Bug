{"sha": "086c0dd33febb752b036fba62dcfb8aa22a51642", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4NmMwZGQzM2ZlYmI3NTJiMDM2ZmJhNjJkY2ZiOGFhMjJhNTE2NDI=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-02-08T00:36:59Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-02-08T06:31:52Z"}, "message": "Delete send_str, rewrite clients on top of MaybeOwned<'static>\n\nDeclare a `type SendStr = MaybeOwned<'static>` to ease readibility of\ntypes that needed the old SendStr behavior.\n\nImplement all the traits for MaybeOwned that SendStr used to implement.", "tree": {"sha": "2543a402c3d2ce04b4d7cd7e8c60da6c5fb40371", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2543a402c3d2ce04b4d7cd7e8c60da6c5fb40371"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/086c0dd33febb752b036fba62dcfb8aa22a51642", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/086c0dd33febb752b036fba62dcfb8aa22a51642", "html_url": "https://github.com/rust-lang/rust/commit/086c0dd33febb752b036fba62dcfb8aa22a51642", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/086c0dd33febb752b036fba62dcfb8aa22a51642/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "122c94d2f3909a06a5dd172b423b9b56a2f17039", "url": "https://api.github.com/repos/rust-lang/rust/commits/122c94d2f3909a06a5dd172b423b9b56a2f17039", "html_url": "https://github.com/rust-lang/rust/commit/122c94d2f3909a06a5dd172b423b9b56a2f17039"}], "stats": {"total": 701, "additions": 310, "deletions": 391}, "files": [{"sha": "9aa76cad83e27dbf0ab6315e1b92cff1696b72bd", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=086c0dd33febb752b036fba62dcfb8aa22a51642", "patch": "@@ -87,8 +87,7 @@ syn keyword rustTrait Primitive Int Float ToStrRadix ToPrimitive FromPrimitive\n syn keyword rustTrait GenericPath Path PosixPath WindowsPath\n syn keyword rustTrait RawPtr\n syn keyword rustTrait Buffer Writer Reader Seek\n-syn keyword rustTrait SendStr SendStrOwned SendStrStatic IntoSendStr\n-syn keyword rustTrait Str StrVector StrSlice OwnedStr\n+syn keyword rustTrait Str StrVector StrSlice OwnedStr IntoMaybeOwned\n syn keyword rustTrait IterBytes\n syn keyword rustTrait ToStr IntoStr\n syn keyword rustTrait CloneableTuple ImmutableTuple"}, {"sha": "2d52a59c8365a5dcff7b50cd7e020392c025b6c0", "filename": "src/libextra/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=086c0dd33febb752b036fba62dcfb8aa22a51642", "patch": "@@ -893,8 +893,8 @@ pub fn run_test(force_ignore: bool,\n         spawn(proc() {\n             let mut task = task::task();\n             task.name(match desc.name {\n-                DynTestName(ref name) => SendStrOwned(name.clone()),\n-                StaticTestName(name) => SendStrStatic(name),\n+                DynTestName(ref name) => name.to_owned().into_maybe_owned(),\n+                StaticTestName(name) => name.into_maybe_owned()\n             });\n             let result_future = task.future_result();\n             task.spawn(testfn);"}, {"sha": "c5b221d22724bbc555eabd675033fefaf2b8f242", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=086c0dd33febb752b036fba62dcfb8aa22a51642", "patch": "@@ -257,7 +257,7 @@ pub fn run(main: proc()) -> int {\n     let (port, chan) = Chan::new();\n     let mut opts = TaskOpts::new();\n     opts.notify_chan = Some(chan);\n-    opts.name = Some(SendStrStatic(\"<main>\"));\n+    opts.name = Some(\"<main>\".into_maybe_owned());\n     pool.spawn(opts, main);\n \n     // Wait for the main task to return, and set the process error code"}, {"sha": "e492acb4468fd143356839536103da474e33f576", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=086c0dd33febb752b036fba62dcfb8aa22a51642", "patch": "@@ -510,7 +510,7 @@ mod tests {\n     #[test]\n     fn smoke_opts() {\n         let mut opts = TaskOpts::new();\n-        opts.name = Some(SendStrStatic(\"test\"));\n+        opts.name = Some(\"test\".into_maybe_owned());\n         opts.stack_size = Some(20 * 4096);\n         let (p, c) = Chan::new();\n         opts.notify_chan = Some(c);"}, {"sha": "d0ca8364aa7d9a021741d7b2e199135de0418c8b", "filename": "src/libnative/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=086c0dd33febb752b036fba62dcfb8aa22a51642", "patch": "@@ -294,7 +294,7 @@ mod tests {\n     #[test]\n     fn smoke_opts() {\n         let mut opts = TaskOpts::new();\n-        opts.name = Some(SendStrStatic(\"test\"));\n+        opts.name = Some(\"test\".into_maybe_owned());\n         opts.stack_size = Some(20 * 4096);\n         let (p, c) = Chan::new();\n         opts.notify_chan = Some(c);"}, {"sha": "7b574d68e78004cc0fb9bd94272ccbd9d3d94bad", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=086c0dd33febb752b036fba62dcfb8aa22a51642", "patch": "@@ -117,7 +117,6 @@ pub mod vec_ng;\n pub mod str;\n \n pub mod ascii;\n-pub mod send_str;\n \n pub mod ptr;\n pub mod owned;"}, {"sha": "f113b2f17ebe6a74c2f70d412220ce2376e206bf", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=086c0dd33febb752b036fba62dcfb8aa22a51642", "patch": "@@ -63,8 +63,7 @@ pub use num::{Primitive, Int, Float, ToStrRadix, ToPrimitive, FromPrimitive};\n pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n pub use ptr::RawPtr;\n pub use io::{Buffer, Writer, Reader, Seek};\n-pub use send_str::{SendStr, SendStrOwned, SendStrStatic, IntoSendStr};\n-pub use str::{Str, StrVector, StrSlice, OwnedStr};\n+pub use str::{Str, StrVector, StrSlice, OwnedStr, IntoMaybeOwned};\n pub use to_bytes::IterBytes;\n pub use to_str::{ToStr, IntoStr};\n pub use tuple::{CloneableTuple, ImmutableTuple};"}, {"sha": "a7648dd2d19dffbc47da317da8d83fdeca3bd9d4", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=086c0dd33febb752b036fba62dcfb8aa22a51642", "patch": "@@ -30,7 +30,7 @@ use rt::local::Local;\n use rt::local_heap::LocalHeap;\n use rt::rtio::LocalIo;\n use rt::unwind::Unwinder;\n-use send_str::SendStr;\n+use str::SendStr;\n use sync::arc::UnsafeArc;\n use sync::atomics::{AtomicUint, SeqCst};\n use task::{TaskResult, TaskOpts};"}, {"sha": "b075b75b70acce849634e1f7895e2974a316ee55", "filename": "src/libstd/send_str.rs", "status": "removed", "additions": 0, "deletions": 246, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/122c94d2f3909a06a5dd172b423b9b56a2f17039/src%2Flibstd%2Fsend_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/122c94d2f3909a06a5dd172b423b9b56a2f17039/src%2Flibstd%2Fsend_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsend_str.rs?ref=122c94d2f3909a06a5dd172b423b9b56a2f17039", "patch": "@@ -1,246 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The `SendStr` trait for optionally static strings\n-\n-use clone::{Clone, DeepClone};\n-use cmp::{Eq, TotalEq, Ord, TotalOrd, Equiv};\n-use cmp::Ordering;\n-use container::Container;\n-use default::Default;\n-use str::{Str, StrSlice};\n-use to_str::ToStr;\n-use to_bytes::{IterBytes, Cb};\n-\n-/// A SendStr is a string that can hold either a ~str or a &'static str.\n-/// This can be useful as an optimization when an allocation is sometimes\n-/// needed but the common case is statically known.\n-#[allow(missing_doc)]\n-pub enum SendStr {\n-    SendStrOwned(~str),\n-    SendStrStatic(&'static str)\n-}\n-\n-impl SendStr {\n-    /// Returns `true` if this `SendStr` wraps an owned string\n-    #[inline]\n-    pub fn is_owned(&self) -> bool {\n-        match *self {\n-            SendStrOwned(_) => true,\n-            SendStrStatic(_) => false\n-        }\n-    }\n-\n-    /// Returns `true` if this `SendStr` wraps a static string\n-    #[inline]\n-    pub fn is_static(&self) -> bool {\n-        match *self {\n-            SendStrOwned(_) => false,\n-            SendStrStatic(_) => true\n-        }\n-    }\n-}\n-\n-/// Trait for moving into an `SendStr`\n-pub trait IntoSendStr {\n-    /// Moves self into an `SendStr`\n-    fn into_send_str(self) -> SendStr;\n-}\n-\n-impl IntoSendStr for ~str {\n-    #[inline]\n-    fn into_send_str(self) -> SendStr { SendStrOwned(self) }\n-}\n-\n-impl IntoSendStr for &'static str {\n-    #[inline]\n-    fn into_send_str(self) -> SendStr { SendStrStatic(self) }\n-}\n-\n-impl IntoSendStr for SendStr {\n-    #[inline]\n-    fn into_send_str(self) -> SendStr { self }\n-}\n-\n-/*\n-Section: String trait impls.\n-`SendStr` should behave like a normal string, so we don't derive.\n-*/\n-\n-impl ToStr for SendStr {\n-    #[inline]\n-    fn to_str(&self) -> ~str { self.as_slice().to_owned() }\n-}\n-\n-impl Eq for SendStr {\n-    #[inline]\n-    fn eq(&self, other: &SendStr) -> bool {\n-        self.as_slice().equals(&other.as_slice())\n-    }\n-}\n-\n-impl TotalEq for SendStr {\n-    #[inline]\n-    fn equals(&self, other: &SendStr) -> bool {\n-        self.as_slice().equals(&other.as_slice())\n-    }\n-}\n-\n-impl Ord for SendStr {\n-    #[inline]\n-    fn lt(&self, other: &SendStr) -> bool {\n-        self.as_slice().lt(&other.as_slice())\n-    }\n-}\n-\n-impl TotalOrd for SendStr {\n-    #[inline]\n-    fn cmp(&self, other: &SendStr) -> Ordering {\n-        self.as_slice().cmp(&other.as_slice())\n-    }\n-}\n-\n-impl<'a, S: Str> Equiv<S> for SendStr {\n-    #[inline]\n-    fn equiv(&self, other: &S) -> bool {\n-        self.as_slice().equals(&other.as_slice())\n-    }\n-}\n-\n-impl Str for SendStr {\n-    #[inline]\n-    fn as_slice<'r>(&'r self) -> &'r str {\n-        match *self {\n-            SendStrOwned(ref s) => s.as_slice(),\n-            // FIXME: Borrowchecker doesn't recognize lifetime as static unless prompted\n-            // SendStrStatic(s) => s.as_slice()\n-            SendStrStatic(s)    => {let tmp: &'static str = s; tmp}\n-        }\n-    }\n-\n-    #[inline]\n-    fn into_owned(self) -> ~str {\n-        match self {\n-            SendStrOwned(s)  => s,\n-            SendStrStatic(s) => s.to_owned()\n-        }\n-    }\n-}\n-\n-impl Container for SendStr {\n-    #[inline]\n-    fn len(&self) -> uint { self.as_slice().len() }\n-}\n-\n-impl Clone for SendStr {\n-    #[inline]\n-    fn clone(&self) -> SendStr {\n-        match *self {\n-            SendStrOwned(ref s) => SendStrOwned(s.to_owned()),\n-            SendStrStatic(s)    => SendStrStatic(s)\n-        }\n-    }\n-}\n-\n-impl DeepClone for SendStr {\n-    #[inline]\n-    fn deep_clone(&self) -> SendStr {\n-        match *self {\n-            SendStrOwned(ref s) => SendStrOwned(s.to_owned()),\n-            SendStrStatic(s)    => SendStrStatic(s)\n-        }\n-    }\n-}\n-\n-impl Default for SendStr {\n-    #[inline]\n-    fn default() -> SendStr { SendStrStatic(\"\") }\n-}\n-\n-impl IterBytes for SendStr {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        match *self {\n-            SendStrOwned(ref s) => s.iter_bytes(lsb0, f),\n-            SendStrStatic(s)    => s.iter_bytes(lsb0, f)\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use send_str::{SendStrOwned, SendStrStatic};\n-\n-    #[test]\n-    fn test_send_str_traits() {\n-        let s = SendStrStatic(\"abcde\");\n-        assert_eq!(s.len(), 5);\n-        assert_eq!(s.as_slice(), \"abcde\");\n-        assert_eq!(s.to_str(), ~\"abcde\");\n-        assert!(s.lt(&SendStrOwned(~\"bcdef\")));\n-        assert_eq!(SendStrStatic(\"\"), Default::default());\n-\n-        let o = SendStrOwned(~\"abcde\");\n-        assert_eq!(o.len(), 5);\n-        assert_eq!(o.as_slice(), \"abcde\");\n-        assert_eq!(o.to_str(), ~\"abcde\");\n-        assert!(o.lt(&SendStrStatic(\"bcdef\")));\n-        assert_eq!(SendStrOwned(~\"\"), Default::default());\n-\n-        assert_eq!(s.cmp(&o), Equal);\n-        assert!(s.equals(&o));\n-        assert!(s.equiv(&o));\n-\n-        assert_eq!(o.cmp(&s), Equal);\n-        assert!(o.equals(&s));\n-        assert!(o.equiv(&s));\n-    }\n-\n-    #[test]\n-    fn test_send_str_methods() {\n-        let s = SendStrStatic(\"abcde\");\n-        assert!(s.is_static());\n-        assert!(!s.is_owned());\n-\n-        let o = SendStrOwned(~\"abcde\");\n-        assert!(!o.is_static());\n-        assert!(o.is_owned());\n-    }\n-\n-    #[test]\n-    fn test_send_str_clone() {\n-        assert_eq!(SendStrOwned(~\"abcde\"), SendStrStatic(\"abcde\").clone());\n-        assert_eq!(SendStrOwned(~\"abcde\"), SendStrStatic(\"abcde\").deep_clone());\n-\n-        assert_eq!(SendStrOwned(~\"abcde\"), SendStrOwned(~\"abcde\").clone());\n-        assert_eq!(SendStrOwned(~\"abcde\"), SendStrOwned(~\"abcde\").deep_clone());\n-\n-        assert_eq!(SendStrStatic(\"abcde\"), SendStrStatic(\"abcde\").clone());\n-        assert_eq!(SendStrStatic(\"abcde\"), SendStrStatic(\"abcde\").deep_clone());\n-\n-        assert_eq!(SendStrStatic(\"abcde\"), SendStrOwned(~\"abcde\").clone());\n-        assert_eq!(SendStrStatic(\"abcde\"), SendStrOwned(~\"abcde\").deep_clone());\n-    }\n-\n-    #[test]\n-    fn test_send_str_into_owned() {\n-        assert_eq!(SendStrStatic(\"abcde\").into_owned(), ~\"abcde\");\n-        assert_eq!(SendStrOwned(~\"abcde\").into_owned(), ~\"abcde\");\n-    }\n-\n-    #[test]\n-    fn test_into_send_str() {\n-        assert_eq!(\"abcde\".into_send_str(), SendStrStatic(\"abcde\"));\n-        assert_eq!((~\"abcde\").into_send_str(), SendStrStatic(\"abcde\"));\n-        assert_eq!(\"abcde\".into_send_str(), SendStrOwned(~\"abcde\"));\n-        assert_eq!((~\"abcde\").into_send_str(), SendStrOwned(~\"abcde\"));\n-    }\n-}"}, {"sha": "3225bb3a6789c30f180627ea675c748ccadde76b", "filename": "src/libstd/str.rs", "status": "modified", "additions": 234, "deletions": 63, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=086c0dd33febb752b036fba62dcfb8aa22a51642", "patch": "@@ -86,7 +86,9 @@ use cast::transmute;\n use char;\n use char::Char;\n use clone::{Clone, DeepClone};\n+use cmp::{Eq, TotalEq, Ord, TotalOrd, Equiv, Ordering};\n use container::{Container, Mutable};\n+use fmt;\n use iter::{Iterator, FromIterator, Extendable, range};\n use iter::{Filter, AdditiveIterator, Map};\n use iter::{Rev, DoubleEndedIterator, ExactSize};\n@@ -100,7 +102,7 @@ use from_str::FromStr;\n use vec;\n use vec::{OwnedVector, OwnedCloneableVector, ImmutableVector, MutableVector};\n use default::Default;\n-use send_str::{SendStr, SendStrOwned};\n+use to_bytes::{IterBytes, Cb};\n use unstable::raw::Repr;\n \n /*\n@@ -915,53 +917,6 @@ macro_rules! utf8_acc_cont_byte(\n \n static TAG_CONT_U8: u8 = 128u8;\n \n-/// Enum that represents either a borrowed or an owned string.\n-#[deriving(Eq,Clone)]\n-pub enum MaybeOwned<'a> {\n-    /// A borrowed string\n-    Slice(&'a str),\n-    /// An owned string\n-    Owned(~str)\n-}\n-\n-impl<'a> Str for MaybeOwned<'a> {\n-    #[inline]\n-    fn as_slice<'b>(&'b self) -> &'b str {\n-        match *self {\n-            Slice(s) => s,\n-            Owned(ref s) => s.as_slice()\n-        }\n-    }\n-\n-    #[inline]\n-    fn into_owned(self) -> ~str {\n-        match self {\n-            Slice(s) => s.to_owned(),\n-            Owned(s) => s\n-        }\n-    }\n-}\n-\n-impl<'a> ToStr for MaybeOwned<'a> {\n-    #[inline]\n-    fn to_str(&self) -> ~str {\n-        match *self {\n-            Slice(s) => s.to_str(),\n-            Owned(ref s) => s.clone()\n-        }\n-    }\n-}\n-\n-impl<'a> ::fmt::Show for MaybeOwned<'a> {\n-    #[inline]\n-    fn fmt(mo: &MaybeOwned, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n-        match *mo {\n-            Slice(ref s) => ::fmt::Show::fmt(s, f),\n-            Owned(ref s) => ::fmt::Show::fmt(&s.as_slice(), f)\n-        }\n-    }\n-}\n-\n /// Converts a vector of bytes to a new utf-8 string.\n /// Any invalid utf-8 sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n ///\n@@ -1083,6 +1038,172 @@ pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n     Owned(res)\n }\n \n+/*\n+Section: MaybeOwned\n+*/\n+\n+/// A MaybeOwned is a string that can hold either a ~str or a &str.\n+/// This can be useful as an optimization when an allocation is sometimes\n+/// needed but not always.\n+pub enum MaybeOwned<'a> {\n+    /// A borrowed string\n+    Slice(&'a str),\n+    /// An owned string\n+    Owned(~str)\n+}\n+\n+/// SendStr is a specialization of `MaybeOwned` to be sendable\n+pub type SendStr = MaybeOwned<'static>;\n+\n+impl<'a> MaybeOwned<'a> {\n+    /// Returns `true` if this `MaybeOwned` wraps an owned string\n+    #[inline]\n+    pub fn is_owned(&self) -> bool {\n+        match *self {\n+            Slice(_) => false,\n+            Owned(_) => true\n+        }\n+    }\n+\n+    /// Returns `true` if this `MaybeOwned` wraps a borrowed string\n+    #[inline]\n+    pub fn is_slice(&self) -> bool {\n+        match *self {\n+            Slice(_) => true,\n+            Owned(_) => false\n+        }\n+    }\n+}\n+\n+/// Trait for moving into a `MaybeOwned`\n+pub trait IntoMaybeOwned<'a> {\n+    /// Moves self into a `MaybeOwned`\n+    fn into_maybe_owned(self) -> MaybeOwned<'a>;\n+}\n+\n+impl<'a> IntoMaybeOwned<'a> for ~str {\n+    #[inline]\n+    fn into_maybe_owned(self) -> MaybeOwned<'a> { Owned(self) }\n+}\n+\n+impl<'a> IntoMaybeOwned<'a> for &'a str {\n+    #[inline]\n+    fn into_maybe_owned(self) -> MaybeOwned<'a> { Slice(self) }\n+}\n+\n+impl<'a> IntoMaybeOwned<'a> for MaybeOwned<'a> {\n+    #[inline]\n+    fn into_maybe_owned(self) -> MaybeOwned<'a> { self }\n+}\n+\n+impl<'a> ToStr for MaybeOwned<'a> {\n+    #[inline]\n+    fn to_str(&self) -> ~str { self.as_slice().to_owned() }\n+}\n+\n+impl<'a> Eq for MaybeOwned<'a> {\n+    #[inline]\n+    fn eq(&self, other: &MaybeOwned) -> bool {\n+        self.as_slice().equals(&other.as_slice())\n+    }\n+}\n+\n+impl<'a> TotalEq for MaybeOwned<'a> {\n+    #[inline]\n+    fn equals(&self, other: &MaybeOwned) -> bool {\n+        self.as_slice().equals(&other.as_slice())\n+    }\n+}\n+\n+impl<'a> Ord for MaybeOwned<'a> {\n+    #[inline]\n+    fn lt(&self, other: &MaybeOwned) -> bool {\n+        self.as_slice().lt(&other.as_slice())\n+    }\n+}\n+\n+impl<'a> TotalOrd for MaybeOwned<'a> {\n+    #[inline]\n+    fn cmp(&self, other: &MaybeOwned) -> Ordering {\n+        self.as_slice().cmp(&other.as_slice())\n+    }\n+}\n+\n+impl<'a, S: Str> Equiv<S> for MaybeOwned<'a> {\n+    #[inline]\n+    fn equiv(&self, other: &S) -> bool {\n+        self.as_slice().equals(&other.as_slice())\n+    }\n+}\n+\n+impl<'a> Str for MaybeOwned<'a> {\n+    #[inline]\n+    fn as_slice<'b>(&'b self) -> &'b str {\n+        match *self {\n+            Slice(s) => s,\n+            Owned(ref s) => s.as_slice()\n+        }\n+    }\n+\n+    #[inline]\n+    fn into_owned(self) -> ~str {\n+        match self {\n+            Slice(s) => s.to_owned(),\n+            Owned(s) => s\n+        }\n+    }\n+}\n+\n+impl<'a> Container for MaybeOwned<'a> {\n+    #[inline]\n+    fn len(&self) -> uint { self.as_slice().len() }\n+}\n+\n+impl<'a> Clone for MaybeOwned<'a> {\n+    #[inline]\n+    fn clone(&self) -> MaybeOwned<'a> {\n+        match *self {\n+            Slice(s) => Slice(s),\n+            Owned(ref s) => Owned(s.to_owned())\n+        }\n+    }\n+}\n+\n+impl<'a> DeepClone for MaybeOwned<'a> {\n+    #[inline]\n+    fn deep_clone(&self) -> MaybeOwned<'a> {\n+        match *self {\n+            Slice(s) => Slice(s),\n+            Owned(ref s) => Owned(s.to_owned())\n+        }\n+    }\n+}\n+\n+impl<'a> Default for MaybeOwned<'a> {\n+    #[inline]\n+    fn default() -> MaybeOwned<'a> { Slice(\"\") }\n+}\n+\n+impl<'a> IterBytes for MaybeOwned<'a> {\n+    #[inline]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        match *self {\n+            Slice(s) => s.iter_bytes(lsb0, f),\n+            Owned(ref s) => s.iter_bytes(lsb0, f)\n+        }\n+    }\n+}\n+\n+impl<'a> fmt::Show for MaybeOwned<'a> {\n+    #[inline]\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Slice(ref s) => s.fmt(f),\n+            Owned(ref s) => s.fmt(f)\n+        }\n+    }\n+}\n+\n /// Unsafe operations\n pub mod raw {\n     use cast;\n@@ -1837,9 +1958,6 @@ pub trait StrSlice<'a> {\n     /// Converts to a vector of `u16` encoded as UTF-16.\n     fn to_utf16(&self) -> ~[u16];\n \n-    /// Copy a slice into a new `SendStr`.\n-    fn to_send_str(&self) -> SendStr;\n-\n     /// Check that `index`-th byte lies at the start and/or end of a\n     /// UTF-8 code point sequence.\n     ///\n@@ -2364,11 +2482,6 @@ impl<'a> StrSlice<'a> for &'a str {\n         u\n     }\n \n-    #[inline]\n-    fn to_send_str(&self) -> SendStr {\n-        SendStrOwned(self.to_owned())\n-    }\n-\n     #[inline]\n     fn is_char_boundary(&self, index: uint) -> bool {\n         if index == self.len() { return true; }\n@@ -2808,7 +2921,6 @@ mod tests {\n     use prelude::*;\n     use ptr;\n     use str::*;\n-    use send_str::{SendStrOwned, SendStrStatic};\n \n     #[test]\n     fn test_eq() {\n@@ -4038,17 +4150,76 @@ mod tests {\n         assert_eq!(from_utf8_lossy(xs), Owned(~\"\\uFFFD\\uFFFD\\uFFFDfoo\\uFFFD\\uFFFD\\uFFFDbar\"));\n     }\n \n-    #[test]\n-    fn test_to_send_str() {\n-        assert_eq!(\"abcde\".to_send_str(), SendStrStatic(\"abcde\"));\n-        assert_eq!(\"abcde\".to_send_str(), SendStrOwned(~\"abcde\"));\n-    }\n-\n     #[test]\n     fn test_from_str() {\n       let owned: Option<~str> = from_str(&\"string\");\n       assert_eq!(owned, Some(~\"string\"));\n     }\n+\n+    #[test]\n+    fn test_maybe_owned_traits() {\n+        let s = Slice(\"abcde\");\n+        assert_eq!(s.len(), 5);\n+        assert_eq!(s.as_slice(), \"abcde\");\n+        assert_eq!(s.to_str(), ~\"abcde\");\n+        assert!(s.lt(&Owned(~\"bcdef\")));\n+        assert_eq!(Slice(\"\"), Default::default());\n+\n+        let o = Owned(~\"abcde\");\n+        assert_eq!(o.len(), 5);\n+        assert_eq!(o.as_slice(), \"abcde\");\n+        assert_eq!(o.to_str(), ~\"abcde\");\n+        assert!(o.lt(&Slice(\"bcdef\")));\n+        assert_eq!(Owned(~\"\"), Default::default());\n+\n+        assert_eq!(s.cmp(&o), Equal);\n+        assert!(s.equals(&o));\n+        assert!(s.equiv(&o));\n+\n+        assert_eq!(o.cmp(&s), Equal);\n+        assert!(o.equals(&s));\n+        assert!(o.equiv(&s));\n+    }\n+\n+    #[test]\n+    fn test_maybe_owned_methods() {\n+        let s = Slice(\"abcde\");\n+        assert!(s.is_slice());\n+        assert!(!s.is_owned());\n+\n+        let o = Owned(~\"abcde\");\n+        assert!(!o.is_slice());\n+        assert!(o.is_owned());\n+    }\n+\n+    #[test]\n+    fn test_maybe_owned_clone() {\n+        assert_eq!(Owned(~\"abcde\"), Slice(\"abcde\").clone());\n+        assert_eq!(Owned(~\"abcde\"), Slice(\"abcde\").deep_clone());\n+\n+        assert_eq!(Owned(~\"abcde\"), Owned(~\"abcde\").clone());\n+        assert_eq!(Owned(~\"abcde\"), Owned(~\"abcde\").deep_clone());\n+\n+        assert_eq!(Slice(\"abcde\"), Slice(\"abcde\").clone());\n+        assert_eq!(Slice(\"abcde\"), Slice(\"abcde\").deep_clone());\n+\n+        assert_eq!(Slice(\"abcde\"), Owned(~\"abcde\").clone());\n+        assert_eq!(Slice(\"abcde\"), Owned(~\"abcde\").deep_clone());\n+    }\n+\n+    #[test]\n+    fn test_maybe_owned_into_owned() {\n+        assert_eq!(Slice(\"abcde\").into_owned(), ~\"abcde\");\n+        assert_eq!(Owned(~\"abcde\").into_owned(), ~\"abcde\");\n+    }\n+\n+    #[test]\n+    fn test_into_maybe_owned() {\n+        assert_eq!(\"abcde\".into_maybe_owned(), Slice(\"abcde\"));\n+        assert_eq!((~\"abcde\").into_maybe_owned(), Slice(\"abcde\"));\n+        assert_eq!(\"abcde\".into_maybe_owned(), Owned(~\"abcde\"));\n+        assert_eq!((~\"abcde\").into_maybe_owned(), Owned(~\"abcde\"));\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "921d0feaa8b195e65bf58dffd95f2f18b9b1e2af", "filename": "src/libstd/task.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=086c0dd33febb752b036fba62dcfb8aa22a51642", "patch": "@@ -62,8 +62,7 @@ use option::{None, Some, Option};\n use result::{Result, Ok, Err};\n use rt::local::Local;\n use rt::task::Task;\n-use send_str::{SendStr, IntoSendStr};\n-use str::Str;\n+use str::{Str, SendStr, IntoMaybeOwned};\n \n #[cfg(test)] use any::{AnyOwnExt, AnyRefExt};\n #[cfg(test)] use comm::SharedChan;\n@@ -190,8 +189,8 @@ impl TaskBuilder {\n \n     /// Name the task-to-be. Currently the name is used for identification\n     /// only in failure messages.\n-    pub fn name<S: IntoSendStr>(&mut self, name: S) {\n-        self.opts.name = Some(name.into_send_str());\n+    pub fn name<S: IntoMaybeOwned<'static>>(&mut self, name: S) {\n+        self.opts.name = Some(name.into_maybe_owned());\n     }\n \n     /**\n@@ -396,7 +395,7 @@ fn test_static_named_task() {\n #[test]\n fn test_send_named_task() {\n     let mut t = task();\n-    t.name(\"ada lovelace\".into_send_str());\n+    t.name(\"ada lovelace\".into_maybe_owned());\n     t.spawn(proc() {\n         with_task_name(|name| {\n             assert!(name.unwrap() == \"ada lovelace\");"}, {"sha": "ea530fe9f69d2019af64317fcf052e3a8087e42d", "filename": "src/test/run-fail/fail-task-name-send-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Ftest%2Frun-fail%2Ffail-task-name-send-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Ftest%2Frun-fail%2Ffail-task-name-send-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-task-name-send-str.rs?ref=086c0dd33febb752b036fba62dcfb8aa22a51642", "patch": "@@ -12,7 +12,7 @@\n \n fn main() {\n     let mut t = ::std::task::task();\n-    t.name(\"send name\".to_send_str());\n+    t.name(\"send name\".into_maybe_owned());\n     t.try(proc() {\n         fail!(\"test\");\n         3"}, {"sha": "8599f9d383605504f99d8a482b64823435662971", "filename": "src/test/run-pass/send_str_hashmap.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs?ref=086c0dd33febb752b036fba62dcfb8aa22a51642", "patch": "@@ -13,45 +13,44 @@ use std::cmp::{TotalEq, Ord, TotalOrd, Equiv};\n use std::cmp::Equal;\n use std::container::{Container, Map, MutableMap};\n use std::default::Default;\n-use std::send_str::{SendStr, SendStrOwned, SendStrStatic};\n-use std::str::Str;\n+use std::str::{Str, SendStr, Owned, Slice};\n use std::to_str::ToStr;\n use std::hashmap::HashMap;\n use std::option::Some;\n \n pub fn main() {\n     let mut map: HashMap<SendStr, uint> = HashMap::new();\n-    assert!(map.insert(SendStrStatic(\"foo\"), 42));\n-    assert!(!map.insert(SendStrOwned(~\"foo\"), 42));\n-    assert!(!map.insert(SendStrStatic(\"foo\"), 42));\n-    assert!(!map.insert(SendStrOwned(~\"foo\"), 42));\n+    assert!(map.insert(Slice(\"foo\"), 42));\n+    assert!(!map.insert(Owned(~\"foo\"), 42));\n+    assert!(!map.insert(Slice(\"foo\"), 42));\n+    assert!(!map.insert(Owned(~\"foo\"), 42));\n \n-    assert!(!map.insert(SendStrStatic(\"foo\"), 43));\n-    assert!(!map.insert(SendStrOwned(~\"foo\"), 44));\n-    assert!(!map.insert(SendStrStatic(\"foo\"), 45));\n-    assert!(!map.insert(SendStrOwned(~\"foo\"), 46));\n+    assert!(!map.insert(Slice(\"foo\"), 43));\n+    assert!(!map.insert(Owned(~\"foo\"), 44));\n+    assert!(!map.insert(Slice(\"foo\"), 45));\n+    assert!(!map.insert(Owned(~\"foo\"), 46));\n \n     let v = 46;\n \n-    assert_eq!(map.find(&SendStrOwned(~\"foo\")), Some(&v));\n-    assert_eq!(map.find(&SendStrStatic(\"foo\")), Some(&v));\n+    assert_eq!(map.find(&Owned(~\"foo\")), Some(&v));\n+    assert_eq!(map.find(&Slice(\"foo\")), Some(&v));\n \n     let (a, b, c, d) = (50, 51, 52, 53);\n \n-    assert!(map.insert(SendStrStatic(\"abc\"), a));\n-    assert!(map.insert(SendStrOwned(~\"bcd\"), b));\n-    assert!(map.insert(SendStrStatic(\"cde\"), c));\n-    assert!(map.insert(SendStrOwned(~\"def\"), d));\n+    assert!(map.insert(Slice(\"abc\"), a));\n+    assert!(map.insert(Owned(~\"bcd\"), b));\n+    assert!(map.insert(Slice(\"cde\"), c));\n+    assert!(map.insert(Owned(~\"def\"), d));\n \n-    assert!(!map.insert(SendStrStatic(\"abc\"), a));\n-    assert!(!map.insert(SendStrOwned(~\"bcd\"), b));\n-    assert!(!map.insert(SendStrStatic(\"cde\"), c));\n-    assert!(!map.insert(SendStrOwned(~\"def\"), d));\n+    assert!(!map.insert(Slice(\"abc\"), a));\n+    assert!(!map.insert(Owned(~\"bcd\"), b));\n+    assert!(!map.insert(Slice(\"cde\"), c));\n+    assert!(!map.insert(Owned(~\"def\"), d));\n \n-    assert!(!map.insert(SendStrOwned(~\"abc\"), a));\n-    assert!(!map.insert(SendStrStatic(\"bcd\"), b));\n-    assert!(!map.insert(SendStrOwned(~\"cde\"), c));\n-    assert!(!map.insert(SendStrStatic(\"def\"), d));\n+    assert!(!map.insert(Owned(~\"abc\"), a));\n+    assert!(!map.insert(Slice(\"bcd\"), b));\n+    assert!(!map.insert(Owned(~\"cde\"), c));\n+    assert!(!map.insert(Slice(\"def\"), d));\n \n     assert_eq!(map.find_equiv(&(\"abc\")), Some(&a));\n     assert_eq!(map.find_equiv(&(\"bcd\")), Some(&b));\n@@ -63,13 +62,13 @@ pub fn main() {\n     assert_eq!(map.find_equiv(&(~\"cde\")), Some(&c));\n     assert_eq!(map.find_equiv(&(~\"def\")), Some(&d));\n \n-    assert_eq!(map.find_equiv(&SendStrStatic(\"abc\")), Some(&a));\n-    assert_eq!(map.find_equiv(&SendStrStatic(\"bcd\")), Some(&b));\n-    assert_eq!(map.find_equiv(&SendStrStatic(\"cde\")), Some(&c));\n-    assert_eq!(map.find_equiv(&SendStrStatic(\"def\")), Some(&d));\n+    assert_eq!(map.find_equiv(&Slice(\"abc\")), Some(&a));\n+    assert_eq!(map.find_equiv(&Slice(\"bcd\")), Some(&b));\n+    assert_eq!(map.find_equiv(&Slice(\"cde\")), Some(&c));\n+    assert_eq!(map.find_equiv(&Slice(\"def\")), Some(&d));\n \n-    assert_eq!(map.find_equiv(&SendStrOwned(~\"abc\")), Some(&a));\n-    assert_eq!(map.find_equiv(&SendStrOwned(~\"bcd\")), Some(&b));\n-    assert_eq!(map.find_equiv(&SendStrOwned(~\"cde\")), Some(&c));\n-    assert_eq!(map.find_equiv(&SendStrOwned(~\"def\")), Some(&d));\n+    assert_eq!(map.find_equiv(&Owned(~\"abc\")), Some(&a));\n+    assert_eq!(map.find_equiv(&Owned(~\"bcd\")), Some(&b));\n+    assert_eq!(map.find_equiv(&Owned(~\"cde\")), Some(&c));\n+    assert_eq!(map.find_equiv(&Owned(~\"def\")), Some(&d));\n }"}, {"sha": "1b7d7bf0b4b570d51f81e9b0973eab844545f4c6", "filename": "src/test/run-pass/send_str_treemap.rs", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086c0dd33febb752b036fba62dcfb8aa22a51642/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs?ref=086c0dd33febb752b036fba62dcfb8aa22a51642", "patch": "@@ -15,57 +15,56 @@ use std::cmp::{TotalEq, Ord, TotalOrd, Equiv};\n use std::cmp::Equal;\n use std::container::{Container, Map, MutableMap};\n use std::default::Default;\n-use std::send_str::{SendStr, SendStrOwned, SendStrStatic};\n-use std::str::Str;\n+use std::str::{Str, SendStr, Owned, Slice};\n use std::to_str::ToStr;\n use self::collections::TreeMap;\n use std::option::Some;\n \n pub fn main() {\n     let mut map: TreeMap<SendStr, uint> = TreeMap::new();\n-    assert!(map.insert(SendStrStatic(\"foo\"), 42));\n-    assert!(!map.insert(SendStrOwned(~\"foo\"), 42));\n-    assert!(!map.insert(SendStrStatic(\"foo\"), 42));\n-    assert!(!map.insert(SendStrOwned(~\"foo\"), 42));\n+    assert!(map.insert(Slice(\"foo\"), 42));\n+    assert!(!map.insert(Owned(~\"foo\"), 42));\n+    assert!(!map.insert(Slice(\"foo\"), 42));\n+    assert!(!map.insert(Owned(~\"foo\"), 42));\n \n-    assert!(!map.insert(SendStrStatic(\"foo\"), 43));\n-    assert!(!map.insert(SendStrOwned(~\"foo\"), 44));\n-    assert!(!map.insert(SendStrStatic(\"foo\"), 45));\n-    assert!(!map.insert(SendStrOwned(~\"foo\"), 46));\n+    assert!(!map.insert(Slice(\"foo\"), 43));\n+    assert!(!map.insert(Owned(~\"foo\"), 44));\n+    assert!(!map.insert(Slice(\"foo\"), 45));\n+    assert!(!map.insert(Owned(~\"foo\"), 46));\n \n     let v = 46;\n \n-    assert_eq!(map.find(&SendStrOwned(~\"foo\")), Some(&v));\n-    assert_eq!(map.find(&SendStrStatic(\"foo\")), Some(&v));\n+    assert_eq!(map.find(&Owned(~\"foo\")), Some(&v));\n+    assert_eq!(map.find(&Slice(\"foo\")), Some(&v));\n \n     let (a, b, c, d) = (50, 51, 52, 53);\n \n-    assert!(map.insert(SendStrStatic(\"abc\"), a));\n-    assert!(map.insert(SendStrOwned(~\"bcd\"), b));\n-    assert!(map.insert(SendStrStatic(\"cde\"), c));\n-    assert!(map.insert(SendStrOwned(~\"def\"), d));\n+    assert!(map.insert(Slice(\"abc\"), a));\n+    assert!(map.insert(Owned(~\"bcd\"), b));\n+    assert!(map.insert(Slice(\"cde\"), c));\n+    assert!(map.insert(Owned(~\"def\"), d));\n \n-    assert!(!map.insert(SendStrStatic(\"abc\"), a));\n-    assert!(!map.insert(SendStrOwned(~\"bcd\"), b));\n-    assert!(!map.insert(SendStrStatic(\"cde\"), c));\n-    assert!(!map.insert(SendStrOwned(~\"def\"), d));\n+    assert!(!map.insert(Slice(\"abc\"), a));\n+    assert!(!map.insert(Owned(~\"bcd\"), b));\n+    assert!(!map.insert(Slice(\"cde\"), c));\n+    assert!(!map.insert(Owned(~\"def\"), d));\n \n-    assert!(!map.insert(SendStrOwned(~\"abc\"), a));\n-    assert!(!map.insert(SendStrStatic(\"bcd\"), b));\n-    assert!(!map.insert(SendStrOwned(~\"cde\"), c));\n-    assert!(!map.insert(SendStrStatic(\"def\"), d));\n+    assert!(!map.insert(Owned(~\"abc\"), a));\n+    assert!(!map.insert(Slice(\"bcd\"), b));\n+    assert!(!map.insert(Owned(~\"cde\"), c));\n+    assert!(!map.insert(Slice(\"def\"), d));\n \n-    assert_eq!(map.find(&SendStrStatic(\"abc\")), Some(&a));\n-    assert_eq!(map.find(&SendStrStatic(\"bcd\")), Some(&b));\n-    assert_eq!(map.find(&SendStrStatic(\"cde\")), Some(&c));\n-    assert_eq!(map.find(&SendStrStatic(\"def\")), Some(&d));\n+    assert_eq!(map.find(&Slice(\"abc\")), Some(&a));\n+    assert_eq!(map.find(&Slice(\"bcd\")), Some(&b));\n+    assert_eq!(map.find(&Slice(\"cde\")), Some(&c));\n+    assert_eq!(map.find(&Slice(\"def\")), Some(&d));\n \n-    assert_eq!(map.find(&SendStrOwned(~\"abc\")), Some(&a));\n-    assert_eq!(map.find(&SendStrOwned(~\"bcd\")), Some(&b));\n-    assert_eq!(map.find(&SendStrOwned(~\"cde\")), Some(&c));\n-    assert_eq!(map.find(&SendStrOwned(~\"def\")), Some(&d));\n+    assert_eq!(map.find(&Owned(~\"abc\")), Some(&a));\n+    assert_eq!(map.find(&Owned(~\"bcd\")), Some(&b));\n+    assert_eq!(map.find(&Owned(~\"cde\")), Some(&c));\n+    assert_eq!(map.find(&Owned(~\"def\")), Some(&d));\n \n-    assert!(map.pop(&SendStrStatic(\"foo\")).is_some());\n+    assert!(map.pop(&Slice(\"foo\")).is_some());\n     assert_eq!(map.move_iter().map(|(k, v)| k.to_str() + v.to_str())\n                               .to_owned_vec()\n                               .concat(),"}]}