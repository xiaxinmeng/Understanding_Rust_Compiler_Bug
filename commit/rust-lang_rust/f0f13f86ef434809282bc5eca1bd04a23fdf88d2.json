{"sha": "f0f13f86ef434809282bc5eca1bd04a23fdf88d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwZjEzZjg2ZWY0MzQ4MDkyODJiYzVlY2ExYmQwNGEyM2ZkZjg4ZDI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-05-11T21:02:56Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-06-15T21:31:27Z"}, "message": "Rather than expanding the where-clauses in the environment over and over\nagain, do it once and then just remember the expanded form. At the same\ntime, filter globally nameable predicates out of the environment, since\nthey can cause cache errors (and they are not necessary in any case).", "tree": {"sha": "15f80f5fc18a3b1f924d84a2af87dd4bcbab51c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15f80f5fc18a3b1f924d84a2af87dd4bcbab51c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0f13f86ef434809282bc5eca1bd04a23fdf88d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0f13f86ef434809282bc5eca1bd04a23fdf88d2", "html_url": "https://github.com/rust-lang/rust/commit/f0f13f86ef434809282bc5eca1bd04a23fdf88d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0f13f86ef434809282bc5eca1bd04a23fdf88d2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff89fcf83b41c2759d69c01d5e41b9043f5acff8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff89fcf83b41c2759d69c01d5e41b9043f5acff8", "html_url": "https://github.com/rust-lang/rust/commit/ff89fcf83b41c2759d69c01d5e41b9043f5acff8"}], "stats": {"total": 102, "additions": 79, "deletions": 23}, "files": [{"sha": "50536f586e7a8579c95c120def5793badf11184e", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f0f13f86ef434809282bc5eca1bd04a23fdf88d2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f13f86ef434809282bc5eca1bd04a23fdf88d2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=f0f13f86ef434809282bc5eca1bd04a23fdf88d2", "patch": "@@ -414,9 +414,27 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n     debug!(\"normalize_param_env_or_error(unnormalized_env={})\",\n            unnormalized_env.repr(tcx));\n \n+    let predicates: Vec<_> =\n+        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.clone())\n+        .filter(|p| !p.is_global()) // (*)\n+        .collect();\n+\n+    // (*) Any predicate like `i32: Trait<u32>` or whatever doesn't\n+    // need to be in the *environment* to be proven, so screen those\n+    // out. This is important for the soundness of inter-fn\n+    // caching. Note though that we should probably check that these\n+    // predicates hold at the point where the environment is\n+    // constructed, but I am not currently doing so out of laziness.\n+    // -nmatsakis\n+\n+    debug!(\"normalize_param_env_or_error: elaborated-predicates={}\",\n+           predicates.repr(tcx));\n+\n+    let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n+\n     let infcx = infer::new_infer_ctxt(tcx);\n-    let predicates = match fully_normalize(&infcx, &unnormalized_env, cause,\n-                                           &unnormalized_env.caller_bounds) {\n+    let predicates = match fully_normalize(&infcx, &elaborated_env, cause,\n+                                           &elaborated_env.caller_bounds) {\n         Ok(predicates) => predicates,\n         Err(errors) => {\n             report_fulfillment_errors(&infcx, &errors);\n@@ -438,14 +456,11 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n             // all things considered.\n             let err_msg = fixup_err_to_string(fixup_err);\n             tcx.sess.span_err(span, &err_msg);\n-            return unnormalized_env; // an unnormalized env is better than nothing\n+            return elaborated_env; // an unnormalized env is better than nothing\n         }\n     };\n \n-    debug!(\"normalize_param_env_or_error: predicates={}\",\n-           predicates.repr(tcx));\n-\n-    unnormalized_env.with_caller_bounds(predicates)\n+    elaborated_env.with_caller_bounds(predicates)\n }\n \n pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,"}, {"sha": "6a9ed1a8cf99ea448d4a0f58a3fd0fccf2a89c13", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f0f13f86ef434809282bc5eca1bd04a23fdf88d2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f13f86ef434809282bc5eca1bd04a23fdf88d2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=f0f13f86ef434809282bc5eca1bd04a23fdf88d2", "patch": "@@ -531,7 +531,7 @@ fn assemble_candidates_from_param_env<'cx,'tcx>(\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n {\n-    let env_predicates = selcx.param_env().caller_bounds.clone();\n+    let env_predicates = selcx.param_env().caller_bounds.iter().cloned();\n     assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n                                         candidate_set, env_predicates);\n }\n@@ -567,22 +567,25 @@ fn assemble_candidates_from_trait_def<'cx,'tcx>(\n     // If so, extract what we know from the trait and try to come up with a good answer.\n     let trait_predicates = ty::lookup_predicates(selcx.tcx(), trait_ref.def_id);\n     let bounds = trait_predicates.instantiate(selcx.tcx(), trait_ref.substs);\n+    let bounds = elaborate_predicates(selcx.tcx(), bounds.predicates.into_vec());\n     assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n-                                        candidate_set, bounds.predicates.into_vec());\n+                                        candidate_set, bounds)\n }\n \n-fn assemble_candidates_from_predicates<'cx,'tcx>(\n+fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n-    env_predicates: Vec<ty::Predicate<'tcx>>)\n+    env_predicates: I)\n+    where I: Iterator<Item=ty::Predicate<'tcx>>\n {\n-    debug!(\"assemble_candidates_from_predicates(obligation={}, env_predicates={})\",\n-           obligation.repr(selcx.tcx()),\n-           env_predicates.repr(selcx.tcx()));\n+    debug!(\"assemble_candidates_from_predicates(obligation={})\",\n+           obligation.repr(selcx.tcx()));\n     let infcx = selcx.infcx();\n-    for predicate in elaborate_predicates(selcx.tcx(), env_predicates) {\n+    for predicate in env_predicates {\n+        debug!(\"assemble_candidates_from_predicates: predicate={}\",\n+               predicate.repr(selcx.tcx()));\n         match predicate {\n             ty::Predicate::Projection(ref data) => {\n                 let same_name = data.item_name() == obligation.predicate.item_name;\n@@ -637,6 +640,7 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n     let env_predicates = projection_bounds.iter()\n                                           .map(|p| p.as_predicate())\n                                           .collect();\n+    let env_predicates = elaborate_predicates(selcx.tcx(), env_predicates);\n     assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n                                         candidate_set, env_predicates)\n }"}, {"sha": "211839fbd25f99f242fc1d12f00841e9eb6f0a68", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f0f13f86ef434809282bc5eca1bd04a23fdf88d2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f13f86ef434809282bc5eca1bd04a23fdf88d2/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=f0f13f86ef434809282bc5eca1bd04a23fdf88d2", "patch": "@@ -1083,14 +1083,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"assemble_candidates_from_caller_bounds({})\",\n                stack.obligation.repr(self.tcx()));\n \n-        let caller_trait_refs: Vec<_> =\n-            self.param_env().caller_bounds.iter()\n-            .filter_map(|o| o.to_opt_poly_trait_ref())\n-            .collect();\n-\n         let all_bounds =\n-            util::transitive_bounds(\n-                self.tcx(), &caller_trait_refs[..]);\n+            self.param_env().caller_bounds\n+                            .iter()\n+                            .filter_map(|o| o.to_opt_poly_trait_ref());\n \n         let matching_bounds =\n             all_bounds.filter("}, {"sha": "62682e1a6fb848006f747070b54ebc9c6cc7110f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0f13f86ef434809282bc5eca1bd04a23fdf88d2/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f13f86ef434809282bc5eca1bd04a23fdf88d2/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f0f13f86ef434809282bc5eca1bd04a23fdf88d2", "patch": "@@ -2371,7 +2371,7 @@ pub struct ParameterEnvironment<'a, 'tcx:'a> {\n \n     /// Obligations that the caller must satisfy. This is basically\n     /// the set of bounds on the in-scope type parameters, translated\n-    /// into Obligations.\n+    /// into Obligations, and elaborated and normalized.\n     pub caller_bounds: Vec<ty::Predicate<'tcx>>,\n \n     /// Caches the results of trait selection. This cache is used"}, {"sha": "0aefd0ae28845f1474dc87000d06af4886e1e2e5", "filename": "src/test/compile-fail/cross-fn-cache-hole.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f0f13f86ef434809282bc5eca1bd04a23fdf88d2/src%2Ftest%2Fcompile-fail%2Fcross-fn-cache-hole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0f13f86ef434809282bc5eca1bd04a23fdf88d2/src%2Ftest%2Fcompile-fail%2Fcross-fn-cache-hole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcross-fn-cache-hole.rs?ref=f0f13f86ef434809282bc5eca1bd04a23fdf88d2", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that when there are vacuous predicates in the environment\n+// (which make a fn uncallable) we don't erroneously cache those and\n+// then consider them satisfied elsewhere. The current technique for\n+// doing this is just to filter \"global\" predicates out of the\n+// environment, which means that we wind up with an error in the\n+// function `vacuous`, because even though `i32: Bar<u32>` is implied\n+// by its where clause, that where clause never holds.\n+\n+trait Foo<X,Y>: Bar<X> {\n+}\n+\n+trait Bar<X> { }\n+\n+fn vacuous<A>()\n+    where i32: Foo<u32, A>\n+{\n+    // vacuous could never be called, because it requires that i32:\n+    // Bar<u32>. But the code doesn't check that this could never be\n+    // satisfied.\n+    require::<i32, u32>();\n+    //~^ ERROR the trait `Bar<u32>` is not implemented for the type `i32`\n+}\n+\n+fn require<A,B>()\n+    where A: Bar<B>\n+{\n+}\n+\n+fn main() {\n+    require::<i32, u32>();\n+}"}]}