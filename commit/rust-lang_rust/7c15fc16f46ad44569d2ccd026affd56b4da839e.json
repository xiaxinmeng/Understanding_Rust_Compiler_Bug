{"sha": "7c15fc16f46ad44569d2ccd026affd56b4da839e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjMTVmYzE2ZjQ2YWQ0NDU2OWQyY2NkMDI2YWZmZDU2YjRkYTgzOWU=", "commit": {"author": {"name": "Roxane", "email": "roxane.fruytier@hotmail.com", "date": "2021-07-03T19:29:09Z"}, "committer": {"name": "Roxane", "email": "roxane.fruytier@hotmail.com", "date": "2021-07-08T21:07:53Z"}, "message": "Consider capture kind for auto traits migration", "tree": {"sha": "15ab73ae99b3b8f54764cdf24747dc5ce6afb1e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15ab73ae99b3b8f54764cdf24747dc5ce6afb1e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c15fc16f46ad44569d2ccd026affd56b4da839e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c15fc16f46ad44569d2ccd026affd56b4da839e", "html_url": "https://github.com/rust-lang/rust/commit/7c15fc16f46ad44569d2ccd026affd56b4da839e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c15fc16f46ad44569d2ccd026affd56b4da839e/comments", "author": {"login": "roxelo", "id": 12419401, "node_id": "MDQ6VXNlcjEyNDE5NDAx", "avatar_url": "https://avatars.githubusercontent.com/u/12419401?v=4", "gravatar_id": "", "url": "https://api.github.com/users/roxelo", "html_url": "https://github.com/roxelo", "followers_url": "https://api.github.com/users/roxelo/followers", "following_url": "https://api.github.com/users/roxelo/following{/other_user}", "gists_url": "https://api.github.com/users/roxelo/gists{/gist_id}", "starred_url": "https://api.github.com/users/roxelo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/roxelo/subscriptions", "organizations_url": "https://api.github.com/users/roxelo/orgs", "repos_url": "https://api.github.com/users/roxelo/repos", "events_url": "https://api.github.com/users/roxelo/events{/privacy}", "received_events_url": "https://api.github.com/users/roxelo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "roxelo", "id": 12419401, "node_id": "MDQ6VXNlcjEyNDE5NDAx", "avatar_url": "https://avatars.githubusercontent.com/u/12419401?v=4", "gravatar_id": "", "url": "https://api.github.com/users/roxelo", "html_url": "https://github.com/roxelo", "followers_url": "https://api.github.com/users/roxelo/followers", "following_url": "https://api.github.com/users/roxelo/following{/other_user}", "gists_url": "https://api.github.com/users/roxelo/gists{/gist_id}", "starred_url": "https://api.github.com/users/roxelo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/roxelo/subscriptions", "organizations_url": "https://api.github.com/users/roxelo/orgs", "repos_url": "https://api.github.com/users/roxelo/repos", "events_url": "https://api.github.com/users/roxelo/events{/privacy}", "received_events_url": "https://api.github.com/users/roxelo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5e8a7d3982ab6d3a1ec0eeea489bc898073787c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5e8a7d3982ab6d3a1ec0eeea489bc898073787c", "html_url": "https://github.com/rust-lang/rust/commit/f5e8a7d3982ab6d3a1ec0eeea489bc898073787c"}], "stats": {"total": 60, "additions": 47, "deletions": 13}, "files": [{"sha": "c93cc39114460f670e9a8f6215501252098b918e", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 46, "deletions": 12, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7c15fc16f46ad44569d2ccd026affd56b4da839e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c15fc16f46ad44569d2ccd026affd56b4da839e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=7c15fc16f46ad44569d2ccd026affd56b4da839e", "patch": "@@ -42,7 +42,9 @@ use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::UpvarRegion;\n use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, Projection, ProjectionKind};\n use rustc_middle::mir::FakeReadCause;\n-use rustc_middle::ty::{self, ClosureSizeProfileData, Ty, TyCtxt, TypeckResults, UpvarSubsts};\n+use rustc_middle::ty::{\n+    self, ClosureSizeProfileData, Ty, TyCtxt, TypeckResults, UpvarCapture, UpvarSubsts,\n+};\n use rustc_session::lint;\n use rustc_span::sym;\n use rustc_span::{MultiSpan, Span, Symbol};\n@@ -299,13 +301,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     captured_place.place, upvar_ty, capture, captured_place.mutability,\n                 );\n \n-                match capture {\n-                    ty::UpvarCapture::ByValue(_) => upvar_ty,\n-                    ty::UpvarCapture::ByRef(borrow) => self.tcx.mk_ref(\n-                        borrow.region,\n-                        ty::TypeAndMut { ty: upvar_ty, mutbl: borrow.kind.to_mutbl_lossy() },\n-                    ),\n-                }\n+                apply_capture_kind_on_capture_ty(self.tcx, upvar_ty, capture)\n             })\n             .collect()\n     }\n@@ -582,6 +578,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n         var_hir_id: hir::HirId,\n         check_trait: Option<DefId>,\n+        closure_clause: hir::CaptureBy,\n     ) -> bool {\n         let root_var_min_capture_list = if let Some(root_var_min_capture_list) =\n             min_captures.and_then(|m| m.get(&var_hir_id))\n@@ -593,6 +590,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let ty = self.infcx.resolve_vars_if_possible(self.node_ty(var_hir_id));\n \n+        let ty = match closure_clause {\n+            hir::CaptureBy::Value => ty, // For move closure the capture kind should be by value\n+            hir::CaptureBy::Ref => {\n+                // For non move closure the capture kind is the max capture kind of all captures\n+                // according to the ordering ImmBorrow < UniqueImmBorrow < MutBorrow < ByValue\n+                let mut max_capture_info = root_var_min_capture_list.first().unwrap().info;\n+                for capture in root_var_min_capture_list.iter() {\n+                    max_capture_info = determine_capture_info(max_capture_info, capture.info);\n+                }\n+\n+                apply_capture_kind_on_capture_ty(self.tcx, ty, max_capture_info.capture_kind)\n+            }\n+        };\n+\n         let obligation_should_hold = check_trait\n             .map(|check_trait| {\n                 self.infcx\n@@ -606,10 +617,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             })\n             .unwrap_or(false);\n \n-        // Check whether catpured fields also implement the trait\n-\n+        // Check whether captured fields also implement the trait\n         for capture in root_var_min_capture_list.iter() {\n-            let ty = capture.place.ty();\n+            let ty = apply_capture_kind_on_capture_ty(\n+                self.tcx,\n+                capture.place.ty(),\n+                capture.info.capture_kind,\n+            );\n \n             let obligation_holds_for_capture = check_trait\n                 .map(|check_trait| {\n@@ -645,6 +659,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         min_captures: Option<&ty::RootVariableMinCaptureList<'tcx>>,\n         var_hir_id: hir::HirId,\n+        closure_clause: hir::CaptureBy,\n     ) -> Option<FxHashSet<&str>> {\n         let tcx = self.infcx.tcx;\n \n@@ -655,6 +670,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             min_captures,\n             var_hir_id,\n             tcx.lang_items().clone_trait(),\n+            closure_clause,\n         ) {\n             auto_trait_reasons.insert(\"`Clone`\");\n         }\n@@ -663,6 +679,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             min_captures,\n             var_hir_id,\n             tcx.lang_items().sync_trait(),\n+            closure_clause,\n         ) {\n             auto_trait_reasons.insert(\"`Sync`\");\n         }\n@@ -671,6 +688,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             min_captures,\n             var_hir_id,\n             tcx.get_diagnostic_item(sym::send_trait),\n+            closure_clause,\n         ) {\n             auto_trait_reasons.insert(\"`Send`\");\n         }\n@@ -679,6 +697,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             min_captures,\n             var_hir_id,\n             tcx.lang_items().unpin_trait(),\n+            closure_clause,\n         ) {\n             auto_trait_reasons.insert(\"`Unpin`\");\n         }\n@@ -687,6 +706,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             min_captures,\n             var_hir_id,\n             tcx.get_diagnostic_item(sym::unwind_safe_trait),\n+            closure_clause,\n         ) {\n             auto_trait_reasons.insert(\"`UnwindSafe`\");\n         }\n@@ -695,6 +715,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             min_captures,\n             var_hir_id,\n             tcx.get_diagnostic_item(sym::ref_unwind_safe_trait),\n+            closure_clause,\n         ) {\n             auto_trait_reasons.insert(\"`RefUnwindSafe`\");\n         }\n@@ -814,7 +835,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         for (&var_hir_id, _) in upvars.iter() {\n             let mut need_migration = false;\n             if let Some(trait_migration_cause) =\n-                self.compute_2229_migrations_for_trait(min_captures, var_hir_id)\n+                self.compute_2229_migrations_for_trait(min_captures, var_hir_id, closure_clause)\n             {\n                 need_migration = true;\n                 auto_trait_reasons.extend(trait_migration_cause);\n@@ -1286,6 +1307,19 @@ fn restrict_repr_packed_field_ref_capture<'tcx>(\n     place\n }\n \n+/// Returns a Ty that applies the specified capture kind on the provided capture Ty\n+fn apply_capture_kind_on_capture_ty(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+    capture_kind: UpvarCapture<'tcx>,\n+) -> Ty<'tcx> {\n+    match capture_kind {\n+        ty::UpvarCapture::ByValue(_) => ty,\n+        ty::UpvarCapture::ByRef(borrow) => tcx\n+            .mk_ref(borrow.region, ty::TypeAndMut { ty: ty, mutbl: borrow.kind.to_mutbl_lossy() }),\n+    }\n+}\n+\n struct InferBorrowKind<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n "}, {"sha": "39cf82053f7df40c9667d536604cde30c931356c", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/unpin_no_migration.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c15fc16f46ad44569d2ccd026affd56b4da839e/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Funpin_no_migration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c15fc16f46ad44569d2ccd026affd56b4da839e/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Funpin_no_migration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Funpin_no_migration.rs?ref=7c15fc16f46ad44569d2ccd026affd56b4da839e", "patch": "@@ -1,5 +1,5 @@\n //run-pass\n-#![deny(disjoint_capture_migration)]\n+#![deny(rust_2021_incompatible_closure_captures)]\n #![allow(unused_must_use)]\n \n fn filter_try_fold("}]}