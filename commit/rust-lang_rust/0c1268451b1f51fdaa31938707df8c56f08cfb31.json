{"sha": "0c1268451b1f51fdaa31938707df8c56f08cfb31", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjMTI2ODQ1MWIxZjUxZmRhYTMxOTM4NzA3ZGY4YzU2ZjA4Y2ZiMzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-02T19:22:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-02T19:22:16Z"}, "message": "auto merge of #18481 : sfackler/rust/enum-namespace, r=pcwalton\n\nAfter a snapshot, everything can be switched over and the small bit of hackery in resolve dealing with `ENUM_STAGING_HACK` can be removed.\r\n\r\ncc #18478", "tree": {"sha": "67bdef1cb83fbd634c5a0e293a80e641de2be4b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67bdef1cb83fbd634c5a0e293a80e641de2be4b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c1268451b1f51fdaa31938707df8c56f08cfb31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c1268451b1f51fdaa31938707df8c56f08cfb31", "html_url": "https://github.com/rust-lang/rust/commit/0c1268451b1f51fdaa31938707df8c56f08cfb31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c1268451b1f51fdaa31938707df8c56f08cfb31/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3327ecca422046699315122345c6c050ab73804b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3327ecca422046699315122345c6c050ab73804b", "html_url": "https://github.com/rust-lang/rust/commit/3327ecca422046699315122345c6c050ab73804b"}, {"sha": "d7ff7da65a1e8e45cbbec7cd487773ee468e12ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7ff7da65a1e8e45cbbec7cd487773ee468e12ed", "html_url": "https://github.com/rust-lang/rust/commit/d7ff7da65a1e8e45cbbec7cd487773ee468e12ed"}], "stats": {"total": 678, "additions": 584, "deletions": 94}, "files": [{"sha": "e6a0363fcbf50f6bb5116c20cca826ae57d657d7", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=0c1268451b1f51fdaa31938707df8c56f08cfb31", "patch": "@@ -15,6 +15,7 @@\n use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n+use middle::def;\n use middle::lang_items;\n use middle::resolve;\n use middle::ty;\n@@ -114,6 +115,12 @@ pub fn maybe_get_item_ast<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId,\n     decoder::maybe_get_item_ast(&*cdata, tcx, def.node, decode_inlined_item)\n }\n \n+pub fn get_enum_variant_defs(cstore: &cstore::CStore, enum_id: ast::DefId)\n+                             -> Vec<(def::Def, ast::Name, ast::Visibility)> {\n+    let cdata = cstore.get_crate_data(enum_id.krate);\n+    decoder::get_enum_variant_defs(&*cstore.intr, &*cdata, enum_id.node)\n+}\n+\n pub fn get_enum_variants(tcx: &ty::ctxt, def: ast::DefId)\n                       -> Vec<Rc<ty::VariantInfo>> {\n     let cstore = &tcx.sess.cstore;"}, {"sha": "0df98bfb0b16dd84deda7c93c81852a071d26803", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=0c1268451b1f51fdaa31938707df8c56f08cfb31", "patch": "@@ -659,6 +659,24 @@ pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: ast::NodeI\n     }\n }\n \n+pub fn get_enum_variant_defs(intr: &IdentInterner,\n+                             cdata: Cmd,\n+                             id: ast::NodeId)\n+                             -> Vec<(def::Def, ast::Name, ast::Visibility)> {\n+    let data = cdata.data();\n+    let items = reader::get_doc(rbml::Doc::new(data), tag_items);\n+    let item = find_item(id, items);\n+    enum_variant_ids(item, cdata).iter().map(|did| {\n+        let item = find_item(did.node, items);\n+        let name = item_name(intr, item);\n+        let visibility = item_visibility(item);\n+        match item_to_def_like(item, *did, cdata.cnum) {\n+            DlDef(def @ def::DefVariant(..)) => (def, name, visibility),\n+            _ => unreachable!()\n+        }\n+    }).collect()\n+}\n+\n pub fn get_enum_variants(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n                      tcx: &ty::ctxt) -> Vec<Rc<ty::VariantInfo>> {\n     let data = cdata.data();"}, {"sha": "c297bdc6ca2e70a131fe4dafc61cf9941b5c0f0f", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 210, "deletions": 86, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=0c1268451b1f51fdaa31938707df8c56f08cfb31", "patch": "@@ -492,6 +492,7 @@ enum ModuleKind {\n     NormalModuleKind,\n     TraitModuleKind,\n     ImplModuleKind,\n+    EnumModuleKind,\n     AnonymousModuleKind,\n }\n \n@@ -568,10 +569,19 @@ impl Module {\n     }\n }\n \n+bitflags! {\n+    #[deriving(Show)]\n+    flags DefModifiers: u8 {\n+        const PUBLIC            = 0b0000_0001,\n+        const IMPORTABLE        = 0b0000_0010,\n+        const ENUM_STAGING_HACK = 0b0000_0100,\n+    }\n+}\n+\n // Records a possibly-private type definition.\n #[deriving(Clone)]\n struct TypeNsDef {\n-    is_public: bool, // see note in ImportResolution about how to use this\n+    modifiers: DefModifiers, // see note in ImportResolution about how to use this\n     module_def: Option<Rc<Module>>,\n     type_def: Option<Def>,\n     type_span: Option<Span>\n@@ -580,7 +590,7 @@ struct TypeNsDef {\n // Records a possibly-private value definition.\n #[deriving(Clone, Show)]\n struct ValueNsDef {\n-    is_public: bool, // see note in ImportResolution about how to use this\n+    modifiers: DefModifiers, // see note in ImportResolution about how to use this\n     def: Def,\n     value_span: Option<Span>,\n }\n@@ -616,21 +626,22 @@ impl NameBindings {\n                      is_public: bool,\n                      sp: Span) {\n         // Merges the module with the existing type def or creates a new one.\n+        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n         let module_ = Rc::new(Module::new(parent_link, def_id, kind, external,\n                                           is_public));\n         let type_def = self.type_def.borrow().clone();\n         match type_def {\n             None => {\n                 *self.type_def.borrow_mut() = Some(TypeNsDef {\n-                    is_public: is_public,\n+                    modifiers: modifiers,\n                     module_def: Some(module_),\n                     type_def: None,\n                     type_span: Some(sp)\n                 });\n             }\n             Some(type_def) => {\n                 *self.type_def.borrow_mut() = Some(TypeNsDef {\n-                    is_public: is_public,\n+                    modifiers: modifiers,\n                     module_def: Some(module_),\n                     type_span: Some(sp),\n                     type_def: type_def.type_def\n@@ -647,13 +658,14 @@ impl NameBindings {\n                        external: bool,\n                        is_public: bool,\n                        _sp: Span) {\n+        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n         let type_def = self.type_def.borrow().clone();\n         match type_def {\n             None => {\n                 let module = Module::new(parent_link, def_id, kind,\n                                          external, is_public);\n                 *self.type_def.borrow_mut() = Some(TypeNsDef {\n-                    is_public: is_public,\n+                    modifiers: modifiers,\n                     module_def: Some(Rc::new(module)),\n                     type_def: None,\n                     type_span: None,\n@@ -668,7 +680,7 @@ impl NameBindings {\n                                                  external,\n                                                  is_public);\n                         *self.type_def.borrow_mut() = Some(TypeNsDef {\n-                            is_public: is_public,\n+                            modifiers: modifiers,\n                             module_def: Some(Rc::new(module)),\n                             type_def: type_def.type_def,\n                             type_span: None,\n@@ -681,7 +693,8 @@ impl NameBindings {\n     }\n \n     /// Records a type definition.\n-    fn define_type(&self, def: Def, sp: Span, is_public: bool) {\n+    fn define_type(&self, def: Def, sp: Span, modifiers: DefModifiers) {\n+        debug!(\"defining type for def {} with modifiers {}\", def, modifiers);\n         // Merges the type with the existing type def or creates a new one.\n         let type_def = self.type_def.borrow().clone();\n         match type_def {\n@@ -690,26 +703,27 @@ impl NameBindings {\n                     module_def: None,\n                     type_def: Some(def),\n                     type_span: Some(sp),\n-                    is_public: is_public,\n+                    modifiers: modifiers,\n                 });\n             }\n             Some(type_def) => {\n                 *self.type_def.borrow_mut() = Some(TypeNsDef {\n                     type_def: Some(def),\n                     type_span: Some(sp),\n                     module_def: type_def.module_def,\n-                    is_public: is_public,\n+                    modifiers: modifiers,\n                 });\n             }\n         }\n     }\n \n     /// Records a value definition.\n-    fn define_value(&self, def: Def, sp: Span, is_public: bool) {\n+    fn define_value(&self, def: Def, sp: Span, modifiers: DefModifiers) {\n+        debug!(\"defining value for def {} with modifiers {}\", def, modifiers);\n         *self.value_def.borrow_mut() = Some(ValueNsDef {\n             def: def,\n             value_span: Some(sp),\n-            is_public: is_public,\n+            modifiers: modifiers,\n         });\n     }\n \n@@ -743,12 +757,16 @@ impl NameBindings {\n     }\n \n     fn defined_in_public_namespace(&self, namespace: Namespace) -> bool {\n+        self.defined_in_namespace_with(namespace, PUBLIC)\n+    }\n+\n+    fn defined_in_namespace_with(&self, namespace: Namespace, modifiers: DefModifiers) -> bool {\n         match namespace {\n             TypeNS => match *self.type_def.borrow() {\n-                Some(ref def) => def.is_public, None => false\n+                Some(ref def) => def.modifiers.contains(modifiers), None => false\n             },\n             ValueNS => match *self.value_def.borrow() {\n-                Some(ref def) => def.is_public, None => false\n+                Some(ref def) => def.modifiers.contains(modifiers), None => false\n             }\n         }\n     }\n@@ -1214,6 +1232,7 @@ impl<'a> Resolver<'a> {\n         let name = item.ident.name;\n         let sp = item.span;\n         let is_public = item.vis == ast::Public;\n+        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n \n         match item.node {\n             ItemMod(..) => {\n@@ -1241,21 +1260,21 @@ impl<'a> Resolver<'a> {\n                 let mutbl = m == ast::MutMutable;\n \n                 name_bindings.define_value\n-                    (DefStatic(local_def(item.id), mutbl), sp, is_public);\n+                    (DefStatic(local_def(item.id), mutbl), sp, modifiers);\n                 parent\n             }\n             ItemConst(_, _) => {\n                 self.add_child(name, parent.clone(), ForbidDuplicateValues, sp)\n                     .define_value(DefConst(local_def(item.id)),\n-                                  sp, is_public);\n+                                  sp, modifiers);\n                 parent\n             }\n             ItemFn(_, _, _, _, _) => {\n                 let name_bindings =\n                     self.add_child(name, parent.clone(), ForbidDuplicateValues, sp);\n \n                 let def = DefFn(local_def(item.id), false);\n-                name_bindings.define_value(def, sp, is_public);\n+                name_bindings.define_value(def, sp, modifiers);\n                 parent\n             }\n \n@@ -1268,7 +1287,7 @@ impl<'a> Resolver<'a> {\n                                    sp);\n \n                 name_bindings.define_type\n-                    (DefTy(local_def(item.id), false), sp, is_public);\n+                    (DefTy(local_def(item.id), false), sp, modifiers);\n                 parent\n             }\n \n@@ -1280,14 +1299,32 @@ impl<'a> Resolver<'a> {\n                                    sp);\n \n                 name_bindings.define_type\n-                    (DefTy(local_def(item.id), true), sp, is_public);\n+                    (DefTy(local_def(item.id), true), sp, modifiers);\n+\n+                let parent_link = self.get_parent_link(parent.clone(), name);\n+                // We want to make sure the module type is EnumModuleKind\n+                // even if there's already an ImplModuleKind module defined,\n+                // since that's how we prevent duplicate enum definitions\n+                name_bindings.set_module_kind(parent_link,\n+                                              Some(local_def(item.id)),\n+                                              EnumModuleKind,\n+                                              false,\n+                                              is_public,\n+                                              sp);\n \n                 for variant in (*enum_definition).variants.iter() {\n+                    self.build_reduced_graph_for_variant(\n+                        &**variant,\n+                        local_def(item.id),\n+                        ModuleReducedGraphParent(name_bindings.get_module()),\n+                        modifiers);\n+\n+                    // Temporary staging hack\n                     self.build_reduced_graph_for_variant(\n                         &**variant,\n                         local_def(item.id),\n                         parent.clone(),\n-                        is_public);\n+                        modifiers | ENUM_STAGING_HACK);\n                 }\n                 parent\n             }\n@@ -1303,14 +1340,14 @@ impl<'a> Resolver<'a> {\n                 let name_bindings = self.add_child(name, parent.clone(), forbid, sp);\n \n                 // Define a name in the type namespace.\n-                name_bindings.define_type(DefTy(local_def(item.id), false), sp, is_public);\n+                name_bindings.define_type(DefTy(local_def(item.id), false), sp, modifiers);\n \n                 // If this is a newtype or unit-like struct, define a name\n                 // in the value namespace as well\n                 match ctor_id {\n                     Some(cid) => {\n                         name_bindings.define_value(DefStruct(local_def(cid)),\n-                                                   sp, is_public);\n+                                                   sp, modifiers);\n                     }\n                     None => {}\n                 }\n@@ -1347,6 +1384,12 @@ impl<'a> Resolver<'a> {\n                                                 ImplModuleKind => {\n                                 ModuleReducedGraphParent(child.get_module())\n                             }\n+                            Some(ref child) if child.get_module_if_available()\n+                                                .is_some() &&\n+                                           child.get_module().kind.get() ==\n+                                                EnumModuleKind => {\n+                                ModuleReducedGraphParent(child.get_module())\n+                            }\n                             // Create the module\n                             _ => {\n                                 let name_bindings =\n@@ -1403,12 +1446,16 @@ impl<'a> Resolver<'a> {\n                                         }\n                                     };\n \n-                                    let is_public =\n-                                        method.pe_vis() == ast::Public;\n+                                    // NB: not IMPORTABLE\n+                                    let modifiers = if method.pe_vis() == ast::Public {\n+                                        PUBLIC\n+                                    } else {\n+                                        DefModifiers::empty()\n+                                    };\n                                     method_name_bindings.define_value(\n                                         def,\n                                         method.span,\n-                                        is_public);\n+                                        modifiers);\n                                 }\n                                 TypeImplItem(ref typedef) => {\n                                     // Add the typedef to the module.\n@@ -1421,12 +1468,16 @@ impl<'a> Resolver<'a> {\n                                             typedef.span);\n                                     let def = DefAssociatedTy(local_def(\n                                             typedef.id));\n-                                    let is_public = typedef.vis ==\n-                                        ast::Public;\n+                                    // NB: not IMPORTABLE\n+                                    let modifiers = if typedef.vis == ast::Public {\n+                                        PUBLIC\n+                                    } else {\n+                                        DefModifiers::empty()\n+                                    };\n                                     typedef_name_bindings.define_type(\n                                         def,\n                                         typedef.span,\n-                                        is_public);\n+                                        modifiers);\n                                 }\n                             }\n                         }\n@@ -1499,9 +1550,10 @@ impl<'a> Resolver<'a> {\n                                                module_parent.clone(),\n                                                ForbidDuplicateTypesAndValues,\n                                                ty_m.span);\n+                            // NB: not IMPORTABLE\n                             method_name_bindings.define_value(def,\n                                                               ty_m.span,\n-                                                              true);\n+                                                              PUBLIC);\n \n                             (name, static_flag)\n                         }\n@@ -1514,9 +1566,10 @@ impl<'a> Resolver<'a> {\n                                                module_parent.clone(),\n                                                ForbidDuplicateTypesAndValues,\n                                                associated_type.span);\n+                            // NB: not IMPORTABLE\n                             name_bindings.define_type(def,\n                                                       associated_type.span,\n-                                                      true);\n+                                                      PUBLIC);\n \n                             (associated_type.ident.name, TypeTraitItemKind)\n                         }\n@@ -1525,7 +1578,7 @@ impl<'a> Resolver<'a> {\n                     self.trait_item_map.insert((name, def_id), kind);\n                 }\n \n-                name_bindings.define_type(DefTrait(def_id), sp, is_public);\n+                name_bindings.define_type(DefTrait(def_id), sp, modifiers);\n                 parent\n             }\n             ItemMac(..) => parent\n@@ -1538,7 +1591,7 @@ impl<'a> Resolver<'a> {\n                                        variant: &Variant,\n                                        item_id: DefId,\n                                        parent: ReducedGraphParent,\n-                                       is_public: bool) {\n+                                       modifiers: DefModifiers) {\n         let name = variant.node.name.name;\n         let is_exported = match variant.node.kind {\n             TupleVariantKind(_) => false,\n@@ -1554,10 +1607,10 @@ impl<'a> Resolver<'a> {\n                                    variant.span);\n         child.define_value(DefVariant(item_id,\n                                       local_def(variant.node.id), is_exported),\n-                           variant.span, is_public);\n+                           variant.span, modifiers);\n         child.define_type(DefVariant(item_id,\n                                      local_def(variant.node.id), is_exported),\n-                          variant.span, is_public);\n+                          variant.span, modifiers);\n     }\n \n     /// Constructs the reduced graph for one 'view item'. View items consist\n@@ -1703,14 +1756,15 @@ impl<'a> Resolver<'a> {\n                                             f: |&mut Resolver|) {\n         let name = foreign_item.ident.name;\n         let is_public = foreign_item.vis == ast::Public;\n+        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n         let name_bindings =\n             self.add_child(name, parent, ForbidDuplicateValues,\n                            foreign_item.span);\n \n         match foreign_item.node {\n             ForeignItemFn(_, ref generics) => {\n                 let def = DefFn(local_def(foreign_item.id), false);\n-                name_bindings.define_value(def, foreign_item.span, is_public);\n+                name_bindings.define_value(def, foreign_item.span, modifiers);\n \n                 self.with_type_parameter_rib(\n                     HasTypeParameters(generics,\n@@ -1721,7 +1775,7 @@ impl<'a> Resolver<'a> {\n             }\n             ForeignItemStatic(_, m) => {\n                 let def = DefStatic(local_def(foreign_item.id), m);\n-                name_bindings.define_value(def, foreign_item.span, is_public);\n+                name_bindings.define_value(def, foreign_item.span, modifiers);\n \n                 f(self)\n             }\n@@ -1766,6 +1820,7 @@ impl<'a> Resolver<'a> {\n                 external crate) building external def, priv {}\",\n                vis);\n         let is_public = vis == ast::Public;\n+        let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n         let is_exported = is_public && match new_parent {\n             ModuleReducedGraphParent(ref module) => {\n                 match module.def_id.get() {\n@@ -1779,6 +1834,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         let kind = match def {\n+            DefTy(_, true) => EnumModuleKind,\n             DefStruct(..) | DefTy(..) => ImplModuleKind,\n             _ => NormalModuleKind\n         };\n@@ -1813,6 +1869,7 @@ impl<'a> Resolver<'a> {\n \n         match def {\n           DefMod(_) | DefForeignMod(_) => {}\n+          // Still here for staging\n           DefVariant(enum_did, variant_id, is_struct) => {\n             debug!(\"(building reduced graph for external crate) building \\\n                     variant {}\",\n@@ -1822,23 +1879,36 @@ impl<'a> Resolver<'a> {\n             // definition.\n             let is_exported = is_public ||\n                               self.external_exports.contains(&enum_did);\n+            let modifiers = IMPORTABLE | ENUM_STAGING_HACK | if is_exported {\n+                PUBLIC\n+            } else {\n+                DefModifiers::empty()\n+            };\n             if is_struct {\n-                child_name_bindings.define_type(def, DUMMY_SP, is_exported);\n+                child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n                 // Not adding fields for variants as they are not accessed with a self receiver\n                 self.structs.insert(variant_id, Vec::new());\n             } else {\n-                child_name_bindings.define_value(def, DUMMY_SP, is_exported);\n+                child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n             }\n           }\n           DefFn(ctor_id, true) => {\n             child_name_bindings.define_value(\n                 csearch::get_tuple_struct_definition_if_ctor(&self.session.cstore, ctor_id)\n-                    .map_or(def, |_| DefStruct(ctor_id)), DUMMY_SP, is_public);\n+                    .map_or(def, |_| DefStruct(ctor_id)), DUMMY_SP, modifiers);\n           }\n           DefFn(..) | DefStaticMethod(..) | DefStatic(..) | DefConst(..) | DefMethod(..) => {\n             debug!(\"(building reduced graph for external \\\n                     crate) building value (fn/static) {}\", final_ident);\n-            child_name_bindings.define_value(def, DUMMY_SP, is_public);\n+            // impl methods have already been defined with the correct importability modifier\n+            let mut modifiers = match *child_name_bindings.value_def.borrow() {\n+                Some(ref def) => (modifiers & !IMPORTABLE) | (def.modifiers & IMPORTABLE),\n+                None => modifiers\n+            };\n+            if new_parent.module().kind.get() != NormalModuleKind {\n+                modifiers = modifiers & !IMPORTABLE;\n+            }\n+            child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n           }\n           DefTrait(def_id) => {\n               debug!(\"(building reduced graph for external \\\n@@ -1867,7 +1937,7 @@ impl<'a> Resolver<'a> {\n                   }\n               }\n \n-              child_name_bindings.define_type(def, DUMMY_SP, is_public);\n+              child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n \n               // Define a module if necessary.\n               let parent_link = self.get_parent_link(new_parent, name);\n@@ -1878,23 +1948,57 @@ impl<'a> Resolver<'a> {\n                                                   is_public,\n                                                   DUMMY_SP)\n           }\n+          DefTy(def_id, true) => { // enums\n+              debug!(\"(building reduced graph for external crate) building enum {}\", final_ident);\n+              child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n+              let enum_module = ModuleReducedGraphParent(child_name_bindings.get_module());\n+\n+              let variants = csearch::get_enum_variant_defs(&self.session.cstore, def_id);\n+              for &(v_def, name, vis) in variants.iter() {\n+                  let (variant_id, is_struct) = match v_def {\n+                      DefVariant(_, variant_id, is_struct) => (variant_id, is_struct),\n+                      _ => unreachable!()\n+                  };\n+                  let child = self.add_child(name, enum_module.clone(),\n+                                             OverwriteDuplicates,\n+                                             DUMMY_SP);\n+\n+                  // If this variant is public, then it was publicly reexported,\n+                  // otherwise we need to inherit the visibility of the enum\n+                  // definition.\n+                  let variant_exported = vis == ast::Public || is_exported;\n+                  let modifiers = IMPORTABLE | if variant_exported {\n+                      PUBLIC\n+                  } else {\n+                      DefModifiers::empty()\n+                  };\n+                  if is_struct {\n+                      child.define_type(v_def, DUMMY_SP, modifiers);\n+                      // Not adding fields for variants as they are not accessed with a self\n+                      // receiver\n+                      self.structs.insert(variant_id, Vec::new());\n+                  } else {\n+                      child.define_value(v_def, DUMMY_SP, modifiers);\n+                  }\n+              }\n+          }\n           DefTy(..) | DefAssociatedTy(..) => {\n               debug!(\"(building reduced graph for external \\\n                       crate) building type {}\", final_ident);\n \n-              child_name_bindings.define_type(def, DUMMY_SP, is_public);\n+              child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n           }\n           DefStruct(def_id) => {\n             debug!(\"(building reduced graph for external \\\n                     crate) building type and value for {}\",\n                    final_ident);\n-            child_name_bindings.define_type(def, DUMMY_SP, is_public);\n+            child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n             let fields = csearch::get_struct_fields(&self.session.cstore, def_id).iter().map(|f| {\n                 f.name\n             }).collect::<Vec<_>>();\n \n             if fields.len() == 0 {\n-                child_name_bindings.define_value(def, DUMMY_SP, is_public);\n+                child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n             }\n \n             // Record the def ID and fields of this struct.\n@@ -2021,9 +2125,14 @@ impl<'a> Resolver<'a> {\n                                                        DUMMY_SP);\n                                     let def = DefFn(method_info.def_id, false);\n \n+                                    // NB: not IMPORTABLE\n+                                    let modifiers = if visibility == ast::Public {\n+                                        PUBLIC\n+                                    } else {\n+                                        DefModifiers::empty()\n+                                    };\n                                     method_name_bindings.define_value(\n-                                        def, DUMMY_SP,\n-                                        visibility == ast::Public);\n+                                        def, DUMMY_SP, modifiers);\n                                 }\n                             }\n \n@@ -2394,7 +2503,7 @@ impl<'a> Resolver<'a> {\n     fn create_name_bindings_from_module(module: Rc<Module>) -> NameBindings {\n         NameBindings {\n             type_def: RefCell::new(Some(TypeNsDef {\n-                is_public: false,\n+                modifiers: IMPORTABLE,\n                 module_def: Some(module),\n                 type_def: None,\n                 type_span: None\n@@ -2596,6 +2705,12 @@ impl<'a> Resolver<'a> {\n                     target,\n                     ValueNS);\n \n+                self.check_that_import_is_importable(\n+                    &**name_bindings,\n+                    directive.span,\n+                    target,\n+                    ValueNS);\n+\n                 import_resolution.value_target =\n                     Some(Target::new(target_module.clone(),\n                                      name_bindings.clone(),\n@@ -2619,6 +2734,12 @@ impl<'a> Resolver<'a> {\n                     target,\n                     TypeNS);\n \n+                self.check_that_import_is_importable(\n+                    &**name_bindings,\n+                    directive.span,\n+                    target,\n+                    TypeNS);\n+\n                 import_resolution.type_target =\n                     Some(Target::new(target_module.clone(),\n                                      name_bindings.clone(),\n@@ -2829,15 +2950,15 @@ impl<'a> Resolver<'a> {\n                self.module_to_string(module_));\n \n         // Merge the child item into the import resolution.\n-        if name_bindings.defined_in_public_namespace(ValueNS) {\n+        if name_bindings.defined_in_namespace_with(ValueNS, IMPORTABLE | PUBLIC) {\n             debug!(\"(resolving glob import) ... for value target\");\n             dest_import_resolution.value_target =\n                 Some(Target::new(containing_module.clone(),\n                                  name_bindings.clone(),\n                                  import_directive.shadowable));\n             dest_import_resolution.value_id = id;\n         }\n-        if name_bindings.defined_in_public_namespace(TypeNS) {\n+        if name_bindings.defined_in_namespace_with(TypeNS, IMPORTABLE | PUBLIC) {\n             debug!(\"(resolving glob import) ... for type target\");\n             dest_import_resolution.type_target =\n                 Some(Target::new(containing_module,\n@@ -2879,6 +3000,19 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    /// Checks that an import is actually importable\n+    fn check_that_import_is_importable(&mut self,\n+                                       name_bindings: &NameBindings,\n+                                       import_span: Span,\n+                                       name: Name,\n+                                       namespace: Namespace) {\n+        if !name_bindings.defined_in_namespace_with(namespace, IMPORTABLE) {\n+            let msg = format!(\"`{}` is not directly importable\",\n+                              token::get_name(name));\n+            self.session.span_err(import_span, msg.as_slice());\n+        }\n+    }\n+\n     /// Checks that imported names and items don't have the same name.\n     fn check_for_conflicts_between_imports_and_items(&mut self,\n                                                      module: &Module,\n@@ -2918,8 +3052,8 @@ impl<'a> Resolver<'a> {\n         match import_resolution.value_target {\n             Some(ref target) if !target.shadowable => {\n                 match *name_bindings.value_def.borrow() {\n-                    None => {}\n-                    Some(ref value) => {\n+                    // We want to allow the \"flat\" def of enum variants to be shadowed\n+                    Some(ref value) if !value.modifiers.contains(ENUM_STAGING_HACK) => {\n                         let msg = format!(\"import `{}` conflicts with value \\\n                                            in this module\",\n                                           token::get_name(name).get());\n@@ -2933,6 +3067,7 @@ impl<'a> Resolver<'a> {\n                             }\n                         }\n                     }\n+                    _ => {}\n                 }\n             }\n             Some(_) | None => {}\n@@ -2941,8 +3076,8 @@ impl<'a> Resolver<'a> {\n         match import_resolution.type_target {\n             Some(ref target) if !target.shadowable => {\n                 match *name_bindings.type_def.borrow() {\n-                    None => {}\n-                    Some(ref ty) => {\n+                    // We want to allow the \"flat\" def of enum variants to be shadowed\n+                    Some(ref ty) if !ty.modifiers.contains(ENUM_STAGING_HACK) => {\n                         match ty.module_def {\n                             None => {\n                                 let msg = format!(\"import `{}` conflicts with type in \\\n@@ -2993,6 +3128,7 @@ impl<'a> Resolver<'a> {\n                             }\n                         }\n                     }\n+                    _ => {}\n                 }\n             }\n             Some(_) | None => {}\n@@ -3131,43 +3267,28 @@ impl<'a> Resolver<'a> {\n                                     return Failed(Some((span, msg)));\n                                 }\n                                 Some(ref module_def) => {\n-                                    // If we're doing the search for an\n-                                    // import, do not allow traits and impls\n-                                    // to be selected.\n-                                    match (name_search_type,\n-                                           module_def.kind.get()) {\n-                                        (ImportSearch, TraitModuleKind) |\n-                                        (ImportSearch, ImplModuleKind) => {\n-                                            let msg =\n-                                                \"Cannot import from a trait or \\\n-                                                type implementation\".to_string();\n-                                            return Failed(Some((span, msg)));\n+                                    search_module = module_def.clone();\n+\n+                                    // track extern crates for unused_extern_crate lint\n+                                    match module_def.def_id.get() {\n+                                        Some(did) => {\n+                                            self.used_crates.insert(did.krate);\n                                         }\n-                                        (_, _) => {\n-                                            search_module = module_def.clone();\n-\n-                                            // track extern crates for unused_extern_crates lint\n-                                            match module_def.def_id.get() {\n-                                                Some(did) => {\n-                                                    self.used_crates.insert(did.krate);\n-                                                }\n-                                                _ => {}\n-                                            }\n+                                        _ => {}\n+                                    }\n \n-                                            // Keep track of the closest\n-                                            // private module used when\n-                                            // resolving this import chain.\n-                                            if !used_proxy &&\n-                                               !search_module.is_public {\n-                                                match search_module.def_id\n-                                                                   .get() {\n-                                                    Some(did) => {\n-                                                        closest_private =\n-                                                            LastMod(DependsOn(did));\n-                                                    }\n-                                                    None => {}\n-                                                }\n+                                    // Keep track of the closest\n+                                    // private module used when\n+                                    // resolving this import chain.\n+                                    if !used_proxy &&\n+                                       !search_module.is_public {\n+                                        match search_module.def_id\n+                                                           .get() {\n+                                            Some(did) => {\n+                                                closest_private =\n+                                                    LastMod(DependsOn(did));\n                                             }\n+                                            None => {}\n                                         }\n                                     }\n                                 }\n@@ -3388,6 +3509,7 @@ impl<'a> Resolver<'a> {\n                         }\n                         TraitModuleKind |\n                         ImplModuleKind |\n+                        EnumModuleKind |\n                         AnonymousModuleKind => {\n                             search_module = parent_module_node.upgrade().unwrap();\n                         }\n@@ -3485,6 +3607,7 @@ impl<'a> Resolver<'a> {\n                         NormalModuleKind => return Some(new_module),\n                         TraitModuleKind |\n                         ImplModuleKind |\n+                        EnumModuleKind |\n                         AnonymousModuleKind => module_ = new_module,\n                     }\n                 }\n@@ -3500,6 +3623,7 @@ impl<'a> Resolver<'a> {\n             NormalModuleKind => return module_,\n             TraitModuleKind |\n             ImplModuleKind |\n+            EnumModuleKind |\n             AnonymousModuleKind => {\n                 match self.get_nearest_normal_module_parent(module_.clone()) {\n                     None => module_,"}, {"sha": "3a11f30049c6a316d8b780d10e4c31d6e6da9f87", "filename": "src/test/auxiliary/namespaced_enum_emulate_flat.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Fauxiliary%2Fnamespaced_enum_emulate_flat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Fauxiliary%2Fnamespaced_enum_emulate_flat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fnamespaced_enum_emulate_flat.rs?ref=0c1268451b1f51fdaa31938707df8c56f08cfb31", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(globs, struct_variant)]\n+\n+pub use Foo::*;\n+\n+pub enum Foo {\n+    A,\n+    B(int),\n+    C { a: int },\n+}\n+\n+impl Foo {\n+    pub fn foo() {}\n+}\n+\n+pub mod nest {\n+    pub use self::Bar::*;\n+\n+    pub enum Bar {\n+        D,\n+        E(int),\n+        F { a: int },\n+    }\n+\n+    impl Bar {\n+        pub fn foo() {}\n+    }\n+}\n+\n+"}, {"sha": "a6e6f9b019160ff3db9c5cb7186d6bb2f2b9868e", "filename": "src/test/auxiliary/namespaced_enums.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Fauxiliary%2Fnamespaced_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Fauxiliary%2Fnamespaced_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fnamespaced_enums.rs?ref=0c1268451b1f51fdaa31938707df8c56f08cfb31", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(struct_variant)]\n+\n+pub enum Foo {\n+    A,\n+    B(int),\n+    C { a: int },\n+}\n+\n+impl Foo {\n+    pub fn foo() {}\n+    pub fn bar(&self) {}\n+}\n+"}, {"sha": "22e0d3168cadc69b5697fc43e0d66aacdfc701fb", "filename": "src/test/auxiliary/use_from_trait_xc.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Fauxiliary%2Fuse_from_trait_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Fauxiliary%2Fuse_from_trait_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fuse_from_trait_xc.rs?ref=0c1268451b1f51fdaa31938707df8c56f08cfb31", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::sub::Bar;\n+pub use self::sub::{Bar, Baz};\n \n pub trait Trait {\n     fn foo();\n@@ -26,4 +26,10 @@ mod sub {\n     impl Bar {\n         pub fn new() {}\n     }\n+\n+    pub enum Baz {}\n+\n+    impl Baz {\n+        pub fn new() {}\n+    }\n }"}, {"sha": "7526c6753e632db1274a284eac60cf9fe21c1df9", "filename": "src/test/compile-fail/enum-and-module-in-same-scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Fcompile-fail%2Fenum-and-module-in-same-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Fcompile-fail%2Fenum-and-module-in-same-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-and-module-in-same-scope.rs?ref=0c1268451b1f51fdaa31938707df8c56f08cfb31", "patch": "@@ -13,7 +13,7 @@ mod Foo {\n }\n \n enum Foo {  //~ ERROR duplicate definition of type or module `Foo`\n-    X\n+    X //~ ERROR duplicate definition of value `X`\n }\n \n fn main() {}"}, {"sha": "09916a11f72e77440d4254e7fb9a65a4ba5ce7bf", "filename": "src/test/compile-fail/namespaced-enum-glob-import-no-impls-xcrate.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Fcompile-fail%2Fnamespaced-enum-glob-import-no-impls-xcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Fcompile-fail%2Fnamespaced-enum-glob-import-no-impls-xcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnamespaced-enum-glob-import-no-impls-xcrate.rs?ref=0c1268451b1f51fdaa31938707df8c56f08cfb31", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:namespaced_enums.rs\n+#![feature(struct_variant, globs)]\n+\n+extern crate namespaced_enums;\n+\n+mod m {\n+    pub use namespaced_enums::Foo::*;\n+}\n+\n+pub fn main() {\n+    use namespaced_enums::Foo::*;\n+\n+    foo(); //~ ERROR unresolved name `foo`\n+    m::foo(); //~ ERROR unresolved name `m::foo`\n+    bar(); //~ ERROR unresolved name `bar`\n+    m::bar(); //~ ERROR unresolved name `m::bar`\n+}\n+"}, {"sha": "1554d410070d697c424fc126d091d5908d8a8efd", "filename": "src/test/compile-fail/namespaced-enum-glob-import-no-impls.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Fcompile-fail%2Fnamespaced-enum-glob-import-no-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Fcompile-fail%2Fnamespaced-enum-glob-import-no-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnamespaced-enum-glob-import-no-impls.rs?ref=0c1268451b1f51fdaa31938707df8c56f08cfb31", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(struct_variant, globs)]\n+\n+mod m2 {\n+    pub enum Foo {\n+        A,\n+        B(int),\n+        C { a: int },\n+    }\n+\n+    impl Foo {\n+        pub fn foo() {}\n+        pub fn bar(&self) {}\n+    }\n+}\n+\n+mod m {\n+    pub use m2::Foo::*;\n+}\n+\n+pub fn main() {\n+    use m2::Foo::*;\n+\n+    foo(); //~ ERROR unresolved name `foo`\n+    m::foo(); //~ ERROR unresolved name `m::foo`\n+    bar(); //~ ERROR unresolved name `bar`\n+    m::bar(); //~ ERROR unresolved name `m::bar`\n+}"}, {"sha": "ff2824135801a38523d0bebb7de26c0de0472cb5", "filename": "src/test/compile-fail/use-from-trait-xc.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs?ref=0c1268451b1f51fdaa31938707df8c56f08cfb31", "patch": "@@ -13,12 +13,15 @@\n extern crate use_from_trait_xc;\n \n use use_from_trait_xc::Trait::foo;\n-//~^ ERROR unresolved import `use_from_trait_xc::Trait::foo`. Cannot import from a trait or type imp\n+//~^ ERROR `foo` is not directly importable\n \n use use_from_trait_xc::Foo::new;\n-//~^ ERROR unresolved import `use_from_trait_xc::Foo::new`. Cannot import from a trait or type imple\n+//~^ ERROR `new` is not directly importable\n \n-use use_from_trait_xc::Bar::new;\n-//~^ ERROR unresolved import `use_from_trait_xc::Bar::new`. Cannot import from a trait or type\n+use use_from_trait_xc::Bar::new as bnew;\n+//~^ ERROR `bnew` is not directly importable\n+\n+use use_from_trait_xc::Baz::new as baznew;\n+//~^ ERROR `baznew` is not directly importable\n \n fn main() {}"}, {"sha": "2a97155dd2efb878eebba9b619663ceaf824553c", "filename": "src/test/compile-fail/use-from-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Fcompile-fail%2Fuse-from-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Fcompile-fail%2Fuse-from-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-from-trait.rs?ref=0c1268451b1f51fdaa31938707df8c56f08cfb31", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n use Trait::foo;\n-//~^ ERROR unresolved import `Trait::foo`. Cannot import from a trait or type implementation\n+//~^ ERROR `foo` is not directly importable\n use Foo::new;\n-//~^ ERROR unresolved import `Foo::new`. Cannot import from a trait or type implementation\n+//~^ ERROR `new` is not directly importable\n \n pub trait Trait {\n     fn foo();"}, {"sha": "540a0acb12316c990043d612d4fe7b428197c2bc", "filename": "src/test/run-pass/namespaced-enum-emulate-flat-xc.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Frun-pass%2Fnamespaced-enum-emulate-flat-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Frun-pass%2Fnamespaced-enum-emulate-flat-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnamespaced-enum-emulate-flat-xc.rs?ref=0c1268451b1f51fdaa31938707df8c56f08cfb31", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:namespaced_enum_emulate_flat.rs\n+#![feature(struct_variant)]\n+\n+extern crate namespaced_enum_emulate_flat;\n+\n+use namespaced_enum_emulate_flat::{Foo, A, B, C};\n+use namespaced_enum_emulate_flat::nest::{Bar, D, E, F};\n+\n+fn _f(f: Foo) {\n+    match f {\n+        A | B(_) | C { .. } => {}\n+    }\n+}\n+\n+fn _f2(f: Bar) {\n+    match f {\n+        D | E(_) | F { .. } => {}\n+    }\n+}\n+\n+pub fn main() {}\n+"}, {"sha": "2aad9bcff5613239aa1a1451480e4668891c52f4", "filename": "src/test/run-pass/namespaced-enum-emulate-flat.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Frun-pass%2Fnamespaced-enum-emulate-flat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Frun-pass%2Fnamespaced-enum-emulate-flat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnamespaced-enum-emulate-flat.rs?ref=0c1268451b1f51fdaa31938707df8c56f08cfb31", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(globs, struct_variant)]\n+\n+pub use Foo::*;\n+use nest::{Bar, D, E, F};\n+\n+pub enum Foo {\n+    A,\n+    B(int),\n+    C { a: int },\n+}\n+\n+impl Foo {\n+    pub fn foo() {}\n+}\n+\n+fn _f(f: Foo) {\n+    match f {\n+        A | B(_) | C { .. } => {}\n+    }\n+}\n+\n+mod nest {\n+    pub use self::Bar::*;\n+\n+    pub enum Bar {\n+        D,\n+        E(int),\n+        F { a: int },\n+    }\n+\n+    impl Bar {\n+        pub fn foo() {}\n+    }\n+}\n+\n+fn _f2(f: Bar) {\n+    match f {\n+        D | E(_) | F { .. } => {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "35fb66769543bad038c49009fc2b8a882ffb4c0a", "filename": "src/test/run-pass/namespaced-enum-glob-import-xcrate.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Frun-pass%2Fnamespaced-enum-glob-import-xcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Frun-pass%2Fnamespaced-enum-glob-import-xcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnamespaced-enum-glob-import-xcrate.rs?ref=0c1268451b1f51fdaa31938707df8c56f08cfb31", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:namespaced_enums.rs\n+#![feature(globs, struct_variant)]\n+\n+extern crate namespaced_enums;\n+\n+fn _f(f: namespaced_enums::Foo) {\n+    use namespaced_enums::Foo::*;\n+\n+    match f {\n+        A | B(_) | C { .. } => {}\n+    }\n+}\n+\n+mod m {\n+    pub use namespaced_enums::Foo::*;\n+}\n+\n+fn _f2(f: namespaced_enums::Foo) {\n+    match f {\n+        m::A | m::B(_) | m::C { .. } => {}\n+    }\n+}\n+\n+pub fn main() {}"}, {"sha": "fe6f342738360b49209bb7b14a25c14ab326c2d5", "filename": "src/test/run-pass/namespaced-enum-glob-import.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Frun-pass%2Fnamespaced-enum-glob-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Frun-pass%2Fnamespaced-enum-glob-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnamespaced-enum-glob-import.rs?ref=0c1268451b1f51fdaa31938707df8c56f08cfb31", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(globs, struct_variant)]\n+\n+mod m2 {\n+    pub enum Foo {\n+        A,\n+        B(int),\n+        C { a: int },\n+    }\n+\n+    impl Foo {\n+        pub fn foo() {}\n+    }\n+}\n+\n+mod m {\n+    pub use m2::Foo::*;\n+}\n+\n+fn _f(f: m2::Foo) {\n+    use m2::Foo::*;\n+\n+    match f {\n+        A | B(_) | C { .. } => {}\n+    }\n+}\n+\n+fn _f2(f: m2::Foo) {\n+    match f {\n+        m::A | m::B(_) | m::C { .. } => {}\n+    }\n+}\n+\n+pub fn main() {}"}, {"sha": "c5f80eaea5a31022bd90c7f9d7608f8c1b6905dc", "filename": "src/test/run-pass/namespaced-enums-xcrate.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Frun-pass%2Fnamespaced-enums-xcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Frun-pass%2Fnamespaced-enums-xcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnamespaced-enums-xcrate.rs?ref=0c1268451b1f51fdaa31938707df8c56f08cfb31", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:namespaced_enums.rs\n+#![feature(struct_variant)]\n+\n+extern crate namespaced_enums;\n+\n+use namespaced_enums::Foo;\n+\n+fn _foo (f: Foo) {\n+    match f {\n+        Foo::A | Foo::B(_) | Foo::C { .. } => {}\n+    }\n+}\n+\n+pub fn main() {}\n+"}, {"sha": "afa39c326b60c9f04d1765e4521c73f4a3feb354", "filename": "src/test/run-pass/namespaced-enums.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Frun-pass%2Fnamespaced-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c1268451b1f51fdaa31938707df8c56f08cfb31/src%2Ftest%2Frun-pass%2Fnamespaced-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnamespaced-enums.rs?ref=0c1268451b1f51fdaa31938707df8c56f08cfb31", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(struct_variant)]\n+\n+enum Foo {\n+    A,\n+    B(int),\n+    C { a: int },\n+}\n+\n+fn _foo (f: Foo) {\n+    match f {\n+        Foo::A | Foo::B(_) | Foo::C { .. } => {}\n+    }\n+}\n+\n+pub fn main() {}"}]}