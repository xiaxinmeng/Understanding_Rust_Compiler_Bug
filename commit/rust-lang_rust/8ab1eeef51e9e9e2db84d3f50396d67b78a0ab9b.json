{"sha": "8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhYjFlZWVmNTFlOWU5ZTJkYjg0ZDNmNTAzOTZkNjdiNzhhMGFiOWI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-08-08T13:53:07Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-08-08T15:09:26Z"}, "message": "Implement packed statics", "tree": {"sha": "5ca3e32cc72987a223ada8a38f6866a075bc8e9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ca3e32cc72987a223ada8a38f6866a075bc8e9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlmJ1CYACgkQpp+NIls6\n19n5DRAAld6ShWiNr/JFAxtum0Cgo9PKrAgHrHpgoSzfdIf1EzFLNGAIOtN97Him\nTlSGD4savMxmnSYf/eh5Ml6VjlrHARY2zssUhOHgeSDU/JhVCelFx8d4UleTO3H5\nmE1WYRVXEHCIZoiAXCBHhJymdsKWPOMoyzLJHN5fQxojmTW46cQcFrMxXZ50/wHv\nzbQSy/VYEsGQfinshmi/ySx4Q8t3WP+jpb0QBKDqhbZzsg1L/NWJY7rH7hW7V/FG\ni1M/9IxlpGtSqYcgrXNEh+nvJK+g0gnfMd89dIQs1GAxD6vYkCP2XZ55AcIsZIBI\nmBiVQESgj39HKCPd+9jWI1Ptn9sHhP689Y7IC9cH98Xn/NIMcP5aW95QxPaK+KR0\nlp8olOC2n4ySEUED/J41GOC2kFy9g3hxgDZI0G1hFe3BboWS3KgN2BWP5hrqE4Gx\nizj7zhhttrvYiXyQqqwYB3g5SduDleF/04l2UVWDHbjkAmKe9QkvvvP5jpIDAcKn\nbbwzeI+BjrKLM68Ll7SHEeNEuUI0+wAcpc4Bh4lQvvpDJQSntSAFBT1Wl8BPYHks\nBmq//8CessCEYknKEZ/yezWBfaCjFqm4M6k5EBrplwSHIALz80/T8bxJrceQAJOI\nIcP82kLKNIedmhbQKEXkJKRJLs6euv9LjSpRt7Aq61lxoTrA8Hw=\n=y//I\n-----END PGP SIGNATURE-----", "payload": "tree 5ca3e32cc72987a223ada8a38f6866a075bc8e9b\nparent 181851fc6b70d85dca534a4428d69fa40dc65446\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1502200387 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1502204966 +0200\n\nImplement packed statics\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b", "html_url": "https://github.com/rust-lang/rust/commit/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "181851fc6b70d85dca534a4428d69fa40dc65446", "url": "https://api.github.com/repos/rust-lang/rust/commits/181851fc6b70d85dca534a4428d69fa40dc65446", "html_url": "https://github.com/rust-lang/rust/commit/181851fc6b70d85dca534a4428d69fa40dc65446"}], "stats": {"total": 249, "additions": 158, "deletions": 91}, "files": [{"sha": "2ffd10b9d0adcf4294ce0ba95ccc6b2104a89bb3", "filename": "miri/fn_call.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/miri%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/miri%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ffn_call.rs?ref=8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b", "patch": "@@ -329,8 +329,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     if let Ok(instance) = self.resolve_path(path) {\n                         let cid = GlobalId { instance, promoted: None };\n                         // compute global if not cached\n-                        let val = match self.globals.get(&cid).map(|&ptr| ptr) {\n-                            Some(ptr) => self.value_to_primval(Value::by_ref(ptr.into()), usize)?.to_u64()?,\n+                        let val = match self.globals.get(&cid).cloned() {\n+                            Some(ptr) => self.value_to_primval(Value::ByRef(ptr), usize)?.to_u64()?,\n                             None => eval_body_as_primval(self.tcx, instance)?.0.to_u64()?,\n                         };\n                         if val == name {"}, {"sha": "5a609a569bb0b8e47d70c79a9faa926994a0ad39", "filename": "miri/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/miri%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/miri%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fintrinsic.rs?ref=8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b", "patch": "@@ -8,7 +8,7 @@ use rustc_miri::interpret::{\n     Lvalue, LvalueExtra,\n     PrimVal, PrimValKind, Value, Pointer,\n     HasMemory,\n-    EvalContext,\n+    EvalContext, PtrAndAlign,\n };\n \n use helpers::EvalContextExt as HelperEvalContextExt;\n@@ -266,10 +266,10 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let size = self.type_size(dest_ty)?.expect(\"cannot zero unsized value\");\n                 let init = |this: &mut Self, val: Value| {\n                     let zero_val = match val {\n-                        Value::ByRef { ptr, aligned } => {\n+                        Value::ByRef(PtrAndAlign { ptr, .. }) => {\n                             // These writes have no alignment restriction anyway.\n                             this.memory.write_repeat(ptr, 0, size)?;\n-                            Value::ByRef { ptr, aligned }\n+                            val\n                         },\n                         // TODO(solson): Revisit this, it's fishy to check for Undef here.\n                         Value::ByVal(PrimVal::Undef) => match this.ty_to_primval_kind(dest_ty) {\n@@ -289,7 +289,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 };\n                 match dest {\n                     Lvalue::Local { frame, local } => self.modify_local(frame, local, init)?,\n-                    Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned: true } => self.memory.write_repeat(ptr, 0, size)?,\n+                    Lvalue::Ptr { ptr: PtrAndAlign { ptr, aligned: true }, extra: LvalueExtra::None } => self.memory.write_repeat(ptr, 0, size)?,\n                     Lvalue::Ptr { .. } => bug!(\"init intrinsic tried to write to fat or unaligned ptr target\"),\n                 }\n             }\n@@ -456,16 +456,16 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let size = dest_layout.size(&self.tcx.data_layout).bytes();\n                 let uninit = |this: &mut Self, val: Value| {\n                     match val {\n-                        Value::ByRef { ptr, aligned } => {\n+                        Value::ByRef(PtrAndAlign { ptr, .. }) => {\n                             this.memory.mark_definedness(ptr, size, false)?;\n-                            Ok(Value::ByRef { ptr, aligned })\n+                            Ok(val)\n                         },\n                         _ => Ok(Value::ByVal(PrimVal::Undef)),\n                     }\n                 };\n                 match dest {\n                     Lvalue::Local { frame, local } => self.modify_local(frame, local, uninit)?,\n-                    Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned: true } =>\n+                    Lvalue::Ptr { ptr: PtrAndAlign { ptr, aligned: true }, extra: LvalueExtra::None } =>\n                         self.memory.mark_definedness(ptr, size, false)?,\n                     Lvalue::Ptr { .. } => bug!(\"uninit intrinsic tried to write to fat or unaligned ptr target\"),\n                 }"}, {"sha": "16004a2110baa25271eabe1f25ee1d7cb9fa174f", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b", "patch": "@@ -9,7 +9,7 @@ use super::{\n     EvalResult, EvalError, EvalErrorKind,\n     GlobalId, Lvalue, Value,\n     PrimVal,\n-    EvalContext, StackPopCleanup,\n+    EvalContext, StackPopCleanup, PtrAndAlign,\n     Kind,\n };\n \n@@ -34,7 +34,8 @@ pub fn eval_body_as_primval<'a, 'tcx>(\n         let size = ecx.type_size_with_substs(mir.return_ty, instance.substs)?.expect(\"unsized global\");\n         let align = ecx.type_align_with_substs(mir.return_ty, instance.substs)?;\n         let ptr = ecx.memory.allocate(size, align, Kind::UninitializedStatic)?;\n-        ecx.globals.insert(cid, ptr);\n+        let aligned = !ecx.is_packed(mir.return_ty)?;\n+        ecx.globals.insert(cid, PtrAndAlign { ptr: ptr.into(), aligned });\n         let mutable = !mir.return_ty.is_freeze(\n                 ecx.tcx,\n                 ty::ParamEnv::empty(Reveal::All),\n@@ -57,7 +58,7 @@ pub fn eval_body_as_primval<'a, 'tcx>(\n \n         while ecx.step()? {}\n     }\n-    let value = Value::by_ref(ecx.globals.get(&cid).expect(\"global not cached\").into());\n+    let value = Value::ByRef(*ecx.globals.get(&cid).expect(\"global not cached\"));\n     Ok((ecx.value_to_primval(value, mir.return_ty)?, mir.return_ty))\n }\n "}, {"sha": "9bb276dcc265f7594b7f39463deaad4baea67d4d", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 78, "deletions": 26, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b", "patch": "@@ -7,7 +7,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::middle::region::CodeExtent;\n use rustc::mir;\n use rustc::traits::Reveal;\n-use rustc::ty::layout::{self, Layout, Size, Align};\n+use rustc::ty::layout::{self, Layout, Size, Align, HasDataLayout};\n use rustc::ty::subst::{Subst, Substs, Kind};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Binder};\n use rustc::traits;\n@@ -41,7 +41,7 @@ pub struct EvalContext<'a, 'tcx: 'a, M: Machine<'tcx>> {\n     pub(crate) suspended: HashMap<DynamicLifetime, Vec<ValidationQuery<'tcx>>>,\n \n     /// Precomputed statics, constants and promoteds.\n-    pub globals: HashMap<GlobalId<'tcx>, MemoryPointer>,\n+    pub globals: HashMap<GlobalId<'tcx>, PtrAndAlign>,\n \n     /// The virtual call stack.\n     pub(crate) stack: Vec<Frame<'tcx>>,\n@@ -143,6 +143,25 @@ pub struct TyAndPacked<'tcx> {\n     pub packed: bool,\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub struct PtrAndAlign {\n+    pub ptr: Pointer,\n+    /// Remember whether this lvalue is *supposed* to be aligned.\n+    pub aligned: bool,\n+}\n+\n+impl PtrAndAlign {\n+    pub fn to_ptr<'tcx>(self) -> EvalResult<'tcx, MemoryPointer> {\n+        self.ptr.to_ptr()\n+    }\n+    pub fn offset<'tcx, C: HasDataLayout>(self, i: u64, cx: C) -> EvalResult<'tcx, Self> {\n+        Ok(PtrAndAlign {\n+            ptr: self.ptr.offset(i, cx)?,\n+            aligned: self.aligned,\n+        })\n+    }\n+}\n+\n impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub fn new(\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -503,7 +522,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     pub fn deallocate_local(&mut self, local: Option<Value>) -> EvalResult<'tcx> {\n-        if let Some(Value::ByRef { ptr, aligned: _ }) = local {\n+        if let Some(Value::ByRef(ptr)) = local {\n             trace!(\"deallocating local\");\n             let ptr = ptr.to_ptr()?;\n             self.memory.dump_alloc(ptr.alloc_id);\n@@ -536,9 +555,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         self.memory.write_uint(discr_dest, discr_val, discr_size)?;\n \n         let dest = Lvalue::Ptr {\n-            ptr: dest_ptr.into(),\n+            ptr: PtrAndAlign {\n+                ptr: dest_ptr.into(),\n+                aligned: true,\n+            },\n             extra: LvalueExtra::DowncastVariant(variant_idx),\n-            aligned: true,\n         };\n \n         self.assign_fields(dest, dest_ty, operands)\n@@ -617,7 +638,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 self.inc_step_counter_and_check_limit(operands.len() as u64)?;\n                 use rustc::ty::layout::Layout::*;\n                 match *dest_layout {\n-                    Univariant { .. } | Array { .. } => {\n+                    Univariant { ref variant, .. } => {\n+                        self.write_maybe_aligned_mut(!variant.packed, |ecx| {\n+                            ecx.assign_fields(dest, dest_ty, operands)\n+                        })?;\n+                    }\n+\n+                    Array { .. } => {\n                         self.assign_fields(dest, dest_ty, operands)?;\n                     }\n \n@@ -664,10 +691,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         }\n                     }\n \n-                    StructWrappedNullablePointer { nndiscr, ref discrfield_source, .. } => {\n+                    StructWrappedNullablePointer { nndiscr, ref discrfield_source, ref nonnull, .. } => {\n                         if let mir::AggregateKind::Adt(_, variant, _, _) = **kind {\n                             if nndiscr == variant as u64 {\n-                                self.assign_fields(dest, dest_ty, operands)?;\n+                                self.write_maybe_aligned_mut(!nonnull.packed, |ecx| {\n+                                    ecx.assign_fields(dest, dest_ty, operands)\n+                                })?;\n                             } else {\n                                 for operand in operands {\n                                     let operand_ty = self.operand_ty(operand);\n@@ -682,7 +711,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                                 let dest = dest.offset(offset.bytes(), &self)?;\n                                 let dest_size = self.type_size(ty)?\n                                     .expect(\"bad StructWrappedNullablePointer discrfield\");\n-                                self.memory.write_int(dest, 0, dest_size)?;\n+                                self.memory.write_maybe_aligned_mut(!nonnull.packed, |mem| {\n+                                    mem.write_int(dest, 0, dest_size)\n+                                })?;\n                             }\n                         } else {\n                             bug!(\"tried to assign {:?} to Layout::RawNullablePointer\", kind);\n@@ -707,12 +738,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         self.assign_fields(dest, dest_ty, operands)?;\n                     }\n \n-                    UntaggedUnion { .. } => {\n+                    UntaggedUnion { ref variants } => {\n                         assert_eq!(operands.len(), 1);\n                         let operand = &operands[0];\n                         let value = self.eval_operand(operand)?;\n                         let value_ty = self.operand_ty(operand);\n-                        self.write_value(value, dest, value_ty)?;\n+                        self.write_maybe_aligned_mut(!variants.packed, |ecx| {\n+                            ecx.write_value(value, dest, value_ty)\n+                        })?;\n                     }\n \n                     _ => {\n@@ -756,12 +789,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let src = self.eval_lvalue(lvalue)?;\n                 // We ignore the alignment of the lvalue here -- special handling for packed structs ends\n                 // at the `&` operator.\n-                let (ptr, extra, _aligned) = self.force_allocation(src)?.to_ptr_extra_aligned();\n+                let (ptr, extra) = self.force_allocation(src)?.to_ptr_extra_aligned();\n \n                 let val = match extra {\n-                    LvalueExtra::None => ptr.to_value(),\n-                    LvalueExtra::Length(len) => ptr.to_value_with_len(len),\n-                    LvalueExtra::Vtable(vtable) => ptr.to_value_with_vtable(vtable),\n+                    LvalueExtra::None => ptr.ptr.to_value(),\n+                    LvalueExtra::Length(len) => ptr.ptr.to_value_with_len(len),\n+                    LvalueExtra::Vtable(vtable) => ptr.ptr.to_value_with_vtable(vtable),\n                     LvalueExtra::DowncastVariant(..) =>\n                         bug!(\"attempted to take a reference to an enum downcast lvalue\"),\n                 };\n@@ -1024,15 +1057,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     Literal::Item { def_id, substs } => {\n                         let instance = self.resolve_associated_const(def_id, substs);\n                         let cid = GlobalId { instance, promoted: None };\n-                        Value::by_ref(self.globals.get(&cid).expect(\"static/const not cached\").into())\n+                        Value::ByRef(*self.globals.get(&cid).expect(\"static/const not cached\"))\n                     }\n \n                     Literal::Promoted { index } => {\n                         let cid = GlobalId {\n                             instance: self.frame().instance,\n                             promoted: Some(index),\n                         };\n-                        Value::by_ref(self.globals.get(&cid).expect(\"promoted not cached\").into())\n+                        Value::ByRef(*self.globals.get(&cid).expect(\"promoted not cached\"))\n                     }\n                 };\n \n@@ -1041,6 +1074,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n+    pub fn read_global_as_value(&self, gid: GlobalId) -> Value {\n+        Value::ByRef(*self.globals.get(&gid).expect(\"global not cached\"))\n+    }\n+\n     pub fn operand_ty(&self, operand: &mir::Operand<'tcx>) -> Ty<'tcx> {\n         self.monomorphize(operand.ty(self.mir(), self.tcx), self.substs())\n     }\n@@ -1052,6 +1089,21 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         Ok(())\n     }\n \n+    pub fn is_packed(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, bool> {\n+        let layout = self.type_layout(ty)?;\n+        use rustc::ty::layout::Layout::*;\n+        Ok(match *layout {\n+            Univariant { ref variant, .. } => variant.packed,\n+\n+            StructWrappedNullablePointer { ref nonnull, .. } => nonnull.packed,\n+\n+            UntaggedUnion { ref variants } => variants.packed,\n+\n+            // can only apply #[repr(packed)] to struct and union\n+            _ => false,\n+        })\n+    }\n+\n     pub fn force_allocation(\n         &mut self,\n         lvalue: Lvalue,\n@@ -1061,8 +1113,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 // -1 since we don't store the return value\n                 match self.stack[frame].locals[local.index() - 1] {\n                     None => return err!(DeadLocal),\n-                    Some(Value::ByRef { ptr, aligned }) => {\n-                        Lvalue::Ptr { ptr, aligned, extra: LvalueExtra::None }\n+                    Some(Value::ByRef(ptr)) => {\n+                        Lvalue::Ptr { ptr, extra: LvalueExtra::None }\n                     },\n                     Some(val) => {\n                         let ty = self.stack[frame].mir.local_decls[local].ty;\n@@ -1083,7 +1135,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     /// ensures this Value is not a ByRef\n     pub(super) fn follow_by_ref_value(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         match value {\n-            Value::ByRef { ptr, aligned } => {\n+            Value::ByRef(PtrAndAlign { ptr, aligned }) => {\n                 self.read_maybe_aligned(aligned, |ectx| ectx.read_value(ptr, ty))\n             }\n             other => Ok(other),\n@@ -1141,7 +1193,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         // correct if we never look at this data with the wrong type.\n \n         match dest {\n-            Lvalue::Ptr { ptr, extra, aligned } => {\n+            Lvalue::Ptr { ptr: PtrAndAlign { ptr, aligned }, extra } => {\n                 assert_eq!(extra, LvalueExtra::None);\n                 self.write_maybe_aligned_mut(aligned,\n                     |ectx| ectx.write_value_to_ptr(src_val, ptr, dest_ty))\n@@ -1167,7 +1219,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         old_dest_val: Value,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        if let Value::ByRef { ptr: dest_ptr, aligned } = old_dest_val {\n+        if let Value::ByRef(PtrAndAlign { ptr: dest_ptr, aligned }) = old_dest_val {\n             // If the value is already `ByRef` (that is, backed by an `Allocation`),\n             // then we must write the new value into this allocation, because there may be\n             // other pointers into the allocation. These other pointers are logically\n@@ -1178,7 +1230,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             self.write_maybe_aligned_mut(aligned,\n                 |ectx| ectx.write_value_to_ptr(src_val, dest_ptr, dest_ty))?;\n \n-        } else if let Value::ByRef { ptr: src_ptr, aligned } = src_val {\n+        } else if let Value::ByRef(PtrAndAlign { ptr: src_ptr, aligned }) = src_val {\n             // If the value is not `ByRef`, then we know there are no pointers to it\n             // and we can simply overwrite the `Value` in the locals array directly.\n             //\n@@ -1216,7 +1268,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         match value {\n-            Value::ByRef { ptr, aligned } => {\n+            Value::ByRef(PtrAndAlign { ptr, aligned }) => {\n                 self.read_maybe_aligned_mut(aligned, |ectx| ectx.copy(ptr, dest, dest_ty))\n             },\n             Value::ByVal(primval) => {\n@@ -1551,7 +1603,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 //let src = adt::MaybeSizedValue::sized(src);\n                 //let dst = adt::MaybeSizedValue::sized(dst);\n                 let src_ptr = match src {\n-                    Value::ByRef { ptr, aligned: true } => ptr,\n+                    Value::ByRef(PtrAndAlign { ptr, aligned: true }) => ptr,\n                     // TODO: Is it possible for unaligned pointers to occur here?\n                     _ => bug!(\"expected aligned pointer, got {:?}\", src),\n                 };\n@@ -1598,7 +1650,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 Err(err) => {\n                     panic!(\"Failed to access local: {:?}\", err);\n                 }\n-                Ok(Value::ByRef { ptr, aligned }) => match ptr.into_inner_primval() {\n+                Ok(Value::ByRef(PtrAndAlign{ ptr, aligned })) => match ptr.into_inner_primval() {\n                     PrimVal::Ptr(ptr) => {\n                         write!(msg, \" by {}ref:\", if aligned { \"\" } else { \"unaligned \" }).unwrap();\n                         allocs.push(ptr.alloc_id);"}, {"sha": "02af68d384f835778ff1e29095a17135ab332691", "filename": "src/librustc_mir/interpret/lvalue.rs", "status": "modified", "additions": 37, "deletions": 31, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs?ref=8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b", "patch": "@@ -9,6 +9,7 @@ use super::{\n     MemoryPointer,\n     PrimVal, Value, Pointer,\n     Machine,\n+    PtrAndAlign,\n };\n \n #[derive(Copy, Clone, Debug)]\n@@ -18,10 +19,8 @@ pub enum Lvalue {\n         /// An lvalue may have an invalid (integral or undef) pointer,\n         /// since it might be turned back into a reference\n         /// before ever being dereferenced.\n-        ptr: Pointer,\n+        ptr: PtrAndAlign,\n         extra: LvalueExtra,\n-        /// Remember whether this lvalue is *supposed* to be aligned.\n-        aligned: bool,\n     },\n \n     /// An lvalue referring to a value on the stack. Represented by a stack frame index paired with\n@@ -58,23 +57,23 @@ impl<'tcx> Lvalue {\n     }\n \n     pub fn from_primval_ptr(ptr: Pointer) -> Self {\n-        Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned: true }\n+        Lvalue::Ptr { ptr: PtrAndAlign { ptr, aligned: true }, extra: LvalueExtra::None }\n     }\n \n     pub fn from_ptr(ptr: MemoryPointer) -> Self {\n         Self::from_primval_ptr(ptr.into())\n     }\n \n-    pub(super) fn to_ptr_extra_aligned(self) -> (Pointer, LvalueExtra, bool) {\n+    pub(super) fn to_ptr_extra_aligned(self) -> (PtrAndAlign, LvalueExtra) {\n         match self {\n-            Lvalue::Ptr { ptr, extra, aligned } => (ptr, extra, aligned),\n+            Lvalue::Ptr { ptr, extra } => (ptr, extra),\n             _ => bug!(\"to_ptr_and_extra: expected Lvalue::Ptr, got {:?}\", self),\n \n         }\n     }\n \n     pub fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n-        let (ptr, extra, _aligned) = self.to_ptr_extra_aligned();\n+        let (ptr, extra) = self.to_ptr_extra_aligned();\n         // At this point, we forget about the alignment information -- the lvalue has been turned into a reference,\n         // and no matter where it came from, it now must be aligned.\n         assert_eq!(extra, LvalueExtra::None);\n@@ -111,7 +110,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             Static(ref static_) => {\n                 let instance = ty::Instance::mono(self.tcx, static_.def_id);\n                 let cid = GlobalId { instance, promoted: None };\n-                Ok(Some(Value::by_ref(self.globals.get(&cid).expect(\"global not cached\").into())))\n+                Ok(Some(Value::ByRef(*self.globals.get(&cid).expect(\"global not cached\"))))\n             },\n             Projection(ref proj) => self.try_read_lvalue_projection(proj),\n         }\n@@ -161,9 +160,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     pub fn read_lvalue(&self, lvalue: Lvalue) -> EvalResult<'tcx, Value> {\n         match lvalue {\n-            Lvalue::Ptr { ptr, extra, aligned } => {\n+            Lvalue::Ptr { ptr, extra } => {\n                 assert_eq!(extra, LvalueExtra::None);\n-                Ok(Value::ByRef { ptr, aligned })\n+                Ok(Value::ByRef(ptr))\n             }\n             Lvalue::Local { frame, local } => {\n                 self.stack[frame].get_local(local)\n@@ -180,7 +179,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             Static(ref static_) => {\n                 let instance = ty::Instance::mono(self.tcx, static_.def_id);\n                 let gid = GlobalId { instance, promoted: None };\n-                Lvalue::from_ptr(*self.globals.get(&gid).expect(\"uncached global\"))\n+                Lvalue::Ptr {\n+                    ptr: *self.globals.get(&gid).expect(\"uncached global\"),\n+                    extra: LvalueExtra::None,\n+                }\n             }\n \n             Projection(ref proj) => {\n@@ -212,10 +214,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             },\n \n             General { ref variants, .. } => {\n-                let (_, base_extra, _) = base.to_ptr_extra_aligned();\n+                let (_, base_extra) = base.to_ptr_extra_aligned();\n                 if let LvalueExtra::DowncastVariant(variant_idx) = base_extra {\n                     // +1 for the discriminant, which is field 0\n-                    (variants[variant_idx].offsets[field_index + 1], variants[variant_idx].packed)\n+                    assert!(!variants[variant_idx].packed);\n+                    (variants[variant_idx].offsets[field_index + 1], false)\n                 } else {\n                     bug!(\"field access on enum had no variant index\");\n                 }\n@@ -262,8 +265,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         };\n \n         // Do not allocate in trivial cases\n-        let (base_ptr, base_extra, aligned) = match base {\n-            Lvalue::Ptr { ptr, extra, aligned } => (ptr, extra, aligned),\n+        let (base_ptr, base_extra) = match base {\n+            Lvalue::Ptr { ptr, extra } => (ptr, extra),\n             Lvalue::Local { frame, local } => match self.stack[frame].get_local(local)? {\n                 // in case the type has a single field, just return the value\n                 Value::ByVal(_) if self.get_field_count(base_ty).map(|c| c == 1).unwrap_or(false) => {\n@@ -278,13 +281,16 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n         let offset = match base_extra {\n             LvalueExtra::Vtable(tab) => {\n-                let (_, align) = self.size_and_align_of_dst(base_ty, base_ptr.to_value_with_vtable(tab))?;\n+                let (_, align) = self.size_and_align_of_dst(base_ty, base_ptr.ptr.to_value_with_vtable(tab))?;\n                 offset.abi_align(Align::from_bytes(align, align).unwrap()).bytes()\n             }\n             _ => offset.bytes(),\n         };\n \n-        let ptr = base_ptr.offset(offset, &self)?;\n+        let mut ptr = base_ptr.offset(offset, &self)?;\n+        // if we were unaligned, stay unaligned\n+        // no matter what we were, if we are packed, we must not be aligned anymore\n+        ptr.aligned &= !packed;\n \n         let field_ty = self.monomorphize(field_ty, self.substs());\n \n@@ -301,33 +307,33 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             base_extra\n         };\n \n-        Ok(Lvalue::Ptr { ptr, extra, aligned: aligned && !packed })\n+        Ok(Lvalue::Ptr { ptr, extra } )\n     }\n \n     pub(super) fn val_to_lvalue(&self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Lvalue> {\n         Ok(match self.tcx.struct_tail(ty).sty {\n             ty::TyDynamic(..) => {\n                 let (ptr, vtable) = val.into_ptr_vtable_pair(&self.memory)?;\n-                Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable), aligned: true }\n+                Lvalue::Ptr { ptr: PtrAndAlign { ptr, aligned: true }, extra: LvalueExtra::Vtable(vtable) }\n             },\n             ty::TyStr | ty::TySlice(_) => {\n                 let (ptr, len) = val.into_slice(&self.memory)?;\n-                Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len), aligned: true }\n+                Lvalue::Ptr { ptr: PtrAndAlign { ptr, aligned: true }, extra: LvalueExtra::Length(len) }\n             },\n-            _ => Lvalue::Ptr { ptr: val.into_ptr(&self.memory)?, extra: LvalueExtra::None, aligned: true },\n+            _ => Lvalue::from_primval_ptr(val.into_ptr(&self.memory)?),\n         })\n     }\n \n     pub(super) fn lvalue_index(&mut self, base: Lvalue, outer_ty: Ty<'tcx>, n: u64) -> EvalResult<'tcx, Lvalue> {\n         // Taking the outer type here may seem odd; it's needed because for array types, the outer type gives away the length.\n         let base = self.force_allocation(base)?;\n-        let (base_ptr, _, aligned) = base.to_ptr_extra_aligned();\n+        let (base_ptr, _) = base.to_ptr_extra_aligned();\n \n         let (elem_ty, len) = base.elem_ty_and_len(outer_ty);\n         let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n         assert!(n < len, \"Tried to access element {} of array/slice with length {}\", n, len);\n         let ptr = base_ptr.offset(n * elem_size, self.memory.layout)?;\n-        Ok(Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned })\n+        Ok(Lvalue::Ptr { ptr, extra: LvalueExtra::None })\n     }\n \n     pub(super) fn eval_lvalue_projection(\n@@ -337,7 +343,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         proj_elem: &mir::ProjectionElem<'tcx, mir::Operand<'tcx>, Ty<'tcx>>,\n     ) -> EvalResult<'tcx, Lvalue> {\n         use rustc::mir::ProjectionElem::*;\n-        let (ptr, extra, aligned) = match *proj_elem {\n+        let (ptr, extra) = match *proj_elem {\n             Field(field, field_ty) => {\n                 return self.lvalue_field(base, field.index(), base_ty, field_ty);\n             }\n@@ -346,15 +352,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let base_layout = self.type_layout(base_ty)?;\n                 // FIXME(solson)\n                 let base = self.force_allocation(base)?;\n-                let (base_ptr, base_extra, aligned) = base.to_ptr_extra_aligned();\n+                let (base_ptr, base_extra) = base.to_ptr_extra_aligned();\n \n                 use rustc::ty::layout::Layout::*;\n                 let extra = match *base_layout {\n                     General { .. } => LvalueExtra::DowncastVariant(variant),\n                     RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => base_extra,\n                     _ => bug!(\"variant downcast on non-aggregate: {:?}\", base_layout),\n                 };\n-                (base_ptr, extra, aligned)\n+                (base_ptr, extra)\n             }\n \n             Deref => {\n@@ -383,7 +389,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             ConstantIndex { offset, min_length, from_end } => {\n                 // FIXME(solson)\n                 let base = self.force_allocation(base)?;\n-                let (base_ptr, _, aligned) = base.to_ptr_extra_aligned();\n+                let (base_ptr, _) = base.to_ptr_extra_aligned();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n                 let elem_size = self.type_size(elem_ty)?.expect(\"sequence element must be sized\");\n@@ -396,24 +402,24 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 };\n \n                 let ptr = base_ptr.offset(index * elem_size, &self)?;\n-                (ptr, LvalueExtra::None, aligned)\n+                (ptr, LvalueExtra::None)\n             }\n \n             Subslice { from, to } => {\n                 // FIXME(solson)\n                 let base = self.force_allocation(base)?;\n-                let (base_ptr, _, aligned) = base.to_ptr_extra_aligned();\n+                let (base_ptr, _) = base.to_ptr_extra_aligned();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n                 let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n                 assert!(u64::from(from) <= n - u64::from(to));\n                 let ptr = base_ptr.offset(u64::from(from) * elem_size, &self)?;\n                 let extra = LvalueExtra::Length(n - u64::from(to) - u64::from(from));\n-                (ptr, extra, aligned)\n+                (ptr, extra)\n             }\n         };\n \n-        Ok(Lvalue::Ptr { ptr, extra, aligned })\n+        Ok(Lvalue::Ptr { ptr, extra })\n     }\n \n     pub(super) fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {"}, {"sha": "a4c317056118f9064616f5455b8f809b26eba4f8", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b", "patch": "@@ -33,6 +33,7 @@ pub use self::eval_context::{\n     StackPopCleanup,\n     DynamicLifetime,\n     TyAndPacked,\n+    PtrAndAlign,\n };\n \n pub use self::lvalue::{"}, {"sha": "e275a4e0a35ced30a4cfb9526485e2e4fab4c548", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b", "patch": "@@ -13,7 +13,7 @@ use rustc::ty::subst::Substs;\n \n use super::{\n     EvalResult,\n-    EvalContext, StackPopCleanup, TyAndPacked,\n+    EvalContext, StackPopCleanup, TyAndPacked, PtrAndAlign,\n     GlobalId, Lvalue,\n     HasMemory, Kind,\n     Machine,\n@@ -182,14 +182,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             let ptr = self.memory.allocate(ptr_size, ptr_size, Kind::UninitializedStatic)?;\n             self.memory.write_usize(ptr, 0)?;\n             self.memory.mark_static_initalized(ptr.alloc_id, mutability)?;\n-            self.globals.insert(cid, ptr);\n+            self.globals.insert(cid, PtrAndAlign { ptr: ptr.into(), aligned: true });\n             return Ok(false);\n         }\n         let mir = self.load_mir(instance.def)?;\n         let size = self.type_size_with_substs(mir.return_ty, substs)?.expect(\"unsized global\");\n         let align = self.type_align_with_substs(mir.return_ty, substs)?;\n         let ptr = self.memory.allocate(size, align, Kind::UninitializedStatic)?;\n-        self.globals.insert(cid, ptr);\n+        let aligned = !self.is_packed(mir.return_ty)?;\n+        self.globals.insert(cid, PtrAndAlign { ptr: ptr.into(), aligned });\n         let internally_mutable = !mir.return_ty.is_freeze(\n                 self.tcx,\n                 ty::ParamEnv::empty(Reveal::All),\n@@ -265,7 +266,8 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n                     let size = this.ecx.type_size_with_substs(mir.return_ty, this.instance.substs)?.expect(\"unsized global\");\n                     let align = this.ecx.type_align_with_substs(mir.return_ty, this.instance.substs)?;\n                     let ptr = this.ecx.memory.allocate(size, align, Kind::UninitializedStatic)?;\n-                    this.ecx.globals.insert(cid, ptr);\n+                    let aligned = !this.ecx.is_packed(mir.return_ty)?;\n+                    this.ecx.globals.insert(cid, PtrAndAlign { ptr: ptr.into(), aligned });\n                     trace!(\"pushing stack frame for {:?}\", index);\n                     this.ecx.push_stack_frame(this.instance,\n                                               constant.span,"}, {"sha": "36d56511afc5362becdac235b39fc60cefde8948", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b", "patch": "@@ -17,9 +17,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         // However, unaligned accesses will probably make the actual drop implementation fail -- a problem shared\n         // by rustc.\n         let val = match self.force_allocation(lval)? {\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable), aligned: _ } => ptr.to_value_with_vtable(vtable),\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len), aligned: _ } => ptr.to_value_with_len(len),\n-            Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned: _ } => ptr.to_value(),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } => ptr.ptr.to_value_with_vtable(vtable),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => ptr.ptr.to_value_with_len(len),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::None } => ptr.ptr.to_value(),\n             _ => bug!(\"force_allocation broken\"),\n         };\n         self.drop(val, instance, ty, span)"}, {"sha": "531e1792d9e79d52777ce1083254c7091c42d363", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b", "patch": "@@ -6,7 +6,7 @@ use syntax::abi::Abi;\n \n use super::{\n     EvalError, EvalResult, EvalErrorKind,\n-    EvalContext, eval_context, TyAndPacked,\n+    EvalContext, eval_context, TyAndPacked, PtrAndAlign,\n     Lvalue,\n     MemoryPointer,\n     PrimVal, Value,\n@@ -311,10 +311,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                             if self.frame().mir.args_iter().count() == fields.len() + 1 {\n                                 let offsets = variant.offsets.iter().map(|s| s.bytes());\n                                 match arg_val {\n-                                    Value::ByRef { ptr, aligned } => {\n+                                    Value::ByRef(PtrAndAlign { ptr, aligned }) => {\n                                         assert!(aligned, \"Unaligned ByRef-values cannot occur as function arguments\");\n                                         for ((offset, ty), arg_local) in offsets.zip(fields).zip(arg_locals) {\n-                                            let arg = Value::ByRef { ptr: ptr.offset(offset, &self)?, aligned: true};\n+                                            let arg = Value::by_ref(ptr.offset(offset, &self)?);\n                                             let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n                                             trace!(\"writing arg {:?} to {:?} (type: {})\", arg, dest, ty);\n                                             self.write_value(arg, dest, ty)?;"}, {"sha": "b291c639b9ca2f31bf11106d24a69c994f5ff2c7", "filename": "src/librustc_mir/interpret/validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b", "patch": "@@ -213,7 +213,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         };\n         if is_owning {\n             match query.lval {\n-                Lvalue::Ptr { ptr, extra, aligned: _ } => {\n+                Lvalue::Ptr { ptr, extra } => {\n                     // Determine the size\n                     // FIXME: Can we reuse size_and_align_of_dst for Lvalues?\n                     let len = match self.type_size(query.ty)? {"}, {"sha": "be6d304d3f5865ec76135f3909cd2427775859f0", "filename": "src/librustc_mir/interpret/value.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs?ref=8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b", "patch": "@@ -7,6 +7,7 @@ use super::{\n     EvalResult,\n     Memory, MemoryPointer, HasMemory, PointerArithmetic,\n     Machine,\n+    PtrAndAlign,\n };\n \n pub(super) fn bytes_to_f32(bytes: u128) -> f32 {\n@@ -36,7 +37,7 @@ pub(super) fn f64_to_bytes(f: f64) -> u128 {\n /// operations and fat pointers. This idea was taken from rustc's trans.\n #[derive(Clone, Copy, Debug)]\n pub enum Value {\n-    ByRef { ptr: Pointer, aligned: bool},\n+    ByRef(PtrAndAlign),\n     ByVal(PrimVal),\n     ByValPair(PrimVal, PrimVal),\n }\n@@ -133,12 +134,6 @@ impl ::std::convert::From<MemoryPointer> for Pointer {\n     }\n }\n \n-impl<'a> ::std::convert::From<&'a MemoryPointer> for Pointer {\n-    fn from(ptr: &'a MemoryPointer) -> Self {\n-        PrimVal::Ptr(*ptr).into()\n-    }\n-}\n-\n /// A `PrimVal` represents an immediate, primitive value existing outside of a\n /// `memory::Allocation`. It is in many ways like a small chunk of a `Allocation`, up to 8 bytes in\n /// size. Like a range of bytes in an `Allocation`, a `PrimVal` can either represent the raw bytes\n@@ -172,15 +167,15 @@ pub enum PrimValKind {\n impl<'a, 'tcx: 'a> Value {\n     #[inline]\n     pub fn by_ref(ptr: Pointer) -> Self {\n-        Value::ByRef { ptr, aligned: true }\n+        Value::ByRef(PtrAndAlign { ptr, aligned: true })\n     }\n \n     /// Convert the value into a pointer (or a pointer-sized integer).  If the value is a ByRef,\n     /// this may have to perform a load.\n     pub fn into_ptr<M: Machine<'tcx>>(&self, mem: &Memory<'a, 'tcx, M>) -> EvalResult<'tcx, Pointer> {\n         use self::Value::*;\n         match *self {\n-            ByRef { ptr, aligned } => {\n+            ByRef(PtrAndAlign { ptr, aligned }) => {\n                 mem.read_maybe_aligned(aligned, |mem| mem.read_ptr(ptr.to_ptr()?) )\n             },\n             ByVal(ptr) | ByValPair(ptr, _) => Ok(ptr.into()),\n@@ -193,7 +188,7 @@ impl<'a, 'tcx: 'a> Value {\n     ) -> EvalResult<'tcx, (Pointer, MemoryPointer)> {\n         use self::Value::*;\n         match *self {\n-            ByRef { ptr: ref_ptr, aligned } => {\n+            ByRef(PtrAndAlign { ptr: ref_ptr, aligned }) => {\n                 mem.read_maybe_aligned(aligned, |mem| {\n                     let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n                     let vtable = mem.read_ptr(ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?)?;\n@@ -211,7 +206,7 @@ impl<'a, 'tcx: 'a> Value {\n     pub(super) fn into_slice<M: Machine<'tcx>>(&self, mem: &Memory<'a, 'tcx, M>) -> EvalResult<'tcx, (Pointer, u64)> {\n         use self::Value::*;\n         match *self {\n-            ByRef { ptr: ref_ptr, aligned } => {\n+            ByRef(PtrAndAlign { ptr: ref_ptr, aligned } ) => {\n                 mem.read_maybe_aligned(aligned, |mem| {\n                     let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n                     let len = mem.read_usize(ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?)?;"}, {"sha": "1fa3a369670bbc2512f063a5b158fc8394b88e27", "filename": "tests/run-pass/packed_static.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/tests%2Frun-pass%2Fpacked_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b/tests%2Frun-pass%2Fpacked_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpacked_static.rs?ref=8ab1eeef51e9e9e2db84d3f50396d67b78a0ab9b", "patch": "@@ -0,0 +1,10 @@\n+#[repr(packed)]\n+struct Foo {\n+    i: i32\n+}\n+\n+fn main() {\n+    assert_eq!({FOO.i}, 42);\n+}\n+\n+static FOO: Foo = Foo { i: 42 };"}]}