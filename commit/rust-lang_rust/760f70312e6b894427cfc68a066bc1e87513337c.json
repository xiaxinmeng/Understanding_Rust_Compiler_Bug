{"sha": "760f70312e6b894427cfc68a066bc1e87513337c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2MGY3MDMxMmU2Yjg5NDQyN2NmYzY4YTA2NmJjMWU4NzUxMzMzN2M=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-04-15T16:20:43Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-05-18T15:45:51Z"}, "message": "Improve `multiple_inherent_impl` lint\nTreat different generic arguments as different types.\nAllow the lint to be ignored on the type definition, or any impl blocks.", "tree": {"sha": "cf223be033deee4a5d88dd114e495bbef612c442", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf223be033deee4a5d88dd114e495bbef612c442"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/760f70312e6b894427cfc68a066bc1e87513337c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmCj4W0ACgkQ2lnoZDo37QYRhAD8C42Qj4Z0+DQZDL3N9xNOY0yX\nf1xj/BnmyqXqu3hKC/IBALsjQHWIY+3to1b1gaBbppPPck/FpN/Ykd0HscdpfIYF\n=YynN\n-----END PGP SIGNATURE-----", "payload": "tree cf223be033deee4a5d88dd114e495bbef612c442\nparent b1c675f3fc682201cdb28719133285b878e2d157\nauthor Jason Newcomb <jsnewcomb@pm.me> 1618503643 -0400\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1621352751 -0400\n\nImprove `multiple_inherent_impl` lint\nTreat different generic arguments as different types.\nAllow the lint to be ignored on the type definition, or any impl blocks.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/760f70312e6b894427cfc68a066bc1e87513337c", "html_url": "https://github.com/rust-lang/rust/commit/760f70312e6b894427cfc68a066bc1e87513337c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/760f70312e6b894427cfc68a066bc1e87513337c/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1c675f3fc682201cdb28719133285b878e2d157", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1c675f3fc682201cdb28719133285b878e2d157", "html_url": "https://github.com/rust-lang/rust/commit/b1c675f3fc682201cdb28719133285b878e2d157"}], "stats": {"total": 200, "additions": 154, "deletions": 46}, "files": [{"sha": "980bcc78f5d0cd3e2df7a019172920a693277be9", "filename": "clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 93, "deletions": 44, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/760f70312e6b894427cfc68a066bc1e87513337c/clippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760f70312e6b894427cfc68a066bc1e87513337c/clippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_impl.rs?ref=760f70312e6b894427cfc68a066bc1e87513337c", "patch": "@@ -1,12 +1,16 @@\n //! lint on inherent implementations\n \n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::in_macro;\n-use rustc_hir::def_id::DefIdMap;\n-use rustc_hir::{def_id, Crate, Impl, Item, ItemKind};\n+use clippy_utils::diagnostics::span_lint_and_note;\n+use clippy_utils::{in_macro, is_allowed};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::{\n+    def_id::{LocalDefId, LOCAL_CRATE},\n+    Crate, Item, ItemKind, Node,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::Span;\n+use std::collections::hash_map::Entry;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for multiple inherent implementations of a struct\n@@ -40,51 +44,96 @@ declare_clippy_lint! {\n     \"Multiple inherent impl that could be grouped\"\n }\n \n-#[allow(clippy::module_name_repetitions)]\n-#[derive(Default)]\n-pub struct MultipleInherentImpl {\n-    impls: DefIdMap<Span>,\n-}\n-\n-impl_lint_pass!(MultipleInherentImpl => [MULTIPLE_INHERENT_IMPL]);\n+declare_lint_pass!(MultipleInherentImpl => [MULTIPLE_INHERENT_IMPL]);\n \n impl<'tcx> LateLintPass<'tcx> for MultipleInherentImpl {\n-    fn check_item(&mut self, _: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if let ItemKind::Impl(Impl {\n-            ref generics,\n-            of_trait: None,\n-            ..\n-        }) = item.kind\n+    fn check_crate_post(&mut self, cx: &LateContext<'tcx>, _: &'tcx Crate<'_>) {\n+        // Map from a type to it's first impl block. Needed to distinguish generic arguments.\n+        // e.g. `Foo<Bar>` and `Foo<Baz>`\n+        let mut type_map = FxHashMap::default();\n+        // List of spans to lint. (lint_span, first_span)\n+        let mut lint_spans = Vec::new();\n+\n+        for (_, impl_ids) in cx\n+            .tcx\n+            .crate_inherent_impls(LOCAL_CRATE)\n+            .inherent_impls\n+            .iter()\n+            .filter(|(id, impls)| {\n+                impls.len() > 1\n+                    // Check for `#[allow]` on the type definition\n+                    && !is_allowed(\n+                        cx,\n+                        MULTIPLE_INHERENT_IMPL,\n+                        cx.tcx.hir().local_def_id_to_hir_id(id.expect_local()),\n+                    )\n+            })\n         {\n-            // Remember for each inherent implementation encountered its span and generics\n-            // but filter out implementations that have generic params (type or lifetime)\n-            // or are derived from a macro\n-            if !in_macro(item.span) && generics.params.is_empty() {\n-                self.impls.insert(item.def_id.to_def_id(), item.span);\n+            for impl_id in impl_ids.iter().map(|id| id.expect_local()) {\n+                match type_map.entry(cx.tcx.type_of(impl_id)) {\n+                    Entry::Vacant(e) => {\n+                        // Store the id for the first impl block of this type. The span is retrieved lazily.\n+                        e.insert(IdOrSpan::Id(impl_id));\n+                    },\n+                    Entry::Occupied(mut e) => {\n+                        if let Some(span) = get_impl_span(cx, impl_id) {\n+                            let first_span = match *e.get() {\n+                                IdOrSpan::Span(s) => s,\n+                                IdOrSpan::Id(id) => {\n+                                    if let Some(s) = get_impl_span(cx, id) {\n+                                        // Remember the span of the first block.\n+                                        *e.get_mut() = IdOrSpan::Span(s);\n+                                        s\n+                                    } else {\n+                                        // The first impl block isn't considered by the lint. Replace it with the\n+                                        // current one.\n+                                        *e.get_mut() = IdOrSpan::Span(span);\n+                                        continue;\n+                                    }\n+                                },\n+                            };\n+                            lint_spans.push((span, first_span));\n+                        }\n+                    },\n+                }\n             }\n+\n+            // Switching to the next type definition, no need to keep the current entries around.\n+            type_map.clear();\n         }\n-    }\n \n-    fn check_crate_post(&mut self, cx: &LateContext<'tcx>, krate: &'tcx Crate<'_>) {\n-        if !krate.items.is_empty() {\n-            // Retrieve all inherent implementations from the crate, grouped by type\n-            for impls in cx.tcx.crate_inherent_impls(def_id::LOCAL_CRATE).inherent_impls.values() {\n-                // Filter out implementations that have generic params (type or lifetime)\n-                let mut impl_spans = impls.iter().filter_map(|impl_def| self.impls.get(impl_def));\n-                if let Some(initial_span) = impl_spans.next() {\n-                    impl_spans.for_each(|additional_span| {\n-                        span_lint_and_then(\n-                            cx,\n-                            MULTIPLE_INHERENT_IMPL,\n-                            *additional_span,\n-                            \"multiple implementations of this structure\",\n-                            |diag| {\n-                                diag.span_note(*initial_span, \"first implementation here\");\n-                            },\n-                        )\n-                    })\n-                }\n-            }\n+        // `TyCtxt::crate_inherent_impls` doesn't have a defined order. Sort the lint output first.\n+        lint_spans.sort_by_key(|x| x.0.lo());\n+        for (span, first_span) in lint_spans {\n+            span_lint_and_note(\n+                cx,\n+                MULTIPLE_INHERENT_IMPL,\n+                span,\n+                \"multiple implementations of this structure\",\n+                Some(first_span),\n+                \"first implementation here\",\n+            );\n         }\n     }\n }\n+\n+/// Gets the span for the given impl block unless it's not being considered by the lint.\n+fn get_impl_span(cx: &LateContext<'_>, id: LocalDefId) -> Option<Span> {\n+    let id = cx.tcx.hir().local_def_id_to_hir_id(id);\n+    if let Node::Item(&Item {\n+        kind: ItemKind::Impl(ref impl_item),\n+        span,\n+        ..\n+    }) = cx.tcx.hir().get(id)\n+    {\n+        (!in_macro(span) && impl_item.generics.params.is_empty() && !is_allowed(cx, MULTIPLE_INHERENT_IMPL, id))\n+            .then(|| span)\n+    } else {\n+        None\n+    }\n+}\n+\n+enum IdOrSpan {\n+    Id(LocalDefId),\n+    Span(Span),\n+}"}, {"sha": "47c576bac4869c83680a602edfff32e98ec59446", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/760f70312e6b894427cfc68a066bc1e87513337c/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760f70312e6b894427cfc68a066bc1e87513337c/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=760f70312e6b894427cfc68a066bc1e87513337c", "patch": "@@ -1154,7 +1154,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| box suspicious_operation_groupings::SuspiciousOperationGroupings);\n     store.register_late_pass(|| box suspicious_trait_impl::SuspiciousImpl);\n     store.register_late_pass(|| box map_unit_fn::MapUnit);\n-    store.register_late_pass(|| box inherent_impl::MultipleInherentImpl::default());\n+    store.register_late_pass(|| box inherent_impl::MultipleInherentImpl);\n     store.register_late_pass(|| box neg_cmp_op_on_partial_ord::NoNegCompOpForPartialOrd);\n     store.register_late_pass(|| box unwrap::Unwrap);\n     store.register_late_pass(|| box duration_subsec::DurationSubsec);"}, {"sha": "39443775015365d7197d1fb036b4b35bd66bdb4f", "filename": "tests/ui/impl.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/760f70312e6b894427cfc68a066bc1e87513337c/tests%2Fui%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/760f70312e6b894427cfc68a066bc1e87513337c/tests%2Fui%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl.rs?ref=760f70312e6b894427cfc68a066bc1e87513337c", "patch": "@@ -33,4 +33,35 @@ impl fmt::Debug for MyStruct {\n     }\n }\n \n+// issue #5772\n+struct WithArgs<T>(T);\n+impl WithArgs<u32> {\n+    fn f1() {}\n+}\n+impl WithArgs<u64> {\n+    fn f2() {}\n+}\n+impl WithArgs<u64> {\n+    fn f3() {}\n+}\n+\n+// Ok, the struct is allowed to have multiple impls.\n+#[allow(clippy::multiple_inherent_impl)]\n+struct Allowed;\n+impl Allowed {}\n+impl Allowed {}\n+impl Allowed {}\n+\n+struct AllowedImpl;\n+#[allow(clippy::multiple_inherent_impl)]\n+impl AllowedImpl {}\n+// Ok, the first block is skipped by this lint.\n+impl AllowedImpl {}\n+\n+struct OneAllowedImpl;\n+impl OneAllowedImpl {}\n+#[allow(clippy::multiple_inherent_impl)]\n+impl OneAllowedImpl {}\n+impl OneAllowedImpl {} // Lint, only one of the three blocks is allowed.\n+\n fn main() {}"}, {"sha": "8703ecac93e898f16e63cd47ef979c096414bbb7", "filename": "tests/ui/impl.stderr", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/760f70312e6b894427cfc68a066bc1e87513337c/tests%2Fui%2Fimpl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/760f70312e6b894427cfc68a066bc1e87513337c/tests%2Fui%2Fimpl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl.stderr?ref=760f70312e6b894427cfc68a066bc1e87513337c", "patch": "@@ -31,5 +31,33 @@ LL | |     fn first() {}\n LL | | }\n    | |_^\n \n-error: aborting due to 2 previous errors\n+error: multiple implementations of this structure\n+  --> $DIR/impl.rs:44:1\n+   |\n+LL | / impl WithArgs<u64> {\n+LL | |     fn f3() {}\n+LL | | }\n+   | |_^\n+   |\n+note: first implementation here\n+  --> $DIR/impl.rs:41:1\n+   |\n+LL | / impl WithArgs<u64> {\n+LL | |     fn f2() {}\n+LL | | }\n+   | |_^\n+\n+error: multiple implementations of this structure\n+  --> $DIR/impl.rs:65:1\n+   |\n+LL | impl OneAllowedImpl {} // Lint, only one of the three blocks is allowed.\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: first implementation here\n+  --> $DIR/impl.rs:62:1\n+   |\n+LL | impl OneAllowedImpl {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n "}]}