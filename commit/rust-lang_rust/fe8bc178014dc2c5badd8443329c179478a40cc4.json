{"sha": "fe8bc178014dc2c5badd8443329c179478a40cc4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlOGJjMTc4MDE0ZGMyYzViYWRkODQ0MzMyOWMxNzk0NzhhNDBjYzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-28T20:11:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-28T20:11:34Z"}, "message": "auto merge of #15208 : alexcrichton/rust/snapshots, r=pcwalton\n\nThis change registers new snapshots, allowing `*T` to be removed from the language. This is a large breaking change, and it is recommended that if compiler errors are seen that any FFI calls are audited to determine whether they should be actually taking `*mut T`.", "tree": {"sha": "b5bfc8f15cc996fe751306924595f81bcc558a27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5bfc8f15cc996fe751306924595f81bcc558a27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe8bc178014dc2c5badd8443329c179478a40cc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe8bc178014dc2c5badd8443329c179478a40cc4", "html_url": "https://github.com/rust-lang/rust/commit/fe8bc178014dc2c5badd8443329c179478a40cc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe8bc178014dc2c5badd8443329c179478a40cc4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de337f3ddfbef800a8cf731e0b593e341af1e3e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/de337f3ddfbef800a8cf731e0b593e341af1e3e5", "html_url": "https://github.com/rust-lang/rust/commit/de337f3ddfbef800a8cf731e0b593e341af1e3e5"}, {"sha": "0dfc90ab15475aa64bea393671463a8e9784ae3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dfc90ab15475aa64bea393671463a8e9784ae3f", "html_url": "https://github.com/rust-lang/rust/commit/0dfc90ab15475aa64bea393671463a8e9784ae3f"}], "stats": {"total": 3494, "additions": 1811, "deletions": 1683}, "files": [{"sha": "9eac38e4cd5b7cb77e70cc03e65fde68c64c45db", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -42,7 +42,7 @@ pub mod common;\n pub mod errors;\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int {\n+fn start(argc: int, argv: *const *const u8) -> int {\n     green::start(argc, argv, rustuv::event_loop, main)\n }\n "}, {"sha": "bba9594afeb6d6bf71f017560ae85f5e1fe48f38", "filename": "src/doc/guide-ffi.md", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fdoc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fdoc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ffi.md?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -50,19 +50,19 @@ use libc::{c_int, size_t};\n \n #[link(name = \"snappy\")]\n extern {\n-    fn snappy_compress(input: *u8,\n+    fn snappy_compress(input: *const u8,\n                        input_length: size_t,\n                        compressed: *mut u8,\n                        compressed_length: *mut size_t) -> c_int;\n-    fn snappy_uncompress(compressed: *u8,\n+    fn snappy_uncompress(compressed: *const u8,\n                          compressed_length: size_t,\n                          uncompressed: *mut u8,\n                          uncompressed_length: *mut size_t) -> c_int;\n     fn snappy_max_compressed_length(source_length: size_t) -> size_t;\n-    fn snappy_uncompressed_length(compressed: *u8,\n+    fn snappy_uncompressed_length(compressed: *const u8,\n                                   compressed_length: size_t,\n                                   result: *mut size_t) -> c_int;\n-    fn snappy_validate_compressed_buffer(compressed: *u8,\n+    fn snappy_validate_compressed_buffer(compressed: *const u8,\n                                          compressed_length: size_t) -> c_int;\n }\n # fn main() {}\n@@ -82,7 +82,7 @@ the allocated memory. The length is less than or equal to the capacity.\n ~~~~\n # extern crate libc;\n # use libc::{c_int, size_t};\n-# unsafe fn snappy_validate_compressed_buffer(_: *u8, _: size_t) -> c_int { 0 }\n+# unsafe fn snappy_validate_compressed_buffer(_: *const u8, _: size_t) -> c_int { 0 }\n # fn main() {}\n pub fn validate_compressed_buffer(src: &[u8]) -> bool {\n     unsafe {\n@@ -106,7 +106,7 @@ the true length after compression for setting the length.\n ~~~~\n # extern crate libc;\n # use libc::{size_t, c_int};\n-# unsafe fn snappy_compress(a: *u8, b: size_t, c: *mut u8,\n+# unsafe fn snappy_compress(a: *const u8, b: size_t, c: *mut u8,\n #                           d: *mut size_t) -> c_int { 0 }\n # unsafe fn snappy_max_compressed_length(a: size_t) -> size_t { a }\n # fn main() {}\n@@ -132,11 +132,11 @@ format and `snappy_uncompressed_length` will retrieve the exact buffer size requ\n ~~~~\n # extern crate libc;\n # use libc::{size_t, c_int};\n-# unsafe fn snappy_uncompress(compressed: *u8,\n+# unsafe fn snappy_uncompress(compressed: *const u8,\n #                             compressed_length: size_t,\n #                             uncompressed: *mut u8,\n #                             uncompressed_length: *mut size_t) -> c_int { 0 }\n-# unsafe fn snappy_uncompressed_length(compressed: *u8,\n+# unsafe fn snappy_uncompressed_length(compressed: *const u8,\n #                                      compressed_length: size_t,\n #                                      result: *mut size_t) -> c_int { 0 }\n # fn main() {}\n@@ -418,7 +418,7 @@ Unsafe functions, on the other hand, advertise it to the world. An unsafe functi\n this:\n \n ~~~~\n-unsafe fn kaboom(ptr: *int) -> int { *ptr }\n+unsafe fn kaboom(ptr: *const int) -> int { *ptr }\n ~~~~\n \n This function can only be called from an `unsafe` block or another `unsafe` function.\n@@ -453,7 +453,7 @@ use std::ptr;\n \n #[link(name = \"readline\")]\n extern {\n-    static mut rl_prompt: *libc::c_char;\n+    static mut rl_prompt: *const libc::c_char;\n }\n \n fn main() {\n@@ -478,7 +478,7 @@ extern crate libc;\n #[link(name = \"kernel32\")]\n #[allow(non_snake_case_functions)]\n extern \"stdcall\" {\n-    fn SetEnvironmentVariableA(n: *u8, v: *u8) -> libc::c_int;\n+    fn SetEnvironmentVariableA(n: *const u8, v: *const u8) -> libc::c_int;\n }\n # fn main() { }\n ~~~~"}, {"sha": "1367bdc07555fb1ee3650e1db560a8d24040861b", "filename": "src/doc/guide-runtime.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fdoc%2Fguide-runtime.md", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fdoc%2Fguide-runtime.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-runtime.md?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -245,7 +245,7 @@ extern crate green;\n extern crate rustuv;\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int {\n+fn start(argc: int, argv: *const *const u8) -> int {\n     green::start(argc, argv, rustuv::event_loop, main)\n }\n \n@@ -261,7 +261,9 @@ inside of an OS thread.\n extern crate native;\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int { native::start(argc, argv, main) }\n+fn start(argc: int, argv: *const *const u8) -> int {\n+    native::start(argc, argv, main)\n+}\n \n fn main() {}\n ~~~"}, {"sha": "ffaabbb04ab680bbfbae1ebdc34b2cb5a8247eaa", "filename": "src/doc/guide-unsafe.md", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fdoc%2Fguide-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fdoc%2Fguide-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-unsafe.md?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -79,7 +79,7 @@ let ref_2: &mut u8 = unsafe { mem::transmute(&mut *ref_1) };\n ## Raw pointers\n \n Rust offers two additional pointer types \"raw pointers\", written as\n-`*T` and `*mut T`. They're an approximation of C's `const T*` and `T*`\n+`*const T` and `*mut T`. They're an approximation of C's `const T*` and `T*`\n respectively; indeed, one of their most common uses is for FFI,\n interfacing with external C libraries.\n \n@@ -100,7 +100,7 @@ offered by the Rust language and libraries. For example, they\n - lack any form of lifetimes, unlike `&`, and so the compiler cannot\n   reason about dangling pointers; and\n - have no guarantees about aliasing or mutability other than mutation\n-  not being allowed directly through a `*T`.\n+  not being allowed directly through a `*const T`.\n \n Fortunately, they come with a redeeming feature: the weaker guarantees\n mean weaker restrictions. The missing restrictions make raw pointers\n@@ -131,13 +131,13 @@ unsafe, and neither is converting to an integer.\n \n At runtime, a raw pointer `*` and a reference pointing to the same\n piece of data have an identical representation. In fact, an `&T`\n-reference will implicitly coerce to an `*T` raw pointer in safe code\n+reference will implicitly coerce to an `*const T` raw pointer in safe code\n and similarly for the `mut` variants (both coercions can be performed\n-explicitly with, respectively, `value as *T` and `value as *mut T`).\n+explicitly with, respectively, `value as *const T` and `value as *mut T`).\n \n-Going the opposite direction, from `*` to a reference `&`, is not\n+Going the opposite direction, from `*const` to a reference `&`, is not\n safe. A `&T` is always valid, and so, at a minimum, the raw pointer\n-`*T` has to be a valid to a valid instance of type `T`. Furthermore,\n+`*const T` has to be a valid to a valid instance of type `T`. Furthermore,\n the resulting pointer must satisfy the aliasing and mutability laws of\n references. The compiler assumes these properties are true for any\n references, no matter how they are created, and so any conversion from\n@@ -149,7 +149,7 @@ The recommended method for the conversion is\n ```\n let i: u32 = 1;\n // explicit cast\n-let p_imm: *u32 = &i as *u32;\n+let p_imm: *const u32 = &i as *const u32;\n let mut m: u32 = 2;\n // implicit coercion\n let p_mut: *mut u32 = &mut m;\n@@ -256,7 +256,7 @@ impl<T: Send> Drop for Unique<T> {\n             // Copy the object out from the pointer onto the stack,\n             // where it is covered by normal Rust destructor semantics\n             // and cleans itself up, if necessary\n-            ptr::read(self.ptr as *T);\n+            ptr::read(self.ptr as *const T);\n \n             // clean-up our allocation\n             free(self.ptr as *mut c_void)\n@@ -457,7 +457,7 @@ extern crate libc;\n \n // Entry point for this program\n #[start]\n-fn start(_argc: int, _argv: **u8) -> int {\n+fn start(_argc: int, _argv: *const *const u8) -> int {\n     0\n }\n \n@@ -482,7 +482,7 @@ compiler's name mangling too:\n extern crate libc;\n \n #[no_mangle] // ensure that this symbol is called `main` in the output\n-pub extern fn main(argc: int, argv: **u8) -> int {\n+pub extern fn main(argc: int, argv: *const *const u8) -> int {\n     0\n }\n \n@@ -540,8 +540,8 @@ use core::mem;\n use core::raw::Slice;\n \n #[no_mangle]\n-pub extern fn dot_product(a: *u32, a_len: u32,\n-                          b: *u32, b_len: u32) -> u32 {\n+pub extern fn dot_product(a: *const u32, a_len: u32,\n+                          b: *const u32, b_len: u32) -> u32 {\n     // Convert the provided arrays into Rust slices.\n     // The core::raw module guarantees that the Slice\n     // structure has the same memory layout as a &[T]\n@@ -573,7 +573,7 @@ extern fn begin_unwind(args: &core::fmt::Arguments,\n \n #[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n-# #[start] fn start(argc: int, argv: **u8) -> int { 0 }\n+# #[start] fn start(argc: int, argv: *const *const u8) -> int { 0 }\n # fn main() {}\n ```\n \n@@ -595,7 +595,7 @@ standard library itself.\n > parts of the language may never be full specified and so details may\n > differ wildly between implementations (and even versions of `rustc`\n > itself).\n-> \n+>\n > Furthermore, this is just an overview; the best form of\n > documentation for specific instances of these features are their\n > definitions and uses in `std`.\n@@ -627,7 +627,7 @@ via a declaration like\n extern \"rust-intrinsic\" {\n     fn transmute<T, U>(x: T) -> U;\n \n-    fn offset<T>(dst: *T, offset: int) -> *T;\n+    fn offset<T>(dst: *const T, offset: int) -> *const T;\n }\n ```\n \n@@ -677,7 +677,7 @@ unsafe fn deallocate(ptr: *mut u8, _size: uint, _align: uint) {\n }\n \n #[start]\n-fn main(argc: int, argv: **u8) -> int {\n+fn main(argc: int, argv: *const *const u8) -> int {\n     let x = box 1;\n \n     0"}, {"sha": "c5a6a01f48355aeb5e95d75afbaa88a67f11c134", "filename": "src/doc/rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -1614,7 +1614,7 @@ extern crate libc;\n use libc::{c_char, FILE};\n \n extern {\n-    fn fopen(filename: *c_char, mode: *c_char) -> *FILE;\n+    fn fopen(filename: *const c_char, mode: *const c_char) -> *mut FILE;\n }\n # fn main() {}\n ~~~~"}, {"sha": "589ff8c1de9fe357c820ae57d58f71727c049c3a", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -99,7 +99,7 @@ pub static mut EMPTY: uint = 12345;\n #[inline]\n unsafe fn exchange_malloc(size: uint, align: uint) -> *mut u8 {\n     if size == 0 {\n-        &EMPTY as *uint as *mut u8\n+        &EMPTY as *const uint as *mut u8\n     } else {\n         allocate(size, align)\n     }\n@@ -144,9 +144,10 @@ mod imp {\n                       flags: c_int) -> size_t;\n         fn je_dallocx(ptr: *mut c_void, flags: c_int);\n         fn je_nallocx(size: size_t, flags: c_int) -> size_t;\n-        fn je_malloc_stats_print(write_cb: Option<extern \"C\" fn(cbopaque: *mut c_void, *c_char)>,\n+        fn je_malloc_stats_print(write_cb: Option<extern \"C\" fn(cbopaque: *mut c_void,\n+                                                                *const c_char)>,\n                                  cbopaque: *mut c_void,\n-                                 opts: *c_char);\n+                                 opts: *const c_char);\n     }\n \n     // -lpthread needs to occur after -ljemalloc, the earlier argument isn't enough\n@@ -226,7 +227,7 @@ mod imp {\n         // a block of memory, so we special case everything under `*uint` to\n         // just pass it to malloc, which is guaranteed to align to at least the\n         // size of `*uint`.\n-        if align < mem::size_of::<*uint>() {\n+        if align < mem::size_of::<uint>() {\n             libc_heap::malloc_raw(size)\n         } else {\n             let mut out = 0 as *mut libc::c_void;\n@@ -244,7 +245,7 @@ mod imp {\n     pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n                              old_size: uint) -> *mut u8 {\n         let new_ptr = allocate(size, align);\n-        ptr::copy_memory(new_ptr, ptr as *u8, old_size);\n+        ptr::copy_memory(new_ptr, ptr as *const u8, old_size);\n         deallocate(ptr, old_size, align);\n         return new_ptr;\n     }"}, {"sha": "77333b4dc2aee614fb6087692d14758d952358b0", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -70,7 +70,6 @@\n \n #![no_std]\n #![feature(lang_items, phase, unsafe_destructor)]\n-#![allow(unknown_features)] // NOTE: remove after a stage0 snap\n \n #[phase(plugin, link)]\n extern crate core;"}, {"sha": "589adbd41d04e74e1ccaf3df57a4a937a187f060", "filename": "src/liballoc/owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fliballoc%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fliballoc%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fowned.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -37,7 +37,7 @@ pub static HEAP: () = ();\n \n /// A type that represents a uniquely-owned value.\n #[lang=\"owned_box\"]\n-pub struct Box<T>(*T);\n+pub struct Box<T>(*mut T);\n \n impl<T: Default> Default for Box<T> {\n     fn default() -> Box<T> { box Default::default() }"}, {"sha": "152967cb4e90841f2cd83b4e62fe4dda0a8a27f6", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -55,7 +55,7 @@ impl Chunk {\n         self.data.borrow().capacity()\n     }\n \n-    unsafe fn as_ptr(&self) -> *u8 {\n+    unsafe fn as_ptr(&self) -> *const u8 {\n         self.data.borrow().as_ptr()\n     }\n }\n@@ -140,22 +140,22 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n     let fill = chunk.fill.get();\n \n     while idx < fill {\n-        let tydesc_data: *uint = mem::transmute(buf.offset(idx as int));\n+        let tydesc_data: *const uint = mem::transmute(buf.offset(idx as int));\n         let (tydesc, is_done) = un_bitpack_tydesc_ptr(*tydesc_data);\n         let (size, align) = ((*tydesc).size, (*tydesc).align);\n \n-        let after_tydesc = idx + mem::size_of::<*TyDesc>();\n+        let after_tydesc = idx + mem::size_of::<*const TyDesc>();\n \n         let start = round_up(after_tydesc, align);\n \n         //debug!(\"freeing object: idx = {}, size = {}, align = {}, done = {}\",\n         //       start, size, align, is_done);\n         if is_done {\n-            ((*tydesc).drop_glue)(buf.offset(start as int) as *i8);\n+            ((*tydesc).drop_glue)(buf.offset(start as int) as *const i8);\n         }\n \n         // Find where the next tydesc lives\n-        idx = round_up(start + size, mem::align_of::<*TyDesc>());\n+        idx = round_up(start + size, mem::align_of::<*const TyDesc>());\n     }\n }\n \n@@ -164,12 +164,12 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n // is necessary in order to properly do cleanup if a failure occurs\n // during an initializer.\n #[inline]\n-fn bitpack_tydesc_ptr(p: *TyDesc, is_done: bool) -> uint {\n+fn bitpack_tydesc_ptr(p: *const TyDesc, is_done: bool) -> uint {\n     p as uint | (is_done as uint)\n }\n #[inline]\n-fn un_bitpack_tydesc_ptr(p: uint) -> (*TyDesc, bool) {\n-    ((p & !1) as *TyDesc, p & 1 == 1)\n+fn un_bitpack_tydesc_ptr(p: uint) -> (*const TyDesc, bool) {\n+    ((p & !1) as *const TyDesc, p & 1 == 1)\n }\n \n impl Arena {\n@@ -178,7 +178,7 @@ impl Arena {\n     }\n \n     // Functions for the POD part of the arena\n-    fn alloc_copy_grow(&self, n_bytes: uint, align: uint) -> *u8 {\n+    fn alloc_copy_grow(&self, n_bytes: uint, align: uint) -> *const u8 {\n         // Allocate a new chunk.\n         let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n         self.chunks.borrow_mut().push(self.copy_head.borrow().clone());\n@@ -190,7 +190,7 @@ impl Arena {\n     }\n \n     #[inline]\n-    fn alloc_copy_inner(&self, n_bytes: uint, align: uint) -> *u8 {\n+    fn alloc_copy_inner(&self, n_bytes: uint, align: uint) -> *const u8 {\n         let start = round_up(self.copy_head.borrow().fill.get(), align);\n \n         let end = start + n_bytes;\n@@ -218,7 +218,8 @@ impl Arena {\n     }\n \n     // Functions for the non-POD part of the arena\n-    fn alloc_noncopy_grow(&self, n_bytes: uint, align: uint) -> (*u8, *u8) {\n+    fn alloc_noncopy_grow(&self, n_bytes: uint,\n+                          align: uint) -> (*const u8, *const u8) {\n         // Allocate a new chunk.\n         let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n         self.chunks.borrow_mut().push(self.head.borrow().clone());\n@@ -230,15 +231,16 @@ impl Arena {\n     }\n \n     #[inline]\n-    fn alloc_noncopy_inner(&self, n_bytes: uint, align: uint) -> (*u8, *u8) {\n+    fn alloc_noncopy_inner(&self, n_bytes: uint,\n+                           align: uint) -> (*const u8, *const u8) {\n         // Be careful to not maintain any `head` borrows active, because\n         // `alloc_noncopy_grow` borrows it mutably.\n         let (start, end, tydesc_start, head_capacity) = {\n             let head = self.head.borrow();\n             let fill = head.fill.get();\n \n             let tydesc_start = fill;\n-            let after_tydesc = fill + mem::size_of::<*TyDesc>();\n+            let after_tydesc = fill + mem::size_of::<*const TyDesc>();\n             let start = round_up(after_tydesc, align);\n             let end = start + n_bytes;\n \n@@ -250,7 +252,7 @@ impl Arena {\n         }\n \n         let head = self.head.borrow();\n-        head.fill.set(round_up(end, mem::align_of::<*TyDesc>()));\n+        head.fill.set(round_up(end, mem::align_of::<*const TyDesc>()));\n \n         unsafe {\n             let buf = head.as_ptr();\n@@ -348,11 +350,11 @@ fn test_arena_destructors_fail() {\n /// run again for these objects.\n pub struct TypedArena<T> {\n     /// A pointer to the next object to be allocated.\n-    ptr: Cell<*T>,\n+    ptr: Cell<*const T>,\n \n     /// A pointer to the end of the allocated area. When this pointer is\n     /// reached, a new chunk is allocated.\n-    end: Cell<*T>,\n+    end: Cell<*const T>,\n \n     /// A pointer to the first arena segment.\n     first: RefCell<TypedArenaChunkRef<T>>,\n@@ -398,7 +400,7 @@ impl<T> TypedArenaChunk<T> {\n         if intrinsics::needs_drop::<T>() {\n             let mut start = self.start();\n             for _ in range(0, len) {\n-                ptr::read(start as *T); // run the destructor on the pointer\n+                ptr::read(start as *const T); // run the destructor on the pointer\n                 start = start.offset(mem::size_of::<T>() as int)\n             }\n         }\n@@ -417,8 +419,8 @@ impl<T> TypedArenaChunk<T> {\n \n     // Returns a pointer to the first allocated object.\n     #[inline]\n-    fn start(&self) -> *u8 {\n-        let this: *TypedArenaChunk<T> = self;\n+    fn start(&self) -> *const u8 {\n+        let this: *const TypedArenaChunk<T> = self;\n         unsafe {\n             mem::transmute(round_up(this.offset(1) as uint,\n                                     mem::min_align_of::<T>()))\n@@ -427,7 +429,7 @@ impl<T> TypedArenaChunk<T> {\n \n     // Returns a pointer to the end of the allocated space.\n     #[inline]\n-    fn end(&self) -> *u8 {\n+    fn end(&self) -> *const u8 {\n         unsafe {\n             let size = mem::size_of::<T>().checked_mul(&self.capacity).unwrap();\n             self.start().offset(size as int)\n@@ -448,8 +450,8 @@ impl<T> TypedArena<T> {\n     pub fn with_capacity(capacity: uint) -> TypedArena<T> {\n         let chunk = TypedArenaChunk::<T>::new(None, capacity);\n         TypedArena {\n-            ptr: Cell::new(chunk.start() as *T),\n-            end: Cell::new(chunk.end() as *T),\n+            ptr: Cell::new(chunk.start() as *const T),\n+            end: Cell::new(chunk.end() as *const T),\n             first: RefCell::new(Some(chunk)),\n         }\n     }\n@@ -477,8 +479,8 @@ impl<T> TypedArena<T> {\n         let chunk = self.first.borrow_mut().take_unwrap();\n         let new_capacity = chunk.capacity.checked_mul(&2).unwrap();\n         let chunk = TypedArenaChunk::<T>::new(Some(chunk), new_capacity);\n-        self.ptr.set(chunk.start() as *T);\n-        self.end.set(chunk.end() as *T);\n+        self.ptr.set(chunk.start() as *const T);\n+        self.end.set(chunk.end() as *const T);\n         *self.first.borrow_mut() = Some(chunk)\n     }\n }"}, {"sha": "7ea5c482e61f206b6b466b33dd4654362aac5ec8", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -652,7 +652,7 @@ mod tests {\n                 (None   , None      ) => {}\n                 (None   , _         ) => fail!(\"prev link for list_head\"),\n                 (Some(p), Some(pptr)) => {\n-                    assert_eq!(p as *Node<T>, pptr as *Node<T>);\n+                    assert_eq!(p as *const Node<T>, pptr as *const Node<T>);\n                 }\n                 _ => fail!(\"prev link is none, not good\"),\n             }"}, {"sha": "976f726244121f527e053a980042fe5b491e078a", "filename": "src/libcollections/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fmod.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -247,7 +247,7 @@ impl<S: Writer, T: Hash<S>> Hash<S> for Option<T> {\n     }\n }\n \n-impl<S: Writer, T> Hash<S> for *T {\n+impl<S: Writer, T> Hash<S> for *const T {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         // NB: raw-pointer Hash does _not_ dereference\n@@ -342,7 +342,7 @@ mod tests {\n         assert_eq!(hasher.hash(& &[1u8, 2u8, 3u8]), 9);\n \n         unsafe {\n-            let ptr: *int = mem::transmute(5);\n+            let ptr: *const int = mem::transmute(5);\n             assert_eq!(hasher.hash(&ptr), 5);\n         }\n "}, {"sha": "ac32d93edbe83710aa4c689e81804c81f1061c60", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -341,7 +341,7 @@ fn insertion_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n         let mut j = i;\n         unsafe {\n             // `i` is in bounds.\n-            let read_ptr = buf_v.offset(i) as *T;\n+            let read_ptr = buf_v.offset(i) as *const T;\n \n             // find where to insert, we need to do strict <,\n             // rather than <=, to maintain stability.\n@@ -365,7 +365,7 @@ fn insertion_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n                                  &*buf_v.offset(j),\n                                  (i - j) as uint);\n                 ptr::copy_nonoverlapping_memory(buf_v.offset(j),\n-                                                &tmp as *T,\n+                                                &tmp as *const T,\n                                                 1);\n                 mem::forget(tmp);\n             }"}, {"sha": "72c5aff675bfb4dbf94518f32acab03badc5a0d5", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -661,7 +661,7 @@ pub mod raw {\n     pub use core::str::raw::{slice_unchecked};\n \n     /// Create a Rust string from a *u8 buffer of the given length\n-    pub unsafe fn from_buf_len(buf: *u8, len: uint) -> String {\n+    pub unsafe fn from_buf_len(buf: *const u8, len: uint) -> String {\n         let mut result = String::new();\n         result.push_bytes(mem::transmute(Slice {\n             data: buf,\n@@ -671,7 +671,7 @@ pub mod raw {\n     }\n \n     /// Create a Rust string from a null-terminated C string\n-    pub unsafe fn from_c_str(c_string: *i8) -> String {\n+    pub unsafe fn from_c_str(c_string: *const i8) -> String {\n         let mut buf = String::new();\n         let mut len = 0;\n         while *c_string.offset(len) != 0 {"}, {"sha": "568baa6fc405236465060b8273edf52cd2deeb05", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -287,7 +287,7 @@ pub struct Entries<'a, K, V> {\n     // See the comment on MutEntries; this is just to allow\n     // code-sharing (for this immutable-values iterator it *could* very\n     // well be Option<&'a TreeNode<K,V>>).\n-    node: *TreeNode<K, V>,\n+    node: *const TreeNode<K, V>,\n     remaining_min: uint,\n     remaining_max: uint\n }\n@@ -468,11 +468,11 @@ define_iterator! {\n     addr_mut = mut\n }\n \n-fn deref<'a, K, V>(node: &'a Option<Box<TreeNode<K, V>>>) -> *TreeNode<K, V> {\n+fn deref<'a, K, V>(node: &'a Option<Box<TreeNode<K, V>>>) -> *const TreeNode<K, V> {\n     match *node {\n         Some(ref n) => {\n             let n: &TreeNode<K, V> = *n;\n-            n as *TreeNode<K, V>\n+            n as *const TreeNode<K, V>\n         }\n         None => ptr::null()\n     }"}, {"sha": "9b6355e121bea459af7c7e4336e3e7396256648d", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -189,7 +189,9 @@ macro_rules! bound {\n             // We like sharing code so much that even a little unsafe won't\n             // stop us.\n             let this = $this;\n-            let mut node = addr!(& $($mut_)* this.root as * $($mut_)* TrieNode<T>);\n+            let mut node = unsafe {\n+                mem::transmute::<_, uint>(&this.root) as *mut TrieNode<T>\n+            };\n \n             let key = $key;\n \n@@ -205,7 +207,10 @@ macro_rules! bound {\n                     let child_id = chunk(key, it.length);\n                     let (slice_idx, ret) = match children[child_id] {\n                         Internal(ref $($mut_)* n) => {\n-                            node = addr!(& $($mut_)* **n as * $($mut_)* TrieNode<T>);\n+                            node = unsafe {\n+                                mem::transmute::<_, uint>(&**n)\n+                                    as *mut TrieNode<T>\n+                            };\n                             (child_id + 1, false)\n                         }\n                         External(stored, _) => {"}, {"sha": "8e6e86ce36ecd6a3e34d48e23868ab087ae9bef3", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -615,7 +615,7 @@ impl<T> Vec<T> {\n         }\n \n         unsafe {\n-            let end = (self.ptr as *T).offset(self.len as int) as *mut T;\n+            let end = (self.ptr as *const T).offset(self.len as int) as *mut T;\n             ptr::write(&mut *end, value);\n             self.len += 1;\n         }\n@@ -674,7 +674,10 @@ impl<T> Vec<T> {\n     #[inline]\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         unsafe {\n-            mem::transmute(Slice { data: self.as_mut_ptr() as *T, len: self.len })\n+            mem::transmute(Slice {\n+                data: self.as_mut_ptr() as *const T,\n+                len: self.len,\n+            })\n         }\n     }\n \n@@ -1014,7 +1017,7 @@ impl<T> Vec<T> {\n                     let ptr = self.as_mut_ptr().offset(index as int);\n                     // copy it out, unsafely having a copy of the value on\n                     // the stack and in the vector at the same time.\n-                    ret = Some(ptr::read(ptr as *T));\n+                    ret = Some(ptr::read(ptr as *const T));\n \n                     // Shift everything down to fill in that spot.\n                     ptr::copy_memory(ptr, &*ptr.offset(1), len - index - 1);\n@@ -1203,15 +1206,15 @@ impl<T> Vec<T> {\n     /// Modifying the vector may cause its buffer to be reallocated, which\n     /// would also make any pointers to it invalid.\n     #[inline]\n-    pub fn as_ptr(&self) -> *T {\n+    pub fn as_ptr(&self) -> *const T {\n         // If we have a 0-sized vector, then the base pointer should not be NULL\n         // because an iterator over the slice will attempt to yield the base\n         // pointer as the first element in the vector, but this will end up\n         // being Some(NULL) which is optimized to None.\n         if mem::size_of::<T>() == 0 {\n-            1 as *T\n+            1 as *const T\n         } else {\n-            self.ptr as *T\n+            self.ptr as *const T\n         }\n     }\n \n@@ -1545,7 +1548,7 @@ pub mod raw {\n     /// The elements of the buffer are copied into the vector without cloning,\n     /// as if `ptr::read()` were called on them.\n     #[inline]\n-    pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> Vec<T> {\n+    pub unsafe fn from_buf<T>(ptr: *const T, elts: uint) -> Vec<T> {\n         let mut dst = Vec::with_capacity(elts);\n         dst.set_len(elts);\n         ptr::copy_nonoverlapping_memory(dst.as_mut_ptr(), ptr, elts);"}, {"sha": "13979bb648fdaa6702fd6aa655f191c22a8baac2", "filename": "src/libcore/atomics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomics.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -94,7 +94,7 @@ impl AtomicBool {\n     /// Load the value\n     #[inline]\n     pub fn load(&self, order: Ordering) -> bool {\n-        unsafe { atomic_load(self.v.get() as *uint, order) > 0 }\n+        unsafe { atomic_load(self.v.get() as *const uint, order) > 0 }\n     }\n \n     /// Store the value\n@@ -295,7 +295,7 @@ impl AtomicInt {\n     /// Load the value\n     #[inline]\n     pub fn load(&self, order: Ordering) -> int {\n-        unsafe { atomic_load(self.v.get() as *int, order) }\n+        unsafe { atomic_load(self.v.get() as *const int, order) }\n     }\n \n     /// Store the value\n@@ -407,7 +407,7 @@ impl AtomicUint {\n     /// Load the value\n     #[inline]\n     pub fn load(&self, order: Ordering) -> uint {\n-        unsafe { atomic_load(self.v.get() as *uint, order) }\n+        unsafe { atomic_load(self.v.get() as *const uint, order) }\n     }\n \n     /// Store the value\n@@ -520,7 +520,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     pub fn load(&self, order: Ordering) -> *mut T {\n         unsafe {\n-            atomic_load(self.p.get() as **mut T, order) as *mut T\n+            atomic_load(self.p.get() as *const *mut T, order) as *mut T\n         }\n     }\n \n@@ -560,7 +560,7 @@ unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) {\n }\n \n #[inline]\n-unsafe fn atomic_load<T>(dst: *T, order:Ordering) -> T {\n+unsafe fn atomic_load<T>(dst: *const T, order:Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_load_acq(dst),\n         Relaxed => intrinsics::atomic_load_relaxed(dst),"}, {"sha": "1a66d952e9bc2d52a4c03cf133cf31ea354a8d8a", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -314,11 +314,11 @@ impl<'a> Formatter<'a> {\n             rt::CountImplied => { None }\n             rt::CountIsParam(i) => {\n                 let v = self.args[i].value;\n-                unsafe { Some(*(v as *any::Void as *uint)) }\n+                unsafe { Some(*(v as *const _ as *const uint)) }\n             }\n             rt::CountIsNextParam => {\n                 let v = self.curarg.next().unwrap().value;\n-                unsafe { Some(*(v as *any::Void as *uint)) }\n+                unsafe { Some(*(v as *const _ as *const uint)) }\n             }\n         }\n     }\n@@ -565,25 +565,25 @@ impl Char for char {\n     }\n }\n \n-impl<T> Pointer for *T {\n+impl<T> Pointer for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.flags |= 1 << (rt::FlagAlternate as uint);\n         secret_lower_hex::<uint>(&(*self as uint), f)\n     }\n }\n impl<T> Pointer for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        secret_pointer::<*T>(&(*self as *T), f)\n+        secret_pointer::<*const T>(&(*self as *const T), f)\n     }\n }\n impl<'a, T> Pointer for &'a T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        secret_pointer::<*T>(&(&**self as *T), f)\n+        secret_pointer::<*const T>(&(&**self as *const T), f)\n     }\n }\n impl<'a, T> Pointer for &'a mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        secret_pointer::<*T>(&(&**self as *T), f)\n+        secret_pointer::<*const T>(&(&**self as *const T), f)\n     }\n }\n \n@@ -669,7 +669,7 @@ delegate!(char to char)\n delegate!(f32 to float)\n delegate!(f64 to float)\n \n-impl<T> Show for *T {\n+impl<T> Show for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result { secret_pointer(self, f) }\n }\n impl<T> Show for *mut T {"}, {"sha": "fd06ae95f1b7f2bd33c131363bc2739e69ff9bc3", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -48,7 +48,7 @@ A quick refresher on memory ordering:\n #[cfg(test)]\n pub use realcore::intrinsics::{TyDesc, Opaque, TyVisitor, TypeId};\n \n-pub type GlueFn = extern \"Rust\" fn(*i8);\n+pub type GlueFn = extern \"Rust\" fn(*const i8);\n \n #[lang=\"ty_desc\"]\n #[cfg(not(test))]\n@@ -102,55 +102,58 @@ pub trait TyVisitor {\n     fn visit_estr_slice(&mut self) -> bool;\n     fn visit_estr_fixed(&mut self, n: uint, sz: uint, align: uint) -> bool;\n \n-    fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n-    fn visit_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n-    fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n-    fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_box(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n+    fn visit_uniq(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n+    fn visit_ptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n+    fn visit_rptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n \n-    fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n+    fn visit_evec_slice(&mut self, mtbl: uint, inner: *const TyDesc) -> bool;\n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n-                        mtbl: uint, inner: *TyDesc) -> bool;\n+                        mtbl: uint, inner: *const TyDesc) -> bool;\n \n     fn visit_enter_rec(&mut self, n_fields: uint,\n                        sz: uint, align: uint) -> bool;\n     fn visit_rec_field(&mut self, i: uint, name: &str,\n-                       mtbl: uint, inner: *TyDesc) -> bool;\n+                       mtbl: uint, inner: *const TyDesc) -> bool;\n     fn visit_leave_rec(&mut self, n_fields: uint,\n                        sz: uint, align: uint) -> bool;\n \n     fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint,\n                          sz: uint, align: uint) -> bool;\n     fn visit_class_field(&mut self, i: uint, name: &str, named: bool,\n-                         mtbl: uint, inner: *TyDesc) -> bool;\n+                         mtbl: uint, inner: *const TyDesc) -> bool;\n     fn visit_leave_class(&mut self, name: &str, named_fields: bool, n_fields: uint,\n                          sz: uint, align: uint) -> bool;\n \n     fn visit_enter_tup(&mut self, n_fields: uint,\n                        sz: uint, align: uint) -> bool;\n-    fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool;\n+    fn visit_tup_field(&mut self, i: uint, inner: *const TyDesc) -> bool;\n     fn visit_leave_tup(&mut self, n_fields: uint,\n                        sz: uint, align: uint) -> bool;\n \n     fn visit_enter_enum(&mut self, n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n+                        get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n                         sz: uint, align: uint) -> bool;\n     fn visit_enter_enum_variant(&mut self, variant: uint,\n                                 disr_val: Disr,\n                                 n_fields: uint,\n                                 name: &str) -> bool;\n-    fn visit_enum_variant_field(&mut self, i: uint, offset: uint, inner: *TyDesc) -> bool;\n+    fn visit_enum_variant_field(&mut self, i: uint, offset: uint,\n+                                inner: *const TyDesc) -> bool;\n     fn visit_leave_enum_variant(&mut self, variant: uint,\n                                 disr_val: Disr,\n                                 n_fields: uint,\n                                 name: &str) -> bool;\n     fn visit_leave_enum(&mut self, n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n+                        get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n                         sz: uint, align: uint) -> bool;\n \n     fn visit_enter_fn(&mut self, purity: uint, proto: uint,\n                       n_inputs: uint, retstyle: uint) -> bool;\n-    fn visit_fn_input(&mut self, i: uint, mode: uint, inner: *TyDesc) -> bool;\n-    fn visit_fn_output(&mut self, retstyle: uint, variadic: bool, inner: *TyDesc) -> bool;\n+    fn visit_fn_input(&mut self, i: uint, mode: uint,\n+                      inner: *const TyDesc) -> bool;\n+    fn visit_fn_output(&mut self, retstyle: uint, variadic: bool,\n+                       inner: *const TyDesc) -> bool;\n     fn visit_leave_fn(&mut self, purity: uint, proto: uint,\n                       n_inputs: uint, retstyle: uint) -> bool;\n \n@@ -170,9 +173,9 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_cxchg_acqrel<T>(dst: *mut T, old: T, src: T) -> T;\n     pub fn atomic_cxchg_relaxed<T>(dst: *mut T, old: T, src: T) -> T;\n \n-    pub fn atomic_load<T>(src: *T) -> T;\n-    pub fn atomic_load_acq<T>(src: *T) -> T;\n-    pub fn atomic_load_relaxed<T>(src: *T) -> T;\n+    pub fn atomic_load<T>(src: *const T) -> T;\n+    pub fn atomic_load_acq<T>(src: *const T) -> T;\n+    pub fn atomic_load_relaxed<T>(src: *const T) -> T;\n \n     pub fn atomic_store<T>(dst: *mut T, val: T);\n     pub fn atomic_store_rel<T>(dst: *mut T, val: T);\n@@ -276,7 +279,7 @@ extern \"rust-intrinsic\" {\n     pub fn pref_align_of<T>() -> uint;\n \n     /// Get a static pointer to a type descriptor.\n-    pub fn get_tydesc<T>() -> *TyDesc;\n+    pub fn get_tydesc<T>() -> *const TyDesc;\n \n     /// Gets an identifier which is globally unique to the specified type. This\n     /// function will return the same value for a type regardless of whichever\n@@ -320,25 +323,25 @@ extern \"rust-intrinsic\" {\n     /// Returns `true` if a type is managed (will be allocated on the local heap)\n     pub fn owns_managed<T>() -> bool;\n \n-    pub fn visit_tydesc(td: *TyDesc, tv: &mut TyVisitor);\n+    pub fn visit_tydesc(td: *const TyDesc, tv: &mut TyVisitor);\n \n     /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n     /// the object, or one-byte-past-the-end. An arithmetic overflow is also\n     /// undefined behaviour.\n     ///\n     /// This is implemented as an intrinsic to avoid converting to and from an\n     /// integer, since the conversion would throw away aliasing information.\n-    pub fn offset<T>(dst: *T, offset: int) -> *T;\n+    pub fn offset<T>(dst: *const T, offset: int) -> *const T;\n \n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with\n     /// a size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`\n-    pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *T, count: uint);\n+    pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint);\n \n     /// Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with\n     /// a size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`\n-    pub fn copy_memory<T>(dst: *mut T, src: *T, count: uint);\n+    pub fn copy_memory<T>(dst: *mut T, src: *const T, count: uint);\n \n     /// Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\n     /// size of `count` * `size_of::<T>()` and an alignment of\n@@ -350,13 +353,14 @@ extern \"rust-intrinsic\" {\n     /// `min_align_of::<T>()`\n     ///\n     /// The volatile parameter parameter is set to `true`, so it will not be optimized out.\n-    pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *T, count: uint);\n+    pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T,\n+                                                  count: uint);\n     /// Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with\n     /// a size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`\n     ///\n     /// The volatile parameter parameter is set to `true`, so it will not be optimized out.\n-    pub fn volatile_copy_memory<T>(dst: *mut T, src: *T, count: uint);\n+    pub fn volatile_copy_memory<T>(dst: *mut T, src: *const T, count: uint);\n     /// Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\n     /// size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`.\n@@ -365,7 +369,7 @@ extern \"rust-intrinsic\" {\n     pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: uint);\n \n     /// Perform a volatile load from the `src` pointer.\n-    pub fn volatile_load<T>(src: *T) -> T;\n+    pub fn volatile_load<T>(src: *const T) -> T;\n     /// Perform a volatile store to the `dst` pointer.\n     pub fn volatile_store<T>(dst: *mut T, val: T);\n "}, {"sha": "9a6cdb1c7697654008d3ce1a4b6294679d764e47", "filename": "src/libcore/kinds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -155,7 +155,7 @@ pub mod marker {\n     /// ```\n     /// use std::mem;\n     ///\n-    /// struct S<T> { x: *() }\n+    /// struct S<T> { x: *const () }\n     /// fn get<T>(s: &S<T>, v: T) {\n     ///    unsafe {\n     ///        let x: fn(T) = mem::transmute(s.x);"}, {"sha": "4dc45ceeb85adb098d07e814ac890e1de69e622c", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -58,7 +58,6 @@\n #![feature(globs, intrinsics, lang_items, macro_rules, managed_boxes, phase)]\n #![feature(simd, unsafe_destructor)]\n #![deny(missing_doc)]\n-#![allow(unknown_features)] // NOTE: remove after stage0 snapshot\n \n #[cfg(test)] extern crate realcore = \"core\";\n #[cfg(test)] extern crate libc;"}, {"sha": "d1e2084243d413b293d61003b145f656e0350def", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -363,7 +363,7 @@ pub unsafe fn forget<T>(thing: T) { intrinsics::forget(thing) }\n #[inline]\n #[stable]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n-    ptr::read(src as *T as *U)\n+    ptr::read(src as *const T as *const U)\n }\n \n /// Transforms lifetime of the second pointer to match the first.\n@@ -407,14 +407,14 @@ mod tests {\n     #[cfg(target_arch = \"mipsel\")]\n     fn size_of_32() {\n         assert_eq!(size_of::<uint>(), 4u);\n-        assert_eq!(size_of::<*uint>(), 4u);\n+        assert_eq!(size_of::<*const uint>(), 4u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86_64\")]\n     fn size_of_64() {\n         assert_eq!(size_of::<uint>(), 8u);\n-        assert_eq!(size_of::<*uint>(), 8u);\n+        assert_eq!(size_of::<*const uint>(), 8u);\n     }\n \n     #[test]\n@@ -439,14 +439,14 @@ mod tests {\n     #[cfg(target_arch = \"mipsel\")]\n     fn align_of_32() {\n         assert_eq!(align_of::<uint>(), 4u);\n-        assert_eq!(align_of::<*uint>(), 4u);\n+        assert_eq!(align_of::<*const uint>(), 4u);\n     }\n \n     #[test]\n     #[cfg(target_arch = \"x86_64\")]\n     fn align_of_64() {\n         assert_eq!(align_of::<uint>(), 8u);\n-        assert_eq!(align_of::<*uint>(), 8u);\n+        assert_eq!(align_of::<*const uint>(), 8u);\n     }\n \n     #[test]\n@@ -486,7 +486,7 @@ mod tests {\n         let a = box 100i as Box<Foo>;\n         unsafe {\n             let x: raw::TraitObject = transmute(a);\n-            assert!(*(x.data as *int) == 100);\n+            assert!(*(x.data as *const int) == 100);\n             let _x: Box<Foo> = transmute(x);\n         }\n "}, {"sha": "afa08f04cb20323919f37a377726ba5788202fb7", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -570,12 +570,6 @@ pub trait Shl<RHS,Result> {\n \n macro_rules! shl_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(stage0)]\n-        impl Shl<$t, $t> for $t {\n-            #[inline]\n-            fn shl(&self, other: &$t) -> $t { (*self) << (*other) }\n-        }\n-        #[cfg(not(stage0), not(test))]\n         impl Shl<$t, $t> for $t {\n             #[inline]\n             fn shl(&self, other: &$t) -> $t {\n@@ -619,12 +613,6 @@ pub trait Shr<RHS,Result> {\n \n macro_rules! shr_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(stage0, not(test))]\n-        impl Shr<$t, $t> for $t {\n-            #[inline]\n-            fn shr(&self, other: &$t) -> $t { (*self) >> (*other) }\n-        }\n-        #[cfg(not(stage0), not(test))]\n         impl Shr<$t, $t> for $t {\n             #[inline]\n             fn shr(&self, other: &$t) -> $t { (*self) >> (*other as uint) }"}, {"sha": "9748235e94a13478ae0d3d03e9fd968b5d99e208", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -628,10 +628,10 @@ mod tests {\n     fn test_get_ptr() {\n         unsafe {\n             let x = box 0;\n-            let addr_x: *int = ::mem::transmute(&*x);\n+            let addr_x: *const int = ::mem::transmute(&*x);\n             let opt = Some(x);\n             let y = opt.unwrap();\n-            let addr_y: *int = ::mem::transmute(&*y);\n+            let addr_y: *const int = ::mem::transmute(&*y);\n             assert_eq!(addr_x, addr_y);\n         }\n     }"}, {"sha": "44e68952df29fa40075cbd361020d4d3fb6994df", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 46, "deletions": 42, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -10,7 +10,7 @@\n \n // FIXME: talk about offset, copy_memory, copy_nonoverlapping_memory\n \n-//! Operations on unsafe pointers, `*T`, and `*mut T`.\n+//! Operations on unsafe pointers, `*const T`, and `*mut T`.\n //!\n //! Working with unsafe pointers in Rust is uncommon,\n //! typically limited to a few patterns.\n@@ -29,7 +29,7 @@\n //!\n //! ```\n //! let my_num: int = 10;\n-//! let my_num_ptr: *int = &my_num;\n+//! let my_num_ptr: *const int = &my_num;\n //! let mut my_speed: int = 88;\n //! let my_speed_ptr: *mut int = &mut my_speed;\n //! ```\n@@ -42,7 +42,7 @@\n //!\n //! The `transmute` function takes, by value, whatever it's given\n //! and returns it as whatever type is requested, as long as the\n-//! types are the same size. Because `Box<T>` and `*T` have the same\n+//! types are the same size. Because `Box<T>` and `*mut T` have the same\n //! representation they can be trivially,\n //! though unsafely, transformed from one type to the other.\n //!\n@@ -51,7 +51,7 @@\n //!\n //! unsafe {\n //!     let my_num: Box<int> = box 10;\n-//!     let my_num: *int = mem::transmute(my_num);\n+//!     let my_num: *const int = mem::transmute(my_num);\n //!     let my_speed: Box<int> = box 88;\n //!     let my_speed: *mut int = mem::transmute(my_speed);\n //!\n@@ -102,12 +102,12 @@ use option::{Some, None, Option};\n /// ```\n /// use std::ptr;\n ///\n-/// let p: *int = ptr::null();\n+/// let p: *const int = ptr::null();\n /// assert!(p.is_null());\n /// ```\n #[inline]\n #[unstable = \"may need a different name after pending changes to pointer types\"]\n-pub fn null<T>() -> *T { 0 as *T }\n+pub fn null<T>() -> *const T { 0 as *const T }\n \n /// Create an unsafe mutable null pointer.\n ///\n@@ -137,7 +137,7 @@ pub fn mut_null<T>() -> *mut T { 0 as *mut T }\n /// ```\n /// use std::ptr;\n ///\n-/// unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> Vec<T> {\n+/// unsafe fn from_buf_raw<T>(ptr: *const T, elts: uint) -> Vec<T> {\n ///     let mut dst = Vec::with_capacity(elts);\n ///     dst.set_len(elts);\n ///     ptr::copy_memory(dst.as_mut_ptr(), ptr, elts);\n@@ -147,7 +147,7 @@ pub fn mut_null<T>() -> *mut T { 0 as *mut T }\n ///\n #[inline]\n #[unstable]\n-pub unsafe fn copy_memory<T>(dst: *mut T, src: *T, count: uint) {\n+pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     intrinsics::copy_memory(dst, src, count)\n }\n \n@@ -190,7 +190,7 @@ pub unsafe fn copy_memory<T>(dst: *mut T, src: *T, count: uint) {\n #[inline]\n #[unstable]\n pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T,\n-                                            src: *T,\n+                                            src: *const T,\n                                             count: uint) {\n     intrinsics::copy_nonoverlapping_memory(dst, src, count)\n }\n@@ -242,7 +242,7 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n /// Reads the value from `*src` and returns it.\n #[inline(always)]\n #[unstable]\n-pub unsafe fn read<T>(src: *T) -> T {\n+pub unsafe fn read<T>(src: *const T) -> T {\n     let mut tmp: T = mem::uninitialized();\n     copy_nonoverlapping_memory(&mut tmp, src, 1);\n     tmp\n@@ -275,11 +275,12 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n     intrinsics::move_val_init(&mut *dst, src)\n }\n \n-/// Given a **T (pointer to an array of pointers),\n-/// iterate through each *T, up to the provided `len`,\n+/// Given a *const *const T (pointer to an array of pointers),\n+/// iterate through each *const T, up to the provided `len`,\n /// passing to the provided callback function\n #[deprecated = \"old-style iteration. use a loop and RawPtr::offset\"]\n-pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: |*T|) {\n+pub unsafe fn array_each_with_len<T>(arr: *const *const T, len: uint,\n+                                     cb: |*const T|) {\n     if arr.is_null() {\n         fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n     }\n@@ -290,8 +291,8 @@ pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: |*T|) {\n     }\n }\n \n-/// Given a null-pointer-terminated **T (pointer to\n-/// an array of pointers), iterate through each *T,\n+/// Given a null-pointer-terminated *const *const T (pointer to\n+/// an array of pointers), iterate through each *const T,\n /// passing to the provided callback function\n ///\n /// # Safety Note\n@@ -300,7 +301,7 @@ pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: |*T|) {\n /// pointer array.\n #[deprecated = \"old-style iteration. use a loop and RawPtr::offset\"]\n #[allow(deprecated)]\n-pub unsafe fn array_each<T>(arr: **T, cb: |*T|) {\n+pub unsafe fn array_each<T>(arr: *const  *const T, cb: |*const T|) {\n     if arr.is_null()  {\n         fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n     }\n@@ -312,14 +313,14 @@ pub unsafe fn array_each<T>(arr: **T, cb: |*T|) {\n #[inline]\n #[deprecated = \"use a loop and RawPtr::offset\"]\n #[allow(deprecated)]\n-pub unsafe fn buf_len<T>(buf: **T) -> uint {\n+pub unsafe fn buf_len<T>(buf: *const *const T) -> uint {\n     position(buf, |i| *i == null())\n }\n \n /// Return the first offset `i` such that `f(buf[i]) == true`.\n #[inline]\n #[deprecated = \"old-style iteration. use a loop and RawPtr::offset\"]\n-pub unsafe fn position<T>(buf: *T, f: |&T| -> bool) -> uint {\n+pub unsafe fn position<T>(buf: *const T, f: |&T| -> bool) -> uint {\n     let mut i = 0;\n     loop {\n         if f(&(*buf.offset(i as int))) { return i; }\n@@ -352,9 +353,9 @@ pub trait RawPtr<T> {\n     unsafe fn offset(self, count: int) -> Self;\n }\n \n-impl<T> RawPtr<T> for *T {\n+impl<T> RawPtr<T> for *const T {\n     #[inline]\n-    fn null() -> *T { null() }\n+    fn null() -> *const T { null() }\n \n     #[inline]\n     fn is_null(&self) -> bool { *self == RawPtr::null() }\n@@ -363,7 +364,9 @@ impl<T> RawPtr<T> for *T {\n     fn to_uint(&self) -> uint { *self as uint }\n \n     #[inline]\n-    unsafe fn offset(self, count: int) -> *T { intrinsics::offset(self, count) }\n+    unsafe fn offset(self, count: int) -> *const T {\n+        intrinsics::offset(self, count)\n+    }\n \n     #[inline]\n     unsafe fn to_option(&self) -> Option<&T> {\n@@ -387,7 +390,7 @@ impl<T> RawPtr<T> for *mut T {\n \n     #[inline]\n     unsafe fn offset(self, count: int) -> *mut T {\n-        intrinsics::offset(self as *T, count) as *mut T\n+        intrinsics::offset(self as *const T, count) as *mut T\n     }\n \n     #[inline]\n@@ -402,17 +405,17 @@ impl<T> RawPtr<T> for *mut T {\n \n // Equality for pointers\n #[cfg(not(test))]\n-impl<T> PartialEq for *T {\n+impl<T> PartialEq for *const T {\n     #[inline]\n-    fn eq(&self, other: &*T) -> bool {\n+    fn eq(&self, other: &*const T) -> bool {\n         *self == *other\n     }\n     #[inline]\n-    fn ne(&self, other: &*T) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &*const T) -> bool { !self.eq(other) }\n }\n \n #[cfg(not(test))]\n-impl<T> Eq for *T {}\n+impl<T> Eq for *const T {}\n \n #[cfg(not(test))]\n impl<T> PartialEq for *mut T {\n@@ -429,22 +432,22 @@ impl<T> Eq for *mut T {}\n \n // Equivalence for pointers\n #[cfg(not(test))]\n-impl<T> Equiv<*mut T> for *T {\n+impl<T> Equiv<*mut T> for *const T {\n     fn equiv(&self, other: &*mut T) -> bool {\n         self.to_uint() == other.to_uint()\n     }\n }\n \n #[cfg(not(test))]\n-impl<T> Equiv<*T> for *mut T {\n-    fn equiv(&self, other: &*T) -> bool {\n+impl<T> Equiv<*const T> for *mut T {\n+    fn equiv(&self, other: &*const T) -> bool {\n         self.to_uint() == other.to_uint()\n     }\n }\n \n-impl<T> Clone for *T {\n+impl<T> Clone for *const T {\n     #[inline]\n-    fn clone(&self) -> *T {\n+    fn clone(&self) -> *const T {\n         *self\n     }\n }\n@@ -465,8 +468,8 @@ mod externfnpointers {\n     impl<_R> PartialEq for extern \"C\" fn() -> _R {\n         #[inline]\n         fn eq(&self, other: &extern \"C\" fn() -> _R) -> bool {\n-            let self_: *() = unsafe { mem::transmute(*self) };\n-            let other_: *() = unsafe { mem::transmute(*other) };\n+            let self_: *const () = unsafe { mem::transmute(*self) };\n+            let other_: *const () = unsafe { mem::transmute(*other) };\n             self_ == other_\n         }\n     }\n@@ -475,8 +478,9 @@ mod externfnpointers {\n             impl<_R,$($p),*> PartialEq for extern \"C\" fn($($p),*) -> _R {\n                 #[inline]\n                 fn eq(&self, other: &extern \"C\" fn($($p),*) -> _R) -> bool {\n-                    let self_: *() = unsafe { mem::transmute(*self) };\n-                    let other_: *() = unsafe { mem::transmute(*other) };\n+                    let self_: *const () = unsafe { mem::transmute(*self) };\n+\n+                    let other_: *const () = unsafe { mem::transmute(*other) };\n                     self_ == other_\n                 }\n             }\n@@ -491,9 +495,9 @@ mod externfnpointers {\n \n // Comparison for pointers\n #[cfg(not(test))]\n-impl<T> PartialOrd for *T {\n+impl<T> PartialOrd for *const T {\n     #[inline]\n-    fn lt(&self, other: &*T) -> bool { *self < *other }\n+    fn lt(&self, other: &*const T) -> bool { *self < *other }\n }\n \n #[cfg(not(test))]\n@@ -587,7 +591,7 @@ pub mod test {\n \n     #[test]\n     fn test_is_null() {\n-        let p: *int = null();\n+        let p: *const int = null();\n         assert!(p.is_null());\n         assert!(!p.is_not_null());\n \n@@ -607,10 +611,10 @@ pub mod test {\n     #[test]\n     fn test_to_option() {\n         unsafe {\n-            let p: *int = null();\n+            let p: *const int = null();\n             assert_eq!(p.to_option(), None);\n \n-            let q: *int = &2;\n+            let q: *const int = &2;\n             assert_eq!(q.to_option().unwrap(), &2);\n \n             let p: *mut int = mut_null();\n@@ -738,7 +742,7 @@ pub mod test {\n     #[should_fail]\n     fn test_ptr_array_each_with_len_null_ptr() {\n         unsafe {\n-            array_each_with_len(0 as **libc::c_char, 1, |e| {\n+            array_each_with_len(0 as *const *const libc::c_char, 1, |e| {\n                 str::raw::from_c_str(e);\n             });\n         }\n@@ -747,7 +751,7 @@ pub mod test {\n     #[should_fail]\n     fn test_ptr_array_each_null_ptr() {\n         unsafe {\n-            array_each(0 as **libc::c_char, |e| {\n+            array_each(0 as *const *const libc::c_char, |e| {\n                 str::raw::from_c_str(e);\n             });\n         }"}, {"sha": "f32e6bd9c7cc5986361df5277505f47d18f0c38a", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -31,29 +31,29 @@ pub struct Box<T> {\n \n /// The representation of a Rust slice\n pub struct Slice<T> {\n-    pub data: *T,\n+    pub data: *const T,\n     pub len: uint,\n }\n \n /// The representation of a Rust closure\n pub struct Closure {\n-    pub code: *(),\n-    pub env: *(),\n+    pub code: *mut (),\n+    pub env: *mut (),\n }\n \n /// The representation of a Rust procedure (`proc()`)\n pub struct Procedure {\n-    pub code: *(),\n-    pub env: *(),\n+    pub code: *mut (),\n+    pub env: *mut (),\n }\n \n /// The representation of a Rust trait object.\n ///\n /// This struct does not have a `Repr` implementation\n /// because there is no way to refer to all trait objects generically.\n pub struct TraitObject {\n-    pub vtable: *(),\n-    pub data: *(),\n+    pub vtable: *mut (),\n+    pub data: *mut (),\n }\n \n /// This trait is meant to map equivalences between raw structs and their"}, {"sha": "fea7986eee5951793455e2cd8ad52b2522b00c34", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -44,7 +44,7 @@ pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n  */\n pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n     unsafe {\n-        let ptr: *A = transmute(s);\n+        let ptr: *const A = transmute(s);\n         transmute(Slice { data: ptr, len: 1 })\n     }\n }\n@@ -439,7 +439,7 @@ pub trait ImmutableVector<'a, T> {\n      * Modifying the vector may cause its buffer to be reallocated, which\n      * would also make any pointers to it invalid.\n      */\n-    fn as_ptr(&self) -> *T;\n+    fn as_ptr(&self) -> *const T;\n \n     /**\n      * Binary search a sorted vector with a comparator function.\n@@ -520,7 +520,7 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n             let p = self.as_ptr();\n             if mem::size_of::<T>() == 0 {\n                 Items{ptr: p,\n-                      end: (p as uint + self.len()) as *T,\n+                      end: (p as uint + self.len()) as *const T,\n                       marker: marker::ContravariantLifetime::<'a>}\n             } else {\n                 Items{ptr: p,\n@@ -606,7 +606,7 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn as_ptr(&self) -> *T {\n+    fn as_ptr(&self) -> *const T {\n         self.repr().data\n     }\n \n@@ -936,7 +936,7 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n         assert!(end <= self.len());\n         unsafe {\n             transmute(Slice {\n-                    data: self.as_mut_ptr().offset(start as int) as *T,\n+                    data: self.as_mut_ptr().offset(start as int) as *const T,\n                     len: (end - start)\n                 })\n         }\n@@ -1115,7 +1115,7 @@ pub mod raw {\n      * not bytes).\n      */\n     #[inline]\n-    pub unsafe fn buf_as_slice<T,U>(p: *T, len: uint, f: |v: &[T]| -> U)\n+    pub unsafe fn buf_as_slice<T,U>(p: *const T, len: uint, f: |v: &[T]| -> U)\n                                -> U {\n         f(transmute(Slice {\n             data: p,\n@@ -1135,7 +1135,7 @@ pub mod raw {\n                                    f: |v: &mut [T]| -> U)\n                                    -> U {\n         f(transmute(Slice {\n-            data: p as *T,\n+            data: p as *const T,\n             len: len\n         }))\n     }\n@@ -1146,9 +1146,9 @@ pub mod raw {\n      * if the slice is empty. O(1).\n      */\n      #[inline]\n-    pub unsafe fn shift_ptr<T>(slice: &mut Slice<T>) -> Option<*T> {\n+    pub unsafe fn shift_ptr<T>(slice: &mut Slice<T>) -> Option<*const T> {\n         if slice.len == 0 { return None; }\n-        let head: *T = slice.data;\n+        let head: *const T = slice.data;\n         slice.data = slice.data.offset(1);\n         slice.len -= 1;\n         Some(head)\n@@ -1160,9 +1160,9 @@ pub mod raw {\n      * if the slice is empty. O(1).\n      */\n      #[inline]\n-    pub unsafe fn pop_ptr<T>(slice: &mut Slice<T>) -> Option<*T> {\n+    pub unsafe fn pop_ptr<T>(slice: &mut Slice<T>) -> Option<*const T> {\n         if slice.len == 0 { return None; }\n-        let tail: *T = slice.data.offset((slice.len - 1) as int);\n+        let tail: *const T = slice.data.offset((slice.len - 1) as int);\n         slice.len -= 1;\n         Some(tail)\n     }\n@@ -1201,8 +1201,8 @@ pub mod bytes {\n \n /// Immutable slice iterator\n pub struct Items<'a, T> {\n-    ptr: *T,\n-    end: *T,\n+    ptr: *const T,\n+    end: *const T,\n     marker: marker::ContravariantLifetime<'a>\n }\n \n@@ -1289,7 +1289,7 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n     }\n }\n \n-iterator!{struct Items -> *T, &'a T}\n+iterator!{struct Items -> *const T, &'a T}\n \n impl<'a, T> ExactSize<&'a T> for Items<'a, T> {}\n impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}"}, {"sha": "0d4b5f590742be64e0740a223aeb7e4d5f940364", "filename": "src/libcore/str.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -568,10 +568,10 @@ Section: Comparing strings\n #[inline]\n fn eq_slice_(a: &str, b: &str) -> bool {\n     #[allow(ctypes)]\n-    extern { fn memcmp(s1: *i8, s2: *i8, n: uint) -> i32; }\n+    extern { fn memcmp(s1: *const i8, s2: *const i8, n: uint) -> i32; }\n     a.len() == b.len() && unsafe {\n-        memcmp(a.as_ptr() as *i8,\n-               b.as_ptr() as *i8,\n+        memcmp(a.as_ptr() as *const i8,\n+               b.as_ptr() as *const i8,\n                a.len()) == 0\n     }\n }\n@@ -888,8 +888,8 @@ pub mod raw {\n     /// Form a slice from a C string. Unsafe because the caller must ensure the\n     /// C string has the static lifetime, or else the return value may be\n     /// invalidated later.\n-    pub unsafe fn c_str_to_static_slice(s: *i8) -> &'static str {\n-        let s = s as *u8;\n+    pub unsafe fn c_str_to_static_slice(s: *const i8) -> &'static str {\n+        let s = s as *const u8;\n         let mut curr = s;\n         let mut len = 0u;\n         while *curr != 0u8 {\n@@ -1618,7 +1618,7 @@ pub trait StrSlice<'a> {\n     /// The caller must ensure that the string outlives this pointer,\n     /// and that it is not reallocated (e.g. by pushing to the\n     /// string).\n-    fn as_ptr(&self) -> *u8;\n+    fn as_ptr(&self) -> *const u8;\n }\n \n impl<'a> StrSlice<'a> for &'a str {\n@@ -1964,7 +1964,7 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn as_ptr(&self) -> *u8 {\n+    fn as_ptr(&self) -> *const u8 {\n         self.repr().data\n     }\n }"}, {"sha": "5bdab6a78ca337d207a63394678360475e5db2a4", "filename": "src/libcore/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibcore%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fty.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -62,7 +62,7 @@ impl<T> Unsafe<T> {\n \n     /// Gets a mutable pointer to the wrapped value\n     #[inline]\n-    pub unsafe fn get(&self) -> *mut T { &self.value as *T as *mut T }\n+    pub unsafe fn get(&self) -> *mut T { &self.value as *const T as *mut T }\n \n     /// Unwraps the value\n     #[inline]"}, {"sha": "0cbae6ee2d3a3910104fd851929655bb0857e713", "filename": "src/libdebug/reflect.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibdebug%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibdebug%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Freflect.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -28,7 +28,7 @@ use std::gc::Gc;\n  * as `TyVisitor`; then build a MovePtrAdaptor wrapped around your struct.\n  */\n pub trait MovePtr {\n-    fn move_ptr(&mut self, adjustment: |*u8| -> *u8);\n+    fn move_ptr(&mut self, adjustment: |*const u8| -> *const u8);\n     fn push_ptr(&mut self);\n     fn pop_ptr(&mut self);\n }\n@@ -51,12 +51,12 @@ impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n \n     #[inline]\n     pub fn bump(&mut self, sz: uint) {\n-        self.inner.move_ptr(|p| ((p as uint) + sz) as *u8)\n+        self.inner.move_ptr(|p| ((p as uint) + sz) as *const u8)\n     }\n \n     #[inline]\n     pub fn align(&mut self, a: uint) {\n-        self.inner.move_ptr(|p| align(p as uint, a) as *u8)\n+        self.inner.move_ptr(|p| align(p as uint, a) as *const u8)\n     }\n \n     #[inline]\n@@ -202,43 +202,43 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_box(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n         self.align_to::<Gc<u8>>();\n         if ! self.inner.visit_box(mtbl, inner) { return false; }\n         self.bump_past::<Gc<u8>>();\n         true\n     }\n \n-    fn visit_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_uniq(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n         self.align_to::<Box<u8>>();\n         if ! self.inner.visit_uniq(mtbl, inner) { return false; }\n         self.bump_past::<Box<u8>>();\n         true\n     }\n \n-    fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<*u8>();\n+    fn visit_ptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n+        self.align_to::<*const u8>();\n         if ! self.inner.visit_ptr(mtbl, inner) { return false; }\n-        self.bump_past::<*u8>();\n+        self.bump_past::<*const u8>();\n         true\n     }\n \n-    fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_rptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n         self.align_to::<&'static u8>();\n         if ! self.inner.visit_rptr(mtbl, inner) { return false; }\n         self.bump_past::<&'static u8>();\n         true\n     }\n \n-    fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_evec_slice(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n         self.align_to::<&'static [u8]>();\n         if ! self.inner.visit_evec_slice(mtbl, inner) { return false; }\n         self.bump_past::<&'static [u8]>();\n         true\n     }\n \n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n-                        mtbl: uint, inner: *TyDesc) -> bool {\n+                        mtbl: uint, inner: *const TyDesc) -> bool {\n         self.align(align);\n         if ! self.inner.visit_evec_fixed(n, sz, align, mtbl, inner) {\n             return false;\n@@ -254,7 +254,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_rec_field(&mut self, i: uint, name: &str,\n-                       mtbl: uint, inner: *TyDesc) -> bool {\n+                       mtbl: uint, inner: *const TyDesc) -> bool {\n         unsafe { self.align((*inner).align); }\n         if ! self.inner.visit_rec_field(i, name, mtbl, inner) {\n             return false;\n@@ -278,7 +278,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_class_field(&mut self, i: uint, name: &str, named: bool, mtbl: uint,\n-                         inner: *TyDesc) -> bool {\n+                         inner: *const TyDesc) -> bool {\n         unsafe { self.align((*inner).align); }\n         if ! self.inner.visit_class_field(i, name, named, mtbl, inner) {\n             return false;\n@@ -301,7 +301,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool {\n+    fn visit_tup_field(&mut self, i: uint, inner: *const TyDesc) -> bool {\n         unsafe { self.align((*inner).align); }\n         if ! self.inner.visit_tup_field(i, inner) { return false; }\n         unsafe { self.bump((*inner).size); }\n@@ -321,12 +321,14 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    fn visit_fn_input(&mut self, i: uint, mode: uint, inner: *TyDesc) -> bool {\n+    fn visit_fn_input(&mut self, i: uint, mode: uint,\n+                      inner: *const TyDesc) -> bool {\n         if ! self.inner.visit_fn_input(i, mode, inner) { return false; }\n         true\n     }\n \n-    fn visit_fn_output(&mut self, retstyle: uint, variadic: bool, inner: *TyDesc) -> bool {\n+    fn visit_fn_output(&mut self, retstyle: uint, variadic: bool,\n+                       inner: *const TyDesc) -> bool {\n         if ! self.inner.visit_fn_output(retstyle, variadic, inner) { return false; }\n         true\n     }\n@@ -340,7 +342,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_enter_enum(&mut self, n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n+                        get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n                         sz: uint, align: uint)\n                      -> bool {\n         self.align(align);\n@@ -361,7 +363,8 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    fn visit_enum_variant_field(&mut self, i: uint, offset: uint, inner: *TyDesc) -> bool {\n+    fn visit_enum_variant_field(&mut self, i: uint, offset: uint,\n+                                inner: *const TyDesc) -> bool {\n         self.inner.push_ptr();\n         self.bump(offset);\n         if ! self.inner.visit_enum_variant_field(i, offset, inner) { return false; }\n@@ -381,7 +384,7 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_leave_enum(&mut self, n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n+                        get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n                         sz: uint, align: uint) -> bool {\n         if ! self.inner.visit_leave_enum(n_variants, get_disr, sz, align) {\n             return false;"}, {"sha": "1494a2defe949934173aab69655ba387704a8449", "filename": "src/libdebug/repr.rs", "status": "modified", "additions": 41, "deletions": 32, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibdebug%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibdebug%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Frepr.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -92,16 +92,16 @@ enum VariantState {\n }\n \n pub struct ReprVisitor<'a> {\n-    ptr: *u8,\n-    ptr_stk: Vec<*u8>,\n+    ptr: *const u8,\n+    ptr_stk: Vec<*const u8>,\n     var_stk: Vec<VariantState>,\n     writer: &'a mut io::Writer,\n     last_err: Option<io::IoError>,\n }\n \n impl<'a> MovePtr for ReprVisitor<'a> {\n     #[inline]\n-    fn move_ptr(&mut self, adjustment: |*u8| -> *u8) {\n+    fn move_ptr(&mut self, adjustment: |*const u8| -> *const u8) {\n         self.ptr = adjustment(self.ptr);\n     }\n     fn push_ptr(&mut self) {\n@@ -114,7 +114,7 @@ impl<'a> MovePtr for ReprVisitor<'a> {\n \n impl<'a> ReprVisitor<'a> {\n     // Various helpers for the TyVisitor impl\n-    pub fn new(ptr: *u8, writer: &'a mut io::Writer) -> ReprVisitor<'a> {\n+    pub fn new(ptr: *const u8, writer: &'a mut io::Writer) -> ReprVisitor<'a> {\n         ReprVisitor {\n             ptr: ptr,\n             ptr_stk: vec!(),\n@@ -128,18 +128,19 @@ impl<'a> ReprVisitor<'a> {\n     pub fn get<T>(&mut self, f: |&mut ReprVisitor, &T| -> bool) -> bool {\n         unsafe {\n             let ptr = self.ptr;\n-            f(self, mem::transmute::<*u8,&T>(ptr))\n+            f(self, mem::transmute::<*const u8,&T>(ptr))\n         }\n     }\n \n     #[inline]\n-    pub fn visit_inner(&mut self, inner: *TyDesc) -> bool {\n+    pub fn visit_inner(&mut self, inner: *const TyDesc) -> bool {\n         let ptr = self.ptr;\n         self.visit_ptr_inner(ptr, inner)\n     }\n \n     #[inline]\n-    pub fn visit_ptr_inner(&mut self, ptr: *u8, inner: *TyDesc) -> bool {\n+    pub fn visit_ptr_inner(&mut self, ptr: *const u8,\n+                           inner: *const TyDesc) -> bool {\n         unsafe {\n             let u = ReprVisitor::new(ptr, mem::transmute_copy(&self.writer));\n             let mut v = reflect::MovePtrAdaptor::new(u);\n@@ -183,8 +184,9 @@ impl<'a> ReprVisitor<'a> {\n         true\n     }\n \n-    pub fn write_vec_range(&mut self, ptr: *(), len: uint, inner: *TyDesc) -> bool {\n-        let mut p = ptr as *u8;\n+    pub fn write_vec_range(&mut self, ptr: *const (), len: uint,\n+                           inner: *const TyDesc) -> bool {\n+        let mut p = ptr as *const u8;\n         let (sz, al) = unsafe { ((*inner).size, (*inner).align) };\n         try!(self, self.writer.write(['[' as u8]));\n         let mut first = true;\n@@ -197,8 +199,8 @@ impl<'a> ReprVisitor<'a> {\n             } else {\n                 try!(self, self.writer.write(\", \".as_bytes()));\n             }\n-            self.visit_ptr_inner(p as *u8, inner);\n-            p = align(unsafe { p.offset(sz as int) as uint }, al) as *u8;\n+            self.visit_ptr_inner(p as *const u8, inner);\n+            p = align(unsafe { p.offset(sz as int) as uint }, al) as *const u8;\n             left -= dec;\n         }\n         try!(self, self.writer.write([']' as u8]));\n@@ -276,40 +278,46 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     fn visit_estr_fixed(&mut self, _n: uint, _sz: uint,\n                         _align: uint) -> bool { fail!(); }\n \n-    fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_box(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n         try!(self, self.writer.write(\"box(GC) \".as_bytes()));\n         self.write_mut_qualifier(mtbl);\n         self.get::<&raw::Box<()>>(|this, b| {\n-            let p = &b.data as *() as *u8;\n+            let p = &b.data as *const () as *const u8;\n             this.visit_ptr_inner(p, inner)\n         })\n     }\n \n-    fn visit_uniq(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_uniq(&mut self, _mtbl: uint, inner: *const TyDesc) -> bool {\n         try!(self, self.writer.write(\"box \".as_bytes()));\n-        self.get::<*u8>(|this, b| {\n+        self.get::<*const u8>(|this, b| {\n             this.visit_ptr_inner(*b, inner)\n         })\n     }\n \n-    fn visit_ptr(&mut self, mtbl: uint, _inner: *TyDesc) -> bool {\n-        self.get::<*u8>(|this, p| {\n+    fn visit_ptr(&mut self, mtbl: uint, _inner: *const TyDesc) -> bool {\n+        self.get::<*const u8>(|this, p| {\n             try!(this, write!(this.writer, \"({} as *\", *p));\n-            this.write_mut_qualifier(mtbl);\n+            if mtbl == 0 {\n+                try!(this, this.writer.write(\"mut \".as_bytes()));\n+            } else if mtbl == 1 {\n+                try!(this, this.writer.write(\"const \".as_bytes()));\n+            } else {\n+                fail!(\"invalid mutability value\");\n+            }\n             try!(this, this.writer.write(\"())\".as_bytes()));\n             true\n         })\n     }\n \n-    fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_rptr(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n         try!(self, self.writer.write(['&' as u8]));\n         self.write_mut_qualifier(mtbl);\n-        self.get::<*u8>(|this, p| {\n+        self.get::<*const u8>(|this, p| {\n             this.visit_ptr_inner(*p, inner)\n         })\n     }\n \n-    fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n+    fn visit_evec_slice(&mut self, mtbl: uint, inner: *const TyDesc) -> bool {\n         self.get::<raw::Slice<()>>(|this, s| {\n             try!(this, this.writer.write(['&' as u8]));\n             this.write_mut_qualifier(mtbl);\n@@ -321,7 +329,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     }\n \n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, _align: uint,\n-                        _: uint, inner: *TyDesc) -> bool {\n+                        _: uint, inner: *const TyDesc) -> bool {\n         let assumed_size = if sz == 0 { n } else { sz };\n         self.get::<()>(|this, b| {\n             this.write_vec_range(b, assumed_size, inner)\n@@ -335,7 +343,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     }\n \n     fn visit_rec_field(&mut self, i: uint, name: &str,\n-                       mtbl: uint, inner: *TyDesc) -> bool {\n+                       mtbl: uint, inner: *const TyDesc) -> bool {\n         if i != 0 {\n             try!(self, self.writer.write(\", \".as_bytes()));\n         }\n@@ -366,7 +374,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     }\n \n     fn visit_class_field(&mut self, i: uint, name: &str, named: bool,\n-                         _mtbl: uint, inner: *TyDesc) -> bool {\n+                         _mtbl: uint, inner: *const TyDesc) -> bool {\n         if i != 0 {\n             try!(self, self.writer.write(\", \".as_bytes()));\n         }\n@@ -396,7 +404,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         true\n     }\n \n-    fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool {\n+    fn visit_tup_field(&mut self, i: uint, inner: *const TyDesc) -> bool {\n         if i != 0 {\n             try!(self, self.writer.write(\", \".as_bytes()));\n         }\n@@ -415,7 +423,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_enter_enum(&mut self,\n                         _n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n+                        get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n                         _sz: uint,\n                         _align: uint) -> bool {\n         let disr = unsafe {\n@@ -456,7 +464,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     fn visit_enum_variant_field(&mut self,\n                                 i: uint,\n                                 _offset: uint,\n-                                inner: *TyDesc)\n+                                inner: *const TyDesc)\n                                 -> bool {\n         match *self.var_stk.get(self.var_stk.len() - 1) {\n             Matched => {\n@@ -489,7 +497,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n     fn visit_leave_enum(&mut self,\n                         _n_variants: uint,\n-                        _get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n+                        _get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n                         _sz: uint,\n                         _align: uint)\n                         -> bool {\n@@ -505,7 +513,8 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         true\n     }\n \n-    fn visit_fn_input(&mut self, i: uint, _mode: uint, inner: *TyDesc) -> bool {\n+    fn visit_fn_input(&mut self, i: uint, _mode: uint,\n+                      inner: *const TyDesc) -> bool {\n         if i != 0 {\n             try!(self, self.writer.write(\", \".as_bytes()));\n         }\n@@ -515,7 +524,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     }\n \n     fn visit_fn_output(&mut self, _retstyle: uint, variadic: bool,\n-                       inner: *TyDesc) -> bool {\n+                       inner: *const TyDesc) -> bool {\n         if variadic {\n             try!(self, self.writer.write(\", ...\".as_bytes()));\n         }\n@@ -543,7 +552,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n pub fn write_repr<T>(writer: &mut io::Writer, object: &T) -> io::IoResult<()> {\n     unsafe {\n-        let ptr = object as *T as *u8;\n+        let ptr = object as *const T as *const u8;\n         let tydesc = get_tydesc::<T>();\n         let u = ReprVisitor::new(ptr, writer);\n         let mut v = reflect::MovePtrAdaptor::new(u);\n@@ -591,7 +600,7 @@ fn test_repr() {\n     let mut x = 10;\n     exact_test(&(&mut x), \"&mut 10\");\n \n-    exact_test(&(0 as *()), \"(0x0 as *())\");\n+    exact_test(&(0 as *const ()), \"(0x0 as *const ())\");\n     exact_test(&(0 as *mut ()), \"(0x0 as *mut ())\");\n \n     exact_test(&(1,), \"(1,)\");"}, {"sha": "06f574f4c88a3a4b275620847e6f4e58e691ae3b", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -38,18 +38,18 @@ use libc::{c_void, size_t, c_int};\n #[link(name = \"miniz\", kind = \"static\")]\n extern {\n     /// Raw miniz compression function.\n-    fn tdefl_compress_mem_to_heap(psrc_buf: *c_void,\n-                                      src_buf_len: size_t,\n-                                      pout_len: *mut size_t,\n-                                      flags: c_int)\n-                                      -> *mut c_void;\n+    fn tdefl_compress_mem_to_heap(psrc_buf: *const c_void,\n+                                  src_buf_len: size_t,\n+                                  pout_len: *mut size_t,\n+                                  flags: c_int)\n+                                  -> *mut c_void;\n \n     /// Raw miniz decompression function.\n-    fn tinfl_decompress_mem_to_heap(psrc_buf: *c_void,\n-                                        src_buf_len: size_t,\n-                                        pout_len: *mut size_t,\n-                                        flags: c_int)\n-                                        -> *mut c_void;\n+    fn tinfl_decompress_mem_to_heap(psrc_buf: *const c_void,\n+                                    src_buf_len: size_t,\n+                                    pout_len: *mut size_t,\n+                                    flags: c_int)\n+                                    -> *mut c_void;\n }\n \n static LZ_NORM : c_int = 0x80;  // LZ with 128 probes, \"normal\"\n@@ -59,10 +59,10 @@ static TDEFL_WRITE_ZLIB_HEADER : c_int = 0x01000; // write zlib header and adler\n fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n     unsafe {\n         let mut outsz : size_t = 0;\n-        let res = tdefl_compress_mem_to_heap(bytes.as_ptr() as *c_void,\n-                                                     bytes.len() as size_t,\n-                                                     &mut outsz,\n-                                                     flags);\n+        let res = tdefl_compress_mem_to_heap(bytes.as_ptr() as *const _,\n+                                             bytes.len() as size_t,\n+                                             &mut outsz,\n+                                             flags);\n         if !res.is_null() {\n             Some(CVec::new_with_dtor(res as *mut u8, outsz as uint, proc() libc::free(res)))\n         } else {\n@@ -84,10 +84,10 @@ pub fn deflate_bytes_zlib(bytes: &[u8]) -> Option<CVec<u8>> {\n fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n     unsafe {\n         let mut outsz : size_t = 0;\n-        let res = tinfl_decompress_mem_to_heap(bytes.as_ptr() as *c_void,\n-                                                       bytes.len() as size_t,\n-                                                       &mut outsz,\n-                                                       flags);\n+        let res = tinfl_decompress_mem_to_heap(bytes.as_ptr() as *const _,\n+                                               bytes.len() as size_t,\n+                                               &mut outsz,\n+                                               flags);\n         if !res.is_null() {\n             Some(CVec::new_with_dtor(res as *mut u8, outsz as uint, proc() libc::free(res)))\n         } else {"}, {"sha": "8c60f3d9fe1dc19f3b83de676c20ce45f73fa27c", "filename": "src/libgreen/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibgreen%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibgreen%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcontext.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -27,7 +27,7 @@ pub struct Context {\n     stack_bounds: Option<(uint, uint)>,\n }\n \n-pub type InitFn = extern \"C\" fn(uint, *(), *()) -> !;\n+pub type InitFn = extern \"C\" fn(uint, *mut (), *mut ()) -> !;\n \n impl Context {\n     pub fn empty() -> Context {\n@@ -49,7 +49,7 @@ impl Context {\n     pub fn new(init: InitFn, arg: uint, start: proc():Send,\n                stack: &mut Stack) -> Context {\n \n-        let sp: *uint = stack.end();\n+        let sp: *const uint = stack.end();\n         let sp: *mut uint = sp as *mut uint;\n         // Save and then immediately load the current context,\n         // which we will then modify to call the given function when restored\n@@ -66,7 +66,7 @@ impl Context {\n         // them in terms of the code running on them (and hopefully they don't\n         // overflow). Additionally, their coroutine stacks are listed as being\n         // zero-length, so that's how we detect what's what here.\n-        let stack_base: *uint = stack.start();\n+        let stack_base: *const uint = stack.start();\n         let bounds = if sp as uint == stack_base as uint {\n             None\n         } else {\n@@ -116,7 +116,7 @@ impl Context {\n \n #[link(name = \"context_switch\", kind = \"static\")]\n extern {\n-    fn rust_swap_registers(out_regs: *mut Registers, in_regs: *Registers);\n+    fn rust_swap_registers(out_regs: *mut Registers, in_regs: *const Registers);\n }\n \n // Register contexts used in various architectures"}, {"sha": "e803c75ca5a725b03a2524fd8d1b91734c8f7e4f", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -116,7 +116,7 @@\n //! extern crate green;\n //!\n //! #[start]\n-//! fn start(argc: int, argv: **u8) -> int {\n+//! fn start(argc: int, argv: *const *const u8) -> int {\n //!     green::start(argc, argv, green::basic::event_loop, main)\n //! }\n //!\n@@ -135,7 +135,7 @@\n //! extern crate rustuv;\n //!\n //! #[start]\n-//! fn start(argc: int, argv: **u8) -> int {\n+//! fn start(argc: int, argv: *const *const u8) -> int {\n //!     green::start(argc, argv, rustuv::event_loop, main)\n //! }\n //!\n@@ -267,7 +267,7 @@ macro_rules! green_start( ($f:ident) => (\n         extern crate rustuv;\n \n         #[start]\n-        fn start(argc: int, argv: **u8) -> int {\n+        fn start(argc: int, argv: *const *const u8) -> int {\n             green::start(argc, argv, rustuv::event_loop, super::$f)\n         }\n     }\n@@ -291,7 +291,7 @@ macro_rules! green_start( ($f:ident) => (\n ///\n /// The return value is used as the process return code. 0 on success, 101 on\n /// error.\n-pub fn start(argc: int, argv: **u8,\n+pub fn start(argc: int, argv: *const *const u8,\n              event_loop_factory: fn() -> Box<rtio::EventLoop + Send>,\n              main: proc():Send) -> int {\n     rt::init(argc, argv);"}, {"sha": "c5130a542fc8295978a93c7798330089d359b9d8", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -611,13 +611,13 @@ impl Scheduler {\n     // old task as inputs.\n \n     pub fn change_task_context(mut ~self,\n-                               current_task: Box<GreenTask>,\n+                               mut current_task: Box<GreenTask>,\n                                mut next_task: Box<GreenTask>,\n                                f: |&mut Scheduler, Box<GreenTask>|)\n                                -> Box<GreenTask> {\n         let f_opaque = ClosureConverter::from_fn(f);\n \n-        let current_task_dupe = &*current_task as *GreenTask;\n+        let current_task_dupe = &mut *current_task as *mut GreenTask;\n \n         // The current task is placed inside an enum with the cleanup\n         // function. This enum is then placed inside the scheduler.\n@@ -871,7 +871,7 @@ impl Scheduler {\n \n     // * Utility Functions\n \n-    pub fn sched_id(&self) -> uint { self as *Scheduler as uint }\n+    pub fn sched_id(&self) -> uint { self as *const Scheduler as uint }\n \n     pub fn run_cleanup_job(&mut self) {\n         let cleanup_job = self.cleanup_job.take_unwrap();"}, {"sha": "874ddbfe7ed0e3137775f4d219b2919834403e4f", "filename": "src/libgreen/simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -32,7 +32,7 @@ impl Runtime for SimpleTask {\n         assert!(times == 1);\n \n         let me = &mut *self as *mut SimpleTask;\n-        let cur_dupe = &*cur_task as *Task;\n+        let cur_dupe = &mut *cur_task as *mut Task;\n         cur_task.put_runtime(self);\n         let task = BlockedTask::block(cur_task);\n "}, {"sha": "c4885edb7d3a776f63cb3df282c6c65f6ed36a13", "filename": "src/libgreen/stack.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibgreen%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibgreen%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fstack.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -78,14 +78,14 @@ impl Stack {\n     }\n \n     /// Point to the low end of the allocated stack\n-    pub fn start(&self) -> *uint {\n-        self.buf.data as *uint\n+    pub fn start(&self) -> *const uint {\n+        self.buf.data as *const uint\n     }\n \n     /// Point one uint beyond the high end of the allocated stack\n-    pub fn end(&self) -> *uint {\n+    pub fn end(&self) -> *const uint {\n         unsafe {\n-            self.buf.data.offset(self.buf.len as int) as *uint\n+            self.buf.data.offset(self.buf.len as int) as *const uint\n         }\n     }\n }\n@@ -168,8 +168,8 @@ fn max_cached_stacks() -> uint {\n }\n \n extern {\n-    fn rust_valgrind_stack_register(start: *libc::uintptr_t,\n-                                    end: *libc::uintptr_t) -> libc::c_uint;\n+    fn rust_valgrind_stack_register(start: *const libc::uintptr_t,\n+                                    end: *const libc::uintptr_t) -> libc::c_uint;\n     fn rust_valgrind_stack_deregister(id: libc::c_uint);\n }\n "}, {"sha": "68a454233cf9a2ce7594568c97dc149ce2c00c5a", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -89,7 +89,7 @@ pub enum Home {\n ///\n /// The goal for having this weird-looking function is to reduce the number of\n /// allocations done on a green-task startup as much as possible.\n-extern fn bootstrap_green_task(task: uint, code: *(), env: *()) -> ! {\n+extern fn bootstrap_green_task(task: uint, code: *mut (), env: *mut ()) -> ! {\n     // Acquire ownership of the `proc()`\n     let start: proc() = unsafe {\n         mem::transmute(raw::Procedure { code: code, env: env })\n@@ -256,7 +256,7 @@ impl GreenTask {\n     // context switches\n \n     pub fn as_uint(&self) -> uint {\n-        self as *GreenTask as uint\n+        self as *const GreenTask as uint\n     }\n \n     pub unsafe fn from_uint(val: uint) -> Box<GreenTask> {"}, {"sha": "3f7f0437baee4378592fa5b3edc1c0b806adab22", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 222, "deletions": 195, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -365,14 +365,14 @@ pub mod types {\n \n                 pub struct glob_t {\n                     pub gl_pathc: size_t,\n-                    pub gl_pathv: **c_char,\n+                    pub gl_pathv: *mut *mut c_char,\n                     pub gl_offs:  size_t,\n \n-                    pub __unused1: *c_void,\n-                    pub __unused2: *c_void,\n-                    pub __unused3: *c_void,\n-                    pub __unused4: *c_void,\n-                    pub __unused5: *c_void,\n+                    pub __unused1: *mut c_void,\n+                    pub __unused2: *mut c_void,\n+                    pub __unused3: *mut c_void,\n+                    pub __unused4: *mut c_void,\n+                    pub __unused5: *mut c_void,\n                 }\n \n                 pub struct timeval {\n@@ -440,18 +440,18 @@ pub mod types {\n                     pub ai_addrlen: socklen_t,\n \n                     #[cfg(target_os = \"linux\")]\n-                    pub ai_addr: *sockaddr,\n+                    pub ai_addr: *mut sockaddr,\n \n                     #[cfg(target_os = \"linux\")]\n-                    pub ai_canonname: *c_char,\n+                    pub ai_canonname: *mut c_char,\n \n                     #[cfg(target_os = \"android\")]\n-                    pub ai_canonname: *c_char,\n+                    pub ai_canonname: *mut c_char,\n \n                     #[cfg(target_os = \"android\")]\n-                    pub ai_addr: *sockaddr,\n+                    pub ai_addr: *mut sockaddr,\n \n-                    pub ai_next: *addrinfo,\n+                    pub ai_next: *mut addrinfo,\n                 }\n                 pub struct sockaddr_un {\n                     pub sun_family: sa_family_t,\n@@ -751,15 +751,15 @@ pub mod types {\n                     pub __unused1: size_t,\n                     pub gl_offs:   size_t,\n                     pub __unused2: c_int,\n-                    pub gl_pathv:  **c_char,\n+                    pub gl_pathv:  *mut *mut c_char,\n \n-                    pub __unused3: *c_void,\n+                    pub __unused3: *mut c_void,\n \n-                    pub __unused4: *c_void,\n-                    pub __unused5: *c_void,\n-                    pub __unused6: *c_void,\n-                    pub __unused7: *c_void,\n-                    pub __unused8: *c_void,\n+                    pub __unused4: *mut c_void,\n+                    pub __unused5: *mut c_void,\n+                    pub __unused6: *mut c_void,\n+                    pub __unused7: *mut c_void,\n+                    pub __unused8: *mut c_void,\n                 }\n \n                 pub struct timeval {\n@@ -830,9 +830,9 @@ pub mod types {\n                     pub ai_socktype: c_int,\n                     pub ai_protocol: c_int,\n                     pub ai_addrlen: socklen_t,\n-                    pub ai_canonname: *c_char,\n-                    pub ai_addr: *sockaddr,\n-                    pub ai_next: *addrinfo,\n+                    pub ai_canonname: *mut c_char,\n+                    pub ai_addr: *mut sockaddr,\n+                    pub ai_next: *mut addrinfo,\n                 }\n                 pub struct sockaddr_un {\n                     pub sun_len: u8,\n@@ -922,7 +922,7 @@ pub mod types {\n                     pub modtime: time_t,\n                 }\n \n-                pub type pthread_attr_t = *c_void;\n+                pub type pthread_attr_t = *mut c_void;\n             }\n             pub mod posix08 {\n             }\n@@ -1028,9 +1028,9 @@ pub mod types {\n                     pub ai_socktype: c_int,\n                     pub ai_protocol: c_int,\n                     pub ai_addrlen: size_t,\n-                    pub ai_canonname: *c_char,\n-                    pub ai_addr: *sockaddr,\n-                    pub ai_next: *addrinfo,\n+                    pub ai_canonname: *mut c_char,\n+                    pub ai_addr: *mut sockaddr,\n+                    pub ai_next: *mut addrinfo,\n                 }\n                 pub struct sockaddr_un {\n                     pub sun_family: sa_family_t,\n@@ -1142,8 +1142,8 @@ pub mod types {\n                 pub type LARGE_INTEGER = c_longlong;\n                 pub type PLARGE_INTEGER = *mut c_longlong;\n \n-                pub type LPCWSTR = *WCHAR;\n-                pub type LPCSTR = *CHAR;\n+                pub type LPCWSTR = *const WCHAR;\n+                pub type LPCSTR = *const CHAR;\n \n                 pub type LPWSTR = *mut WCHAR;\n                 pub type LPSTR = *mut CHAR;\n@@ -1159,7 +1159,7 @@ pub mod types {\n                 pub type LPSECURITY_ATTRIBUTES = *mut SECURITY_ATTRIBUTES;\n \n                 pub type LPVOID = *mut c_void;\n-                pub type LPCVOID = *c_void;\n+                pub type LPCVOID = *const c_void;\n                 pub type LPBYTE = *mut BYTE;\n                 pub type LPWORD = *mut WORD;\n                 pub type LPDWORD = *mut DWORD;\n@@ -1231,8 +1231,8 @@ pub mod types {\n                 pub type LPMEMORY_BASIC_INFORMATION = *mut MEMORY_BASIC_INFORMATION;\n \n                 pub struct OVERLAPPED {\n-                    pub Internal: *c_ulong,\n-                    pub InternalHigh: *c_ulong,\n+                    pub Internal: *mut c_ulong,\n+                    pub InternalHigh: *mut c_ulong,\n                     pub Offset: DWORD,\n                     pub OffsetHigh: DWORD,\n                     pub hEvent: HANDLE,\n@@ -1308,15 +1308,15 @@ pub mod types {\n                     pub __unused1: c_int,\n                     pub gl_offs:   size_t,\n                     pub __unused2: c_int,\n-                    pub gl_pathv:  **c_char,\n+                    pub gl_pathv:  *mut *mut c_char,\n \n-                    pub __unused3: *c_void,\n+                    pub __unused3: *mut c_void,\n \n-                    pub __unused4: *c_void,\n-                    pub __unused5: *c_void,\n-                    pub __unused6: *c_void,\n-                    pub __unused7: *c_void,\n-                    pub __unused8: *c_void,\n+                    pub __unused4: *mut c_void,\n+                    pub __unused5: *mut c_void,\n+                    pub __unused6: *mut c_void,\n+                    pub __unused7: *mut c_void,\n+                    pub __unused8: *mut c_void,\n                 }\n \n                 pub struct timeval {\n@@ -1388,9 +1388,9 @@ pub mod types {\n                     pub ai_socktype: c_int,\n                     pub ai_protocol: c_int,\n                     pub ai_addrlen: socklen_t,\n-                    pub ai_canonname: *c_char,\n-                    pub ai_addr: *sockaddr,\n-                    pub ai_next: *addrinfo,\n+                    pub ai_canonname: *mut c_char,\n+                    pub ai_addr: *mut sockaddr,\n+                    pub ai_next: *mut addrinfo,\n                 }\n                 pub struct sockaddr_un {\n                     pub sun_len: u8,\n@@ -3539,53 +3539,56 @@ pub mod funcs {\n             use types::os::arch::c95::{c_char, c_int, c_long, size_t};\n \n             extern {\n-                pub fn fopen(filename: *c_char, mode: *c_char) -> *FILE;\n-                pub fn freopen(filename: *c_char, mode: *c_char, file: *FILE)\n-                               -> *FILE;\n-                pub fn fflush(file: *FILE) -> c_int;\n-                pub fn fclose(file: *FILE) -> c_int;\n-                pub fn remove(filename: *c_char) -> c_int;\n-                pub fn rename(oldname: *c_char, newname: *c_char) -> c_int;\n-                pub fn tmpfile() -> *FILE;\n-                pub fn setvbuf(stream: *FILE,\n-                               buffer: *c_char,\n+                pub fn fopen(filename: *const c_char,\n+                             mode: *const c_char) -> *mut FILE;\n+                pub fn freopen(filename: *const c_char, mode: *const c_char,\n+                               file: *mut FILE)\n+                               -> *mut FILE;\n+                pub fn fflush(file: *mut FILE) -> c_int;\n+                pub fn fclose(file: *mut FILE) -> c_int;\n+                pub fn remove(filename: *const c_char) -> c_int;\n+                pub fn rename(oldname: *const c_char,\n+                              newname: *const c_char) -> c_int;\n+                pub fn tmpfile() -> *mut FILE;\n+                pub fn setvbuf(stream: *mut FILE,\n+                               buffer: *mut c_char,\n                                mode: c_int,\n                                size: size_t)\n                                -> c_int;\n-                pub fn setbuf(stream: *FILE, buf: *c_char);\n+                pub fn setbuf(stream: *mut FILE, buf: *mut c_char);\n                 // Omitted: printf and scanf variants.\n-                pub fn fgetc(stream: *FILE) -> c_int;\n-                pub fn fgets(buf: *mut c_char, n: c_int, stream: *FILE)\n-                             -> *c_char;\n-                pub fn fputc(c: c_int, stream: *FILE) -> c_int;\n-                pub fn fputs(s: *c_char, stream: *FILE) -> *c_char;\n+                pub fn fgetc(stream: *mut FILE) -> c_int;\n+                pub fn fgets(buf: *mut c_char, n: c_int, stream: *mut FILE)\n+                             -> *mut c_char;\n+                pub fn fputc(c: c_int, stream: *mut FILE) -> c_int;\n+                pub fn fputs(s: *const c_char, stream: *mut FILE)-> c_int;\n                 // Omitted: getc, getchar (might be macros).\n \n                 // Omitted: gets, so ridiculously unsafe that it should not\n                 // survive.\n \n                 // Omitted: putc, putchar (might be macros).\n-                pub fn puts(s: *c_char) -> c_int;\n-                pub fn ungetc(c: c_int, stream: *FILE) -> c_int;\n+                pub fn puts(s: *const c_char) -> c_int;\n+                pub fn ungetc(c: c_int, stream: *mut FILE) -> c_int;\n                 pub fn fread(ptr: *mut c_void,\n                              size: size_t,\n                              nobj: size_t,\n-                             stream: *FILE)\n+                             stream: *mut FILE)\n                              -> size_t;\n-                pub fn fwrite(ptr: *c_void,\n+                pub fn fwrite(ptr: *const c_void,\n                               size: size_t,\n                               nobj: size_t,\n-                              stream: *FILE)\n+                              stream: *mut FILE)\n                               -> size_t;\n-                pub fn fseek(stream: *FILE, offset: c_long, whence: c_int)\n+                pub fn fseek(stream: *mut FILE, offset: c_long, whence: c_int)\n                              -> c_int;\n-                pub fn ftell(stream: *FILE) -> c_long;\n-                pub fn rewind(stream: *FILE);\n-                pub fn fgetpos(stream: *FILE, ptr: *fpos_t) -> c_int;\n-                pub fn fsetpos(stream: *FILE, ptr: *fpos_t) -> c_int;\n-                pub fn feof(stream: *FILE) -> c_int;\n-                pub fn ferror(stream: *FILE) -> c_int;\n-                pub fn perror(s: *c_char);\n+                pub fn ftell(stream: *mut FILE) -> c_long;\n+                pub fn rewind(stream: *mut FILE);\n+                pub fn fgetpos(stream: *mut FILE, ptr: *mut fpos_t) -> c_int;\n+                pub fn fsetpos(stream: *mut FILE, ptr: *mut fpos_t) -> c_int;\n+                pub fn feof(stream: *mut FILE) -> c_int;\n+                pub fn ferror(stream: *mut FILE) -> c_int;\n+                pub fn perror(s: *const c_char);\n             }\n         }\n \n@@ -3599,22 +3602,23 @@ pub mod funcs {\n                 pub fn abs(i: c_int) -> c_int;\n                 pub fn labs(i: c_long) -> c_long;\n                 // Omitted: div, ldiv (return pub type incomplete).\n-                pub fn atof(s: *c_char) -> c_double;\n-                pub fn atoi(s: *c_char) -> c_int;\n-                pub fn strtod(s: *c_char, endp: **c_char) -> c_double;\n-                pub fn strtol(s: *c_char, endp: **c_char, base: c_int)\n-                              -> c_long;\n-                pub fn strtoul(s: *c_char, endp: **c_char, base: c_int)\n-                               -> c_ulong;\n-                pub fn calloc(nobj: size_t, size: size_t) -> *c_void;\n+                pub fn atof(s: *const c_char) -> c_double;\n+                pub fn atoi(s: *const c_char) -> c_int;\n+                pub fn strtod(s: *const c_char,\n+                              endp: *mut *mut c_char) -> c_double;\n+                pub fn strtol(s: *const c_char,\n+                              endp: *mut *mut c_char, base: c_int) -> c_long;\n+                pub fn strtoul(s: *const c_char, endp: *mut *mut c_char,\n+                               base: c_int) -> c_ulong;\n+                pub fn calloc(nobj: size_t, size: size_t) -> *mut c_void;\n                 pub fn malloc(size: size_t) -> *mut c_void;\n                 pub fn realloc(p: *mut c_void, size: size_t) -> *mut c_void;\n                 pub fn free(p: *mut c_void);\n                 pub fn exit(status: c_int) -> !;\n                 pub fn _exit(status: c_int) -> !;\n                 // Omitted: atexit.\n-                pub fn system(s: *c_char) -> c_int;\n-                pub fn getenv(s: *c_char) -> *c_char;\n+                pub fn system(s: *const c_char) -> c_int;\n+                pub fn getenv(s: *const c_char) -> *mut c_char;\n                 // Omitted: bsearch, qsort\n                 pub fn rand() -> c_int;\n                 pub fn srand(seed: c_uint);\n@@ -3627,32 +3631,40 @@ pub mod funcs {\n             use types::os::arch::c95::{wchar_t};\n \n             extern {\n-                pub fn strcpy(dst: *c_char, src: *c_char) -> *c_char;\n-                pub fn strncpy(dst: *c_char, src: *c_char, n: size_t)\n-                               -> *c_char;\n-                pub fn strcat(s: *c_char, ct: *c_char) -> *c_char;\n-                pub fn strncat(s: *c_char, ct: *c_char, n: size_t) -> *c_char;\n-                pub fn strcmp(cs: *c_char, ct: *c_char) -> c_int;\n-                pub fn strncmp(cs: *c_char, ct: *c_char, n: size_t) -> c_int;\n-                pub fn strcoll(cs: *c_char, ct: *c_char) -> c_int;\n-                pub fn strchr(cs: *c_char, c: c_int) -> *c_char;\n-                pub fn strrchr(cs: *c_char, c: c_int) -> *c_char;\n-                pub fn strspn(cs: *c_char, ct: *c_char) -> size_t;\n-                pub fn strcspn(cs: *c_char, ct: *c_char) -> size_t;\n-                pub fn strpbrk(cs: *c_char, ct: *c_char) -> *c_char;\n-                pub fn strstr(cs: *c_char, ct: *c_char) -> *c_char;\n-                pub fn strlen(cs: *c_char) -> size_t;\n-                pub fn strerror(n: c_int) -> *c_char;\n-                pub fn strtok(s: *c_char, t: *c_char) -> *c_char;\n-                pub fn strxfrm(s: *c_char, ct: *c_char, n: size_t) -> size_t;\n-                pub fn wcslen(buf: *wchar_t) -> size_t;\n+                pub fn strcpy(dst: *mut c_char,\n+                              src: *const c_char) -> *mut c_char;\n+                pub fn strncpy(dst: *mut c_char, src: *const c_char, n: size_t)\n+                               -> *mut c_char;\n+                pub fn strcat(s: *mut c_char, ct: *const c_char) -> *mut c_char;\n+                pub fn strncat(s: *mut c_char, ct: *const c_char,\n+                               n: size_t) -> *mut c_char;\n+                pub fn strcmp(cs: *const c_char, ct: *const c_char) -> c_int;\n+                pub fn strncmp(cs: *const c_char, ct: *const c_char,\n+                               n: size_t) -> c_int;\n+                pub fn strcoll(cs: *const c_char, ct: *const c_char) -> c_int;\n+                pub fn strchr(cs: *const c_char, c: c_int) -> *mut c_char;\n+                pub fn strrchr(cs: *const c_char, c: c_int) -> *mut c_char;\n+                pub fn strspn(cs: *const c_char, ct: *const c_char) -> size_t;\n+                pub fn strcspn(cs: *const c_char, ct: *const c_char) -> size_t;\n+                pub fn strpbrk(cs: *const c_char,\n+                               ct: *const c_char) -> *mut c_char;\n+                pub fn strstr(cs: *const c_char,\n+                              ct: *const c_char) -> *mut c_char;\n+                pub fn strlen(cs: *const c_char) -> size_t;\n+                pub fn strerror(n: c_int) -> *mut c_char;\n+                pub fn strtok(s: *mut c_char, t: *const c_char) -> *mut c_char;\n+                pub fn strxfrm(s: *mut c_char, ct: *const c_char,\n+                               n: size_t) -> size_t;\n+                pub fn wcslen(buf: *const wchar_t) -> size_t;\n \n                 // Omitted: memcpy, memmove, memset (provided by LLVM)\n \n                 // These are fine to execute on the Rust stack. They must be,\n                 // in fact, because LLVM generates calls to them!\n-                pub fn memcmp(cx: *c_void, ct: *c_void, n: size_t) -> c_int;\n-                pub fn memchr(cx: *c_void, c: c_int, n: size_t) -> *c_void;\n+                pub fn memcmp(cx: *const c_void, ct: *const c_void,\n+                              n: size_t) -> c_int;\n+                pub fn memchr(cx: *const c_void, c: c_int,\n+                              n: size_t) -> *mut c_void;\n             }\n         }\n     }\n@@ -3671,21 +3683,21 @@ pub mod funcs {\n \n             extern {\n                 #[link_name = \"_chmod\"]\n-                pub fn chmod(path: *c_char, mode: c_int) -> c_int;\n+                pub fn chmod(path: *const c_char, mode: c_int) -> c_int;\n                 #[link_name = \"_wchmod\"]\n-                pub fn wchmod(path: *wchar_t, mode: c_int) -> c_int;\n+                pub fn wchmod(path: *const wchar_t, mode: c_int) -> c_int;\n                 #[link_name = \"_mkdir\"]\n-                pub fn mkdir(path: *c_char) -> c_int;\n+                pub fn mkdir(path: *const c_char) -> c_int;\n                 #[link_name = \"_wrmdir\"]\n-                pub fn wrmdir(path: *wchar_t) -> c_int;\n+                pub fn wrmdir(path: *const wchar_t) -> c_int;\n                 #[link_name = \"_fstat64\"]\n                 pub fn fstat(fildes: c_int, buf: *mut stat) -> c_int;\n                 #[link_name = \"_stat64\"]\n-                pub fn stat(path: *c_char, buf: *mut stat) -> c_int;\n+                pub fn stat(path: *const c_char, buf: *mut stat) -> c_int;\n                 #[link_name = \"_wstat64\"]\n-                pub fn wstat(path: *wchar_t, buf: *mut stat) -> c_int;\n+                pub fn wstat(path: *const wchar_t, buf: *mut stat) -> c_int;\n                 #[link_name = \"_wutime64\"]\n-                pub fn wutime(file: *wchar_t, buf: *utimbuf) -> c_int;\n+                pub fn wutime(file: *const wchar_t, buf: *mut utimbuf) -> c_int;\n             }\n         }\n \n@@ -3695,27 +3707,28 @@ pub mod funcs {\n \n             extern {\n                 #[link_name = \"_popen\"]\n-                pub fn popen(command: *c_char, mode: *c_char) -> *FILE;\n+                pub fn popen(command: *const c_char,\n+                             mode: *const c_char) -> *mut FILE;\n                 #[link_name = \"_pclose\"]\n-                pub fn pclose(stream: *FILE) -> c_int;\n+                pub fn pclose(stream: *mut FILE) -> c_int;\n                 #[link_name = \"_fdopen\"]\n-                pub fn fdopen(fd: c_int, mode: *c_char) -> *FILE;\n+                pub fn fdopen(fd: c_int, mode: *const c_char) -> *mut FILE;\n                 #[link_name = \"_fileno\"]\n-                pub fn fileno(stream: *FILE) -> c_int;\n+                pub fn fileno(stream: *mut FILE) -> c_int;\n             }\n         }\n \n         pub mod fcntl {\n             use types::os::arch::c95::{c_int, c_char, wchar_t};\n             extern {\n                 #[link_name = \"_open\"]\n-                pub fn open(path: *c_char, oflag: c_int, mode: c_int)\n+                pub fn open(path: *const c_char, oflag: c_int, mode: c_int)\n                             -> c_int;\n                 #[link_name = \"_wopen\"]\n-                pub fn wopen(path: *wchar_t, oflag: c_int, mode: c_int)\n+                pub fn wopen(path: *const wchar_t, oflag: c_int, mode: c_int)\n                             -> c_int;\n                 #[link_name = \"_creat\"]\n-                pub fn creat(path: *c_char, mode: c_int) -> c_int;\n+                pub fn creat(path: *const c_char, mode: c_int) -> c_int;\n             }\n         }\n \n@@ -3731,27 +3744,30 @@ pub mod funcs {\n \n             extern {\n                 #[link_name = \"_access\"]\n-                pub fn access(path: *c_char, amode: c_int) -> c_int;\n+                pub fn access(path: *const c_char, amode: c_int) -> c_int;\n                 #[link_name = \"_chdir\"]\n-                pub fn chdir(dir: *c_char) -> c_int;\n+                pub fn chdir(dir: *const c_char) -> c_int;\n                 #[link_name = \"_close\"]\n                 pub fn close(fd: c_int) -> c_int;\n                 #[link_name = \"_dup\"]\n                 pub fn dup(fd: c_int) -> c_int;\n                 #[link_name = \"_dup2\"]\n                 pub fn dup2(src: c_int, dst: c_int) -> c_int;\n                 #[link_name = \"_execv\"]\n-                pub fn execv(prog: *c_char, argv: **c_char) -> intptr_t;\n+                pub fn execv(prog: *const c_char,\n+                             argv: *mut *const c_char) -> intptr_t;\n                 #[link_name = \"_execve\"]\n-                pub fn execve(prog: *c_char, argv: **c_char, envp: **c_char)\n+                pub fn execve(prog: *const c_char, argv: *mut *const c_char,\n+                              envp: *mut *const c_char)\n                               -> c_int;\n                 #[link_name = \"_execvp\"]\n-                pub fn execvp(c: *c_char, argv: **c_char) -> c_int;\n+                pub fn execvp(c: *const c_char,\n+                              argv: *mut *const c_char) -> c_int;\n                 #[link_name = \"_execvpe\"]\n-                pub fn execvpe(c: *c_char, argv: **c_char, envp: **c_char)\n-                               -> c_int;\n+                pub fn execvpe(c: *const c_char, argv: *mut *const c_char,\n+                               envp: *mut *const c_char) -> c_int;\n                 #[link_name = \"_getcwd\"]\n-                pub fn getcwd(buf: *mut c_char, size: size_t) -> *c_char;\n+                pub fn getcwd(buf: *mut c_char, size: size_t) -> *mut c_char;\n                 #[link_name = \"_getpid\"]\n                 pub fn getpid() -> c_int;\n                 #[link_name = \"_isatty\"]\n@@ -3766,11 +3782,12 @@ pub mod funcs {\n                 pub fn read(fd: c_int, buf: *mut c_void, count: c_uint)\n                             -> c_int;\n                 #[link_name = \"_rmdir\"]\n-                pub fn rmdir(path: *c_char) -> c_int;\n+                pub fn rmdir(path: *const c_char) -> c_int;\n                 #[link_name = \"_unlink\"]\n-                pub fn unlink(c: *c_char) -> c_int;\n+                pub fn unlink(c: *const c_char) -> c_int;\n                 #[link_name = \"_write\"]\n-                pub fn write(fd: c_int, buf: *c_void, count: c_uint) -> c_int;\n+                pub fn write(fd: c_int, buf: *const c_void,\n+                             count: c_uint) -> c_int;\n             }\n         }\n \n@@ -3791,7 +3808,7 @@ pub mod funcs {\n             use types::os::arch::posix88::mode_t;\n \n             extern {\n-                pub fn chmod(path: *c_char, mode: mode_t) -> c_int;\n+                pub fn chmod(path: *const c_char, mode: mode_t) -> c_int;\n                 pub fn fchmod(fd: c_int, mode: mode_t) -> c_int;\n \n                 #[cfg(target_os = \"linux\")]\n@@ -3804,18 +3821,18 @@ pub mod funcs {\n                 #[link_name = \"fstat64\"]\n                 pub fn fstat(fildes: c_int, buf: *mut stat) -> c_int;\n \n-                pub fn mkdir(path: *c_char, mode: mode_t) -> c_int;\n-                pub fn mkfifo(path: *c_char, mode: mode_t) -> c_int;\n+                pub fn mkdir(path: *const c_char, mode: mode_t) -> c_int;\n+                pub fn mkfifo(path: *const c_char, mode: mode_t) -> c_int;\n \n                 #[cfg(target_os = \"linux\")]\n                 #[cfg(target_os = \"freebsd\")]\n                 #[cfg(target_os = \"android\")]\n                 #[cfg(target_os = \"ios\")]\n-                pub fn stat(path: *c_char, buf: *mut stat) -> c_int;\n+                pub fn stat(path: *const c_char, buf: *mut stat) -> c_int;\n \n                 #[cfg(target_os = \"macos\")]\n                 #[link_name = \"stat64\"]\n-                pub fn stat(path: *c_char, buf: *mut stat) -> c_int;\n+                pub fn stat(path: *const c_char, buf: *mut stat) -> c_int;\n             }\n         }\n \n@@ -3824,10 +3841,11 @@ pub mod funcs {\n             use types::os::arch::c95::{c_char, c_int};\n \n             extern {\n-                pub fn popen(command: *c_char, mode: *c_char) -> *FILE;\n-                pub fn pclose(stream: *FILE) -> c_int;\n-                pub fn fdopen(fd: c_int, mode: *c_char) -> *FILE;\n-                pub fn fileno(stream: *FILE) -> c_int;\n+                pub fn popen(command: *const c_char,\n+                             mode: *const c_char) -> *mut FILE;\n+                pub fn pclose(stream: *mut FILE) -> c_int;\n+                pub fn fdopen(fd: c_int, mode: *const c_char) -> *mut FILE;\n+                pub fn fileno(stream: *mut FILE) -> c_int;\n             }\n         }\n \n@@ -3836,9 +3854,9 @@ pub mod funcs {\n             use types::os::arch::posix88::mode_t;\n \n             extern {\n-                pub fn open(path: *c_char, oflag: c_int, mode: c_int)\n+                pub fn open(path: *const c_char, oflag: c_int, mode: c_int)\n                             -> c_int;\n-                pub fn creat(path: *c_char, mode: mode_t) -> c_int;\n+                pub fn creat(path: *const c_char, mode: mode_t) -> c_int;\n                 pub fn fcntl(fd: c_int, cmd: c_int, ...) -> c_int;\n             }\n         }\n@@ -3856,17 +3874,17 @@ pub mod funcs {\n \n             extern {\n                 #[link_name=\"rust_opendir\"]\n-                pub fn opendir(dirname: *c_char) -> *DIR;\n+                pub fn opendir(dirname: *const c_char) -> *mut DIR;\n                 #[link_name=\"rust_readdir_r\"]\n-                pub fn readdir_r(dirp: *DIR, entry: *mut dirent_t,\n+                pub fn readdir_r(dirp: *mut DIR, entry: *mut dirent_t,\n                                   result: *mut *mut dirent_t) -> c_int;\n             }\n \n             extern {\n-                pub fn closedir(dirp: *DIR) -> c_int;\n-                pub fn rewinddir(dirp: *DIR);\n-                pub fn seekdir(dirp: *DIR, loc: c_long);\n-                pub fn telldir(dirp: *DIR) -> c_long;\n+                pub fn closedir(dirp: *mut DIR) -> c_int;\n+                pub fn rewinddir(dirp: *mut DIR);\n+                pub fn seekdir(dirp: *mut DIR, loc: c_long);\n+                pub fn telldir(dirp: *mut DIR) -> c_long;\n             }\n         }\n \n@@ -3882,60 +3900,65 @@ pub mod funcs {\n             pub static _PC_NAME_MAX: c_int = 4;\n \n             extern {\n-                pub fn access(path: *c_char, amode: c_int) -> c_int;\n+                pub fn access(path: *const c_char, amode: c_int) -> c_int;\n                 pub fn alarm(seconds: c_uint) -> c_uint;\n-                pub fn chdir(dir: *c_char) -> c_int;\n-                pub fn chown(path: *c_char, uid: uid_t, gid: gid_t) -> c_int;\n+                pub fn chdir(dir: *const c_char) -> c_int;\n+                pub fn chown(path: *const c_char, uid: uid_t,\n+                             gid: gid_t) -> c_int;\n                 pub fn close(fd: c_int) -> c_int;\n                 pub fn dup(fd: c_int) -> c_int;\n                 pub fn dup2(src: c_int, dst: c_int) -> c_int;\n-                pub fn execv(prog: *c_char, argv: **c_char) -> c_int;\n-                pub fn execve(prog: *c_char, argv: **c_char, envp: **c_char)\n+                pub fn execv(prog: *const c_char,\n+                             argv: *mut *const c_char) -> c_int;\n+                pub fn execve(prog: *const c_char, argv: *mut *const c_char,\n+                              envp: *mut *const c_char)\n                               -> c_int;\n-                pub fn execvp(c: *c_char, argv: **c_char) -> c_int;\n+                pub fn execvp(c: *const c_char,\n+                              argv: *mut *const c_char) -> c_int;\n                 pub fn fork() -> pid_t;\n                 pub fn fpathconf(filedes: c_int, name: c_int) -> c_long;\n-                pub fn getcwd(buf: *mut c_char, size: size_t) -> *c_char;\n+                pub fn getcwd(buf: *mut c_char, size: size_t) -> *mut c_char;\n                 pub fn getegid() -> gid_t;\n                 pub fn geteuid() -> uid_t;\n                 pub fn getgid() -> gid_t ;\n                 pub fn getgroups(ngroups_max: c_int, groups: *mut gid_t)\n                                  -> c_int;\n-                pub fn getlogin() -> *c_char;\n-                pub fn getopt(argc: c_int, argv: **c_char, optstr: *c_char)\n-                              -> c_int;\n+                pub fn getlogin() -> *mut c_char;\n+                pub fn getopt(argc: c_int, argv: *mut *const c_char,\n+                              optstr: *const c_char) -> c_int;\n                 pub fn getpgrp() -> pid_t;\n                 pub fn getpid() -> pid_t;\n                 pub fn getppid() -> pid_t;\n                 pub fn getuid() -> uid_t;\n                 pub fn isatty(fd: c_int) -> c_int;\n-                pub fn link(src: *c_char, dst: *c_char) -> c_int;\n+                pub fn link(src: *const c_char, dst: *const c_char) -> c_int;\n                 pub fn lseek(fd: c_int, offset: off_t, whence: c_int)\n                              -> off_t;\n-                pub fn pathconf(path: *c_char, name: c_int) -> c_long;\n+                pub fn pathconf(path: *mut c_char, name: c_int) -> c_long;\n                 pub fn pause() -> c_int;\n                 pub fn pipe(fds: *mut c_int) -> c_int;\n                 pub fn read(fd: c_int, buf: *mut c_void, count: size_t)\n                             -> ssize_t;\n-                pub fn rmdir(path: *c_char) -> c_int;\n+                pub fn rmdir(path: *const c_char) -> c_int;\n                 pub fn setgid(gid: gid_t) -> c_int;\n                 pub fn setpgid(pid: pid_t, pgid: pid_t) -> c_int;\n                 pub fn setsid() -> pid_t;\n                 pub fn setuid(uid: uid_t) -> c_int;\n                 pub fn sleep(secs: c_uint) -> c_uint;\n                 pub fn usleep(secs: c_uint) -> c_int;\n-                pub fn nanosleep(rqtp: *timespec, rmtp: *mut timespec) -> c_int;\n+                pub fn nanosleep(rqtp: *const timespec,\n+                                 rmtp: *mut timespec) -> c_int;\n                 pub fn sysconf(name: c_int) -> c_long;\n                 pub fn tcgetpgrp(fd: c_int) -> pid_t;\n-                pub fn ttyname(fd: c_int) -> *c_char;\n-                pub fn unlink(c: *c_char) -> c_int;\n-                pub fn write(fd: c_int, buf: *c_void, count: size_t)\n+                pub fn ttyname(fd: c_int) -> *mut c_char;\n+                pub fn unlink(c: *const c_char) -> c_int;\n+                pub fn write(fd: c_int, buf: *const c_void, count: size_t)\n                              -> ssize_t;\n-                pub fn pread(fd: c_int, buf: *c_void, count: size_t,\n+                pub fn pread(fd: c_int, buf: *mut c_void, count: size_t,\n                              offset: off_t) -> ssize_t;\n-                pub fn pwrite(fd: c_int, buf: *c_void, count: size_t,\n+                pub fn pwrite(fd: c_int, buf: *const c_void, count: size_t,\n                               offset: off_t) -> ssize_t;\n-                pub fn utime(file: *c_char, buf: *utimbuf) -> c_int;\n+                pub fn utime(file: *const c_char, buf: *const utimbuf) -> c_int;\n             }\n         }\n \n@@ -3954,8 +3977,8 @@ pub mod funcs {\n             use types::os::arch::posix88::{mode_t, off_t};\n \n             extern {\n-                pub fn mlock(addr: *c_void, len: size_t) -> c_int;\n-                pub fn munlock(addr: *c_void, len: size_t) -> c_int;\n+                pub fn mlock(addr: *const c_void, len: size_t) -> c_int;\n+                pub fn munlock(addr: *const c_void, len: size_t) -> c_int;\n                 pub fn mlockall(flags: c_int) -> c_int;\n                 pub fn munlockall() -> c_int;\n \n@@ -3973,9 +3996,9 @@ pub mod funcs {\n \n                 pub fn msync(addr: *mut c_void, len: size_t, flags: c_int)\n                              -> c_int;\n-                pub fn shm_open(name: *c_char, oflag: c_int, mode: mode_t)\n+                pub fn shm_open(name: *const c_char, oflag: c_int, mode: mode_t)\n                                 -> c_int;\n-                pub fn shm_unlink(name: *c_char) -> c_int;\n+                pub fn shm_unlink(name: *const c_char) -> c_int;\n             }\n         }\n     }\n@@ -3995,11 +4018,11 @@ pub mod funcs {\n                 #[cfg(target_os = \"freebsd\")]\n                 #[cfg(target_os = \"android\")]\n                 #[cfg(target_os = \"ios\")]\n-                pub fn lstat(path: *c_char, buf: *mut stat) -> c_int;\n+                pub fn lstat(path: *const c_char, buf: *mut stat) -> c_int;\n \n                 #[cfg(target_os = \"macos\")]\n                 #[link_name = \"lstat64\"]\n-                pub fn lstat(path: *c_char, buf: *mut stat) -> c_int;\n+                pub fn lstat(path: *const c_char, buf: *mut stat) -> c_int;\n             }\n         }\n \n@@ -4008,7 +4031,7 @@ pub mod funcs {\n             use types::os::arch::posix88::{ssize_t, off_t};\n \n             extern {\n-                pub fn readlink(path: *c_char,\n+                pub fn readlink(path: *const c_char,\n                                 buf: *mut c_char,\n                                 bufsz: size_t)\n                                 -> ssize_t;\n@@ -4019,12 +4042,13 @@ pub mod funcs {\n                 #[cfg(target_os = \"android\")]\n                 pub fn fdatasync(fd: c_int) -> c_int;\n \n-                pub fn setenv(name: *c_char, val: *c_char, overwrite: c_int)\n-                              -> c_int;\n-                pub fn unsetenv(name: *c_char) -> c_int;\n-                pub fn putenv(string: *c_char) -> c_int;\n+                pub fn setenv(name: *const c_char, val: *const c_char,\n+                              overwrite: c_int) -> c_int;\n+                pub fn unsetenv(name: *const c_char) -> c_int;\n+                pub fn putenv(string: *mut c_char) -> c_int;\n \n-                pub fn symlink(path1: *c_char, path2: *c_char) -> c_int;\n+                pub fn symlink(path1: *const c_char,\n+                               path2: *const c_char) -> c_int;\n \n                 pub fn ftruncate(fd: c_int, length: off_t) -> c_int;\n             }\n@@ -4053,9 +4077,10 @@ pub mod funcs {\n             use types::os::common::posix01::{glob_t};\n \n             extern {\n-                pub fn glob(pattern: *c_char,\n+                pub fn glob(pattern: *const c_char,\n                             flags: c_int,\n-                            errfunc: ::Nullable<extern \"C\" fn(epath: *c_char, errno: int) -> int>,\n+                            errfunc: ::Nullable<extern \"C\" fn(epath: *const c_char,\n+                                                              errno: int) -> int>,\n                             pglob: *mut glob_t);\n                 pub fn globfree(pglob: *mut glob_t);\n             }\n@@ -4066,7 +4091,7 @@ pub mod funcs {\n             use types::os::arch::c95::{c_int, size_t};\n \n             extern {\n-                pub fn posix_madvise(addr: *c_void,\n+                pub fn posix_madvise(addr: *mut c_void,\n                                      len: size_t,\n                                      advice: c_int)\n                                      -> c_int;\n@@ -4110,9 +4135,9 @@ pub mod funcs {\n \n         extern \"system\" {\n             pub fn socket(domain: c_int, ty: c_int, protocol: c_int) -> c_int;\n-            pub fn connect(socket: c_int, address: *sockaddr,\n+            pub fn connect(socket: c_int, address: *const sockaddr,\n                            len: socklen_t) -> c_int;\n-            pub fn bind(socket: c_int, address: *sockaddr,\n+            pub fn bind(socket: c_int, address: *const sockaddr,\n                         address_len: socklen_t) -> c_int;\n             pub fn listen(socket: c_int, backlog: c_int) -> c_int;\n             pub fn accept(socket: c_int, address: *mut sockaddr,\n@@ -4122,16 +4147,17 @@ pub mod funcs {\n             pub fn getsockname(socket: c_int, address: *mut sockaddr,\n                                address_len: *mut socklen_t) -> c_int;\n             pub fn setsockopt(socket: c_int, level: c_int, name: c_int,\n-                              value: *c_void, option_len: socklen_t) -> c_int;\n+                              value: *const c_void,\n+                              option_len: socklen_t) -> c_int;\n             pub fn recv(socket: c_int, buf: *mut c_void, len: size_t,\n                         flags: c_int) -> ssize_t;\n             pub fn send(socket: c_int, buf: *mut c_void, len: size_t,\n                         flags: c_int) -> ssize_t;\n             pub fn recvfrom(socket: c_int, buf: *mut c_void, len: size_t,\n                             flags: c_int, addr: *mut sockaddr,\n                             addrlen: *mut socklen_t) -> ssize_t;\n-            pub fn sendto(socket: c_int, buf: *c_void, len: size_t,\n-                          flags: c_int, addr: *sockaddr,\n+            pub fn sendto(socket: c_int, buf: *const c_void, len: size_t,\n+                          flags: c_int, addr: *const sockaddr,\n                           addrlen: socklen_t) -> ssize_t;\n             pub fn shutdown(socket: c_int, how: c_int) -> c_int;\n         }\n@@ -4146,9 +4172,9 @@ pub mod funcs {\n \n         extern \"system\" {\n             pub fn socket(domain: c_int, ty: c_int, protocol: c_int) -> SOCKET;\n-            pub fn connect(socket: SOCKET, address: *sockaddr,\n+            pub fn connect(socket: SOCKET, address: *const sockaddr,\n                            len: socklen_t) -> c_int;\n-            pub fn bind(socket: SOCKET, address: *sockaddr,\n+            pub fn bind(socket: SOCKET, address: *const sockaddr,\n                         address_len: socklen_t) -> c_int;\n             pub fn listen(socket: SOCKET, backlog: c_int) -> c_int;\n             pub fn accept(socket: SOCKET, address: *mut sockaddr,\n@@ -4158,7 +4184,8 @@ pub mod funcs {\n             pub fn getsockname(socket: SOCKET, address: *mut sockaddr,\n                                address_len: *mut socklen_t) -> c_int;\n             pub fn setsockopt(socket: SOCKET, level: c_int, name: c_int,\n-                              value: *c_void, option_len: socklen_t) -> c_int;\n+                              value: *const c_void,\n+                              option_len: socklen_t) -> c_int;\n             pub fn closesocket(socket: SOCKET) -> c_int;\n             pub fn recv(socket: SOCKET, buf: *mut c_void, len: c_int,\n                         flags: c_int) -> c_int;\n@@ -4167,8 +4194,8 @@ pub mod funcs {\n             pub fn recvfrom(socket: SOCKET, buf: *mut c_void, len: c_int,\n                             flags: c_int, addr: *mut sockaddr,\n                             addrlen: *mut c_int) -> ssize_t;\n-            pub fn sendto(socket: SOCKET, buf: *c_void, len: c_int,\n-                          flags: c_int, addr: *sockaddr,\n+            pub fn sendto(socket: SOCKET, buf: *const c_void, len: c_int,\n+                          flags: c_int, addr: *const sockaddr,\n                           addrlen: c_int) -> c_int;\n             pub fn shutdown(socket: SOCKET, how: c_int) -> c_int;\n         }\n@@ -4182,27 +4209,27 @@ pub mod funcs {\n         use types::os::arch::c95::{c_char, c_uchar, c_int, c_uint, size_t};\n \n         extern {\n-            pub fn sysctl(name: *c_int,\n+            pub fn sysctl(name: *mut c_int,\n                           namelen: c_uint,\n                           oldp: *mut c_void,\n                           oldlenp: *mut size_t,\n-                          newp: *c_void,\n+                          newp: *mut c_void,\n                           newlen: size_t)\n                           -> c_int;\n-            pub fn sysctlbyname(name: *c_char,\n+            pub fn sysctlbyname(name: *const c_char,\n                                 oldp: *mut c_void,\n                                 oldlenp: *mut size_t,\n-                                newp: *c_void,\n+                                newp: *mut c_void,\n                                 newlen: size_t)\n                                 -> c_int;\n-            pub fn sysctlnametomib(name: *c_char,\n+            pub fn sysctlnametomib(name: *const c_char,\n                                    mibp: *mut c_int,\n                                    sizep: *mut size_t)\n                                    -> c_int;\n             pub fn getdtablesize() -> c_int;\n-            pub fn madvise(addr: *c_void, len: size_t, advice: c_int)\n+            pub fn madvise(addr: *mut c_void, len: size_t, advice: c_int)\n                            -> c_int;\n-            pub fn mincore(addr: *c_void, len: size_t, vec: *c_uchar)\n+            pub fn mincore(addr: *mut c_void, len: size_t, vec: *mut c_uchar)\n                            -> c_int;\n         }\n     }\n@@ -4294,7 +4321,7 @@ pub mod funcs {\n                                             -> DWORD;\n                 pub fn SetCurrentDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n                 pub fn GetLastError() -> DWORD;\n-                pub fn FindFirstFileW(fileName: *u16, findFileData: HANDLE)\n+                pub fn FindFirstFileW(fileName: LPCWSTR, findFileData: HANDLE)\n                                       -> HANDLE;\n                 pub fn FindNextFileW(findFile: HANDLE, findFileData: HANDLE)\n                                      -> BOOL;"}, {"sha": "ba102a85c1bcb16b6cd3d533274372ba01201302", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -144,8 +144,8 @@ static DEFAULT_LOG_LEVEL: u32 = 1;\n /// logging statement should be run.\n static mut LOG_LEVEL: u32 = MAX_LOG_LEVEL;\n \n-static mut DIRECTIVES: *Vec<directive::LogDirective> =\n-    0 as *Vec<directive::LogDirective>;\n+static mut DIRECTIVES: *const Vec<directive::LogDirective> =\n+    0 as *const Vec<directive::LogDirective>;\n \n /// Debug log level\n pub static DEBUG: u32 = 4;\n@@ -351,7 +351,7 @@ fn init() {\n             assert!(!DIRECTIVES.is_null());\n             let _directives: Box<Vec<directive::LogDirective>> =\n                 mem::transmute(DIRECTIVES);\n-            DIRECTIVES = 0 as *Vec<directive::LogDirective>;\n+            DIRECTIVES = 0 as *const Vec<directive::LogDirective>;\n         });\n     }\n }"}, {"sha": "8c3cdf4e9ecaf53859c40b6c65db8d91715202a5", "filename": "src/libnative/io/addrinfo.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Faddrinfo.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -37,13 +37,15 @@ impl GetAddrInfoRequest {\n                 ai_socktype: 0,\n                 ai_protocol: 0,\n                 ai_addrlen: 0,\n-                ai_canonname: null(),\n-                ai_addr: null(),\n-                ai_next: null()\n+                ai_canonname: mut_null(),\n+                ai_addr: mut_null(),\n+                ai_next: mut_null()\n             }\n         });\n \n-        let hint_ptr = hint.as_ref().map_or(null(), |x| x as *libc::addrinfo);\n+        let hint_ptr = hint.as_ref().map_or(null(), |x| {\n+            x as *const libc::addrinfo\n+        });\n         let mut res = mut_null();\n \n         // Make the call\n@@ -87,11 +89,12 @@ impl GetAddrInfoRequest {\n }\n \n extern \"system\" {\n-    fn getaddrinfo(node: *c_char, service: *c_char,\n-                   hints: *libc::addrinfo, res: *mut *mut libc::addrinfo) -> c_int;\n+    fn getaddrinfo(node: *const c_char, service: *const c_char,\n+                   hints: *const libc::addrinfo,\n+                   res: *mut *mut libc::addrinfo) -> c_int;\n     fn freeaddrinfo(res: *mut libc::addrinfo);\n     #[cfg(not(windows))]\n-    fn gai_strerror(errcode: c_int) -> *c_char;\n+    fn gai_strerror(errcode: c_int) -> *const c_char;\n }\n \n #[cfg(windows)]"}, {"sha": "9fbf3659d3f6ba900a0883655045394558343304", "filename": "src/libnative/io/c_unix.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Fc_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Fc_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_unix.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -57,12 +57,12 @@ pub static WNOHANG: libc::c_int = 1;\n \n extern {\n     pub fn gettimeofday(timeval: *mut libc::timeval,\n-                        tzp: *libc::c_void) -> libc::c_int;\n+                        tzp: *mut libc::c_void) -> libc::c_int;\n     pub fn select(nfds: libc::c_int,\n-                  readfds: *fd_set,\n-                  writefds: *fd_set,\n-                  errorfds: *fd_set,\n-                  timeout: *libc::timeval) -> libc::c_int;\n+                  readfds: *mut fd_set,\n+                  writefds: *mut fd_set,\n+                  errorfds: *mut fd_set,\n+                  timeout: *mut libc::timeval) -> libc::c_int;\n     pub fn getsockopt(sockfd: libc::c_int,\n                       level: libc::c_int,\n                       optname: libc::c_int,\n@@ -75,7 +75,7 @@ extern {\n                    options: libc::c_int) -> libc::pid_t;\n \n     pub fn sigaction(signum: libc::c_int,\n-                     act: *sigaction,\n+                     act: *const sigaction,\n                      oldact: *mut sigaction) -> libc::c_int;\n \n     pub fn sigaddset(set: *mut sigset_t, signum: libc::c_int) -> libc::c_int;"}, {"sha": "7e58102d2418399b9d314242be84edcfc1d9e332", "filename": "src/libnative/io/c_win32.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Fc_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Fc_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_win32.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -28,7 +28,7 @@ pub struct WSADATA {\n     pub szSystemStatus: [u8, ..WSASYS_STATUS_LEN + 1],\n     pub iMaxSockets: u16,\n     pub iMaxUdpDg: u16,\n-    pub lpVendorInfo: *u8,\n+    pub lpVendorInfo: *mut u8,\n }\n \n pub type LPWSADATA = *mut WSADATA;\n@@ -53,10 +53,10 @@ extern \"system\" {\n     pub fn ioctlsocket(s: libc::SOCKET, cmd: libc::c_long,\n                        argp: *mut libc::c_ulong) -> libc::c_int;\n     pub fn select(nfds: libc::c_int,\n-                  readfds: *fd_set,\n-                  writefds: *fd_set,\n-                  exceptfds: *fd_set,\n-                  timeout: *libc::timeval) -> libc::c_int;\n+                  readfds: *mut fd_set,\n+                  writefds: *mut fd_set,\n+                  exceptfds: *mut fd_set,\n+                  timeout: *mut libc::timeval) -> libc::c_int;\n     pub fn getsockopt(sockfd: libc::SOCKET,\n                       level: libc::c_int,\n                       optname: libc::c_int,"}, {"sha": "72dad27c6e761f9a8b74ddaea6d3b93124258f5c", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -68,7 +68,7 @@ impl FileDesc {\n     pub fn inner_write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let ret = keep_going(buf, |buf, len| {\n             unsafe {\n-                libc::write(self.fd(), buf as *libc::c_void,\n+                libc::write(self.fd(), buf as *const libc::c_void,\n                             len as libc::size_t) as i64\n             }\n         });\n@@ -91,7 +91,7 @@ impl rtio::RtioFileStream for FileDesc {\n     }\n     fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int> {\n         match retry(|| unsafe {\n-            libc::pread(self.fd(), buf.as_ptr() as *libc::c_void,\n+            libc::pread(self.fd(), buf.as_ptr() as *mut _,\n                         buf.len() as libc::size_t,\n                         offset as libc::off_t) as libc::c_int\n         }) {\n@@ -101,7 +101,7 @@ impl rtio::RtioFileStream for FileDesc {\n     }\n     fn pwrite(&mut self, buf: &[u8], offset: u64) -> IoResult<()> {\n         super::mkerr_libc(retry(|| unsafe {\n-            libc::pwrite(self.fd(), buf.as_ptr() as *libc::c_void,\n+            libc::pwrite(self.fd(), buf.as_ptr() as *const _,\n                          buf.len() as libc::size_t, offset as libc::off_t)\n         } as c_int))\n     }\n@@ -222,7 +222,7 @@ impl Drop for Inner {\n }\n \n pub struct CFile {\n-    file: *libc::FILE,\n+    file: *mut libc::FILE,\n     fd: FileDesc,\n }\n \n@@ -231,7 +231,7 @@ impl CFile {\n     ///\n     /// The `CFile` takes ownership of the `FILE` pointer and will close it upon\n     /// destruction.\n-    pub fn new(file: *libc::FILE) -> CFile {\n+    pub fn new(file: *mut libc::FILE) -> CFile {\n         CFile {\n             file: file,\n             fd: FileDesc::new(unsafe { libc::fileno(file) }, false)\n@@ -263,7 +263,7 @@ impl rtio::RtioFileStream for CFile {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let ret = keep_going(buf, |buf, len| {\n             unsafe {\n-                libc::fwrite(buf as *libc::c_void, 1, len as libc::size_t,\n+                libc::fwrite(buf as *const libc::c_void, 1, len as libc::size_t,\n                             self.file) as i64\n             }\n         });\n@@ -366,7 +366,7 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n \n     extern {\n         fn rust_dirent_t_size() -> libc::c_int;\n-        fn rust_list_dir_val(ptr: *mut dirent_t) -> *libc::c_char;\n+        fn rust_list_dir_val(ptr: *mut dirent_t) -> *const libc::c_char;\n     }\n \n     let size = unsafe { rust_dirent_t_size() };\n@@ -423,7 +423,7 @@ pub fn chown(p: &CString, uid: int, gid: int) -> IoResult<()> {\n \n pub fn readlink(p: &CString) -> IoResult<CString> {\n     let p = p.with_ref(|p| p);\n-    let mut len = unsafe { libc::pathconf(p, libc::_PC_NAME_MAX) };\n+    let mut len = unsafe { libc::pathconf(p as *mut _, libc::_PC_NAME_MAX) };\n     if len == -1 {\n         len = 1024; // FIXME: read PATH_MAX from C ffi?\n     }"}, {"sha": "cdbf762f87d528ba8ad4de9d266ff2845533866b", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -357,7 +357,7 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n \n     extern {\n         fn rust_list_dir_wfd_size() -> libc::size_t;\n-        fn rust_list_dir_wfd_fp_buf(wfd: *libc::c_void) -> *u16;\n+        fn rust_list_dir_wfd_fp_buf(wfd: *mut libc::c_void) -> *const u16;\n     }\n     let star = Path::new(unsafe {\n         CString::new(p.with_ref(|p| p), false)\n@@ -366,12 +366,13 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n \n     unsafe {\n         let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n-        let find_handle = libc::FindFirstFileW(path.as_ptr(), wfd_ptr as libc::HANDLE);\n+        let find_handle = libc::FindFirstFileW(path.as_ptr(),\n+                                               wfd_ptr as libc::HANDLE);\n         if find_handle as libc::c_int != libc::INVALID_HANDLE_VALUE {\n             let mut paths = vec!();\n             let mut more_files = 1 as libc::c_int;\n             while more_files != 0 {\n-                let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr as *c_void);\n+                let fp_buf = rust_list_dir_wfd_fp_buf(wfd_ptr as *mut c_void);\n                 if fp_buf as uint == 0 {\n                     fail!(\"os::list_dir() failure: got null ptr from wfd\");\n                 } else {\n@@ -446,7 +447,7 @@ pub fn readlink(p: &CString) -> IoResult<CString> {\n     // without the null pointer\n     let ret = fill_utf16_buf_and_decode(|buf, sz| unsafe {\n         GetFinalPathNameByHandleW(handle,\n-                                  buf as *u16,\n+                                  buf as *const u16,\n                                   sz - 1,\n                                   libc::VOLUME_NAME_DOS)\n     });\n@@ -514,12 +515,12 @@ pub fn lstat(_p: &CString) -> IoResult<rtio::FileStat> {\n }\n \n pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n-    let buf = libc::utimbuf {\n+    let mut buf = libc::utimbuf {\n         actime: (atime / 1000) as libc::time64_t,\n         modtime: (mtime / 1000) as libc::time64_t,\n     };\n     let p = try!(to_utf16(p));\n     super::mkerr_libc(unsafe {\n-        libc::wutime(p.as_ptr(), &buf)\n+        libc::wutime(p.as_ptr(), &mut buf)\n     })\n }"}, {"sha": "f6764b8f26a790893853e1c88e716bb1bb51341e", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -132,7 +132,7 @@ fn retry(f: || -> libc::c_int) -> libc::c_int {\n     }\n }\n \n-fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 {\n+fn keep_going(data: &[u8], f: |*const u8, uint| -> i64) -> i64 {\n     let origamt = data.len();\n     let mut data = data.as_ptr();\n     let mut amt = origamt;"}, {"sha": "395c063e706f11d8494d11fa36901ebd2815f9a6", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -105,7 +105,7 @@ fn socket(addr: rtio::SocketAddr, ty: libc::c_int) -> IoResult<sock_t> {\n fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,\n                  payload: T) -> IoResult<()> {\n     unsafe {\n-        let payload = &payload as *T as *libc::c_void;\n+        let payload = &payload as *const T as *const libc::c_void;\n         let ret = libc::setsockopt(fd, opt, val,\n                                    payload,\n                                    mem::size_of::<T>() as libc::socklen_t);\n@@ -278,7 +278,7 @@ impl TcpStream {\n         let ret = TcpStream::new(Inner::new(fd));\n \n         let (addr, len) = addr_to_sockaddr(addr);\n-        let addrp = &addr as *_ as *libc::sockaddr;\n+        let addrp = &addr as *const _ as *const libc::sockaddr;\n         let len = len as libc::socklen_t;\n \n         match timeout {\n@@ -369,7 +369,7 @@ impl rtio::RtioTcpStream for TcpStream {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n-        let dowrite = |nb: bool, buf: *u8, len: uint| unsafe {\n+        let dowrite = |nb: bool, buf: *const u8, len: uint| unsafe {\n             let flags = if nb {c::MSG_DONTWAIT} else {0};\n             libc::send(fd,\n                        buf as *mut libc::c_void,\n@@ -456,7 +456,7 @@ impl TcpListener {\n         let ret = TcpListener { inner: Inner::new(fd) };\n \n         let (addr, len) = addr_to_sockaddr(addr);\n-        let addrp = &addr as *_ as *libc::sockaddr;\n+        let addrp = &addr as *const _ as *const libc::sockaddr;\n         let len = len as libc::socklen_t;\n \n         // On platforms with Berkeley-derived sockets, this allows\n@@ -564,7 +564,7 @@ impl UdpSocket {\n         };\n \n         let (addr, len) = addr_to_sockaddr(addr);\n-        let addrp = &addr as *_ as *libc::sockaddr;\n+        let addrp = &addr as *const _ as *const libc::sockaddr;\n         let len = len as libc::socklen_t;\n \n         match unsafe { libc::bind(fd, addrp, len) } {\n@@ -654,15 +654,15 @@ impl rtio::RtioUdpSocket for UdpSocket {\n \n     fn sendto(&mut self, buf: &[u8], dst: rtio::SocketAddr) -> IoResult<()> {\n         let (dst, dstlen) = addr_to_sockaddr(dst);\n-        let dstp = &dst as *_ as *libc::sockaddr;\n+        let dstp = &dst as *const _ as *const libc::sockaddr;\n         let dstlen = dstlen as libc::socklen_t;\n \n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n-        let dowrite = |nb, buf: *u8, len: uint| unsafe {\n+        let dowrite = |nb, buf: *const u8, len: uint| unsafe {\n             let flags = if nb {c::MSG_DONTWAIT} else {0};\n             libc::sendto(fd,\n-                         buf as *libc::c_void,\n+                         buf as *const libc::c_void,\n                          len as msglen_t,\n                          flags,\n                          dstp,\n@@ -842,7 +842,7 @@ pub fn write<T>(fd: sock_t,\n                 buf: &[u8],\n                 write_everything: bool,\n                 lock: || -> T,\n-                write: |bool, *u8, uint| -> i64) -> IoResult<uint> {\n+                write: |bool, *const u8, uint| -> i64) -> IoResult<uint> {\n     let mut ret = -1;\n     let mut written = 0;\n     if deadline == 0 {"}, {"sha": "ae08d0ea0a9b75ab447a498aa81a8c7024a58338", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -78,7 +78,7 @@ fn connect(addr: &CString, ty: libc::c_int,\n            timeout: Option<u64>) -> IoResult<Inner> {\n     let (addr, len) = try!(addr_to_sockaddr_un(addr));\n     let inner = Inner::new(try!(unix_socket(ty)));\n-    let addrp = &addr as *_ as *libc::sockaddr;\n+    let addrp = &addr as *const _ as *const libc::sockaddr;\n     let len = len as libc::socklen_t;\n \n     match timeout {\n@@ -98,9 +98,9 @@ fn connect(addr: &CString, ty: libc::c_int,\n fn bind(addr: &CString, ty: libc::c_int) -> IoResult<Inner> {\n     let (addr, len) = try!(addr_to_sockaddr_un(addr));\n     let inner = Inner::new(try!(unix_socket(ty)));\n-    let addrp = &addr as *libc::sockaddr_storage;\n+    let addrp = &addr as *const _;\n     match unsafe {\n-        libc::bind(inner.fd, addrp as *libc::sockaddr, len as libc::socklen_t)\n+        libc::bind(inner.fd, addrp as *const _, len as libc::socklen_t)\n     } {\n         -1 => Err(super::last_error()),\n         _  => Ok(inner)\n@@ -166,7 +166,7 @@ impl rtio::RtioPipe for UnixStream {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n-        let dowrite = |nb: bool, buf: *u8, len: uint| unsafe {\n+        let dowrite = |nb: bool, buf: *const u8, len: uint| unsafe {\n             let flags = if nb {c::MSG_DONTWAIT} else {0};\n             libc::send(fd,\n                        buf as *mut libc::c_void,"}, {"sha": "da713e3f2a931e9394a02f90b5bd3061175d2601", "filename": "src/libnative/io/pipe_win32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Fpipe_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Fpipe_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_win32.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -152,7 +152,7 @@ impl Drop for Inner {\n     }\n }\n \n-unsafe fn pipe(name: *u16, init: bool) -> libc::HANDLE {\n+unsafe fn pipe(name: *const u16, init: bool) -> libc::HANDLE {\n     libc::CreateNamedPipeW(\n         name,\n         libc::PIPE_ACCESS_DUPLEX |\n@@ -210,7 +210,7 @@ pub struct UnixStream {\n }\n \n impl UnixStream {\n-    fn try_connect(p: *u16) -> Option<libc::HANDLE> {\n+    fn try_connect(p: *const u16) -> Option<libc::HANDLE> {\n         // Note that most of this is lifted from the libuv implementation.\n         // The idea is that if we fail to open a pipe in read/write mode\n         // that we try afterwards in just read or just write"}, {"sha": "7f4c52585f2a4749ec800022739d7b77144aded8", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 35, "deletions": 31, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -43,7 +43,7 @@ pub struct Process {\n     /// A handle to the process - on unix this will always be NULL, but on\n     /// windows it will be a HANDLE to the process, which will prevent the\n     /// pid being re-used until the handle is closed.\n-    handle: *(),\n+    handle: *mut (),\n \n     /// None until finish() is called.\n     exit_code: Option<rtio::ProcessExit>,\n@@ -269,7 +269,7 @@ unsafe fn killpid(pid: pid_t, signal: int) -> IoResult<()> {\n \n struct SpawnProcessResult {\n     pid: pid_t,\n-    handle: *(),\n+    handle: *mut (),\n }\n \n #[cfg(windows)]\n@@ -403,7 +403,7 @@ fn spawn_process_os(cfg: ProcessConfig,\n \n         Ok(SpawnProcessResult {\n             pid: pi.dwProcessId as pid_t,\n-            handle: pi.hProcess as *()\n+            handle: pi.hProcess as *mut ()\n         })\n     }\n }\n@@ -515,14 +515,14 @@ fn spawn_process_os(cfg: ProcessConfig,\n     }\n \n     #[cfg(target_os = \"macos\")]\n-    unsafe fn set_environ(envp: *c_void) {\n-        extern { fn _NSGetEnviron() -> *mut *c_void; }\n+    unsafe fn set_environ(envp: *const c_void) {\n+        extern { fn _NSGetEnviron() -> *mut *const c_void; }\n \n         *_NSGetEnviron() = envp;\n     }\n     #[cfg(not(target_os = \"macos\"))]\n-    unsafe fn set_environ(envp: *c_void) {\n-        extern { static mut environ: *c_void; }\n+    unsafe fn set_environ(envp: *const c_void) {\n+        extern { static mut environ: *const c_void; }\n         environ = envp;\n     }\n \n@@ -568,7 +568,7 @@ fn spawn_process_os(cfg: ProcessConfig,\n                     Err(..) => {\n                         Ok(SpawnProcessResult {\n                             pid: pid,\n-                            handle: ptr::null()\n+                            handle: ptr::mut_null()\n                         })\n                     }\n                     Ok(..) => fail!(\"short read on the cloexec pipe\"),\n@@ -668,17 +668,18 @@ fn spawn_process_os(cfg: ProcessConfig,\n             }\n             match cfg.uid {\n                 Some(u) => {\n-                    // When dropping privileges from root, the `setgroups` call will\n-                    // remove any extraneous groups. If we don't call this, then\n-                    // even though our uid has dropped, we may still have groups\n-                    // that enable us to do super-user things. This will fail if we\n-                    // aren't root, so don't bother checking the return value, this\n-                    // is just done as an optimistic privilege dropping function.\n+                    // When dropping privileges from root, the `setgroups` call\n+                    // will remove any extraneous groups. If we don't call this,\n+                    // then even though our uid has dropped, we may still have\n+                    // groups that enable us to do super-user things. This will\n+                    // fail if we aren't root, so don't bother checking the\n+                    // return value, this is just done as an optimistic\n+                    // privilege dropping function.\n                     extern {\n                         fn setgroups(ngroups: libc::c_int,\n-                                     ptr: *libc::c_void) -> libc::c_int;\n+                                     ptr: *const libc::c_void) -> libc::c_int;\n                     }\n-                    let _ = setgroups(0, 0 as *libc::c_void);\n+                    let _ = setgroups(0, 0 as *const libc::c_void);\n \n                     if libc::setuid(u as libc::uid_t) != 0 {\n                         fail(&mut output);\n@@ -698,15 +699,16 @@ fn spawn_process_os(cfg: ProcessConfig,\n             if !envp.is_null() {\n                 set_environ(envp);\n             }\n-            let _ = execvp(*argv, argv);\n+            let _ = execvp(*argv, argv as *mut _);\n             fail(&mut output);\n         })\n     })\n }\n \n #[cfg(unix)]\n-fn with_argv<T>(prog: &CString, args: &[CString], cb: proc(**libc::c_char) -> T) -> T {\n-    let mut ptrs: Vec<*libc::c_char> = Vec::with_capacity(args.len()+1);\n+fn with_argv<T>(prog: &CString, args: &[CString],\n+                cb: proc(*const *const libc::c_char) -> T) -> T {\n+    let mut ptrs: Vec<*const libc::c_char> = Vec::with_capacity(args.len()+1);\n \n     // Convert the CStrings into an array of pointers. Note: the\n     // lifetime of the various CStrings involved is guaranteed to be\n@@ -723,7 +725,8 @@ fn with_argv<T>(prog: &CString, args: &[CString], cb: proc(**libc::c_char) -> T)\n }\n \n #[cfg(unix)]\n-fn with_envp<T>(env: Option<&[(CString, CString)]>, cb: proc(*c_void) -> T) -> T {\n+fn with_envp<T>(env: Option<&[(CString, CString)]>,\n+                cb: proc(*const c_void) -> T) -> T {\n     // On posixy systems we can pass a char** for envp, which is a\n     // null-terminated array of \"k=v\\0\" strings. Since we must create\n     // these strings locally, yet expose a raw pointer to them, we\n@@ -742,13 +745,13 @@ fn with_envp<T>(env: Option<&[(CString, CString)]>, cb: proc(*c_void) -> T) -> T\n             }\n \n             // As with `with_argv`, this is unsafe, since cb could leak the pointers.\n-            let mut ptrs: Vec<*libc::c_char> =\n+            let mut ptrs: Vec<*const libc::c_char> =\n                 tmps.iter()\n-                    .map(|tmp| tmp.as_ptr() as *libc::c_char)\n+                    .map(|tmp| tmp.as_ptr() as *const libc::c_char)\n                     .collect();\n             ptrs.push(ptr::null());\n \n-            cb(ptrs.as_ptr() as *c_void)\n+            cb(ptrs.as_ptr() as *const c_void)\n         }\n         _ => cb(ptr::null())\n     }\n@@ -780,7 +783,7 @@ fn with_envp<T>(env: Option<&[(CString, CString)]>, cb: |*mut c_void| -> T) -> T\n }\n \n #[cfg(windows)]\n-fn with_dirp<T>(d: Option<&CString>, cb: |*u16| -> T) -> T {\n+fn with_dirp<T>(d: Option<&CString>, cb: |*const u16| -> T) -> T {\n     match d {\n       Some(dir) => {\n           let dir_str = dir.as_str()\n@@ -793,14 +796,14 @@ fn with_dirp<T>(d: Option<&CString>, cb: |*u16| -> T) -> T {\n }\n \n #[cfg(windows)]\n-fn free_handle(handle: *()) {\n+fn free_handle(handle: *mut ()) {\n     assert!(unsafe {\n         libc::CloseHandle(mem::transmute(handle)) != 0\n     })\n }\n \n #[cfg(unix)]\n-fn free_handle(_handle: *()) {\n+fn free_handle(_handle: *mut ()) {\n     // unix has no process handle object, just a pid\n }\n \n@@ -1014,15 +1017,16 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<rtio::ProcessExit> {\n                     let now = ::io::timer::now();\n                     let ms = if now < deadline {deadline - now} else {0};\n                     tv = util::ms_to_timeval(ms);\n-                    (&tv as *_, idx)\n+                    (&mut tv as *mut _, idx)\n                 }\n-                None => (ptr::null(), -1),\n+                None => (ptr::mut_null(), -1),\n             };\n \n             // Wait for something to happen\n             c::fd_set(&mut set, input);\n             c::fd_set(&mut set, read_fd);\n-            match unsafe { c::select(max, &set, ptr::null(), ptr::null(), p) } {\n+            match unsafe { c::select(max, &mut set, ptr::mut_null(),\n+                                     ptr::mut_null(), p) } {\n                 // interrupted, retry\n                 -1 if os::errno() == libc::EINTR as int => continue,\n \n@@ -1132,9 +1136,9 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<rtio::ProcessExit> {\n     // which will wake up the other end at some point, so we just allow this\n     // signal to be coalesced with the pending signals on the pipe.\n     extern fn sigchld_handler(_signum: libc::c_int) {\n-        let mut msg = 1;\n+        let msg = 1;\n         match unsafe {\n-            libc::write(WRITE_FD, &mut msg as *mut _ as *libc::c_void, 1)\n+            libc::write(WRITE_FD, &msg as *const _ as *const libc::c_void, 1)\n         } {\n             1 => {}\n             -1 if util::wouldblock() => {} // see above comments"}, {"sha": "8d6563bafad6365c3ed287bda8a31b81731a3918", "filename": "src/libnative/io/timer_unix.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -88,7 +88,7 @@ pub enum Req {\n pub fn now() -> u64 {\n     unsafe {\n         let mut now: libc::timeval = mem::zeroed();\n-        assert_eq!(c::gettimeofday(&mut now, ptr::null()), 0);\n+        assert_eq!(c::gettimeofday(&mut now, ptr::mut_null()), 0);\n         return (now.tv_sec as u64) * 1000 + (now.tv_usec as u64) / 1000;\n     }\n }\n@@ -146,7 +146,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: int) {\n     'outer: loop {\n         let timeout = if active.len() == 0 {\n             // Empty array? no timeout (wait forever for the next request)\n-            ptr::null()\n+            ptr::mut_null()\n         } else {\n             let now = now();\n             // If this request has already expired, then signal it and go\n@@ -162,12 +162,13 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: int) {\n             let tm = active.get(0).target - now;\n             timeout.tv_sec = (tm / 1000) as libc::time_t;\n             timeout.tv_usec = ((tm % 1000) * 1000) as libc::suseconds_t;\n-            &timeout as *libc::timeval\n+            &mut timeout as *mut libc::timeval\n         };\n \n         c::fd_set(&mut set, input);\n         match unsafe {\n-            c::select(input + 1, &set, ptr::null(), ptr::null(), timeout)\n+            c::select(input + 1, &mut set, ptr::mut_null(),\n+                      ptr::mut_null(), timeout)\n         } {\n             // timed out\n             0 => signal(&mut active, &mut dead),"}, {"sha": "1e5594126b10a9739b606b2cb40d2ce96024d4fb", "filename": "src/libnative/io/timer_win32.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Ftimer_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Ftimer_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_win32.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -141,7 +141,7 @@ impl rtio::RtioTimer for Timer {\n         // 100ns intervals, so we multiply by 10^4.\n         let due = -(msecs as i64 * 10000) as libc::LARGE_INTEGER;\n         assert_eq!(unsafe {\n-            imp::SetWaitableTimer(self.obj, &due, 0, ptr::null(),\n+            imp::SetWaitableTimer(self.obj, &due, 0, ptr::mut_null(),\n                                   ptr::mut_null(), 0)\n         }, 1);\n \n@@ -154,7 +154,7 @@ impl rtio::RtioTimer for Timer {\n         // see above for the calculation\n         let due = -(msecs as i64 * 10000) as libc::LARGE_INTEGER;\n         assert_eq!(unsafe {\n-            imp::SetWaitableTimer(self.obj, &due, 0, ptr::null(),\n+            imp::SetWaitableTimer(self.obj, &due, 0, ptr::mut_null(),\n                                   ptr::mut_null(), 0)\n         }, 1);\n \n@@ -169,7 +169,7 @@ impl rtio::RtioTimer for Timer {\n         let due = -(msecs as i64 * 10000) as libc::LARGE_INTEGER;\n         assert_eq!(unsafe {\n             imp::SetWaitableTimer(self.obj, &due, msecs as libc::LONG,\n-                                  ptr::null(), ptr::mut_null(), 0)\n+                                  ptr::mut_null(), ptr::mut_null(), 0)\n         }, 1);\n \n         unsafe { HELPER.send(NewTimer(self.obj, cb, false)) }\n@@ -188,20 +188,20 @@ mod imp {\n     use libc::{LPSECURITY_ATTRIBUTES, BOOL, LPCSTR, HANDLE, LARGE_INTEGER,\n                     LONG, LPVOID, DWORD, c_void};\n \n-    pub type PTIMERAPCROUTINE = *c_void;\n+    pub type PTIMERAPCROUTINE = *mut c_void;\n \n     extern \"system\" {\n         pub fn CreateWaitableTimerA(lpTimerAttributes: LPSECURITY_ATTRIBUTES,\n                                     bManualReset: BOOL,\n                                     lpTimerName: LPCSTR) -> HANDLE;\n         pub fn SetWaitableTimer(hTimer: HANDLE,\n-                                pDueTime: *LARGE_INTEGER,\n+                                pDueTime: *const LARGE_INTEGER,\n                                 lPeriod: LONG,\n                                 pfnCompletionRoutine: PTIMERAPCROUTINE,\n                                 lpArgToCompletionRoutine: LPVOID,\n                                 fResume: BOOL) -> BOOL;\n         pub fn WaitForMultipleObjects(nCount: DWORD,\n-                                      lpHandles: *HANDLE,\n+                                      lpHandles: *const HANDLE,\n                                       bWaitAll: BOOL,\n                                       dwMilliseconds: DWORD) -> DWORD;\n         pub fn WaitForSingleObject(hHandle: HANDLE,"}, {"sha": "31ba2223082d554325d66814aa8869500c566324", "filename": "src/libnative/io/util.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Futil.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -90,7 +90,7 @@ pub fn set_nonblocking(fd: net::sock_t, nb: bool) -> IoResult<()> {\n // See http://developerweb.net/viewtopic.php?id=3196 for where this is\n // derived from.\n pub fn connect_timeout(fd: net::sock_t,\n-                       addrp: *libc::sockaddr,\n+                       addrp: *const libc::sockaddr,\n                        len: libc::socklen_t,\n                        timeout_ms: u64) -> IoResult<()> {\n     use std::os;\n@@ -145,16 +145,16 @@ pub fn connect_timeout(fd: net::sock_t,\n             // Recalculate the timeout each iteration (it is generally\n             // undefined what the value of the 'tv' is after select\n             // returns EINTR).\n-            let tv = ms_to_timeval(timeout - (::io::timer::now() - start));\n-            c::select(fd + 1, ptr::null(), set as *mut _ as *_,\n-                      ptr::null(), &tv)\n+            let mut tv = ms_to_timeval(timeout - (::io::timer::now() - start));\n+            c::select(fd + 1, ptr::mut_null(), set as *mut _,\n+                      ptr::mut_null(), &mut tv)\n         })\n     }\n     #[cfg(windows)]\n     fn await(_fd: net::sock_t, set: &mut c::fd_set,\n              timeout: u64) -> libc::c_int {\n-        let tv = ms_to_timeval(timeout);\n-        unsafe { c::select(1, ptr::null(), &*set, ptr::null(), &tv) }\n+        let mut tv = ms_to_timeval(timeout);\n+        unsafe { c::select(1, ptr::mut_null(), set, ptr::mut_null(), &mut tv) }\n     }\n }\n \n@@ -163,25 +163,25 @@ pub fn await(fd: net::sock_t, deadline: Option<u64>,\n     let mut set: c::fd_set = unsafe { mem::zeroed() };\n     c::fd_set(&mut set, fd);\n     let (read, write) = match status {\n-        Readable => (&set as *_, ptr::null()),\n-        Writable => (ptr::null(), &set as *_),\n+        Readable => (&mut set as *mut _, ptr::mut_null()),\n+        Writable => (ptr::mut_null(), &mut set as *mut _),\n     };\n     let mut tv: libc::timeval = unsafe { mem::zeroed() };\n \n     match retry(|| {\n         let now = ::io::timer::now();\n         let tvp = match deadline {\n-            None => ptr::null(),\n+            None => ptr::mut_null(),\n             Some(deadline) => {\n                 // If we're past the deadline, then pass a 0 timeout to\n                 // select() so we can poll the status\n                 let ms = if deadline < now {0} else {deadline - now};\n                 tv = ms_to_timeval(ms);\n-                &tv as *_\n+                &mut tv as *mut _\n             }\n         };\n         let n = if cfg!(windows) {1} else {fd as libc::c_int + 1};\n-        let r = unsafe { c::select(n, read, write, ptr::null(), tvp) };\n+        let r = unsafe { c::select(n, read, write, ptr::mut_null(), tvp) };\n         r\n     }) {\n         -1 => Err(last_error()),"}, {"sha": "b6a4b08c60cafdfc7abba70ca2cf9f970cf53bef", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -20,7 +20,9 @@\n //! extern crate native;\n //!\n //! #[start]\n-//! fn start(argc: int, argv: **u8) -> int { native::start(argc, argv, main) }\n+//! fn start(argc: int, argv: *const *const u8) -> int {\n+//!     native::start(argc, argv, main)\n+//! }\n //!\n //! fn main() {\n //!     // this code is running on the main OS thread\n@@ -55,7 +57,6 @@\n \n #![deny(unused_result, unused_must_use)]\n #![allow(non_camel_case_types, deprecated)]\n-#![allow(unknown_features)] // NOTE: remove after a stage0 snap\n #![feature(default_type_params, lang_items)]\n \n // NB this crate explicitly does *not* allow glob imports, please seriously\n@@ -84,7 +85,7 @@ static OS_DEFAULT_STACK_ESTIMATE: uint = 2 * (1 << 20);\n \n #[lang = \"start\"]\n #[cfg(not(test))]\n-pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n+pub fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n     use std::mem;\n     start(argc, argv, proc() {\n         let main: extern \"Rust\" fn() = unsafe { mem::transmute(main) };\n@@ -101,9 +102,9 @@ pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n ///\n /// This function will only return once *all* native threads in the system have\n /// exited.\n-pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n+pub fn start(argc: int, argv: *const *const u8, main: proc()) -> int {\n     let something_around_the_top_of_the_stack = 1;\n-    let addr = &something_around_the_top_of_the_stack as *int;\n+    let addr = &something_around_the_top_of_the_stack as *const int;\n     let my_stack_top = addr as uint;\n \n     // FIXME #11359 we just assume that this thread has a stack of a"}, {"sha": "7ba588ac21c481fc6a6f4c2f654e0e1cdf600f54", "filename": "src/libnative/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -81,7 +81,7 @@ pub fn spawn_opts(opts: TaskOpts, f: proc():Send) {\n     // which our stack started).\n     Thread::spawn_stack(stack, proc() {\n         let something_around_the_top_of_the_stack = 1;\n-        let addr = &something_around_the_top_of_the_stack as *int;\n+        let addr = &something_around_the_top_of_the_stack as *const int;\n         let my_stack = addr as uint;\n         unsafe {\n             stack::record_stack_bounds(my_stack - stack + 1024, my_stack);\n@@ -198,7 +198,7 @@ impl rt::Runtime for Ops {\n         cur_task.put_runtime(self);\n \n         unsafe {\n-            let cur_task_dupe = &*cur_task as *Task;\n+            let cur_task_dupe = &mut *cur_task as *mut Task;\n             let task = BlockedTask::block(cur_task);\n \n             if times == 1 {"}, {"sha": "c85e0099ab832f9012f59c4ece785ac7298e43e4", "filename": "src/librlibc/lib.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrlibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrlibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrlibc%2Flib.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -27,7 +27,6 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/\")]\n #![feature(intrinsics)]\n-#![allow(unknown_features)] // NOTE: remove after stage0 snapshot\n \n #![no_std]\n #![experimental]\n@@ -43,31 +42,36 @@\n // implementations below. If pointer arithmetic is done through integers the\n // optimizations start to break down.\n extern \"rust-intrinsic\" {\n-    fn offset<T>(dst: *T, offset: int) -> *T;\n+    fn offset<T>(dst: *const T, offset: int) -> *const T;\n }\n \n #[no_mangle]\n-pub unsafe extern \"C\" fn memcpy(dest: *mut u8, src: *u8, n: uint) -> *mut u8 {\n+pub unsafe extern \"C\" fn memcpy(dest: *mut u8, src: *const u8,\n+                                n: uint) -> *mut u8 {\n     let mut i = 0;\n     while i < n {\n-        *(offset(dest as *u8, i as int) as *mut u8) = *offset(src, i as int);\n+        *(offset(dest as *const u8, i as int) as *mut u8) =\n+            *offset(src, i as int);\n         i += 1;\n     }\n     return dest;\n }\n \n #[no_mangle]\n-pub unsafe extern \"C\" fn memmove(dest: *mut u8, src: *u8, n: uint) -> *mut u8 {\n-    if src < dest as *u8 { // copy from end\n+pub unsafe extern \"C\" fn memmove(dest: *mut u8, src: *const u8,\n+                                 n: uint) -> *mut u8 {\n+    if src < dest as *const u8 { // copy from end\n         let mut i = n;\n         while i != 0 {\n             i -= 1;\n-            *(offset(dest as *u8, i as int) as *mut u8) = *offset(src, i as int);\n+            *(offset(dest as *const u8, i as int) as *mut u8) =\n+                *offset(src, i as int);\n         }\n     } else { // copy from beginning\n         let mut i = 0;\n         while i < n {\n-            *(offset(dest as *u8, i as int) as *mut u8) = *offset(src, i as int);\n+            *(offset(dest as *const u8, i as int) as *mut u8) =\n+                *offset(src, i as int);\n             i += 1;\n         }\n     }\n@@ -78,14 +82,14 @@ pub unsafe extern \"C\" fn memmove(dest: *mut u8, src: *u8, n: uint) -> *mut u8 {\n pub unsafe extern \"C\" fn memset(s: *mut u8, c: i32, n: uint) -> *mut u8 {\n     let mut i = 0;\n     while i < n {\n-        *(offset(s as *u8, i as int) as *mut u8) = c as u8;\n+        *(offset(s as *const u8, i as int) as *mut u8) = c as u8;\n         i += 1;\n     }\n     return s;\n }\n \n #[no_mangle]\n-pub unsafe extern \"C\" fn memcmp(s1: *u8, s2: *u8, n: uint) -> i32 {\n+pub unsafe extern \"C\" fn memcmp(s1: *const u8, s2: *const u8, n: uint) -> i32 {\n     let mut i = 0;\n     while i < n {\n         let a = *offset(s1, i as int);"}, {"sha": "69cc52d68b30b3172a0ffea3d870d5faf7dde49d", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -82,7 +82,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n              (),\n              |()| unsafe {\n             if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n-                                                    ptr as *libc::c_char,\n+                                                    ptr as *const libc::c_char,\n                                                     bc.len() as libc::size_t) {\n                 link::llvm_err(sess,\n                                format!(\"failed to load bc of `{}`\",\n@@ -94,10 +94,11 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     // Internalize everything but the reachable symbols of the current module\n     let cstrs: Vec<::std::c_str::CString> =\n         reachable.iter().map(|s| s.as_slice().to_c_str()).collect();\n-    let arr: Vec<*i8> = cstrs.iter().map(|c| c.with_ref(|p| p)).collect();\n+    let arr: Vec<*const i8> = cstrs.iter().map(|c| c.with_ref(|p| p)).collect();\n     let ptr = arr.as_ptr();\n     unsafe {\n-        llvm::LLVMRustRunRestrictionPass(llmod, ptr as **libc::c_char,\n+        llvm::LLVMRustRunRestrictionPass(llmod,\n+                                         ptr as *const *const libc::c_char,\n                                          arr.len() as libc::size_t);\n     }\n "}, {"sha": "d07e74493be96dc4b82547a158860d7e68e3442e", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 209, "deletions": 209, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -255,45 +255,45 @@ pub enum CodeGenModel {\n \n // Opaque pointer types\n pub enum Module_opaque {}\n-pub type ModuleRef = *Module_opaque;\n+pub type ModuleRef = *mut Module_opaque;\n pub enum Context_opaque {}\n-pub type ContextRef = *Context_opaque;\n+pub type ContextRef = *mut Context_opaque;\n pub enum Type_opaque {}\n-pub type TypeRef = *Type_opaque;\n+pub type TypeRef = *mut Type_opaque;\n pub enum Value_opaque {}\n-pub type ValueRef = *Value_opaque;\n+pub type ValueRef = *mut Value_opaque;\n pub enum BasicBlock_opaque {}\n-pub type BasicBlockRef = *BasicBlock_opaque;\n+pub type BasicBlockRef = *mut BasicBlock_opaque;\n pub enum Builder_opaque {}\n-pub type BuilderRef = *Builder_opaque;\n+pub type BuilderRef = *mut Builder_opaque;\n pub enum ExecutionEngine_opaque {}\n-pub type ExecutionEngineRef = *ExecutionEngine_opaque;\n+pub type ExecutionEngineRef = *mut ExecutionEngine_opaque;\n pub enum MemoryBuffer_opaque {}\n-pub type MemoryBufferRef = *MemoryBuffer_opaque;\n+pub type MemoryBufferRef = *mut MemoryBuffer_opaque;\n pub enum PassManager_opaque {}\n-pub type PassManagerRef = *PassManager_opaque;\n+pub type PassManagerRef = *mut PassManager_opaque;\n pub enum PassManagerBuilder_opaque {}\n-pub type PassManagerBuilderRef = *PassManagerBuilder_opaque;\n+pub type PassManagerBuilderRef = *mut PassManagerBuilder_opaque;\n pub enum Use_opaque {}\n-pub type UseRef = *Use_opaque;\n+pub type UseRef = *mut Use_opaque;\n pub enum TargetData_opaque {}\n-pub type TargetDataRef = *TargetData_opaque;\n+pub type TargetDataRef = *mut TargetData_opaque;\n pub enum ObjectFile_opaque {}\n-pub type ObjectFileRef = *ObjectFile_opaque;\n+pub type ObjectFileRef = *mut ObjectFile_opaque;\n pub enum SectionIterator_opaque {}\n-pub type SectionIteratorRef = *SectionIterator_opaque;\n+pub type SectionIteratorRef = *mut SectionIterator_opaque;\n pub enum Pass_opaque {}\n-pub type PassRef = *Pass_opaque;\n+pub type PassRef = *mut Pass_opaque;\n pub enum TargetMachine_opaque {}\n-pub type TargetMachineRef = *TargetMachine_opaque;\n+pub type TargetMachineRef = *mut TargetMachine_opaque;\n pub enum Archive_opaque {}\n-pub type ArchiveRef = *Archive_opaque;\n+pub type ArchiveRef = *mut Archive_opaque;\n \n pub mod debuginfo {\n     use super::{ValueRef};\n \n     pub enum DIBuilder_opaque {}\n-    pub type DIBuilderRef = *DIBuilder_opaque;\n+    pub type DIBuilderRef = *mut DIBuilder_opaque;\n \n     pub type DIDescriptor = ValueRef;\n     pub type DIScope = DIDescriptor;\n@@ -354,30 +354,30 @@ pub mod llvm {\n         pub fn LLVMContextCreate() -> ContextRef;\n         pub fn LLVMContextDispose(C: ContextRef);\n         pub fn LLVMGetMDKindIDInContext(C: ContextRef,\n-                                        Name: *c_char,\n+                                        Name: *const c_char,\n                                         SLen: c_uint)\n                                         -> c_uint;\n \n         /* Create and destroy modules. */\n-        pub fn LLVMModuleCreateWithNameInContext(ModuleID: *c_char,\n+        pub fn LLVMModuleCreateWithNameInContext(ModuleID: *const c_char,\n                                                  C: ContextRef)\n                                                  -> ModuleRef;\n         pub fn LLVMGetModuleContext(M: ModuleRef) -> ContextRef;\n         pub fn LLVMDisposeModule(M: ModuleRef);\n \n         /** Data layout. See Module::getDataLayout. */\n-        pub fn LLVMGetDataLayout(M: ModuleRef) -> *c_char;\n-        pub fn LLVMSetDataLayout(M: ModuleRef, Triple: *c_char);\n+        pub fn LLVMGetDataLayout(M: ModuleRef) -> *const c_char;\n+        pub fn LLVMSetDataLayout(M: ModuleRef, Triple: *const c_char);\n \n         /** Target triple. See Module::getTargetTriple. */\n-        pub fn LLVMGetTarget(M: ModuleRef) -> *c_char;\n-        pub fn LLVMSetTarget(M: ModuleRef, Triple: *c_char);\n+        pub fn LLVMGetTarget(M: ModuleRef) -> *const c_char;\n+        pub fn LLVMSetTarget(M: ModuleRef, Triple: *const c_char);\n \n         /** See Module::dump. */\n         pub fn LLVMDumpModule(M: ModuleRef);\n \n         /** See Module::setModuleInlineAsm. */\n-        pub fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *c_char);\n+        pub fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *const c_char);\n \n         /** See llvm::LLVMTypeKind::getTypeID. */\n         pub fn LLVMGetTypeKind(Ty: TypeRef) -> TypeKind;\n@@ -405,18 +405,18 @@ pub mod llvm {\n \n         /* Operations on function types */\n         pub fn LLVMFunctionType(ReturnType: TypeRef,\n-                                ParamTypes: *TypeRef,\n+                                ParamTypes: *const TypeRef,\n                                 ParamCount: c_uint,\n                                 IsVarArg: Bool)\n                                 -> TypeRef;\n         pub fn LLVMIsFunctionVarArg(FunctionTy: TypeRef) -> Bool;\n         pub fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n         pub fn LLVMCountParamTypes(FunctionTy: TypeRef) -> c_uint;\n-        pub fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *TypeRef);\n+        pub fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *const TypeRef);\n \n         /* Operations on struct types */\n         pub fn LLVMStructTypeInContext(C: ContextRef,\n-                                       ElementTypes: *TypeRef,\n+                                       ElementTypes: *const TypeRef,\n                                        ElementCount: c_uint,\n                                        Packed: Bool)\n                                        -> TypeRef;\n@@ -436,7 +436,7 @@ pub mod llvm {\n         pub fn LLVMGetArrayLength(ArrayTy: TypeRef) -> c_uint;\n         pub fn LLVMGetPointerAddressSpace(PointerTy: TypeRef) -> c_uint;\n         pub fn LLVMGetPointerToGlobal(EE: ExecutionEngineRef, V: ValueRef)\n-                                      -> *();\n+                                      -> *const ();\n         pub fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n \n         /* Operations on other types */\n@@ -446,8 +446,8 @@ pub mod llvm {\n \n         /* Operations on all values */\n         pub fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n-        pub fn LLVMGetValueName(Val: ValueRef) -> *c_char;\n-        pub fn LLVMSetValueName(Val: ValueRef, Name: *c_char);\n+        pub fn LLVMGetValueName(Val: ValueRef) -> *const c_char;\n+        pub fn LLVMSetValueName(Val: ValueRef, Name: *const c_char);\n         pub fn LLVMDumpValue(Val: ValueRef);\n         pub fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n         pub fn LLVMHasMetadata(Val: ValueRef) -> c_int;\n@@ -482,32 +482,32 @@ pub mod llvm {\n \n         /* Operations on metadata */\n         pub fn LLVMMDStringInContext(C: ContextRef,\n-                                     Str: *c_char,\n+                                     Str: *const c_char,\n                                      SLen: c_uint)\n                                      -> ValueRef;\n         pub fn LLVMMDNodeInContext(C: ContextRef,\n-                                   Vals: *ValueRef,\n+                                   Vals: *const ValueRef,\n                                    Count: c_uint)\n                                    -> ValueRef;\n         pub fn LLVMAddNamedMetadataOperand(M: ModuleRef,\n-                                           Str: *c_char,\n+                                           Str: *const c_char,\n                                            Val: ValueRef);\n \n         /* Operations on scalar constants */\n         pub fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool)\n                             -> ValueRef;\n-        pub fn LLVMConstIntOfString(IntTy: TypeRef, Text: *c_char, Radix: u8)\n+        pub fn LLVMConstIntOfString(IntTy: TypeRef, Text: *const c_char, Radix: u8)\n                                     -> ValueRef;\n         pub fn LLVMConstIntOfStringAndSize(IntTy: TypeRef,\n-                                           Text: *c_char,\n+                                           Text: *const c_char,\n                                            SLen: c_uint,\n                                            Radix: u8)\n                                            -> ValueRef;\n         pub fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n-        pub fn LLVMConstRealOfString(RealTy: TypeRef, Text: *c_char)\n+        pub fn LLVMConstRealOfString(RealTy: TypeRef, Text: *const c_char)\n                                      -> ValueRef;\n         pub fn LLVMConstRealOfStringAndSize(RealTy: TypeRef,\n-                                            Text: *c_char,\n+                                            Text: *const c_char,\n                                             SLen: c_uint)\n                                             -> ValueRef;\n         pub fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n@@ -516,21 +516,21 @@ pub mod llvm {\n \n         /* Operations on composite constants */\n         pub fn LLVMConstStringInContext(C: ContextRef,\n-                                        Str: *c_char,\n+                                        Str: *const c_char,\n                                         Length: c_uint,\n                                         DontNullTerminate: Bool)\n                                         -> ValueRef;\n         pub fn LLVMConstStructInContext(C: ContextRef,\n-                                        ConstantVals: *ValueRef,\n+                                        ConstantVals: *const ValueRef,\n                                         Count: c_uint,\n                                         Packed: Bool)\n                                         -> ValueRef;\n \n         pub fn LLVMConstArray(ElementTy: TypeRef,\n-                              ConstantVals: *ValueRef,\n+                              ConstantVals: *const ValueRef,\n                               Length: c_uint)\n                               -> ValueRef;\n-        pub fn LLVMConstVector(ScalarConstantVals: *ValueRef, Size: c_uint)\n+        pub fn LLVMConstVector(ScalarConstantVals: *const ValueRef, Size: c_uint)\n                                -> ValueRef;\n \n         /* Constant expressions */\n@@ -593,11 +593,11 @@ pub mod llvm {\n         pub fn LLVMConstAShr(LHSConstant: ValueRef, RHSConstant: ValueRef)\n                              -> ValueRef;\n         pub fn LLVMConstGEP(ConstantVal: ValueRef,\n-                            ConstantIndices: *ValueRef,\n+                            ConstantIndices: *const ValueRef,\n                             NumIndices: c_uint)\n                             -> ValueRef;\n         pub fn LLVMConstInBoundsGEP(ConstantVal: ValueRef,\n-                                    ConstantIndices: *ValueRef,\n+                                    ConstantIndices: *const ValueRef,\n                                     NumIndices: c_uint)\n                                     -> ValueRef;\n         pub fn LLVMConstTrunc(ConstantVal: ValueRef, ToType: TypeRef)\n@@ -654,17 +654,17 @@ pub mod llvm {\n                                       MaskConstant: ValueRef)\n                                       -> ValueRef;\n         pub fn LLVMConstExtractValue(AggConstant: ValueRef,\n-                                     IdxList: *c_uint,\n+                                     IdxList: *const c_uint,\n                                      NumIdx: c_uint)\n                                      -> ValueRef;\n         pub fn LLVMConstInsertValue(AggConstant: ValueRef,\n                                     ElementValueConstant: ValueRef,\n-                                    IdxList: *c_uint,\n+                                    IdxList: *const c_uint,\n                                     NumIdx: c_uint)\n                                     -> ValueRef;\n         pub fn LLVMConstInlineAsm(Ty: TypeRef,\n-                                  AsmString: *c_char,\n-                                  Constraints: *c_char,\n+                                  AsmString: *const c_char,\n+                                  Constraints: *const c_char,\n                                   HasSideEffects: Bool,\n                                   IsAlignStack: Bool)\n                                   -> ValueRef;\n@@ -677,23 +677,23 @@ pub mod llvm {\n         pub fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n         pub fn LLVMGetLinkage(Global: ValueRef) -> c_uint;\n         pub fn LLVMSetLinkage(Global: ValueRef, Link: c_uint);\n-        pub fn LLVMGetSection(Global: ValueRef) -> *c_char;\n-        pub fn LLVMSetSection(Global: ValueRef, Section: *c_char);\n+        pub fn LLVMGetSection(Global: ValueRef) -> *const c_char;\n+        pub fn LLVMSetSection(Global: ValueRef, Section: *const c_char);\n         pub fn LLVMGetVisibility(Global: ValueRef) -> c_uint;\n         pub fn LLVMSetVisibility(Global: ValueRef, Viz: c_uint);\n         pub fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n         pub fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n \n \n         /* Operations on global variables */\n-        pub fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: *c_char)\n+        pub fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMAddGlobalInAddressSpace(M: ModuleRef,\n                                            Ty: TypeRef,\n-                                           Name: *c_char,\n+                                           Name: *const c_char,\n                                            AddressSpace: c_uint)\n                                            -> ValueRef;\n-        pub fn LLVMGetNamedGlobal(M: ModuleRef, Name: *c_char) -> ValueRef;\n+        pub fn LLVMGetNamedGlobal(M: ModuleRef, Name: *const c_char) -> ValueRef;\n         pub fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n         pub fn LLVMGetLastGlobal(M: ModuleRef) -> ValueRef;\n         pub fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n@@ -711,37 +711,37 @@ pub mod llvm {\n         pub fn LLVMAddAlias(M: ModuleRef,\n                             Ty: TypeRef,\n                             Aliasee: ValueRef,\n-                            Name: *c_char)\n+                            Name: *const c_char)\n                             -> ValueRef;\n \n         /* Operations on functions */\n         pub fn LLVMAddFunction(M: ModuleRef,\n-                               Name: *c_char,\n+                               Name: *const c_char,\n                                FunctionTy: TypeRef)\n                                -> ValueRef;\n-        pub fn LLVMGetNamedFunction(M: ModuleRef, Name: *c_char) -> ValueRef;\n+        pub fn LLVMGetNamedFunction(M: ModuleRef, Name: *const c_char) -> ValueRef;\n         pub fn LLVMGetFirstFunction(M: ModuleRef) -> ValueRef;\n         pub fn LLVMGetLastFunction(M: ModuleRef) -> ValueRef;\n         pub fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n         pub fn LLVMGetPreviousFunction(Fn: ValueRef) -> ValueRef;\n         pub fn LLVMDeleteFunction(Fn: ValueRef);\n         pub fn LLVMGetOrInsertFunction(M: ModuleRef,\n-                                       Name: *c_char,\n+                                       Name: *const c_char,\n                                        FunctionTy: TypeRef)\n                                        -> ValueRef;\n         pub fn LLVMGetIntrinsicID(Fn: ValueRef) -> c_uint;\n         pub fn LLVMGetFunctionCallConv(Fn: ValueRef) -> c_uint;\n         pub fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n-        pub fn LLVMGetGC(Fn: ValueRef) -> *c_char;\n-        pub fn LLVMSetGC(Fn: ValueRef, Name: *c_char);\n+        pub fn LLVMGetGC(Fn: ValueRef) -> *const c_char;\n+        pub fn LLVMSetGC(Fn: ValueRef, Name: *const c_char);\n         pub fn LLVMAddFunctionAttribute(Fn: ValueRef, index: c_uint, PA: uint64_t);\n-        pub fn LLVMAddFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *c_char);\n-        pub fn LLVMRemoveFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *c_char);\n+        pub fn LLVMAddFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n+        pub fn LLVMRemoveFunctionAttrString(Fn: ValueRef, index: c_uint, Name: *const c_char);\n         pub fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_ulonglong;\n \n         /* Operations on parameters */\n         pub fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n-        pub fn LLVMGetParams(Fn: ValueRef, Params: *ValueRef);\n+        pub fn LLVMGetParams(Fn: ValueRef, Params: *const ValueRef);\n         pub fn LLVMGetParam(Fn: ValueRef, Index: c_uint) -> ValueRef;\n         pub fn LLVMGetParamParent(Inst: ValueRef) -> ValueRef;\n         pub fn LLVMGetFirstParam(Fn: ValueRef) -> ValueRef;\n@@ -759,7 +759,7 @@ pub mod llvm {\n         pub fn LLVMValueAsBasicBlock(Val: ValueRef) -> BasicBlockRef;\n         pub fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> ValueRef;\n         pub fn LLVMCountBasicBlocks(Fn: ValueRef) -> c_uint;\n-        pub fn LLVMGetBasicBlocks(Fn: ValueRef, BasicBlocks: *ValueRef);\n+        pub fn LLVMGetBasicBlocks(Fn: ValueRef, BasicBlocks: *const ValueRef);\n         pub fn LLVMGetFirstBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n         pub fn LLVMGetLastBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n         pub fn LLVMGetNextBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n@@ -768,11 +768,11 @@ pub mod llvm {\n \n         pub fn LLVMAppendBasicBlockInContext(C: ContextRef,\n                                              Fn: ValueRef,\n-                                             Name: *c_char)\n+                                             Name: *const c_char)\n                                              -> BasicBlockRef;\n         pub fn LLVMInsertBasicBlockInContext(C: ContextRef,\n                                              BB: BasicBlockRef,\n-                                             Name: *c_char)\n+                                             Name: *const c_char)\n                                              -> BasicBlockRef;\n         pub fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n \n@@ -816,8 +816,8 @@ pub mod llvm {\n \n         /* Operations on phi nodes */\n         pub fn LLVMAddIncoming(PhiNode: ValueRef,\n-                               IncomingValues: *ValueRef,\n-                               IncomingBlocks: *BasicBlockRef,\n+                               IncomingValues: *const ValueRef,\n+                               IncomingBlocks: *const BasicBlockRef,\n                                Count: c_uint);\n         pub fn LLVMCountIncoming(PhiNode: ValueRef) -> c_uint;\n         pub fn LLVMGetIncomingValue(PhiNode: ValueRef, Index: c_uint)\n@@ -839,7 +839,7 @@ pub mod llvm {\n         pub fn LLVMInsertIntoBuilder(Builder: BuilderRef, Instr: ValueRef);\n         pub fn LLVMInsertIntoBuilderWithName(Builder: BuilderRef,\n                                              Instr: ValueRef,\n-                                             Name: *c_char);\n+                                             Name: *const c_char);\n         pub fn LLVMDisposeBuilder(Builder: BuilderRef);\n         pub fn LLVMDisposeExecutionEngine(EE: ExecutionEngineRef);\n \n@@ -852,7 +852,7 @@ pub mod llvm {\n         pub fn LLVMBuildRetVoid(B: BuilderRef) -> ValueRef;\n         pub fn LLVMBuildRet(B: BuilderRef, V: ValueRef) -> ValueRef;\n         pub fn LLVMBuildAggregateRet(B: BuilderRef,\n-                                     RetVals: *ValueRef,\n+                                     RetVals: *const ValueRef,\n                                      N: c_uint)\n                                      -> ValueRef;\n         pub fn LLVMBuildBr(B: BuilderRef, Dest: BasicBlockRef) -> ValueRef;\n@@ -872,17 +872,17 @@ pub mod llvm {\n                                    -> ValueRef;\n         pub fn LLVMBuildInvoke(B: BuilderRef,\n                                Fn: ValueRef,\n-                               Args: *ValueRef,\n+                               Args: *const ValueRef,\n                                NumArgs: c_uint,\n                                Then: BasicBlockRef,\n                                Catch: BasicBlockRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildLandingPad(B: BuilderRef,\n                                    Ty: TypeRef,\n                                    PersFn: ValueRef,\n                                    NumClauses: c_uint,\n-                                   Name: *c_char)\n+                                   Name: *const c_char)\n                                    -> ValueRef;\n         pub fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef) -> ValueRef;\n         pub fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n@@ -905,369 +905,369 @@ pub mod llvm {\n         pub fn LLVMBuildAdd(B: BuilderRef,\n                             LHS: ValueRef,\n                             RHS: ValueRef,\n-                            Name: *c_char)\n+                            Name: *const c_char)\n                             -> ValueRef;\n         pub fn LLVMBuildNSWAdd(B: BuilderRef,\n                                LHS: ValueRef,\n                                RHS: ValueRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildNUWAdd(B: BuilderRef,\n                                LHS: ValueRef,\n                                RHS: ValueRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildFAdd(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildSub(B: BuilderRef,\n                             LHS: ValueRef,\n                             RHS: ValueRef,\n-                            Name: *c_char)\n+                            Name: *const c_char)\n                             -> ValueRef;\n         pub fn LLVMBuildNSWSub(B: BuilderRef,\n                                LHS: ValueRef,\n                                RHS: ValueRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildNUWSub(B: BuilderRef,\n                                LHS: ValueRef,\n                                RHS: ValueRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildFSub(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildMul(B: BuilderRef,\n                             LHS: ValueRef,\n                             RHS: ValueRef,\n-                            Name: *c_char)\n+                            Name: *const c_char)\n                             -> ValueRef;\n         pub fn LLVMBuildNSWMul(B: BuilderRef,\n                                LHS: ValueRef,\n                                RHS: ValueRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildNUWMul(B: BuilderRef,\n                                LHS: ValueRef,\n                                RHS: ValueRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildFMul(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildUDiv(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildSDiv(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildExactSDiv(B: BuilderRef,\n                                   LHS: ValueRef,\n                                   RHS: ValueRef,\n-                                  Name: *c_char)\n+                                  Name: *const c_char)\n                                   -> ValueRef;\n         pub fn LLVMBuildFDiv(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildURem(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildSRem(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildFRem(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildShl(B: BuilderRef,\n                             LHS: ValueRef,\n                             RHS: ValueRef,\n-                            Name: *c_char)\n+                            Name: *const c_char)\n                             -> ValueRef;\n         pub fn LLVMBuildLShr(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildAShr(B: BuilderRef,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildAnd(B: BuilderRef,\n                             LHS: ValueRef,\n                             RHS: ValueRef,\n-                            Name: *c_char)\n+                            Name: *const c_char)\n                             -> ValueRef;\n         pub fn LLVMBuildOr(B: BuilderRef,\n                            LHS: ValueRef,\n                            RHS: ValueRef,\n-                           Name: *c_char)\n+                           Name: *const c_char)\n                            -> ValueRef;\n         pub fn LLVMBuildXor(B: BuilderRef,\n                             LHS: ValueRef,\n                             RHS: ValueRef,\n-                            Name: *c_char)\n+                            Name: *const c_char)\n                             -> ValueRef;\n         pub fn LLVMBuildBinOp(B: BuilderRef,\n                               Op: Opcode,\n                               LHS: ValueRef,\n                               RHS: ValueRef,\n-                              Name: *c_char)\n+                              Name: *const c_char)\n                               -> ValueRef;\n-        pub fn LLVMBuildNeg(B: BuilderRef, V: ValueRef, Name: *c_char)\n+        pub fn LLVMBuildNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n                             -> ValueRef;\n-        pub fn LLVMBuildNSWNeg(B: BuilderRef, V: ValueRef, Name: *c_char)\n+        pub fn LLVMBuildNSWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n                                -> ValueRef;\n-        pub fn LLVMBuildNUWNeg(B: BuilderRef, V: ValueRef, Name: *c_char)\n+        pub fn LLVMBuildNUWNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n                                -> ValueRef;\n-        pub fn LLVMBuildFNeg(B: BuilderRef, V: ValueRef, Name: *c_char)\n+        pub fn LLVMBuildFNeg(B: BuilderRef, V: ValueRef, Name: *const c_char)\n                              -> ValueRef;\n-        pub fn LLVMBuildNot(B: BuilderRef, V: ValueRef, Name: *c_char)\n+        pub fn LLVMBuildNot(B: BuilderRef, V: ValueRef, Name: *const c_char)\n                             -> ValueRef;\n \n         /* Memory */\n-        pub fn LLVMBuildMalloc(B: BuilderRef, Ty: TypeRef, Name: *c_char)\n+        pub fn LLVMBuildMalloc(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildArrayMalloc(B: BuilderRef,\n                                     Ty: TypeRef,\n                                     Val: ValueRef,\n-                                    Name: *c_char)\n+                                    Name: *const c_char)\n                                     -> ValueRef;\n-        pub fn LLVMBuildAlloca(B: BuilderRef, Ty: TypeRef, Name: *c_char)\n+        pub fn LLVMBuildAlloca(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildArrayAlloca(B: BuilderRef,\n                                     Ty: TypeRef,\n                                     Val: ValueRef,\n-                                    Name: *c_char)\n+                                    Name: *const c_char)\n                                     -> ValueRef;\n         pub fn LLVMBuildFree(B: BuilderRef, PointerVal: ValueRef) -> ValueRef;\n         pub fn LLVMBuildLoad(B: BuilderRef,\n                              PointerVal: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n \n         pub fn LLVMBuildStore(B: BuilderRef, Val: ValueRef, Ptr: ValueRef)\n                               -> ValueRef;\n \n         pub fn LLVMBuildGEP(B: BuilderRef,\n                             Pointer: ValueRef,\n-                            Indices: *ValueRef,\n+                            Indices: *const ValueRef,\n                             NumIndices: c_uint,\n-                            Name: *c_char)\n+                            Name: *const c_char)\n                             -> ValueRef;\n         pub fn LLVMBuildInBoundsGEP(B: BuilderRef,\n                                     Pointer: ValueRef,\n-                                    Indices: *ValueRef,\n+                                    Indices: *const ValueRef,\n                                     NumIndices: c_uint,\n-                                    Name: *c_char)\n+                                    Name: *const c_char)\n                                     -> ValueRef;\n         pub fn LLVMBuildStructGEP(B: BuilderRef,\n                                   Pointer: ValueRef,\n                                   Idx: c_uint,\n-                                  Name: *c_char)\n+                                  Name: *const c_char)\n                                   -> ValueRef;\n         pub fn LLVMBuildGlobalString(B: BuilderRef,\n-                                     Str: *c_char,\n-                                     Name: *c_char)\n+                                     Str: *const c_char,\n+                                     Name: *const c_char)\n                                      -> ValueRef;\n         pub fn LLVMBuildGlobalStringPtr(B: BuilderRef,\n-                                        Str: *c_char,\n-                                        Name: *c_char)\n+                                        Str: *const c_char,\n+                                        Name: *const c_char)\n                                         -> ValueRef;\n \n         /* Casts */\n         pub fn LLVMBuildTrunc(B: BuilderRef,\n                               Val: ValueRef,\n                               DestTy: TypeRef,\n-                              Name: *c_char)\n+                              Name: *const c_char)\n                               -> ValueRef;\n         pub fn LLVMBuildZExt(B: BuilderRef,\n                              Val: ValueRef,\n                              DestTy: TypeRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildSExt(B: BuilderRef,\n                              Val: ValueRef,\n                              DestTy: TypeRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildFPToUI(B: BuilderRef,\n                                Val: ValueRef,\n                                DestTy: TypeRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildFPToSI(B: BuilderRef,\n                                Val: ValueRef,\n                                DestTy: TypeRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildUIToFP(B: BuilderRef,\n                                Val: ValueRef,\n                                DestTy: TypeRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildSIToFP(B: BuilderRef,\n                                Val: ValueRef,\n                                DestTy: TypeRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildFPTrunc(B: BuilderRef,\n                                 Val: ValueRef,\n                                 DestTy: TypeRef,\n-                                Name: *c_char)\n+                                Name: *const c_char)\n                                 -> ValueRef;\n         pub fn LLVMBuildFPExt(B: BuilderRef,\n                               Val: ValueRef,\n                               DestTy: TypeRef,\n-                              Name: *c_char)\n+                              Name: *const c_char)\n                               -> ValueRef;\n         pub fn LLVMBuildPtrToInt(B: BuilderRef,\n                                  Val: ValueRef,\n                                  DestTy: TypeRef,\n-                                 Name: *c_char)\n+                                 Name: *const c_char)\n                                  -> ValueRef;\n         pub fn LLVMBuildIntToPtr(B: BuilderRef,\n                                  Val: ValueRef,\n                                  DestTy: TypeRef,\n-                                 Name: *c_char)\n+                                 Name: *const c_char)\n                                  -> ValueRef;\n         pub fn LLVMBuildBitCast(B: BuilderRef,\n                                 Val: ValueRef,\n                                 DestTy: TypeRef,\n-                                Name: *c_char)\n+                                Name: *const c_char)\n                                 -> ValueRef;\n         pub fn LLVMBuildZExtOrBitCast(B: BuilderRef,\n                                       Val: ValueRef,\n                                       DestTy: TypeRef,\n-                                      Name: *c_char)\n+                                      Name: *const c_char)\n                                       -> ValueRef;\n         pub fn LLVMBuildSExtOrBitCast(B: BuilderRef,\n                                       Val: ValueRef,\n                                       DestTy: TypeRef,\n-                                      Name: *c_char)\n+                                      Name: *const c_char)\n                                       -> ValueRef;\n         pub fn LLVMBuildTruncOrBitCast(B: BuilderRef,\n                                        Val: ValueRef,\n                                        DestTy: TypeRef,\n-                                       Name: *c_char)\n+                                       Name: *const c_char)\n                                        -> ValueRef;\n         pub fn LLVMBuildCast(B: BuilderRef,\n                              Op: Opcode,\n                              Val: ValueRef,\n                              DestTy: TypeRef,\n-                             Name: *c_char) -> ValueRef;\n+                             Name: *const c_char) -> ValueRef;\n         pub fn LLVMBuildPointerCast(B: BuilderRef,\n                                     Val: ValueRef,\n                                     DestTy: TypeRef,\n-                                    Name: *c_char)\n+                                    Name: *const c_char)\n                                     -> ValueRef;\n         pub fn LLVMBuildIntCast(B: BuilderRef,\n                                 Val: ValueRef,\n                                 DestTy: TypeRef,\n-                                Name: *c_char)\n+                                Name: *const c_char)\n                                 -> ValueRef;\n         pub fn LLVMBuildFPCast(B: BuilderRef,\n                                Val: ValueRef,\n                                DestTy: TypeRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n \n         /* Comparisons */\n         pub fn LLVMBuildICmp(B: BuilderRef,\n                              Op: c_uint,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildFCmp(B: BuilderRef,\n                              Op: c_uint,\n                              LHS: ValueRef,\n                              RHS: ValueRef,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n \n         /* Miscellaneous instructions */\n-        pub fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: *c_char)\n+        pub fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: *const c_char)\n                             -> ValueRef;\n         pub fn LLVMBuildCall(B: BuilderRef,\n                              Fn: ValueRef,\n-                             Args: *ValueRef,\n+                             Args: *const ValueRef,\n                              NumArgs: c_uint,\n-                             Name: *c_char)\n+                             Name: *const c_char)\n                              -> ValueRef;\n         pub fn LLVMBuildSelect(B: BuilderRef,\n                                If: ValueRef,\n                                Then: ValueRef,\n                                Else: ValueRef,\n-                               Name: *c_char)\n+                               Name: *const c_char)\n                                -> ValueRef;\n         pub fn LLVMBuildVAArg(B: BuilderRef,\n                               list: ValueRef,\n                               Ty: TypeRef,\n-                              Name: *c_char)\n+                              Name: *const c_char)\n                               -> ValueRef;\n         pub fn LLVMBuildExtractElement(B: BuilderRef,\n                                        VecVal: ValueRef,\n                                        Index: ValueRef,\n-                                       Name: *c_char)\n+                                       Name: *const c_char)\n                                        -> ValueRef;\n         pub fn LLVMBuildInsertElement(B: BuilderRef,\n                                       VecVal: ValueRef,\n                                       EltVal: ValueRef,\n                                       Index: ValueRef,\n-                                      Name: *c_char)\n+                                      Name: *const c_char)\n                                       -> ValueRef;\n         pub fn LLVMBuildShuffleVector(B: BuilderRef,\n                                       V1: ValueRef,\n                                       V2: ValueRef,\n                                       Mask: ValueRef,\n-                                      Name: *c_char)\n+                                      Name: *const c_char)\n                                       -> ValueRef;\n         pub fn LLVMBuildExtractValue(B: BuilderRef,\n                                      AggVal: ValueRef,\n                                      Index: c_uint,\n-                                     Name: *c_char)\n+                                     Name: *const c_char)\n                                      -> ValueRef;\n         pub fn LLVMBuildInsertValue(B: BuilderRef,\n                                     AggVal: ValueRef,\n                                     EltVal: ValueRef,\n                                     Index: c_uint,\n-                                    Name: *c_char)\n+                                    Name: *const c_char)\n                                     -> ValueRef;\n \n-        pub fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: *c_char)\n+        pub fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: *const c_char)\n                                -> ValueRef;\n-        pub fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *c_char)\n+        pub fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *const c_char)\n                                   -> ValueRef;\n         pub fn LLVMBuildPtrDiff(B: BuilderRef,\n                                 LHS: ValueRef,\n                                 RHS: ValueRef,\n-                                Name: *c_char)\n+                                Name: *const c_char)\n                                 -> ValueRef;\n \n         /* Atomic Operations */\n         pub fn LLVMBuildAtomicLoad(B: BuilderRef,\n                                    PointerVal: ValueRef,\n-                                   Name: *c_char,\n+                                   Name: *const c_char,\n                                    Order: AtomicOrdering,\n                                    Alignment: c_uint)\n                                    -> ValueRef;\n@@ -1302,10 +1302,10 @@ pub mod llvm {\n         pub fn LLVMIsAStoreInst(Inst: ValueRef) -> ValueRef;\n \n         /** Writes a module to the specified path. Returns 0 on success. */\n-        pub fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: *c_char) -> c_int;\n+        pub fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: *const c_char) -> c_int;\n \n         /** Creates target data from a target layout string. */\n-        pub fn LLVMCreateTargetData(StringRep: *c_char) -> TargetDataRef;\n+        pub fn LLVMCreateTargetData(StringRep: *const c_char) -> TargetDataRef;\n         /// Adds the target data to the given pass manager. The pass manager\n         /// references the target data only weakly.\n         pub fn LLVMAddTargetData(TD: TargetDataRef, PM: PassManagerRef);\n@@ -1464,42 +1464,42 @@ pub mod llvm {\n         /** Returns the current section size. */\n         pub fn LLVMGetSectionSize(SI: SectionIteratorRef) -> c_ulonglong;\n         /** Returns the current section contents as a string buffer. */\n-        pub fn LLVMGetSectionContents(SI: SectionIteratorRef) -> *c_char;\n+        pub fn LLVMGetSectionContents(SI: SectionIteratorRef) -> *const c_char;\n \n         /** Reads the given file and returns it as a memory buffer. Use\n             LLVMDisposeMemoryBuffer() to get rid of it. */\n-        pub fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *c_char)\n+        pub fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *const c_char)\n             -> MemoryBufferRef;\n         /** Borrows the contents of the memory buffer (doesn't copy it) */\n-        pub fn LLVMCreateMemoryBufferWithMemoryRange(InputData: *c_char,\n+        pub fn LLVMCreateMemoryBufferWithMemoryRange(InputData: *const c_char,\n                                                      InputDataLength: size_t,\n-                                                     BufferName: *c_char,\n+                                                     BufferName: *const c_char,\n                                                      RequiresNull: Bool)\n             -> MemoryBufferRef;\n-        pub fn LLVMCreateMemoryBufferWithMemoryRangeCopy(InputData: *c_char,\n+        pub fn LLVMCreateMemoryBufferWithMemoryRangeCopy(InputData: *const c_char,\n                                                          InputDataLength: size_t,\n-                                                         BufferName: *c_char)\n+                                                         BufferName: *const c_char)\n             -> MemoryBufferRef;\n \n         pub fn LLVMIsMultithreaded() -> Bool;\n         pub fn LLVMStartMultithreaded() -> Bool;\n \n         /** Returns a string describing the last error caused by an LLVMRust*\n             call. */\n-        pub fn LLVMRustGetLastError() -> *c_char;\n+        pub fn LLVMRustGetLastError() -> *const c_char;\n \n         /// Print the pass timings since static dtors aren't picking them up.\n         pub fn LLVMRustPrintPassTimings();\n \n-        pub fn LLVMStructCreateNamed(C: ContextRef, Name: *c_char) -> TypeRef;\n+        pub fn LLVMStructCreateNamed(C: ContextRef, Name: *const c_char) -> TypeRef;\n \n         pub fn LLVMStructSetBody(StructTy: TypeRef,\n-                                 ElementTypes: *TypeRef,\n+                                 ElementTypes: *const TypeRef,\n                                  ElementCount: c_uint,\n                                  Packed: Bool);\n \n         pub fn LLVMConstNamedStruct(S: TypeRef,\n-                                    ConstantVals: *ValueRef,\n+                                    ConstantVals: *const ValueRef,\n                                     Count: c_uint)\n                                     -> ValueRef;\n \n@@ -1508,8 +1508,8 @@ pub mod llvm {\n \n         /** Prepares inline assembly. */\n         pub fn LLVMInlineAsm(Ty: TypeRef,\n-                             AsmString: *c_char,\n-                             Constraints: *c_char,\n+                             AsmString: *const c_char,\n+                             Constraints: *const c_char,\n                              SideEffects: Bool,\n                              AlignStack: Bool,\n                              Dialect: c_uint)\n@@ -1518,7 +1518,7 @@ pub mod llvm {\n         pub static LLVMRustDebugMetadataVersion: u32;\n \n         pub fn LLVMRustAddModuleFlag(M: ModuleRef,\n-                                     name: *c_char,\n+                                     name: *const c_char,\n                                      value: u32);\n \n         pub fn LLVMDIBuilderCreate(M: ModuleRef) -> DIBuilderRef;\n@@ -1529,17 +1529,17 @@ pub mod llvm {\n \n         pub fn LLVMDIBuilderCreateCompileUnit(Builder: DIBuilderRef,\n                                               Lang: c_uint,\n-                                              File: *c_char,\n-                                              Dir: *c_char,\n-                                              Producer: *c_char,\n+                                              File: *const c_char,\n+                                              Dir: *const c_char,\n+                                              Producer: *const c_char,\n                                               isOptimized: bool,\n-                                              Flags: *c_char,\n+                                              Flags: *const c_char,\n                                               RuntimeVer: c_uint,\n-                                              SplitName: *c_char);\n+                                              SplitName: *const c_char);\n \n         pub fn LLVMDIBuilderCreateFile(Builder: DIBuilderRef,\n-                                       Filename: *c_char,\n-                                       Directory: *c_char)\n+                                       Filename: *const c_char,\n+                                       Directory: *const c_char)\n                                        -> DIFile;\n \n         pub fn LLVMDIBuilderCreateSubroutineType(Builder: DIBuilderRef,\n@@ -1549,8 +1549,8 @@ pub mod llvm {\n \n         pub fn LLVMDIBuilderCreateFunction(Builder: DIBuilderRef,\n                                            Scope: DIDescriptor,\n-                                           Name: *c_char,\n-                                           LinkageName: *c_char,\n+                                           Name: *const c_char,\n+                                           LinkageName: *const c_char,\n                                            File: DIFile,\n                                            LineNo: c_uint,\n                                            Ty: DIType,\n@@ -1565,7 +1565,7 @@ pub mod llvm {\n                                            -> DISubprogram;\n \n         pub fn LLVMDIBuilderCreateBasicType(Builder: DIBuilderRef,\n-                                            Name: *c_char,\n+                                            Name: *const c_char,\n                                             SizeInBits: c_ulonglong,\n                                             AlignInBits: c_ulonglong,\n                                             Encoding: c_uint)\n@@ -1575,12 +1575,12 @@ pub mod llvm {\n                                               PointeeTy: DIType,\n                                               SizeInBits: c_ulonglong,\n                                               AlignInBits: c_ulonglong,\n-                                              Name: *c_char)\n+                                              Name: *const c_char)\n                                               -> DIDerivedType;\n \n         pub fn LLVMDIBuilderCreateStructType(Builder: DIBuilderRef,\n                                              Scope: DIDescriptor,\n-                                             Name: *c_char,\n+                                             Name: *const c_char,\n                                              File: DIFile,\n                                              LineNumber: c_uint,\n                                              SizeInBits: c_ulonglong,\n@@ -1590,12 +1590,12 @@ pub mod llvm {\n                                              Elements: DIArray,\n                                              RunTimeLang: c_uint,\n                                              VTableHolder: ValueRef,\n-                                             UniqueId: *c_char)\n+                                             UniqueId: *const c_char)\n                                              -> DICompositeType;\n \n         pub fn LLVMDIBuilderCreateMemberType(Builder: DIBuilderRef,\n                                              Scope: DIDescriptor,\n-                                             Name: *c_char,\n+                                             Name: *const c_char,\n                                              File: DIFile,\n                                              LineNo: c_uint,\n                                              SizeInBits: c_ulonglong,\n@@ -1615,8 +1615,8 @@ pub mod llvm {\n \n         pub fn LLVMDIBuilderCreateStaticVariable(Builder: DIBuilderRef,\n                                                  Context: DIDescriptor,\n-                                                 Name: *c_char,\n-                                                 LinkageName: *c_char,\n+                                                 Name: *const c_char,\n+                                                 LinkageName: *const c_char,\n                                                  File: DIFile,\n                                                  LineNo: c_uint,\n                                                  Ty: DIType,\n@@ -1628,7 +1628,7 @@ pub mod llvm {\n         pub fn LLVMDIBuilderCreateLocalVariable(Builder: DIBuilderRef,\n                                                 Tag: c_uint,\n                                                 Scope: DIDescriptor,\n-                                                Name: *c_char,\n+                                                Name: *const c_char,\n                                                 File: DIFile,\n                                                 LineNo: c_uint,\n                                                 Ty: DIType,\n@@ -1657,7 +1657,7 @@ pub mod llvm {\n                                                 -> DISubrange;\n \n         pub fn LLVMDIBuilderGetOrCreateArray(Builder: DIBuilderRef,\n-                                             Ptr: *DIDescriptor,\n+                                             Ptr: *const DIDescriptor,\n                                              Count: c_uint)\n                                              -> DIArray;\n \n@@ -1674,13 +1674,13 @@ pub mod llvm {\n                                                 -> ValueRef;\n \n         pub fn LLVMDIBuilderCreateEnumerator(Builder: DIBuilderRef,\n-                                             Name: *c_char,\n+                                             Name: *const c_char,\n                                              Val: c_ulonglong)\n                                              -> ValueRef;\n \n         pub fn LLVMDIBuilderCreateEnumerationType(Builder: DIBuilderRef,\n                                                   Scope: ValueRef,\n-                                                  Name: *c_char,\n+                                                  Name: *const c_char,\n                                                   File: ValueRef,\n                                                   LineNumber: c_uint,\n                                                   SizeInBits: c_ulonglong,\n@@ -1691,22 +1691,22 @@ pub mod llvm {\n \n         pub fn LLVMDIBuilderCreateUnionType(Builder: DIBuilderRef,\n                                             Scope: ValueRef,\n-                                            Name: *c_char,\n+                                            Name: *const c_char,\n                                             File: ValueRef,\n                                             LineNumber: c_uint,\n                                             SizeInBits: c_ulonglong,\n                                             AlignInBits: c_ulonglong,\n                                             Flags: c_uint,\n                                             Elements: ValueRef,\n                                             RunTimeLang: c_uint,\n-                                            UniqueId: *c_char)\n+                                            UniqueId: *const c_char)\n                                             -> ValueRef;\n \n         pub fn LLVMSetUnnamedAddr(GlobalVar: ValueRef, UnnamedAddr: Bool);\n \n         pub fn LLVMDIBuilderCreateTemplateTypeParameter(Builder: DIBuilderRef,\n                                                         Scope: ValueRef,\n-                                                        Name: *c_char,\n+                                                        Name: *const c_char,\n                                                         Ty: ValueRef,\n                                                         File: ValueRef,\n                                                         LineNo: c_uint,\n@@ -1720,25 +1720,25 @@ pub mod llvm {\n         pub fn LLVMDIBuilderCreateComplexVariable(Builder: DIBuilderRef,\n             Tag: c_uint,\n             Scope: ValueRef,\n-            Name: *c_char,\n+            Name: *const c_char,\n             File: ValueRef,\n             LineNo: c_uint,\n             Ty: ValueRef,\n-            AddrOps: *ValueRef,\n+            AddrOps: *const ValueRef,\n             AddrOpsCount: c_uint,\n             ArgNo: c_uint)\n             -> ValueRef;\n \n         pub fn LLVMDIBuilderCreateNameSpace(Builder: DIBuilderRef,\n                                             Scope: ValueRef,\n-                                            Name: *c_char,\n+                                            Name: *const c_char,\n                                             File: ValueRef,\n                                             LineNo: c_uint)\n                                             -> ValueRef;\n \n         pub fn LLVMDICompositeTypeSetTypeArray(CompositeType: ValueRef, TypeArray: ValueRef);\n-        pub fn LLVMTypeToString(Type: TypeRef) -> *c_char;\n-        pub fn LLVMValueToString(value_ref: ValueRef) -> *c_char;\n+        pub fn LLVMTypeToString(Type: TypeRef) -> *const c_char;\n+        pub fn LLVMValueToString(value_ref: ValueRef) -> *const c_char;\n \n         pub fn LLVMIsAArgument(value_ref: ValueRef) -> ValueRef;\n \n@@ -1760,10 +1760,10 @@ pub mod llvm {\n         pub fn LLVMInitializeMipsAsmPrinter();\n         pub fn LLVMInitializeMipsAsmParser();\n \n-        pub fn LLVMRustAddPass(PM: PassManagerRef, Pass: *c_char) -> bool;\n-        pub fn LLVMRustCreateTargetMachine(Triple: *c_char,\n-                                           CPU: *c_char,\n-                                           Features: *c_char,\n+        pub fn LLVMRustAddPass(PM: PassManagerRef, Pass: *const c_char) -> bool;\n+        pub fn LLVMRustCreateTargetMachine(Triple: *const c_char,\n+                                           CPU: *const c_char,\n+                                           Features: *const c_char,\n                                            Model: CodeGenModel,\n                                            Reloc: RelocMode,\n                                            Level: CodeGenOptLevel,\n@@ -1785,35 +1785,35 @@ pub mod llvm {\n         pub fn LLVMRustWriteOutputFile(T: TargetMachineRef,\n                                        PM: PassManagerRef,\n                                        M: ModuleRef,\n-                                       Output: *c_char,\n+                                       Output: *const c_char,\n                                        FileType: FileType) -> bool;\n         pub fn LLVMRustPrintModule(PM: PassManagerRef,\n                                    M: ModuleRef,\n-                                   Output: *c_char);\n-        pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: **c_char);\n+                                   Output: *const c_char);\n+        pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: *const *const c_char);\n         pub fn LLVMRustPrintPasses();\n-        pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *c_char);\n+        pub fn LLVMRustSetNormalizedTarget(M: ModuleRef, triple: *const c_char);\n         pub fn LLVMRustAddAlwaysInlinePass(P: PassManagerBuilderRef,\n                                            AddLifetimes: bool);\n         pub fn LLVMRustLinkInExternalBitcode(M: ModuleRef,\n-                                             bc: *c_char,\n+                                             bc: *const c_char,\n                                              len: size_t) -> bool;\n         pub fn LLVMRustRunRestrictionPass(M: ModuleRef,\n-                                          syms: **c_char,\n+                                          syms: *const *const c_char,\n                                           len: size_t);\n         pub fn LLVMRustMarkAllFunctionsNounwind(M: ModuleRef);\n \n-        pub fn LLVMRustOpenArchive(path: *c_char) -> ArchiveRef;\n-        pub fn LLVMRustArchiveReadSection(AR: ArchiveRef, name: *c_char,\n-                                          out_len: *mut size_t) -> *c_char;\n+        pub fn LLVMRustOpenArchive(path: *const c_char) -> ArchiveRef;\n+        pub fn LLVMRustArchiveReadSection(AR: ArchiveRef, name: *const c_char,\n+                                          out_len: *mut size_t) -> *const c_char;\n         pub fn LLVMRustDestroyArchive(AR: ArchiveRef);\n \n         pub fn LLVMRustSetDLLExportStorageClass(V: ValueRef);\n         pub fn LLVMVersionMajor() -> c_int;\n         pub fn LLVMVersionMinor() -> c_int;\n \n         pub fn LLVMRustGetSectionName(SI: SectionIteratorRef,\n-                                      data: *mut *c_char) -> c_int;\n+                                      data: *mut *const c_char) -> c_int;\n     }\n }\n "}, {"sha": "8896a068baa76b992f80bf708cd8d4ab59371f05", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -176,15 +176,15 @@ pub struct LintId {\n \n impl PartialEq for LintId {\n     fn eq(&self, other: &LintId) -> bool {\n-        (self.lint as *Lint) == (other.lint as *Lint)\n+        (self.lint as *const Lint) == (other.lint as *const Lint)\n     }\n }\n \n impl Eq for LintId { }\n \n impl<S: hash::Writer> hash::Hash<S> for LintId {\n     fn hash(&self, state: &mut S) {\n-        let ptr = self.lint as *Lint;\n+        let ptr = self.lint as *const Lint;\n         ptr.hash(state);\n     }\n }"}, {"sha": "c5789e4442a9d20e955af7b784dab36418718019", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -1308,7 +1308,7 @@ fn my_visit_expr(_e: &Expr) { }\n \n fn my_visit_item(i: &Item,\n                  ebml_w: &mut Encoder,\n-                 ecx_ptr: *int,\n+                 ecx_ptr: *const int,\n                  index: &mut Vec<entry<i64>>) {\n     let mut ebml_w = unsafe { ebml_w.unsafe_clone() };\n     // See above\n@@ -1320,7 +1320,7 @@ fn my_visit_item(i: &Item,\n \n fn my_visit_foreign_item(ni: &ForeignItem,\n                          ebml_w: &mut Encoder,\n-                         ecx_ptr:*int,\n+                         ecx_ptr:*const int,\n                          index: &mut Vec<entry<i64>>) {\n     // See above\n     let ecx: &EncodeContext = unsafe { mem::transmute(ecx_ptr) };\n@@ -1341,7 +1341,7 @@ fn my_visit_foreign_item(ni: &ForeignItem,\n \n struct EncodeVisitor<'a,'b> {\n     ebml_w_for_visit_item: &'a mut Encoder<'b>,\n-    ecx_ptr:*int,\n+    ecx_ptr:*const int,\n     index: &'a mut Vec<entry<i64>>,\n }\n \n@@ -1386,7 +1386,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n                         Public);\n \n     // See comment in `encode_side_tables_for_ii` in astencode\n-    let ecx_ptr: *int = unsafe { mem::transmute(ecx) };\n+    let ecx_ptr: *const int = unsafe { mem::transmute(ecx) };\n     visit::walk_crate(&mut EncodeVisitor {\n         index: &mut index,\n         ecx_ptr: ecx_ptr,"}, {"sha": "ccab76ca6f012d641250ceaa8f369e953a793ff1", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -545,14 +545,15 @@ fn get_metadata_section_imp(os: abi::Os, filename: &Path) -> Result<MetadataBlob\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n             let mut name_buf = ptr::null();\n             let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n-            let name = str::raw::from_buf_len(name_buf as *u8, name_len as uint);\n+            let name = str::raw::from_buf_len(name_buf as *const u8,\n+                                              name_len as uint);\n             debug!(\"get_metadata_section: name {}\", name);\n             if read_meta_section_name(os).as_slice() == name.as_slice() {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n                 let mut found =\n                     Err(format!(\"metadata not found: '{}'\", filename.display()));\n-                let cvbuf: *u8 = mem::transmute(cbuf);\n+                let cvbuf: *const u8 = mem::transmute(cbuf);\n                 let vlen = encoder::metadata_encoding_version.len();\n                 debug!(\"checking {} bytes of metadata-version stamp\",\n                        vlen);"}, {"sha": "19e7b9329b1ff218a9f25627766706e19732b98a", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -943,7 +943,7 @@ impl<'a> write_tag_and_id for Encoder<'a> {\n }\n \n struct SideTableEncodingIdVisitor<'a,'b> {\n-    ecx_ptr: *libc::c_void,\n+    ecx_ptr: *const libc::c_void,\n     new_ebml_w: &'a mut Encoder<'b>,\n }\n "}, {"sha": "77cb5f667fd000c9b7fbe57655718d4181ea901c", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -360,7 +360,8 @@ fn visit_fn(ir: &mut IrMaps,\n     let mut fn_maps = IrMaps::new(ir.tcx);\n \n     unsafe {\n-        debug!(\"creating fn_maps: {}\", transmute::<&IrMaps, *IrMaps>(&fn_maps));\n+        debug!(\"creating fn_maps: {}\",\n+               transmute::<&IrMaps, *const IrMaps>(&fn_maps));\n     }\n \n     for arg in decl.inputs.iter() {"}, {"sha": "0cd3b6e7d79184ee8dd9f1f737e278ae0d7cba6e", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -44,15 +44,15 @@ impl<T> HomogeneousTuple3<T> for (T, T, T) {\n \n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         unsafe {\n-            let ptr: *T = mem::transmute(self);\n+            let ptr: *const T = mem::transmute(self);\n             let slice = raw::Slice { data: ptr, len: 3 };\n             mem::transmute(slice)\n         }\n     }\n \n     fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         unsafe {\n-            let ptr: *T = mem::transmute(self);\n+            let ptr: *const T = mem::transmute(self);\n             let slice = raw::Slice { data: ptr, len: 3 };\n             mem::transmute(slice)\n         }"}, {"sha": "e1c02f543bf9e7c4ee2046012efeeeb5ce3c69cc", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -453,7 +453,7 @@ pub fn StructGEP(cx: &Block, pointer: ValueRef, idx: uint) -> ValueRef {\n     }\n }\n \n-pub fn GlobalString(cx: &Block, _str: *c_char) -> ValueRef {\n+pub fn GlobalString(cx: &Block, _str: *const c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n@@ -462,7 +462,7 @@ pub fn GlobalString(cx: &Block, _str: *c_char) -> ValueRef {\n     }\n }\n \n-pub fn GlobalStringPtr(cx: &Block, _str: *c_char) -> ValueRef {\n+pub fn GlobalStringPtr(cx: &Block, _str: *const c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n@@ -577,7 +577,8 @@ pub fn TruncOrBitCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     }\n }\n \n-pub fn Cast(cx: &Block, op: Opcode, val: ValueRef, dest_ty: Type, _: *u8)\n+pub fn Cast(cx: &Block, op: Opcode, val: ValueRef, dest_ty: Type,\n+            _: *const u8)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n@@ -636,7 +637,8 @@ pub fn EmptyPhi(cx: &Block, ty: Type) -> ValueRef {\n     }\n }\n \n-pub fn Phi(cx: &Block, ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef]) -> ValueRef {\n+pub fn Phi(cx: &Block, ty: Type, vals: &[ValueRef],\n+           bbs: &[BasicBlockRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.to_ref()); }\n         B(cx).phi(ty, vals, bbs)\n@@ -672,7 +674,7 @@ pub fn add_comment(cx: &Block, text: &str) {\n     B(cx).add_comment(text)\n }\n \n-pub fn InlineAsmCall(cx: &Block, asm: *c_char, cons: *c_char,\n+pub fn InlineAsmCall(cx: &Block, asm: *const c_char, cons: *const c_char,\n                      inputs: &[ValueRef], output: Type,\n                      volatile: bool, alignstack: bool,\n                      dia: AsmDialect) -> ValueRef {"}, {"sha": "c64f4cfa8779887d8d341457866027e896379573", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -31,9 +31,9 @@ pub struct Builder<'a> {\n \n // This is a really awful way to get a zero-length c-string, but better (and a\n // lot more efficient) than doing str::as_c_str(\"\", ...) every time.\n-pub fn noname() -> *c_char {\n+pub fn noname() -> *const c_char {\n     static cnull: c_char = 0;\n-    &cnull as *c_char\n+    &cnull as *const c_char\n }\n \n impl<'a> Builder<'a> {\n@@ -564,14 +564,14 @@ impl<'a> Builder<'a> {\n         }\n     }\n \n-    pub fn global_string(&self, _str: *c_char) -> ValueRef {\n+    pub fn global_string(&self, _str: *const c_char) -> ValueRef {\n         self.count_insn(\"globalstring\");\n         unsafe {\n             llvm::LLVMBuildGlobalString(self.llbuilder, _str, noname())\n         }\n     }\n \n-    pub fn global_string_ptr(&self, _str: *c_char) -> ValueRef {\n+    pub fn global_string_ptr(&self, _str: *const c_char) -> ValueRef {\n         self.count_insn(\"globalstringptr\");\n         unsafe {\n             llvm::LLVMBuildGlobalStringPtr(self.llbuilder, _str, noname())\n@@ -774,7 +774,7 @@ impl<'a> Builder<'a> {\n         }\n     }\n \n-    pub fn inline_asm_call(&self, asm: *c_char, cons: *c_char,\n+    pub fn inline_asm_call(&self, asm: *const c_char, cons: *const c_char,\n                          inputs: &[ValueRef], output: Type,\n                          volatile: bool, alignstack: bool,\n                          dia: AsmDialect) -> ValueRef {"}, {"sha": "b1577a6abfe1452f461a3a59c20ebb388424ad2a", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -471,7 +471,7 @@ impl<'a> Block<'a> {\n     }\n \n     pub fn to_str(&self) -> String {\n-        let blk: *Block = self;\n+        let blk: *const Block = self;\n         format!(\"[block {}]\", blk)\n     }\n }\n@@ -568,7 +568,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n         }\n \n         let sc = llvm::LLVMConstStringInContext(cx.llcx,\n-                                                s.get().as_ptr() as *c_char,\n+                                                s.get().as_ptr() as *const c_char,\n                                                 s.get().len() as c_uint,\n                                                 !null_terminated as Bool);\n \n@@ -636,7 +636,7 @@ pub fn C_array(ty: Type, elts: &[ValueRef]) -> ValueRef {\n \n pub fn C_bytes(ccx: &CrateContext, bytes: &[u8]) -> ValueRef {\n     unsafe {\n-        let ptr = bytes.as_ptr() as *c_char;\n+        let ptr = bytes.as_ptr() as *const c_char;\n         return llvm::LLVMConstStringInContext(ccx.llcx, ptr, bytes.len() as c_uint, True);\n     }\n }"}, {"sha": "6387ec791bab93d6b5f4c5c9698c718ad2db55b3", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -221,8 +221,8 @@ impl CrateContext {\n                     llvm_insns: RefCell::new(HashMap::new()),\n                     fn_stats: RefCell::new(Vec::new()),\n                 },\n-                int_type: Type::from_ref(ptr::null()),\n-                opaque_vec_type: Type::from_ref(ptr::null()),\n+                int_type: Type::from_ref(ptr::mut_null()),\n+                opaque_vec_type: Type::from_ref(ptr::mut_null()),\n                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n                 uses_gc: false,\n                 dbg_cx: dbg_cx,"}, {"sha": "65f272072c0976611288330da63503de7979394c", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -805,7 +805,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                                                         type_metadata,\n                                                         is_local_to_unit,\n                                                         global,\n-                                                        ptr::null());\n+                                                        ptr::mut_null());\n             }\n         })\n     });\n@@ -980,7 +980,7 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n             }\n         };\n \n-        if unsafe { llvm::LLVMIsAAllocaInst(llarg.val) } == ptr::null() {\n+        if unsafe { llvm::LLVMIsAAllocaInst(llarg.val) } == ptr::mut_null() {\n             cx.sess().span_bug(span, \"debuginfo::create_argument_metadata() - \\\n                                     Referenced variable location is not an alloca!\");\n         }\n@@ -1221,7 +1221,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                     cx.sess().opts.optimize != config::No,\n                     llfn,\n                     template_parameters,\n-                    ptr::null())\n+                    ptr::mut_null())\n             }\n         })\n     });\n@@ -1257,7 +1257,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         // Return type -- llvm::DIBuilder wants this at index 0\n         match fn_decl.output.node {\n             ast::TyNil => {\n-                signature.push(ptr::null());\n+                signature.push(ptr::mut_null());\n             }\n             _ => {\n                 assert_type_for_node_id(cx, fn_ast_id, error_span);\n@@ -1328,7 +1328,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                             file_metadata,\n                             name,\n                             actual_self_type_metadata,\n-                            ptr::null(),\n+                            ptr::mut_null(),\n                             0,\n                             0)\n                     }\n@@ -1361,7 +1361,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                             file_metadata,\n                             name,\n                             actual_type_metadata,\n-                            ptr::null(),\n+                            ptr::mut_null(),\n                             0,\n                             0)\n                     }\n@@ -2374,7 +2374,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                 bytes_to_bits(enum_type_size),\n                 bytes_to_bits(enum_type_align),\n                 0, // Flags\n-                ptr::null(),\n+                ptr::mut_null(),\n                 0, // RuntimeLang\n                 unique_type_id_str)\n             }\n@@ -2554,10 +2554,10 @@ fn create_struct_stub(cx: &CrateContext,\n                     bytes_to_bits(struct_size),\n                     bytes_to_bits(struct_align),\n                     0,\n-                    ptr::null(),\n+                    ptr::mut_null(),\n                     empty_array,\n                     0,\n-                    ptr::null(),\n+                    ptr::mut_null(),\n                     unique_type_id)\n             })\n         })\n@@ -2855,7 +2855,7 @@ fn subroutine_type_metadata(cx: &CrateContext,\n \n     // return type\n     signature_metadata.push(match ty::get(signature.output).sty {\n-        ty::ty_nil => ptr::null(),\n+        ty::ty_nil => ptr::mut_null(),\n         _ => type_metadata(cx, signature.output, span)\n     });\n \n@@ -3153,7 +3153,8 @@ fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n         KnownLocation { scope, line, .. } => {\n             let col = 0u; // Always set the column to zero like Clang and GCC\n             debug!(\"setting debug location to {} {}\", line, col);\n-            let elements = [C_i32(cx, line as i32), C_i32(cx, col as i32), scope, ptr::null()];\n+            let elements = [C_i32(cx, line as i32), C_i32(cx, col as i32),\n+                            scope, ptr::mut_null()];\n             unsafe {\n                 metadata_node = llvm::LLVMMDNodeInContext(debug_context(cx).llcontext,\n                                                           elements.as_ptr(),\n@@ -3162,7 +3163,7 @@ fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n         }\n         UnknownLocation => {\n             debug!(\"clearing debug location \");\n-            metadata_node = ptr::null();\n+            metadata_node = ptr::mut_null();\n         }\n     };\n \n@@ -3771,7 +3772,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n                     // create and insert\n                     let parent_scope = match parent_node {\n                         Some(ref node) => node.scope,\n-                        None => ptr::null()\n+                        None => ptr::mut_null()\n                     };\n                     let namespace_name = token::get_name(name);\n                     let scope = namespace_name.get().with_c_str(|namespace_name| {\n@@ -3781,7 +3782,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n                                 parent_scope,\n                                 namespace_name,\n                                 // cannot reconstruct file ...\n-                                ptr::null(),\n+                                ptr::mut_null(),\n                                 // ... or line information, but that's not so important.\n                                 0)\n                         }"}, {"sha": "8d84d089c01b2adff75514cf313a74df9196d7b6", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -158,7 +158,7 @@ pub struct creader_cache_key {\n pub type creader_cache = RefCell<HashMap<creader_cache_key, t>>;\n \n pub struct intern_key {\n-    sty: *sty,\n+    sty: *const sty,\n }\n \n // NB: Do not replace this with #[deriving(PartialEq)]. The automatically-derived\n@@ -409,7 +409,7 @@ enum t_opaque {}\n \n #[allow(raw_pointer_deriving)]\n #[deriving(Clone, PartialEq, Eq, Hash)]\n-pub struct t { inner: *t_opaque }\n+pub struct t { inner: *const t_opaque }\n \n impl fmt::Show for t {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -1216,7 +1216,7 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n         flags: flags,\n     };\n \n-    let sty_ptr = &t.sty as *sty;\n+    let sty_ptr = &t.sty as *const sty;\n \n     let key = intern_key {\n         sty: sty_ptr,\n@@ -1227,7 +1227,7 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n     cx.next_id.set(cx.next_id.get() + 1);\n \n     unsafe {\n-        mem::transmute::<*sty, t>(sty_ptr)\n+        mem::transmute::<*const sty, t>(sty_ptr)\n     }\n }\n "}, {"sha": "bb20c3ce0b4aabbe646e69a4409c74b2cf71a58f", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -1262,7 +1262,7 @@ impl<'a> RegionScope for infer::InferCtxt<'a> {\n \n impl<'a> FnCtxt<'a> {\n     pub fn tag(&self) -> String {\n-        format!(\"{}\", self as *FnCtxt)\n+        format!(\"{}\", self as *const FnCtxt)\n     }\n \n     pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> ty::t {"}, {"sha": "79d0690653faf9d3a6a99d501bea05f3fb947b72", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -129,7 +129,7 @@ impl<'a> PluginLoader<'a> {\n             let registrar =\n                 match lib.symbol(symbol.as_slice()) {\n                     Ok(registrar) => {\n-                        mem::transmute::<*u8,PluginRegistrarFun>(registrar)\n+                        mem::transmute::<*mut u8,PluginRegistrarFun>(registrar)\n                     }\n                     // again fatal if we can't register macros\n                     Err(err) => self.sess.span_fatal(vi.span, err.as_slice())"}, {"sha": "fa353652fe1ec21ae311ae6ea866a417df431ade", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -355,7 +355,12 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> String {\n       ty_float(t) => ast_util::float_ty_to_str(t).to_string(),\n       ty_box(typ) => format!(\"Gc<{}>\", ty_to_str(cx, typ)),\n       ty_uniq(typ) => format!(\"Box<{}>\", ty_to_str(cx, typ)),\n-      ty_ptr(ref tm) => format!(\"*{}\", mt_to_str(cx, tm)),\n+      ty_ptr(ref tm) => {\n+          format!(\"*{} {}\", match tm.mutbl {\n+              ast::MutMutable => \"mut\",\n+              ast::MutImmutable => \"const\",\n+          }, ty_to_str(cx, tm.ty))\n+      }\n       ty_rptr(r, ref tm) => {\n           let mut buf = region_ptr_to_str(cx, r);\n           buf.push_str(mt_to_str(cx, tm).as_slice());"}, {"sha": "bfd3deb0f2dcd627fd4b6b3db25ebc2bd78da9ed", "filename": "src/librustc/util/sha2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -34,7 +34,7 @@ fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n     assert!(dst.len() * 4 == input.len());\n     unsafe {\n         let mut x = dst.unsafe_mut_ref(0) as *mut _ as *mut u32;\n-        let mut y = input.unsafe_ref(0) as *_ as *u32;\n+        let mut y = input.unsafe_ref(0) as *const _ as *const u32;\n         for _ in range(0, dst.len()) {\n             *x = to_be32(*y);\n             x = x.offset(1);"}, {"sha": "cb2ebd15b3970ffc21733dc3672571bd1d479ba1", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -104,7 +104,7 @@ mod imp {\n                 l_sysid: 0,\n             };\n             let ret = unsafe {\n-                libc::fcntl(fd, os::F_SETLKW, &flock as *os::flock)\n+                libc::fcntl(fd, os::F_SETLKW, &flock as *const os::flock)\n             };\n             if ret == -1 {\n                 unsafe { libc::close(fd); }\n@@ -125,7 +125,7 @@ mod imp {\n                 l_sysid: 0,\n             };\n             unsafe {\n-                libc::fcntl(self.fd, os::F_SETLK, &flock as *os::flock);\n+                libc::fcntl(self.fd, os::F_SETLK, &flock as *const os::flock);\n                 libc::close(self.fd);\n             }\n         }"}, {"sha": "949936603e2b7566f067b2da0cf07705edd34c18", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -66,13 +66,13 @@ type hoedown_document = libc::c_void;  // this is opaque to us\n \n struct hoedown_renderer {\n     opaque: *mut hoedown_html_renderer_state,\n-    blockcode: Option<extern \"C\" fn(*mut hoedown_buffer, *hoedown_buffer,\n-                                    *hoedown_buffer, *mut libc::c_void)>,\n-    blockquote: Option<extern \"C\" fn(*mut hoedown_buffer, *hoedown_buffer,\n+    blockcode: Option<extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n+                                    *const hoedown_buffer, *mut libc::c_void)>,\n+    blockquote: Option<extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n                                      *mut libc::c_void)>,\n-    blockhtml: Option<extern \"C\" fn(*mut hoedown_buffer, *hoedown_buffer,\n+    blockhtml: Option<extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n                                     *mut libc::c_void)>,\n-    header: Option<extern \"C\" fn(*mut hoedown_buffer, *hoedown_buffer,\n+    header: Option<extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n                                  libc::c_int, *mut libc::c_void)>,\n     other: [libc::size_t, ..28],\n }\n@@ -81,7 +81,8 @@ struct hoedown_html_renderer_state {\n     opaque: *mut libc::c_void,\n     toc_data: html_toc_data,\n     flags: libc::c_uint,\n-    link_attributes: Option<extern \"C\" fn(*mut hoedown_buffer, *hoedown_buffer,\n+    link_attributes: Option<extern \"C\" fn(*mut hoedown_buffer,\n+                                          *const hoedown_buffer,\n                                           *mut libc::c_void)>,\n }\n \n@@ -93,13 +94,13 @@ struct html_toc_data {\n }\n \n struct MyOpaque {\n-    dfltblk: extern \"C\" fn(*mut hoedown_buffer, *hoedown_buffer,\n-                           *hoedown_buffer, *mut libc::c_void),\n+    dfltblk: extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n+                           *const hoedown_buffer, *mut libc::c_void),\n     toc_builder: Option<TocBuilder>,\n }\n \n struct hoedown_buffer {\n-    data: *u8,\n+    data: *const u8,\n     size: libc::size_t,\n     asize: libc::size_t,\n     unit: libc::size_t,\n@@ -118,12 +119,12 @@ extern {\n                             max_nesting: libc::size_t) -> *mut hoedown_document;\n     fn hoedown_document_render(doc: *mut hoedown_document,\n                                ob: *mut hoedown_buffer,\n-                               document: *u8,\n+                               document: *const u8,\n                                doc_size: libc::size_t);\n     fn hoedown_document_free(md: *mut hoedown_document);\n \n     fn hoedown_buffer_new(unit: libc::size_t) -> *mut hoedown_buffer;\n-    fn hoedown_buffer_puts(b: *mut hoedown_buffer, c: *libc::c_char);\n+    fn hoedown_buffer_puts(b: *mut hoedown_buffer, c: *const libc::c_char);\n     fn hoedown_buffer_free(b: *mut hoedown_buffer);\n \n }\n@@ -147,13 +148,13 @@ local_data_key!(test_idx: Cell<uint>)\n local_data_key!(pub playground_krate: Option<String>)\n \n pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n-    extern fn block(ob: *mut hoedown_buffer, text: *hoedown_buffer,\n-                    lang: *hoedown_buffer, opaque: *mut libc::c_void) {\n+    extern fn block(ob: *mut hoedown_buffer, text: *const hoedown_buffer,\n+                    lang: *const hoedown_buffer, opaque: *mut libc::c_void) {\n         unsafe {\n             if text.is_null() { return }\n \n             let opaque = opaque as *mut hoedown_html_renderer_state;\n-            let my_opaque: &MyOpaque = &*((*opaque).opaque as *MyOpaque);\n+            let my_opaque: &MyOpaque = &*((*opaque).opaque as *const MyOpaque);\n             slice::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n                 let origtext = str::from_utf8(text).unwrap();\n                 debug!(\"docblock: ==============\\n{}\\n=======\", text);\n@@ -213,7 +214,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n         }\n     }\n \n-    extern fn header(ob: *mut hoedown_buffer, text: *hoedown_buffer,\n+    extern fn header(ob: *mut hoedown_buffer, text: *const hoedown_buffer,\n                      level: libc::c_int, opaque: *mut libc::c_void) {\n         // hoedown does this, we may as well too\n         \"\\n\".with_c_str(|p| unsafe { hoedown_buffer_puts(ob, p) });\n@@ -304,8 +305,10 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n }\n \n pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n-    extern fn block(_ob: *mut hoedown_buffer, text: *hoedown_buffer,\n-                    lang: *hoedown_buffer, opaque: *mut libc::c_void) {\n+    extern fn block(_ob: *mut hoedown_buffer,\n+                    text: *const hoedown_buffer,\n+                    lang: *const hoedown_buffer,\n+                    opaque: *mut libc::c_void) {\n         unsafe {\n             if text.is_null() { return }\n             let block_info = if lang.is_null() {\n@@ -333,7 +336,8 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n         }\n     }\n \n-    extern fn header(_ob: *mut hoedown_buffer, text: *hoedown_buffer,\n+    extern fn header(_ob: *mut hoedown_buffer,\n+                     text: *const hoedown_buffer,\n                      level: libc::c_int, opaque: *mut libc::c_void) {\n         unsafe {\n             let opaque = opaque as *mut hoedown_html_renderer_state;"}, {"sha": "9ac366655636cca447ce9c4a00895cb99e06521b", "filename": "src/librustdoc/plugins.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -48,7 +48,7 @@ impl PluginManager {\n         let lib = lib_result.unwrap();\n         unsafe {\n             let plugin = lib.symbol(\"rustdoc_plugin_entrypoint\").unwrap();\n-            self.callbacks.push(mem::transmute::<*u8,PluginCallback>(plugin));\n+            self.callbacks.push(mem::transmute::<*mut u8,PluginCallback>(plugin));\n         }\n         self.dylibs.push(lib);\n     }"}, {"sha": "3c0a4aae251dbd90506a5af37a829274eec771e1", "filename": "src/librustrt/args.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fargs.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -23,7 +23,7 @@ use core::prelude::*;\n use collections::vec::Vec;\n \n /// One-time global initialization.\n-pub unsafe fn init(argc: int, argv: **u8) { imp::init(argc, argv) }\n+pub unsafe fn init(argc: int, argv: *const *const u8) { imp::init(argc, argv) }\n \n /// One-time global cleanup.\n pub unsafe fn cleanup() { imp::cleanup() }\n@@ -55,7 +55,7 @@ mod imp {\n     static mut global_args_ptr: uint = 0;\n     static mut lock: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n-    pub unsafe fn init(argc: int, argv: **u8) {\n+    pub unsafe fn init(argc: int, argv: *const *const u8) {\n         let args = load_argc_and_argv(argc, argv);\n         put(args);\n     }\n@@ -99,7 +99,7 @@ mod imp {\n         unsafe { mem::transmute(&global_args_ptr) }\n     }\n \n-    unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> Vec<Vec<u8>> {\n+    unsafe fn load_argc_and_argv(argc: int, argv: *const *const u8) -> Vec<Vec<u8>> {\n         Vec::from_fn(argc as uint, |i| {\n             let base = *argv.offset(i as int);\n             let mut len = 0;\n@@ -151,7 +151,7 @@ mod imp {\n     use core::prelude::*;\n     use collections::vec::Vec;\n \n-    pub unsafe fn init(_argc: int, _argv: **u8) {\n+    pub unsafe fn init(_argc: int, _argv: *const *const u8) {\n     }\n \n     pub fn cleanup() {"}, {"sha": "dcba7fb7cb6a6255d51b295c6c9f2d6d3e2d2d17", "filename": "src/librustrt/at_exit_imp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fat_exit_imp.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -43,7 +43,7 @@ pub fn push(f: proc():Send) {\n         rtassert!(!RUNNING.load(atomics::SeqCst));\n         let queue = QUEUE.load(atomics::SeqCst);\n         rtassert!(queue != 0);\n-        (*(queue as *Queue)).lock().push(f);\n+        (*(queue as *const Queue)).lock().push(f);\n     }\n }\n "}, {"sha": "26216f655304e734757d588d8c2d9ef85a35f0a6", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -42,7 +42,7 @@ An example of creating and using a C string would be:\n extern crate libc;\n \n extern {\n-    fn puts(s: *libc::c_char);\n+    fn puts(s: *const libc::c_char);\n }\n \n fn main() {\n@@ -82,7 +82,7 @@ use libc;\n /// This structure wraps a `*libc::c_char`, and will automatically free the\n /// memory it is pointing to when it goes out of scope.\n pub struct CString {\n-    buf: *libc::c_char,\n+    buf: *const libc::c_char,\n     owns_buffer_: bool,\n }\n \n@@ -97,7 +97,7 @@ impl Clone for CString {\n             let len = self.len() + 1;\n             let buf = unsafe { malloc_raw(len) } as *mut libc::c_char;\n             unsafe { ptr::copy_nonoverlapping_memory(buf, self.buf, len); }\n-            CString { buf: buf as *libc::c_char, owns_buffer_: true }\n+            CString { buf: buf as *const libc::c_char, owns_buffer_: true }\n         }\n     }\n }\n@@ -118,7 +118,7 @@ impl PartialEq for CString {\n \n impl CString {\n     /// Create a C String from a pointer.\n-    pub unsafe fn new(buf: *libc::c_char, owns_buffer: bool) -> CString {\n+    pub unsafe fn new(buf: *const libc::c_char, owns_buffer: bool) -> CString {\n         CString { buf: buf, owns_buffer_: owns_buffer }\n     }\n \n@@ -127,7 +127,7 @@ impl CString {\n     /// The original object is destructed after this method is called, and if\n     /// the underlying pointer was previously allocated, care must be taken to\n     /// ensure that it is deallocated properly.\n-    pub unsafe fn unwrap(self) -> *libc::c_char {\n+    pub unsafe fn unwrap(self) -> *const libc::c_char {\n         let mut c_str = self;\n         c_str.owns_buffer_ = false;\n         c_str.buf\n@@ -138,7 +138,7 @@ impl CString {\n     /// # Failure\n     ///\n     /// Fails if the CString is null.\n-    pub fn with_ref<T>(&self, f: |*libc::c_char| -> T) -> T {\n+    pub fn with_ref<T>(&self, f: |*const libc::c_char| -> T) -> T {\n         if self.buf.is_null() { fail!(\"CString is null!\"); }\n         f(self.buf)\n     }\n@@ -284,13 +284,13 @@ pub trait ToCStr {\n     ///\n     /// Fails the task if the receiver has an interior null.\n     #[inline]\n-    fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n+    fn with_c_str<T>(&self, f: |*const libc::c_char| -> T) -> T {\n         self.to_c_str().with_ref(f)\n     }\n \n     /// Unsafe variant of `with_c_str()` that doesn't check for nulls.\n     #[inline]\n-    unsafe fn with_c_str_unchecked<T>(&self, f: |*libc::c_char| -> T) -> T {\n+    unsafe fn with_c_str_unchecked<T>(&self, f: |*const libc::c_char| -> T) -> T {\n         self.to_c_str_unchecked().with_ref(f)\n     }\n }\n@@ -315,12 +315,12 @@ impl<'a> ToCStr for &'a str {\n     }\n \n     #[inline]\n-    fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n+    fn with_c_str<T>(&self, f: |*const libc::c_char| -> T) -> T {\n         self.as_bytes().with_c_str(f)\n     }\n \n     #[inline]\n-    unsafe fn with_c_str_unchecked<T>(&self, f: |*libc::c_char| -> T) -> T {\n+    unsafe fn with_c_str_unchecked<T>(&self, f: |*const libc::c_char| -> T) -> T {\n         self.as_bytes().with_c_str_unchecked(f)\n     }\n }\n@@ -337,12 +337,12 @@ impl ToCStr for String {\n     }\n \n     #[inline]\n-    fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n+    fn with_c_str<T>(&self, f: |*const libc::c_char| -> T) -> T {\n         self.as_bytes().with_c_str(f)\n     }\n \n     #[inline]\n-    unsafe fn with_c_str_unchecked<T>(&self, f: |*libc::c_char| -> T) -> T {\n+    unsafe fn with_c_str_unchecked<T>(&self, f: |*const libc::c_char| -> T) -> T {\n         self.as_bytes().with_c_str_unchecked(f)\n     }\n }\n@@ -364,20 +364,21 @@ impl<'a> ToCStr for &'a [u8] {\n         ptr::copy_memory(buf, self.as_ptr(), self_len);\n         *buf.offset(self_len as int) = 0;\n \n-        CString::new(buf as *libc::c_char, true)\n+        CString::new(buf as *const libc::c_char, true)\n     }\n \n-    fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n+    fn with_c_str<T>(&self, f: |*const libc::c_char| -> T) -> T {\n         unsafe { with_c_str(*self, true, f) }\n     }\n \n-    unsafe fn with_c_str_unchecked<T>(&self, f: |*libc::c_char| -> T) -> T {\n+    unsafe fn with_c_str_unchecked<T>(&self, f: |*const libc::c_char| -> T) -> T {\n         with_c_str(*self, false, f)\n     }\n }\n \n // Unsafe function that handles possibly copying the &[u8] into a stack array.\n-unsafe fn with_c_str<T>(v: &[u8], checked: bool, f: |*libc::c_char| -> T) -> T {\n+unsafe fn with_c_str<T>(v: &[u8], checked: bool,\n+                        f: |*const libc::c_char| -> T) -> T {\n     if v.len() < BUF_LEN {\n         let mut buf: [u8, .. BUF_LEN] = mem::uninitialized();\n         slice::bytes::copy_memory(buf, v);\n@@ -388,7 +389,7 @@ unsafe fn with_c_str<T>(v: &[u8], checked: bool, f: |*libc::c_char| -> T) -> T {\n             check_for_null(v, buf as *mut libc::c_char);\n         }\n \n-        f(buf as *libc::c_char)\n+        f(buf as *const libc::c_char)\n     } else if checked {\n         v.to_c_str().with_ref(f)\n     } else {\n@@ -410,7 +411,7 @@ fn check_for_null(v: &[u8], buf: *mut libc::c_char) {\n ///\n /// Use with the `std::iter` module.\n pub struct CChars<'a> {\n-    ptr: *libc::c_char,\n+    ptr: *const libc::c_char,\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n@@ -434,7 +435,7 @@ impl<'a> Iterator<libc::c_char> for CChars<'a> {\n ///\n /// The specified closure is invoked with each string that\n /// is found, and the number of strings found is returned.\n-pub unsafe fn from_c_multistring(buf: *libc::c_char,\n+pub unsafe fn from_c_multistring(buf: *const libc::c_char,\n                                  count: Option<uint>,\n                                  f: |&CString|) -> uint {\n \n@@ -445,8 +446,8 @@ pub unsafe fn from_c_multistring(buf: *libc::c_char,\n         None => (false, 0)\n     };\n     while ((limited_count && ctr < limit) || !limited_count)\n-          && *(curr_ptr as *libc::c_char) != 0 as libc::c_char {\n-        let cstr = CString::new(curr_ptr as *libc::c_char, false);\n+          && *(curr_ptr as *const libc::c_char) != 0 as libc::c_char {\n+        let cstr = CString::new(curr_ptr as *const libc::c_char, false);\n         f(&cstr);\n         curr_ptr += cstr.len() + 1;\n         ctr += 1;\n@@ -470,7 +471,7 @@ mod tests {\n             let ptr = input.as_ptr();\n             let expected = [\"zero\", \"one\"];\n             let mut it = expected.iter();\n-            let result = from_c_multistring(ptr as *libc::c_char, None, |c| {\n+            let result = from_c_multistring(ptr as *const libc::c_char, None, |c| {\n                 let cbytes = c.as_bytes_no_nul();\n                 assert_eq!(cbytes, it.next().unwrap().as_bytes());\n             });\n@@ -707,7 +708,7 @@ mod bench {\n     use std::prelude::*;\n \n     #[inline]\n-    fn check(s: &str, c_str: *libc::c_char) {\n+    fn check(s: &str, c_str: *const libc::c_char) {\n         let s_buf = s.as_ptr();\n         for i in range(0, s.len()) {\n             unsafe {"}, {"sha": "a040829ebe33ddf5ca7015c2a4f02e3c3ccb8585", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -18,7 +18,6 @@\n \n #![feature(macro_rules, phase, globs, thread_local, managed_boxes, asm)]\n #![feature(linkage, lang_items, unsafe_destructor)]\n-#![allow(unknown_features)] // NOTE: remove after stage0 snapshot\n #![no_std]\n #![experimental]\n \n@@ -105,7 +104,7 @@ pub static DEFAULT_ERROR_CODE: int = 101;\n /// Initializes global state, including frobbing\n /// the crate's logging flags, registering GC\n /// metadata, and storing the process arguments.\n-pub fn init(argc: int, argv: **u8) {\n+pub fn init(argc: int, argv: *const *const u8) {\n     // FIXME: Derefing these pointers is not safe.\n     // Need to propagate the unsafety to `start`.\n     unsafe {"}, {"sha": "6811a62c74f523f7cda3ed8943f2c20accc833e6", "filename": "src/librustrt/libunwind.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flibunwind.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -82,7 +82,7 @@ pub enum _Unwind_Context {}\n \n pub type _Unwind_Exception_Cleanup_Fn =\n         extern \"C\" fn(unwind_code: _Unwind_Reason_Code,\n-                      exception: *_Unwind_Exception);\n+                      exception: *mut _Unwind_Exception);\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"freebsd\")]\n@@ -99,22 +99,22 @@ extern \"C\" {\n     // iOS on armv7 uses SjLj exceptions and requires to link\n     // agains corresponding routine (..._SjLj_...)\n     #[cfg(not(target_os = \"ios\", target_arch = \"arm\"))]\n-    pub fn _Unwind_RaiseException(exception: *_Unwind_Exception)\n+    pub fn _Unwind_RaiseException(exception: *mut _Unwind_Exception)\n                                   -> _Unwind_Reason_Code;\n \n     #[cfg(target_os = \"ios\", target_arch = \"arm\")]\n-    fn _Unwind_SjLj_RaiseException(e: *_Unwind_Exception)\n+    fn _Unwind_SjLj_RaiseException(e: *mut _Unwind_Exception)\n                                    -> _Unwind_Reason_Code;\n \n-    pub fn _Unwind_DeleteException(exception: *_Unwind_Exception);\n+    pub fn _Unwind_DeleteException(exception: *mut _Unwind_Exception);\n }\n \n // ... and now we just providing access to SjLj counterspart\n // through a standard name to hide those details from others\n // (see also comment above regarding _Unwind_RaiseException)\n #[cfg(target_os = \"ios\", target_arch = \"arm\")]\n #[inline(always)]\n-pub unsafe fn _Unwind_RaiseException(exc: *_Unwind_Exception)\n+pub unsafe fn _Unwind_RaiseException(exc: *mut _Unwind_Exception)\n                                      -> _Unwind_Reason_Code {\n     _Unwind_SjLj_RaiseException(exc)\n }"}, {"sha": "d4c87e9fc05c14e458ff110237360935b2baa28b", "filename": "src/librustrt/local_data.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -90,7 +90,7 @@ impl<T: 'static> LocalData for T {}\n // n.b. If TLS is used heavily in future, this could be made more efficient with\n //      a proper map.\n #[doc(hidden)]\n-pub type Map = Vec<Option<(*u8, TLSValue, uint)>>;\n+pub type Map = Vec<Option<(*const u8, TLSValue, uint)>>;\n type TLSValue = Box<LocalData + Send>;\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n@@ -116,8 +116,8 @@ unsafe fn get_local_map() -> Option<&mut Map> {\n     }\n }\n \n-fn key_to_key_value<T: 'static>(key: Key<T>) -> *u8 {\n-    key as *KeyValue<T> as *u8\n+fn key_to_key_value<T: 'static>(key: Key<T>) -> *const u8 {\n+    key as *const KeyValue<T> as *const u8\n }\n \n /// An RAII immutable reference to a task-local value.\n@@ -236,7 +236,8 @@ impl<T: 'static> KeyValue<T> {\n             // pointer part of the trait, (as ~T), and then use\n             // compiler coercions to achieve a '&' pointer.\n             let ptr = unsafe {\n-                let data = data as *Box<LocalData + Send> as *raw::TraitObject;\n+                let data = data as *const Box<LocalData + Send>\n+                                as *const raw::TraitObject;\n                 &mut *((*data).data as *mut T)\n             };\n             Ref { _ptr: ptr, _index: pos, _nosend: marker::NoSend, _key: self }"}, {"sha": "aca9e46d2f4a0aa43831f6a344a83cf8c32cb746", "filename": "src/librustrt/local_heap.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_heap.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -225,8 +225,8 @@ impl MemoryRegion {\n     #[inline]\n     fn malloc(&mut self, size: uint) -> *mut Box {\n         let total_size = size + AllocHeader::size();\n-        let alloc: *AllocHeader = unsafe {\n-            libc_heap::malloc_raw(total_size) as *AllocHeader\n+        let alloc: *mut AllocHeader = unsafe {\n+            libc_heap::malloc_raw(total_size) as *mut AllocHeader\n         };\n \n         let alloc: &mut AllocHeader = unsafe { mem::transmute(alloc) };\n@@ -244,14 +244,14 @@ impl MemoryRegion {\n         unsafe { (*orig_alloc).assert_sane(); }\n \n         let total_size = size + AllocHeader::size();\n-        let alloc: *AllocHeader = unsafe {\n-            libc_heap::realloc_raw(orig_alloc as *mut u8, total_size) as *AllocHeader\n+        let alloc: *mut AllocHeader = unsafe {\n+            libc_heap::realloc_raw(orig_alloc as *mut u8, total_size) as *mut AllocHeader\n         };\n \n         let alloc: &mut AllocHeader = unsafe { mem::transmute(alloc) };\n         alloc.assert_sane();\n         alloc.update_size(size as u32);\n-        self.update(alloc, orig_alloc as *AllocHeader);\n+        self.update(alloc, orig_alloc as *mut AllocHeader);\n         return alloc.as_box();\n     }\n \n@@ -273,7 +273,7 @@ impl MemoryRegion {\n     #[inline]\n     fn release(&mut self, _alloc: &AllocHeader) {}\n     #[inline]\n-    fn update(&mut self, _alloc: &mut AllocHeader, _orig: *AllocHeader) {}\n+    fn update(&mut self, _alloc: &mut AllocHeader, _orig: *mut AllocHeader) {}\n }\n \n impl Drop for MemoryRegion {\n@@ -287,17 +287,19 @@ impl Drop for MemoryRegion {\n #[cfg(not(test))]\n #[lang=\"malloc\"]\n #[inline]\n-pub unsafe fn local_malloc_(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 {\n+pub unsafe fn local_malloc_(drop_glue: fn(*mut u8), size: uint,\n+                            align: uint) -> *mut u8 {\n     local_malloc(drop_glue, size, align)\n }\n \n #[inline]\n-pub unsafe fn local_malloc(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 {\n+pub unsafe fn local_malloc(drop_glue: fn(*mut u8), size: uint,\n+                           align: uint) -> *mut u8 {\n     // FIXME: Unsafe borrow for speed. Lame.\n     let task: Option<*mut Task> = Local::try_unsafe_borrow();\n     match task {\n         Some(task) => {\n-            (*task).heap.alloc(drop_glue, size, align) as *u8\n+            (*task).heap.alloc(drop_glue, size, align) as *mut u8\n         }\n         None => rtabort!(\"local malloc outside of task\")\n     }\n@@ -306,15 +308,15 @@ pub unsafe fn local_malloc(drop_glue: fn(*mut u8), size: uint, align: uint) -> *\n #[cfg(not(test))]\n #[lang=\"free\"]\n #[inline]\n-pub unsafe fn local_free_(ptr: *u8) {\n+pub unsafe fn local_free_(ptr: *mut u8) {\n     local_free(ptr)\n }\n \n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n // inside a landing pad may corrupt the state of the exception handler. If a\n // problem occurs, call exit instead.\n #[inline]\n-pub unsafe fn local_free(ptr: *u8) {\n+pub unsafe fn local_free(ptr: *mut u8) {\n     // FIXME: Unsafe borrow for speed. Lame.\n     let task_ptr: Option<*mut Task> = Local::try_unsafe_borrow();\n     match task_ptr {"}, {"sha": "a0140129c0b406d666f0c7c350461ff6429f2543", "filename": "src/librustrt/local_ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_ptr.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -35,7 +35,7 @@ pub use self::compiled::{init, cleanup, put, take, try_take, unsafe_take, exists\n /// Encapsulates a borrowed value. When this value goes out of scope, the\n /// pointer is returned.\n pub struct Borrowed<T> {\n-    val: *(),\n+    val: *const (),\n }\n \n #[unsafe_destructor]\n@@ -54,7 +54,7 @@ impl<T> Drop for Borrowed<T> {\n \n impl<T> Deref<T> for Borrowed<T> {\n     fn deref<'a>(&'a self) -> &'a T {\n-        unsafe { &*(self.val as *T) }\n+        unsafe { &*(self.val as *const T) }\n     }\n }\n \n@@ -72,7 +72,7 @@ impl<T> DerefMut<T> for Borrowed<T> {\n /// Does not validate the pointer type.\n #[inline]\n pub unsafe fn borrow<T>() -> Borrowed<T> {\n-    let val: *() = mem::transmute(take::<T>());\n+    let val: *const () = mem::transmute(take::<T>());\n     Borrowed {\n         val: val,\n     }"}, {"sha": "6950d987d2f270d5339160118492e9d84619968b", "filename": "src/librustrt/mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmutex.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -351,8 +351,8 @@ mod imp {\n     mod os {\n         use libc;\n \n-        pub type pthread_mutex_t = *libc::c_void;\n-        pub type pthread_cond_t = *libc::c_void;\n+        pub type pthread_mutex_t = *mut libc::c_void;\n+        pub type pthread_cond_t = *mut libc::c_void;\n \n         pub static PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t =\n             0 as pthread_mutex_t;"}, {"sha": "8e637207d2209c07879c581112e507c33c68296b", "filename": "src/librustrt/stack.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fstack.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -221,9 +221,9 @@ pub unsafe fn record_sp_limit(limit: uint) {\n     #[cfg(target_arch = \"arm\", not(target_os = \"ios\"))] #[inline(always)]\n     unsafe fn target_record_sp_limit(limit: uint) {\n         use libc::c_void;\n-        return record_sp_limit(limit as *c_void);\n+        return record_sp_limit(limit as *const c_void);\n         extern {\n-            fn record_sp_limit(limit: *c_void);\n+            fn record_sp_limit(limit: *const c_void);\n         }\n     }\n \n@@ -305,7 +305,7 @@ pub unsafe fn get_sp_limit() -> uint {\n         use libc::c_void;\n         return get_sp_limit() as uint;\n         extern {\n-            fn get_sp_limit() -> *c_void;\n+            fn get_sp_limit() -> *const c_void;\n         }\n     }\n "}, {"sha": "9908e87e86a4727a0230eba1c77c66265bf8c9fd", "filename": "src/librustrt/thread.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -25,7 +25,7 @@ use libc;\n \n use stack;\n \n-type StartFn = extern \"C\" fn(*libc::c_void) -> imp::rust_thread_return;\n+type StartFn = extern \"C\" fn(*mut libc::c_void) -> imp::rust_thread_return;\n \n /// This struct represents a native thread's state. This is used to join on an\n /// existing thread created in the join-able state.\n@@ -42,7 +42,7 @@ static DEFAULT_STACK_SIZE: uint = 1024 * 1024;\n // no_split_stack annotation), and then we extract the main function\n // and invoke it.\n #[no_split_stack]\n-extern fn thread_start(main: *libc::c_void) -> imp::rust_thread_return {\n+extern fn thread_start(main: *mut libc::c_void) -> imp::rust_thread_return {\n     unsafe {\n         stack::record_stack_bounds(0, uint::MAX);\n         let f: Box<proc()> = mem::transmute(main);\n@@ -82,7 +82,7 @@ impl Thread<()> {\n         // so.\n         let packet = box None;\n         let packet2: *mut Option<T> = unsafe {\n-            *mem::transmute::<&Box<Option<T>>, **mut Option<T>>(&packet)\n+            *mem::transmute::<&Box<Option<T>>, *const *mut Option<T>>(&packet)\n         };\n         let main = proc() unsafe { *packet2 = Some(main()); };\n         let native = unsafe { imp::create(stack, box main) };\n@@ -225,7 +225,7 @@ mod imp {\n     use stack::RED_ZONE;\n \n     pub type rust_thread = libc::pthread_t;\n-    pub type rust_thread_return = *u8;\n+    pub type rust_thread_return = *mut u8;\n \n     pub unsafe fn create(stack: uint, p: Box<proc():Send>) -> rust_thread {\n         let mut native: libc::pthread_t = mem::zeroed();\n@@ -255,7 +255,7 @@ mod imp {\n             },\n         };\n \n-        let arg: *libc::c_void = mem::transmute(p);\n+        let arg: *mut libc::c_void = mem::transmute(p);\n         let ret = pthread_create(&mut native, &attr, super::thread_start, arg);\n         assert_eq!(pthread_attr_destroy(&mut attr), 0);\n \n@@ -268,7 +268,7 @@ mod imp {\n     }\n \n     pub unsafe fn join(native: rust_thread) {\n-        assert_eq!(pthread_join(native, ptr::null()), 0);\n+        assert_eq!(pthread_join(native, ptr::mut_null()), 0);\n     }\n \n     pub unsafe fn detach(native: rust_thread) {\n@@ -287,33 +287,33 @@ mod imp {\n     // currently always the case.  Note that you need to check that the symbol\n     // is non-null before calling it!\n     #[cfg(target_os = \"linux\")]\n-    fn min_stack_size(attr: *libc::pthread_attr_t) -> libc::size_t {\n-        type F = unsafe extern \"C\" fn(*libc::pthread_attr_t) -> libc::size_t;\n+    fn min_stack_size(attr: *const libc::pthread_attr_t) -> libc::size_t {\n+        type F = unsafe extern \"C\" fn(*const libc::pthread_attr_t) -> libc::size_t;\n         extern {\n             #[linkage = \"extern_weak\"]\n-            static __pthread_get_minstack: *();\n+            static __pthread_get_minstack: *const ();\n         }\n         if __pthread_get_minstack.is_null() {\n             PTHREAD_STACK_MIN\n         } else {\n-            unsafe { mem::transmute::<*(), F>(__pthread_get_minstack)(attr) }\n+            unsafe { mem::transmute::<*const (), F>(__pthread_get_minstack)(attr) }\n         }\n     }\n \n     // __pthread_get_minstack() is marked as weak but extern_weak linkage is\n     // not supported on OS X, hence this kludge...\n     #[cfg(not(target_os = \"linux\"))]\n-    fn min_stack_size(_: *libc::pthread_attr_t) -> libc::size_t {\n+    fn min_stack_size(_: *const libc::pthread_attr_t) -> libc::size_t {\n         PTHREAD_STACK_MIN\n     }\n \n     extern {\n         fn pthread_create(native: *mut libc::pthread_t,\n-                          attr: *libc::pthread_attr_t,\n+                          attr: *const libc::pthread_attr_t,\n                           f: super::StartFn,\n-                          value: *libc::c_void) -> libc::c_int;\n+                          value: *mut libc::c_void) -> libc::c_int;\n         fn pthread_join(native: libc::pthread_t,\n-                        value: **libc::c_void) -> libc::c_int;\n+                        value: *mut *mut libc::c_void) -> libc::c_int;\n         fn pthread_attr_init(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n         fn pthread_attr_destroy(attr: *mut libc::pthread_attr_t) -> libc::c_int;\n         fn pthread_attr_setstacksize(attr: *mut libc::pthread_attr_t,"}, {"sha": "e1db67140aad755cbd4d302a27d7a87e49adec74", "filename": "src/librustrt/thread_local_storage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread_local_storage.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -50,7 +50,7 @@ type pthread_key_t = ::libc::c_uint;\n \n #[cfg(unix)]\n extern {\n-    fn pthread_key_create(key: *mut pthread_key_t, dtor: *u8) -> c_int;\n+    fn pthread_key_create(key: *mut pthread_key_t, dtor: *const u8) -> c_int;\n     fn pthread_key_delete(key: pthread_key_t) -> c_int;\n     fn pthread_getspecific(key: pthread_key_t) -> *mut u8;\n     fn pthread_setspecific(key: pthread_key_t, value: *mut u8) -> c_int;"}, {"sha": "18688cbcc64ca788668db469d231b520b562533d", "filename": "src/librustrt/unwind.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -136,8 +136,8 @@ impl Unwinder {\n ///   run.\n pub unsafe fn try(f: ||) -> ::core::result::Result<(), Box<Any + Send>> {\n     let closure: Closure = mem::transmute(f);\n-    let ep = rust_try(try_fn, closure.code as *c_void,\n-                      closure.env as *c_void);\n+    let ep = rust_try(try_fn, closure.code as *mut c_void,\n+                      closure.env as *mut c_void);\n     return if ep.is_null() {\n         Ok(())\n     } else {\n@@ -148,11 +148,11 @@ pub unsafe fn try(f: ||) -> ::core::result::Result<(), Box<Any + Send>> {\n         Err(cause.unwrap())\n     };\n \n-    extern fn try_fn(code: *c_void, env: *c_void) {\n+    extern fn try_fn(code: *mut c_void, env: *mut c_void) {\n         unsafe {\n             let closure: || = mem::transmute(Closure {\n-                code: code as *(),\n-                env: env as *(),\n+                code: code as *mut (),\n+                env: env as *mut (),\n             });\n             closure();\n         }\n@@ -164,9 +164,9 @@ pub unsafe fn try(f: ||) -> ::core::result::Result<(), Box<Any + Send>> {\n         // When f(...) returns normally, the return value is null.\n         // When f(...) throws, the return value is a pointer to the caught\n         // exception object.\n-        fn rust_try(f: extern \"C\" fn(*c_void, *c_void),\n-                    code: *c_void,\n-                    data: *c_void) -> *uw::_Unwind_Exception;\n+        fn rust_try(f: extern \"C\" fn(*mut c_void, *mut c_void),\n+                    code: *mut c_void,\n+                    data: *mut c_void) -> *mut uw::_Unwind_Exception;\n     }\n }\n \n@@ -190,7 +190,7 @@ fn rust_fail(cause: Box<Any + Send>) -> ! {\n     }\n \n     extern fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,\n-                                exception: *uw::_Unwind_Exception) {\n+                                exception: *mut uw::_Unwind_Exception) {\n         rtdebug!(\"exception_cleanup()\");\n         unsafe {\n             let _: Box<Exception> = mem::transmute(exception);\n@@ -235,8 +235,8 @@ pub mod eabi {\n         fn __gcc_personality_v0(version: c_int,\n                                 actions: uw::_Unwind_Action,\n                                 exception_class: uw::_Unwind_Exception_Class,\n-                                ue_header: *uw::_Unwind_Exception,\n-                                context: *uw::_Unwind_Context)\n+                                ue_header: *mut uw::_Unwind_Exception,\n+                                context: *mut uw::_Unwind_Context)\n             -> uw::_Unwind_Reason_Code;\n     }\n \n@@ -245,8 +245,8 @@ pub mod eabi {\n         version: c_int,\n         actions: uw::_Unwind_Action,\n         exception_class: uw::_Unwind_Exception_Class,\n-        ue_header: *uw::_Unwind_Exception,\n-        context: *uw::_Unwind_Context\n+        ue_header: *mut uw::_Unwind_Exception,\n+        context: *mut uw::_Unwind_Context\n     ) -> uw::_Unwind_Reason_Code\n     {\n         unsafe {\n@@ -260,8 +260,8 @@ pub mod eabi {\n         version: c_int,\n         actions: uw::_Unwind_Action,\n         exception_class: uw::_Unwind_Exception_Class,\n-        ue_header: *uw::_Unwind_Exception,\n-        context: *uw::_Unwind_Context\n+        ue_header: *mut uw::_Unwind_Exception,\n+        context: *mut uw::_Unwind_Context\n     ) -> uw::_Unwind_Reason_Code\n     {\n         if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n@@ -290,8 +290,8 @@ pub mod eabi {\n         fn __gcc_personality_sj0(version: c_int,\n                                 actions: uw::_Unwind_Action,\n                                 exception_class: uw::_Unwind_Exception_Class,\n-                                ue_header: *uw::_Unwind_Exception,\n-                                context: *uw::_Unwind_Context)\n+                                ue_header: *mut uw::_Unwind_Exception,\n+                                context: *mut uw::_Unwind_Context)\n             -> uw::_Unwind_Reason_Code;\n     }\n \n@@ -301,8 +301,8 @@ pub mod eabi {\n         version: c_int,\n         actions: uw::_Unwind_Action,\n         exception_class: uw::_Unwind_Exception_Class,\n-        ue_header: *uw::_Unwind_Exception,\n-        context: *uw::_Unwind_Context\n+        ue_header: *mut uw::_Unwind_Exception,\n+        context: *mut uw::_Unwind_Context\n     ) -> uw::_Unwind_Reason_Code\n     {\n         unsafe {\n@@ -316,8 +316,8 @@ pub mod eabi {\n         version: c_int,\n         actions: uw::_Unwind_Action,\n         exception_class: uw::_Unwind_Exception_Class,\n-        ue_header: *uw::_Unwind_Exception,\n-        context: *uw::_Unwind_Context\n+        ue_header: *mut uw::_Unwind_Exception,\n+        context: *mut uw::_Unwind_Context\n     ) -> uw::_Unwind_Reason_Code\n     {\n         if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n@@ -343,16 +343,16 @@ pub mod eabi {\n \n     extern \"C\" {\n         fn __gcc_personality_v0(state: uw::_Unwind_State,\n-                                ue_header: *uw::_Unwind_Exception,\n-                                context: *uw::_Unwind_Context)\n+                                ue_header: *mut uw::_Unwind_Exception,\n+                                context: *mut uw::_Unwind_Context)\n             -> uw::_Unwind_Reason_Code;\n     }\n \n     #[lang=\"eh_personality\"]\n     extern \"C\" fn eh_personality(\n         state: uw::_Unwind_State,\n-        ue_header: *uw::_Unwind_Exception,\n-        context: *uw::_Unwind_Context\n+        ue_header: *mut uw::_Unwind_Exception,\n+        context: *mut uw::_Unwind_Context\n     ) -> uw::_Unwind_Reason_Code\n     {\n         unsafe {\n@@ -363,8 +363,8 @@ pub mod eabi {\n     #[no_mangle] // referenced from rust_try.ll\n     pub extern \"C\" fn rust_eh_personality_catch(\n         state: uw::_Unwind_State,\n-        ue_header: *uw::_Unwind_Exception,\n-        context: *uw::_Unwind_Context\n+        ue_header: *mut uw::_Unwind_Exception,\n+        context: *mut uw::_Unwind_Context\n     ) -> uw::_Unwind_Reason_Code\n     {\n         if (state as c_int & uw::_US_ACTION_MASK as c_int)"}, {"sha": "40c3e19576e4fa304467661d73aa8028da28325e", "filename": "src/librustrt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustrt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Futil.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -38,7 +38,7 @@ impl fmt::FormatWriter for Stdio {\n         unsafe {\n             let Stdio(fd) = *self;\n             libc::write(fd,\n-                        data.as_ptr() as *libc::c_void,\n+                        data.as_ptr() as *const libc::c_void,\n                         data.len() as WriteLen);\n         }\n         Ok(()) // yes, we're lying"}, {"sha": "fa30199109e76ce2554da23076a1f33283b37d57", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -11,7 +11,7 @@\n use libc::c_int;\n use libc;\n use std::mem;\n-use std::ptr::null;\n+use std::ptr::{null, mut_null};\n use std::rt::task::BlockedTask;\n use std::rt::rtio;\n \n@@ -20,7 +20,7 @@ use super::{Loop, UvError, Request, wait_until_woken_after, wakeup};\n use uvll;\n \n struct Addrinfo {\n-    handle: *libc::addrinfo,\n+    handle: *const libc::addrinfo,\n }\n \n struct Ctx {\n@@ -62,12 +62,14 @@ impl GetAddrInfoRequest {\n                 ai_socktype: 0,\n                 ai_protocol: 0,\n                 ai_addrlen: 0,\n-                ai_canonname: null(),\n-                ai_addr: null(),\n-                ai_next: null(),\n+                ai_canonname: mut_null(),\n+                ai_addr: mut_null(),\n+                ai_next: mut_null(),\n             }\n         });\n-        let hint_ptr = hint.as_ref().map_or(null(), |x| x as *libc::addrinfo);\n+        let hint_ptr = hint.as_ref().map_or(null(), |x| {\n+            x as *const libc::addrinfo\n+        });\n         let mut req = Request::new(uvll::UV_GETADDRINFO);\n \n         return match unsafe {\n@@ -80,7 +82,7 @@ impl GetAddrInfoRequest {\n                 let mut cx = Ctx { slot: None, status: 0, addrinfo: None };\n \n                 wait_until_woken_after(&mut cx.slot, loop_, || {\n-                    req.set_data(&cx);\n+                    req.set_data(&mut cx);\n                 });\n \n                 match cx.status {\n@@ -92,9 +94,9 @@ impl GetAddrInfoRequest {\n         };\n \n \n-        extern fn getaddrinfo_cb(req: *uvll::uv_getaddrinfo_t,\n+        extern fn getaddrinfo_cb(req: *mut uvll::uv_getaddrinfo_t,\n                                  status: c_int,\n-                                 res: *libc::addrinfo) {\n+                                 res: *const libc::addrinfo) {\n             let req = Request::wrap(req);\n             assert!(status != uvll::ECANCELED);\n             let cx: &mut Ctx = unsafe { req.get_data() };\n@@ -108,7 +110,7 @@ impl GetAddrInfoRequest {\n \n impl Drop for Addrinfo {\n     fn drop(&mut self) {\n-        unsafe { uvll::uv_freeaddrinfo(self.handle) }\n+        unsafe { uvll::uv_freeaddrinfo(self.handle as *mut _) }\n     }\n }\n \n@@ -130,7 +132,7 @@ pub fn accum_addrinfo(addr: &Addrinfo) -> Vec<rtio::AddrinfoInfo> {\n                 flags: 0,\n             });\n             if (*addr).ai_next.is_not_null() {\n-                addr = (*addr).ai_next;\n+                addr = (*addr).ai_next as *const _;\n             } else {\n                 break;\n             }"}, {"sha": "97f95145b8992e6be43e19e5f2303c29d92ac577", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -19,7 +19,7 @@ use super::{Loop, UvHandle};\n // The entire point of async is to call into a loop from other threads so it\n // does not need to home.\n pub struct AsyncWatcher {\n-    handle: *uvll::uv_async_t,\n+    handle: *mut uvll::uv_async_t,\n \n     // A flag to tell the callback to exit, set from the dtor. This is\n     // almost never contested - only in rare races with the dtor.\n@@ -40,21 +40,21 @@ impl AsyncWatcher {\n         let flag = Arc::new(Exclusive::new(false));\n         let payload = box Payload { callback: cb, exit_flag: flag.clone() };\n         unsafe {\n-            let payload: *u8 = mem::transmute(payload);\n+            let payload: *mut u8 = mem::transmute(payload);\n             uvll::set_data_for_uv_handle(handle, payload);\n         }\n         return AsyncWatcher { handle: handle, exit_flag: flag, };\n     }\n }\n \n impl UvHandle<uvll::uv_async_t> for AsyncWatcher {\n-    fn uv_handle(&self) -> *uvll::uv_async_t { self.handle }\n-    unsafe fn from_uv_handle<'a>(_: &'a *uvll::uv_async_t) -> &'a mut AsyncWatcher {\n+    fn uv_handle(&self) -> *mut uvll::uv_async_t { self.handle }\n+    unsafe fn from_uv_handle<'a>(_: &'a *mut uvll::uv_async_t) -> &'a mut AsyncWatcher {\n         fail!(\"async watchers can't be built from their handles\");\n     }\n }\n \n-extern fn async_cb(handle: *uvll::uv_async_t) {\n+extern fn async_cb(handle: *mut uvll::uv_async_t) {\n     let payload: &mut Payload = unsafe {\n         mem::transmute(uvll::get_data_for_uv_handle(handle))\n     };\n@@ -90,7 +90,7 @@ extern fn async_cb(handle: *uvll::uv_async_t) {\n     }\n }\n \n-extern fn close_cb(handle: *uvll::uv_handle_t) {\n+extern fn close_cb(handle: *mut uvll::uv_handle_t) {\n     // drop the payload\n     let _payload: Box<Payload> = unsafe {\n         mem::transmute(uvll::get_data_for_uv_handle(handle))"}, {"sha": "85abc45c4302a52c640690aa332fbf4f41e8ea9f", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -24,7 +24,7 @@ use uvio::UvIoFactory;\n use uvll;\n \n pub struct FsRequest {\n-    req: *uvll::uv_fs_t,\n+    req: *mut uvll::uv_fs_t,\n     fired: bool,\n }\n \n@@ -94,7 +94,7 @@ impl FsRequest {\n                 offset + written as i64\n             };\n             let uvbuf = uvll::uv_buf_t {\n-                base: buf.slice_from(written as uint).as_ptr(),\n+                base: buf.slice_from(written as uint).as_ptr() as *mut _,\n                 len: (buf.len() - written) as uvll::uv_buf_len_t,\n             };\n             match execute(|req, cb| unsafe {\n@@ -111,11 +111,11 @@ impl FsRequest {\n         -> Result<int, UvError>\n     {\n         execute(|req, cb| unsafe {\n-            let uvbuf = uvll::uv_buf_t {\n-                base: buf.as_ptr(),\n+            let mut uvbuf = uvll::uv_buf_t {\n+                base: buf.as_mut_ptr(),\n                 len: buf.len() as uvll::uv_buf_len_t,\n             };\n-            uvll::uv_fs_read(loop_.handle, req, fd, &uvbuf, 1, offset, cb)\n+            uvll::uv_fs_read(loop_.handle, req, fd, &mut uvbuf, 1, offset, cb)\n         }).map(|req| {\n             req.get_result() as int\n         })\n@@ -168,7 +168,7 @@ impl FsRequest {\n             let mut paths = vec!();\n             let path = CString::new(path.with_ref(|p| p), false);\n             let parent = Path::new(path);\n-            let _ = c_str::from_c_multistring(req.get_ptr() as *libc::c_char,\n+            let _ = c_str::from_c_multistring(req.get_ptr() as *const libc::c_char,\n                                               Some(req.get_result() as uint),\n                                               |rel| {\n                 let p = rel.as_bytes();\n@@ -186,7 +186,7 @@ impl FsRequest {\n             // Be sure to clone the cstring so we get an independently owned\n             // allocation to work with and return.\n             unsafe {\n-                CString::new(req.get_ptr() as *libc::c_char, false).clone()\n+                CString::new(req.get_ptr() as *const libc::c_char, false).clone()\n             }\n         })\n     }\n@@ -262,12 +262,12 @@ impl FsRequest {\n     }\n \n     pub fn get_stat(&self) -> uvll::uv_stat_t {\n-        let stat = uvll::uv_stat_t::new();\n-        unsafe { uvll::populate_stat(self.req, &stat); }\n+        let mut stat = uvll::uv_stat_t::new();\n+        unsafe { uvll::populate_stat(self.req, &mut stat); }\n         stat\n     }\n \n-    pub fn get_ptr(&self) -> *libc::c_void {\n+    pub fn get_ptr(&self) -> *mut libc::c_void {\n         unsafe { uvll::get_ptr_from_fs_req(self.req) }\n     }\n \n@@ -310,7 +310,7 @@ impl Drop for FsRequest {\n     }\n }\n \n-fn execute(f: |*uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)\n+fn execute(f: |*mut uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)\n     -> Result<FsRequest, UvError>\n {\n     let mut req = FsRequest {\n@@ -323,7 +323,7 @@ fn execute(f: |*uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)\n             let mut slot = None;\n             let loop_ = unsafe { uvll::get_loop_from_fs_req(req.req) };\n             wait_until_woken_after(&mut slot, &Loop::wrap(loop_), || {\n-                unsafe { uvll::set_data_for_req(req.req, &slot) }\n+                unsafe { uvll::set_data_for_req(req.req, &mut slot) }\n             });\n             match req.get_result() {\n                 n if n < 0 => Err(UvError(n as i32)),\n@@ -333,15 +333,15 @@ fn execute(f: |*uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)\n         n => Err(UvError(n))\n     };\n \n-    extern fn fs_cb(req: *uvll::uv_fs_t) {\n+    extern fn fs_cb(req: *mut uvll::uv_fs_t) {\n         let slot: &mut Option<BlockedTask> = unsafe {\n             mem::transmute(uvll::get_data_for_req(req))\n         };\n         wakeup(slot);\n     }\n }\n \n-fn execute_nop(f: |*uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)\n+fn execute_nop(f: |*mut uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)\n     -> Result<(), UvError> {\n     execute(f).map(|_| {})\n }\n@@ -397,7 +397,7 @@ impl Drop for FileWatcher {\n                                                  self.fd, close_cb), 0);\n                 }\n \n-                extern fn close_cb(req: *uvll::uv_fs_t) {\n+                extern fn close_cb(req: *mut uvll::uv_fs_t) {\n                     unsafe {\n                         uvll::uv_fs_req_cleanup(req);\n                         uvll::free_req(req);"}, {"sha": "7b9a2fcf4446779af43fad88ec92f87217afc9b3", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -16,7 +16,7 @@ use super::{Loop, UvHandle};\n use std::rt::rtio::{Callback, PausableIdleCallback};\n \n pub struct IdleWatcher {\n-    handle: *uvll::uv_idle_t,\n+    handle: *mut uvll::uv_idle_t,\n     idle_flag: bool,\n     callback: Box<Callback + Send>,\n }\n@@ -39,12 +39,12 @@ impl IdleWatcher {\n         let handle = UvHandle::alloc(None::<IdleWatcher>, uvll::UV_IDLE);\n         unsafe {\n             assert_eq!(uvll::uv_idle_init(loop_.handle, handle), 0);\n-            let data: *c_void = mem::transmute(box f);\n+            let data: *mut c_void = mem::transmute(box f);\n             uvll::set_data_for_uv_handle(handle, data);\n             assert_eq!(uvll::uv_idle_start(handle, onetime_cb), 0)\n         }\n \n-        extern fn onetime_cb(handle: *uvll::uv_idle_t) {\n+        extern fn onetime_cb(handle: *mut uvll::uv_idle_t) {\n             unsafe {\n                 let data = uvll::get_data_for_uv_handle(handle);\n                 let f: Box<proc()> = mem::transmute(data);\n@@ -54,7 +54,7 @@ impl IdleWatcher {\n             }\n         }\n \n-        extern fn close_cb(handle: *uvll::uv_handle_t) {\n+        extern fn close_cb(handle: *mut uvll::uv_handle_t) {\n             unsafe { uvll::free_handle(handle) }\n         }\n     }\n@@ -76,10 +76,10 @@ impl PausableIdleCallback for IdleWatcher {\n }\n \n impl UvHandle<uvll::uv_idle_t> for IdleWatcher {\n-    fn uv_handle(&self) -> *uvll::uv_idle_t { self.handle }\n+    fn uv_handle(&self) -> *mut uvll::uv_idle_t { self.handle }\n }\n \n-extern fn idle_cb(handle: *uvll::uv_idle_t) {\n+extern fn idle_cb(handle: *mut uvll::uv_idle_t) {\n     let idle: &mut IdleWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n     idle.callback.call();\n }"}, {"sha": "968a283995bef2fef78775b9594ac7a9cf47d018", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -53,7 +53,6 @@ extern crate alloc;\n use libc::{c_int, c_void};\n use std::fmt;\n use std::mem;\n-use std::ptr::null;\n use std::ptr;\n use std::rt::local::Local;\n use std::rt::rtio;\n@@ -78,7 +77,7 @@ pub use self::tty::TtyWatcher;\n //        threading mode than the default by reaching into the auto-generated\n //        '__test' module.\n #[cfg(test)] #[start]\n-fn start(argc: int, argv: **u8) -> int {\n+fn start(argc: int, argv: *const *const u8) -> int {\n     green::start(argc, argv, event_loop, __test::main)\n }\n \n@@ -118,7 +117,7 @@ pub mod stream;\n /// extern crate green;\n ///\n /// #[start]\n-/// fn start(argc: int, argv: **u8) -> int {\n+/// fn start(argc: int, argv: *const *const u8) -> int {\n ///     green::start(argc, argv, rustuv::event_loop, main)\n /// }\n ///\n@@ -132,28 +131,28 @@ pub fn event_loop() -> Box<rtio::EventLoop + Send> {\n \n /// A type that wraps a uv handle\n pub trait UvHandle<T> {\n-    fn uv_handle(&self) -> *T;\n+    fn uv_handle(&self) -> *mut T;\n \n     fn uv_loop(&self) -> Loop {\n         Loop::wrap(unsafe { uvll::get_loop_for_uv_handle(self.uv_handle()) })\n     }\n \n     // FIXME(#8888) dummy self\n-    fn alloc(_: Option<Self>, ty: uvll::uv_handle_type) -> *T {\n+    fn alloc(_: Option<Self>, ty: uvll::uv_handle_type) -> *mut T {\n         unsafe {\n             let handle = uvll::malloc_handle(ty);\n             assert!(!handle.is_null());\n-            handle as *T\n+            handle as *mut T\n         }\n     }\n \n-    unsafe fn from_uv_handle<'a>(h: &'a *T) -> &'a mut Self {\n+    unsafe fn from_uv_handle<'a>(h: &'a *mut T) -> &'a mut Self {\n         mem::transmute(uvll::get_data_for_uv_handle(*h))\n     }\n \n     fn install(~self) -> Box<Self> {\n         unsafe {\n-            let myptr = mem::transmute::<&Box<Self>, &*u8>(&self);\n+            let myptr = mem::transmute::<&Box<Self>, &*mut u8>(&self);\n             uvll::set_data_for_uv_handle(self.uv_handle(), *myptr);\n         }\n         self\n@@ -162,33 +161,34 @@ pub trait UvHandle<T> {\n     fn close_async_(&mut self) {\n         // we used malloc to allocate all handles, so we must always have at\n         // least a callback to free all the handles we allocated.\n-        extern fn close_cb(handle: *uvll::uv_handle_t) {\n+        extern fn close_cb(handle: *mut uvll::uv_handle_t) {\n             unsafe { uvll::free_handle(handle) }\n         }\n \n         unsafe {\n-            uvll::set_data_for_uv_handle(self.uv_handle(), null::<()>());\n-            uvll::uv_close(self.uv_handle() as *uvll::uv_handle_t, close_cb)\n+            uvll::set_data_for_uv_handle(self.uv_handle(), ptr::mut_null::<()>());\n+            uvll::uv_close(self.uv_handle() as *mut uvll::uv_handle_t, close_cb)\n         }\n     }\n \n     fn close(&mut self) {\n         let mut slot = None;\n \n         unsafe {\n-            uvll::uv_close(self.uv_handle() as *uvll::uv_handle_t, close_cb);\n-            uvll::set_data_for_uv_handle(self.uv_handle(), ptr::null::<()>());\n+            uvll::uv_close(self.uv_handle() as *mut uvll::uv_handle_t, close_cb);\n+            uvll::set_data_for_uv_handle(self.uv_handle(),\n+                                         ptr::mut_null::<()>());\n \n             wait_until_woken_after(&mut slot, &self.uv_loop(), || {\n-                uvll::set_data_for_uv_handle(self.uv_handle(), &slot);\n+                uvll::set_data_for_uv_handle(self.uv_handle(), &mut slot);\n             })\n         }\n \n-        extern fn close_cb(handle: *uvll::uv_handle_t) {\n+        extern fn close_cb(handle: *mut uvll::uv_handle_t) {\n             unsafe {\n                 let data = uvll::get_data_for_uv_handle(handle);\n                 uvll::free_handle(handle);\n-                if data == ptr::null() { return }\n+                if data == ptr::mut_null() { return }\n                 let slot: &mut Option<BlockedTask> = mem::transmute(data);\n                 wakeup(slot);\n             }\n@@ -261,30 +261,30 @@ fn wakeup(slot: &mut Option<BlockedTask>) {\n }\n \n pub struct Request {\n-    pub handle: *uvll::uv_req_t,\n+    pub handle: *mut uvll::uv_req_t,\n     defused: bool,\n }\n \n impl Request {\n     pub fn new(ty: uvll::uv_req_type) -> Request {\n         unsafe {\n             let handle = uvll::malloc_req(ty);\n-            uvll::set_data_for_req(handle, null::<()>());\n+            uvll::set_data_for_req(handle, ptr::mut_null::<()>());\n             Request::wrap(handle)\n         }\n     }\n \n-    pub fn wrap(handle: *uvll::uv_req_t) -> Request {\n+    pub fn wrap(handle: *mut uvll::uv_req_t) -> Request {\n         Request { handle: handle, defused: false }\n     }\n \n-    pub fn set_data<T>(&self, t: *T) {\n+    pub fn set_data<T>(&self, t: *mut T) {\n         unsafe { uvll::set_data_for_req(self.handle, t) }\n     }\n \n     pub unsafe fn get_data<T>(&self) -> &'static mut T {\n         let data = uvll::get_data_for_req(self.handle);\n-        assert!(data != null());\n+        assert!(data != ptr::mut_null());\n         mem::transmute(data)\n     }\n \n@@ -313,18 +313,18 @@ impl Drop for Request {\n /// with dtors may not be destructured, but tuple structs can,\n /// but the results are not correct.\n pub struct Loop {\n-    handle: *uvll::uv_loop_t\n+    handle: *mut uvll::uv_loop_t\n }\n \n impl Loop {\n     pub fn new() -> Loop {\n         let handle = unsafe { uvll::loop_new() };\n         assert!(handle.is_not_null());\n-        unsafe { uvll::set_data_for_uv_loop(handle, 0 as *c_void) }\n+        unsafe { uvll::set_data_for_uv_loop(handle, 0 as *mut c_void) }\n         Loop::wrap(handle)\n     }\n \n-    pub fn wrap(handle: *uvll::uv_loop_t) -> Loop { Loop { handle: handle } }\n+    pub fn wrap(handle: *mut uvll::uv_loop_t) -> Loop { Loop { handle: handle } }\n \n     pub fn run(&mut self) {\n         assert_eq!(unsafe { uvll::uv_run(self.handle, uvll::RUN_DEFAULT) }, 0);\n@@ -339,7 +339,7 @@ impl Loop {\n     fn modify_blockers(&self, amt: uint) {\n         unsafe {\n             let cur = uvll::get_data_for_uv_loop(self.handle) as uint;\n-            uvll::set_data_for_uv_loop(self.handle, (cur + amt) as *c_void)\n+            uvll::set_data_for_uv_loop(self.handle, (cur + amt) as *mut c_void)\n         }\n     }\n \n@@ -445,15 +445,15 @@ pub type Buf = uvll::uv_buf_t;\n \n pub fn empty_buf() -> Buf {\n     uvll::uv_buf_t {\n-        base: null(),\n+        base: ptr::mut_null(),\n         len: 0,\n     }\n }\n \n /// Borrow a slice to a Buf\n pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n     let data = v.as_ptr();\n-    uvll::uv_buf_t { base: data, len: v.len() as uvll::uv_buf_len_t }\n+    uvll::uv_buf_t { base: data as *mut u8, len: v.len() as uvll::uv_buf_len_t }\n }\n \n // This function is full of lies!\n@@ -512,7 +512,7 @@ mod test {\n         assert_eq!(buf.len, 20);\n \n         unsafe {\n-            let base = transmute::<*u8, *mut u8>(buf.base);\n+            let base = transmute::<*mut u8, *mut u8>(buf.base);\n             (*base) = 1;\n             (*base.offset(1)) = 2;\n         }"}, {"sha": "f1c37762129a3b442d8013e56e41bb47a804982e", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -125,7 +125,7 @@ enum SocketNameKind {\n }\n \n fn socket_name(sk: SocketNameKind,\n-               handle: *c_void) -> Result<rtio::SocketAddr, IoError> {\n+               handle: *mut c_void) -> Result<rtio::SocketAddr, IoError> {\n     let getsockname = match sk {\n         TcpPeer => uvll::uv_tcp_getpeername,\n         Tcp     => uvll::uv_tcp_getsockname,\n@@ -150,7 +150,7 @@ fn socket_name(sk: SocketNameKind,\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct TcpWatcher {\n-    handle: *uvll::uv_tcp_t,\n+    handle: *mut uvll::uv_tcp_t,\n     stream: StreamWatcher,\n     home: HomeHandle,\n     refcount: Refcount,\n@@ -165,7 +165,7 @@ pub struct TcpWatcher {\n \n pub struct TcpListener {\n     home: HomeHandle,\n-    handle: *uvll::uv_pipe_t,\n+    handle: *mut uvll::uv_pipe_t,\n     outgoing: Sender<Result<Box<rtio::RtioTcpStream + Send>, IoError>>,\n     incoming: Receiver<Result<Box<rtio::RtioTcpStream + Send>, IoError>>,\n }\n@@ -204,7 +204,7 @@ impl TcpWatcher {\n         let tcp = TcpWatcher::new(io);\n         let cx = ConnectCtx { status: -1, task: None, timer: None };\n         let (addr, _len) = addr_to_sockaddr(address);\n-        let addr_p = &addr as *_ as *libc::sockaddr;\n+        let addr_p = &addr as *const _ as *const libc::sockaddr;\n         cx.connect(tcp, timeout, io, |req, tcp, cb| {\n             unsafe { uvll::uv_tcp_connect(req.handle, tcp.handle, addr_p, cb) }\n         })\n@@ -311,7 +311,7 @@ impl rtio::RtioTcpStream for TcpWatcher {\n         let _m = self.fire_homing_missile();\n         let loop_ = self.uv_loop();\n         self.read_access.set_timeout(ms, &self.home, &loop_, cancel_read,\n-                                     &self.stream as *_ as uint);\n+                                     &self.stream as *const _ as uint);\n \n         fn cancel_read(stream: uint) -> Option<BlockedTask> {\n             let stream: &mut StreamWatcher = unsafe { mem::transmute(stream) };\n@@ -323,7 +323,7 @@ impl rtio::RtioTcpStream for TcpWatcher {\n         let _m = self.fire_homing_missile();\n         let loop_ = self.uv_loop();\n         self.write_access.set_timeout(ms, &self.home, &loop_, cancel_write,\n-                                      &self.stream as *_ as uint);\n+                                      &self.stream as *const _ as uint);\n \n         fn cancel_write(stream: uint) -> Option<BlockedTask> {\n             let stream: &mut StreamWatcher = unsafe { mem::transmute(stream) };\n@@ -333,7 +333,7 @@ impl rtio::RtioTcpStream for TcpWatcher {\n }\n \n impl UvHandle<uvll::uv_tcp_t> for TcpWatcher {\n-    fn uv_handle(&self) -> *uvll::uv_tcp_t { self.stream.handle }\n+    fn uv_handle(&self) -> *mut uvll::uv_tcp_t { self.stream.handle }\n }\n \n impl Drop for TcpWatcher {\n@@ -363,8 +363,8 @@ impl TcpListener {\n         };\n         let (addr, _len) = addr_to_sockaddr(address);\n         let res = unsafe {\n-            let addr_p = &addr as *libc::sockaddr_storage;\n-            uvll::uv_tcp_bind(l.handle, addr_p as *libc::sockaddr)\n+            let addr_p = &addr as *const libc::sockaddr_storage;\n+            uvll::uv_tcp_bind(l.handle, addr_p as *const libc::sockaddr)\n         };\n         return match res {\n             0 => Ok(l.install()),\n@@ -378,7 +378,7 @@ impl HomingIO for TcpListener {\n }\n \n impl UvHandle<uvll::uv_tcp_t> for TcpListener {\n-    fn uv_handle(&self) -> *uvll::uv_tcp_t { self.handle }\n+    fn uv_handle(&self) -> *mut uvll::uv_tcp_t { self.handle }\n }\n \n impl rtio::RtioSocket for TcpListener {\n@@ -405,7 +405,7 @@ impl rtio::RtioTcpListener for TcpListener {\n     }\n }\n \n-extern fn listen_cb(server: *uvll::uv_stream_t, status: c_int) {\n+extern fn listen_cb(server: *mut uvll::uv_stream_t, status: c_int) {\n     assert!(status != uvll::ECANCELED);\n     let tcp: &mut TcpListener = unsafe { UvHandle::from_uv_handle(&server) };\n     let msg = match status {\n@@ -475,7 +475,7 @@ impl rtio::RtioTcpAcceptor for TcpAcceptor {\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct UdpWatcher {\n-    handle: *uvll::uv_udp_t,\n+    handle: *mut uvll::uv_udp_t,\n     home: HomeHandle,\n \n     // See above for what these fields are\n@@ -514,8 +514,8 @@ impl UdpWatcher {\n         }, 0);\n         let (addr, _len) = addr_to_sockaddr(address);\n         let result = unsafe {\n-            let addr_p = &addr as *libc::sockaddr_storage;\n-            uvll::uv_udp_bind(udp.handle, addr_p as *libc::sockaddr, 0u32)\n+            let addr_p = &addr as *const libc::sockaddr_storage;\n+            uvll::uv_udp_bind(udp.handle, addr_p as *const libc::sockaddr, 0u32)\n         };\n         return match result {\n             0 => Ok(udp),\n@@ -525,7 +525,7 @@ impl UdpWatcher {\n }\n \n impl UvHandle<uvll::uv_udp_t> for UdpWatcher {\n-    fn uv_handle(&self) -> *uvll::uv_udp_t { self.handle }\n+    fn uv_handle(&self) -> *mut uvll::uv_udp_t { self.handle }\n }\n \n impl HomingIO for UdpWatcher {\n@@ -558,7 +558,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                 };\n                 let handle = self.handle;\n                 wait_until_woken_after(&mut cx.task, &loop_, || {\n-                    unsafe { uvll::set_data_for_uv_handle(handle, &cx) }\n+                    unsafe { uvll::set_data_for_uv_handle(handle, &mut cx) }\n                 });\n                 match cx.result.take_unwrap() {\n                     (n, _) if n < 0 =>\n@@ -569,7 +569,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n             n => Err(uv_error_to_io_error(UvError(n)))\n         };\n \n-        extern fn alloc_cb(handle: *uvll::uv_udp_t,\n+        extern fn alloc_cb(handle: *mut uvll::uv_udp_t,\n                            _suggested_size: size_t,\n                            buf: *mut Buf) {\n             unsafe {\n@@ -579,8 +579,9 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n             }\n         }\n \n-        extern fn recv_cb(handle: *uvll::uv_udp_t, nread: ssize_t, buf: *Buf,\n-                          addr: *libc::sockaddr, _flags: c_uint) {\n+        extern fn recv_cb(handle: *mut uvll::uv_udp_t, nread: ssize_t,\n+                          buf: *const Buf,\n+                          addr: *const libc::sockaddr, _flags: c_uint) {\n             assert!(nread != uvll::ECANCELED as ssize_t);\n             let cx = unsafe {\n                 &mut *(uvll::get_data_for_uv_handle(handle) as *mut UdpRecvCtx)\n@@ -613,7 +614,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n \n         let mut req = Request::new(uvll::UV_UDP_SEND);\n         let (addr, _len) = addr_to_sockaddr(dst);\n-        let addr_p = &addr as *_ as *libc::sockaddr;\n+        let addr_p = &addr as *const _ as *const libc::sockaddr;\n \n         // see comments in StreamWatcher::write for why we may allocate a buffer\n         // here.\n@@ -633,7 +634,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                     result: uvll::ECANCELED, data: data, udp: self as *mut _\n                 };\n                 wait_until_woken_after(&mut self.blocked_sender, &loop_, || {\n-                    req.set_data(&cx);\n+                    req.set_data(&mut cx);\n                 });\n \n                 if cx.result != uvll::ECANCELED {\n@@ -642,13 +643,13 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                         n => Err(uv_error_to_io_error(UvError(n)))\n                     }\n                 }\n-                let new_cx = box UdpSendCtx {\n+                let mut new_cx = box UdpSendCtx {\n                     result: 0,\n                     udp: 0 as *mut UdpWatcher,\n                     data: cx.data.take(),\n                 };\n                 unsafe {\n-                    req.set_data(&*new_cx);\n+                    req.set_data(&mut *new_cx);\n                     mem::forget(new_cx);\n                 }\n                 Err(uv_error_to_io_error(UvError(cx.result)))\n@@ -658,7 +659,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n \n         // This function is the same as stream::write_cb, but adapted for udp\n         // instead of streams.\n-        extern fn send_cb(req: *uvll::uv_udp_send_t, status: c_int) {\n+        extern fn send_cb(req: *mut uvll::uv_udp_send_t, status: c_int) {\n             let req = Request::wrap(req);\n             let cx: &mut UdpSendCtx = unsafe { req.get_data() };\n             cx.result = status;\n@@ -766,12 +767,12 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n         fn cancel_read(stream: uint) -> Option<BlockedTask> {\n             // This method is quite similar to StreamWatcher::cancel_read, see\n             // there for more information\n-            let handle = stream as *uvll::uv_udp_t;\n+            let handle = stream as *mut uvll::uv_udp_t;\n             assert_eq!(unsafe { uvll::uv_udp_recv_stop(handle) }, 0);\n             let data = unsafe {\n                 let data = uvll::get_data_for_uv_handle(handle);\n                 if data.is_null() { return None }\n-                uvll::set_data_for_uv_handle(handle, 0 as *int);\n+                uvll::set_data_for_uv_handle(handle, 0 as *mut int);\n                 &mut *(data as *mut UdpRecvCtx)\n             };\n             data.result = Some((uvll::ECANCELED as ssize_t, None));\n@@ -806,7 +807,7 @@ impl Drop for UdpWatcher {\n // Shutdown helper\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub fn shutdown(handle: *uvll::uv_stream_t, loop_: &Loop) -> Result<(), IoError> {\n+pub fn shutdown(handle: *mut uvll::uv_stream_t, loop_: &Loop) -> Result<(), IoError> {\n     struct Ctx {\n         slot: Option<BlockedTask>,\n         status: c_int,\n@@ -819,15 +820,15 @@ pub fn shutdown(handle: *uvll::uv_stream_t, loop_: &Loop) -> Result<(), IoError>\n             let mut cx = Ctx { slot: None, status: 0 };\n \n             wait_until_woken_after(&mut cx.slot, loop_, || {\n-                req.set_data(&cx);\n+                req.set_data(&mut cx);\n             });\n \n             status_to_io_result(cx.status)\n         }\n         n => Err(uv_error_to_io_error(UvError(n)))\n     };\n \n-    extern fn shutdown_cb(req: *uvll::uv_shutdown_t, status: libc::c_int) {\n+    extern fn shutdown_cb(req: *mut uvll::uv_shutdown_t, status: libc::c_int) {\n         let req = Request::wrap(req);\n         assert!(status != uvll::ECANCELED);\n         let cx: &mut Ctx = unsafe { req.get_data() };"}, {"sha": "f14f81b0b6072af3c286d3f404cdfef6476c5046", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -37,7 +37,7 @@ pub struct PipeWatcher {\n \n pub struct PipeListener {\n     home: HomeHandle,\n-    pipe: *uvll::uv_pipe_t,\n+    pipe: *mut uvll::uv_pipe_t,\n     outgoing: Sender<IoResult<Box<rtio::RtioPipe + Send>>>,\n     incoming: Receiver<IoResult<Box<rtio::RtioPipe + Send>>>,\n }\n@@ -100,11 +100,11 @@ impl PipeWatcher {\n         })\n     }\n \n-    pub fn handle(&self) -> *uvll::uv_pipe_t { self.stream.handle }\n+    pub fn handle(&self) -> *mut uvll::uv_pipe_t { self.stream.handle }\n \n     // Unwraps the underlying uv pipe. This cancels destruction of the pipe and\n     // allows the pipe to get moved elsewhere\n-    fn unwrap(mut self) -> *uvll::uv_pipe_t {\n+    fn unwrap(mut self) -> *mut uvll::uv_pipe_t {\n         self.defused = true;\n         return self.stream.handle;\n     }\n@@ -181,7 +181,7 @@ impl rtio::RtioPipe for PipeWatcher {\n         let _m = self.fire_homing_missile();\n         let loop_ = self.uv_loop();\n         self.read_access.set_timeout(ms, &self.home, &loop_, cancel_read,\n-                                     &self.stream as *_ as uint);\n+                                     &self.stream as *const _ as uint);\n \n         fn cancel_read(stream: uint) -> Option<BlockedTask> {\n             let stream: &mut StreamWatcher = unsafe { mem::transmute(stream) };\n@@ -193,7 +193,7 @@ impl rtio::RtioPipe for PipeWatcher {\n         let _m = self.fire_homing_missile();\n         let loop_ = self.uv_loop();\n         self.write_access.set_timeout(ms, &self.home, &loop_, cancel_write,\n-                                      &self.stream as *_ as uint);\n+                                      &self.stream as *const _ as uint);\n \n         fn cancel_write(stream: uint) -> Option<BlockedTask> {\n             let stream: &mut StreamWatcher = unsafe { mem::transmute(stream) };\n@@ -207,7 +207,7 @@ impl HomingIO for PipeWatcher {\n }\n \n impl UvHandle<uvll::uv_pipe_t> for PipeWatcher {\n-    fn uv_handle(&self) -> *uvll::uv_pipe_t { self.stream.handle }\n+    fn uv_handle(&self) -> *mut uvll::uv_pipe_t { self.stream.handle }\n }\n \n impl Drop for PipeWatcher {\n@@ -269,10 +269,10 @@ impl HomingIO for PipeListener {\n }\n \n impl UvHandle<uvll::uv_pipe_t> for PipeListener {\n-    fn uv_handle(&self) -> *uvll::uv_pipe_t { self.pipe }\n+    fn uv_handle(&self) -> *mut uvll::uv_pipe_t { self.pipe }\n }\n \n-extern fn listen_cb(server: *uvll::uv_stream_t, status: libc::c_int) {\n+extern fn listen_cb(server: *mut uvll::uv_stream_t, status: libc::c_int) {\n     assert!(status != uvll::ECANCELED);\n \n     let pipe: &mut PipeListener = unsafe { UvHandle::from_uv_handle(&server) };"}, {"sha": "a341f04f567835a8d288dd41198db641d391148c", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -25,7 +25,7 @@ use uvio::UvIoFactory;\n use uvll;\n \n pub struct Process {\n-    handle: *uvll::uv_process_t,\n+    handle: *mut uvll::uv_process_t,\n     home: HomeHandle,\n \n     /// Task to wake up (may be null) for when the process exits\n@@ -60,8 +60,8 @@ impl Process {\n         let mut ret_io = Vec::with_capacity(io.len());\n         unsafe {\n             stdio.set_len(io.len());\n-            for (slot, other) in stdio.iter().zip(io.iter()) {\n-                let io = set_stdio(slot as *uvll::uv_stdio_container_t, other,\n+            for (slot, other) in stdio.mut_iter().zip(io.iter()) {\n+                let io = set_stdio(slot as *mut uvll::uv_stdio_container_t, other,\n                                    io_loop);\n                 ret_io.push(io);\n             }\n@@ -79,7 +79,7 @@ impl Process {\n                 if cfg.detach {\n                     flags |= uvll::PROCESS_DETACHED;\n                 }\n-                let options = uvll::uv_process_options_t {\n+                let mut options = uvll::uv_process_options_t {\n                     exit_cb: on_exit,\n                     file: unsafe { *argv },\n                     args: argv,\n@@ -90,7 +90,7 @@ impl Process {\n                     },\n                     flags: flags as libc::c_uint,\n                     stdio_count: stdio.len() as libc::c_int,\n-                    stdio: stdio.as_ptr(),\n+                    stdio: stdio.as_mut_ptr(),\n                     uid: cfg.uid.unwrap_or(0) as uvll::uv_uid_t,\n                     gid: cfg.gid.unwrap_or(0) as uvll::uv_gid_t,\n                 };\n@@ -105,7 +105,7 @@ impl Process {\n                     timeout_state: NoTimeout,\n                 };\n                 match unsafe {\n-                    uvll::uv_spawn(io_loop.uv_loop(), handle, &options)\n+                    uvll::uv_spawn(io_loop.uv_loop(), handle, &mut options)\n                 } {\n                     0 => Ok(process.install()),\n                     err => Err(UvError(err)),\n@@ -129,7 +129,7 @@ impl Process {\n     }\n }\n \n-extern fn on_exit(handle: *uvll::uv_process_t,\n+extern fn on_exit(handle: *mut uvll::uv_process_t,\n                   exit_status: i64,\n                   term_signal: libc::c_int) {\n     let p: &mut Process = unsafe { UvHandle::from_uv_handle(&handle) };\n@@ -144,7 +144,7 @@ extern fn on_exit(handle: *uvll::uv_process_t,\n     wakeup(&mut p.to_wake);\n }\n \n-unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,\n+unsafe fn set_stdio(dst: *mut uvll::uv_stdio_container_t,\n                     io: &rtio::StdioContainer,\n                     io_loop: &mut UvIoFactory) -> Option<PipeWatcher> {\n     match *io {\n@@ -174,8 +174,9 @@ unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,\n }\n \n /// Converts the program and arguments to the argv array expected by libuv.\n-fn with_argv<T>(prog: &CString, args: &[CString], cb: |**libc::c_char| -> T) -> T {\n-    let mut ptrs: Vec<*libc::c_char> = Vec::with_capacity(args.len()+1);\n+fn with_argv<T>(prog: &CString, args: &[CString],\n+                cb: |*const *const libc::c_char| -> T) -> T {\n+    let mut ptrs: Vec<*const libc::c_char> = Vec::with_capacity(args.len()+1);\n \n     // Convert the CStrings into an array of pointers. Note: the\n     // lifetime of the various CStrings involved is guaranteed to be\n@@ -192,7 +193,8 @@ fn with_argv<T>(prog: &CString, args: &[CString], cb: |**libc::c_char| -> T) ->\n }\n \n /// Converts the environment to the env array expected by libuv\n-fn with_env<T>(env: Option<&[(CString, CString)]>, cb: |**libc::c_char| -> T) -> T {\n+fn with_env<T>(env: Option<&[(CString, CString)]>,\n+               cb: |*const *const libc::c_char| -> T) -> T {\n     // We can pass a char** for envp, which is a null-terminated array\n     // of \"k=v\\0\" strings. Since we must create these strings locally,\n     // yet expose a raw pointer to them, we create a temporary vector\n@@ -210,9 +212,9 @@ fn with_env<T>(env: Option<&[(CString, CString)]>, cb: |**libc::c_char| -> T) ->\n             }\n \n             // As with `with_argv`, this is unsafe, since cb could leak the pointers.\n-            let mut ptrs: Vec<*libc::c_char> =\n+            let mut ptrs: Vec<*const libc::c_char> =\n                 tmps.iter()\n-                    .map(|tmp| tmp.as_ptr() as *libc::c_char)\n+                    .map(|tmp| tmp.as_ptr() as *const libc::c_char)\n                     .collect();\n             ptrs.push(ptr::null());\n \n@@ -227,7 +229,7 @@ impl HomingIO for Process {\n }\n \n impl UvHandle<uvll::uv_process_t> for Process {\n-    fn uv_handle(&self) -> *uvll::uv_process_t { self.handle }\n+    fn uv_handle(&self) -> *mut uvll::uv_process_t { self.handle }\n }\n \n impl rtio::RtioProcess for Process {\n@@ -290,7 +292,7 @@ impl rtio::RtioProcess for Process {\n             });\n             let mut timer = box TimerWatcher::new_home(&loop_, self.home().clone());\n             unsafe {\n-                timer.set_data(self as *mut _ as *Process);\n+                timer.set_data(self as *mut _);\n             }\n             self.timer = Some(timer);\n         }\n@@ -300,7 +302,7 @@ impl rtio::RtioProcess for Process {\n         timer.start(timer_cb, ms, 0);\n         self.timeout_state = TimeoutPending;\n \n-        extern fn timer_cb(timer: *uvll::uv_timer_t) {\n+        extern fn timer_cb(timer: *mut uvll::uv_timer_t) {\n             let p: &mut Process = unsafe {\n                 &mut *(uvll::get_data_for_uv_handle(timer) as *mut Process)\n             };"}, {"sha": "902e2b0bd192fec42d3329f8674d01bdece34290", "filename": "src/librustuv/queue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Fqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Fqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fqueue.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -38,7 +38,7 @@ enum Message {\n }\n \n struct State {\n-    handle: *uvll::uv_async_t,\n+    handle: *mut uvll::uv_async_t,\n     lock: NativeMutex, // see comments in async_cb for why this is needed\n     queue: mpsc::Queue<Message>,\n }\n@@ -55,7 +55,7 @@ pub struct Queue {\n     queue: Arc<State>,\n }\n \n-extern fn async_cb(handle: *uvll::uv_async_t) {\n+extern fn async_cb(handle: *mut uvll::uv_async_t) {\n     let pool: &mut QueuePool = unsafe {\n         mem::transmute(uvll::get_data_for_uv_handle(handle))\n     };\n@@ -114,15 +114,15 @@ impl QueuePool {\n             lock: unsafe {NativeMutex::new()},\n             queue: mpsc::Queue::new(),\n         });\n-        let q = box QueuePool {\n+        let mut q = box QueuePool {\n             refcnt: 0,\n             queue: state,\n         };\n \n         unsafe {\n             assert_eq!(uvll::uv_async_init(loop_.handle, handle, async_cb), 0);\n             uvll::uv_unref(handle);\n-            let data = &*q as *QueuePool as *c_void;\n+            let data = &mut *q as *mut QueuePool as *mut c_void;\n             uvll::set_data_for_uv_handle(handle, data);\n         }\n \n@@ -139,7 +139,7 @@ impl QueuePool {\n         Queue { queue: self.queue.clone() }\n     }\n \n-    pub fn handle(&self) -> *uvll::uv_async_t { self.queue.handle }\n+    pub fn handle(&self) -> *mut uvll::uv_async_t { self.queue.handle }\n }\n \n impl Queue {"}, {"sha": "49ef4e9a24bccad8f1ce42d507539e1c616b386b", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -17,7 +17,7 @@ use uvll;\n use uvio::UvIoFactory;\n \n pub struct SignalWatcher {\n-    handle: *uvll::uv_signal_t,\n+    handle: *mut uvll::uv_signal_t,\n     home: HomeHandle,\n \n     cb: Box<Callback + Send>,\n@@ -45,7 +45,7 @@ impl SignalWatcher {\n     }\n }\n \n-extern fn signal_cb(handle: *uvll::uv_signal_t, _signum: c_int) {\n+extern fn signal_cb(handle: *mut uvll::uv_signal_t, _signum: c_int) {\n     let s: &mut SignalWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n     let _ = s.cb.call();\n }\n@@ -55,7 +55,7 @@ impl HomingIO for SignalWatcher {\n }\n \n impl UvHandle<uvll::uv_signal_t> for SignalWatcher {\n-    fn uv_handle(&self) -> *uvll::uv_signal_t { self.handle }\n+    fn uv_handle(&self) -> *mut uvll::uv_signal_t { self.handle }\n }\n \n impl RtioSignal for SignalWatcher {}"}, {"sha": "f615e8287b3c7efb3b77daf3b07f3cd4f954c720", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -23,7 +23,7 @@ use uvll;\n // uv_stream_t instance, and all I/O operations assume that it's already located\n // on the appropriate scheduler.\n pub struct StreamWatcher {\n-    pub handle: *uvll::uv_stream_t,\n+    pub handle: *mut uvll::uv_stream_t,\n \n     // Cache the last used uv_write_t so we don't have to allocate a new one on\n     // every call to uv_write(). Ideally this would be a stack-allocated\n@@ -59,8 +59,8 @@ impl StreamWatcher {\n     // will be manipulated on each of the methods called on this watcher.\n     // Wrappers should ensure to always reset the field to an appropriate value\n     // if they rely on the field to perform an action.\n-    pub fn new(stream: *uvll::uv_stream_t) -> StreamWatcher {\n-        unsafe { uvll::set_data_for_uv_handle(stream, 0 as *int) }\n+    pub fn new(stream: *mut uvll::uv_stream_t) -> StreamWatcher {\n+        unsafe { uvll::set_data_for_uv_handle(stream, 0 as *mut int) }\n         StreamWatcher {\n             handle: stream,\n             last_write_req: None,\n@@ -85,7 +85,7 @@ impl StreamWatcher {\n         // we must be ready for this to happen (by setting the data in the uv\n         // handle). In theory this otherwise doesn't need to happen until after\n         // the read is succesfully started.\n-        unsafe { uvll::set_data_for_uv_handle(self.handle, &rcx) }\n+        unsafe { uvll::set_data_for_uv_handle(self.handle, &mut rcx) }\n \n         // Send off the read request, but don't block until we're sure that the\n         // read request is queued.\n@@ -103,7 +103,7 @@ impl StreamWatcher {\n             n => Err(UvError(n))\n         };\n         // Make sure a read cancellation sees that there's no pending read\n-        unsafe { uvll::set_data_for_uv_handle(self.handle, 0 as *int) }\n+        unsafe { uvll::set_data_for_uv_handle(self.handle, 0 as *mut int) }\n         return ret;\n     }\n \n@@ -115,7 +115,7 @@ impl StreamWatcher {\n         let data = unsafe {\n             let data = uvll::get_data_for_uv_handle(self.handle);\n             if data.is_null() { return None }\n-            uvll::set_data_for_uv_handle(self.handle, 0 as *int);\n+            uvll::set_data_for_uv_handle(self.handle, 0 as *mut int);\n             &mut *(data as *mut ReadContext)\n         };\n         data.result = reason;\n@@ -133,7 +133,7 @@ impl StreamWatcher {\n         let mut req = match self.last_write_req.take() {\n             Some(req) => req, None => Request::new(uvll::UV_WRITE),\n         };\n-        req.set_data(ptr::null::<()>());\n+        req.set_data(ptr::mut_null::<()>());\n \n         // And here's where timeouts get a little interesting. Currently, libuv\n         // does not support canceling an in-flight write request. Consequently,\n@@ -180,7 +180,7 @@ impl StreamWatcher {\n                 let loop_ = unsafe { uvll::get_loop_for_uv_handle(self.handle) };\n                 wait_until_woken_after(&mut self.blocked_writer,\n                                        &Loop::wrap(loop_), || {\n-                    req.set_data(&wcx);\n+                    req.set_data(&mut wcx);\n                 });\n \n                 if wcx.result != uvll::ECANCELED {\n@@ -205,13 +205,13 @@ impl StreamWatcher {\n                 // Note that we don't cache this write request back in the\n                 // stream watcher because we no longer have ownership of it, and\n                 // we never will.\n-                let new_wcx = box WriteContext {\n+                let mut new_wcx = box WriteContext {\n                     result: 0,\n                     stream: 0 as *mut StreamWatcher,\n                     data: wcx.data.take(),\n                 };\n                 unsafe {\n-                    req.set_data(&*new_wcx);\n+                    req.set_data(&mut *new_wcx);\n                     mem::forget(new_wcx);\n                 }\n                 Err(UvError(wcx.result))\n@@ -228,7 +228,7 @@ impl StreamWatcher {\n // This allocation callback expects to be invoked once and only once. It will\n // unwrap the buffer in the ReadContext stored in the stream and return it. This\n // will fail if it is called more than once.\n-extern fn alloc_cb(stream: *uvll::uv_stream_t, _hint: size_t, buf: *mut Buf) {\n+extern fn alloc_cb(stream: *mut uvll::uv_stream_t, _hint: size_t, buf: *mut Buf) {\n     uvdebug!(\"alloc_cb\");\n     unsafe {\n         let rcx: &mut ReadContext =\n@@ -239,7 +239,8 @@ extern fn alloc_cb(stream: *uvll::uv_stream_t, _hint: size_t, buf: *mut Buf) {\n \n // When a stream has read some data, we will always forcibly stop reading and\n // return all the data read (even if it didn't fill the whole buffer).\n-extern fn read_cb(handle: *uvll::uv_stream_t, nread: ssize_t, _buf: *Buf) {\n+extern fn read_cb(handle: *mut uvll::uv_stream_t, nread: ssize_t,\n+                  _buf: *const Buf) {\n     uvdebug!(\"read_cb {}\", nread);\n     assert!(nread != uvll::ECANCELED as ssize_t);\n     let rcx: &mut ReadContext = unsafe {\n@@ -258,7 +259,7 @@ extern fn read_cb(handle: *uvll::uv_stream_t, nread: ssize_t, _buf: *Buf) {\n // Unlike reading, the WriteContext is stored in the uv_write_t request. Like\n // reading, however, all this does is wake up the blocked task after squirreling\n // away the error code as a result.\n-extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n+extern fn write_cb(req: *mut uvll::uv_write_t, status: c_int) {\n     let mut req = Request::wrap(req);\n     // Remember to not free the request because it is re-used between writes on\n     // the same stream."}, {"sha": "1caaf5e0fc75dd04059388e6949be83be6531e22", "filename": "src/librustuv/timeout.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Ftimeout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Ftimeout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimeout.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -119,13 +119,13 @@ impl AccessTimeout {\n         // to fire when the timeout runs out.\n         if self.timer.is_none() {\n             let mut timer = box TimerWatcher::new_home(loop_, home.clone());\n-            let cx = box TimerContext {\n+            let mut cx = box TimerContext {\n                 timeout: self as *mut _,\n                 callback: cb,\n                 payload: data,\n             };\n             unsafe {\n-                timer.set_data(&*cx);\n+                timer.set_data(&mut *cx);\n                 mem::forget(cx);\n             }\n             self.timer = Some(timer);\n@@ -142,9 +142,9 @@ impl AccessTimeout {\n         timer.start(timer_cb, ms, 0);\n         self.state = TimeoutPending(NoWaiter);\n \n-        extern fn timer_cb(timer: *uvll::uv_timer_t) {\n+        extern fn timer_cb(timer: *mut uvll::uv_timer_t) {\n             let cx: &TimerContext = unsafe {\n-                &*(uvll::get_data_for_uv_handle(timer) as *TimerContext)\n+                &*(uvll::get_data_for_uv_handle(timer) as *const TimerContext)\n             };\n             let me = unsafe { &mut *cx.timeout };\n \n@@ -240,7 +240,7 @@ impl ConnectCtx {\n                     None => {}\n                 }\n                 wait_until_woken_after(&mut self.task, &io.loop_, || {\n-                    let data = &self as *_;\n+                    let data = &self as *const _ as *mut ConnectCtx;\n                     match self.timer {\n                         Some(ref mut timer) => unsafe { timer.set_data(data) },\n                         None => {}\n@@ -249,7 +249,7 @@ impl ConnectCtx {\n                 });\n                 // Make sure an erroneously fired callback doesn't have access\n                 // to the context any more.\n-                req.set_data(0 as *int);\n+                req.set_data(0 as *mut int);\n \n                 // If we failed because of a timeout, drop the TcpWatcher as\n                 // soon as possible because it's data is now set to null and we\n@@ -262,7 +262,7 @@ impl ConnectCtx {\n             n => Err(UvError(n))\n         };\n \n-        extern fn timer_cb(handle: *uvll::uv_timer_t) {\n+        extern fn timer_cb(handle: *mut uvll::uv_timer_t) {\n             // Don't close the corresponding tcp request, just wake up the task\n             // and let RAII take care of the pending watcher.\n             let cx: &mut ConnectCtx = unsafe {\n@@ -272,7 +272,7 @@ impl ConnectCtx {\n             wakeup(&mut cx.task);\n         }\n \n-        extern fn connect_cb(req: *uvll::uv_connect_t, status: c_int) {\n+        extern fn connect_cb(req: *mut uvll::uv_connect_t, status: c_int) {\n             // This callback can be invoked with ECANCELED if the watcher is\n             // closed by the timeout callback. In that case we just want to free\n             // the request and be along our merry way.\n@@ -367,7 +367,7 @@ impl AcceptTimeout {\n             });\n             let mut timer = TimerWatcher::new_home(&loop_, t.home().clone());\n             unsafe {\n-                timer.set_data(self as *mut _ as *AcceptTimeout);\n+                timer.set_data(self as *mut _);\n             }\n             self.timer = Some(timer);\n         }\n@@ -381,7 +381,7 @@ impl AcceptTimeout {\n         self.timeout_tx = Some(tx);\n         self.timeout_rx = Some(rx);\n \n-        extern fn timer_cb(timer: *uvll::uv_timer_t) {\n+        extern fn timer_cb(timer: *mut uvll::uv_timer_t) {\n             let acceptor: &mut AcceptTimeout = unsafe {\n                 &mut *(uvll::get_data_for_uv_handle(timer) as *mut AcceptTimeout)\n             };"}, {"sha": "9d0a56b3c851d69d82f15e3cdf4ab10a0278739b", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -18,7 +18,7 @@ use uvio::UvIoFactory;\n use uvll;\n \n pub struct TimerWatcher {\n-    pub handle: *uvll::uv_timer_t,\n+    pub handle: *mut uvll::uv_timer_t,\n     home: HomeHandle,\n     action: Option<NextAction>,\n     blocker: Option<BlockedTask>,\n@@ -60,7 +60,7 @@ impl TimerWatcher {\n         assert_eq!(unsafe { uvll::uv_timer_stop(self.handle) }, 0)\n     }\n \n-    pub unsafe fn set_data<T>(&mut self, data: *T) {\n+    pub unsafe fn set_data<T>(&mut self, data: *mut T) {\n         uvll::set_data_for_uv_handle(self.handle, data);\n     }\n }\n@@ -70,7 +70,7 @@ impl HomingIO for TimerWatcher {\n }\n \n impl UvHandle<uvll::uv_timer_t> for TimerWatcher {\n-    fn uv_handle(&self) -> *uvll::uv_timer_t { self.handle }\n+    fn uv_handle(&self) -> *mut uvll::uv_timer_t { self.handle }\n }\n \n impl RtioTimer for TimerWatcher {\n@@ -128,7 +128,7 @@ impl RtioTimer for TimerWatcher {\n     }\n }\n \n-extern fn timer_cb(handle: *uvll::uv_timer_t) {\n+extern fn timer_cb(handle: *mut uvll::uv_timer_t) {\n     let _f = ForbidSwitch::new(\"timer callback can't switch\");\n     let timer: &mut TimerWatcher = unsafe { UvHandle::from_uv_handle(&handle) };\n "}, {"sha": "85ec0c75d53c8cd270a0fd9ef63005bbf08894c1", "filename": "src/librustuv/tty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftty.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -19,7 +19,7 @@ use uvio::UvIoFactory;\n use uvll;\n \n pub struct TtyWatcher{\n-    tty: *uvll::uv_tty_t,\n+    tty: *mut uvll::uv_tty_t,\n     stream: StreamWatcher,\n     home: HomeHandle,\n     fd: libc::c_int,\n@@ -70,7 +70,7 @@ impl TtyWatcher {\n                 // handle, so our only cleanup is to free the handle itself\n                 if cfg!(windows) {\n                     unsafe { uvll::free_handle(handle); }\n-                    watcher.tty = ptr::null();\n+                    watcher.tty = ptr::mut_null();\n                 }\n                 Err(UvError(n))\n             }\n@@ -102,8 +102,8 @@ impl RtioTTY for TtyWatcher {\n     fn get_winsize(&mut self) -> IoResult<(int, int)> {\n         let mut width: libc::c_int = 0;\n         let mut height: libc::c_int = 0;\n-        let widthptr: *libc::c_int = &width;\n-        let heightptr: *libc::c_int = &width;\n+        let widthptr: *mut libc::c_int = &mut width;\n+        let heightptr: *mut libc::c_int = &mut width;\n \n         let _m = self.fire_homing_missile();\n         match unsafe { uvll::uv_tty_get_winsize(self.tty,\n@@ -119,7 +119,7 @@ impl RtioTTY for TtyWatcher {\n }\n \n impl UvHandle<uvll::uv_tty_t> for TtyWatcher {\n-    fn uv_handle(&self) -> *uvll::uv_tty_t { self.tty }\n+    fn uv_handle(&self) -> *mut uvll::uv_tty_t { self.tty }\n }\n \n impl HomingIO for TtyWatcher {"}, {"sha": "61e52a3abd19cc0e11e2ad50d321c1ad5cc63593", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -126,7 +126,7 @@ pub struct UvIoFactory {\n }\n \n impl UvIoFactory {\n-    pub fn uv_loop<'a>(&mut self) -> *uvll::uv_loop_t { self.loop_.handle }\n+    pub fn uv_loop<'a>(&mut self) -> *mut uvll::uv_loop_t { self.loop_.handle }\n \n     pub fn make_handle(&mut self) -> HomeHandle {\n         // It's understood by the homing code that the \"local id\" is just the"}, {"sha": "863536a4111018c2d6919b96b3b8f64dfa058743", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 201, "deletions": 190, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -103,15 +103,15 @@ pub type uv_buf_len_t = libc::c_ulong;\n // see libuv/include/uv-unix.h\n #[cfg(unix)]\n pub struct uv_buf_t {\n-    pub base: *u8,\n+    pub base: *mut u8,\n     pub len: uv_buf_len_t,\n }\n \n // see libuv/include/uv-win.h\n #[cfg(windows)]\n pub struct uv_buf_t {\n     pub len: uv_buf_len_t,\n-    pub base: *u8,\n+    pub base: *mut u8,\n }\n \n #[repr(C)]\n@@ -123,13 +123,13 @@ pub enum uv_run_mode {\n \n pub struct uv_process_options_t {\n     pub exit_cb: uv_exit_cb,\n-    pub file: *libc::c_char,\n-    pub args: **libc::c_char,\n-    pub env: **libc::c_char,\n-    pub cwd: *libc::c_char,\n+    pub file: *const libc::c_char,\n+    pub args: *const *const libc::c_char,\n+    pub env: *const *const libc::c_char,\n+    pub cwd: *const libc::c_char,\n     pub flags: libc::c_uint,\n     pub stdio_count: libc::c_int,\n-    pub stdio: *uv_stdio_container_t,\n+    pub stdio: *mut uv_stdio_container_t,\n     pub uid: uv_uid_t,\n     pub gid: uv_gid_t,\n }\n@@ -139,7 +139,7 @@ pub struct uv_process_options_t {\n #[repr(C)]\n pub struct uv_stdio_container_t {\n     flags: libc::c_int,\n-    stream: *uv_stream_t,\n+    stream: *mut uv_stream_t,\n }\n \n pub type uv_handle_t = c_void;\n@@ -216,41 +216,41 @@ impl uv_stat_t {\n     }\n }\n \n-pub type uv_idle_cb = extern \"C\" fn(handle: *uv_idle_t);\n-pub type uv_alloc_cb = extern \"C\" fn(stream: *uv_stream_t,\n+pub type uv_idle_cb = extern \"C\" fn(handle: *mut uv_idle_t);\n+pub type uv_alloc_cb = extern \"C\" fn(stream: *mut uv_stream_t,\n                                      suggested_size: size_t,\n                                      buf: *mut uv_buf_t);\n-pub type uv_read_cb = extern \"C\" fn(stream: *uv_stream_t,\n+pub type uv_read_cb = extern \"C\" fn(stream: *mut uv_stream_t,\n                                     nread: ssize_t,\n-                                    buf: *uv_buf_t);\n-pub type uv_udp_send_cb = extern \"C\" fn(req: *uv_udp_send_t,\n+                                    buf: *const uv_buf_t);\n+pub type uv_udp_send_cb = extern \"C\" fn(req: *mut uv_udp_send_t,\n                                         status: c_int);\n-pub type uv_udp_recv_cb = extern \"C\" fn(handle: *uv_udp_t,\n+pub type uv_udp_recv_cb = extern \"C\" fn(handle: *mut uv_udp_t,\n                                         nread: ssize_t,\n-                                        buf: *uv_buf_t,\n-                                        addr: *sockaddr,\n+                                        buf: *const uv_buf_t,\n+                                        addr: *const sockaddr,\n                                         flags: c_uint);\n-pub type uv_close_cb = extern \"C\" fn(handle: *uv_handle_t);\n-pub type uv_walk_cb = extern \"C\" fn(handle: *uv_handle_t,\n-                                    arg: *c_void);\n-pub type uv_async_cb = extern \"C\" fn(handle: *uv_async_t);\n-pub type uv_connect_cb = extern \"C\" fn(handle: *uv_connect_t,\n+pub type uv_close_cb = extern \"C\" fn(handle: *mut uv_handle_t);\n+pub type uv_walk_cb = extern \"C\" fn(handle: *mut uv_handle_t,\n+                                    arg: *mut c_void);\n+pub type uv_async_cb = extern \"C\" fn(handle: *mut uv_async_t);\n+pub type uv_connect_cb = extern \"C\" fn(handle: *mut uv_connect_t,\n                                        status: c_int);\n-pub type uv_connection_cb = extern \"C\" fn(handle: *uv_connection_t,\n+pub type uv_connection_cb = extern \"C\" fn(handle: *mut uv_connection_t,\n                                           status: c_int);\n-pub type uv_timer_cb = extern \"C\" fn(handle: *uv_timer_t);\n-pub type uv_write_cb = extern \"C\" fn(handle: *uv_write_t,\n+pub type uv_timer_cb = extern \"C\" fn(handle: *mut uv_timer_t);\n+pub type uv_write_cb = extern \"C\" fn(handle: *mut uv_write_t,\n                                      status: c_int);\n-pub type uv_getaddrinfo_cb = extern \"C\" fn(req: *uv_getaddrinfo_t,\n+pub type uv_getaddrinfo_cb = extern \"C\" fn(req: *mut uv_getaddrinfo_t,\n                                            status: c_int,\n-                                           res: *addrinfo);\n-pub type uv_exit_cb = extern \"C\" fn(handle: *uv_process_t,\n+                                           res: *const addrinfo);\n+pub type uv_exit_cb = extern \"C\" fn(handle: *mut uv_process_t,\n                                     exit_status: i64,\n                                     term_signal: c_int);\n-pub type uv_signal_cb = extern \"C\" fn(handle: *uv_signal_t,\n+pub type uv_signal_cb = extern \"C\" fn(handle: *mut uv_signal_t,\n                                       signum: c_int);\n-pub type uv_fs_cb = extern \"C\" fn(req: *uv_fs_t);\n-pub type uv_shutdown_cb = extern \"C\" fn(req: *uv_shutdown_t, status: c_int);\n+pub type uv_fs_cb = extern \"C\" fn(req: *mut uv_fs_t);\n+pub type uv_shutdown_cb = extern \"C\" fn(req: *mut uv_shutdown_t, status: c_int);\n \n #[cfg(unix)] pub type uv_uid_t = libc::types::os::arch::posix88::uid_t;\n #[cfg(unix)] pub type uv_gid_t = libc::types::os::arch::posix88::gid_t;\n@@ -330,23 +330,23 @@ pub enum uv_membership {\n     UV_JOIN_GROUP\n }\n \n-pub unsafe fn malloc_handle(handle: uv_handle_type) -> *c_void {\n+pub unsafe fn malloc_handle(handle: uv_handle_type) -> *mut c_void {\n     assert!(handle != UV_UNKNOWN_HANDLE && handle != UV_HANDLE_TYPE_MAX);\n     let size = uv_handle_size(handle);\n-    malloc_raw(size as uint) as *c_void\n+    malloc_raw(size as uint) as *mut c_void\n }\n \n-pub unsafe fn free_handle(v: *c_void) {\n+pub unsafe fn free_handle(v: *mut c_void) {\n     free(v as *mut c_void)\n }\n \n-pub unsafe fn malloc_req(req: uv_req_type) -> *c_void {\n+pub unsafe fn malloc_req(req: uv_req_type) -> *mut c_void {\n     assert!(req != UV_UNKNOWN_REQ && req != UV_REQ_TYPE_MAX);\n     let size = uv_req_size(req);\n-    malloc_raw(size as uint) as *c_void\n+    malloc_raw(size as uint) as *mut c_void\n }\n \n-pub unsafe fn free_req(v: *c_void) {\n+pub unsafe fn free_req(v: *mut c_void) {\n     free(v as *mut c_void)\n }\n \n@@ -365,17 +365,17 @@ fn request_sanity_check() {\n }\n \n // FIXME Event loops ignore SIGPIPE by default.\n-pub unsafe fn loop_new() -> *c_void {\n+pub unsafe fn loop_new() -> *mut c_void {\n     return rust_uv_loop_new();\n }\n \n-pub unsafe fn uv_write(req: *uv_write_t,\n-                       stream: *uv_stream_t,\n+pub unsafe fn uv_write(req: *mut uv_write_t,\n+                       stream: *mut uv_stream_t,\n                        buf_in: &[uv_buf_t],\n                        cb: uv_write_cb) -> c_int {\n     extern {\n-        fn uv_write(req: *uv_write_t, stream: *uv_stream_t,\n-                    buf_in: *uv_buf_t, buf_cnt: c_int,\n+        fn uv_write(req: *mut uv_write_t, stream: *mut uv_stream_t,\n+                    buf_in: *const uv_buf_t, buf_cnt: c_int,\n                     cb: uv_write_cb) -> c_int;\n     }\n \n@@ -384,14 +384,15 @@ pub unsafe fn uv_write(req: *uv_write_t,\n     return uv_write(req, stream, buf_ptr, buf_cnt, cb);\n }\n \n-pub unsafe fn uv_udp_send(req: *uv_udp_send_t,\n-                          handle: *uv_udp_t,\n+pub unsafe fn uv_udp_send(req: *mut uv_udp_send_t,\n+                          handle: *mut uv_udp_t,\n                           buf_in: &[uv_buf_t],\n-                          addr: *sockaddr,\n+                          addr: *const sockaddr,\n                           cb: uv_udp_send_cb) -> c_int {\n     extern {\n-        fn uv_udp_send(req: *uv_write_t, stream: *uv_stream_t,\n-                       buf_in: *uv_buf_t, buf_cnt: c_int, addr: *sockaddr,\n+        fn uv_udp_send(req: *mut uv_write_t, stream: *mut uv_stream_t,\n+                       buf_in: *const uv_buf_t, buf_cnt: c_int,\n+                       addr: *const sockaddr,\n                        cb: uv_udp_send_cb) -> c_int;\n     }\n \n@@ -400,76 +401,76 @@ pub unsafe fn uv_udp_send(req: *uv_udp_send_t,\n     return uv_udp_send(req, handle, buf_ptr, buf_cnt, addr, cb);\n }\n \n-pub unsafe fn get_udp_handle_from_send_req(send_req: *uv_udp_send_t) -> *uv_udp_t {\n+pub unsafe fn get_udp_handle_from_send_req(send_req: *mut uv_udp_send_t) -> *mut uv_udp_t {\n     return rust_uv_get_udp_handle_from_send_req(send_req);\n }\n \n-pub unsafe fn process_pid(p: *uv_process_t) -> c_int {\n+pub unsafe fn process_pid(p: *mut uv_process_t) -> c_int {\n \n     return rust_uv_process_pid(p);\n }\n \n-pub unsafe fn set_stdio_container_flags(c: *uv_stdio_container_t,\n+pub unsafe fn set_stdio_container_flags(c: *mut uv_stdio_container_t,\n                                         flags: libc::c_int) {\n \n     rust_set_stdio_container_flags(c, flags);\n }\n \n-pub unsafe fn set_stdio_container_fd(c: *uv_stdio_container_t,\n+pub unsafe fn set_stdio_container_fd(c: *mut uv_stdio_container_t,\n                                      fd: libc::c_int) {\n \n     rust_set_stdio_container_fd(c, fd);\n }\n \n-pub unsafe fn set_stdio_container_stream(c: *uv_stdio_container_t,\n-                                         stream: *uv_stream_t) {\n+pub unsafe fn set_stdio_container_stream(c: *mut uv_stdio_container_t,\n+                                         stream: *mut uv_stream_t) {\n     rust_set_stdio_container_stream(c, stream);\n }\n \n // data access helpers\n-pub unsafe fn get_result_from_fs_req(req: *uv_fs_t) -> ssize_t {\n+pub unsafe fn get_result_from_fs_req(req: *mut uv_fs_t) -> ssize_t {\n     rust_uv_get_result_from_fs_req(req)\n }\n-pub unsafe fn get_ptr_from_fs_req(req: *uv_fs_t) -> *libc::c_void {\n+pub unsafe fn get_ptr_from_fs_req(req: *mut uv_fs_t) -> *mut libc::c_void {\n     rust_uv_get_ptr_from_fs_req(req)\n }\n-pub unsafe fn get_path_from_fs_req(req: *uv_fs_t) -> *c_char {\n+pub unsafe fn get_path_from_fs_req(req: *mut uv_fs_t) -> *mut c_char {\n     rust_uv_get_path_from_fs_req(req)\n }\n-pub unsafe fn get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t {\n+pub unsafe fn get_loop_from_fs_req(req: *mut uv_fs_t) -> *mut uv_loop_t {\n     rust_uv_get_loop_from_fs_req(req)\n }\n-pub unsafe fn get_loop_from_getaddrinfo_req(req: *uv_getaddrinfo_t) -> *uv_loop_t {\n+pub unsafe fn get_loop_from_getaddrinfo_req(req: *mut uv_getaddrinfo_t) -> *mut uv_loop_t {\n     rust_uv_get_loop_from_getaddrinfo_req(req)\n }\n-pub unsafe fn get_loop_for_uv_handle<T>(handle: *T) -> *c_void {\n-    return rust_uv_get_loop_for_uv_handle(handle as *c_void);\n+pub unsafe fn get_loop_for_uv_handle<T>(handle: *mut T) -> *mut c_void {\n+    return rust_uv_get_loop_for_uv_handle(handle as *mut c_void);\n }\n-pub unsafe fn get_stream_handle_from_connect_req(connect: *uv_connect_t) -> *uv_stream_t {\n+pub unsafe fn get_stream_handle_from_connect_req(connect: *mut uv_connect_t) -> *mut uv_stream_t {\n     return rust_uv_get_stream_handle_from_connect_req(connect);\n }\n-pub unsafe fn get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t {\n+pub unsafe fn get_stream_handle_from_write_req(write_req: *mut uv_write_t) -> *mut uv_stream_t {\n     return rust_uv_get_stream_handle_from_write_req(write_req);\n }\n-pub unsafe fn get_data_for_uv_loop(loop_ptr: *c_void) -> *c_void {\n+pub unsafe fn get_data_for_uv_loop(loop_ptr: *mut c_void) -> *mut c_void {\n     rust_uv_get_data_for_uv_loop(loop_ptr)\n }\n-pub unsafe fn set_data_for_uv_loop(loop_ptr: *c_void, data: *c_void) {\n+pub unsafe fn set_data_for_uv_loop(loop_ptr: *mut c_void, data: *mut c_void) {\n     rust_uv_set_data_for_uv_loop(loop_ptr, data);\n }\n-pub unsafe fn get_data_for_uv_handle<T>(handle: *T) -> *c_void {\n-    return rust_uv_get_data_for_uv_handle(handle as *c_void);\n+pub unsafe fn get_data_for_uv_handle<T>(handle: *mut T) -> *mut c_void {\n+    return rust_uv_get_data_for_uv_handle(handle as *mut c_void);\n }\n-pub unsafe fn set_data_for_uv_handle<T, U>(handle: *T, data: *U) {\n-    rust_uv_set_data_for_uv_handle(handle as *c_void, data as *c_void);\n+pub unsafe fn set_data_for_uv_handle<T, U>(handle: *mut T, data: *mut U) {\n+    rust_uv_set_data_for_uv_handle(handle as *mut c_void, data as *mut c_void);\n }\n-pub unsafe fn get_data_for_req<T>(req: *T) -> *c_void {\n-    return rust_uv_get_data_for_req(req as *c_void);\n+pub unsafe fn get_data_for_req<T>(req: *mut T) -> *mut c_void {\n+    return rust_uv_get_data_for_req(req as *mut c_void);\n }\n-pub unsafe fn set_data_for_req<T, U>(req: *T, data: *U) {\n-    rust_uv_set_data_for_req(req as *c_void, data as *c_void);\n+pub unsafe fn set_data_for_req<T, U>(req: *mut T, data: *mut U) {\n+    rust_uv_set_data_for_req(req as *mut c_void, data as *mut c_void);\n }\n-pub unsafe fn populate_stat(req_in: *uv_fs_t, stat_out: *uv_stat_t) {\n+pub unsafe fn populate_stat(req_in: *mut uv_fs_t, stat_out: *mut uv_stat_t) {\n     rust_uv_populate_uv_stat(req_in, stat_out)\n }\n pub unsafe fn guess_handle(handle: c_int) -> c_int {\n@@ -493,186 +494,196 @@ pub unsafe fn guess_handle(handle: c_int) -> c_int {\n extern {}\n \n extern {\n-    fn rust_uv_loop_new() -> *c_void;\n+    fn rust_uv_loop_new() -> *mut c_void;\n \n     #[cfg(test)]\n     fn rust_uv_handle_type_max() -> uintptr_t;\n     #[cfg(test)]\n     fn rust_uv_req_type_max() -> uintptr_t;\n-    fn rust_uv_get_udp_handle_from_send_req(req: *uv_udp_send_t) -> *uv_udp_t;\n-\n-    fn rust_uv_populate_uv_stat(req_in: *uv_fs_t, stat_out: *uv_stat_t);\n-    fn rust_uv_get_result_from_fs_req(req: *uv_fs_t) -> ssize_t;\n-    fn rust_uv_get_ptr_from_fs_req(req: *uv_fs_t) -> *libc::c_void;\n-    fn rust_uv_get_path_from_fs_req(req: *uv_fs_t) -> *c_char;\n-    fn rust_uv_get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t;\n-    fn rust_uv_get_loop_from_getaddrinfo_req(req: *uv_fs_t) -> *uv_loop_t;\n-    fn rust_uv_get_stream_handle_from_connect_req(req: *uv_connect_t) -> *uv_stream_t;\n-    fn rust_uv_get_stream_handle_from_write_req(req: *uv_write_t) -> *uv_stream_t;\n-    fn rust_uv_get_loop_for_uv_handle(handle: *c_void) -> *c_void;\n-    fn rust_uv_get_data_for_uv_loop(loop_ptr: *c_void) -> *c_void;\n-    fn rust_uv_set_data_for_uv_loop(loop_ptr: *c_void, data: *c_void);\n-    fn rust_uv_get_data_for_uv_handle(handle: *c_void) -> *c_void;\n-    fn rust_uv_set_data_for_uv_handle(handle: *c_void, data: *c_void);\n-    fn rust_uv_get_data_for_req(req: *c_void) -> *c_void;\n-    fn rust_uv_set_data_for_req(req: *c_void, data: *c_void);\n-    fn rust_set_stdio_container_flags(c: *uv_stdio_container_t, flags: c_int);\n-    fn rust_set_stdio_container_fd(c: *uv_stdio_container_t, fd: c_int);\n-    fn rust_set_stdio_container_stream(c: *uv_stdio_container_t,\n-                                       stream: *uv_stream_t);\n-    fn rust_uv_process_pid(p: *uv_process_t) -> c_int;\n+    fn rust_uv_get_udp_handle_from_send_req(req: *mut uv_udp_send_t) -> *mut uv_udp_t;\n+\n+    fn rust_uv_populate_uv_stat(req_in: *mut uv_fs_t, stat_out: *mut uv_stat_t);\n+    fn rust_uv_get_result_from_fs_req(req: *mut uv_fs_t) -> ssize_t;\n+    fn rust_uv_get_ptr_from_fs_req(req: *mut uv_fs_t) -> *mut libc::c_void;\n+    fn rust_uv_get_path_from_fs_req(req: *mut uv_fs_t) -> *mut c_char;\n+    fn rust_uv_get_loop_from_fs_req(req: *mut uv_fs_t) -> *mut uv_loop_t;\n+    fn rust_uv_get_loop_from_getaddrinfo_req(req: *mut uv_fs_t) -> *mut uv_loop_t;\n+    fn rust_uv_get_stream_handle_from_connect_req(req: *mut uv_connect_t) -> *mut uv_stream_t;\n+    fn rust_uv_get_stream_handle_from_write_req(req: *mut uv_write_t) -> *mut uv_stream_t;\n+    fn rust_uv_get_loop_for_uv_handle(handle: *mut c_void) -> *mut c_void;\n+    fn rust_uv_get_data_for_uv_loop(loop_ptr: *mut c_void) -> *mut c_void;\n+    fn rust_uv_set_data_for_uv_loop(loop_ptr: *mut c_void, data: *mut c_void);\n+    fn rust_uv_get_data_for_uv_handle(handle: *mut c_void) -> *mut c_void;\n+    fn rust_uv_set_data_for_uv_handle(handle: *mut c_void, data: *mut c_void);\n+    fn rust_uv_get_data_for_req(req: *mut c_void) -> *mut c_void;\n+    fn rust_uv_set_data_for_req(req: *mut c_void, data: *mut c_void);\n+    fn rust_set_stdio_container_flags(c: *mut uv_stdio_container_t, flags: c_int);\n+    fn rust_set_stdio_container_fd(c: *mut uv_stdio_container_t, fd: c_int);\n+    fn rust_set_stdio_container_stream(c: *mut uv_stdio_container_t,\n+                                       stream: *mut uv_stream_t);\n+    fn rust_uv_process_pid(p: *mut uv_process_t) -> c_int;\n     fn rust_uv_guess_handle(fd: c_int) -> c_int;\n \n     // generic uv functions\n-    pub fn uv_loop_delete(l: *uv_loop_t);\n-    pub fn uv_ref(t: *uv_handle_t);\n-    pub fn uv_unref(t: *uv_handle_t);\n+    pub fn uv_loop_delete(l: *mut uv_loop_t);\n+    pub fn uv_ref(t: *mut uv_handle_t);\n+    pub fn uv_unref(t: *mut uv_handle_t);\n     pub fn uv_handle_size(ty: uv_handle_type) -> size_t;\n     pub fn uv_req_size(ty: uv_req_type) -> size_t;\n-    pub fn uv_run(l: *uv_loop_t, mode: uv_run_mode) -> c_int;\n-    pub fn uv_close(h: *uv_handle_t, cb: uv_close_cb);\n-    pub fn uv_walk(l: *uv_loop_t, cb: uv_walk_cb, arg: *c_void);\n-    pub fn uv_buf_init(base: *c_char, len: c_uint) -> uv_buf_t;\n-    pub fn uv_strerror(err: c_int) -> *c_char;\n-    pub fn uv_err_name(err: c_int) -> *c_char;\n-    pub fn uv_listen(s: *uv_stream_t, backlog: c_int,\n+    pub fn uv_run(l: *mut uv_loop_t, mode: uv_run_mode) -> c_int;\n+    pub fn uv_close(h: *mut uv_handle_t, cb: uv_close_cb);\n+    pub fn uv_walk(l: *mut uv_loop_t, cb: uv_walk_cb, arg: *mut c_void);\n+    pub fn uv_buf_init(base: *mut c_char, len: c_uint) -> uv_buf_t;\n+    pub fn uv_strerror(err: c_int) -> *const c_char;\n+    pub fn uv_err_name(err: c_int) -> *const c_char;\n+    pub fn uv_listen(s: *mut uv_stream_t, backlog: c_int,\n                      cb: uv_connection_cb) -> c_int;\n-    pub fn uv_accept(server: *uv_stream_t, client: *uv_stream_t) -> c_int;\n-    pub fn uv_read_start(stream: *uv_stream_t,\n+    pub fn uv_accept(server: *mut uv_stream_t, client: *mut uv_stream_t) -> c_int;\n+    pub fn uv_read_start(stream: *mut uv_stream_t,\n                          on_alloc: uv_alloc_cb,\n                          on_read: uv_read_cb) -> c_int;\n-    pub fn uv_read_stop(stream: *uv_stream_t) -> c_int;\n-    pub fn uv_shutdown(req: *uv_shutdown_t, handle: *uv_stream_t,\n+    pub fn uv_read_stop(stream: *mut uv_stream_t) -> c_int;\n+    pub fn uv_shutdown(req: *mut uv_shutdown_t, handle: *mut uv_stream_t,\n                        cb: uv_shutdown_cb) -> c_int;\n \n     // idle bindings\n-    pub fn uv_idle_init(l: *uv_loop_t, i: *uv_idle_t) -> c_int;\n-    pub fn uv_idle_start(i: *uv_idle_t, cb: uv_idle_cb) -> c_int;\n-    pub fn uv_idle_stop(i: *uv_idle_t) -> c_int;\n+    pub fn uv_idle_init(l: *mut uv_loop_t, i: *mut uv_idle_t) -> c_int;\n+    pub fn uv_idle_start(i: *mut uv_idle_t, cb: uv_idle_cb) -> c_int;\n+    pub fn uv_idle_stop(i: *mut uv_idle_t) -> c_int;\n \n     // async bindings\n-    pub fn uv_async_init(l: *uv_loop_t, a: *uv_async_t,\n+    pub fn uv_async_init(l: *mut uv_loop_t, a: *mut uv_async_t,\n                          cb: uv_async_cb) -> c_int;\n-    pub fn uv_async_send(a: *uv_async_t);\n+    pub fn uv_async_send(a: *mut uv_async_t);\n \n     // tcp bindings\n-    pub fn uv_tcp_init(l: *uv_loop_t, h: *uv_tcp_t) -> c_int;\n-    pub fn uv_tcp_connect(c: *uv_connect_t, h: *uv_tcp_t,\n-                          addr: *sockaddr, cb: uv_connect_cb) -> c_int;\n-    pub fn uv_tcp_bind(t: *uv_tcp_t, addr: *sockaddr) -> c_int;\n-    pub fn uv_tcp_nodelay(h: *uv_tcp_t, enable: c_int) -> c_int;\n-    pub fn uv_tcp_keepalive(h: *uv_tcp_t, enable: c_int,\n+    pub fn uv_tcp_init(l: *mut uv_loop_t, h: *mut uv_tcp_t) -> c_int;\n+    pub fn uv_tcp_connect(c: *mut uv_connect_t, h: *mut uv_tcp_t,\n+                          addr: *const sockaddr, cb: uv_connect_cb) -> c_int;\n+    pub fn uv_tcp_bind(t: *mut uv_tcp_t, addr: *const sockaddr) -> c_int;\n+    pub fn uv_tcp_nodelay(h: *mut uv_tcp_t, enable: c_int) -> c_int;\n+    pub fn uv_tcp_keepalive(h: *mut uv_tcp_t, enable: c_int,\n                             delay: c_uint) -> c_int;\n-    pub fn uv_tcp_simultaneous_accepts(h: *uv_tcp_t, enable: c_int) -> c_int;\n-    pub fn uv_tcp_getsockname(h: *uv_tcp_t, name: *mut sockaddr,\n+    pub fn uv_tcp_simultaneous_accepts(h: *mut uv_tcp_t, enable: c_int) -> c_int;\n+    pub fn uv_tcp_getsockname(h: *mut uv_tcp_t, name: *mut sockaddr,\n                               len: *mut c_int) -> c_int;\n-    pub fn uv_tcp_getpeername(h: *uv_tcp_t, name: *mut sockaddr,\n+    pub fn uv_tcp_getpeername(h: *mut uv_tcp_t, name: *mut sockaddr,\n                               len: *mut c_int) -> c_int;\n \n     // udp bindings\n-    pub fn uv_udp_init(l: *uv_loop_t, h: *uv_udp_t) -> c_int;\n-    pub fn uv_udp_bind(h: *uv_udp_t, addr: *sockaddr, flags: c_uint) -> c_int;\n-    pub fn uv_udp_recv_start(server: *uv_udp_t,\n+    pub fn uv_udp_init(l: *mut uv_loop_t, h: *mut uv_udp_t) -> c_int;\n+    pub fn uv_udp_bind(h: *mut uv_udp_t, addr: *const sockaddr,\n+                       flags: c_uint) -> c_int;\n+    pub fn uv_udp_recv_start(server: *mut uv_udp_t,\n                              on_alloc: uv_alloc_cb,\n                              on_recv: uv_udp_recv_cb) -> c_int;\n-    pub fn uv_udp_set_membership(handle: *uv_udp_t, multicast_addr: *c_char,\n-                                 interface_addr: *c_char,\n+    pub fn uv_udp_set_membership(handle: *mut uv_udp_t,\n+                                 multicast_addr: *const c_char,\n+                                 interface_addr: *const c_char,\n                                  membership: uv_membership) -> c_int;\n-    pub fn uv_udp_recv_stop(server: *uv_udp_t) -> c_int;\n-    pub fn uv_udp_set_multicast_loop(handle: *uv_udp_t, on: c_int) -> c_int;\n-    pub fn uv_udp_set_multicast_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int;\n-    pub fn uv_udp_set_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int;\n-    pub fn uv_udp_set_broadcast(handle: *uv_udp_t, on: c_int) -> c_int;\n-    pub fn uv_udp_getsockname(h: *uv_udp_t, name: *mut sockaddr,\n+    pub fn uv_udp_recv_stop(server: *mut uv_udp_t) -> c_int;\n+    pub fn uv_udp_set_multicast_loop(handle: *mut uv_udp_t, on: c_int) -> c_int;\n+    pub fn uv_udp_set_multicast_ttl(handle: *mut uv_udp_t, ttl: c_int) -> c_int;\n+    pub fn uv_udp_set_ttl(handle: *mut uv_udp_t, ttl: c_int) -> c_int;\n+    pub fn uv_udp_set_broadcast(handle: *mut uv_udp_t, on: c_int) -> c_int;\n+    pub fn uv_udp_getsockname(h: *mut uv_udp_t, name: *mut sockaddr,\n                               len: *mut c_int) -> c_int;\n \n     // timer bindings\n-    pub fn uv_timer_init(l: *uv_loop_t, t: *uv_timer_t) -> c_int;\n-    pub fn uv_timer_start(t: *uv_timer_t, cb: uv_timer_cb,\n+    pub fn uv_timer_init(l: *mut uv_loop_t, t: *mut uv_timer_t) -> c_int;\n+    pub fn uv_timer_start(t: *mut uv_timer_t, cb: uv_timer_cb,\n                           timeout: libc::uint64_t,\n                           repeat: libc::uint64_t) -> c_int;\n-    pub fn uv_timer_stop(handle: *uv_timer_t) -> c_int;\n+    pub fn uv_timer_stop(handle: *mut uv_timer_t) -> c_int;\n \n     // fs operations\n-    pub fn uv_fs_open(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                      flags: c_int, mode: c_int, cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_unlink(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                        cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_write(l: *uv_loop_t, req: *uv_fs_t, fd: c_int,\n-                       bufs: *uv_buf_t, nbufs: c_uint,\n+    pub fn uv_fs_open(loop_ptr: *mut uv_loop_t, req: *mut uv_fs_t,\n+                      path: *const c_char, flags: c_int, mode: c_int,\n+                      cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_unlink(loop_ptr: *mut uv_loop_t, req: *mut uv_fs_t,\n+                        path: *const c_char, cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_write(l: *mut uv_loop_t, req: *mut uv_fs_t, fd: c_int,\n+                       bufs: *const uv_buf_t, nbufs: c_uint,\n                        offset: i64, cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_read(l: *uv_loop_t, req: *uv_fs_t, fd: c_int,\n-                      bufs: *uv_buf_t, nbufs: c_uint,\n+    pub fn uv_fs_read(l: *mut uv_loop_t, req: *mut uv_fs_t, fd: c_int,\n+                      bufs: *mut uv_buf_t, nbufs: c_uint,\n                       offset: i64, cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_close(l: *uv_loop_t, req: *uv_fs_t, fd: c_int,\n+    pub fn uv_fs_close(l: *mut uv_loop_t, req: *mut uv_fs_t, fd: c_int,\n                        cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_stat(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+    pub fn uv_fs_stat(l: *mut uv_loop_t, req: *mut uv_fs_t, path: *const c_char,\n                       cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_fstat(l: *uv_loop_t, req: *uv_fs_t, fd: c_int,\n+    pub fn uv_fs_fstat(l: *mut uv_loop_t, req: *mut uv_fs_t, fd: c_int,\n                        cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_mkdir(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+    pub fn uv_fs_mkdir(l: *mut uv_loop_t, req: *mut uv_fs_t, path: *const c_char,\n                        mode: c_int, cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_rmdir(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+    pub fn uv_fs_rmdir(l: *mut uv_loop_t, req: *mut uv_fs_t, path: *const c_char,\n                        cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_readdir(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                         flags: c_int, cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_req_cleanup(req: *uv_fs_t);\n-    pub fn uv_fs_fsync(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,\n+    pub fn uv_fs_readdir(l: *mut uv_loop_t, req: *mut uv_fs_t,\n+                         path: *const c_char, flags: c_int,\n+                         cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_req_cleanup(req: *mut uv_fs_t);\n+    pub fn uv_fs_fsync(handle: *mut uv_loop_t, req: *mut uv_fs_t, file: c_int,\n                        cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_fdatasync(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,\n+    pub fn uv_fs_fdatasync(handle: *mut uv_loop_t, req: *mut uv_fs_t, file: c_int,\n                            cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_ftruncate(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,\n+    pub fn uv_fs_ftruncate(handle: *mut uv_loop_t, req: *mut uv_fs_t, file: c_int,\n                            offset: i64, cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_readlink(handle: *uv_loop_t, req: *uv_fs_t, file: *c_char,\n-                          cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_symlink(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n-                         dst: *c_char, flags: c_int, cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_rename(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n-                        dst: *c_char, cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_utime(handle: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                       atime: c_double, mtime: c_double,\n+    pub fn uv_fs_readlink(handle: *mut uv_loop_t, req: *mut uv_fs_t,\n+                          file: *const c_char, cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_symlink(handle: *mut uv_loop_t, req: *mut uv_fs_t,\n+                         src: *const c_char, dst: *const c_char, flags: c_int,\n+                         cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_rename(handle: *mut uv_loop_t, req: *mut uv_fs_t,\n+                        src: *const c_char, dst: *const c_char,\n+                        cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_utime(handle: *mut uv_loop_t, req: *mut uv_fs_t,\n+                       path: *const c_char, atime: c_double, mtime: c_double,\n                        cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_link(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n-                      dst: *c_char, cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_chown(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n+    pub fn uv_fs_link(handle: *mut uv_loop_t, req: *mut uv_fs_t,\n+                      src: *const c_char, dst: *const c_char,\n+                      cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_chown(handle: *mut uv_loop_t, req: *mut uv_fs_t, src: *const c_char,\n                        uid: uv_uid_t, gid: uv_gid_t, cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_chmod(handle: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                       mode: c_int, cb: uv_fs_cb) -> c_int;\n-    pub fn uv_fs_lstat(handle: *uv_loop_t, req: *uv_fs_t, file: *c_char,\n-                       cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_chmod(handle: *mut uv_loop_t, req: *mut uv_fs_t,\n+                       path: *const c_char, mode: c_int, cb: uv_fs_cb) -> c_int;\n+    pub fn uv_fs_lstat(handle: *mut uv_loop_t, req: *mut uv_fs_t,\n+                       file: *const c_char, cb: uv_fs_cb) -> c_int;\n \n     // getaddrinfo\n-    pub fn uv_getaddrinfo(loop_: *uv_loop_t, req: *uv_getaddrinfo_t,\n+    pub fn uv_getaddrinfo(loop_: *mut uv_loop_t, req: *mut uv_getaddrinfo_t,\n                           getaddrinfo_cb: uv_getaddrinfo_cb,\n-                          node: *c_char, service: *c_char,\n-                          hints: *addrinfo) -> c_int;\n-    pub fn uv_freeaddrinfo(ai: *addrinfo);\n+                          node: *const c_char, service: *const c_char,\n+                          hints: *const addrinfo) -> c_int;\n+    pub fn uv_freeaddrinfo(ai: *mut addrinfo);\n \n     // process spawning\n-    pub fn uv_spawn(loop_ptr: *uv_loop_t, outptr: *uv_process_t,\n-                    options: *uv_process_options_t) -> c_int;\n-    pub fn uv_process_kill(p: *uv_process_t, signum: c_int) -> c_int;\n+    pub fn uv_spawn(loop_ptr: *mut uv_loop_t, outptr: *mut uv_process_t,\n+                    options: *mut uv_process_options_t) -> c_int;\n+    pub fn uv_process_kill(p: *mut uv_process_t, signum: c_int) -> c_int;\n     pub fn uv_kill(pid: c_int, signum: c_int) -> c_int;\n \n     // pipes\n-    pub fn uv_pipe_init(l: *uv_loop_t, p: *uv_pipe_t, ipc: c_int) -> c_int;\n-    pub fn uv_pipe_open(pipe: *uv_pipe_t, file: c_int) -> c_int;\n-    pub fn uv_pipe_bind(pipe: *uv_pipe_t, name: *c_char) -> c_int;\n-    pub fn uv_pipe_connect(req: *uv_connect_t, handle: *uv_pipe_t,\n-                           name: *c_char, cb: uv_connect_cb);\n+    pub fn uv_pipe_init(l: *mut uv_loop_t, p: *mut uv_pipe_t,\n+                        ipc: c_int) -> c_int;\n+    pub fn uv_pipe_open(pipe: *mut uv_pipe_t, file: c_int) -> c_int;\n+    pub fn uv_pipe_bind(pipe: *mut uv_pipe_t, name: *const c_char) -> c_int;\n+    pub fn uv_pipe_connect(req: *mut uv_connect_t, handle: *mut uv_pipe_t,\n+                           name: *const c_char, cb: uv_connect_cb);\n \n     // tty\n-    pub fn uv_tty_init(l: *uv_loop_t, tty: *uv_tty_t, fd: c_int,\n+    pub fn uv_tty_init(l: *mut uv_loop_t, tty: *mut uv_tty_t, fd: c_int,\n                        readable: c_int) -> c_int;\n-    pub fn uv_tty_set_mode(tty: *uv_tty_t, mode: c_int) -> c_int;\n-    pub fn uv_tty_get_winsize(tty: *uv_tty_t, width: *c_int,\n-                              height: *c_int) -> c_int;\n+    pub fn uv_tty_set_mode(tty: *mut uv_tty_t, mode: c_int) -> c_int;\n+    pub fn uv_tty_get_winsize(tty: *mut uv_tty_t,\n+                              width: *mut c_int,\n+                              height: *mut c_int) -> c_int;\n \n     // signals\n-    pub fn uv_signal_init(loop_: *uv_loop_t, handle: *uv_signal_t) -> c_int;\n-    pub fn uv_signal_start(h: *uv_signal_t, cb: uv_signal_cb,\n+    pub fn uv_signal_init(loop_: *mut uv_loop_t,\n+                          handle: *mut uv_signal_t) -> c_int;\n+    pub fn uv_signal_start(h: *mut uv_signal_t, cb: uv_signal_cb,\n                            signum: c_int) -> c_int;\n-    pub fn uv_signal_stop(handle: *uv_signal_t) -> c_int;\n+    pub fn uv_signal_stop(handle: *mut uv_signal_t) -> c_int;\n }\n \n // libuv requires other native libraries on various platforms. These are all"}, {"sha": "dfce1eeb832d574a635e4ac8abf8041513470dfd", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -182,7 +182,7 @@ pub mod reader {\n         ];\n \n         unsafe {\n-            let ptr = data.as_ptr().offset(start as int) as *u32;\n+            let ptr = data.as_ptr().offset(start as int) as *const u32;\n             let val = Int::from_be(*ptr);\n \n             let i = (val >> 28u) as uint;"}, {"sha": "1926d6b1b960fc4f36bb19bc76c03609c5191e8a", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -102,14 +102,14 @@ impl<T> CVec<T> {\n     /// View the stored data as a slice.\n     pub fn as_slice<'a>(&'a self) -> &'a [T] {\n         unsafe {\n-            mem::transmute(raw::Slice { data: self.base as *T, len: self.len })\n+            mem::transmute(raw::Slice { data: self.base as *const T, len: self.len })\n         }\n     }\n \n     /// View the stored data as a mutable slice.\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         unsafe {\n-            mem::transmute(raw::Slice { data: self.base as *T, len: self.len })\n+            mem::transmute(raw::Slice { data: self.base as *const T, len: self.len })\n         }\n     }\n "}, {"sha": "b94141748d57fe2561cc14a4a20fb43ace1338ca", "filename": "src/libstd/collections/hashmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Fcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Fcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -361,8 +361,8 @@ mod table {\n                 *self.hashes.offset(idx) = EMPTY_BUCKET;\n \n                 // Drop the mutable constraint.\n-                let keys = self.keys as *K;\n-                let vals = self.vals as *V;\n+                let keys = self.keys as *const K;\n+                let vals = self.vals as *const V;\n \n                 let k = ptr::read(keys.offset(idx));\n                 let v = ptr::read(vals.offset(idx));"}, {"sha": "08f11581e838a17a74f5ee8badd66b350e230066", "filename": "src/libstd/collections/lru_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Fcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Fcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Flru_cache.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -49,7 +49,7 @@ use owned::Box;\n use ptr;\n use result::{Ok, Err};\n \n-struct KeyRef<K> { k: *K }\n+struct KeyRef<K> { k: *const K }\n \n struct LruEntry<K, V> {\n     next: *mut LruEntry<K, V>,"}, {"sha": "ec2cc67a60a16a53f92e7fd5c715e72cdf10516a", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -33,7 +33,7 @@ use str;\n use string::String;\n use vec::Vec;\n \n-pub struct DynamicLibrary { handle: *u8}\n+pub struct DynamicLibrary { handle: *mut u8 }\n \n impl Drop for DynamicLibrary {\n     fn drop(&mut self) {\n@@ -134,7 +134,7 @@ impl DynamicLibrary {\n     }\n \n     /// Access the value at the symbol of the dynamic library\n-    pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<*T, String> {\n+    pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<*mut T, String> {\n         // This function should have a lifetime constraint of 'a on\n         // T but that feature is still unimplemented\n \n@@ -175,7 +175,7 @@ mod test {\n         let cosine: extern fn(libc::c_double) -> libc::c_double = unsafe {\n             match libm.symbol(\"cos\") {\n                 Err(error) => fail!(\"Could not load function cos: {}\", error),\n-                Ok(cosine) => mem::transmute::<*u8, _>(cosine)\n+                Ok(cosine) => mem::transmute::<*mut u8, _>(cosine)\n             }\n         };\n \n@@ -218,14 +218,14 @@ pub mod dl {\n     use str::StrAllocating;\n     use string::String;\n \n-    pub unsafe fn open_external<T: ToCStr>(filename: T) -> *u8 {\n+    pub unsafe fn open_external<T: ToCStr>(filename: T) -> *mut u8 {\n         filename.with_c_str(|raw_name| {\n-            dlopen(raw_name, Lazy as libc::c_int) as *u8\n+            dlopen(raw_name, Lazy as libc::c_int) as *mut u8\n         })\n     }\n \n-    pub unsafe fn open_internal() -> *u8 {\n-        dlopen(ptr::null(), Lazy as libc::c_int) as *u8\n+    pub unsafe fn open_internal() -> *mut u8 {\n+        dlopen(ptr::null(), Lazy as libc::c_int) as *mut u8\n     }\n \n     pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, String> {\n@@ -239,7 +239,7 @@ pub mod dl {\n \n             let result = f();\n \n-            let last_error = dlerror();\n+            let last_error = dlerror() as *const _;\n             let ret = if ptr::null() == last_error {\n                 Ok(result)\n             } else {\n@@ -252,11 +252,12 @@ pub mod dl {\n         }\n     }\n \n-    pub unsafe fn symbol(handle: *u8, symbol: *libc::c_char) -> *u8 {\n-        dlsym(handle as *libc::c_void, symbol) as *u8\n+    pub unsafe fn symbol(handle: *mut u8,\n+                         symbol: *const libc::c_char) -> *mut u8 {\n+        dlsym(handle as *mut libc::c_void, symbol) as *mut u8\n     }\n-    pub unsafe fn close(handle: *u8) {\n-        dlclose(handle as *libc::c_void); ()\n+    pub unsafe fn close(handle: *mut u8) {\n+        dlclose(handle as *mut libc::c_void); ()\n     }\n \n     pub enum RTLD {\n@@ -268,10 +269,12 @@ pub mod dl {\n \n     #[link_name = \"dl\"]\n     extern {\n-        fn dlopen(filename: *libc::c_char, flag: libc::c_int) -> *libc::c_void;\n-        fn dlerror() -> *libc::c_char;\n-        fn dlsym(handle: *libc::c_void, symbol: *libc::c_char) -> *libc::c_void;\n-        fn dlclose(handle: *libc::c_void) -> libc::c_int;\n+        fn dlopen(filename: *const libc::c_char,\n+                  flag: libc::c_int) -> *mut libc::c_void;\n+        fn dlerror() -> *mut libc::c_char;\n+        fn dlsym(handle: *mut libc::c_void,\n+                 symbol: *const libc::c_char) -> *mut libc::c_void;\n+        fn dlclose(handle: *mut libc::c_void) -> libc::c_int;\n     }\n }\n \n@@ -286,18 +289,18 @@ pub mod dl {\n     use str;\n     use string::String;\n \n-    pub unsafe fn open_external<T: ToCStr>(filename: T) -> *u8 {\n+    pub unsafe fn open_external<T: ToCStr>(filename: T) -> *mut u8 {\n         // Windows expects Unicode data\n         let filename_cstr = filename.to_c_str();\n         let filename_str = str::from_utf8(filename_cstr.as_bytes_no_nul()).unwrap();\n         let filename_str = filename_str.to_utf16().append_one(0);\n-        LoadLibraryW(filename_str.as_ptr() as *libc::c_void) as *u8\n+        LoadLibraryW(filename_str.as_ptr() as *const libc::c_void) as *mut u8\n     }\n \n-    pub unsafe fn open_internal() -> *u8 {\n-        let handle = ptr::null();\n-        GetModuleHandleExW(0 as libc::DWORD, ptr::null(), &handle as **libc::c_void);\n-        handle as *u8\n+    pub unsafe fn open_internal() -> *mut u8 {\n+        let mut handle = ptr::mut_null();\n+        GetModuleHandleExW(0 as libc::DWORD, ptr::null(), &mut handle);\n+        handle as *mut u8\n     }\n \n     pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, String> {\n@@ -315,20 +318,22 @@ pub mod dl {\n         }\n     }\n \n-    pub unsafe fn symbol(handle: *u8, symbol: *libc::c_char) -> *u8 {\n-        GetProcAddress(handle as *libc::c_void, symbol) as *u8\n+    pub unsafe fn symbol(handle: *mut u8, symbol: *const libc::c_char) -> *mut u8 {\n+        GetProcAddress(handle as *mut libc::c_void, symbol) as *mut u8\n     }\n-    pub unsafe fn close(handle: *u8) {\n-        FreeLibrary(handle as *libc::c_void); ()\n+    pub unsafe fn close(handle: *mut u8) {\n+        FreeLibrary(handle as *mut libc::c_void); ()\n     }\n \n     #[allow(non_snake_case_functions)]\n     extern \"system\" {\n         fn SetLastError(error: libc::size_t);\n-        fn LoadLibraryW(name: *libc::c_void) -> *libc::c_void;\n-        fn GetModuleHandleExW(dwFlags: libc::DWORD, name: *u16,\n-                              handle: **libc::c_void) -> *libc::c_void;\n-        fn GetProcAddress(handle: *libc::c_void, name: *libc::c_char) -> *libc::c_void;\n-        fn FreeLibrary(handle: *libc::c_void);\n+        fn LoadLibraryW(name: *const libc::c_void) -> *mut libc::c_void;\n+        fn GetModuleHandleExW(dwFlags: libc::DWORD, name: *const u16,\n+                              handle: *mut *mut libc::c_void)\n+                              -> *mut libc::c_void;\n+        fn GetProcAddress(handle: *mut libc::c_void,\n+                          name: *const libc::c_char) -> *mut libc::c_void;\n+        fn FreeLibrary(handle: *mut libc::c_void);\n     }\n }"}, {"sha": "363c577563e8c8fad90346ad632cc5395c05c5de", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -33,7 +33,7 @@ use raw;\n                   task annihilation. For now, cycles need to be broken manually by using `Rc<T>` \\\n                   with a non-owning `Weak<T>` pointer. A tracing garbage collector is planned.\"]\n pub struct Gc<T> {\n-    _ptr: *T,\n+    _ptr: *mut T,\n     marker: marker::NoSend,\n }\n \n@@ -83,7 +83,7 @@ impl<T: Default + 'static> Default for Gc<T> {\n     }\n }\n \n-impl<T: 'static> raw::Repr<*raw::Box<T>> for Gc<T> {}\n+impl<T: 'static> raw::Repr<*const raw::Box<T>> for Gc<T> {}\n \n impl<S: hash::Writer, T: hash::Hash<S> + 'static> hash::Hash<S> for Gc<T> {\n     fn hash(&self, s: &mut S) {"}, {"sha": "277aca2332d475cb1b42a9852f0f59b793d2d505", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -166,7 +166,7 @@ pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n         let ptr = data.as_ptr().offset(start as int);\n         let out = buf.as_mut_ptr();\n         copy_nonoverlapping_memory(out.offset((8 - size) as int), ptr, size);\n-        from_be64(*(out as *u64))\n+        from_be64(*(out as *const u64))\n     }\n }\n "}, {"sha": "26e854d9d999fa1b58eae5e061c878a5472a9c70", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -155,7 +155,7 @@ mod darwin_fd_limit {\n                   oldp: *mut libc::c_void, oldlenp: *mut libc::size_t,\n                   newp: *mut libc::c_void, newlen: libc::size_t) -> libc::c_int;\n         fn getrlimit(resource: libc::c_int, rlp: *mut rlimit) -> libc::c_int;\n-        fn setrlimit(resource: libc::c_int, rlp: *rlimit) -> libc::c_int;\n+        fn setrlimit(resource: libc::c_int, rlp: *const rlimit) -> libc::c_int;\n     }\n     static CTL_KERN: libc::c_int = 1;\n     static KERN_MAXFILESPERPROC: libc::c_int = 29;"}, {"sha": "f63e69f3cca0a17af6720d38f95608212ccee046", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -111,7 +111,6 @@\n #![no_std]\n \n #![allow(deprecated)]\n-#![allow(unknown_features)] // NOTE: remove after stage0 snapshot\n #![deny(missing_doc)]\n \n // When testing libstd, bring in libuv as the I/O backend so tests can print\n@@ -184,7 +183,7 @@ pub use core_sync::comm;\n //        threading mode than the default by reaching into the auto-generated\n //        '__test' module.\n #[cfg(test)] #[start]\n-fn start(argc: int, argv: **u8) -> int {\n+fn start(argc: int, argv: *const *const u8) -> int {\n     green::start(argc, argv, rustuv::event_loop, __test::main)\n }\n "}, {"sha": "90f4cbb25778dcb1d8e174217249e240cd6fe25d", "filename": "src/libstd/os.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -276,7 +276,7 @@ pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n             use c_str::CString;\n \n             extern {\n-                fn rust_env_pairs() -> **c_char;\n+                fn rust_env_pairs() -> *const *const c_char;\n             }\n             let environ = rust_env_pairs();\n             if environ as uint == 0 {\n@@ -351,7 +351,7 @@ pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n             if s.is_null() {\n                 None\n             } else {\n-                Some(Vec::from_slice(CString::new(s,\n+                Some(Vec::from_slice(CString::new(s as *const i8,\n                                                   false).as_bytes_no_nul()))\n             }\n         })\n@@ -598,19 +598,20 @@ pub fn self_exe_name() -> Option<Path> {\n         unsafe {\n             use libc::funcs::bsd44::*;\n             use libc::consts::os::extra::*;\n-            let mib = vec![CTL_KERN as c_int,\n-                        KERN_PROC as c_int,\n-                        KERN_PROC_PATHNAME as c_int, -1 as c_int];\n+            let mut mib = vec![CTL_KERN as c_int,\n+                               KERN_PROC as c_int,\n+                               KERN_PROC_PATHNAME as c_int,\n+                               -1 as c_int];\n             let mut sz: libc::size_t = 0;\n-            let err = sysctl(mib.as_ptr(), mib.len() as ::libc::c_uint,\n-                             ptr::mut_null(), &mut sz, ptr::null(),\n+            let err = sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n+                             ptr::mut_null(), &mut sz, ptr::mut_null(),\n                              0u as libc::size_t);\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n             let mut v: Vec<u8> = Vec::with_capacity(sz as uint);\n-            let err = sysctl(mib.as_ptr(), mib.len() as ::libc::c_uint,\n-                             v.as_mut_ptr() as *mut c_void, &mut sz, ptr::null(),\n-                             0u as libc::size_t);\n+            let err = sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n+                             v.as_mut_ptr() as *mut c_void, &mut sz,\n+                             ptr::mut_null(), 0u as libc::size_t);\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n             v.set_len(sz as uint - 1); // chop off trailing NUL\n@@ -827,9 +828,9 @@ pub fn errno() -> int {\n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"ios\")]\n     #[cfg(target_os = \"freebsd\")]\n-    fn errno_location() -> *c_int {\n+    fn errno_location() -> *const c_int {\n         extern {\n-            fn __error() -> *c_int;\n+            fn __error() -> *const c_int;\n         }\n         unsafe {\n             __error()\n@@ -838,9 +839,9 @@ pub fn errno() -> int {\n \n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n-    fn errno_location() -> *c_int {\n+    fn errno_location() -> *const c_int {\n         extern {\n-            fn __errno_location() -> *c_int;\n+            fn __errno_location() -> *const c_int;\n         }\n         unsafe {\n             __errno_location()\n@@ -913,7 +914,7 @@ pub fn error_string(errnum: uint) -> String {\n                 fail!(\"strerror_r failure\");\n             }\n \n-            str::raw::from_c_str(p as *c_char).into_string()\n+            str::raw::from_c_str(p as *const c_char).into_string()\n         }\n     }\n \n@@ -932,7 +933,7 @@ pub fn error_string(errnum: uint) -> String {\n                               langId: DWORD,\n                               buf: LPWSTR,\n                               nsize: DWORD,\n-                              args: *c_void)\n+                              args: *const c_void)\n                               -> DWORD;\n         }\n \n@@ -997,7 +998,8 @@ pub fn get_exit_status() -> int {\n }\n \n #[cfg(target_os = \"macos\")]\n-unsafe fn load_argc_and_argv(argc: int, argv: **c_char) -> Vec<Vec<u8>> {\n+unsafe fn load_argc_and_argv(argc: int,\n+                             argv: *const *const c_char) -> Vec<Vec<u8>> {\n     use c_str::CString;\n \n     Vec::from_fn(argc as uint, |i| {\n@@ -1015,7 +1017,7 @@ unsafe fn load_argc_and_argv(argc: int, argv: **c_char) -> Vec<Vec<u8>> {\n fn real_args_as_bytes() -> Vec<Vec<u8>> {\n     unsafe {\n         let (argc, argv) = (*_NSGetArgc() as int,\n-                            *_NSGetArgv() as **c_char);\n+                            *_NSGetArgv() as *const *const c_char);\n         load_argc_and_argv(argc, argv)\n     }\n }\n@@ -1040,16 +1042,16 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n \n     #[link(name = \"objc\")]\n     extern {\n-        fn sel_registerName(name: *libc::c_uchar) -> Sel;\n+        fn sel_registerName(name: *const libc::c_uchar) -> Sel;\n         fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;\n-        fn objc_getClass(class_name: *libc::c_uchar) -> NsId;\n+        fn objc_getClass(class_name: *const libc::c_uchar) -> NsId;\n     }\n \n     #[link(name = \"Foundation\", kind = \"framework\")]\n     extern {}\n \n-    type Sel = *libc::c_void;\n-    type NsId = *libc::c_void;\n+    type Sel = *const libc::c_void;\n+    type NsId = *const libc::c_void;\n \n     let mut res = Vec::new();\n \n@@ -1067,7 +1069,8 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n         let cnt: int = mem::transmute(objc_msgSend(args, countSel));\n         for i in range(0, cnt) {\n             let tmp = objc_msgSend(args, objectAtSel, i);\n-            let utf_c_str: *libc::c_char = mem::transmute(objc_msgSend(tmp, utf8Sel));\n+            let utf_c_str: *const libc::c_char =\n+                mem::transmute(objc_msgSend(tmp, utf8Sel));\n             let s = CString::new(utf_c_str, false);\n             if s.is_not_null() {\n                 res.push(Vec::from_slice(s.as_bytes_no_nul()))\n@@ -1114,14 +1117,14 @@ fn real_args() -> Vec<String> {\n         while *ptr.offset(len as int) != 0 { len += 1; }\n \n         // Push it onto the list.\n-        let opt_s = slice::raw::buf_as_slice(ptr, len, |buf| {\n+        let opt_s = slice::raw::buf_as_slice(ptr as *const _, len, |buf| {\n             str::from_utf16(str::truncate_utf16_at_nul(buf))\n         });\n         opt_s.expect(\"CommandLineToArgvW returned invalid UTF-16\")\n     });\n \n     unsafe {\n-        LocalFree(szArgList as *c_void);\n+        LocalFree(szArgList as *mut c_void);\n     }\n \n     return args\n@@ -1132,19 +1135,20 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n     real_args().move_iter().map(|s| s.into_bytes()).collect()\n }\n \n-type LPCWSTR = *u16;\n+type LPCWSTR = *const u16;\n \n #[cfg(windows)]\n #[link_name=\"kernel32\"]\n extern \"system\" {\n     fn GetCommandLineW() -> LPCWSTR;\n-    fn LocalFree(ptr: *c_void);\n+    fn LocalFree(ptr: *mut c_void);\n }\n \n #[cfg(windows)]\n #[link_name=\"shell32\"]\n extern \"system\" {\n-    fn CommandLineToArgvW(lpCmdLine: LPCWSTR, pNumArgs: *mut c_int) -> **u16;\n+    fn CommandLineToArgvW(lpCmdLine: LPCWSTR,\n+                          pNumArgs: *mut c_int) -> *mut *mut u16;\n }\n \n /// Returns the arguments which this program was started with (normally passed\n@@ -1165,8 +1169,8 @@ pub fn args_as_bytes() -> Vec<Vec<u8>> {\n #[cfg(target_os = \"macos\")]\n extern {\n     // These functions are in crt_externs.h.\n-    pub fn _NSGetArgc() -> *c_int;\n-    pub fn _NSGetArgv() -> ***c_char;\n+    pub fn _NSGetArgc() -> *mut c_int;\n+    pub fn _NSGetArgv() -> *mut *mut *mut c_char;\n }\n \n // Round up `from` to be divisible by `to`\n@@ -1224,7 +1228,7 @@ pub struct MemoryMap {\n pub enum MemoryMapKind {\n     /// Virtual memory map. Usually used to change the permissions of a given\n     /// chunk of memory.  Corresponds to `VirtualAlloc` on Windows.\n-    MapFile(*u8),\n+    MapFile(*const u8),\n     /// Virtual memory map. Usually used to change the permissions of a given\n     /// chunk of memory, or for allocation. Corresponds to `VirtualAlloc` on\n     /// Windows.\n@@ -1241,7 +1245,7 @@ pub enum MapOption {\n     MapExecutable,\n     /// Create a map for a specific address range. Corresponds to `MAP_FIXED` on\n     /// POSIX.\n-    MapAddr(*u8),\n+    MapAddr(*const u8),\n     /// Create a memory mapping for a file with a given fd.\n     MapFd(c_int),\n     /// When using `MapFd`, the start of the map is `uint` bytes from the start\n@@ -1342,7 +1346,7 @@ impl MemoryMap {\n         if min_len == 0 {\n             return Err(ErrZeroLength)\n         }\n-        let mut addr: *u8 = ptr::null();\n+        let mut addr: *const u8 = ptr::null();\n         let mut prot = 0;\n         let mut flags = libc::MAP_PRIVATE;\n         let mut fd = -1;\n@@ -1502,7 +1506,7 @@ impl MemoryMap {\n                     _ => Ok(MemoryMap {\n                        data: r as *mut u8,\n                        len: len,\n-                       kind: MapFile(mapping as *u8)\n+                       kind: MapFile(mapping as *const u8)\n                     })\n                 }\n             }\n@@ -1990,7 +1994,7 @@ mod tests {\n                 open(path, O_CREAT | O_RDWR | O_TRUNC, S_IRUSR | S_IWUSR)\n             });\n             lseek_(fd, size);\n-            \"x\".with_c_str(|x| assert!(write(fd, x as *c_void, 1) == 1));\n+            \"x\".with_c_str(|x| assert!(write(fd, x as *const c_void, 1) == 1));\n             fd\n         };\n         let chunk = match MemoryMap::new(size / 2, ["}, {"sha": "60e2c4c894919eb8266b200c958135d9e7c7d70b", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -87,11 +87,12 @@ mod imp {\n \n     struct SecRandom;\n \n-    static kSecRandomDefault: *SecRandom = 0 as *SecRandom;\n+    static kSecRandomDefault: *const SecRandom = 0 as *const SecRandom;\n \n     #[link(name = \"Security\", kind = \"framework\")]\n     extern \"C\" {\n-        fn SecRandomCopyBytes(rnd: *SecRandom, count: size_t, bytes: *mut u8) -> c_int;\n+        fn SecRandomCopyBytes(rnd: *const SecRandom,\n+                              count: size_t, bytes: *mut u8) -> c_int;\n     }\n \n     impl OsRng {"}, {"sha": "8f51e834c6a024ec0d67b9319908fb0db88cf45d", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 44, "deletions": 41, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -261,7 +261,8 @@ mod imp {\n         use slice::{MutableVector};\n \n         extern {\n-            fn backtrace(buf: *mut *libc::c_void, sz: libc::c_int) -> libc::c_int;\n+            fn backtrace(buf: *mut *const libc::c_void,\n+                         sz: libc::c_int) -> libc::c_int;\n         }\n \n         // while it doesn't requires lock for work as everything is\n@@ -273,7 +274,7 @@ mod imp {\n         try!(writeln!(w, \"stack backtrace:\"));\n         // 100 lines should be enough\n         static SIZE: libc::c_int = 100;\n-        let mut buf: [*libc::c_void, ..SIZE] = unsafe {mem::zeroed()};\n+        let mut buf: [*const libc::c_void, ..SIZE] = unsafe {mem::zeroed()};\n         let cnt = unsafe { backtrace(buf.as_mut_ptr(), SIZE) as uint};\n \n         // skipping the first one as it is write itself\n@@ -307,7 +308,7 @@ mod imp {\n         let mut cx = Context { writer: w, last_error: None, idx: 0 };\n         return match unsafe {\n             uw::_Unwind_Backtrace(trace_fn,\n-                                  &mut cx as *mut Context as *libc::c_void)\n+                                  &mut cx as *mut Context as *mut libc::c_void)\n         } {\n             uw::_URC_NO_REASON => {\n                 match cx.last_error {\n@@ -318,10 +319,10 @@ mod imp {\n             _ => Ok(()),\n         };\n \n-        extern fn trace_fn(ctx: *uw::_Unwind_Context,\n-                           arg: *libc::c_void) -> uw::_Unwind_Reason_Code {\n+        extern fn trace_fn(ctx: *mut uw::_Unwind_Context,\n+                           arg: *mut libc::c_void) -> uw::_Unwind_Reason_Code {\n             let cx: &mut Context = unsafe { mem::transmute(arg) };\n-            let ip = unsafe { uw::_Unwind_GetIP(ctx) as *libc::c_void };\n+            let ip = unsafe { uw::_Unwind_GetIP(ctx) as *mut libc::c_void };\n             // dladdr() on osx gets whiny when we use FindEnclosingFunction, and\n             // it appears to work fine without it, so we only use\n             // FindEnclosingFunction on non-osx platforms. In doing so, we get a\n@@ -365,22 +366,22 @@ mod imp {\n \n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"ios\")]\n-    fn print(w: &mut Writer, idx: int, addr: *libc::c_void) -> IoResult<()> {\n+    fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n         use intrinsics;\n         #[repr(C)]\n         struct Dl_info {\n-            dli_fname: *libc::c_char,\n-            dli_fbase: *libc::c_void,\n-            dli_sname: *libc::c_char,\n-            dli_saddr: *libc::c_void,\n+            dli_fname: *const libc::c_char,\n+            dli_fbase: *mut libc::c_void,\n+            dli_sname: *const libc::c_char,\n+            dli_saddr: *mut libc::c_void,\n         }\n         extern {\n-            fn dladdr(addr: *libc::c_void,\n+            fn dladdr(addr: *const libc::c_void,\n                       info: *mut Dl_info) -> libc::c_int;\n         }\n \n         let mut info: Dl_info = unsafe { intrinsics::init() };\n-        if unsafe { dladdr(addr, &mut info) == 0 } {\n+        if unsafe { dladdr(addr as *const libc::c_void, &mut info) == 0 } {\n             output(w, idx,addr, None)\n         } else {\n             output(w, idx, addr, Some(unsafe {\n@@ -390,7 +391,7 @@ mod imp {\n     }\n \n     #[cfg(not(target_os = \"macos\"), not(target_os = \"ios\"))]\n-    fn print(w: &mut Writer, idx: int, addr: *libc::c_void) -> IoResult<()> {\n+    fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n         use collections::Collection;\n         use iter::Iterator;\n         use os;\n@@ -405,17 +406,17 @@ mod imp {\n         type backtrace_syminfo_callback =\n             extern \"C\" fn(data: *mut libc::c_void,\n                           pc: libc::uintptr_t,\n-                          symname: *libc::c_char,\n+                          symname: *const libc::c_char,\n                           symval: libc::uintptr_t,\n                           symsize: libc::uintptr_t);\n         type backtrace_error_callback =\n             extern \"C\" fn(data: *mut libc::c_void,\n-                          msg: *libc::c_char,\n+                          msg: *const libc::c_char,\n                           errnum: libc::c_int);\n         enum backtrace_state {}\n         #[link(name = \"backtrace\", kind = \"static\")]\n         extern {\n-            fn backtrace_create_state(filename: *libc::c_char,\n+            fn backtrace_create_state(filename: *const libc::c_char,\n                                       threaded: libc::c_int,\n                                       error: backtrace_error_callback,\n                                       data: *mut libc::c_void)\n@@ -431,16 +432,16 @@ mod imp {\n         // helper callbacks\n         ////////////////////////////////////////////////////////////////////////\n \n-        extern fn error_cb(_data: *mut libc::c_void, _msg: *libc::c_char,\n+        extern fn error_cb(_data: *mut libc::c_void, _msg: *const libc::c_char,\n                            _errnum: libc::c_int) {\n             // do nothing for now\n         }\n         extern fn syminfo_cb(data: *mut libc::c_void,\n                              _pc: libc::uintptr_t,\n-                             symname: *libc::c_char,\n+                             symname: *const libc::c_char,\n                              _symval: libc::uintptr_t,\n                              _symsize: libc::uintptr_t) {\n-            let slot = data as *mut *libc::c_char;\n+            let slot = data as *mut *const libc::c_char;\n             unsafe { *slot = symname; }\n         }\n \n@@ -502,8 +503,8 @@ mod imp {\n         if state.is_null() {\n             return output(w, idx, addr, None)\n         }\n-        let mut data = 0 as *libc::c_char;\n-        let data_addr = &mut data as *mut *libc::c_char;\n+        let mut data = 0 as *const libc::c_char;\n+        let data_addr = &mut data as *mut *const libc::c_char;\n         let ret = unsafe {\n             backtrace_syminfo(state, addr as libc::uintptr_t,\n                               syminfo_cb, error_cb,\n@@ -517,7 +518,7 @@ mod imp {\n     }\n \n     // Finally, after all that work above, we can emit a symbol.\n-    fn output(w: &mut Writer, idx: int, addr: *libc::c_void,\n+    fn output(w: &mut Writer, idx: int, addr: *mut libc::c_void,\n               s: Option<CString>) -> IoResult<()> {\n         try!(write!(w, \"  {:2}: {:2$} - \", idx, addr, super::HEX_WIDTH));\n         match s.as_ref().and_then(|c| c.as_str()) {\n@@ -557,31 +558,31 @@ mod imp {\n         pub enum _Unwind_Context {}\n \n         pub type _Unwind_Trace_Fn =\n-                extern fn(ctx: *_Unwind_Context,\n-                          arg: *libc::c_void) -> _Unwind_Reason_Code;\n+                extern fn(ctx: *mut _Unwind_Context,\n+                          arg: *mut libc::c_void) -> _Unwind_Reason_Code;\n \n         extern {\n             // No native _Unwind_Backtrace on iOS\n             #[cfg(not(target_os = \"ios\", target_arch = \"arm\"))]\n             pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n-                                     trace_argument: *libc::c_void)\n+                                     trace_argument: *mut libc::c_void)\n                         -> _Unwind_Reason_Code;\n \n             #[cfg(not(target_os = \"android\"),\n                   not(target_os = \"linux\", target_arch = \"arm\"))]\n-            pub fn _Unwind_GetIP(ctx: *_Unwind_Context) -> libc::uintptr_t;\n+            pub fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t;\n             #[cfg(not(target_os = \"android\"),\n                   not(target_os = \"linux\", target_arch = \"arm\"))]\n-            pub fn _Unwind_FindEnclosingFunction(pc: *libc::c_void)\n-                -> *libc::c_void;\n+            pub fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)\n+                -> *mut libc::c_void;\n         }\n \n         // On android, the function _Unwind_GetIP is a macro, and this is the\n         // expansion of the macro. This is all copy/pasted directly from the\n         // header file with the definition of _Unwind_GetIP.\n         #[cfg(target_os = \"android\")]\n         #[cfg(target_os = \"linux\", target_arch = \"arm\")]\n-        pub unsafe fn _Unwind_GetIP(ctx: *_Unwind_Context) -> libc::uintptr_t {\n+        pub unsafe fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t {\n             #[repr(C)]\n             enum _Unwind_VRS_Result {\n                 _UVRSR_OK = 0,\n@@ -608,7 +609,7 @@ mod imp {\n \n             type _Unwind_Word = libc::c_uint;\n             extern {\n-                fn _Unwind_VRS_Get(ctx: *_Unwind_Context,\n+                fn _Unwind_VRS_Get(ctx: *mut _Unwind_Context,\n                                    klass: _Unwind_VRS_RegClass,\n                                    word: _Unwind_Word,\n                                    repr: _Unwind_VRS_DataRepresentation,\n@@ -627,8 +628,8 @@ mod imp {\n         // a no-op\n         #[cfg(target_os = \"android\")]\n         #[cfg(target_os = \"linux\", target_arch = \"arm\")]\n-        pub unsafe fn _Unwind_FindEnclosingFunction(pc: *libc::c_void)\n-            -> *libc::c_void\n+        pub unsafe fn _Unwind_FindEnclosingFunction(pc: *mut libc::c_void)\n+            -> *mut libc::c_void\n         {\n             pc\n         }\n@@ -677,16 +678,16 @@ mod imp {\n         extern \"system\" fn(libc::HANDLE, u64, *mut u64,\n                            *mut SYMBOL_INFO) -> libc::BOOL;\n     type SymInitializeFn =\n-        extern \"system\" fn(libc::HANDLE, *libc::c_void,\n+        extern \"system\" fn(libc::HANDLE, *mut libc::c_void,\n                            libc::BOOL) -> libc::BOOL;\n     type SymCleanupFn =\n         extern \"system\" fn(libc::HANDLE) -> libc::BOOL;\n \n     type StackWalk64Fn =\n         extern \"system\" fn(libc::DWORD, libc::HANDLE, libc::HANDLE,\n                            *mut STACKFRAME64, *mut arch::CONTEXT,\n-                           *libc::c_void, *libc::c_void,\n-                           *libc::c_void, *libc::c_void) -> libc::BOOL;\n+                           *mut libc::c_void, *mut libc::c_void,\n+                           *mut libc::c_void, *mut libc::c_void) -> libc::BOOL;\n \n     static MAX_SYM_NAME: uint = 2000;\n     static IMAGE_FILE_MACHINE_I386: libc::DWORD = 0x014c;\n@@ -735,7 +736,7 @@ mod imp {\n         AddrFrame: ADDRESS64,\n         AddrStack: ADDRESS64,\n         AddrBStore: ADDRESS64,\n-        FuncTableEntry: *libc::c_void,\n+        FuncTableEntry: *mut libc::c_void,\n         Params: [u64, ..4],\n         Far: libc::BOOL,\n         Virtual: libc::BOOL,\n@@ -924,7 +925,7 @@ mod imp {\n \n         macro_rules! sym( ($e:expr, $t:ident) => (unsafe {\n             match lib.symbol($e) {\n-                Ok(f) => mem::transmute::<*u8, $t>(f),\n+                Ok(f) => mem::transmute::<*mut u8, $t>(f),\n                 Err(..) => return Ok(())\n             }\n         }) )\n@@ -944,16 +945,18 @@ mod imp {\n         let image = arch::init_frame(&mut frame, &context);\n \n         // Initialize this process's symbols\n-        let ret = SymInitialize(process, 0 as *libc::c_void, libc::TRUE);\n+        let ret = SymInitialize(process, 0 as *mut libc::c_void, libc::TRUE);\n         if ret != libc::TRUE { return Ok(()) }\n         let _c = Cleanup { handle: process, SymCleanup: SymCleanup };\n \n         // And now that we're done with all the setup, do the stack walking!\n         let mut i = 0i;\n         try!(write!(w, \"stack backtrace:\\n\"));\n         while StackWalk64(image, process, thread, &mut frame, &mut context,\n-                          0 as *libc::c_void, 0 as *libc::c_void,\n-                          0 as *libc::c_void, 0 as *libc::c_void) == libc::TRUE{\n+                          0 as *mut libc::c_void,\n+                          0 as *mut libc::c_void,\n+                          0 as *mut libc::c_void,\n+                          0 as *mut libc::c_void) == libc::TRUE{\n             let addr = frame.AddrPC.Offset;\n             if addr == frame.AddrReturn.Offset || addr == 0 ||\n                frame.AddrReturn.Offset == 0 { break }"}, {"sha": "19853138afd547ce5f44295429a4444486ac89d8", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -79,7 +79,7 @@ mod util;\n /// the crate's logging flags, registering GC\n /// metadata, and storing the process arguments.\n #[allow(experimental)]\n-pub fn init(argc: int, argv: **u8) {\n+pub fn init(argc: int, argv: *const *const u8) {\n     rustrt::init(argc, argv);\n     unsafe { unwind::register(failure::on_fail); }\n }"}, {"sha": "21d19deb0c7b6dcc7198dc7fbd931ea92f1bd98e", "filename": "src/libstd/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -511,10 +511,10 @@ mod test {\n         let (tx, rx) = channel::<uint>();\n \n         let x = box 1;\n-        let x_in_parent = (&*x) as *int as uint;\n+        let x_in_parent = (&*x) as *const int as uint;\n \n         spawnfn(proc() {\n-            let x_in_child = (&*x) as *int as uint;\n+            let x_in_child = (&*x) as *const int as uint;\n             tx.send(x_in_child);\n         });\n "}, {"sha": "cdd030ac34adcde2a09ddc3b9a722d88bf087283", "filename": "src/libsync/deque.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fdeque.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -137,7 +137,7 @@ pub struct BufferPool<T> {\n ///   2. We can certainly avoid bounds checks using *T instead of Vec<T>, although\n ///      LLVM is probably pretty good at doing this already.\n struct Buffer<T> {\n-    storage: *T,\n+    storage: *const T,\n     log_size: uint,\n }\n \n@@ -354,7 +354,7 @@ impl<T: Send> Buffer<T> {\n         let size = buffer_alloc_size::<T>(log_size);\n         let buffer = allocate(size, min_align_of::<T>());\n         Buffer {\n-            storage: buffer as *T,\n+            storage: buffer as *const T,\n             log_size: log_size,\n         }\n     }\n@@ -364,7 +364,9 @@ impl<T: Send> Buffer<T> {\n     // Apparently LLVM cannot optimize (foo % (1 << bar)) into this implicitly\n     fn mask(&self) -> int { (1 << self.log_size) - 1 }\n \n-    unsafe fn elem(&self, i: int) -> *T { self.storage.offset(i & self.mask()) }\n+    unsafe fn elem(&self, i: int) -> *const T {\n+        self.storage.offset(i & self.mask())\n+    }\n \n     // This does not protect against loading duplicate values of the same cell,\n     // nor does this clear out the contents contained within. Hence, this is a\n@@ -610,7 +612,8 @@ mod tests {\n             let s = s.clone();\n             let unique_box = box AtomicUint::new(0);\n             let thread_box = unsafe {\n-                *mem::transmute::<&Box<AtomicUint>, **mut AtomicUint>(&unique_box)\n+                *mem::transmute::<&Box<AtomicUint>,\n+                                  *const *mut AtomicUint>(&unique_box)\n             };\n             (Thread::start(proc() {\n                 unsafe {"}, {"sha": "2b6886ab7f434f25f72cf89ac950b7f4b91383c2", "filename": "src/libsync/mpsc_intrusive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibsync%2Fmpsc_intrusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibsync%2Fmpsc_intrusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpsc_intrusive.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -104,7 +104,7 @@ impl<T: Send> Queue<T> {\n             mem::transmute(&self.stub)\n         };\n         let mut next = (*tail).next(atomics::Relaxed);\n-        if tail as uint == &self.stub as *DummyNode as uint {\n+        if tail as uint == &self.stub as *const DummyNode as uint {\n             if next.is_null() {\n                 return None;\n             }"}, {"sha": "26cc0b2c6a23cd772889819cfad701cd48c523e3", "filename": "src/libsync/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -890,7 +890,7 @@ mod tests {\n         let x2 = x.clone();\n         let mut sharedstate = box 0;\n         {\n-            let ptr: *int = &*sharedstate;\n+            let ptr: *const int = &*sharedstate;\n             task::spawn(proc() {\n                 let sharedstate: &mut int =\n                     unsafe { mem::transmute(ptr) };"}, {"sha": "530ea013112386f1203d00135452273cc9ad4008", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -69,9 +69,9 @@ impl<T> OwnedSlice<T> {\n         static PTR_MARKER: u8 = 0;\n         let ptr = if self.data.is_null() {\n             // length zero, i.e. this will never be read as a T.\n-            &PTR_MARKER as *u8 as *T\n+            &PTR_MARKER as *const u8 as *const T\n         } else {\n-            self.data as *T\n+            self.data as *const T\n         };\n \n         let slice: &[T] = unsafe {mem::transmute(raw::Slice {"}, {"sha": "0fd5a7086b78c897507508137b3d7c410242a6a5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -1448,7 +1448,11 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(keywords::Const) {\n             MutImmutable\n         } else {\n-            // NOTE: after a stage0 snap this should turn into a span_err.\n+            let span = self.last_span;\n+            self.span_err(span,\n+                          \"bare raw pointers are no longer allowed, you should \\\n+                           likely use `*mut T`, but otherwise `*T` is now \\\n+                           known as `*const T`\");\n             MutImmutable\n         };\n         let t = self.parse_ty(true);"}, {"sha": "6719f25abb942f0c671661619fdfb6c60447b32a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -479,7 +479,11 @@ impl<'a> State<'a> {\n             }\n             ast::TyPtr(ref mt) => {\n                 try!(word(&mut self.s, \"*\"));\n-                try!(self.print_mt(mt));\n+                match mt.mutbl {\n+                    ast::MutMutable => try!(self.word_nbsp(\"mut\")),\n+                    ast::MutImmutable => try!(self.word_nbsp(\"const\")),\n+                }\n+                try!(self.print_type(&*mt.ty));\n             }\n             ast::TyRptr(ref lifetime, ref mt) => {\n                 try!(word(&mut self.s, \"&\"));"}, {"sha": "3ed7fccb933e667908d204c2199886dd690eec06", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -1091,7 +1091,7 @@ mod tests {\n         // `SetEnvironmentVariable`, which `os::setenv` internally uses.\n         // It is why we use `putenv` here.\n         extern {\n-            fn _putenv(envstring: *libc::c_char) -> libc::c_int;\n+            fn _putenv(envstring: *const libc::c_char) -> libc::c_int;\n         }\n \n         unsafe {"}, {"sha": "5c694b34193ef981489759aba1b064e90c9fd34d", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -1,3 +1,11 @@\n+S 2014-06-25 bab614f\n+  freebsd-x86_64 14cb361c8fdefa2534bb6776a04815c08680ecd6\n+  linux-i386 8fec4845626c557431a4aa7bfb2b5cfc65ad9eda\n+  linux-x86_64 2304534c8e2431a5da2086164dd3a3e019b87ecd\n+  macos-i386 d9e348cc1f9021f0f8e8907880fded80afb5db5b\n+  macos-x86_64 aa790195d1f8191dce2f990ec4323bcc69566288\n+  winnt-i386 19b67f8a583516553a4fe62e453eecc5c17aff8e\n+\n S 2014-06-21 db9af1d\n   freebsd-x86_64 ef2bd0fc0b0efa2bd6f5c1eaa60a2ec8df533254\n   linux-i386 84339ea0f796ae468ef86797ef4587274bec19ea"}, {"sha": "ee7787d6fccf56bb02d7f7f6a5b2a1fb3830353a", "filename": "src/test/auxiliary/issue13507.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fauxiliary%2Fissue13507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fauxiliary%2Fissue13507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue13507.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -64,7 +64,7 @@ pub mod testtypes {\n     // As with ty_str, what type should be used for ty_vec?\n \n     // Tests ty_ptr\n-    pub type FooPtr = *u8;\n+    pub type FooPtr = *const u8;\n \n     // Skipping ty_rptr\n "}, {"sha": "8065533dd738269766733fe45ec908a17c1deefc", "filename": "src/test/auxiliary/xcrate_static_addresses.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fauxiliary%2Fxcrate_static_addresses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fauxiliary%2Fxcrate_static_addresses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fxcrate_static_addresses.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -18,13 +18,13 @@ static global0: int = 4;\n pub static global2: &'static int = &global0;\n \n pub fn verify_same(a: &'static int) {\n-    let a = a as *int as uint;\n-    let b = &global as *int as uint;\n+    let a = a as *const int as uint;\n+    let b = &global as *const int as uint;\n     assert_eq!(a, b);\n }\n \n pub fn verify_same2(a: &'static int) {\n-    let a = a as *int as uint;\n-    let b = global2 as *int as uint;\n+    let a = a as *const int as uint;\n+    let b = global2 as *const int as uint;\n     assert_eq!(a, b);\n }"}, {"sha": "2737c6df533fec71f3b77fe47b0120c06f34fa36", "filename": "src/test/bench/rt-spawn-rate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-spawn-rate.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -21,7 +21,7 @@ use std::uint;\n // return.\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int {\n+fn start(argc: int, argv: *const *const u8) -> int {\n     green::start(argc, argv, rustuv::event_loop, main)\n }\n "}, {"sha": "1e5eedfa8a9eae6668cc046f900e51d8ff89924b", "filename": "src/test/bench/silly-test-spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fbench%2Fsilly-test-spawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fbench%2Fsilly-test-spawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsilly-test-spawn.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -17,7 +17,7 @@ extern crate green;\n extern crate rustuv;\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int {\n+fn start(argc: int, argv: *const *const u8) -> int {\n     green::start(argc, argv, rustuv::event_loop, main)\n }\n "}, {"sha": "30aed76a4ebdb04dadf032fc071f08d635a7189b", "filename": "src/test/compile-fail/borrowck-borrow-overloaded-auto-deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-auto-deref.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -14,7 +14,7 @@\n use std::ops::Deref;\n \n struct Rc<T> {\n-    value: *T\n+    value: *const T\n }\n \n impl<T> Deref<T> for Rc<T> {"}, {"sha": "5397c5b8a569fe92a58148ddd2d2621c4ed8d8f5", "filename": "src/test/compile-fail/borrowck-borrow-overloaded-deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -14,7 +14,7 @@\n use std::ops::Deref;\n \n struct Rc<T> {\n-    value: *T\n+    value: *const T\n }\n \n impl<T> Deref<T> for Rc<T> {"}, {"sha": "87bb8ef7a588221d03a4d068a57490583aa07294", "filename": "src/test/compile-fail/borrowck-move-from-unsafe-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fborrowck-move-from-unsafe-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fborrowck-move-from-unsafe-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-from-unsafe-ptr.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-fn foo(x: *Box<int>) -> Box<int> {\n+fn foo(x: *const Box<int>) -> Box<int> {\n     let y = *x; //~ ERROR dereference of unsafe pointer requires unsafe function or block\n     return y;\n }"}, {"sha": "1ea4a98c45beeefaf196787c5501b30931af1261", "filename": "src/test/compile-fail/borrowck-preserve-box-in-field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-field.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -28,12 +28,12 @@ pub fn main() {\n     borrow(x.f, |b_x| {\n     //~^ ERROR cannot borrow `x` as mutable because `*x.f` is also borrowed as immutable\n         assert_eq!(*b_x, 3);\n-        assert_eq!(&(*x.f) as *int, &(*b_x) as *int);\n+        assert_eq!(&(*x.f) as *const int, &(*b_x) as *const int);\n         //~^ NOTE borrow occurs due to use of `x` in closure\n         x = box(GC) F {f: box 4};\n \n         println!(\"&*b_x = {:p}\", &(*b_x));\n         assert_eq!(*b_x, 3);\n-        assert!(&(*x.f) as *int != &(*b_x) as *int);\n+        assert!(&(*x.f) as *const int != &(*b_x) as *const int);\n     })\n }"}, {"sha": "979791ad763f56b33cfa09e4be5d0435e6d18aab", "filename": "src/test/compile-fail/borrowck-preserve-box-in-uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box-in-uniq.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -28,12 +28,12 @@ pub fn main() {\n     borrow(x.f, |b_x| {\n     //~^ ERROR cannot borrow `x` as mutable because `*x.f` is also borrowed as immutable\n         assert_eq!(*b_x, 3);\n-        assert_eq!(&(*x.f) as *int, &(*b_x) as *int);\n+        assert_eq!(&(*x.f) as *const int, &(*b_x) as *const int);\n         //~^ NOTE  borrow occurs due to use of `x` in closure\n         *x = box(GC) F{f: box 4};\n \n         println!(\"&*b_x = {:p}\", &(*b_x));\n         assert_eq!(*b_x, 3);\n-        assert!(&(*x.f) as *int != &(*b_x) as *int);\n+        assert!(&(*x.f) as *const int != &(*b_x) as *const int);\n     })\n }"}, {"sha": "9eadb62c3a059b0dd911ec5d45b68749562ff1a8", "filename": "src/test/compile-fail/borrowck-preserve-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-box.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -26,12 +26,12 @@ pub fn main() {\n     borrow(x, |b_x| {\n     //~^ ERROR cannot borrow `x` as mutable because `*x` is also borrowed as immutable\n         assert_eq!(*b_x, 3);\n-        assert_eq!(&(*x) as *int, &(*b_x) as *int);\n+        assert_eq!(&(*x) as *const int, &(*b_x) as *const int);\n         //~^ NOTE borrow occurs due to use of `x` in closure\n         x = box(GC) 22;\n \n         println!(\"&*b_x = {:p}\", &(*b_x));\n         assert_eq!(*b_x, 3);\n-        assert!(&(*x) as *int != &(*b_x) as *int);\n+        assert!(&(*x) as *const int != &(*b_x) as *const int);\n     })\n }"}, {"sha": "066bb53cdc4d3ffc2cab5923e6c590b7fa0c561a", "filename": "src/test/compile-fail/borrowck-preserve-expl-deref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-expl-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-expl-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-preserve-expl-deref.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -28,12 +28,12 @@ pub fn main() {\n     borrow((*x).f, |b_x| {\n     //~^ ERROR cannot borrow `x` as mutable because `*x.f` is also borrowed as immutable\n         assert_eq!(*b_x, 3);\n-        assert_eq!(&(*x.f) as *int, &(*b_x) as *int);\n+        assert_eq!(&(*x.f) as *const int, &(*b_x) as *const int);\n         //~^ NOTE borrow occurs due to use of `x` in closure\n         x = box(GC) F {f: box 4};\n \n         println!(\"&*b_x = {:p}\", &(*b_x));\n         assert_eq!(*b_x, 3);\n-        assert!(&(*x.f) as *int != &(*b_x) as *int);\n+        assert!(&(*x.f) as *const int != &(*b_x) as *const int);\n     })\n }"}, {"sha": "f7d5ddb314557eeea18ae59ab5bb0c5d3a3fdbbb", "filename": "src/test/compile-fail/const-cast-different-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fconst-cast-different-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fconst-cast-different-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-cast-different-types.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n static a: &'static str = \"foo\";\n-static b: *u8 = a as *u8; //~ ERROR non-scalar cast\n-static c: *u8 = &a as *u8; //~ ERROR mismatched types\n+static b: *const u8 = a as *const u8; //~ ERROR non-scalar cast\n+static c: *const u8 = &a as *const u8; //~ ERROR mismatched types\n \n fn main() {\n }"}, {"sha": "223426dc7c6896c4f3f7621a346acc584a1013ce", "filename": "src/test/compile-fail/const-cast-wrong-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fconst-cast-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fconst-cast-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-cast-wrong-type.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n static a: [u8, ..3] = ['h' as u8, 'i' as u8, 0 as u8];\n-static b: *i8 = &a as *i8; //~ ERROR mismatched types\n+static b: *const i8 = &a as *const i8; //~ ERROR mismatched types\n \n fn main() {\n }"}, {"sha": "dc19b9d51c8c435446d444b075fb360757bb0455", "filename": "src/test/compile-fail/issue-14254.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fissue-14254.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fissue-14254.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14254.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -24,7 +24,7 @@ impl BarTy {\n     fn b(&self) {}\n }\n \n-impl Foo for *BarTy {\n+impl Foo for *const BarTy {\n     fn bar(&self) {\n         baz();\n         //~^ ERROR: unresolved name `baz`. Did you mean to call `self.baz`?\n@@ -76,7 +76,7 @@ impl Foo for Box<BarTy> {\n     }\n }\n \n-impl Foo for *int {\n+impl Foo for *const int {\n     fn bar(&self) {\n         baz();\n         //~^ ERROR: unresolved name `baz`. Did you mean to call `self.baz`?"}, {"sha": "920897e6828a04770c438d7fcd4b03856a915f8b", "filename": "src/test/compile-fail/issue-2995.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fissue-2995.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fissue-2995.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2995.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn bad (p: *int) {\n+fn bad (p: *const int) {\n     let _q: &int = p as &int; //~ ERROR non-scalar cast\n }\n "}, {"sha": "2d1ad9a2692ece90250e3075faf493649c60e4aa", "filename": "src/test/compile-fail/issue-3096-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fissue-3096-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fissue-3096-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3096-2.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -11,6 +11,6 @@\n enum bottom { }\n \n fn main() {\n-    let x = &() as *() as *bottom;\n+    let x = &() as *const () as *const bottom;\n     match x { } //~ ERROR non-exhaustive patterns\n }"}, {"sha": "aa3d9d9fef080691385ff4cf10650d1c12c035b0", "filename": "src/test/compile-fail/issue-9575.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fissue-9575.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fissue-9575.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-9575.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #[start]\n-fn start(argc: int, argv: **u8, crate_map: *u8) -> int {\n-    //~^ ERROR start function expects type: `fn(int, **u8) -> int`\n+fn start(argc: int, argv: *const *const u8, crate_map: *const u8) -> int {\n+    //~^ ERROR start function expects type: `fn(int, *const *const u8) -> int`\n     0\n }"}, {"sha": "f2a3d86ef0fd803e7ffd303a7fc56e8131b148c7", "filename": "src/test/compile-fail/kindck-copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -60,8 +60,8 @@ fn test<'a,T,U:Copy>(_: &'a int) {\n     assert_copy::<||>(); //~ ERROR does not fulfill\n \n     // unsafe ptrs are ok\n-    assert_copy::<*int>();\n-    assert_copy::<*&'a mut int>();\n+    assert_copy::<*const int>();\n+    assert_copy::<*const &'a mut int>();\n \n     // regular old ints and such are ok\n     assert_copy::<int>();"}, {"sha": "424c7a4e4303f3d2bb3fc8b3fb65585263606a79", "filename": "src/test/compile-fail/kindck-send.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -52,8 +52,8 @@ fn test<'a,T,U:Send>(_: &'a int) {\n     // assert_send::<Box<Dummy+'a>>(); // ERROR does not fulfill `Send`\n \n     // unsafe ptrs are ok unless they point at unsendable things\n-    assert_send::<*int>();\n-    assert_send::<*&'a int>(); //~ ERROR does not fulfill `Send`\n+    assert_send::<*const int>();\n+    assert_send::<*const &'a int>(); //~ ERROR does not fulfill `Send`\n }\n \n fn main() {"}, {"sha": "6c1b3ef67cc831e92c17ee81838bd1948ed8a4f7", "filename": "src/test/compile-fail/linkage3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Flinkage3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Flinkage3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flinkage3.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -11,7 +11,7 @@\n #![feature(linkage)]\n \n extern {\n-    #[linkage = \"foo\"] static foo: *i32;\n+    #[linkage = \"foo\"] static foo: *const i32;\n     //~^ ERROR: invalid linkage specified\n }\n "}, {"sha": "9e609814c8b3c2236d8b396f205bde670be5085e", "filename": "src/test/compile-fail/lint-ctypes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -15,11 +15,11 @@ extern crate libc;\n extern {\n     pub fn bare_type1(size: int); //~ ERROR: found rust type\n     pub fn bare_type2(size: uint); //~ ERROR: found rust type\n-    pub fn ptr_type1(size: *int); //~ ERROR: found rust type\n-    pub fn ptr_type2(size: *uint); //~ ERROR: found rust type\n+    pub fn ptr_type1(size: *const int); //~ ERROR: found rust type\n+    pub fn ptr_type2(size: *const uint); //~ ERROR: found rust type\n \n-    pub fn good1(size: *libc::c_int);\n-    pub fn good2(size: *libc::c_uint);\n+    pub fn good1(size: *const libc::c_int);\n+    pub fn good2(size: *const libc::c_uint);\n }\n \n fn main() {"}, {"sha": "f8e59ad13ad7a127bb84bdb95f7910433e91382b", "filename": "src/test/compile-fail/lint-dead-code-1.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -37,7 +37,7 @@ pub static used_static2: int = used_static;\n static USED_STATIC: int = 0;\n static STATIC_USED_IN_ENUM_DISCRIMINANT: uint = 10;\n \n-pub type typ = *UsedStruct4;\n+pub type typ = *const UsedStruct4;\n pub struct PubStruct;\n struct PrivStruct; //~ ERROR: code is never used\n struct UsedStruct1 {\n@@ -58,11 +58,11 @@ struct StructUsedInEnum;\n struct StructUsedInGeneric;\n pub struct PubStruct2 {\n     #[allow(dead_code)]\n-    struct_used_as_field: *StructUsedAsField\n+    struct_used_as_field: *const StructUsedAsField\n }\n \n pub enum pub_enum { foo1, bar1 }\n-pub enum pub_enum2 { a(*StructUsedInEnum) }\n+pub enum pub_enum2 { a(*const StructUsedInEnum) }\n pub enum pub_enum3 { Foo = STATIC_USED_IN_ENUM_DISCRIMINANT }\n enum priv_enum { foo2, bar2 } //~ ERROR: code is never used\n enum used_enum { foo3, bar3 }\n@@ -106,4 +106,4 @@ fn h() {}\n \n // Similarly, lang items are live\n #[lang=\"fail_\"]\n-fn fail(_: *u8, _: *u8, _: uint) -> ! { loop {} }\n+fn fail(_: *const u8, _: *const u8, _: uint) -> ! { loop {} }"}, {"sha": "4ad56ce915431deaf2f99abfef9df2708405d8f0", "filename": "src/test/compile-fail/lint-dead-code-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Flint-dead-code-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Flint-dead-code-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-2.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -36,7 +36,7 @@ fn dead_fn2() {} //~ ERROR: code is never used\n fn used_fn() {}\n \n #[start]\n-fn start(_: int, _: **u8) -> int {\n+fn start(_: int, _: *const *const u8) -> int {\n     used_fn();\n     let foo = Foo;\n     foo.bar2();"}, {"sha": "4687d66ca5391cd6087b8b7082535610877346ef", "filename": "src/test/compile-fail/lint-dead-code-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -54,8 +54,8 @@ mod blah {\n     enum c_void {}\n \n     extern {\n-        fn free(p: *c_void);\n-        fn malloc(size: size_t) -> *c_void;\n+        fn free(p: *const c_void);\n+        fn malloc(size: size_t) -> *const c_void;\n     }\n \n     pub fn baz() {\n@@ -65,7 +65,7 @@ mod blah {\n \n enum c_void {} //~ ERROR: code is never used\n extern {\n-    fn free(p: *c_void); //~ ERROR: code is never used\n+    fn free(p: *const c_void); //~ ERROR: code is never used\n }\n \n // Check provided method"}, {"sha": "da43324d494a53db9858b0e65d5a2584d60e8e69", "filename": "src/test/compile-fail/lint-raw-ptr-deriving.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Flint-raw-ptr-deriving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Flint-raw-ptr-deriving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-raw-ptr-deriving.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -14,22 +14,22 @@\n \n #[deriving(Clone)]\n struct Foo {\n-    x: *int //~ ERROR use of `#[deriving]` with a raw pointer\n+    x: *const int //~ ERROR use of `#[deriving]` with a raw pointer\n }\n \n #[deriving(Clone)]\n struct Bar(*mut int); //~ ERROR use of `#[deriving]` with a raw pointer\n \n #[deriving(Clone)]\n enum Baz {\n-    A(*int), //~ ERROR use of `#[deriving]` with a raw pointer\n+    A(*const int), //~ ERROR use of `#[deriving]` with a raw pointer\n     B { x: *mut int } //~ ERROR use of `#[deriving]` with a raw pointer\n }\n \n #[deriving(Clone)]\n struct Buzz {\n-    x: (*int, //~ ERROR use of `#[deriving]` with a raw pointer\n-        *uint) //~ ERROR use of `#[deriving]` with a raw pointer\n+    x: (*const int, //~ ERROR use of `#[deriving]` with a raw pointer\n+        *const uint) //~ ERROR use of `#[deriving]` with a raw pointer\n }\n \n fn main() {}"}, {"sha": "cd134ccf71d7e20c73e7b02943101f53461a714b", "filename": "src/test/compile-fail/non-copyable-void.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -11,8 +11,8 @@\n extern crate libc;\n \n fn main() {\n-    let x : *Vec<int> = &vec!(1,2,3);\n-    let y : *libc::c_void = x as *libc::c_void;\n+    let x : *const Vec<int> = &vec!(1,2,3);\n+    let y : *const libc::c_void = x as *const libc::c_void;\n     unsafe {\n         let _z = (*y).clone();\n         //~^ ERROR does not implement any method in scope"}, {"sha": "015d221e7efe78b37a1f429d0aa3a296254ced8a", "filename": "src/test/compile-fail/privacy1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -184,4 +184,4 @@ pub mod mytest {\n     }\n }\n \n-#[start] fn main(_: int, _: **u8) -> int { 3 }\n+#[start] fn main(_: int, _: *const *const u8) -> int { 3 }"}, {"sha": "1a94751b46bfe9d01ab2c672b51ec9e52cf95f98", "filename": "src/test/compile-fail/privacy2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fprivacy2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fprivacy2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy2.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -33,5 +33,5 @@ fn test2() {\n     //~^ ERROR unresolved import `bar::glob::foo`. There is no `foo` in `bar::glob`\n }\n \n-#[start] fn main(_: int, _: **u8) -> int { 3 }\n+#[start] fn main(_: int, _: *const *const u8) -> int { 3 }\n "}, {"sha": "4c67a9910cfe9ebf2dd83ec15f97e90e88b8fd9a", "filename": "src/test/compile-fail/privacy3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fprivacy3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fprivacy3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy3.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -30,4 +30,4 @@ fn test1() {\n     gpriv();\n }\n \n-#[start] fn main(_: int, _: **u8) -> int { 3 }\n+#[start] fn main(_: int, _: *const *const u8) -> int { 3 }"}, {"sha": "65f4a0e950ff6a32ff9f03743dd27c86518eacee", "filename": "src/test/compile-fail/privacy4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fprivacy4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fprivacy4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy4.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -29,4 +29,4 @@ fn test2() {\n     gpriv();\n }\n \n-#[start] fn main(_: int, _: **u8) -> int { 3 }\n+#[start] fn main(_: int, _: *const *const u8) -> int { 3 }"}, {"sha": "97908118e3518fa82ba54d64a8f2c076b7ce8fa9", "filename": "src/test/compile-fail/unsafe-fn-assign-deref-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Funsafe-fn-assign-deref-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Funsafe-fn-assign-deref-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-assign-deref-ptr.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-fn f(p: *u8) {\n+fn f(p: *const u8) {\n     *p = 0u8; //~ ERROR dereference of unsafe pointer requires unsafe function or block\n     return;\n }"}, {"sha": "464abd57872bcd56c50a3154e9c1eed2263e308a", "filename": "src/test/compile-fail/unsafe-fn-autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Funsafe-fn-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Funsafe-fn-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-autoderef.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -12,7 +12,7 @@ struct Rec {\n     f: int\n }\n \n-fn f(p: *Rec) -> int {\n+fn f(p: *const Rec) -> int {\n \n     // Test that * ptrs do not autoderef.  There is a deeper reason for\n     // prohibiting this, beyond making unsafe things annoying (which doesn't\n@@ -26,7 +26,7 @@ fn f(p: *Rec) -> int {\n     // are prohibited by various checks, such as that the enum is\n     // instantiable and so forth).\n \n-    return p.f; //~ ERROR attempted access of field `f` on type `*Rec`\n+    return p.f; //~ ERROR attempted access of field `f` on type `*const Rec`\n }\n \n fn main() {"}, {"sha": "bdf079e24d2a1e40af13796ba5ad172038152a7c", "filename": "src/test/compile-fail/unsafe-fn-deref-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Funsafe-fn-deref-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Funsafe-fn-deref-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-deref-ptr.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-fn f(p: *u8) -> u8 {\n+fn f(p: *const u8) -> u8 {\n     return *p; //~ ERROR dereference of unsafe pointer requires unsafe function or block\n }\n "}, {"sha": "2110d4c80095a79f0dc5cd67eb2382e296caf2cb", "filename": "src/test/compile-fail/variadic-ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariadic-ffi.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n extern \"stdcall\" {\n-    fn printf(_: *u8, ...); //~ ERROR: variadic function must have C calling convention\n+    fn printf(_: *const u8, ...); //~ ERROR: variadic function must have C calling convention\n }\n \n extern {"}, {"sha": "e096e5eb436298556ab7a0ceb2bf6c7958b2f799", "filename": "src/test/compile-fail/vector-cast-weirdness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fvector-cast-weirdness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fvector-cast-weirdness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvector-cast-weirdness.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -18,9 +18,9 @@ struct X {\n fn main() {\n     let x1 = X { y: [0, 0] };\n \n-    let p1: *u8 = &x1.y as *_;  //~ ERROR mismatched types\n-    let t1: *[u8, ..2] = &x1.y as *_;\n-    let h1: *[u8, ..2] = &x1.y as *[u8, ..2];\n+    let p1: *const u8 = &x1.y as *const _;  //~ ERROR mismatched types\n+    let t1: *const [u8, ..2] = &x1.y as *const _;\n+    let h1: *const [u8, ..2] = &x1.y as *const [u8, ..2];\n \n     let mut x1 = X { y: [0, 0] };\n "}, {"sha": "cfa6623176ca3a199f0a2d1d2cf191309b902413", "filename": "src/test/compile-fail/warn-foreign-int-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fwarn-foreign-int-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Fcompile-fail%2Fwarn-foreign-int-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwarn-foreign-int-types.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -13,7 +13,7 @@\n \n mod xx {\n     extern {\n-        pub fn strlen(str: *u8) -> uint; //~ ERROR found rust type `uint`\n+        pub fn strlen(str: *const u8) -> uint; //~ ERROR found rust type `uint`\n         pub fn foo(x: int, y: uint); //~ ERROR found rust type `int`\n         //~^ ERROR found rust type `uint`\n     }"}, {"sha": "ae3924ba9356cbd7525c7b72a82b9eb8cd518a33", "filename": "src/test/run-fail/native-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-fail%2Fnative-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-fail%2Fnative-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fnative-failure.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -14,7 +14,7 @@\n extern crate native;\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int {\n+fn start(argc: int, argv: *const *const u8) -> int {\n     native::start(argc, argv, proc() {\n         fail!();\n     })"}, {"sha": "c370846c673db5240610f89512664d48eb228cab", "filename": "src/test/run-fail/unwind-box-res.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-fail%2Funwind-box-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-fail%2Funwind-box-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-res.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -22,7 +22,7 @@ fn failfn() {\n }\n \n struct r {\n-  v: *int,\n+  v: *const int,\n }\n \n impl Drop for r {\n@@ -33,7 +33,7 @@ impl Drop for r {\n     }\n }\n \n-fn r(v: *int) -> r {\n+fn r(v: *const int) -> r {\n     r {\n         v: v\n     }"}, {"sha": "69c65ef8b037a2869ee00682bf449942c742565d", "filename": "src/test/run-make/bootstrap-from-c-with-green/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Flib.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -15,7 +15,7 @@ extern crate rustuv;\n extern crate green;\n \n #[no_mangle] // this needs to get called from C\n-pub extern \"C\" fn foo(argc: int, argv: **u8) -> int {\n+pub extern \"C\" fn foo(argc: int, argv: *const *const u8) -> int {\n     green::start(argc, argv, rustuv::event_loop, proc() {\n         spawn(proc() {\n             println!(\"hello\");"}, {"sha": "d211167626d77fd3eecd460c4e8f95073c972b49", "filename": "src/test/run-make/bootstrap-from-c-with-native/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -14,7 +14,7 @@\n extern crate native;\n \n #[no_mangle] // this needs to get called from C\n-pub extern \"C\" fn foo(argc: int, argv: **u8) -> int {\n+pub extern \"C\" fn foo(argc: int, argv: *const *const u8) -> int {\n     native::start(argc, argv, proc() {\n         spawn(proc() {\n             println!(\"hello\");"}, {"sha": "3bea7e84807cea3e632e8bcdbc44f3238741092f", "filename": "src/test/run-pass/attr-start.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fattr-start.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fattr-start.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fattr-start.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -10,6 +10,6 @@\n \n \n #[start]\n-fn start(_argc: int, _argv: **u8) -> int {\n+fn start(_argc: int, _argv: *const *const u8) -> int {\n     return 0;\n }"}, {"sha": "97862844030b2c7c52ba97f790bfdec300246ea3", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -18,7 +18,9 @@ use std::finally::Finally;\n use std::str;\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int { native::start(argc, argv, main) }\n+fn start(argc: int, argv: *const *const u8) -> int {\n+    native::start(argc, argv, main)\n+}\n \n #[inline(never)]\n fn foo() {"}, {"sha": "218247008601d3469837a678716fe16356e91b62", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -52,9 +52,9 @@ fn test_box() {\n \n fn test_ptr() {\n     unsafe {\n-        let p1: *u8 = ::std::mem::transmute(0u);\n-        let p2: *u8 = ::std::mem::transmute(0u);\n-        let p3: *u8 = ::std::mem::transmute(1u);\n+        let p1: *const u8 = ::std::mem::transmute(0u);\n+        let p2: *const u8 = ::std::mem::transmute(0u);\n+        let p3: *const u8 = ::std::mem::transmute(1u);\n \n         assert_eq!(p1, p2);\n         assert!(p1 != p3);\n@@ -86,8 +86,8 @@ fn test_class() {\n \n   unsafe {\n   println!(\"q = {:x}, r = {:x}\",\n-         (::std::mem::transmute::<*p, uint>(&q)),\n-         (::std::mem::transmute::<*p, uint>(&r)));\n+         (::std::mem::transmute::<*const p, uint>(&q)),\n+         (::std::mem::transmute::<*const p, uint>(&r)));\n   }\n   assert_eq!(q, r);\n   r.y = 17;"}, {"sha": "c9e1c2c8d42c6450b67bcc1173d7b71a6da7fe2f", "filename": "src/test/run-pass/borrowck-borrow-from-expr-block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -18,8 +18,8 @@ fn borrow(x: &int, f: |x: &int|) {\n \n fn test1(x: Gc<Box<int>>) {\n     borrow(&*(*x).clone(), |p| {\n-        let x_a = &**x as *int;\n-        assert!((x_a as uint) != (p as *int as uint));\n+        let x_a = &**x as *const int;\n+        assert!((x_a as uint) != (p as *const int as uint));\n         assert_eq!(unsafe{*x_a}, *p);\n     })\n }"}, {"sha": "597e067b8b6ae22932dc63046b95403c5a39bfb6", "filename": "src/test/run-pass/c-stack-returning-int64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -16,8 +16,8 @@ mod mlibc {\n     use libc::{c_char, c_long, c_longlong};\n \n     extern {\n-        pub fn atol(x: *c_char) -> c_long;\n-        pub fn atoll(x: *c_char) -> c_longlong;\n+        pub fn atol(x: *const c_char) -> c_long;\n+        pub fn atoll(x: *const c_char) -> c_longlong;\n     }\n }\n "}, {"sha": "19186f4b46bcef9fb0fd50168477d58c822715f3", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -31,7 +31,7 @@ impl Logger for MyWriter {\n }\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int {\n+fn start(argc: int, argv: *const *const u8) -> int {\n     native::start(argc, argv, proc() {\n         main();\n     })"}, {"sha": "a298a08a1b7a099bcce4a7e20e38168a0269a735", "filename": "src/test/run-pass/cast-region-to-uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fcast-region-to-uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fcast-region-to-uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast-region-to-uint.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -10,5 +10,5 @@\n \n pub fn main() {\n     let x = 3;\n-    println!(\"&x={:x}\", (&x as *int as uint));\n+    println!(\"&x={:x}\", (&x as *const int as uint));\n }"}, {"sha": "01eccc53427877de3d82edc8856788e0ed7ca605", "filename": "src/test/run-pass/const-block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fconst-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fconst-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-block.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -13,7 +13,7 @@\n \n struct Foo {\n     a: uint,\n-    b: *()\n+    b: *const ()\n }\n \n fn foo<T>(a: T) -> T {\n@@ -25,7 +25,7 @@ static BLOCK_EXPLICIT_UNIT: () = { () };\n static BLOCK_IMPLICIT_UNIT: () = { };\n static BLOCK_FLOAT: f64 = { 1.0 };\n static BLOCK_ENUM: Option<uint> = { Some(100) };\n-static BLOCK_STRUCT: Foo = { Foo { a: 12, b: 0 as *() } };\n+static BLOCK_STRUCT: Foo = { Foo { a: 12, b: 0 as *const () } };\n static BLOCK_UNSAFE: uint = unsafe { 1000 };\n \n // FIXME: #13970\n@@ -50,7 +50,7 @@ pub fn main() {\n     assert_eq!(BLOCK_IMPLICIT_UNIT, ());\n     assert_eq!(BLOCK_FLOAT, 1.0_f64);\n     assert_eq!(BLOCK_STRUCT.a, 12);\n-    assert_eq!(BLOCK_STRUCT.b, 0 as *());\n+    assert_eq!(BLOCK_STRUCT.b, 0 as *const ());\n     assert_eq!(BLOCK_ENUM, Some(100));\n     assert_eq!(BLOCK_UNSAFE, 1000);\n "}, {"sha": "e4734fc3e55aa9bec0923940f882995f0c2adee2", "filename": "src/test/run-pass/const-cast-ptr-int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fconst-cast-ptr-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fconst-cast-ptr-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-cast-ptr-int.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -10,7 +10,7 @@\n \n use std::ptr;\n \n-static a: *u8 = 0 as *u8;\n+static a: *const u8 = 0 as *const u8;\n \n pub fn main() {\n     assert_eq!(a, ptr::null());"}, {"sha": "87a4fd1153f8229496501df8cca84487e063ef9e", "filename": "src/test/run-pass/const-cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fconst-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fconst-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-cast.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -13,11 +13,11 @@ extern crate libc;\n extern fn foo() {}\n \n static x: extern \"C\" fn() = foo;\n-static y: *libc::c_void = x as *libc::c_void;\n+static y: *const libc::c_void = x as *const libc::c_void;\n static a: &'static int = &10;\n-static b: *int = a as *int;\n+static b: *const int = a as *const int;\n \n pub fn main() {\n-    assert_eq!(x as *libc::c_void, y);\n-    assert_eq!(a as *int, b);\n+    assert_eq!(x as *const libc::c_void, y);\n+    assert_eq!(a as *const int, b);\n }"}, {"sha": "36fe021b97e1447628df28cb252b78724a76eafa", "filename": "src/test/run-pass/const-region-ptrs-noncopy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -14,5 +14,5 @@ static x: &'static Big = &([13, 14, 10, 13, 11, 14, 14, 15]);\n static y: &'static Pair<'static> = &Pair {a: 15, b: x};\n \n pub fn main() {\n-    assert_eq!(x as *Big, y.b as *Big);\n+    assert_eq!(x as *const Big, y.b as *const Big);\n }"}, {"sha": "51f5855bb92a08f12c991428077fe3d95041b52b", "filename": "src/test/run-pass/const-str-ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -12,16 +12,16 @@ use std::str;\n \n static A: [u8, ..2] = ['h' as u8, 'i' as u8];\n static B: &'static [u8, ..2] = &A;\n-static C: *u8 = B as *u8;\n+static C: *const u8 = B as *const u8;\n \n pub fn main() {\n     unsafe {\n-        let foo = &A as *u8;\n+        let foo = &A as *const u8;\n         assert_eq!(str::raw::from_utf8(A), \"hi\");\n         assert_eq!(str::raw::from_buf_len(foo, A.len()), \"hi\".to_string());\n         assert_eq!(str::raw::from_buf_len(C, B.len()), \"hi\".to_string());\n         assert!(*C == A[0]);\n-        assert!(*(&B[0] as *u8) == A[0]);\n+        assert!(*(&B[0] as *const u8) == A[0]);\n \n         let bar = str::raw::from_utf8(A).to_c_str();\n         assert_eq!(bar.with_ref(|buf| str::raw::from_c_str(buf)), \"hi\".to_string());"}, {"sha": "8e84278c10e02ab235ba2fd039df06dbb6a99766", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -54,7 +54,7 @@ macro_rules! iotest (\n )\n \n #[cfg(test)] #[start]\n-fn start(argc: int, argv: **u8) -> int {\n+fn start(argc: int, argv: *const *const u8) -> int {\n     green::start(argc, argv, rustuv::event_loop, __test::main)\n }\n "}, {"sha": "a1ef12a7657fe50deaab40a2b319979f3e1dca0f", "filename": "src/test/run-pass/enum-alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fenum-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fenum-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-alignment.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -11,7 +11,7 @@\n use std::mem;\n \n fn addr_of<T>(ptr: &T) -> uint {\n-    ptr as *T as uint\n+    ptr as *const T as uint\n }\n \n fn is_aligned<T>(ptr: &T) -> bool {"}, {"sha": "cefc266b5c764019ccda14b0211a607964d88eb2", "filename": "src/test/run-pass/extern-pub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fextern-pub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fextern-pub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pub.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n extern {\n-    pub fn free(p: *u8);\n+    pub fn free(p: *const u8);\n }\n \n pub fn main() {"}, {"sha": "21238e68b3143f59cd64362a59a2428cfd3a95b3", "filename": "src/test/run-pass/foreign-call-no-runtime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -30,7 +30,7 @@ pub fn main() {\n \n extern fn callback(data: libc::uintptr_t) {\n     unsafe {\n-        let data: *int = mem::transmute(data);\n+        let data: *const int = mem::transmute(data);\n         assert_eq!(*data, 100);\n     }\n }"}, {"sha": "750c0c8ed682ab63cf71643d6f35fc308f3c1541", "filename": "src/test/run-pass/foreign-fn-linkname.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -18,7 +18,7 @@ mod mlibc {\n \n     extern {\n         #[link_name = \"strlen\"]\n-        pub fn my_strlen(str: *c_char) -> size_t;\n+        pub fn my_strlen(str: *const c_char) -> size_t;\n     }\n }\n "}, {"sha": "ce2f895566439433143810603ae1b87984796622", "filename": "src/test/run-pass/foreign2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fforeign2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fforeign2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign2.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -24,7 +24,7 @@ mod mlibc {\n     use libc::{c_int, c_void, size_t, ssize_t};\n \n     extern {\n-        pub fn write(fd: c_int, buf: *c_void, count: size_t) -> ssize_t;\n+        pub fn write(fd: c_int, buf: *const c_void, count: size_t) -> ssize_t;\n     }\n }\n "}, {"sha": "6d06c12c4507e033326b59cde040482228165a06", "filename": "src/test/run-pass/func-arg-incomplete-pattern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Ffunc-arg-incomplete-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Ffunc-arg-incomplete-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffunc-arg-incomplete-pattern.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -17,14 +17,14 @@ struct Foo {\n     y: Box<uint>,\n }\n \n-fn foo(Foo {x, ..}: Foo) -> *uint {\n-    let addr: *uint = &*x;\n+fn foo(Foo {x, ..}: Foo) -> *const uint {\n+    let addr: *const uint = &*x;\n     addr\n }\n \n pub fn main() {\n     let obj = box 1;\n-    let objptr: *uint = &*obj;\n+    let objptr: *const uint = &*obj;\n     let f = Foo {x: obj, y: box 2};\n     let xptr = foo(f);\n     assert_eq!(objptr, xptr);"}, {"sha": "5eeace65054009bf70913acf6121a9a5572f9067", "filename": "src/test/run-pass/func-arg-ref-pattern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Ffunc-arg-ref-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Ffunc-arg-ref-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffunc-arg-ref-pattern.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -15,8 +15,8 @@\n // pattern.\n \n \n-fn getaddr(box ref x: Box<uint>) -> *uint {\n-    let addr: *uint = &*x;\n+fn getaddr(box ref x: Box<uint>) -> *const uint {\n+    let addr: *const uint = &*x;\n     addr\n }\n \n@@ -26,7 +26,7 @@ fn checkval(box ref x: Box<uint>) -> uint {\n \n pub fn main() {\n     let obj = box 1;\n-    let objptr: *uint = &*obj;\n+    let objptr: *const uint = &*obj;\n     let xptr = getaddr(obj);\n     assert_eq!(objptr, xptr);\n "}, {"sha": "1258a498dacb4e4368918588176ebc2bfbf7be29", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -69,7 +69,7 @@ pub fn main() {\n     t!(format!(\"{:X}\", 10u), \"A\");\n     t!(format!(\"{:s}\", \"foo\"), \"foo\");\n     t!(format!(\"{:s}\", \"foo\".to_string()), \"foo\");\n-    t!(format!(\"{:p}\", 0x1234 as *int), \"0x1234\");\n+    t!(format!(\"{:p}\", 0x1234 as *const int), \"0x1234\");\n     t!(format!(\"{:p}\", 0x1234 as *mut int), \"0x1234\");\n     t!(format!(\"{:d}\", A), \"aloha\");\n     t!(format!(\"{:d}\", B), \"adios\");"}, {"sha": "35897d5b823f1e9dcc628dabb704fad5eb58a0f8", "filename": "src/test/run-pass/instantiable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Finstantiable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Finstantiable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finstantiable.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -14,7 +14,7 @@ use std::ptr;\n // even though it would be if the nxt field had type @foo:\n struct foo(X);\n \n-struct X { x: uint, nxt: *foo }\n+struct X { x: uint, nxt: *const foo }\n \n pub fn main() {\n     let _x = foo(X {x: 0, nxt: ptr::null()});"}, {"sha": "3b81943000bf83192490d71bd5861a6ef90f188c", "filename": "src/test/run-pass/intrinsic-atomics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -16,8 +16,8 @@ mod rusti {\n         pub fn atomic_cxchg_acq<T>(dst: *mut T, old: T, src: T) -> T;\n         pub fn atomic_cxchg_rel<T>(dst: *mut T, old: T, src: T) -> T;\n \n-        pub fn atomic_load<T>(src: *T) -> T;\n-        pub fn atomic_load_acq<T>(src: *T) -> T;\n+        pub fn atomic_load<T>(src: *const T) -> T;\n+        pub fn atomic_load_acq<T>(src: *const T) -> T;\n \n         pub fn atomic_store<T>(dst: *mut T, val: T);\n         pub fn atomic_store_rel<T>(dst: *mut T, val: T);"}, {"sha": "f1bbf353f717d23ca8bf0bf6329481fd46a96744", "filename": "src/test/run-pass/intrinsic-move-val.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -23,7 +23,7 @@ pub fn main() {\n     unsafe {\n         let x = box 1i;\n         let mut y = rusti::init();\n-        let mut z: *uint = transmute(&x);\n+        let mut z: *const uint = transmute(&x);\n         rusti::move_val_init(&mut y, x);\n         assert_eq!(*y, 1);\n         assert_eq!(*z, 0); // `x` is nulled out, not directly visible"}, {"sha": "37e675b52ebd886d342c73f6a6f9b1e77960fad2", "filename": "src/test/run-pass/issue-12684.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-12684.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-12684.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12684.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -14,7 +14,7 @@ extern crate green;\n extern crate rustuv;\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int {\n+fn start(argc: int, argv: *const *const u8) -> int {\n     green::start(argc, argv, rustuv::event_loop, main)\n }\n "}, {"sha": "c24128f97e372a47954b24ce7b98182e3ad2a6df", "filename": "src/test/run-pass/issue-12699.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-12699.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-12699.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12699.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -14,7 +14,7 @@ extern crate native;\n use std::io::timer;\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int {\n+fn start(argc: int, argv: *const *const u8) -> int {\n     native::start(argc, argv, main)\n }\n "}, {"sha": "6ca605742efa9fe799b8fb01354e784e68528c4d", "filename": "src/test/run-pass/issue-13304.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13304.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -19,7 +19,7 @@ use std::io;\n use std::str;\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int {\n+fn start(argc: int, argv: *const *const u8) -> int {\n     green::start(argc, argv, rustuv::event_loop, main)\n }\n "}, {"sha": "528e6d43cef730e3b41ac0865f0015d9c8bb8321", "filename": "src/test/run-pass/issue-13494.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-13494.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-13494.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13494.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -16,7 +16,7 @@ extern crate rustuv;\n extern crate native;\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int {\n+fn start(argc: int, argv: *const *const u8) -> int {\n     green::start(argc, argv, rustuv::event_loop, main)\n }\n "}, {"sha": "160828d42fc54a768bc8c0ad4c3bffedc86b0517", "filename": "src/test/run-pass/issue-14254.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-14254.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-14254.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14254.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -25,11 +25,11 @@ impl BarTy {\n }\n \n // If these fail, it's necessary to update middle::resolve and the cfail tests.\n-impl Foo for *BarTy {\n+impl Foo for *const BarTy {\n     fn bar(&self) {\n         self.baz();\n         BarTy::a();\n-        Foo::bah(None::<*BarTy>);\n+        Foo::bah(None::<*const BarTy>);\n     }\n }\n \n@@ -66,10 +66,10 @@ impl Foo for Box<BarTy> {\n }\n \n // If these fail, it's necessary to update middle::resolve and the cfail tests.\n-impl Foo for *int {\n+impl Foo for *const int {\n     fn bar(&self) {\n         self.baz();\n-        Foo::bah(None::<*int>);\n+        Foo::bah(None::<*const int>);\n     }\n }\n "}, {"sha": "10ae2749a090202073e148129e2c2bc1e86ffbb3", "filename": "src/test/run-pass/issue-1866.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-1866.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-1866.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1866.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -13,7 +13,7 @@ mod a {\n     pub mod rustrt {\n         use super::rust_task;\n         extern {\n-            pub fn rust_task_is_unwinding(rt: *rust_task) -> bool;\n+            pub fn rust_task_is_unwinding(rt: *const rust_task) -> bool;\n         }\n     }\n }\n@@ -23,7 +23,7 @@ mod b {\n     pub mod rustrt {\n         use super::rust_task;\n         extern {\n-            pub fn rust_task_is_unwinding(rt: *rust_task) -> bool;\n+            pub fn rust_task_is_unwinding(rt: *const rust_task) -> bool;\n         }\n     }\n }"}, {"sha": "b4807964d46dd4d8abeac5bacb13f3bb9e457ec4", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -42,9 +42,9 @@ pub mod pipes {\n         payload: Option<T>\n     }\n \n-    pub fn packet<T:Send>() -> *packet<T> {\n+    pub fn packet<T:Send>() -> *const packet<T> {\n         unsafe {\n-            let p: *packet<T> = mem::transmute(box Stuff{\n+            let p: *const packet<T> = mem::transmute(box Stuff{\n                 state: empty,\n                 blocked_task: None::<Task>,\n                 payload: None::<T>\n@@ -61,7 +61,7 @@ pub mod pipes {\n \n     // We should consider moving this to ::std::unsafe, although I\n     // suspect graydon would want us to use void pointers instead.\n-    pub unsafe fn uniquify<T>(x: *T) -> Box<T> {\n+    pub unsafe fn uniquify<T>(x: *const T) -> Box<T> {\n         mem::transmute(x)\n     }\n \n@@ -123,7 +123,7 @@ pub mod pipes {\n         }\n     }\n \n-    pub fn sender_terminate<T:Send>(p: *packet<T>) {\n+    pub fn sender_terminate<T:Send>(p: *const packet<T>) {\n         let mut p = unsafe { uniquify(p) };\n         match swap_state_rel(&mut (*p).state, terminated) {\n           empty | blocked => {\n@@ -140,7 +140,7 @@ pub mod pipes {\n         }\n     }\n \n-    pub fn receiver_terminate<T:Send>(p: *packet<T>) {\n+    pub fn receiver_terminate<T:Send>(p: *const packet<T>) {\n         let mut p = unsafe { uniquify(p) };\n         match swap_state_rel(&mut (*p).state, terminated) {\n           empty => {\n@@ -158,15 +158,15 @@ pub mod pipes {\n     }\n \n     pub struct send_packet<T> {\n-        p: Option<*packet<T>>,\n+        p: Option<*const packet<T>>,\n     }\n \n     #[unsafe_destructor]\n     impl<T:Send> Drop for send_packet<T> {\n         fn drop(&mut self) {\n             unsafe {\n                 if self.p != None {\n-                    let self_p: &mut Option<*packet<T>> =\n+                    let self_p: &mut Option<*const packet<T>> =\n                         mem::transmute(&self.p);\n                     let p = replace(self_p, None);\n                     sender_terminate(p.unwrap())\n@@ -176,27 +176,27 @@ pub mod pipes {\n     }\n \n     impl<T:Send> send_packet<T> {\n-        pub fn unwrap(&mut self) -> *packet<T> {\n+        pub fn unwrap(&mut self) -> *const packet<T> {\n             replace(&mut self.p, None).unwrap()\n         }\n     }\n \n-    pub fn send_packet<T:Send>(p: *packet<T>) -> send_packet<T> {\n+    pub fn send_packet<T:Send>(p: *const packet<T>) -> send_packet<T> {\n         send_packet {\n             p: Some(p)\n         }\n     }\n \n     pub struct recv_packet<T> {\n-        p: Option<*packet<T>>,\n+        p: Option<*const packet<T>>,\n     }\n \n     #[unsafe_destructor]\n     impl<T:Send> Drop for recv_packet<T> {\n         fn drop(&mut self) {\n             unsafe {\n                 if self.p != None {\n-                    let self_p: &mut Option<*packet<T>> =\n+                    let self_p: &mut Option<*const packet<T>> =\n                         mem::transmute(&self.p);\n                     let p = replace(self_p, None);\n                     receiver_terminate(p.unwrap())\n@@ -206,12 +206,12 @@ pub mod pipes {\n     }\n \n     impl<T:Send> recv_packet<T> {\n-        pub fn unwrap(&mut self) -> *packet<T> {\n+        pub fn unwrap(&mut self) -> *const packet<T> {\n             replace(&mut self.p, None).unwrap()\n         }\n     }\n \n-    pub fn recv_packet<T:Send>(p: *packet<T>) -> recv_packet<T> {\n+    pub fn recv_packet<T:Send>(p: *const packet<T>) -> recv_packet<T> {\n         recv_packet {\n             p: Some(p)\n         }\n@@ -231,7 +231,7 @@ pub mod pingpong {\n \n     pub fn liberate_ping(p: ping) -> ::pipes::send_packet<pong> {\n         unsafe {\n-            let _addr : *::pipes::send_packet<pong> = match &p {\n+            let _addr : *const ::pipes::send_packet<pong> = match &p {\n               &ping(ref x) => { mem::transmute(x) }\n             };\n             fail!()\n@@ -240,7 +240,7 @@ pub mod pingpong {\n \n     pub fn liberate_pong(p: pong) -> ::pipes::send_packet<ping> {\n         unsafe {\n-            let _addr : *::pipes::send_packet<ping> = match &p {\n+            let _addr : *const ::pipes::send_packet<ping> = match &p {\n               &pong(ref x) => { mem::transmute(x) }\n             };\n             fail!()"}, {"sha": "8fd603781ba61e76de0f8e9cab3658054398116c", "filename": "src/test/run-pass/issue-3656.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-3656.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-3656.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3656.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -18,7 +18,7 @@ use libc::{c_uint, uint32_t, c_void};\n struct KEYGEN {\n     hash_algorithm: [c_uint, ..2],\n     count: uint32_t,\n-    salt: *c_void,\n+    salt: *const c_void,\n     salt_size: uint32_t,\n }\n "}, {"sha": "7730d75a3a9c21bb6535a4e8ffb15e1c22eb64cc", "filename": "src/test/run-pass/issue-4735.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-4735.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-4735.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4735.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -15,17 +15,17 @@ extern crate libc;\n use std::mem::transmute;\n use libc::c_void;\n \n-struct NonCopyable(*c_void);\n+struct NonCopyable(*const c_void);\n \n impl Drop for NonCopyable {\n     fn drop(&mut self) {\n         let NonCopyable(p) = *self;\n-        let _v = unsafe { transmute::<*c_void, Box<int>>(p) };\n+        let _v = unsafe { transmute::<*const c_void, Box<int>>(p) };\n     }\n }\n \n pub fn main() {\n     let t = box 0;\n-    let p = unsafe { transmute::<Box<int>, *c_void>(t) };\n+    let p = unsafe { transmute::<Box<int>, *const c_void>(t) };\n     let _z = NonCopyable(p);\n }"}, {"sha": "468f420624a5f8f44ede4e90b5b023fdca5c31ad", "filename": "src/test/run-pass/issue-5791.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-5791.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-5791.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5791.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -12,9 +12,9 @@ extern crate libc;\n \n extern {\n     #[link_name = \"malloc\"]\n-    fn malloc1(len: libc::c_int) -> *libc::c_void;\n+    fn malloc1(len: libc::c_int) -> *const libc::c_void;\n     #[link_name = \"malloc\"]\n-    fn malloc2(len: libc::c_int, foo: libc::c_int) -> *libc::c_void;\n+    fn malloc2(len: libc::c_int, foo: libc::c_int) -> *const libc::c_void;\n }\n \n pub fn main () {}"}, {"sha": "ef164150804b99a98b4bff37a04e39b8473e3a59", "filename": "src/test/run-pass/issue-6470.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-6470.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-6470.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6470.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -14,7 +14,7 @@ pub mod Bar {\n     }\n \n     extern {\n-        pub fn foo(v: *Foo) -> Foo;\n+        pub fn foo(v: *const Foo) -> Foo;\n     }\n }\n "}, {"sha": "d775f23bab4ac3ca39adbc3cdc82bea02796a93b", "filename": "src/test/run-pass/issue-8860.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-8860.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fissue-8860.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8860.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -16,7 +16,7 @@ static mut DROP_S: int = 0i;\n static mut DROP_T: int = 0i;\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int {\n+fn start(argc: int, argv: *const *const u8) -> int {\n     let ret = green::start(argc, argv, green::basic::event_loop, main);\n     unsafe {\n         assert_eq!(2, DROP);"}, {"sha": "6330e1bf3c16e60f62b3c4e84d2f6c05a8811fee", "filename": "src/test/run-pass/lang-item-public.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Flang-item-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Flang-item-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flang-item-public.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -33,6 +33,6 @@ extern {}\n extern {}\n \n #[start]\n-fn main(_: int, _: **u8) -> int {\n+fn main(_: int, _: *const *const u8) -> int {\n     1 % 1\n }"}, {"sha": "2ab1e911180f0d3775093b30bf9273daa2e82f95", "filename": "src/test/run-pass/linkage1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Flinkage1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Flinkage1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinkage1.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -19,7 +19,7 @@ extern crate other = \"linkage1\";\n \n extern {\n     #[linkage = \"extern_weak\"]\n-    static foo: *int;\n+    static foo: *const int;\n     #[linkage = \"extern_weak\"]\n     static something_that_should_never_exist: *mut int;\n }"}, {"sha": "ea3eb29964883520cdfe2eefc82f84d0a9177517", "filename": "src/test/run-pass/native-always-waits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fnative-always-waits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fnative-always-waits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative-always-waits.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -15,7 +15,7 @@ extern crate native;\n static mut set: bool = false;\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int {\n+fn start(argc: int, argv: *const *const u8) -> int {\n     // make sure that native::start always waits for all children to finish\n     native::start(argc, argv, proc() {\n         spawn(proc() {"}, {"sha": "a7937efd66fceeab040afd334f0876a8e5af751b", "filename": "src/test/run-pass/native-print-no-runtime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fnative-print-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fnative-print-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative-print-no-runtime.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -10,7 +10,7 @@\n \n \n #[start]\n-pub fn main(_: int, _: **u8) -> int {\n+pub fn main(_: int, _: *const *const u8) -> int {\n     println!(\"hello\");\n     0\n }"}, {"sha": "69ff9fca6ceb935b0d0167b0c5d6ab2df825133c", "filename": "src/test/run-pass/process-detach.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fprocess-detach.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fprocess-detach.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-detach.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -28,7 +28,7 @@ use std::io::process::Command;\n use std::io::signal::{Listener, Interrupt};\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int {\n+fn start(argc: int, argv: *const *const u8) -> int {\n     green::start(argc, argv, rustuv::event_loop, main)\n }\n "}, {"sha": "d48f9dccaafc9561f79c2adf061820857e404c6c", "filename": "src/test/run-pass/pub-extern-privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fpub-extern-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fpub-extern-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpub-extern-privacy.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -12,7 +12,7 @@ use std::mem::transmute;\n \n mod a {\n     extern {\n-        pub fn free(x: *u8);\n+        pub fn free(x: *const u8);\n     }\n }\n "}, {"sha": "a8a9afc61561128cc9da105dc6769e613f1c3a49", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -66,44 +66,44 @@ impl TyVisitor for MyVisitor {\n                         _sz: uint, _sz2: uint,\n                         _align: uint) -> bool { true }\n \n-    fn visit_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_uniq(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_ptr(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_rptr(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_box(&mut self, _mtbl: uint, _inner: *const TyDesc) -> bool { true }\n+    fn visit_uniq(&mut self, _mtbl: uint, _inner: *const TyDesc) -> bool { true }\n+    fn visit_ptr(&mut self, _mtbl: uint, _inner: *const TyDesc) -> bool { true }\n+    fn visit_rptr(&mut self, _mtbl: uint, _inner: *const TyDesc) -> bool { true }\n \n-    fn visit_evec_slice(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_evec_slice(&mut self, _mtbl: uint, _inner: *const TyDesc) -> bool { true }\n     fn visit_evec_fixed(&mut self, _n: uint, _sz: uint, _align: uint,\n-                        _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+                        _mtbl: uint, _inner: *const TyDesc) -> bool { true }\n \n     fn visit_enter_rec(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n     fn visit_rec_field(&mut self, _i: uint, _name: &str,\n-                       _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+                       _mtbl: uint, _inner: *const TyDesc) -> bool { true }\n     fn visit_leave_rec(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n \n     fn visit_enter_class(&mut self, _name: &str, _named_fields: bool, _n_fields: uint,\n                          _sz: uint, _align: uint) -> bool { true }\n     fn visit_class_field(&mut self, _i: uint, _name: &str, _named: bool,\n-                         _mtbl: uint, _inner: *TyDesc) -> bool { true }\n+                         _mtbl: uint, _inner: *const TyDesc) -> bool { true }\n     fn visit_leave_class(&mut self, _name: &str, _named_fields: bool, _n_fields: uint,\n                          _sz: uint, _align: uint) -> bool { true }\n \n     fn visit_enter_tup(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n-    fn visit_tup_field(&mut self, _i: uint, _inner: *TyDesc) -> bool { true }\n+    fn visit_tup_field(&mut self, _i: uint, _inner: *const TyDesc) -> bool { true }\n     fn visit_leave_tup(&mut self, _n_fields: uint,\n                        _sz: uint, _align: uint) -> bool { true }\n \n     fn visit_enter_enum(&mut self, _n_variants: uint,\n-                        _get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n+                        _get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n                         _sz: uint, _align: uint) -> bool { true }\n     fn visit_enter_enum_variant(&mut self,\n                                 _variant: uint,\n                                 _disr_val: Disr,\n                                 _n_fields: uint,\n                                 _name: &str) -> bool { true }\n-    fn visit_enum_variant_field(&mut self, _i: uint, _offset: uint, _inner: *TyDesc)\n+    fn visit_enum_variant_field(&mut self, _i: uint, _offset: uint, _inner: *const TyDesc)\n         -> bool { true }\n     fn visit_leave_enum_variant(&mut self,\n                                 _variant: uint,\n@@ -112,13 +112,13 @@ impl TyVisitor for MyVisitor {\n                                 _name: &str) -> bool { true }\n     fn visit_leave_enum(&mut self,\n                         _n_variants: uint,\n-                        _get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n+                        _get_disr: unsafe extern fn(ptr: *const Opaque) -> Disr,\n                         _sz: uint, _align: uint) -> bool { true }\n \n     fn visit_enter_fn(&mut self, _purity: uint, _proto: uint,\n                       _n_inputs: uint, _retstyle: uint) -> bool { true }\n-    fn visit_fn_input(&mut self, _i: uint, _mode: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_fn_output(&mut self, _retstyle: uint, _variadic: bool, _inner: *TyDesc)\n+    fn visit_fn_input(&mut self, _i: uint, _mode: uint, _inner: *const TyDesc) -> bool { true }\n+    fn visit_fn_output(&mut self, _retstyle: uint, _variadic: bool, _inner: *const TyDesc)\n         -> bool { true }\n     fn visit_leave_fn(&mut self, _purity: uint, _proto: uint,\n                       _n_inputs: uint, _retstyle: uint) -> bool { true }"}, {"sha": "e0609782a0aa9820c3789e27addb013064631ed9", "filename": "src/test/run-pass/rename-directory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Frename-directory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Frename-directory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frename-directory.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -37,7 +37,7 @@ fn rename_directory() {\n         assert!((ostream as uint != 0u));\n         let s = \"hello\".to_string();\n         \"hello\".with_c_str(|buf| {\n-            let write_len = libc::fwrite(buf as *libc::c_void,\n+            let write_len = libc::fwrite(buf as *const libc::c_void,\n                                          1u as libc::size_t,\n                                          (s.len() + 1u) as libc::size_t,\n                                          ostream);"}, {"sha": "44435dc2398dc7489c59961fd603b063b751b1e7", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -18,7 +18,7 @@ use std::rt::unwind::try;\n local_data_key!(foo: int)\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int {\n+fn start(argc: int, argv: *const *const u8) -> int {\n     if argc > 1 {\n         unsafe {\n             match **argv.offset(1) {"}, {"sha": "4f1a3817fabd781a9e3c0bfe9bbf2700faa85107", "filename": "src/test/run-pass/smallest-hello-world.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -17,17 +17,17 @@\n \n extern crate libc;\n \n-extern { fn puts(s: *u8); }\n+extern { fn puts(s: *const u8); }\n extern \"rust-intrinsic\" { fn transmute<T, U>(t: T) -> U; }\n \n #[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n \n #[start]\n #[no_split_stack]\n-fn main(_: int, _: **u8) -> int {\n+fn main(_: int, _: *const *const u8) -> int {\n     unsafe {\n-        let (ptr, _): (*u8, uint) = transmute(\"Hello!\\0\");\n+        let (ptr, _): (*const u8, uint) = transmute(\"Hello!\\0\");\n         puts(ptr);\n     }\n     return 0;"}, {"sha": "515198f7a71eb0faa4bdaffc4301c93346fda479", "filename": "src/test/run-pass/stable-addr-of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fstable-addr-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fstable-addr-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstable-addr-of.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -12,5 +12,5 @@\n \n pub fn main() {\n     let foo = 1;\n-    assert_eq!(&foo as *int, &foo as *int);\n+    assert_eq!(&foo as *const int, &foo as *const int);\n }"}, {"sha": "a3ab4637412fc0266b4d5637d89cee9987c6c241", "filename": "src/test/run-pass/supported-cast.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fsupported-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fsupported-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsupported-cast.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -11,7 +11,7 @@\n extern crate libc;\n \n pub fn main() {\n-  let f = 1 as *libc::FILE;\n+  let f = 1 as *const libc::FILE;\n   println!(\"{}\", f as int);\n   println!(\"{}\", f as uint);\n   println!(\"{}\", f as i8);\n@@ -25,7 +25,7 @@ pub fn main() {\n \n   println!(\"{}\", 1 as int);\n   println!(\"{}\", 1 as uint);\n-  println!(\"{}\", 1 as *libc::FILE);\n+  println!(\"{}\", 1 as *const libc::FILE);\n   println!(\"{}\", 1 as i8);\n   println!(\"{}\", 1 as i16);\n   println!(\"{}\", 1 as i32);\n@@ -39,7 +39,7 @@ pub fn main() {\n \n   println!(\"{}\", 1u as int);\n   println!(\"{}\", 1u as uint);\n-  println!(\"{}\", 1u as *libc::FILE);\n+  println!(\"{}\", 1u as *const libc::FILE);\n   println!(\"{}\", 1u as i8);\n   println!(\"{}\", 1u as i16);\n   println!(\"{}\", 1u as i32);\n@@ -53,7 +53,7 @@ pub fn main() {\n \n   println!(\"{}\", 1i8 as int);\n   println!(\"{}\", 1i8 as uint);\n-  println!(\"{}\", 1i8 as *libc::FILE);\n+  println!(\"{}\", 1i8 as *const libc::FILE);\n   println!(\"{}\", 1i8 as i8);\n   println!(\"{}\", 1i8 as i16);\n   println!(\"{}\", 1i8 as i32);\n@@ -67,7 +67,7 @@ pub fn main() {\n \n   println!(\"{}\", 1u8 as int);\n   println!(\"{}\", 1u8 as uint);\n-  println!(\"{}\", 1u8 as *libc::FILE);\n+  println!(\"{}\", 1u8 as *const libc::FILE);\n   println!(\"{}\", 1u8 as i8);\n   println!(\"{}\", 1u8 as i16);\n   println!(\"{}\", 1u8 as i32);\n@@ -81,7 +81,7 @@ pub fn main() {\n \n   println!(\"{}\", 1i16 as int);\n   println!(\"{}\", 1i16 as uint);\n-  println!(\"{}\", 1i16 as *libc::FILE);\n+  println!(\"{}\", 1i16 as *const libc::FILE);\n   println!(\"{}\", 1i16 as i8);\n   println!(\"{}\", 1i16 as i16);\n   println!(\"{}\", 1i16 as i32);\n@@ -95,7 +95,7 @@ pub fn main() {\n \n   println!(\"{}\", 1u16 as int);\n   println!(\"{}\", 1u16 as uint);\n-  println!(\"{}\", 1u16 as *libc::FILE);\n+  println!(\"{}\", 1u16 as *const libc::FILE);\n   println!(\"{}\", 1u16 as i8);\n   println!(\"{}\", 1u16 as i16);\n   println!(\"{}\", 1u16 as i32);\n@@ -109,7 +109,7 @@ pub fn main() {\n \n   println!(\"{}\", 1i32 as int);\n   println!(\"{}\", 1i32 as uint);\n-  println!(\"{}\", 1i32 as *libc::FILE);\n+  println!(\"{}\", 1i32 as *const libc::FILE);\n   println!(\"{}\", 1i32 as i8);\n   println!(\"{}\", 1i32 as i16);\n   println!(\"{}\", 1i32 as i32);\n@@ -123,7 +123,7 @@ pub fn main() {\n \n   println!(\"{}\", 1u32 as int);\n   println!(\"{}\", 1u32 as uint);\n-  println!(\"{}\", 1u32 as *libc::FILE);\n+  println!(\"{}\", 1u32 as *const libc::FILE);\n   println!(\"{}\", 1u32 as i8);\n   println!(\"{}\", 1u32 as i16);\n   println!(\"{}\", 1u32 as i32);\n@@ -137,7 +137,7 @@ pub fn main() {\n \n   println!(\"{}\", 1i64 as int);\n   println!(\"{}\", 1i64 as uint);\n-  println!(\"{}\", 1i64 as *libc::FILE);\n+  println!(\"{}\", 1i64 as *const libc::FILE);\n   println!(\"{}\", 1i64 as i8);\n   println!(\"{}\", 1i64 as i16);\n   println!(\"{}\", 1i64 as i32);\n@@ -151,7 +151,7 @@ pub fn main() {\n \n   println!(\"{}\", 1u64 as int);\n   println!(\"{}\", 1u64 as uint);\n-  println!(\"{}\", 1u64 as *libc::FILE);\n+  println!(\"{}\", 1u64 as *const libc::FILE);\n   println!(\"{}\", 1u64 as i8);\n   println!(\"{}\", 1u64 as i16);\n   println!(\"{}\", 1u64 as i32);\n@@ -165,7 +165,7 @@ pub fn main() {\n \n   println!(\"{}\", 1u64 as int);\n   println!(\"{}\", 1u64 as uint);\n-  println!(\"{}\", 1u64 as *libc::FILE);\n+  println!(\"{}\", 1u64 as *const libc::FILE);\n   println!(\"{}\", 1u64 as i8);\n   println!(\"{}\", 1u64 as i16);\n   println!(\"{}\", 1u64 as i32);\n@@ -179,7 +179,7 @@ pub fn main() {\n \n   println!(\"{}\", true as int);\n   println!(\"{}\", true as uint);\n-  println!(\"{}\", true as *libc::FILE);\n+  println!(\"{}\", true as *const libc::FILE);\n   println!(\"{}\", true as i8);\n   println!(\"{}\", true as i16);\n   println!(\"{}\", true as i32);"}, {"sha": "fafb9412c01e5b279eff37900022012ea4df6d15", "filename": "src/test/run-pass/task-spawn-move-and-copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -14,10 +14,10 @@ pub fn main() {\n     let (tx, rx) = channel::<uint>();\n \n     let x = box 1;\n-    let x_in_parent = &(*x) as *int as uint;\n+    let x_in_parent = &(*x) as *const int as uint;\n \n     task::spawn(proc() {\n-        let x_in_child = &(*x) as *int as uint;\n+        let x_in_child = &(*x) as *const int as uint;\n         tx.send(x_in_child);\n     });\n "}, {"sha": "ebc720aa0c888d60f2bc5c675709c38d863f564a", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -24,7 +24,7 @@ extern crate green;\n extern crate rustuv;\n \n #[cfg(test)] #[start]\n-fn start(argc: int, argv: **u8) -> int {\n+fn start(argc: int, argv: *const *const u8) -> int {\n     green::start(argc, argv, rustuv::event_loop, __test::main)\n }\n "}, {"sha": "de3366708c5a0a0e3ebcef92c1279577bfdf3a4a", "filename": "src/test/run-pass/tcp-stress.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -25,7 +25,7 @@ use std::io::{Acceptor, Listener};\n use std::task::TaskBuilder;\n \n #[start]\n-fn start(argc: int, argv: **u8) -> int {\n+fn start(argc: int, argv: *const *const u8) -> int {\n     green::start(argc, argv, rustuv::event_loop, main)\n }\n "}, {"sha": "410e3df9e2ac9fa28321e0b0bd25b65e1c024665", "filename": "src/test/run-pass/type-ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Ftype-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Ftype-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-ptr.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f(a: *int) -> *int { return a; }\n+fn f(a: *const int) -> *const int { return a; }\n \n-fn g(a: *int) -> *int { let b = f(a); return b; }\n+fn g(a: *const int) -> *const int { let b = f(a); return b; }\n \n pub fn main() { return; }"}, {"sha": "1a79edb30c9c640a36ac2d4e509ef51f623faf95", "filename": "src/test/run-pass/typeck_type_placeholder_1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -11,7 +11,7 @@\n // This test checks that the `_` type placeholder works\n // correctly for enabling type inference.\n \n-static CONSTEXPR: *int = &'static 413 as *_;\n+static CONSTEXPR: *const int = &'static 413 as *const _;\n \n pub fn main() {\n     let x: Vec<_> = range(0u, 5).collect();\n@@ -24,7 +24,7 @@ pub fn main() {\n     assert_eq!(y.len(), 5);\n \n     let ptr = &5u;\n-    let ptr2 = ptr as *_;\n+    let ptr2 = ptr as *const _;\n \n-    assert_eq!(ptr as *uint as uint, ptr2 as uint);\n+    assert_eq!(ptr as *const uint as uint, ptr2 as uint);\n }"}, {"sha": "bf74dedebc4fbffc0731c91b1401576b9695c8bc", "filename": "src/test/run-pass/unify-return-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Funify-return-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Funify-return-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funify-return-ty.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -14,7 +14,7 @@\n \n use std::mem;\n \n-fn null<T>() -> *T {\n+fn null<T>() -> *const T {\n     unsafe {\n         mem::transmute(0)\n     }"}, {"sha": "eb0a3c0eda816d1cb498235ef09bf3aaad077998", "filename": "src/test/run-pass/uniq-cc-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -26,7 +26,7 @@ struct Pointy {\n }\n \n fn make_uniq_closure<A:Send>(a: A) -> proc():Send -> uint {\n-    proc() { &a as *A as uint }\n+    proc() { &a as *const A as uint }\n }\n \n fn empty_pointy() -> Gc<RefCell<Pointy>> {"}, {"sha": "7a624109a5507a72defdb859f0f53699737829a3", "filename": "src/test/run-pass/unsafe-pointer-assignability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Funsafe-pointer-assignability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Funsafe-pointer-assignability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsafe-pointer-assignability.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f(x: *int) {\n+fn f(x: *const int) {\n     unsafe {\n         assert_eq!(*x, 3);\n     }"}, {"sha": "de22f428713f71be7e15441b422dc729b7415502", "filename": "src/test/run-pass/use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuse.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -26,4 +26,4 @@ mod baz {\n }\n \n #[start]\n-pub fn start(_: int, _: **u8) -> int { 0 }\n+pub fn start(_: int, _: *const *const u8) -> int { 0 }"}, {"sha": "570b881650ae89a1f844a87507359c4742eff9ff", "filename": "src/test/run-pass/variadic-ffi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -15,7 +15,7 @@ use libc::{c_char, c_int};\n // ignore-fast doesn't like extern crate\n \n extern {\n-    fn sprintf(s: *mut c_char, format: *c_char, ...) -> c_int;\n+    fn sprintf(s: *mut c_char, format: *const c_char, ...) -> c_int;\n }\n \n unsafe fn check<T>(expected: &str, f: |*mut c_char| -> T) {\n@@ -41,10 +41,10 @@ pub fn main() {\n         });\n \n         // Make a function pointer\n-        let x: unsafe extern \"C\" fn(*mut c_char, *c_char, ...) -> c_int = sprintf;\n+        let x: unsafe extern \"C\" fn(*mut c_char, *const c_char, ...) -> c_int = sprintf;\n \n         // A function that takes a function pointer\n-        unsafe fn call(p: unsafe extern \"C\" fn(*mut c_char, *c_char, ...) -> c_int) {\n+        unsafe fn call(p: unsafe extern \"C\" fn(*mut c_char, *const c_char, ...) -> c_int) {\n             // Call with just the named parameter via fn pointer\n             \"Hello World\\n\".with_c_str(|c| {\n                 check(\"Hello World\\n\", |s| p(s, c));"}, {"sha": "93112e3e7ec9ddfed34f4029acdadc6d03ded8b5", "filename": "src/test/run-pass/warn-ctypes-inhibit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fwarn-ctypes-inhibit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe8bc178014dc2c5badd8443329c179478a40cc4/src%2Ftest%2Frun-pass%2Fwarn-ctypes-inhibit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwarn-ctypes-inhibit.rs?ref=fe8bc178014dc2c5badd8443329c179478a40cc4", "patch": "@@ -14,7 +14,7 @@\n \n mod libc {\n     extern {\n-        pub fn malloc(size: int) -> *u8;\n+        pub fn malloc(size: int) -> *const u8;\n     }\n }\n "}]}