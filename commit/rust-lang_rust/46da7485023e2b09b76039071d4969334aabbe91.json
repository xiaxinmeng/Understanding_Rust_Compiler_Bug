{"sha": "46da7485023e2b09b76039071d4969334aabbe91", "node_id": "C_kwDOAAsO6NoAKDQ2ZGE3NDg1MDIzZTJiMDliNzYwMzkwNzFkNDk2OTMzNGFhYmJlOTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-18T15:26:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-18T15:26:07Z"}, "message": "Auto merge of #2231 - DrMeepster:winfred, r=RalfJung\n\nWindows thread support: Part 1\n\nThis PR adds support for threads on Windows.", "tree": {"sha": "a56d1d76250592caccc2866dc1e6261a62f4a3e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a56d1d76250592caccc2866dc1e6261a62f4a3e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46da7485023e2b09b76039071d4969334aabbe91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46da7485023e2b09b76039071d4969334aabbe91", "html_url": "https://github.com/rust-lang/rust/commit/46da7485023e2b09b76039071d4969334aabbe91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46da7485023e2b09b76039071d4969334aabbe91/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "339500f060e2faeb8303a0e27418844e1afed87e", "url": "https://api.github.com/repos/rust-lang/rust/commits/339500f060e2faeb8303a0e27418844e1afed87e", "html_url": "https://github.com/rust-lang/rust/commit/339500f060e2faeb8303a0e27418844e1afed87e"}, {"sha": "c466ac0b3ec200ac53b1ca8196c47261b692bda1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c466ac0b3ec200ac53b1ca8196c47261b692bda1", "html_url": "https://github.com/rust-lang/rust/commit/c466ac0b3ec200ac53b1ca8196c47261b692bda1"}], "stats": {"total": 1142, "additions": 919, "deletions": 223}, "files": [{"sha": "8ca3e8d15e182b53b9429f9c00552c178b5ccf8d", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -5,6 +5,8 @@\n #![feature(try_blocks)]\n #![feature(let_else)]\n #![feature(io_error_more)]\n+#![feature(int_log)]\n+#![feature(variant_count)]\n #![feature(yeet_expr)]\n #![feature(is_some_with)]\n #![feature(nonzero_ops)]"}, {"sha": "4dc0916067399522e111391024d00f52f235ed0c", "filename": "src/machine.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -421,6 +421,7 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n     ) -> InterpResult<'tcx> {\n         EnvVars::init(this, config)?;\n         Evaluator::init_extern_statics(this)?;\n+        ThreadManager::init(this);\n         Ok(())\n     }\n "}, {"sha": "fcf92dfc9f93515ec8c503b4a081a40b10d9c879", "filename": "src/shims/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/src%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/src%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fos_str.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -74,7 +74,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         'mir: 'a,\n     {\n         #[cfg(windows)]\n-        pub fn u16vec_to_osstring<'tcx, 'a>(u16_vec: Vec<u16>) -> InterpResult<'tcx, OsString> {\n+        pub fn u16vec_to_osstring<'tcx>(u16_vec: Vec<u16>) -> InterpResult<'tcx, OsString> {\n             Ok(OsString::from_wide(&u16_vec[..]))\n         }\n         #[cfg(not(windows))]"}, {"sha": "67303c47db7ee4cb68c7af6cc78a9a32a79540d2", "filename": "src/shims/time.rs", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/src%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/src%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftime.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -197,12 +197,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn nanosleep(\n         &mut self,\n         req_op: &OpTy<'tcx, Provenance>,\n-        _rem: &OpTy<'tcx, Provenance>,\n+        _rem: &OpTy<'tcx, Provenance>, // Signal handlers are not supported, so rem will never be written to.\n     ) -> InterpResult<'tcx, i32> {\n-        // Signal handlers are not supported, so rem will never be written to.\n-\n         let this = self.eval_context_mut();\n \n+        this.assert_target_os_is_unix(\"nanosleep\");\n         this.check_no_isolation(\"`nanosleep`\")?;\n \n         let duration = match this.read_timespec(&this.deref_operand(req_op)?)? {\n@@ -233,4 +232,31 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         Ok(0)\n     }\n+\n+    #[allow(non_snake_case)]\n+    fn Sleep(&mut self, timeout: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        this.assert_target_os(\"windows\", \"Sleep\");\n+        this.check_no_isolation(\"`Sleep`\")?;\n+\n+        let timeout_ms = this.read_scalar(timeout)?.to_u32()?;\n+\n+        let duration = Duration::from_millis(timeout_ms.into());\n+        let timeout_time = Time::Monotonic(Instant::now().checked_add(duration).unwrap());\n+\n+        let active_thread = this.get_active_thread();\n+        this.block_thread(active_thread);\n+\n+        this.register_timeout_callback(\n+            active_thread,\n+            timeout_time,\n+            Box::new(move |ecx| {\n+                ecx.unblock_thread(active_thread);\n+                Ok(())\n+            }),\n+        );\n+\n+        Ok(())\n+    }\n }"}, {"sha": "a5205487981139e46b82533d2498a2ef29b66e3c", "filename": "src/shims/tls.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -229,25 +229,28 @@ impl<'tcx> TlsData<'tcx> {\n \n impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    /// Schedule TLS destructors for the main thread on Windows. The\n-    /// implementation assumes that we do not support concurrency on Windows\n-    /// yet.\n+    /// Schedule TLS destructors for Windows.\n+    /// On windows, TLS destructors are managed by std.\n     fn schedule_windows_tls_dtors(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let active_thread = this.get_active_thread();\n-        assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows is not supported\");\n+\n         // Windows has a special magic linker section that is run on certain events.\n         // Instead of searching for that section and supporting arbitrary hooks in there\n         // (that would be basically https://github.com/rust-lang/miri/issues/450),\n         // we specifically look up the static in libstd that we know is placed\n         // in that section.\n-        let thread_callback = this\n-            .eval_path_scalar(&[\"std\", \"sys\", \"windows\", \"thread_local_key\", \"p_thread_callback\"])?\n-            .to_pointer(this)?;\n+        let thread_callback =\n+            this.eval_windows(\"thread_local_key\", \"p_thread_callback\")?.to_pointer(this)?;\n         let thread_callback = this.get_ptr_fn(thread_callback)?.as_instance()?;\n \n+        // FIXME: Technically, the reason should be `DLL_PROCESS_DETACH` when the main thread exits\n+        // but std treats both the same.\n+        let reason = this.eval_windows(\"c\", \"DLL_THREAD_DETACH\")?;\n+\n         // The signature of this function is `unsafe extern \"system\" fn(h: c::LPVOID, dwReason: c::DWORD, pv: c::LPVOID)`.\n-        let reason = this.eval_path_scalar(&[\"std\", \"sys\", \"windows\", \"c\", \"DLL_THREAD_DETACH\"])?;\n+        // FIXME: `h` should be a handle to the current module and what `pv` should be is unknown\n+        // but both are ignored by std\n         this.call_function(\n             thread_callback,\n             Abi::System { unwind: false },"}, {"sha": "9365ec9a21f4da02dc9e3dd33c13e006f2705ad0", "filename": "src/shims/unix/thread.rs", "status": "modified", "additions": 12, "deletions": 36, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/src%2Fshims%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/src%2Fshims%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fthread.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -13,47 +13,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        // Create the new thread\n-        let new_thread_id = this.create_thread();\n-\n-        // Write the current thread-id, switch to the next thread later\n-        // to treat this write operation as occuring on the current thread.\n         let thread_info_place = this.deref_operand(thread)?;\n-        this.write_scalar(\n-            Scalar::from_uint(new_thread_id.to_u32(), thread_info_place.layout.size),\n-            &thread_info_place.into(),\n-        )?;\n-\n-        // Read the function argument that will be sent to the new thread\n-        // before the thread starts executing since reading after the\n-        // context switch will incorrectly report a data-race.\n-        let fn_ptr = this.read_pointer(start_routine)?;\n-        let func_arg = this.read_immediate(arg)?;\n \n-        // Finally switch to new thread so that we can push the first stackframe.\n-        // After this all accesses will be treated as occuring in the new thread.\n-        let old_thread_id = this.set_active_thread(new_thread_id);\n+        let start_routine = this.read_pointer(start_routine)?;\n \n-        // Perform the function pointer load in the new thread frame.\n-        let instance = this.get_ptr_fn(fn_ptr)?.as_instance()?;\n-\n-        // Note: the returned value is currently ignored (see the FIXME in\n-        // pthread_join below) because the Rust standard library does not use\n-        // it.\n-        let ret_place =\n-            this.allocate(this.layout_of(this.tcx.types.usize)?, MiriMemoryKind::Machine.into())?;\n+        let func_arg = this.read_immediate(arg)?;\n \n-        this.call_function(\n-            instance,\n+        this.start_thread(\n+            Some(thread_info_place),\n+            start_routine,\n             Abi::C { unwind: false },\n-            &[*func_arg],\n-            Some(&ret_place.into()),\n-            StackPopCleanup::Root { cleanup: true },\n+            func_arg,\n+            this.layout_of(this.tcx.types.usize)?,\n         )?;\n \n-        // Restore the old active thread frame.\n-        this.set_active_thread(old_thread_id);\n-\n         Ok(0)\n     }\n \n@@ -70,7 +43,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n \n         let thread_id = this.read_scalar(thread)?.to_machine_usize(this)?;\n-        this.join_thread(thread_id.try_into().expect(\"thread ID should fit in u32\"))?;\n+        this.join_thread_exclusive(thread_id.try_into().expect(\"thread ID should fit in u32\"))?;\n \n         Ok(0)\n     }\n@@ -79,7 +52,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         let thread_id = this.read_scalar(thread)?.to_machine_usize(this)?;\n-        this.detach_thread(thread_id.try_into().expect(\"thread ID should fit in u32\"))?;\n+        this.detach_thread(\n+            thread_id.try_into().expect(\"thread ID should fit in u32\"),\n+            /*allow_terminated_joined*/ false,\n+        )?;\n \n         Ok(0)\n     }"}, {"sha": "d87ca8f81841076e61ffdc418cccaa343a42f11d", "filename": "src/shims/windows/dlsym.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/src%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/src%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fdlsym.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -5,11 +5,13 @@ use rustc_target::spec::abi::Abi;\n use log::trace;\n \n use crate::helpers::check_arg_count;\n+use crate::shims::windows::handle::{EvalContextExt as _, Handle, PseudoHandle};\n use crate::*;\n \n #[derive(Debug, Copy, Clone)]\n pub enum Dlsym {\n     NtWriteFile,\n+    SetThreadDescription,\n }\n \n impl Dlsym {\n@@ -18,8 +20,8 @@ impl Dlsym {\n     pub fn from_str<'tcx>(name: &str) -> InterpResult<'tcx, Option<Dlsym>> {\n         Ok(match name {\n             \"GetSystemTimePreciseAsFileTime\" => None,\n-            \"SetThreadDescription\" => None,\n             \"NtWriteFile\" => Some(Dlsym::NtWriteFile),\n+            \"SetThreadDescription\" => Some(Dlsym::SetThreadDescription),\n             _ => throw_unsup_format!(\"unsupported Windows dlsym: {}\", name),\n         })\n     }\n@@ -107,6 +109,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     dest,\n                 )?;\n             }\n+            Dlsym::SetThreadDescription => {\n+                let [handle, name] = check_arg_count(args)?;\n+\n+                let handle = this.read_scalar(handle)?.check_init()?;\n+\n+                let name = this.read_wide_str(this.read_pointer(name)?)?;\n+\n+                let thread = match Handle::from_scalar(handle, this)? {\n+                    Some(Handle::Thread(thread)) => thread,\n+                    Some(Handle::Pseudo(PseudoHandle::CurrentThread)) => this.get_active_thread(),\n+                    _ => this.invalid_handle(\"SetThreadDescription\")?,\n+                };\n+\n+                this.set_thread_name_wide(thread, &name);\n+\n+                this.write_null(dest)?;\n+            }\n         }\n \n         trace!(\"{:?}\", this.dump_place(**dest));"}, {"sha": "d853f3084d492fa0ade34f9d32f1f7f224432830", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 49, "deletions": 44, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -6,7 +6,10 @@ use rustc_target::spec::abi::Abi;\n \n use crate::*;\n use shims::foreign_items::EmulateByNameResult;\n+use shims::windows::handle::{EvalContextExt as _, Handle, PseudoHandle};\n use shims::windows::sync::EvalContextExt as _;\n+use shims::windows::thread::EvalContextExt as _;\n+\n use smallvec::SmallVec;\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n@@ -219,6 +222,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let result = this.QueryPerformanceFrequency(lpFrequency)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n+            \"Sleep\" => {\n+                let [timeout] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+\n+                this.Sleep(timeout)?;\n+            }\n \n             // Synchronization primitives\n             \"AcquireSRWLockExclusive\" => {\n@@ -314,36 +323,57 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // FIXME: we should set last_error, but to what?\n                 this.write_null(dest)?;\n             }\n-            \"SwitchToThread\" => {\n-                let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                // Note that once Miri supports concurrency, this will need to return a nonzero\n-                // value if this call does result in switching to another thread.\n-                this.write_null(dest)?;\n-            }\n             \"GetStdHandle\" => {\n                 let [which] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let which = this.read_scalar(which)?.to_i32()?;\n                 // We just make this the identity function, so we know later in `NtWriteFile` which\n                 // one it is. This is very fake, but libtest needs it so we cannot make it a\n                 // std-only shim.\n+                // FIXME: this should return real HANDLEs when io support is added\n                 this.write_scalar(Scalar::from_machine_isize(which.into(), this), dest)?;\n             }\n+            \"CloseHandle\" => {\n+                let [handle] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+\n+                this.CloseHandle(handle)?;\n+\n+                this.write_scalar(Scalar::from_u32(1), dest)?;\n+            }\n \n-            // Better error for attempts to create a thread\n+            // Threading\n             \"CreateThread\" => {\n-                let [_, _, _, _, _, _] =\n+                let [security, stacksize, start, arg, flags, thread] =\n                     this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n \n-                this.handle_unsupported(\"can't create threads on Windows\")?;\n-                return Ok(EmulateByNameResult::AlreadyJumped);\n+                let thread_id =\n+                    this.CreateThread(security, stacksize, start, arg, flags, thread)?;\n+\n+                this.write_scalar(Handle::Thread(thread_id).to_scalar(this), dest)?;\n+            }\n+            \"WaitForSingleObject\" => {\n+                let [handle, timeout] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+\n+                let ret = this.WaitForSingleObject(handle, timeout)?;\n+                this.write_scalar(Scalar::from_u32(ret), dest)?;\n+            }\n+            \"GetCurrentThread\" => {\n+                let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+\n+                this.write_scalar(\n+                    Handle::Pseudo(PseudoHandle::CurrentThread).to_scalar(this),\n+                    dest,\n+                )?;\n             }\n \n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library.\n             \"GetProcessHeap\" if this.frame_in_std() => {\n                 let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 // Just fake a HANDLE\n+                // It's fine to not use the Handle type here because its a stub\n                 this.write_scalar(Scalar::from_machine_isize(1, this), dest)?;\n             }\n             \"GetModuleHandleA\" if this.frame_in_std() => {\n@@ -374,45 +404,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n                 this.write_scalar(Scalar::from_u32(1), dest)?;\n             }\n-            | \"InitializeCriticalSection\"\n-            | \"EnterCriticalSection\"\n-            | \"LeaveCriticalSection\"\n-            | \"DeleteCriticalSection\"\n-                if this.frame_in_std() =>\n-            {\n-                #[allow(non_snake_case)]\n-                let [_lpCriticalSection] =\n-                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                assert_eq!(\n-                    this.get_total_thread_count(),\n-                    1,\n-                    \"concurrency on Windows is not supported\"\n-                );\n-                // Nothing to do, not even a return value.\n-                // (Windows locks are reentrant, and we have only 1 thread,\n-                // so not doing any futher checks here is at least not incorrect.)\n-            }\n-            \"TryEnterCriticalSection\" if this.frame_in_std() => {\n-                #[allow(non_snake_case)]\n-                let [_lpCriticalSection] =\n-                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                assert_eq!(\n-                    this.get_total_thread_count(),\n-                    1,\n-                    \"concurrency on Windows is not supported\"\n-                );\n-                // There is only one thread, so this always succeeds and returns TRUE.\n-                this.write_scalar(Scalar::from_i32(1), dest)?;\n-            }\n-            \"GetCurrentThread\" if this.frame_in_std() => {\n-                let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n-                this.write_scalar(Scalar::from_machine_isize(1, this), dest)?;\n-            }\n             \"GetCurrentProcessId\" if this.frame_in_std() => {\n                 let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n                 let result = this.GetCurrentProcessId()?;\n                 this.write_scalar(Scalar::from_u32(result), dest)?;\n             }\n+            // this is only callable from std because we know that std ignores the return value\n+            \"SwitchToThread\" if this.frame_in_std() => {\n+                let [] = this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+\n+                this.yield_active_thread();\n+\n+                // FIXME: this should return a nonzero value if this call does result in switching to another thread.\n+                this.write_null(dest)?;\n+            }\n \n             _ => return Ok(EmulateByNameResult::NotSupported),\n         }"}, {"sha": "443af1dfeaaa467b1904bd49a794335d2c65c774", "filename": "src/shims/windows/handle.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/src%2Fshims%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/src%2Fshims%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fhandle.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -0,0 +1,167 @@\n+use rustc_target::abi::HasDataLayout;\n+use std::mem::variant_count;\n+\n+use crate::*;\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum PseudoHandle {\n+    CurrentThread,\n+}\n+\n+/// Miri representation of a Windows `HANDLE`\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum Handle {\n+    Null,\n+    Pseudo(PseudoHandle),\n+    Thread(ThreadId),\n+}\n+\n+impl PseudoHandle {\n+    const CURRENT_THREAD_VALUE: u32 = 0;\n+\n+    fn value(self) -> u32 {\n+        match self {\n+            Self::CurrentThread => Self::CURRENT_THREAD_VALUE,\n+        }\n+    }\n+\n+    fn from_value(value: u32) -> Option<Self> {\n+        match value {\n+            Self::CURRENT_THREAD_VALUE => Some(Self::CurrentThread),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+impl Handle {\n+    const NULL_DISCRIMINANT: u32 = 0;\n+    const PSEUDO_DISCRIMINANT: u32 = 1;\n+    const THREAD_DISCRIMINANT: u32 = 2;\n+\n+    fn discriminant(self) -> u32 {\n+        match self {\n+            Self::Null => Self::NULL_DISCRIMINANT,\n+            Self::Pseudo(_) => Self::PSEUDO_DISCRIMINANT,\n+            Self::Thread(_) => Self::THREAD_DISCRIMINANT,\n+        }\n+    }\n+\n+    fn data(self) -> u32 {\n+        match self {\n+            Self::Null => 0,\n+            Self::Pseudo(pseudo_handle) => pseudo_handle.value(),\n+            Self::Thread(thread) => thread.to_u32(),\n+        }\n+    }\n+\n+    fn packed_disc_size() -> u32 {\n+        // ceil(log2(x)) is how many bits it takes to store x numbers\n+        let variant_count = variant_count::<Self>();\n+\n+        // however, std's ilog2 is floor(log2(x))\n+        let floor_log2 = variant_count.ilog2();\n+\n+        // we need to add one for non powers of two to compensate for the difference\n+        if variant_count.is_power_of_two() { floor_log2 } else { floor_log2 + 1 }\n+    }\n+\n+    /// Converts a handle into its machine representation.\n+    ///\n+    /// The upper [`Self::packed_disc_size()`] bits are used to store a discriminant corresponding to the handle variant.\n+    /// The remaining bits are used for the variant's field.\n+    ///\n+    /// None of this layout is guaranteed to applications by Windows or Miri.\n+    fn to_packed(self) -> u32 {\n+        let disc_size = Self::packed_disc_size();\n+        let data_size = u32::BITS - disc_size;\n+\n+        let discriminant = self.discriminant();\n+        let data = self.data();\n+\n+        // make sure the discriminant fits into `disc_size` bits\n+        assert!(discriminant < 2u32.pow(disc_size));\n+\n+        // make sure the data fits into `data_size` bits\n+        assert!(data < 2u32.pow(data_size));\n+\n+        // packs the data into the lower `data_size` bits\n+        // and packs the discriminant right above the data\n+        discriminant << data_size | data\n+    }\n+\n+    fn new(discriminant: u32, data: u32) -> Option<Self> {\n+        match discriminant {\n+            Self::NULL_DISCRIMINANT if data == 0 => Some(Self::Null),\n+            Self::PSEUDO_DISCRIMINANT => Some(Self::Pseudo(PseudoHandle::from_value(data)?)),\n+            Self::THREAD_DISCRIMINANT => Some(Self::Thread(data.into())),\n+            _ => None,\n+        }\n+    }\n+\n+    /// see docs for `to_packed`\n+    fn from_packed(handle: u32) -> Option<Self> {\n+        let disc_size = Self::packed_disc_size();\n+        let data_size = u32::BITS - disc_size;\n+\n+        // the lower `data_size` bits of this mask are 1\n+        let data_mask = 2u32.pow(data_size) - 1;\n+\n+        // the discriminant is stored right above the lower `data_size` bits\n+        let discriminant = handle >> data_size;\n+\n+        // the data is stored in the lower `data_size` bits\n+        let data = handle & data_mask;\n+\n+        Self::new(discriminant, data)\n+    }\n+\n+    pub fn to_scalar(self, cx: &impl HasDataLayout) -> Scalar<Provenance> {\n+        // 64-bit handles are sign extended 32-bit handles\n+        // see https://docs.microsoft.com/en-us/windows/win32/winprog64/interprocess-communication\n+        #[allow(clippy::cast_possible_wrap)] // we want it to wrap\n+        let signed_handle = self.to_packed() as i32;\n+        Scalar::from_machine_isize(signed_handle.into(), cx)\n+    }\n+\n+    pub fn from_scalar<'tcx>(\n+        handle: Scalar<Provenance>,\n+        cx: &impl HasDataLayout,\n+    ) -> InterpResult<'tcx, Option<Self>> {\n+        let sign_extended_handle = handle.to_machine_isize(cx)?;\n+\n+        #[allow(clippy::cast_sign_loss)] // we want to lose the sign\n+        let handle = if let Ok(signed_handle) = i32::try_from(sign_extended_handle) {\n+            signed_handle as u32\n+        } else {\n+            // if a handle doesn't fit in an i32, it isn't valid.\n+            return Ok(None);\n+        };\n+\n+        Ok(Self::from_packed(handle))\n+    }\n+}\n+\n+impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+\n+#[allow(non_snake_case)]\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    fn invalid_handle(&mut self, function_name: &str) -> InterpResult<'tcx, !> {\n+        throw_machine_stop!(TerminationInfo::Abort(format!(\n+            \"invalid handle passed to `{function_name}`\"\n+        )))\n+    }\n+\n+    fn CloseHandle(&mut self, handle_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        let handle = this.read_scalar(handle_op)?.check_init()?;\n+\n+        match Handle::from_scalar(handle, this)? {\n+            Some(Handle::Thread(thread)) =>\n+                this.detach_thread(thread, /*allow_terminated_joined*/ true)?,\n+            _ => this.invalid_handle(\"CloseHandle\")?,\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "40fe71b2dbd02c6c01071885d0ab5fcda5ad680a", "filename": "src/shims/windows/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/src%2Fshims%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/src%2Fshims%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fmod.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,6 @@\n pub mod dlsym;\n pub mod foreign_items;\n \n+mod handle;\n mod sync;\n+mod thread;"}, {"sha": "06a5887d3e50920d94056831cd60df96c4ca89e9", "filename": "src/shims/windows/thread.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/src%2Fshims%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/src%2Fshims%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fthread.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -0,0 +1,89 @@\n+use rustc_middle::ty::layout::LayoutOf;\n+use rustc_target::spec::abi::Abi;\n+\n+use crate::*;\n+use shims::windows::handle::{EvalContextExt as _, Handle, PseudoHandle};\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+\n+#[allow(non_snake_case)]\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    fn CreateThread(\n+        &mut self,\n+        security_op: &OpTy<'tcx, Provenance>,\n+        stacksize_op: &OpTy<'tcx, Provenance>,\n+        start_op: &OpTy<'tcx, Provenance>,\n+        arg_op: &OpTy<'tcx, Provenance>,\n+        flags_op: &OpTy<'tcx, Provenance>,\n+        thread_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, ThreadId> {\n+        let this = self.eval_context_mut();\n+\n+        let security = this.read_pointer(security_op)?;\n+\n+        // stacksize is ignored, but still needs to be a valid usize\n+        this.read_scalar(stacksize_op)?.to_machine_usize(this)?;\n+\n+        let start_routine = this.read_pointer(start_op)?;\n+\n+        let func_arg = this.read_immediate(arg_op)?;\n+\n+        let flags = this.read_scalar(flags_op)?.to_u32()?;\n+\n+        let thread = if this.ptr_is_null(this.read_pointer(thread_op)?)? {\n+            None\n+        } else {\n+            let thread_info_place = this.deref_operand(thread_op)?;\n+            Some(thread_info_place)\n+        };\n+\n+        let stack_size_param_is_a_reservation =\n+            this.eval_windows(\"c\", \"STACK_SIZE_PARAM_IS_A_RESERVATION\")?.to_u32()?;\n+\n+        // We ignore the stack size, so we also ignore the\n+        // `STACK_SIZE_PARAM_IS_A_RESERVATION` flag.\n+        if flags != 0 && flags != stack_size_param_is_a_reservation {\n+            throw_unsup_format!(\"unsupported `dwCreationFlags` {} in `CreateThread`\", flags)\n+        }\n+\n+        if !this.ptr_is_null(security)? {\n+            throw_unsup_format!(\"non-null `lpThreadAttributes` in `CreateThread`\")\n+        }\n+\n+        this.start_thread(\n+            thread,\n+            start_routine,\n+            Abi::System { unwind: false },\n+            func_arg,\n+            this.layout_of(this.tcx.types.u32)?,\n+        )\n+    }\n+\n+    fn WaitForSingleObject(\n+        &mut self,\n+        handle_op: &OpTy<'tcx, Provenance>,\n+        timeout_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, u32> {\n+        let this = self.eval_context_mut();\n+\n+        let handle = this.read_scalar(handle_op)?.check_init()?;\n+\n+        let timeout = this.read_scalar(timeout_op)?.to_u32()?;\n+\n+        let thread = match Handle::from_scalar(handle, this)? {\n+            Some(Handle::Thread(thread)) => thread,\n+            // Unlike on posix, the outcome of joining the current thread is not documented.\n+            // On current Windows, it just deadlocks.\n+            Some(Handle::Pseudo(PseudoHandle::CurrentThread)) => this.get_active_thread(),\n+            _ => this.invalid_handle(\"WaitForSingleObject\")?,\n+        };\n+\n+        if timeout != this.eval_windows(\"c\", \"INFINITE\")?.to_u32()? {\n+            throw_unsup_format!(\"`WaitForSingleObject` with non-infinite timeout\");\n+        }\n+\n+        this.join_thread(thread)?;\n+\n+        Ok(0)\n+    }\n+}"}, {"sha": "b92728be208744300d6140eca3332d8541c29ecd", "filename": "src/thread.rs", "status": "modified", "additions": 131, "deletions": 19, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -11,6 +11,8 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::Mutability;\n+use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_target::spec::abi::Abi;\n \n use crate::concurrency::data_race;\n use crate::sync::SynchronizationState;\n@@ -238,10 +240,7 @@ impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n     fn default() -> Self {\n         let mut threads = IndexVec::new();\n         // Create the main thread and add it to the list of threads.\n-        let mut main_thread = Thread::new(\"main\");\n-        // The main thread can *not* be joined on.\n-        main_thread.join_status = ThreadJoinStatus::Detached;\n-        threads.push(main_thread);\n+        threads.push(Thread::new(\"main\"));\n         Self {\n             active_thread: ThreadId::new(0),\n             threads,\n@@ -254,6 +253,13 @@ impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n }\n \n impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n+    pub(crate) fn init(ecx: &mut MiriEvalContext<'mir, 'tcx>) {\n+        if ecx.tcx.sess.target.os.as_ref() != \"windows\" {\n+            // The main thread can *not* be joined on except on windows.\n+            ecx.machine.threads.threads[ThreadId::new(0)].join_status = ThreadJoinStatus::Detached;\n+        }\n+    }\n+\n     /// Check if we have an allocation for the given thread local static for the\n     /// active thread.\n     fn get_thread_local_alloc_id(&self, def_id: DefId) -> Option<Pointer<Provenance>> {\n@@ -348,10 +354,26 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n \n     /// Mark the thread as detached, which means that no other thread will try\n     /// to join it and the thread is responsible for cleaning up.\n-    fn detach_thread(&mut self, id: ThreadId) -> InterpResult<'tcx> {\n-        if self.threads[id].join_status != ThreadJoinStatus::Joinable {\n+    ///\n+    /// `allow_terminated_joined` allows detaching joined threads that have already terminated.\n+    /// This matches Windows's behavior for `CloseHandle`.\n+    ///\n+    /// See <https://docs.microsoft.com/en-us/windows/win32/procthread/thread-handles-and-identifiers>:\n+    /// > The handle is valid until closed, even after the thread it represents has been terminated.\n+    fn detach_thread(&mut self, id: ThreadId, allow_terminated_joined: bool) -> InterpResult<'tcx> {\n+        trace!(\"detaching {:?}\", id);\n+\n+        let is_ub = if allow_terminated_joined && self.threads[id].state == ThreadState::Terminated\n+        {\n+            // \"Detached\" in particular means \"not yet joined\". Redundant detaching is still UB.\n+            self.threads[id].join_status == ThreadJoinStatus::Detached\n+        } else {\n+            self.threads[id].join_status != ThreadJoinStatus::Joinable\n+        };\n+        if is_ub {\n             throw_ub_format!(\"trying to detach thread that was already detached or joined\");\n         }\n+\n         self.threads[id].join_status = ThreadJoinStatus::Detached;\n         Ok(())\n     }\n@@ -362,18 +384,10 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         joined_thread_id: ThreadId,\n         data_race: Option<&mut data_race::GlobalState>,\n     ) -> InterpResult<'tcx> {\n-        if self.threads[joined_thread_id].join_status != ThreadJoinStatus::Joinable {\n-            throw_ub_format!(\"trying to join a detached or already joined thread\");\n-        }\n-        if joined_thread_id == self.active_thread {\n-            throw_ub_format!(\"trying to join itself\");\n+        if self.threads[joined_thread_id].join_status == ThreadJoinStatus::Detached {\n+            throw_ub_format!(\"trying to join a detached thread\");\n         }\n-        assert!(\n-            self.threads\n-                .iter()\n-                .all(|thread| thread.state != ThreadState::BlockedOnJoin(joined_thread_id)),\n-            \"a joinable thread already has threads waiting for its termination\"\n-        );\n+\n         // Mark the joined thread as being joined so that we detect if other\n         // threads try to join it.\n         self.threads[joined_thread_id].join_status = ThreadJoinStatus::Joined;\n@@ -394,6 +408,31 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         Ok(())\n     }\n \n+    /// Mark that the active thread tries to exclusively join the thread with `joined_thread_id`.\n+    /// If the thread is already joined by another thread, it will throw UB\n+    fn join_thread_exclusive(\n+        &mut self,\n+        joined_thread_id: ThreadId,\n+        data_race: Option<&mut data_race::GlobalState>,\n+    ) -> InterpResult<'tcx> {\n+        if self.threads[joined_thread_id].join_status == ThreadJoinStatus::Joined {\n+            throw_ub_format!(\"trying to join an already joined thread\");\n+        }\n+\n+        if joined_thread_id == self.active_thread {\n+            throw_ub_format!(\"trying to join itself\");\n+        }\n+\n+        assert!(\n+            self.threads\n+                .iter()\n+                .all(|thread| thread.state != ThreadState::BlockedOnJoin(joined_thread_id)),\n+            \"this thread already has threads waiting for its termination\"\n+        );\n+\n+        self.join_thread(joined_thread_id, data_race)\n+    }\n+\n     /// Set the name of the given thread.\n     pub fn set_thread_name(&mut self, thread: ThreadId, new_thread_name: Vec<u8>) {\n         self.threads[thread].thread_name = Some(new_thread_name);\n@@ -624,9 +663,62 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[inline]\n-    fn detach_thread(&mut self, thread_id: ThreadId) -> InterpResult<'tcx> {\n+    fn start_thread(\n+        &mut self,\n+        thread: Option<MPlaceTy<'tcx, Provenance>>,\n+        start_routine: Pointer<Option<Provenance>>,\n+        start_abi: Abi,\n+        func_arg: ImmTy<'tcx, Provenance>,\n+        ret_layout: TyAndLayout<'tcx>,\n+    ) -> InterpResult<'tcx, ThreadId> {\n+        let this = self.eval_context_mut();\n+\n+        // Create the new thread\n+        let new_thread_id = this.create_thread();\n+\n+        // Write the current thread-id, switch to the next thread later\n+        // to treat this write operation as occuring on the current thread.\n+        if let Some(thread_info_place) = thread {\n+            this.write_scalar(\n+                Scalar::from_uint(new_thread_id.to_u32(), thread_info_place.layout.size),\n+                &thread_info_place.into(),\n+            )?;\n+        }\n+\n+        // Finally switch to new thread so that we can push the first stackframe.\n+        // After this all accesses will be treated as occuring in the new thread.\n+        let old_thread_id = this.set_active_thread(new_thread_id);\n+\n+        // Perform the function pointer load in the new thread frame.\n+        let instance = this.get_ptr_fn(start_routine)?.as_instance()?;\n+\n+        // Note: the returned value is currently ignored (see the FIXME in\n+        // pthread_join in shims/unix/thread.rs) because the Rust standard library does not use\n+        // it.\n+        let ret_place = this.allocate(ret_layout, MiriMemoryKind::Machine.into())?;\n+\n+        this.call_function(\n+            instance,\n+            start_abi,\n+            &[*func_arg],\n+            Some(&ret_place.into()),\n+            StackPopCleanup::Root { cleanup: true },\n+        )?;\n+\n+        // Restore the old active thread frame.\n+        this.set_active_thread(old_thread_id);\n+\n+        Ok(new_thread_id)\n+    }\n+\n+    #[inline]\n+    fn detach_thread(\n+        &mut self,\n+        thread_id: ThreadId,\n+        allow_terminated_joined: bool,\n+    ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        this.machine.threads.detach_thread(thread_id)\n+        this.machine.threads.detach_thread(thread_id, allow_terminated_joined)\n     }\n \n     #[inline]\n@@ -636,6 +728,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(())\n     }\n \n+    #[inline]\n+    fn join_thread_exclusive(&mut self, joined_thread_id: ThreadId) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        this.machine\n+            .threads\n+            .join_thread_exclusive(joined_thread_id, this.machine.data_race.as_mut())?;\n+        Ok(())\n+    }\n+\n     #[inline]\n     fn set_active_thread(&mut self, thread_id: ThreadId) -> ThreadId {\n         let this = self.eval_context_mut();\n@@ -704,6 +805,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.machine.threads.set_thread_name(thread, new_thread_name);\n     }\n \n+    #[inline]\n+    fn set_thread_name_wide(&mut self, thread: ThreadId, new_thread_name: &[u16]) {\n+        let this = self.eval_context_mut();\n+\n+        // The Windows `GetThreadDescription` shim to get the thread name isn't implemented, so being lossy is okay.\n+        // This is only read by diagnostics, which already use `from_utf8_lossy`.\n+        this.machine\n+            .threads\n+            .set_thread_name(thread, String::from_utf16_lossy(new_thread_name).into_bytes());\n+    }\n+\n     #[inline]\n     fn get_thread_name<'c>(&'c self, thread: ThreadId) -> &'c [u8]\n     where"}, {"sha": "e1d3704af7c0b54cf7d69d402fbc4bed72e7f8b9", "filename": "tests/fail/concurrency/libc_pthread_create_too_few_args.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_few_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_few_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_few_args.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,4 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n+//@ignore-target-windows: No libc on Windows\n \n //! The thread function must have exactly one argument.\n ", "previous_filename": "tests/fail/concurrency/too_few_args.rs"}, {"sha": "2304b42b2c786e6bb3eff7010147b85c3c6b19a7", "filename": "tests/fail/concurrency/libc_pthread_create_too_few_args.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_few_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_few_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_few_args.stderr?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,5 +1,5 @@\n error: Undefined Behavior: callee has fewer arguments than expected\n-  --> $DIR/too_few_args.rs:LL:CC\n+  --> $DIR/libc_pthread_create_too_few_args.rs:LL:CC\n    |\n LL |     panic!()\n    |     ^^^^^^^^ callee has fewer arguments than expected", "previous_filename": "tests/fail/concurrency/too_few_args.stderr"}, {"sha": "7408634db528fee3540fe7d52e02c2d87fd3130b", "filename": "tests/fail/concurrency/libc_pthread_create_too_many_args.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_many_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_many_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_many_args.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,4 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n+//@ignore-target-windows: No libc on Windows\n \n //! The thread function must have exactly one argument.\n ", "previous_filename": "tests/fail/concurrency/too_many_args.rs"}, {"sha": "49c7f579970f23c8fe158670b5d685fdfe0314c4", "filename": "tests/fail/concurrency/libc_pthread_create_too_many_args.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_many_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_many_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_create_too_many_args.stderr?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,5 +1,5 @@\n error: Undefined Behavior: callee has more arguments than expected\n-  --> $DIR/too_many_args.rs:LL:CC\n+  --> $DIR/libc_pthread_create_too_many_args.rs:LL:CC\n    |\n LL |     panic!()\n    |     ^^^^^^^^ callee has more arguments than expected", "previous_filename": "tests/fail/concurrency/too_many_args.stderr"}, {"sha": "0b810dc8c7212e59f0c69b14dc888962a8f0bb96", "filename": "tests/fail/concurrency/libc_pthread_join_detached.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -15,6 +15,6 @@ fn main() {\n         // assert_eq!(libc::pthread_attr_init(&mut attr), 0); FIXME: this function is not yet implemented.\n         assert_eq!(libc::pthread_create(&mut native, &attr, thread_start, ptr::null_mut()), 0);\n         assert_eq!(libc::pthread_detach(native), 0);\n-        assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0); //~ ERROR: Undefined Behavior: trying to join a detached or already joined thread\n+        assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0); //~ ERROR: Undefined Behavior: trying to join a detached thread\n     }\n }"}, {"sha": "92b693c0fd6bf73171fb3a859a8f7ad39a7c87e8", "filename": "tests/fail/concurrency/libc_pthread_join_detached.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_detached.stderr?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: trying to join a detached or already joined thread\n+error: Undefined Behavior: trying to join a detached thread\n   --> $DIR/libc_pthread_join_detached.rs:LL:CC\n    |\n-LL | ...   assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0);\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to join a detached or already joined thread\n+LL |         assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0);\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to join a detached thread\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "04ca4bbb3f6110db7b46644122a4be387fcd3ac1", "filename": "tests/fail/concurrency/libc_pthread_join_joined.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -15,6 +15,6 @@ fn main() {\n         // assert_eq!(libc::pthread_attr_init(&mut attr), 0); FIXME: this function is not yet implemented.\n         assert_eq!(libc::pthread_create(&mut native, &attr, thread_start, ptr::null_mut()), 0);\n         assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0);\n-        assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0); //~ ERROR: Undefined Behavior: trying to join a detached or already joined thread\n+        assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0); //~ ERROR: Undefined Behavior: trying to join an already joined thread\n     }\n }"}, {"sha": "f11b94cde8ee60613dee2491bd78de34633d7fc1", "filename": "tests/fail/concurrency/libc_pthread_join_joined.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_joined.stderr?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: trying to join a detached or already joined thread\n+error: Undefined Behavior: trying to join an already joined thread\n   --> $DIR/libc_pthread_join_joined.rs:LL:CC\n    |\n-LL | ...   assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0);\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to join a detached or already joined thread\n+LL |         assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0);\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to join an already joined thread\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "7576518216372370550127d3dbc1385964180851", "filename": "tests/fail/concurrency/libc_pthread_join_main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -8,7 +8,7 @@ fn main() {\n     let thread_id: libc::pthread_t = unsafe { libc::pthread_self() };\n     let handle = thread::spawn(move || {\n         unsafe {\n-            assert_eq!(libc::pthread_join(thread_id, ptr::null_mut()), 0); //~ ERROR: Undefined Behavior: trying to join a detached or already joined thread\n+            assert_eq!(libc::pthread_join(thread_id, ptr::null_mut()), 0); //~ ERROR: Undefined Behavior: trying to join a detached thread\n         }\n     });\n     thread::yield_now();"}, {"sha": "c162f37b309f7109e0a660e30c749e5e854608b9", "filename": "tests/fail/concurrency/libc_pthread_join_main.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_main.stderr?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: trying to join a detached or already joined thread\n+error: Undefined Behavior: trying to join a detached thread\n   --> $DIR/libc_pthread_join_main.rs:LL:CC\n    |\n-LL | ...   assert_eq!(libc::pthread_join(thread_id, ptr::null_mut()), 0);\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to join a detached or already joined thread\n+LL |             assert_eq!(libc::pthread_join(thread_id, ptr::null_mut()), 0);\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to join a detached thread\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "966f416eeac7e5b8782446c41347b1c2b19503bb", "filename": "tests/fail/concurrency/libc_pthread_join_multiple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -21,7 +21,7 @@ fn main() {\n         let mut native_copy: libc::pthread_t = mem::zeroed();\n         ptr::copy_nonoverlapping(&native, &mut native_copy, 1);\n         let handle = thread::spawn(move || {\n-            assert_eq!(libc::pthread_join(native_copy, ptr::null_mut()), 0); //~ ERROR: Undefined Behavior: trying to join a detached or already joined thread\n+            assert_eq!(libc::pthread_join(native_copy, ptr::null_mut()), 0); //~ ERROR: Undefined Behavior: trying to join an already joined thread\n         });\n         assert_eq!(libc::pthread_join(native, ptr::null_mut()), 0);\n         handle.join().unwrap();"}, {"sha": "c0c73086f14d60f93295fae70c2862dee96193f5", "filename": "tests/fail/concurrency/libc_pthread_join_multiple.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Flibc_pthread_join_multiple.stderr?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: trying to join a detached or already joined thread\n+error: Undefined Behavior: trying to join an already joined thread\n   --> $DIR/libc_pthread_join_multiple.rs:LL:CC\n    |\n LL | ...   assert_eq!(libc::pthread_join(native_copy, ptr::null_mut()), 0);\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to join a detached or already joined thread\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to join an already joined thread\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "84848e35a0f3e75312564ba48ff27defb1a859f6", "filename": "tests/fail/concurrency/thread-spawn.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/339500f060e2faeb8303a0e27418844e1afed87e/tests%2Ffail%2Fconcurrency%2Fthread-spawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339500f060e2faeb8303a0e27418844e1afed87e/tests%2Ffail%2Fconcurrency%2Fthread-spawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fthread-spawn.rs?ref=339500f060e2faeb8303a0e27418844e1afed87e", "patch": "@@ -1,9 +0,0 @@\n-//@only-target-windows: Only Windows is not supported.\n-\n-use std::thread;\n-\n-//@error-pattern: can't create threads on Windows\n-\n-fn main() {\n-    thread::spawn(|| {});\n-}"}, {"sha": "2e4b3a045e6915e2c29853fa95d9878811db1f32", "filename": "tests/fail/concurrency/thread-spawn.stderr", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/339500f060e2faeb8303a0e27418844e1afed87e/tests%2Ffail%2Fconcurrency%2Fthread-spawn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/339500f060e2faeb8303a0e27418844e1afed87e/tests%2Ffail%2Fconcurrency%2Fthread-spawn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fthread-spawn.stderr?ref=339500f060e2faeb8303a0e27418844e1afed87e", "patch": "@@ -1,30 +0,0 @@\n-error: unsupported operation: can't create threads on Windows\n-  --> RUSTLIB/std/src/sys/PLATFORM/thread.rs:LL:CC\n-   |\n-LL |           let ret = c::CreateThread(\n-   |  ___________________^\n-LL | |             ptr::null_mut(),\n-LL | |             stack,\n-LL | |             thread_start,\n-...  |\n-LL | |             ptr::null_mut(),\n-LL | |         );\n-   | |_________^ can't create threads on Windows\n-   |\n-   = help: this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\n-   = note: backtrace:\n-   = note: inside `std::sys::PLATFORM::thread::Thread::new` at RUSTLIB/std/src/sys/PLATFORM/thread.rs:LL:CC\n-   = note: inside `std::thread::Builder::spawn_unchecked_::<[closure@$DIR/thread-spawn.rs:LL:CC], ()>` at RUSTLIB/std/src/thread/mod.rs:LL:CC\n-   = note: inside `std::thread::Builder::spawn_unchecked::<[closure@$DIR/thread-spawn.rs:LL:CC], ()>` at RUSTLIB/std/src/thread/mod.rs:LL:CC\n-   = note: inside `std::thread::Builder::spawn::<[closure@$DIR/thread-spawn.rs:LL:CC], ()>` at RUSTLIB/std/src/thread/mod.rs:LL:CC\n-   = note: inside `std::thread::spawn::<[closure@$DIR/thread-spawn.rs:LL:CC], ()>` at RUSTLIB/std/src/thread/mod.rs:LL:CC\n-note: inside `main` at $DIR/thread-spawn.rs:LL:CC\n-  --> $DIR/thread-spawn.rs:LL:CC\n-   |\n-LL |     thread::spawn(|| {});\n-   |     ^^^^^^^^^^^^^^^^^^^^\n-\n-note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n-\n-error: aborting due to previous error\n-"}, {"sha": "d89c670b632e6d5735fee65270cc2fd7121c6900", "filename": "tests/fail/concurrency/thread_local_static_dealloc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fthread_local_static_dealloc.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,5 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n-\n //! Ensure that thread-local statics get deallocated when the thread dies.\n \n #![feature(thread_local)]"}, {"sha": "4704cfed03938a9f2d72b571ef7fb752a7154c5a", "filename": "tests/fail/concurrency/unwind_top_of_stack.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Funwind_top_of_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Funwind_top_of_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Funwind_top_of_stack.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,5 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n+//@ignore-target-windows: No libc on Windows\n+\n //@compile-flags: -Zmiri-disable-abi-check\n \n //! Unwinding past the top frame of a stack is Undefined Behavior."}, {"sha": "548ed63534dbd64be3bc3dece48d30bfbf878c2c", "filename": "tests/fail/concurrency/windows_join_detached.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Fwindows_join_detached.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Fwindows_join_detached.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fwindows_join_detached.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -0,0 +1,21 @@\n+//@only-target-windows: Uses win32 api functions\n+//@error-pattern: Undefined Behavior: trying to join a detached thread\n+\n+// Joining a detached thread is undefined behavior.\n+\n+use std::os::windows::io::{AsRawHandle, RawHandle};\n+use std::thread;\n+\n+extern \"system\" {\n+    fn CloseHandle(handle: RawHandle) -> u32;\n+}\n+\n+fn main() {\n+    let thread = thread::spawn(|| ());\n+\n+    unsafe {\n+        assert_ne!(CloseHandle(thread.as_raw_handle()), 0);\n+    }\n+\n+    thread.join().unwrap();\n+}"}, {"sha": "a0e85f6ce5ab4f33a5ecb88537b38a24168fe188", "filename": "tests/fail/concurrency/windows_join_detached.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Fwindows_join_detached.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Fwindows_join_detached.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fwindows_join_detached.stderr?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -0,0 +1,22 @@\n+error: Undefined Behavior: trying to join a detached thread\n+  --> RUSTLIB/std/src/sys/PLATFORM/thread.rs:LL:CC\n+   |\n+LL |         let rc = unsafe { c::WaitForSingleObject(self.handle.as_raw_handle(), c::INFINITE) };\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ trying to join a detached thread\n+   |\n+   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n+   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n+   = note: backtrace:\n+   = note: inside `std::sys::PLATFORM::thread::Thread::join` at RUSTLIB/std/src/sys/PLATFORM/thread.rs:LL:CC\n+   = note: inside `std::thread::JoinInner::<()>::join` at RUSTLIB/std/src/thread/mod.rs:LL:CC\n+   = note: inside `std::thread::JoinHandle::<()>::join` at RUSTLIB/std/src/thread/mod.rs:LL:CC\n+note: inside `main` at $DIR/windows_join_detached.rs:LL:CC\n+  --> $DIR/windows_join_detached.rs:LL:CC\n+   |\n+LL |     thread.join().unwrap();\n+   |     ^^^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "cde6d19ef25bb73813f1ea30238e484287423854", "filename": "tests/fail/concurrency/windows_join_main.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Fwindows_join_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Fwindows_join_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fwindows_join_main.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -0,0 +1,28 @@\n+//@only-target-windows: Uses win32 api functions\n+// We are making scheduler assumptions here.\n+//@compile-flags: -Zmiri-preemption-rate=0\n+\n+// On windows, joining main is not UB, but it will block a thread forever.\n+\n+use std::thread;\n+\n+extern \"system\" {\n+    fn WaitForSingleObject(handle: isize, timeout: u32) -> u32;\n+}\n+\n+const INFINITE: u32 = u32::MAX;\n+\n+// XXX HACK: This is how miri represents the handle for thread 0.\n+// This value can be \"legitimately\" obtained by using `GetCurrentThread` with `DuplicateHandle`\n+// but miri does not implement `DuplicateHandle` yet.\n+const MAIN_THREAD: isize = (2i32 << 30) as isize;\n+\n+fn main() {\n+    thread::spawn(|| {\n+        unsafe {\n+            assert_eq!(WaitForSingleObject(MAIN_THREAD, INFINITE), 0); //~ ERROR: deadlock: the evaluated program deadlocked\n+        }\n+    })\n+    .join()\n+    .unwrap();\n+}"}, {"sha": "ff0d074fa7d2604874b30c77f3fdbb365476ac4f", "filename": "tests/fail/concurrency/windows_join_main.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Fwindows_join_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Fwindows_join_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fwindows_join_main.stderr?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -0,0 +1,13 @@\n+error: deadlock: the evaluated program deadlocked\n+  --> $DIR/windows_join_main.rs:LL:CC\n+   |\n+LL |             assert_eq!(WaitForSingleObject(MAIN_THREAD, INFINITE), 0);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the evaluated program deadlocked\n+   |\n+   = note: inside closure at RUSTLIB/core/src/macros/mod.rs:LL:CC\n+   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "d9bbf66a7dca5fca6eed97f4a646231a904af751", "filename": "tests/fail/concurrency/windows_join_self.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Fwindows_join_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Fwindows_join_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fwindows_join_self.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -0,0 +1,25 @@\n+//@only-target-windows: Uses win32 api functions\n+// We are making scheduler assumptions here.\n+//@compile-flags: -Zmiri-preemption-rate=0\n+\n+// On windows, a thread joining itself is not UB, but it will deadlock.\n+\n+use std::thread;\n+\n+extern \"system\" {\n+    fn GetCurrentThread() -> usize;\n+    fn WaitForSingleObject(handle: usize, timeout: u32) -> u32;\n+}\n+\n+const INFINITE: u32 = u32::MAX;\n+\n+fn main() {\n+    thread::spawn(|| {\n+        unsafe {\n+            let native = GetCurrentThread();\n+            assert_eq!(WaitForSingleObject(native, INFINITE), 0); //~ ERROR: deadlock: the evaluated program deadlocked\n+        }\n+    })\n+    .join()\n+    .unwrap();\n+}"}, {"sha": "bbec3f7257ec0d44be556eef3cab1c39b4ec4408", "filename": "tests/fail/concurrency/windows_join_self.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Fwindows_join_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fconcurrency%2Fwindows_join_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fwindows_join_self.stderr?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -0,0 +1,12 @@\n+error: deadlock: the evaluated program deadlocked\n+  --> $DIR/windows_join_self.rs:LL:CC\n+   |\n+LL |             assert_eq!(WaitForSingleObject(native, INFINITE), 0);\n+   |                                                            ^ the evaluated program deadlocked\n+   |\n+   = note: inside closure at $DIR/windows_join_self.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "0bd3068af1ffe9995c8db5937ecd70115df08f88", "filename": "tests/fail/data_race/alloc_read_race.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Falloc_read_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Falloc_read_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Falloc_read_race.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n #![feature(new_uninit)]\n "}, {"sha": "7991280721e293907d0783a07b62a708e71c1965", "filename": "tests/fail/data_race/alloc_write_race.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Falloc_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Falloc_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Falloc_write_race.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n #![feature(new_uninit)]\n "}, {"sha": "2b0446d724a029e6fb8531ce494a61bafd95b71e", "filename": "tests/fail/data_race/atomic_read_na_write_race1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "ef5157515c64a3274eff556b247e98b83d52e8f6", "filename": "tests/fail/data_race/atomic_read_na_write_race2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering;"}, {"sha": "8c17e7674843832ca6ba2182584ccb1fab1785c5", "filename": "tests/fail/data_race/atomic_write_na_read_race1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering;"}, {"sha": "f14d7c704dbb18e43df9930a42fb626ed4ccbca7", "filename": "tests/fail/data_race/atomic_write_na_read_race2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "0804b33407580c8b8e8b96ecadc403b2c15d8e42", "filename": "tests/fail/data_race/atomic_write_na_write_race1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread::spawn;"}, {"sha": "658cddcc9c5b609a1dd6a69d9e0c9caa3aa997fb", "filename": "tests/fail/data_race/atomic_write_na_write_race2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering;"}, {"sha": "af2588e923240d43070dafedbf871fbe5f0c68cc", "filename": "tests/fail/data_race/dangling_thread_async_race.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-disable-isolation -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::mem;\n use std::thread::{sleep, spawn};"}, {"sha": "1ee619c3f99d573ab20f86f7012f048083b65449", "filename": "tests/fail/data_race/dangling_thread_race.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-disable-isolation -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::mem;\n use std::thread::{sleep, spawn};"}, {"sha": "cbc02549a2541c72c64fa81588dbe4f3e9988834", "filename": "tests/fail/data_race/dealloc_read_race1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::thread::spawn;\n "}, {"sha": "24cce5d6fac1cb7495ccb7129fda8aebd1670ff5", "filename": "tests/fail/data_race/dealloc_read_race2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::thread::spawn;\n "}, {"sha": "5484370f35c17bd0a89da9ee08e47c89f516857f", "filename": "tests/fail/data_race/dealloc_read_race_stack.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::ptr::null_mut;"}, {"sha": "23bf73fe8c5adf6d687d4312fddc8b4202823367", "filename": "tests/fail/data_race/dealloc_write_race1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::thread::spawn;\n "}, {"sha": "7c8033e2335e99e3d0d34120ef589a9f742979af", "filename": "tests/fail/data_race/dealloc_write_race2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::thread::spawn;\n "}, {"sha": "1872abfe021b305d38ba9443332d5a2a17a08933", "filename": "tests/fail/data_race/dealloc_write_race_stack.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::ptr::null_mut;"}, {"sha": "c11239da7febba4710b45d0f7c64a2a2cc7a297f", "filename": "tests/fail/data_race/enable_after_join_to_main.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::thread::spawn;\n "}, {"sha": "ae443908598fe59b20f18103fe378d6d7ef5da75", "filename": "tests/fail/data_race/fence_after_load.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Ffence_after_load.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Ffence_after_load.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Ffence_after_load.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-disable-isolation -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n use std::sync::atomic::{fence, AtomicUsize, Ordering};\n use std::sync::Arc;\n use std::thread;"}, {"sha": "482dd2df7df91111604627eec894a169daac832e", "filename": "tests/fail/data_race/read_write_race.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fread_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fread_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fread_write_race.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::thread::spawn;\n "}, {"sha": "1b4932439b010ebbfb0ec476b1e16a04be6b6cac", "filename": "tests/fail/data_race/read_write_race_stack.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-isolation -Zmir-opt-level=0 -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n // Note: mir-opt-level set to 0 to prevent the read of stack_var in thread 1"}, {"sha": "240b4c90eb225d6f846807fe51d592975cdd58c9", "filename": "tests/fail/data_race/relax_acquire_race.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::sync::atomic::{AtomicUsize, Ordering};"}, {"sha": "5ae801278357b56247c1b7c36374d45eda4d7ef2", "filename": "tests/fail/data_race/release_seq_race.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Frelease_seq_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Frelease_seq_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelease_seq_race.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::sync::atomic::{AtomicUsize, Ordering};"}, {"sha": "63e6dc2dd71b9e7f0622d15ab8584ff976b6baff", "filename": "tests/fail/data_race/release_seq_race_same_thread.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::sync::atomic::{AtomicUsize, Ordering};"}, {"sha": "122780d11aa1f612e34e05c968173c70e6d4ff34", "filename": "tests/fail/data_race/rmw_race.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Frmw_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Frmw_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Frmw_race.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::sync::atomic::{AtomicUsize, Ordering};"}, {"sha": "13c31c87cbbaedd9945f0a4e3516e39cf201f935", "filename": "tests/fail/data_race/write_write_race.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fwrite_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fwrite_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fwrite_write_race.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::thread::spawn;\n "}, {"sha": "731ac8b26aa74fe9eba4aad64ac537537c627788", "filename": "tests/fail/data_race/write_write_race_stack.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-isolation -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::ptr::null_mut;"}, {"sha": "545875a582a462d9909806772749adcd52326fa7", "filename": "tests/fail/should-pass/cpp20_rwc_syncs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-ignore-leaks\n \n // https://plv.mpi-sws.org/scfix/paper.pdf"}, {"sha": "7bbb7f9fe7c2a124ce3599f5ec3c63b331573c94", "filename": "tests/fail/weak_memory/racing_mixed_size.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n #![feature(core_intrinsics)]\n "}, {"sha": "73178980b7e5a38214433ab36f11ccaea643f0db", "filename": "tests/fail/weak_memory/racing_mixed_size_read.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fweak_memory%2Fracing_mixed_size_read.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,6 +1,5 @@\n // We want to control preemption here.\n //@compile-flags: -Zmiri-preemption-rate=0\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n \n use std::sync::atomic::Ordering::*;\n use std::sync::atomic::{AtomicU16, AtomicU32};"}, {"sha": "8c650bca2f36b78426f1dd0256bf159683eddb5c", "filename": "tests/pass/0weak_memory_consistency.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2F0weak_memory_consistency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2F0weak_memory_consistency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2F0weak_memory_consistency.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-ignore-leaks -Zmiri-disable-stacked-borrows\n \n // The following tests check whether our weak memory emulation produces"}, {"sha": "c75c5199bf11d6be6bb3de885552f8068eef6ac3", "filename": "tests/pass/concurrency/channels.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fchannels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fchannels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fchannels.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,4 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n+//@ignore-target-windows: Channels on Windows are not supported yet.\n //@compile-flags: -Zmiri-strict-provenance\n \n use std::sync::mpsc::{channel, sync_channel};"}, {"sha": "0490330a15d8b53337c40b502dd6e257152130aa", "filename": "tests/pass/concurrency/concurrent_caller_location.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fconcurrent_caller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fconcurrent_caller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fconcurrent_caller_location.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,5 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n-\n use std::panic::Location;\n use std::thread::spawn;\n "}, {"sha": "4e3c99058a0df9783bc930e13596a7c195fa2f86", "filename": "tests/pass/concurrency/data_race.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fdata_race.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-weak-memory-emulation -Zmiri-preemption-rate=0\n \n use std::sync::atomic::{fence, AtomicUsize, Ordering};"}, {"sha": "d71e51b038429b0316e9b622005aa40a43aa5528", "filename": "tests/pass/concurrency/disable_data_race_detector.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fdisable_data_race_detector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fdisable_data_race_detector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fdisable_data_race_detector.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-disable-data-race-detector\n \n use std::thread::spawn;"}, {"sha": "c0956569ad8f918c82e6df267b0f69571b6d1df5", "filename": "tests/pass/concurrency/issue1643.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fissue1643.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fissue1643.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fissue1643.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,5 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n-\n use std::thread::spawn;\n \n fn initialize() {"}, {"sha": "556e0a24769d7dcea8fc48c8039368a21bcf3e5b", "filename": "tests/pass/concurrency/simple.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fsimple.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-strict-provenance\n \n use std::thread;"}, {"sha": "019bd44f164888fcf022fe1293c6515d265f13fa", "filename": "tests/pass/concurrency/spin_loop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fspin_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fspin_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fspin_loop.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread;\n "}, {"sha": "5d8e2ef5f0282deea0f6b18cef1eb4ff973710d7", "filename": "tests/pass/concurrency/spin_loops_nopreempt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fspin_loops_nopreempt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fspin_loops_nopreempt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fspin_loops_nopreempt.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,4 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n+//@ignore-target-windows: Channels on Windows are not supported yet.\n // This specifically tests behavior *without* preemption.\n //@compile-flags: -Zmiri-preemption-rate=0\n "}, {"sha": "b19e56312f304ddd60ed2714a48942bed3d45ae0", "filename": "tests/pass/concurrency/thread_locals.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fthread_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fthread_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fthread_locals.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-strict-provenance\n \n //! The main purpose of this test is to check that if we take a pointer to"}, {"sha": "3fd6e2d6f2426396a210f39b257adb40fd6c8911", "filename": "tests/pass/concurrency/tls_lib_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,4 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n+//@ignore-target-windows: TLS destructor order is different on Windows.\n \n use std::cell::RefCell;\n use std::thread;"}, {"sha": "e8c6538e701d3bb0feab1ffa46ece63ec1bf355c", "filename": "tests/pass/concurrency/tls_lib_drop_windows.rs", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop_windows.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -0,0 +1,191 @@\n+//@only-target-windows: TLS destructor order is different on Windows.\n+\n+use std::cell::RefCell;\n+use std::thread;\n+\n+struct TestCell {\n+    value: RefCell<u8>,\n+}\n+\n+impl Drop for TestCell {\n+    fn drop(&mut self) {\n+        for _ in 0..10 {\n+            thread::yield_now();\n+        }\n+        println!(\"Dropping: {} (should be before 'Continue main 1').\", *self.value.borrow())\n+    }\n+}\n+\n+thread_local! {\n+    static A: TestCell = TestCell { value: RefCell::new(0) };\n+    static A_CONST: TestCell = const { TestCell { value: RefCell::new(10) } };\n+}\n+\n+/// Check that destructors of the library thread locals are executed immediately\n+/// after a thread terminates.\n+fn check_destructors() {\n+    thread::spawn(|| {\n+        A.with(|f| {\n+            assert_eq!(*f.value.borrow(), 0);\n+            *f.value.borrow_mut() = 5;\n+        });\n+        A_CONST.with(|f| {\n+            assert_eq!(*f.value.borrow(), 10);\n+            *f.value.borrow_mut() = 15;\n+        });\n+    })\n+    .join()\n+    .unwrap();\n+    println!(\"Continue main 1.\")\n+}\n+\n+struct JoinCell {\n+    value: RefCell<Option<thread::JoinHandle<u8>>>,\n+}\n+\n+impl Drop for JoinCell {\n+    fn drop(&mut self) {\n+        for _ in 0..10 {\n+            thread::yield_now();\n+        }\n+        let join_handle = self.value.borrow_mut().take().unwrap();\n+        println!(\"Joining: {} (should be before 'Continue main 2').\", join_handle.join().unwrap());\n+    }\n+}\n+\n+thread_local! {\n+    static B: JoinCell = JoinCell { value: RefCell::new(None) };\n+}\n+\n+/// Check that the destructor can be blocked joining another thread.\n+fn check_blocking() {\n+    thread::spawn(|| {\n+        B.with(|f| {\n+            assert!(f.value.borrow().is_none());\n+            let handle = thread::spawn(|| 7);\n+            *f.value.borrow_mut() = Some(handle);\n+        });\n+    })\n+    .join()\n+    .unwrap();\n+    println!(\"Continue main 2.\");\n+    // Preempt the main thread so that the destructor gets executed and can join\n+    // the thread.\n+    thread::yield_now();\n+    thread::yield_now();\n+}\n+\n+// This test tests that TLS destructors have run before the thread joins. The\n+// test has no false positives (meaning: if the test fails, there's actually\n+// an ordering problem). It may have false negatives, where the test passes but\n+// join is not guaranteed to be after the TLS destructors. However, false\n+// negatives should be exceedingly rare due to judicious use of\n+// thread::yield_now and running the test several times.\n+fn join_orders_after_tls_destructors() {\n+    use std::sync::atomic::{AtomicU8, Ordering};\n+\n+    // We emulate a synchronous MPSC rendezvous channel using only atomics and\n+    // thread::yield_now. We can't use std::mpsc as the implementation itself\n+    // may rely on thread locals.\n+    //\n+    // The basic state machine for an SPSC rendezvous channel is:\n+    //           FRESH -> THREAD1_WAITING -> MAIN_THREAD_RENDEZVOUS\n+    // where the first transition is done by the \u201creceiving\u201d thread and the 2nd\n+    // transition is done by the \u201csending\u201d thread.\n+    //\n+    // We add an additional state `THREAD2_LAUNCHED` between `FRESH` and\n+    // `THREAD1_WAITING` to block until all threads are actually running.\n+    //\n+    // A thread that joins on the \u201creceiving\u201d thread completion should never\n+    // observe the channel in the `THREAD1_WAITING` state. If this does occur,\n+    // we switch to the \u201cpoison\u201d state `THREAD2_JOINED` and panic all around.\n+    // (This is equivalent to \u201csending\u201d from an alternate producer thread.)\n+    const FRESH: u8 = 0;\n+    const THREAD2_LAUNCHED: u8 = 1;\n+    const THREAD1_WAITING: u8 = 2;\n+    const MAIN_THREAD_RENDEZVOUS: u8 = 3;\n+    const THREAD2_JOINED: u8 = 4;\n+    static SYNC_STATE: AtomicU8 = AtomicU8::new(FRESH);\n+\n+    for _ in 0..10 {\n+        SYNC_STATE.store(FRESH, Ordering::SeqCst);\n+\n+        let jh = thread::Builder::new()\n+            .name(\"thread1\".into())\n+            .spawn(move || {\n+                struct TlDrop;\n+\n+                impl Drop for TlDrop {\n+                    fn drop(&mut self) {\n+                        let mut sync_state = SYNC_STATE.swap(THREAD1_WAITING, Ordering::SeqCst);\n+                        loop {\n+                            match sync_state {\n+                                THREAD2_LAUNCHED | THREAD1_WAITING => thread::yield_now(),\n+                                MAIN_THREAD_RENDEZVOUS => break,\n+                                THREAD2_JOINED =>\n+                                    panic!(\n+                                        \"Thread 1 still running after thread 2 joined on thread 1\"\n+                                    ),\n+                                v => unreachable!(\"sync state: {}\", v),\n+                            }\n+                            sync_state = SYNC_STATE.load(Ordering::SeqCst);\n+                        }\n+                    }\n+                }\n+\n+                thread_local! {\n+                    static TL_DROP: TlDrop = TlDrop;\n+                }\n+\n+                TL_DROP.with(|_| {});\n+\n+                loop {\n+                    match SYNC_STATE.load(Ordering::SeqCst) {\n+                        FRESH => thread::yield_now(),\n+                        THREAD2_LAUNCHED => break,\n+                        v => unreachable!(\"sync state: {}\", v),\n+                    }\n+                }\n+            })\n+            .unwrap();\n+\n+        let jh2 = thread::Builder::new()\n+            .name(\"thread2\".into())\n+            .spawn(move || {\n+                assert_eq!(SYNC_STATE.swap(THREAD2_LAUNCHED, Ordering::SeqCst), FRESH);\n+                jh.join().unwrap();\n+                match SYNC_STATE.swap(THREAD2_JOINED, Ordering::SeqCst) {\n+                    MAIN_THREAD_RENDEZVOUS => return,\n+                    THREAD2_LAUNCHED | THREAD1_WAITING => {\n+                        panic!(\"Thread 2 running after thread 1 join before main thread rendezvous\")\n+                    }\n+                    v => unreachable!(\"sync state: {:?}\", v),\n+                }\n+            })\n+            .unwrap();\n+\n+        loop {\n+            match SYNC_STATE.compare_exchange(\n+                THREAD1_WAITING,\n+                MAIN_THREAD_RENDEZVOUS,\n+                Ordering::SeqCst,\n+                Ordering::SeqCst,\n+            ) {\n+                Ok(_) => break,\n+                Err(FRESH) => thread::yield_now(),\n+                Err(THREAD2_LAUNCHED) => thread::yield_now(),\n+                Err(THREAD2_JOINED) => {\n+                    panic!(\"Main thread rendezvous after thread 2 joined thread 1\")\n+                }\n+                v => unreachable!(\"sync state: {:?}\", v),\n+            }\n+        }\n+        jh2.join().unwrap();\n+    }\n+}\n+\n+fn main() {\n+    check_destructors();\n+    check_blocking();\n+    join_orders_after_tls_destructors();\n+}"}, {"sha": "e5b8efcaf5fac8efe605d242be67dbd4d27995d9", "filename": "tests/pass/concurrency/tls_lib_drop_windows.stdout", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop_windows.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop_windows.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Ftls_lib_drop_windows.stdout?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -0,0 +1,5 @@\n+Dropping: 15 (should be before 'Continue main 1').\n+Dropping: 5 (should be before 'Continue main 1').\n+Continue main 1.\n+Joining: 7 (should be before 'Continue main 2').\n+Continue main 2."}, {"sha": "91088ce6aef9b8916bb802551246ae12f27e8dda", "filename": "tests/pass/concurrency/windows_detach_terminated.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fwindows_detach_terminated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fwindows_detach_terminated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fwindows_detach_terminated.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -0,0 +1,21 @@\n+//@only-target-windows: Uses win32 api functions\n+// We are making scheduler assumptions here.\n+//@compile-flags: -Zmiri-preemption-rate=0\n+\n+use std::os::windows::io::IntoRawHandle;\n+use std::thread;\n+\n+extern \"system\" {\n+    fn CloseHandle(handle: usize) -> i32;\n+}\n+\n+fn main() {\n+    let thread = thread::spawn(|| {}).into_raw_handle() as usize;\n+\n+    // this yield ensures that `thread` is terminated by this point\n+    thread::yield_now();\n+\n+    unsafe {\n+        assert_ne!(CloseHandle(thread), 0);\n+    }\n+}"}, {"sha": "986e2b8cc10f7ddfb6e0cd7daab6b222461625e4", "filename": "tests/pass/concurrency/windows_join_multiple.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fwindows_join_multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fconcurrency%2Fwindows_join_multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fwindows_join_multiple.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -0,0 +1,41 @@\n+//@only-target-windows: Uses win32 api functions\n+// We are making scheduler assumptions here.\n+//@compile-flags: -Zmiri-preemption-rate=0\n+\n+use std::os::windows::io::IntoRawHandle;\n+use std::sync::atomic::{AtomicBool, Ordering};\n+use std::thread;\n+\n+extern \"system\" {\n+    fn WaitForSingleObject(handle: usize, timeout: u32) -> u32;\n+}\n+\n+const INFINITE: u32 = u32::MAX;\n+\n+fn main() {\n+    static FLAG: AtomicBool = AtomicBool::new(false);\n+\n+    let blocker = thread::spawn(|| {\n+        while !FLAG.load(Ordering::Relaxed) {\n+            thread::yield_now();\n+        }\n+    })\n+    .into_raw_handle() as usize;\n+\n+    let waiter = move || {\n+        unsafe {\n+            assert_eq!(WaitForSingleObject(blocker, INFINITE), 0);\n+        }\n+    };\n+\n+    let waiter1 = thread::spawn(waiter);\n+    let waiter2 = thread::spawn(waiter);\n+\n+    // this yield ensures `waiter1` & `waiter2` are blocked on `blocker` by this point\n+    thread::yield_now();\n+\n+    FLAG.store(true, Ordering::Relaxed);\n+\n+    waiter1.join().unwrap();\n+    waiter2.join().unwrap();\n+}"}, {"sha": "342269c6acbe3e21d420657cd86e1703fd27b45e", "filename": "tests/pass/panic/concurrent-panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fpanic%2Fconcurrent-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fpanic%2Fconcurrent-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fpanic%2Fconcurrent-panic.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,4 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n+//@ignore-target-windows: Condvars on Windows are not supported yet.\n // We are making scheduler assumptions here.\n //@compile-flags: -Zmiri-preemption-rate=0\n "}, {"sha": "23b5ab57efa02e93656bd6982164ec794d49e2a6", "filename": "tests/pass/shims/time.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fshims%2Ftime.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -8,8 +8,6 @@ fn duration_sanity(diff: Duration) {\n     assert!(diff.as_millis() < 500);\n }\n \n-// Sleeping on Windows is not supported yet.\n-#[cfg(unix)]\n fn test_sleep() {\n     let before = Instant::now();\n     std::thread::sleep(Duration::from_millis(100));\n@@ -50,6 +48,5 @@ fn main() {\n     assert_eq!(now2 - diff, now1);\n     duration_sanity(diff);\n \n-    #[cfg(unix)]\n     test_sleep();\n }"}, {"sha": "99bac7aa42a808a23705a231aa8ac96519d25c57", "filename": "tests/pass/threadleak_ignored.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fthreadleak_ignored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fthreadleak_ignored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fthreadleak_ignored.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,4 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n+//@ignore-target-windows: Channels on Windows are not supported yet.\n // FIXME: disallow preemption to work around https://github.com/rust-lang/rust/issues/55005\n //@compile-flags: -Zmiri-ignore-leaks -Zmiri-preemption-rate=0\n "}, {"sha": "07cbb4a803f1f23e03ada83c42030f5735338cf7", "filename": "tests/pass/weak_memory/extra_cpp.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fweak_memory%2Fextra_cpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fweak_memory%2Fextra_cpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fweak_memory%2Fextra_cpp.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-ignore-leaks\n \n // Tests operations not perfomable through C++'s atomic API"}, {"sha": "f7e2748408ff8fbff16ad5e8972d1e9bf63727da", "filename": "tests/pass/weak_memory/extra_cpp_unsafe.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fweak_memory%2Fextra_cpp_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fweak_memory%2Fextra_cpp_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fweak_memory%2Fextra_cpp_unsafe.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-ignore-leaks\n \n // Tests operations not perfomable through C++'s atomic API"}, {"sha": "4c3be6b3559ae52b45aec6b06a837138a484ce8b", "filename": "tests/pass/weak_memory/weak.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fweak_memory%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46da7485023e2b09b76039071d4969334aabbe91/tests%2Fpass%2Fweak_memory%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fweak_memory%2Fweak.rs?ref=46da7485023e2b09b76039071d4969334aabbe91", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Concurrency on Windows is not supported yet.\n //@compile-flags: -Zmiri-ignore-leaks -Zmiri-preemption-rate=0\n \n // Tests showing weak memory behaviours are exhibited. All tests"}]}