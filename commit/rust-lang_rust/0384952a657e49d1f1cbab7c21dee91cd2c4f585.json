{"sha": "0384952a657e49d1f1cbab7c21dee91cd2c4f585", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzODQ5NTJhNjU3ZTQ5ZDFmMWNiYWI3YzIxZGVlOTFjZDJjNGY1ODU=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-03-19T14:51:08Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-03-21T14:36:46Z"}, "message": "syntax: add the OwnedSlice vector wrapper.\n\nThis is a stand-in until we have a saner `~[T]` type (i.e. a proper\nowned slice). It's a library version of what `~[T]` will be, i.e. an\nowned pointer and a length.", "tree": {"sha": "a35f30b02fabb1ccfb806be98a349486034571ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a35f30b02fabb1ccfb806be98a349486034571ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0384952a657e49d1f1cbab7c21dee91cd2c4f585", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0384952a657e49d1f1cbab7c21dee91cd2c4f585", "html_url": "https://github.com/rust-lang/rust/commit/0384952a657e49d1f1cbab7c21dee91cd2c4f585", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0384952a657e49d1f1cbab7c21dee91cd2c4f585/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7785fe191651fb42a6300a399d61414bf49dffb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7785fe191651fb42a6300a399d61414bf49dffb3", "html_url": "https://github.com/rust-lang/rust/commit/7785fe191651fb42a6300a399d61414bf49dffb3"}], "stats": {"total": 143, "additions": 143, "deletions": 0}, "files": [{"sha": "d0608ac2e307d1e829fce8c399610d249c03e739", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0384952a657e49d1f1cbab7c21dee91cd2c4f585/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0384952a657e49d1f1cbab7c21dee91cd2c4f585/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=0384952a657e49d1f1cbab7c21dee91cd2c4f585", "patch": "@@ -49,6 +49,7 @@ pub mod syntax {\n     pub use parse;\n }\n \n+pub mod owned_slice;\n pub mod opt_vec;\n pub mod attr;\n pub mod diagnostic;"}, {"sha": "df38945f198538b808ef5462498e2122cdd93066", "filename": "src/libsyntax/owned_slice.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/0384952a657e49d1f1cbab7c21dee91cd2c4f585/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0384952a657e49d1f1cbab7c21dee91cd2c4f585/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=0384952a657e49d1f1cbab7c21dee91cd2c4f585", "patch": "@@ -0,0 +1,142 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::default::Default;\n+use std::hash::Hash;\n+use std::{cast, mem, raw, ptr, slice};\n+use serialize::{Encodable, Decodable, Encoder, Decoder};\n+\n+/// A non-growable owned slice. This would preferably become `~[T]`\n+/// under DST.\n+#[unsafe_no_drop_flag] // data is set to null on destruction\n+pub struct OwnedSlice<T> {\n+    /// null iff len == 0\n+    priv data: *mut T,\n+    priv len: uint,\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for OwnedSlice<T> {\n+    fn drop(&mut self) {\n+        if self.data.is_null() { return }\n+\n+        // extract the vector\n+        let v = mem::replace(self, OwnedSlice::empty());\n+        // free via the Vec destructor\n+        v.into_vec();\n+    }\n+}\n+\n+impl<T> OwnedSlice<T> {\n+    pub fn empty() -> OwnedSlice<T> {\n+        OwnedSlice  { data: ptr::mut_null(), len: 0 }\n+    }\n+\n+    #[inline(never)]\n+    pub fn from_vec(mut v: Vec<T>) -> OwnedSlice<T> {\n+        let len = v.len();\n+\n+        if len == 0 {\n+            OwnedSlice::empty()\n+        } else {\n+            let p = v.as_mut_ptr();\n+            // we own the allocation now\n+            unsafe {cast::forget(v)}\n+\n+            OwnedSlice { data: p, len: len }\n+        }\n+    }\n+\n+    #[inline(never)]\n+    pub fn into_vec(self) -> Vec<T> {\n+        // null is ok, because len == 0 in that case, as required by Vec.\n+        unsafe {\n+            let ret = Vec::from_raw_parts(self.len, self.len, self.data);\n+            // the vector owns the allocation now\n+            cast::forget(self);\n+            ret\n+        }\n+    }\n+\n+    pub fn as_slice<'a>(&'a self) -> &'a [T] {\n+        static PTR_MARKER: u8 = 0;\n+        let ptr = if self.data.is_null() {\n+            // length zero, i.e. this will never be read as a T.\n+            &PTR_MARKER as *u8 as *T\n+        } else {\n+            self.data as *T\n+        };\n+\n+        let slice: &[T] = unsafe {cast::transmute(raw::Slice {\n+            data: ptr,\n+            len: self.len\n+        })};\n+\n+        slice\n+    }\n+\n+    pub fn get<'a>(&'a self, i: uint) -> &'a T {\n+        self.as_slice().get(i).expect(\"OwnedSlice: index out of bounds\")\n+    }\n+\n+    pub fn iter<'r>(&'r self) -> slice::Items<'r, T> {\n+        self.as_slice().iter()\n+    }\n+\n+    pub fn map<U>(&self, f: |&T| -> U) -> OwnedSlice<U> {\n+        self.iter().map(f).collect()\n+    }\n+}\n+\n+impl<T> Default for OwnedSlice<T> {\n+    fn default() -> OwnedSlice<T> {\n+        OwnedSlice::empty()\n+    }\n+}\n+\n+impl<T: Clone> Clone for OwnedSlice<T> {\n+    fn clone(&self) -> OwnedSlice<T> {\n+        OwnedSlice::from_vec(Vec::from_slice(self.as_slice()))\n+    }\n+}\n+\n+impl<S: Writer, T: Hash<S>> Hash<S> for OwnedSlice<T> {\n+    fn hash(&self, state: &mut S) {\n+        self.as_slice().hash(state)\n+    }\n+}\n+\n+impl<T: Eq> Eq for OwnedSlice<T> {\n+    fn eq(&self, other: &OwnedSlice<T>) -> bool {\n+        self.as_slice() == other.as_slice()\n+    }\n+}\n+\n+impl<T> Container for OwnedSlice<T> {\n+    fn len(&self) -> uint { self.len }\n+}\n+\n+impl<T> FromIterator<T> for OwnedSlice<T> {\n+    fn from_iterator<I: Iterator<T>>(iter: &mut I) -> OwnedSlice<T> {\n+        OwnedSlice::from_vec(iter.collect())\n+    }\n+}\n+\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for OwnedSlice<T> {\n+    fn encode(&self, s: &mut S) {\n+       self.as_slice().encode(s)\n+    }\n+}\n+\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for OwnedSlice<T> {\n+    fn decode(d: &mut D) -> OwnedSlice<T> {\n+        OwnedSlice::from_vec(Decodable::decode(d))\n+    }\n+}"}]}