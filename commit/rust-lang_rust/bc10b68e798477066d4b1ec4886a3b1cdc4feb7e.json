{"sha": "bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMTBiNjhlNzk4NDc3MDY2ZDRiMWVjNDg4NmEzYjFjZGM0ZmViN2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-08T16:32:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-08T16:32:49Z"}, "message": "Auto merge of #73115 - RalfJung:rollup-jecowhz, r=RalfJung\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #72026 (Update annotate-snippets-rs to 0.8.0)\n - #72583 (impl AsRef<[T]> for vec::IntoIter<T>)\n - #72615 (Fix documentation example for gcov profiling)\n - #72761 (Added the documentation for the 'use' keyword)\n - #72799 (Add `-Z span-debug` to allow for easier debugging of proc macros)\n - #72811 (Liballoc impl)\n - #72963 (Cstring `from_raw` and `into_raw` safety precisions)\n - #73001 (Free `default()` forwarding to `Default::default()`)\n - #73075 (Add comments to `Resolve::get_module`)\n - #73092 (Clean up E0646)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "1c2d58cb9bd0d9a45bc5972c256eac6db0f94a14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c2d58cb9bd0d9a45bc5972c256eac6db0f94a14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "html_url": "https://github.com/rust-lang/rust/commit/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73558160933b2764ed9a84b1b2b647e128eac3f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/73558160933b2764ed9a84b1b2b647e128eac3f8", "html_url": "https://github.com/rust-lang/rust/commit/73558160933b2764ed9a84b1b2b647e128eac3f8"}, {"sha": "7983e56f40e7536a645993485754c302e5090435", "url": "https://api.github.com/repos/rust-lang/rust/commits/7983e56f40e7536a645993485754c302e5090435", "html_url": "https://github.com/rust-lang/rust/commit/7983e56f40e7536a645993485754c302e5090435"}], "stats": {"total": 830, "additions": 655, "deletions": 175}, "files": [{"sha": "76665d5a6f7f35fe25498321e480b3321790c83b", "filename": "Cargo.lock", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -48,6 +48,12 @@ dependencies = [\n  \"ansi_term\",\n ]\n \n+[[package]]\n+name = \"annotate-snippets\"\n+version = \"0.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d78ea013094e5ea606b1c05fe35f1dd7ea1eb1ea259908d040b25bd5ec677ee5\"\n+\n [[package]]\n name = \"ansi_term\"\n version = \"0.11.0\"\n@@ -3316,7 +3322,7 @@ version = \"659.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"0c374e89b3c9714869ef86076942155383804ba6778c26be2169d324563c31f9\"\n dependencies = [\n- \"annotate-snippets\",\n+ \"annotate-snippets 0.6.1\",\n  \"atty\",\n  \"log\",\n  \"rustc-ap-rustc_data_structures\",\n@@ -3810,7 +3816,7 @@ version = \"0.0.0\"\n name = \"rustc_errors\"\n version = \"0.0.0\"\n dependencies = [\n- \"annotate-snippets\",\n+ \"annotate-snippets 0.8.0\",\n  \"atty\",\n  \"log\",\n  \"rustc_data_structures\",\n@@ -4477,7 +4483,7 @@ dependencies = [\n name = \"rustfmt-nightly\"\n version = \"1.4.15\"\n dependencies = [\n- \"annotate-snippets\",\n+ \"annotate-snippets 0.6.1\",\n  \"bytecount\",\n  \"cargo_metadata 0.8.0\",\n  \"derive-new\","}, {"sha": "7973b3e4f2f322ad40bd1bcea87f85742de9e193", "filename": "src/doc/unstable-book/src/compiler-flags/profile.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fprofile.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fprofile.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fprofile.md?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -12,10 +12,16 @@ For example:\n ```Bash\n cargo new testgcov --bin\n cd testgcov\n-export RUSTFLAGS=\"-Zprofile\"\n+export RUSTFLAGS=\"-Zprofile -Ccodegen-units=1 -Copt-level=0 -Clink-dead-code -Coverflow-checks=off -Zpanic_abort_tests -Cpanic=abort\"\n+export CARGO_INCREMENTAL=0\n cargo build\n cargo run\n ```\n \n Once you've built and run your program, files with the `gcno` (after build) and `gcda` (after execution) extensions will be created.\n You can parse them with [llvm-cov gcov](https://llvm.org/docs/CommandGuide/llvm-cov.html#llvm-cov-gcov) or [grcov](https://github.com/mozilla/grcov).\n+\n+Please note that `RUSTFLAGS` by default applies to everything that cargo builds and runs during a build!\n+When the `--target` flag is explicitly passed to cargo, the `RUSTFLAGS` no longer apply to build scripts and procedural macros. \n+For more fine-grained control consider passing a `RUSTC_WRAPPER` program to cargo that only adds the profiling flags to \n+rustc for the specific crates you want to profile."}, {"sha": "5dff73a94dd872c956aa1c231719290d5791271a", "filename": "src/doc/unstable-book/src/library-features/default-free-fn.md", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdefault-free-fn.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdefault-free-fn.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdefault-free-fn.md?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -0,0 +1,45 @@\n+# `default_free_fn`\n+\n+The tracking issue for this feature is: [#73014]\n+\n+[#73014]: https://github.com/rust-lang/rust/issues/73014\n+\n+------------------------\n+\n+Adds a free `default()` function to the `std::default` module.  This function\n+just forwards to [`Default::default()`], but may remove repetition of the word\n+\"default\" from the call site.\n+\n+Here is an example:\n+\n+```rust\n+#![feature(default_free_fn)]\n+use std::default::default;\n+\n+#[derive(Default)]\n+struct AppConfig {\n+    foo: FooConfig,\n+    bar: BarConfig,\n+}\n+\n+#[derive(Default)]\n+struct FooConfig {\n+    foo: i32,\n+}\n+\n+#[derive(Default)]\n+struct BarConfig {\n+    bar: f32,\n+    baz: u8,\n+}\n+\n+fn main() {\n+    let options = AppConfig {\n+        foo: default(),\n+        bar: BarConfig {\n+            bar: 10.1,\n+            ..default()\n+        },\n+    };\n+}\n+```"}, {"sha": "5b365f0387a9b0e50742f3478c4f2d41f8d92f06", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -118,6 +118,30 @@ impl<T> RawVec<T, Global> {\n             RawVec::from_raw_parts(slice.as_mut_ptr(), slice.len())\n         }\n     }\n+\n+    /// Converts the entire buffer into `Box<[MaybeUninit<T>]>` with the specified `len`.\n+    ///\n+    /// Note that this will correctly reconstitute any `cap` changes\n+    /// that may have been performed. (See description of type for details.)\n+    ///\n+    /// # Safety\n+    ///\n+    /// * `len` must be greater than or equal to the most recently requested capacity, and\n+    /// * `len` must be less than or equal to `self.capacity()`.\n+    ///\n+    /// Note, that the requested capacity and `self.capacity()` could differ, as\n+    /// an allocator could overallocate and return a greater memory block than requested.\n+    pub unsafe fn into_box(self, len: usize) -> Box<[MaybeUninit<T>]> {\n+        // Sanity-check one half of the safety requirement (we cannot check the other half).\n+        debug_assert!(\n+            len <= self.capacity(),\n+            \"`len` must be smaller than or equal to `self.capacity()`\"\n+        );\n+\n+        let me = ManuallyDrop::new(self);\n+        let slice = slice::from_raw_parts_mut(me.ptr() as *mut MaybeUninit<T>, len);\n+        Box::from_raw(slice)\n+    }\n }\n \n impl<T, A: AllocRef> RawVec<T, A> {\n@@ -520,32 +544,6 @@ where\n     Ok(memory)\n }\n \n-impl<T> RawVec<T, Global> {\n-    /// Converts the entire buffer into `Box<[MaybeUninit<T>]>` with the specified `len`.\n-    ///\n-    /// Note that this will correctly reconstitute any `cap` changes\n-    /// that may have been performed. (See description of type for details.)\n-    ///\n-    /// # Safety\n-    ///\n-    /// * `len` must be greater than or equal to the most recently requested capacity, and\n-    /// * `len` must be less than or equal to `self.capacity()`.\n-    ///\n-    /// Note, that the requested capacity and `self.capacity()` could differ, as\n-    /// an allocator could overallocate and return a greater memory block than requested.\n-    pub unsafe fn into_box(self, len: usize) -> Box<[MaybeUninit<T>]> {\n-        // Sanity-check one half of the safety requirement (we cannot check the other half).\n-        debug_assert!(\n-            len <= self.capacity(),\n-            \"`len` must be smaller than or equal to `self.capacity()`\"\n-        );\n-\n-        let me = ManuallyDrop::new(self);\n-        let slice = slice::from_raw_parts_mut(me.ptr() as *mut MaybeUninit<T>, len);\n-        Box::from_raw(slice)\n-    }\n-}\n-\n unsafe impl<#[may_dangle] T, A: AllocRef> Drop for RawVec<T, A> {\n     /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n     fn drop(&mut self) {"}, {"sha": "af943ecfd4800e631491b564755a290ede243771", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -1905,6 +1905,22 @@ unsafe impl<T: ?Sized> IsZero for Option<Box<T>> {\n // Common trait implementations for Vec\n ////////////////////////////////////////////////////////////////////////////////\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> ops::Deref for Vec<T> {\n+    type Target = [T];\n+\n+    fn deref(&self) -> &[T] {\n+        unsafe { slice::from_raw_parts(self.as_ptr(), self.len) }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> ops::DerefMut for Vec<T> {\n+    fn deref_mut(&mut self) -> &mut [T] {\n+        unsafe { slice::from_raw_parts_mut(self.as_mut_ptr(), self.len) }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for Vec<T> {\n     #[cfg(not(test))]\n@@ -1960,22 +1976,6 @@ impl<T, I: SliceIndex<[T]>> IndexMut<I> for Vec<T> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::Deref for Vec<T> {\n-    type Target = [T];\n-\n-    fn deref(&self) -> &[T] {\n-        unsafe { slice::from_raw_parts(self.as_ptr(), self.len) }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::DerefMut for Vec<T> {\n-    fn deref_mut(&mut self) -> &mut [T] {\n-        unsafe { slice::from_raw_parts_mut(self.as_mut_ptr(), self.len) }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n@@ -2628,6 +2628,13 @@ impl<T> IntoIter<T> {\n     }\n }\n \n+#[stable(feature = \"vec_intoiter_as_ref\", since = \"1.46.0\")]\n+impl<T> AsRef<[T]> for IntoIter<T> {\n+    fn as_ref(&self) -> &[T] {\n+        self.as_slice()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: Send> Send for IntoIter<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "9a8d65cd4e06b93e37e075f100a589b18e97eba5", "filename": "src/libcore/default.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -115,6 +115,50 @@ pub trait Default: Sized {\n     fn default() -> Self;\n }\n \n+/// Return the default value of a type according to the `Default` trait.\n+///\n+/// The type to return is inferred from context; this is equivalent to\n+/// `Default::default()` but shorter to type.\n+///\n+/// For example:\n+/// ```\n+/// #![feature(default_free_fn)]\n+///\n+/// use std::default::default;\n+///\n+/// #[derive(Default)]\n+/// struct AppConfig {\n+///     foo: FooConfig,\n+///     bar: BarConfig,\n+/// }\n+///\n+/// #[derive(Default)]\n+/// struct FooConfig {\n+///     foo: i32,\n+/// }\n+///\n+/// #[derive(Default)]\n+/// struct BarConfig {\n+///     bar: f32,\n+///     baz: u8,\n+/// }\n+///\n+/// fn main() {\n+///     let options = AppConfig {\n+///         foo: default(),\n+///         bar: BarConfig {\n+///             bar: 10.1,\n+///             ..default()\n+///         },\n+///     };\n+/// }\n+/// ```\n+#[unstable(feature = \"default_free_fn\", issue = \"73014\")]\n+#[inline]\n+pub fn default<T: Default>() -> T {\n+    Default::default()\n+}\n+\n /// Derive macro generating an impl of the trait `Default`.\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]"}, {"sha": "1e9ec7d4380adb56050f447f500e56f3a8844b3a", "filename": "src/librustc_error_codes/error_codes/E0646.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibrustc_error_codes%2Ferror_codes%2FE0646.md", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibrustc_error_codes%2Ferror_codes%2FE0646.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0646.md?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -1,4 +1,5 @@\n It is not possible to define `main` with a where clause.\n+\n Erroneous code example:\n \n ```compile_fail,E0646"}, {"sha": "7f72161aff826a09091bc7012cdabd0582c67b52", "filename": "src/librustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibrustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibrustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2FCargo.toml?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -17,7 +17,7 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n unicode-width = \"0.1.4\"\n atty = \"0.2\"\n termcolor = \"1.0\"\n-annotate-snippets = \"0.6.1\"\n+annotate-snippets = \"0.8.0\"\n termize = \"0.1.1\"\n \n [target.'cfg(windows)'.dependencies]"}, {"sha": "5b47364e714e910dbf6792c98af13e119944a74b", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 92, "deletions": 123, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -8,12 +8,11 @@\n use crate::emitter::FileWithAnnotatedLines;\n use crate::snippet::Line;\n use crate::{CodeSuggestion, Diagnostic, DiagnosticId, Emitter, Level, SubDiagnostic};\n-use annotate_snippets::display_list::DisplayList;\n-use annotate_snippets::formatter::DisplayListFormatter;\n+use annotate_snippets::display_list::{DisplayList, FormatOptions};\n use annotate_snippets::snippet::*;\n use rustc_data_structures::sync::Lrc;\n use rustc_span::source_map::SourceMap;\n-use rustc_span::{Loc, MultiSpan, SourceFile};\n+use rustc_span::{MultiSpan, SourceFile};\n \n /// Generates diagnostics using annotate-snippet\n pub struct AnnotateSnippetEmitterWriter {\n@@ -59,112 +58,20 @@ impl Emitter for AnnotateSnippetEmitterWriter {\n     }\n }\n \n-/// Collects all the data needed to generate the data structures needed for the\n-/// `annotate-snippets` library.\n-struct DiagnosticConverter<'a> {\n-    source_map: Option<Lrc<SourceMap>>,\n-    level: Level,\n-    message: String,\n-    code: Option<DiagnosticId>,\n-    msp: MultiSpan,\n-    #[allow(dead_code)]\n-    children: &'a [SubDiagnostic],\n-    #[allow(dead_code)]\n-    suggestions: &'a [CodeSuggestion],\n+/// Provides the source string for the given `line` of `file`\n+fn source_string(file: Lrc<SourceFile>, line: &Line) -> String {\n+    file.get_line(line.line_index - 1).map(|a| a.to_string()).unwrap_or_default()\n }\n \n-impl<'a> DiagnosticConverter<'a> {\n-    /// Turns rustc Diagnostic information into a `annotate_snippets::snippet::Snippet`.\n-    fn to_annotation_snippet(&self) -> Option<Snippet> {\n-        if let Some(source_map) = &self.source_map {\n-            // Make sure our primary file comes first\n-            let primary_lo = if let Some(ref primary_span) = self.msp.primary_span().as_ref() {\n-                source_map.lookup_char_pos(primary_span.lo())\n-            } else {\n-                // FIXME(#59346): Not sure when this is the case and what\n-                // should be done if it happens\n-                return None;\n-            };\n-            let annotated_files =\n-                FileWithAnnotatedLines::collect_annotations(&self.msp, &self.source_map);\n-            let slices = self.slices_for_files(annotated_files, primary_lo);\n-\n-            Some(Snippet {\n-                title: Some(Annotation {\n-                    label: Some(self.message.to_string()),\n-                    id: self.code.clone().map(|c| match c {\n-                        DiagnosticId::Error(val) | DiagnosticId::Lint(val) => val,\n-                    }),\n-                    annotation_type: Self::annotation_type_for_level(self.level),\n-                }),\n-                footer: vec![],\n-                slices,\n-            })\n-        } else {\n-            // FIXME(#59346): Is it ok to return None if there's no source_map?\n-            None\n-        }\n-    }\n-\n-    fn slices_for_files(\n-        &self,\n-        annotated_files: Vec<FileWithAnnotatedLines>,\n-        primary_lo: Loc,\n-    ) -> Vec<Slice> {\n-        // FIXME(#64205): Provide a test case where `annotated_files` is > 1\n-        annotated_files\n-            .iter()\n-            .flat_map(|annotated_file| {\n-                annotated_file\n-                    .lines\n-                    .iter()\n-                    .map(|line| {\n-                        let line_source = Self::source_string(annotated_file.file.clone(), &line);\n-                        Slice {\n-                            source: line_source,\n-                            line_start: line.line_index,\n-                            origin: Some(primary_lo.file.name.to_string()),\n-                            // FIXME(#59346): Not really sure when `fold` should be true or false\n-                            fold: false,\n-                            annotations: line\n-                                .annotations\n-                                .iter()\n-                                .map(|a| self.annotation_to_source_annotation(a.clone()))\n-                                .collect(),\n-                        }\n-                    })\n-                    .collect::<Vec<Slice>>()\n-            })\n-            .collect::<Vec<Slice>>()\n-    }\n-\n-    /// Turns a `crate::snippet::Annotation` into a `SourceAnnotation`\n-    fn annotation_to_source_annotation(\n-        &self,\n-        annotation: crate::snippet::Annotation,\n-    ) -> SourceAnnotation {\n-        SourceAnnotation {\n-            range: (annotation.start_col, annotation.end_col),\n-            label: annotation.label.unwrap_or(\"\".to_string()),\n-            annotation_type: Self::annotation_type_for_level(self.level),\n-        }\n-    }\n-\n-    /// Provides the source string for the given `line` of `file`\n-    fn source_string(file: Lrc<SourceFile>, line: &Line) -> String {\n-        file.get_line(line.line_index - 1).map(|a| a.to_string()).unwrap_or(String::new())\n-    }\n-\n-    /// Maps `Diagnostic::Level` to `snippet::AnnotationType`\n-    fn annotation_type_for_level(level: Level) -> AnnotationType {\n-        match level {\n-            Level::Bug | Level::Fatal | Level::Error => AnnotationType::Error,\n-            Level::Warning => AnnotationType::Warning,\n-            Level::Note => AnnotationType::Note,\n-            Level::Help => AnnotationType::Help,\n-            // FIXME(#59346): Not sure how to map these two levels\n-            Level::Cancelled | Level::FailureNote => AnnotationType::Error,\n-        }\n+/// Maps `Diagnostic::Level` to `snippet::AnnotationType`\n+fn annotation_type_for_level(level: Level) -> AnnotationType {\n+    match level {\n+        Level::Bug | Level::Fatal | Level::Error => AnnotationType::Error,\n+        Level::Warning => AnnotationType::Warning,\n+        Level::Note => AnnotationType::Note,\n+        Level::Help => AnnotationType::Help,\n+        // FIXME(#59346): Not sure how to map these two levels\n+        Level::Cancelled | Level::FailureNote => AnnotationType::Error,\n     }\n }\n \n@@ -191,25 +98,87 @@ impl AnnotateSnippetEmitterWriter {\n         message: String,\n         code: &Option<DiagnosticId>,\n         msp: &MultiSpan,\n-        children: &[SubDiagnostic],\n-        suggestions: &[CodeSuggestion],\n+        _children: &[SubDiagnostic],\n+        _suggestions: &[CodeSuggestion],\n     ) {\n-        let converter = DiagnosticConverter {\n-            source_map: self.source_map.clone(),\n-            level: *level,\n-            message,\n-            code: code.clone(),\n-            msp: msp.clone(),\n-            children,\n-            suggestions,\n-        };\n-        if let Some(snippet) = converter.to_annotation_snippet() {\n-            let dl = DisplayList::from(snippet);\n-            let dlf = DisplayListFormatter::new(true, self.ui_testing);\n+        if let Some(source_map) = &self.source_map {\n+            // Make sure our primary file comes first\n+            let primary_lo = if let Some(ref primary_span) = msp.primary_span().as_ref() {\n+                if primary_span.is_dummy() {\n+                    // FIXME(#59346): Not sure when this is the case and what\n+                    // should be done if it happens\n+                    return;\n+                } else {\n+                    source_map.lookup_char_pos(primary_span.lo())\n+                }\n+            } else {\n+                // FIXME(#59346): Not sure when this is the case and what\n+                // should be done if it happens\n+                return;\n+            };\n+            let mut annotated_files =\n+                FileWithAnnotatedLines::collect_annotations(msp, &self.source_map);\n+            if let Ok(pos) =\n+                annotated_files.binary_search_by(|x| x.file.name.cmp(&primary_lo.file.name))\n+            {\n+                annotated_files.swap(0, pos);\n+            }\n+            // owned: line source, line index, annotations\n+            type Owned = (String, usize, Vec<crate::snippet::Annotation>);\n+            let origin = primary_lo.file.name.to_string();\n+            let annotated_files: Vec<Owned> = annotated_files\n+                .into_iter()\n+                .flat_map(|annotated_file| {\n+                    let file = annotated_file.file;\n+                    annotated_file\n+                        .lines\n+                        .into_iter()\n+                        .map(|line| {\n+                            (source_string(file.clone(), &line), line.line_index, line.annotations)\n+                        })\n+                        .collect::<Vec<Owned>>()\n+                })\n+                .collect();\n+            let snippet = Snippet {\n+                title: Some(Annotation {\n+                    label: Some(&message),\n+                    id: code.as_ref().map(|c| match c {\n+                        DiagnosticId::Error(val) | DiagnosticId::Lint(val) => val.as_str(),\n+                    }),\n+                    annotation_type: annotation_type_for_level(*level),\n+                }),\n+                footer: vec![],\n+                opt: FormatOptions { color: true, anonymized_line_numbers: self.ui_testing },\n+                slices: annotated_files\n+                    .iter()\n+                    .map(|(source, line_index, annotations)| {\n+                        Slice {\n+                            source,\n+                            line_start: *line_index,\n+                            origin: Some(&origin),\n+                            // FIXME(#59346): Not really sure when `fold` should be true or false\n+                            fold: false,\n+                            annotations: annotations\n+                                .into_iter()\n+                                .map(|annotation| SourceAnnotation {\n+                                    range: (annotation.start_col, annotation.end_col),\n+                                    label: annotation\n+                                        .label\n+                                        .as_ref()\n+                                        .map(|s| s.as_str())\n+                                        .unwrap_or_default(),\n+                                    annotation_type: annotation_type_for_level(*level),\n+                                })\n+                                .collect(),\n+                        }\n+                    })\n+                    .collect(),\n+            };\n             // FIXME(#59346): Figure out if we can _always_ print to stderr or not.\n             // `emitter.rs` has the `Destination` enum that lists various possible output\n             // destinations.\n-            eprintln!(\"{}\", dlf.format(&dl));\n-        };\n+            eprintln!(\"{}\", DisplayList::from(snippet))\n+        }\n+        // FIXME(#59346): Is it ok to return None if there's no source_map?\n     }\n }"}, {"sha": "4e41bd4bbfa08c42532c299ff3093698b44e3142", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -1789,6 +1789,7 @@ pub struct ExpansionConfig<'feat> {\n     pub trace_mac: bool,\n     pub should_test: bool, // If false, strip `#[test]` nodes\n     pub keep_macs: bool,\n+    pub span_debug: bool, // If true, use verbose debugging for `proc_macro::Span`\n }\n \n impl<'feat> ExpansionConfig<'feat> {\n@@ -1800,6 +1801,7 @@ impl<'feat> ExpansionConfig<'feat> {\n             trace_mac: false,\n             should_test: false,\n             keep_macs: false,\n+            span_debug: false,\n         }\n     }\n "}, {"sha": "79fa091ba180888e17d73986e103e6a2737df634", "filename": "src/librustc_expand/proc_macro_server.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibrustc_expand%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibrustc_expand%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro_server.rs?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -352,6 +352,7 @@ pub(crate) struct Rustc<'a> {\n     def_site: Span,\n     call_site: Span,\n     mixed_site: Span,\n+    span_debug: bool,\n }\n \n impl<'a> Rustc<'a> {\n@@ -362,6 +363,7 @@ impl<'a> Rustc<'a> {\n             def_site: cx.with_def_site_ctxt(expn_data.def_site),\n             call_site: cx.with_call_site_ctxt(expn_data.call_site),\n             mixed_site: cx.with_mixed_site_ctxt(expn_data.call_site),\n+            span_debug: cx.ecfg.span_debug,\n         }\n     }\n \n@@ -646,7 +648,11 @@ impl server::Diagnostic for Rustc<'_> {\n \n impl server::Span for Rustc<'_> {\n     fn debug(&mut self, span: Self::Span) -> String {\n-        format!(\"{:?} bytes({}..{})\", span.ctxt(), span.lo().0, span.hi().0)\n+        if self.span_debug {\n+            format!(\"{:?}\", span)\n+        } else {\n+            format!(\"{:?} bytes({}..{})\", span.ctxt(), span.lo().0, span.hi().0)\n+        }\n     }\n     fn def_site(&mut self) -> Self::Span {\n         self.def_site"}, {"sha": "9a60e74d94d01fe9055cb12fb34185c5552da9c5", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -291,6 +291,7 @@ fn configure_and_expand_inner<'a>(\n             recursion_limit: sess.recursion_limit(),\n             trace_mac: sess.opts.debugging_opts.trace_macros,\n             should_test: sess.opts.test,\n+            span_debug: sess.opts.debugging_opts.span_debug,\n             ..rustc_expand::expand::ExpansionConfig::default(crate_name.to_string())\n         };\n "}, {"sha": "87647f3b0b017c84dadc9d46803043794f040cdd", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -506,6 +506,7 @@ fn test_debugging_options_tracking_hash() {\n     untracked!(save_analysis, true);\n     untracked!(self_profile, SwitchWithOptPath::Enabled(None));\n     untracked!(self_profile_events, Some(vec![String::new()]));\n+    untracked!(span_debug, true);\n     untracked!(span_free_formats, true);\n     untracked!(strip, Strip::None);\n     untracked!(terminal_width, Some(80));"}, {"sha": "2ae063660e38d9d9ba178fc5630cea14a56a8182", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -95,24 +95,30 @@ impl<'a> Resolver<'a> {\n     }\n \n     crate fn get_module(&mut self, def_id: DefId) -> Module<'a> {\n+        // If this is a local module, it will be in `module_map`, no need to recalculate it.\n         if let Some(def_id) = def_id.as_local() {\n             return self.module_map[&def_id];\n         }\n \n+        // Cache module resolution\n         if let Some(&module) = self.extern_module_map.get(&def_id) {\n             return module;\n         }\n \n         let (name, parent) = if def_id.index == CRATE_DEF_INDEX {\n+            // This is the crate root\n             (self.cstore().crate_name_untracked(def_id.krate), None)\n         } else {\n             let def_key = self.cstore().def_key(def_id);\n             (\n+                // This unwrap is safe: crates must always have a name\n                 def_key.disambiguated_data.data.get_opt_name().unwrap(),\n+                // This unwrap is safe since we know this isn't the root\n                 Some(self.get_module(DefId { index: def_key.parent.unwrap(), ..def_id })),\n             )\n         };\n \n+        // Allocate and return a new module with the information we found\n         let kind = ModuleKind::Def(DefKind::Mod, def_id, name);\n         let module = self.arenas.alloc_module(ModuleData::new(\n             parent,"}, {"sha": "d22c6ec9d7d010930110db39125fedcee8fef86c", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -996,6 +996,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"make the current crate share its generic instantiations\"),\n     show_span: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"show spans for compiler debugging (expr|pat|ty)\"),\n+    span_debug: bool = (false, parse_bool, [UNTRACKED],\n+        \"forward proc_macro::Span's `Debug` impl to `Span`\"),\n     // o/w tests have closure@path\n     span_free_formats: bool = (false, parse_bool, [UNTRACKED],\n         \"exclude spans when debug-printing compiler state (default: no)\"),"}, {"sha": "b324b1618966bce066c494865a0d7da3e0f0a430", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -395,6 +395,12 @@ impl CString {\n     /// ownership of a string that was allocated by foreign code) is likely to lead\n     /// to undefined behavior or allocator corruption.\n     ///\n+    /// It should be noted that the length isn't just \"recomputed,\" but that\n+    /// the recomputed length must match the original length from the\n+    /// [`into_raw`] call. This means the [`into_raw`]/`from_raw` methods\n+    /// should not be used when passing the string to C functions that can\n+    /// modify the string's length.\n+    ///\n     /// > **Note:** If you need to borrow a string that was allocated by\n     /// > foreign code, use [`CStr`]. If you need to take ownership of\n     /// > a string that was allocated by foreign code, you will need to\n@@ -440,6 +446,11 @@ impl CString {\n     ///\n     /// Failure to call [`from_raw`] will lead to a memory leak.\n     ///\n+    /// The C side must **not** modify the length of the string (by writing a\n+    /// `NULL` somewhere inside the string or removing the final one) before\n+    /// it makes it back into Rust using [`from_raw`]. See the safety section\n+    /// in [`from_raw`].\n+    ///\n     /// [`from_raw`]: #method.from_raw\n     ///\n     /// # Examples"}, {"sha": "a4996d9eee810d0c2654aedda0fe3b048684522d", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -1213,9 +1213,61 @@ mod unsafe_keyword {}\n //\n /// Import or rename items from other crates or modules.\n ///\n-/// The documentation for this keyword is [not yet complete]. Pull requests welcome!\n+/// Usually a `use` keyword is used to shorten the path required to refer to a module item.\n+/// The keyword may appear in modules, blocks and even functions, usually at the top.\n+///\n+/// The most basic usage of the keyword is `use path::to::item;`,\n+/// though a number of convenient shortcuts are supported:\n+///\n+///   * Simultaneously binding a list of paths with a common prefix,\n+///     using the glob-like brace syntax `use a::b::{c, d, e::f, g::h::i};`\n+///   * Simultaneously binding a list of paths with a common prefix and their common parent module,\n+///     using the [`self`] keyword, such as `use a::b::{self, c, d::e};`\n+///   * Rebinding the target name as a new local name, using the syntax `use p::q::r as x;`.\n+///     This can also be used with the last two features: `use a::b::{self as ab, c as abc}`.\n+///   * Binding all paths matching a given prefix,\n+///     using the asterisk wildcard syntax `use a::b::*;`.\n+///   * Nesting groups of the previous features multiple times,\n+///     such as `use a::b::{self as ab, c, d::{*, e::f}};`\n+///   * Reexporting with visibility modifiers such as `pub use a::b;`\n+///   * Importing with `_` to only import the methods of a trait without binding it to a name\n+///     (to avoid conflict for example): `use ::std::io::Read as _;`.\n+///\n+/// Using path qualifiers like [`crate`], [`super`] or [`self`] is supported: `use crate::a::b;`.\n+///\n+/// Note that when the wildcard `*` is used on a type, it does not import its methods (though\n+/// for `enum`s it imports the variants, as shown in the example below).\n+///\n+/// ```compile_fail,edition2018\n+/// enum ExampleEnum {\n+///     VariantA,\n+///     VariantB,\n+/// }\n ///\n-/// [not yet complete]: https://github.com/rust-lang/rust/issues/34601\n+/// impl ExampleEnum {\n+///     fn new() -> Self {\n+///         Self::VariantA\n+///     }\n+/// }\n+///\n+/// use ExampleEnum::*;\n+///\n+/// // Compiles.\n+/// let _ = VariantA;\n+///\n+/// // Does not compile !\n+/// let n = new();\n+/// ```\n+///\n+/// For more information on `use` and paths in general, see the [Reference].\n+///\n+/// The differences about paths and the `use` keyword between the 2015 and 2018 editions\n+/// can also be found in the [Reference].\n+///\n+/// [`crate`]: keyword.crate.html\n+/// [`self`]: keyword.self.html\n+/// [`super`]: keyword.super.html\n+/// [Reference]: ../reference/items/use-declarations.html\n mod use_keyword {}\n \n #[doc(keyword = \"where\")]"}, {"sha": "c05d15643dbb12518c3cd69d646758985408a701", "filename": "src/test/ui/annotate-snippet/auxiliary/multispan.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Ftest%2Fui%2Fannotate-snippet%2Fauxiliary%2Fmultispan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Ftest%2Fui%2Fannotate-snippet%2Fauxiliary%2Fmultispan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fannotate-snippet%2Fauxiliary%2Fmultispan.rs?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -0,0 +1,37 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro_diagnostic, proc_macro_span, proc_macro_def_site)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::{TokenStream, TokenTree, Span, Diagnostic};\n+\n+fn parse(input: TokenStream) -> Result<(), Diagnostic> {\n+    let mut hi_spans = vec![];\n+    for tree in input {\n+        if let TokenTree::Ident(ref ident) = tree {\n+            if ident.to_string() == \"hi\" {\n+                hi_spans.push(ident.span());\n+            }\n+        }\n+    }\n+\n+    if !hi_spans.is_empty() {\n+        return Err(Span::def_site()\n+                       .error(\"hello to you, too!\")\n+                       .span_note(hi_spans, \"found these 'hi's\"));\n+    }\n+\n+    Ok(())\n+}\n+\n+#[proc_macro]\n+pub fn hello(input: TokenStream) -> TokenStream {\n+    if let Err(diag) = parse(input) {\n+        diag.emit();\n+    }\n+\n+    TokenStream::new()\n+}"}, {"sha": "c16f022a77fa338c5edc16d91d6d81d50be029ff", "filename": "src/test/ui/annotate-snippet/missing-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Ftest%2Fui%2Fannotate-snippet%2Fmissing-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Ftest%2Fui%2Fannotate-snippet%2Fmissing-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fannotate-snippet%2Fmissing-type.stderr?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -1,5 +1,5 @@\n error[E0412]: cannot find type `Iter` in this scope\n-  --> $DIR/missing-type.rs:4:11\n+  --> $DIR/missing-type.rs:4:12\n    |\n LL |     let x: Iter;\n    |            ^^^^ not found in this scope"}, {"sha": "325252d7716f60b1ab6d5c720e627e9c29ce52cf", "filename": "src/test/ui/annotate-snippet/multispan.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Ftest%2Fui%2Fannotate-snippet%2Fmultispan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Ftest%2Fui%2Fannotate-snippet%2Fmultispan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fannotate-snippet%2Fmultispan.rs?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -0,0 +1,28 @@\n+// aux-build:multispan.rs\n+// compile-flags: --error-format human-annotate-rs\n+\n+#![feature(proc_macro_hygiene)]\n+\n+extern crate multispan;\n+\n+use multispan::hello;\n+\n+fn main() {\n+    // This one emits no error.\n+    hello!();\n+\n+    // Exactly one 'hi'.\n+    hello!(hi); //~ ERROR hello to you, too!\n+\n+    // Now two, back to back.\n+    hello!(hi hi); //~ ERROR hello to you, too!\n+\n+    // Now three, back to back.\n+    hello!(hi hi hi); //~ ERROR hello to you, too!\n+\n+    // Now several, with spacing.\n+    hello!(hi hey hi yo hi beep beep hi hi); //~ ERROR hello to you, too!\n+    hello!(hi there, hi how are you? hi... hi.); //~ ERROR hello to you, too!\n+    hello!(whoah. hi di hi di ho); //~ ERROR hello to you, too!\n+    hello!(hi good hi and good bye); //~ ERROR hello to you, too!\n+}"}, {"sha": "4ac31e32ba7cfa80f6e025598f8ad3f7f4ab3e3c", "filename": "src/test/ui/annotate-snippet/multispan.stderr", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Ftest%2Fui%2Fannotate-snippet%2Fmultispan.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Ftest%2Fui%2Fannotate-snippet%2Fmultispan.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fannotate-snippet%2Fmultispan.stderr?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -0,0 +1,42 @@\n+error: hello to you, too!\n+  --> $DIR/multispan.rs:15:5\n+   |\n+LL |     hello!(hi);\n+   |     ^^^^^^^^^^^\n+   |\n+error: hello to you, too!\n+  --> $DIR/multispan.rs:18:5\n+   |\n+LL |     hello!(hi hi);\n+   |     ^^^^^^^^^^^^^^\n+   |\n+error: hello to you, too!\n+  --> $DIR/multispan.rs:21:5\n+   |\n+LL |     hello!(hi hi hi);\n+   |     ^^^^^^^^^^^^^^^^^\n+   |\n+error: hello to you, too!\n+  --> $DIR/multispan.rs:24:5\n+   |\n+LL |     hello!(hi hey hi yo hi beep beep hi hi);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+error: hello to you, too!\n+  --> $DIR/multispan.rs:25:5\n+   |\n+LL |     hello!(hi there, hi how are you? hi... hi.);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+error: hello to you, too!\n+  --> $DIR/multispan.rs:26:5\n+   |\n+LL |     hello!(whoah. hi di hi di ho);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+error: hello to you, too!\n+  --> $DIR/multispan.rs:27:5\n+   |\n+LL |     hello!(hi good hi and good bye);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |"}, {"sha": "fd34eb974c094676105acd0514e22b97693e1931", "filename": "src/test/ui/proc-macro/debug/dump-debug-span-debug.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Ftest%2Fui%2Fproc-macro%2Fdebug%2Fdump-debug-span-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Ftest%2Fui%2Fproc-macro%2Fdebug%2Fdump-debug-span-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdebug%2Fdump-debug-span-debug.rs?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -0,0 +1,41 @@\n+// run-pass\n+// aux-build:macro-dump-debug.rs\n+// compile-flags: -Z span-debug\n+\n+extern crate macro_dump_debug;\n+use macro_dump_debug::dump_debug;\n+\n+dump_debug! {\n+    ident   // ident\n+    r#ident // raw ident\n+    ,       // alone punct\n+    ==>     // joint punct\n+    ()      // empty group\n+    [_]     // nonempty group\n+\n+    // unsuffixed literals\n+    0\n+    1.0\n+    \"S\"\n+    b\"B\"\n+    r\"R\"\n+    r##\"R\"##\n+    br\"BR\"\n+    br##\"BR\"##\n+    'C'\n+    b'B'\n+\n+    // suffixed literals\n+    0q\n+    1.0q\n+    \"S\"q\n+    b\"B\"q\n+    r\"R\"q\n+    r##\"R\"##q\n+    br\"BR\"q\n+    br##\"BR\"##q\n+    'C'q\n+    b'B'q\n+}\n+\n+fn main() {}"}, {"sha": "163a2c9f44cad0d450363742fed6bdb59ce440b2", "filename": "src/test/ui/proc-macro/debug/dump-debug-span-debug.stderr", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Ftest%2Fui%2Fproc-macro%2Fdebug%2Fdump-debug-span-debug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Ftest%2Fui%2Fproc-macro%2Fdebug%2Fdump-debug-span-debug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdebug%2Fdump-debug-span-debug.stderr?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -0,0 +1,166 @@\n+TokenStream [Ident { ident: \"ident\", span: $DIR/dump-debug-span-debug.rs:9:5: 9:10 }, Ident { ident: \"r#ident\", span: $DIR/dump-debug-span-debug.rs:10:5: 10:12 }, Punct { ch: ',', spacing: Alone, span: $DIR/dump-debug-span-debug.rs:11:5: 11:6 }, Punct { ch: '=', spacing: Joint, span: $DIR/dump-debug-span-debug.rs:12:5: 12:7 }, Punct { ch: '=', spacing: Joint, span: $DIR/dump-debug-span-debug.rs:12:5: 12:7 }, Punct { ch: '>', spacing: Alone, span: $DIR/dump-debug-span-debug.rs:12:7: 12:8 }, Group { delimiter: Parenthesis, stream: TokenStream [], span: $DIR/dump-debug-span-debug.rs:13:5: 13:7 }, Group { delimiter: Bracket, stream: TokenStream [Ident { ident: \"_\", span: $DIR/dump-debug-span-debug.rs:14:6: 14:7 }], span: $DIR/dump-debug-span-debug.rs:14:5: 14:8 }, Literal { kind: Integer, symbol: \"0\", suffix: None, span: $DIR/dump-debug-span-debug.rs:17:5: 17:6 }, Literal { kind: Float, symbol: \"1.0\", suffix: None, span: $DIR/dump-debug-span-debug.rs:18:5: 18:8 }, Literal { kind: Str, symbol: \"S\", suffix: None, span: $DIR/dump-debug-span-debug.rs:19:5: 19:8 }, Literal { kind: ByteStr, symbol: \"B\", suffix: None, span: $DIR/dump-debug-span-debug.rs:20:5: 20:9 }, Literal { kind: StrRaw(0), symbol: \"R\", suffix: None, span: $DIR/dump-debug-span-debug.rs:21:5: 21:9 }, Literal { kind: StrRaw(2), symbol: \"R\", suffix: None, span: $DIR/dump-debug-span-debug.rs:22:5: 22:13 }, Literal { kind: ByteStrRaw(0), symbol: \"BR\", suffix: None, span: $DIR/dump-debug-span-debug.rs:23:5: 23:11 }, Literal { kind: ByteStrRaw(2), symbol: \"BR\", suffix: None, span: $DIR/dump-debug-span-debug.rs:24:5: 24:15 }, Literal { kind: Char, symbol: \"C\", suffix: None, span: $DIR/dump-debug-span-debug.rs:25:5: 25:8 }, Literal { kind: Byte, symbol: \"B\", suffix: None, span: $DIR/dump-debug-span-debug.rs:26:5: 26:9 }, Literal { kind: Integer, symbol: \"0\", suffix: Some(\"q\"), span: $DIR/dump-debug-span-debug.rs:29:5: 29:7 }, Literal { kind: Float, symbol: \"1.0\", suffix: Some(\"q\"), span: $DIR/dump-debug-span-debug.rs:30:5: 30:9 }, Literal { kind: Str, symbol: \"S\", suffix: Some(\"q\"), span: $DIR/dump-debug-span-debug.rs:31:5: 31:9 }, Literal { kind: ByteStr, symbol: \"B\", suffix: Some(\"q\"), span: $DIR/dump-debug-span-debug.rs:32:5: 32:10 }, Literal { kind: StrRaw(0), symbol: \"R\", suffix: Some(\"q\"), span: $DIR/dump-debug-span-debug.rs:33:5: 33:10 }, Literal { kind: StrRaw(2), symbol: \"R\", suffix: Some(\"q\"), span: $DIR/dump-debug-span-debug.rs:34:5: 34:14 }, Literal { kind: ByteStrRaw(0), symbol: \"BR\", suffix: Some(\"q\"), span: $DIR/dump-debug-span-debug.rs:35:5: 35:12 }, Literal { kind: ByteStrRaw(2), symbol: \"BR\", suffix: Some(\"q\"), span: $DIR/dump-debug-span-debug.rs:36:5: 36:16 }, Literal { kind: Char, symbol: \"C\", suffix: Some(\"q\"), span: $DIR/dump-debug-span-debug.rs:37:5: 37:9 }, Literal { kind: Byte, symbol: \"B\", suffix: Some(\"q\"), span: $DIR/dump-debug-span-debug.rs:38:5: 38:10 }]\n+TokenStream [\n+    Ident {\n+        ident: \"ident\",\n+        span: $DIR/dump-debug-span-debug.rs:9:5: 9:10,\n+    },\n+    Ident {\n+        ident: \"r#ident\",\n+        span: $DIR/dump-debug-span-debug.rs:10:5: 10:12,\n+    },\n+    Punct {\n+        ch: ',',\n+        spacing: Alone,\n+        span: $DIR/dump-debug-span-debug.rs:11:5: 11:6,\n+    },\n+    Punct {\n+        ch: '=',\n+        spacing: Joint,\n+        span: $DIR/dump-debug-span-debug.rs:12:5: 12:7,\n+    },\n+    Punct {\n+        ch: '=',\n+        spacing: Joint,\n+        span: $DIR/dump-debug-span-debug.rs:12:5: 12:7,\n+    },\n+    Punct {\n+        ch: '>',\n+        spacing: Alone,\n+        span: $DIR/dump-debug-span-debug.rs:12:7: 12:8,\n+    },\n+    Group {\n+        delimiter: Parenthesis,\n+        stream: TokenStream [],\n+        span: $DIR/dump-debug-span-debug.rs:13:5: 13:7,\n+    },\n+    Group {\n+        delimiter: Bracket,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"_\",\n+                span: $DIR/dump-debug-span-debug.rs:14:6: 14:7,\n+            },\n+        ],\n+        span: $DIR/dump-debug-span-debug.rs:14:5: 14:8,\n+    },\n+    Literal {\n+        kind: Integer,\n+        symbol: \"0\",\n+        suffix: None,\n+        span: $DIR/dump-debug-span-debug.rs:17:5: 17:6,\n+    },\n+    Literal {\n+        kind: Float,\n+        symbol: \"1.0\",\n+        suffix: None,\n+        span: $DIR/dump-debug-span-debug.rs:18:5: 18:8,\n+    },\n+    Literal {\n+        kind: Str,\n+        symbol: \"S\",\n+        suffix: None,\n+        span: $DIR/dump-debug-span-debug.rs:19:5: 19:8,\n+    },\n+    Literal {\n+        kind: ByteStr,\n+        symbol: \"B\",\n+        suffix: None,\n+        span: $DIR/dump-debug-span-debug.rs:20:5: 20:9,\n+    },\n+    Literal {\n+        kind: StrRaw(0),\n+        symbol: \"R\",\n+        suffix: None,\n+        span: $DIR/dump-debug-span-debug.rs:21:5: 21:9,\n+    },\n+    Literal {\n+        kind: StrRaw(2),\n+        symbol: \"R\",\n+        suffix: None,\n+        span: $DIR/dump-debug-span-debug.rs:22:5: 22:13,\n+    },\n+    Literal {\n+        kind: ByteStrRaw(0),\n+        symbol: \"BR\",\n+        suffix: None,\n+        span: $DIR/dump-debug-span-debug.rs:23:5: 23:11,\n+    },\n+    Literal {\n+        kind: ByteStrRaw(2),\n+        symbol: \"BR\",\n+        suffix: None,\n+        span: $DIR/dump-debug-span-debug.rs:24:5: 24:15,\n+    },\n+    Literal {\n+        kind: Char,\n+        symbol: \"C\",\n+        suffix: None,\n+        span: $DIR/dump-debug-span-debug.rs:25:5: 25:8,\n+    },\n+    Literal {\n+        kind: Byte,\n+        symbol: \"B\",\n+        suffix: None,\n+        span: $DIR/dump-debug-span-debug.rs:26:5: 26:9,\n+    },\n+    Literal {\n+        kind: Integer,\n+        symbol: \"0\",\n+        suffix: Some(\"q\"),\n+        span: $DIR/dump-debug-span-debug.rs:29:5: 29:7,\n+    },\n+    Literal {\n+        kind: Float,\n+        symbol: \"1.0\",\n+        suffix: Some(\"q\"),\n+        span: $DIR/dump-debug-span-debug.rs:30:5: 30:9,\n+    },\n+    Literal {\n+        kind: Str,\n+        symbol: \"S\",\n+        suffix: Some(\"q\"),\n+        span: $DIR/dump-debug-span-debug.rs:31:5: 31:9,\n+    },\n+    Literal {\n+        kind: ByteStr,\n+        symbol: \"B\",\n+        suffix: Some(\"q\"),\n+        span: $DIR/dump-debug-span-debug.rs:32:5: 32:10,\n+    },\n+    Literal {\n+        kind: StrRaw(0),\n+        symbol: \"R\",\n+        suffix: Some(\"q\"),\n+        span: $DIR/dump-debug-span-debug.rs:33:5: 33:10,\n+    },\n+    Literal {\n+        kind: StrRaw(2),\n+        symbol: \"R\",\n+        suffix: Some(\"q\"),\n+        span: $DIR/dump-debug-span-debug.rs:34:5: 34:14,\n+    },\n+    Literal {\n+        kind: ByteStrRaw(0),\n+        symbol: \"BR\",\n+        suffix: Some(\"q\"),\n+        span: $DIR/dump-debug-span-debug.rs:35:5: 35:12,\n+    },\n+    Literal {\n+        kind: ByteStrRaw(2),\n+        symbol: \"BR\",\n+        suffix: Some(\"q\"),\n+        span: $DIR/dump-debug-span-debug.rs:36:5: 36:16,\n+    },\n+    Literal {\n+        kind: Char,\n+        symbol: \"C\",\n+        suffix: Some(\"q\"),\n+        span: $DIR/dump-debug-span-debug.rs:37:5: 37:9,\n+    },\n+    Literal {\n+        kind: Byte,\n+        symbol: \"B\",\n+        suffix: Some(\"q\"),\n+        span: $DIR/dump-debug-span-debug.rs:38:5: 38:10,\n+    },\n+]"}, {"sha": "b687f0b0af0ad90f60c98d9d0a6f44e182055bbf", "filename": "src/test/ui/resolve/issue-2356.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Ftest%2Fui%2Fresolve%2Fissue-2356.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bc10b68e798477066d4b1ec4886a3b1cdc4feb7e/src%2Ftest%2Fui%2Fresolve%2Fissue-2356.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-2356.stderr?ref=bc10b68e798477066d4b1ec4886a3b1cdc4feb7e", "patch": "@@ -14,7 +14,16 @@ error[E0425]: cannot find function `default` in this scope\n   --> $DIR/issue-2356.rs:31:5\n    |\n LL |     default();\n-   |     ^^^^^^^ help: try: `Self::default`\n+   |     ^^^^^^^\n+   |\n+help: try\n+   |\n+LL |     Self::default();\n+   |     ^^^^^^^^^^^^^\n+help: consider importing this function\n+   |\n+LL | use std::default::default;\n+   |\n \n error[E0425]: cannot find value `whiskers` in this scope\n   --> $DIR/issue-2356.rs:39:5"}]}