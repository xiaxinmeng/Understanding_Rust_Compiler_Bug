{"sha": "b62289153cd94dc60e142e169816bbec68514906", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2MjI4OTE1M2NkOTRkYzYwZTE0MmUxNjk4MTZiYmVjNjg1MTQ5MDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-04T16:54:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-04T16:54:11Z"}, "message": "Auto merge of #30553 - luqmana:mir-match-arm-guards, r=nikomatsakis\n\nFixes #30527.\n\n```Rust\n\nfn main() {\n    let _abc = match Some(101i8) {\n        Some(xyz) if xyz > 100 => xyz,\n        Some(_) => -1,\n        None => -2\n    };\n}\n```\n\nResulting MIR now includes the `Some(xyz)` arm, guard and all:\n![match.dot](https://cloud.githubusercontent.com/assets/287063/11999413/066f7610-aa8b-11e5-927b-24215af57fc4.png)\n\n~~Not quite sure how to write a test for this.~~ Thinking too hard, just tested the end result.\n\nr? @nikomatsakis", "tree": {"sha": "a78fd4fb9d719ea396e8e75836b9c051fa900bf8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a78fd4fb9d719ea396e8e75836b9c051fa900bf8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b62289153cd94dc60e142e169816bbec68514906", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b62289153cd94dc60e142e169816bbec68514906", "html_url": "https://github.com/rust-lang/rust/commit/b62289153cd94dc60e142e169816bbec68514906", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b62289153cd94dc60e142e169816bbec68514906/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "543bb03d3ec864cfe47a9afd761101ea95f628f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/543bb03d3ec864cfe47a9afd761101ea95f628f6", "html_url": "https://github.com/rust-lang/rust/commit/543bb03d3ec864cfe47a9afd761101ea95f628f6"}, {"sha": "f88c808b7311fe6cf6f8b4133fed7e33e437b325", "url": "https://api.github.com/repos/rust-lang/rust/commits/f88c808b7311fe6cf6f8b4133fed7e33e437b325", "html_url": "https://github.com/rust-lang/rust/commit/f88c808b7311fe6cf6f8b4133fed7e33e437b325"}], "stats": {"total": 69, "additions": 46, "deletions": 23}, "files": [{"sha": "10c6851feb3e1cd909e0de9069af2501fbf3f787", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b62289153cd94dc60e142e169816bbec68514906/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62289153cd94dc60e142e169816bbec68514906/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=b62289153cd94dc60e142e169816bbec68514906", "patch": "@@ -61,16 +61,13 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // assemble a list of candidates: there is one candidate per\n         // pattern, which means there may be more than one candidate\n         // *per arm*. These candidates are kept sorted such that the\n-        // highest priority candidate comes last in the list. This the\n-        // reverse of the order in which candidates are written in the\n-        // source.\n+        // highest priority candidate comes first in the list.\n+        // (i.e. same order as in source)\n         let candidates: Vec<_> =\n             arms.iter()\n                 .enumerate()\n-                .rev() // highest priority comes last\n                 .flat_map(|(arm_index, arm)| {\n                     arm.patterns.iter()\n-                                .rev()\n                                 .map(move |pat| (arm_index, pat, arm.guard.clone()))\n                 })\n                 .map(|(arm_index, pattern, guard)| {\n@@ -290,9 +287,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// The main match algorithm. It begins with a set of candidates\n     /// `candidates` and has the job of generating code to determine\n     /// which of these candidates, if any, is the correct one. The\n-    /// candidates are sorted in inverse priority -- so the last item\n-    /// in the list has highest priority. When a candidate is found to\n-    /// match the value, we will generate a branch to the appropriate\n+    /// candidates are sorted such that the first item in the list\n+    /// has the highest priority. When a candidate is found to match\n+    /// the value, we will generate a branch to the appropriate\n     /// block found in `arm_blocks`.\n     ///\n     /// The return value is a list of \"otherwise\" blocks. These are\n@@ -324,17 +321,17 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             unpack!(block = self.simplify_candidate(block, candidate));\n         }\n \n-        // The candidates are inversely sorted by priority. Check to\n-        // see whether the candidates in the front of the queue (and\n-        // hence back of the vec) have satisfied all their match\n+        // The candidates are sorted by priority. Check to see\n+        // whether the higher priority candidates (and hence at\n+        // the front of the vec) have satisfied all their match\n         // pairs.\n         let fully_matched =\n-            candidates.iter().rev().take_while(|c| c.match_pairs.is_empty()).count();\n+            candidates.iter().take_while(|c| c.match_pairs.is_empty()).count();\n         debug!(\"match_candidates: {:?} candidates fully matched\", fully_matched);\n-        for _ in 0..fully_matched {\n+        let mut unmatched_candidates = candidates.split_off(fully_matched);\n+        for candidate in candidates {\n             // If so, apply any bindings, test the guard (if any), and\n             // branch to the arm.\n-            let candidate = candidates.pop().unwrap();\n             if let Some(b) = self.bind_and_guard_matched_candidate(block, arm_blocks, candidate) {\n                 block = b;\n             } else {\n@@ -346,13 +343,13 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n         // If there are no candidates that still need testing, we're done.\n         // Since all matches are exhaustive, execution should never reach this point.\n-        if candidates.is_empty() {\n+        if unmatched_candidates.is_empty() {\n             return vec![block];\n         }\n \n         // Test candidates where possible.\n         let (otherwise, tested_candidates) =\n-            self.test_candidates(span, arm_blocks, &candidates, block);\n+            self.test_candidates(span, arm_blocks, &unmatched_candidates, block);\n \n         // If the target candidates were exhaustive, then we are done.\n         if otherwise.is_empty() {\n@@ -361,15 +358,14 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n         // If all candidates were sorted into `target_candidates` somewhere, then\n         // the initial set was inexhaustive.\n-        let untested_candidates = candidates.len() - tested_candidates;\n-        if untested_candidates == 0 {\n+        let untested_candidates = unmatched_candidates.split_off(tested_candidates);\n+        if untested_candidates.len() == 0 {\n             return otherwise;\n         }\n \n         // Otherwise, let's process those remaining candidates.\n         let join_block = self.join_otherwise_blocks(otherwise);\n-        candidates.truncate(untested_candidates);\n-        self.match_candidates(span, arm_blocks, candidates, join_block)\n+        self.match_candidates(span, arm_blocks, untested_candidates, join_block)\n     }\n \n     fn join_otherwise_blocks(&mut self,\n@@ -461,7 +457,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                              -> (Vec<BasicBlock>, usize)\n     {\n         // extract the match-pair from the highest priority candidate\n-        let match_pair = &candidates.last().unwrap().match_pairs[0];\n+        let match_pair = &candidates.first().unwrap().match_pairs[0];\n         let mut test = self.test(match_pair);\n \n         // most of the time, the test to perform is simply a function\n@@ -470,7 +466,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // available\n         match test.kind {\n             TestKind::SwitchInt { switch_ty, ref mut options, ref mut indices } => {\n-                for candidate in candidates.iter().rev() {\n+                for candidate in candidates.iter() {\n                     if !self.add_cases_to_switch(&match_pair.lvalue,\n                                                  candidate,\n                                                  switch_ty,\n@@ -497,7 +493,6 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // that point, we stop sorting.\n         let tested_candidates =\n             candidates.iter()\n-                      .rev()\n                       .take_while(|c| self.sort_candidate(&match_pair.lvalue,\n                                                           &test,\n                                                           c,"}, {"sha": "fb177ba7b2bb083aeb925d09f2a487f8bffd7ee0", "filename": "src/test/run-pass/mir_match_arm_guard.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b62289153cd94dc60e142e169816bbec68514906/src%2Ftest%2Frun-pass%2Fmir_match_arm_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62289153cd94dc60e142e169816bbec68514906/src%2Ftest%2Frun-pass%2Fmir_match_arm_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_match_arm_guard.rs?ref=b62289153cd94dc60e142e169816bbec68514906", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// #30527 - We were not generating arms with guards in certain cases.\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_mir]\n+fn match_with_guard(x: Option<i8>) -> i8 {\n+    match x {\n+        Some(xyz) if xyz > 100 => 0,\n+        Some(_) => -1,\n+        None => -2\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(match_with_guard(Some(111)), 0);\n+    assert_eq!(match_with_guard(Some(2)), -1);\n+    assert_eq!(match_with_guard(None), -2);\n+}"}]}