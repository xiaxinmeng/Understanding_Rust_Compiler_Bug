{"sha": "9877d98b8f91be7e1494e84d685882996b84c877", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4NzdkOThiOGY5MWJlN2UxNDk0ZTg0ZDY4NTg4Mjk5NmI4NGM4Nzc=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2013-02-12T01:07:25Z"}, "committer": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2013-02-12T04:49:49Z"}, "message": "core: Rewrite last_os_error in Rust for unix and provide access to errno (unix) and GetLastError (windows).", "tree": {"sha": "ef386dd16e42ecb3c9a8df4dc2befe3de34e659c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef386dd16e42ecb3c9a8df4dc2befe3de34e659c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9877d98b8f91be7e1494e84d685882996b84c877", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9877d98b8f91be7e1494e84d685882996b84c877", "html_url": "https://github.com/rust-lang/rust/commit/9877d98b8f91be7e1494e84d685882996b84c877", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9877d98b8f91be7e1494e84d685882996b84c877/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8f039a085c7d7622899b7a4d1bebfe2d7621165", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8f039a085c7d7622899b7a4d1bebfe2d7621165", "html_url": "https://github.com/rust-lang/rust/commit/a8f039a085c7d7622899b7a4d1bebfe2d7621165"}], "stats": {"total": 112, "additions": 103, "deletions": 9}, "files": [{"sha": "8abbce0649d1190f4d6c90f77f1cfd405c172a38", "filename": "src/libcore/os.rs", "status": "modified", "additions": 103, "deletions": 9, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/9877d98b8f91be7e1494e84d685882996b84c877/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9877d98b8f91be7e1494e84d685882996b84c877/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=9877d98b8f91be7e1494e84d685882996b84c877", "patch": "@@ -66,7 +66,7 @@ extern mod rustrt {\n     unsafe fn rust_set_exit_status(code: libc::intptr_t);\n }\n \n-pub const tmpbuf_sz : uint = 1000u;\n+pub const TMPBUF_SZ : uint = 1000u;\n \n pub fn getcwd() -> Path {\n     unsafe {\n@@ -80,7 +80,7 @@ pub fn as_c_charp<T>(s: &str, f: fn(*c_char) -> T) -> T {\n \n pub fn fill_charp_buf(f: fn(*mut c_char, size_t) -> bool)\n     -> Option<~str> {\n-    let buf = vec::cast_to_mut(vec::from_elem(tmpbuf_sz, 0u8 as c_char));\n+    let buf = vec::cast_to_mut(vec::from_elem(TMPBUF_SZ, 0u8 as c_char));\n     do vec::as_mut_buf(buf) |b, sz| {\n         if f(b, sz as size_t) {\n             unsafe {\n@@ -99,19 +99,19 @@ pub mod win32 {\n     use str;\n     use option::{None, Option};\n     use option;\n-    use os::tmpbuf_sz;\n+    use os::TMPBUF_SZ;\n     use libc::types::os::arch::extra::DWORD;\n \n     pub fn fill_utf16_buf_and_decode(f: fn(*mut u16, DWORD) -> DWORD)\n         -> Option<~str> {\n         unsafe {\n-            let mut n = tmpbuf_sz as DWORD;\n+            let mut n = TMPBUF_SZ as DWORD;\n             let mut res = None;\n             let mut done = false;\n             while !done {\n                 let buf = vec::cast_to_mut(vec::from_elem(n as uint, 0u16));\n                 do vec::as_mut_buf(buf) |b, _sz| {\n-                    let k : DWORD = f(b, tmpbuf_sz as DWORD);\n+                    let k : DWORD = f(b, TMPBUF_SZ as DWORD);\n                     if k == (0 as DWORD) {\n                         done = true;\n                     } else if (k == n &&\n@@ -387,11 +387,11 @@ pub fn self_exe_path() -> Option<Path> {\n         unsafe {\n             use libc::funcs::posix01::unistd::readlink;\n \n-            let mut path_str = str::with_capacity(tmpbuf_sz);\n+            let mut path_str = str::with_capacity(TMPBUF_SZ);\n             let len = do str::as_c_str(path_str) |buf| {\n                 let buf = buf as *mut c_char;\n                 do as_c_charp(\"/proc/self/exe\") |proc_self_buf| {\n-                    readlink(proc_self_buf, buf, tmpbuf_sz as size_t)\n+                    readlink(proc_self_buf, buf, TMPBUF_SZ as size_t)\n                 }\n             };\n             if len == -1 {\n@@ -766,11 +766,105 @@ pub fn remove_file(p: &Path) -> bool {\n     }\n }\n \n+#[cfg(unix)]\n+pub fn errno() -> int {\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    fn errno_location() -> *c_int {\n+        #[nolink]\n+        extern {\n+            unsafe fn __error() -> *c_int;\n+        }\n+        unsafe {\n+            __error()\n+        }\n+    }\n+\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"android\")]\n+    fn errno_location() -> *c_int {\n+        #[nolink]\n+        extern {\n+            unsafe fn __errno_location() -> *c_int;\n+        }\n+        unsafe {\n+            __errno_location()\n+        }\n+    }\n+\n+    unsafe {\n+        (*errno_location()) as int\n+    }\n+}\n+\n+#[cfg(windows)]\n+pub fn errno() -> uint {\n+    use libc::types::os::arch::extra::DWORD;\n+\n+    #[link_name = \"kernel32\"]\n+    #[abi = \"stdcall\"]\n+    extern {\n+        unsafe fn GetLastError() -> DWORD;\n+    }\n+\n+    unsafe {\n+        GetLastError() as uint;\n+    }\n+}\n+\n /// Get a string representing the platform-dependent last error\n pub fn last_os_error() -> ~str {\n-    unsafe {\n-        rustrt::last_os_error()\n+    #[cfg(unix)]\n+    fn strerror() -> ~str {\n+        #[cfg(target_os = \"macos\")]\n+        #[cfg(target_os = \"android\")]\n+        #[cfg(target_os = \"freebsd\")]\n+        fn strerror_r(errnum: c_int, buf: *c_char, buflen: size_t) -> c_int {\n+            #[nolink]\n+            extern {\n+                unsafe fn strerror_r(errnum: c_int, buf: *c_char,\n+                                     buflen: size_t) -> c_int;\n+            }\n+            unsafe {\n+                strerror_r(errnum, buf, buflen)\n+            }\n+        }\n+\n+        // GNU libc provides a non-compliant version of strerror_r by default\n+        // and requires macros to instead use the POSIX compliant variant.\n+        // So instead we just use __xpg_strerror_r which is always POSIX compliant\n+        #[cfg(target_os = \"linux\")]\n+        fn strerror_r(errnum: c_int, buf: *c_char, buflen: size_t) -> c_int {\n+            #[nolink]\n+            extern {\n+                unsafe fn __xpg_strerror_r(errnum: c_int, buf: *c_char,\n+                                           buflen: size_t) -> c_int;\n+            }\n+            unsafe {\n+                __xpg_strerror_r(errnum, buf, buflen)\n+            }\n+        }\n+\n+        let mut buf = [0 as c_char, ..TMPBUF_SZ];\n+        unsafe {\n+            let err = strerror_r(errno() as c_int, &buf[0],\n+                                 TMPBUF_SZ as size_t);\n+            if err < 0 {\n+                die!(~\"strerror_r failure\");\n+            }\n+            \n+            str::raw::from_c_str(&buf[0])\n+        }\n     }\n+\n+    #[cfg(windows)]\n+    fn strerror() -> ~str {\n+        unsafe {\n+            rustrt::last_os_error()\n+        }\n+    }\n+\n+    strerror()\n }\n \n /**"}]}