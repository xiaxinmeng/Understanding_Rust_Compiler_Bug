{"sha": "6848ba2665d10380f259addbd9f60d0ab8d3542a", "node_id": "C_kwDOAAsO6NoAKDY4NDhiYTI2NjVkMTAzODBmMjU5YWRkYmQ5ZjYwZDBhYjhkMzU0MmE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-08-17T06:17:36Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-08-21T02:35:11Z"}, "message": "Comment a bit, use find_ancestor_in_same_ctxt to suppress some weird macro notes", "tree": {"sha": "87a269ac4ba606b55f1c70d4bd911c56d04b66fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87a269ac4ba606b55f1c70d4bd911c56d04b66fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6848ba2665d10380f259addbd9f60d0ab8d3542a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6848ba2665d10380f259addbd9f60d0ab8d3542a", "html_url": "https://github.com/rust-lang/rust/commit/6848ba2665d10380f259addbd9f60d0ab8d3542a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6848ba2665d10380f259addbd9f60d0ab8d3542a/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "292ab399b339154e77fef54efe8b975654259733", "url": "https://api.github.com/repos/rust-lang/rust/commits/292ab399b339154e77fef54efe8b975654259733", "html_url": "https://github.com/rust-lang/rust/commit/292ab399b339154e77fef54efe8b975654259733"}], "stats": {"total": 251, "additions": 151, "deletions": 100}, "files": [{"sha": "a624e3ab1429fa8854796521f49d13a62750ec9d", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6848ba2665d10380f259addbd9f60d0ab8d3542a/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6848ba2665d10380f259addbd9f60d0ab8d3542a/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=6848ba2665d10380f259addbd9f60d0ab8d3542a", "patch": "@@ -664,6 +664,13 @@ impl Span {\n         Some(self)\n     }\n \n+    pub fn find_ancestor_in_same_ctxt(mut self, other: Span) -> Option<Span> {\n+        while !Span::eq_ctxt(self, other) {\n+            self = self.parent_callsite()?;\n+        }\n+        Some(self)\n+    }\n+\n     /// Edition of the crate from which this span came.\n     pub fn edition(self) -> edition::Edition {\n         self.ctxt().edition()"}, {"sha": "12f73ae96e9e5c31f1325da14504ade4bb7c5d4b", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 144, "deletions": 96, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/6848ba2665d10380f259addbd9f60d0ab8d3542a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6848ba2665d10380f259addbd9f60d0ab8d3542a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=6848ba2665d10380f259addbd9f60d0ab8d3542a", "patch": "@@ -657,7 +657,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             Applicability::MachineApplicable,\n                         );\n                     };\n-                    self.label_fn_like(&mut err, fn_def_id, callee_ty, Some(mismatch_idx), is_method);\n+                    self.label_fn_like(\n+                        &mut err,\n+                        fn_def_id,\n+                        callee_ty,\n+                        Some(mismatch_idx),\n+                        is_method,\n+                    );\n                     err.emit();\n                     return;\n                 }\n@@ -1064,8 +1070,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 let suggestion_text = if let Some(provided_idx) = provided_idx\n                     && let (_, provided_span) = provided_arg_tys[*provided_idx]\n-                    && let Ok(arg_text) =\n-                        source_map.span_to_snippet(provided_span)\n+                    && let Ok(arg_text) = source_map.span_to_snippet(provided_span)\n                 {\n                     arg_text\n                 } else {\n@@ -1603,22 +1608,32 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    /// Given a vec of evaluated `FulfillmentError`s and an `fn` call argument expressions, we walk\n-    /// the checked and coerced types for each argument to see if any of the `FulfillmentError`s\n-    /// reference a type argument. The reason to walk also the checked type is that the coerced type\n-    /// can be not easily comparable with predicate type (because of coercion). If the types match\n-    /// for either checked or coerced type, and there's only *one* argument that does, we point at\n-    /// the corresponding argument's expression span instead of the `fn` call path span.\n+    /// Given a vector of fulfillment errors, try to adjust the spans of the\n+    /// errors to more accurately point at the cause of the failure.\n+    ///\n+    /// This applies to calls, methods, and struct expressions. This will also\n+    /// try to deduplicate errors that are due to the same cause but might\n+    /// have been created with different [`ObligationCause`][traits::ObligationCause]s.\n     pub(super) fn adjust_fulfillment_errors_for_expr_obligation(\n         &self,\n         errors: &mut Vec<traits::FulfillmentError<'tcx>>,\n     ) {\n+        // Store a mapping from `(Span, Predicate) -> ObligationCause`, so that\n+        // other errors that have the same span and predicate can also get fixed,\n+        // even if their `ObligationCauseCode` isn't an `Expr*Obligation` kind.\n+        // This is important since if we adjust one span but not the other, then\n+        // we will have \"duplicated\" the error on the UI side.\n         let mut remap_cause = FxHashSet::default();\n         let mut not_adjusted = vec![];\n \n         for error in errors {\n             let before_span = error.obligation.cause.span;\n-            if self.adjust_fulfillment_error_for_expr_obligation(error) {\n+            if self.adjust_fulfillment_error_for_expr_obligation(error)\n+                || before_span != error.obligation.cause.span\n+            {\n+                // Store both the predicate and the predicate *without constness*\n+                // since sometimes we instantiate and check both of these in a\n+                // method call, for example.\n                 remap_cause.insert((\n                     before_span,\n                     error.obligation.predicate,\n@@ -1630,6 +1645,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     error.obligation.cause.clone(),\n                 ));\n             } else {\n+                // If it failed to be adjusted once around, it may be adjusted\n+                // via the \"remap cause\" mapping the second time...\n                 not_adjusted.push(error);\n             }\n         }\n@@ -1697,7 +1714,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         // Prefer generics that are local to the fn item, since these are likely\n-        // to be the cause of the unsatisfied predicaete.\n+        // to be the cause of the unsatisfied predicate.\n         let mut param_to_point_at = find_param_matching(&|param_ty| {\n             self.tcx.parent(generics.type_param(param_ty, self.tcx).def_id) == def_id\n         });\n@@ -1708,14 +1725,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 && param_ty.name != rustc_span::symbol::kw::SelfUpper\n         });\n         // Finally, the `Self` parameter is possibly the reason that the predicate\n-        // is unsatisfied. This is less likely to be true for methods, because the\n+        // is unsatisfied. This is less likely to be true for methods, because\n         // method probe means that we already kinda check that the predicates due\n         // to the `Self` type are true.\n         let mut self_param_to_point_at =\n             find_param_matching(&|param_ty| param_ty.name == rustc_span::symbol::kw::SelfUpper);\n \n-        // For ambiguity errors, we actually want to look for a parameter that is\n-        // the source of the inference type left over in this predicate.\n+        // Finally, for ambiguity-related errors, we actually want to look\n+        // for a parameter that is the source of the inference type left\n+        // over in this predicate.\n         if let traits::FulfillmentErrorCode::CodeAmbiguity = error.code {\n             fallback_param_to_point_at = None;\n             self_param_to_point_at = None;\n@@ -1724,25 +1742,35 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         let hir = self.tcx.hir();\n-\n         match hir.get(hir_id) {\n             hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Path(qpath), hir_id, .. }) => {\n-                if let hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Call(callee, args), hir_id: call_hir_id, .. })\n-                    = hir.get(hir.get_parent_node(*hir_id))\n+                if let hir::Node::Expr(hir::Expr {\n+                    kind: hir::ExprKind::Call(callee, args),\n+                    hir_id: call_hir_id,\n+                    ..\n+                }) = hir.get(hir.get_parent_node(*hir_id))\n                     && callee.hir_id == *hir_id\n                 {\n-                    for param in [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at] {\n+                    for param in\n+                        [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n+                    {\n                         if let Some(param) = param\n-                            && self.point_at_arg_if_possible(error, def_id, param, *call_hir_id, callee.span, args)\n+                            && self.point_at_arg_if_possible(\n+                                error,\n+                                def_id,\n+                                param,\n+                                *call_hir_id,\n+                                callee.span,\n+                                args,\n+                            )\n                         {\n                             return true;\n                         }\n                     }\n-\n                     // Notably, we only point to params that are local to the\n                     // item we're checking, since those are the ones we are able\n-                    // to look in the hir::PathSegment for. Everything else\n-                    // would require a deeper search into the qpath than I think\n+                    // to look in the final `hir::PathSegment` for. Everything else\n+                    // would require a deeper search into the `qpath` than I think\n                     // is worthwhile.\n                     if let Some(param_to_point_at) = param_to_point_at\n                         && self.point_at_path_if_possible(error, def_id, param_to_point_at, qpath)\n@@ -1758,12 +1786,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 for param in [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n                 {\n                     if let Some(param) = param\n-                        && self.point_at_arg_if_possible(error, def_id, param, hir_id, segment.ident.span, args)\n+                        && self.point_at_arg_if_possible(\n+                            error,\n+                            def_id,\n+                            param,\n+                            hir_id,\n+                            segment.ident.span,\n+                            args,\n+                        )\n                     {\n                         return true;\n                     }\n                 }\n-\n                 if let Some(param_to_point_at) = param_to_point_at\n                     && self.point_at_generic_if_possible(error, def_id, param_to_point_at, segment)\n                 {\n@@ -1780,13 +1814,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n                     {\n                         if let Some(param) = param\n-                            && self.point_at_field_if_possible(error, def_id, param, variant_def_id, fields)\n+                            && self.point_at_field_if_possible(\n+                                error,\n+                                def_id,\n+                                param,\n+                                variant_def_id,\n+                                fields,\n+                            )\n                         {\n                             return true;\n                         }\n                     }\n                 }\n-\n                 if let Some(param_to_point_at) = param_to_point_at\n                     && self.point_at_path_if_possible(error, def_id, param_to_point_at, qpath)\n                 {\n@@ -1799,32 +1838,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n-    fn point_at_path_if_possible(\n-        &self,\n-        error: &mut traits::FulfillmentError<'tcx>,\n-        def_id: DefId,\n-        param: ty::GenericArg<'tcx>,\n-        qpath: &QPath<'tcx>,\n-    ) -> bool {\n-        match qpath {\n-            hir::QPath::Resolved(_, path) => {\n-                if let Some(segment) = path.segments.last()\n-                    && self.point_at_generic_if_possible(error, def_id, param, segment)\n-                {\n-                    return true;\n-                }\n-            }\n-            hir::QPath::TypeRelative(_, segment) => {\n-                if self.point_at_generic_if_possible(error, def_id, param, segment) {\n-                    return true;\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        false\n-    }\n-\n     fn point_at_arg_if_possible(\n         &self,\n         error: &mut traits::FulfillmentError<'tcx>,\n@@ -1839,29 +1852,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .inputs()\n             .iter()\n             .enumerate()\n-            .filter(|(_, ty)| find_param_in_ty(ty, param_to_point_at))\n+            .filter(|(_, ty)| find_param_in_ty(**ty, param_to_point_at))\n             .collect();\n \n-        if let [(idx, _)] = args_referencing_param.as_slice()\n-            && let Some(arg) = args.get(*idx)\n-        {\n-            error.obligation.cause.span = arg.span;\n+        // If there's one field that references the given generic, great!\n+        if let [(idx, _)] = args_referencing_param.as_slice() && let Some(arg) = args.get(*idx) {\n+            error.obligation.cause.span = arg.span.find_ancestor_in_same_ctxt(error.obligation.cause.span).unwrap_or(arg.span);\n             error.obligation.cause.map_code(|parent_code| {\n                 ObligationCauseCode::FunctionArgumentObligation {\n                     arg_hir_id: arg.hir_id,\n                     call_hir_id,\n                     parent_code,\n                 }\n             });\n-            true\n+            return true;\n         } else if args_referencing_param.len() > 0 {\n-            // If more than one argument applies, then point to the callee\n+            // If more than one argument applies, then point to the callee span at least...\n             // We have chance to fix this up further in `point_at_generics_if_possible`\n             error.obligation.cause.span = callee_span;\n-            false\n-        } else {\n-            false\n         }\n+\n+        false\n     }\n \n     fn point_at_field_if_possible(\n@@ -1873,30 +1884,60 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr_fields: &[hir::ExprField<'tcx>],\n     ) -> bool {\n         let def = self.tcx.adt_def(def_id);\n+\n         let identity_substs = ty::InternalSubsts::identity_for_item(self.tcx, def_id);\n         let fields_referencing_param: Vec<_> = def\n             .variant_with_id(variant_def_id)\n             .fields\n             .iter()\n             .filter(|field| {\n                 let field_ty = field.ty(self.tcx, identity_substs);\n-                match find_param_in_ty(field_ty, param_to_point_at) {\n-                    Ok(value) => value,\n-                    Err(value) => return value,\n-                }\n+                find_param_in_ty(field_ty, param_to_point_at)\n             })\n             .collect();\n+\n         if let [field] = fields_referencing_param.as_slice() {\n             for expr_field in expr_fields {\n+                // Look for the ExprField that matches the field, using the\n+                // same rules that check_expr_struct uses for macro hygiene.\n                 if self.tcx.adjust_ident(expr_field.ident, variant_def_id) == field.ident(self.tcx)\n                 {\n-                    error.obligation.cause.span = expr_field.span;\n+                    error.obligation.cause.span = expr_field\n+                        .span\n+                        .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n+                        .unwrap_or(expr_field.span);\n+                    return true;\n                 }\n             }\n-            true\n-        } else {\n-            false\n         }\n+\n+        false\n+    }\n+\n+    fn point_at_path_if_possible(\n+        &self,\n+        error: &mut traits::FulfillmentError<'tcx>,\n+        def_id: DefId,\n+        param: ty::GenericArg<'tcx>,\n+        qpath: &QPath<'tcx>,\n+    ) -> bool {\n+        match qpath {\n+            hir::QPath::Resolved(_, path) => {\n+                if let Some(segment) = path.segments.last()\n+                    && self.point_at_generic_if_possible(error, def_id, param, segment)\n+                {\n+                    return true;\n+                }\n+            }\n+            hir::QPath::TypeRelative(_, segment) => {\n+                if self.point_at_generic_if_possible(error, def_id, param, segment) {\n+                    return true;\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        false\n     }\n \n     fn point_at_generic_if_possible(\n@@ -1921,7 +1962,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .iter()\n             .filter(|arg| matches!(arg, hir::GenericArg::Type(_)))\n             .nth(index) else { return false; };\n-        error.obligation.cause.span = arg.span();\n+        error.obligation.cause.span = arg\n+            .span()\n+            .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n+            .unwrap_or(arg.span());\n         true\n     }\n \n@@ -1935,11 +1979,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             type BreakTy = ty::GenericArg<'tcx>;\n             fn visit_ty(&mut self, ty: Ty<'tcx>) -> std::ops::ControlFlow<Self::BreakTy> {\n                 if let Some(origin) = self.0.type_var_origin(ty)\n-                    && let TypeVariableOriginKind::TypeParameterDefinition(_, Some(def_id))\n-                        = origin.kind\n+                    && let TypeVariableOriginKind::TypeParameterDefinition(_, Some(def_id)) =\n+                        origin.kind\n                     && let generics = self.0.tcx.generics_of(self.1)\n                     && let Some(index) = generics.param_def_id_to_index(self.0.tcx, def_id)\n-                    && let Some(subst) = ty::InternalSubsts::identity_for_item(self.0.tcx, self.1).get(index as usize)\n+                    && let Some(subst) = ty::InternalSubsts::identity_for_item(self.0.tcx, self.1)\n+                        .get(index as usize)\n                 {\n                     ControlFlow::Break(*subst)\n                 } else {\n@@ -2015,14 +2060,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let new_def_id = self.probe(|_| {\n                         let trait_ref = ty::TraitRef::new(\n                             call_kind.to_def_id(self.tcx),\n-                            self.tcx.mk_substs([\n-                                ty::GenericArg::from(callee_ty),\n-                                self.next_ty_var(TypeVariableOrigin {\n-                                    kind: TypeVariableOriginKind::MiscVariable,\n-                                    span: rustc_span::DUMMY_SP,\n-                                })\n-                                .into(),\n-                            ].into_iter()),\n+                            self.tcx.mk_substs(\n+                                [\n+                                    ty::GenericArg::from(callee_ty),\n+                                    self.next_ty_var(TypeVariableOrigin {\n+                                        kind: TypeVariableOriginKind::MiscVariable,\n+                                        span: rustc_span::DUMMY_SP,\n+                                    })\n+                                    .into(),\n+                                ]\n+                                .into_iter(),\n+                            ),\n                         );\n                         let obligation = traits::Obligation::new(\n                             traits::ObligationCause::dummy(),\n@@ -2037,7 +2085,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             Ok(Some(traits::ImplSource::UserDefined(impl_source))) => {\n                                 Some(impl_source.impl_def_id)\n                             }\n-                            _ => None\n+                            _ => None,\n                         }\n                     });\n                     if let Some(new_def_id) = new_def_id {\n@@ -2092,22 +2140,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n }\n \n-fn find_param_in_ty(ty: Ty, param_to_point_at: ty::GenericArg) -> bool {\n+fn find_param_in_ty<'tcx>(ty: Ty<'tcx>, param_to_point_at: ty::GenericArg<'tcx>) -> bool {\n     let mut walk = ty.walk();\n     while let Some(arg) = walk.next() {\n         if arg == param_to_point_at {\n-        return true;\n-    } else if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-        && let ty::Projection(..) = ty.kind()\n-    {\n-        // This logic may seem a bit strange, but typically when\n-        // we have a projection type in a function signature, the\n-        // argument that's being passed into that signature is\n-        // not actually constraining that projection's substs in\n-        // a meaningful way. So we skip it, and see improvements\n-        // in some UI tests.\n-        walk.skip_current_subtree();\n-    }\n+            return true;\n+        } else if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+            && let ty::Projection(..) = ty.kind()\n+        {\n+            // This logic may seem a bit strange, but typically when\n+            // we have a projection type in a function signature, the\n+            // argument that's being passed into that signature is\n+            // not actually constraining that projection's substs in\n+            // a meaningful way. So we skip it, and see improvements\n+            // in some UI tests.\n+            walk.skip_current_subtree();\n+        }\n     }\n     false\n }"}, {"sha": "3ed040c3ab35926e91d4d0731b008da25cd2f0e1", "filename": "src/test/ui/fmt/send-sync.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6848ba2665d10380f259addbd9f60d0ab8d3542a/src%2Ftest%2Fui%2Ffmt%2Fsend-sync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6848ba2665d10380f259addbd9f60d0ab8d3542a/src%2Ftest%2Fui%2Ffmt%2Fsend-sync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fsend-sync.stderr?ref=6848ba2665d10380f259addbd9f60d0ab8d3542a", "patch": "@@ -17,7 +17,6 @@ note: required by a bound in `send`\n    |\n LL | fn send<T: Send>(_: T) {}\n    |            ^^^^ required by this bound in `send`\n-   = note: this error originates in the macro `format_args` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: `core::fmt::Opaque` cannot be shared between threads safely\n   --> $DIR/send-sync.rs:9:10\n@@ -38,7 +37,6 @@ note: required by a bound in `sync`\n    |\n LL | fn sync<T: Sync>(_: T) {}\n    |            ^^^^ required by this bound in `sync`\n-   = note: this error originates in the macro `format_args` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "dd72b6515ddca41d5241bfda07632328a14015cb", "filename": "src/test/ui/issues/issue-60218.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6848ba2665d10380f259addbd9f60d0ab8d3542a/src%2Ftest%2Fui%2Fissues%2Fissue-60218.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6848ba2665d10380f259addbd9f60d0ab8d3542a/src%2Ftest%2Fui%2Fissues%2Fissue-60218.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60218.stderr?ref=6848ba2665d10380f259addbd9f60d0ab8d3542a", "patch": "@@ -14,7 +14,6 @@ LL | pub fn trigger_error<I, F>(iterable: I, functor: F)\n ...\n LL | for<'t> <Map<<&'t I as IntoIterator>::IntoIter, F> as Iterator>::Item: Foo,\n    |                                                                        ^^^ required by this bound in `trigger_error`\n-   = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "6dc039fc35db7c3294c82b065ec17706d83dfc81", "filename": "src/test/ui/never_type/feature-gate-never_type_fallback.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6848ba2665d10380f259addbd9f60d0ab8d3542a/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6848ba2665d10380f259addbd9f60d0ab8d3542a/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr?ref=6848ba2665d10380f259addbd9f60d0ab8d3542a", "patch": "@@ -13,7 +13,6 @@ note: required by a bound in `foo`\n    |\n LL | fn foo(_: impl T) {}\n    |                ^ required by this bound in `foo`\n-   = note: this error originates in the macro `$crate::panic::panic_2015` which comes from the expansion of the macro `panic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}]}