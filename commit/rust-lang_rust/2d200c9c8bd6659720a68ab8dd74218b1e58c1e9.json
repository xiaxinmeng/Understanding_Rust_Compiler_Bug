{"sha": "2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkMjAwYzljOGJkNjY1OTcyMGE2OGFiOGRkNzQyMThiMWU1OGMxZTk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-23T18:59:17Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-24T23:27:42Z"}, "message": "std: Move std::env to the new I/O APIs\n\nThis commit moves `std::env` away from the `std::old_io` error type as well as\nthe `std::old_path` module. Methods returning an error now return `io::Error`\nand methods consuming or returning paths use `std::path` instead of\n`std::old_path`. This commit does not yet mark these APIs as `#[stable]`.\n\nThis commit also migrates `std::old_io::TempDir` to `std::fs::TempDir` with\nessentially the exact same API. This type was added to interoperate with the new\npath API and has its own `tempdir` feature.\n\nFinally, this commit reverts the deprecation of `std::os` APIs returning the old\npath API types. This deprecation can come back once the entire `std::old_path`\nmodule is deprecated.\n\n[breaking-change]", "tree": {"sha": "3dec2aac34e92d6c04d02c3897d0fb70dc21a6e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3dec2aac34e92d6c04d02c3897d0fb70dc21a6e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "html_url": "https://github.com/rust-lang/rust/commit/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0f7ca27de6b4e03f30012656dad270cda55a363", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0f7ca27de6b4e03f30012656dad270cda55a363", "html_url": "https://github.com/rust-lang/rust/commit/f0f7ca27de6b4e03f30012656dad270cda55a363"}], "stats": {"total": 464, "additions": 323, "deletions": 141}, "files": [{"sha": "26cb4f917c5669d5114364f506625fc1476043bc", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -40,6 +40,7 @@\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]\n+#![feature(os)]\n #![cfg_attr(test, feature(test))]\n \n extern crate arena;"}, {"sha": "a8d39f95739326174f2f3714ef3085173ffcbfa4", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -14,6 +14,7 @@ pub use self::FileMatch::*;\n \n use std::collections::HashSet;\n use std::env;\n+use std::os;\n use std::old_io::fs::PathExtensions;\n use std::old_io::fs;\n \n@@ -194,7 +195,7 @@ pub fn get_or_default_sysroot() -> Path {\n             })\n     }\n \n-    match canonicalize(env::current_exe().ok()) {\n+    match canonicalize(os::self_exe_name()) {\n         Some(mut p) => { p.pop(); p.pop(); p }\n         None => panic!(\"can't determine value for sysroot\")\n     }\n@@ -224,7 +225,7 @@ pub fn rust_path() -> Vec<Path> {\n         }\n         None => Vec::new()\n     };\n-    let mut cwd = env::current_dir().unwrap();\n+    let mut cwd = os::getcwd().unwrap();\n     // now add in default entries\n     let cwd_dot_rust = cwd.join(\".rust\");\n     if !env_rust_path.contains(&cwd_dot_rust) {\n@@ -243,7 +244,7 @@ pub fn rust_path() -> Vec<Path> {\n         }\n         cwd.pop();\n     }\n-    if let Some(h) = env::home_dir() {\n+    if let Some(h) = os::homedir() {\n         let p = h.join(\".rust\");\n         if !env_rust_path.contains(&p) && p.exists() {\n             env_rust_path.push(p);"}, {"sha": "a419d4134b40e4677faba9b0355848ccc5e1b98a", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -15,7 +15,7 @@ use metadata::creader::CrateReader;\n use plugin::registry::Registry;\n \n use std::mem;\n-use std::env;\n+use std::os;\n use std::dynamic_lib::DynamicLibrary;\n use std::borrow::ToOwned;\n use syntax::ast;\n@@ -103,7 +103,7 @@ impl<'a> PluginLoader<'a> {\n                         path: Path,\n                         symbol: String) -> PluginRegistrarFun {\n         // Make sure the path contains a / or the linker will search for it.\n-        let path = env::current_dir().unwrap().join(&path);\n+        let path = os::getcwd().unwrap().join(&path);\n \n         let lib = match DynamicLibrary::open(Some(&path)) {\n             Ok(lib) => lib,"}, {"sha": "615ee77c1e0958209389330c1b6c2df11c8b7917", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -27,8 +27,8 @@ use syntax::{ast, codemap};\n \n use rustc_back::target::Target;\n \n-use std::env;\n use std::cell::{Cell, RefCell};\n+use std::os;\n \n pub mod config;\n pub mod search_paths;\n@@ -347,7 +347,7 @@ pub fn build_session_(sopts: config::Options,\n         if path.is_absolute() {\n             path.clone()\n         } else {\n-            env::current_dir().unwrap().join(&path)\n+            os::getcwd().unwrap().join(&path)\n         }\n     );\n \n@@ -370,7 +370,7 @@ pub fn build_session_(sopts: config::Options,\n         plugin_registrar_fn: Cell::new(None),\n         default_sysroot: default_sysroot,\n         local_crate_source_file: local_crate_source_file,\n-        working_dir: env::current_dir().unwrap(),\n+        working_dir: os::getcwd().unwrap(),\n         lint_store: RefCell::new(lint::LintStore::new()),\n         lints: RefCell::new(NodeMap()),\n         crate_types: RefCell::new(Vec::new()),"}, {"sha": "3fcae6a8034c207ac3408c2beb3ea76bdf2f97cb", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -14,7 +14,7 @@ use std::old_io::fs::PathExtensions;\n use std::old_io::process::{Command, ProcessOutput};\n use std::old_io::{fs, TempDir};\n use std::old_io;\n-use std::env;\n+use std::os;\n use std::str;\n use syntax::diagnostic::Handler as ErrorHandler;\n \n@@ -224,7 +224,7 @@ impl<'a> ArchiveBuilder<'a> {\n     pub fn build(self) -> Archive<'a> {\n         // Get an absolute path to the destination, so `ar` will work even\n         // though we run it from `self.work_dir`.\n-        let abs_dst = env::current_dir().unwrap().join(&self.archive.dst);\n+        let abs_dst = os::getcwd().unwrap().join(&self.archive.dst);\n         assert!(!abs_dst.is_relative());\n         let mut args = vec![&abs_dst];\n         let mut total_len = abs_dst.as_vec().len();\n@@ -283,7 +283,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // First, extract the contents of the archive to a temporary directory.\n         // We don't unpack directly into `self.work_dir` due to the possibility\n         // of filename collisions.\n-        let archive = env::current_dir().unwrap().join(archive);\n+        let archive = os::getcwd().unwrap().join(archive);\n         run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n                \"x\", Some(loc.path()), &[&archive]);\n "}, {"sha": "99a1df95a80cddf398549aa2226f3d48fb2be119", "filename": "src/librustc_back/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -10,13 +10,13 @@\n \n use std::old_io;\n use std::old_io::fs;\n-use std::env;\n+use std::os;\n \n /// Returns an absolute path in the filesystem that `path` points to. The\n /// returned path does not contain any symlinks in its hierarchy.\n pub fn realpath(original: &Path) -> old_io::IoResult<Path> {\n     static MAX_LINKS_FOLLOWED: uint = 256;\n-    let original = try!(env::current_dir()).join(original);\n+    let original = try!(os::getcwd()).join(original);\n \n     // Right now lstat on windows doesn't work quite well\n     if cfg!(windows) {"}, {"sha": "711f937d2f355991e5cc6ac1f97b6d47ffb93734", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -41,6 +41,7 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(env)]\n+#![feature(path)]\n \n extern crate syntax;\n extern crate serialize;"}, {"sha": "943ff52925a244545de15c4856f252db57bf7991", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use std::collections::HashSet;\n use std::env;\n use std::old_io::IoError;\n+use std::os;\n use syntax::ast;\n \n pub struct RPathConfig<F, G> where\n@@ -109,7 +109,7 @@ fn get_rpath_relative_to_output<F, G>(config: &mut RPathConfig<F, G>, lib: &Path\n         \"$ORIGIN\"\n     };\n \n-    let cwd = env::current_dir().unwrap();\n+    let cwd = os::getcwd().unwrap();\n     let mut lib = (config.realpath)(&cwd.join(lib)).unwrap();\n     lib.pop();\n     let mut output = (config.realpath)(&cwd.join(&config.out_filename)).unwrap();\n@@ -129,7 +129,7 @@ fn get_install_prefix_rpath<F, G>(config: RPathConfig<F, G>) -> String where\n     let path = (config.get_install_prefix_lib_path)();\n     let path = env::current_dir().unwrap().join(&path);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    path.as_str().expect(\"non-utf8 component in rpath\").to_string()\n+    path.to_str().expect(\"non-utf8 component in rpath\").to_string()\n }\n \n fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {"}, {"sha": "d09a7c355d3e3c32ef00aa2d1f819f1d9d39ff26", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -310,6 +310,7 @@ impl Target {\n     /// JSON decoding.\n     pub fn search(target: &str) -> Result<Target, String> {\n         use std::env;\n+        use std::os;\n         use std::ffi::OsString;\n         use std::old_io::File;\n         use std::old_path::Path;\n@@ -396,7 +397,7 @@ impl Target {\n \n         // FIXME 16351: add a sane default search path?\n \n-        for dir in env::split_paths(&target_path) {\n+        for dir in os::split_paths(target_path.to_str().unwrap()).iter() {\n             let p =  dir.join(path.clone());\n             if p.is_file() {\n                 return load_file(&p);"}, {"sha": "a1a0e71f3343f74d9c8535eee4eb7d3e550ea79a", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -32,6 +32,7 @@ use super::Compilation;\n use serialize::json;\n \n use std::env;\n+use std::os;\n use std::ffi::OsString;\n use std::old_io::fs;\n use std::old_io;\n@@ -471,7 +472,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             if cfg!(windows) {\n                 _old_path = env::var_os(\"PATH\").unwrap_or(_old_path);\n                 let mut new_path = sess.host_filesearch(PathKind::All).get_dylib_search_paths();\n-                new_path.extend(env::split_paths(&_old_path));\n+                new_path.extend(os::split_paths(_old_path.to_str().unwrap()).into_iter());\n                 env::set_var(\"PATH\", &env::join_paths(new_path.iter()).unwrap());\n             }\n             let features = sess.features.borrow();\n@@ -738,7 +739,7 @@ pub fn phase_6_link_output(sess: &Session,\n                            outputs: &OutputFilenames) {\n     let old_path = env::var_os(\"PATH\").unwrap_or(OsString::from_str(\"\"));\n     let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths();\n-    new_path.extend(env::split_paths(&old_path));\n+    new_path.extend(os::split_paths(old_path.to_str().unwrap()).into_iter());\n     env::set_var(\"PATH\", &env::join_paths(new_path.iter()).unwrap());\n \n     time(sess.time_passes(), \"linking\", (), |_|"}, {"sha": "78f126dcf6a827d438057e6cd074c2a7a47e853e", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -13,7 +13,7 @@ use std::sync::mpsc::channel;\n use std::dynamic_lib::DynamicLibrary;\n use std::old_io::{Command, TempDir};\n use std::old_io;\n-use std::env;\n+use std::os;\n use std::str;\n use std::thread;\n use std::thunk::Thunk;\n@@ -46,7 +46,7 @@ pub fn run(input: &str,\n     let input = config::Input::File(input_path.clone());\n \n     let sessopts = config::Options {\n-        maybe_sysroot: Some(env::current_exe().unwrap().dir_path().dir_path()),\n+        maybe_sysroot: Some(os::self_exe_name().unwrap().dir_path().dir_path()),\n         search_paths: libs.clone(),\n         crate_types: vec!(config::CrateTypeDylib),\n         externs: externs.clone(),\n@@ -113,7 +113,7 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     let input = config::Input::Str(test.to_string());\n \n     let sessopts = config::Options {\n-        maybe_sysroot: Some(env::current_exe().unwrap().dir_path().dir_path()),\n+        maybe_sysroot: Some(os::self_exe_name().unwrap().dir_path().dir_path()),\n         search_paths: libs,\n         crate_types: vec!(config::CrateTypeExecutable),\n         output_types: vec!(config::OutputTypeExe),"}, {"sha": "babae3b3019ec18c33d01b2749c4395d4ae7bd13", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -21,6 +21,7 @@ use ffi::CString;\n use mem;\n use env;\n use str;\n+use os;\n \n pub struct DynamicLibrary {\n     handle: *mut u8\n@@ -102,7 +103,7 @@ impl DynamicLibrary {\n     /// process\n     pub fn search_path() -> Vec<Path> {\n         match env::var_os(DynamicLibrary::envvar()) {\n-            Some(var) => env::split_paths(&var).collect(),\n+            Some(var) => os::split_paths(var.to_str().unwrap()),\n             None => Vec::new(),\n         }\n     }"}, {"sha": "5db9f6ef7fdd4dd998f9d8eb2f5b1101a6786a38", "filename": "src/libstd/env.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -21,7 +21,8 @@ use prelude::v1::*;\n use error::Error;\n use ffi::{OsString, AsOsStr};\n use fmt;\n-use old_io::IoResult;\n+use io;\n+use path::{AsPath, PathBuf};\n use sync::atomic::{AtomicIsize, ATOMIC_ISIZE_INIT, Ordering};\n use sync::{StaticMutex, MUTEX_INIT};\n use sys::os as os_imp;\n@@ -46,7 +47,7 @@ use sys::os as os_imp;\n /// let p = env::current_dir().unwrap();\n /// println!(\"The current directory is {}\", p.display());\n /// ```\n-pub fn current_dir() -> IoResult<Path> {\n+pub fn current_dir() -> io::Result<PathBuf> {\n     os_imp::getcwd()\n }\n \n@@ -57,14 +58,14 @@ pub fn current_dir() -> IoResult<Path> {\n ///\n /// ```rust\n /// use std::env;\n-/// use std::old_path::Path;\n+/// use std::path::Path;\n ///\n /// let root = Path::new(\"/\");\n /// assert!(env::set_current_dir(&root).is_ok());\n /// println!(\"Successfully changed working directory to {}!\", root.display());\n /// ```\n-pub fn set_current_dir(p: &Path) -> IoResult<()> {\n-    os_imp::chdir(p)\n+pub fn set_current_dir<P: AsPath + ?Sized>(p: &P) -> io::Result<()> {\n+    os_imp::chdir(p.as_path())\n }\n \n static ENV_LOCK: StaticMutex = MUTEX_INIT;\n@@ -280,8 +281,8 @@ pub fn split_paths<T: AsOsStr + ?Sized>(unparsed: &T) -> SplitPaths {\n }\n \n impl<'a> Iterator for SplitPaths<'a> {\n-    type Item = Path;\n-    fn next(&mut self) -> Option<Path> { self.inner.next() }\n+    type Item = PathBuf;\n+    fn next(&mut self) -> Option<PathBuf> { self.inner.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n@@ -305,10 +306,11 @@ pub struct JoinPathsError {\n ///\n /// ```rust\n /// use std::env;\n+/// use std::path::PathBuf;\n ///\n /// if let Some(path) = env::var_os(\"PATH\") {\n ///     let mut paths = env::split_paths(&path).collect::<Vec<_>>();\n-///     paths.push(Path::new(\"/home/xyz/bin\"));\n+///     paths.push(PathBuf::new(\"/home/xyz/bin\"));\n ///     let new_path = env::join_paths(paths.iter()).unwrap();\n ///     env::set_var(\"PATH\", &new_path);\n /// }\n@@ -355,7 +357,7 @@ impl Error for JoinPathsError {\n ///     None => println!(\"Impossible to get your home dir!\")\n /// }\n /// ```\n-pub fn home_dir() -> Option<Path> {\n+pub fn home_dir() -> Option<PathBuf> {\n     os_imp::home_dir()\n }\n \n@@ -369,7 +371,7 @@ pub fn home_dir() -> Option<Path> {\n /// On Windows, returns the value of, in order, the 'TMP', 'TEMP',\n /// 'USERPROFILE' environment variable  if any are set and not the empty\n /// string. Otherwise, tmpdir returns the path to the Windows directory.\n-pub fn temp_dir() -> Path {\n+pub fn temp_dir() -> PathBuf {\n     os_imp::temp_dir()\n }\n \n@@ -396,7 +398,7 @@ pub fn temp_dir() -> Path {\n ///     Err(e) => println!(\"failed to get current exe path: {}\", e),\n /// };\n /// ```\n-pub fn current_exe() -> IoResult<Path> {\n+pub fn current_exe() -> io::Result<PathBuf> {\n     os_imp::current_exe()\n }\n \n@@ -825,6 +827,7 @@ mod tests {\n     use iter::repeat;\n     use rand::{self, Rng};\n     use ffi::{OsString, OsStr};\n+    use path::PathBuf;\n \n     fn make_rand_name() -> OsString {\n         let mut rng = rand::thread_rng();\n@@ -944,7 +947,7 @@ mod tests {\n     fn split_paths_unix() {\n         fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n             split_paths(unparsed).collect::<Vec<_>>() ==\n-                parsed.iter().map(|s| Path::new(*s)).collect::<Vec<_>>()\n+                parsed.iter().map(|s| PathBuf::new(*s)).collect::<Vec<_>>()\n         }\n \n         assert!(check_parse(\"\", &mut [\"\"]));"}, {"sha": "aa2117586216a53f178d6894aeace34054ef91ad", "filename": "src/libstd/fs/mod.rs", "status": "renamed", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Ffs%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Ffs%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs%2Fmod.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -25,6 +25,10 @@ use sys::fs2 as fs_imp;\n use sys_common::{AsInnerMut, FromInner, AsInner};\n use vec::Vec;\n \n+pub use self::tempdir::TempDir;\n+\n+mod tempdir;\n+\n /// A reference to an open file on the filesystem.\n ///\n /// An instance of a `File` can be read and/or written depending on what options", "previous_filename": "src/libstd/fs.rs"}, {"sha": "79bdb35dd48cd3b6ebc1e3f9b5d5d6004be241c0", "filename": "src/libstd/fs/tempdir.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Ffs%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Ffs%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs%2Ftempdir.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -0,0 +1,125 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"tempdir\", reason = \"needs an RFC before stabilization\")]\n+\n+use prelude::v1::*;\n+\n+use env;\n+use io::{self, Error, ErrorKind};\n+use fs;\n+use path::{self, PathBuf, AsPath};\n+use rand::{thread_rng, Rng};\n+\n+/// A wrapper for a path to temporary directory implementing automatic\n+/// scope-based deletion.\n+pub struct TempDir {\n+    path: Option<PathBuf>,\n+}\n+\n+// How many times should we (re)try finding an unused random name? It should be\n+// enough that an attacker will run out of luck before we run out of patience.\n+const NUM_RETRIES: u32 = 1 << 31;\n+// How many characters should we include in a random file name? It needs to\n+// be enough to dissuade an attacker from trying to preemptively create names\n+// of that length, but not so huge that we unnecessarily drain the random number\n+// generator of entropy.\n+const NUM_RAND_CHARS: uint = 12;\n+\n+impl TempDir {\n+    /// Attempts to make a temporary directory inside of `tmpdir` whose name\n+    /// will have the prefix `prefix`. The directory will be automatically\n+    /// deleted once the returned wrapper is destroyed.\n+    ///\n+    /// If no directory can be created, `Err` is returned.\n+    #[allow(deprecated)] // rand usage\n+    pub fn new_in<P: AsPath + ?Sized>(tmpdir: &P, prefix: &str)\n+                                      -> io::Result<TempDir> {\n+        let storage;\n+        let mut tmpdir = tmpdir.as_path();\n+        if !tmpdir.is_absolute() {\n+            let cur_dir = try!(env::current_dir());\n+            storage = cur_dir.join(tmpdir);\n+            tmpdir = &storage;\n+            // return TempDir::new_in(&cur_dir.join(tmpdir), prefix);\n+        }\n+\n+        let mut rng = thread_rng();\n+        for _ in 0..NUM_RETRIES {\n+            let suffix: String = rng.gen_ascii_chars().take(NUM_RAND_CHARS).collect();\n+            let leaf = if prefix.len() > 0 {\n+                format!(\"{}.{}\", prefix, suffix)\n+            } else {\n+                // If we're given an empty string for a prefix, then creating a\n+                // directory starting with \".\" would lead to it being\n+                // semi-invisible on some systems.\n+                suffix\n+            };\n+            let path = tmpdir.join(&leaf);\n+            match fs::create_dir(&path) {\n+                Ok(_) => return Ok(TempDir { path: Some(path) }),\n+                Err(ref e) if e.kind() == ErrorKind::PathAlreadyExists => {}\n+                Err(e) => return Err(e)\n+            }\n+        }\n+\n+        Err(Error::new(ErrorKind::PathAlreadyExists,\n+                       \"too many temporary directories already exist\",\n+                       None))\n+    }\n+\n+    /// Attempts to make a temporary directory inside of `env::temp_dir()` whose\n+    /// name will have the prefix `prefix`. The directory will be automatically\n+    /// deleted once the returned wrapper is destroyed.\n+    ///\n+    /// If no directory can be created, `Err` is returned.\n+    #[allow(deprecated)]\n+    pub fn new(prefix: &str) -> io::Result<TempDir> {\n+        TempDir::new_in(&env::temp_dir(), prefix)\n+    }\n+\n+    /// Unwrap the wrapped `std::path::Path` from the `TempDir` wrapper.\n+    /// This discards the wrapper so that the automatic deletion of the\n+    /// temporary directory is prevented.\n+    pub fn into_path(mut self) -> PathBuf {\n+        self.path.take().unwrap()\n+    }\n+\n+    /// Access the wrapped `std::path::Path` to the temporary directory.\n+    pub fn path(&self) -> &path::Path {\n+        self.path.as_ref().unwrap()\n+    }\n+\n+    /// Close and remove the temporary directory\n+    ///\n+    /// Although `TempDir` removes the directory on drop, in the destructor\n+    /// any errors are ignored. To detect errors cleaning up the temporary\n+    /// directory, call `close` instead.\n+    pub fn close(mut self) -> io::Result<()> {\n+        self.cleanup_dir()\n+    }\n+\n+    fn cleanup_dir(&mut self) -> io::Result<()> {\n+        match self.path {\n+            Some(ref p) => fs::remove_dir_all(p),\n+            None => Ok(())\n+        }\n+    }\n+}\n+\n+impl Drop for TempDir {\n+    fn drop(&mut self) {\n+        let _ = self.cleanup_dir();\n+    }\n+}\n+\n+// the tests for this module need to change the path using change_dir,\n+// and this doesn't play nicely with other tests so these unit tests are located\n+// in src/test/run-pass/tempfile.rs"}, {"sha": "aec50d638c69f2393c116c1daa55a031107e7b4b", "filename": "src/libstd/net/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fnet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fnet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftest.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -34,6 +34,6 @@ fn base_port() -> u16 {\n     let dirs = [\"32-opt\", \"32-nopt\", \"64-opt\", \"64-nopt\", \"64-opt-vg\",\n                 \"all-opt\", \"snap3\", \"dist\"];\n     dirs.iter().enumerate().find(|&(_, dir)| {\n-        cwd.as_str().unwrap().contains(dir)\n+        cwd.to_str().unwrap().contains(dir)\n     }).map(|p| p.0).unwrap_or(0) as u16 * 1000 + 19600\n }"}, {"sha": "76753dca52e1eec4dfdad70d862723c3b5e88427", "filename": "src/libstd/old_io/tempfile.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fold_io%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fold_io%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftempfile.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -96,9 +96,10 @@ impl TempDir {\n     /// deleted once the returned wrapper is destroyed.\n     ///\n     /// If no directory can be created, `Err` is returned.\n+    #[allow(deprecated)]\n     pub fn new_in(tmpdir: &Path, prefix: &str) -> IoResult<TempDir> {\n         if !tmpdir.is_absolute() {\n-            let cur_dir = try!(env::current_dir());\n+            let cur_dir = try!(::os::getcwd());\n             return TempDir::new_in(&cur_dir.join(tmpdir), prefix);\n         }\n \n@@ -132,8 +133,9 @@ impl TempDir {\n     /// deleted once the returned wrapper is destroyed.\n     ///\n     /// If no directory can be created, `Err` is returned.\n+    #[allow(deprecated)]\n     pub fn new(prefix: &str) -> IoResult<TempDir> {\n-        TempDir::new_in(&env::temp_dir(), prefix)\n+        TempDir::new_in(&::os::tmpdir(), prefix)\n     }\n \n     /// Unwrap the wrapped `std::path::Path` from the `TempDir` wrapper."}, {"sha": "43c0b9268a242d065cc90b9c53c0a71a3207cb9c", "filename": "src/libstd/old_io/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fold_io%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fold_io%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftest.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -38,10 +38,11 @@ fn next_test_unix_socket() -> String {\n \n /// Get a temporary path which could be the location of a unix socket\n #[cfg(not(target_os = \"ios\"))]\n+#[allow(deprecated)]\n pub fn next_test_unix() -> Path {\n     let string = next_test_unix_socket();\n     if cfg!(unix) {\n-        env::temp_dir().join(string)\n+        ::os::tmpdir().join(string)\n     } else {\n         Path::new(format!(\"{}{}\", r\"\\\\.\\pipe\\\", string))\n     }\n@@ -88,7 +89,7 @@ fn base_port() -> u16 {\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let path = env::current_dir().unwrap();\n-    let path_s = path.as_str().unwrap();\n+    let path_s = path.to_str().unwrap();\n \n     let mut final_base = base;\n "}, {"sha": "9c42d1be77ee1c009ead6a37df39ebbaeda03878", "filename": "src/libstd/os.rs", "status": "modified", "additions": 39, "deletions": 16, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -49,6 +49,7 @@ use ops::{Drop, FnOnce};\n use option::Option::{Some, None};\n use option::Option;\n use old_path::{Path, GenericPath, BytesContainer};\n+use path::{self, PathBuf};\n use ptr::PtrExt;\n use ptr;\n use result::Result::{Err, Ok};\n@@ -67,6 +68,35 @@ use vec::Vec;\n #[cfg(unix)] pub use sys::ext as unix;\n #[cfg(windows)] pub use sys::ext as windows;\n \n+fn err2old(new: ::io::Error) -> IoError {\n+    IoError {\n+        kind: ::old_io::OtherIoError,\n+        desc: \"os error\",\n+        detail: Some(new.to_string()),\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn path2new(path: &Path) -> PathBuf {\n+    PathBuf::new(path.as_str().unwrap())\n+}\n+#[cfg(unix)]\n+fn path2new(path: &Path) -> PathBuf {\n+    use os::unix::prelude::*;\n+    PathBuf::new(<OsStr as OsStrExt>::from_bytes(path.as_vec()))\n+}\n+\n+#[cfg(unix)]\n+fn path2old(path: &path::Path) -> Path {\n+    use os::unix::prelude::*;\n+    use ffi::AsOsStr;\n+    Path::new(path.as_os_str().as_bytes())\n+}\n+#[cfg(windows)]\n+fn path2old(path: &path::Path) -> Path {\n+    Path::new(path.to_str().unwrap())\n+}\n+\n /// Get the number of cores available\n pub fn num_cpus() -> uint {\n     unsafe {\n@@ -100,10 +130,9 @@ pub const TMPBUF_SZ : uint = 1000;\n /// let current_working_directory = os::getcwd().unwrap();\n /// println!(\"The current directory is {:?}\", current_working_directory.display());\n /// ```\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to std::env::current_dir\")]\n #[unstable(feature = \"os\")]\n pub fn getcwd() -> IoResult<Path> {\n-    env::current_dir()\n+    env::current_dir().map_err(err2old).map(|s| path2old(&s))\n }\n \n /// Returns a vector of (variable, value) pairs, for all the environment\n@@ -245,12 +274,11 @@ pub fn unsetenv(n: &str) {\n ///     None => println!(\"{} is not defined in the environment.\", key)\n /// }\n /// ```\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::split_paths\")]\n #[unstable(feature = \"os\")]\n pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n     let b = unparsed.container_as_bytes();\n     let s = str::from_utf8(b).unwrap();\n-    env::split_paths(s).collect()\n+    env::split_paths(s).map(|s| path2old(&s)).collect()\n }\n \n /// Joins a collection of `Path`s appropriately for the `PATH`\n@@ -274,7 +302,6 @@ pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n /// paths.push(Path::new(\"/home/xyz/bin\"));\n /// os::setenv(key, os::join_paths(paths.as_slice()).unwrap());\n /// ```\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::join_paths\")]\n #[unstable(feature = \"os\")]\n pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n     env::join_paths(paths.iter().map(|s| {\n@@ -335,10 +362,9 @@ pub fn dll_filename(base: &str) -> String {\n ///     None => println!(\"Unable to get the path of this executable!\")\n /// };\n /// ```\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::current_exe\")]\n #[unstable(feature = \"os\")]\n pub fn self_exe_name() -> Option<Path> {\n-    env::current_exe().ok()\n+    env::current_exe().ok().map(|p| path2old(&p))\n }\n \n /// Optionally returns the filesystem path to the current executable which is\n@@ -356,10 +382,9 @@ pub fn self_exe_name() -> Option<Path> {\n ///     None => println!(\"Impossible to fetch the path of this executable.\")\n /// };\n /// ```\n-#[deprecated(since = \"1.0.0\", reason = \"use env::current_exe + dir_path/pop\")]\n #[unstable(feature = \"os\")]\n pub fn self_exe_path() -> Option<Path> {\n-    env::current_exe().ok().map(|mut p| { p.pop(); p })\n+    env::current_exe().ok().map(|p| { let mut p = path2old(&p); p.pop(); p })\n }\n \n /// Optionally returns the path to the current user's home directory if known.\n@@ -386,9 +411,8 @@ pub fn self_exe_path() -> Option<Path> {\n ///     None => println!(\"Impossible to get your home dir!\")\n /// }\n /// ```\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::home_dir\")]\n-#[allow(deprecated)]\n #[unstable(feature = \"os\")]\n+#[allow(deprecated)]\n pub fn homedir() -> Option<Path> {\n     #[inline]\n     #[cfg(unix)]\n@@ -424,9 +448,8 @@ pub fn homedir() -> Option<Path> {\n /// On Windows, returns the value of, in order, the 'TMP', 'TEMP',\n /// 'USERPROFILE' environment variable  if any are set and not the empty\n /// string. Otherwise, tmpdir returns the path to the Windows directory.\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::temp_dir\")]\n-#[allow(deprecated)]\n #[unstable(feature = \"os\")]\n+#[allow(deprecated)]\n pub fn tmpdir() -> Path {\n     return lookup();\n \n@@ -488,7 +511,8 @@ pub fn make_absolute(p: &Path) -> IoResult<Path> {\n     if p.is_absolute() {\n         Ok(p.clone())\n     } else {\n-        env::current_dir().map(|mut cwd| {\n+        env::current_dir().map_err(err2old).map(|cwd| {\n+            let mut cwd = path2old(&cwd);\n             cwd.push(p);\n             cwd\n         })\n@@ -507,10 +531,9 @@ pub fn make_absolute(p: &Path) -> IoResult<Path> {\n /// assert!(os::change_dir(&root).is_ok());\n /// println!(\"Successfully changed working directory to {}!\", root.display());\n /// ```\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::set_current_dir\")]\n #[unstable(feature = \"os\")]\n pub fn change_dir(p: &Path) -> IoResult<()> {\n-    return sys::os::chdir(p);\n+    sys::os::chdir(&path2new(p)).map_err(err2old)\n }\n \n /// Returns the platform-specific value of errno"}, {"sha": "6267792ba745e5ffa82bcca807c959d8ed4dd2a5", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -84,8 +84,9 @@\n /// all unix platforms we support right now, so it at least gets the job done.\n \n use prelude::v1::*;\n+use os::unix::prelude::*;\n \n-use ffi::CStr;\n+use ffi::{CStr, AsOsStr};\n use old_io::IoResult;\n use libc;\n use mem;\n@@ -327,7 +328,7 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n         };\n         let filename = match selfname {\n             Some(path) => {\n-                let bytes = path.as_vec();\n+                let bytes = path.as_os_str().as_bytes();\n                 if bytes.len() < LAST_FILENAME.len() {\n                     let i = bytes.iter();\n                     for (slot, val) in LAST_FILENAME.iter_mut().zip(i) {"}, {"sha": "951c091f9f36c47d32602dd1d7ba20a4db950d2f", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -16,12 +16,13 @@ use os::unix::*;\n use error::Error as StdError;\n use ffi::{CString, CStr, OsString, OsStr, AsOsStr};\n use fmt;\n+use io;\n use iter;\n use libc::{self, c_int, c_char, c_void};\n use mem;\n-use io;\n-use old_io::{IoResult, IoError, fs};\n+use old_io::{IoError, IoResult};\n use ptr;\n+use path::{self, PathBuf};\n use slice;\n use str;\n use sys::c;\n@@ -32,6 +33,14 @@ use vec;\n const BUF_BYTES: usize = 2048;\n const TMPBUF_SZ: usize = 128;\n \n+fn bytes2path(b: &[u8]) -> PathBuf {\n+    PathBuf::new(<OsStr as OsStrExt>::from_bytes(b))\n+}\n+\n+fn os2path(os: OsString) -> PathBuf {\n+    bytes2path(os.as_bytes())\n+}\n+\n /// Returns the platform-specific value of errno\n pub fn errno() -> i32 {\n     #[cfg(any(target_os = \"macos\",\n@@ -102,44 +111,44 @@ pub fn error_string(errno: i32) -> String {\n     }\n }\n \n-pub fn getcwd() -> IoResult<Path> {\n+pub fn getcwd() -> io::Result<PathBuf> {\n     let mut buf = [0 as c_char; BUF_BYTES];\n     unsafe {\n         if libc::getcwd(buf.as_mut_ptr(), buf.len() as libc::size_t).is_null() {\n-            Err(IoError::last_error())\n+            Err(io::Error::last_os_error())\n         } else {\n-            Ok(Path::new(CStr::from_ptr(buf.as_ptr()).to_bytes()))\n+            Ok(bytes2path(CStr::from_ptr(buf.as_ptr()).to_bytes()))\n         }\n     }\n }\n \n-pub fn chdir(p: &Path) -> IoResult<()> {\n-    let p = CString::new(p.as_vec()).unwrap();\n+pub fn chdir(p: &path::Path) -> io::Result<()> {\n+    let p = try!(CString::new(p.as_os_str().as_bytes()));\n     unsafe {\n         match libc::chdir(p.as_ptr()) == (0 as c_int) {\n             true => Ok(()),\n-            false => Err(IoError::last_error()),\n+            false => Err(io::Error::last_os_error()),\n         }\n     }\n }\n \n pub struct SplitPaths<'a> {\n     iter: iter::Map<slice::Split<'a, u8, fn(&u8) -> bool>,\n-                    fn(&'a [u8]) -> Path>,\n+                    fn(&'a [u8]) -> PathBuf>,\n }\n \n pub fn split_paths<'a>(unparsed: &'a OsStr) -> SplitPaths<'a> {\n     fn is_colon(b: &u8) -> bool { *b == b':' }\n     let unparsed = unparsed.as_bytes();\n     SplitPaths {\n         iter: unparsed.split(is_colon as fn(&u8) -> bool)\n-                      .map(Path::new as fn(&'a [u8]) ->  Path)\n+                      .map(bytes2path as fn(&'a [u8]) -> PathBuf)\n     }\n }\n \n impl<'a> Iterator for SplitPaths<'a> {\n-    type Item = Path;\n-    fn next(&mut self) -> Option<Path> { self.iter.next() }\n+    type Item = PathBuf;\n+    fn next(&mut self) -> Option<PathBuf> { self.iter.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n@@ -200,12 +209,12 @@ pub fn current_exe() -> IoResult<Path> {\n }\n \n #[cfg(target_os = \"dragonfly\")]\n-pub fn current_exe() -> IoResult<Path> {\n-    fs::readlink(&Path::new(\"/proc/curproc/file\"))\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    ::fs::read_link(\"/proc/curproc/file\")\n }\n \n #[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n-pub fn current_exe() -> IoResult<Path> {\n+pub fn current_exe() -> io::Result<PathBuf> {\n     use sync::{StaticMutex, MUTEX_INIT};\n     static LOCK: StaticMutex = MUTEX_INIT;\n \n@@ -226,8 +235,8 @@ pub fn current_exe() -> IoResult<Path> {\n }\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-pub fn current_exe() -> IoResult<Path> {\n-    fs::readlink(&Path::new(\"/proc/self/exe\"))\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    ::fs::read_link(\"/proc/self/exe\")\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n@@ -451,22 +460,20 @@ pub fn page_size() -> usize {\n     }\n }\n \n-pub fn temp_dir() -> Path {\n-    getenv(\"TMPDIR\".as_os_str()).map(|p| Path::new(p.into_vec())).unwrap_or_else(|| {\n+pub fn temp_dir() -> PathBuf {\n+    getenv(\"TMPDIR\".as_os_str()).map(os2path).unwrap_or_else(|| {\n         if cfg!(target_os = \"android\") {\n-            Path::new(\"/data/local/tmp\")\n+            PathBuf::new(\"/data/local/tmp\")\n         } else {\n-            Path::new(\"/tmp\")\n+            PathBuf::new(\"/tmp\")\n         }\n     })\n }\n \n-pub fn home_dir() -> Option<Path> {\n+pub fn home_dir() -> Option<PathBuf> {\n     return getenv(\"HOME\".as_os_str()).or_else(|| unsafe {\n         fallback()\n-    }).map(|os| {\n-        Path::new(os.into_vec())\n-    });\n+    }).map(os2path);\n \n     #[cfg(any(target_os = \"android\",\n               target_os = \"ios\"))]"}, {"sha": "309d6c9dc48c26b48c27f4cae8af38e2a11a194c", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -368,7 +368,9 @@ pub fn readlink(p: &Path) -> IoResult<Path> {\n                                   buf as *const u16,\n                                   sz - 1,\n                                   libc::VOLUME_NAME_DOS)\n-    }, super::os2path);\n+    }, |data| {\n+        Path::new(String::from_utf16(data).unwrap())\n+    });\n     assert!(unsafe { libc::CloseHandle(handle) } != 0);\n     return ret;\n }"}, {"sha": "51df18d504dc1664a101bea6b645df7f000f3dc5", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -14,13 +14,14 @@\n \n use prelude::v1::*;\n \n-use ffi::OsStr;\n+use ffi::{OsStr, OsString};\n use io::{self, ErrorKind};\n use libc;\n use mem;\n-use old_io::{self, IoResult, IoError};\n use num::Int;\n-use os::windows::OsStrExt;\n+use old_io::{self, IoResult, IoError};\n+use os::windows::{OsStrExt, OsStringExt};\n+use path::PathBuf;\n use sync::{Once, ONCE_INIT};\n \n macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n@@ -314,9 +315,10 @@ fn fill_utf16_buf_new<F1, F2, T>(f1: F1, f2: F2) -> io::Result<T>\n     fill_utf16_buf_base(f1, f2).map_err(|()| io::Error::last_os_error())\n }\n \n-fn os2path(s: &[u16]) -> Path {\n-    // FIXME: this should not be a panicking conversion (aka path reform)\n-    Path::new(String::from_utf16(s).unwrap())\n+fn os2path(s: &[u16]) -> PathBuf {\n+    let os = <OsString as OsStringExt>::from_wide(s);\n+    // FIXME(#22751) should consume `os`\n+    PathBuf::new(&os)\n }\n \n pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {"}, {"sha": "587ab7924fd1dc541fd7751cb82a61ff077f3362", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -18,11 +18,13 @@ use os::windows::*;\n use error::Error as StdError;\n use ffi::{OsString, OsStr, AsOsStr};\n use fmt;\n-use ops::Range;\n+use io;\n use libc::types::os::arch::extra::LPWCH;\n use libc::{self, c_int, c_void};\n use mem;\n use old_io::{IoError, IoResult};\n+use ops::Range;\n+use path::{self, PathBuf};\n use ptr;\n use slice;\n use sys::c;\n@@ -151,8 +153,8 @@ pub fn split_paths(unparsed: &OsStr) -> SplitPaths {\n }\n \n impl<'a> Iterator for SplitPaths<'a> {\n-    type Item = Path;\n-    fn next(&mut self) -> Option<Path> {\n+    type Item = PathBuf;\n+    fn next(&mut self) -> Option<PathBuf> {\n         // On Windows, the PATH environment variable is semicolon separated.\n         // Double quotes are used as a way of introducing literal semicolons\n         // (since c:\\some;dir is a valid Windows path). Double quotes are not\n@@ -186,7 +188,7 @@ impl<'a> Iterator for SplitPaths<'a> {\n         if !must_yield && in_progress.is_empty() {\n             None\n         } else {\n-            Some(super::os2path(&in_progress[..]))\n+            Some(super::os2path(&in_progress))\n         }\n     }\n }\n@@ -228,33 +230,33 @@ impl StdError for JoinPathsError {\n     fn description(&self) -> &str { \"failed to join paths\" }\n }\n \n-pub fn current_exe() -> IoResult<Path> {\n-    super::fill_utf16_buf(|buf, sz| unsafe {\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    super::fill_utf16_buf_new(|buf, sz| unsafe {\n         libc::GetModuleFileNameW(ptr::null_mut(), buf, sz)\n     }, super::os2path)\n }\n \n-pub fn getcwd() -> IoResult<Path> {\n-    super::fill_utf16_buf(|buf, sz| unsafe {\n+pub fn getcwd() -> io::Result<PathBuf> {\n+    super::fill_utf16_buf_new(|buf, sz| unsafe {\n         libc::GetCurrentDirectoryW(sz, buf)\n     }, super::os2path)\n }\n \n-pub fn chdir(p: &Path) -> IoResult<()> {\n+pub fn chdir(p: &path::Path) -> io::Result<()> {\n     let mut p = p.as_os_str().encode_wide().collect::<Vec<_>>();\n     p.push(0);\n \n     unsafe {\n         match libc::SetCurrentDirectoryW(p.as_ptr()) != (0 as libc::BOOL) {\n             true => Ok(()),\n-            false => Err(IoError::last_error()),\n+            false => Err(io::Error::last_os_error()),\n         }\n     }\n }\n \n pub fn getenv(k: &OsStr) -> Option<OsString> {\n     let k = super::to_utf16_os(k);\n-    super::fill_utf16_buf(|buf, sz| unsafe {\n+    super::fill_utf16_buf_new(|buf, sz| unsafe {\n         libc::GetEnvironmentVariableW(k.as_ptr(), buf, sz)\n     }, |buf| {\n         OsStringExt::from_wide(buf)\n@@ -349,26 +351,26 @@ pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n     }\n }\n \n-pub fn temp_dir() -> Path {\n-    super::fill_utf16_buf(|buf, sz| unsafe {\n+pub fn temp_dir() -> PathBuf {\n+    super::fill_utf16_buf_new(|buf, sz| unsafe {\n         c::GetTempPathW(sz, buf)\n     }, super::os2path).unwrap()\n }\n \n-pub fn home_dir() -> Option<Path> {\n+pub fn home_dir() -> Option<PathBuf> {\n     getenv(\"HOME\".as_os_str()).or_else(|| {\n         getenv(\"USERPROFILE\".as_os_str())\n     }).map(|os| {\n-        // FIXME: OsString => Path\n-        Path::new(os.to_str().unwrap())\n+        // FIXME(#22751) should consume `os`\n+        PathBuf::new(&os)\n     }).or_else(|| unsafe {\n         let me = c::GetCurrentProcess();\n         let mut token = ptr::null_mut();\n         if c::OpenProcessToken(me, c::TOKEN_READ, &mut token) == 0 {\n             return None\n         }\n         let _handle = RawHandle::new(token);\n-        super::fill_utf16_buf(|buf, mut sz| {\n+        super::fill_utf16_buf_new(|buf, mut sz| {\n             match c::GetUserProfileDirectoryW(token, buf, &mut sz) {\n                 0 if libc::GetLastError() != 0 => 0,\n                 0 => sz,"}, {"sha": "d4c6e85489f5d25d87f82e01791834869ba96fea", "filename": "src/libstd/sys/windows/process2.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -16,16 +16,15 @@ use collections;\n use env;\n use ffi::{OsString, OsStr};\n use fmt;\n+use fs;\n use io::{self, Error};\n use libc::{self, c_void};\n-use old_io::fs;\n-use old_path;\n use os::windows::OsStrExt;\n use ptr;\n use sync::{StaticMutex, MUTEX_INIT};\n+use sys::handle::Handle;\n use sys::pipe2::AnonPipe;\n use sys::{self, cvt};\n-use sys::handle::Handle;\n use sys_common::{AsInner, FromInner};\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -142,9 +141,8 @@ impl Process {\n                 for path in split_paths(&v) {\n                     let path = path.join(cfg.program.to_str().unwrap())\n                                    .with_extension(env::consts::EXE_EXTENSION);\n-                    // FIXME: update with new fs module once it lands\n-                    if fs::stat(&old_path::Path::new(&path)).is_ok() {\n-                        return Some(OsString::from_str(path.as_str().unwrap()))\n+                    if fs::metadata(&path).is_ok() {\n+                        return Some(path.into_os_string())\n                     }\n                 }\n                 break"}, {"sha": "823d2879236d1a9d961a60f5c9a8a646968fb7a0", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -60,6 +60,7 @@\n #![feature(unicode)]\n #![feature(std_misc)]\n #![feature(env)]\n+#![feature(os)]\n #![cfg_attr(windows, feature(libc))]\n \n #[macro_use] extern crate log;"}, {"sha": "a0cd78420700187e78aa2ef451e5ff81f0bf2a3a", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -17,12 +17,13 @@ use std::old_io::fs::PathExtensions;\n use std::env;\n \n /// Return path to database entry for `term`\n+#[allow(deprecated)]\n pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n     if term.len() == 0 {\n         return None;\n     }\n \n-    let homedir = env::home_dir();\n+    let homedir = ::std::os::homedir();\n \n     let mut dirs_to_search = Vec::new();\n     let first_char = term.char_at(0);"}, {"sha": "2ab6feaf782f34d85f6529feb407488b32b19439", "filename": "src/test/run-pass/env-home-dir.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Ftest%2Frun-pass%2Fenv-home-dir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Ftest%2Frun-pass%2Fenv-home-dir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenv-home-dir.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -9,13 +9,14 @@\n // except according to those terms.\n \n use std::env::*;\n+use std::path::PathBuf;\n \n #[cfg(unix)]\n fn main() {\n     let oldhome = var(\"HOME\");\n \n     set_var(\"HOME\", \"/home/MountainView\");\n-    assert!(home_dir() == Some(Path::new(\"/home/MountainView\")));\n+    assert!(home_dir() == Some(PathBuf::new(\"/home/MountainView\")));\n \n     remove_var(\"HOME\");\n     if cfg!(target_os = \"android\") {"}, {"sha": "d995ecc492e3477f65d3ac466c4d30e8e00d100c", "filename": "src/test/run-pass/issue-15149.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15149.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -1,5 +1,3 @@\n-// no-prefer-dynamic\n-\n // Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -10,12 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::slice::SliceExt;\n-use std::old_io::{fs, USER_RWX};\n-use std::process;\n+// no-prefer-dynamic\n+\n+#![feature(fs, process, env, path, rand)]\n+\n use std::env;\n-use std::old_path::BytesContainer;\n+use std::fs;\n+use std::process;\n use std::rand::random;\n+use std::str;\n \n fn main() {\n     // If we're the child, make sure we were invoked correctly\n@@ -34,21 +35,20 @@ fn main() {\n fn test() {\n     // If we're the parent, copy our own binary to a new directory.\n     let my_path = env::current_exe().unwrap();\n-    let my_dir  = my_path.dir_path();\n+    let my_dir  = my_path.parent().unwrap();\n \n     let random_u32: u32 = random();\n-    let child_dir = Path::new(my_dir.join(format!(\"issue-15149-child-{}\",\n-                                                  random_u32)));\n-    fs::mkdir(&child_dir, USER_RWX).unwrap();\n+    let child_dir = my_dir.join(&format!(\"issue-15149-child-{}\", random_u32));\n+    fs::create_dir(&child_dir).unwrap();\n \n-    let child_path = child_dir.join(format!(\"mytest{}\",\n-                                            env::consts::EXE_SUFFIX));\n+    let child_path = child_dir.join(&format!(\"mytest{}\",\n+                                             env::consts::EXE_SUFFIX));\n     fs::copy(&my_path, &child_path).unwrap();\n \n     // Append the new directory to our own PATH.\n     let path = {\n         let mut paths: Vec<_> = env::split_paths(&env::var_os(\"PATH\").unwrap()).collect();\n-        paths.push(child_dir.clone());\n+        paths.push(child_dir.to_path_buf());\n         env::join_paths(paths.iter()).unwrap()\n     };\n \n@@ -58,9 +58,9 @@ fn test() {\n \n     assert!(child_output.status.success(),\n             format!(\"child assertion failed\\n child stdout:\\n {}\\n child stderr:\\n {}\",\n-                    child_output.stdout.container_as_str().unwrap(),\n-                    child_output.stderr.container_as_str().unwrap()));\n+                    str::from_utf8(&child_output.stdout).unwrap(),\n+                    str::from_utf8(&child_output.stderr).unwrap()));\n \n-    fs::rmdir_recursive(&child_dir).unwrap();\n+    fs::remove_dir_all(&child_dir).unwrap();\n \n }"}, {"sha": "92d8dfa2cf9a975bc306078ebdfeebe5267c1f63", "filename": "src/test/run-pass/issue-16272.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Ftest%2Frun-pass%2Fissue-16272.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Ftest%2Frun-pass%2Fissue-16272.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16272.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::old_io::{process, Command};\n+use std::process::Command;\n use std::env;\n \n fn main() {\n@@ -22,10 +22,8 @@ fn main() {\n }\n \n fn test() {\n-    let status = Command::new(env::current_exe().unwrap())\n+    let status = Command::new(&env::current_exe().unwrap())\n                          .arg(\"foo\").arg(\"\")\n-                         .stdout(process::InheritFd(1))\n-                         .stderr(process::InheritFd(2))\n                          .status().unwrap();\n     assert!(status.success());\n }"}, {"sha": "ba107dd2cf9a2457b8b41db94e66834b9b56847f", "filename": "src/test/run-pass/issue-20091.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Ftest%2Frun-pass%2Fissue-20091.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d200c9c8bd6659720a68ab8dd74218b1e58c1e9/src%2Ftest%2Frun-pass%2Fissue-20091.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20091.rs?ref=2d200c9c8bd6659720a68ab8dd74218b1e58c1e9", "patch": "@@ -8,14 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-windows currently windows requires UTF-8 for spawning processes\n-\n-use std::old_io::Command;\n-use std::env;\n-\n+#[cfg(unix)]\n fn main() {\n+    use std::process::Command;\n+    use std::env;\n+    use std::os::unix::prelude::*;\n+    use std::ffi::OsStr;\n+\n     if env::args().len() == 1 {\n-        assert!(Command::new(env::current_exe().unwrap()).arg(b\"\\xff\")\n+        assert!(Command::new(&env::current_exe().unwrap())\n+                        .arg(<OsStr as OsStrExt>::from_bytes(b\"\\xff\"))\n                         .status().unwrap().success())\n     }\n }\n+\n+#[cfg(windows)]\n+fn main() {}"}]}