{"sha": "e5a0dd7c6e906ba736c9cf26d5db55cf9787c61f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1YTBkZDdjNmU5MDZiYTczNmM5Y2YyNmQ1ZGI1NWNmOTc4N2M2MWY=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-02T23:26:18Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-09T02:31:06Z"}, "message": "Resolve paths generated in the ast->hir lowerer", "tree": {"sha": "56936f3da24e184bf173ba02acfd26fa19d777eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56936f3da24e184bf173ba02acfd26fa19d777eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5a0dd7c6e906ba736c9cf26d5db55cf9787c61f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5a0dd7c6e906ba736c9cf26d5db55cf9787c61f", "html_url": "https://github.com/rust-lang/rust/commit/e5a0dd7c6e906ba736c9cf26d5db55cf9787c61f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5a0dd7c6e906ba736c9cf26d5db55cf9787c61f/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "983b4d3925a498cf6af96a0443f2235e69f761e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/983b4d3925a498cf6af96a0443f2235e69f761e5", "html_url": "https://github.com/rust-lang/rust/commit/983b4d3925a498cf6af96a0443f2235e69f761e5"}], "stats": {"total": 220, "additions": 144, "deletions": 76}, "files": [{"sha": "f10760f89f767d45f623af5dcb39cfadbc585a34", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 82, "deletions": 48, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/e5a0dd7c6e906ba736c9cf26d5db55cf9787c61f/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a0dd7c6e906ba736c9cf26d5db55cf9787c61f/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e5a0dd7c6e906ba736c9cf26d5db55cf9787c61f", "patch": "@@ -43,7 +43,8 @@\n use hir;\n use hir::map::Definitions;\n use hir::map::definitions::DefPathData;\n-use hir::def_id::DefIndex;\n+use hir::def_id::{DefIndex, DefId};\n+use hir::def::{Def, DefMap, PathResolution};\n \n use std::collections::BTreeMap;\n use std::iter;\n@@ -63,19 +64,25 @@ pub struct LoweringContext<'a> {\n     crate_root: Option<&'static str>,\n     // Use to assign ids to hir nodes that do not directly correspond to an ast node\n     id_assigner: &'a NodeIdAssigner,\n-    // We must keep the set of definitions up to date as we add nodes that\n-    // weren't in the AST.\n-    definitions: Option<&'a RefCell<Definitions>>,\n     // As we walk the AST we must keep track of the current 'parent' def id (in\n     // the form of a DefIndex) so that if we create a new node which introduces\n     // a definition, then we can properly create the def id.\n     parent_def: Cell<Option<DefIndex>>,\n+    resolver: Option<RefCell<&'a mut Resolver>>,\n+}\n+\n+pub trait Resolver {\n+    fn resolve_generated_global_path(&mut self, path: &hir::Path, is_value: bool) -> Def;\n+\n+    fn def_map(&mut self) -> &mut DefMap;\n+    // We must keep the set of definitions up to date as we add nodes that weren't in the AST.\n+    fn definitions(&mut self) -> &mut Definitions;\n }\n \n impl<'a, 'hir> LoweringContext<'a> {\n     pub fn new(id_assigner: &'a NodeIdAssigner,\n                c: Option<&Crate>,\n-               defs: &'a RefCell<Definitions>)\n+               resolver: &'a mut Resolver)\n                -> LoweringContext<'a> {\n         let crate_root = c.and_then(|c| {\n             if std_inject::no_core(c) {\n@@ -90,8 +97,8 @@ impl<'a, 'hir> LoweringContext<'a> {\n         LoweringContext {\n             crate_root: crate_root,\n             id_assigner: id_assigner,\n-            definitions: Some(defs),\n             parent_def: Cell::new(None),\n+            resolver: Some(RefCell::new(resolver)),\n         }\n     }\n \n@@ -101,8 +108,8 @@ impl<'a, 'hir> LoweringContext<'a> {\n         LoweringContext {\n             crate_root: None,\n             id_assigner: id_assigner,\n-            definitions: None,\n             parent_def: Cell::new(None),\n+            resolver: None,\n         }\n     }\n \n@@ -120,7 +127,7 @@ impl<'a, 'hir> LoweringContext<'a> {\n     }\n \n     fn with_parent_def<T, F: FnOnce() -> T>(&self, parent_id: NodeId, f: F) -> T {\n-        if self.definitions.is_none() {\n+        if self.resolver.is_none() {\n             // This should only be used for testing.\n             return f();\n         }\n@@ -134,8 +141,22 @@ impl<'a, 'hir> LoweringContext<'a> {\n     }\n \n     fn get_def(&self, id: NodeId) -> DefIndex {\n-        let defs = self.definitions.unwrap().borrow();\n-        defs.opt_def_index(id).unwrap()\n+        let mut resolver = self.resolver.as_ref().unwrap().borrow_mut();\n+        resolver.definitions().opt_def_index(id).unwrap()\n+    }\n+\n+    fn record_def(&self, id: NodeId, def: Def) {\n+        if let Some(ref resolver) = self.resolver {\n+            resolver.borrow_mut().def_map().insert(id, PathResolution { base_def: def, depth: 0 });\n+        }\n+    }\n+\n+    fn resolve_generated_global_path(&self, path: &hir::Path, is_value: bool) -> Def {\n+        if let Some(ref resolver) = self.resolver {\n+            resolver.borrow_mut().resolve_generated_global_path(path, is_value)\n+        } else {\n+            Def::Err\n+        }\n     }\n }\n \n@@ -999,7 +1020,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 };\n \n                 // let placer = <placer_expr> ;\n-                let s1 = {\n+                let (s1, placer_binding) = {\n                     let placer_expr = signal_block_expr(lctx,\n                                                         hir_vec![],\n                                                         placer_expr,\n@@ -1010,15 +1031,15 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 };\n \n                 // let mut place = Placer::make_place(placer);\n-                let s2 = {\n-                    let placer = expr_ident(lctx, e.span, placer_ident, None);\n+                let (s2, place_binding) = {\n+                    let placer = expr_ident(lctx, e.span, placer_ident, None, placer_binding);\n                     let call = make_call(lctx, &make_place, hir_vec![placer]);\n                     mk_stmt_let_mut(lctx, place_ident, call)\n                 };\n \n                 // let p_ptr = Place::pointer(&mut place);\n-                let s3 = {\n-                    let agent = expr_ident(lctx, e.span, place_ident, None);\n+                let (s3, p_ptr_binding) = {\n+                    let agent = expr_ident(lctx, e.span, place_ident, None, place_binding);\n                     let args = hir_vec![expr_mut_addr_of(lctx, e.span, agent, None)];\n                     let call = make_call(lctx, &place_pointer, args);\n                     mk_stmt_let(lctx, p_ptr_ident, call)\n@@ -1044,14 +1065,14 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 //     InPlace::finalize(place)\n                 // })\n                 let expr = {\n-                    let ptr = expr_ident(lctx, e.span, p_ptr_ident, None);\n+                    let ptr = expr_ident(lctx, e.span, p_ptr_ident, None, p_ptr_binding);\n                     let call_move_val_init =\n                         hir::StmtSemi(\n                             make_call(lctx, &move_val_init, hir_vec![ptr, pop_unsafe_expr]),\n                             lctx.next_id());\n                     let call_move_val_init = respan(e.span, call_move_val_init);\n \n-                    let place = expr_ident(lctx, e.span, place_ident, None);\n+                    let place = expr_ident(lctx, e.span, place_ident, None, place_binding);\n                     let call = make_call(lctx, &inplace_finalize, hir_vec![place]);\n                     signal_block_expr(lctx,\n                                       hir_vec![call_move_val_init],\n@@ -1489,14 +1510,18 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     arm(hir_vec![pat_none(lctx, e.span)], break_expr)\n                 };\n \n+                // `mut iter`\n+                let iter_pat =\n+                    pat_ident_binding_mode(lctx, e.span, iter, hir::BindByValue(hir::MutMutable));\n+\n                 // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n                 let match_expr = {\n                     let next_path = {\n                         let strs = std_path(lctx, &[\"iter\", \"Iterator\", \"next\"]);\n \n                         path_global(e.span, strs)\n                     };\n-                    let iter = expr_ident(lctx, e.span, iter, None);\n+                    let iter = expr_ident(lctx, e.span, iter, None, iter_pat.id);\n                     let ref_mut_iter = expr_mut_addr_of(lctx, e.span, iter, None);\n                     let next_path = expr_path(lctx, next_path, None);\n                     let next_expr = expr_call(lctx,\n@@ -1520,13 +1545,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     P(hir::Expr { id: e.id, node: loop_expr, span: e.span, attrs: None });\n \n                 // `mut iter => { ... }`\n-                let iter_arm = {\n-                    let iter_pat = pat_ident_binding_mode(lctx,\n-                                                          e.span,\n-                                                          iter,\n-                                                          hir::BindByValue(hir::MutMutable));\n-                    arm(hir_vec![iter_pat], loop_expr)\n-                };\n+                let iter_arm = arm(hir_vec![iter_pat], loop_expr);\n \n                 // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n                 let into_iter_expr = {\n@@ -1550,13 +1569,10 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 // `{ let _result = ...; _result }`\n                 // underscore prevents an unused_variables lint if the head diverges\n                 let result_ident = lctx.str_to_ident(\"_result\");\n-                let let_stmt = stmt_let(lctx,\n-                                        e.span,\n-                                        false,\n-                                        result_ident,\n-                                        match_expr,\n-                                        None);\n-                let result = expr_ident(lctx, e.span, result_ident, None);\n+                let (let_stmt, let_stmt_binding) =\n+                    stmt_let(lctx, e.span, false, result_ident, match_expr, None);\n+\n+                let result = expr_ident(lctx, e.span, result_ident, None, let_stmt_binding);\n                 let block = block_all(lctx, e.span, hir_vec![let_stmt], Some(result));\n                 // add the attributes to the outer returned expr node\n                 return expr_block(lctx, block, e.attrs.clone());\n@@ -1583,7 +1599,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 let ok_arm = {\n                     let val_ident = lctx.str_to_ident(\"val\");\n                     let val_pat = pat_ident(lctx, e.span, val_ident);\n-                    let val_expr = expr_ident(lctx, e.span, val_ident, None);\n+                    let val_expr = expr_ident(lctx, e.span, val_ident, None, val_pat.id);\n                     let ok_pat = pat_ok(lctx, e.span, val_pat);\n \n                     arm(hir_vec![ok_pat], val_expr)\n@@ -1592,11 +1608,12 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 // Err(err) => return Err(From::from(err))\n                 let err_arm = {\n                     let err_ident = lctx.str_to_ident(\"err\");\n+                    let err_local = pat_ident(lctx, e.span, err_ident);\n                     let from_expr = {\n                         let path = std_path(lctx, &[\"convert\", \"From\", \"from\"]);\n                         let path = path_global(e.span, path);\n                         let from = expr_path(lctx, path, None);\n-                        let err_expr = expr_ident(lctx, e.span, err_ident, None);\n+                        let err_expr = expr_ident(lctx, e.span, err_ident, None, err_local.id);\n \n                         expr_call(lctx, e.span, from, hir_vec![err_expr], None)\n                     };\n@@ -1606,8 +1623,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                         let err_ctor = expr_path(lctx, path, None);\n                         expr_call(lctx, e.span, err_ctor, hir_vec![from_expr], None)\n                     };\n-                    let err_pat = pat_err(lctx, e.span,\n-                                          pat_ident(lctx, e.span, err_ident));\n+                    let err_pat = pat_err(lctx, e.span, err_local);\n                     let ret_expr = expr(lctx, e.span,\n                                         hir::Expr_::ExprRet(Some(err_expr)), None);\n \n@@ -1747,8 +1763,13 @@ fn expr_call(lctx: &LoweringContext,\n }\n \n fn expr_ident(lctx: &LoweringContext, span: Span, id: hir::Ident,\n-              attrs: ThinAttributes) -> P<hir::Expr> {\n-    expr_path(lctx, path_ident(span, id), attrs)\n+              attrs: ThinAttributes, binding: NodeId) -> P<hir::Expr> {\n+    let expr = expr(lctx, span, hir::ExprPath(None, path_ident(span, id)), attrs);\n+    if let Some(ref resolver) = lctx.resolver {\n+        let def_id = resolver.borrow_mut().definitions().local_def_id(binding);\n+        lctx.record_def(expr.id, Def::Local(def_id, binding));\n+    }\n+    expr\n }\n \n fn expr_mut_addr_of(lctx: &LoweringContext, span: Span, e: P<hir::Expr>,\n@@ -1758,7 +1779,10 @@ fn expr_mut_addr_of(lctx: &LoweringContext, span: Span, e: P<hir::Expr>,\n \n fn expr_path(lctx: &LoweringContext, path: hir::Path,\n              attrs: ThinAttributes) -> P<hir::Expr> {\n-    expr(lctx, path.span, hir::ExprPath(None, path), attrs)\n+    let def = lctx.resolve_generated_global_path(&path, true);\n+    let expr = expr(lctx, path.span, hir::ExprPath(None, path), attrs);\n+    lctx.record_def(expr.id, def);\n+    expr\n }\n \n fn expr_match(lctx: &LoweringContext,\n@@ -1787,7 +1811,11 @@ fn expr_struct(lctx: &LoweringContext,\n                fields: hir::HirVec<hir::Field>,\n                e: Option<P<hir::Expr>>,\n                attrs: ThinAttributes) -> P<hir::Expr> {\n-    expr(lctx, sp, hir::ExprStruct(path, fields, e), attrs)\n+    let def = lctx.resolve_generated_global_path(&path, false);\n+    let expr = expr(lctx, sp, hir::ExprStruct(path, fields, e), attrs);\n+    lctx.record_def(expr.id, def);\n+    expr\n+\n }\n \n fn expr(lctx: &LoweringContext, span: Span, node: hir::Expr_,\n@@ -1806,12 +1834,13 @@ fn stmt_let(lctx: &LoweringContext,\n             ident: hir::Ident,\n             ex: P<hir::Expr>,\n             attrs: ThinAttributes)\n-            -> hir::Stmt {\n+            -> (hir::Stmt, NodeId) {\n     let pat = if mutbl {\n         pat_ident_binding_mode(lctx, sp, ident, hir::BindByValue(hir::MutMutable))\n     } else {\n         pat_ident(lctx, sp, ident)\n     };\n+    let pat_id = pat.id;\n     let local = P(hir::Local {\n         pat: pat,\n         ty: None,\n@@ -1821,7 +1850,7 @@ fn stmt_let(lctx: &LoweringContext,\n         attrs: attrs,\n     });\n     let decl = respan(sp, hir::DeclLocal(local));\n-    respan(sp, hir::StmtDecl(P(decl), lctx.next_id()))\n+    (respan(sp, hir::StmtDecl(P(decl), lctx.next_id())), pat_id)\n }\n \n fn block_expr(lctx: &LoweringContext, expr: P<hir::Expr>) -> P<hir::Block> {\n@@ -1871,12 +1900,15 @@ fn pat_enum(lctx: &LoweringContext,\n             path: hir::Path,\n             subpats: hir::HirVec<P<hir::Pat>>)\n             -> P<hir::Pat> {\n+    let def = lctx.resolve_generated_global_path(&path, true);\n     let pt = if subpats.is_empty() {\n         hir::PatKind::Path(path)\n     } else {\n         hir::PatKind::TupleStruct(path, Some(subpats))\n     };\n-    pat(lctx, span, pt)\n+    let pat = pat(lctx, span, pt);\n+    lctx.record_def(pat.id, def);\n+    pat\n }\n \n fn pat_ident(lctx: &LoweringContext, span: Span, ident: hir::Ident) -> P<hir::Pat> {\n@@ -1897,11 +1929,13 @@ fn pat_ident_binding_mode(lctx: &LoweringContext,\n \n     let pat = pat(lctx, span, pat_ident);\n \n-    if let Some(defs) = lctx.definitions {\n-        let mut defs = defs.borrow_mut();\n-        defs.create_def_with_parent(lctx.parent_def.get(),\n-                                    pat.id,\n-                                    DefPathData::Binding(ident.name));\n+    if let Some(ref resolver) = lctx.resolver {\n+        let def_index =\n+            resolver.borrow_mut().definitions()\n+                                 .create_def_with_parent(lctx.parent_def.get(),\n+                                                         pat.id,\n+                                                         DefPathData::Binding(ident.name));\n+        lctx.record_def(pat.id, Def::Local(DefId::local(def_index), pat.id));\n     }\n \n     pat"}, {"sha": "ebb6cf709ce7585b922fb30a8a68639e236275c3", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e5a0dd7c6e906ba736c9cf26d5db55cf9787c61f/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a0dd7c6e906ba736c9cf26d5db55cf9787c61f/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=e5a0dd7c6e906ba736c9cf26d5db55cf9787c61f", "patch": "@@ -154,12 +154,19 @@ pub fn compile_input(sess: &Session,\n              \"early lint checks\",\n              || lint::check_ast_crate(sess, &expanded_crate));\n \n-        let (analysis, resolutions) = {\n-            resolve::with_resolver(sess, &defs.borrow(), control.make_glob_map, |mut resolver| {\n+        let (analysis, resolutions, mut hir_forest) = {\n+            let defs = &mut *defs.borrow_mut();\n+            resolve::with_resolver(sess, defs, control.make_glob_map, |mut resolver| {\n                 time(sess.time_passes(), \"name resolution\", || {\n                     resolve::resolve_crate(&mut resolver, &expanded_crate);\n                 });\n \n+                // Lower ast -> hir.\n+                let hir_forest = time(sess.time_passes(), \"lowering ast -> hir\", || {\n+                    let lcx = LoweringContext::new(sess, Some(&expanded_crate), &mut resolver);\n+                    hir_map::Forest::new(lower_crate(&lcx, &expanded_crate), dep_graph)\n+                });\n+\n                 (ty::CrateAnalysis {\n                     export_map: resolver.export_map,\n                     access_levels: AccessLevels::default(),\n@@ -171,17 +178,10 @@ pub fn compile_input(sess: &Session,\n                     freevars: resolver.freevars,\n                     trait_map: resolver.trait_map,\n                     maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,\n-                })\n+                }, hir_forest)\n             })\n         };\n \n-        // Lower ast -> hir.\n-        let lcx = LoweringContext::new(sess, Some(&expanded_crate), defs);\n-        let hir_forest = &mut time(sess.time_passes(),\n-                                   \"lowering ast -> hir\",\n-                                   || hir_map::Forest::new(lower_crate(&lcx, &expanded_crate),\n-                                                           dep_graph));\n-\n         // Discard MTWT tables that aren't required past lowering to HIR.\n         if !keep_mtwt_tables(sess) {\n             syntax::ext::mtwt::clear_tables();\n@@ -190,6 +190,7 @@ pub fn compile_input(sess: &Session,\n         let arenas = ty::CtxtArenas::new();\n \n         // Construct the HIR map\n+        let hir_forest = &mut hir_forest;\n         let hir_map = time(sess.time_passes(),\n                            \"indexing hir\",\n                            move || hir_map::map_crate(hir_forest, defs));"}, {"sha": "8f1fa2f7aa8a425d43149b6e353ee0934a4d19e2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 51, "deletions": 18, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e5a0dd7c6e906ba736c9cf26d5db55cf9787c61f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a0dd7c6e906ba736c9cf26d5db55cf9787c61f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e5a0dd7c6e906ba736c9cf26d5db55cf9787c61f", "patch": "@@ -44,7 +44,7 @@ use self::BareIdentifierPatternResolution::*;\n use self::ParentLink::*;\n \n use rustc::hir::map::Definitions;\n-use rustc::hir::{PrimTy, TyBool, TyChar, TyFloat, TyInt, TyUint, TyStr};\n+use rustc::hir::{self, PrimTy, TyBool, TyChar, TyFloat, TyInt, TyUint, TyStr};\n use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::*;\n@@ -962,7 +962,7 @@ impl PrimitiveTypeTable {\n pub struct Resolver<'a> {\n     session: &'a Session,\n \n-    definitions: &'a Definitions,\n+    definitions: &'a mut Definitions,\n \n     graph_root: Module<'a>,\n \n@@ -1082,9 +1082,49 @@ impl<'a> ty::NodeIdTree for Resolver<'a> {\n     }\n }\n \n+impl<'a> hir::lowering::Resolver for Resolver<'a> {\n+    fn resolve_generated_global_path(&mut self, path: &hir::Path, is_value: bool) -> Def {\n+        let namespace = if is_value { ValueNS } else { TypeNS };\n+        match self.resolve_crate_relative_path(path.span, &path.segments, namespace) {\n+            Ok(binding) => binding.def().unwrap(),\n+            Err(true) => Def::Err,\n+            Err(false) => {\n+                let path_name = &format!(\"{}\", path);\n+                let error =\n+                    ResolutionError::UnresolvedName(path_name, \"\", UnresolvedNameContext::Other);\n+                resolve_error(self, path.span, error);\n+                Def::Err\n+            }\n+        }\n+    }\n+\n+    fn def_map(&mut self) -> &mut DefMap {\n+        &mut self.def_map\n+    }\n+    fn definitions(&mut self) -> &mut Definitions {\n+        self.definitions\n+    }\n+}\n+\n+trait Named {\n+    fn name(&self) -> Name;\n+}\n+\n+impl Named for ast::PathSegment {\n+    fn name(&self) -> Name {\n+        self.identifier.name\n+    }\n+}\n+\n+impl Named for hir::PathSegment {\n+    fn name(&self) -> Name {\n+        self.identifier.name\n+    }\n+}\n+\n impl<'a> Resolver<'a> {\n     fn new(session: &'a Session,\n-           definitions: &'a Definitions,\n+           definitions: &'a mut Definitions,\n            make_glob_map: MakeGlobMap,\n            arenas: &'a ResolverArenas<'a>)\n            -> Resolver<'a> {\n@@ -2721,19 +2761,12 @@ impl<'a> Resolver<'a> {\n \n     /// Invariant: This must be called only during main resolution, not during\n     /// import resolution.\n-    fn resolve_crate_relative_path(&mut self,\n-                                   span: Span,\n-                                   segments: &[ast::PathSegment],\n-                                   namespace: Namespace)\n-                                   -> Result<&'a NameBinding<'a>,\n-                                             bool /* true if an error was reported */> {\n-        let module_path = segments.split_last()\n-                                  .unwrap()\n-                                  .1\n-                                  .iter()\n-                                  .map(|ps| ps.identifier.name)\n-                                  .collect::<Vec<_>>();\n-\n+    fn resolve_crate_relative_path<T>(&mut self, span: Span, segments: &[T], namespace: Namespace)\n+                                      -> Result<&'a NameBinding<'a>,\n+                                                bool /* true if an error was reported */>\n+        where T: Named,\n+    {\n+        let module_path = segments.split_last().unwrap().1.iter().map(T::name).collect::<Vec<_>>();\n         let root_module = self.graph_root;\n \n         let containing_module;\n@@ -2762,7 +2795,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let name = segments.last().unwrap().identifier.name;\n+        let name = segments.last().unwrap().name();\n         let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n         result.success().map(|binding| {\n             self.check_privacy(name, binding, span);\n@@ -3588,7 +3621,7 @@ pub fn resolve_crate<'a, 'b>(resolver: &'b mut Resolver<'a>, krate: &'b Crate) {\n }\n \n pub fn with_resolver<'a, T, F>(session: &'a Session,\n-                               definitions: &'a Definitions,\n+                               definitions: &'a mut Definitions,\n                                make_glob_map: MakeGlobMap,\n                                f: F) -> T\n     where F: for<'b> FnOnce(Resolver<'b>) -> T,"}]}