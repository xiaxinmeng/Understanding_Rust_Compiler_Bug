{"sha": "f453d1127d9095cf3c3356655d9e8502ceeb8373", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0NTNkMTEyN2Q5MDk1Y2YzYzMzNTY2NTVkOWU4NTAyY2VlYjgzNzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-28T14:22:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-28T14:22:47Z"}, "message": "Auto merge of #66603 - Nadrieril:fix-65413, r=varkor\n\nFix #65413\n\n#65413 was due to an oversight in `pat_constructor` that didn't check if a particular const value was maybe a slice/array const.", "tree": {"sha": "939f5268cd2439debbdb10ac71d51f0d51435641", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/939f5268cd2439debbdb10ac71d51f0d51435641"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f453d1127d9095cf3c3356655d9e8502ceeb8373", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f453d1127d9095cf3c3356655d9e8502ceeb8373", "html_url": "https://github.com/rust-lang/rust/commit/f453d1127d9095cf3c3356655d9e8502ceeb8373", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f453d1127d9095cf3c3356655d9e8502ceeb8373/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4752c05af4a5f392de026f9ae1877eae030be359", "url": "https://api.github.com/repos/rust-lang/rust/commits/4752c05af4a5f392de026f9ae1877eae030be359", "html_url": "https://github.com/rust-lang/rust/commit/4752c05af4a5f392de026f9ae1877eae030be359"}, {"sha": "3f917120a09459c649cccf903752b2addb1c9a01", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f917120a09459c649cccf903752b2addb1c9a01", "html_url": "https://github.com/rust-lang/rust/commit/3f917120a09459c649cccf903752b2addb1c9a01"}], "stats": {"total": 154, "additions": 111, "deletions": 43}, "files": [{"sha": "5db567dae29c11638413f481758467406764c060", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 30, "deletions": 36, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f453d1127d9095cf3c3356655d9e8502ceeb8373/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f453d1127d9095cf3c3356655d9e8502ceeb8373/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=f453d1127d9095cf3c3356655d9e8502ceeb8373", "patch": "@@ -347,6 +347,7 @@ impl PatternFolder<'tcx> for LiteralExpander<'tcx> {\n             ) => bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty),\n \n             (_, &PatKind::Binding { subpattern: Some(ref s), .. }) => s.fold_with(self),\n+            (_, &PatKind::AscribeUserType { subpattern: ref s, .. }) => s.fold_with(self),\n             _ => pat.super_fold_with(self),\n         }\n     }\n@@ -747,7 +748,7 @@ impl<'tcx> Constructor<'tcx> {\n                     .iter()\n                     .filter_map(|c: &Constructor<'_>| match c {\n                         Slice(slice) => Some(*slice),\n-                        // FIXME(#65413): We ignore `ConstantValue`s here.\n+                        // FIXME(oli-obk): implement `deref` for `ConstValue`\n                         ConstantValue(..) => None,\n                         _ => bug!(\"bad slice pattern constructor {:?}\", c),\n                     })\n@@ -1759,9 +1760,7 @@ fn pat_constructor<'tcx>(\n     pat: &Pat<'tcx>,\n ) -> Option<Constructor<'tcx>> {\n     match *pat.kind {\n-        PatKind::AscribeUserType { ref subpattern, .. } => {\n-            pat_constructor(tcx, param_env, subpattern)\n-        }\n+        PatKind::AscribeUserType { .. } => bug!(), // Handled by `expand_pattern`\n         PatKind::Binding { .. } | PatKind::Wild => None,\n         PatKind::Leaf { .. } | PatKind::Deref { .. } => Some(Single),\n         PatKind::Variant { adt_def, variant_index, .. } => {\n@@ -1771,7 +1770,19 @@ fn pat_constructor<'tcx>(\n             if let Some(int_range) = IntRange::from_const(tcx, param_env, value, pat.span) {\n                 Some(IntRange(int_range))\n             } else {\n-                Some(ConstantValue(value))\n+                match (value.val, &value.ty.kind) {\n+                    (_, ty::Array(_, n)) => {\n+                        let len = n.eval_usize(tcx, param_env);\n+                        Some(Slice(Slice { array_len: Some(len), kind: FixedLen(len) }))\n+                    }\n+                    (ty::ConstKind::Value(ConstValue::Slice { start, end, .. }), ty::Slice(_)) => {\n+                        let len = (end - start) as u64;\n+                        Some(Slice(Slice { array_len: None, kind: FixedLen(len) }))\n+                    }\n+                    // FIXME(oli-obk): implement `deref` for `ConstValue`\n+                    // (ty::ConstKind::Value(ConstValue::ByRef { .. }), ty::Slice(_)) => { ... }\n+                    _ => Some(ConstantValue(value)),\n+                }\n             }\n         }\n         PatKind::Range(PatRange { lo, hi, end }) => {\n@@ -2085,32 +2096,19 @@ fn split_grouped_constructors<'p, 'tcx>(\n                 let mut max_suffix_len = self_suffix;\n                 let mut max_fixed_len = 0;\n \n-                for row in matrix.heads() {\n-                    match *row.kind {\n-                        PatKind::Constant { value } => {\n-                            // extract the length of an array/slice from a constant\n-                            match (value.val, &value.ty.kind) {\n-                                (_, ty::Array(_, n)) => {\n-                                    max_fixed_len =\n-                                        cmp::max(max_fixed_len, n.eval_usize(tcx, param_env))\n-                                }\n-                                (\n-                                    ty::ConstKind::Value(ConstValue::Slice { start, end, .. }),\n-                                    ty::Slice(_),\n-                                ) => max_fixed_len = cmp::max(max_fixed_len, (end - start) as u64),\n-                                _ => {}\n+                let head_ctors =\n+                    matrix.heads().filter_map(|pat| pat_constructor(tcx, param_env, pat));\n+                for ctor in head_ctors {\n+                    match ctor {\n+                        Slice(slice) => match slice.pattern_kind() {\n+                            FixedLen(len) => {\n+                                max_fixed_len = cmp::max(max_fixed_len, len);\n                             }\n-                        }\n-                        PatKind::Slice { ref prefix, slice: None, ref suffix }\n-                        | PatKind::Array { ref prefix, slice: None, ref suffix } => {\n-                            let fixed_len = prefix.len() as u64 + suffix.len() as u64;\n-                            max_fixed_len = cmp::max(max_fixed_len, fixed_len);\n-                        }\n-                        PatKind::Slice { ref prefix, slice: Some(_), ref suffix }\n-                        | PatKind::Array { ref prefix, slice: Some(_), ref suffix } => {\n-                            max_prefix_len = cmp::max(max_prefix_len, prefix.len() as u64);\n-                            max_suffix_len = cmp::max(max_suffix_len, suffix.len() as u64);\n-                        }\n+                            VarLen(prefix, suffix) => {\n+                                max_prefix_len = cmp::max(max_prefix_len, prefix);\n+                                max_suffix_len = cmp::max(max_suffix_len, suffix);\n+                            }\n+                        },\n                         _ => {}\n                     }\n                 }\n@@ -2250,21 +2248,17 @@ fn patterns_for_variant<'p, 'a: 'p, 'tcx>(\n /// fields filled with wild patterns.\n fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    mut pat: &'q Pat<'tcx>,\n+    pat: &'q Pat<'tcx>,\n     constructor: &Constructor<'tcx>,\n     ctor_wild_subpatterns: &[&'p Pat<'tcx>],\n ) -> Option<PatStack<'p, 'tcx>> {\n-    while let PatKind::AscribeUserType { ref subpattern, .. } = *pat.kind {\n-        pat = subpattern;\n-    }\n-\n     if let NonExhaustive = constructor {\n         // Only a wildcard pattern can match the special extra constructor\n         return if pat.is_wildcard() { Some(PatStack::default()) } else { None };\n     }\n \n     let result = match *pat.kind {\n-        PatKind::AscribeUserType { .. } => bug!(), // Handled above\n+        PatKind::AscribeUserType { .. } => bug!(), // Handled by `expand_pattern`\n \n         PatKind::Binding { .. } | PatKind::Wild => {\n             Some(PatStack::from_slice(ctor_wild_subpatterns))"}, {"sha": "6c54c938bf110af6dd5ed07c3a1536f20d627990", "filename": "src/test/ui/pattern/usefulness/65413-constants-and-slices-exhaustiveness.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f453d1127d9095cf3c3356655d9e8502ceeb8373/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2F65413-constants-and-slices-exhaustiveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f453d1127d9095cf3c3356655d9e8502ceeb8373/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2F65413-constants-and-slices-exhaustiveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2F65413-constants-and-slices-exhaustiveness.rs?ref=f453d1127d9095cf3c3356655d9e8502ceeb8373", "patch": "@@ -0,0 +1,15 @@\n+// check-pass\n+#![feature(slice_patterns)]\n+#![deny(unreachable_patterns)]\n+\n+const C0: &'static [u8] = b\"\\x00\";\n+\n+fn main() {\n+    let x: &[u8] = &[0];\n+    match x {\n+        &[] => {}\n+        &[1..=255] => {}\n+        C0 => {}\n+        &[_, _, ..] => {}\n+    }\n+}"}, {"sha": "539aa854f9e6b9ad7ca1b2ebee870f48fb7c4686", "filename": "src/test/ui/pattern/usefulness/match-byte-array-patterns-2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f453d1127d9095cf3c3356655d9e8502ceeb8373/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f453d1127d9095cf3c3356655d9e8502ceeb8373/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr?ref=f453d1127d9095cf3c3356655d9e8502ceeb8373", "patch": "@@ -1,16 +1,16 @@\n-error[E0004]: non-exhaustive patterns: `&[..]` not covered\n+error[E0004]: non-exhaustive patterns: `&[0u8..=64u8, _, _, _]` and `&[66u8..=std::u8::MAX, _, _, _]` not covered\n   --> $DIR/match-byte-array-patterns-2.rs:4:11\n    |\n LL |     match buf {\n-   |           ^^^ pattern `&[..]` not covered\n+   |           ^^^ patterns `&[0u8..=64u8, _, _, _]` and `&[66u8..=std::u8::MAX, _, _, _]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error[E0004]: non-exhaustive patterns: `&[..]` not covered\n+error[E0004]: non-exhaustive patterns: `&[]`, `&[_]`, `&[_, _]` and 2 more not covered\n   --> $DIR/match-byte-array-patterns-2.rs:10:11\n    |\n LL |     match buf {\n-   |           ^^^ pattern `&[..]` not covered\n+   |           ^^^ patterns `&[]`, `&[_]`, `&[_, _]` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "89195d5b11e52700ea56103ba6e93682be0823af", "filename": "src/test/ui/pattern/usefulness/slice-pattern-const.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f453d1127d9095cf3c3356655d9e8502ceeb8373/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f453d1127d9095cf3c3356655d9e8502ceeb8373/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const.rs?ref=f453d1127d9095cf3c3356655d9e8502ceeb8373", "patch": "@@ -44,4 +44,11 @@ fn main() {\n         b\"\" => (), //~ ERROR unreachable pattern\n         _ => (), //~ ERROR unreachable pattern\n     }\n+\n+    const CONST1: &[bool; 1] = &[true];\n+    match &[false] {\n+        CONST1 => {}\n+        [true] => {} //~ ERROR unreachable pattern\n+        [false] => {}\n+    }\n }"}, {"sha": "d274d6d7c678be70f49f8e6189100e89b1e7b26a", "filename": "src/test/ui/pattern/usefulness/slice-pattern-const.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f453d1127d9095cf3c3356655d9e8502ceeb8373/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f453d1127d9095cf3c3356655d9e8502ceeb8373/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const.stderr?ref=f453d1127d9095cf3c3356655d9e8502ceeb8373", "patch": "@@ -52,5 +52,11 @@ error: unreachable pattern\n LL |         _ => (),\n    |         ^\n \n-error: aborting due to 8 previous errors\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const.rs:51:9\n+   |\n+LL |         [true] => {}\n+   |         ^^^^^^\n+\n+error: aborting due to 9 previous errors\n "}, {"sha": "41ba2cc4501c089a540a7260071cd88e6ed51b6c", "filename": "src/test/ui/pattern/usefulness/slice-patterns-exhaustiveness.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f453d1127d9095cf3c3356655d9e8502ceeb8373/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f453d1127d9095cf3c3356655d9e8502ceeb8373/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.rs?ref=f453d1127d9095cf3c3356655d9e8502ceeb8373", "patch": "@@ -82,4 +82,26 @@ fn main() {\n         [_, _] => {}\n         [false, .., false] => {}\n     }\n+\n+    const CONST: &[bool] = &[true];\n+    match s {\n+    //~^ ERROR `&[..]` not covered\n+        CONST => {}\n+    }\n+    match s {\n+    //~^ ERROR `&[true]` not covered\n+        [] => {},\n+        [false] => {},\n+        CONST => {},\n+        [_, _, ..] => {}\n+    }\n+    const CONST1: &[bool; 1] = &[true];\n+    match s1 {\n+    //~^ ERROR `&[false]` not covered\n+        CONST1 => {}\n+    }\n+    match s1 {\n+        CONST1 => {}\n+        [false] => {}\n+    }\n }"}, {"sha": "8cb342f33dfa0d917f94f585aedfec03b2db38e4", "filename": "src/test/ui/pattern/usefulness/slice-patterns-exhaustiveness.stderr", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f453d1127d9095cf3c3356655d9e8502ceeb8373/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f453d1127d9095cf3c3356655d9e8502ceeb8373/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr?ref=f453d1127d9095cf3c3356655d9e8502ceeb8373", "patch": "@@ -102,6 +102,30 @@ LL |     match s {\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error: aborting due to 13 previous errors\n+error[E0004]: non-exhaustive patterns: `&[..]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:87:11\n+   |\n+LL |     match s {\n+   |           ^ pattern `&[..]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `&[true]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:91:11\n+   |\n+LL |     match s {\n+   |           ^ pattern `&[true]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: `&[false]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:99:11\n+   |\n+LL |     match s1 {\n+   |           ^^ pattern `&[false]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error: aborting due to 16 previous errors\n \n For more information about this error, try `rustc --explain E0004`."}, {"sha": "cd229a0fcbee4fef806df994a720a1de1f1b87e0", "filename": "src/test/ui/pattern/usefulness/slice-patterns-reachability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f453d1127d9095cf3c3356655d9e8502ceeb8373/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-reachability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f453d1127d9095cf3c3356655d9e8502ceeb8373/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-reachability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-reachability.rs?ref=f453d1127d9095cf3c3356655d9e8502ceeb8373", "patch": "@@ -2,7 +2,7 @@\n #![deny(unreachable_patterns)]\n \n fn main() {\n-    let s: &[bool] = &[true; 0];\n+    let s: &[bool] = &[];\n \n     match s {\n         [true, ..] => {}"}]}